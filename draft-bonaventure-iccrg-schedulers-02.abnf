next_idx = self.paths.index(self.last_path) + 1
next_idx = 0
sorted_paths = self.paths[next_idx:] + self.paths[:next_idx]
next_idx = (self.last_idx + 1) % len(self.distribution)
sorted_paths = self.distribution[next_idx:]
                     + self.distribution[:next_idx]
         for i, p in enumerate(sorted_paths):
             if not p.blocked(packet_len):
                 self.last_idx =
                    (self.last.idx + i) % len(self.distribution)
                 return p

               Figure 2: A Weighted Round Robin scheduler

key=lambda p: p.priority, reverse=True):
paths = sorted(self.paths, key=lambda path: path.srtt)
paths = sorted(paths, key=lambda path: path.priority, reverse=True)
