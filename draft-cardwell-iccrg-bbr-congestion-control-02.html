<!DOCTYPE html>
<html lang="en" class="Internet-Draft">
<head>
<meta charset="utf-8">
<meta content="Common,Latin" name="scripts">
<meta content="initial-scale=1.0" name="viewport">
<title>BBR Congestion Control</title>
<meta content="Neal Cardwell" name="author">
<meta content="Yuchung Cheng" name="author">
<meta content="Soheil Hassas Yeganeh" name="author">
<meta content="Ian Swett" name="author">
<meta content="Van Jacobson" name="author">
<meta content="
       
This document specifies the BBR congestion control algorithm. BBR (&quot;Bottleneck Bandwidth and Round-trip propagation time&quot;) uses recent measurements of a transport connection's delivery rate,  round-trip time, and packet loss rate to build an explicit model of the network path. BBR then uses this model to control both how fast it sends data and the maximum volume of data it allows in flight in the network at any time. Relative to loss-based congestion control algorithms such as Reno [RFC5681] or CUBIC [RFC8312], BBR offers substantially higher throughput for bottlenecks with shallow buffers or random losses, and substantially lower queueing delays for bottlenecks with deep buffers (avoiding &quot;bufferbloat&quot;). BBR can be implemented in any transport protocol that supports packet-delivery acknowledgment. Thus far, open source implementations are available for TCP [RFC793] and QUIC [RFC9000]. This document specifies version 2 of the BBR algorithm, also sometimes referred to as BBRv2 or bbr2.
 
    " name="description">
<meta content="xml2rfc 3.12.3" name="generator">
<meta content="Congestion Control" name="keyword">
<meta content="TCP" name="keyword">
<meta content="QUIC" name="keyword">
<meta content="draft-cardwell-iccrg-bbr-congestion-control-02" name="ietf.draft">
<!-- Generator version information:
  xml2rfc 3.12.3
    Python 3.6.12
    appdirs 1.4.4
    ConfigArgParse 1.5.3
    google-i18n-address 2.5.0
    html5lib 1.1
    intervaltree 3.1.0
    Jinja2 2.11.3
    kitchen 1.2.6
    lxml 4.8.0
    MarkupSafe 2.0.1
    pycountry 22.1.10
    pyflakes 2.4.0
    PyYAML 6.0
    requests 2.27.1
    setuptools 59.6.0
    six 1.16.0
    WeasyPrint 52.5
-->
<link href="/tmp/draft-cardwell-iccrg-bbr-congestion-control-02-qdyczjx8.xml" rel="alternate" type="application/rfc+xml">
<link href="#copyright" rel="license">
<style type="text/css">/*

  NOTE: Changes at the bottom of this file overrides some earlier settings.

  Once the style has stabilized and has been adopted as an official RFC style,
  this can be consolidated so that style settings occur only in one place, but
  for now the contents of this file consists first of the initial CSS work as
  provided to the RFC Formatter (xml2rfc) work, followed by itemized and
  commented changes found necssary during the development of the v3
  formatters.

*/

/* fonts */
@import url('https://fonts.googleapis.com/css?family=Noto+Sans'); /* Sans-serif */
@import url('https://fonts.googleapis.com/css?family=Noto+Serif'); /* Serif (print) */
@import url('https://fonts.googleapis.com/css?family=Roboto+Mono'); /* Monospace */

@viewport {
  zoom: 1.0;
  width: extend-to-zoom;
}
@-ms-viewport {
  width: extend-to-zoom;
  zoom: 1.0;
}
/* general and mobile first */
html {
}
body {
  max-width: 90%;
  margin: 1.5em auto;
  color: #222;
  background-color: #fff;
  font-size: 14px;
  font-family: 'Noto Sans', Arial, Helvetica, sans-serif;
  line-height: 1.6;
  scroll-behavior: smooth;
}
.ears {
  display: none;
}

/* headings */
#title, h1, h2, h3, h4, h5, h6 {
  margin: 1em 0 0.5em;
  font-weight: bold;
  line-height: 1.3;
}
#title {
  clear: both;
  border-bottom: 1px solid #ddd;
  margin: 0 0 0.5em 0;
  padding: 1em 0 0.5em;
}
.author {
  padding-bottom: 4px;
}
h1 {
  font-size: 26px;
  margin: 1em 0;
}
h2 {
  font-size: 22px;
  margin-top: -20px;  /* provide offset for in-page anchors */
  padding-top: 33px;
}
h3 {
  font-size: 18px;
  margin-top: -36px;  /* provide offset for in-page anchors */
  padding-top: 42px;
}
h4 {
  font-size: 16px;
  margin-top: -36px;  /* provide offset for in-page anchors */
  padding-top: 42px;
}
h5, h6 {
  font-size: 14px;
}
#n-copyright-notice {
  border-bottom: 1px solid #ddd;
  padding-bottom: 1em;
  margin-bottom: 1em;
}
/* general structure */
p {
  padding: 0;
  margin: 0 0 1em 0;
  text-align: left;
}
div, span {
  position: relative;
}
div {
  margin: 0;
}
.alignRight.art-text {
  background-color: #f9f9f9;
  border: 1px solid #eee;
  border-radius: 3px;
  padding: 1em 1em 0;
  margin-bottom: 1.5em;
}
.alignRight.art-text pre {
  padding: 0;
}
.alignRight {
  margin: 1em 0;
}
.alignRight > *:first-child {
  border: none;
  margin: 0;
  float: right;
  clear: both;
}
.alignRight > *:nth-child(2) {
  clear: both;
  display: block;
  border: none;
}
svg {
  display: block;
}
.alignCenter.art-text {
  background-color: #f9f9f9;
  border: 1px solid #eee;
  border-radius: 3px;
  padding: 1em 1em 0;
  margin-bottom: 1.5em;
}
.alignCenter.art-text pre {
  padding: 0;
}
.alignCenter {
  margin: 1em 0;
}
.alignCenter > *:first-child {
  border: none;
  /* this isn't optimal, but it's an existence proof.  PrinceXML doesn't
     support flexbox yet.
  */
  display: table;
  margin: 0 auto;
}

/* lists */
ol, ul {
  padding: 0;
  margin: 0 0 1em 2em;
}
ol ol, ul ul, ol ul, ul ol {
  margin-left: 1em;
}
li {
  margin: 0 0 0.25em 0;
}
.ulCompact li {
  margin: 0;
}
ul.empty, .ulEmpty {
  list-style-type: none;
}
ul.empty li, .ulEmpty li {
  margin-top: 0.5em;
}
ul.ulBare, li.ulBare {
  margin-left: 0em !important;
}
ul.compact, .ulCompact,
ol.compact, .olCompact {
  line-height: 100%;
  margin: 0 0 0 2em;
}

/* definition lists */
dl {
}
dl > dt {
  float: left;
  margin-right: 1em;
}
/* 
dl.nohang > dt {
  float: none;
}
*/
dl > dd {
  margin-bottom: .8em;
  min-height: 1.3em;
}
dl.compact > dd, .dlCompact > dd {
  margin-bottom: 0em;
}
dl > dd > dl {
  margin-top: 0.5em;
  margin-bottom: 0em;
}

/* links */
a {
  text-decoration: none;
}
a[href] {
  color: #22e; /* Arlen: WCAG 2019 */
}
a[href]:hover {
  background-color: #f2f2f2;
}
figcaption a[href],
a[href].selfRef {
  color: #222;
}
/* XXX probably not this:
a.selfRef:hover {
  background-color: transparent;
  cursor: default;
} */

/* Figures */
tt, code, pre, code {
  background-color: #f9f9f9;
  font-family: 'Roboto Mono', monospace;
}
pre {
  border: 1px solid #eee;
  margin: 0;
  padding: 1em;
}
img {
  max-width: 100%;
}
figure {
  margin: 0;
}
figure blockquote {
  margin: 0.8em 0.4em 0.4em;
}
figcaption {
  font-style: italic;
  margin: 0 0 1em 0;
}
@media screen {
  pre {
    overflow-x: auto;
    max-width: 100%;
    max-width: calc(100% - 22px);
  }
}

/* aside, blockquote */
aside, blockquote {
  margin-left: 0;
  padding: 1.2em 2em;
}
blockquote {
  background-color: #f9f9f9;
  color: #111; /* Arlen: WCAG 2019 */
  border: 1px solid #ddd;
  border-radius: 3px;
  margin: 1em 0;
}
cite {
  display: block;
  text-align: right;
  font-style: italic;
}

/* tables */
table {
  width: 100%;
  margin: 0 0 1em;
  border-collapse: collapse;
  border: 1px solid #eee;
}
th, td {
  text-align: left;
  vertical-align: top;
  padding: 0.5em 0.75em;
}
th {
  text-align: left;
  background-color: #e9e9e9;
}
tr:nth-child(2n+1) > td {
  background-color: #f5f5f5;
}
table caption {
  font-style: italic;
  margin: 0;
  padding: 0;
  text-align: left;
}
table p {
  /* XXX to avoid bottom margin on table row signifiers. If paragraphs should
     be allowed within tables more generally, it would be far better to select on a class. */
  margin: 0;
}

/* pilcrow */
a.pilcrow {
  color: #666; /* Arlen: AHDJ 2019 */
  text-decoration: none;
  visibility: hidden;
  user-select: none;
  -ms-user-select: none;
  -o-user-select:none;
  -moz-user-select: none;
  -khtml-user-select: none;
  -webkit-user-select: none;
  -webkit-touch-callout: none;
}
@media screen {
  aside:hover > a.pilcrow,
  p:hover > a.pilcrow,
  blockquote:hover > a.pilcrow,
  div:hover > a.pilcrow,
  li:hover > a.pilcrow,
  pre:hover > a.pilcrow {
    visibility: visible;
  }
  a.pilcrow:hover {
    background-color: transparent;
  }
}

/* misc */
hr {
  border: 0;
  border-top: 1px solid #eee;
}
.bcp14 {
  font-variant: small-caps;
}

.role {
  font-variant: all-small-caps;
}

/* info block */
#identifiers {
  margin: 0;
  font-size: 0.9em;
}
#identifiers dt {
  width: 3em;
  clear: left;
}
#identifiers dd {
  float: left;
  margin-bottom: 0;
}
/* Fix PDF info block run off issue */
@media print {
  #identifiers dd {
    float: none;
  }
}
#identifiers .authors .author {
  display: inline-block;
  margin-right: 1.5em;
}
#identifiers .authors .org {
  font-style: italic;
}

/* The prepared/rendered info at the very bottom of the page */
.docInfo {
  color: #666; /* Arlen: WCAG 2019 */
  font-size: 0.9em;
  font-style: italic;
  margin-top: 2em;
}
.docInfo .prepared {
  float: left;
}
.docInfo .prepared {
  float: right;
}

/* table of contents */
#toc  {
  padding: 0.75em 0 2em 0;
  margin-bottom: 1em;
}
nav.toc ul {
  margin: 0 0.5em 0 0;
  padding: 0;
  list-style: none;
}
nav.toc li {
  line-height: 1.3em;
  margin: 0.75em 0;
  padding-left: 1.2em;
  text-indent: -1.2em;
}
/* references */
.references dt {
  text-align: right;
  font-weight: bold;
  min-width: 7em;
}
.references dd {
  margin-left: 8em;
  overflow: auto;
}

.refInstance {
  margin-bottom: 1.25em;
}

.references .ascii {
  margin-bottom: 0.25em;
}

/* index */
.index ul {
  margin: 0 0 0 1em;
  padding: 0;
  list-style: none;
}
.index ul ul {
  margin: 0;
}
.index li {
  margin: 0;
  text-indent: -2em;
  padding-left: 2em;
  padding-bottom: 5px;
}
.indexIndex {
  margin: 0.5em 0 1em;
}
.index a {
  font-weight: 700;
}
/* make the index two-column on all but the smallest screens */
@media (min-width: 600px) {
  .index ul {
    -moz-column-count: 2;
    -moz-column-gap: 20px;
  }
  .index ul ul {
    -moz-column-count: 1;
    -moz-column-gap: 0;
  }
}

/* authors */
address.vcard {
  font-style: normal;
  margin: 1em 0;
}

address.vcard .nameRole {
  font-weight: 700;
  margin-left: 0;
}
address.vcard .label {
  font-family: "Noto Sans",Arial,Helvetica,sans-serif;
  margin: 0.5em 0;
}
address.vcard .type {
  display: none;
}
.alternative-contact {
  margin: 1.5em 0 1em;
}
hr.addr {
  border-top: 1px dashed;
  margin: 0;
  color: #ddd;
  max-width: calc(100% - 16px);
}

/* temporary notes */
.rfcEditorRemove::before {
  position: absolute;
  top: 0.2em;
  right: 0.2em;
  padding: 0.2em;
  content: "The RFC Editor will remove this note";
  color: #9e2a00; /* Arlen: WCAG 2019 */
  background-color: #ffd; /* Arlen: WCAG 2019 */
}
.rfcEditorRemove {
  position: relative;
  padding-top: 1.8em;
  background-color: #ffd; /* Arlen: WCAG 2019 */
  border-radius: 3px;
}
.cref {
  background-color: #ffd; /* Arlen: WCAG 2019 */
  padding: 2px 4px;
}
.crefSource {
  font-style: italic;
}
/* alternative layout for smaller screens */
@media screen and (max-width: 1023px) {
  body {
    padding-top: 2em;
  }
  #title {
    padding: 1em 0;
  }
  h1 {
    font-size: 24px;
  }
  h2 {
    font-size: 20px;
    margin-top: -18px;  /* provide offset for in-page anchors */
    padding-top: 38px;
  }
  #identifiers dd {
    max-width: 60%;
  }
  #toc {
    position: fixed;
    z-index: 2;
    top: 0;
    right: 0;
    padding: 0;
    margin: 0;
    background-color: inherit;
    border-bottom: 1px solid #ccc;
  }
  #toc h2 {
    margin: -1px 0 0 0;
    padding: 4px 0 4px 6px;
    padding-right: 1em;
    min-width: 190px;
    font-size: 1.1em;
    text-align: right;
    background-color: #444;
    color: white;
    cursor: pointer;
  }
  #toc h2::before { /* css hamburger */
    float: right;
    position: relative;
    width: 1em;
    height: 1px;
    left: -164px;
    margin: 6px 0 0 0;
    background: white none repeat scroll 0 0;
    box-shadow: 0 4px 0 0 white, 0 8px 0 0 white;
    content: "";
  }
  #toc nav {
    display: none;
    padding: 0.5em 1em 1em;
    overflow: auto;
    height: calc(100vh - 48px);
    border-left: 1px solid #ddd;
  }
}

/* alternative layout for wide screens */
@media screen and (min-width: 1024px) {
  body {
    max-width: 724px;
    margin: 42px auto;
    padding-left: 1.5em;
    padding-right: 29em;
  }
  #toc {
    position: fixed;
    top: 42px;
    right: 42px;
    width: 25%;
    margin: 0;
    padding: 0 1em;
    z-index: 1;
  }
  #toc h2 {
    border-top: none;
    border-bottom: 1px solid #ddd;
    font-size: 1em;
    font-weight: normal;
    margin: 0;
    padding: 0.25em 1em 1em 0;
  }
  #toc nav {
    display: block;
    height: calc(90vh - 84px);
    bottom: 0;
    padding: 0.5em 0 0;
    overflow: auto;
  }
  img { /* future proofing */
    max-width: 100%;
    height: auto;
  }
}

/* pagination */
@media print {
  body {

    width: 100%;
  }
  p {
    orphans: 3;
    widows: 3;
  }
  #n-copyright-notice {
    border-bottom: none;
  }
  #toc, #n-introduction {
    page-break-before: always;
  }
  #toc {
    border-top: none;
    padding-top: 0;
  }
  figure, pre {
    page-break-inside: avoid;
  }
  figure {
    overflow: scroll;
  }
  h1, h2, h3, h4, h5, h6 {
    page-break-after: avoid;
  }
  h2+*, h3+*, h4+*, h5+*, h6+* {
    page-break-before: avoid;
  }
  pre {
    white-space: pre-wrap;
    word-wrap: break-word;
    font-size: 10pt;
  }
  table {
    border: 1px solid #ddd;
  }
  td {
    border-top: 1px solid #ddd;
  }
}

/* This is commented out here, as the string-set: doesn't
   pass W3C validation currently */
/*
.ears thead .left {
  string-set: ears-top-left content();
}

.ears thead .center {
  string-set: ears-top-center content();
}

.ears thead .right {
  string-set: ears-top-right content();
}

.ears tfoot .left {
  string-set: ears-bottom-left content();
}

.ears tfoot .center {
  string-set: ears-bottom-center content();
}

.ears tfoot .right {
  string-set: ears-bottom-right content();
}
*/

@page :first {
  padding-top: 0;
  @top-left {
    content: normal;
    border: none;
  }
  @top-center {
    content: normal;
    border: none;
  }
  @top-right {
    content: normal;
    border: none;
  }
}

@page {
  size: A4;
  margin-bottom: 45mm;
  padding-top: 20px;
  /* The follwing is commented out here, but set appropriately by in code, as
     the content depends on the document */
  /*
  @top-left {
    content: 'Internet-Draft';
    vertical-align: bottom;
    border-bottom: solid 1px #ccc;
  }
  @top-left {
    content: string(ears-top-left);
    vertical-align: bottom;
    border-bottom: solid 1px #ccc;
  }
  @top-center {
    content: string(ears-top-center);
    vertical-align: bottom;
    border-bottom: solid 1px #ccc;
  }
  @top-right {
    content: string(ears-top-right);
    vertical-align: bottom;
    border-bottom: solid 1px #ccc;
  }
  @bottom-left {
    content: string(ears-bottom-left);
    vertical-align: top;
    border-top: solid 1px #ccc;
  }
  @bottom-center {
    content: string(ears-bottom-center);
    vertical-align: top;
    border-top: solid 1px #ccc;
  }
  @bottom-right {
      content: '[Page ' counter(page) ']';
      vertical-align: top;
      border-top: solid 1px #ccc;
  }
  */

}

/* Changes introduced to fix issues found during implementation */
/* Make sure links are clickable even if overlapped by following H* */
a {
  z-index: 2;
}
/* Separate body from document info even without intervening H1 */
section {
  clear: both;
}


/* Top align author divs, to avoid names without organization dropping level with org names */
.author {
  vertical-align: top;
}

/* Leave room in document info to show Internet-Draft on one line */
#identifiers dt {
  width: 8em;
}

/* Don't waste quite as much whitespace between label and value in doc info */
#identifiers dd {
  margin-left: 1em;
}

/* Give floating toc a background color (needed when it's a div inside section */
#toc {
  background-color: white;
}

/* Make the collapsed ToC header render white on gray also when it's a link */
@media screen and (max-width: 1023px) {
  #toc h2 a,
  #toc h2 a:link,
  #toc h2 a:focus,
  #toc h2 a:hover,
  #toc a.toplink,
  #toc a.toplink:hover {
    color: white;
    background-color: #444;
    text-decoration: none;
  }
}

/* Give the bottom of the ToC some whitespace */
@media screen and (min-width: 1024px) {
  #toc {
    padding: 0 0 1em 1em;
  }
}

/* Style section numbers with more space between number and title */
.section-number {
  padding-right: 0.5em;
}

/* prevent monospace from becoming overly large */
tt, code, pre, code {
  font-size: 95%;
}

/* Fix the height/width aspect for ascii art*/
pre.sourcecode,
.art-text pre {
  line-height: 1.12;
}


/* Add styling for a link in the ToC that points to the top of the document */
a.toplink {
  float: right;
  margin-right: 0.5em;
}

/* Fix the dl styling to match the RFC 7992 attributes */
dl > dt,
dl.dlParallel > dt {
  float: left;
  margin-right: 1em;
}
dl.dlNewline > dt {
  float: none;
}

/* Provide styling for table cell text alignment */
table td.text-left,
table th.text-left {
  text-align: left;
}
table td.text-center,
table th.text-center {
  text-align: center;
}
table td.text-right,
table th.text-right {
  text-align: right;
}

/* Make the alternative author contact informatio look less like just another
   author, and group it closer with the primary author contact information */
.alternative-contact {
  margin: 0.5em 0 0.25em 0;
}
address .non-ascii {
  margin: 0 0 0 2em;
}

/* With it being possible to set tables with alignment
  left, center, and right, { width: 100%; } does not make sense */
table {
  width: auto;
}

/* Avoid reference text that sits in a block with very wide left margin,
   because of a long floating dt label.*/
.references dd {
  overflow: visible;
}

/* Control caption placement */
caption {
  caption-side: bottom;
}

/* Limit the width of the author address vcard, so names in right-to-left
   script don't end up on the other side of the page. */

address.vcard {
  max-width: 30em;
  margin-right: auto;
}

/* For address alignment dependent on LTR or RTL scripts */
address div.left {
  text-align: left;
}
address div.right {
  text-align: right;
}

/* Provide table alignment support.  We can't use the alignX classes above
   since they do unwanted things with caption and other styling. */
table.right {
 margin-left: auto;
 margin-right: 0;
}
table.center {
 margin-left: auto;
 margin-right: auto;
}
table.left {
 margin-left: 0;
 margin-right: auto;
}

/* Give the table caption label the same styling as the figcaption */
caption a[href] {
  color: #222;
}

@media print {
  .toplink {
    display: none;
  }

  /* avoid overwriting the top border line with the ToC header */
  #toc {
    padding-top: 1px;
  }

  /* Avoid page breaks inside dl and author address entries */
  .vcard {
    page-break-inside: avoid;
  }

}
/* Tweak the bcp14 keyword presentation */
.bcp14 {
  font-variant: small-caps;
  font-weight: bold;
  font-size: 0.9em;
}
/* Tweak the invisible space above H* in order not to overlay links in text above */
 h2 {
  margin-top: -18px;  /* provide offset for in-page anchors */
  padding-top: 31px;
 }
 h3 {
  margin-top: -18px;  /* provide offset for in-page anchors */
  padding-top: 24px;
 }
 h4 {
  margin-top: -18px;  /* provide offset for in-page anchors */
  padding-top: 24px;
 }
/* Float artwork pilcrow to the right */
@media screen {
  .artwork a.pilcrow {
    display: block;
    line-height: 0.7;
    margin-top: 0.15em;
  }
}
/* Make pilcrows on dd visible */
@media screen {
  dd:hover > a.pilcrow {
    visibility: visible;
  }
}
/* Make the placement of figcaption match that of a table's caption
   by removing the figure's added bottom margin */
.alignLeft.art-text,
.alignCenter.art-text,
.alignRight.art-text {
   margin-bottom: 0;
}
.alignLeft,
.alignCenter,
.alignRight {
  margin: 1em 0 0 0;
}
/* In print, the pilcrow won't show on hover, so prevent it from taking up space,
   possibly even requiring a new line */
@media print {
  a.pilcrow {
    display: none;
  }
}
/* Styling for the external metadata */
div#external-metadata {
  background-color: #eee;
  padding: 0.5em;
  margin-bottom: 0.5em;
  display: none;
}
div#internal-metadata {
  padding: 0.5em;                       /* to match the external-metadata padding */
}
/* Styling for title RFC Number */
h1#rfcnum {
  clear: both;
  margin: 0 0 -1em;
  padding: 1em 0 0 0;
}
/* Make .olPercent look the same as <ol><li> */
dl.olPercent > dd {
  margin-bottom: 0.25em;
  min-height: initial;
}
/* Give aside some styling to set it apart */
aside {
  border-left: 1px solid #ddd;
  margin: 1em 0 1em 2em;
  padding: 0.2em 2em;
}
aside > dl,
aside > ol,
aside > ul,
aside > table,
aside > p {
  margin-bottom: 0.5em;
}
/* Additional page break settings */
@media print {
  figcaption, table caption {
    page-break-before: avoid;
  }
}
/* Font size adjustments for print */
@media print {
  body  { font-size: 10pt;      line-height: normal; max-width: 96%; }
  h1    { font-size: 1.72em;    padding-top: 1.5em; } /* 1*1.2*1.2*1.2 */
  h2    { font-size: 1.44em;    padding-top: 1.5em; } /* 1*1.2*1.2 */
  h3    { font-size: 1.2em;     padding-top: 1.5em; } /* 1*1.2 */
  h4    { font-size: 1em;       padding-top: 1.5em; }
  h5, h6 { font-size: 1em;      margin: initial; padding: 0.5em 0 0.3em; }
}
/* Sourcecode margin in print, when there's no pilcrow */
@media print {
  .artwork,
  .sourcecode {
    margin-bottom: 1em;
  }
}
/* Avoid narrow tables forcing too narrow table captions, which may render badly */
table {
  min-width: 20em;
}
/* ol type a */
ol.type-a { list-style-type: lower-alpha; }
ol.type-A { list-style-type: upper-alpha; }
ol.type-i { list-style-type: lower-roman; }
ol.type-I { list-style-type: lower-roman; }
/* Apply the print table and row borders in general, on request from the RPC,
and increase the contrast between border and odd row background sligthtly */
table {
  border: 1px solid #ddd;
}
td {
  border-top: 1px solid #ddd;
}
tr:nth-child(2n+1) > td {
  background-color: #f8f8f8;
}
/* Use style rules to govern display of the TOC. */
@media screen and (max-width: 1023px) {
  #toc nav { display: none; }
  #toc.active nav { display: block; }
}
/* Add support for keepWithNext */
.keepWithNext {
  break-after: avoid-page;
  break-after: avoid-page;
}
/* Add support for keepWithPrevious */
.keepWithPrevious {
  break-before: avoid-page;
}
/* Change the approach to avoiding breaks inside artwork etc. */
figure, pre, table, .artwork, .sourcecode  {
  break-before: auto;
  break-after: auto;
}
/* Avoid breaks between <dt> and <dd> */
dl {
  break-before: auto;
  break-inside: auto;
}
dt {
  break-before: auto;
  break-after: avoid-page;
}
dd {
  break-before: avoid-page;
  break-after: auto;
  orphans: 3;
  widows: 3
}
span.break, dd.break {
  margin-bottom: 0;
  min-height: 0;
  break-before: auto;
  break-inside: auto;
  break-after: auto;
}
/* Undo break-before ToC */
@media print {
  #toc {
    break-before: auto;
  }
}
/* Text in compact lists should not get extra bottim margin space,
   since that would makes the list not compact */
ul.compact p, .ulCompact p,
ol.compact p, .olCompact p {
 margin: 0;
}
/* But the list as a whole needs the extra space at the end */
section ul.compact,
section .ulCompact,
section ol.compact,
section .olCompact {
  margin-bottom: 1em;                    /* same as p not within ul.compact etc. */
}
/* The tt and code background above interferes with for instance table cell
   backgrounds.  Changed to something a bit more selective. */
tt, code {
  background-color: transparent;
}
p tt, p code, li tt, li code {
  background-color: #f8f8f8;
}
/* Tweak the pre margin -- 0px doesn't come out well */
pre {
   margin-top: 0.5px;
}
/* Tweak the comact list text */
ul.compact, .ulCompact,
ol.compact, .olCompact,
dl.compact, .dlCompact {
  line-height: normal;
}
/* Don't add top margin for nested lists */
li > ul, li > ol, li > dl,
dd > ul, dd > ol, dd > dl,
dl > dd > dl {
  margin-top: initial;
}
/* Elements that should not be rendered on the same line as a <dt> */
/* This should match the element list in writer.text.TextWriter.render_dl() */
dd > div.artwork:first-child,
dd > aside:first-child,
dd > figure:first-child,
dd > ol:first-child,
dd > div:first-child > pre.sourcecode,
dd > table:first-child,
dd > ul:first-child {
  clear: left;
}
/* fix for weird browser behaviour when <dd/> is empty */
dt+dd:empty::before{
  content: "\00a0";
}
/* Make paragraph spacing inside <li> smaller than in body text, to fit better within the list */
li > p {
  margin-bottom: 0.5em
}
/* Don't let p margin spill out from inside list items */
li > p:last-of-type {
  margin-bottom: 0;
}
</style>
<link href="rfc-local.css" rel="stylesheet" type="text/css">
<script type="application/javascript">async function addMetadata(){try{const e=document.styleSheets[0].cssRules;for(let t=0;t<e.length;t++)if(/#identifiers/.exec(e[t].selectorText)){const a=e[t].cssText.replace("#identifiers","#external-updates");document.styleSheets[0].insertRule(a,document.styleSheets[0].cssRules.length)}}catch(e){console.log(e)}const e=document.getElementById("external-metadata");if(e)try{var t,a="",o=function(e){const t=document.getElementsByTagName("meta");for(let a=0;a<t.length;a++)if(t[a].getAttribute("name")===e)return t[a].getAttribute("content");return""}("rfc.number");if(o){t="https://www.rfc-editor.org/rfc/rfc"+o+".json";try{const e=await fetch(t);a=await e.json()}catch(e){t=document.URL.indexOf("html")>=0?document.URL.replace(/html$/,"json"):document.URL+".json";const o=await fetch(t);a=await o.json()}}if(!a)return;e.style.display="block";const s="",d="https://datatracker.ietf.org/doc",n="https://datatracker.ietf.org/ipr/search",c="https://www.rfc-editor.org/info",l=a.doc_id.toLowerCase(),i=a.doc_id.slice(0,3).toLowerCase(),f=a.doc_id.slice(3).replace(/^0+/,""),u={status:"Status",obsoletes:"Obsoletes",obsoleted_by:"Obsoleted By",updates:"Updates",updated_by:"Updated By",see_also:"See Also",errata_url:"Errata"};let h="<dl style='overflow:hidden' id='external-updates'>";["status","obsoletes","obsoleted_by","updates","updated_by","see_also","errata_url"].forEach(e=>{if("status"==e){a[e]=a[e].toLowerCase();var t=a[e].split(" "),o=t.length,w="",p=1;for(let e=0;e<o;e++)p<o?w=w+r(t[e])+" ":w+=r(t[e]),p++;a[e]=w}else if("obsoletes"==e||"obsoleted_by"==e||"updates"==e||"updated_by"==e){var g,m="",b=1;g=a[e].length;for(let t=0;t<g;t++)a[e][t]&&(a[e][t]=String(a[e][t]).toLowerCase(),m=b<g?m+"<a href='"+s+"/rfc/".concat(a[e][t])+"'>"+a[e][t].slice(3)+"</a>, ":m+"<a href='"+s+"/rfc/".concat(a[e][t])+"'>"+a[e][t].slice(3)+"</a>",b++);a[e]=m}else if("see_also"==e){var y,L="",C=1;y=a[e].length;for(let t=0;t<y;t++)if(a[e][t]){a[e][t]=String(a[e][t]);var _=a[e][t].slice(0,3),v=a[e][t].slice(3).replace(/^0+/,"");L=C<y?"RFC"!=_?L+"<a href='"+s+"/info/"+_.toLowerCase().concat(v.toLowerCase())+"'>"+_+" "+v+"</a>, ":L+"<a href='"+s+"/info/"+_.toLowerCase().concat(v.toLowerCase())+"'>"+v+"</a>, ":"RFC"!=_?L+"<a href='"+s+"/info/"+_.toLowerCase().concat(v.toLowerCase())+"'>"+_+" "+v+"</a>":L+"<a href='"+s+"/info/"+_.toLowerCase().concat(v.toLowerCase())+"'>"+v+"</a>",C++}a[e]=L}else if("errata_url"==e){var R="";R=a[e]?R+"<a href='"+a[e]+"'>Errata exist</a> | <a href='"+d+"/"+l+"'>Datatracker</a>| <a href='"+n+"/?"+i+"="+f+"&submit="+i+"'>IPR</a> | <a href='"+c+"/"+l+"'>Info page</a>":"<a href='"+d+"/"+l+"'>Datatracker</a> | <a href='"+n+"/?"+i+"="+f+"&submit="+i+"'>IPR</a> | <a href='"+c+"/"+l+"'>Info page</a>",a[e]=R}""!=a[e]?"Errata"==u[e]?h+=`<dt>More info:</dt><dd>${a[e]}</dd>`:h+=`<dt>${u[e]}:</dt><dd>${a[e]}</dd>`:"Errata"==u[e]&&(h+=`<dt>More info:</dt><dd>${a[e]}</dd>`)}),h+="</dl>",e.innerHTML=h}catch(e){console.log(e)}else console.log("Could not locate metadata <div> element");function r(e){return e.charAt(0).toUpperCase()+e.slice(1)}}window.removeEventListener("load",addMetadata),window.addEventListener("load",addMetadata);</script>
</head>
<body>
<script src="metadata.min.js"></script>
<table class="ears">
<thead><tr>
<td class="left">Internet-Draft</td>
<td class="center">BBR</td>
<td class="right">March 2022</td>
</tr></thead>
<tfoot><tr>
<td class="left">Cardwell, et al.</td>
<td class="center">Expires 8 September 2022</td>
<td class="right">[Page]</td>
</tr></tfoot>
</table>
<div id="external-metadata" class="document-information"></div>
<div id="internal-metadata" class="document-information">
<dl id="identifiers">
<dt class="label-workgroup">Workgroup:</dt>
<dd class="workgroup">Internet Congestion Control Research Group</dd>
<dt class="label-internet-draft">Internet-Draft:</dt>
<dd class="internet-draft">draft-cardwell-iccrg-bbr-congestion-control-02</dd>
<dt class="label-published">Published:</dt>
<dd class="published">
<time datetime="2022-03-07" class="published">7 March 2022</time>
    </dd>
<dt class="label-intended-status">Intended Status:</dt>
<dd class="intended-status">Experimental</dd>
<dt class="label-expires">Expires:</dt>
<dd class="expires"><time datetime="2022-09-08">8 September 2022</time></dd>
<dt class="label-authors">Authors:</dt>
<dd class="authors">
<div class="author">
      <div class="author-name">N. Cardwell</div>
<div class="org">Google</div>
</div>
<div class="author">
      <div class="author-name">Y. Cheng</div>
<div class="org">Google</div>
</div>
<div class="author">
      <div class="author-name">S. Hassas Yeganeh</div>
<div class="org">Google</div>
</div>
<div class="author">
      <div class="author-name">I. Swett</div>
<div class="org">Google</div>
</div>
<div class="author">
      <div class="author-name">V. Jacobson</div>
<div class="org">Google</div>
</div>
</dd>
</dl>
</div>
<h1 id="title">BBR Congestion Control</h1>
<section id="section-abstract">
      <h2 id="abstract"><a href="#abstract" class="selfRef">Abstract</a></h2>
<p id="section-abstract-1">
This document specifies the BBR congestion control algorithm. BBR ("Bottleneck Bandwidth and Round-trip propagation time") uses recent measurements of a transport connection's delivery rate,  round-trip time, and packet loss rate to build an explicit model of the network path. BBR then uses this model to control both how fast it sends data and the maximum volume of data it allows in flight in the network at any time. Relative to loss-based congestion control algorithms such as Reno [RFC5681] or CUBIC [RFC8312], BBR offers substantially higher throughput for bottlenecks with shallow buffers or random losses, and substantially lower queueing delays for bottlenecks with deep buffers (avoiding "bufferbloat"). BBR can be implemented in any transport protocol that supports packet-delivery acknowledgment. Thus far, open source implementations are available for TCP [RFC793] and QUIC [RFC9000]. This document specifies version 2 of the BBR algorithm, also sometimes referred to as BBRv2 or bbr2.<a href="#section-abstract-1" class="pilcrow">¶</a></p>
</section>
<div id="status-of-memo">
<section id="section-boilerplate.1">
        <h2 id="name-status-of-this-memo-8">
<a href="#name-status-of-this-memo-8" class="section-name selfRef">Status of This Memo</a>
        </h2>
<p id="section-boilerplate.1-1">
        This Internet-Draft is submitted in full conformance with the
        provisions of BCP 78 and BCP 79.<a href="#section-boilerplate.1-1" class="pilcrow">¶</a></p>
<p id="section-boilerplate.1-2">
        Internet-Drafts are working documents of the Internet Engineering Task
        Force (IETF). Note that other groups may also distribute working
        documents as Internet-Drafts. The list of current Internet-Drafts is
        at <span><a href="https://datatracker.ietf.org/drafts/current/">https://datatracker.ietf.org/drafts/current/</a></span>.<a href="#section-boilerplate.1-2" class="pilcrow">¶</a></p>
<p id="section-boilerplate.1-3">
        Internet-Drafts are draft documents valid for a maximum of six months
        and may be updated, replaced, or obsoleted by other documents at any
        time. It is inappropriate to use Internet-Drafts as reference
        material or to cite them other than as "work in progress."<a href="#section-boilerplate.1-3" class="pilcrow">¶</a></p>
<p id="section-boilerplate.1-4">
        This Internet-Draft will expire on 8 September 2022.<a href="#section-boilerplate.1-4" class="pilcrow">¶</a></p>
</section>
</div>
<div id="copyright">
<section id="section-boilerplate.2">
        <h2 id="name-copyright-notice-8">
<a href="#name-copyright-notice-8" class="section-name selfRef">Copyright Notice</a>
        </h2>
<p id="section-boilerplate.2-1">
            Copyright (c) 2022 IETF Trust and the persons identified as the
            document authors. All rights reserved.<a href="#section-boilerplate.2-1" class="pilcrow">¶</a></p>
<p id="section-boilerplate.2-2">
            This document is subject to BCP 78 and the IETF Trust's Legal
            Provisions Relating to IETF Documents
            (<span><a href="https://trustee.ietf.org/license-info">https://trustee.ietf.org/license-info</a></span>) in effect on the date of
            publication of this document. Please review these documents
            carefully, as they describe your rights and restrictions with
            respect to this document. Code Components extracted from this
            document must include Revised BSD License text as described in
            Section 4.e of the Trust Legal Provisions and are provided without
            warranty as described in the Revised BSD License.<a href="#section-boilerplate.2-2" class="pilcrow">¶</a></p>
</section>
</div>
<div id="toc">
<section id="section-toc.1">
        <a href="#" onclick="scroll(0,0)" class="toplink">▲</a><h2 id="name-table-of-contents-8">
<a href="#name-table-of-contents-8" class="section-name selfRef">Table of Contents</a>
        </h2>
<nav class="toc"><ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.1">
            <p id="section-toc.1-1.1.1" class="keepWithNext"><a href="#section-1" class="xref">1</a>.  <a href="#name-introduction-7" class="xref">Introduction</a></p>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.2">
            <p id="section-toc.1-1.2.1"><a href="#section-2" class="xref">2</a>.  <a href="#name-terminology-3" class="xref">Terminology</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.2.2.1">
                <p id="section-toc.1-1.2.2.1.1" class="keepWithNext"><a href="#section-2.1" class="xref">2.1</a>.  <a href="#name-transport-connection-state" class="xref">Transport Connection State</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.2.2.2">
                <p id="section-toc.1-1.2.2.2.1" class="keepWithNext"><a href="#section-2.2" class="xref">2.2</a>.  <a href="#name-per-packet-state" class="xref">Per-Packet State</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.2.2.3">
                <p id="section-toc.1-1.2.2.3.1"><a href="#section-2.3" class="xref">2.3</a>.  <a href="#name-per-ack-rate-sample-state" class="xref">Per-ACK Rate Sample State</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.2.2.4">
                <p id="section-toc.1-1.2.2.4.1"><a href="#section-2.4" class="xref">2.4</a>.  <a href="#name-output-control-parameters" class="xref">Output Control Parameters</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.2.2.5">
                <p id="section-toc.1-1.2.2.5.1"><a href="#section-2.5" class="xref">2.5</a>.  <a href="#name-pacing-state-and-parameters" class="xref">Pacing State and Parameters</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.2.2.6">
                <p id="section-toc.1-1.2.2.6.1"><a href="#section-2.6" class="xref">2.6</a>.  <a href="#name-cwnd-state-and-parameters" class="xref">cwnd State and Parameters</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.2.2.7">
                <p id="section-toc.1-1.2.2.7.1"><a href="#section-2.7" class="xref">2.7</a>.  <a href="#name-general-algorithm-state" class="xref">General Algorithm State</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.2.2.8">
                <p id="section-toc.1-1.2.2.8.1"><a href="#section-2.8" class="xref">2.8</a>.  <a href="#name-core-algorithm-design-param" class="xref">Core Algorithm Design Parameters</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.2.2.9">
                <p id="section-toc.1-1.2.2.9.1"><a href="#section-2.9" class="xref">2.9</a>.  <a href="#name-network-path-model-paramete" class="xref">Network Path Model Parameters</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.2.2.9.2.1">
                    <p id="section-toc.1-1.2.2.9.2.1.1"><a href="#section-2.9.1" class="xref">2.9.1</a>.  <a href="#name-data-rate-network-path-mode" class="xref">Data Rate Network Path Model Parameters</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.2.2.9.2.2">
                    <p id="section-toc.1-1.2.2.9.2.2.1"><a href="#section-2.9.2" class="xref">2.9.2</a>.  <a href="#name-data-volume-network-path-mo" class="xref">Data Volume Network Path Model Parameters</a></p>
</li>
                </ul>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.2.2.10">
                <p id="section-toc.1-1.2.2.10.1"><a href="#section-2.10" class="xref">2.10</a>. <a href="#name-state-for-responding-to-con" class="xref">State for Responding to Congestion</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.2.2.11">
                <p id="section-toc.1-1.2.2.11.1"><a href="#section-2.11" class="xref">2.11</a>. <a href="#name-estimating-bbrmax_bw" class="xref">Estimating BBR.max_bw</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.2.2.12">
                <p id="section-toc.1-1.2.2.12.1"><a href="#section-2.12" class="xref">2.12</a>. <a href="#name-estimating-bbrextra_acked" class="xref">Estimating BBR.extra_acked</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.2.2.13">
                <p id="section-toc.1-1.2.2.13.1"><a href="#section-2.13" class="xref">2.13</a>. <a href="#name-startup-parameters-and-stat" class="xref">Startup Parameters and State</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.2.2.14">
                <p id="section-toc.1-1.2.2.14.1"><a href="#section-2.14" class="xref">2.14</a>. <a href="#name-probertt-and-min_rtt-parame" class="xref">ProbeRTT and min_rtt Parameters and State</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.2.2.14.2.1">
                    <p id="section-toc.1-1.2.2.14.2.1.1"><a href="#section-2.14.1" class="xref">2.14.1</a>.  <a href="#name-parameters-for-estimating-b" class="xref">Parameters for Estimating BBR.min_rtt</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.2.2.14.2.2">
                    <p id="section-toc.1-1.2.2.14.2.2.1"><a href="#section-2.14.2" class="xref">2.14.2</a>.  <a href="#name-parameters-for-scheduling-p" class="xref">Parameters for Scheduling ProbeRTT</a></p>
</li>
                </ul>
</li>
            </ul>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.3">
            <p id="section-toc.1-1.3.1"><a href="#section-3" class="xref">3</a>.  <a href="#name-design-overview" class="xref">Design Overview</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.3.2.1">
                <p id="section-toc.1-1.3.2.1.1"><a href="#section-3.1" class="xref">3.1</a>.  <a href="#name-high-level-design-goals" class="xref">High-Level Design Goals</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.3.2.2">
                <p id="section-toc.1-1.3.2.2.1"><a href="#section-3.2" class="xref">3.2</a>.  <a href="#name-algorithm-overview" class="xref">Algorithm Overview</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.3.2.3">
                <p id="section-toc.1-1.3.2.3.1"><a href="#section-3.3" class="xref">3.3</a>.  <a href="#name-state-machine-overview" class="xref">State Machine Overview</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.3.2.4">
                <p id="section-toc.1-1.3.2.4.1"><a href="#section-3.4" class="xref">3.4</a>.  <a href="#name-network-path-model-overview" class="xref">Network Path Model Overview</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.3.2.4.2.1">
                    <p id="section-toc.1-1.3.2.4.2.1.1"><a href="#section-3.4.1" class="xref">3.4.1</a>.  <a href="#name-high-level-design-goals-for" class="xref">High-Level Design Goals for the Network Path Model</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.3.2.4.2.2">
                    <p id="section-toc.1-1.3.2.4.2.2.1"><a href="#section-3.4.2" class="xref">3.4.2</a>.  <a href="#name-time-scales-for-the-network" class="xref">Time Scales for the Network Model</a></p>
</li>
                </ul>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.3.2.5">
                <p id="section-toc.1-1.3.2.5.1"><a href="#section-3.5" class="xref">3.5</a>.  <a href="#name-control-parameter-overview" class="xref">Control Parameter Overview</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.3.2.6">
                <p id="section-toc.1-1.3.2.6.1"><a href="#section-3.6" class="xref">3.6</a>.  <a href="#name-environment-and-usage" class="xref">Environment and Usage</a></p>
</li>
            </ul>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4">
            <p id="section-toc.1-1.4.1"><a href="#section-4" class="xref">4</a>.  <a href="#name-detailed-algorithm" class="xref">Detailed Algorithm</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.1">
                <p id="section-toc.1-1.4.2.1.1"><a href="#section-4.1" class="xref">4.1</a>.  <a href="#name-state-machine" class="xref">State Machine</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.1.2.1">
                    <p id="section-toc.1-1.4.2.1.2.1.1"><a href="#section-4.1.1" class="xref">4.1.1</a>.  <a href="#name-state-transition-diagram" class="xref">State Transition Diagram</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.1.2.2">
                    <p id="section-toc.1-1.4.2.1.2.2.1"><a href="#section-4.1.2" class="xref">4.1.2</a>.  <a href="#name-state-machine-operation-ove" class="xref">State Machine Operation Overview</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.1.2.3">
                    <p id="section-toc.1-1.4.2.1.2.3.1"><a href="#section-4.1.3" class="xref">4.1.3</a>.  <a href="#name-state-machine-tactics" class="xref">State Machine Tactics</a></p>
</li>
                </ul>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.2">
                <p id="section-toc.1-1.4.2.2.1"><a href="#section-4.2" class="xref">4.2</a>.  <a href="#name-algorithm-organization" class="xref">Algorithm Organization</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.2.2.1">
                    <p id="section-toc.1-1.4.2.2.2.1.1"><a href="#section-4.2.1" class="xref">4.2.1</a>.  <a href="#name-initialization" class="xref">Initialization</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.2.2.2">
                    <p id="section-toc.1-1.4.2.2.2.2.1"><a href="#section-4.2.2" class="xref">4.2.2</a>.  <a href="#name-per-transmit-steps" class="xref">Per-Transmit Steps</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.2.2.3">
                    <p id="section-toc.1-1.4.2.2.2.3.1"><a href="#section-4.2.3" class="xref">4.2.3</a>.  <a href="#name-per-ack-steps" class="xref">Per-ACK Steps</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.2.2.4">
                    <p id="section-toc.1-1.4.2.2.2.4.1"><a href="#section-4.2.4" class="xref">4.2.4</a>.  <a href="#name-per-loss-steps" class="xref">Per-Loss Steps</a></p>
</li>
                </ul>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.3">
                <p id="section-toc.1-1.4.2.3.1"><a href="#section-4.3" class="xref">4.3</a>.  <a href="#name-state-machine-operation" class="xref">State Machine Operation</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.3.2.1">
                    <p id="section-toc.1-1.4.2.3.2.1.1"><a href="#section-4.3.1" class="xref">4.3.1</a>.  <a href="#name-startup" class="xref">Startup</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.3.2.2">
                    <p id="section-toc.1-1.4.2.3.2.2.1"><a href="#section-4.3.2" class="xref">4.3.2</a>.  <a href="#name-drain" class="xref">Drain</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.3.2.3">
                    <p id="section-toc.1-1.4.2.3.2.3.1"><a href="#section-4.3.3" class="xref">4.3.3</a>.  <a href="#name-probebw" class="xref">ProbeBW</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.3.2.4">
                    <p id="section-toc.1-1.4.2.3.2.4.1"><a href="#section-4.3.4" class="xref">4.3.4</a>.  <a href="#name-probertt" class="xref">ProbeRTT</a></p>
</li>
                </ul>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.4">
                <p id="section-toc.1-1.4.2.4.1"><a href="#section-4.4" class="xref">4.4</a>.  <a href="#name-restarting-from-idle" class="xref">Restarting From Idle</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.4.2.1">
                    <p id="section-toc.1-1.4.2.4.2.1.1"><a href="#section-4.4.1" class="xref">4.4.1</a>.  <a href="#name-setting-pacing-rate-in-prob" class="xref">Setting Pacing Rate in ProbeBW</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.4.2.2">
                    <p id="section-toc.1-1.4.2.4.2.2.1"><a href="#section-4.4.2" class="xref">4.4.2</a>.  <a href="#name-checking-for-proberrtt-comp" class="xref">Checking for ProberRTT Completion</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.4.2.3">
                    <p id="section-toc.1-1.4.2.4.2.3.1"><a href="#section-4.4.3" class="xref">4.4.3</a>.  <a href="#name-logic" class="xref">Logic</a></p>
</li>
                </ul>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.5">
                <p id="section-toc.1-1.4.2.5.1"><a href="#section-4.5" class="xref">4.5</a>.  <a href="#name-updating-network-path-model" class="xref">Updating Network Path Model Parameters</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.5.2.1">
                    <p id="section-toc.1-1.4.2.5.2.1.1"><a href="#section-4.5.1" class="xref">4.5.1</a>.  <a href="#name-bbrround_count-tracking-pac" class="xref">BBR.round_count: Tracking Packet-Timed Round Trips</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.5.2.2">
                    <p id="section-toc.1-1.4.2.5.2.2.1"><a href="#section-4.5.2" class="xref">4.5.2</a>.  <a href="#name-bbrmax_bw-estimated-maximum" class="xref">BBR.max_bw: Estimated Maximum Bandwidth</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.5.2.3">
                    <p id="section-toc.1-1.4.2.5.2.3.1"><a href="#section-4.5.3" class="xref">4.5.3</a>.  <a href="#name-bbrmin_rtt-estimated-minimu" class="xref">BBR.min_rtt: Estimated Minimum Round-Trip Time</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.5.2.4">
                    <p id="section-toc.1-1.4.2.5.2.4.1"><a href="#section-4.5.4" class="xref">4.5.4</a>.  <a href="#name-bbroffload_budget" class="xref">BBR.offload_budget</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.5.2.5">
                    <p id="section-toc.1-1.4.2.5.2.5.1"><a href="#section-4.5.5" class="xref">4.5.5</a>.  <a href="#name-bbrextra_acked" class="xref">BBR.extra_acked</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.5.2.6">
                    <p id="section-toc.1-1.4.2.5.2.6.1"><a href="#section-4.5.6" class="xref">4.5.6</a>.  <a href="#name-updating-the-model-upon-pac" class="xref">Updating the Model Upon Packet Loss</a></p>
</li>
                </ul>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.6">
                <p id="section-toc.1-1.4.2.6.1"><a href="#section-4.6" class="xref">4.6</a>.  <a href="#name-updating-control-parameters" class="xref">Updating Control Parameters</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.6.2.1">
                    <p id="section-toc.1-1.4.2.6.2.1.1"><a href="#section-4.6.1" class="xref">4.6.1</a>.  <a href="#name-summary-of-control-behavior" class="xref">Summary of Control Behavior in the State Machine</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.6.2.2">
                    <p id="section-toc.1-1.4.2.6.2.2.1"><a href="#section-4.6.2" class="xref">4.6.2</a>.  <a href="#name-pacing-rate-bbrpacing_rate" class="xref">Pacing Rate: BBR.pacing_rate</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.6.2.3">
                    <p id="section-toc.1-1.4.2.6.2.3.1"><a href="#section-4.6.3" class="xref">4.6.3</a>.  <a href="#name-send-quantum-bbrsend_quantu" class="xref">Send Quantum: BBR.send_quantum</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.6.2.4">
                    <p id="section-toc.1-1.4.2.6.2.4.1"><a href="#section-4.6.4" class="xref">4.6.4</a>.  <a href="#name-congestion-window" class="xref">Congestion Window</a></p>
</li>
                </ul>
</li>
            </ul>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.5">
            <p id="section-toc.1-1.5.1"><a href="#section-5" class="xref">5</a>.  <a href="#name-implementation-status" class="xref">Implementation Status</a></p>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.6">
            <p id="section-toc.1-1.6.1"><a href="#section-6" class="xref">6</a>.  <a href="#name-security-considerations-8" class="xref">Security Considerations</a></p>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.7">
            <p id="section-toc.1-1.7.1"><a href="#section-7" class="xref">7</a>.  <a href="#name-iana-considerations-8" class="xref">IANA Considerations</a></p>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.8">
            <p id="section-toc.1-1.8.1"><a href="#section-8" class="xref">8</a>.  <a href="#name-acknowledgments-4" class="xref">Acknowledgments</a></p>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.9">
            <p id="section-toc.1-1.9.1"><a href="#section-9" class="xref">9</a>.  <a href="#name-references-8" class="xref">References</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.9.2.1">
                <p id="section-toc.1-1.9.2.1.1"><a href="#section-9.1" class="xref">9.1</a>.  <a href="#name-normative-references-8" class="xref">Normative References</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.9.2.2">
                <p id="section-toc.1-1.9.2.2.1"><a href="#section-9.2" class="xref">9.2</a>.  <a href="#name-informative-references-8" class="xref">Informative References</a></p>
</li>
            </ul>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.10">
            <p id="section-toc.1-1.10.1"><a href="#appendix-A" class="xref"></a><a href="#name-authors-addresses-7" class="xref">Authors' Addresses</a></p>
</li>
        </ul>
</nav>
</section>
</div>
<div id="introduction">
<section id="section-1">
      <h2 id="name-introduction-7">
<a href="#section-1" class="section-number selfRef">1. </a><a href="#name-introduction-7" class="section-name selfRef">Introduction</a>
      </h2>
<p id="section-1-1">The Internet has traditionally used loss-based congestion control algorithms like Reno ([Jac88], [Jac90], [WS95] [RFC5681]) and CUBIC ([HRX08], [RFC8312]). These algorithms worked well for many years because they were sufficiently well-matched to the prevalent range of bandwidth-delay products and degrees of buffering in Internet paths. As the Internet has evolved, loss-based congestion control is increasingly problematic in several important scenarios:<a href="#section-1-1" class="pilcrow">¶</a></p>
<ol start="1" type="1" class="normal type-1" id="section-1-2">
<li id="section-1-2.1">Shallow buffers: In shallow buffers, packet loss can happen even when a link has low utilization. With high-speed, long-haul links employing commodity switches with shallow buffers, loss-based congestion control can cause abysmal throughput because it overreacts, multiplicatively decreasing the sending rate upon packet loss, and only slowly growing its sending rate thereafter. This can happen even if the packet loss arises from transient traffic bursts  when the link is mostly idle.<a href="#section-1-2.1" class="pilcrow">¶</a>
</li>
        <li id="section-1-2.2">Deep buffers: At the edge of today's Internet, loss-based congestion control can cause the problem of  "bufferbloat", by repeatedly filling deep buffers in last-mile links and causing high queuing delays.<a href="#section-1-2.2" class="pilcrow">¶</a>
</li>
        <li id="section-1-2.3">Dynamic traffic workloads: With buffers of any depth, dynamic mixes of newly-entering flows or flights of data from recently idle flows can cause frequent packet loss. In such scenarios loss-based congestion control can fail to maintain its fair share of bandwidth, leading to poor application performance.<a href="#section-1-2.3" class="pilcrow">¶</a>
</li>
      </ol>
<p id="section-1-3">In both the shallow-buffer (1.) or dynamic-traffic (3.) scenarios mentioned above it is difficult to achieve full throughput with loss-based congestion control in practice: for CUBIC, sustaining 10Gbps over 100ms RTT needs a packet loss rate below 0.000003% (i.e., more than 40 seconds between packet losses), and over a 100ms RTT path a more feasible loss rate like 1% can only sustain at most 3 Mbps  [RFC8312]. These limitations apply no matter what the bottleneck link is capable of or what the connection's fair share is. Furthermore,  failure to reach the fair share can cause poor throughpout and poor tail latency for latency-sensitive applications.<a href="#section-1-3" class="pilcrow">¶</a></p>
<p id="section-1-4">The BBR ("Bottleneck Bandwidth and Round-trip propagation time") congestion control algorithm is a model-based algorithm that takes an approach different from loss-based congestion control: BBR uses recent measurements of a transport connection's delivery rate,  round-trip time, and packet loss rate to build an explicit model of the network path, including its estimated available bandwidth, bandwidth-delay product, and the maximum volume of data that the connection can place in-flight in the network without causing excessive queue pressure. It then uses this model in order to guide its control behavior in seeking high throughput and low queue pressure.<a href="#section-1-4" class="pilcrow">¶</a></p>
<p id="section-1-5">This document describes the current version of the BBR algorithm, BBRv2. The previous version of the algorithm,  BBRv1, was described previously at a high level [CCGHJ16][CCGHJ17]. The implications of BBR in allowing high utilization of high-speed networks with shallow buffers have been discussed in other work [MM19]. Active work on the BBR algorithm is continuing.<a href="#section-1-5" class="pilcrow">¶</a></p>
<p id="section-1-6">This document is organized as follows. Section 2 provides various definitions that will be used throughout this document. Section 3 provides an overview of the design of the BBR algorithm, and section 4 describes the BBR algorithm in detail, including BBR's network path model, control parameters, and state machine. Section 5 describes the implementation status, section 6 describes security considerations, section 7 notes that there are no IANA considerations, and section 8 closes with Acknowledgments.<a href="#section-1-6" class="pilcrow">¶</a></p>
</section>
</div>
<div id="terminology">
<section id="section-2">
      <h2 id="name-terminology-3">
<a href="#section-2" class="section-number selfRef">2. </a><a href="#name-terminology-3" class="section-name selfRef">Terminology</a>
      </h2>
<p id="section-2-1">This document defines state variables and constants for the BBR algorithm.<a href="#section-2-1" class="pilcrow">¶</a></p>
<p id="section-2-2">The variables starting with C, P, or rs not defined below are defined in [draft-cheng-iccrg-delivery-rate-estimation].<a href="#section-2-2" class="pilcrow">¶</a></p>
<div id="transport-connection-state">
<section id="section-2.1">
        <h3 id="name-transport-connection-state">
<a href="#section-2.1" class="section-number selfRef">2.1. </a><a href="#name-transport-connection-state" class="section-name selfRef">Transport Connection State</a>
        </h3>
<p id="section-2.1-1">C.delivered: The total amount of data (tracked in octets or in packets) delivered so far over the lifetime of the transport connection C.<a href="#section-2.1-1" class="pilcrow">¶</a></p>
<p id="section-2.1-2">SMSS: The Sender Maximum Segment Size.<a href="#section-2.1-2" class="pilcrow">¶</a></p>
<p id="section-2.1-3">is_cwnd_limited: True if the connection has fully utilized its cwnd at any point in the last packet-timed round trip.<a href="#section-2.1-3" class="pilcrow">¶</a></p>
<p id="section-2.1-4">InitialCwnd: The initial congestion window set by the transport protocol implementation for the connection at initialization time.<a href="#section-2.1-4" class="pilcrow">¶</a></p>
</section>
</div>
<div id="per-packet-state">
<section id="section-2.2">
        <h3 id="name-per-packet-state">
<a href="#section-2.2" class="section-number selfRef">2.2. </a><a href="#name-per-packet-state" class="section-name selfRef">Per-Packet State</a>
        </h3>
<p id="section-2.2-1">packet.delivered: C.delivered when the given packet was sent by transport connection C.<a href="#section-2.2-1" class="pilcrow">¶</a></p>
<p id="section-2.2-2">packet.departure_time: The earliest pacing departure time for the given packet.<a href="#section-2.2-2" class="pilcrow">¶</a></p>
<p id="section-2.2-3">packet.tx_in_flight: The volume of data that was estimated to be in flight at the time of the transmission of the packet.<a href="#section-2.2-3" class="pilcrow">¶</a></p>
</section>
</div>
<div id="per-ack-rate-sample-state">
<section id="section-2.3">
        <h3 id="name-per-ack-rate-sample-state">
<a href="#section-2.3" class="section-number selfRef">2.3. </a><a href="#name-per-ack-rate-sample-state" class="section-name selfRef">Per-ACK Rate Sample State</a>
        </h3>
<p id="section-2.3-1">rs.delivered: The volume of data delivered between the transmission of the packet that has just been ACKed and the current time.<a href="#section-2.3-1" class="pilcrow">¶</a></p>
<p id="section-2.3-2">rs.delivery_rate: The delivery rate (aka bandwidth) sample obtained from the packet that has just been ACKed.<a href="#section-2.3-2" class="pilcrow">¶</a></p>
<p id="section-2.3-3">rs.rtt: The RTT sample calculated based on the most recently-sent segment of the segments that have just been ACKed.<a href="#section-2.3-3" class="pilcrow">¶</a></p>
<p id="section-2.3-4">rs.newly_acked: The volume of data cumulatively or selectively acknowledged upon the ACK that was just received. (This quantity is referred to as "DeliveredData" in [RFC6937].)<a href="#section-2.3-4" class="pilcrow">¶</a></p>
<p id="section-2.3-5">rs.newly_lost: The volume of data newly marked lost upon the ACK that was just received.<a href="#section-2.3-5" class="pilcrow">¶</a></p>
<p id="section-2.3-6">rs.tx_in_flight: The volume of data that was estimated to be in flight at the time of the transmission of the packet that has just been ACKed (the most recently sent segment among segments ACKed by the ACK that was just received).<a href="#section-2.3-6" class="pilcrow">¶</a></p>
<p id="section-2.3-7">rs.lost: The volume of data that was declared lost between the transmission and acknowledgement of the packet that has just been ACKed (the most recently sent segment among segments ACKed by the ACK that was just received).<a href="#section-2.3-7" class="pilcrow">¶</a></p>
</section>
</div>
<div id="output-control-parameters">
<section id="section-2.4">
        <h3 id="name-output-control-parameters">
<a href="#section-2.4" class="section-number selfRef">2.4. </a><a href="#name-output-control-parameters" class="section-name selfRef">Output Control Parameters</a>
        </h3>
<p id="section-2.4-1">cwnd: The transport sender's congestion window, which limits the amount of data in flight.<a href="#section-2.4-1" class="pilcrow">¶</a></p>
<p id="section-2.4-2">BBR.pacing_rate: The current pacing rate for a BBR flow, which controls inter-packet spacing.<a href="#section-2.4-2" class="pilcrow">¶</a></p>
<p id="section-2.4-3">BBR.send_quantum: The maximum size of a data aggregate scheduled and transmitted together.<a href="#section-2.4-3" class="pilcrow">¶</a></p>
</section>
</div>
<div id="pacing-state-and-parameters">
<section id="section-2.5">
        <h3 id="name-pacing-state-and-parameters">
<a href="#section-2.5" class="section-number selfRef">2.5. </a><a href="#name-pacing-state-and-parameters" class="section-name selfRef">Pacing State and Parameters</a>
        </h3>
<p id="section-2.5-1">BBR.pacing_gain: The dynamic gain factor used to scale BBR.bw to produce BBR.pacing_rate.<a href="#section-2.5-1" class="pilcrow">¶</a></p>
<p id="section-2.5-2">BBRPacingMarginPercent: The static discount factor of 1% used to scale BBR.bw to produce BBR.pacing_rate.<a href="#section-2.5-2" class="pilcrow">¶</a></p>
<p id="section-2.5-3">BBR.next_departure_time: The earliest pacing departure time for the next packet BBR schedules for transmission.<a href="#section-2.5-3" class="pilcrow">¶</a></p>
</section>
</div>
<div id="cwnd-state-and-parameters">
<section id="section-2.6">
        <h3 id="name-cwnd-state-and-parameters">
<a href="#section-2.6" class="section-number selfRef">2.6. </a><a href="#name-cwnd-state-and-parameters" class="section-name selfRef">cwnd State and Parameters</a>
        </h3>
<p id="section-2.6-1">BBR.cwnd_gain: The dynamic gain factor used to scale the estimated BDP to produce a congestion window (cwnd).<a href="#section-2.6-1" class="pilcrow">¶</a></p>
<p id="section-2.6-2">BBRStartupPacingGain: A constant specifying the minimum gain value for calculating the pacing rate that will allow the sending rate to double each round (4*ln(2) ~= 2.77) [BBRStartupPacingGain]; used in Startup mode for BBR.pacing_gain.<a href="#section-2.6-2" class="pilcrow">¶</a></p>
<p id="section-2.6-3">BBRStartupCwndGain: A constant specifying the minimum gain value for calculating the cwnd that will allow the sending rate to double each round (2.0); used in Startup mode for BBR.cwnd_gain.<a href="#section-2.6-3" class="pilcrow">¶</a></p>
<p id="section-2.6-4">BBR.packet_conservation: A boolean indicating whether BBR is currently using packet conservation dynamics to bound cwnd.<a href="#section-2.6-4" class="pilcrow">¶</a></p>
</section>
</div>
<div id="general-algorithm-state">
<section id="section-2.7">
        <h3 id="name-general-algorithm-state">
<a href="#section-2.7" class="section-number selfRef">2.7. </a><a href="#name-general-algorithm-state" class="section-name selfRef">General Algorithm State</a>
        </h3>
<p id="section-2.7-1">BBR.state: The current state of a BBR flow in the BBR state machine.<a href="#section-2.7-1" class="pilcrow">¶</a></p>
<p id="section-2.7-2">BBR.round_count: Count of packet-timed round trips elapsed so far.<a href="#section-2.7-2" class="pilcrow">¶</a></p>
<p id="section-2.7-3">BBR.round_start: A boolean that BBR sets to true once per packet-timed round trip, on ACKs that advance BBR.round_count.<a href="#section-2.7-3" class="pilcrow">¶</a></p>
<p id="section-2.7-4">BBR.next_round_delivered: packet.delivered value denoting the end of a packet-timed round trip.<a href="#section-2.7-4" class="pilcrow">¶</a></p>
<p id="section-2.7-5">BBR.idle_restart: A boolean that is true if and only if a connection is restarting after being idle.<a href="#section-2.7-5" class="pilcrow">¶</a></p>
</section>
</div>
<div id="core-algorithm-design-parameters">
<section id="section-2.8">
        <h3 id="name-core-algorithm-design-param">
<a href="#section-2.8" class="section-number selfRef">2.8. </a><a href="#name-core-algorithm-design-param" class="section-name selfRef">Core Algorithm Design Parameters</a>
        </h3>
<p id="section-2.8-1">BBRLossThresh: The maximum tolerated per-round-trip packet loss rate when probing for bandwidth (the default is 2%).<a href="#section-2.8-1" class="pilcrow">¶</a></p>
<p id="section-2.8-2">BBRBeta: The default multiplicative decrease to make upon each round trip during which the connection detects packet loss (the value is 0.7).<a href="#section-2.8-2" class="pilcrow">¶</a></p>
<p id="section-2.8-3">BBRHeadroom: The multiplicative factor to apply to BBR.inflight_hi when attempting to leave free headroom in the path (e.g. free space in the bottleneck buffer or free time slots in the bottleneck link) that can be used by cross traffic (the value is 0.85).<a href="#section-2.8-3" class="pilcrow">¶</a></p>
<p id="section-2.8-4">BBRMinPipeCwnd: The minimal cwnd value BBR targets, to allow pipelining with TCP endpoints that follow an "ACK every other packet" delayed-ACK policy: 4 * SMSS.<a href="#section-2.8-4" class="pilcrow">¶</a></p>
</section>
</div>
<div id="network-path-model-parameters">
<section id="section-2.9">
        <h3 id="name-network-path-model-paramete">
<a href="#section-2.9" class="section-number selfRef">2.9. </a><a href="#name-network-path-model-paramete" class="section-name selfRef">Network Path Model Parameters</a>
        </h3>
<div id="data-rate-network-path-model-parameters">
<section id="section-2.9.1">
          <h4 id="name-data-rate-network-path-mode">
<a href="#section-2.9.1" class="section-number selfRef">2.9.1. </a><a href="#name-data-rate-network-path-mode" class="section-name selfRef">Data Rate Network Path Model Parameters</a>
          </h4>
<p id="section-2.9.1-1">The data rate model parameters together estimate both the sending rate required to reach the full bandwidth available to the flow (BBR.max_bw), and the maximum pacing rate control parameter that is consistent with the queue pressure objective (BBR.bw).<a href="#section-2.9.1-1" class="pilcrow">¶</a></p>
<p id="section-2.9.1-2">BBR.max_bw: The windowed maximum recent bandwidth sample - obtained using the BBR delivery rate sampling algorithm [draft-cheng-iccrg-delivery-rate-estimation] - measured during the current or previous bandwidth probing cycle (or during Startup, if the flow is still in that state). (Part of the long-term model.)<a href="#section-2.9.1-2" class="pilcrow">¶</a></p>
<p id="section-2.9.1-3">BBR.bw_hi: The long-term maximum sending bandwidth that the algorithm estimates will produce acceptable queue pressure, based on signals in the current or previous bandwidth probing cycle, as measured by loss. (Part of the long-term model.)<a href="#section-2.9.1-3" class="pilcrow">¶</a></p>
<p id="section-2.9.1-4">BBR.bw_lo: The short-term maximum sending bandwidth that the algorithm estimates is safe for matching the current network path delivery rate, based on any loss signals in the current bandwidth probing cycle. This is generally lower than  max_bw or bw_hi (thus the name). (Part of the short-term model.)<a href="#section-2.9.1-4" class="pilcrow">¶</a></p>
<p id="section-2.9.1-5">BBR.bw: The maximum sending bandwidth that the algorithm estimates is appropriate for matching the current network path delivery rate, given all available signals in the model, at any time scale. It is the min() of max_bw, bw_hi, and bw_lo.<a href="#section-2.9.1-5" class="pilcrow">¶</a></p>
</section>
</div>
<div id="data-volume-network-path-model-parameters">
<section id="section-2.9.2">
          <h4 id="name-data-volume-network-path-mo">
<a href="#section-2.9.2" class="section-number selfRef">2.9.2. </a><a href="#name-data-volume-network-path-mo" class="section-name selfRef">Data Volume Network Path Model Parameters</a>
          </h4>
<p id="section-2.9.2-1">The data volume model parameters together estimate both the volume of in-flight data required to reach the full bandwidth available to the flow (BBR.max_inflight), and the maximum volume of data that is consistent with the queue pressure objective (cwnd).<a href="#section-2.9.2-1" class="pilcrow">¶</a></p>
<p id="section-2.9.2-2">BBR.min_rtt: The windowed minimum round-trip time sample measured over the last MinRTTFilterLen = 10 seconds. This attempts to estimate the two-way propagation delay of the network path when all connections sharing a bottleneck are using BBR, but also allows BBR to estimate the value required for a bdp estimate that allows full throughput if there are legacy loss-based Reno or CUBIC flows sharing the bottleneck.<a href="#section-2.9.2-2" class="pilcrow">¶</a></p>
<p id="section-2.9.2-3">BBR.bdp: The estimate of the network path's BDP (Bandwidth-Delay Product), computed as: BBR.bdp = BBR.bw * BBR.min_rtt.<a href="#section-2.9.2-3" class="pilcrow">¶</a></p>
<p id="section-2.9.2-4">BBR.extra_acked: A volume of data that is the estimate of the recent degree of aggregation in the network path.<a href="#section-2.9.2-4" class="pilcrow">¶</a></p>
<p id="section-2.9.2-5">BBR.offload_budget: The estimate of the minimum volume of data necessary to achieve full throughput when using sender (TSO/GSO)  and receiver (LRO, GRO) host offload mechanisms.<a href="#section-2.9.2-5" class="pilcrow">¶</a></p>
<p id="section-2.9.2-6">BBR.max_inflight: The estimate of the volume of in-flight data required to fully utilize the bottleneck bandwidth available to the flow, based on the BDP estimate (BBR.bdp), the aggregation estimate (BBR.extra_acked), the offload budget (BBR.offload_budget), and BBRMinPipeCwnd.<a href="#section-2.9.2-6" class="pilcrow">¶</a></p>
<p id="section-2.9.2-7">BBR.inflight_hi: Analogous to BBR.bw_hi, the long-term maximum volume of in-flight data that the algorithm estimates will produce acceptable queue pressure, based on signals in the current or previous bandwidth probing cycle, as measured by loss. That is, if a flow is probing for bandwidth, and observes that sending a particular volume of in-flight data causes a loss rate higher than the loss rate objective, it sets inflight_hi to that volume of data. (Part of the long-term model.)<a href="#section-2.9.2-7" class="pilcrow">¶</a></p>
<p id="section-2.9.2-8">BBR.inflight_lo: Analogous to BBR.bw_lo, the short-term maximum volume of in-flight data that the algorithm estimates is safe for matching the current network path delivery process, based on any loss signals in the current bandwidth probing cycle. This is generally lower than  max_inflight or inflight_hi (thus the name). (Part of the short-term model.)<a href="#section-2.9.2-8" class="pilcrow">¶</a></p>
</section>
</div>
</section>
</div>
<div id="state-for-responding-to-congestion">
<section id="section-2.10">
        <h3 id="name-state-for-responding-to-con">
<a href="#section-2.10" class="section-number selfRef">2.10. </a><a href="#name-state-for-responding-to-con" class="section-name selfRef">State for Responding to Congestion</a>
        </h3>
<p id="section-2.10-1">BBR.bw_latest: a 1-round-trip max of delivered bandwidth (rs.delivery_rate).<a href="#section-2.10-1" class="pilcrow">¶</a></p>
<p id="section-2.10-2">BBR.inflight_latest: a 1-round-trip max of delivered volume of data (rs.delivered).<a href="#section-2.10-2" class="pilcrow">¶</a></p>
</section>
</div>
<div id="estimating-bbrmaxbw">
<section id="section-2.11">
        <h3 id="name-estimating-bbrmax_bw">
<a href="#section-2.11" class="section-number selfRef">2.11. </a><a href="#name-estimating-bbrmax_bw" class="section-name selfRef">Estimating BBR.max_bw</a>
        </h3>
<p id="section-2.11-1">BBR.MaxBwFilter: The filter for tracking the maximum recent rs.delivery_rate sample, for estimating BBR.max_bw.<a href="#section-2.11-1" class="pilcrow">¶</a></p>
<p id="section-2.11-2">MaxBwFilterLen: The filter window length for BBR.MaxBwFilter = 2 (representing up to 2 ProbeBW cycles, the current cycle and the previous full cycle).<a href="#section-2.11-2" class="pilcrow">¶</a></p>
<p id="section-2.11-3">BBR.cycle_count: The virtual time used by the BBR.max_bw filter window. Note that BBR.cycle_count only needs to be tracked with a single bit, since the BBR.MaxBwFilter only needs to track samples from two time slots: the previous ProbeBW cycle and the current ProbeBW cycle.<a href="#section-2.11-3" class="pilcrow">¶</a></p>
</section>
</div>
<div id="estimating-bbrextraacked">
<section id="section-2.12">
        <h3 id="name-estimating-bbrextra_acked">
<a href="#section-2.12" class="section-number selfRef">2.12. </a><a href="#name-estimating-bbrextra_acked" class="section-name selfRef">Estimating BBR.extra_acked</a>
        </h3>
<p id="section-2.12-1">BBR.extra_acked_interval_start: the start of the time interval for estimating the excess amount of data acknowledged due to aggregation effects.<a href="#section-2.12-1" class="pilcrow">¶</a></p>
<p id="section-2.12-2">BBR.extra_acked_delivered: the volume of data marked as delivered since BBR.extra_acked_interval_start.<a href="#section-2.12-2" class="pilcrow">¶</a></p>
<p id="section-2.12-3">BBR.ExtraACKedFilter: the max filter tracking the recent maximum degree of aggregation in the path.<a href="#section-2.12-3" class="pilcrow">¶</a></p>
<p id="section-2.12-4">BBRExtraAckedFilterLen = The window length of the BBR.ExtraACKedFilter max filter window: 10  (in units of packet-timed round trips).<a href="#section-2.12-4" class="pilcrow">¶</a></p>
</section>
</div>
<div id="startup-parameters-and-state">
<section id="section-2.13">
        <h3 id="name-startup-parameters-and-stat">
<a href="#section-2.13" class="section-number selfRef">2.13. </a><a href="#name-startup-parameters-and-stat" class="section-name selfRef">Startup Parameters and State</a>
        </h3>
<p id="section-2.13-1">BBR.filled_pipe: A boolean that records whether BBR estimates that it has ever fully utilized its available bandwidth ("filled the pipe").<a href="#section-2.13-1" class="pilcrow">¶</a></p>
<p id="section-2.13-2">BBR.full_bw: A recent baseline BBR.max_bw to estimate if BBR has "filled the pipe" in Startup.<a href="#section-2.13-2" class="pilcrow">¶</a></p>
<p id="section-2.13-3">BBR.full_bw_count: The number of non-app-limited round trips without large increases in BBR.full_bw.<a href="#section-2.13-3" class="pilcrow">¶</a></p>
</section>
</div>
<div id="probertt-and-minrtt-parameters-and-state">
<section id="section-2.14">
        <h3 id="name-probertt-and-min_rtt-parame">
<a href="#section-2.14" class="section-number selfRef">2.14. </a><a href="#name-probertt-and-min_rtt-parame" class="section-name selfRef">ProbeRTT and min_rtt Parameters and State</a>
        </h3>
<div id="parameters-for-estimating-bbrminrtt">
<section id="section-2.14.1">
          <h4 id="name-parameters-for-estimating-b">
<a href="#section-2.14.1" class="section-number selfRef">2.14.1. </a><a href="#name-parameters-for-estimating-b" class="section-name selfRef">Parameters for Estimating BBR.min_rtt</a>
          </h4>
<p id="section-2.14.1-1">BBR.min_rtt_stamp: The wall clock time at which the current BBR.min_rtt sample was obtained.<a href="#section-2.14.1-1" class="pilcrow">¶</a></p>
<p id="section-2.14.1-2">MinRTTFilterLen: A constant specifying the length of the BBR.min_rtt min filter window, MinRTTFilterLen is 10 secs.<a href="#section-2.14.1-2" class="pilcrow">¶</a></p>
</section>
</div>
<div id="parameters-for-scheduling-probertt">
<section id="section-2.14.2">
          <h4 id="name-parameters-for-scheduling-p">
<a href="#section-2.14.2" class="section-number selfRef">2.14.2. </a><a href="#name-parameters-for-scheduling-p" class="section-name selfRef">Parameters for Scheduling ProbeRTT</a>
          </h4>
<p id="section-2.14.2-1">BBRProbeRTTCwndGain = A constant specifying the gain value for calculating the cwnd during ProbeRTT: 0.5 (meaning that ProbeRTT attempts to reduce in-flight data to 50% of the estimated BDP).<a href="#section-2.14.2-1" class="pilcrow">¶</a></p>
<p id="section-2.14.2-2">ProbeRTTDuration: A constant specifying the minimum duration for which ProbeRTT state holds inflight to BBRMinPipeCwnd or fewer packets: 200 ms.<a href="#section-2.14.2-2" class="pilcrow">¶</a></p>
<p id="section-2.14.2-3">ProbeRTTInterval: A constant specifying the minimum time interval between ProbeRTT states: 5 secs.<a href="#section-2.14.2-3" class="pilcrow">¶</a></p>
<p id="section-2.14.2-4">BBR.probe_rtt_min_delay: The minimum RTT sample recorded in the last ProbeRTTInterval.<a href="#section-2.14.2-4" class="pilcrow">¶</a></p>
<p id="section-2.14.2-5">BBR.probe_rtt_min_stamp: The wall clock time at which the current BBR.probe_rtt_min_delay sample was obtained.<a href="#section-2.14.2-5" class="pilcrow">¶</a></p>
<p id="section-2.14.2-6">BBR.probe_rtt_expired: A boolean recording whether the BBR.probe_rtt_min_delay has expired and is due for a refresh with an application idle period or a transition into ProbeRTT state.<a href="#section-2.14.2-6" class="pilcrow">¶</a></p>
<p id="section-2.14.2-7">The keywords "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in [RFC2119].<a href="#section-2.14.2-7" class="pilcrow">¶</a></p>
</section>
</div>
</section>
</div>
</section>
</div>
<div id="design-overview">
<section id="section-3">
      <h2 id="name-design-overview">
<a href="#section-3" class="section-number selfRef">3. </a><a href="#name-design-overview" class="section-name selfRef">Design Overview</a>
      </h2>
<div id="high-level-design-goals">
<section id="section-3.1">
        <h3 id="name-high-level-design-goals">
<a href="#section-3.1" class="section-number selfRef">3.1. </a><a href="#name-high-level-design-goals" class="section-name selfRef">High-Level Design Goals</a>
        </h3>
<p id="section-3.1-1">The high-level goal of BBR is to achieve both:<a href="#section-3.1-1" class="pilcrow">¶</a></p>
<ol start="1" type="1" class="normal type-1" id="section-3.1-2">
<li id="section-3.1-2.1">
            <p id="section-3.1-2.1.1">The full throughput (or approximate fair share thereof) available to a flow<a href="#section-3.1-2.1.1" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-3.1-2.1.2.1">Achieved in a fast and scalable manner (using bandwidth in O(log(BDP)) time).<a href="#section-3.1-2.1.2.1" class="pilcrow">¶</a>
</li>
              <li class="normal" id="section-3.1-2.1.2.2">Achieved with average packet loss rates of up to 1%.<a href="#section-3.1-2.1.2.2" class="pilcrow">¶</a>
</li>
            </ul>
</li>
          <li id="section-3.1-2.2">Low queue pressure (low queuing delay and low packet loss).<a href="#section-3.1-2.2" class="pilcrow">¶</a>
</li>
        </ol>
<p id="section-3.1-3">These goals are in tension: sending faster improves the odds of achieving (1) but reduces the odds of achieving (2), while sending slower improves the odds of achieving (2) but reduces the odds of achieving (1). Thus the algorithm cannot maximize throughput or minimize queue pressure independently, and must jointly optimize both.<a href="#section-3.1-3" class="pilcrow">¶</a></p>
<p id="section-3.1-4">To try to achieve these goals, and seek an operating point with high throughput and low delay [K79] [GK81], BBR aims to adapt its sending process to match the network delivery process, in two dimensions:<a href="#section-3.1-4" class="pilcrow">¶</a></p>
<ol start="1" type="1" class="normal type-1" id="section-3.1-5">
<li id="section-3.1-5.1">data rate: the rate at which the flow sends data should ideally match the rate at which the network delivers the flow's data (the available bottleneck bandwidth)<a href="#section-3.1-5.1" class="pilcrow">¶</a>
</li>
          <li id="section-3.1-5.2">data volume: the amount of unacknowledged data in flight in the network should ideally match the bandwidth-delay product (BDP) of the path<a href="#section-3.1-5.2" class="pilcrow">¶</a>
</li>
        </ol>
<p id="section-3.1-6">Both the control of the data rate (via the pacing rate) and data volume (directly via the congestion window or cwnd; and indirectly via the pacing rate) are important. A mismatch in either dimension can cause the sender to fail to meet its high-level design goals:<a href="#section-3.1-6" class="pilcrow">¶</a></p>
<ol start="1" type="1" class="normal type-1" id="section-3.1-7">
<li id="section-3.1-7.1">volume mismatch: If a sender perfectly matches its sending rate to the available bandwidth, but its volume of in-flight data exceeds the BDP, then the sender can maintain a large standing queue, increasing network latency and risking packet loss.<a href="#section-3.1-7.1" class="pilcrow">¶</a>
</li>
          <li id="section-3.1-7.2">rate mismatch: If a sender's volume of in-flight data matches the BDP perfectly but its sending rate exceeds the available bottleneck bandwidth (e.g. the sender transmits a BDP of data in an unpaced fashion, at the sender's link rate), then up to a full BDP of data can burst into the bottleneck queue, causing high delay and/or high loss.<a href="#section-3.1-7.2" class="pilcrow">¶</a>
</li>
        </ol>
</section>
</div>
<div id="algorithm-overview">
<section id="section-3.2">
        <h3 id="name-algorithm-overview">
<a href="#section-3.2" class="section-number selfRef">3.2. </a><a href="#name-algorithm-overview" class="section-name selfRef">Algorithm Overview</a>
        </h3>
<p id="section-3.2-1">Based on the rationale above, BBR tries to spend most of its time matching its sending process (data rate and data volume) to the network path's delivery process. To do this, it explores the 2-dimensional control parameter space of (1) data rate ("bandwidth" or "throughput") and (2) data volume ("in-flight data"), with a goal of finding the maximum values of each control parameter that are consistent with its objective for queue pressure.<a href="#section-3.2-1" class="pilcrow">¶</a></p>
<p id="section-3.2-2">Depending on what signals a given network path manifests at a given time, the objective for queue pressure is measured in terms of the most strict among:<a href="#section-3.2-2" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-3.2-3.1">the amount of data that is estimated to be queued in the bottleneck buffer (data_in_flight - estimated_BDP): the objective is to maintain this amount at or below 1.5 * estimated_BDP<a href="#section-3.2-3.1" class="pilcrow">¶</a>
</li>
          <li class="normal" id="section-3.2-3.2">the packet loss rate: the objective is a maximum per-round-trip packet loss rate of BBRLossThresh=2% (and an average packet loss rate considerably lower)<a href="#section-3.2-3.2" class="pilcrow">¶</a>
</li>
        </ul>
</section>
</div>
<div id="state-machine-overview">
<section id="section-3.3">
        <h3 id="name-state-machine-overview">
<a href="#section-3.3" class="section-number selfRef">3.3. </a><a href="#name-state-machine-overview" class="section-name selfRef">State Machine Overview</a>
        </h3>
<p id="section-3.3-1">BBR varies its control parameters with a simple state machine that aims for high throughput, low latency, and an approximately fair sharing of bandwidth, while maintaining an up-to-date model of the network path.<a href="#section-3.3-1" class="pilcrow">¶</a></p>
<p id="section-3.3-2">A BBR flow starts in the Startup state, and ramps up its sending rate quickly, to rapidly estimate the maximum available bandwidth (BBR.max_bw). When it estimates the bottleneck bandwidth has been fully utilized, it enters the Drain state to drain the estimated queue. In steady state a BBR flow mostly uses the ProbeBW states, to periodically briefly send faster to probe for higher capacity and then briefly send slower to try to drain any resulting queue. If needed, it briefly enters the ProbeRTT state, to lower the sending rate to probe for lower BBR.min_rtt samples. The detailed behavior for each state is described below.<a href="#section-3.3-2" class="pilcrow">¶</a></p>
</section>
</div>
<div id="network-path-model-overview">
<section id="section-3.4">
        <h3 id="name-network-path-model-overview">
<a href="#section-3.4" class="section-number selfRef">3.4. </a><a href="#name-network-path-model-overview" class="section-name selfRef">Network Path Model Overview</a>
        </h3>
<div id="high-level-design-goals-for-the-network-path-model">
<section id="section-3.4.1">
          <h4 id="name-high-level-design-goals-for">
<a href="#section-3.4.1" class="section-number selfRef">3.4.1. </a><a href="#name-high-level-design-goals-for" class="section-name selfRef">High-Level Design Goals for the Network Path Model</a>
          </h4>
<p id="section-3.4.1-1">At a high level, the BBR model is trying to reflect two aspects of the network path:<a href="#section-3.4.1-1" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-3.4.1-2.1">Model what's required for achieving full throughput: Estimate the minimum data rate and data volume required to fully utilize the fair share of the bottleneck bandwidth available to the flow. This must incorporate estimates of the maximum available bandwidth (BBR.max_bw), the BDP of the path (BBR.bdp), and the requirements of any offload features on the end hosts or mechanisms on the network path that produce aggregation effects (summing up to BBR.max_inflight).<a href="#section-3.4.1-2.1" class="pilcrow">¶</a>
</li>
            <li class="normal" id="section-3.4.1-2.2">Model what's permitted for achieving low queue pressure: Estimate the maximum data rate (BBR.bw) and data volume (cwnd) consistent with the queue pressure objective, as measured by the estimated degree of queuing and packet loss.<a href="#section-3.4.1-2.2" class="pilcrow">¶</a>
</li>
          </ul>
<p id="section-3.4.1-3">Note that those two aspects are in tension: the highest throughput is available to the flow when it sends as fast as possible and occupies as many bottleneck buffer slots as possible; the lowest que pressure is achieved by the flow when it sends as slow as possible and occupies as few bottleneck buffer slots as possible. To resolve the tension, the algorithm aims to achieve the maximum throughput achievable while still meeting the queue pressure objective.<a href="#section-3.4.1-3" class="pilcrow">¶</a></p>
</section>
</div>
<div id="time-scales-for-the-network-model">
<section id="section-3.4.2">
          <h4 id="name-time-scales-for-the-network">
<a href="#section-3.4.2" class="section-number selfRef">3.4.2. </a><a href="#name-time-scales-for-the-network" class="section-name selfRef">Time Scales for the Network Model</a>
          </h4>
<p id="section-3.4.2-1">At a high level, the BBR model is trying to reflect the properties of the network path on two different time scales:<a href="#section-3.4.2-1" class="pilcrow">¶</a></p>
<div id="long-term-model">
<section id="section-3.4.2.1">
            <h5 id="name-long-term-model">
<a href="#section-3.4.2.1" class="section-number selfRef">3.4.2.1. </a><a href="#name-long-term-model" class="section-name selfRef">Long-term model</a>
            </h5>
<p id="section-3.4.2.1-1">One goal is for BBR to maintain high average utilization of the fair share of the available bandwidth, over long time intervals. This requires estimates of the path's data rate and volume capacities that are robust over long time intervals. This means being robust to congestion signals that may be noisy or may reflect short-term congestion that has already abated by the time an ACK arrives. This also means providing a robust history of the best recently-achievable performance on the path so that the flow can quickly and robustly aim to re-probe that level of performance whenever it decides to probe the capacity of the path.<a href="#section-3.4.2.1-1" class="pilcrow">¶</a></p>
</section>
</div>
<div id="short-term-model">
<section id="section-3.4.2.2">
            <h5 id="name-short-term-model">
<a href="#section-3.4.2.2" class="section-number selfRef">3.4.2.2. </a><a href="#name-short-term-model" class="section-name selfRef">Short-term model</a>
            </h5>
<p id="section-3.4.2.2-1">A second goal of BBR is to react to every congestion signal, including loss, as if it may indicate a persistent/long-term increase in congestion and/or decrease in the bandwidth available to the flow, because that may indeed be the case.<a href="#section-3.4.2.2-1" class="pilcrow">¶</a></p>
</section>
</div>
<div id="time-scale-strategy">
<section id="section-3.4.2.3">
            <h5 id="name-time-scale-strategy">
<a href="#section-3.4.2.3" class="section-number selfRef">3.4.2.3. </a><a href="#name-time-scale-strategy" class="section-name selfRef">Time Scale Strategy</a>
            </h5>
<p id="section-3.4.2.3-1">BBR sequentially alternates between spending most of its time using short-term models to conservatively respect all congestion signals in case they represent persistent congestion, but periodically using its long-term model to robustly probe the limits of the available path capacity in case the congestion has abated and more capacity is available.<a href="#section-3.4.2.3-1" class="pilcrow">¶</a></p>
</section>
</div>
</section>
</div>
</section>
</div>
<div id="control-parameter-overview">
<section id="section-3.5">
        <h3 id="name-control-parameter-overview">
<a href="#section-3.5" class="section-number selfRef">3.5. </a><a href="#name-control-parameter-overview" class="section-name selfRef">Control Parameter Overview</a>
        </h3>
<p id="section-3.5-1">BBR uses its model to control the connection's sending behavior. Rather than using a single control parameter, like the cwnd parameter that limits the volume of in-flight data in the Reno and CUBIC congestion control algorithms, BBR uses three distinct control parameters:<a href="#section-3.5-1" class="pilcrow">¶</a></p>
<ol start="1" type="1" class="normal type-1" id="section-3.5-2">
<li id="section-3.5-2.1">pacing rate: the maximum rate at which BBR sends data.<a href="#section-3.5-2.1" class="pilcrow">¶</a>
</li>
          <li id="section-3.5-2.2">send quantum: the maximum size of any aggregate that the transport sender implementation may need to transmit as a unit to amortize per-packet transmission overheads.<a href="#section-3.5-2.2" class="pilcrow">¶</a>
</li>
          <li id="section-3.5-2.3">cwnd: the maximum volume of data BBR allows in-flight in the network at any time.<a href="#section-3.5-2.3" class="pilcrow">¶</a>
</li>
        </ol>
</section>
</div>
<div id="environment-and-usage">
<section id="section-3.6">
        <h3 id="name-environment-and-usage">
<a href="#section-3.6" class="section-number selfRef">3.6. </a><a href="#name-environment-and-usage" class="section-name selfRef">Environment and Usage</a>
        </h3>
<p id="section-3.6-1">BBR is a congestion control algorithm that is agnostic to transport-layer and link-layer technologies, requires only sender-side changes, and does not require changes in the network. Open source implementations of BBR are available for the TCP [RFC793] and QUIC [RFC9000] transport protocols, and these implementations have been used in production for a large volume of Internet traffic. An open source implementation of BBR is also available for DCCP [RFC4340] [draft-romo-iccrg-ccid5].<a href="#section-3.6-1" class="pilcrow">¶</a></p>
</section>
</div>
</section>
</div>
<div id="detailed-algorithm">
<section id="section-4">
      <h2 id="name-detailed-algorithm">
<a href="#section-4" class="section-number selfRef">4. </a><a href="#name-detailed-algorithm" class="section-name selfRef">Detailed Algorithm</a>
      </h2>
<div id="state-machine">
<section id="section-4.1">
        <h3 id="name-state-machine">
<a href="#section-4.1" class="section-number selfRef">4.1. </a><a href="#name-state-machine" class="section-name selfRef">State Machine</a>
        </h3>
<p id="section-4.1-1">BBR implements a state machine that uses the network path model to guide its decisions, and the control parameters to enact its decisions.<a href="#section-4.1-1" class="pilcrow">¶</a></p>
<div id="state-transition-diagram">
<section id="section-4.1.1">
          <h4 id="name-state-transition-diagram">
<a href="#section-4.1.1" class="section-number selfRef">4.1.1. </a><a href="#name-state-transition-diagram" class="section-name selfRef">State Transition Diagram</a>
          </h4>
<p id="section-4.1.1-1">The following state transition diagram summarizes the flow of control and the relationship between the different states:<a href="#section-4.1.1-1" class="pilcrow">¶</a></p>
<div class="alignLeft art-text artwork" id="section-4.1.1-2">
<pre>
             |
             V
    +---&gt; Startup  ------------+
    |        |                 |
    |        V                 |
    |     Drain  --------------+
    |        |                 |
    |        V                 |
    +---&gt; ProbeBW_DOWN  -------+
    | ^      |                 |
    | |      V                 |
    | |   ProbeBW_CRUISE ------+
    | |      |                 |
    | |      V                 |
    | |   ProbeBW_REFILL  -----+
    | |      |                 |
    | |      V                 |
    | |   ProbeBW_UP  ---------+
    | |      |                 |
    | +------+                 |
    |                          |
    +---- ProbeRTT &lt;-----------+
</pre><a href="#section-4.1.1-2" class="pilcrow">¶</a>
</div>
</section>
</div>
<div id="state-machine-operation-overview">
<section id="section-4.1.2">
          <h4 id="name-state-machine-operation-ove">
<a href="#section-4.1.2" class="section-number selfRef">4.1.2. </a><a href="#name-state-machine-operation-ove" class="section-name selfRef">State Machine Operation Overview</a>
          </h4>
<p id="section-4.1.2-1">When starting up, BBR probes to try to quickly build a model of the network path; to adapt to later changes to the path or its traffic, BBR must continue to probe to update its model. If the available bottleneck bandwidth increases, BBR must send faster to discover this. Likewise, if the round-trip propagation delay changes, this changes the BDP, and thus BBR must send slower to get inflight below the new BDP in order to measure the new BBR.min_rtt. Thus, BBR's state machine runs periodic, sequential experiments, sending faster to check for BBR.bw increases or sending slower to yield bandwidth, drain the queue, and check for BBR.min_rtt decreases. The frequency, magnitude, duration, and structure of these experiments differ depending on what's already known (startup or steady-state) and application sending behavior (intermittent or continuous).<a href="#section-4.1.2-1" class="pilcrow">¶</a></p>
<p id="section-4.1.2-2">This state machine has several goals:<a href="#section-4.1.2-2" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-4.1.2-3.1">Achieve high throughput by efficiently utilizing available bandwidth.<a href="#section-4.1.2-3.1" class="pilcrow">¶</a>
</li>
            <li class="normal" id="section-4.1.2-3.2">Achieve low latency and packet loss rates by keeping queues bounded and small.<a href="#section-4.1.2-3.2" class="pilcrow">¶</a>
</li>
            <li class="normal" id="section-4.1.2-3.3">Share bandwidth with other flows in an approximately fair manner.<a href="#section-4.1.2-3.3" class="pilcrow">¶</a>
</li>
            <li class="normal" id="section-4.1.2-3.4">Feed samples to the model estimators to refresh and update the model.<a href="#section-4.1.2-3.4" class="pilcrow">¶</a>
</li>
          </ul>
</section>
</div>
<div id="state-machine-tactics">
<section id="section-4.1.3">
          <h4 id="name-state-machine-tactics">
<a href="#section-4.1.3" class="section-number selfRef">4.1.3. </a><a href="#name-state-machine-tactics" class="section-name selfRef">State Machine Tactics</a>
          </h4>
<p id="section-4.1.3-1">In the BBR framework, at any given time the sender can choose one of the following tactics:<a href="#section-4.1.3-1" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-4.1.3-2.1">Acceleration: Send faster then the network is delivering data: to probe the maximum bandwidth available to the flow<a href="#section-4.1.3-2.1" class="pilcrow">¶</a>
</li>
            <li class="normal" id="section-4.1.3-2.2">Cruising: Send at the same rate the network is delivering data: try to match the sending rate to the flow's current available bandwidth, to try to achieve high utilization of the available bandwidth without increasing queue pressure<a href="#section-4.1.3-2.2" class="pilcrow">¶</a>
</li>
            <li class="normal" id="section-4.1.3-2.3">
              <p id="section-4.1.3-2.3.1">Deceleration: Send slower than the network is delivering data: to reduce the amount of data in flight, with a number of overlapping motivations:<a href="#section-4.1.3-2.3.1" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-4.1.3-2.3.2.1">Reducing queuing delay: to reduce queuing delay, to reduce latency for request/response cross-traffic (e.g. RPC, web traffic).<a href="#section-4.1.3-2.3.2.1" class="pilcrow">¶</a>
</li>
                <li class="normal" id="section-4.1.3-2.3.2.2">Reducing packet loss: to reduce packet loss, to reduce tail latency for request/response cross-traffic (e.g. RPC, web traffic) and improve coexistence with Reno/CUBIC.<a href="#section-4.1.3-2.3.2.2" class="pilcrow">¶</a>
</li>
                <li class="normal" id="section-4.1.3-2.3.2.3">Probing BBR.min_rtt: to probe the path's BBR.min_rtt<a href="#section-4.1.3-2.3.2.3" class="pilcrow">¶</a>
</li>
                <li class="normal" id="section-4.1.3-2.3.2.4">Bandwidth convergence: to aid bandwidth fairness convergence, by leaving unused capacity in the bottleneck link or bottleneck buffer, to allow other flows that may have lower sending rates to discover and utilize the unused capacity<a href="#section-4.1.3-2.3.2.4" class="pilcrow">¶</a>
</li>
                <li class="normal" id="section-4.1.3-2.3.2.5">Burst tolerance: to allow bursty arrivals of cross-traffic (e.g. short web or RPC requests) to be able to share the bottleneck link without causing excessive queuing delay or packet loss<a href="#section-4.1.3-2.3.2.5" class="pilcrow">¶</a>
</li>
              </ul>
</li>
          </ul>
<p id="section-4.1.3-3">Throughout the lifetime of a BBR flow, it sequentially cycles through all three tactics, to measure the network path and try to optimize its operating point.<a href="#section-4.1.3-3" class="pilcrow">¶</a></p>
<p id="section-4.1.3-4">BBR's state machine uses two control mechanisms. Primarily, it uses the pacing_gain (see the "Pacing Rate" section), which controls how fast packets are sent relative to BBR.bw. A pacing_gain &gt; 1 decreases inter-packet time and increases inflight. A pacing_gain &lt; 1 has the opposite effect, increasing inter-packet time and while aiming to decrease inflight. Second, if the state machine needs to quickly reduce inflight to a particular absolute value, it uses the cwnd.<a href="#section-4.1.3-4" class="pilcrow">¶</a></p>
</section>
</div>
</section>
</div>
<div id="algorithm-organization">
<section id="section-4.2">
        <h3 id="name-algorithm-organization">
<a href="#section-4.2" class="section-number selfRef">4.2. </a><a href="#name-algorithm-organization" class="section-name selfRef">Algorithm Organization</a>
        </h3>
<p id="section-4.2-1">The BBR algorithm is an event-driven algorithm that executes steps upon the following events: connection initialization, upon each ACK, upon the transmission of each quantum, and upon loss detection events. All of the sub-steps invoked referenced below are described below.<a href="#section-4.2-1" class="pilcrow">¶</a></p>
<div id="initialization">
<section id="section-4.2.1">
          <h4 id="name-initialization">
<a href="#section-4.2.1" class="section-number selfRef">4.2.1. </a><a href="#name-initialization" class="section-name selfRef">Initialization</a>
          </h4>
<p id="section-4.2.1-1">Upon transport connection initialization, BBR executes its initialization steps:<a href="#section-4.2.1-1" class="pilcrow">¶</a></p>
<div class="alignLeft art-text artwork" id="section-4.2.1-2">
<pre>
  BBROnInit():
    init_windowed_max_filter(filter=BBR.MaxBwFilter, value=0, time=0)
    BBR.min_rtt = SRTT ? SRTT : Inf
    BBR.min_rtt_stamp = Now()
    BBR.probe_rtt_done_stamp = 0
    BBR.probe_rtt_round_done = false
    BBR.prior_cwnd = 0
    BBR.idle_restart = false
    BBR.extra_acked_interval_start = Now()
    BBR.extra_acked_delivered = 0
    BBRResetCongestionSignals()
    BBRResetLowerBounds()
    BBRInitRoundCounting()
    BBRInitFullPipe()
    BBRInitPacingRate()
    BBREnterStartup()
</pre><a href="#section-4.2.1-2" class="pilcrow">¶</a>
</div>
</section>
</div>
<div id="per-transmit-steps">
<section id="section-4.2.2">
          <h4 id="name-per-transmit-steps">
<a href="#section-4.2.2" class="section-number selfRef">4.2.2. </a><a href="#name-per-transmit-steps" class="section-name selfRef">Per-Transmit Steps</a>
          </h4>
<p id="section-4.2.2-1">When transmitting, BBR merely needs to check for the case where the flow is restarting from idle:<a href="#section-4.2.2-1" class="pilcrow">¶</a></p>
<div class="alignLeft art-text artwork" id="section-4.2.2-2">
<pre>
  BBROnTransmit():
    BBRHandleRestartFromIdle()
</pre><a href="#section-4.2.2-2" class="pilcrow">¶</a>
</div>
</section>
</div>
<div id="per-ack-steps">
<section id="section-4.2.3">
          <h4 id="name-per-ack-steps">
<a href="#section-4.2.3" class="section-number selfRef">4.2.3. </a><a href="#name-per-ack-steps" class="section-name selfRef">Per-ACK Steps</a>
          </h4>
<p id="section-4.2.3-1">On every ACK, the BBR algorithm executes the following BBRUpdateOnACK() steps in order to update its network path model, update its state machine, and adjust its control parameters to adapt to the updated model:<a href="#section-4.2.3-1" class="pilcrow">¶</a></p>
<div class="alignLeft art-text artwork" id="section-4.2.3-2">
<pre>
  BBRUpdateOnACK():
    BBRUpdateModelAndState()
    BBRUpdateControlParameters()

  BBRUpdateModelAndState():
    BBRUpdateLatestDeliverySignals()
    BBRUpdateCongestionSignals()
    BBRUpdateACKAggregation()
    BBRCheckStartupDone()
    BBRCheckDrain()
    BBRUpdateProbeBWCyclePhase()
    BBRUpdateMinRTT()
    BBRCheckProbeRTT()
    BBRAdvanceLatestDeliverySignals()
    BBRBoundBWForModel()

  BBRUpdateControlParameters():
    BBRSetPacingRate()
    BBRSetSendQuantum()
    BBRSetCwnd()
</pre><a href="#section-4.2.3-2" class="pilcrow">¶</a>
</div>
</section>
</div>
<div id="per-loss-steps">
<section id="section-4.2.4">
          <h4 id="name-per-loss-steps">
<a href="#section-4.2.4" class="section-number selfRef">4.2.4. </a><a href="#name-per-loss-steps" class="section-name selfRef">Per-Loss Steps</a>
          </h4>
<p id="section-4.2.4-1">On every packet loss event, where some sequence range "packet" is marked lost, the BBR algorithm executes the following BBRUpdateOnLoss() steps in order to update its network path model<a href="#section-4.2.4-1" class="pilcrow">¶</a></p>
<div class="alignLeft art-text artwork" id="section-4.2.4-2">
<pre>
  BBRUpdateOnLoss(packet):
    BBRHandleLostPacket(packet)
</pre><a href="#section-4.2.4-2" class="pilcrow">¶</a>
</div>
</section>
</div>
</section>
</div>
<div id="state-machine-operation">
<section id="section-4.3">
        <h3 id="name-state-machine-operation">
<a href="#section-4.3" class="section-number selfRef">4.3. </a><a href="#name-state-machine-operation" class="section-name selfRef">State Machine Operation</a>
        </h3>
<div id="startup">
<section id="section-4.3.1">
          <h4 id="name-startup">
<a href="#section-4.3.1" class="section-number selfRef">4.3.1. </a><a href="#name-startup" class="section-name selfRef">Startup</a>
          </h4>
<div id="startup-dynamics">
<section id="section-4.3.1.1">
            <h5 id="name-startup-dynamics">
<a href="#section-4.3.1.1" class="section-number selfRef">4.3.1.1. </a><a href="#name-startup-dynamics" class="section-name selfRef">Startup Dynamics</a>
            </h5>
<p id="section-4.3.1.1-1">When a BBR flow starts up, it performs its first (and most rapid) sequential probe/drain process in the Startup and Drain states. Network link bandwidths currently span a range of at least 11 orders of magnitude, from a few bps to 200 Gbps. To quickly learn BBR.max_bw, given this huge range to explore, BBR's Startup state does an exponential search of the rate space, doubling the sending rate each round. This finds BBR.max_bw in O(log_2(BDP)) round trips.<a href="#section-4.3.1.1-1" class="pilcrow">¶</a></p>
<p id="section-4.3.1.1-2">To achieve this rapid probing in the smoothest possible fashion, in Startup BBR uses the minimum gain values that will allow the sending rate to double each round: in Startup BBR sets BBR.pacing_gain to BBRStartupPacingGain (2.77) [BBRStartupPacingGain] and BBR.cwnd_gain to BBRStartupCwndGain (2).<a href="#section-4.3.1.1-2" class="pilcrow">¶</a></p>
<p id="section-4.3.1.1-3">When initializing a connection, or upon any later entry into Startup mode, BBR executes the following BBREnterStartup() steps:<a href="#section-4.3.1.1-3" class="pilcrow">¶</a></p>
<div class="alignLeft art-text artwork" id="section-4.3.1.1-4">
<pre>
  BBREnterStartup():
    BBR.state = Startup
    BBR.pacing_gain = BBRStartupPacingGain
    BBR.cwnd_gain = BBRStartupCwndGain
</pre><a href="#section-4.3.1.1-4" class="pilcrow">¶</a>
</div>
<p id="section-4.3.1.1-5">As BBR grows its sending rate rapidly, it obtains higher delivery rate samples, BBR.max_bw increases, and the pacing rate and cwnd both adapt by smoothly growing in proportion. Once the pipe is full, a queue typically forms, but the cwnd_gain bounds any queue to (cwnd_gain - 1) * estimated_BDP, which is approximately (2.77 - 1) * estimated_BDP = 1.77 * estimated_BDP. The immediately following Drain state is designed to quickly drain that queue.<a href="#section-4.3.1.1-5" class="pilcrow">¶</a></p>
<p id="section-4.3.1.1-6">During Startup, BBR estimates whether the pipe is full using two estimators. The first looks for a plateau in the BBR.max_bw estimate. The second looks for packet loss. The following subsections discuss these estimators.<a href="#section-4.3.1.1-6" class="pilcrow">¶</a></p>
<div class="alignLeft art-text artwork" id="section-4.3.1.1-7">
<pre>
  BBRCheckStartupDone():
    BBRCheckStartupFullBandwidth()
    BBRCheckStartupHighLoss()
    if (BBR.state == Startup and BBR.filled_pipe)
      BBREnterDrain()
</pre><a href="#section-4.3.1.1-7" class="pilcrow">¶</a>
</div>
</section>
</div>
<div id="exiting-startup-based-on-bandwidth-plateau">
<section id="section-4.3.1.2">
            <h5 id="name-exiting-startup-based-on-ba">
<a href="#section-4.3.1.2" class="section-number selfRef">4.3.1.2. </a><a href="#name-exiting-startup-based-on-ba" class="section-name selfRef">Exiting Startup Based on Bandwidth Plateau</a>
            </h5>
<p id="section-4.3.1.2-1">During Startup, BBR estimates whether the pipe is full by looking for a plateau in the BBR.max_bw estimate. The output of this "full pipe" estimator is tracked in BBR.filled_pipe, a boolean that records whether BBR estimates that it has ever fully utilized its available bandwidth ("filled the pipe"). If BBR notices that there are several (three) rounds where attempts to double the delivery rate actually result in little increase (less than 25 percent), then it estimates that it has reached BBR.max_bw, sets BBR.filled_pipe to true, exits Startup and enters Drain.<a href="#section-4.3.1.2-1" class="pilcrow">¶</a></p>
<p id="section-4.3.1.2-2">Upon connection initialization the full pipe estimator runs:<a href="#section-4.3.1.2-2" class="pilcrow">¶</a></p>
<div class="alignLeft art-text artwork" id="section-4.3.1.2-3">
<pre>
  BBRInitFullPipe():
    BBR.filled_pipe = false
    BBR.full_bw = 0
    BBR.full_bw_count = 0
</pre><a href="#section-4.3.1.2-3" class="pilcrow">¶</a>
</div>
<p id="section-4.3.1.2-4">Once per round trip, upon an ACK that acknowledges new data, and when the delivery rate sample is not application-limited (see [draft-cheng-iccrg-delivery-rate-estimation]), BBR runs the "full pipe" estimator, if needed:<a href="#section-4.3.1.2-4" class="pilcrow">¶</a></p>
<div class="alignLeft art-text artwork" id="section-4.3.1.2-5">
<pre>
  BBRCheckStartupFullBandwidth():
    if BBR.filled_pipe or
       !BBR.round_start or rs.is_app_limited
      return  /* no need to check for a full pipe now */
    if (BBR.max_bw &gt;= BBR.full_bw * 1.25)  /* still growing? */
      BBR.full_bw = BBR.max_bw    /* record new baseline level */
      BBR.full_bw_count = 0
      return
    BBR.full_bw_count++ /* another round w/o much growth */
    if (BBR.full_bw_count &gt;= 3)
      BBR.filled_pipe = true
</pre><a href="#section-4.3.1.2-5" class="pilcrow">¶</a>
</div>
<p id="section-4.3.1.2-6">BBR waits three rounds to have solid evidence that the sender is not detecting a delivery-rate plateau that was temporarily imposed by the receive window. Allowing three rounds provides time for the receiver's receive-window auto-tuning to open up the receive window and for the BBR sender to realize that BBR.max_bw should be higher: in the first round the receive-window auto-tuning algorithm grows the receive window; in the second round the sender fills the higher receive window; in the third round the sender gets higher delivery-rate samples. This three-round threshold was validated by YouTube experimental data.<a href="#section-4.3.1.2-6" class="pilcrow">¶</a></p>
</section>
</div>
<div id="exiting-startup-based-on-packet-loss">
<section id="section-4.3.1.3">
            <h5 id="name-exiting-startup-based-on-pa">
<a href="#section-4.3.1.3" class="section-number selfRef">4.3.1.3. </a><a href="#name-exiting-startup-based-on-pa" class="section-name selfRef">Exiting Startup Based on Packet Loss</a>
            </h5>
<p id="section-4.3.1.3-1">A second method BBR uses for estimating the bottleneck is full is by looking at sustained packet losses Specifically  for a case where the following criteria are all met:<a href="#section-4.3.1.3-1" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-4.3.1.3-2.1">The connection has been in fast recovery for at least one full round trip.<a href="#section-4.3.1.3-2.1" class="pilcrow">¶</a>
</li>
              <li class="normal" id="section-4.3.1.3-2.2">The loss rate over the time scale of a single full round trip exceeds BBRLossThresh (2%).<a href="#section-4.3.1.3-2.2" class="pilcrow">¶</a>
</li>
              <li class="normal" id="section-4.3.1.3-2.3">There are at least BBRStartupFullLossCnt=3 discontiguous sequence ranges lost in that round trip.<a href="#section-4.3.1.3-2.3" class="pilcrow">¶</a>
</li>
            </ul>
<p id="section-4.3.1.3-3">If these criteria are all met, then BBRCheckStartupHighLoss() sets BBR.filled_pipe = true and exits Startup and enters Drain.<a href="#section-4.3.1.3-3" class="pilcrow">¶</a></p>
<p id="section-4.3.1.3-4">The algorithm waits until all three criteria are met to filter out noise from burst losses, and to try to ensure the bottleneck is fully utilized on a sustained basis, and the full bottleneck bandwidth has been measured, before attempting to drain the level of in-flight data to the estimated BDP.<a href="#section-4.3.1.3-4" class="pilcrow">¶</a></p>
</section>
</div>
</section>
</div>
<div id="drain">
<section id="section-4.3.2">
          <h4 id="name-drain">
<a href="#section-4.3.2" class="section-number selfRef">4.3.2. </a><a href="#name-drain" class="section-name selfRef">Drain</a>
          </h4>
<p id="section-4.3.2-1">Upon exiting Startup, BBR enters its Drain state. In Drain, BBR aims to quickly drain any queue created in Startup by switching to a pacing_gain well below 1.0, until any estimated queue has been drained. It uses a pacing_gain that is the inverse of the value used during Startup, chosen to try to drain the queue in one round [BBRDrainPacingGain]:<a href="#section-4.3.2-1" class="pilcrow">¶</a></p>
<div class="alignLeft art-text artwork" id="section-4.3.2-2">
<pre>
  BBREnterDrain():
    BBR.state = Drain
    BBR.pacing_gain = 1/BBRStartupCwndGain  /* pace slowly */
    BBR.cwnd_gain = BBRStartupCwndGain      /* maintain cwnd */
</pre><a href="#section-4.3.2-2" class="pilcrow">¶</a>
</div>
<p id="section-4.3.2-3">In Drain, when the amount of data in flight is less than or equal to the estimated BDP, meaning BBR estimates that the queue has been fully drained, then BBR exits Drain and enters ProbeBW. To implement this, upon every ACK BBR executes:<a href="#section-4.3.2-3" class="pilcrow">¶</a></p>
<div class="alignLeft art-text artwork" id="section-4.3.2-4">
<pre>
  BBRCheckDrain():
    if (BBR.state == Drain and packets_in_flight &lt;= BBRInflight(1.0))
      BBREnterProbeBW()  /* BBR estimates the queue was drained */
</pre><a href="#section-4.3.2-4" class="pilcrow">¶</a>
</div>
</section>
</div>
<div id="probebw">
<section id="section-4.3.3">
          <h4 id="name-probebw">
<a href="#section-4.3.3" class="section-number selfRef">4.3.3. </a><a href="#name-probebw" class="section-name selfRef">ProbeBW</a>
          </h4>
<p id="section-4.3.3-1">Long-lived BBR flows tend to spend the vast majority of their time in the ProbeBW states. In the ProbeBW states, a BBR flow sequentially accelerates, decelerates, and cruises, to measure the network path, improve its operating point (increase throughput and reduce queue pressure), and converge toward a more fair allocation of bottleneck bandwidth. To do this, the flow sequentially cycles through all three tactics: trying to send faster than, slower than, and at the same rate as the network delivery process. To achieve this, a BBR flow in ProbeBW mode cycles through the four Probe bw states - DOWN, CRUISE, REFILL, and UP - described below in turn.<a href="#section-4.3.3-1" class="pilcrow">¶</a></p>
<div id="probebwdown">
<section id="section-4.3.3.1">
            <h5 id="name-probebw_down">
<a href="#section-4.3.3.1" class="section-number selfRef">4.3.3.1. </a><a href="#name-probebw_down" class="section-name selfRef">ProbeBW_DOWN</a>
            </h5>
<p id="section-4.3.3.1-1">In the ProbeBW_DOWN phase of the cycle, a BBR flow pursues the deceleration tactic, to try to send slower than the network is delivering data, to reduce the amount of data in flight, with all of the standard motivations for the deceleration tactic (discussed in "State Machine Tactics", above).  It does this by switching to a BBR.pacing_gain of 0.9, sending at 90% of BBR.bw. The pacing_gain value of 0.9 is derived based on the ProbeBW_UP pacing gain of 1.25, as the minimum pacing_gain value that allows bandwidth-based convergence to approximate fairness.<a href="#section-4.3.3.1-1" class="pilcrow">¶</a></p>
<p id="section-4.3.3.1-2">Exit conditions: The flow exits this phase and enters CRUISE when the flow estimates that  both of the following conditions have been met:<a href="#section-4.3.3.1-2" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-4.3.3.1-3.1">There is free headroom: If inflight_hi is set, then BBR remains in DOWN at least until the volume of in-flight data is less than or equal to BBRHeadroom*BBR.inflight_hi. The goal of this constraint is to ensure that in cases where loss signals suggest an upper limit on the volume of in-flight data, then the flow attempts to leave some free headroom in the path (e.g. free space in the bottleneck buffer or free time slots in the bottleneck link) that can be used by cross traffic (both for volume-based convergence of bandwidth shares and for burst tolerance).<a href="#section-4.3.3.1-3.1" class="pilcrow">¶</a>
</li>
              <li class="normal" id="section-4.3.3.1-3.2">The volume of in-flight data is less than or equal to BBR.BDP, i.e. the flow estimates that it has drained any queue at the bottleneck.<a href="#section-4.3.3.1-3.2" class="pilcrow">¶</a>
</li>
            </ul>
</section>
</div>
<div id="probebwcruise">
<section id="section-4.3.3.2">
            <h5 id="name-probebw_cruise">
<a href="#section-4.3.3.2" class="section-number selfRef">4.3.3.2. </a><a href="#name-probebw_cruise" class="section-name selfRef">ProbeBW_CRUISE</a>
            </h5>
<p id="section-4.3.3.2-1">In the ProbeBW_CRUISE phase of the cycle, a BBR flow pursues the "cruising" tactic (discussed in "State Machine Tactics", above), attempting to send at the same rate the network is delivering data. It tries to match the sending rate to the flow's current available bandwidth, to try to achieve high utilization of the available bandwidth without increasing queue pressure. It does this by switching to a pacing_gain of 1.0, sending at 100% of BBR.bw. Notably, while in this state it responds to concrete congestion signals (loss) by reducing BBR.bw_lo and BBR.inflight_lo, because these signals suggest that the available bandwidth and deliverable volume of in-flight data have likely reduced, and the flow needs to change to adapt, slowing down to match the latest delivery process.<a href="#section-4.3.3.2-1" class="pilcrow">¶</a></p>
<p id="section-4.3.3.2-2">Exit conditions: The connection adaptively holds this state until it decides that it is time to probe for bandwidth, at which time it enters ProbeBW_REFILL (see "Time Scale for Bandwidth Probing", below).<a href="#section-4.3.3.2-2" class="pilcrow">¶</a></p>
</section>
</div>
<div id="probebwrefill">
<section id="section-4.3.3.3">
            <h5 id="name-probebw_refill">
<a href="#section-4.3.3.3" class="section-number selfRef">4.3.3.3. </a><a href="#name-probebw_refill" class="section-name selfRef">ProbeBW_REFILL</a>
            </h5>
<p id="section-4.3.3.3-1">The goal of the ProbeBW_REFILL state is to "refill the pipe", to try to fully utilize the network bottleneck without creating any significant queue pressure.<a href="#section-4.3.3.3-1" class="pilcrow">¶</a></p>
<p id="section-4.3.3.3-2">To do this, BBR first resets the short-term model parameters bw_lo and inflight_lo, setting both to "Infinity". This is the key moment in the BBR time scale strategy (see "Time Scale Strategy", above) where the flow pivots, discarding its conservative short-term bw_lo and inflight_lo parameters and beginning to robustly probe the bottleneck's long-term available bandwidth. During this time bw_hi and inflight_hi, if set, constrain the connection.<a href="#section-4.3.3.3-2" class="pilcrow">¶</a></p>
<p id="section-4.3.3.3-3">During ProbeBW_REFILL BBR uses a BBR.pacing_gain of 1.0, to send at a rate that matches the current estimated available bandwidth, for one packet-timed round trip. The goal is to fully utilize the bottleneck link before transitioning into ProbeBW_UP and significantly increasing the chances of causing a loss signal. The motivating insight is that, as soon as a flow starts acceleration, sending faster than the available bandwidth, it will start building a queue at the bottleneck. And if the buffer is shallow enough, then the flow can cause loss signals very shortly after the first accelerating packets arrive at the bottleneck. If the flow were to neglect to fill the pipe before it causes this loss signal, then these very quick signals of excess queue could cause the flow's estimate of the path's capacity (i.e. inflight_hi) to significantly underestimate. In particular, if the flow were to transition directly from ProbeBW_CRUISE to ProbeBW_UP, the volume of in-flight data (at the time the first accelerating packets were sent) may often be still very close to the volume of in-flight data maintained in CRUISE, which may be only BBRHeadroom*inflight_hi.<a href="#section-4.3.3.3-3" class="pilcrow">¶</a></p>
<p id="section-4.3.3.3-4">Exit conditions: The flow exits ProbeBW_REFILL after one packet-timed round trip, and enters UP. This is because after one full round trip of sending in ProbeBW_REFILL the flow (if not application-limited) has had an opportunity to place as many packets in flight as its BBR.bw estimate permits. And correspondingly, at this point the flow starts to see bandwidth samples reflecting its ProbeBW_REFILL behavior, which may be putting too much data in flight.<a href="#section-4.3.3.3-4" class="pilcrow">¶</a></p>
</section>
</div>
<div id="probebwup">
<section id="section-4.3.3.4">
            <h5 id="name-probebw_up">
<a href="#section-4.3.3.4" class="section-number selfRef">4.3.3.4. </a><a href="#name-probebw_up" class="section-name selfRef">ProbeBW_UP</a>
            </h5>
<p id="section-4.3.3.4-1">After ProbeBW_REFILL refills the pipe, ProbeBW_UP probes for possible increases in available bandwidth by using a BBR.pacing_gain of 1.25, sending faster than the current estimated available bandwidth.<a href="#section-4.3.3.4-1" class="pilcrow">¶</a></p>
<p id="section-4.3.3.4-2">If the flow has not set BBR.inflight_hi or BBR.bw_hi, it tries to raise the volume of in-flight data to at least BBR.pacing_gain * BBR.bdp = 1.25 * BBR.bdp; note that this may take more than BBR.min_rtt if BBR.min_rtt is small (e.g. on a LAN).<a href="#section-4.3.3.4-2" class="pilcrow">¶</a></p>
<p id="section-4.3.3.4-3">If the flow has set BBR.inflight_hi or BBR.bw_hi, it moves to an operating point based on those limits and then gradually increases the upper volume bound (BBR.inflight_hi) and rate bound (BBR.bw_hi) using the following approach:<a href="#section-4.3.3.4-3" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-4.3.3.4-4.1">bw_hi: The flow raises bw_hi to the latest measured bandwidth sample if the latest measured bandwidth sample is above bw_hi and the loss rate for the sample is not above the BBRLossThresh.<a href="#section-4.3.3.4-4.1" class="pilcrow">¶</a>
</li>
              <li class="normal" id="section-4.3.3.4-4.2">inflight_hi: The flow raises inflight_hi in ProbeBW_UP in a manner that is slow and cautious at first, but increasingly rapid and bold over time. The initial caution is motivated by the fact that a given BBR flow may be sharing a shallow buffer with thousands of other flows, so that the buffer space available to the flow may be quite tight - even just a single packet.  The increasingly rapid growth over time is motivated by the fact that in a high-speed WAN the increase in available bandwidth (and thus the estimated BDP) may require the flow to grow the volume of its inflight data by up to O(1,000,000); even a quite typical BDP like 10Gbps * 100ms is 82,563 packets. BBR takes an approach where the additive increase to BBR.inflight_hi exponentially doubles each round trip; in each successive round trip, inflight_hi grows by 1, 2, 4, 8, 16, etc, with the increases spread uniformly across the entire round trip. This helps allow BBR to utilize a larger BDP in O(log(BDP)) round trips, meeting the design goal for scalable utilization of newly-available bandwidth.<a href="#section-4.3.3.4-4.2" class="pilcrow">¶</a>
</li>
            </ul>
<p id="section-4.3.3.4-5">Exit conditions: The BBR flow ends ProbeBW_UP bandwidth probing and transitions to ProbeBW_DOWN to try to drain the bottleneck queue when any of the following conditions are met:<a href="#section-4.3.3.4-5" class="pilcrow">¶</a></p>
<ol start="1" type="1" class="normal type-1" id="section-4.3.3.4-6">
<li id="section-4.3.3.4-6.1">Estimated queue: The flow has been in ProbeBW_UP for at least 1*min_rtt, and the estimated queue is high enough that the flow judges it has robustly probed for available bandwidth (packets_in_flight &gt; 1.25 * BBR.bdp).<a href="#section-4.3.3.4-6.1" class="pilcrow">¶</a>
</li>
              <li id="section-4.3.3.4-6.2">Loss: The current loss rate exceeds BBRLossThresh (2%).<a href="#section-4.3.3.4-6.2" class="pilcrow">¶</a>
</li>
            </ol>
</section>
</div>
<div id="time-scale-for-bandwidth-probing-">
<section id="section-4.3.3.5">
            <h5 id="name-time-scale-for-bandwidth-pr">
<a href="#section-4.3.3.5" class="section-number selfRef">4.3.3.5. </a><a href="#name-time-scale-for-bandwidth-pr" class="section-name selfRef">Time Scale for Bandwidth Probing</a>
            </h5>
<p id="section-4.3.3.5-1">Choosing the time scale for probing bandwidth is tied to the question of how to coexist with legacy Reno/CUBIC flows, since probing for bandwidth runs a significant risk of causing packet loss, and causing packet loss can significantly limit the throughput of such legacy Reno/CUBIC flows.<a href="#section-4.3.3.5-1" class="pilcrow">¶</a></p>
<div id="bandwidth-probing-and-coexistence-with-renocubic">
<section id="section-4.3.3.5.1">
              <h6 id="name-bandwidth-probing-and-coexi">
<a href="#section-4.3.3.5.1" class="section-number selfRef">4.3.3.5.1. </a><a href="#name-bandwidth-probing-and-coexi" class="section-name selfRef">Bandwidth Probing and Coexistence with Reno/CUBIC</a>
              </h6>
<p id="section-4.3.3.5.1-1">BBR has an explicit strategy for coexistence with Reno/CUBIC: to try to behave in a manner so that  Reno/CUBIC flows coexisting with BBR can continue to work well in the primary contexts where they do today:<a href="#section-4.3.3.5.1-1" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-4.3.3.5.1-2.1">
                  <p id="section-4.3.3.5.1-2.1.1">Intra-datacenter/LAN traffic: we want Reno/CUBIC to be able to perform well in 100M through 40G enterprise and datacenter Ethernet<a href="#section-4.3.3.5.1-2.1.1" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-4.3.3.5.1-2.1.2.1">BDP = 40 Gbps * 20 us / (1514 bytes) ~= 66 packets<a href="#section-4.3.3.5.1-2.1.2.1" class="pilcrow">¶</a>
</li>
                  </ul>
</li>
                <li class="normal" id="section-4.3.3.5.1-2.2">
                  <p id="section-4.3.3.5.1-2.2.1">Public Internet last mile traffic: we want Reno/CUBIC to be able to support up to 25Mbps (for 4K Video) at an RTT of 30ms, typical parameters for common CDNs for large video services:<a href="#section-4.3.3.5.1-2.2.1" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-4.3.3.5.1-2.2.2.1">BDP = 25Mbps * 30 ms / (1514 bytes) ~= 62 packets<a href="#section-4.3.3.5.1-2.2.2.1" class="pilcrow">¶</a>
</li>
                  </ul>
</li>
              </ul>
<p id="section-4.3.3.5.1-3">The challenge in meeting these goals is that Reno/CUBIC need long periods of no loss to utilize large BDPs. The good news is that in the environments where Reno/CUBIC work well today (mentioned above), the BDPs are small, roughly ~100 packets or less.<a href="#section-4.3.3.5.1-3" class="pilcrow">¶</a></p>
</section>
</div>
<div id="a-dual-time-scale-approach-for-coexistence">
<section id="section-4.3.3.5.2">
              <h6 id="name-a-dual-time-scale-approach-">
<a href="#section-4.3.3.5.2" class="section-number selfRef">4.3.3.5.2. </a><a href="#name-a-dual-time-scale-approach-" class="section-name selfRef">A Dual-Time-Scale Approach for Coexistence</a>
              </h6>
<p id="section-4.3.3.5.2-1">The BBR strategy has several aspects:<a href="#section-4.3.3.5.2-1" class="pilcrow">¶</a></p>
<ol start="1" type="1" class="normal type-1" id="section-4.3.3.5.2-2">
<li id="section-4.3.3.5.2-2.1">The highest priority is to estimate the bandwidth available to the BBR flow in question.<a href="#section-4.3.3.5.2-2.1" class="pilcrow">¶</a>
</li>
                <li id="section-4.3.3.5.2-2.2">Secondarily, a given BBR flow adapts (within bounds) the frequency at which it probes bandwidth and knowingly risks packet loss, to allow Reno/CUBIC to reach a bandwidth at least as high as that given BBR flow.<a href="#section-4.3.3.5.2-2.2" class="pilcrow">¶</a>
</li>
              </ol>
<p id="section-4.3.3.5.2-3">To adapt the frequency of bandwidth probing, BBR considers two time scales: a BBR-native time scale, and a bounded Reno-conscious time scale:<a href="#section-4.3.3.5.2-3" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-4.3.3.5.2-4.1">
                  <p id="section-4.3.3.5.2-4.1.1">T_bbr: BBR-native time-scale<a href="#section-4.3.3.5.2-4.1.1" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-4.3.3.5.2-4.1.2.1">T_bbr = uniformly randomly distributed between 2 and 3 secs<a href="#section-4.3.3.5.2-4.1.2.1" class="pilcrow">¶</a>
</li>
                  </ul>
</li>
                <li class="normal" id="section-4.3.3.5.2-4.2">
                  <p id="section-4.3.3.5.2-4.2.1">T_reno: Reno-coexistence time scale<a href="#section-4.3.3.5.2-4.2.1" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-4.3.3.5.2-4.2.2.1">T_reno_bound = pick_randomly_either({62, 63})<a href="#section-4.3.3.5.2-4.2.2.1" class="pilcrow">¶</a>
</li>
                    <li class="normal" id="section-4.3.3.5.2-4.2.2.2">reno_bdp = min(BBR.bdp, cwnd)<a href="#section-4.3.3.5.2-4.2.2.2" class="pilcrow">¶</a>
</li>
                    <li class="normal" id="section-4.3.3.5.2-4.2.2.3">T_reno = min(reno_bdp, T_reno_bound) round trips<a href="#section-4.3.3.5.2-4.2.2.3" class="pilcrow">¶</a>
</li>
                  </ul>
</li>
                <li class="normal" id="section-4.3.3.5.2-4.3">
                  <p id="section-4.3.3.5.2-4.3.1">T_probe: The time between bandwidth probe UP phases:<a href="#section-4.3.3.5.2-4.3.1" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-4.3.3.5.2-4.3.2.1">T_probe = min(T_bbr, T_reno)<a href="#section-4.3.3.5.2-4.3.2.1" class="pilcrow">¶</a>
</li>
                  </ul>
</li>
              </ul>
<p id="section-4.3.3.5.2-5">This dual-time-scale approach is similar to that used by CUBIC, which has a CUBIC-native time scale given by a cubic curve, and a "Reno emulation" module that estimates what cwnd would give the flow Reno-equivalent throughput. At any given moment, CUBIC choose the cwnd implied by the more aggressive strategy.<a href="#section-4.3.3.5.2-5" class="pilcrow">¶</a></p>
<p id="section-4.3.3.5.2-6">We randomize both the T_bbr and T_reno parameters, for better mixing and fairness convergence.<a href="#section-4.3.3.5.2-6" class="pilcrow">¶</a></p>
</section>
</div>
<div id="design-considerations-for-choosing-constant-parameters">
<section id="section-4.3.3.5.3">
              <h6 id="name-design-considerations-for-c">
<a href="#section-4.3.3.5.3" class="section-number selfRef">4.3.3.5.3. </a><a href="#name-design-considerations-for-c" class="section-name selfRef">Design Considerations for Choosing Constant Parameters</a>
              </h6>
<p id="section-4.3.3.5.3-1">We design the maximum wall-clock bounds of BBR-native inter-bandwidth-probe wall clock time, T_bbr, to be:<a href="#section-4.3.3.5.3-1" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-4.3.3.5.3-2.1">Higher than 2 sec to try to avoid causing loss for a long enough time to allow Reno flow with RTT=30ms to get 25Mbps (4K video) throughput. For this workload, given the Reno sawtooth that raises cwnd from roughly BDP to 2*BDP, one MSS per round trip,  the inter-bandwidth-probe time must be at least: BDP * RTT = 25Mbps * .030 sec / (1514 bytes) * 0.030 sec = 1.9secs<a href="#section-4.3.3.5.3-2.1" class="pilcrow">¶</a>
</li>
                <li class="normal" id="section-4.3.3.5.3-2.2">Lower than 3 sec to ensure flows can start probing in a reasonable amount of time to discover unutilized bw on human-scale interactive  time-scales (e.g. perhaps traffic from a competing web page download is now complete).<a href="#section-4.3.3.5.3-2.2" class="pilcrow">¶</a>
</li>
              </ul>
<p id="section-4.3.3.5.3-3">The maximum round-trip bounds of the Reno-coexistence time scale, T_reno, are chosen to be 62-63 with the following considerations in mind:<a href="#section-4.3.3.5.3-3" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-4.3.3.5.3-4.1">Choosing a value smaller than roughly 60 would imply that when BBR flows coexisted with Reno/CUBIC flows (e.g. Netflix Reno flows) on public Internet broadband links, the Reno/CUBIC flows would not be able to achieve enough bandwidth to show 4K video.<a href="#section-4.3.3.5.3-4.1" class="pilcrow">¶</a>
</li>
                <li class="normal" id="section-4.3.3.5.3-4.2">Choosing a value larger than roughly 65 would prevent BBR from reaching its goal of tolerating 1% loss per round trip. Given that the steady-state (non-bandwidth-probing) BBR response to a round trip with X% packet loss is to reduce the sending rate by X% (see the "Updating the Model Upon Packet Loss" section), this means that the BBR sending rate after N rounds of packet loss at a rate loss_rate is (1 - loss_rate)^N. This means that for a flow that encounters 1% loss in 65 round trips of ProbeBW_CRUISE, and then doubles its cwnd (back to BBR.inflight_hi) in ProbeBW_REFILL and ProbeBW_UP, it will be able to restore and reprobe its original sending rate, since: BBW.max_bw * (1 - loss_rate)^N * 2 = BBR.max_bw * (1 - .01)^65 ~= 1.04 * BBR.max_bw. That is, the flow will be able to fully respond to packet loss signals in ProbeBW_CRUISE while also fully re-measuring its maximum achievable throughput in ProbeBW_UP.<a href="#section-4.3.3.5.3-4.2" class="pilcrow">¶</a>
</li>
              </ul>
<p id="section-4.3.3.5.3-5">The resulting behavior is that for BBR flows with small BDPs, the bandwidth probing will be on roughly the same time scale as Reno/CUBIC; flows with large BDPs will intentionally probe more rapidly/frequently than Reno/CUBIC would (roughly every 62 round trips for low-RTT flows, or 2-3 secs for high-RTT flows).<a href="#section-4.3.3.5.3-5" class="pilcrow">¶</a></p>
<p id="section-4.3.3.5.3-6">The considerations above for timing bandwidth probing can be implemented as follows:<a href="#section-4.3.3.5.3-6" class="pilcrow">¶</a></p>
<div class="alignLeft art-text artwork" id="section-4.3.3.5.3-7">
<pre>
  /* Is it time to transition from DOWN or CRUISE to REFILL? */
  BBRCheckTimeToProbeBW():
    if (BBRHasElapsedInPhase(BBR.bw_probe_wait) ||
        BBRIsRenoCoexistenceProbeTime())
      BBRStartProbeBW_REFILL()
      return true
    return false

  /* Randomized decision about how long to wait until
   * probing for bandwidth, using round count and wall clock.
   */
  BBRPickProbeWait():
    /* Decide random round-trip bound for wait: */
    BBR.rounds_since_bw_probe =
      random_int_between(0, 1); /* 0 or 1 */
    /* Decide the random wall clock bound for wait: */
    BBR.bw_probe_wait =
      2sec + random_float_between(0.0, 1.0) /* 0..1 sec */

  BBRIsRenoCoexistenceProbeTime():
    reno_rounds = BBRTargetInflight()
    rounds = min(reno_rounds, 63)
    return BBR.rounds_since_bw_probe &gt;= rounds

  /* How much data do we want in flight?
   * Our estimated BDP, unless congestion cut cwnd. */
  BBRTargetInflight()
    return min(BBR.bdp, cwnd)
</pre><a href="#section-4.3.3.5.3-7" class="pilcrow">¶</a>
</div>
</section>
</div>
</section>
</div>
<div id="probebw-algorithm-details">
<section id="section-4.3.3.6">
            <h5 id="name-probebw-algorithm-details">
<a href="#section-4.3.3.6" class="section-number selfRef">4.3.3.6. </a><a href="#name-probebw-algorithm-details" class="section-name selfRef">ProbeBW Algorithm Details</a>
            </h5>
<p id="section-4.3.3.6-1">BBR's ProbeBW algorithm operates as follows.<a href="#section-4.3.3.6-1" class="pilcrow">¶</a></p>
<p id="section-4.3.3.6-2">Upon entering ProbeBW, BBR executes:<a href="#section-4.3.3.6-2" class="pilcrow">¶</a></p>
<div class="alignLeft art-text artwork" id="section-4.3.3.6-3">
<pre>
  BBREnterProbeBW():
    BBRStartProbeBW_DOWN()
</pre><a href="#section-4.3.3.6-3" class="pilcrow">¶</a>
</div>
<p id="section-4.3.3.6-4">The core logic for entering each state:<a href="#section-4.3.3.6-4" class="pilcrow">¶</a></p>
<div class="alignLeft art-text artwork" id="section-4.3.3.6-5">
<pre>
  BBRStartProbeBW_DOWN():
    BBRResetCongestionSignals()
    BBR.probe_up_cnt = Infinity /* not growing inflight_hi */
    BBRPickProbeWait()
    BBR.cycle_stamp = Now()  /* start wall clock */
    BBR.ack_phase  = ACKS_PROBE_STOPPING
    BBRStartRound()
    BBR.state = ProbeBW_DOWN

  BBRStartProbeBW_CRUISE():
    BBR.state = ProbeBW_CRUISE

  BBRStartProbeBW_REFILL():
    BBRResetLowerBounds()
    BBR.bw_probe_up_rounds = 0
    BBR.bw_probe_up_acks = 0
    BBR.ack_phase = ACKS_REFILLING
    BBRStartRound()
    BBR.state = ProbeBW_REFILL

  BBRStartProbeBW_UP():
    BBR.ack_phase = ACKS_PROBE_STARTING
    BBRStartRound()
    BBR.cycle_stamp = Now() /* start wall clock */
    BBR.state = ProbeBW_UP
    BBRRaiseInflightHiSlope()
</pre><a href="#section-4.3.3.6-5" class="pilcrow">¶</a>
</div>
<p id="section-4.3.3.6-6">BBR executes the following BBRUpdateProbeBWCyclePhase() logic on each ACK that ACKs or SACKs new data, to advance the ProbeBW state machine:<a href="#section-4.3.3.6-6" class="pilcrow">¶</a></p>
<div class="alignLeft art-text artwork" id="section-4.3.3.6-7">
<pre>
  /* The core state machine logic for ProbeBW: */
  BBRUpdateProbeBWCyclePhase():
    if (!BBR.filled_pipe)
      return  /* only handling steady-state behavior here */
    BBRAdaptUpperBounds()
    if (!IsInAProbeBWState())
      return /* only handling ProbeBW states here: */

    switch (state)

    ProbeBW_DOWN:
      if (BBRCheckTimeToProbeBW())
        return /* already decided state transition */
      if (BBRCheckTimeToCruise())
        BBRStartProbeBW_CRUISE()

    ProbeBW_CRUISE:
      if (BBRCheckTimeToProbeBW())
        return /* already decided state transition */

    ProbeBW_REFILL:
      /* After one round of REFILL, start UP */
      if (BBR.round_start)
        BBR.bw_probe_samples = 1
        BBRStartProbeBW_UP()

    ProbeBW_UP:
      if (BBRHasElapsedInPhase(BBR.min_rtt) and
          inflight &gt; BBRInflight(BBR.max_bw, 1.25))
        BBRStartProbeBW_DOWN()
</pre><a href="#section-4.3.3.6-7" class="pilcrow">¶</a>
</div>
<p id="section-4.3.3.6-8">The ancillary logic to implement the ProbeBW state machine:<a href="#section-4.3.3.6-8" class="pilcrow">¶</a></p>
<div class="alignLeft art-text artwork" id="section-4.3.3.6-9">
<pre>
  IsInAProbeBWState()
    state = BBR.state
    return (state == ProbeBW_DOWN or
            state == ProbeBW_CRUISE or
            state == ProbeBW_REFILL or
            state == ProbeBW_UP)

  /* Time to transition from DOWN to CRUISE? */
  BBRCheckTimeToCruise():
    if (inflight &gt; BBRInflightWithHeadroom())
      return false /* not enough headroom */
    if (inflight &lt;= BBRInflight(BBR.max_bw, 1.0))
      return true  /* inflight &lt;= estimated BDP */

  BBRHasElapsedInPhase(interval):
    return Now() &gt; BBR.cycle_stamp + interval

  /* Return a volume of data that tries to leave free
   * headroom in the bottleneck buffer or link for
   * other flows, for fairness convergence and lower
   * RTTs and loss */
  BBRInflightWithHeadroom():
    if (BBR.inflight_hi == Infinity)
      return Infinity
    headroom = max(1, BBRHeadroom * BBR.inflight_hi)
      return max(BBR.inflight_hi - headroom,
                 BBRMinPipeCwnd)

  /* Raise inflight_hi slope if appropriate. */
  BBRRaiseInflightHiSlope():
    growth_this_round = 1MSS &lt;&lt; BBR.bw_probe_up_rounds
    BBR.bw_probe_up_rounds = min(BBR.bw_probe_up_rounds + 1, 30)
    BBR.probe_up_cnt = max(cwnd / growth_this_round, 1)

  /* Increase inflight_hi if appropriate. */
  BBRProbeInflightHiUpward():
    if (!is_cwnd_limited or cwnd &lt; BBR.inflight_hi)
      return  /* not fully using inflight_hi, so don't grow it */
   BBR.bw_probe_up_acks += rs.newly_acked
   if (BBR.bw_probe_up_acks &gt;= BBR.probe_up_cnt)
     delta = BBR.bw_probe_up_acks / BBR.probe_up_cnt
     BBR.bw_probe_up_acks -= delta * BBR.bw_probe_up_cnt
     BBR.inflight_hi += delta
   if (BBR.round_start)
     BBRRaiseInflightHiSlope()

  /* Track ACK state and update BBR.max_bw window and
   * BBR.inflight_hi and BBR.bw_hi. */
  BBRAdaptUpperBounds():
    if (BBR.ack_phase == ACKS_PROBE_STARTING and BBR.round_start)
      /* starting to get bw probing samples */
      BBR.ack_phase = ACKS_PROBE_FEEDBACK
    if (BBR.ack_phase == ACKS_PROBE_STOPPING and BBR.round_start)
      /* end of samples from bw probing phase */
      if (IsInAProbeBWState() and !rs.is_app_limited)
        BBRAdvanceMaxBwFilter()

    if (!CheckInflightTooHigh())
      /* Loss rate is safe. Adjust upper bounds upward. */
      if (BBR.inflight_hi == Infinity or BBR.bw_hi == Infinity)
        return /* no upper bounds to raise */
      if (rs.tx_in_flight &gt; BBR.inflight_hi)
        BBR.inflight_hi = rs.tx_in_flight
      if (rs.delivery_rate &gt; BBR.bw_hi)
        BBR.bw_hi = rs.bw
      if (BBR.state == ProbeBW_UP)
        BBRProbeInflightHiUpward()
</pre><a href="#section-4.3.3.6-9" class="pilcrow">¶</a>
</div>
</section>
</div>
</section>
</div>
<div id="probertt">
<section id="section-4.3.4">
          <h4 id="name-probertt">
<a href="#section-4.3.4" class="section-number selfRef">4.3.4. </a><a href="#name-probertt" class="section-name selfRef">ProbeRTT</a>
          </h4>
<div id="probertt-overview">
<section id="section-4.3.4.1">
            <h5 id="name-probertt-overview">
<a href="#section-4.3.4.1" class="section-number selfRef">4.3.4.1. </a><a href="#name-probertt-overview" class="section-name selfRef">ProbeRTT Overview</a>
            </h5>
<p id="section-4.3.4.1-1">To help probe for BBR.min_rtt, on an as-needed basis BBR flows enter the ProbeRTT state to try to cooperate to periodically drain the bottleneck queue - and thus improve their BBR.min_rtt estimate of the unloaded two-way propagation delay.<a href="#section-4.3.4.1-1" class="pilcrow">¶</a></p>
<p id="section-4.3.4.1-2">A critical point is that before BBR raises its BBR.min_rtt estimate (which would in turn raise its maximum permissible cwnd), it first enters ProbeRTT to try to make a concerted and coordinated effort to drain the bottleneck queue and make a robust BBR.min_rtt measurement. This allows the BBR.min_rtt estimates of ensembles of BBR flows to converge  avoiding feedback loops of ever-increasing queues and RTT samples.<a href="#section-4.3.4.1-2" class="pilcrow">¶</a></p>
<p id="section-4.3.4.1-3">The ProbeRTT state works in concert with BBR.min_rtt estimation. Up to once every ProbeRTTInterval = 5 seconds, the flow enters ProbeRTT, decelerating by setting its cwnd_gain to BBRProbeRTTCwndGain = 0.5 to reduce its volume of inflight data to half of its estimated BDP, to try to allow the flow to measure the unloaded two-way propagation delay.<a href="#section-4.3.4.1-3" class="pilcrow">¶</a></p>
<p id="section-4.3.4.1-4">There are two main motivations for making the MinRTTFilterLen roughly twice the ProbeRTTInterval. First, this ensures that during a ProbeRTT episode the flow will "remember" the BBR.min_rtt value it measured during the previous ProbeRTT episode, providing a robust bdp estimate for the cwnd = 0.5*bdp calculation, increasing the likelihood of fully draining the bottleneck queue. Second, this allows the flow's BBR.min_rtt filter window to generally include RTT samples from two ProbeTT episodes, providing a more robust estimate.<a href="#section-4.3.4.1-4" class="pilcrow">¶</a></p>
<p id="section-4.3.4.1-5">The algorithm for ProbeRTT is as follows:<a href="#section-4.3.4.1-5" class="pilcrow">¶</a></p>
<p id="section-4.3.4.1-6"></p>
<p id="section-4.3.4.1-7">Entry conditions: In any state other than ProbeRTT itself, if the BBR.probe_rtt_min_delay estimate has not been updated (i.e., by getting a lower RTT measurement) for more than ProbeRTTInterval = 5 seconds, then BBR enters ProbeRTT and reduces the BBR.cwnd_gain to BBRProbeRTTCwndGain = 0.5.<a href="#section-4.3.4.1-7" class="pilcrow">¶</a></p>
<p id="section-4.3.4.1-8">Exit conditions: After maintaining the volume of in-flight data at BBRProbeRTTCwndGain*BBR.bdp for at least ProbeRTTDuration (200 ms) and at least one round trip, BBR leaves ProbeRTT and transitions to ProbeBW if it estimates the pipe was filled already, or Startup otherwise.<a href="#section-4.3.4.1-8" class="pilcrow">¶</a></p>
</section>
</div>
<div id="probertt-design-rationale">
<section id="section-4.3.4.2">
            <h5 id="name-probertt-design-rationale">
<a href="#section-4.3.4.2" class="section-number selfRef">4.3.4.2. </a><a href="#name-probertt-design-rationale" class="section-name selfRef">ProbeRTT Design Rationale</a>
            </h5>
<p id="section-4.3.4.2-1">BBR is designed to have ProbeRTT sacrifice no more than roughly 2% of a flow's available bandwidth. It is also designed to spend the vast majority of its time (at least roughly 96 percent) in ProbeBW and the rest in ProbeRTT, based on a set of tradeoffs. ProbeRTT lasts long enough (at least ProbeRTTDuration = 200 ms) to allow flows with different RTTs to have overlapping ProbeRTT states, while still being short enough to bound the throughput penalty of ProbeRTT's cwnd capping to roughly 2%, with the average throughput targeted at:<a href="#section-4.3.4.2-1" class="pilcrow">¶</a></p>
<div class="alignLeft art-text artwork" id="section-4.3.4.2-2">
<pre>
  throughput = (200ms*0.5*BBR.bw + (5s - 200ms)*BBR.bw) / 5s
             = (.1s + 4.8s)/5s * BBR.bw = 0.98 * BBR.bw
</pre><a href="#section-4.3.4.2-2" class="pilcrow">¶</a>
</div>
<p id="section-4.3.4.2-3">As discussed above, BBR's BBR.min_rtt filter window, MinRTTFilterLen, and time interval between ProbeRTT states, ProbeRTTInterval, work in concert. BBR uses a MinRTTFilterLen equal to or longer than ProbeRTTInterval to allow the filter window to include at least one ProbeRTT.<a href="#section-4.3.4.2-3" class="pilcrow">¶</a></p>
<p id="section-4.3.4.2-4">To allow coordination with other BBR flows, each flow MUST use the standard ProbeRTTInterval of 5 secs.<a href="#section-4.3.4.2-4" class="pilcrow">¶</a></p>
<p id="section-4.3.4.2-5">An ProbeRTTInterval of 5 secs is short enough to allow quick convergence if traffic levels or routes change, but long enough so that interactive applications (e.g., Web, remote procedure calls, video chunks) often have natural silences or low-rate periods within the window where the flow's rate is low enough for long enough to drain its queue in the bottleneck. Then the BBR.probe_rtt_min_delay filter opportunistically picks up these measurements, and the BBR.probe_rtt_min_delay estimate refreshes without requiring ProbeRTT. This way, flows typically need only pay the 2 percent throughput penalty if there are multiple bulk flows busy sending over the entire ProbeRTTInterval window.<a href="#section-4.3.4.2-5" class="pilcrow">¶</a></p>
<p id="section-4.3.4.2-6">As an optimization, when restarting from idle and finding that the BBR.probe_rtt_min_delay has expired, BBR does not enter ProbeRTT; the idleness is deemed a sufficient attempt to coordinate to drain the queue.<a href="#section-4.3.4.2-6" class="pilcrow">¶</a></p>
</section>
</div>
<div id="calculating-the-rsrtt-rtt-sample">
<section id="section-4.3.4.3">
            <h5 id="name-calculating-the-rsrtt-rtt-s">
<a href="#section-4.3.4.3" class="section-number selfRef">4.3.4.3. </a><a href="#name-calculating-the-rsrtt-rtt-s" class="section-name selfRef">Calculating the rs.rtt RTT Sample</a>
            </h5>
<p id="section-4.3.4.3-1">Upon transmitting each packet, BBR (or the associated transport protocol) stores in per-packet data the wall-clock scheduled transmission time of the packet in packet.departure_time (see the "Pacing Rate: BBR.pacing_rate" section for how this is calculated).<a href="#section-4.3.4.3-1" class="pilcrow">¶</a></p>
<p id="section-4.3.4.3-2">For every ACK that newly acknowledges some data (whether cumulatively or selectively), the sender's BBR implementation (or the associated transport protocol implementation) attempts to calculate an RTT sample. The sender MUST consider any potential retransmission ambiguities that can arise in some transport protocols. If some of the acknowledged data was not retransmitted, or some of the data was retransmitted but the sender can still unambiguously determine the RTT of the data (e.g. if the transport supports [RFC7323] TCP timestamps or an equivalent mechanism), then the sender calculates an RTT sample, rs.rtt, as follows:<a href="#section-4.3.4.3-2" class="pilcrow">¶</a></p>
<div class="alignLeft art-text artwork" id="section-4.3.4.3-3">
<pre>
  rs.rtt = Now() - packet.departure_time
</pre><a href="#section-4.3.4.3-3" class="pilcrow">¶</a>
</div>
</section>
</div>
<div id="probertt-logic">
<section id="section-4.3.4.4">
            <h5 id="name-probertt-logic">
<a href="#section-4.3.4.4" class="section-number selfRef">4.3.4.4. </a><a href="#name-probertt-logic" class="section-name selfRef">ProbeRTT Logic</a>
            </h5>
<p id="section-4.3.4.4-1">On every ACK BBR executes BBRUpdateMinRTT() to update its ProbeRTT scheduling state (BBR.probe_rtt_min_delay and BBR.probe_rtt_min_stamp) and its BBR.min_rtt estimate:<a href="#section-4.3.4.4-1" class="pilcrow">¶</a></p>
<div class="alignLeft art-text artwork" id="section-4.3.4.4-2">
<pre>
  BBRUpdateMinRTT()
    BBR.probe_rtt_expired =
      Now() &gt; BBR.probe_rtt_min_stamp + ProbeRTTInterval
    if (rs.rtt &gt;= 0 and
        (rs.rtt &lt; BBR.probe_rtt_min_delay or
         BBR.probe_rtt_expired))
       BBR.probe_rtt_min_delay = rs.rtt
       BBR.probe_rtt_min_stamp = Now()

    min_rtt_expired =
      Now() &gt; BBR.min_rtt_stamp + MinRTTFilterLen
    if (BBR.probe_rtt_min_delay &lt; BBR.min_rtt or
        min_rtt_expired)
      BBR.min_rtt       = BBR.probe_rtt_min_delay
      BBR.min_rtt_stamp = BBR.probe_rtt_min_stamp
</pre><a href="#section-4.3.4.4-2" class="pilcrow">¶</a>
</div>
<p id="section-4.3.4.4-3">Here BBR.probe_rtt_expired is a boolean recording whether the BBR.probe_rtt_min_delay has expired and is due for a refresh, via either an application idle period or a transition into ProbeRTT state.<a href="#section-4.3.4.4-3" class="pilcrow">¶</a></p>
<p id="section-4.3.4.4-4">On every ACK BBR executes BBRCheckProbeRTT() to handle the steps related to the ProbeRTT state as follows:<a href="#section-4.3.4.4-4" class="pilcrow">¶</a></p>
<div class="alignLeft art-text artwork" id="section-4.3.4.4-5">
<pre>
  BBRCheckProbeRTT():
    if (BBR.state != ProbeRTT and
        BBR.probe_rtt_expired and
        not BBR.idle_restart)
      BBREnterProbeRTT()
      BBRSaveCwnd()
      BBR.probe_rtt_done_stamp = 0
      BBR.ack_phase = ACKS_PROBE_STOPPING
      BBRStartRound()
    if (BBR.state == ProbeRTT)
      BBRHandleProbeRTT()
    if (rs.delivered &gt; 0)
      BBR.idle_restart = false

  BBREnterProbeRTT():
    BBR.state = ProbeRTT
    BBR.pacing_gain = 1
    BBR.cwnd_gain = BBRProbeRTTCwndGain  /* 0.5 */

  BBRHandleProbeRTT():
    /* Ignore low rate samples during ProbeRTT: */
    MarkConnectionAppLimited()
    if (BBR.probe_rtt_done_stamp == 0 and
        packets_in_flight &lt;= BBRProbeRTTCwnd())
      /* Wait for at least ProbeRTTDuration to elapse: */
      BBR.probe_rtt_done_stamp =
        Now() + ProbeRTTDuration
      /* Wait for at least one round to elapse: */
      BBR.probe_rtt_round_done = false
      BBRStartRound()
    else if (BBR.probe_rtt_done_stamp != 0)
      if (BBR.round_start)
        BBR.probe_rtt_round_done = true
      if (BBR.probe_rtt_round_done)
        BBRCheckProbeRTTDone()

  BBRCheckProbeRTTDone():
    if (BBR.probe_rtt_done_stamp != 0 and
        Now() &gt; BBR.probe_rtt_done_stamp)
      /* schedule next ProbeRTT: */
      BBR.probe_rtt_min_stamp = Now()
      BBRRestoreCwnd()
      BBRExitProbeRTT()

  MarkConnectionAppLimited():
    C.app_limited =
      (C.delivered + packets_in_flight) ? : 1
</pre><a href="#section-4.3.4.4-5" class="pilcrow">¶</a>
</div>
</section>
</div>
<div id="exiting-probertt">
<section id="section-4.3.4.5">
            <h5 id="name-exiting-probertt">
<a href="#section-4.3.4.5" class="section-number selfRef">4.3.4.5. </a><a href="#name-exiting-probertt" class="section-name selfRef">Exiting ProbeRTT</a>
            </h5>
<p id="section-4.3.4.5-1">When exiting ProbeRTT, BBR transitions to ProbeBW if it estimates the pipe was filled already, or Startup otherwise.<a href="#section-4.3.4.5-1" class="pilcrow">¶</a></p>
<p id="section-4.3.4.5-2">When transitioning out of ProbeRTT, BBR calls BBRResetLowerBounds() to reset the lower bounds, since any congestion encountered in ProbeRTT may have pulled the short-term model far below the capacity of the path.<a href="#section-4.3.4.5-2" class="pilcrow">¶</a></p>
<p id="section-4.3.4.5-3">But the algorithm is cautious in timing the next bandwidth probe: raising inflight after ProbeRTT may cause loss, so the algorithm resets the bandwidth-probing clock by starting the cycle at ProbeBW_DOWN(). But then as an optimization, since the connection is exiting ProbeRTT, we know that infligh is already below the estimated BDP, so the connection can proceed immediately to ProbeBW_CRUISE.<a href="#section-4.3.4.5-3" class="pilcrow">¶</a></p>
<p id="section-4.3.4.5-4">To summarize, the logic for exiting ProbeRTT is as follows:<a href="#section-4.3.4.5-4" class="pilcrow">¶</a></p>
<div class="alignLeft art-text artwork" id="section-4.3.4.5-5">
<pre>
  BBRExitProbeRTT():
    BBRResetLowerBounds()
    if (BBR.filled_pipe)
      BBRStartProbeBW_DOWN()
      BBRStartProbeBW_CRUISE()
    else
      BBREnterStartup()
</pre><a href="#section-4.3.4.5-5" class="pilcrow">¶</a>
</div>
</section>
</div>
</section>
</div>
</section>
</div>
<div id="restarting-from-idle">
<section id="section-4.4">
        <h3 id="name-restarting-from-idle">
<a href="#section-4.4" class="section-number selfRef">4.4. </a><a href="#name-restarting-from-idle" class="section-name selfRef">Restarting From Idle</a>
        </h3>
<div id="setting-pacing-rate-in-probebw">
<section id="section-4.4.1">
          <h4 id="name-setting-pacing-rate-in-prob">
<a href="#section-4.4.1" class="section-number selfRef">4.4.1. </a><a href="#name-setting-pacing-rate-in-prob" class="section-name selfRef">Setting Pacing Rate in ProbeBW</a>
          </h4>
<p id="section-4.4.1-1">When restarting from idle in ProbeBW states, BBR leaves its cwnd as-is and paces packets at exactly BBR.bw, aiming to return as quickly as possible to its target operating point of rate balance and a full pipe. Specifically, if the flow's BBR.state is ProbeBW, and the flow is application-limited, and there are no packets in flight currently, then at the moment the flow sends one or more packets BBR sets BBR.pacing_rate to exactly BBR.bw. More precisely, the BBR algorithm takes the following steps in BBRHandleRestartFromIdle() before sending a packet for a flow.<a href="#section-4.4.1-1" class="pilcrow">¶</a></p>
<p id="section-4.4.1-2">The "Restarting Idle Connections" section of [RFC5681] suggests restarting from idle by slow-starting from the initial window. However, this approach was assuming a congestion control algorithm that had no estimate of the bottleneck bandwidth and no pacing, and thus resorted to relying on slow-starting driven by an ACK clock. The long (log_2(BDP)*RTT) delays required to reach full utilization with that "slow start after idle" approach caused many large deployments to disable this mechanism, resulting in a "BDP-scale line-rate burst" approach instead. Instead of these two approaches, BBR restarts by pacing at BBR.bw, typically achieving approximate rate balance and a full pipe after only one BBR.min_rtt has elapsed.<a href="#section-4.4.1-2" class="pilcrow">¶</a></p>
</section>
</div>
<div id="checking-for-proberrtt-completion">
<section id="section-4.4.2">
          <h4 id="name-checking-for-proberrtt-comp">
<a href="#section-4.4.2" class="section-number selfRef">4.4.2. </a><a href="#name-checking-for-proberrtt-comp" class="section-name selfRef">Checking for ProberRTT Completion</a>
          </h4>
<p id="section-4.4.2-1">As an optimization, when restarting from idle BBR checks to see if the connection is in ProbeRTT and has met the exit conditions for ProbeRTT. If a connection goes idle during ProbeRTT then often it will have met those exit conditions by the time it restarts, so that the connection can restore the cwnd to its full value before it starts transmitting a new flight of data.<a href="#section-4.4.2-1" class="pilcrow">¶</a></p>
</section>
</div>
<div id="logic">
<section id="section-4.4.3">
          <h4 id="name-logic">
<a href="#section-4.4.3" class="section-number selfRef">4.4.3. </a><a href="#name-logic" class="section-name selfRef">Logic</a>
          </h4>
<p id="section-4.4.3-1">The BBR algorithm takes the following steps in BBRHandleRestartFromIdle() before sending a packet for a flow:<a href="#section-4.4.3-1" class="pilcrow">¶</a></p>
<div class="alignLeft art-text artwork" id="section-4.4.3-2">
<pre>
  BBRHandleRestartFromIdle():
    if (packets_in_flight == 0 and C.app_limited)
      BBR.idle_restart = true
         BBR.extra_acked_interval_start = Now()
      if (IsInAProbeBWState())
        BBRSetPacingRateWithGain(1)
      else if (BBR.state == ProbeRTT)
        BBRCheckProbeRTTDone()
</pre><a href="#section-4.4.3-2" class="pilcrow">¶</a>
</div>
</section>
</div>
</section>
</div>
<div id="updating-network-path-model-parameters">
<section id="section-4.5">
        <h3 id="name-updating-network-path-model">
<a href="#section-4.5" class="section-number selfRef">4.5. </a><a href="#name-updating-network-path-model" class="section-name selfRef">Updating Network Path Model Parameters</a>
        </h3>
<p id="section-4.5-1">BBR is a model-based congestion control algorithm: it is based on an explicit model of the network path over which a transport flow travels. The following is a summary of each parameter, including its meaning and how the algorithm calculates and uses its value. We can group the parameter into three groups:<a href="#section-4.5-1" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-4.5-2.1">core state machine parameters<a href="#section-4.5-2.1" class="pilcrow">¶</a>
</li>
          <li class="normal" id="section-4.5-2.2">parameters to model the data rate<a href="#section-4.5-2.2" class="pilcrow">¶</a>
</li>
          <li class="normal" id="section-4.5-2.3">parameters to model the volume of in-flight data<a href="#section-4.5-2.3" class="pilcrow">¶</a>
</li>
        </ul>
<div id="bbrroundcount-tracking-packet-timed-round-trips">
<section id="section-4.5.1">
          <h4 id="name-bbrround_count-tracking-pac">
<a href="#section-4.5.1" class="section-number selfRef">4.5.1. </a><a href="#name-bbrround_count-tracking-pac" class="section-name selfRef">BBR.round_count: Tracking Packet-Timed Round Trips</a>
          </h4>
<p id="section-4.5.1-1">Several aspects of the BBR algorithm depend on counting the progress of "packet-timed" round trips, which start at the transmission of some segment, and then end at the acknowledgement of that segment. BBR.round_count is a count of the number of these "packet-timed" round trips elapsed so far. BBR uses this virtual BBR.round_count because it is more robust than using wall clock time. In particular, arbitrary intervals of wall clock time can elapse due to application idleness, variations in RTTs, or timer delays for retransmission timeouts, causing wall-clock-timed model parameter estimates to "time out" or to be "forgotten" too quickly to provide robustness.<a href="#section-4.5.1-1" class="pilcrow">¶</a></p>
<p id="section-4.5.1-2">BBR counts packet-timed round trips by recording state about a sentinel packet, and waiting for an ACK of any data packet that was sent after that sentinel packet, using the following pseudocode:<a href="#section-4.5.1-2" class="pilcrow">¶</a></p>
<p id="section-4.5.1-3">Upon connection initialization:<a href="#section-4.5.1-3" class="pilcrow">¶</a></p>
<div class="alignLeft art-text artwork" id="section-4.5.1-4">
<pre>
  BBRInitRoundCounting():
    BBR.next_round_delivered = 0
    BBR.round_start = false
    BBR.round_count = 0
</pre><a href="#section-4.5.1-4" class="pilcrow">¶</a>
</div>
<p id="section-4.5.1-5">Upon sending each packet, the rate estimation algorithm [draft-cheng-iccrg-delivery-rate-estimation] records the amount of data thus far acknowledged as delivered:<a href="#section-4.5.1-5" class="pilcrow">¶</a></p>
<div class="alignLeft art-text artwork" id="section-4.5.1-6">
<pre>
  packet.delivered = C.delivered
</pre><a href="#section-4.5.1-6" class="pilcrow">¶</a>
</div>
<p id="section-4.5.1-7">Upon receiving an ACK for a given data packet, the rate estimation algorithm [draft-cheng-iccrg-delivery-rate-estimation] updates the amount of data thus far acknowledged as delivered:<a href="#section-4.5.1-7" class="pilcrow">¶</a></p>
<div class="alignLeft art-text artwork" id="section-4.5.1-8">
<pre>
    C.delivered += packet.size
</pre><a href="#section-4.5.1-8" class="pilcrow">¶</a>
</div>
<p id="section-4.5.1-9">Upon receiving an ACK for a given data packet, the BBR algorithm first executes the following logic to see if a round trip has elapsed, and if so, increment the count of such round trips elapsed:<a href="#section-4.5.1-9" class="pilcrow">¶</a></p>
<div class="alignLeft art-text artwork" id="section-4.5.1-10">
<pre>
  BBRUpdateRound():
    if (packet.delivered &gt;= BBR.next_round_delivered)
      BBRStartRound()
      BBR.round_count++
      BBR.rounds_since_probe++
      BBR.round_start = true
    else
      BBR.round_start = false

  BBRStartRound():
    BBR.next_round_delivered = C.delivered
</pre><a href="#section-4.5.1-10" class="pilcrow">¶</a>
</div>
</section>
</div>
<div id="bbrmaxbw-estimated-maximum-bandwidth">
<section id="section-4.5.2">
          <h4 id="name-bbrmax_bw-estimated-maximum">
<a href="#section-4.5.2" class="section-number selfRef">4.5.2. </a><a href="#name-bbrmax_bw-estimated-maximum" class="section-name selfRef">BBR.max_bw: Estimated Maximum Bandwidth</a>
          </h4>
<p id="section-4.5.2-1">BBR.max_bw is BBR's estimate of the maximum bottleneck bandwidth available to data transmissions for the transport flow. At any time, a transport connection's data transmissions experience some slowest link or bottleneck. The bottleneck's delivery rate determines the connection's maximum data-delivery rate. BBR tries to closely match its sending rate to this bottleneck delivery rate to help seek "rate balance", where the flow's packet arrival rate at the bottleneck equals the departure rate. The bottleneck rate varies over the life of a connection, so BBR continually estimates BBR.max_bw using recent signals.<a href="#section-4.5.2-1" class="pilcrow">¶</a></p>
<div id="delivery-rate-samples-for-estimating-bbrmaxbw">
<section id="section-4.5.2.1">
            <h5 id="name-delivery-rate-samples-for-e">
<a href="#section-4.5.2.1" class="section-number selfRef">4.5.2.1. </a><a href="#name-delivery-rate-samples-for-e" class="section-name selfRef">Delivery Rate Samples for Estimating BBR.max_bw</a>
            </h5>
<p id="section-4.5.2.1-1">Since calculating delivery rate samples is subtle, and the samples are useful independent of congestion control, the approach BBR uses for measuring each single delivery rate sample is specified in a separate Internet Draft [draft-cheng-iccrg-delivery-rate-estimation].<a href="#section-4.5.2.1-1" class="pilcrow">¶</a></p>
</section>
</div>
<div id="bbrmaxbw-max-filter">
<section id="section-4.5.2.2">
            <h5 id="name-bbrmax_bw-max-filter">
<a href="#section-4.5.2.2" class="section-number selfRef">4.5.2.2. </a><a href="#name-bbrmax_bw-max-filter" class="section-name selfRef">BBR.max_bw Max Filter</a>
            </h5>
<p id="section-4.5.2.2-1">Delivery rate samples are often below the typical bottleneck bandwidth available to the flow, due to "noise" introduced by random variation in physical transmission processes (e.g. radio link layer noise) or queues or along the network path. To filter these effects BBR uses a max filter: BBR estimates BBR.max_bw using the windowed maximum recent delivery rate sample seen by the connection over recent history.<a href="#section-4.5.2.2-1" class="pilcrow">¶</a></p>
<p id="section-4.5.2.2-2">The BBR.max_bw max filter window covers a time period extending over the past two ProbeBW cycles. The BBR.max_bw max filter window length is driven by trade-offs among several considerations:<a href="#section-4.5.2.2-2" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-4.5.2.2-3.1">It is long enough to cover at least one entire ProbeBW cycle (see the "ProbeBW" section). This ensures that the window contains at least some delivery rate samples that are the result of data transmitted with a super-unity pacing_gain (a pacing_gain larger than 1.0). Such super-unity delivery rate samples are instrumental in revealing the path's underlying available bandwidth even when there is noise from delivery rate shortfalls due to aggregation delays, queuing delays from variable cross-traffic, lossy link layers with uncorrected losses, or short-term buffer exhaustion (e.g., brief coincident bursts in a shallow buffer).<a href="#section-4.5.2.2-3.1" class="pilcrow">¶</a>
</li>
              <li class="normal" id="section-4.5.2.2-3.2">It aims to be long enough to cover short-term fluctuations in the network's delivery rate due to the aforementioned sources of noise. In particular, the delivery rate for radio link layers (e.g., wifi and cellular technologies) can be highly variable, and the filter window needs to be long enough to remember "good" delivery rate samples in order to be robust to such variations.<a href="#section-4.5.2.2-3.2" class="pilcrow">¶</a>
</li>
              <li class="normal" id="section-4.5.2.2-3.3">It aims to be short enough to respond in a timely manner to sustained reductions in the bandwidth available to a flow, whether this is because other flows are using a larger share of the bottleneck, or the bottleneck link service rate has reduced due to layer 1 or layer 2 changes, policy changes, or routing changes. In any of these cases, existing BBR flows traversing the bottleneck should, in a timely manner, reduce their BBR.max_bw estimates and thus pacing rate and in-flight data, in order to match the sending behavior to the new available bandwidth.<a href="#section-4.5.2.2-3.3" class="pilcrow">¶</a>
</li>
            </ul>
</section>
</div>
<div id="bbrmaxbw-and-application-limited-delivery-rate-samples">
<section id="section-4.5.2.3">
            <h5 id="name-bbrmax_bw-and-application-l">
<a href="#section-4.5.2.3" class="section-number selfRef">4.5.2.3. </a><a href="#name-bbrmax_bw-and-application-l" class="section-name selfRef">BBR.max_bw and Application-limited Delivery Rate Samples</a>
            </h5>
<p id="section-4.5.2.3-1">Transmissions can be application-limited, meaning the transmission rate is limited by the application rather than the congestion control algorithm. This is quite common because of request/response traffic. When there is a transmission opportunity but no data to send, the delivery rate sampler marks the corresponding bandwidth sample(s) as application-limited [draft-cheng-iccrg-delivery-rate-estimation]. The BBR.max_bw estimator carefully decides which samples to include in the bandwidth model to ensure that BBR.max_bw reflects network limits, not application limits. By default, the estimator discards application-limited samples, since by definition they reflect application limits. However, the estimator does use application-limited samples if the measured delivery rate happens to be larger than the current BBR.max_bw estimate, since this indicates the current BBR.Max_bw estimate is too low.<a href="#section-4.5.2.3-1" class="pilcrow">¶</a></p>
</section>
</div>
<div id="updating-the-bbrmaxbw-max-filter">
<section id="section-4.5.2.4">
            <h5 id="name-updating-the-bbrmax_bw-max-">
<a href="#section-4.5.2.4" class="section-number selfRef">4.5.2.4. </a><a href="#name-updating-the-bbrmax_bw-max-" class="section-name selfRef">Updating the BBR.max_bw Max Filter</a>
            </h5>
<p id="section-4.5.2.4-1">For every ACK that acknowledges some data packets as delivered, BBR invokes BBRUpdateMaxBw() to update the BBR.max_bw estimator as follows (here rs.delivery_rate is the delivery rate sample obtained from the ACK that is being processed, as specified in [draft-cheng-iccrg-delivery-rate-estimation]):<a href="#section-4.5.2.4-1" class="pilcrow">¶</a></p>
<div class="alignLeft art-text artwork" id="section-4.5.2.4-2">
<pre>
  BBRUpdateMaxBw()
    BBRUpdateRound()
    if (rs.delivery_rate &gt;= BBR.max_bw || !rs.is_app_limited)
        BBR.max_bw = update_windowed_max_filter(
                      filter=BBR.MaxBwFilter,
                      value=rs.delivery_rate,
                      time=BBR.cycle_count,
                      window_length=MaxBwFilterLen)
</pre><a href="#section-4.5.2.4-2" class="pilcrow">¶</a>
</div>
</section>
</div>
<div id="tracking-time-for-the-bbrmaxbw-max-filter">
<section id="section-4.5.2.5">
            <h5 id="name-tracking-time-for-the-bbrma">
<a href="#section-4.5.2.5" class="section-number selfRef">4.5.2.5. </a><a href="#name-tracking-time-for-the-bbrma" class="section-name selfRef">Tracking Time for the BBR.max_bw Max Filter</a>
            </h5>
<p id="section-4.5.2.5-1">BBR tracks time for the BBR.max_bw filter window using a virtual (non-wall-clock) time tracked by counting the cyclical progression through ProbeBW cycles. Each time through the Probe bw cycle, one round trip after exiting ProbeBW_UP (the point at which the flow has its best chance to measure the highest throughput of the cycle), BBR increments BBR.cycle_count, the virtual time used by the BBR.max_bw filter window. Note that BBR.cycle_count only needs to be tracked with a single bit, since the BBR.max_bw filter only needs to track samples from two time slots: the previous ProbeBW cycle and the current ProbeBW cycle:<a href="#section-4.5.2.5-1" class="pilcrow">¶</a></p>
<div class="alignLeft art-text artwork" id="section-4.5.2.5-2">
<pre>
  BBRAdvanceMaxBwFilter():
    BBR.cycle_count++
</pre><a href="#section-4.5.2.5-2" class="pilcrow">¶</a>
</div>
</section>
</div>
</section>
</div>
<div id="bbrminrtt-estimated-minimum-round-trip-time">
<section id="section-4.5.3">
          <h4 id="name-bbrmin_rtt-estimated-minimu">
<a href="#section-4.5.3" class="section-number selfRef">4.5.3. </a><a href="#name-bbrmin_rtt-estimated-minimu" class="section-name selfRef">BBR.min_rtt: Estimated Minimum Round-Trip Time</a>
          </h4>
<p id="section-4.5.3-1">BBR.min_rtt is BBR's estimate of the round-trip propagation delay of the path over which a transport connection is sending. The path's round-trip propagation delay determines the minimum amount of time over which the connection must be willing to sustain transmissions at the BBR.bw rate, and thus the minimum amount of data needed in-flight, for the connection to reach full utilization (a "Full Pipe"). The round-trip propagation delay can vary over the life of a connection, so BBR continually estimates BBR.min_rtt using recent round-trip delay samples.<a href="#section-4.5.3-1" class="pilcrow">¶</a></p>
<div id="round-trip-time-samples-for-estimating-bbrminrtt">
<section id="section-4.5.3.1">
            <h5 id="name-round-trip-time-samples-for">
<a href="#section-4.5.3.1" class="section-number selfRef">4.5.3.1. </a><a href="#name-round-trip-time-samples-for" class="section-name selfRef">Round-Trip Time Samples for Estimating BBR.min_rtt</a>
            </h5>
<p id="section-4.5.3.1-1">For every data packet a connection sends, BBR calculates an RTT sample that measures the time interval from sending a data packet until that packet is acknowledged.<a href="#section-4.5.3.1-1" class="pilcrow">¶</a></p>
<p id="section-4.5.3.1-2">For the most part, the same considerations and mechanisms that apply to RTT estimation for the purposes of retransmission timeout calculations [RFC6298] apply to BBR RTT samples. Namely, BBR does not use RTT samples based on the transmission time of retransmitted packets, since these are ambiguous, and thus unreliable. Also, BBR calculates RTT samples using both cumulative and selective acknowledgments (if the transport supports [RFC2018] SACK options or an equivalent mechanism), or transport-layer timestamps (if the transport supports [RFC7323] TCP timestamps or an equivalent mechanism).<a href="#section-4.5.3.1-2" class="pilcrow">¶</a></p>
<p id="section-4.5.3.1-3">The only divergence from RTT estimation for retransmission timeouts is in the case where a given acknowledgment ACKs more than one data packet. In order to be conservative and schedule long timeouts to avoid spurious retransmissions, the maximum among such potential RTT samples is typically used for computing retransmission timeouts; i.e., SRTT is typically calculated using the data packet with the earliest transmission time. By contrast, in order for BBR to try to reach the minimum amount of data in flight to fill the pipe, BBR uses the minimum among such potential RTT samples; i.e., BBR calculates the RTT using the data packet with the latest transmission time.<a href="#section-4.5.3.1-3" class="pilcrow">¶</a></p>
</section>
</div>
<div id="bbrminrtt-min-filter">
<section id="section-4.5.3.2">
            <h5 id="name-bbrmin_rtt-min-filter">
<a href="#section-4.5.3.2" class="section-number selfRef">4.5.3.2. </a><a href="#name-bbrmin_rtt-min-filter" class="section-name selfRef">BBR.min_rtt Min Filter</a>
            </h5>
<p id="section-4.5.3.2-1">RTT samples tend to be above the round-trip propagation delay of the path, due to "noise" introduced by random variation in physical transmission processes (e.g. radio link layer noise), queues along the network path, the receiver's delayed ack strategy, ack aggregation, etc. Thus to filter out these effects BBR uses a min filter: BBR estimates BBR.min_rtt using the minimum recent RTT sample seen by the connection over that past MinRTTFilterLen seconds. (Many of the same network effects that can decrease delivery rate measurements can increase RTT samples, which is why BBR's min-filtering approach for RTTs is the complement of its max-filtering approach for delivery rates.)<a href="#section-4.5.3.2-1" class="pilcrow">¶</a></p>
<p id="section-4.5.3.2-2">The length of the BBR.min_rtt min filter window is MinRTTFilterLen = 10 secs. This is driven by trade-offs among several considerations:<a href="#section-4.5.3.2-2" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-4.5.3.2-3.1">The MinRTTFilterLen is longer than ProbeRTTInterval, so that it covers an entire ProbeRTT cycle (see the "ProbeRTT" section below). This helps ensure that the window can contain RTT samples that are the result of data transmitted with inflight below the estimated BDP of the flow. Such RTT samples are important for helping to reveal the path's underlying two-way propagation delay even when the aforementioned "noise" effects can often obscure it.<a href="#section-4.5.3.2-3.1" class="pilcrow">¶</a>
</li>
              <li class="normal" id="section-4.5.3.2-3.2">The MinRTTFilterLen aims to be long enough to avoid needing to cut in-flight and throughput often. Measuring two-way propagation delay requires in-flight to be at or below BDP, which risks  some amount of underutilization, so BBR uses a filter window long enough that such underutilization events can be rare.<a href="#section-4.5.3.2-3.2" class="pilcrow">¶</a>
</li>
              <li class="normal" id="section-4.5.3.2-3.3">The MinRTTFilterLen aims to be long enough that many applications have a "natural" moment of silence or low utilization that can cut in-flight below BDP and naturally serve to refresh the BBR.min_rtt, without requiring BBR to force an artificial cut in in-flight. This applies to many popular applications, including Web, RPC, chunked audio or video traffic.<a href="#section-4.5.3.2-3.3" class="pilcrow">¶</a>
</li>
              <li class="normal" id="section-4.5.3.2-3.4">The MinRTTFilterLen aims to be short enough to respond in a timely manner to real increases in the two-way propagation delay of the path, e.g. due to route changes, which are expected to typically happen on longer time scales.<a href="#section-4.5.3.2-3.4" class="pilcrow">¶</a>
</li>
            </ul>
<p id="section-4.5.3.2-4">A BBR implementation MAY use a generic windowed min filter to track BBR.min_rtt. However, a significant savings in space and improvement in freshness can be achieved by integrating the BBR.min_rtt estimation into the ProbeRTT state machine, so this document discusses that approach in the ProbeRTT section.<a href="#section-4.5.3.2-4" class="pilcrow">¶</a></p>
</section>
</div>
</section>
</div>
<div id="bbroffloadbudget">
<section id="section-4.5.4">
          <h4 id="name-bbroffload_budget">
<a href="#section-4.5.4" class="section-number selfRef">4.5.4. </a><a href="#name-bbroffload_budget" class="section-name selfRef">BBR.offload_budget</a>
          </h4>
<p id="section-4.5.4-1">BBR.offload_budget is the estimate of the minimum volume of data necessary to achieve full throughput using sender (TSO/GSO)  and receiver (LRO, GRO) host offload mechanisms, computed as follows:<a href="#section-4.5.4-1" class="pilcrow">¶</a></p>
<div class="alignLeft art-text artwork" id="section-4.5.4-2">
<pre>
    BBRUpdateOffloadBudget():
      BBR.offload_budget = 3 * BBR.send_quantum
</pre><a href="#section-4.5.4-2" class="pilcrow">¶</a>
</div>
<p id="section-4.5.4-3">The factor of 3 is chosen to allow maintaining at least:<a href="#section-4.5.4-3" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-4.5.4-4.1">1 quantum in the sending host's queuing discipline layer<a href="#section-4.5.4-4.1" class="pilcrow">¶</a>
</li>
            <li class="normal" id="section-4.5.4-4.2">1 quantum being segmented in the sending host TSO/GSO engine<a href="#section-4.5.4-4.2" class="pilcrow">¶</a>
</li>
            <li class="normal" id="section-4.5.4-4.3">1 quantum being reassembled or otherwise remaining unacknowledged due to the receiver host's LRO/GRO/delayed-ACK engine<a href="#section-4.5.4-4.3" class="pilcrow">¶</a>
</li>
          </ul>
</section>
</div>
<div id="bbrextraacked">
<section id="section-4.5.5">
          <h4 id="name-bbrextra_acked">
<a href="#section-4.5.5" class="section-number selfRef">4.5.5. </a><a href="#name-bbrextra_acked" class="section-name selfRef">BBR.extra_acked</a>
          </h4>
<p id="section-4.5.5-1">BBR.extra_acked is a volume of data that is the estimate of the recent degree of aggregation in the network path. For each ACK, the algorithm computes a sample of the estimated extra ACKed data beyond the amount of data that the sender expected to be ACKed over the timescale of a round-trip, given the BBR.bw. Then it computes BBR.extra_acked as the windowed maximum sample over the last BBRExtraAckedFilterLen=10 packet-timed round-trips. If the ACK rate falls below the expected bandwidth, then the algorithm estimates an aggregation episode has terminated, and resets the sampling interval to start from the current time.<a href="#section-4.5.5-1" class="pilcrow">¶</a></p>
<p id="section-4.5.5-2">The BBR.extra_acked thus reflects the recently-measured magnitude of data and ACK aggregation effects such as batching and slotting at shared-medium L2 hops (wifi, cellular, DOCSIS), as well as end-host offload mechanisms (TSO, GSO, LRO, GRO), and end host or middlebox ACK decimation/thinning.<a href="#section-4.5.5-2" class="pilcrow">¶</a></p>
<p id="section-4.5.5-3">​​BBR augments its cwnd by BBR.extra_acked to allow the connection to keep sending during inter-ACK silences, to an extent that matches the recently measured degree of aggregation.<a href="#section-4.5.5-3" class="pilcrow">¶</a></p>
<p id="section-4.5.5-4">More precisely, this is computed as:<a href="#section-4.5.5-4" class="pilcrow">¶</a></p>
<div class="alignLeft art-text artwork" id="section-4.5.5-5">
<pre>
  BBRUpdateACKAggregation():
    /* Find excess ACKed beyond expected amount over this interval */
    interval = (Now() - BBR.extra_acked_interval_start)
    expected_delivered = BBR.bw * interval
    /* Reset interval if ACK rate is below expected rate: */
    if (BBR.extra_acked_delivered &lt;= expected_delivered)
        BBR.extra_acked_delivered = 0
        BBR.extra_acked_interval_start = Now()
        expected_delivered = 0
    BBR.extra_acked_delivered += rs.newly_acked
    extra = BBR.extra_acked_delivered - expected_delivered
    extra = min(extra, cwnd)
    BBR.extra_acked =
      update_windowed_max_filter(
        filter=BBR.ExtraACKedFilter,
        value=extra,
        time=BBR.round_count,
        window_length=BBRExtraAckedFilterLen)
</pre><a href="#section-4.5.5-5" class="pilcrow">¶</a>
</div>
</section>
</div>
<div id="updating-the-model-upon-packet-loss">
<section id="section-4.5.6">
          <h4 id="name-updating-the-model-upon-pac">
<a href="#section-4.5.6" class="section-number selfRef">4.5.6. </a><a href="#name-updating-the-model-upon-pac" class="section-name selfRef">Updating the Model Upon Packet Loss</a>
          </h4>
<p id="section-4.5.6-1">In every state, BBR responds to (filtered) congestion signals, including loss. The response to those congestion signals depends on the flow's current state, since the information that the flow can infer depends on what the flow was doing when the flow experienced the signal.<a href="#section-4.5.6-1" class="pilcrow">¶</a></p>
<div id="probing-for-bandwidth-in-startup">
<section id="section-4.5.6.1">
            <h5 id="name-probing-for-bandwidth-in-st">
<a href="#section-4.5.6.1" class="section-number selfRef">4.5.6.1. </a><a href="#name-probing-for-bandwidth-in-st" class="section-name selfRef">Probing for Bandwidth In Startup</a>
            </h5>
<p id="section-4.5.6.1-1">In Startup, if the congestion signals meet the Startup exit criteria, the flow exits Startup and enters Drain.<a href="#section-4.5.6.1-1" class="pilcrow">¶</a></p>
</section>
</div>
<div id="probing-for-bandwidth-in-probebw">
<section id="section-4.5.6.2">
            <h5 id="name-probing-for-bandwidth-in-pr">
<a href="#section-4.5.6.2" class="section-number selfRef">4.5.6.2. </a><a href="#name-probing-for-bandwidth-in-pr" class="section-name selfRef">Probing for Bandwidth In ProbeBW</a>
            </h5>
<p id="section-4.5.6.2-1">BBR searches for the maximum volume of data that can be sensibly placed in-flight in the network. A key precondition is that the flow is actually trying robustly to find that operating point. To implement this, when a flow is in ProbeBW, and an ACK covers data sent in one of the accelerating phases (REFILL or UP), and the ACK indicates that the loss rate over the past round trip exceeds the queue pressure objective,  and the flow is not application limited, and has not yet responded to congestion signals from the most  recent REFILL or UP phase, then the flow estimates that the volume of data it allowed in flight exceeded what matches the current delivery process on the path, and reduces BBR.inflight_hi:<a href="#section-4.5.6.2-1" class="pilcrow">¶</a></p>
<div class="alignLeft art-text artwork" id="section-4.5.6.2-2">
<pre>
  /* Do loss signals suggest inflight is too high?
   * If so, react. */
  CheckInflightTooHigh():
    if (IsInflightTooHigh(rs))
      if (BBR.bw_probe_samples)
        BBRHandleInflightTooHigh()
      return true  /* inflight too high */
    else
      return false /* inflight not too high */

  IsInflightTooHigh():
    return (rs.lost &gt; rs.tx_in_flight * BBRLossThresh)

  BBRHandleInflightTooHigh():
    BBR.bw_probe_samples = 0;  /* only react once per bw probe */
    if (!rs.is_app_limited)
      BBR.inflight_hi = max(rs.tx_in_flight,
                            BBRTargetInflight() * BBRBeta))
    If (BBR.state == ProbeBW_UP)
      BBRStartProbeBW_DOWN()
</pre><a href="#section-4.5.6.2-2" class="pilcrow">¶</a>
</div>
<p id="section-4.5.6.2-3">Here rs.tx_in_flight is the amount of data that was estimated to be in flight when the most recently ACKed packet was sent. And the BBRBeta (0.7x) bound is to try to ensure that BBR does not react more dramatically than CUBIC's 0.7x multiplicative decrease factor.<a href="#section-4.5.6.2-3" class="pilcrow">¶</a></p>
<p id="section-4.5.6.2-4">Some loss detection algorithms, including algorithms like RACK [RFC8985] that delay loss marking while waiting for potential reordering to resolve, may mark packets as lost long after the loss itself happened. In such cases, the tx_in_flight for the delivered sequence range that allowed the loss to be detected may be considerably smaller than the tx_in_flight of the lost packet itself. In such cases using the former tx_in_flight rather than the latter can cause BBR.inflight_hi to be significantly underestimated. To avoid such issues, BBR processes each loss detection event to more precisely estimate the volume of in-flight data at which loss rates cross BBRLossThresh, noting that this may have happened mid-way through some packet. To estimate this value, we can solve for "lost_prefix" in the following equation, where inflight_prev represents the volume of in-flight data preceding this packet, lost_prev represents the data lost among that previous in-flight data:<a href="#section-4.5.6.2-4" class="pilcrow">¶</a></p>
<div class="alignLeft art-text artwork" id="section-4.5.6.2-5">
<pre>
    lost                     /  inflight                     &gt;= BBRLossThresh
   (lost_prev + lost_prefix) / (inflight_prev + lost_prefix) &gt;= BBRLossThresh
   /* solving for lost_prefix we arrive at: */
   lost_prefix = (BBRLossThresh * inflight_prev - lost_prev) / (1 - BBRLossThresh)
</pre><a href="#section-4.5.6.2-5" class="pilcrow">¶</a>
</div>
<p id="section-4.5.6.2-6">In pseudocode:<a href="#section-4.5.6.2-6" class="pilcrow">¶</a></p>
<div class="alignLeft art-text artwork" id="section-4.5.6.2-7">
<pre>
  BBRHandleLostPacket(packet):
    if (!BBR.bw_probe_samples)
      return /* not a packet sent while probing bandwidth */
    rs.tx_in_flight = packet.tx_in_flight /* inflight at transmit */
    rs.lost = C.lost - packet.lost /* data lost since transmit */
    rs.is_app_limited = packet.is_app_limited;
    if (IsInflightTooHigh(rs))
      rs.tx_in_flight = BBRInflightHiFromLostPacket(rs, packet)
      BBRHandleInflightTooHigh(rs)

  /* At what prefix of packet did losses exceed BBRLossThresh? */
  BBRInflightHiFromLostPacket(rs, packet):
    size = packet.size
    /* What was in flight before this packet? */
    inflight_prev = rs.tx_in_flight - size
    /* What was lost before this packet? */
    lost_prev = rs.lost - size
    lost_prefix = (BBRLossThresh * inflight_prev - lost_prev) /
                  (1 - BBRLossThresh)
    /* At what inflight value did losses cross BBRLossThresh? */
    inflight = inflight_prev + lost_prefix
    return inflight
</pre><a href="#section-4.5.6.2-7" class="pilcrow">¶</a>
</div>
</section>
</div>
<div id="when-not-probing-for-bandwidth">
<section id="section-4.5.6.3">
            <h5 id="name-when-not-probing-for-bandwi">
<a href="#section-4.5.6.3" class="section-number selfRef">4.5.6.3. </a><a href="#name-when-not-probing-for-bandwi" class="section-name selfRef">When not Probing for Bandwidth</a>
            </h5>
<p id="section-4.5.6.3-1">When not explicitly accelerating to probe for bandwidth (Drain, ProbeRTT, ProbeBW_DOWN, ProbeBW_CRUISE), BBR  responds to loss by slowing down to some extent. This is because loss suggests that the available bandwidth and safe volume of in-flight data may have decreased recently, and the flow needs to adapt, slowing down toward the latest delivery process. BBR flows implement this response by reducing the short-term model parameters, BBR.bw_lo and BBR.inflight_lo.<a href="#section-4.5.6.3-1" class="pilcrow">¶</a></p>
<p id="section-4.5.6.3-2">When encountering packet loss when the flow is not probing for bandwidth, the strategy is to gradually adapt to the current measured delivery process (the rate and volume of data that is delivered through the network path over the last round trip). This applies generally: whether in fast recovery, RTO recovery, TLP recovery; whether application-limited or not.<a href="#section-4.5.6.3-2" class="pilcrow">¶</a></p>
<p id="section-4.5.6.3-3">There are two key parameters the algorithm tracks, to measure the current delivery process:<a href="#section-4.5.6.3-3" class="pilcrow">¶</a></p>
<p id="section-4.5.6.3-4">BBR.bw_latest: a 1-round-trip max of delivered bandwidth (rs.delivery_rate).<a href="#section-4.5.6.3-4" class="pilcrow">¶</a></p>
<p id="section-4.5.6.3-5">BBR.inflight_latest: a 1-round-trip max of delivered volume of data (rs.delivered).<a href="#section-4.5.6.3-5" class="pilcrow">¶</a></p>
<p id="section-4.5.6.3-6">Upon the ACK at the end of each round that encountered a newly-marked loss, the flow updates its model (bw_lo and inflight_lo) as follows:<a href="#section-4.5.6.3-6" class="pilcrow">¶</a></p>
<div class="alignLeft art-text artwork" id="section-4.5.6.3-7">
<pre>
      bw_lo     = max(       bw_latest, BBRBeta *       bw_lo )
inflight_lo     = max( inflight_latest, BBRBeta * inflight_lo )
</pre><a href="#section-4.5.6.3-7" class="pilcrow">¶</a>
</div>
<p id="section-4.5.6.3-8">This logic can be represented as follows:<a href="#section-4.5.6.3-8" class="pilcrow">¶</a></p>
<div class="alignLeft art-text artwork" id="section-4.5.6.3-9">
<pre>
  /* Near start of ACK processing: */
  BBRUpdateLatestDeliverySignals():
    BBR.loss_round_start = 0
    BBR.bw_latest       = max(BBR.bw_latest,       rs.delivery_rate)
    BBR.inflight_latest = max(BBR.inflight_latest, rs.delivered)
    if (rs.prior_delivered &gt;= BBR.loss_round_delivered)
      BBR.loss_round_delivered = C.delivered
      BBR.loss_round_start = 1

  /* Near end of ACK processing: */
  BBRAdvanceLatestDeliverySignals():
    if (BBR.loss_round_start)
      BBR.bw_latest       = rs.delivery_rate
      BBR.inflight_latest = rs.delivered

  BBRResetCongestionSignals():
    BBR.loss_in_round = 0
    BBR.bw_latest = 0
    BBR.inflight_latest = 0

  /* Update congestion state on every ACK */
  BBRUpdateCongestionSignals():
    BBRUpdateMaxBw()
    if (rs.losses &gt; 0)
      BBR.loss_in_round = 1
    if (!BBR.loss_round_start)
      return  /* wait until end of round trip */
    BBRAdaptLowerBoundsFromCongestion()
    BBR.loss_in_round = 0

  /* Once per round-trip respond to congestion */
  BBRAdaptLowerBoundsFromCongestion():
    if (BBRIsProbingBW())
      return
    if (BBR.loss_in_round())
      BBRInitLowerBounds()
      BBRLossLowerBounds()

  /* Handle the first congestion episode in this cycle */
  BBRInitLowerBounds():
    if (BBR.bw_lo == Infinity)
      BBR.bw_lo = BBR.max_bw
    if (BBR.inflight_lo == Infinity)
      BBR.inflight_lo = cwnd

  /* Adjust model once per round based on loss */
  BBRLossLowerBounds()
    BBR.bw_lo       = max(BBR.bw_latest,
                          BBRBeta * BBR.bw_lo)
    BBR.inflight_lo = max(BBR.inflight_latest,
                          BBRBeta * BBR.infligh_lo)

  BBRResetLowerBounds():
    BBR.bw_lo       = Infinity
    BBR.inflight_lo = Infinity

  BBRBoundBWForModel():
    BBR.bw = min(BBR.max_bw, BBR.bw_lo, BBR.bw_hi)

</pre><a href="#section-4.5.6.3-9" class="pilcrow">¶</a>
</div>
</section>
</div>
</section>
</div>
</section>
</div>
<div id="updating-control-parameters">
<section id="section-4.6">
        <h3 id="name-updating-control-parameters">
<a href="#section-4.6" class="section-number selfRef">4.6. </a><a href="#name-updating-control-parameters" class="section-name selfRef">Updating Control Parameters</a>
        </h3>
<p id="section-4.6-1">BBR uses three distinct but interrelated control parameters: pacing rate, send quantum, and congestion window (cwnd).<a href="#section-4.6-1" class="pilcrow">¶</a></p>
<div id="summary-of-control-behavior-in-the-state-machine">
<section id="section-4.6.1">
          <h4 id="name-summary-of-control-behavior">
<a href="#section-4.6.1" class="section-number selfRef">4.6.1. </a><a href="#name-summary-of-control-behavior" class="section-name selfRef">Summary of Control Behavior in the State Machine</a>
          </h4>
<p id="section-4.6.1-1">The following table summarizes how BBR modulates the control parameters in each state. In the table below, the semantics of the columns are as follows:<a href="#section-4.6.1-1" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-4.6.1-2.1">State: the state in the BBR state machine, as depicted in the "State Transition Diagram" section above.<a href="#section-4.6.1-2.1" class="pilcrow">¶</a>
</li>
            <li class="normal" id="section-4.6.1-2.2">Tactic: The tactic chosen from the "State Machine Tactics" subsection above: "accel" refers to acceleration, "decel" to deceleration, and "cruise" to cruising.<a href="#section-4.6.1-2.2" class="pilcrow">¶</a>
</li>
            <li class="normal" id="section-4.6.1-2.3">Pacing Gain: the value used for BBR.pacing_gain in the given state.<a href="#section-4.6.1-2.3" class="pilcrow">¶</a>
</li>
            <li class="normal" id="section-4.6.1-2.4">Cwnd Gain: the value used for BBR.cwnd_gain in the given state.<a href="#section-4.6.1-2.4" class="pilcrow">¶</a>
</li>
            <li class="normal" id="section-4.6.1-2.5">Rate Cap: the rate values applied as bounds on the BBR.max_bw value applied to compute BBR.bw.<a href="#section-4.6.1-2.5" class="pilcrow">¶</a>
</li>
            <li class="normal" id="section-4.6.1-2.6">Volume Cap: the volume values applied as bounds on the BBR.max_inflight value to compute cwnd.<a href="#section-4.6.1-2.6" class="pilcrow">¶</a>
</li>
          </ul>
<p id="section-4.6.1-3">The control behavior can be summarized as follows. Upon processing each ACK, BBR uses the values in the table below to compute BBR.bw in BBRBoundBWForModel(), and the cwnd in BBRBoundCwndForModel():<a href="#section-4.6.1-3" class="pilcrow">¶</a></p>
<div class="alignLeft art-text artwork" id="section-4.6.1-4">
<pre>
+-----------------+--------+--------+------+--------+------------------+
| State           | Tactic | Pacing | Cwnd | Rate   | Volume           |
|                 |        | Gain   | Gain | Cap    | Cap              |
+-----------------+--------+--------+------+--------+------------------+
| Startup         | accel  | 2.77   | 2    |        |                  |
|                 |        |        |      |        |                  |
+-----------------+--------+--------+------+--------+------------------+
| Drain           | decel  | 0.5    | 2    | bw_hi, | inflight_hi,     |
|                 |        |        |      | bw_lo  | inflight_lo      |
+-----------------+--------+--------+------+--------+------------------+
| ProbeBW_DOWN    | decel  | 0.9    | 2    | bw_hi, | inflight_hi,     |
|                 |        |        |      | bw_lo  | inflight_lo      |
+-----------------+--------+--------+------+--------+------------------+
| ProbeBW_CRUISE  | cruise | 1.0    | 2    | bw_hi, | 0.85*inflight_hi |
|                 |        |        |      | bw_lo  | inflight_lo      |
+-----------------+--------+--------+------+--------+------------------+
| ProbeBW_REFILL  | accel  | 1.0    | 2    | bw_hi  | inflight_hi      |
|                 |        |        |      |        |                  |
+-----------------+--------+--------+------+--------+------------------+
| ProbeBW_UP      | accel  | 1.25   | 2    | bw_hi  | inflight_hi      |
|                 |        |        |      |        |                  |
+-----------------+--------+--------+------+--------+------------------+
| ProbeRTT        | decel  | 1.0    | 0.5  | bw_hi, | 0.85*inflight_hi |
|                 |        |        |      | bw_lo  | inflight_lo      |
+-----------------+--------+--------+------+--------+------------------+
</pre><a href="#section-4.6.1-4" class="pilcrow">¶</a>
</div>
</section>
</div>
<div id="pacing-rate-bbrpacingrate">
<section id="section-4.6.2">
          <h4 id="name-pacing-rate-bbrpacing_rate">
<a href="#section-4.6.2" class="section-number selfRef">4.6.2. </a><a href="#name-pacing-rate-bbrpacing_rate" class="section-name selfRef">Pacing Rate: BBR.pacing_rate</a>
          </h4>
<p id="section-4.6.2-1">To help match the packet-arrival rate to the bottleneck bandwidth available to the flow, BBR paces data packets. Pacing enforces a maximum rate at which BBR schedules quanta of packets for transmission.<a href="#section-4.6.2-1" class="pilcrow">¶</a></p>
<p id="section-4.6.2-2">The sending host implements pacing by maintaining inter-quantum spacing at the time each packet is scheduled for departure, calculating the next departure time for a packet for a given flow (BBR.next_departure_time) as a function of the most recent packet size and the current pacing rate, as follows:<a href="#section-4.6.2-2" class="pilcrow">¶</a></p>
<div class="alignLeft art-text artwork" id="section-4.6.2-3">
<pre>
  BBR.next_departure_time = max(Now(), BBR.next_departure_time)
  packet.departure_time = BBR.next_departure_time
  pacing_delay = packet.size / BBR.pacing_rate
  BBR.next_departure_time = BBR.next_departure_time + pacing_delay
</pre><a href="#section-4.6.2-3" class="pilcrow">¶</a>
</div>
<p id="section-4.6.2-4">To adapt to the bottleneck, in general BBR sets the pacing rate to be proportional to bw, with a dynamic gain, or scaling factor of proportionality, called pacing_gain.<a href="#section-4.6.2-4" class="pilcrow">¶</a></p>
<p id="section-4.6.2-5">When a BBR flow starts it has no bw estimate (bw is 0). So in this case it sets an initial pacing rate based on the transport sender implementation's initial congestion window ("InitialCwnd", e.g. from [RFC6928]), the initial SRTT (smoothed round-trip time) after the first non-zero RTT sample, and the initial pacing_gain:<a href="#section-4.6.2-5" class="pilcrow">¶</a></p>
<div class="alignLeft art-text artwork" id="section-4.6.2-6">
<pre>
  BBRInitPacingRate():
    nominal_bandwidth = InitialCwnd / (SRTT ? SRTT : 1ms)
    BBR.pacing_rate =  BBRStartupPacingGain * nominal_bandwidth
</pre><a href="#section-4.6.2-6" class="pilcrow">¶</a>
</div>
<p id="section-4.6.2-7">After initialization, on each data ACK BBR updates its pacing rate to be proportional to bw, as long as it estimates that it has filled the pipe (BBR.filled_pipe is true; see the "Startup" section for details), or doing so increases the pacing rate. Limiting the pacing rate updates in this way helps the connection probe robustly for bandwidth until it estimates it has reached its full available bandwidth ("filled the pipe"). In particular, this prevents the pacing rate from being reduced when the connection has only seen application-limited bandwidth samples. BBR updates the pacing rate on each ACK by executing the BBRSetPacingRate() step as follows:<a href="#section-4.6.2-7" class="pilcrow">¶</a></p>
<div class="alignLeft art-text artwork" id="section-4.6.2-8">
<pre>
  BBRSetPacingRateWithGain(pacing_gain):
    rate = pacing_gain * bw * (100 - BBRPacingMarginPercent) / 100
    if (BBR.filled_pipe || rate &gt; BBR.pacing_rate)
      BBR.pacing_rate = rate

  BBRSetPacingRate():
    BBRSetPacingRateWithGain(BBR.pacing_gain)
</pre><a href="#section-4.6.2-8" class="pilcrow">¶</a>
</div>
<p id="section-4.6.2-9">To help drive the network toward lower queues and low latency while maintaining high utilization, the BBRPacingMarginPercent constant of 1 aims to cause BBR to pace at 1% below the bw, on average.<a href="#section-4.6.2-9" class="pilcrow">¶</a></p>
</section>
</div>
<div id="send-quantum-bbrsendquantum">
<section id="section-4.6.3">
          <h4 id="name-send-quantum-bbrsend_quantu">
<a href="#section-4.6.3" class="section-number selfRef">4.6.3. </a><a href="#name-send-quantum-bbrsend_quantu" class="section-name selfRef">Send Quantum: BBR.send_quantum</a>
          </h4>
<p id="section-4.6.3-1">In order to amortize per-packet overheads involved in the sending process (host CPU, NIC processing, and interrupt processing delays), high-performance transport sender implementations (e.g., Linux TCP) often schedule an aggregate containing multiple packets (multiple SMSS) worth of data as a single quantum (using TSO, GSO, or other offload mechanisms). The BBR congestion control algorithm makes this control decision explicitly, dynamically calculating a quantum control parameter that specifies the maximum size of these transmission aggregates. This decision is based on a trade-off:<a href="#section-4.6.3-1" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-4.6.3-2.1">A smaller quantum is preferred at lower data rates because it results in shorter packet bursts, shorter queues, lower queueing delays, and lower rates of packet loss.<a href="#section-4.6.3-2.1" class="pilcrow">¶</a>
</li>
            <li class="normal" id="section-4.6.3-2.2">A bigger quantum can be required at higher data rates because it results in lower CPU overheads at the sending and receiving hosts, who can ship larger amounts of data with a single trip through the networking stack.<a href="#section-4.6.3-2.2" class="pilcrow">¶</a>
</li>
          </ul>
<p id="section-4.6.3-3">On each ACK, BBR runs BBRSetSendQuantum() to update BBR.send_quantum  as follows:<a href="#section-4.6.3-3" class="pilcrow">¶</a></p>
<div class="alignLeft art-text artwork" id="section-4.6.3-4">
<pre>
  BBRSetSendQuantum():
    if (BBR.pacing_rate &lt; 1.2 Mbps)
      floor = 1 * SMSS
    else
      floor = 2 * SMSS
    BBR.send_quantum = min(BBR.pacing_rate * 1ms, 64KBytes)
    BBR.send_quantum = max(BBR.send_quantum, floor)
</pre><a href="#section-4.6.3-4" class="pilcrow">¶</a>
</div>
<p id="section-4.6.3-5">A BBR implementation MAY use alternate approaches to select a BBR.send_quantum, as appropriate for the CPU overheads anticipated for senders and receivers, and buffering considerations anticipated in the network path. However, for the sake of the network and other users, a BBR implementation SHOULD attempt to use the smallest feasible quanta.<a href="#section-4.6.3-5" class="pilcrow">¶</a></p>
</section>
</div>
<div id="congestion-window">
<section id="section-4.6.4">
          <h4 id="name-congestion-window">
<a href="#section-4.6.4" class="section-number selfRef">4.6.4. </a><a href="#name-congestion-window" class="section-name selfRef">Congestion Window</a>
          </h4>
<p id="section-4.6.4-1">The congestion window, or cwnd, controls the maximum volume of data BBR allows in flight in the network at any time. It is the maximum volume of in-flight data that the algorithm estimates is appropriate for matching the current network path delivery process, given all available signals in the model, at any time scale. BBR adapts the cwnd based on its model of the network path and the state machine's decisions about how to probe that path.<a href="#section-4.6.4-1" class="pilcrow">¶</a></p>
<p id="section-4.6.4-2">By default, BBR grows its cwnd to meet its BBR.max_inflight, which models what's required for achieving full throughput, and as such is scaled to adapt to the estimated BDP computed from its path model. But BBR's selection of cwnd is designed to explicitly trade off among competing considerations that dynamically adapt to various conditions. So in loss recovery BBR more conservatively adjusts its sending behavior based on more recent delivery samples, and if BBR needs to re-probe the current BBR.min_rtt of the path then it cuts its cwnd accordingly. The following sections describe the various considerations that impact cwnd.<a href="#section-4.6.4-2" class="pilcrow">¶</a></p>
<div id="initial-cwnd">
<section id="section-4.6.4.1">
            <h5 id="name-initial-cwnd">
<a href="#section-4.6.4.1" class="section-number selfRef">4.6.4.1. </a><a href="#name-initial-cwnd" class="section-name selfRef">Initial cwnd</a>
            </h5>
<p id="section-4.6.4.1-1">BBR generally uses measurements to build a model of the network path and then adapts control decisions to the path based on that model. As such, the selection of the initial cwnd is considered to be outside the scope of the BBR algorithm, since at initialization there are no measurements yet upon which BBR can operate. Thus, at initialization, BBR uses the transport sender implementation's initial congestion window (e.g. from [RFC6298] for TCP).<a href="#section-4.6.4.1-1" class="pilcrow">¶</a></p>
</section>
</div>
<div id="computing-bbrmaxinflight">
<section id="section-4.6.4.2">
            <h5 id="name-computing-bbrmax_inflight">
<a href="#section-4.6.4.2" class="section-number selfRef">4.6.4.2. </a><a href="#name-computing-bbrmax_inflight" class="section-name selfRef">Computing BBR.max_inflight</a>
            </h5>
<p id="section-4.6.4.2-1">The BBR BBR.max_inflight is the upper bound on the volume of data BBR allows in flight. This bound is always in place, and dominates when all other considerations have been satisfied: the flow is not in loss recovery, does not need to probe BBR.min_rtt, and has accumulated confidence in its model parameters by receiving enough ACKs to gradually grow the current cwnd to meet the BBR.max_inflight.<a href="#section-4.6.4.2-1" class="pilcrow">¶</a></p>
<p id="section-4.6.4.2-2">On each ACK, BBR calculates the BBR.max_inflight in BBRUpdateMaxInflight() as follows:<a href="#section-4.6.4.2-2" class="pilcrow">¶</a></p>
<div class="alignLeft art-text artwork" id="section-4.6.4.2-3">
<pre>
  BBRBDPMultiple(gain):
    if (BBR.min_rtt == Inf)
      return InitialCwnd /* no valid RTT samples yet */
    BBR.bdp = BBR.bw * BBR.min_rtt
    return gain * BBR.bdp

  BBRQuantizationBudget(inflight)
    BBRUpdateOffloadBudget()
    inflight = max(inflight, BBR.offload_budget)
    inflight = max(inflight, BBRMinPipeCwnd)
      if (BBR.state == ProbeBW &amp;&amp; BBR.cycle_idx == ProbeBW_UP)
      inflight += 2
    return inflight

  BBRInflight(gain):
    inflight = BBRBDPMultiple(gain)
    return BBRQuantizationBudget(inflight)

  BBRUpdateMaxInflight():
    BBRUpdateAggregationBudget()
    inflight = BBRBDPMultiple(BBR.cwnd_gain)
    inflight += BBR.extra_acked
    BBR.max_inflight = BBRQuantizationBudget(inflight)
</pre><a href="#section-4.6.4.2-3" class="pilcrow">¶</a>
</div>
<p id="section-4.6.4.2-4">The "estimated_bdp" term tries to allow enough packets in flight to fully utilize the estimated BDP of the path, by allowing the flow to send at BBR.bw for a duration of BBR.min_rtt. Scaling up the BDP by BBR.cwnd_gain bounds in-flight data to a small multiple of the BDP, to handle common network and receiver behavior, such as delayed, stretched, or aggregated ACKs [A15]. The "quanta" term allows enough quanta in flight on the sending and receiving hosts to reach high throughput even in environments using offload mechanisms.<a href="#section-4.6.4.2-4" class="pilcrow">¶</a></p>
</section>
</div>
<div id="minimum-cwnd-for-pipelining">
<section id="section-4.6.4.3">
            <h5 id="name-minimum-cwnd-for-pipelining">
<a href="#section-4.6.4.3" class="section-number selfRef">4.6.4.3. </a><a href="#name-minimum-cwnd-for-pipelining" class="section-name selfRef">Minimum cwnd for Pipelining</a>
            </h5>
<p id="section-4.6.4.3-1">For BBR.max_inflight, BBR imposes a floor of BBRMinPipeCwnd (4 packets, i.e. 4 * SMSS). This floor helps ensure that even at very low BDPs, and with a transport like TCP where a receiver may ACK only every alternate SMSS of data, there are enough packets in flight to maintain full pipelining. In particular BBR tries to allow at least 2 data packets in flight and ACKs for at least 2 data packets on the path from receiver to sender.<a href="#section-4.6.4.3-1" class="pilcrow">¶</a></p>
</section>
</div>
<div id="modulating-cwnd-in-loss-recovery">
<section id="section-4.6.4.4">
            <h5 id="name-modulating-cwnd-in-loss-rec">
<a href="#section-4.6.4.4" class="section-number selfRef">4.6.4.4. </a><a href="#name-modulating-cwnd-in-loss-rec" class="section-name selfRef">Modulating cwnd in Loss Recovery</a>
            </h5>
<p id="section-4.6.4.4-1">BBR interprets loss as a hint that there may be recent changes in path behavior that are not yet fully reflected in its model of the path, and thus it needs to be more conservative.<a href="#section-4.6.4.4-1" class="pilcrow">¶</a></p>
<p id="section-4.6.4.4-2">Upon a retransmission timeout (RTO), BBR conservatively reduces cwnd to a value that will allow 1 SMSS to be transmitted. Then BBR gradually increases cwnd using the normal approach outlined below in "Core cwnd Adjustment Mechanism".<a href="#section-4.6.4.4-2" class="pilcrow">¶</a></p>
<p id="section-4.6.4.4-3">When a BBR sender detects packet loss but there are still packets in flight, on the first round of the loss-repair process BBR temporarily reduces the cwnd to match the current delivery rate as ACKs arrive. On second and later rounds of loss repair, it ensures the sending rate never exceeds twice the current delivery rate as ACKs arrive.<a href="#section-4.6.4.4-3" class="pilcrow">¶</a></p>
<p id="section-4.6.4.4-4">When BBR exits loss recovery it restores the cwnd to the "last known good" value that cwnd held before entering recovery. This applies equally whether the flow exits loss recovery because it finishes repairing all losses or because it executes an "undo" event after inferring that a loss recovery event was spurious.<a href="#section-4.6.4.4-4" class="pilcrow">¶</a></p>
<p id="section-4.6.4.4-5">There are several ways to implement this high-level design for updating cwnd in loss recovery. One is as follows:<a href="#section-4.6.4.4-5" class="pilcrow">¶</a></p>
<p id="section-4.6.4.4-6">Upon retransmission timeout (RTO):<a href="#section-4.6.4.4-6" class="pilcrow">¶</a></p>
<div class="alignLeft art-text artwork" id="section-4.6.4.4-7">
<pre>
  BBROnEnterRTO():
    BBR.prior_cwnd = BBRSaveCwnd()
    cwnd = packets_in_flight + 1
</pre><a href="#section-4.6.4.4-7" class="pilcrow">¶</a>
</div>
<p id="section-4.6.4.4-8">Upon entering Fast Recovery, set cwnd to the number of packets still in flight (allowing at least one for a fast retransmit):<a href="#section-4.6.4.4-8" class="pilcrow">¶</a></p>
<div class="alignLeft art-text artwork" id="section-4.6.4.4-9">
<pre>
  BBROnEnterFastRecovery():
    BBR.prior_cwnd = BBRSaveCwnd()
    cwnd = packets_in_flight + max(rs.newly_acked, 1)
    BBR.packet_conservation = true
</pre><a href="#section-4.6.4.4-9" class="pilcrow">¶</a>
</div>
<p id="section-4.6.4.4-10">Upon every ACK in Fast Recovery, run the following BBRModulateCwndForRecovery() steps, which help ensure packet conservation on the first round of recovery, and sending at no more than twice the current delivery rate on later rounds of recovery (given that "rs.newly_acked" packets were newly marked ACKed or SACKed and "rs.newly_lost" were newly marked lost):<a href="#section-4.6.4.4-10" class="pilcrow">¶</a></p>
<div class="alignLeft art-text artwork" id="section-4.6.4.4-11">
<pre>
  BBRModulateCwndForRecovery():
    if (rs.newly_lost &gt; 0)
      cwnd = max(cwnd - rs.newly_lost, 1)
    if (BBR.packet_conservation)
      cwnd = max(cwnd, packets_in_flight + rs.newly_acked)
</pre><a href="#section-4.6.4.4-11" class="pilcrow">¶</a>
</div>
<p id="section-4.6.4.4-12">After one round-trip in Fast Recovery:<a href="#section-4.6.4.4-12" class="pilcrow">¶</a></p>
<div class="alignLeft art-text artwork" id="section-4.6.4.4-13">
<pre>
  BBR.packet_conservation = false
</pre><a href="#section-4.6.4.4-13" class="pilcrow">¶</a>
</div>
<p id="section-4.6.4.4-14">Upon exiting loss recovery (RTO recovery or Fast Recovery), either by repairing all losses or undoing recovery, BBR restores the best-known cwnd value we had upon entering loss recovery:<a href="#section-4.6.4.4-14" class="pilcrow">¶</a></p>
<div class="alignLeft art-text artwork" id="section-4.6.4.4-15">
<pre>
  BBR.packet_conservation = false
  BBRRestoreCwnd()
</pre><a href="#section-4.6.4.4-15" class="pilcrow">¶</a>
</div>
<p id="section-4.6.4.4-16">Note that exiting loss recovery happens during ACK processing, and at the end of ACK processing BBRBoundCwndForModel() will bound the cwnd based on the current model parameters. Thus the cwnd and pacing rate after loss recovery will generally be smaller than the values entering loss recovery.<a href="#section-4.6.4.4-16" class="pilcrow">¶</a></p>
<p id="section-4.6.4.4-17">The BBRSaveCwnd() and BBRRestoreCwnd() helpers help remember and restore the last-known good cwnd (the latest cwnd unmodulated by loss recovery or ProbeRTT), and is defined as follows:<a href="#section-4.6.4.4-17" class="pilcrow">¶</a></p>
<div class="alignLeft art-text artwork" id="section-4.6.4.4-18">
<pre>
  BBRSaveCwnd():
    if (!InLossRecovery() and BBR.state != ProbeRTT)
      return cwnd
    else
      return max(BBR.prior_cwnd, cwnd)

  BBRRestoreCwnd():
    cwnd = max(cwnd, BBR.prior_cwnd)
</pre><a href="#section-4.6.4.4-18" class="pilcrow">¶</a>
</div>
</section>
</div>
<div id="modulating-cwnd-in-probertt">
<section id="section-4.6.4.5">
            <h5 id="name-modulating-cwnd-in-probertt">
<a href="#section-4.6.4.5" class="section-number selfRef">4.6.4.5. </a><a href="#name-modulating-cwnd-in-probertt" class="section-name selfRef">Modulating cwnd in ProbeRTT</a>
            </h5>
<p id="section-4.6.4.5-1">If BBR decides it needs to enter the ProbeRTT state (see the "ProbeRTT" section below), its goal is to quickly reduce the volume of in-flight data and drain the bottleneck queue, thereby allowing measurement of BBR.min_rtt. To implement this mode, BBR bounds the cwnd to BBRMinPipeCwnd, the minimal value that allows pipelining (see the "Minimum cwnd for Pipelining" section, above):<a href="#section-4.6.4.5-1" class="pilcrow">¶</a></p>
<div class="alignLeft art-text artwork" id="section-4.6.4.5-2">
<pre>
  BBRProbeRTTCwnd():
    probe_rtt_cwnd = BBRBDPMultiple(BBR.bw, BBRProbeRTTCwndGain)
    probe_rtt_cwnd = max(probe_rtt_cwnd, BBRMinPipeCwnd)
    return probe_rtt_cwnd

  BBRBoundCwndForProbeRTT():
    if (BBR.state == ProbeRTT)
      cwnd = min(cwnd, BBRProbeRTTCwnd())
</pre><a href="#section-4.6.4.5-2" class="pilcrow">¶</a>
</div>
</section>
</div>
<div id="core-cwnd-adjustment-mechanism">
<section id="section-4.6.4.6">
            <h5 id="name-core-cwnd-adjustment-mechan">
<a href="#section-4.6.4.6" class="section-number selfRef">4.6.4.6. </a><a href="#name-core-cwnd-adjustment-mechan" class="section-name selfRef">Core cwnd Adjustment Mechanism</a>
            </h5>
<p id="section-4.6.4.6-1">The network path and traffic traveling over it can make sudden dramatic changes. To adapt to these changes smoothly and robustly, and reduce packet losses in such cases, BBR uses a conservative strategy. When cwnd is above the BBR.max_inflight derived from BBR's path model, BBR cuts the cwnd immediately to the BBR.max_inflight. When cwnd is below BBR.max_inflight, BBR raises the cwnd gradually and cautiously, increasing cwnd by no more than the amount of data acknowledged (cumulatively or selectively) upon each ACK.<a href="#section-4.6.4.6-1" class="pilcrow">¶</a></p>
<p id="section-4.6.4.6-2">Specifically, on each ACK that acknowledges "rs.newly_acked" packets as newly ACKed or SACKed, BBR runs the following BBRSetCwnd() steps to update cwnd:<a href="#section-4.6.4.6-2" class="pilcrow">¶</a></p>
<div class="alignLeft art-text artwork" id="section-4.6.4.6-3">
<pre>
  BBRSetCwnd():
    BBRUpdateMaxInflight()
    BBRModulateCwndForRecovery()
    if (!BBR.packet_conservation) {
      if (BBR.filled_pipe)
        cwnd = min(cwnd + rs.newly_acked, BBR.max_inflight)
      else if (cwnd &lt; BBR.max_inflight || C.delivered &lt; InitialCwnd)
        cwnd = cwnd + rs.newly_acked
      cwnd = max(cwnd, BBRMinPipeCwnd)
    }
    BBRBoundCwndForProbeRTT()
    BBRBoundCwndForModel()
</pre><a href="#section-4.6.4.6-3" class="pilcrow">¶</a>
</div>
<p id="section-4.6.4.6-4">There are several considerations embodied in the logic above. If BBR has measured enough samples to achieve confidence that it has filled the pipe (see the description of BBR.filled_pipe in the "Startup" section below), then it increases its cwnd based on the number of packets delivered, while bounding its cwnd to be no larger than the BBR.max_inflight adapted to the estimated BDP. Otherwise, if the cwnd is below the BBR.max_inflight, or the sender has marked so little data delivered (less than InitialCwnd) that it does not yet judge its BBR.max_bw estimate and BBR.max_inflight as useful, then it increases cwnd without bounding it to be below BBR.max_inflight. Finally, BBR imposes a floor of BBRMinPipeCwnd in order to allow pipelining even with small BDPs (see the "Minimum cwnd for Pipelining" section, above).<a href="#section-4.6.4.6-4" class="pilcrow">¶</a></p>
</section>
</div>
<div id="bounding-cwnd-based-on-recent-congestion">
<section id="section-4.6.4.7">
            <h5 id="name-bounding-cwnd-based-on-rece">
<a href="#section-4.6.4.7" class="section-number selfRef">4.6.4.7. </a><a href="#name-bounding-cwnd-based-on-rece" class="section-name selfRef">Bounding cwnd Based on Recent Congestion</a>
            </h5>
<p id="section-4.6.4.7-1">Finally, BBR bounds the cwnd based on recent congestion, as outlined in the "Volume Cap" column of the table in the "Summary of Control Behavior in the State Machine" section:<a href="#section-4.6.4.7-1" class="pilcrow">¶</a></p>
<div class="alignLeft art-text artwork" id="section-4.6.4.7-2">
<pre>
  BBRBoundCwndForModel():
    cap = Infinity
    if (IsInAProbeBWState() and
        BBR.state != ProbeBW_CRUISE)
      cap = BBR.inflight_hi
    else if (BBR.state == ProbeRTT or
             BBR.state == ProbeBW_CRUISE)
      cap = BBRInflightWithHeadroom()

    /* apply inflight_lo (possibly infinite): */
    cap = min(cap, BBR.inflight_lo)
    cap = max(cap, BBRMinPipeCwnd)
    cwnd = min(cwnd, cap)
</pre><a href="#section-4.6.4.7-2" class="pilcrow">¶</a>
</div>
</section>
</div>
</section>
</div>
</section>
</div>
</section>
</div>
<div id="implementation-status">
<section id="section-5">
      <h2 id="name-implementation-status">
<a href="#section-5" class="section-number selfRef">5. </a><a href="#name-implementation-status" class="section-name selfRef">Implementation Status</a>
      </h2>
<p id="section-5-1">This section records the status of known implementations of the algorithm defined by this specification at the time of posting of this Internet-Draft, and is based on a proposal described in [RFC7942]. The description of implementations in this section is intended to assist the IETF in its decision processes in progressing drafts to RFCs. Please note that the listing of any individual implementation here does not imply endorsement by the IETF. Furthermore, no effort has been spent to verify the information presented here that was supplied by IETF contributors. This is not intended as, and must not be construed to be, a catalog of available implementations or their features.  Readers are advised to note that other implementations may exist.<a href="#section-5-1" class="pilcrow">¶</a></p>
<p id="section-5-2">According to [RFC7942], "this will allow reviewers and working groups to assign due consideration to documents that have the benefit of running code, which may serve as evidence of valuable experimentation and feedback that have made the implemented protocols more mature.  It is up to the individual working groups to use this information as they see fit".<a href="#section-5-2" class="pilcrow">¶</a></p>
<p id="section-5-3">As of the time of writing, the following implementations of BBR have been publicly released:<a href="#section-5-3" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-5-4.1">
          <p id="section-5-4.1.1">Linux TCP<a href="#section-5-4.1.1" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-5-4.1.2.1">
              <p id="section-5-4.1.2.1.1">Source code URL:<a href="#section-5-4.1.2.1.1" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-5-4.1.2.1.2.1">https://github.com/google/bbr/blob/v2alpha/README.md<a href="#section-5-4.1.2.1.2.1" class="pilcrow">¶</a>
</li>
                <li class="normal" id="section-5-4.1.2.1.2.2">https://github.com/google/bbr/blob/v2alpha/net/ipv4/tcp_bbr2.c<a href="#section-5-4.1.2.1.2.2" class="pilcrow">¶</a>
</li>
              </ul>
</li>
            <li class="normal" id="section-5-4.1.2.2">Source: Google<a href="#section-5-4.1.2.2" class="pilcrow">¶</a>
</li>
            <li class="normal" id="section-5-4.1.2.3">Maturity: production<a href="#section-5-4.1.2.3" class="pilcrow">¶</a>
</li>
            <li class="normal" id="section-5-4.1.2.4">License: dual-licensed: GPLv2 / BSD<a href="#section-5-4.1.2.4" class="pilcrow">¶</a>
</li>
            <li class="normal" id="section-5-4.1.2.5">Contact: https://groups.google.com/d/forum/bbr-dev<a href="#section-5-4.1.2.5" class="pilcrow">¶</a>
</li>
            <li class="normal" id="section-5-4.1.2.6">Last updated: August 21, 2021<a href="#section-5-4.1.2.6" class="pilcrow">¶</a>
</li>
          </ul>
</li>
        <li class="normal" id="section-5-4.2">
          <p id="section-5-4.2.1">QUIC<a href="#section-5-4.2.1" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-5-4.2.2.1">
              <p id="section-5-4.2.2.1.1">Source code URLs:<a href="#section-5-4.2.2.1.1" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-5-4.2.2.1.2.1">https://cs.chromium.org/chromium/src/net/third_party/quiche/src/quic/core/congestion_control/bbr2_sender.cc<a href="#section-5-4.2.2.1.2.1" class="pilcrow">¶</a>
</li>
                <li class="normal" id="section-5-4.2.2.1.2.2">https://cs.chromium.org/chromium/src/net/third_party/quiche/src/quic/core/congestion_control/bbr2_sender.h<a href="#section-5-4.2.2.1.2.2" class="pilcrow">¶</a>
</li>
              </ul>
</li>
            <li class="normal" id="section-5-4.2.2.2">Source: Google<a href="#section-5-4.2.2.2" class="pilcrow">¶</a>
</li>
            <li class="normal" id="section-5-4.2.2.3">Maturity: production<a href="#section-5-4.2.2.3" class="pilcrow">¶</a>
</li>
            <li class="normal" id="section-5-4.2.2.4">License: BSD-style<a href="#section-5-4.2.2.4" class="pilcrow">¶</a>
</li>
            <li class="normal" id="section-5-4.2.2.5">Contact: https://groups.google.com/d/forum/bbr-dev<a href="#section-5-4.2.2.5" class="pilcrow">¶</a>
</li>
            <li class="normal" id="section-5-4.2.2.6">Last updated: October 21, 2021<a href="#section-5-4.2.2.6" class="pilcrow">¶</a>
</li>
          </ul>
</li>
      </ul>
</section>
</div>
<div id="security-considerations">
<section id="section-6">
      <h2 id="name-security-considerations-8">
<a href="#section-6" class="section-number selfRef">6. </a><a href="#name-security-considerations-8" class="section-name selfRef">Security Considerations</a>
      </h2>
<p id="section-6-1">This proposal makes no changes to the underlying security of transport protocols or congestion control algorithms. BBR shares the same security considerations as the existing standard congestion control algorithm [RFC5681].<a href="#section-6-1" class="pilcrow">¶</a></p>
</section>
</div>
<div id="iana-considerations">
<section id="section-7">
      <h2 id="name-iana-considerations-8">
<a href="#section-7" class="section-number selfRef">7. </a><a href="#name-iana-considerations-8" class="section-name selfRef">IANA Considerations</a>
      </h2>
<p id="section-7-1">This document has no IANA actions. Here we are using that phrase, suggested by [RFC5226], because BBR does not modify or extend the wire format of any network protocol, nor does it add new dependencies on assigned numbers. BBR involves only a change to the congestion control algorithm of a transport sender, and does not involve changes in the network, the receiver, or any network protocol.<a href="#section-7-1" class="pilcrow">¶</a></p>
<p id="section-7-2">Note to RFC Editor: this section may be removed on publication as an RFC.<a href="#section-7-2" class="pilcrow">¶</a></p>
</section>
</div>
<div id="acknowledgments">
<section id="section-8">
      <h2 id="name-acknowledgments-4">
<a href="#section-8" class="section-number selfRef">8. </a><a href="#name-acknowledgments-4" class="section-name selfRef">Acknowledgments</a>
      </h2>
<p id="section-8-1">The authors are grateful to Len Kleinrock for his work on the theory underlying congestion control. We are indebted to Larry Brakmo for pioneering work on the Vegas [BP95] and New Vegas [B15] congestion control algorithms, which presaged many elements of BBR, and for Larry's advice and guidance during BBR's early development. The authors would also like to thank Kevin Yang, Priyaranjan Jha, Yousuk Seung, Luke Hsiao for their work on TCP BBR; Jana Iyengar, Victor Vasiliev, Bin Wu for their work on QUIC BBR; and Matt Mathis for his research work on the BBR algorithm and its implications [MM19]. We would also like to thank C. Stephen Gunn, Eric Dumazet, Nandita Dukkipati, Pawel Jurczyk, Biren Roy, David Wetherall, Amin Vahdat, Leonidas Kontothanassis, and the YouTube, google.com, Bandwidth Enforcer, and Google SRE teams for their invaluable help and support. We would like to thank Randall R. Stewart, Jim Warner, Loganaden Velvindron, Hiren Panchasara, and Adrian Zapletal for feedback and suggestions on earlier versions of this document.<a href="#section-8-1" class="pilcrow">¶</a></p>
</section>
</div>
<section id="section-9">
      <h2 id="name-references-8">
<a href="#section-9" class="section-number selfRef">9. </a><a href="#name-references-8" class="section-name selfRef">References</a>
      </h2>
<section id="section-9.1">
        <h3 id="name-normative-references-8">
<a href="#section-9.1" class="section-number selfRef">9.1. </a><a href="#name-normative-references-8" class="section-name selfRef">Normative References</a>
        </h3>
<dl class="references">
<dt id="RFC793">[RFC793]</dt>
        <dd>
<span class="refAuthor">Postel, J.</span>, <span class="refTitle">"Transmission Control Protocol"</span>, <time datetime="1981-09" class="refDate">September 1981</time>. </dd>
<dd class="break"></dd>
<dt id="RFC2018">[RFC2018]</dt>
        <dd>
<span class="refAuthor">Mathis, M.</span> and <span class="refAuthor">J. Mahdavi</span>, <span class="refTitle">"TCP Selective Acknowledgment Options"</span>, <span class="seriesInfo">RFC 2018</span>, <time datetime="1996-10" class="refDate">October 1996</time>, <span>&lt;<a href="http://www.rfc-editor.org/rfc/rfc2018.txt">http://www.rfc-editor.org/rfc/rfc2018.txt</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC7323">[RFC7323]</dt>
        <dd>
<span class="refAuthor">Borman, D.</span>, <span class="refAuthor">Braden, B.</span>, <span class="refAuthor">Jacobson, V.</span>, and <span class="refAuthor">R. Scheffenegger</span>, <span class="refTitle">"TCP Extensions for High Performance"</span>, <time datetime="2014-09" class="refDate">September 2014</time>. </dd>
<dd class="break"></dd>
<dt id="RFC2119">[RFC2119]</dt>
        <dd>
<span class="refAuthor">Bradner, S.</span>, <span class="refTitle">"Key words for use in RFCs to Indicate Requirement Levels"</span>, <span class="seriesInfo">RFC 2119</span>, <time datetime="1997-03" class="refDate">March 1997</time>, <span>&lt;<a href="http://www.rfc-editor.org/rfc/rfc2119.txt">http://www.rfc-editor.org/rfc/rfc2119.txt</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC5226">[RFC5226]</dt>
        <dd>
<span class="refAuthor">Narten, T.</span> and <span class="refAuthor">H. Alvestrand</span>, <span class="refTitle">"Guidelines for Writing an IANA Considerations Section in RFCs"</span>, <time datetime="2008-05" class="refDate">May 2008</time>. </dd>
<dd class="break"></dd>
<dt id="RFC6298">[RFC6298]</dt>
        <dd>
<span class="refAuthor">Paxson, V.</span>, <span class="refTitle">"Computing TCP's Retransmission Timer"</span>, <span class="seriesInfo">RFC 6298</span>, <time datetime="2011-06" class="refDate">June 2011</time>, <span>&lt;<a href="https://wiki.tools.ietf.org/html/rfc6298">https://wiki.tools.ietf.org/html/rfc6298</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC5681">[RFC5681]</dt>
        <dd>
<span class="refAuthor">Allman, M.</span>, <span class="refAuthor">Paxson, V.</span>, and <span class="refAuthor">E. Blanton</span>, <span class="refTitle">"TCP Congestion Control"</span>, <span class="seriesInfo">RFC 5681</span>, <time datetime="2009-09" class="refDate">September 2009</time>, <span>&lt;<a href="https://tools.ietf.org/html/rfc5681">https://tools.ietf.org/html/rfc5681</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC7942">[RFC7942]</dt>
        <dd>
<span class="refAuthor">Sheffer, Y.</span> and <span class="refAuthor">A. Farrel</span>, <span class="refTitle">"Improving Awareness of Running Code: The Implementation Status Section"</span>, <time datetime="2016-07" class="refDate">July 2016</time>. </dd>
<dd class="break"></dd>
<dt id="RFC8312">[RFC8312]</dt>
        <dd>
<span class="refAuthor">Rhee, I.</span>, <span class="refAuthor">Xu, L.</span>, <span class="refAuthor">Ha, S.</span>, <span class="refAuthor">Zimmermann, A.</span>, <span class="refAuthor">Eggert, L.</span>, and <span class="refAuthor">R. Scheffenegger</span>, <span class="refTitle">"CUBIC for Fast Long-Distance Networks"</span>, <time datetime="2018-02" class="refDate">February 2018</time>, <span>&lt;<a href="https://tools.ietf.org/html/rfc8312">https://tools.ietf.org/html/rfc8312</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC8985">[RFC8985]</dt>
        <dd>
<span class="refAuthor">Cheng, Y.</span>, <span class="refAuthor">Cardwell, N.</span>, <span class="refAuthor">Dukkipati, N.</span>, and <span class="refAuthor">P. Jha</span>, <span class="refTitle">"The RACK-TLP Loss Detection Algorithm for TCP"</span>, <span class="seriesInfo">RFC 8985</span>, <span class="seriesInfo">DOI 10.17487/RFC8985</span>, <time datetime="2021-02" class="refDate">February 2021</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc8985">https://www.rfc-editor.org/info/rfc8985</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC9000">[RFC9000]</dt>
        <dd>
<span class="refAuthor">Iyengar, J., Ed.</span> and <span class="refAuthor">M. Thomson, Ed.</span>, <span class="refTitle">"QUIC: A UDP-Based Multiplexed and Secure Transport"</span>, <span class="seriesInfo">RFC 9000</span>, <span class="seriesInfo">DOI 10.17487/RFC9000</span>, <time datetime="2021-05" class="refDate">May 2021</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc9000">https://www.rfc-editor.org/info/rfc9000</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC4340">[RFC4340]</dt>
      <dd>
<span class="refAuthor">Kohler, E.</span>, <span class="refAuthor">Handley, M.</span>, and <span class="refAuthor">S. Floyd</span>, <span class="refTitle">"Datagram Congestion Control Protocol (DCCP)"</span>, <span class="seriesInfo">RFC 4340</span>, <span class="seriesInfo">DOI 10.17487/RFC4340</span>, <time datetime="2006-03" class="refDate">March 2006</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc4340">https://www.rfc-editor.org/info/rfc4340</a>&gt;</span>. </dd>
<dd class="break"></dd>
</dl>
</section>
<section id="section-9.2">
        <h3 id="name-informative-references-8">
<a href="#section-9.2" class="section-number selfRef">9.2. </a><a href="#name-informative-references-8" class="section-name selfRef">Informative References</a>
        </h3>
<dl class="references">
<dt id="draft-cheng-iccrg-delivery-rate-estimation">[draft-cheng-iccrg-delivery-rate-estimation]</dt>
        <dd>
<span class="refAuthor">Cheng, Y.</span>, <span class="refAuthor">Cardwell, N.</span>, <span class="refAuthor">Hassas Yeganeh, S.</span>, and <span class="refAuthor">V. Jacobson</span>, <span class="refTitle">"Delivery Rate Estimation"</span>, <span class="refContent">Work in Progress</span>, <span class="seriesInfo">Internet-Draft, draft-cheng-iccrg-delivery-rate-estimation</span>, <time datetime="2021-11" class="refDate">November 2021</time>, <span>&lt;<a href="https://tools.ietf.org/html/draft-cheng-iccrg-delivery-rate-estimation">https://tools.ietf.org/html/draft-cheng-iccrg-delivery-rate-estimation</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="CCGHJ16">[CCGHJ16]</dt>
        <dd>
<span class="refAuthor">Cardwell, N.</span>, <span class="refAuthor">Cheng, Y.</span>, <span class="refAuthor">Gunn, C.</span>, <span class="refAuthor">Hassas Yeganeh, S.</span>, and <span class="refAuthor">V. Jacobson</span>, <span class="refTitle">"BBR: Congestion-Based Congestion Control"</span>, <span class="seriesInfo">ACM Queue Oct 2016</span>, <time datetime="2016-10" class="refDate">October 2016</time>, <span>&lt;<a href="http://queue.acm.org/detail.cfm?id=3022184">http://queue.acm.org/detail.cfm?id=3022184</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="CCGHJ17">[CCGHJ17]</dt>
        <dd>
<span class="refAuthor">Cardwell, N.</span>, <span class="refAuthor">Cheng, Y.</span>, <span class="refAuthor">Gunn, C.</span>, <span class="refAuthor">Hassas Yeganeh, S.</span>, and <span class="refAuthor">V. Jacobson</span>, <span class="refTitle">"BBR: Congestion-Based Congestion Control"</span>, <span class="seriesInfo">Communications of the ACM Feb 2017</span>, <time datetime="2017-02" class="refDate">February 2017</time>, <span>&lt;<a href="https://cacm.acm.org/magazines/2017/2/212428-bbr-congestion-based-congestion-control/pdf">https://cacm.acm.org/magazines/2017/2/212428-bbr-congestion-based-congestion-control/pdf</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="MM19">[MM19]</dt>
        <dd>
<span class="refAuthor">Mathis, M.</span> and <span class="refAuthor">J. Mahdavi</span>, <span class="refTitle">"Deprecating The TCP Macroscopic Model"</span>, <span class="seriesInfo">Computer Communication Review, vol. 49, no. 5, pp. 63-68 </span>, <time datetime="2019-10" class="refDate">October 2019</time>. </dd>
<dd class="break"></dd>
<dt id="BBRStartupPacingGain">[BBRStartupPacingGain]</dt>
        <dd>
<span class="refAuthor">Cardwell, N.</span>, <span class="refAuthor">Cheng, Y.</span>, <span class="refAuthor">Hassas Yeganeh, S.</span>, and <span class="refAuthor">V. Jacobson</span>, <span class="refTitle">"BBR Startup Pacing Gain: a Derivation"</span>, <time datetime="2018-06" class="refDate">June 2018</time>, <span>&lt;<a href="https://github.com/google/bbr/blob/master/Documentation/startup/gain/analysis/bbr_startup_gain.pdf">https://github.com/google/bbr/blob/master/Documentation/startup/gain/analysis/bbr_startup_gain.pdf</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="BBRDrainPacingGain">[BBRDrainPacingGain]</dt>
        <dd>
<span class="refAuthor">Cardwell, N.</span>, <span class="refAuthor">Cheng, Y.</span>, <span class="refAuthor">Hassas Yeganeh, S.</span>, and <span class="refAuthor">V. Jacobson</span>, <span class="refTitle">"BBR Drain Pacing Gain: a Derivation"</span>, <time datetime="2021-09" class="refDate">September 2021</time>, <span>&lt;<a href="https://github.com/google/bbr/blob/master/Documentation/startup/gain/analysis/bbr_drain_gain.pdf">https://github.com/google/bbr/blob/master/Documentation/startup/gain/analysis/bbr_drain_gain.pdf</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="draft-romo-iccrg-ccid5">[draft-romo-iccrg-ccid5]</dt>
        <dd>
<span class="refAuthor">Romo, N.</span>, <span class="refAuthor">Kim, J.</span>, and <span class="refAuthor">M. Amend</span>, <span class="refTitle">"Profile for Datagram Congestion Control Protocol (DCCP) Congestion Control ID 5"</span>, <span class="refContent">Work in Progress</span>, <span class="seriesInfo">Internet-Draft, draft-romo-iccrg-ccid5</span>, <time datetime="2021-10-25" class="refDate">25 October 2021</time>, <span>&lt;<a href="https://tools.ietf.org/html/draft-romo-iccrg-ccid5">https://tools.ietf.org/html/draft-romo-iccrg-ccid5</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="DC13">[DC13]</dt>
        <dd>
<span class="refAuthor">Dumazet, E.</span> and <span class="refAuthor">Y. Cheng</span>, <span class="refTitle">"TSO, fair queuing, pacing: three's a charm"</span>, <span class="seriesInfo">IETF 88 </span>, <time datetime="2013-11" class="refDate">November 2013</time>, <span>&lt;<a href="https://www.ietf.org/proceedings/88/slides/slides-88-tcpm-9.pdf">https://www.ietf.org/proceedings/88/slides/slides-88-tcpm-9.pdf</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="A15">[A15]</dt>
        <dd>
<span class="refAuthor">Abrahamsson, M.</span>, <span class="refTitle">"TCP ACK suppression"</span>, <span class="seriesInfo">IETF AQM mailing list </span>, <time datetime="2015-11" class="refDate">November 2015</time>, <span>&lt;<a href="https://www.ietf.org/mail-archive/web/aqm/current/msg01480.html">https://www.ietf.org/mail-archive/web/aqm/current/msg01480.html</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="Jac88">[Jac88]</dt>
        <dd>
<span class="refAuthor">Jacobson, V.</span>, <span class="refTitle">"Congestion Avoidance and Control"</span>, <span class="seriesInfo">SIGCOMM 1988, Computer Communication Review, vol. 18, no. 4, pp. 314-329 </span>, <time datetime="1988-08" class="refDate">August 1988</time>, <span>&lt;<a href="http://ee.lbl.gov/papers/congavoid.pdf">http://ee.lbl.gov/papers/congavoid.pdf</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="Jac90">[Jac90]</dt>
        <dd>
<span class="refAuthor">Jacobson, V.</span>, <span class="refTitle">"Modified TCP Congestion Avoidance Algorithm"</span>, <span class="seriesInfo">end2end-interest mailing list </span>, <time datetime="1990-04" class="refDate">April 1990</time>, <span>&lt;<a href="ftp://ftp.isi.edu/end2end/end2end-interest-1990.mail">ftp://ftp.isi.edu/end2end/end2end-interest-1990.mail</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="BP95">[BP95]</dt>
        <dd>
<span class="refAuthor">Brakmo, L.</span> and <span class="refAuthor">L. Peterson</span>, <span class="refTitle">"TCP Vegas: end-to-end congestion avoidance on a global Internet"</span>, <span class="seriesInfo">IEEE Journal on Selected Areas in Communications 13(8): 1465-1480 </span>, <time datetime="1995-10" class="refDate">October 1995</time>. </dd>
<dd class="break"></dd>
<dt id="B15">[B15]</dt>
        <dd>
<span class="refAuthor">Brakmo, L.</span>, <span class="refTitle">"TCP-NV: An Update to TCP-Vegas"</span>, <span class="seriesInfo"></span>, <time datetime="2015-08" class="refDate">August 2015</time>, <span>&lt;<a href="https://docs.google.com/document/d/1o-53jbO_xH-m9g2YCgjaf5bK8vePjWP6Mk0rYiRLK-U/edit">https://docs.google.com/document/d/1o-53jbO_xH-m9g2YCgjaf5bK8vePjWP6Mk0rYiRLK-U/edit</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="WS95">[WS95]</dt>
        <dd>
<span class="refAuthor">Wright, G.</span> and <span class="refAuthor">W. Stevens</span>, <span class="refTitle">"TCP/IP Illustrated, Volume 2: The Implementation"</span>, <span class="seriesInfo">Addison-Wesley </span>, <time datetime="1995" class="refDate">1995</time>. </dd>
<dd class="break"></dd>
<dt id="HRX08">[HRX08]</dt>
        <dd>
<span class="refAuthor">Ha, S.</span>, <span class="refAuthor">Rhee, I.</span>, and <span class="refAuthor">L. Xu</span>, <span class="refTitle">"CUBIC: A New TCP-Friendly High-Speed TCP Variant"</span>, <span class="seriesInfo">ACM SIGOPS Operating System Review </span>, <time datetime="2008" class="refDate">2008</time>. </dd>
<dd class="break"></dd>
<dt id="GK81">[GK81]</dt>
        <dd>
<span class="refAuthor">Gail, R.</span> and <span class="refAuthor">L. Kleinrock</span>, <span class="refTitle">"An Invariant Property of Computer Network Power"</span>, <span class="seriesInfo">Proceedings of the International Conference on Communications June, 1981</span>, <span>&lt;<a href="http://www.lk.cs.ucla.edu/data/files/Gail/power.pdf">http://www.lk.cs.ucla.edu/data/files/Gail/power.pdf</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="K79">[K79]</dt>
      <dd>
<span class="refAuthor">Kleinrock, L.</span>, <span class="refTitle">"Power and deterministic rules of thumb for probabilistic problems in computer communications"</span>, <span class="seriesInfo">Proceedings of the International Conference on Communications 1979</span>. </dd>
<dd class="break"></dd>
</dl>
</section>
</section>
<div id="authors-addresses">
<section id="appendix-A">
      <h2 id="name-authors-addresses-7">
<a href="#name-authors-addresses-7" class="section-name selfRef">Authors' Addresses</a>
      </h2>
<address class="vcard">
        <div dir="auto" class="left"><span class="fn nameRole">Neal Cardwell</span></div>
<div dir="auto" class="left"><span class="org">Google</span></div>
<div class="email">
<span>Email:</span>
<a href="mailto:ncardwell@google.com" class="email">ncardwell@google.com</a>
</div>
</address>
<address class="vcard">
        <div dir="auto" class="left"><span class="fn nameRole">Yuchung Cheng</span></div>
<div dir="auto" class="left"><span class="org">Google</span></div>
<div class="email">
<span>Email:</span>
<a href="mailto:ycheng@google.com" class="email">ycheng@google.com</a>
</div>
</address>
<address class="vcard">
        <div dir="auto" class="left"><span class="fn nameRole">Soheil Hassas Yeganeh</span></div>
<div dir="auto" class="left"><span class="org">Google</span></div>
<div class="email">
<span>Email:</span>
<a href="mailto:soheil@google.com" class="email">soheil@google.com</a>
</div>
</address>
<address class="vcard">
        <div dir="auto" class="left"><span class="fn nameRole">Ian Swett</span></div>
<div dir="auto" class="left"><span class="org">Google</span></div>
<div class="email">
<span>Email:</span>
<a href="mailto:ianswett@google.com" class="email">ianswett@google.com</a>
</div>
</address>
<address class="vcard">
        <div dir="auto" class="left"><span class="fn nameRole">Van Jacobson</span></div>
<div dir="auto" class="left"><span class="org">Google</span></div>
<div class="email">
<span>Email:</span>
<a href="mailto:vanj@google.com" class="email">vanj@google.com</a>
</div>
</address>
</section>
</div>
<script>const toc = document.getElementById("toc");
toc.querySelector("h2").addEventListener("click", e => {
  toc.classList.toggle("active");
});
toc.querySelector("nav").addEventListener("click", e => {
  toc.classList.remove("active");
});
</script>
</body>
</html>
