<!DOCTYPE html>
<html lang="en" class="Internet-Draft">
<head>
<meta charset="utf-8">
<meta content="Common,Latin" name="scripts">
<meta content="initial-scale=1.0" name="viewport">
<title>QUIC Loss Detection and Congestion Control</title>
<meta content="Jana Iyengar" name="author">
<meta content="Ian Swett" name="author">
<meta content="
       This document describes loss detection and congestion control mechanisms for
QUIC. 
    " name="description">
<meta content="xml2rfc 2.38.1" name="generator">
<meta content="draft-ietf-quic-recovery-25" name="ietf.draft">
<link href="/tmp/draft-ietf-quic-recovery-25-zUu6Ph.xml" type="application/rfc+xml" rel="alternate">
<link href="#copyright" rel="license">
<style type="text/css">/*

  NOTE: Changes at the bottom of this file overrides some earlier settings.

  Once the style has stabilized and has been adopted as an official RFC style,
  this can be consolidated so that style settings occur only in one place, but
  for now the contents of this file consists first of the initial CSS work as
  provided to the RFC Formatter (xml2rfc) work, followed by itemized and
  commented changes found necssary during the development of the v3
  formatters.

*/

/* fonts */
@import url('https://fonts.googleapis.com/css?family=Noto+Sans'); /* Sans-serif */
@import url('https://fonts.googleapis.com/css?family=Noto+Serif'); /* Serif (print) */
@import url('https://fonts.googleapis.com/css?family=Roboto+Mono'); /* Monospace */

@viewport {
  zoom: 1.0;
  width: extend-to-zoom;
}
@-ms-viewport {
  width: extend-to-zoom;
  zoom: 1.0;
}
/* general and mobile first */
html {
}
body {
  max-width: 90%;
  margin: 1.5em auto;
  color: #222;
  background-color: #fff;
  font-size: 14px;
  font-family: 'Noto Sans', Arial, Helvetica, sans-serif;
  line-height: 1.6;
  scroll-behavior: smooth;
}
.ears {
  display: none;
}

/* headings */
#title, h1, h2, h3, h4, h5, h6 {
  margin: 1em 0 0.5em;
  font-weight: bold;
  line-height: 1.3;
}
#title {
  clear: both;
  border-bottom: 1px solid #ddd;
  margin: 0 0 0.5em 0;
  padding: 1em 0 0.5em;
}
.author {
  padding-bottom: 4px;
}
h1 {
  font-size: 26px;
  margin: 1em 0;
}
h2 {
  font-size: 22px;
  margin-top: -20px;  /* provide offset for in-page anchors */
  padding-top: 33px;
}
h3 {
  font-size: 18px;
  margin-top: -36px;  /* provide offset for in-page anchors */
  padding-top: 42px;
}
h4 {
  font-size: 16px;
  margin-top: -36px;  /* provide offset for in-page anchors */
  padding-top: 42px;
}
h5, h6 {
  font-size: 14px;
}
#n-copyright-notice {
  border-bottom: 1px solid #ddd;
  padding-bottom: 1em;
  margin-bottom: 1em;
}
/* general structure */
p {
  padding: 0;
  margin: 0 0 1em 0;
  text-align: left;
}
div, span {
  position: relative;
}
div {
  margin: 0;
}
.alignRight.art-text {
  background-color: #f9f9f9;
  border: 1px solid #eee;
  border-radius: 3px;
  padding: 1em 1em 0;
  margin-bottom: 1.5em;
}
.alignRight.art-text pre {
  padding: 0;
}
.alignRight {
  margin: 1em 0;
}
.alignRight > *:first-child {
  border: none;
  margin: 0;
  float: right;
  clear: both;
}
.alignRight > *:nth-child(2) {
  clear: both;
  display: block;
  border: none;
}
svg {
  display: block;
}
.alignCenter.art-text {
  background-color: #f9f9f9;
  border: 1px solid #eee;
  border-radius: 3px;
  padding: 1em 1em 0;
  margin-bottom: 1.5em;
}
.alignCenter.art-text pre {
  padding: 0;
}
.alignCenter {
  margin: 1em 0;
}
.alignCenter > *:first-child {
  border: none;
  /* this isn't optimal, but it's an existence proof.  PrinceXML doesn't
     support flexbox yet.
  */
  display: table;
  margin: 0 auto;
}

/* lists */
ol, ul {
  padding: 0;
  margin: 0 0 1em 2em;
}
ol ol, ul ul, ol ul, ul ol {
  margin-left: 1em;
}
li {
  margin: 0 0 0.25em 0;
}
.ulCompact li {
  margin: 0;
}
ul.empty, .ulEmpty {
  list-style-type: none;
}
ul.empty li, .ulEmpty li {
  margin-top: 0.5em;
}
ul.compact, .ulCompact,
ol.compact, .olCompact {
  line-height: 100%;
  margin: 0 0 0 2em;
}

/* definition lists */
dl {
}
dl > dt {
  float: left;
  margin-right: 1em;
}
/* 
dl.nohang > dt {
  float: none;
}
*/
dl > dd {
  margin-bottom: .8em;
  min-height: 1.3em;
}
dl.compact > dd, .dlCompact > dd {
  margin-bottom: 0em;
}
dl > dd > dl {
  margin-top: 0.5em;
  margin-bottom: 0em;
}

/* links */
a {
  text-decoration: none;
}
a[href] {
  color: #22e; /* Arlen: WCAG 2019 */
}
a[href]:hover {
  background-color: #f2f2f2;
}
figcaption a[href],
a[href].selfRef {
  color: #222;
}
/* XXX probably not this:
a.selfRef:hover {
  background-color: transparent;
  cursor: default;
} */

/* Figures */
tt, code, pre, code {
  background-color: #f9f9f9;
  font-family: 'Roboto Mono', monospace;
}
pre {
  border: 1px solid #eee;
  margin: 0;
  padding: 1em;
}
img {
  max-width: 100%;
}
figure {
  margin: 0;
}
figure blockquote {
  margin: 0.8em 0.4em 0.4em;
}
figcaption {
  font-style: italic;
  margin: 0 0 1em 0;
}
@media screen {
  pre {
    overflow-x: auto;
    max-width: 100%;
    max-width: calc(100% - 22px);
  }
}

/* aside, blockquote */
aside, blockquote {
  margin-left: 0;
  padding: 1.2em 2em;
}
blockquote {
  background-color: #f9f9f9;
  color: #111; /* Arlen: WCAG 2019 */
  border: 1px solid #ddd;
  border-radius: 3px;
  margin: 1em 0;
}
cite {
  display: block;
  text-align: right;
  font-style: italic;
}

/* tables */
table {
  width: 100%;
  margin: 0 0 1em;
  border-collapse: collapse;
  border: 1px solid #eee;
}
th, td {
  text-align: left;
  vertical-align: top;
  padding: 0.5em 0.75em;
}
th {
  text-align: left;
  background-color: #e9e9e9;
}
tr:nth-child(2n+1) > td {
  background-color: #f5f5f5;
}
table caption {
  font-style: italic;
  margin: 0;
  padding: 0;
  text-align: left;
}
table p {
  /* XXX to avoid bottom margin on table row signifiers. If paragraphs should
     be allowed within tables more generally, it would be far better to select on a class. */
  margin: 0;
}

/* pilcrow */
a.pilcrow {
  color: #666; /* Arlen: AHDJ 2019 */
  text-decoration: none;
  visibility: hidden;
  user-select: none;
  -ms-user-select: none;
  -o-user-select:none;
  -moz-user-select: none;
  -khtml-user-select: none;
  -webkit-user-select: none;
  -webkit-touch-callout: none;
}
@media screen {
  aside:hover > a.pilcrow,
  p:hover > a.pilcrow,
  blockquote:hover > a.pilcrow,
  div:hover > a.pilcrow,
  li:hover > a.pilcrow,
  pre:hover > a.pilcrow {
    visibility: visible;
  }
  a.pilcrow:hover {
    background-color: transparent;
  }
}

/* misc */
hr {
  border: 0;
  border-top: 1px solid #eee;
}
.bcp14 {
  font-variant: small-caps;
}

.role {
  font-variant: all-small-caps;
}

/* info block */
#identifiers {
  margin: 0;
  font-size: 0.9em;
}
#identifiers dt {
  width: 3em;
  clear: left;
}
#identifiers dd {
  float: left;
  margin-bottom: 0;
}
#identifiers .authors .author {
  display: inline-block;
  margin-right: 1.5em;
}
#identifiers .authors .org {
  font-style: italic;
}

/* The prepared/rendered info at the very bottom of the page */
.docInfo {
  color: #666; /* Arlen: WCAG 2019 */
  font-size: 0.9em;
  font-style: italic;
  margin-top: 2em;
}
.docInfo .prepared {
  float: left;
}
.docInfo .prepared {
  float: right;
}

/* table of contents */
#toc  {
  padding: 0.75em 0 2em 0;
  margin-bottom: 1em;
}
nav.toc ul {
  margin: 0 0.5em 0 0;
  padding: 0;
  list-style: none;
}
nav.toc li {
  line-height: 1.3em;
  margin: 0.75em 0;
  padding-left: 1.2em;
  text-indent: -1.2em;
}
/* references */
.references dt {
  text-align: right;
  font-weight: bold;
  min-width: 7em;
}
.references dd {
  margin-left: 8em;
  overflow: auto;
}

.refInstance {
  margin-bottom: 1.25em;
}

.references .ascii {
  margin-bottom: 0.25em;
}

/* index */
.index ul {
  margin: 0 0 0 1em;
  padding: 0;
  list-style: none;
}
.index ul ul {
  margin: 0;
}
.index li {
  margin: 0;
  text-indent: -2em;
  padding-left: 2em;
  padding-bottom: 5px;
}
.indexIndex {
  margin: 0.5em 0 1em;
}
.index a {
  font-weight: 700;
}
/* make the index two-column on all but the smallest screens */
@media (min-width: 600px) {
  .index ul {
    -moz-column-count: 2;
    -moz-column-gap: 20px;
  }
  .index ul ul {
    -moz-column-count: 1;
    -moz-column-gap: 0;
  }
}

/* authors */
address.vcard {
  font-style: normal;
  margin: 1em 0;
}

address.vcard .nameRole {
  font-weight: 700;
  margin-left: 0;
}
address.vcard .label {
  font-family: "Noto Sans",Arial,Helvetica,sans-serif;
  margin: 0.5em 0;
}
address.vcard .type {
  display: none;
}
.alternative-contact {
  margin: 1.5em 0 1em;
}
hr.addr {
  border-top: 1px dashed;
  margin: 0;
  color: #ddd;
  max-width: calc(100% - 16px);
}

/* temporary notes */
.rfcEditorRemove::before {
  position: absolute;
  top: 0.2em;
  right: 0.2em;
  padding: 0.2em;
  content: "The RFC Editor will remove this note";
  color: #9e2a00; /* Arlen: WCAG 2019 */
  background-color: #ffd; /* Arlen: WCAG 2019 */
}
.rfcEditorRemove {
  position: relative;
  padding-top: 1.8em;
  background-color: #ffd; /* Arlen: WCAG 2019 */
  border-radius: 3px;
}
.cref {
  background-color: #ffd; /* Arlen: WCAG 2019 */
  padding: 2px 4px;
}
.crefSource {
  font-style: italic;
}
/* alternative layout for smaller screens */
@media screen and (max-width: 1023px) {
  body {
    padding-top: 2em;
  }
  #title {
    padding: 1em 0;
  }
  h1 {
    font-size: 24px;
  }
  h2 {
    font-size: 20px;
    margin-top: -18px;  /* provide offset for in-page anchors */
    padding-top: 38px;
  }
  #identifiers dd {
    max-width: 60%;
  }
  #toc {
    position: fixed;
    z-index: 2;
    top: 0;
    right: 0;
    padding: 0;
    margin: 0;
    background-color: inherit;
    border-bottom: 1px solid #ccc;
  }
  #toc h2 {
    margin: -1px 0 0 0;
    padding: 4px 0 4px 6px;
    padding-right: 1em;
    min-width: 190px;
    font-size: 1.1em;
    text-align: right;
    background-color: #444;
    color: white;
    cursor: pointer;
  }
  #toc h2::before { /* css hamburger */
    float: right;
    position: relative;
    width: 1em;
    height: 1px;
    left: -164px;
    margin: 6px 0 0 0;
    background: white none repeat scroll 0 0;
    box-shadow: 0 4px 0 0 white, 0 8px 0 0 white;
    content: "";
  }
  #toc nav {
    display: none;
    padding: 0.5em 1em 1em;
    overflow: auto;
    height: calc(100vh - 48px);
    border-left: 1px solid #ddd;
  }
}

/* alternative layout for wide screens */
@media screen and (min-width: 1024px) {
  body {
    max-width: 724px;
    margin: 42px auto;
    padding-left: 1.5em;
    padding-right: 29em;
  }
  #toc {
    position: fixed;
    top: 42px;
    right: 42px;
    width: 25%;
    margin: 0;
    padding: 0 1em;
    z-index: 1;
  }
  #toc h2 {
    border-top: none;
    border-bottom: 1px solid #ddd;
    font-size: 1em;
    font-weight: normal;
    margin: 0;
    padding: 0.25em 1em 1em 0;
  }
  #toc nav {
    display: block;
    height: calc(90vh - 84px);
    bottom: 0;
    padding: 0.5em 0 0;
    overflow: auto;
  }
  img { /* future proofing */
    max-width: 100%;
    height: auto;
  }
}

/* pagination */
@media print {
  body {

    width: 100%;
  }
  p {
    orphans: 3;
    widows: 3;
  }
  #n-copyright-notice {
    border-bottom: none;
  }
  #toc, #n-introduction {
    page-break-before: always;
  }
  #toc {
    border-top: none;
    padding-top: 0;
  }
  figure, pre {
    page-break-inside: avoid;
  }
  figure {
    overflow: scroll;
  }
  h1, h2, h3, h4, h5, h6 {
    page-break-after: avoid;
  }
  h2+*, h3+*, h4+*, h5+*, h6+* {
    page-break-before: avoid;
  }
  pre {
    white-space: pre-wrap;
    word-wrap: break-word;
    font-size: 10pt;
  }
  table {
    border: 1px solid #ddd;
  }
  td {
    border-top: 1px solid #ddd;
  }
}

/* This is commented out here, as the string-set: doesn't
   pass W3C validation currently */
/*
.ears thead .left {
  string-set: ears-top-left content();
}

.ears thead .center {
  string-set: ears-top-center content();
}

.ears thead .right {
  string-set: ears-top-right content();
}

.ears tfoot .left {
  string-set: ears-bottom-left content();
}

.ears tfoot .center {
  string-set: ears-bottom-center content();
}

.ears tfoot .right {
  string-set: ears-bottom-right content();
}
*/

@page :first {
  padding-top: 0;
  @top-left {
    content: normal;
    border: none;
  }
  @top-center {
    content: normal;
    border: none;
  }
  @top-right {
    content: normal;
    border: none;
  }
}

@page {
  size: A4;
  margin-bottom: 45mm;
  padding-top: 20px;
  /* The follwing is commented out here, but set appropriately by in code, as
     the content depends on the document */
  /*
  @top-left {
    content: 'Internet-Draft';
    vertical-align: bottom;
    border-bottom: solid 1px #ccc;
  }
  @top-left {
    content: string(ears-top-left);
    vertical-align: bottom;
    border-bottom: solid 1px #ccc;
  }
  @top-center {
    content: string(ears-top-center);
    vertical-align: bottom;
    border-bottom: solid 1px #ccc;
  }
  @top-right {
    content: string(ears-top-right);
    vertical-align: bottom;
    border-bottom: solid 1px #ccc;
  }
  @bottom-left {
    content: string(ears-bottom-left);
    vertical-align: top;
    border-top: solid 1px #ccc;
  }
  @bottom-center {
    content: string(ears-bottom-center);
    vertical-align: top;
    border-top: solid 1px #ccc;
  }
  @bottom-right {
      content: '[Page ' counter(page) ']';
      vertical-align: top;
      border-top: solid 1px #ccc;
  }
  */

}

/* Changes introduced to fix issues found during implementation */
/* Make sure links are clickable even if overlapped by following H* */
a {
  z-index: 2;
}
/* Separate body from document info even without intervening H1 */
section {
  clear: both;
}


/* Top align author divs, to avoid names without organization dropping level with org names */
.author {
  vertical-align: top;
}

/* Leave room in document info to show Internet-Draft on one line */
#identifiers dt {
  width: 8em;
}

/* Don't waste quite as much whitespace between label and value in doc info */
#identifiers dd {
  margin-left: 1em;
}

/* Give floating toc a background color (needed when it's a div inside section */
#toc {
  background-color: white;
}

/* Make the collapsed ToC header render white on gray also when it's a link */
@media screen and (max-width: 1023px) {
  #toc h2 a,
  #toc h2 a:link,
  #toc h2 a:focus,
  #toc h2 a:hover,
  #toc a.toplink,
  #toc a.toplink:hover {
    color: white;
    background-color: #444;
    text-decoration: none;
  }
}

/* Give the bottom of the ToC some whitespace */
@media screen and (min-width: 1024px) {
  #toc {
    padding: 0 0 1em 1em;
  }
}

/* Style section numbers with more space between number and title */
.section-number {
  padding-right: 0.5em;
}

/* prevent monospace from becoming overly large */
tt, code, pre, code {
  font-size: 95%;
}

/* Fix the height/width aspect for ascii art*/
pre.sourcecode,
.art-text pre {
  line-height: 1.12;
}


/* Add styling for a link in the ToC that points to the top of the document */
a.toplink {
  float: right;
  margin-right: 0.5em;
}

/* Fix the dl styling to match the RFC 7992 attributes */
dl > dt,
dl.dlParallel > dt {
  float: left;
  margin-right: 1em;
}
dl.dlNewline > dt {
  float: none;
}

/* Provide styling for table cell text alignment */
table td.text-left,
table th.text-left {
  text-align: left;
}
table td.text-center,
table th.text-center {
  text-align: center;
}
table td.text-right,
table th.text-right {
  text-align: right;
}

/* Make the alternative author contact informatio look less like just another
   author, and group it closer with the primary author contact information */
.alternative-contact {
  margin: 0.5em 0 0.25em 0;
}
address .non-ascii {
  margin: 0 0 0 2em;
}

/* With it being possible to set tables with alignment
  left, center, and right, { width: 100%; } does not make sense */
table {
  width: auto;
}

/* Avoid reference text that sits in a block with very wide left margin,
   because of a long floating dt label.*/
.references dd {
  overflow: visible;
}

/* Control caption placement */
caption {
  caption-side: bottom;
}

/* Limit the width of the author address vcard, so names in right-to-left
   script don't end up on the other side of the page. */

address.vcard {
  max-width: 30em;
  margin-right: auto;
}

/* For address alignment dependent on LTR or RTL scripts */
address div.left {
  text-align: left;
}
address div.right {
  text-align: right;
}

/* Provide table alignment support.  We can't use the alignX classes above
   since they do unwanted things with caption and other styling. */
table.right {
 margin-left: auto;
 margin-right: 0;
}
table.center {
 margin-left: auto;
 margin-right: auto;
}
table.left {
 margin-left: 0;
 margin-right: auto;
}

/* Give the table caption label the same styling as the figcaption */
caption a[href] {
  color: #222;
}

@media print {
  .toplink {
    display: none;
  }

  /* avoid overwriting the top border line with the ToC header */
  #toc {
    padding-top: 1px;
  }

  /* Avoid page breaks inside dl and author address entries */
  .vcard {
    page-break-inside: avoid;
  }

}
/* Avoid wrapping of URLs in references */
@media screen {
  .references a {
    white-space: nowrap;
  }
}
/* Tweak the bcp14 keyword presentation */
.bcp14 {
  font-variant: small-caps;
  font-weight: bold;
  font-size: 0.9em;
}
/* Tweak the invisible space above H* in order not to overlay links in text above */
 h2 {
  margin-top: -18px;  /* provide offset for in-page anchors */
  padding-top: 31px;
 }
 h3 {
  margin-top: -18px;  /* provide offset for in-page anchors */
  padding-top: 24px;
 }
 h4 {
  margin-top: -18px;  /* provide offset for in-page anchors */
  padding-top: 24px;
 }
/* Float artwork pilcrow to the right */
@media screen {
  .artwork a.pilcrow {
    display: block;
    line-height: 0.7;
    margin-top: 0.15em;
  }
}
/* Make pilcrows on dd visible */
@media screen {
  dd:hover > a.pilcrow {
    visibility: visible;
  }
}
/* Make the placement of figcaption match that of a table's caption
   by removing the figure's added bottom margin */
.alignLeft.art-text,
.alignCenter.art-text,
.alignRight.art-text {
   margin-bottom: 0;
}
.alignLeft,
.alignCenter,
.alignRight {
  margin: 1em 0 0 0;
}
/* In print, the pilcrow won't show on hover, so prevent it from taking up space,
   possibly even requiring a new line */
@media print {
  a.pilcrow {
    display: none;
  }
}
/* Styling for the external metadata */
div#external-metadata {
  background-color: #eee;
  padding: 0.5em;
  margin-bottom: 0.5em;
  display: none;
}
div#internal-metadata {
  padding: 0.5em;                       /* to match the external-metadata padding */
}
/* Styling for title RFC Number */
h1#rfcnum {
  clear: both;
  margin: 0 0 -1em;
  padding: 1em 0 0 0;
}
/* Make .olPercent look the same as <ol><li> */
dl.olPercent > dd {
  margin: 0 0 0.25em 0;
  min-height: initial;
}
/* Give aside some styling to set it apart */
aside {
  border-left: 1px solid #ddd;
  margin: 1em 0 1em 2em;
  padding: 0.2em 2em;
}
aside > dl,
aside > ol,
aside > ul,
aside > table,
aside > p {
  margin-bottom: 0.5em;
}
/* Additional page break settings */
@media print {
  figcaption, table caption {
    page-break-before: avoid;
  }
}
/* Font size adjustments for print */
@media print {
  body  { font-size: 10pt;      line-height: normal; max-width: 96%; }
  h1    { font-size: 1.72em;    padding-top: 1.5em; } /* 1*1.2*1.2*1.2 */
  h2    { font-size: 1.44em;    padding-top: 1.5em; } /* 1*1.2*1.2 */
  h3    { font-size: 1.2em;     padding-top: 1.5em; } /* 1*1.2 */
  h4    { font-size: 1em;       padding-top: 1.5em; }
  h5, h6 { font-size: 1em;      margin: initial; padding: 0.5em 0 0.3em; }
}
/* Sourcecode margin in print, when there's no pilcrow */
@media print {
  .artwork,
  .sourcecode {
    margin-bottom: 1em;
  }
}
/*
  The margin-left: 0 on <dd> removes all distinction
  between levels from nested <dl>s.  Undo that.
*/
dl.olPercent > dd,
dd {
  margin-left: revert;
}
/* Avoid narrow tables forcing too narrow table captions, which may render badly */
table {
  min-width: 20em;
}</style>
<link href="rfc-local.css" type="text/css" rel="stylesheet">
</head>
<body>
<script src="metadata.min.js"></script>
<table class="ears">
<thead><tr>
<td class="left">Internet-Draft</td>
<td class="center">QUIC Loss Detection</td>
<td class="right">January 2020</td>
</tr></thead>
<tfoot><tr>
<td class="left">Iyengar &amp; Swett</td>
<td class="center">Expires 25 July 2020</td>
<td class="right">[Page]</td>
</tr></tfoot>
</table>
<div id="external-metadata" class="document-information"></div>
<div id="internal-metadata" class="document-information">
<dl id="identifiers">
<dt class="label-workgroup">Workgroup:</dt>
<dd class="workgroup">QUIC</dd>
<dt class="label-internet-draft">Internet-Draft:</dt>
<dd class="internet-draft">draft-ietf-quic-recovery-25</dd>
<dt class="label-published">Published:</dt>
<dd class="published">
<time datetime="2020-01-22" class="published">22 January 2020</time>
    </dd>
<dt class="label-intended-status">Intended Status:</dt>
<dd class="intended-status">Standards Track</dd>
<dt class="label-expires">Expires:</dt>
<dd class="expires"><time datetime="2020-07-25">25 July 2020</time></dd>
<dt class="label-authors">Authors:</dt>
<dd class="authors">
<div class="author">
      <div class="author-name">J. Iyengar, <span class="editor">Ed.</span>
</div>
<div class="org">Fastly</div>
</div>
<div class="author">
      <div class="author-name">I. Swett, <span class="editor">Ed.</span>
</div>
<div class="org">Google</div>
</div>
</dd>
</dl>
</div>
<h1 id="title">QUIC Loss Detection and Congestion Control</h1>
<section id="section-abstract">
      <h2 id="abstract"><a href="#abstract" class="selfRef">Abstract</a></h2>
<p id="section-abstract-1">This document describes loss detection and congestion control mechanisms for
QUIC.<a href="#section-abstract-1" class="pilcrow">¶</a></p>
</section>
<section class="note" id="section-note.1">
      <h2 id="name-note-to-readers">
<a href="#name-note-to-readers" class="section-name selfRef">Note to Readers</a>
      </h2>
<p id="section-note.1-1">Discussion of this draft takes place on the QUIC working group mailing list
(quic@ietf.org), which is archived at
<a href="https://mailarchive.ietf.org/arch/search/?email_list=quic">https://mailarchive.ietf.org/arch/search/?email_list=quic</a>.<a href="#section-note.1-1" class="pilcrow">¶</a></p>
<p id="section-note.1-2">Working Group information can be found at <a href="https://github.com/quicwg">https://github.com/quicwg</a>; source
code and issues list for this draft can be found at
<a href="https://github.com/quicwg/base-drafts/labels/-recovery">https://github.com/quicwg/base-drafts/labels/-recovery</a>.<a href="#section-note.1-2" class="pilcrow">¶</a></p>
</section>
<div id="status-of-memo">
<section id="section-boilerplate.1">
        <h2 id="name-status-of-this-memo">
<a href="#name-status-of-this-memo" class="section-name selfRef">Status of This Memo</a>
        </h2>
<p id="section-boilerplate.1-1">
        This Internet-Draft is submitted in full conformance with the
        provisions of BCP 78 and BCP 79.<a href="#section-boilerplate.1-1" class="pilcrow">¶</a></p>
<p id="section-boilerplate.1-2">
        Internet-Drafts are working documents of the Internet Engineering Task
        Force (IETF). Note that other groups may also distribute working
        documents as Internet-Drafts. The list of current Internet-Drafts is
        at <span><a href="https://datatracker.ietf.org/drafts/current/">https://datatracker.ietf.org/drafts/current/</a></span>.<a href="#section-boilerplate.1-2" class="pilcrow">¶</a></p>
<p id="section-boilerplate.1-3">
        Internet-Drafts are draft documents valid for a maximum of six months
        and may be updated, replaced, or obsoleted by other documents at any
        time. It is inappropriate to use Internet-Drafts as reference
        material or to cite them other than as "work in progress."<a href="#section-boilerplate.1-3" class="pilcrow">¶</a></p>
<p id="section-boilerplate.1-4">
        This Internet-Draft will expire on 25 July 2020.<a href="#section-boilerplate.1-4" class="pilcrow">¶</a></p>
</section>
</div>
<div id="copyright">
<section id="section-boilerplate.2">
        <h2 id="name-copyright-notice">
<a href="#name-copyright-notice" class="section-name selfRef">Copyright Notice</a>
        </h2>
<p id="section-boilerplate.2-1">
            Copyright (c) 2020 IETF Trust and the persons identified as the
            document authors. All rights reserved.<a href="#section-boilerplate.2-1" class="pilcrow">¶</a></p>
<p id="section-boilerplate.2-2">
            This document is subject to BCP 78 and the IETF Trust's Legal
            Provisions Relating to IETF Documents
            (<span><a href="https://trustee.ietf.org/license-info">https://trustee.ietf.org/license-info</a></span>) in effect on the date of
            publication of this document. Please review these documents
            carefully, as they describe your rights and restrictions with
            respect to this document. Code Components extracted from this
            document must include Simplified BSD License text as described in
            Section 4.e of the Trust Legal Provisions and are provided without
            warranty as described in the Simplified BSD License.<a href="#section-boilerplate.2-2" class="pilcrow">¶</a></p>
</section>
</div>
<div id="toc">
<section id="section-toc.1">
        <a href="#" onclick="scroll(0,0)" class="toplink">▲</a><h2 id="name-table-of-contents">
<a href="#name-table-of-contents" class="section-name selfRef">Table of Contents</a>
        </h2>
<nav class="toc"><ul class="toc ulEmpty">
<li class="toc ulEmpty" id="section-toc.1-1.1">
            <p id="section-toc.1-1.1.1"><a href="#section-1" class="xref">1</a>.  <a href="#name-introduction" class="xref">Introduction</a><a href="#section-toc.1-1.1.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.2">
            <p id="section-toc.1-1.2.1"><a href="#section-2" class="xref">2</a>.  <a href="#name-conventions-and-definitions" class="xref">Conventions and Definitions</a><a href="#section-toc.1-1.2.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.3">
            <p id="section-toc.1-1.3.1"><a href="#section-3" class="xref">3</a>.  <a href="#name-design-of-the-quic-transmis" class="xref">Design of the QUIC Transmission Machinery</a><a href="#section-toc.1-1.3.1" class="pilcrow">¶</a></p>
<ul class="toc ulEmpty">
<li class="toc ulEmpty" id="section-toc.1-1.3.2.1">
                <p id="section-toc.1-1.3.2.1.1"><a href="#section-3.1" class="xref">3.1</a>.  <a href="#name-relevant-differences-betwee" class="xref">Relevant Differences Between QUIC and TCP</a><a href="#section-toc.1-1.3.2.1.1" class="pilcrow">¶</a></p>
<ul class="toc ulEmpty">
<li class="toc ulEmpty" id="section-toc.1-1.3.2.1.2.1">
                    <p id="section-toc.1-1.3.2.1.2.1.1"><a href="#section-3.1.1" class="xref">3.1.1</a>.  <a href="#name-separate-packet-number-spac" class="xref">Separate Packet Number Spaces</a><a href="#section-toc.1-1.3.2.1.2.1.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.3.2.1.2.2">
                    <p id="section-toc.1-1.3.2.1.2.2.1"><a href="#section-3.1.2" class="xref">3.1.2</a>.  <a href="#name-monotonically-increasing-pa" class="xref">Monotonically Increasing Packet Numbers</a><a href="#section-toc.1-1.3.2.1.2.2.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.3.2.1.2.3">
                    <p id="section-toc.1-1.3.2.1.2.3.1"><a href="#section-3.1.3" class="xref">3.1.3</a>.  <a href="#name-clearer-loss-epoch" class="xref">Clearer Loss Epoch</a><a href="#section-toc.1-1.3.2.1.2.3.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.3.2.1.2.4">
                    <p id="section-toc.1-1.3.2.1.2.4.1"><a href="#section-3.1.4" class="xref">3.1.4</a>.  <a href="#name-no-reneging" class="xref">No Reneging</a><a href="#section-toc.1-1.3.2.1.2.4.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.3.2.1.2.5">
                    <p id="section-toc.1-1.3.2.1.2.5.1"><a href="#section-3.1.5" class="xref">3.1.5</a>.  <a href="#name-more-ack-ranges" class="xref">More ACK Ranges</a><a href="#section-toc.1-1.3.2.1.2.5.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.3.2.1.2.6">
                    <p id="section-toc.1-1.3.2.1.2.6.1"><a href="#section-3.1.6" class="xref">3.1.6</a>.  <a href="#name-explicit-correction-for-del" class="xref">Explicit Correction For Delayed Acknowledgements</a><a href="#section-toc.1-1.3.2.1.2.6.1" class="pilcrow">¶</a></p>
</li>
</ul>
</li>
</ul>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.4">
            <p id="section-toc.1-1.4.1"><a href="#section-4" class="xref">4</a>.  <a href="#name-estimating-the-round-trip-t" class="xref">Estimating the Round-Trip Time</a><a href="#section-toc.1-1.4.1" class="pilcrow">¶</a></p>
<ul class="toc ulEmpty">
<li class="toc ulEmpty" id="section-toc.1-1.4.2.1">
                <p id="section-toc.1-1.4.2.1.1"><a href="#section-4.1" class="xref">4.1</a>.  <a href="#name-generating-rtt-samples" class="xref">Generating RTT samples</a><a href="#section-toc.1-1.4.2.1.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.4.2.2">
                <p id="section-toc.1-1.4.2.2.1"><a href="#section-4.2" class="xref">4.2</a>.  <a href="#name-estimating-min_rtt" class="xref">Estimating min_rtt</a><a href="#section-toc.1-1.4.2.2.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.4.2.3">
                <p id="section-toc.1-1.4.2.3.1"><a href="#section-4.3" class="xref">4.3</a>.  <a href="#name-estimating-smoothed_rtt-and" class="xref">Estimating smoothed_rtt and rttvar</a><a href="#section-toc.1-1.4.2.3.1" class="pilcrow">¶</a></p>
</li>
</ul>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.5">
            <p id="section-toc.1-1.5.1"><a href="#section-5" class="xref">5</a>.  <a href="#name-loss-detection" class="xref">Loss Detection</a><a href="#section-toc.1-1.5.1" class="pilcrow">¶</a></p>
<ul class="toc ulEmpty">
<li class="toc ulEmpty" id="section-toc.1-1.5.2.1">
                <p id="section-toc.1-1.5.2.1.1"><a href="#section-5.1" class="xref">5.1</a>.  <a href="#name-acknowledgement-based-detec" class="xref">Acknowledgement-based Detection</a><a href="#section-toc.1-1.5.2.1.1" class="pilcrow">¶</a></p>
<ul class="toc ulEmpty">
<li class="toc ulEmpty" id="section-toc.1-1.5.2.1.2.1">
                    <p id="section-toc.1-1.5.2.1.2.1.1"><a href="#section-5.1.1" class="xref">5.1.1</a>.  <a href="#name-packet-threshold" class="xref">Packet Threshold</a><a href="#section-toc.1-1.5.2.1.2.1.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.5.2.1.2.2">
                    <p id="section-toc.1-1.5.2.1.2.2.1"><a href="#section-5.1.2" class="xref">5.1.2</a>.  <a href="#name-time-threshold" class="xref">Time Threshold</a><a href="#section-toc.1-1.5.2.1.2.2.1" class="pilcrow">¶</a></p>
</li>
</ul>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.5.2.2">
                <p id="section-toc.1-1.5.2.2.1"><a href="#section-5.2" class="xref">5.2</a>.  <a href="#name-probe-timeout" class="xref">Probe Timeout</a><a href="#section-toc.1-1.5.2.2.1" class="pilcrow">¶</a></p>
<ul class="toc ulEmpty">
<li class="toc ulEmpty" id="section-toc.1-1.5.2.2.2.1">
                    <p id="section-toc.1-1.5.2.2.2.1.1"><a href="#section-5.2.1" class="xref">5.2.1</a>.  <a href="#name-computing-pto" class="xref">Computing PTO</a><a href="#section-toc.1-1.5.2.2.2.1.1" class="pilcrow">¶</a></p>
</li>
</ul>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.5.2.3">
                <p id="section-toc.1-1.5.2.3.1"><a href="#section-5.3" class="xref">5.3</a>.  <a href="#name-handshakes-and-new-paths" class="xref">Handshakes and New Paths</a><a href="#section-toc.1-1.5.2.3.1" class="pilcrow">¶</a></p>
<ul class="toc ulEmpty">
<li class="toc ulEmpty" id="section-toc.1-1.5.2.3.2.1">
                    <p id="section-toc.1-1.5.2.3.2.1.1"><a href="#section-5.3.1" class="xref">5.3.1</a>.  <a href="#name-sending-probe-packets" class="xref">Sending Probe Packets</a><a href="#section-toc.1-1.5.2.3.2.1.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.5.2.3.2.2">
                    <p id="section-toc.1-1.5.2.3.2.2.1"><a href="#section-5.3.2" class="xref">5.3.2</a>.  <a href="#name-loss-detection-2" class="xref">Loss Detection</a><a href="#section-toc.1-1.5.2.3.2.2.1" class="pilcrow">¶</a></p>
</li>
</ul>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.5.2.4">
                <p id="section-toc.1-1.5.2.4.1"><a href="#section-5.4" class="xref">5.4</a>.  <a href="#name-handling-retry-packets" class="xref">Handling Retry Packets</a><a href="#section-toc.1-1.5.2.4.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.5.2.5">
                <p id="section-toc.1-1.5.2.5.1"><a href="#section-5.5" class="xref">5.5</a>.  <a href="#name-discarding-keys-and-packet-" class="xref">Discarding Keys and Packet State</a><a href="#section-toc.1-1.5.2.5.1" class="pilcrow">¶</a></p>
</li>
</ul>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.6">
            <p id="section-toc.1-1.6.1"><a href="#section-6" class="xref">6</a>.  <a href="#name-congestion-control" class="xref">Congestion Control</a><a href="#section-toc.1-1.6.1" class="pilcrow">¶</a></p>
<ul class="toc ulEmpty">
<li class="toc ulEmpty" id="section-toc.1-1.6.2.1">
                <p id="section-toc.1-1.6.2.1.1"><a href="#section-6.1" class="xref">6.1</a>.  <a href="#name-explicit-congestion-notific" class="xref">Explicit Congestion Notification</a><a href="#section-toc.1-1.6.2.1.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.6.2.2">
                <p id="section-toc.1-1.6.2.2.1"><a href="#section-6.2" class="xref">6.2</a>.  <a href="#name-slow-start" class="xref">Slow Start</a><a href="#section-toc.1-1.6.2.2.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.6.2.3">
                <p id="section-toc.1-1.6.2.3.1"><a href="#section-6.3" class="xref">6.3</a>.  <a href="#name-congestion-avoidance" class="xref">Congestion Avoidance</a><a href="#section-toc.1-1.6.2.3.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.6.2.4">
                <p id="section-toc.1-1.6.2.4.1"><a href="#section-6.4" class="xref">6.4</a>.  <a href="#name-recovery-period" class="xref">Recovery Period</a><a href="#section-toc.1-1.6.2.4.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.6.2.5">
                <p id="section-toc.1-1.6.2.5.1"><a href="#section-6.5" class="xref">6.5</a>.  <a href="#name-ignoring-loss-of-undecrypta" class="xref">Ignoring Loss of Undecryptable Packets</a><a href="#section-toc.1-1.6.2.5.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.6.2.6">
                <p id="section-toc.1-1.6.2.6.1"><a href="#section-6.6" class="xref">6.6</a>.  <a href="#name-probe-timeout-2" class="xref">Probe Timeout</a><a href="#section-toc.1-1.6.2.6.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.6.2.7">
                <p id="section-toc.1-1.6.2.7.1"><a href="#section-6.7" class="xref">6.7</a>.  <a href="#name-persistent-congestion" class="xref">Persistent Congestion</a><a href="#section-toc.1-1.6.2.7.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.6.2.8">
                <p id="section-toc.1-1.6.2.8.1"><a href="#section-6.8" class="xref">6.8</a>.  <a href="#name-pacing" class="xref">Pacing</a><a href="#section-toc.1-1.6.2.8.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.6.2.9">
                <p id="section-toc.1-1.6.2.9.1"><a href="#section-6.9" class="xref">6.9</a>.  <a href="#name-under-utilizing-the-congest" class="xref">Under-utilizing the Congestion Window</a><a href="#section-toc.1-1.6.2.9.1" class="pilcrow">¶</a></p>
</li>
</ul>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.7">
            <p id="section-toc.1-1.7.1"><a href="#section-7" class="xref">7</a>.  <a href="#name-security-considerations" class="xref">Security Considerations</a><a href="#section-toc.1-1.7.1" class="pilcrow">¶</a></p>
<ul class="toc ulEmpty">
<li class="toc ulEmpty" id="section-toc.1-1.7.2.1">
                <p id="section-toc.1-1.7.2.1.1"><a href="#section-7.1" class="xref">7.1</a>.  <a href="#name-congestion-signals" class="xref">Congestion Signals</a><a href="#section-toc.1-1.7.2.1.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.7.2.2">
                <p id="section-toc.1-1.7.2.2.1"><a href="#section-7.2" class="xref">7.2</a>.  <a href="#name-traffic-analysis" class="xref">Traffic Analysis</a><a href="#section-toc.1-1.7.2.2.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.7.2.3">
                <p id="section-toc.1-1.7.2.3.1"><a href="#section-7.3" class="xref">7.3</a>.  <a href="#name-misreporting-ecn-markings" class="xref">Misreporting ECN Markings</a><a href="#section-toc.1-1.7.2.3.1" class="pilcrow">¶</a></p>
</li>
</ul>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.8">
            <p id="section-toc.1-1.8.1"><a href="#section-8" class="xref">8</a>.  <a href="#name-iana-considerations" class="xref">IANA Considerations</a><a href="#section-toc.1-1.8.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.9">
            <p id="section-toc.1-1.9.1"><a href="#section-9" class="xref">9</a>.  <a href="#name-references" class="xref">References</a><a href="#section-toc.1-1.9.1" class="pilcrow">¶</a></p>
<ul class="toc ulEmpty">
<li class="toc ulEmpty" id="section-toc.1-1.9.2.1">
                <p id="section-toc.1-1.9.2.1.1"><a href="#section-9.1" class="xref">9.1</a>.  <a href="#name-normative-references" class="xref">Normative References</a><a href="#section-toc.1-1.9.2.1.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.9.2.2">
                <p id="section-toc.1-1.9.2.2.1"><a href="#section-9.2" class="xref">9.2</a>.  <a href="#name-informative-references" class="xref">Informative References</a><a href="#section-toc.1-1.9.2.2.1" class="pilcrow">¶</a></p>
</li>
</ul>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.10">
            <p id="section-toc.1-1.10.1"><a href="#section-appendix.a" class="xref">Appendix A</a>.  <a href="#name-loss-recovery-pseudocode" class="xref">Loss Recovery Pseudocode</a><a href="#section-toc.1-1.10.1" class="pilcrow">¶</a></p>
<ul class="toc ulEmpty">
<li class="toc ulEmpty" id="section-toc.1-1.10.2.1">
                <p id="section-toc.1-1.10.2.1.1"><a href="#section-a.1" class="xref">A.1</a>.  <a href="#name-tracking-sent-packets" class="xref">Tracking Sent Packets</a><a href="#section-toc.1-1.10.2.1.1" class="pilcrow">¶</a></p>
<ul class="toc ulEmpty">
<li class="toc ulEmpty" id="section-toc.1-1.10.2.1.2.1">
                    <p id="section-toc.1-1.10.2.1.2.1.1"><a href="#section-a.1.1" class="xref">A.1.1</a>.  <a href="#name-sent-packet-fields" class="xref">Sent Packet Fields</a><a href="#section-toc.1-1.10.2.1.2.1.1" class="pilcrow">¶</a></p>
</li>
</ul>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.10.2.2">
                <p id="section-toc.1-1.10.2.2.1"><a href="#section-a.2" class="xref">A.2</a>.  <a href="#name-constants-of-interest" class="xref">Constants of interest</a><a href="#section-toc.1-1.10.2.2.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.10.2.3">
                <p id="section-toc.1-1.10.2.3.1"><a href="#section-a.3" class="xref">A.3</a>.  <a href="#name-variables-of-interest" class="xref">Variables of interest</a><a href="#section-toc.1-1.10.2.3.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.10.2.4">
                <p id="section-toc.1-1.10.2.4.1"><a href="#section-a.4" class="xref">A.4</a>.  <a href="#name-initialization" class="xref">Initialization</a><a href="#section-toc.1-1.10.2.4.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.10.2.5">
                <p id="section-toc.1-1.10.2.5.1"><a href="#section-a.5" class="xref">A.5</a>.  <a href="#name-on-sending-a-packet" class="xref">On Sending a Packet</a><a href="#section-toc.1-1.10.2.5.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.10.2.6">
                <p id="section-toc.1-1.10.2.6.1"><a href="#section-a.6" class="xref">A.6</a>.  <a href="#name-on-receiving-an-acknowledgm" class="xref">On Receiving an Acknowledgment</a><a href="#section-toc.1-1.10.2.6.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.10.2.7">
                <p id="section-toc.1-1.10.2.7.1"><a href="#section-a.7" class="xref">A.7</a>.  <a href="#name-on-packet-acknowledgment" class="xref">On Packet Acknowledgment</a><a href="#section-toc.1-1.10.2.7.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.10.2.8">
                <p id="section-toc.1-1.10.2.8.1"><a href="#section-a.8" class="xref">A.8</a>.  <a href="#name-setting-the-loss-detection-" class="xref">Setting the Loss Detection Timer</a><a href="#section-toc.1-1.10.2.8.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.10.2.9">
                <p id="section-toc.1-1.10.2.9.1"><a href="#section-a.9" class="xref">A.9</a>.  <a href="#name-on-timeout" class="xref">On Timeout</a><a href="#section-toc.1-1.10.2.9.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.10.2.10">
                <p id="section-toc.1-1.10.2.10.1"><a href="#section-a.10" class="xref">A.10</a>. <a href="#name-detecting-lost-packets" class="xref">Detecting Lost Packets</a><a href="#section-toc.1-1.10.2.10.1" class="pilcrow">¶</a></p>
</li>
</ul>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.11">
            <p id="section-toc.1-1.11.1"><a href="#section-appendix.b" class="xref">Appendix B</a>.  <a href="#name-congestion-control-pseudoco" class="xref">Congestion Control Pseudocode</a><a href="#section-toc.1-1.11.1" class="pilcrow">¶</a></p>
<ul class="toc ulEmpty">
<li class="toc ulEmpty" id="section-toc.1-1.11.2.1">
                <p id="section-toc.1-1.11.2.1.1"><a href="#section-b.1" class="xref">B.1</a>.  <a href="#name-constants-of-interest-2" class="xref">Constants of interest</a><a href="#section-toc.1-1.11.2.1.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.11.2.2">
                <p id="section-toc.1-1.11.2.2.1"><a href="#section-b.2" class="xref">B.2</a>.  <a href="#name-variables-of-interest-2" class="xref">Variables of interest</a><a href="#section-toc.1-1.11.2.2.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.11.2.3">
                <p id="section-toc.1-1.11.2.3.1"><a href="#section-b.3" class="xref">B.3</a>.  <a href="#name-initialization-2" class="xref">Initialization</a><a href="#section-toc.1-1.11.2.3.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.11.2.4">
                <p id="section-toc.1-1.11.2.4.1"><a href="#section-b.4" class="xref">B.4</a>.  <a href="#name-on-packet-sent" class="xref">On Packet Sent</a><a href="#section-toc.1-1.11.2.4.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.11.2.5">
                <p id="section-toc.1-1.11.2.5.1"><a href="#section-b.5" class="xref">B.5</a>.  <a href="#name-on-packet-acknowledgement" class="xref">On Packet Acknowledgement</a><a href="#section-toc.1-1.11.2.5.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.11.2.6">
                <p id="section-toc.1-1.11.2.6.1"><a href="#section-b.6" class="xref">B.6</a>.  <a href="#name-on-new-congestion-event" class="xref">On New Congestion Event</a><a href="#section-toc.1-1.11.2.6.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.11.2.7">
                <p id="section-toc.1-1.11.2.7.1"><a href="#section-b.7" class="xref">B.7</a>.  <a href="#name-process-ecn-information" class="xref">Process ECN Information</a><a href="#section-toc.1-1.11.2.7.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.11.2.8">
                <p id="section-toc.1-1.11.2.8.1"><a href="#section-b.8" class="xref">B.8</a>.  <a href="#name-on-packets-lost" class="xref">On Packets Lost</a><a href="#section-toc.1-1.11.2.8.1" class="pilcrow">¶</a></p>
</li>
</ul>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.12">
            <p id="section-toc.1-1.12.1"><a href="#section-appendix.c" class="xref">Appendix C</a>.  <a href="#name-change-log" class="xref">Change Log</a><a href="#section-toc.1-1.12.1" class="pilcrow">¶</a></p>
<ul class="toc ulEmpty">
<li class="toc ulEmpty" id="section-toc.1-1.12.2.1">
                <p id="section-toc.1-1.12.2.1.1"><a href="#section-c.1" class="xref">C.1</a>.  <a href="#name-since-draft-ietf-quic-recov" class="xref">Since draft-ietf-quic-recovery-24</a><a href="#section-toc.1-1.12.2.1.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.12.2.2">
                <p id="section-toc.1-1.12.2.2.1"><a href="#section-c.2" class="xref">C.2</a>.  <a href="#name-since-draft-ietf-quic-recove" class="xref">Since draft-ietf-quic-recovery-23</a><a href="#section-toc.1-1.12.2.2.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.12.2.3">
                <p id="section-toc.1-1.12.2.3.1"><a href="#section-c.3" class="xref">C.3</a>.  <a href="#name-since-draft-ietf-quic-recover" class="xref">Since draft-ietf-quic-recovery-22</a><a href="#section-toc.1-1.12.2.3.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.12.2.4">
                <p id="section-toc.1-1.12.2.4.1"><a href="#section-c.4" class="xref">C.4</a>.  <a href="#name-since-draft-ietf-quic-recovery" class="xref">Since draft-ietf-quic-recovery-21</a><a href="#section-toc.1-1.12.2.4.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.12.2.5">
                <p id="section-toc.1-1.12.2.5.1"><a href="#section-c.5" class="xref">C.5</a>.  <a href="#name-since-draft-ietf-quic-recovery-" class="xref">Since draft-ietf-quic-recovery-20</a><a href="#section-toc.1-1.12.2.5.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.12.2.6">
                <p id="section-toc.1-1.12.2.6.1"><a href="#section-c.6" class="xref">C.6</a>.  <a href="#name-since-draft-ietf-quic-recovery-1" class="xref">Since draft-ietf-quic-recovery-19</a><a href="#section-toc.1-1.12.2.6.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.12.2.7">
                <p id="section-toc.1-1.12.2.7.1"><a href="#section-c.7" class="xref">C.7</a>.  <a href="#name-since-draft-ietf-quic-recovery-18" class="xref">Since draft-ietf-quic-recovery-18</a><a href="#section-toc.1-1.12.2.7.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.12.2.8">
                <p id="section-toc.1-1.12.2.8.1"><a href="#section-c.8" class="xref">C.8</a>.  <a href="#name-since-draft-ietf-quic-recovery-17" class="xref">Since draft-ietf-quic-recovery-17</a><a href="#section-toc.1-1.12.2.8.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.12.2.9">
                <p id="section-toc.1-1.12.2.9.1"><a href="#section-c.9" class="xref">C.9</a>.  <a href="#name-since-draft-ietf-quic-recovery-16" class="xref">Since draft-ietf-quic-recovery-16</a><a href="#section-toc.1-1.12.2.9.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.12.2.10">
                <p id="section-toc.1-1.12.2.10.1"><a href="#section-c.10" class="xref">C.10</a>. <a href="#name-since-draft-ietf-quic-recovery-14" class="xref">Since draft-ietf-quic-recovery-14</a><a href="#section-toc.1-1.12.2.10.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.12.2.11">
                <p id="section-toc.1-1.12.2.11.1"><a href="#section-c.11" class="xref">C.11</a>. <a href="#name-since-draft-ietf-quic-recovery-13" class="xref">Since draft-ietf-quic-recovery-13</a><a href="#section-toc.1-1.12.2.11.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.12.2.12">
                <p id="section-toc.1-1.12.2.12.1"><a href="#section-c.12" class="xref">C.12</a>. <a href="#name-since-draft-ietf-quic-recovery-12" class="xref">Since draft-ietf-quic-recovery-12</a><a href="#section-toc.1-1.12.2.12.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.12.2.13">
                <p id="section-toc.1-1.12.2.13.1"><a href="#section-c.13" class="xref">C.13</a>. <a href="#name-since-draft-ietf-quic-recovery-11" class="xref">Since draft-ietf-quic-recovery-11</a><a href="#section-toc.1-1.12.2.13.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.12.2.14">
                <p id="section-toc.1-1.12.2.14.1"><a href="#section-c.14" class="xref">C.14</a>. <a href="#name-since-draft-ietf-quic-recovery-10" class="xref">Since draft-ietf-quic-recovery-10</a><a href="#section-toc.1-1.12.2.14.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.12.2.15">
                <p id="section-toc.1-1.12.2.15.1"><a href="#section-c.15" class="xref">C.15</a>. <a href="#name-since-draft-ietf-quic-recovery-0" class="xref">Since draft-ietf-quic-recovery-09</a><a href="#section-toc.1-1.12.2.15.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.12.2.16">
                <p id="section-toc.1-1.12.2.16.1"><a href="#section-c.16" class="xref">C.16</a>. <a href="#name-since-draft-ietf-quic-recovery-08" class="xref">Since draft-ietf-quic-recovery-08</a><a href="#section-toc.1-1.12.2.16.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.12.2.17">
                <p id="section-toc.1-1.12.2.17.1"><a href="#section-c.17" class="xref">C.17</a>. <a href="#name-since-draft-ietf-quic-recovery-07" class="xref">Since draft-ietf-quic-recovery-07</a><a href="#section-toc.1-1.12.2.17.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.12.2.18">
                <p id="section-toc.1-1.12.2.18.1"><a href="#section-c.18" class="xref">C.18</a>. <a href="#name-since-draft-ietf-quic-recovery-06" class="xref">Since draft-ietf-quic-recovery-06</a><a href="#section-toc.1-1.12.2.18.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.12.2.19">
                <p id="section-toc.1-1.12.2.19.1"><a href="#section-c.19" class="xref">C.19</a>. <a href="#name-since-draft-ietf-quic-recovery-05" class="xref">Since draft-ietf-quic-recovery-05</a><a href="#section-toc.1-1.12.2.19.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.12.2.20">
                <p id="section-toc.1-1.12.2.20.1"><a href="#section-c.20" class="xref">C.20</a>. <a href="#name-since-draft-ietf-quic-recovery-04" class="xref">Since draft-ietf-quic-recovery-04</a><a href="#section-toc.1-1.12.2.20.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.12.2.21">
                <p id="section-toc.1-1.12.2.21.1"><a href="#section-c.21" class="xref">C.21</a>. <a href="#name-since-draft-ietf-quic-recovery-03" class="xref">Since draft-ietf-quic-recovery-03</a><a href="#section-toc.1-1.12.2.21.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.12.2.22">
                <p id="section-toc.1-1.12.2.22.1"><a href="#section-c.22" class="xref">C.22</a>. <a href="#name-since-draft-ietf-quic-recovery-02" class="xref">Since draft-ietf-quic-recovery-02</a><a href="#section-toc.1-1.12.2.22.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.12.2.23">
                <p id="section-toc.1-1.12.2.23.1"><a href="#section-c.23" class="xref">C.23</a>. <a href="#name-since-draft-ietf-quic-recovery-01" class="xref">Since draft-ietf-quic-recovery-01</a><a href="#section-toc.1-1.12.2.23.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.12.2.24">
                <p id="section-toc.1-1.12.2.24.1"><a href="#section-c.24" class="xref">C.24</a>. <a href="#name-since-draft-ietf-quic-recovery-00" class="xref">Since draft-ietf-quic-recovery-00</a><a href="#section-toc.1-1.12.2.24.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.12.2.25">
                <p id="section-toc.1-1.12.2.25.1"><a href="#section-c.25" class="xref">C.25</a>. <a href="#name-since-draft-iyengar-quic-lo" class="xref">Since draft-iyengar-quic-loss-recovery-01</a><a href="#section-toc.1-1.12.2.25.1" class="pilcrow">¶</a></p>
</li>
</ul>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.13">
            <p id="section-toc.1-1.13.1"><a href="#section-appendix.d" class="xref">Appendix D</a>.  <a href="#name-contributors" class="xref">Contributors</a><a href="#section-toc.1-1.13.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.14">
            <p id="section-toc.1-1.14.1"><a href="#section-appendix.e" class="xref"></a><a href="#name-acknowledgments" class="xref">Acknowledgments</a><a href="#section-toc.1-1.14.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.15">
            <p id="section-toc.1-1.15.1"><a href="#section-appendix.f" class="xref"></a><a href="#name-authors-addresses" class="xref">Authors' Addresses</a><a href="#section-toc.1-1.15.1" class="pilcrow">¶</a></p>
</li>
</ul>
</nav>
</section>
</div>
<div id="introduction">
<section id="section-1">
      <h2 id="name-introduction">
<a href="#section-1" class="section-number selfRef">1. </a><a href="#name-introduction" class="section-name selfRef">Introduction</a>
      </h2>
<p id="section-1-1">QUIC is a new multiplexed and secure transport atop UDP.  QUIC builds on decades
of transport and security experience, and implements mechanisms that make it
attractive as a modern general-purpose transport.  The QUIC protocol is
described in <span>[<a href="#QUIC-TRANSPORT" class="xref">QUIC-TRANSPORT</a>]</span>.<a href="#section-1-1" class="pilcrow">¶</a></p>
<p id="section-1-2">QUIC implements the spirit of existing TCP congestion control and loss recovery
mechanisms, described in RFCs, various Internet-drafts, and also those prevalent
in the Linux TCP implementation.  This document describes QUIC congestion
control and loss recovery, and where applicable, attributes the TCP equivalent
in RFCs, Internet-drafts, academic papers, and/or TCP implementations.<a href="#section-1-2" class="pilcrow">¶</a></p>
</section>
</div>
<div id="conventions-and-definitions">
<section id="section-2">
      <h2 id="name-conventions-and-definitions">
<a href="#section-2" class="section-number selfRef">2. </a><a href="#name-conventions-and-definitions" class="section-name selfRef">Conventions and Definitions</a>
      </h2>
<p id="section-2-1">The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD",
"SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this
document are to be interpreted as described in BCP 14 <span>[<a href="#RFC2119" class="xref">RFC2119</a>]</span> <span>[<a href="#RFC8174" class="xref">RFC8174</a>]</span>
when, and only when, they appear in all capitals, as shown here.<a href="#section-2-1" class="pilcrow">¶</a></p>
<p id="section-2-2">Definitions of terms that are used in this document:<a href="#section-2-2" class="pilcrow">¶</a></p>
<dl class="dlParallel" id="section-2-3">
        <dt id="section-2-3.1">ACK-only:</dt>
<dd id="section-2-3.2">
  Any packet containing only one or more ACK frame(s).<a href="#section-2-3.2" class="pilcrow">¶</a>
</dd>
<dt id="section-2-3.3">In-flight:</dt>
<dd id="section-2-3.4">
  Packets are considered in-flight when they have been sent and
are not ACK-only, and they are not acknowledged, declared lost,
or abandoned along with old keys.<a href="#section-2-3.4" class="pilcrow">¶</a>
</dd>
<dt id="section-2-3.5">Ack-eliciting Frames:</dt>
<dd id="section-2-3.6">
  All frames other than ACK, PADDING, and CONNECTION_CLOSE are considered
ack-eliciting.<a href="#section-2-3.6" class="pilcrow">¶</a>
</dd>
<dt id="section-2-3.7">Ack-eliciting Packets:</dt>
<dd id="section-2-3.8">
  Packets that contain ack-eliciting frames elicit an ACK from the receiver
within the maximum ack delay and are called ack-eliciting packets.<a href="#section-2-3.8" class="pilcrow">¶</a>
</dd>
</dl>
</section>
</div>
<div id="design-of-the-quic-transmission-machinery">
<section id="section-3">
      <h2 id="name-design-of-the-quic-transmis">
<a href="#section-3" class="section-number selfRef">3. </a><a href="#name-design-of-the-quic-transmis" class="section-name selfRef">Design of the QUIC Transmission Machinery</a>
      </h2>
<p id="section-3-1">All transmissions in QUIC are sent with a packet-level header, which indicates
the encryption level and includes a packet sequence number (referred to below as
a packet number).  The encryption level indicates the packet number space, as
described in <span>[<a href="#QUIC-TRANSPORT" class="xref">QUIC-TRANSPORT</a>]</span>.  Packet numbers never repeat within a packet
number space for the lifetime of a connection.  Packet numbers are sent in
monotonically increasing order within a space, preventing ambiguity.<a href="#section-3-1" class="pilcrow">¶</a></p>
<p id="section-3-2">This design obviates the need for disambiguating between transmissions and
retransmissions and eliminates significant complexity from QUIC's interpretation
of TCP loss detection mechanisms.<a href="#section-3-2" class="pilcrow">¶</a></p>
<p id="section-3-3">QUIC packets can contain multiple frames of different types. The recovery
mechanisms ensure that data and frames that need reliable delivery are
acknowledged or declared lost and sent in new packets as necessary. The types
of frames contained in a packet affect recovery and congestion control logic:<a href="#section-3-3" class="pilcrow">¶</a></p>
<ul>
<li id="section-3-4.1">All packets are acknowledged, though packets that contain no
ack-eliciting frames are only acknowledged along with ack-eliciting
packets.<a href="#section-3-4.1" class="pilcrow">¶</a>
</li>
<li id="section-3-4.2">Long header packets that contain CRYPTO frames are critical to the
performance of the QUIC handshake and use shorter timers for
acknowledgement.<a href="#section-3-4.2" class="pilcrow">¶</a>
</li>
<li id="section-3-4.3">Packets containing frames besides ACK or CONNECTION_CLOSE frames count toward
congestion control limits and are considered in-flight.<a href="#section-3-4.3" class="pilcrow">¶</a>
</li>
<li id="section-3-4.4">PADDING frames cause packets to contribute toward bytes in flight without
directly causing an acknowledgment to be sent.<a href="#section-3-4.4" class="pilcrow">¶</a>
</li>
</ul>
<div id="relevant-differences-between-quic-and-tcp">
<section id="section-3.1">
        <h3 id="name-relevant-differences-betwee">
<a href="#section-3.1" class="section-number selfRef">3.1. </a><a href="#name-relevant-differences-betwee" class="section-name selfRef">Relevant Differences Between QUIC and TCP</a>
        </h3>
<p id="section-3.1-1">Readers familiar with TCP's loss detection and congestion control will find
algorithms here that parallel well-known TCP ones. Protocol differences between
QUIC and TCP however contribute to algorithmic differences. We briefly describe
these protocol differences below.<a href="#section-3.1-1" class="pilcrow">¶</a></p>
<div id="separate-packet-number-spaces">
<section id="section-3.1.1">
          <h4 id="name-separate-packet-number-spac">
<a href="#section-3.1.1" class="section-number selfRef">3.1.1. </a><a href="#name-separate-packet-number-spac" class="section-name selfRef">Separate Packet Number Spaces</a>
          </h4>
<p id="section-3.1.1-1">QUIC uses separate packet number spaces for each encryption level, except 0-RTT
and all generations of 1-RTT keys use the same packet number space.  Separate
packet number spaces ensures acknowledgement of packets sent with one level of
encryption will not cause spurious retransmission of packets sent with a
different encryption level.  Congestion control and round-trip time (RTT)
measurement are unified across packet number spaces.<a href="#section-3.1.1-1" class="pilcrow">¶</a></p>
</section>
</div>
<div id="monotonically-increasing-packet-numbers">
<section id="section-3.1.2">
          <h4 id="name-monotonically-increasing-pa">
<a href="#section-3.1.2" class="section-number selfRef">3.1.2. </a><a href="#name-monotonically-increasing-pa" class="section-name selfRef">Monotonically Increasing Packet Numbers</a>
          </h4>
<p id="section-3.1.2-1">TCP conflates transmission order at the sender with delivery order at the
receiver, which results in retransmissions of the same data carrying the same
sequence number, and consequently leads to "retransmission ambiguity".  QUIC
separates the two: QUIC uses a packet number to indicate transmission order,
and any application data is sent in one or more streams, with delivery order
determined by stream offsets encoded within STREAM frames.<a href="#section-3.1.2-1" class="pilcrow">¶</a></p>
<p id="section-3.1.2-2">QUIC's packet number is strictly increasing within a packet number space,
and directly encodes transmission order.  A higher packet number signifies
that the packet was sent later, and a lower packet number signifies that
the packet was sent earlier.  When a packet containing ack-eliciting
frames is detected lost, QUIC rebundles necessary frames in a new packet
with a new packet number, removing ambiguity about which packet is
acknowledged when an ACK is received.  Consequently, more accurate RTT
measurements can be made, spurious retransmissions are trivially detected, and
mechanisms such as Fast Retransmit can be applied universally, based only on
packet number.<a href="#section-3.1.2-2" class="pilcrow">¶</a></p>
<p id="section-3.1.2-3">This design point significantly simplifies loss detection mechanisms for QUIC.
Most TCP mechanisms implicitly attempt to infer transmission ordering based on
TCP sequence numbers - a non-trivial task, especially when TCP timestamps are
not available.<a href="#section-3.1.2-3" class="pilcrow">¶</a></p>
</section>
</div>
<div id="clearer-loss-epoch">
<section id="section-3.1.3">
          <h4 id="name-clearer-loss-epoch">
<a href="#section-3.1.3" class="section-number selfRef">3.1.3. </a><a href="#name-clearer-loss-epoch" class="section-name selfRef">Clearer Loss Epoch</a>
          </h4>
<p id="section-3.1.3-1">QUIC starts a loss epoch when a packet is lost and ends one when any packet
sent after the epoch starts is acknowledged.  TCP waits for the gap in the
sequence number space to be filled, and so if a segment is lost multiple times
in a row, the loss epoch may not end for several round trips. Because both
should reduce their congestion windows only once per epoch, QUIC will do it
once for every round trip that experiences loss, while TCP may only do it
once across multiple round trips.<a href="#section-3.1.3-1" class="pilcrow">¶</a></p>
</section>
</div>
<div id="no-reneging">
<section id="section-3.1.4">
          <h4 id="name-no-reneging">
<a href="#section-3.1.4" class="section-number selfRef">3.1.4. </a><a href="#name-no-reneging" class="section-name selfRef">No Reneging</a>
          </h4>
<p id="section-3.1.4-1">QUIC ACKs contain information that is similar to TCP SACK, but QUIC does not
allow any acked packet to be reneged, greatly simplifying implementations on
both sides and reducing memory pressure on the sender.<a href="#section-3.1.4-1" class="pilcrow">¶</a></p>
</section>
</div>
<div id="more-ack-ranges">
<section id="section-3.1.5">
          <h4 id="name-more-ack-ranges">
<a href="#section-3.1.5" class="section-number selfRef">3.1.5. </a><a href="#name-more-ack-ranges" class="section-name selfRef">More ACK Ranges</a>
          </h4>
<p id="section-3.1.5-1">QUIC supports many ACK ranges, opposed to TCP's 3 SACK ranges.  In high loss
environments, this speeds recovery, reduces spurious retransmits, and ensures
forward progress without relying on timeouts.<a href="#section-3.1.5-1" class="pilcrow">¶</a></p>
</section>
</div>
<div id="explicit-correction-for-delayed-acknowledgements">
<section id="section-3.1.6">
          <h4 id="name-explicit-correction-for-del">
<a href="#section-3.1.6" class="section-number selfRef">3.1.6. </a><a href="#name-explicit-correction-for-del" class="section-name selfRef">Explicit Correction For Delayed Acknowledgements</a>
          </h4>
<p id="section-3.1.6-1">QUIC endpoints measure the delay incurred between when a packet is received and
when the corresponding acknowledgment is sent, allowing a peer to maintain a
more accurate round-trip time estimate (see Section 13.2 of <span>[<a href="#QUIC-TRANSPORT" class="xref">QUIC-TRANSPORT</a>]</span>).<a href="#section-3.1.6-1" class="pilcrow">¶</a></p>
</section>
</div>
</section>
</div>
</section>
</div>
<div id="compute-rtt">
<section id="section-4">
      <h2 id="name-estimating-the-round-trip-t">
<a href="#section-4" class="section-number selfRef">4. </a><a href="#name-estimating-the-round-trip-t" class="section-name selfRef">Estimating the Round-Trip Time</a>
      </h2>
<p id="section-4-1">At a high level, an endpoint measures the time from when a packet was sent to
when it is acknowledged as a round-trip time (RTT) sample.  The endpoint uses
RTT samples and peer-reported host delays (see Section 13.2 of
<span>[<a href="#QUIC-TRANSPORT" class="xref">QUIC-TRANSPORT</a>]</span>) to generate a statistical description of the network
path's RTT. An endpoint computes the following three values for each path:
the minimum value observed over the lifetime of the path (min_rtt), an
exponentially-weighted moving average (smoothed_rtt), and the mean deviation
(referred to as "variation" in the rest of this document) in the observed RTT
samples (rttvar).<a href="#section-4-1" class="pilcrow">¶</a></p>
<div id="latest-rtt">
<section id="section-4.1">
        <h3 id="name-generating-rtt-samples">
<a href="#section-4.1" class="section-number selfRef">4.1. </a><a href="#name-generating-rtt-samples" class="section-name selfRef">Generating RTT samples</a>
        </h3>
<p id="section-4.1-1">An endpoint generates an RTT sample on receiving an ACK frame that meets the
following two conditions:<a href="#section-4.1-1" class="pilcrow">¶</a></p>
<ul>
<li id="section-4.1-2.1">the largest acknowledged packet number is newly acknowledged, and<a href="#section-4.1-2.1" class="pilcrow">¶</a>
</li>
<li id="section-4.1-2.2">at least one of the newly acknowledged packets was ack-eliciting.<a href="#section-4.1-2.2" class="pilcrow">¶</a>
</li>
</ul>
<p id="section-4.1-3">The RTT sample, latest_rtt, is generated as the time elapsed since the largest
acknowledged packet was sent:<a href="#section-4.1-3" class="pilcrow">¶</a></p>
<div class="artwork art-text alignLeft" id="section-4.1-4">
<pre>
latest_rtt = ack_time - send_time_of_largest_acked
</pre><a href="#section-4.1-4" class="pilcrow">¶</a>
</div>
<p id="section-4.1-5">An RTT sample is generated using only the largest acknowledged packet in the
received ACK frame.  This is because a peer reports ACK delays for only the
largest acknowledged packet in an ACK frame.  While the reported ACK delay is
not used by the RTT sample measurement, it is used to adjust the RTT sample in
subsequent computations of smoothed_rtt and rttvar <a href="#smoothed-rtt" class="xref">Section 4.3</a>.<a href="#section-4.1-5" class="pilcrow">¶</a></p>
<p id="section-4.1-6">To avoid generating multiple RTT samples for a single packet, an ACK frame
SHOULD NOT be used to update RTT estimates if it does not newly acknowledge the
largest acknowledged packet.<a href="#section-4.1-6" class="pilcrow">¶</a></p>
<p id="section-4.1-7">An RTT sample MUST NOT be generated on receiving an ACK frame that does not
newly acknowledge at least one ack-eliciting packet.  A peer does not send an
ACK frame on receiving only non-ack-eliciting packets, so an ACK frame that is
subsequently sent can include an arbitrarily large Ack Delay field.  Ignoring
such ACK frames avoids complications in subsequent smoothed_rtt and rttvar
computations.<a href="#section-4.1-7" class="pilcrow">¶</a></p>
<p id="section-4.1-8">A sender might generate multiple RTT samples per RTT when multiple ACK frames
are received within an RTT.  As suggested in <span>[<a href="#RFC6298" class="xref">RFC6298</a>]</span>, doing so might result
in inadequate history in smoothed_rtt and rttvar.  Ensuring that RTT estimates
retain sufficient history is an open research question.<a href="#section-4.1-8" class="pilcrow">¶</a></p>
</section>
</div>
<div id="min-rtt">
<section id="section-4.2">
        <h3 id="name-estimating-min_rtt">
<a href="#section-4.2" class="section-number selfRef">4.2. </a><a href="#name-estimating-min_rtt" class="section-name selfRef">Estimating min_rtt</a>
        </h3>
<p id="section-4.2-1">min_rtt is the minimum RTT observed for a given network path.  min_rtt is set
to the latest_rtt on the first RTT sample, and to the lesser of min_rtt and
latest_rtt on subsequent samples.  In this document, min_rtt is used by loss
detection to reject implausibly small rtt samples.<a href="#section-4.2-1" class="pilcrow">¶</a></p>
<p id="section-4.2-2">An endpoint uses only locally observed times in computing the min_rtt and does
not adjust for ACK delays reported by the peer.  Doing so allows the endpoint
to set a lower bound for the smoothed_rtt based entirely on what it observes
(see <a href="#smoothed-rtt" class="xref">Section 4.3</a>), and limits potential underestimation due to
erroneously-reported delays by the peer.<a href="#section-4.2-2" class="pilcrow">¶</a></p>
<p id="section-4.2-3">The RTT for a network path may change over time.  If a path's actual RTT
decreases, the min_rtt will adapt immediately on the first low sample.  If
the path's actual RTT increases, the min_rtt will not adapt to it, allowing
future RTT samples that are smaller than the new RTT be included in
smoothed_rtt.<a href="#section-4.2-3" class="pilcrow">¶</a></p>
</section>
</div>
<div id="smoothed-rtt">
<section id="section-4.3">
        <h3 id="name-estimating-smoothed_rtt-and">
<a href="#section-4.3" class="section-number selfRef">4.3. </a><a href="#name-estimating-smoothed_rtt-and" class="section-name selfRef">Estimating smoothed_rtt and rttvar</a>
        </h3>
<p id="section-4.3-1">smoothed_rtt is an exponentially-weighted moving average of an endpoint's RTT
samples, and rttvar is the variation in the RTT samples, estimated using a
mean variation.<a href="#section-4.3-1" class="pilcrow">¶</a></p>
<p id="section-4.3-2">The calculation of smoothed_rtt uses path latency after adjusting RTT samples
for ACK delays.  For packets sent in the ApplicationData packet number space,
a peer limits any delay in sending an acknowledgement for an ack-eliciting
packet to no greater than the value it advertised in the max_ack_delay transport
parameter.  Consequently, when a peer reports an Ack Delay that is greater than
its max_ack_delay, the delay is attributed to reasons out of the peer's control,
such as scheduler latency at the peer or loss of previous ACK frames.  Any
delays beyond the peer's max_ack_delay are therefore considered effectively
part of path delay and incorporated into the smoothed_rtt estimate.<a href="#section-4.3-2" class="pilcrow">¶</a></p>
<p id="section-4.3-3">When adjusting an RTT sample using peer-reported acknowledgement delays, an
endpoint:<a href="#section-4.3-3" class="pilcrow">¶</a></p>
<ul>
<li id="section-4.3-4.1">MUST ignore the Ack Delay field of the ACK frame for packets sent in the
Initial and Handshake packet number space.<a href="#section-4.3-4.1" class="pilcrow">¶</a>
</li>
<li id="section-4.3-4.2">MUST use the lesser of the value reported in Ack Delay field of the ACK frame
and the peer's max_ack_delay transport parameter.<a href="#section-4.3-4.2" class="pilcrow">¶</a>
</li>
<li id="section-4.3-4.3">MUST NOT apply the adjustment if the resulting RTT sample is smaller than the
min_rtt.  This limits the underestimation that a misreporting peer can cause
to the smoothed_rtt.<a href="#section-4.3-4.3" class="pilcrow">¶</a>
</li>
</ul>
<p id="section-4.3-5">On the first RTT sample for a network path, the smoothed_rtt is set to the
latest_rtt.<a href="#section-4.3-5" class="pilcrow">¶</a></p>
<p id="section-4.3-6">smoothed_rtt and rttvar are computed as follows, similar to <span>[<a href="#RFC6298" class="xref">RFC6298</a>]</span>.  On
the first RTT sample for a network path:<a href="#section-4.3-6" class="pilcrow">¶</a></p>
<div class="artwork art-text alignLeft" id="section-4.3-7">
<pre>
smoothed_rtt = latest_rtt
rttvar = latest_rtt / 2
</pre><a href="#section-4.3-7" class="pilcrow">¶</a>
</div>
<p id="section-4.3-8">On subsequent RTT samples, smoothed_rtt and rttvar evolve as follows:<a href="#section-4.3-8" class="pilcrow">¶</a></p>
<div class="artwork art-text alignLeft" id="section-4.3-9">
<pre>
ack_delay = min(Ack Delay in ACK Frame, max_ack_delay)
adjusted_rtt = latest_rtt
if (min_rtt + ack_delay &lt; latest_rtt):
  adjusted_rtt = latest_rtt - ack_delay
smoothed_rtt = 7/8 * smoothed_rtt + 1/8 * adjusted_rtt
rttvar_sample = abs(smoothed_rtt - adjusted_rtt)
rttvar = 3/4 * rttvar + 1/4 * rttvar_sample
</pre><a href="#section-4.3-9" class="pilcrow">¶</a>
</div>
</section>
</div>
</section>
</div>
<div id="loss-detection">
<section id="section-5">
      <h2 id="name-loss-detection">
<a href="#section-5" class="section-number selfRef">5. </a><a href="#name-loss-detection" class="section-name selfRef">Loss Detection</a>
      </h2>
<p id="section-5-1">QUIC senders use acknowledgements to detect lost packets, and a probe
time out <a href="#pto" class="xref">Section 5.2</a> to ensure acknowledgements are received. This section
provides a description of these algorithms.<a href="#section-5-1" class="pilcrow">¶</a></p>
<p id="section-5-2">If a packet is lost, the QUIC transport needs to recover from that loss, such
as by retransmitting the data, sending an updated frame, or abandoning the
frame.  For more information, see Section 13.3 of <span>[<a href="#QUIC-TRANSPORT" class="xref">QUIC-TRANSPORT</a>]</span>.<a href="#section-5-2" class="pilcrow">¶</a></p>
<div id="ack-loss-detection">
<section id="section-5.1">
        <h3 id="name-acknowledgement-based-detec">
<a href="#section-5.1" class="section-number selfRef">5.1. </a><a href="#name-acknowledgement-based-detec" class="section-name selfRef">Acknowledgement-based Detection</a>
        </h3>
<p id="section-5.1-1">Acknowledgement-based loss detection implements the spirit of TCP's Fast
Retransmit <span>[<a href="#RFC5681" class="xref">RFC5681</a>]</span>, Early Retransmit <span>[<a href="#RFC5827" class="xref">RFC5827</a>]</span>, FACK <span>[<a href="#FACK" class="xref">FACK</a>]</span>, SACK loss
recovery <span>[<a href="#RFC6675" class="xref">RFC6675</a>]</span>, and RACK <span>[<a href="#RACK" class="xref">RACK</a>]</span>. This section
provides an overview of how these algorithms are implemented in QUIC.<a href="#section-5.1-1" class="pilcrow">¶</a></p>
<p id="section-5.1-2">A packet is declared lost if it meets all the following conditions:<a href="#section-5.1-2" class="pilcrow">¶</a></p>
<ul>
<li id="section-5.1-3.1">The packet is unacknowledged, in-flight, and was sent prior to an
acknowledged packet.<a href="#section-5.1-3.1" class="pilcrow">¶</a>
</li>
<li id="section-5.1-3.2">Either its packet number is kPacketThreshold smaller than an acknowledged
packet (<a href="#packet-threshold" class="xref">Section 5.1.1</a>), or it was sent long enough in the past
(<a href="#time-threshold" class="xref">Section 5.1.2</a>).<a href="#section-5.1-3.2" class="pilcrow">¶</a>
</li>
</ul>
<p id="section-5.1-4">The acknowledgement indicates that a packet sent later was delivered, and the
packet and time thresholds provide some tolerance for packet reordering.<a href="#section-5.1-4" class="pilcrow">¶</a></p>
<p id="section-5.1-5">Spuriously declaring packets as lost leads to unnecessary retransmissions and
may result in degraded performance due to the actions of the congestion
controller upon detecting loss.  Implementations that detect spurious
retransmissions and increase the reordering threshold in packets or time MAY
choose to start with smaller initial reordering thresholds to minimize recovery
latency.<a href="#section-5.1-5" class="pilcrow">¶</a></p>
<div id="packet-threshold">
<section id="section-5.1.1">
          <h4 id="name-packet-threshold">
<a href="#section-5.1.1" class="section-number selfRef">5.1.1. </a><a href="#name-packet-threshold" class="section-name selfRef">Packet Threshold</a>
          </h4>
<p id="section-5.1.1-1">The RECOMMENDED initial value for the packet reordering threshold
(kPacketThreshold) is 3, based on best practices for TCP loss detection
<span>[<a href="#RFC5681" class="xref">RFC5681</a>]</span> <span>[<a href="#RFC6675" class="xref">RFC6675</a>]</span>.  Implementations SHOULD NOT use a packet threshold
less than 3, to keep in line with TCP <span>[<a href="#RFC5681" class="xref">RFC5681</a>]</span>.<a href="#section-5.1.1-1" class="pilcrow">¶</a></p>
<p id="section-5.1.1-2">Some networks may exhibit higher degrees of reordering, causing a sender to
detect spurious losses.  Implementers MAY use algorithms developed for TCP, such
as TCP-NCR <span>[<a href="#RFC4653" class="xref">RFC4653</a>]</span>, to improve QUIC's reordering resilience.<a href="#section-5.1.1-2" class="pilcrow">¶</a></p>
</section>
</div>
<div id="time-threshold">
<section id="section-5.1.2">
          <h4 id="name-time-threshold">
<a href="#section-5.1.2" class="section-number selfRef">5.1.2. </a><a href="#name-time-threshold" class="section-name selfRef">Time Threshold</a>
          </h4>
<p id="section-5.1.2-1">Once a later packet within the same packet number space has been acknowledged,
an endpoint SHOULD declare an earlier packet lost if it was sent a threshold
amount of time in the past. To avoid declaring packets as lost too early, this
time threshold MUST be set to at least kGranularity.  The time threshold is:<a href="#section-5.1.2-1" class="pilcrow">¶</a></p>
<div class="artwork art-text alignLeft" id="section-5.1.2-2">
<pre>
max(kTimeThreshold * max(smoothed_rtt, latest_rtt), kGranularity)
</pre><a href="#section-5.1.2-2" class="pilcrow">¶</a>
</div>
<p id="section-5.1.2-3">If packets sent prior to the largest acknowledged packet cannot yet be declared
lost, then a timer SHOULD be set for the remaining time.<a href="#section-5.1.2-3" class="pilcrow">¶</a></p>
<p id="section-5.1.2-4">Using max(smoothed_rtt, latest_rtt) protects from the two following cases:<a href="#section-5.1.2-4" class="pilcrow">¶</a></p>
<ul>
<li id="section-5.1.2-5.1">the latest RTT sample is lower than the smoothed RTT, perhaps due to
reordering where the acknowledgement encountered a shorter path;<a href="#section-5.1.2-5.1" class="pilcrow">¶</a>
</li>
<li id="section-5.1.2-5.2">the latest RTT sample is higher than the smoothed RTT, perhaps due to a
sustained increase in the actual RTT, but the smoothed RTT has not yet caught
up.<a href="#section-5.1.2-5.2" class="pilcrow">¶</a>
</li>
</ul>
<p id="section-5.1.2-6">The RECOMMENDED time threshold (kTimeThreshold), expressed as a round-trip time
multiplier, is 9/8.<a href="#section-5.1.2-6" class="pilcrow">¶</a></p>
<p id="section-5.1.2-7">Implementations MAY experiment with absolute thresholds, thresholds from
previous connections, adaptive thresholds, or including RTT variation.  Smaller
thresholds reduce reordering resilience and increase spurious retransmissions,
and larger thresholds increase loss detection delay.<a href="#section-5.1.2-7" class="pilcrow">¶</a></p>
</section>
</div>
</section>
</div>
<div id="pto">
<section id="section-5.2">
        <h3 id="name-probe-timeout">
<a href="#section-5.2" class="section-number selfRef">5.2. </a><a href="#name-probe-timeout" class="section-name selfRef">Probe Timeout</a>
        </h3>
<p id="section-5.2-1">A Probe Timeout (PTO) triggers sending one or two probe datagrams when
ack-eliciting packets are not acknowledged within the expected period of
time or the handshake has not been completed.  A PTO enables a connection to
recover from loss of tail packets or acknowledgements.<a href="#section-5.2-1" class="pilcrow">¶</a></p>
<p id="section-5.2-2">As with loss detection, the probe timeout is per packet number space.
The PTO algorithm used in QUIC implements the reliability functions of
Tail Loss Probe <span>[<a href="#RACK" class="xref">RACK</a>]</span>, RTO <span>[<a href="#RFC5681" class="xref">RFC5681</a>]</span>, and F-RTO algorithms for
TCP <span>[<a href="#RFC5682" class="xref">RFC5682</a>]</span>. The timeout computation is based on TCP's retransmission
timeout period <span>[<a href="#RFC6298" class="xref">RFC6298</a>]</span>.<a href="#section-5.2-2" class="pilcrow">¶</a></p>
<div id="computing-pto">
<section id="section-5.2.1">
          <h4 id="name-computing-pto">
<a href="#section-5.2.1" class="section-number selfRef">5.2.1. </a><a href="#name-computing-pto" class="section-name selfRef">Computing PTO</a>
          </h4>
<p id="section-5.2.1-1">When an ack-eliciting packet is transmitted, the sender schedules a timer for
the PTO period as follows:<a href="#section-5.2.1-1" class="pilcrow">¶</a></p>
<div class="artwork art-text alignLeft" id="section-5.2.1-2">
<pre>
PTO = smoothed_rtt + max(4*rttvar, kGranularity) + max_ack_delay
</pre><a href="#section-5.2.1-2" class="pilcrow">¶</a>
</div>
<p id="section-5.2.1-3">kGranularity, smoothed_rtt, rttvar, and max_ack_delay are defined in
<a href="#ld-consts-of-interest" class="xref">Appendix A.2</a> and <a href="#ld-vars-of-interest" class="xref">Appendix A.3</a>.<a href="#section-5.2.1-3" class="pilcrow">¶</a></p>
<p id="section-5.2.1-4">The PTO period is the amount of time that a sender ought to wait for an
acknowledgement of a sent packet.  This time period includes the estimated
network roundtrip-time (smoothed_rtt), the variation in the estimate (4*rttvar),
and max_ack_delay, to account for the maximum time by which a receiver might
delay sending an acknowledgement.  When the PTO is armed for Initial or
Handshake packet number spaces, the max_ack_delay is 0, as specified in
13.2.5 of <span>[<a href="#QUIC-TRANSPORT" class="xref">QUIC-TRANSPORT</a>]</span>.<a href="#section-5.2.1-4" class="pilcrow">¶</a></p>
<p id="section-5.2.1-5">The PTO value MUST be set to at least kGranularity, to avoid the timer expiring
immediately.<a href="#section-5.2.1-5" class="pilcrow">¶</a></p>
<p id="section-5.2.1-6">A sender computes its PTO timer every time an ack-eliciting packet is sent.
When ack-eliciting packets are in-flight in multiple packet number spaces,
the timer MUST be set for the packet number space with the earliest timeout,
except for ApplicationData, which MUST be ignored until the handshake
completes; see Section 4.1.1 of <span>[<a href="#QUIC-TLS" class="xref">QUIC-TLS</a>]</span>.  Not arming the PTO for
ApplicationData prioritizes completing the handshake and prevents the server
from sending a 1-RTT packet on a PTO before before it has the keys to process
a 1-RTT packet.<a href="#section-5.2.1-6" class="pilcrow">¶</a></p>
<p id="section-5.2.1-7">When a PTO timer expires, the PTO period MUST be set to twice its current
value. This exponential reduction in the sender's rate is important because
consecutive PTOs might be caused by loss of packets or acknowledgements due to
severe congestion.  Even when there are ack-eliciting packets in-flight in
multiple packet number spaces, the exponential increase in probe timeout
occurs across all spaces to prevent excess load on the network.  For example,
a timeout in the Initial packet number space doubles the length of the timeout
in the Handshake packet number space.<a href="#section-5.2.1-7" class="pilcrow">¶</a></p>
<p id="section-5.2.1-8">The life of a connection that is experiencing consecutive PTOs is limited by
the endpoint's idle timeout.<a href="#section-5.2.1-8" class="pilcrow">¶</a></p>
<p id="section-5.2.1-9">The probe timer is not set if the time threshold <a href="#time-threshold" class="xref">Section 5.1.2</a> loss
detection timer is set.  The time threshold loss detection timer is expected
to both expire earlier than the PTO and be less likely to spuriously retransmit
data.<a href="#section-5.2.1-9" class="pilcrow">¶</a></p>
</section>
</div>
</section>
</div>
<div id="handshakes-and-new-paths">
<section id="section-5.3">
        <h3 id="name-handshakes-and-new-paths">
<a href="#section-5.3" class="section-number selfRef">5.3. </a><a href="#name-handshakes-and-new-paths" class="section-name selfRef">Handshakes and New Paths</a>
        </h3>
<p id="section-5.3-1">The initial probe timeout for a new connection or new path SHOULD be
set to twice the initial RTT.  Resumed connections over the same network
SHOULD use the previous connection's final smoothed RTT value as the resumed
connection's initial RTT.  If no previous RTT is available, the initial RTT
SHOULD be set to 500ms, resulting in a 1 second initial timeout as recommended
in <span>[<a href="#RFC6298" class="xref">RFC6298</a>]</span>.<a href="#section-5.3-1" class="pilcrow">¶</a></p>
<p id="section-5.3-2">A connection MAY use the delay between sending a PATH_CHALLENGE and receiving a
PATH_RESPONSE to set the initial RTT (see kInitialRtt in
<a href="#ld-consts-of-interest" class="xref">Appendix A.2</a>) for a new path, but the delay SHOULD NOT be
considered an RTT sample.<a href="#section-5.3-2" class="pilcrow">¶</a></p>
<p id="section-5.3-3">Until the server has validated the client's address on the path, the amount of
data it can send is limited to three times the amount of data received,
as specified in Section 8.1 of <span>[<a href="#QUIC-TRANSPORT" class="xref">QUIC-TRANSPORT</a>]</span>. If no data can be sent,
then the PTO alarm MUST NOT be armed until datagrams have been received from
the client.<a href="#section-5.3-3" class="pilcrow">¶</a></p>
<p id="section-5.3-4">Since the server could be blocked until more packets are received from the
client, it is the client's responsibility to send packets to unblock the server
until it is certain that the server has finished its address validation
(see Section 8 of <span>[<a href="#QUIC-TRANSPORT" class="xref">QUIC-TRANSPORT</a>]</span>).  That is, the client MUST set the
probe timer if the client has not received an acknowledgement for one of its
Handshake or 1-RTT packets.<a href="#section-5.3-4" class="pilcrow">¶</a></p>
<p id="section-5.3-5">Prior to handshake completion, when few to none RTT samples have been
generated, it is possible that the probe timer expiration is due to an
incorrect RTT estimate at the client. To allow the client to improve its RTT
estimate, the new packet that it sends MUST be ack-eliciting.  If Handshake
keys are available to the client, it MUST send a Handshake packet, and
otherwise it MUST send an Initial packet in a UDP datagram of at least 1200
bytes.<a href="#section-5.3-5" class="pilcrow">¶</a></p>
<p id="section-5.3-6">Initial packets and Handshake packets could be never acknowledged, but they are
removed from bytes in flight when the Initial and Handshake keys are discarded.<a href="#section-5.3-6" class="pilcrow">¶</a></p>
<div id="sending-probe-packets">
<section id="section-5.3.1">
          <h4 id="name-sending-probe-packets">
<a href="#section-5.3.1" class="section-number selfRef">5.3.1. </a><a href="#name-sending-probe-packets" class="section-name selfRef">Sending Probe Packets</a>
          </h4>
<p id="section-5.3.1-1">When a PTO timer expires, a sender MUST send at least one ack-eliciting packet
in the packet number space as a probe, unless there is no data available to
send.  An endpoint MAY send up to two full-sized datagrams containing
ack-eliciting packets, to avoid an expensive consecutive PTO expiration due
to a single lost datagram or transmit data from multiple packet number spaces.<a href="#section-5.3.1-1" class="pilcrow">¶</a></p>
<p id="section-5.3.1-2">In addition to sending data in the packet number space for which the timer
expired, the sender SHOULD send ack-eliciting packets from other packet
number spaces with in-flight data, coalescing packets if possible.<a href="#section-5.3.1-2" class="pilcrow">¶</a></p>
<p id="section-5.3.1-3">When the PTO timer expires, and there is new or previously sent unacknowledged
data, it MUST be sent.<a href="#section-5.3.1-3" class="pilcrow">¶</a></p>
<p id="section-5.3.1-4">It is possible the sender has no new or previously-sent data to send.
As an example, consider the following sequence of events: new application data
is sent in a STREAM frame, deemed lost, then retransmitted in a new packet,
and then the original transmission is acknowledged.  When there is no data to
send, the sender SHOULD send a PING or other ack-eliciting frame in a single
packet, re-arming the PTO timer.<a href="#section-5.3.1-4" class="pilcrow">¶</a></p>
<p id="section-5.3.1-5">Alternatively, instead of sending an ack-eliciting packet, the sender MAY mark
any packets still in flight as lost.  Doing so avoids sending an additional
packet, but increases the risk that loss is declared too aggressively, resulting
in an unnecessary rate reduction by the congestion controller.<a href="#section-5.3.1-5" class="pilcrow">¶</a></p>
<p id="section-5.3.1-6">Consecutive PTO periods increase exponentially, and as a result, connection
recovery latency increases exponentially as packets continue to be dropped in
the network.  Sending two packets on PTO expiration increases resilience to
packet drops, thus reducing the probability of consecutive PTO events.<a href="#section-5.3.1-6" class="pilcrow">¶</a></p>
<p id="section-5.3.1-7">Probe packets sent on a PTO MUST be ack-eliciting.  A probe packet SHOULD carry
new data when possible.  A probe packet MAY carry retransmitted unacknowledged
data when new data is unavailable, when flow control does not permit new data to
be sent, or to opportunistically reduce loss recovery delay.  Implementations
MAY use alternative strategies for determining the content of probe packets,
including sending new or retransmitted data based on the application's
priorities.<a href="#section-5.3.1-7" class="pilcrow">¶</a></p>
<p id="section-5.3.1-8">When the PTO timer expires multiple times and new data cannot be sent,
implementations must choose between sending the same payload every time
or sending different payloads.  Sending the same payload may be simpler
and ensures the highest priority frames arrive first.  Sending different
payloads each time reduces the chances of spurious retransmission.<a href="#section-5.3.1-8" class="pilcrow">¶</a></p>
</section>
</div>
<div id="pto-loss">
<section id="section-5.3.2">
          <h4 id="name-loss-detection-2">
<a href="#section-5.3.2" class="section-number selfRef">5.3.2. </a><a href="#name-loss-detection-2" class="section-name selfRef">Loss Detection</a>
          </h4>
<p id="section-5.3.2-1">Delivery or loss of packets in flight is established when an ACK frame is
received that newly acknowledges one or more packets.<a href="#section-5.3.2-1" class="pilcrow">¶</a></p>
<p id="section-5.3.2-2">A PTO timer expiration event does not indicate packet loss and MUST NOT cause
prior unacknowledged packets to be marked as lost. When an acknowledgement
is received that newly acknowledges packets, loss detection proceeds as
dictated by packet and time threshold mechanisms; see <a href="#ack-loss-detection" class="xref">Section 5.1</a>.<a href="#section-5.3.2-2" class="pilcrow">¶</a></p>
</section>
</div>
</section>
</div>
<div id="handling-retry-packets">
<section id="section-5.4">
        <h3 id="name-handling-retry-packets">
<a href="#section-5.4" class="section-number selfRef">5.4. </a><a href="#name-handling-retry-packets" class="section-name selfRef">Handling Retry Packets</a>
        </h3>
<p id="section-5.4-1">A Retry packet causes a client to send another Initial packet, effectively
restarting the connection process.  A Retry packet indicates that the Initial
was received, but not processed.  A Retry packet cannot be treated as an
acknowledgment, because it does not indicate that a packet was processed or
specify the packet number.<a href="#section-5.4-1" class="pilcrow">¶</a></p>
<p id="section-5.4-2">Clients that receive a Retry packet reset congestion control and loss recovery
state, including resetting any pending timers.  Other connection state, in
particular cryptographic handshake messages, is retained; see Section 17.2.5 of
<span>[<a href="#QUIC-TRANSPORT" class="xref">QUIC-TRANSPORT</a>]</span>.<a href="#section-5.4-2" class="pilcrow">¶</a></p>
<p id="section-5.4-3">The client MAY compute an RTT estimate to the server as the time period from
when the first Initial was sent to when a Retry or a Version Negotiation packet
is received.  The client MAY use this value in place of its default for the
initial RTT estimate.<a href="#section-5.4-3" class="pilcrow">¶</a></p>
</section>
</div>
<div id="discarding-packets">
<section id="section-5.5">
        <h3 id="name-discarding-keys-and-packet-">
<a href="#section-5.5" class="section-number selfRef">5.5. </a><a href="#name-discarding-keys-and-packet-" class="section-name selfRef">Discarding Keys and Packet State</a>
        </h3>
<p id="section-5.5-1">When packet protection keys are discarded (see Section 4.10 of <span>[<a href="#QUIC-TLS" class="xref">QUIC-TLS</a>]</span>),
all packets that were sent with those keys can no longer be acknowledged because
their acknowledgements cannot be processed anymore. The sender MUST discard
all recovery state associated with those packets and MUST remove them from
the count of bytes in flight.<a href="#section-5.5-1" class="pilcrow">¶</a></p>
<p id="section-5.5-2">Endpoints stop sending and receiving Initial packets once they start exchanging
Handshake packets (see Section 17.2.2.1 of <span>[<a href="#QUIC-TRANSPORT" class="xref">QUIC-TRANSPORT</a>]</span>). At this point,
recovery state for all in-flight Initial packets is discarded.<a href="#section-5.5-2" class="pilcrow">¶</a></p>
<p id="section-5.5-3">When 0-RTT is rejected, recovery state for all in-flight 0-RTT packets is
discarded.<a href="#section-5.5-3" class="pilcrow">¶</a></p>
<p id="section-5.5-4">If a server accepts 0-RTT, but does not buffer 0-RTT packets that arrive
before Initial packets, early 0-RTT packets will be declared lost, but that
is expected to be infrequent.<a href="#section-5.5-4" class="pilcrow">¶</a></p>
<p id="section-5.5-5">It is expected that keys are discarded after packets encrypted with them would
be acknowledged or declared lost.  Initial secrets however might be destroyed
sooner, as soon as handshake keys are available (see Section 4.10.1 of
<span>[<a href="#QUIC-TLS" class="xref">QUIC-TLS</a>]</span>).<a href="#section-5.5-5" class="pilcrow">¶</a></p>
</section>
</div>
</section>
</div>
<div id="congestion-control">
<section id="section-6">
      <h2 id="name-congestion-control">
<a href="#section-6" class="section-number selfRef">6. </a><a href="#name-congestion-control" class="section-name selfRef">Congestion Control</a>
      </h2>
<p id="section-6-1">This document specifies a Reno congestion controller for QUIC <span>[<a href="#RFC6582" class="xref">RFC6582</a>]</span>.<a href="#section-6-1" class="pilcrow">¶</a></p>
<p id="section-6-2">The signals QUIC provides for congestion control are generic and are designed to
support different algorithms. Endpoints can unilaterally choose a different
algorithm to use, such as Cubic <span>[<a href="#RFC8312" class="xref">RFC8312</a>]</span>.<a href="#section-6-2" class="pilcrow">¶</a></p>
<p id="section-6-3">If an endpoint uses a different controller than that specified in this document,
the chosen controller MUST conform to the congestion control guidelines
specified in Section 3.1 of <span>[<a href="#RFC8085" class="xref">RFC8085</a>]</span>.<a href="#section-6-3" class="pilcrow">¶</a></p>
<p id="section-6-4">The algorithm in this document specifies and uses the controller's congestion
window in bytes.<a href="#section-6-4" class="pilcrow">¶</a></p>
<p id="section-6-5">An endpoint MUST NOT send a packet if it would cause bytes_in_flight (see
<a href="#vars-of-interest" class="xref">Appendix B.2</a>) to be larger than the congestion window, unless the packet
is sent on a PTO timer expiration (see <a href="#pto" class="xref">Section 5.2</a>).<a href="#section-6-5" class="pilcrow">¶</a></p>
<div id="congestion-ecn">
<section id="section-6.1">
        <h3 id="name-explicit-congestion-notific">
<a href="#section-6.1" class="section-number selfRef">6.1. </a><a href="#name-explicit-congestion-notific" class="section-name selfRef">Explicit Congestion Notification</a>
        </h3>
<p id="section-6.1-1">If a path has been verified to support ECN <span>[<a href="#RFC3168" class="xref">RFC3168</a>]</span> <span>[<a href="#RFC8311" class="xref">RFC8311</a>]</span>, QUIC
treats a Congestion Experienced(CE) codepoint in the IP header as a signal of
congestion. This document specifies an endpoint's response when its peer
receives packets with the Congestion Experienced codepoint.<a href="#section-6.1-1" class="pilcrow">¶</a></p>
</section>
</div>
<div id="slow-start">
<section id="section-6.2">
        <h3 id="name-slow-start">
<a href="#section-6.2" class="section-number selfRef">6.2. </a><a href="#name-slow-start" class="section-name selfRef">Slow Start</a>
        </h3>
<p id="section-6.2-1">QUIC begins every connection in slow start and exits slow start upon loss or
upon increase in the ECN-CE counter. QUIC re-enters slow start any time the
congestion window is less than ssthresh, which only occurs after persistent
congestion is declared. While in slow start, QUIC increases the congestion
window by the number of bytes acknowledged when each acknowledgment is
processed.<a href="#section-6.2-1" class="pilcrow">¶</a></p>
</section>
</div>
<div id="congestion-avoidance">
<section id="section-6.3">
        <h3 id="name-congestion-avoidance">
<a href="#section-6.3" class="section-number selfRef">6.3. </a><a href="#name-congestion-avoidance" class="section-name selfRef">Congestion Avoidance</a>
        </h3>
<p id="section-6.3-1">Slow start exits to congestion avoidance.  Congestion avoidance in NewReno
uses an additive increase multiplicative decrease (AIMD) approach that
increases the congestion window by one maximum packet size per
congestion window acknowledged.  When a loss is detected, NewReno halves
the congestion window and sets the slow start threshold to the new
congestion window.<a href="#section-6.3-1" class="pilcrow">¶</a></p>
</section>
</div>
<div id="recovery-period">
<section id="section-6.4">
        <h3 id="name-recovery-period">
<a href="#section-6.4" class="section-number selfRef">6.4. </a><a href="#name-recovery-period" class="section-name selfRef">Recovery Period</a>
        </h3>
<p id="section-6.4-1">Recovery is a period of time beginning with detection of a lost packet or an
increase in the ECN-CE counter. Because QUIC does not retransmit packets,
it defines the end of recovery as a packet sent after the start of recovery
being acknowledged. This is slightly different from TCP's definition of
recovery, which ends when the lost packet that started recovery is acknowledged.<a href="#section-6.4-1" class="pilcrow">¶</a></p>
<p id="section-6.4-2">The recovery period limits congestion window reduction to once per round trip.
During recovery, the congestion window remains unchanged irrespective of new
losses or increases in the ECN-CE counter.<a href="#section-6.4-2" class="pilcrow">¶</a></p>
</section>
</div>
<div id="ignoring-loss-of-undecryptable-packets">
<section id="section-6.5">
        <h3 id="name-ignoring-loss-of-undecrypta">
<a href="#section-6.5" class="section-number selfRef">6.5. </a><a href="#name-ignoring-loss-of-undecrypta" class="section-name selfRef">Ignoring Loss of Undecryptable Packets</a>
        </h3>
<p id="section-6.5-1">During the handshake, some packet protection keys might not be
available when a packet arrives. In particular, Handshake and 0-RTT packets
cannot be processed until the Initial packets arrive, and 1-RTT packets
cannot be processed until the handshake completes.  Endpoints MAY
ignore the loss of Handshake, 0-RTT, and 1-RTT packets that might arrive before
the peer has packet protection keys to process those packets.<a href="#section-6.5-1" class="pilcrow">¶</a></p>
</section>
</div>
<div id="probe-timeout">
<section id="section-6.6">
        <h3 id="name-probe-timeout-2">
<a href="#section-6.6" class="section-number selfRef">6.6. </a><a href="#name-probe-timeout-2" class="section-name selfRef">Probe Timeout</a>
        </h3>
<p id="section-6.6-1">Probe packets MUST NOT be blocked by the congestion controller.  A sender MUST
however count these packets as being additionally in flight, since these packets
add network load without establishing packet loss.  Note that sending probe
packets might cause the sender's bytes in flight to exceed the congestion window
until an acknowledgement is received that establishes loss or delivery of
packets.<a href="#section-6.6-1" class="pilcrow">¶</a></p>
</section>
</div>
<div id="persistent-congestion">
<section id="section-6.7">
        <h3 id="name-persistent-congestion">
<a href="#section-6.7" class="section-number selfRef">6.7. </a><a href="#name-persistent-congestion" class="section-name selfRef">Persistent Congestion</a>
        </h3>
<p id="section-6.7-1">When an ACK frame is received that establishes loss of all in-flight packets
sent over a long enough period of time, the network is considered to be
experiencing persistent congestion.  Commonly, this can be established by
consecutive PTOs, but since the PTO timer is reset when a new ack-eliciting
packet is sent, an explicit duration must be used to account for those cases
where PTOs do not occur or are substantially delayed.  This duration is computed
as follows:<a href="#section-6.7-1" class="pilcrow">¶</a></p>
<div class="artwork art-text alignLeft" id="section-6.7-2">
<pre>
(smoothed_rtt + 4 * rttvar + max_ack_delay) *
    kPersistentCongestionThreshold
</pre><a href="#section-6.7-2" class="pilcrow">¶</a>
</div>
<p id="section-6.7-3">For example, assume:<a href="#section-6.7-3" class="pilcrow">¶</a></p>
<p id="section-6.7-4">smoothed_rtt = 1
  rttvar = 0
  max_ack_delay = 0
  kPersistentCongestionThreshold = 3<a href="#section-6.7-4" class="pilcrow">¶</a></p>
<p id="section-6.7-5">If an ack-eliciting packet is sent at time = 0, the following scenario would
illustrate persistent congestion:<a href="#section-6.7-5" class="pilcrow">¶</a></p>
<table class="center" id="table-1">
          <caption><a href="#table-1" class="selfRef">Table 1</a></caption>
<thead>
            <tr>
              <th class="text-left" rowspan="1" colspan="1">t=0</th>
              <th class="text-left" rowspan="1" colspan="1">Send Pkt #1 (App Data)</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">t=1</td>
              <td class="text-left" rowspan="1" colspan="1">Send Pkt #2 (PTO 1)</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">t=3</td>
              <td class="text-left" rowspan="1" colspan="1">Send Pkt #3 (PTO 2)</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">t=7</td>
              <td class="text-left" rowspan="1" colspan="1">Send Pkt #4 (PTO 3)</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">t=8</td>
              <td class="text-left" rowspan="1" colspan="1">Recv ACK of Pkt #4</td>
            </tr>
          </tbody>
        </table>
<p id="section-6.7-7">The first three packets are determined to be lost when the acknowlegement of
packet 4 is received at t=8.  The congestion period is calculated as the time
between the oldest and newest lost packets: (3 - 0) = 3.  The duration for
persistent congestion is equal to: (1 * kPersistentCongestionThreshold) = 3.
Because the threshold was reached and because none of the packets between the
oldest and the newest packets are acknowledged, the network is considered to
have experienced persistent congestion.<a href="#section-6.7-7" class="pilcrow">¶</a></p>
<p id="section-6.7-8">When persistent congestion is established, the sender's congestion window MUST
be reduced to the minimum congestion window (kMinimumWindow).  This response of
collapsing the congestion window on persistent congestion is functionally
similar to a sender's response on a Retransmission Timeout (RTO) in TCP
<span>[<a href="#RFC5681" class="xref">RFC5681</a>]</span> after Tail Loss Probes (TLP) <span>[<a href="#RACK" class="xref">RACK</a>]</span>.<a href="#section-6.7-8" class="pilcrow">¶</a></p>
</section>
</div>
<div id="pacing">
<section id="section-6.8">
        <h3 id="name-pacing">
<a href="#section-6.8" class="section-number selfRef">6.8. </a><a href="#name-pacing" class="section-name selfRef">Pacing</a>
        </h3>
<p id="section-6.8-1">This document does not specify a pacer, but it is RECOMMENDED that a sender pace
sending of all in-flight packets based on input from the congestion
controller. For example, a pacer might distribute the congestion window over
the smoothed RTT when used with a window-based controller, and a pacer might use
the rate estimate of a rate-based controller.<a href="#section-6.8-1" class="pilcrow">¶</a></p>
<p id="section-6.8-2">An implementation should take care to architect its congestion controller to
work well with a pacer.  For instance, a pacer might wrap the congestion
controller and control the availability of the congestion window, or a pacer
might pace out packets handed to it by the congestion controller. Timely
delivery of ACK frames is important for efficient loss recovery. Packets
containing only ACK frames should therefore not be paced, to avoid delaying
their delivery to the peer.<a href="#section-6.8-2" class="pilcrow">¶</a></p>
<p id="section-6.8-3">Sending multiple packets into the network without any delay between them
creates a packet burst that might cause short-term congestion and losses.
Implementations MUST either use pacing or limit such bursts to the initial
congestion window, which is recommended to be the minimum of
10 * max_datagram_size and max(2* max_datagram_size, 14720)), where
max_datagram_size is the current maximum size of a datagram for the connection,
not including UDP or IP overhead.<a href="#section-6.8-3" class="pilcrow">¶</a></p>
<p id="section-6.8-4">As an example of a well-known and publicly available implementation of a flow
pacer, implementers are referred to the Fair Queue packet scheduler (fq qdisc)
in Linux (3.11 onwards).<a href="#section-6.8-4" class="pilcrow">¶</a></p>
</section>
</div>
<div id="under-utilizing-the-congestion-window">
<section id="section-6.9">
        <h3 id="name-under-utilizing-the-congest">
<a href="#section-6.9" class="section-number selfRef">6.9. </a><a href="#name-under-utilizing-the-congest" class="section-name selfRef">Under-utilizing the Congestion Window</a>
        </h3>
<p id="section-6.9-1">When bytes in flight is smaller than the congestion window and sending is not
pacing limited, the congestion window is under-utilized.  When this occurs,
the congestion window SHOULD NOT be increased in either slow start or
congestion avoidance. This can happen due to insufficient application data
or flow control credit.<a href="#section-6.9-1" class="pilcrow">¶</a></p>
<p id="section-6.9-2">A sender MAY use the pipeACK method described in section 4.3 of <span>[<a href="#RFC7661" class="xref">RFC7661</a>]</span>
to determine if the congestion window is sufficiently utilized.<a href="#section-6.9-2" class="pilcrow">¶</a></p>
<p id="section-6.9-3">A sender that paces packets (see <a href="#pacing" class="xref">Section 6.8</a>) might delay sending packets
and not fully utilize the congestion window due to this delay. A sender
should not consider itself application limited if it would have fully
utilized the congestion window without pacing delay.<a href="#section-6.9-3" class="pilcrow">¶</a></p>
<p id="section-6.9-4">A sender MAY implement alternative mechanisms to update its congestion window
after periods of under-utilization, such as those proposed for TCP in
<span>[<a href="#RFC7661" class="xref">RFC7661</a>]</span>.<a href="#section-6.9-4" class="pilcrow">¶</a></p>
</section>
</div>
</section>
</div>
<div id="security-considerations">
<section id="section-7">
      <h2 id="name-security-considerations">
<a href="#section-7" class="section-number selfRef">7. </a><a href="#name-security-considerations" class="section-name selfRef">Security Considerations</a>
      </h2>
<div id="congestion-signals">
<section id="section-7.1">
        <h3 id="name-congestion-signals">
<a href="#section-7.1" class="section-number selfRef">7.1. </a><a href="#name-congestion-signals" class="section-name selfRef">Congestion Signals</a>
        </h3>
<p id="section-7.1-1">Congestion control fundamentally involves the consumption of signals - both
loss and ECN codepoints - from unauthenticated entities.  On-path attackers can
spoof or alter these signals.  An attacker can cause endpoints to reduce their
sending rate by dropping packets, or alter send rate by changing ECN codepoints.<a href="#section-7.1-1" class="pilcrow">¶</a></p>
</section>
</div>
<div id="traffic-analysis">
<section id="section-7.2">
        <h3 id="name-traffic-analysis">
<a href="#section-7.2" class="section-number selfRef">7.2. </a><a href="#name-traffic-analysis" class="section-name selfRef">Traffic Analysis</a>
        </h3>
<p id="section-7.2-1">Packets that carry only ACK frames can be heuristically identified by observing
packet size.  Acknowledgement patterns may expose information about link
characteristics or application behavior.  Endpoints can use PADDING frames or
bundle acknowledgments with other frames to reduce leaked information.<a href="#section-7.2-1" class="pilcrow">¶</a></p>
</section>
</div>
<div id="misreporting-ecn-markings">
<section id="section-7.3">
        <h3 id="name-misreporting-ecn-markings">
<a href="#section-7.3" class="section-number selfRef">7.3. </a><a href="#name-misreporting-ecn-markings" class="section-name selfRef">Misreporting ECN Markings</a>
        </h3>
<p id="section-7.3-1">A receiver can misreport ECN markings to alter the congestion response of a
sender.  Suppressing reports of ECN-CE markings could cause a sender to
increase their send rate.  This increase could result in congestion and loss.<a href="#section-7.3-1" class="pilcrow">¶</a></p>
<p id="section-7.3-2">A sender MAY attempt to detect suppression of reports by marking occasional
packets that they send with ECN-CE.  If a packet sent with ECN-CE is not
reported as having been CE marked when the packet is acknowledged, then the
sender SHOULD disable ECN for that path.<a href="#section-7.3-2" class="pilcrow">¶</a></p>
<p id="section-7.3-3">Reporting additional ECN-CE markings will cause a sender to reduce their sending
rate, which is similar in effect to advertising reduced connection flow control
limits and so no advantage is gained by doing so.<a href="#section-7.3-3" class="pilcrow">¶</a></p>
<p id="section-7.3-4">Endpoints choose the congestion controller that they use.  Though congestion
controllers generally treat reports of ECN-CE markings as equivalent to loss
<span>[<a href="#RFC8311" class="xref">RFC8311</a>]</span>, the exact response for each controller could be different.  Failure
to correctly respond to information about ECN markings is therefore difficult to
detect.<a href="#section-7.3-4" class="pilcrow">¶</a></p>
</section>
</div>
</section>
</div>
<div id="iana-considerations">
<section id="section-8">
      <h2 id="name-iana-considerations">
<a href="#section-8" class="section-number selfRef">8. </a><a href="#name-iana-considerations" class="section-name selfRef">IANA Considerations</a>
      </h2>
<p id="section-8-1">This document has no IANA actions.  Yet.<a href="#section-8-1" class="pilcrow">¶</a></p>
</section>
</div>
<section id="section-9">
      <h2 id="name-references">
<a href="#section-9" class="section-number selfRef">9. </a><a href="#name-references" class="section-name selfRef">References</a>
      </h2>
<section id="section-9.1">
        <h3 id="name-normative-references">
<a href="#section-9.1" class="section-number selfRef">9.1. </a><a href="#name-normative-references" class="section-name selfRef">Normative References</a>
        </h3>
<dl class="references">
<dt id="QUIC-TLS">[QUIC-TLS]</dt>
<dd>
<span class="refAuthor">Thomson, M., Ed.</span><span class="refAuthor"> and S. Turner, Ed.</span>, <span class="refTitle">"Using TLS to Secure QUIC"</span>, <span class="refContent">Work in Progress</span>, <span class="seriesInfo">Internet-Draft, draft-ietf-quic-tls-25</span>, <time datetime="2020-01-22">22 January 2020</time>, <span>&lt;<a href="https://tools.ietf.org/html/draft-ietf-quic-tls-25">https://tools.ietf.org/html/draft-ietf-quic-tls-25</a>&gt;</span>. </dd>
<dt id="QUIC-TRANSPORT">[QUIC-TRANSPORT]</dt>
<dd>
<span class="refAuthor">Iyengar, J., Ed.</span><span class="refAuthor"> and M. Thomson, Ed.</span>, <span class="refTitle">"QUIC: A UDP-Based Multiplexed and Secure Transport"</span>, <span class="refContent">Work in Progress</span>, <span class="seriesInfo">Internet-Draft, draft-ietf-quic-transport-25</span>, <time datetime="2020-01-22">22 January 2020</time>, <span>&lt;<a href="https://tools.ietf.org/html/draft-ietf-quic-transport-25">https://tools.ietf.org/html/draft-ietf-quic-transport-25</a>&gt;</span>. </dd>
<dt id="RFC2119">[RFC2119]</dt>
<dd>
<span class="refAuthor">Bradner, S.</span>, <span class="refTitle">"Key words for use in RFCs to Indicate Requirement Levels"</span>, <span class="seriesInfo">BCP 14</span>, <span class="seriesInfo">RFC 2119</span>, <span class="seriesInfo">DOI 10.17487/RFC2119</span>, <time datetime="1997-03">March 1997</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc2119">https://www.rfc-editor.org/info/rfc2119</a>&gt;</span>. </dd>
<dt id="RFC8085">[RFC8085]</dt>
<dd>
<span class="refAuthor">Eggert, L.</span><span class="refAuthor">, Fairhurst, G.</span><span class="refAuthor">, and G. Shepherd</span>, <span class="refTitle">"UDP Usage Guidelines"</span>, <span class="seriesInfo">BCP 145</span>, <span class="seriesInfo">RFC 8085</span>, <span class="seriesInfo">DOI 10.17487/RFC8085</span>, <time datetime="2017-03">March 2017</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc8085">https://www.rfc-editor.org/info/rfc8085</a>&gt;</span>. </dd>
<dt id="RFC8174">[RFC8174]</dt>
<dd>
<span class="refAuthor">Leiba, B.</span>, <span class="refTitle">"Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words"</span>, <span class="seriesInfo">BCP 14</span>, <span class="seriesInfo">RFC 8174</span>, <span class="seriesInfo">DOI 10.17487/RFC8174</span>, <time datetime="2017-05">May 2017</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc8174">https://www.rfc-editor.org/info/rfc8174</a>&gt;</span>. </dd>
</dl>
</section>
<section id="section-9.2">
        <h3 id="name-informative-references">
<a href="#section-9.2" class="section-number selfRef">9.2. </a><a href="#name-informative-references" class="section-name selfRef">Informative References</a>
        </h3>
<dl class="references">
<dt id="FACK">[FACK]</dt>
<dd>
<span class="refAuthor">Mathis, M.</span><span class="refAuthor"> and J. Mahdavi</span>, <span class="refTitle">"Forward Acknowledgement: Refining TCP Congestion Control"</span>, <span class="seriesInfo">ACM SIGCOMM </span>, <time datetime="1996-08">August 1996</time>. </dd>
<dt id="RACK">[RACK]</dt>
<dd>
<span class="refAuthor">Cheng, Y.</span><span class="refAuthor">, Cardwell, N.</span><span class="refAuthor">, Dukkipati, N.</span><span class="refAuthor">, and P. Jha</span>, <span class="refTitle">"RACK: a time-based fast loss detection algorithm for TCP"</span>, <span class="refContent">Work in Progress</span>, <span class="seriesInfo">Internet-Draft, draft-ietf-tcpm-rack-05</span>, <time datetime="2019-04-26">26 April 2019</time>, <span>&lt;<a href="http://www.ietf.org/internet-drafts/draft-ietf-tcpm-rack-05.txt">http://www.ietf.org/internet-drafts/draft-ietf-tcpm-rack-05.txt</a>&gt;</span>. </dd>
<dt id="RFC3168">[RFC3168]</dt>
<dd>
<span class="refAuthor">Ramakrishnan, K.</span><span class="refAuthor">, Floyd, S.</span><span class="refAuthor">, and D. Black</span>, <span class="refTitle">"The Addition of Explicit Congestion Notification (ECN) to IP"</span>, <span class="seriesInfo">RFC 3168</span>, <span class="seriesInfo">DOI 10.17487/RFC3168</span>, <time datetime="2001-09">September 2001</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc3168">https://www.rfc-editor.org/info/rfc3168</a>&gt;</span>. </dd>
<dt id="RFC4653">[RFC4653]</dt>
<dd>
<span class="refAuthor">Bhandarkar, S.</span><span class="refAuthor">, Reddy, A. L. N.</span><span class="refAuthor">, Allman, M.</span><span class="refAuthor">, and E. Blanton</span>, <span class="refTitle">"Improving the Robustness of TCP to Non-Congestion Events"</span>, <span class="seriesInfo">RFC 4653</span>, <span class="seriesInfo">DOI 10.17487/RFC4653</span>, <time datetime="2006-08">August 2006</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc4653">https://www.rfc-editor.org/info/rfc4653</a>&gt;</span>. </dd>
<dt id="RFC5681">[RFC5681]</dt>
<dd>
<span class="refAuthor">Allman, M.</span><span class="refAuthor">, Paxson, V.</span><span class="refAuthor">, and E. Blanton</span>, <span class="refTitle">"TCP Congestion Control"</span>, <span class="seriesInfo">RFC 5681</span>, <span class="seriesInfo">DOI 10.17487/RFC5681</span>, <time datetime="2009-09">September 2009</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc5681">https://www.rfc-editor.org/info/rfc5681</a>&gt;</span>. </dd>
<dt id="RFC5682">[RFC5682]</dt>
<dd>
<span class="refAuthor">Sarolahti, P.</span><span class="refAuthor">, Kojo, M.</span><span class="refAuthor">, Yamamoto, K.</span><span class="refAuthor">, and M. Hata</span>, <span class="refTitle">"Forward RTO-Recovery (F-RTO): An Algorithm for Detecting Spurious Retransmission Timeouts with TCP"</span>, <span class="seriesInfo">RFC 5682</span>, <span class="seriesInfo">DOI 10.17487/RFC5682</span>, <time datetime="2009-09">September 2009</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc5682">https://www.rfc-editor.org/info/rfc5682</a>&gt;</span>. </dd>
<dt id="RFC5827">[RFC5827]</dt>
<dd>
<span class="refAuthor">Allman, M.</span><span class="refAuthor">, Avrachenkov, K.</span><span class="refAuthor">, Ayesta, U.</span><span class="refAuthor">, Blanton, J.</span><span class="refAuthor">, and P. Hurtig</span>, <span class="refTitle">"Early Retransmit for TCP and Stream Control Transmission Protocol (SCTP)"</span>, <span class="seriesInfo">RFC 5827</span>, <span class="seriesInfo">DOI 10.17487/RFC5827</span>, <time datetime="2010-05">May 2010</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc5827">https://www.rfc-editor.org/info/rfc5827</a>&gt;</span>. </dd>
<dt id="RFC6298">[RFC6298]</dt>
<dd>
<span class="refAuthor">Paxson, V.</span><span class="refAuthor">, Allman, M.</span><span class="refAuthor">, Chu, J.</span><span class="refAuthor">, and M. Sargent</span>, <span class="refTitle">"Computing TCP's Retransmission Timer"</span>, <span class="seriesInfo">RFC 6298</span>, <span class="seriesInfo">DOI 10.17487/RFC6298</span>, <time datetime="2011-06">June 2011</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc6298">https://www.rfc-editor.org/info/rfc6298</a>&gt;</span>. </dd>
<dt id="RFC6582">[RFC6582]</dt>
<dd>
<span class="refAuthor">Henderson, T.</span><span class="refAuthor">, Floyd, S.</span><span class="refAuthor">, Gurtov, A.</span><span class="refAuthor">, and Y. Nishida</span>, <span class="refTitle">"The NewReno Modification to TCP's Fast Recovery Algorithm"</span>, <span class="seriesInfo">RFC 6582</span>, <span class="seriesInfo">DOI 10.17487/RFC6582</span>, <time datetime="2012-04">April 2012</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc6582">https://www.rfc-editor.org/info/rfc6582</a>&gt;</span>. </dd>
<dt id="RFC6675">[RFC6675]</dt>
<dd>
<span class="refAuthor">Blanton, E.</span><span class="refAuthor">, Allman, M.</span><span class="refAuthor">, Wang, L.</span><span class="refAuthor">, Jarvinen, I.</span><span class="refAuthor">, Kojo, M.</span><span class="refAuthor">, and Y. Nishida</span>, <span class="refTitle">"A Conservative Loss Recovery Algorithm Based on Selective Acknowledgment (SACK) for TCP"</span>, <span class="seriesInfo">RFC 6675</span>, <span class="seriesInfo">DOI 10.17487/RFC6675</span>, <time datetime="2012-08">August 2012</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc6675">https://www.rfc-editor.org/info/rfc6675</a>&gt;</span>. </dd>
<dt id="RFC6928">[RFC6928]</dt>
<dd>
<span class="refAuthor">Chu, J.</span><span class="refAuthor">, Dukkipati, N.</span><span class="refAuthor">, Cheng, Y.</span><span class="refAuthor">, and M. Mathis</span>, <span class="refTitle">"Increasing TCP's Initial Window"</span>, <span class="seriesInfo">RFC 6928</span>, <span class="seriesInfo">DOI 10.17487/RFC6928</span>, <time datetime="2013-04">April 2013</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc6928">https://www.rfc-editor.org/info/rfc6928</a>&gt;</span>. </dd>
<dt id="RFC7661">[RFC7661]</dt>
<dd>
<span class="refAuthor">Fairhurst, G.</span><span class="refAuthor">, Sathiaseelan, A.</span><span class="refAuthor">, and R. Secchi</span>, <span class="refTitle">"Updating TCP to Support Rate-Limited Traffic"</span>, <span class="seriesInfo">RFC 7661</span>, <span class="seriesInfo">DOI 10.17487/RFC7661</span>, <time datetime="2015-10">October 2015</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc7661">https://www.rfc-editor.org/info/rfc7661</a>&gt;</span>. </dd>
<dt id="RFC8311">[RFC8311]</dt>
<dd>
<span class="refAuthor">Black, D.</span>, <span class="refTitle">"Relaxing Restrictions on Explicit Congestion Notification (ECN) Experimentation"</span>, <span class="seriesInfo">RFC 8311</span>, <span class="seriesInfo">DOI 10.17487/RFC8311</span>, <time datetime="2018-01">January 2018</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc8311">https://www.rfc-editor.org/info/rfc8311</a>&gt;</span>. </dd>
<dt id="RFC8312">[RFC8312]</dt>
<dd>
<span class="refAuthor">Rhee, I.</span><span class="refAuthor">, Xu, L.</span><span class="refAuthor">, Ha, S.</span><span class="refAuthor">, Zimmermann, A.</span><span class="refAuthor">, Eggert, L.</span><span class="refAuthor">, and R. Scheffenegger</span>, <span class="refTitle">"CUBIC for Fast Long-Distance Networks"</span>, <span class="seriesInfo">RFC 8312</span>, <span class="seriesInfo">DOI 10.17487/RFC8312</span>, <time datetime="2018-02">February 2018</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc8312">https://www.rfc-editor.org/info/rfc8312</a>&gt;</span>. </dd>
</dl>
</section>
</section>
<div id="loss-recovery-pseudocode">
<section id="section-appendix.a">
      <h2 id="name-loss-recovery-pseudocode">
<a href="#section-appendix.a" class="section-number selfRef">Appendix A. </a><a href="#name-loss-recovery-pseudocode" class="section-name selfRef">Loss Recovery Pseudocode</a>
      </h2>
<p id="section-appendix.a-1">We now describe an example implementation of the loss detection mechanisms
described in <a href="#loss-detection" class="xref">Section 5</a>.<a href="#section-appendix.a-1" class="pilcrow">¶</a></p>
<div id="tracking-sent-packets">
<section id="section-a.1">
        <h2 id="name-tracking-sent-packets">
<a href="#section-a.1" class="section-number selfRef">A.1. </a><a href="#name-tracking-sent-packets" class="section-name selfRef">Tracking Sent Packets</a>
        </h2>
<p id="section-a.1-1">To correctly implement congestion control, a QUIC sender tracks every
ack-eliciting packet until the packet is acknowledged or lost.
It is expected that implementations will be able to access this information by
packet number and crypto context and store the per-packet fields
(<a href="#sent-packets-fields" class="xref">Appendix A.1.1</a>) for loss recovery and congestion control.<a href="#section-a.1-1" class="pilcrow">¶</a></p>
<p id="section-a.1-2">After a packet is declared lost, the endpoint can track it for an amount of
time comparable to the maximum expected packet reordering, such as 1 RTT.
This allows for detection of spurious retransmissions.<a href="#section-a.1-2" class="pilcrow">¶</a></p>
<p id="section-a.1-3">Sent packets are tracked for each packet number space, and ACK
processing only applies to a single space.<a href="#section-a.1-3" class="pilcrow">¶</a></p>
<div id="sent-packets-fields">
<section id="section-a.1.1">
          <h3 id="name-sent-packet-fields">
<a href="#section-a.1.1" class="section-number selfRef">A.1.1. </a><a href="#name-sent-packet-fields" class="section-name selfRef">Sent Packet Fields</a>
          </h3>
<dl class="dlParallel" id="section-a.1.1-1">
            <dt id="section-a.1.1-1.1">packet_number:</dt>
<dd id="section-a.1.1-1.2">
  The packet number of the sent packet.<a href="#section-a.1.1-1.2" class="pilcrow">¶</a>
</dd>
<dt id="section-a.1.1-1.3">ack_eliciting:</dt>
<dd id="section-a.1.1-1.4">
  A boolean that indicates whether a packet is ack-eliciting.
If true, it is expected that an acknowledgement will be received,
though the peer could delay sending the ACK frame containing it
by up to the MaxAckDelay.<a href="#section-a.1.1-1.4" class="pilcrow">¶</a>
</dd>
<dt id="section-a.1.1-1.5">in_flight:</dt>
<dd id="section-a.1.1-1.6">
  A boolean that indicates whether the packet counts towards bytes in
flight.<a href="#section-a.1.1-1.6" class="pilcrow">¶</a>
</dd>
<dt id="section-a.1.1-1.7">sent_bytes:</dt>
<dd id="section-a.1.1-1.8">
  The number of bytes sent in the packet, not including UDP or IP
overhead, but including QUIC framing overhead.<a href="#section-a.1.1-1.8" class="pilcrow">¶</a>
</dd>
<dt id="section-a.1.1-1.9">time_sent:</dt>
<dd id="section-a.1.1-1.10">
  The time the packet was sent.<a href="#section-a.1.1-1.10" class="pilcrow">¶</a>
</dd>
</dl>
</section>
</div>
</section>
</div>
<div id="ld-consts-of-interest">
<section id="section-a.2">
        <h2 id="name-constants-of-interest">
<a href="#section-a.2" class="section-number selfRef">A.2. </a><a href="#name-constants-of-interest" class="section-name selfRef">Constants of interest</a>
        </h2>
<p id="section-a.2-1">Constants used in loss recovery are based on a combination of RFCs, papers, and
common practice.<a href="#section-a.2-1" class="pilcrow">¶</a></p>
<dl class="dlParallel" id="section-a.2-2">
          <dt id="section-a.2-2.1">kPacketThreshold:</dt>
<dd id="section-a.2-2.2">
  Maximum reordering in packets before packet threshold loss detection
considers a packet lost. The RECOMMENDED value is 3.<a href="#section-a.2-2.2" class="pilcrow">¶</a>
</dd>
<dt id="section-a.2-2.3">kTimeThreshold:</dt>
<dd id="section-a.2-2.4">
  Maximum reordering in time before time threshold loss detection
considers a packet lost. Specified as an RTT multiplier. The RECOMMENDED
value is 9/8.<a href="#section-a.2-2.4" class="pilcrow">¶</a>
</dd>
<dt id="section-a.2-2.5">kGranularity:</dt>
<dd id="section-a.2-2.6">
  Timer granularity. This is a system-dependent value.  However, implementations
SHOULD use a value no smaller than 1ms.<a href="#section-a.2-2.6" class="pilcrow">¶</a>
</dd>
<dt id="section-a.2-2.7">kInitialRtt:</dt>
<dd id="section-a.2-2.8">
  The RTT used before an RTT sample is taken. The RECOMMENDED value is 500ms.<a href="#section-a.2-2.8" class="pilcrow">¶</a>
</dd>
<dt id="section-a.2-2.9">kPacketNumberSpace:</dt>
<dd id="section-a.2-2.10">
  An enum to enumerate the three packet number spaces.<a href="#section-a.2-2.10" class="pilcrow">¶</a>
</dd>
</dl>
<div class="artwork art-text alignLeft" id="section-a.2-3">
<pre>
  enum kPacketNumberSpace {
    Initial,
    Handshake,
    ApplicationData,
  }
</pre><a href="#section-a.2-3" class="pilcrow">¶</a>
</div>
</section>
</div>
<div id="ld-vars-of-interest">
<section id="section-a.3">
        <h2 id="name-variables-of-interest">
<a href="#section-a.3" class="section-number selfRef">A.3. </a><a href="#name-variables-of-interest" class="section-name selfRef">Variables of interest</a>
        </h2>
<p id="section-a.3-1">Variables required to implement the congestion control mechanisms
are described in this section.<a href="#section-a.3-1" class="pilcrow">¶</a></p>
<dl class="dlParallel" id="section-a.3-2">
          <dt id="section-a.3-2.1">latest_rtt:</dt>
<dd id="section-a.3-2.2">
  The most recent RTT measurement made when receiving an ack for
a previously unacked packet.<a href="#section-a.3-2.2" class="pilcrow">¶</a>
</dd>
<dt id="section-a.3-2.3">smoothed_rtt:</dt>
<dd id="section-a.3-2.4">
  The smoothed RTT of the connection, computed as described in
<span>[<a href="#RFC6298" class="xref">RFC6298</a>]</span><a href="#section-a.3-2.4" class="pilcrow">¶</a>
</dd>
<dt id="section-a.3-2.5">rttvar:</dt>
<dd id="section-a.3-2.6">
  The RTT variation, computed as described in <span>[<a href="#RFC6298" class="xref">RFC6298</a>]</span><a href="#section-a.3-2.6" class="pilcrow">¶</a>
</dd>
<dt id="section-a.3-2.7">min_rtt:</dt>
<dd id="section-a.3-2.8">
  The minimum RTT seen in the connection, ignoring ack delay.<a href="#section-a.3-2.8" class="pilcrow">¶</a>
</dd>
<dt id="section-a.3-2.9">max_ack_delay:</dt>
<dd id="section-a.3-2.10">
  The maximum amount of time by which the receiver intends to delay
acknowledgments for packets in the ApplicationData packet number space. The
actual ack_delay in a received ACK frame may be larger due to late timers,
reordering, or lost ACK frames.<a href="#section-a.3-2.10" class="pilcrow">¶</a>
</dd>
<dt id="section-a.3-2.11">loss_detection_timer:</dt>
<dd id="section-a.3-2.12">
  Multi-modal timer used for loss detection.<a href="#section-a.3-2.12" class="pilcrow">¶</a>
</dd>
<dt id="section-a.3-2.13">pto_count:</dt>
<dd id="section-a.3-2.14">
  The number of times a PTO has been sent without receiving an ack.<a href="#section-a.3-2.14" class="pilcrow">¶</a>
</dd>
<dt id="section-a.3-2.15">time_of_last_sent_ack_eliciting_packet[kPacketNumberSpace]:</dt>
<dd id="section-a.3-2.16">
  The time the most recent ack-eliciting packet was sent.<a href="#section-a.3-2.16" class="pilcrow">¶</a>
</dd>
<dt id="section-a.3-2.17">largest_acked_packet[kPacketNumberSpace]:</dt>
<dd id="section-a.3-2.18">
  The largest packet number acknowledged in the packet number space so far.<a href="#section-a.3-2.18" class="pilcrow">¶</a>
</dd>
<dt id="section-a.3-2.19">loss_time[kPacketNumberSpace]:</dt>
<dd id="section-a.3-2.20">
  The time at which the next packet in that packet number space will be
considered lost based on exceeding the reordering window in time.<a href="#section-a.3-2.20" class="pilcrow">¶</a>
</dd>
<dt id="section-a.3-2.21">sent_packets[kPacketNumberSpace]:</dt>
<dd id="section-a.3-2.22">
  An association of packet numbers in a packet number space to information
about them.  Described in detail above in <a href="#tracking-sent-packets" class="xref">Appendix A.1</a>.<a href="#section-a.3-2.22" class="pilcrow">¶</a>
</dd>
</dl>
</section>
</div>
<div id="initialization">
<section id="section-a.4">
        <h2 id="name-initialization">
<a href="#section-a.4" class="section-number selfRef">A.4. </a><a href="#name-initialization" class="section-name selfRef">Initialization</a>
        </h2>
<p id="section-a.4-1">At the beginning of the connection, initialize the loss detection variables as
follows:<a href="#section-a.4-1" class="pilcrow">¶</a></p>
<div class="artwork art-text alignLeft" id="section-a.4-2">
<pre>
   loss_detection_timer.reset()
   pto_count = 0
   latest_rtt = 0
   smoothed_rtt = 0
   rttvar = 0
   min_rtt = 0
   max_ack_delay = 0
   for pn_space in [ Initial, Handshake, ApplicationData ]:
     largest_acked_packet[pn_space] = infinite
     time_of_last_sent_ack_eliciting_packet[pn_space] = 0
     loss_time[pn_space] = 0
</pre><a href="#section-a.4-2" class="pilcrow">¶</a>
</div>
</section>
</div>
<div id="on-sending-a-packet">
<section id="section-a.5">
        <h2 id="name-on-sending-a-packet">
<a href="#section-a.5" class="section-number selfRef">A.5. </a><a href="#name-on-sending-a-packet" class="section-name selfRef">On Sending a Packet</a>
        </h2>
<p id="section-a.5-1">After a packet is sent, information about the packet is stored.  The parameters
to OnPacketSent are described in detail above in <a href="#sent-packets-fields" class="xref">Appendix A.1.1</a>.<a href="#section-a.5-1" class="pilcrow">¶</a></p>
<p id="section-a.5-2">Pseudocode for OnPacketSent follows:<a href="#section-a.5-2" class="pilcrow">¶</a></p>
<div class="artwork art-text alignLeft" id="section-a.5-3">
<pre>
 OnPacketSent(packet_number, pn_space, ack_eliciting,
              in_flight, sent_bytes):
   sent_packets[pn_space][packet_number].packet_number =
                                            packet_number
   sent_packets[pn_space][packet_number].time_sent = now
   sent_packets[pn_space][packet_number].ack_eliciting =
                                            ack_eliciting
   sent_packets[pn_space][packet_number].in_flight = in_flight
   if (in_flight):
     if (ack_eliciting):
       time_of_last_sent_ack_eliciting_packet[pn_space] = now
     OnPacketSentCC(sent_bytes)
     sent_packets[pn_space][packet_number].size = sent_bytes
     SetLossDetectionTimer()
</pre><a href="#section-a.5-3" class="pilcrow">¶</a>
</div>
</section>
</div>
<div id="on-receiving-an-acknowledgment">
<section id="section-a.6">
        <h2 id="name-on-receiving-an-acknowledgm">
<a href="#section-a.6" class="section-number selfRef">A.6. </a><a href="#name-on-receiving-an-acknowledgm" class="section-name selfRef">On Receiving an Acknowledgment</a>
        </h2>
<p id="section-a.6-1">When an ACK frame is received, it may newly acknowledge any number of packets.<a href="#section-a.6-1" class="pilcrow">¶</a></p>
<p id="section-a.6-2">Pseudocode for OnAckReceived and UpdateRtt follow:<a href="#section-a.6-2" class="pilcrow">¶</a></p>
<div class="artwork art-text alignLeft" id="section-a.6-3">
<pre>
OnAckReceived(ack, pn_space):
  if (largest_acked_packet[pn_space] == infinite):
    largest_acked_packet[pn_space] = ack.largest_acked
  else:
    largest_acked_packet[pn_space] =
        max(largest_acked_packet[pn_space], ack.largest_acked)

  // Nothing to do if there are no newly acked packets.
  newly_acked_packets = DetermineNewlyAckedPackets(ack, pn_space)
  if (newly_acked_packets.empty()):
    return

  // If the largest acknowledged is newly acked and
  // at least one ack-eliciting was newly acked, update the RTT.
  if (sent_packets[pn_space].contains(ack.largest_acked) &amp;&amp;
      IncludesAckEliciting(newly_acked_packets)):
    latest_rtt =
      now - sent_packets[pn_space][ack.largest_acked].time_sent
    ack_delay = 0
    if (pn_space == ApplicationData):
      ack_delay = ack.ack_delay
    UpdateRtt(ack_delay)

  // Process ECN information if present.
  if (ACK frame contains ECN information):
      ProcessECN(ack, pn_space)

  for acked_packet in newly_acked_packets:
    OnPacketAcked(acked_packet.packet_number, pn_space)

  DetectLostPackets(pn_space)

  pto_count = 0

  SetLossDetectionTimer()


UpdateRtt(ack_delay):
  // First RTT sample.
  if (smoothed_rtt == 0):
    min_rtt = latest_rtt
    smoothed_rtt = latest_rtt
    rttvar = latest_rtt / 2
    return

  // min_rtt ignores ack delay.
  min_rtt = min(min_rtt, latest_rtt)
  // Limit ack_delay by max_ack_delay
  ack_delay = min(ack_delay, max_ack_delay)
  // Adjust for ack delay if plausible.
  adjusted_rtt = latest_rtt
  if (latest_rtt &gt; min_rtt + ack_delay):
    adjusted_rtt = latest_rtt - ack_delay

  rttvar = 3/4 * rttvar + 1/4 * abs(smoothed_rtt - adjusted_rtt)
  smoothed_rtt = 7/8 * smoothed_rtt + 1/8 * adjusted_rtt
</pre><a href="#section-a.6-3" class="pilcrow">¶</a>
</div>
</section>
</div>
<div id="on-packet-acknowledgment">
<section id="section-a.7">
        <h2 id="name-on-packet-acknowledgment">
<a href="#section-a.7" class="section-number selfRef">A.7. </a><a href="#name-on-packet-acknowledgment" class="section-name selfRef">On Packet Acknowledgment</a>
        </h2>
<p id="section-a.7-1">When a packet is acknowledged for the first time, the following OnPacketAcked
function is called.  Note that a single ACK frame may newly acknowledge several
packets. OnPacketAcked must be called once for each of these newly acknowledged
packets.<a href="#section-a.7-1" class="pilcrow">¶</a></p>
<p id="section-a.7-2">OnPacketAcked takes two parameters: acked_packet, which is the struct detailed
in <a href="#sent-packets-fields" class="xref">Appendix A.1.1</a>, and the packet number space that this ACK frame was
sent for.<a href="#section-a.7-2" class="pilcrow">¶</a></p>
<p id="section-a.7-3">Pseudocode for OnPacketAcked follows:<a href="#section-a.7-3" class="pilcrow">¶</a></p>
<div class="artwork art-text alignLeft" id="section-a.7-4">
<pre>
   OnPacketAcked(acked_packet, pn_space):
     if (acked_packet.in_flight):
       OnPacketAckedCC(acked_packet)
     sent_packets[pn_space].remove(acked_packet.packet_number)
</pre><a href="#section-a.7-4" class="pilcrow">¶</a>
</div>
</section>
</div>
<div id="setting-the-loss-detection-timer">
<section id="section-a.8">
        <h2 id="name-setting-the-loss-detection-">
<a href="#section-a.8" class="section-number selfRef">A.8. </a><a href="#name-setting-the-loss-detection-" class="section-name selfRef">Setting the Loss Detection Timer</a>
        </h2>
<p id="section-a.8-1">QUIC loss detection uses a single timer for all timeout loss detection.  The
duration of the timer is based on the timer's mode, which is set in the packet
and timer events further below.  The function SetLossDetectionTimer defined
below shows how the single timer is set.<a href="#section-a.8-1" class="pilcrow">¶</a></p>
<p id="section-a.8-2">This algorithm may result in the timer being set in the past, particularly if
timers wake up late. Timers set in the past SHOULD fire immediately.<a href="#section-a.8-2" class="pilcrow">¶</a></p>
<p id="section-a.8-3">Pseudocode for SetLossDetectionTimer follows:<a href="#section-a.8-3" class="pilcrow">¶</a></p>
<div class="artwork art-text alignLeft" id="section-a.8-4">
<pre>
GetEarliestTimeAndSpace(times):
  time = times[Initial]
  space = Initial
  for pn_space in [ Handshake, ApplicationData ]:
    if (times[pn_space] != 0 &amp;&amp;
        (time == 0 || times[pn_space] &lt; time) &amp;&amp;
        # Skip ApplicationData until handshake completion.
        (pn_space != ApplicationData ||
          IsHandshakeComplete()):
      time = times[pn_space];
      space = pn_space
  return time, space

PeerNotAwaitingAddressValidation():
  # Assume clients validate the server's address implicitly.
  if (endpoint is server):
    return true
  # Servers complete address validation when a
  # protected packet is received.
  return has received Handshake ACK ||
         has received 1-RTT ACK

SetLossDetectionTimer():
  earliest_loss_time, _ = GetEarliestTimeAndSpace(loss_time)
  if (earliest_loss_time != 0):
    // Time threshold loss detection.
    loss_detection_timer.update(earliest_loss_time)
    return

  if (no ack-eliciting packets in flight &amp;&amp;
      PeerNotAwaitingAddressValidation()):
    loss_detection_timer.cancel()
    return

  // Use a default timeout if there are no RTT measurements
  if (smoothed_rtt == 0):
    timeout = 2 * kInitialRtt
  else:
    // Calculate PTO duration
    timeout = smoothed_rtt + max(4 * rttvar, kGranularity) +
      max_ack_delay
  timeout = timeout * (2 ^ pto_count)

  sent_time, _ = GetEarliestTimeAndSpace(
    time_of_last_sent_ack_eliciting_packet)
  loss_detection_timer.update(sent_time + timeout)
</pre><a href="#section-a.8-4" class="pilcrow">¶</a>
</div>
</section>
</div>
<div id="on-timeout">
<section id="section-a.9">
        <h2 id="name-on-timeout">
<a href="#section-a.9" class="section-number selfRef">A.9. </a><a href="#name-on-timeout" class="section-name selfRef">On Timeout</a>
        </h2>
<p id="section-a.9-1">When the loss detection timer expires, the timer's mode determines the action
to be performed.<a href="#section-a.9-1" class="pilcrow">¶</a></p>
<p id="section-a.9-2">Pseudocode for OnLossDetectionTimeout follows:<a href="#section-a.9-2" class="pilcrow">¶</a></p>
<div class="artwork art-text alignLeft" id="section-a.9-3">
<pre>
OnLossDetectionTimeout():
  earliest_loss_time, pn_space =
    GetEarliestTimeAndSpace(loss_time)
  if (earliest_loss_time != 0):
    // Time threshold loss Detection
    DetectLostPackets(pn_space)
    SetLossDetectionTimer()
    return

  if (endpoint is client without 1-RTT keys):
    // Client sends an anti-deadlock packet: Initial is padded
    // to earn more anti-amplification credit,
    // a Handshake packet proves address ownership.
    if (has Handshake keys):
      SendOneAckElicitingHandshakePacket()
    else:
      SendOneAckElicitingPaddedInitialPacket()
  else:
    // PTO. Send new data if available, else retransmit old data.
    // If neither is available, send a single PING frame.
    _, pn_space = GetEarliestTimeAndSpace(
      time_of_last_sent_ack_eliciting_packet)
    SendOneOrTwoAckElicitingPackets(pn_space)

  pto_count++
  SetLossDetectionTimer()
</pre><a href="#section-a.9-3" class="pilcrow">¶</a>
</div>
</section>
</div>
<div id="detecting-lost-packets">
<section id="section-a.10">
        <h2 id="name-detecting-lost-packets">
<a href="#section-a.10" class="section-number selfRef">A.10. </a><a href="#name-detecting-lost-packets" class="section-name selfRef">Detecting Lost Packets</a>
        </h2>
<p id="section-a.10-1">DetectLostPackets is called every time an ACK is received and operates on
the sent_packets for that packet number space.<a href="#section-a.10-1" class="pilcrow">¶</a></p>
<p id="section-a.10-2">Pseudocode for DetectLostPackets follows:<a href="#section-a.10-2" class="pilcrow">¶</a></p>
<div class="artwork art-text alignLeft" id="section-a.10-3">
<pre>
DetectLostPackets(pn_space):
  assert(largest_acked_packet[pn_space] != infinite)
  loss_time[pn_space] = 0
  lost_packets = {}
  loss_delay = kTimeThreshold * max(latest_rtt, smoothed_rtt)

  // Minimum time of kGranularity before packets are deemed lost.
  loss_delay = max(loss_delay, kGranularity)

  // Packets sent before this time are deemed lost.
  lost_send_time = now() - loss_delay

  foreach unacked in sent_packets[pn_space]:
    if (unacked.packet_number &gt; largest_acked_packet[pn_space]):
      continue

    // Mark packet as lost, or set time when it should be marked.
    if (unacked.time_sent &lt;= lost_send_time ||
        largest_acked_packet[pn_space] &gt;=
          unacked.packet_number + kPacketThreshold):
      sent_packets[pn_space].remove(unacked.packet_number)
      if (unacked.in_flight):
        lost_packets.insert(unacked)
    else:
      if (loss_time[pn_space] == 0):
        loss_time[pn_space] = unacked.time_sent + loss_delay
      else:
        loss_time[pn_space] = min(loss_time[pn_space],
                                  unacked.time_sent + loss_delay)

  // Inform the congestion controller of lost packets and
  // let it decide whether to retransmit immediately.
  if (!lost_packets.empty()):
    OnPacketsLost(lost_packets)
</pre><a href="#section-a.10-3" class="pilcrow">¶</a>
</div>
</section>
</div>
</section>
</div>
<div id="congestion-control-pseudocode">
<section id="section-appendix.b">
      <h2 id="name-congestion-control-pseudoco">
<a href="#section-appendix.b" class="section-number selfRef">Appendix B. </a><a href="#name-congestion-control-pseudoco" class="section-name selfRef">Congestion Control Pseudocode</a>
      </h2>
<p id="section-appendix.b-1">We now describe an example implementation of the congestion controller described
in <a href="#congestion-control" class="xref">Section 6</a>.<a href="#section-appendix.b-1" class="pilcrow">¶</a></p>
<div id="cc-consts-of-interest">
<section id="section-b.1">
        <h2 id="name-constants-of-interest-2">
<a href="#section-b.1" class="section-number selfRef">B.1. </a><a href="#name-constants-of-interest-2" class="section-name selfRef">Constants of interest</a>
        </h2>
<p id="section-b.1-1">Constants used in congestion control are based on a combination of RFCs, papers,
and common practice.<a href="#section-b.1-1" class="pilcrow">¶</a></p>
<dl class="dlParallel" id="section-b.1-2">
          <dt id="section-b.1-2.1">kInitialWindow:</dt>
<dd id="section-b.1-2.2">
  Default limit on the initial amount of data in flight, in bytes.
The RECOMMENDED value is the minimum of 10 * max_datagram_size and
max(2 * max_datagram_size, 14720)).  This follows the analysis and
recommendations in <span>[<a href="#RFC6928" class="xref">RFC6928</a>]</span>, increasing the byte limit to account
for the smaller 8 byte overhead of UDP compared to the 20 byte overhead
for TCP.<a href="#section-b.1-2.2" class="pilcrow">¶</a>
</dd>
<dt id="section-b.1-2.3">kMinimumWindow:</dt>
<dd id="section-b.1-2.4">
  Minimum congestion window in bytes. The RECOMMENDED value is
2 * max_datagram_size.<a href="#section-b.1-2.4" class="pilcrow">¶</a>
</dd>
<dt id="section-b.1-2.5">kLossReductionFactor:</dt>
<dd id="section-b.1-2.6">
  Reduction in congestion window when a new loss event is detected.
The RECOMMENDED value is 0.5.<a href="#section-b.1-2.6" class="pilcrow">¶</a>
</dd>
<dt id="section-b.1-2.7">kPersistentCongestionThreshold:</dt>
<dd id="section-b.1-2.8">
  Period of time for persistent congestion to be established, specified as a PTO
multiplier.  The rationale for this threshold is to enable a sender to use
initial PTOs for aggressive probing, as TCP does with Tail Loss Probe (TLP)
<span>[<a href="#RACK" class="xref">RACK</a>]</span>, before establishing persistent congestion, as TCP does with a
Retransmission Timeout (RTO) <span>[<a href="#RFC5681" class="xref">RFC5681</a>]</span>.  The RECOMMENDED value for
kPersistentCongestionThreshold is 3, which is approximately equivalent to
having two TLPs before an RTO in TCP.<a href="#section-b.1-2.8" class="pilcrow">¶</a>
</dd>
</dl>
</section>
</div>
<div id="vars-of-interest">
<section id="section-b.2">
        <h2 id="name-variables-of-interest-2">
<a href="#section-b.2" class="section-number selfRef">B.2. </a><a href="#name-variables-of-interest-2" class="section-name selfRef">Variables of interest</a>
        </h2>
<p id="section-b.2-1">Variables required to implement the congestion control mechanisms
are described in this section.<a href="#section-b.2-1" class="pilcrow">¶</a></p>
<dl class="dlParallel" id="section-b.2-2">
          <dt id="section-b.2-2.1">max_datagram_size:</dt>
<dd id="section-b.2-2.2">
  The sender's current maximum payload size. Does not include UDP or IP
overhead.  The max datagram size is used for congestion window
computations. An endpoint sets the value of this variable based on its
PMTU (see Section 14.1 of <span>[<a href="#QUIC-TRANSPORT" class="xref">QUIC-TRANSPORT</a>]</span>), with a minimum value of
1200 bytes.<a href="#section-b.2-2.2" class="pilcrow">¶</a>
</dd>
<dt id="section-b.2-2.3">ecn_ce_counters[kPacketNumberSpace]:</dt>
<dd id="section-b.2-2.4">
  The highest value reported for the ECN-CE counter in the packet number space
by the peer in an ACK frame. This value is used to detect increases in the
reported ECN-CE counter.<a href="#section-b.2-2.4" class="pilcrow">¶</a>
</dd>
<dt id="section-b.2-2.5">bytes_in_flight:</dt>
<dd id="section-b.2-2.6">
  The sum of the size in bytes of all sent packets that contain at least one
ack-eliciting or PADDING frame, and have not been acked or declared
lost. The size does not include IP or UDP overhead, but does include the QUIC
header and AEAD overhead.  Packets only containing ACK frames do not count
towards bytes_in_flight to ensure congestion control does not impede
congestion feedback.<a href="#section-b.2-2.6" class="pilcrow">¶</a>
</dd>
<dt id="section-b.2-2.7">congestion_window:</dt>
<dd id="section-b.2-2.8">
  Maximum number of bytes-in-flight that may be sent.<a href="#section-b.2-2.8" class="pilcrow">¶</a>
</dd>
<dt id="section-b.2-2.9">congestion_recovery_start_time:</dt>
<dd id="section-b.2-2.10">
  The time when QUIC first detects congestion due to loss or ECN, causing
it to enter congestion recovery. When a packet sent after this time is
acknowledged, QUIC exits congestion recovery.<a href="#section-b.2-2.10" class="pilcrow">¶</a>
</dd>
<dt id="section-b.2-2.11">ssthresh:</dt>
<dd id="section-b.2-2.12">
  Slow start threshold in bytes.  When the congestion window is below ssthresh,
the mode is slow start and the window grows by the number of bytes
acknowledged.<a href="#section-b.2-2.12" class="pilcrow">¶</a>
</dd>
</dl>
</section>
</div>
<div id="initialization-1">
<section id="section-b.3">
        <h2 id="name-initialization-2">
<a href="#section-b.3" class="section-number selfRef">B.3. </a><a href="#name-initialization-2" class="section-name selfRef">Initialization</a>
        </h2>
<p id="section-b.3-1">At the beginning of the connection, initialize the congestion control
variables as follows:<a href="#section-b.3-1" class="pilcrow">¶</a></p>
<div class="artwork art-text alignLeft" id="section-b.3-2">
<pre>
   congestion_window = kInitialWindow
   bytes_in_flight = 0
   congestion_recovery_start_time = 0
   ssthresh = infinite
   for pn_space in [ Initial, Handshake, ApplicationData ]:
     ecn_ce_counters[pn_space] = 0
</pre><a href="#section-b.3-2" class="pilcrow">¶</a>
</div>
</section>
</div>
<div id="on-packet-sent">
<section id="section-b.4">
        <h2 id="name-on-packet-sent">
<a href="#section-b.4" class="section-number selfRef">B.4. </a><a href="#name-on-packet-sent" class="section-name selfRef">On Packet Sent</a>
        </h2>
<p id="section-b.4-1">Whenever a packet is sent, and it contains non-ACK frames, the packet
increases bytes_in_flight.<a href="#section-b.4-1" class="pilcrow">¶</a></p>
<div class="artwork art-text alignLeft" id="section-b.4-2">
<pre>
   OnPacketSentCC(bytes_sent):
     bytes_in_flight += bytes_sent
</pre><a href="#section-b.4-2" class="pilcrow">¶</a>
</div>
</section>
</div>
<div id="on-packet-acknowledgement">
<section id="section-b.5">
        <h2 id="name-on-packet-acknowledgement">
<a href="#section-b.5" class="section-number selfRef">B.5. </a><a href="#name-on-packet-acknowledgement" class="section-name selfRef">On Packet Acknowledgement</a>
        </h2>
<p id="section-b.5-1">Invoked from loss detection's OnPacketAcked and is supplied with the
acked_packet from sent_packets.<a href="#section-b.5-1" class="pilcrow">¶</a></p>
<div class="artwork art-text alignLeft" id="section-b.5-2">
<pre>
   InCongestionRecovery(sent_time):
     return sent_time &lt;= congestion_recovery_start_time

   OnPacketAckedCC(acked_packet):
     // Remove from bytes_in_flight.
     bytes_in_flight -= acked_packet.size
     if (InCongestionRecovery(acked_packet.time_sent)):
       // Do not increase congestion window in recovery period.
       return
     if (IsAppOrFlowControlLimited()):
       // Do not increase congestion_window if application
       // limited or flow control limited.
       return
     if (congestion_window &lt; ssthresh):
       // Slow start.
       congestion_window += acked_packet.size
     else:
       // Congestion avoidance.
       congestion_window += max_datagram_size * acked_packet.size
           / congestion_window
</pre><a href="#section-b.5-2" class="pilcrow">¶</a>
</div>
</section>
</div>
<div id="on-new-congestion-event">
<section id="section-b.6">
        <h2 id="name-on-new-congestion-event">
<a href="#section-b.6" class="section-number selfRef">B.6. </a><a href="#name-on-new-congestion-event" class="section-name selfRef">On New Congestion Event</a>
        </h2>
<p id="section-b.6-1">Invoked from ProcessECN and OnPacketsLost when a new congestion event is
detected. May start a new recovery period and reduces the congestion
window.<a href="#section-b.6-1" class="pilcrow">¶</a></p>
<div class="artwork art-text alignLeft" id="section-b.6-2">
<pre>
   CongestionEvent(sent_time):
     // Start a new congestion event if packet was sent after the
     // start of the previous congestion recovery period.
     if (!InCongestionRecovery(sent_time)):
       congestion_recovery_start_time = Now()
       congestion_window *= kLossReductionFactor
       congestion_window = max(congestion_window, kMinimumWindow)
       ssthresh = congestion_window
</pre><a href="#section-b.6-2" class="pilcrow">¶</a>
</div>
</section>
</div>
<div id="process-ecn-information">
<section id="section-b.7">
        <h2 id="name-process-ecn-information">
<a href="#section-b.7" class="section-number selfRef">B.7. </a><a href="#name-process-ecn-information" class="section-name selfRef">Process ECN Information</a>
        </h2>
<p id="section-b.7-1">Invoked when an ACK frame with an ECN section is received from the peer.<a href="#section-b.7-1" class="pilcrow">¶</a></p>
<div class="artwork art-text alignLeft" id="section-b.7-2">
<pre>
   ProcessECN(ack, pn_space):
     // If the ECN-CE counter reported by the peer has increased,
     // this could be a new congestion event.
     if (ack.ce_counter &gt; ecn_ce_counters[pn_space]):
       ecn_ce_counters[pn_space] = ack.ce_counter
       CongestionEvent(sent_packets[ack.largest_acked].time_sent)
</pre><a href="#section-b.7-2" class="pilcrow">¶</a>
</div>
</section>
</div>
<div id="on-packets-lost">
<section id="section-b.8">
        <h2 id="name-on-packets-lost">
<a href="#section-b.8" class="section-number selfRef">B.8. </a><a href="#name-on-packets-lost" class="section-name selfRef">On Packets Lost</a>
        </h2>
<p id="section-b.8-1">Invoked from DetectLostPackets when packets are deemed lost.<a href="#section-b.8-1" class="pilcrow">¶</a></p>
<div class="artwork art-text alignLeft" id="section-b.8-2">
<pre>
   InPersistentCongestion(largest_lost_packet):
     pto = smoothed_rtt + max(4 * rttvar, kGranularity) +
       max_ack_delay
     congestion_period = pto * kPersistentCongestionThreshold
     // Determine if all packets in the time period before the
     // newest lost packet, including the edges, are marked
     // lost
     return AreAllPacketsLost(largest_lost_packet,
                              congestion_period)

   OnPacketsLost(lost_packets):
     // Remove lost packets from bytes_in_flight.
     for (lost_packet : lost_packets):
       bytes_in_flight -= lost_packet.size
     largest_lost_packet = lost_packets.last()
     CongestionEvent(largest_lost_packet.time_sent)

     // Collapse congestion window if persistent congestion
     if (InPersistentCongestion(largest_lost_packet)):
       congestion_window = kMinimumWindow
</pre><a href="#section-b.8-2" class="pilcrow">¶</a>
</div>
</section>
</div>
</section>
</div>
<div id="change-log">
<section id="section-appendix.c">
      <h2 id="name-change-log">
<a href="#section-appendix.c" class="section-number selfRef">Appendix C. </a><a href="#name-change-log" class="section-name selfRef">Change Log</a>
      </h2>
<ul class="ulEmpty">
<li class="ulEmpty" id="section-appendix.c-1.1">
          <strong>RFC Editor's Note:</strong>  Please remove this section prior to
publication of a final version of this document.<a href="#section-appendix.c-1.1" class="pilcrow">¶</a>
</li>
</ul>
<p id="section-appendix.c-2">Issue and pull request numbers are listed with a leading octothorp.<a href="#section-appendix.c-2" class="pilcrow">¶</a></p>
<div id="since-draft-ietf-quic-recovery-24">
<section id="section-c.1">
        <h2 id="name-since-draft-ietf-quic-recov">
<a href="#section-c.1" class="section-number selfRef">C.1. </a><a href="#name-since-draft-ietf-quic-recov" class="section-name selfRef">Since draft-ietf-quic-recovery-24</a>
        </h2>
<ul>
<li id="section-c.1-1.1">Require congestion control of some sort (#3247, #3244, #3248)<a href="#section-c.1-1.1" class="pilcrow">¶</a>
</li>
<li id="section-c.1-1.2">Set a minimum reordering threshold (#3256, #3240)<a href="#section-c.1-1.2" class="pilcrow">¶</a>
</li>
<li id="section-c.1-1.3">PTO is specific to a packet number space (#3067, #3074, #3066)<a href="#section-c.1-1.3" class="pilcrow">¶</a>
</li>
</ul>
</section>
</div>
<div id="since-draft-ietf-quic-recovery-23">
<section id="section-c.2">
        <h2 id="name-since-draft-ietf-quic-recove">
<a href="#section-c.2" class="section-number selfRef">C.2. </a><a href="#name-since-draft-ietf-quic-recove" class="section-name selfRef">Since draft-ietf-quic-recovery-23</a>
        </h2>
<ul>
<li id="section-c.2-1.1">Define under-utilizing the congestion window (#2630, #2686, #2675)<a href="#section-c.2-1.1" class="pilcrow">¶</a>
</li>
<li id="section-c.2-1.2">PTO MUST send data if possible (#3056, #3057)<a href="#section-c.2-1.2" class="pilcrow">¶</a>
</li>
<li id="section-c.2-1.3">Connection Close is not ack-eliciting (#3097, #3098)<a href="#section-c.2-1.3" class="pilcrow">¶</a>
</li>
<li id="section-c.2-1.4">MUST limit bursts to the initial congestion window (#3160)<a href="#section-c.2-1.4" class="pilcrow">¶</a>
</li>
<li id="section-c.2-1.5">Define the current max_datagram_size for congestion control
(#3041, #3167)<a href="#section-c.2-1.5" class="pilcrow">¶</a>
</li>
</ul>
</section>
</div>
<div id="since-draft-ietf-quic-recovery-22">
<section id="section-c.3">
        <h2 id="name-since-draft-ietf-quic-recover">
<a href="#section-c.3" class="section-number selfRef">C.3. </a><a href="#name-since-draft-ietf-quic-recover" class="section-name selfRef">Since draft-ietf-quic-recovery-22</a>
        </h2>
<ul>
<li id="section-c.3-1.1">PTO should always send an ack-eliciting packet (#2895)<a href="#section-c.3-1.1" class="pilcrow">¶</a>
</li>
<li id="section-c.3-1.2">Unify the Handshake Timer with the PTO timer (#2648, #2658, #2886)<a href="#section-c.3-1.2" class="pilcrow">¶</a>
</li>
<li id="section-c.3-1.3">Move ACK generation text to transport draft (#1860, #2916)<a href="#section-c.3-1.3" class="pilcrow">¶</a>
</li>
</ul>
</section>
</div>
<div id="since-draft-ietf-quic-recovery-21">
<section id="section-c.4">
        <h2 id="name-since-draft-ietf-quic-recovery">
<a href="#section-c.4" class="section-number selfRef">C.4. </a><a href="#name-since-draft-ietf-quic-recovery" class="section-name selfRef">Since draft-ietf-quic-recovery-21</a>
        </h2>
<ul>
<li id="section-c.4-1.1">No changes<a href="#section-c.4-1.1" class="pilcrow">¶</a>
</li>
</ul>
</section>
</div>
<div id="since-draft-ietf-quic-recovery-20">
<section id="section-c.5">
        <h2 id="name-since-draft-ietf-quic-recovery-">
<a href="#section-c.5" class="section-number selfRef">C.5. </a><a href="#name-since-draft-ietf-quic-recovery-" class="section-name selfRef">Since draft-ietf-quic-recovery-20</a>
        </h2>
<ul>
<li id="section-c.5-1.1">Path validation can be used as initial RTT value (#2644, #2687)<a href="#section-c.5-1.1" class="pilcrow">¶</a>
</li>
<li id="section-c.5-1.2">max_ack_delay transport parameter defaults to 0 (#2638, #2646)<a href="#section-c.5-1.2" class="pilcrow">¶</a>
</li>
<li id="section-c.5-1.3">Ack Delay only measures intentional delays induced by the implementation
(#2596, #2786)<a href="#section-c.5-1.3" class="pilcrow">¶</a>
</li>
</ul>
</section>
</div>
<div id="since-draft-ietf-quic-recovery-19">
<section id="section-c.6">
        <h2 id="name-since-draft-ietf-quic-recovery-1">
<a href="#section-c.6" class="section-number selfRef">C.6. </a><a href="#name-since-draft-ietf-quic-recovery-1" class="section-name selfRef">Since draft-ietf-quic-recovery-19</a>
        </h2>
<ul>
<li id="section-c.6-1.1">Change kPersistentThreshold from an exponent to a multiplier (#2557)<a href="#section-c.6-1.1" class="pilcrow">¶</a>
</li>
<li id="section-c.6-1.2">Send a PING if the PTO timer fires and there's nothing to send (#2624)<a href="#section-c.6-1.2" class="pilcrow">¶</a>
</li>
<li id="section-c.6-1.3">Set loss delay to at least kGranularity (#2617)<a href="#section-c.6-1.3" class="pilcrow">¶</a>
</li>
<li id="section-c.6-1.4">Merge application limited and sending after idle sections. Always limit
burst size instead of requiring resetting CWND to initial CWND after
idle (#2605)<a href="#section-c.6-1.4" class="pilcrow">¶</a>
</li>
<li id="section-c.6-1.5">Rewrite RTT estimation, allow RTT samples where a newly acked packet is
ack-eliciting but the largest_acked is not (#2592)<a href="#section-c.6-1.5" class="pilcrow">¶</a>
</li>
<li id="section-c.6-1.6">Don't arm the handshake timer if there is no handshake data (#2590)<a href="#section-c.6-1.6" class="pilcrow">¶</a>
</li>
<li id="section-c.6-1.7">Clarify that the time threshold loss alarm takes precedence over the
crypto handshake timer (#2590, #2620)<a href="#section-c.6-1.7" class="pilcrow">¶</a>
</li>
<li id="section-c.6-1.8">Change initial RTT to 500ms to align with RFC6298 (#2184)<a href="#section-c.6-1.8" class="pilcrow">¶</a>
</li>
</ul>
</section>
</div>
<div id="since-draft-ietf-quic-recovery-18">
<section id="section-c.7">
        <h2 id="name-since-draft-ietf-quic-recovery-18">
<a href="#section-c.7" class="section-number selfRef">C.7. </a><a href="#name-since-draft-ietf-quic-recovery-18" class="section-name selfRef">Since draft-ietf-quic-recovery-18</a>
        </h2>
<ul>
<li id="section-c.7-1.1">Change IW byte limit to 14720 from 14600 (#2494)<a href="#section-c.7-1.1" class="pilcrow">¶</a>
</li>
<li id="section-c.7-1.2">Update PTO calculation to match RFC6298 (#2480, #2489, #2490)<a href="#section-c.7-1.2" class="pilcrow">¶</a>
</li>
<li id="section-c.7-1.3">Improve loss detection's description of multiple packet number spaces and
pseudocode (#2485, #2451, #2417)<a href="#section-c.7-1.3" class="pilcrow">¶</a>
</li>
<li id="section-c.7-1.4">Declare persistent congestion even if non-probe packets are sent and don't
make persistent congestion more aggressive than RTO verified was (#2365,
#2244)<a href="#section-c.7-1.4" class="pilcrow">¶</a>
</li>
<li id="section-c.7-1.5">Move pseudocode to the appendices (#2408)<a href="#section-c.7-1.5" class="pilcrow">¶</a>
</li>
<li id="section-c.7-1.6">What to send on multiple PTOs (#2380)<a href="#section-c.7-1.6" class="pilcrow">¶</a>
</li>
</ul>
</section>
</div>
<div id="since-draft-ietf-quic-recovery-17">
<section id="section-c.8">
        <h2 id="name-since-draft-ietf-quic-recovery-17">
<a href="#section-c.8" class="section-number selfRef">C.8. </a><a href="#name-since-draft-ietf-quic-recovery-17" class="section-name selfRef">Since draft-ietf-quic-recovery-17</a>
        </h2>
<ul>
<li id="section-c.8-1.1">After Probe Timeout discard in-flight packets or send another (#2212, #1965)<a href="#section-c.8-1.1" class="pilcrow">¶</a>
</li>
<li id="section-c.8-1.2">Endpoints discard initial keys as soon as handshake keys are available (#1951,
#2045)<a href="#section-c.8-1.2" class="pilcrow">¶</a>
</li>
<li id="section-c.8-1.3">0-RTT state is discarded when 0-RTT is rejected (#2300)<a href="#section-c.8-1.3" class="pilcrow">¶</a>
</li>
<li id="section-c.8-1.4">Loss detection timer is cancelled when ack-eliciting frames are in flight
(#2117, #2093)<a href="#section-c.8-1.4" class="pilcrow">¶</a>
</li>
<li id="section-c.8-1.5">Packets are declared lost if they are in flight (#2104)<a href="#section-c.8-1.5" class="pilcrow">¶</a>
</li>
<li id="section-c.8-1.6">After becoming idle, either pace packets or reset the congestion controller
(#2138, 2187)<a href="#section-c.8-1.6" class="pilcrow">¶</a>
</li>
<li id="section-c.8-1.7">Process ECN counts before marking packets lost (#2142)<a href="#section-c.8-1.7" class="pilcrow">¶</a>
</li>
<li id="section-c.8-1.8">Mark packets lost before resetting crypto_count and pto_count (#2208, #2209)<a href="#section-c.8-1.8" class="pilcrow">¶</a>
</li>
<li id="section-c.8-1.9">Congestion and loss recovery state are discarded when keys are discarded
(#2327)<a href="#section-c.8-1.9" class="pilcrow">¶</a>
</li>
</ul>
</section>
</div>
<div id="since-draft-ietf-quic-recovery-16">
<section id="section-c.9">
        <h2 id="name-since-draft-ietf-quic-recovery-16">
<a href="#section-c.9" class="section-number selfRef">C.9. </a><a href="#name-since-draft-ietf-quic-recovery-16" class="section-name selfRef">Since draft-ietf-quic-recovery-16</a>
        </h2>
<ul>
<li id="section-c.9-1.1">Unify TLP and RTO into a single PTO; eliminate min RTO, min TLP and min crypto
timeouts; eliminate timeout validation (#2114, #2166, #2168, #1017)<a href="#section-c.9-1.1" class="pilcrow">¶</a>
</li>
<li id="section-c.9-1.2">Redefine how congestion avoidance in terms of when the period starts (#1928,
#1930)<a href="#section-c.9-1.2" class="pilcrow">¶</a>
</li>
<li id="section-c.9-1.3">Document what needs to be tracked for packets that are in flight (#765, #1724,
#1939)<a href="#section-c.9-1.3" class="pilcrow">¶</a>
</li>
<li id="section-c.9-1.4">Integrate both time and packet thresholds into loss detection (#1969, #1212,
#934, #1974)<a href="#section-c.9-1.4" class="pilcrow">¶</a>
</li>
<li id="section-c.9-1.5">Reduce congestion window after idle, unless pacing is used (#2007, #2023)<a href="#section-c.9-1.5" class="pilcrow">¶</a>
</li>
<li id="section-c.9-1.6">Disable RTT calculation for packets that don't elicit acknowledgment (#2060,
#2078)<a href="#section-c.9-1.6" class="pilcrow">¶</a>
</li>
<li id="section-c.9-1.7">Limit ack_delay by max_ack_delay (#2060, #2099)<a href="#section-c.9-1.7" class="pilcrow">¶</a>
</li>
<li id="section-c.9-1.8">Initial keys are discarded once Handshake keys are available (#1951, #2045)<a href="#section-c.9-1.8" class="pilcrow">¶</a>
</li>
<li id="section-c.9-1.9">Reorder ECN and loss detection in pseudocode (#2142)<a href="#section-c.9-1.9" class="pilcrow">¶</a>
</li>
<li id="section-c.9-1.10">Only cancel loss detection timer if ack-eliciting packets are in flight
(#2093, #2117)<a href="#section-c.9-1.10" class="pilcrow">¶</a>
</li>
</ul>
</section>
</div>
<div id="since-draft-ietf-quic-recovery-14">
<section id="section-c.10">
        <h2 id="name-since-draft-ietf-quic-recovery-14">
<a href="#section-c.10" class="section-number selfRef">C.10. </a><a href="#name-since-draft-ietf-quic-recovery-14" class="section-name selfRef">Since draft-ietf-quic-recovery-14</a>
        </h2>
<ul>
<li id="section-c.10-1.1">Used max_ack_delay from transport params (#1796, #1782)<a href="#section-c.10-1.1" class="pilcrow">¶</a>
</li>
<li id="section-c.10-1.2">Merge ACK and ACK_ECN (#1783)<a href="#section-c.10-1.2" class="pilcrow">¶</a>
</li>
</ul>
</section>
</div>
<div id="since-draft-ietf-quic-recovery-13">
<section id="section-c.11">
        <h2 id="name-since-draft-ietf-quic-recovery-13">
<a href="#section-c.11" class="section-number selfRef">C.11. </a><a href="#name-since-draft-ietf-quic-recovery-13" class="section-name selfRef">Since draft-ietf-quic-recovery-13</a>
        </h2>
<ul>
<li id="section-c.11-1.1">Corrected the lack of ssthresh reduction in CongestionEvent pseudocode (#1598)<a href="#section-c.11-1.1" class="pilcrow">¶</a>
</li>
<li id="section-c.11-1.2">Considerations for ECN spoofing (#1426, #1626)<a href="#section-c.11-1.2" class="pilcrow">¶</a>
</li>
<li id="section-c.11-1.3">Clarifications for PADDING and congestion control (#837, #838, #1517, #1531,
#1540)<a href="#section-c.11-1.3" class="pilcrow">¶</a>
</li>
<li id="section-c.11-1.4">Reduce early retransmission timer to RTT/8 (#945, #1581)<a href="#section-c.11-1.4" class="pilcrow">¶</a>
</li>
<li id="section-c.11-1.5">Packets are declared lost after an RTO is verified (#935, #1582)<a href="#section-c.11-1.5" class="pilcrow">¶</a>
</li>
</ul>
</section>
</div>
<div id="since-draft-ietf-quic-recovery-12">
<section id="section-c.12">
        <h2 id="name-since-draft-ietf-quic-recovery-12">
<a href="#section-c.12" class="section-number selfRef">C.12. </a><a href="#name-since-draft-ietf-quic-recovery-12" class="section-name selfRef">Since draft-ietf-quic-recovery-12</a>
        </h2>
<ul>
<li id="section-c.12-1.1">Changes to manage separate packet number spaces and encryption levels (#1190,
#1242, #1413, #1450)<a href="#section-c.12-1.1" class="pilcrow">¶</a>
</li>
<li id="section-c.12-1.2">Added ECN feedback mechanisms and handling; new ACK_ECN frame (#804, #805,
#1372)<a href="#section-c.12-1.2" class="pilcrow">¶</a>
</li>
</ul>
</section>
</div>
<div id="since-draft-ietf-quic-recovery-11">
<section id="section-c.13">
        <h2 id="name-since-draft-ietf-quic-recovery-11">
<a href="#section-c.13" class="section-number selfRef">C.13. </a><a href="#name-since-draft-ietf-quic-recovery-11" class="section-name selfRef">Since draft-ietf-quic-recovery-11</a>
        </h2>
<p id="section-c.13-1">No significant changes.<a href="#section-c.13-1" class="pilcrow">¶</a></p>
</section>
</div>
<div id="since-draft-ietf-quic-recovery-10">
<section id="section-c.14">
        <h2 id="name-since-draft-ietf-quic-recovery-10">
<a href="#section-c.14" class="section-number selfRef">C.14. </a><a href="#name-since-draft-ietf-quic-recovery-10" class="section-name selfRef">Since draft-ietf-quic-recovery-10</a>
        </h2>
<ul>
<li id="section-c.14-1.1">Improved text on ack generation (#1139, #1159)<a href="#section-c.14-1.1" class="pilcrow">¶</a>
</li>
<li id="section-c.14-1.2">Make references to TCP recovery mechanisms informational (#1195)<a href="#section-c.14-1.2" class="pilcrow">¶</a>
</li>
<li id="section-c.14-1.3">Define time_of_last_sent_handshake_packet (#1171)<a href="#section-c.14-1.3" class="pilcrow">¶</a>
</li>
<li id="section-c.14-1.4">Added signal from TLS the data it includes needs to be sent in a Retry packet
(#1061, #1199)<a href="#section-c.14-1.4" class="pilcrow">¶</a>
</li>
<li id="section-c.14-1.5">Minimum RTT (min_rtt) is initialized with an infinite value (#1169)<a href="#section-c.14-1.5" class="pilcrow">¶</a>
</li>
</ul>
</section>
</div>
<div id="since-draft-ietf-quic-recovery-09">
<section id="section-c.15">
        <h2 id="name-since-draft-ietf-quic-recovery-0">
<a href="#section-c.15" class="section-number selfRef">C.15. </a><a href="#name-since-draft-ietf-quic-recovery-0" class="section-name selfRef">Since draft-ietf-quic-recovery-09</a>
        </h2>
<p id="section-c.15-1">No significant changes.<a href="#section-c.15-1" class="pilcrow">¶</a></p>
</section>
</div>
<div id="since-draft-ietf-quic-recovery-08">
<section id="section-c.16">
        <h2 id="name-since-draft-ietf-quic-recovery-08">
<a href="#section-c.16" class="section-number selfRef">C.16. </a><a href="#name-since-draft-ietf-quic-recovery-08" class="section-name selfRef">Since draft-ietf-quic-recovery-08</a>
        </h2>
<ul>
<li id="section-c.16-1.1">Clarified pacing and RTO (#967, #977)<a href="#section-c.16-1.1" class="pilcrow">¶</a>
</li>
</ul>
</section>
</div>
<div id="since-draft-ietf-quic-recovery-07">
<section id="section-c.17">
        <h2 id="name-since-draft-ietf-quic-recovery-07">
<a href="#section-c.17" class="section-number selfRef">C.17. </a><a href="#name-since-draft-ietf-quic-recovery-07" class="section-name selfRef">Since draft-ietf-quic-recovery-07</a>
        </h2>
<ul>
<li id="section-c.17-1.1">Include Ack Delay in RTO(and TLP) computations (#981)<a href="#section-c.17-1.1" class="pilcrow">¶</a>
</li>
<li id="section-c.17-1.2">Ack Delay in SRTT computation (#961)<a href="#section-c.17-1.2" class="pilcrow">¶</a>
</li>
<li id="section-c.17-1.3">Default RTT and Slow Start (#590)<a href="#section-c.17-1.3" class="pilcrow">¶</a>
</li>
<li id="section-c.17-1.4">Many editorial fixes.<a href="#section-c.17-1.4" class="pilcrow">¶</a>
</li>
</ul>
</section>
</div>
<div id="since-draft-ietf-quic-recovery-06">
<section id="section-c.18">
        <h2 id="name-since-draft-ietf-quic-recovery-06">
<a href="#section-c.18" class="section-number selfRef">C.18. </a><a href="#name-since-draft-ietf-quic-recovery-06" class="section-name selfRef">Since draft-ietf-quic-recovery-06</a>
        </h2>
<p id="section-c.18-1">No significant changes.<a href="#section-c.18-1" class="pilcrow">¶</a></p>
</section>
</div>
<div id="since-draft-ietf-quic-recovery-05">
<section id="section-c.19">
        <h2 id="name-since-draft-ietf-quic-recovery-05">
<a href="#section-c.19" class="section-number selfRef">C.19. </a><a href="#name-since-draft-ietf-quic-recovery-05" class="section-name selfRef">Since draft-ietf-quic-recovery-05</a>
        </h2>
<ul>
<li id="section-c.19-1.1">Add more congestion control text (#776)<a href="#section-c.19-1.1" class="pilcrow">¶</a>
</li>
</ul>
</section>
</div>
<div id="since-draft-ietf-quic-recovery-04">
<section id="section-c.20">
        <h2 id="name-since-draft-ietf-quic-recovery-04">
<a href="#section-c.20" class="section-number selfRef">C.20. </a><a href="#name-since-draft-ietf-quic-recovery-04" class="section-name selfRef">Since draft-ietf-quic-recovery-04</a>
        </h2>
<p id="section-c.20-1">No significant changes.<a href="#section-c.20-1" class="pilcrow">¶</a></p>
</section>
</div>
<div id="since-draft-ietf-quic-recovery-03">
<section id="section-c.21">
        <h2 id="name-since-draft-ietf-quic-recovery-03">
<a href="#section-c.21" class="section-number selfRef">C.21. </a><a href="#name-since-draft-ietf-quic-recovery-03" class="section-name selfRef">Since draft-ietf-quic-recovery-03</a>
        </h2>
<p id="section-c.21-1">No significant changes.<a href="#section-c.21-1" class="pilcrow">¶</a></p>
</section>
</div>
<div id="since-draft-ietf-quic-recovery-02">
<section id="section-c.22">
        <h2 id="name-since-draft-ietf-quic-recovery-02">
<a href="#section-c.22" class="section-number selfRef">C.22. </a><a href="#name-since-draft-ietf-quic-recovery-02" class="section-name selfRef">Since draft-ietf-quic-recovery-02</a>
        </h2>
<ul>
<li id="section-c.22-1.1">Integrate F-RTO (#544, #409)<a href="#section-c.22-1.1" class="pilcrow">¶</a>
</li>
<li id="section-c.22-1.2">Add congestion control (#545, #395)<a href="#section-c.22-1.2" class="pilcrow">¶</a>
</li>
<li id="section-c.22-1.3">Require connection abort if a skipped packet was acknowledged (#415)<a href="#section-c.22-1.3" class="pilcrow">¶</a>
</li>
<li id="section-c.22-1.4">Simplify RTO calculations (#142, #417)<a href="#section-c.22-1.4" class="pilcrow">¶</a>
</li>
</ul>
</section>
</div>
<div id="since-draft-ietf-quic-recovery-01">
<section id="section-c.23">
        <h2 id="name-since-draft-ietf-quic-recovery-01">
<a href="#section-c.23" class="section-number selfRef">C.23. </a><a href="#name-since-draft-ietf-quic-recovery-01" class="section-name selfRef">Since draft-ietf-quic-recovery-01</a>
        </h2>
<ul>
<li id="section-c.23-1.1">Overview added to loss detection<a href="#section-c.23-1.1" class="pilcrow">¶</a>
</li>
<li id="section-c.23-1.2">Changes initial default RTT to 100ms<a href="#section-c.23-1.2" class="pilcrow">¶</a>
</li>
<li id="section-c.23-1.3">Added time-based loss detection and fixes early retransmit<a href="#section-c.23-1.3" class="pilcrow">¶</a>
</li>
<li id="section-c.23-1.4">Clarified loss recovery for handshake packets<a href="#section-c.23-1.4" class="pilcrow">¶</a>
</li>
<li id="section-c.23-1.5">Fixed references and made TCP references informative<a href="#section-c.23-1.5" class="pilcrow">¶</a>
</li>
</ul>
</section>
</div>
<div id="since-draft-ietf-quic-recovery-00">
<section id="section-c.24">
        <h2 id="name-since-draft-ietf-quic-recovery-00">
<a href="#section-c.24" class="section-number selfRef">C.24. </a><a href="#name-since-draft-ietf-quic-recovery-00" class="section-name selfRef">Since draft-ietf-quic-recovery-00</a>
        </h2>
<ul>
<li id="section-c.24-1.1">Improved description of constants and ACK behavior<a href="#section-c.24-1.1" class="pilcrow">¶</a>
</li>
</ul>
</section>
</div>
<div id="since-draft-iyengar-quic-loss-recovery-01">
<section id="section-c.25">
        <h2 id="name-since-draft-iyengar-quic-lo">
<a href="#section-c.25" class="section-number selfRef">C.25. </a><a href="#name-since-draft-iyengar-quic-lo" class="section-name selfRef">Since draft-iyengar-quic-loss-recovery-01</a>
        </h2>
<ul>
<li id="section-c.25-1.1">Adopted as base for draft-ietf-quic-recovery<a href="#section-c.25-1.1" class="pilcrow">¶</a>
</li>
<li id="section-c.25-1.2">Updated authors/editors list<a href="#section-c.25-1.2" class="pilcrow">¶</a>
</li>
<li id="section-c.25-1.3">Added table of contents<a href="#section-c.25-1.3" class="pilcrow">¶</a>
</li>
</ul>
</section>
</div>
</section>
</div>
<div id="contributors">
<section id="section-appendix.d">
      <h2 id="name-contributors">
<a href="#section-appendix.d" class="section-number selfRef">Appendix D. </a><a href="#name-contributors" class="section-name selfRef">Contributors</a>
      </h2>
<p id="section-appendix.d-1">The IETF QUIC Working Group received an enormous amount of support from many
people. The following people provided substantive contributions to this
document:
Alessandro Ghedini,
Benjamin Saunders,
Gorry Fairhurst, <span class="contact-name"><span class="non-ascii">奥 一穂</span> (<span class="ascii">Kazuho Oku</span>)</span>,
Lars Eggert,
Magnus Westerlund,
Marten Seemann,
Martin Duke,
Martin Thomson,
Nick Banks,
Praveen Balasubramaniam.<a href="#section-appendix.d-1" class="pilcrow">¶</a></p>
</section>
</div>
<div id="acknowledgments">
<section id="section-appendix.e">
      <h2 id="name-acknowledgments">
<a href="#name-acknowledgments" class="section-name selfRef">Acknowledgments</a>
    </h2>
</section>
</div>
<div id="authors-addresses">
<section id="section-appendix.f">
      <h2 id="name-authors-addresses">
<a href="#name-authors-addresses" class="section-name selfRef">Authors' Addresses</a>
      </h2>
<address class="vcard">
        <div dir="auto" class="left"><span class="fn nameRole">Jana Iyengar (<span class="role">editor</span>)</span></div>
<div dir="auto" class="left"><span class="org">Fastly</span></div>
<div class="email">
<span>Email:</span>
<a href="mailto:jri.ietf@gmail.com" class="email">jri.ietf@gmail.com</a>
</div>
</address>
<address class="vcard">
        <div dir="auto" class="left"><span class="fn nameRole">Ian Swett (<span class="role">editor</span>)</span></div>
<div dir="auto" class="left"><span class="org">Google</span></div>
<div class="email">
<span>Email:</span>
<a href="mailto:ianswett@google.com" class="email">ianswett@google.com</a>
</div>
</address>
</section>
</div>
<script>var toc = document.getElementById("toc");
var tocToggle = toc.querySelector("h2");
var tocNav = toc.querySelector("nav");

// mobile menu toggle
tocToggle.onclick = function(event) {
    if (window.innerWidth < 1024) {
 var tocNavDisplay = tocNav.currentStyle ? tocNav.currentStyle.display : getComputedStyle(tocNav, null).display;
 if (tocNavDisplay == "none") {
     tocNav.style.display = "block";
 } else {
     tocNav.style.display = "none";
 }
    }
}

// toc anchor scroll to anchor
tocNav.addEventListener("click", function (event) {
    event.preventDefault();
    if (event.target.nodeName == 'A') {
 if (window.innerWidth < 1024) {
     tocNav.style.display = "none";
 }
 var href = event.target.getAttribute("href");
 var anchorId = href.substr(1);
 var anchor =  document.getElementById(anchorId);
 anchor.scrollIntoView(true);
 window.history.pushState("","",href);
    }
});

// switch toc mode when window resized
window.onresize = function () {
    if (window.innerWidth < 1024) {
 tocNav.style.display = "none";
    } else {
 tocNav.style.display = "block";
    }
}
</script>
</body>
</html>
