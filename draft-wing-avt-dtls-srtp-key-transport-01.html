<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="en"><head><title>Datagram TLS Secure RTP
    (DTLS-SRTP) Key Transport</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="description" content="Datagram TLS Secure RTP
    (DTLS-SRTP) Key Transport">
<meta name="generator" content="xml2rfc v1.35 (http://xml.resource.org/)">
<meta name="viewport" content="width=600;" />
<style type='text/css'><!--
        body {
                font-family: verdana, charcoal, helvetica, arial, sans-serif;
                font-size: 85%;
		max-width: 40em; 
		color: #000; background-color: #FFF;
                margin: 2em;
        }
        h1, h2, h3, h4, h5, h6 {
                font-family: helvetica, monaco, "MS Sans Serif", arial, sans-serif;
                font-weight: bold; font-style: normal;
        }
        h1 { color: #900; background-color: transparent; text-align: right; }
        h3 { color: #333; background-color: transparent; }

        td.RFCbug {
                font-size: x-small; text-decoration: none;
                width: 30px; height: 30px; padding-top: 2px;
                text-align: justify; vertical-align: middle;
                background-color: #000;
        }
        td.RFCbug span.RFC {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: bold; color: #666;
        }
        td.RFCbug span.hotText {
                font-family: charcoal, monaco, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: normal; text-align: center; color: #FFF;
        }

        table.TOCbug { width: 30px; height: 15px; }
        td.TOCbug {
                text-align: center; width: 30px; height: 15px;
                color: #FFF; background-color: #900;
        }
        td.TOCbug a {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, sans-serif;
                font-weight: bold; font-size: x-small; text-decoration: none;
                color: #FFF; background-color: transparent;
        }

        td.header {
                font-family: arial, helvetica, sans-serif; font-size: x-small;
                vertical-align: top; width: 33%;
                color: #FFF; background-color: #666;
        }
        td.author { font-weight: bold; font-size: x-small; margin-left: 4em; }
        td.author-text { font-size: x-small; }

        /* info code from SantaKlauss at http://www.madaboutstyle.com/tooltip2.html */
        a.info {
                /* This is the key. */
                position: relative;
                z-index: 24;
                text-decoration: none;
        }
        a.info:hover {
                z-index: 25;
                color: #FFF; background-color: #900;
        }
        a.info span { display: none; }
        a.info:hover span.info {
                /* The span will display just on :hover state. */
                display: block;
                position: absolute;
                font-size: smaller;
                top: 2em; left: -5em; width: 15em;
                padding: 2px; border: 1px solid #333;
                color: #900; background-color: #EEE;
                text-align: left;
        }

        a { font-weight: bold; }
        a:link    { color: #900; background-color: transparent; }
        a:visited { color: #633; background-color: transparent; }
        a:active  { color: #633; background-color: transparent; }

        p { margin-left: 2em; margin-right: 2em; }
        p.copyright { font-size: x-small; }
        p.toc { font-size: 85%;
		max-width: 40em; 
		font-weight: bold; margin-left: 3em; }
        table.toc { margin: 0 0 0 3em; padding: 0; border: 0; vertical-align: text-top; }
        td.toc { font-size: 85%;
		max-width: 40em; 
		font-weight: bold; vertical-align: text-top; }

        ol.text { margin-left: 2em; margin-right: 2em; }
        ul.text { margin-left: 2em; margin-right: 2em; }
        li      { margin-left: 3em; }

        /* RFC-2629 <spanx>s and <artwork>s. */
        em     { font-style: italic; }
        strong { font-weight: bold; }
        dfn    { font-weight: bold; font-style: normal; }
        cite   { font-weight: normal; font-style: normal; }
        tt     { color: #036; }
        tt, pre, pre dfn, pre em, pre cite, pre span {
                font-family: "Courier New", Courier, monospace; font-size: small;
        }
        pre {
                text-align: left; padding: 4px;
                color: #000; background-color: #CCC;
        }
        pre dfn  { color: #900; }
        pre em   { color: #66F; background-color: #FFC; font-weight: normal; }
        pre .key { color: #33C; font-weight: bold; }
        pre .id  { color: #900; }
        pre .str { color: #000; background-color: #CFF; }
        pre .val { color: #066; }
        pre .rep { color: #909; }
        pre .oth { color: #000; background-color: #FCF; }
        pre .err { background-color: #FCC; }

        /* RFC-2629 <texttable>s. */
        table.all, table.full, table.headers, table.none {
                font-size: 85%;
		max-width: 40em; 
		text-align: center; border-width: 2px;
                vertical-align: top; border-collapse: collapse;
        }
        table.all, table.full { border-style: solid; border-color: black; }
        table.headers, table.none { border-style: none; }
        th {
                font-weight: bold; border-color: black;
                border-width: 2px 2px 3px 2px;
        }
        table.all th, table.full th { border-style: solid; }
        table.headers th { border-style: none none solid none; }
        table.none th { border-style: none; }
        table.all td {
                border-style: solid; border-color: #333;
                border-width: 1px 2px;
        }
        table.full td, table.headers td, table.none td { border-style: none; }

        hr { height: 1px; }
        hr.insert {
                width: 80%; border-style: none; border-width: 0;
                color: #CCC; background-color: #CCC;
        }
--></style>
</head>
<body>
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<table summary="layout" width="66%" border="0" cellpadding="0" cellspacing="0"><tr><td><table summary="layout" width="100%" border="0" cellpadding="2" cellspacing="1">
<tr><td class="header">AVT Working Group</td><td class="header">D. Wing</td></tr>
<tr><td class="header">Internet-Draft</td><td class="header">Cisco Systems</td></tr>
<tr><td class="header">Intended status:  Standards Track</td><td class="header">February 16, 2008</td></tr>
<tr><td class="header">Expires:  August 19, 2008</td><td class="header">&nbsp;</td></tr>
</table></td></tr></table>
<h1><br />Datagram TLS Secure RTP
    (DTLS-SRTP) Key Transport<br />draft-wing-avt-dtls-srtp-key-transport-01</h1>

<h3>Status of this Memo</h3>
<p>
By submitting this Internet-Draft,
each author represents that any applicable patent or other IPR claims of which
he or she is aware have been or will be disclosed,
and any of which he or she becomes aware will be disclosed,
in accordance with Section&nbsp;6 of BCP&nbsp;79.</p>
<p>
Internet-Drafts are working documents of the Internet Engineering
Task Force (IETF), its areas, and its working groups.
Note that other groups may also distribute working documents as
Internet-Drafts.</p>
<p>
Internet-Drafts are draft documents valid for a maximum of six months
and may be updated, replaced, or obsoleted by other documents at any time.
It is inappropriate to use Internet-Drafts as reference material or to cite
them other than as &ldquo;work in progress.&rdquo;</p>
<p>
The list of current Internet-Drafts can be accessed at
<a href='http://www.ietf.org/ietf/1id-abstracts.txt'>http://www.ietf.org/ietf/1id-abstracts.txt</a>.</p>
<p>
The list of Internet-Draft Shadow Directories can be accessed at
<a href='http://www.ietf.org/shadow.html'>http://www.ietf.org/shadow.html</a>.</p>
<p>
This Internet-Draft will expire on August 19, 2008.</p>

<h3>Abstract</h3>

<p>The existing DTLS-SRTP specification allows SRTP keys to be
      established between a pair of SRTP endpoints. However, when there are
      more than two participants in an RTP session, DTLS-SRTP is unable to
      provide a single key for all of the participants. This existing
      limitation of DTLS-SRTP prevents deploying DTLS-SRTP in certain
      scenarios.
</p>
<p>This document describes an extension to DTLS-SRTP which transports
      SRTP keying material from one DTLS-SRTP peer to another, so the same
      SRTP keying material can be used by multiple DTLS-SRTP peers. This
      extension reduces (and often eliminates) the need to key each SRTP
      session individually, allowing deployment of several DTLS-SRTP
      scenarios.
</p><a name="toc"></a><br /><hr />
<h3>Table of Contents</h3>
<p class="toc">
<a href="#anchor1">1.</a>&nbsp;
Introduction<br />
<a href="#anchor2">2.</a>&nbsp;
Notational Conventions<br />
<a href="#sec_scenarios">3.</a>&nbsp;
Scenarios<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section_point_multipoint">3.1.</a>&nbsp;
Point to Multipoint using the RFC 3550 mixer model<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor3">3.2.</a>&nbsp;
Point to Multipoint using Multicast<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor4">3.3.</a>&nbsp;
Point to Multipoint Using Video Switching MCUs<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor5">3.4.</a>&nbsp;
Voicemail Storage and Retrieval<br />
<a href="#sec_protocol_description">4.</a>&nbsp;
Protocol Description<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor6">4.1.</a>&nbsp;
key_transport extension<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor7">4.2.</a>&nbsp;
SRTP Key Transport Protocol<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor8">4.3.</a>&nbsp;
Key Transport SSRC and RTP SSRC Collisions<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor9">4.4.</a>&nbsp;
Fragmentation, Reassembly, and Retransmission<br />
<a href="#anchor10">5.</a>&nbsp;
Examples<br />
<a href="#security_considerations">6.</a>&nbsp;
Security Considerations<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec-group-policy">6.1.</a>&nbsp;
Group Policy when Joining/Leaving<br />
<a href="#anchor11">7.</a>&nbsp;
Acknowledgements<br />
<a href="#anchor12">8.</a>&nbsp;
IANA Considerations<br />
<a href="#rfc.references1">9.</a>&nbsp;
References<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#rfc.references1">9.1.</a>&nbsp;
Normative References<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#rfc.references2">9.2.</a>&nbsp;
Informational References<br />
<a href="#anchor15">Appendix&nbsp;A.</a>&nbsp;
Changes<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor16">A.1.</a>&nbsp;
Changes from -00 to -01<br />
<a href="#rfc.authors">&#167;</a>&nbsp;
Author's Address<br />
<a href="#rfc.copyright">&#167;</a>&nbsp;
Intellectual Property and Copyright Statements<br />
</p>
<br clear="all" />

<a name="anchor1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1"></a><h3>1.&nbsp;
Introduction</h3>

<p>Unique SRTP master keys can be established, in each direction, using
      <a class='info' href='#I-D.ietf-avt-dtls-srtp'>DTLS-SRTP<span> (</span><span class='info'>McGrew, D. and E. Rescorla, &ldquo;Datagram Transport Layer Security (DTLS) Extension to Establish Keys for Secure Real-time Transport Protocol (SRTP),&rdquo; February&nbsp;2009.</span><span>)</span></a> [I&#8209;D.ietf&#8209;avt&#8209;dtls&#8209;srtp]. Using DTLS, each
      peer contributes part of the keying material to generate the eventual
      SRTP master key.
</p>
<p>In some scenarios after the DTLS handshake has completed, it is
      desirable for one peer to change its SRTP key and to transmit SRTP
      packets using an SRTP key that was not derived from the DTLS key
      exchange. These scenarios are described in <a class='info' href='#sec_scenarios'>Section&nbsp;3<span> (</span><span class='info'>Scenarios</span><span>)</span></a>.
</p>
<p>The extensions described in this document allow transporting an SRTP
      master key from one DTLS peer to the other. Thus, DTLS Key Transport
      differs from normal DTLS-SRTP in that the SRTP master key is not derived
      from the TLS handshake.
</p>
<a name="anchor2"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2"></a><h3>2.&nbsp;
Notational Conventions</h3>

<p>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
      "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
      document are to be interpreted as described in <a class='info' href='#RFC2119'>[RFC2119]<span> (</span><span class='info'>Bradner, S., &ldquo;Key words for use in RFCs to Indicate Requirement Levels,&rdquo; March&nbsp;1997.</span><span>)</span></a>.
</p>
<a name="sec_scenarios"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3"></a><h3>3.&nbsp;
Scenarios</h3>

<p>DTLS Key Transport allows mixers and video switchers to avoid having
      to encrypt each packet multiple times under multiple SRTP keys. DTLS Key
      Transport causes sharing of SRTP keys.
</p>
<p>Several SRTP scenarios that benefit from DTLS-SRTP Key Transport are
      described in the following sections, using terminology from <a class='info' href='#RFC5117'>RTP Topologies<span> (</span><span class='info'>Westerlund, M. and S. Wenger, &ldquo;RTP Topologies,&rdquo; January&nbsp;2008.</span><span>)</span></a> [RFC5117].
</p>
<a name="section_point_multipoint"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.1"></a><h3>3.1.&nbsp;
Point to Multipoint using the RFC 3550 mixer model</h3>

<p>This RTP scenario is described in Section 3.4 of <a class='info' href='#RFC5117'>RTP Topologies<span> (</span><span class='info'>Westerlund, M. and S. Wenger, &ldquo;RTP Topologies,&rdquo; January&nbsp;2008.</span><span>)</span></a> [RFC5117].
</p>
<p>With DTLS-SRTP, this topology is computationally expensive for the
        video switcher because it has to encrypt the payload uniquely for each
        SRTP listener. Additionally, the architecture of a typical mixer
        requires each listener's SRTP to be encrypted serially, incurring
        additional delay for each successive listener. This is depicted below
        in <a class='info' href='#multipoint-without-kt'>Figure&nbsp;1<span> (</span><span class='info'>Point to Multipoint Mixer, without DTLS Key Transport</span><span>)</span></a>.
</p><br /><hr class="insert" />
<a name="multipoint-without-kt"></a>

<p>
</p><div style='display: table; width: 0; margin-left: auto; margin-right: auto'><pre>     +-------key=F-------+
     |                   |
     V               +-------+         +------------+
+----+----+          |       +--key=C-&gt;+ listener 1 |
| speaker +--key=A--&gt;+       |         +------------+
+---------+          |       |         +------------+
                     | mixer +--key=D-&gt;+ listener 2 |
+---------+          |       |         +------------+
| speaker +--key=B--&gt;+       |         +------------+
+----+----+          |       +--key=E-&gt;+ listener 3 |
     ^               +---+---+         +------------+
     |                   |
     +-------key=G-------+
</pre></div>
<p>
</p><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;1: Point to Multipoint Mixer, without DTLS Key Transport&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>With DTLS Key Transport, the mixer can maintain one outbound SRTP
        cryptographic context, and encrypt the SRTP once for all listeners.
        This is depicted below in <a class='info' href='#multipoint-with-kt'>Figure&nbsp;2<span> (</span><span class='info'>Point to Multipoint Mixer, with DTLS Key Transport</span><span>)</span></a>.
</p><br /><hr class="insert" />
<a name="multipoint-with-kt"></a>

<p>In the following figure, "=" indicates sessions where
          DTLS-SRTP Key Transport is used, and "-" indicates where only
          DTLS-SRTP is necessary. In this topology, only the listeners need
          support DTLS-SRTP Key Transport so that the switcher and the
          listeners can benefit from DTLS-SRTP Key Transport. In this scenario
          with DTLS-SRTP Key Transport, the mixer assumes an additional role
          -- group's key server -- and provides a common group SRTP key ("C")
          to all of the listeners. This group SRTP key is shared between all
          of the listeners.
</p><div style='display: table; width: 0; margin-left: auto; margin-right: auto'><pre>
     +=======key=C=======+
     |                   |
     V               +---+---+         +------------+
+---------+          |       +==key=C=&gt;+ listener 1 |
| speaker +--key=A--&gt;+       |         +------------+
+---------+          |       |         +------------+
                     | mixer +==key=C=&gt;+ listener 2 |
+---------+          |       |         +------------+
| speaker +--key=B--&gt;+       |         +------------+
+----+----+          |       +==key=C=&gt;+ listener 3 |
     ^               +---+---+         +------------+
     |                   |
     +=======key=C=======+
</pre></div>
<p>
</p><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;2: Point to Multipoint Mixer, with DTLS Key Transport&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>The mixer is aware of listeners leaving or joining, and the mixer
        can rekey the remaining active listeners.
</p>
<a name="anchor3"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.2"></a><h3>3.2.&nbsp;
Point to Multipoint using Multicast</h3>

<p>This RTP topology is described in Section 3.2 of <a class='info' href='#RFC5117'>RTP Topologies<span> (</span><span class='info'>Westerlund, M. and S. Wenger, &ldquo;RTP Topologies,&rdquo; January&nbsp;2008.</span><span>)</span></a> [RFC5117].
</p>
<p>With DTLS-SRTP, this scenario is not attainable because each
        listener has a unique SRTP key. For this reason, <a class='info' href='#I-D.ietf-msec-gdoi-srtp'>[I&#8209;D.ietf&#8209;msec&#8209;gdoi&#8209;srtp]<span> (</span><span class='info'>Baugher, M., Rueegsegger, A., and S. Rowles, &ldquo;GDOI Key Establishment for the SRTP Data Security Protocol,&rdquo; December&nbsp;2007.</span><span>)</span></a> was developed by the MSEC
        working group.
</p>
<p>With DTLS-SRTP Key Transport, this scenario is attainable because the
        same key can be provided to multiple listeners, as depicted below
        in <a class='info' href='#multipoint-multicast-with-kt'>Figure&nbsp;3<span> (</span><span class='info'>Point to Multipoint using Multicast with Key Transport</span><span>)</span></a>. This compares
        favorably with <a class='info' href='#I-D.ietf-msec-gdoi-srtp'>[I&#8209;D.ietf&#8209;msec&#8209;gdoi&#8209;srtp]<span> (</span><span class='info'>Baugher, M., Rueegsegger, A., and S. Rowles, &ldquo;GDOI Key Establishment for the SRTP Data Security Protocol,&rdquo; December&nbsp;2007.</span><span>)</span></a> when the
        group size is small enough that the speaker can perform key server
        functions (i.e., perform DTLS-SRTP Key Transport) for all of the
        listeners. 
</p><br /><hr class="insert" />
<a name="multipoint-multicast-with-kt"></a>

<p>
</p><div style='display: table; width: 0; margin-left: auto; margin-right: auto'><pre>                        +-------+            +------------+
                       /         \==key=A===&gt;+ listener 1 |
                      /           \          +------------+
+---------+           | multicast |          +------------+
| speaker +==key=A===&gt;+  network  +==key=A==&gt;+ listener 2 |
+---------+           |           |          +------------+
                      \           /          +------------+
                       \         /===key=A==&gt;+ listener 3 |
                        +-------+            +------------+</pre></div>
<p>
</p><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;3: Point to Multipoint using Multicast with Key Transport&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p></p>
<blockquote class="text">
<p>[[For future study: could we express, in SDP, alternate DTLS-SRTP
            key servers to support large groups for this scenario, so that the
            speaker can be offloaded from DTLS-SRTP Key Transport duties?  That alternate key server would need authorize new participants.  This seems to begin stepping into GDOI territory, but how does a DTLS-SRTP endpoint know when it will join a large group and need GDOI code inside the DTLS-SRTP endpoint?  Ideally we would want to split the effort and protocols so that endpoint needs *no* additional code with really large groups.]]
</p>
</blockquote>

<a name="anchor4"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.3"></a><h3>3.3.&nbsp;
Point to Multipoint Using Video Switching MCUs</h3>

<p>This RTP topology is described in Section 3.5 of <a class='info' href='#RFC5117'>RTP Topologies<span> (</span><span class='info'>Westerlund, M. and S. Wenger, &ldquo;RTP Topologies,&rdquo; January&nbsp;2008.</span><span>)</span></a> [RFC5117].
</p>
<p>With DTLS-SRTP, this topology is computationally expensive for the
        video switcher because it has to encrypt the payload uniquely for each
        SRTP listener. Additionally, the architecture of a typical video
        switcher requires each listener's SRTP to be encrypted serially,
        incurring additional delay for each successive listener. This is
        depicted below in <a class='info' href='#multipoint-video-without-kt'>Figure&nbsp;4<span> (</span><span class='info'>Point to Multipoint Video Switching, without DTLS Key Transport</span><span>)</span></a>.
</p><br /><hr class="insert" />
<a name="multipoint-video-without-kt"></a>

<p>In the following figure, DTLS-SRTP Key Transport is used
          on all sessions and depicted by "=". In this scenario, both the
          speakers and listeners must support DTLS-SRTP Key Transport so that
          the switcher and the listeners can benefit from DTLS-SRTP Key
          Transport.
</p><div style='display: table; width: 0; margin-left: auto; margin-right: auto'><pre>
     +-------key=F-------+
     |                   |
     V               +---+------+         +------------+
+---------+          |          +==key=C=&gt;+ listener 1 |
| speaker +==key=A==&gt;+selected  |         +------------+
+---------+          |          |         +------------+
                     | switcher +==key=D=&gt;+ listener 2 |
+---------+          |          |         +------------+
| speaker +==key=B==&gt;+dropped   |         +------------+
+----+----+          |          +==key=E=&gt;+ listener 3 |
     ^               +---+------+         +------------+
     |                   |
     +-------key=G-------+</pre></div>
<p>
</p><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;4: Point to Multipoint Video Switching, without DTLS Key Transport&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>With DTLS key transport, this becomes easier; in fact, the video
        switcher doesn't need to decrypt the SRTP at all, but just make its
        decision (select the stream or drop the stream) and transmit the SRTP
        packets to the listeners. This is depicted below in <a class='info' href='#multipoint-video-with-kt'>Figure&nbsp;5<span> (</span><span class='info'>Point to Multipoint Video Switching, with DTLS Key Transport</span><span>)</span></a>.
</p><br /><hr class="insert" />
<a name="multipoint-video-with-kt"></a>

<p>
</p><div style='display: table; width: 0; margin-left: auto; margin-right: auto'><pre>     +-------key=B-------+
     |                   |
     V               +---+------+         +------------+
+----+----+          |          +==key=A=&gt;+ listener 1 |
| speaker +==key=A==&gt;+selected  |         +------------+
+---------+          |          |         +------------+
                     | switcher +==key=A=&gt;+ listener 2 |
+---------+          |          |         +------------+
| speaker +==key=B==&gt;+prev.spkr |         +------------+
+---------+          |          +==key=A=&gt;+ listener 3 |
     ^               +----------+         +------------+
     |                   |
     +-------key=A-------+</pre></div>
<p>
</p><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;5: Point to Multipoint Video Switching, with DTLS Key Transport&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>The video switcher is aware of listeners leaving or joining. The
        protocol described in this document allows the switcher to dictate, to
        the speaker, that the speaker use a new encryption key. This allows
        the switcher to enforce security, based on the switcher's policy
        (<a class='info' href='#sec-group-policy'>Section&nbsp;6.1<span> (</span><span class='info'>Group Policy when Joining/Leaving</span><span>)</span></a>). This is done by the video
        switcher sending a DTLS "your_new_srtp_key" message. The speaker will
        respond with a DTLS "new_srtp_key" message which echos the same key.
        The "new_srtp_key" message is relayed, by the switcher, to each of the
        active listeners.
</p>
<p>When there are multiple speakers, as shown in <a class='info' href='#multipoint-video-with-kt'>Figure&nbsp;5<span> (</span><span class='info'>Point to Multipoint Video Switching, with DTLS Key Transport</span><span>)</span></a> above, each speaker
        transmits with his own SRTP key. That SRTP key is derived from the
        DTLS handshake with the switcher. Each speaker uses DTLS-SRTP Key
        Transport to signal the SSRC that it will use.
</p>
<a name="anchor5"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.4"></a><h3>3.4.&nbsp;
Voicemail Storage and Retrieval</h3>

<p>With DTLS-SRTP, voicemail storage servers have to decrypt the SRTP
        when the message is recorded. In some voicemail server architectures,
        the recorded message is re-encrypted, using a new key to protect the
        content while it is on disk. Then, later, the voicemail is retrieved,
        which involves encrypting the message using SRTP again. This is
        depicted below in <a class='info' href='#voicemail-without-kt'>Figure&nbsp;6<span> (</span><span class='info'>Voicemail Storage and Retrieval without Key Transport</span><span>)</span></a>. This
        SRTP decryption and encryption can create a significant computational
        load on a voicemail storage server.
</p><br /><hr class="insert" />
<a name="voicemail-without-kt"></a>

<p>
</p><div style='display: table; width: 0; margin-left: auto; margin-right: auto'><pre>                     +-----------+
+---------+          |           |
| speaker +--key=A--&gt;| voicemail |
+---------+          |  storage  |
                     |  server   |          +-----------+
                     |           +--key=B--&gt;+ voicemail |
                     | (store    |          | retrieval |
                     | decrypted |          +-----------+
                     |  content) |
                     +-----------+
</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;6: Voicemail Storage and Retrieval without Key Transport&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>DTLS-SRTP Key Transport removes the need for the voicemail storage
        server to decrypt the incoming SRTP and to re-encrypt upon message
        retrieval. With DTLS-SRTP Key Transport, the voicemail storage server
        can store the speaker's DTLS-SRTP key along with the encrypted message
        (including RTP headers), and then use DTLS-SRTP Key Transport to
        communicate that key during voicemail retrieval. This is depicted
        below in <a class='info' href='#voicemail-with-kt'>Figure&nbsp;7<span> (</span><span class='info'>Voicemail Storage and Retrieval with Key Transport</span><span>)</span></a>.
</p><br /><hr class="insert" />
<a name="voicemail-with-kt"></a>

<p>In the following figure, DTLS-SRTP Key Transport is used
          on all sessions and depicted by "=". In this scenario, only the
          device performing the voicemail retrieval needs to implement
          DTLS-SRTP Key Transport to help offload SRTP processing from the
          voicemail storage server.
</p><div style='display: table; width: 0; margin-left: auto; margin-right: auto'><pre>
                     +-----------+
+---------+          |           |
| speaker +--key=A--&gt;| voicemail |
+---------+          |  storage  |
                     |  server   |          +-----------+
                     |           +==key=A==&gt;+ voicemail |
                     | (store    |          | retrieval |
                     | encrypted |          +-----------+
                     | content &amp; |
                     | SRTP key  |
                     +-----------+
</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;7: Voicemail Storage and Retrieval with Key Transport&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<a name="sec_protocol_description"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4"></a><h3>4.&nbsp;
Protocol Description</h3>

<p>This section describes the extension to the DTLS protocol for DTLS-SRTP
      key transport, which allows securely communicating the SRTP key to the
      DTLS peer.
</p>
<a name="anchor6"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.1"></a><h3>4.1.&nbsp;
key_transport extension</h3>

<p>This document adds a new negotiated extension called
        "key_transport", which MUST only be requested in conjunction with the
        "use_srtp" extension (Section 3.2 of <a class='info' href='#I-D.ietf-avt-dtls-srtp'>[I&#8209;D.ietf&#8209;avt&#8209;dtls&#8209;srtp]<span> (</span><span class='info'>McGrew, D. and E. Rescorla, &ldquo;Datagram Transport Layer Security (DTLS) Extension to Establish Keys for Secure Real-time Transport Protocol (SRTP),&rdquo; February&nbsp;2009.</span><span>)</span></a>). The DTLS server indicates
        its support for key_transport by including key_transport in its
        ServerHello message. If a DTLS client includes key_transport in its
        ClientHello, but does not receive key_transport in the ServerHello,
        the DTLS client MUST NOT send DTLS packets with the srtp_key_transport
        content-type.
</p>
<p>Support for the DTLS Key Transport extension is indicated in SDP
        with the "srtp-kt" attribute. Advertising support for the extension is
        necessary in SDP because in some cases it is required to establish an
        SRTP call. For example, a mixer may be able to only support SRTP
        listeners if those listeners implement DTLS Key Transport (because it
        lacks the CPU cycles necessary to encrypt SRTP uniquely for each
        listener).
</p><br /><hr class="insert" />
<a name="handshake_message_flow"></a>

<p>A message flow showing a DTLS client and DTLS server using
          the key_transport extension
</p><div style='display: table; width: 0; margin-left: auto; margin-right: auto'><pre>
Client                                               Server

ClientHello + use_srtp + key_transport
                             --------&gt;
                     ServerHello + use_srtp + key_transport
                                               Certificate*
                                         ServerKeyExchange*
                                        CertificateRequest*
                             &lt;--------      ServerHelloDone
Certificate*
ClientKeyExchange
CertificateVerify*
[ChangeCipherSpec]
Finished                     --------&gt;
                                         [ChangeCipherSpec]
                             &lt;--------             Finished
SRTP packets                 &lt;-------&gt;      SRTP packets
</pre></div>
<p>
</p><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;8: Handshake Message Flow&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>After successful negotiation of the key_transport extension, the
        DTLS client and server MAY exchange SRTP packets, encrypted using the
        KDF described in <a class='info' href='#I-D.ietf-avt-dtls-srtp'>[I&#8209;D.ietf&#8209;avt&#8209;dtls&#8209;srtp]<span> (</span><span class='info'>McGrew, D. and E. Rescorla, &ldquo;Datagram Transport Layer Security (DTLS) Extension to Establish Keys for Secure Real-time Transport Protocol (SRTP),&rdquo; February&nbsp;2009.</span><span>)</span></a>. This
        is normal and expected, even if Key Transport was negotiated by both
        sides, as neither side may (yet) have a need to alter the SRTP key.
        However, it is also possible that one (or both) peers will immediately
        send a new_srtp_key message before sending any SRTP.
</p>
<a name="anchor7"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.2"></a><h3>4.2.&nbsp;
SRTP Key Transport Protocol</h3>

<p>A new protocol is defined, called the srtp_key_transport protocol
        which uses srtp_key_transport content-type which consists of the
        following message types:
</p>
<p></p>
<blockquote class="text"><dl>
<dt>new_srtp_key_request:</dt>
<dd>request that the DTLS peer
            choose a new key. Valid responses are new_srtp_key and
            new_srtp_key_error.
</dd>
<dt>your_new_srtp_key:</dt>
<dd>Dictates a new SRTP key for the
            peer to use when the peer transmits its SRTP packets.
</dd>
<dt>new_srtp_key:</dt>
<dd>contains the new SRTP keying material.
            This message is sent by a DTLS endpoint that wants to change its
            SRTP key. This does not change any cryptographic parameters (a new
            DTLS handshake is necessary for that), but only the DTLS key for
            the associated SRTP session. This message includes the SSRC that
            will be used for this key, which allows listeners to establish one
            SRTP crypto-context per speaker (necessary for the video switching
            scenario). The key chosen MUST be cryptographically random <a class='info' href='#RFC4086'>[RFC4086]<span> (</span><span class='info'>Eastlake, D., Schiller, J., and S. Crocker, &ldquo;Randomness Requirements for Security,&rdquo; June&nbsp;2005.</span><span>)</span></a>.
</dd>
<dt>new_key_activate:</dt>
<dd>indicates receiver is prepared to
            receive SRTP packets encrypted with the new key.
</dd>
<dt>delete_srtp_key:</dt>
<dd>indicates the security association
            related to this key can be deleted.
</dd>
<dt>new_srtp_key_failure:</dt>
<dd>indicates a failure.
</dd>
</dl></blockquote>

<p>At any time, the DTLS client or DTLS server MAY send a
        key_transport message, as shown in <a class='info' href='#new_key_message_flow'>Figure&nbsp;9<span> (</span><span class='info'>New Key Message Flow</span><span>)</span></a>. The sender of the new_srtp_key
        message MAY immediately start transmitting SRTP packets with this new
        key. However, to account for loss of the new_srtp_key message it is
        RECOMMENDED that the sender wait before changing to the new SRTP key
        until it receives the new_key_activate message or it times out waiting
        for the new_key_activate_message. The duration of this timeout may
        vary depending on the sensitivity of the content (e.g., 1 second or 10
        seconds). In any case, the new_srtp_key message is retransmitted until
        acknowledged by receipt of a new_key_activate message.
</p><br /><hr class="insert" />
<a name="new_key_message_flow"></a>

<p>
</p><div style='display: table; width: 0; margin-left: auto; margin-right: auto'><pre>Client / Server                             Server / Client

[new_srtp_key_request]        --------&gt;
                             &lt;--------         new_srtp_key
new_srtp_key_activiate        --------&gt;</pre></div>
<p>
</p><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;9: New Key Message Flow&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>The following figure shows the state machine for the protocol.
</p><br /><hr class="insert" />
<a name="state_machine"></a>

<p>
</p><div style='display: table; width: 0; margin-left: auto; margin-right: auto'><pre>      receive new_srtp_key_request from peer
         or decide to choose new SRTP key
                     |
                     |
send                 V
new_srtp_key  +---------------+    timeout
    +---------| Communicate   |--------+
    |         |     Key       |        |
    +--------&gt;|               |        |
              +---------------+        |
                |           ^          |
     receive    |           |   +----------------+
new_key_activate|           +---| send SRTP using|
                |               |  new SRTP key  |
        +----------------+      +----------------+
        | send SRTP using|
        |  new SRTP key  |
        +----------------+
                |
                V
               done</pre></div>
<p>
</p><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;10: Key Transport protocol state machine&nbsp;</b></font><br /></td></tr></table><hr class="insert" />
<br /><hr class="insert" />
<a name="datastructure"></a>

<p>Using the syntax described in <a class='info' href='#RFC4346'>TLS<span> (</span><span class='info'>Dierks, T. and E. Rescorla, &ldquo;The Transport Layer Security (TLS) Protocol Version 1.1,&rdquo; April&nbsp;2006.</span><span>)</span></a> [RFC4346], the following structures are
          used:
</p><div style='display: table; width: 0; margin-left: auto; margin-right: auto'><pre>
enum {
   new_srtp_key_request(0),
   your_new_srtp_key(1),
   new_srtp_key(2),
   new_srtp_key_activate(3),
   delete_srtp_key(4),
   new_srtp_key_failure(128),
   (255)
} SRTPKeyTransportType;

struct {
   SRTPKeyTransportType keytrans_type;
   uint24 length;
   uint16 message_seq;
   uint24 fragment_offset;
   uint24 fragment_length;
   select (SRTPKeyTransportType) {
      case new_srtp_key_request:         NewSRTPKeyRequest;
      case your_new_srtp_key:            YourNewSRTPKey;
      case new_srtp_key:                 NewSRTPKey;
      case new_srtp_key_activate:        NewSRTPKeyActivate;
      case delete_srtp_key:              DeleteSRTPKey;
      case new_srtp_key_failure:         NewSRTPKeyFailure;
    };
} KeyTransport;

struct {
    uint  random&lt;64&gt;;           // additional entropy for peer
} NewSRTPKeyRequest;

struct {
    uint32 ssrc;                // SSRC used for this key
    uint   key&lt;16..32&gt;;         // The last change_cipher_spec
    uint   auth_tag&lt;4..10&gt;      // decides the length of key
                                // and auth_tag
    uint  random&lt;64&gt;;           // additional entropy for peer
} NewSRTPKey;

struct {
    uint   key&lt;16..32&gt;;         // The last change_cipher_spec
    uint   auth_tag&lt;4..10&gt;      // decides the length of key
                                // and auth_tag
} YourNewSRTPKey;

struct {
    uint  random&lt;64&gt;;           // additional entropy for peer
} NewSRTPKeyActivate;

struct {
    uint32 ssrc;                // SSRC used for this key
} DeleteSRTPKey;

struct { } NewSRTPKeyFailure;</pre></div>
<p>
</p><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;11: Data Structures&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<a name="anchor8"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.3"></a><h3>4.3.&nbsp;
Key Transport SSRC and RTP SSRC Collisions</h3>

<p>Per <a class='info' href='#RFC3550'>[RFC3550]<span> (</span><span class='info'>Schulzrinne, H., Casner, S., Frederick, R., and V. Jacobson, &ldquo;RTP: A Transport Protocol for Real-Time Applications,&rdquo; July&nbsp;2003.</span><span>)</span></a>, if an RTP source notices an RTP
        SSRC collision, it is required to change its SSRC. If it has
        negotiated support for DTLS-SRTP Key Transport, it then MUST also send
        a new_srtp_key message indicating the new SSRC. As part of this
        procedure, it does not need to also change its SRTP key.
</p>
<p>The communication of the SSRC used for each key is necessary if
        there are multiple speakers in the video switching scenario. However,
        because a speaker is not able to determine if their audio or their
        video is being switched, a speaker MUST always adhere indicate a
        change in SSRC by following the procedure in this section for any SRTP
        stream (audio, video, or other).
</p>
<a name="anchor9"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.4"></a><h3>4.4.&nbsp;
Fragmentation, Reassembly, and Retransmission</h3>

<p>Much like the DTLS handshake itself, this extension also needs to
        handle fragmentation and reassembly (to send a large key) and
        retransmission (to account for packet loss). Using the same technique
        as DTLS's handshake, the message_seq, fragment_offset, fragment_length
        are used.
</p>
<p>When transmitting the key transport message, the sender divides the
        message into a series of N contiguous data ranges. These ranges MUST
        NOT be larger than the maximum handshake fragment size and MUST
        jointly contain the entire key transport message. The ranges SHOULD
        NOT overlap. The sender then creates N key transport messages, all
        with the same message_seq value as the original key transport message.
        Each new message is labelled with the fragment_offset (the number of
        bytes contained in previous fragments) and the fragment_length (the
        length of this fragment). The length field in all messages is the same
        as the length field of the original message. An unfragmented message
        is a degenerate case with fragment_offset=0 and
        fragment_length=length.
</p>
<p>When a DTLS implementation receives a key transport message
        fragment, it MUST buffer it until it has the entire key transport
        message. DTLS implementations MUST be able to handle overlapping
        fragment ranges. This allows senders to retransmit key transport
        messages with smaller fragment sizes during path MTU discovery.
</p>
<a name="anchor10"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5"></a><h3>5.&nbsp;
Examples</h3>
<br /><hr class="insert" />
<a name="fig_example_simple_offer_kt_required"></a>

<p>The following example shows how Key Transport would be
requested in an offer, using "a=dtls-srtp-kt".
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
      v=0
      o=- 25678 753849 IN IP4 192.0.2.1
      s=
      c=IN IP4 192.0.2.1
      t=0 0
      m=audio 53456 UDP/TLS/RTP/SAVP 0
      a=fingerprint:SHA-1 \
        4A:AD:B9:B1:3F:82:18:3B:54:02:12:DF:3E:5D:49:6B:19:E5:7C:AB
      a=dtls-srtp-kt</pre></div>
<p>
</p><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;12: Simple SDP offer showing Key Transport is required&nbsp;</b></font><br /></td></tr></table><hr class="insert" />
<br /><hr class="insert" />
<a name="fig_example_offer_kt_required"></a>

<p>Using the SDP syntax described in <a class='info' href='#I-D.ietf-mmusic-sdp-capability-negotiation'>[I&#8209;D.ietf&#8209;mmusic&#8209;sdp&#8209;capability&#8209;negotiation]<span> (</span><span class='info'>Andreasen, F., &ldquo;SDP Capability Negotiation,&rdquo; March&nbsp;2010.</span><span>)</span></a>, the
        following figure shows an offerer that requires DTLS Key Transport in
        order to set up this call as an SRTP call, otherwise it can set up
        this call as an RTP call. This is indicated by the ",2" on the
        "a=pcfg" line. If the answerer does not understand "a=dtls-srtp-kt"
        but does understand DTLS-SRTP and <a class='info' href='#I-D.ietf-mmusic-sdp-capability-negotiation'>[I&#8209;D.ietf&#8209;mmusic&#8209;sdp&#8209;capability&#8209;negotiation]<span> (</span><span class='info'>Andreasen, F., &ldquo;SDP Capability Negotiation,&rdquo; March&nbsp;2010.</span><span>)</span></a>, this can
        cannot be established using DTLS-SRTP; however, it can be established
        using RTP.
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
      v=0
      o=- 25678 753849 IN IP4 192.0.2.1
      s=
      c=IN IP4 192.0.2.1
      t=0 0
      m=audio 53456 RTP/AVP 0
      a=tcap:1 UDP/TLS/RTP/SAVP
      a=acap:1 fingerprint:SHA-1 \
        4A:AD:B9:B1:3F:82:18:3B:54:02:12:DF:3E:5D:49:6B:19:E5:7C:AB
      a=acap:2 dtls-srtp-kt
      a=pcfg:1 t=1 a=1,2</pre></div>
<p>
</p><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;13: Example SDP offer showing Key Transport is required&nbsp;</b></font><br /></td></tr></table><hr class="insert" />
<br /><hr class="insert" />
<a name="fig_example_offer_kt_optional"></a>

<p>Using the SDP syntax described in <a class='info' href='#I-D.ietf-mmusic-sdp-capability-negotiation'>[I&#8209;D.ietf&#8209;mmusic&#8209;sdp&#8209;capability&#8209;negotiation]<span> (</span><span class='info'>Andreasen, F., &ldquo;SDP Capability Negotiation,&rdquo; March&nbsp;2010.</span><span>)</span></a>, the
        following figure shows an offerer that indicates support for DTLS Key
        Transport but does not require DTLS Key Transport in order to set up
        this call as an SRTP call. This is indicated by the ",[2]" on the
        "a=pcfg" line. If the answerer does not understand "a=dtls-srtp-kt"
        but does understand DTLS-SRTP and <a class='info' href='#I-D.ietf-mmusic-sdp-capability-negotiation'>[I&#8209;D.ietf&#8209;mmusic&#8209;sdp&#8209;capability&#8209;negotiation]<span> (</span><span class='info'>Andreasen, F., &ldquo;SDP Capability Negotiation,&rdquo; March&nbsp;2010.</span><span>)</span></a>, this call
        can still be established using DTLS-SRTP.
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
      v=0
      o=- 25678 753849 IN IP4 192.0.2.1
      s=
      c=IN IP4 192.0.2.1
      t=0 0
      m=audio 53456 RTP/AVP 0
      a=tcap:1 UDP/TLS/RTP/SAVP
      a=acap:1 fingerprint:SHA-1 \
          4A:AD:B9:B1:3F:82:18:3B:54:02:12:DF:3E:5D:49:6B:19:E5:7C:AB
      a=acap:2 dtls-srtp-kt
      a=pcfg:1 t=1 a=1,[2]</pre></div>
<p>
</p><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;14: Example SDP offer showing Key Transport is optional&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>
</p>
<a name="security_considerations"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6"></a><h3>6.&nbsp;
Security Considerations</h3>

<p>In the point-to-multipoint scenario, <a class='info' href='#section_point_multipoint'>Section&nbsp;3.1<span> (</span><span class='info'>Point to Multipoint using the RFC 3550 mixer model</span><span>)</span></a>, all of the listeners know the
      key being used by the mixer. Any of those listeners could create SRTP
      packets that are encrypted with this same key, and send those SRTP
      packets to other listeners. In order to reduce the vulnerability to this
      threat, it is RECOMMENDED that the source transport address of received
      SRTP packets be discarded if they do not match the source transport
      address of the associated DTLS-SRTP session. Additionally, the network
      SHOULD prevent IP address spoofing <a class='info' href='#RFC2827'>[RFC2827]<span> (</span><span class='info'>Ferguson, P. and D. Senie, &ldquo;Network Ingress Filtering: Defeating Denial of Service Attacks which employ IP Source Address Spoofing,&rdquo; May&nbsp;2000.</span><span>)</span></a>.
</p>
<a name="sec-group-policy"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.1"></a><h3>6.1.&nbsp;
Group Policy when Joining/Leaving</h3>

<p>When sharing SRTP keys with several listeners, it is imperative
        that the SRTP is changed when a new listener is added or a listener is
        removed. This is because a legitimate listener should only be able to
        decrypt the SRTP stream while he is listening; he should not be able
        to decrypt the SRTP stream prior to joining the conference or after
        leaving the conference. Failing to change the key when a listener
        joins (or leaves) allows a listener to decrypt SRTP traffic prior to
        (or after) they are authorized participants in the conference.
</p>
<p>Policies for a specific user's access to a conference may be
        different from conference to conference. For example, a
        company-internal event announcing promotions might be accessible to
        all employees and have no need for re-keying when listeners join or
        leave the conference. As another example, a conference where a job
        candidate is interviewed should be rekeyed when the job candidate
        joins the conference and again when the job candidate leaves the
        conference.
</p>
<p>The protocol described in this document allows whichever policy is
        needed for a particular situation. The protocol itself does not
        enforce a certain policy; that is, the protocol itself does not ensure
        the SRTP key is changed when a listener leaves (or joins) the
        conference.
</p>
<a name="anchor11"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7"></a><h3>7.&nbsp;
Acknowledgements</h3>

<p>Thanks to David McGrew for his improvements to this document and to
      the underlying protocol. Thanks to Brian Weis, Sheela Rowles, and Mark
      Baugher for suggesting how GDOI-SRTP's key management could be used by
      DTLS-SRTP; these suggestions have been incorporated into DTLS-SRTP Key
      Transport.
</p>
<a name="anchor12"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.8"></a><h3>8.&nbsp;
IANA Considerations</h3>

<p>[[This section will be completed in a future version of this
      document.]]
</p>
<p>To do:
</p>
<ul class="text">
<li>Register new SDP attribute "dtls-srtp-kt"
</li>
<li>new TLS content-type "key_transport" (26?)
</li>
</ul><p> 
</p>
<a name="rfc.references"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.9"></a><h3>9.&nbsp;
References</h3>

<a name="rfc.references1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>9.1.&nbsp;Normative References</h3>
<table width="99%" border="0">
<tr><td class="author-text" valign="top"><a name="I-D.ietf-avt-dtls-srtp">[I-D.ietf-avt-dtls-srtp]</a></td>
<td class="author-text">McGrew, D. and E. Rescorla, &ldquo;<a href="http://www.ietf.org/internet-drafts/draft-ietf-avt-dtls-srtp-07.txt">Datagram Transport Layer Security (DTLS) Extension to Establish Keys for Secure Real-time Transport Protocol (SRTP)</a>,&rdquo; draft-ietf-avt-dtls-srtp-07 (work in progress), February&nbsp;2009 (<a href="http://www.ietf.org/internet-drafts/draft-ietf-avt-dtls-srtp-07.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC2119">[RFC2119]</a></td>
<td class="author-text"><a href="mailto:sob@harvard.edu">Bradner, S.</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>,&rdquo; BCP&nbsp;14, RFC&nbsp;2119, March&nbsp;1997 (<a href="http://www.rfc-editor.org/rfc/rfc2119.txt">TXT</a>, <a href="http://xml.resource.org/public/rfc/html/rfc2119.html">HTML</a>, <a href="http://xml.resource.org/public/rfc/xml/rfc2119.xml">XML</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4346">[RFC4346]</a></td>
<td class="author-text">Dierks, T. and E. Rescorla, &ldquo;<a href="http://tools.ietf.org/html/rfc4346">The Transport Layer Security (TLS) Protocol Version 1.1</a>,&rdquo; RFC&nbsp;4346, April&nbsp;2006 (<a href="http://www.rfc-editor.org/rfc/rfc4346.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC2827">[RFC2827]</a></td>
<td class="author-text">Ferguson, P. and D. Senie, &ldquo;<a href="http://tools.ietf.org/html/rfc2827">Network Ingress Filtering: Defeating Denial of Service Attacks which employ IP Source Address Spoofing</a>,&rdquo; BCP&nbsp;38, RFC&nbsp;2827, May&nbsp;2000 (<a href="http://www.rfc-editor.org/rfc/rfc2827.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="I-D.ietf-mmusic-sdp-capability-negotiation">[I-D.ietf-mmusic-sdp-capability-negotiation]</a></td>
<td class="author-text">Andreasen, F., &ldquo;<a href="http://www.ietf.org/internet-drafts/draft-ietf-mmusic-sdp-capability-negotiation-13.txt">SDP Capability Negotiation</a>,&rdquo; draft-ietf-mmusic-sdp-capability-negotiation-13 (work in progress), March&nbsp;2010 (<a href="http://www.ietf.org/internet-drafts/draft-ietf-mmusic-sdp-capability-negotiation-13.txt">TXT</a>).</td></tr>
</table>

<a name="rfc.references2"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>9.2.&nbsp;Informational References</h3>
<table width="99%" border="0">
<tr><td class="author-text" valign="top"><a name="RFC5117">[RFC5117]</a></td>
<td class="author-text">Westerlund, M. and S. Wenger, &ldquo;<a href="http://tools.ietf.org/html/rfc5117">RTP Topologies</a>,&rdquo; RFC&nbsp;5117, January&nbsp;2008 (<a href="http://www.rfc-editor.org/rfc/rfc5117.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC3550">[RFC3550]</a></td>
<td class="author-text">Schulzrinne, H., Casner, S., Frederick, R., and V. Jacobson, &ldquo;<a href="http://tools.ietf.org/html/rfc3550">RTP: A Transport Protocol for Real-Time Applications</a>,&rdquo; STD&nbsp;64, RFC&nbsp;3550, July&nbsp;2003 (<a href="http://www.rfc-editor.org/rfc/rfc3550.txt">TXT</a>, <a href="http://www.rfc-editor.org/rfc/rfc3550.ps">PS</a>, <a href="http://www.rfc-editor.org/rfc/rfc3550.pdf">PDF</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4086">[RFC4086]</a></td>
<td class="author-text">Eastlake, D., Schiller, J., and S. Crocker, &ldquo;<a href="http://tools.ietf.org/html/rfc4086">Randomness Requirements for Security</a>,&rdquo; BCP&nbsp;106, RFC&nbsp;4086, June&nbsp;2005 (<a href="http://www.rfc-editor.org/rfc/rfc4086.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="I-D.ietf-msec-gdoi-srtp">[I-D.ietf-msec-gdoi-srtp]</a></td>
<td class="author-text">Baugher, M., Rueegsegger, A., and S. Rowles, &ldquo;<a href="http://www.ietf.org/internet-drafts/draft-ietf-msec-gdoi-srtp-01.txt">GDOI Key Establishment for the SRTP Data Security Protocol</a>,&rdquo; draft-ietf-msec-gdoi-srtp-01 (work in progress), December&nbsp;2007 (<a href="http://www.ietf.org/internet-drafts/draft-ietf-msec-gdoi-srtp-01.txt">TXT</a>).</td></tr>
</table>

<a name="anchor15"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.A"></a><h3>Appendix A.&nbsp;
Changes</h3>

<p>[[Note to RFC Editor: Please remove this section prior to publication]]
</p>
<a name="anchor16"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.A.1"></a><h3>A.1.&nbsp;
Changes from -00 to -01</h3>

<p></p>
<ul class="text">
<li>more closely aligned with <a class='info' href='#RFC5117'>RTP Topologies<span> (</span><span class='info'>Westerlund, M. and S. Wenger, &ldquo;RTP Topologies,&rdquo; January&nbsp;2008.</span><span>)</span></a> [RFC5117]
</li>
<li>added multicast scenario
</li>
<li>added voicemail storage/retrieval scenario
</li>
<li>added delete_srtp_key
</li>
<li>added your_new_srtp_key
</li>
<li>aligned SDP for DTLS-SRTP with draft-ietf-mmusic-sdp-dtls-00
</li>
<li>key change rules are now discussed in Security Considerations
</li>
</ul>

<a name="rfc.authors"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>Author's Address</h3>
<table width="99%" border="0" cellpadding="0" cellspacing="0">
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Dan Wing</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Cisco Systems, Inc.</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">170 West Tasman Drive</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">San Jose, CA  95134</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">USA</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:dwing@cisco.com">dwing@cisco.com</a></td></tr>
</table>
<a name="rfc.copyright"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>Full Copyright Statement</h3>
<p class='copyright'>
Copyright &copy; The IETF Trust (2008).</p>
<p class='copyright'>
This document is subject to the rights,
licenses and restrictions contained in BCP&nbsp;78,
and except as set forth therein,
the authors retain all their rights.</p>
<p class='copyright'>
This document and the information contained herein are provided
on an &ldquo;AS IS&rdquo; basis and THE CONTRIBUTOR,
THE ORGANIZATION HE/SHE REPRESENTS
OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY, THE IETF TRUST
AND THE INTERNET ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT
THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY
IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR
PURPOSE.</p>
<h3>Intellectual Property</h3>
<p class='copyright'>
The IETF takes no position regarding the validity or scope of any
Intellectual Property Rights or other rights that might be claimed
to pertain to the implementation or use of the technology
described in this document or the extent to which any license
under such rights might or might not be available; nor does it
represent that it has made any independent effort to identify any
such rights.
Information on the procedures with respect to
rights in RFC documents can be found in BCP&nbsp;78 and BCP&nbsp;79.</p>
<p class='copyright'>
Copies of IPR disclosures made to the IETF Secretariat and any
assurances of licenses to be made available,
or the result of an attempt made to obtain a general license or
permission for the use of such proprietary rights by implementers or
users of this specification can be obtained from the IETF on-line IPR
repository at <a href='http://www.ietf.org/ipr'>http://www.ietf.org/ipr</a>.</p>
<p class='copyright'>
The IETF invites any interested party to bring to its attention
any copyrights,
patents or patent applications,
or other
proprietary rights that may cover technology that may be required
to implement this standard.
Please address the information to the IETF at <a href='mailto:ietf-ipr@ietf.org'>ietf-ipr@ietf.org</a>.</p>
<h3>Acknowledgment</h3>
<p class='copyright'>
This document was produced
using xml2rfc&nbsp;v1.35 (of <a href='http://xml.resource.org/'>http://xml.resource.org/</a>)
from a source in RFC-2629 XML format.</p>
</body></html>
