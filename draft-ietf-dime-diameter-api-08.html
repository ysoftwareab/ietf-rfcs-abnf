<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="en"><head><title>The Diameter API</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="description" content="The Diameter API">
<meta name="generator" content="xml2rfc v1.35 (http://xml.resource.org/)">
<meta name="viewport" content="width=600;" />
<style type='text/css'><!--
        body {
                font-family: verdana, charcoal, helvetica, arial, sans-serif;
                font-size: 85%;
		max-width: 40em; 
		color: #000; background-color: #FFF;
                margin: 2em;
        }
        h1, h2, h3, h4, h5, h6 {
                font-family: helvetica, monaco, "MS Sans Serif", arial, sans-serif;
                font-weight: bold; font-style: normal;
        }
        h1 { color: #900; background-color: transparent; text-align: right; }
        h3 { color: #333; background-color: transparent; }

        td.RFCbug {
                font-size: x-small; text-decoration: none;
                width: 30px; height: 30px; padding-top: 2px;
                text-align: justify; vertical-align: middle;
                background-color: #000;
        }
        td.RFCbug span.RFC {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: bold; color: #666;
        }
        td.RFCbug span.hotText {
                font-family: charcoal, monaco, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: normal; text-align: center; color: #FFF;
        }

        table.TOCbug { width: 30px; height: 15px; }
        td.TOCbug {
                text-align: center; width: 30px; height: 15px;
                color: #FFF; background-color: #900;
        }
        td.TOCbug a {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, sans-serif;
                font-weight: bold; font-size: x-small; text-decoration: none;
                color: #FFF; background-color: transparent;
        }

        td.header {
                font-family: arial, helvetica, sans-serif; font-size: x-small;
                vertical-align: top; width: 33%;
                color: #FFF; background-color: #666;
        }
        td.author { font-weight: bold; font-size: x-small; margin-left: 4em; }
        td.author-text { font-size: x-small; }

        /* info code from SantaKlauss at http://www.madaboutstyle.com/tooltip2.html */
        a.info {
                /* This is the key. */
                position: relative;
                z-index: 24;
                text-decoration: none;
        }
        a.info:hover {
                z-index: 25;
                color: #FFF; background-color: #900;
        }
        a.info span { display: none; }
        a.info:hover span.info {
                /* The span will display just on :hover state. */
                display: block;
                position: absolute;
                font-size: smaller;
                top: 2em; left: -5em; width: 15em;
                padding: 2px; border: 1px solid #333;
                color: #900; background-color: #EEE;
                text-align: left;
        }

        a { font-weight: bold; }
        a:link    { color: #900; background-color: transparent; }
        a:visited { color: #633; background-color: transparent; }
        a:active  { color: #633; background-color: transparent; }

        p { margin-left: 2em; margin-right: 2em; }
        p.copyright { font-size: x-small; }
        p.toc { font-size: 85%;
		max-width: 40em; 
		font-weight: bold; margin-left: 3em; }
        table.toc { margin: 0 0 0 3em; padding: 0; border: 0; vertical-align: text-top; }
        td.toc { font-size: 85%;
		max-width: 40em; 
		font-weight: bold; vertical-align: text-top; }

        ol.text { margin-left: 2em; margin-right: 2em; }
        ul.text { margin-left: 2em; margin-right: 2em; }
        li      { margin-left: 3em; }

        /* RFC-2629 <spanx>s and <artwork>s. */
        em     { font-style: italic; }
        strong { font-weight: bold; }
        dfn    { font-weight: bold; font-style: normal; }
        cite   { font-weight: normal; font-style: normal; }
        tt     { color: #036; }
        tt, pre, pre dfn, pre em, pre cite, pre span {
                font-family: "Courier New", Courier, monospace; font-size: small;
        }
        pre {
                text-align: left; padding: 4px;
                color: #000; background-color: #CCC;
        }
        pre dfn  { color: #900; }
        pre em   { color: #66F; background-color: #FFC; font-weight: normal; }
        pre .key { color: #33C; font-weight: bold; }
        pre .id  { color: #900; }
        pre .str { color: #000; background-color: #CFF; }
        pre .val { color: #066; }
        pre .rep { color: #909; }
        pre .oth { color: #000; background-color: #FCF; }
        pre .err { background-color: #FCC; }

        /* RFC-2629 <texttable>s. */
        table.all, table.full, table.headers, table.none {
                font-size: 85%;
		max-width: 40em; 
		text-align: center; border-width: 2px;
                vertical-align: top; border-collapse: collapse;
        }
        table.all, table.full { border-style: solid; border-color: black; }
        table.headers, table.none { border-style: none; }
        th {
                font-weight: bold; border-color: black;
                border-width: 2px 2px 3px 2px;
        }
        table.all th, table.full th { border-style: solid; }
        table.headers th { border-style: none none solid none; }
        table.none th { border-style: none; }
        table.all td {
                border-style: solid; border-color: #333;
                border-width: 1px 2px;
        }
        table.full td, table.headers td, table.none td { border-style: none; }

        hr { height: 1px; }
        hr.insert {
                width: 80%; border-style: none; border-width: 0;
                color: #CCC; background-color: #CCC;
        }
--></style>
</head>
<body>
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<table summary="layout" width="66%" border="0" cellpadding="0" cellspacing="0"><tr><td><table summary="layout" width="100%" border="0" cellpadding="2" cellspacing="1">
<tr><td class="header">Diameter Maintenance and</td><td class="header">V. Fajardo, Ed.</td></tr>
<tr><td class="header">Extensions (DIME)</td><td class="header">Toshiba America Research Inc.</td></tr>
<tr><td class="header">Internet-Draft</td><td class="header">P. Calhoun</td></tr>
<tr><td class="header">Intended status: Informational</td><td class="header">D. Frascone</td></tr>
<tr><td class="header">Expires: October 30, 2009</td><td class="header">Cisco Systems, Inc.</td></tr>
<tr><td class="header">&nbsp;</td><td class="header">April 28, 2009</td></tr>
</table></td></tr></table>
<h1><br />The Diameter API<br />draft-ietf-dime-diameter-api-08.txt</h1>

<h3>Status of this Memo</h3>
<p>
This Internet-Draft is submitted to IETF in full
conformance with the provisions of BCP&nbsp;78 and BCP&nbsp;79.</p>
<p>
Internet-Drafts are working documents of the Internet Engineering
Task Force (IETF), its areas, and its working groups.
Note that other groups may also distribute working documents as
Internet-Drafts.</p>
<p>
Internet-Drafts are draft documents valid for a maximum of six months
and may be updated, replaced, or obsoleted by other documents at any time.
It is inappropriate to use Internet-Drafts as reference material or to cite
them other than as &ldquo;work in progress.&rdquo;</p>
<p>
The list of current Internet-Drafts can be accessed at
<a href='http://www.ietf.org/ietf/1id-abstracts.txt'>http://www.ietf.org/ietf/1id-abstracts.txt</a>.</p>
<p>
The list of Internet-Draft Shadow Directories can be accessed at
<a href='http://www.ietf.org/shadow.html'>http://www.ietf.org/shadow.html</a>.</p>
<p>
This Internet-Draft will expire on October 30, 2009.</p>

<h3>Copyright Notice</h3>
<p>
Copyright (c) 2009 IETF Trust and the persons identified as the
document authors.  All rights reserved.</p>
<p>
This document is subject to BCP 78 and the IETF Trust's Legal
Provisions Relating to IETF Documents in effect on the date of
publication of this document (http://trustee.ietf.org/license-info).
Please review these documents carefully, as they describe your
rights and restrictions with respect to this document.</p>

<h3>Abstract</h3>

<p>The Diameter authentication, authorization,
      and accounting (AAA) protocol provides support for peering AAA transactions
      across the Internet. This document describes an API for the 
      Diameter protocol. The API is defined for the C language. 
      The intent of the API is to foster source code portability across
      multiple programming platforms. 
</p><a name="toc"></a><br /><hr />
<h3>Table of Contents</h3>
<p class="toc">
<a href="#anchor1">1.</a>&nbsp;
Introduction<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor2">1.1.</a>&nbsp;
Conventions Used in This Document<br />
<a href="#anchor3">2.</a>&nbsp;
Binding Independent Considerations<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor4">2.1.</a>&nbsp;
Multithreading<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor5">2.2.</a>&nbsp;
Error Reporting<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor6">2.3.</a>&nbsp;
String Format<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor7">2.4.</a>&nbsp;
Handling Connections with Other Servers/Peers<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor8">2.5.</a>&nbsp;
Command Dictionary File<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#visibility">2.6.</a>&nbsp;
Structure Member Visibility<br />
<a href="#clang">3.</a>&nbsp;
C API<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor9">3.1.</a>&nbsp;
Constant Types<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor10">3.1.1.</a>&nbsp;
IP Address and Port<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor11">3.1.2.</a>&nbsp;
Command Code<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor12">3.1.3.</a>&nbsp;
Vendor Identifier<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor13">3.1.4.</a>&nbsp;
Extension Identifier<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor14">3.1.5.</a>&nbsp;
Attribute/Value Pair Code<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor15">3.1.6.</a>&nbsp;
Value Type Identifier<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor16">3.1.7.</a>&nbsp;
Server Identifier<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor17">3.1.8.</a>&nbsp;
Session Identifier<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor18">3.1.9.</a>&nbsp;
Message Identifier<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor19">3.1.10.</a>&nbsp;
Callback Handle<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor20">3.1.11.</a>&nbsp;
Application Identifier<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor21">3.1.12.</a>&nbsp;
API Return Codes<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor22">3.1.13.</a>&nbsp;
Callback Location Codes<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor23">3.1.14.</a>&nbsp;
AVP Data Type Codes<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor24">3.1.15.</a>&nbsp;
AVP Flags<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor25">3.1.16.</a>&nbsp;
Domain Interconnection Types<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor26">3.1.17.</a>&nbsp;
Message Flags<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor27">3.1.18.</a>&nbsp;
Result Codes<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor28">3.1.19.</a>&nbsp;
Search Direction Type<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor29">3.1.20.</a>&nbsp;
Accounting Types<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor30">3.2.</a>&nbsp;
Structure Definitions<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor31">3.2.1.</a>&nbsp;
Dictionary Entry Definition<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor32">3.2.2.</a>&nbsp;
AVP Definition<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor33">3.2.3.</a>&nbsp;
AVP List<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor34">3.2.4.</a>&nbsp;
Message Definition<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor35">3.3.</a>&nbsp;
Macros and Preprocessor Definitions<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor36">3.4.</a>&nbsp;
Functions<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor37">3.4.1.</a>&nbsp;
Initialization and Configuration<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor41">3.4.2.</a>&nbsp;
Registering Commands<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor47">3.4.3.</a>&nbsp;
Session and Server Management<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor55">3.4.4.</a>&nbsp;
Dictionary Lookup<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor62">3.4.5.</a>&nbsp;
Message Management<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor81">3.4.6.</a>&nbsp;
Message Control<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor84">3.4.7.</a>&nbsp;
Accounting<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor86">3.5.</a>&nbsp;
Implementation Notes<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor87">3.6.</a>&nbsp;
Grouped AVPs<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#aaa_avp">3.7.</a>&nbsp;
Extended AAA_AVP structure<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor88">3.8.</a>&nbsp;
Avoiding AVP Copying<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor89">3.9.</a>&nbsp;
Callback Processing Order<br />
<a href="#anchor90">4.</a>&nbsp;
Security Considerations<br />
<a href="#anchor91">5.</a>&nbsp;
IANA Considerations<br />
<a href="#anchor92">6.</a>&nbsp;
Acknowledgments<br />
<a href="#rfc.references1">7.</a>&nbsp;
References<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#rfc.references1">7.1.</a>&nbsp;
Normative References<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#rfc.references2">7.2.</a>&nbsp;
Informative References<br />
<a href="#rfc.authors">&#167;</a>&nbsp;
Authors' Addresses<br />
</p>
<br clear="all" />

<a name="anchor1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1"></a><h3>1.&nbsp;
Introduction</h3>

<p>The Diameter authentication, authorization and accounting (AAA) protocol
      provides scale-able AAA support for peering transactions across the Internet
      <a class='info' href='#RFC3588'>[RFC3588]<span> (</span><span class='info'>Calhoun, Loughney, Guttman, Zorn, and Arkko, &ldquo;Diameter Base Protocol,&rdquo; October&nbsp;2002.</span><span>)</span></a>. This document describes an API in C for
      applications to access the Diameter protocol. 
      While an API is not strictly necessary for protocol
      interoperability, it does help to promote the
      use and deployment of a protocol by reducing the amount of work
      necessary to develop and access applications that use the protocol.
</p>
<p>The Diameter protocol provides a basic attribute/value pair (AVP) data format,
      which particular application profiles extend. Processing of the extensions
      is handled by code specific to the application profile. Application
      profile customizability is reflected into the API as callback functions
      for C.
</p>
<p>The callbacks implement the application profile processing for incoming
      messages. For outgoing calls, the C API provides an asynchronous model,
      leaving processing of the return message to the callbacks.
</p>
<p>For the most part, the API hides the details of establishing peering
      and redirect connections, parsing and creating Diameter messages, and
      other work necessary to set up and maintain a redirect or peering session. 
      The application profile codes need only be concerned with processing of the
      AVPs defined in the application profile.
</p>
<a name="anchor2"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1.1"></a><h3>1.1.&nbsp;
Conventions Used in This Document</h3>

<p>   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
   document are to be interpreted as described in  <a class='info' href='#RFC2119'>[RFC2119]<span> (</span><span class='info'>Bradner, S., &ldquo;Key words for use in RFCs to Indicate Requirement Levels,&rdquo; March&nbsp;1997.</span><span>)</span></a>.
</p>
<a name="anchor3"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2"></a><h3>2.&nbsp;
Binding Independent Considerations</h3>

<p>This section discusses a number of implementation considerations for
      bindings.
</p>
<a name="anchor4"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2.1"></a><h3>2.1.&nbsp;
Multithreading</h3>

<p>The C API is expected to be thread-safe. Access to 
        data structures shared among threads must be coordinated to
        avoid corruption or invalid access. In addition, API implementers
        are encouraged to provide the maximum amount of parallel processing
        within their library implementations by allowing multiple threads
        in the API library at once.
</p>
<a name="anchor5"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2.2"></a><h3>2.2.&nbsp;
Error Reporting</h3>

<p>The API reports errors resulting from client calls through
        language specific mechanisms. All functions in the API return
        error codes. API implementers
        are additionally encouraged to log errors using the appropriate platform
        specific error logging technique, especially for errors that result
        from network processing or other causes that are not directly related
        to an API function or method call.
</p>
<a name="anchor6"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2.3"></a><h3>2.3.&nbsp;
String Format</h3>

<p>C API clients are required to format strings as UTF-8 if the string
        contains 16 bit characters. Since the ASCII characters and the UTF-8
        8 bit characters have the same codes, ASCII can be used for UTF-8 if
        no wide characters are in the string.
        All strings passed through the C API are standard null-terminated C strings.
        Processing to remove the null terminator for transmission on the wire
        is done by the library. 
</p>
<a name="anchor7"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2.4"></a><h3>2.4.&nbsp;
Handling Connections with Other Servers/Peers</h3>

<p>The API supports making a connection with
        an arbitrary Diameter peer. The API allows a client to set
        the server address in a message (AAASetServer()).
        If a message is not sent to a particular server, the API library is 
        required to infer the servers by either looking in the configuration files
        or dynamically determining the servers that support the extension. 
</p>
<a name="anchor8"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2.5"></a><h3>2.5.&nbsp;
Command Dictionary File</h3>

<p>The commands that can be parsed by the local Diameter client
        library or server are defined in a command dictionary file
        containing the command definitions including AVPs. The location
        and name of the command dictionary file is platform-specific. This
        file is read and parsed to drive creation of 
        a command dictionary which is used by the library to
        parse commands. The syntax
        for the command dictionary file is in XML and
        a DTD describing it is available in <a class='info' href='#XML'>[XML]<span> (</span><span class='info'>Frascone, Jones, and Guttman, &ldquo;Diameter XML Dictionary,&rdquo; September&nbsp;2007.</span><span>)</span></a>.
        XML was selected as the definition language because
        support for XML parsing is available as an extension to the standard
        Java APIs and as a wide variety of public-domain C libraries, 
        simplifying implementation. Both APIs also support programmatic
        definition of commands, AVPs, and extensions so programs can
        add commands not in the dictionary for purposes of experimentation
        and implementing the library.
</p>
<a name="visibility"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2.6"></a><h3>2.6.&nbsp;
Structure Member Visibility</h3>

<p>Some data structures defined in this document shows only the visible
        or public member variables. Other internal or private member variables that maybe
        necessary for the correct functioning of an implementation are
        left for the implementors to define. Note that this document uses the
        C language (see <a class='info' href='#clang'>Section&nbsp;3<span> (</span><span class='info'>C API</span><span>)</span></a>) so there are no formal ways to guarantee
        privacy of internal variables. It would be up to careful documentation and
        the implementors discipline to maintain the integrity of the internal
        variables privacy. An example of this is shown in
        Sec <a class='info' href='#aaa_avp'>Section&nbsp;3.7<span> (</span><span class='info'>Extended AAA_AVP structure</span><span>)</span></a>.
</p>
<a name="clang"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3"></a><h3>3.&nbsp;
C API</h3>

<p>The C language API is designed around callbacks. An application profile
      defines a collection of Diameter commands, and a library of callbacks for 
      processing those commands. Each command is processed
      by a callback. Callbacks can also be defined that handle all commands.
      The API provides functions for managing callbacks, including registration
      and deregistration. 
</p>
<p>When an incoming Diameter command arrives, the command is parsed and
      passed to the appropriate callback. The callback receives as a parameter
      the message struct, which contains the AVPs for the command. The
      callback code can process the command by stepping through the AVPs.
</p>
<p>For outgoing requests, the API provides functions for creating messages and
      adding AVPs. A collection of functions also provides access to the
      AVP dictionary.
</p>
<p>Unless otherwise noted, parameters to API functions and callbacks
      are non-NULL. Some parameters may have other restrictions. If a
      parameter fails to satisfy the restrictions on its value, the 
      function returns AAA_ERR_PARAMETER.
</p>
<a name="anchor9"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.1"></a><h3>3.1.&nbsp;
Constant Types</h3>

<a name="anchor10"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.1.1"></a><h3>3.1.1.&nbsp;
IP Address and Port</h3>

<p>typedef struct sockaddr_storage AAA_IP_ADDR;
</p>
<p>AAA_IP_ADDR provides a way of referring to an IPv4 address,
            IPv6 address, and IP port. The default implementation (shown here)
            is defined in the Basic Socket Interface Extensions for IPv6 <a class='info' href='#RFC3493'>[RFC3493]<span> (</span><span class='info'>Gilligan, Thomson, Bound, McCann, and Stevens, &ldquo;Basic Socket Interface Extensions for IPv6,&rdquo; February&nbsp;2003.</span><span>)</span></a>
</p>
<a name="anchor11"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.1.2"></a><h3>3.1.2.&nbsp;
Command Code</h3>

<p>
             typedef uint32_t AAACommandCode;
            
</p>
<p>
            AAACommandCode provides a way of referring to the AAA command code
            of a command. It is used when registering callbacks, among others.
            
</p>
<a name="anchor12"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.1.3"></a><h3>3.1.3.&nbsp;
Vendor Identifier</h3>

<p>
             typedef uint32_t AAAVendorId;
            
</p>
<p>
              AAAVendorId provides a way of referring to the vendor identification
              code. It is used when registering callbacks, among others. Note
              that vendor id 0 is reserved and is defined by the preprocessor
              constant AAA_NO_VENDOR_ID.
            
</p>
<a name="anchor13"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.1.4"></a><h3>3.1.4.&nbsp;
Extension Identifier</h3>

<p>
              typedef uint32_t AAAExtensionId;
            
</p>
<p>
             AAAExtensionId provides a way of referring to an application profile
             extension, for registering callbacks and other purposes.
            
</p>
<a name="anchor14"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.1.5"></a><h3>3.1.5.&nbsp;
Attribute/Value Pair Code</h3>

<p>
              typedef uint32_t AAA_AVPCode;
            
</p>
<p>
             AAA_AVPCode provides a way of referring to the code number of an AVP.
             It is used as a parameter to the dictionary functions, and a field
             in the AVP struct.
            
</p>
<a name="anchor15"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.1.6"></a><h3>3.1.6.&nbsp;
Value Type Identifier</h3>

<p>
              typedef int32_t AAAValue;
            
</p>
<p>
             AAAValue provides a way of referring to particular dictionary-defined
             values. It is used in the dictionary API.
            
</p>
<a name="anchor16"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.1.7"></a><h3>3.1.7.&nbsp;
Server Identifier</h3>

<p>
             typedef void AAAServer;
            
</p>
<p>
             AAAServer is an identifier for a particular serving peer. It is used in
             the server access functions.
            
</p>
<a name="anchor17"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.1.8"></a><h3>3.1.8.&nbsp;
Session Identifier</h3>

<p>
             typedef void AAASessionId;
            
</p>
<p>
             AAASessionId is an identifier for a particular AAA session. It is used in
             the session APIs and when a message is created.
            
</p>
<a name="anchor18"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.1.9"></a><h3>3.1.9.&nbsp;
Message Identifier</h3>

<p>
             typedef uint32_t AAAMsgIdentifier;
            
</p>
<p>
             AAAMsgIdentifier is a unique identifier for an AAA message. Each individual
             message is marked with an identifier.
            
</p>
<a name="anchor19"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.1.10"></a><h3>3.1.10.&nbsp;
Callback Handle</h3>

<p>
             typedef void AAACallbackHandle;
            
</p>
<p>
             AAACallbackHandle is a type for representing the callback
             handle returned to the client when a callback is
             registered.
            
</p>
<a name="anchor20"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.1.11"></a><h3>3.1.11.&nbsp;
Application Identifier</h3>

<p>
             typedef void* AAAApplicationId;
            
</p>
<p>
             AAAApplicationId identifies a particular client session
             to the API. The application id is passed to AAAStartSession(),
             and is attached to incoming messages, to indicate with which
             client session the message is associated. 
            
</p>
<a name="anchor21"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.1.12"></a><h3>3.1.12.&nbsp;
API Return Codes</h3>

<p>The following status codes are returned by functions in the AAA API:
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
        typedef enum {
              AAA_ERR_NOT_FOUND =       -2,
              AAA_ERR_FAILURE =         -1,
              AAA_ERR_SUCCESS =          0,
              AAA_ERR_NOMEM,
              AAA_ERR_PROTO,
              AAA_ERR_SECURITY,
              AAA_ERR_PARAMETER,
              AAA_ERR_CONFIG,
              AAA_ERR_UNKNOWN_CMD,
              AAA_ERR_MISSING_AVP,
              AAA_ERR_ALREADY_INIT,
              AAA_ERR_TIMED_OUT,
              AAA_ERR_CANNOT_SEND_MSG,
              AAA_ERR_ALREADY_REGISTERED,
              AAA_ERR_CANNOT_REGISTER,
              AAA_ERR_NOT_INITIALIZED,
              AAA_ERR_NETWORK_ERROR
        } AAAReturnCode;
</pre></div>
<p>Note that these status codes are separate from the codes returned by
       remote AAA servers. 
</p>
<p>The following is a description of the error codes and the reasons why
       they can be returned:

       </p>
<blockquote class="text"><dl>
<dt>AAA_ERR_NOT_FOUND:</dt>
<dd> This code is returned if a handle or id was
           not found. 
</dd>
<dt>AAA_ERR_FAILURE:</dt>
<dd>
             This code is returned if an unspecified failure
             occurred during an AAA operation.
</dd>
<dt>AAA_ERR_SUCCESS:</dt>
<dd>
             This code is returned if the AAA operation succeeded.
             
</dd>
<dt>AAA_ERR_NOMEM:</dt>
<dd>
             This code is returned if there is not enough memory to execute the operation.
</dd>
<dt>AAA_ERR_PROTO:</dt>
<dd>
             This code is returned if a AAA protocol error occurred.
             
</dd>
<dt>AAA_ERR_SECURITY:</dt>
<dd>
             This code is returned if a security check failed or
             another security error occurred.
</dd>
<dt>AAA_ERR_PARAMETER:</dt>
<dd>
             This code is returned if an invalid parameter was
             passed to an AAA function.
</dd>
<dt>AAA_ERR_CONFIG:</dt>
<dd>
             This code is returned if an error was encountered
             in a configuration file during library initialization.
</dd>
<dt>AAA_ERR_UNKNOWN_CMD:</dt>
<dd>
             This code is returned if the library received a
             AAA command that is not in the set of registered AAA commands.
</dd>
<dt>AAA_ERR_MISSING_AVP:</dt>
<dd>
             This code is returned if a command was received
             without a required AVP.
</dd>
<dt>AAA_ERR_ALREADY_INIT:</dt>
<dd>
             This code is returned if an attempt is made
             to initialize the AAA library when it has already been initialized.
</dd>
<dt>AAA_ERR_TIMED_OUT:</dt>
<dd>
             This code is returned when a network operation
             times out.
</dd>
<dt>AAA_ERR_CANNOT_SEND_MSG:</dt>
<dd>
             This code is returned if the library can't
             send a message. It is also of used to application profile extensions
             that encounter the same error condition.
</dd>
<dt>AAA_ERR_ALREADY_REGISTERED:</dt>
<dd>
             This code is returned by the command
             registration functions if the command was already registered.
</dd>
<dt>AAA_ERR_CANNOT_REGISTER:</dt>
<dd>
             This code is returned by the command
             registration functions if the command could not be registered.
</dd>
<dt>AAA_ERR_NOT_INITIALIZED:</dt>
<dd>
             This code is returned by any function
             in the API except AAAOpen() if the library hasn't been initialized.
</dd>
<dt>AAA_ERR_NETWORK_ERROR:</dt>
<dd>
             This code is returned by any function when an error in 
             networking occurs.
</dd>
</dl></blockquote><p> 
</p>
<p>In addition to returning the error code, functions are required to log
       errors using the platform dependent logging facility.
</p>
<a name="anchor22"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.1.13"></a><h3>3.1.13.&nbsp;
Callback Location Codes</h3>

<p>The following are codes used to indicate where a callback should
         be installed in callback chain for processing:
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
        typedef enum {
                AAA_APP_INSTALL_FIRST,
                AAA_APP_INSTALL_ANYWHERE,
                AAA_APP_INSTALL_LAST
       } AAACallbackLocation;
</pre></div>
<p>Callbacks installed with AAA_APP_INSTALL_FIRST and AAA_APP_INSTALL_LAST
         operate on all commands, callbacks installed with AAA_APP_INSTALL_ANYWHERE
         just operate on the command for which they are installed.
</p>
<p>The codes have the following semantics:

        </p>
<blockquote class="text"><dl>
<dt>AAA_APP_INSTALL_FIRST:</dt>
<dd>
             Install this callback as the first callback in the
             chain. If subsequent callbacks are installed with this code, then
             AAA_ERR_ALREADY_REGISTERED is returned.
</dd>
<dt>AAA_APP_INSTALL_ANYWHERE:</dt>
<dd>
             Install this callback anywhere in the callback
             chain.
</dd>
<dt>AAA_APP_INSTALL_LAST:</dt>
<dd>
             Install this callback as the last callback in the
             chain. If subsequent callbacks are installed with this code, then
             AAA_ERR_ALREADY_REGISTERED is returned.
</dd>
</dl></blockquote>

<a name="anchor23"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.1.14"></a><h3>3.1.14.&nbsp;
AVP Data Type Codes</h3>

<p>The following are AVP data type codes. They correspond directly to the
        AVP data types outline in the Diameter specification <a class='info' href='#RFC3588'>[RFC3588]<span> (</span><span class='info'>Calhoun, Loughney, Guttman, Zorn, and Arkko, &ldquo;Diameter Base Protocol,&rdquo; October&nbsp;2002.</span><span>)</span></a>:
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
        typedef enum {
             AAA_AVP_OCTET_STRING_TYPE,
             AAA_AVP_INTEGER32_TYPE,
             AAA_AVP_INTEGER64_TYPE,
             AAA_AVP_UNSIGNED32_TYPE,
             AAA_AVP_UNSIGNED64_TYPE,
             AAA_AVP_FLOAT32_TYPE,
             AAA_AVP_FLOAT64_TYPE,
        } AAA_AVPDataType;
</pre></div>
<a name="anchor24"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.1.15"></a><h3>3.1.15.&nbsp;
AVP Flags</h3>

<p>The following are used for AVP header flags and for flags
        in the AVP wrapper struct and AVP dictionary definitions. The first four
        correspond to the AVP flags defined in the Diameter specification <a class='info' href='#RFC3588'>[RFC3588]<span> (</span><span class='info'>Calhoun, Loughney, Guttman, Zorn, and Arkko, &ldquo;Diameter Base Protocol,&rdquo; October&nbsp;2002.</span><span>)</span></a>. 
        Some of these are also used in the wrapper struct and dictionary definitions
        also. The last four are used only in  AAA_AVP and AAADictionaryEntry: 
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
        typedef enum {
            AAA_AVP_FLAG_NONE =                 0,
            AAA_AVP_FLAG_MANDATORY =            0x1,
            AAA_AVP_FLAG_RESERVED =             0x2,
            AAA_AVP_FLAG_VENDOR_SPECIFIC =      0x4,
            AAA_AVP_FLAG_UNKNOWN =              0x10000
        } AAA_AVPFlag;
</pre></div>
<p>The semantics of the flags are as follows:

        </p>
<blockquote class="text"><dl>
<dt>AAA_AVP_FLAG_NONE:</dt>
<dd>
             Indicates that no AVP flags are set.
             
</dd>
<dt>AAA_AVP_FLAG_MANDATORY:</dt>
<dd>
             Represents the 'M' flag in
             the Diameter AVP header <a class='info' href='#RFC3588'>[RFC3588]<span> (</span><span class='info'>Calhoun, Loughney, Guttman, Zorn, and Arkko, &ldquo;Diameter Base Protocol,&rdquo; October&nbsp;2002.</span><span>)</span></a>, meaning the AVP is mandatory.
</dd>
<dt>AAA_AVP_FLAG_VENDOR_SPECIFIC:</dt>
<dd>
             Represents the 'V' flag in
             the Diameter AVP header <a class='info' href='#RFC3588'>[RFC3588]<span> (</span><span class='info'>Calhoun, Loughney, Guttman, Zorn, and Arkko, &ldquo;Diameter Base Protocol,&rdquo; October&nbsp;2002.</span><span>)</span></a>, meaning that the AVP is vendor specific.
             If this flag is set, the header will contain a vendor identifier.
</dd>
<dt>AAA_AVP_FLAG_UNKNOWN:</dt>
<dd>
             Indicates that the AVP was not located in the
             AVP dictionary. This flag is only used
             in AAA_AVP.
</dd>
</dl></blockquote>

<a name="anchor25"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.1.16"></a><h3>3.1.16.&nbsp;
Domain Interconnection Types</h3>

<p>The following domain interconnection types are returned by 
       AAAGetDomainInterconnectType(). They indicate the type of
       domain interconnection:
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
        typedef enum {
           AAA_DOMAIN_LOCAL,
           AAA_DOMAIN_PROXY,
           AAA_DOMAIN_BROKER,
           AAA_DOMAIN_FORWARD
        } AAADomainInterconnect;
</pre></div>
<p>The flags have the following semantics:

       </p>
<blockquote class="text"><dl>
<dt>AAA_DOMAIN_LOCAL</dt>
<dd>
             The domain name is for the local domain.
             
</dd>
<dt>AAA_DOMAIN_PROXY</dt>
<dd>
             The domain name is for a proxy domain. A proxy is a server
             that simply forwards the request based on the user's identity or
             through some other means. The routing method used for a proxy is
             the Proxy-State method, requiring routing through a fixed chain of
             proxies <a class='info' href='#RFC3588'>[RFC3588]<span> (</span><span class='info'>Calhoun, Loughney, Guttman, Zorn, and Arkko, &ldquo;Diameter Base Protocol,&rdquo; October&nbsp;2002.</span><span>)</span></a>.
</dd>
<dt>AAA_DOMAIN_BROKER</dt>
<dd>
             The domain name is for a broker domain. A broker is
             a server that provides redirect services, allowing all servers in a
             roaming consortium to interact directly.
</dd>
<dt>AAA_DOMAIN_FORWARD</dt>
<dd>
             The domain name is for a forwarding domain. A forwarding
             domain is a proxy that uses Destination-NAI routing. With Destination-NAI
             routing, there is no set sequence of proxies through which messages
             must be routed <a class='info' href='#RFC3588'>[RFC3588]<span> (</span><span class='info'>Calhoun, Loughney, Guttman, Zorn, and Arkko, &ldquo;Diameter Base Protocol,&rdquo; October&nbsp;2002.</span><span>)</span></a>.
</dd>
</dl></blockquote>

<a name="anchor26"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.1.17"></a><h3>3.1.17.&nbsp;
Message Flags</h3>

<p>The following type is for the AAA message flags. Currently, there
        are no message flags defined in the Diameter protocol <a class='info' href='#RFC3588'>[RFC3588]<span> (</span><span class='info'>Calhoun, Loughney, Guttman, Zorn, and Arkko, &ldquo;Diameter Base Protocol,&rdquo; October&nbsp;2002.</span><span>)</span></a>:
</p>
<p>typedef uint8_t AAAMsgFlag;
</p>
<a name="anchor27"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.1.18"></a><h3>3.1.18.&nbsp;
Result Codes</h3>

<p>Result codes will be returned by the remote server to indicate the success
			or failure of the operation.  Result code values are defined in the 
			Diameter specification. <a class='info' href='#RFC3588'>[RFC3588]<span> (</span><span class='info'>Calhoun, Loughney, Guttman, Zorn, and Arkko, &ldquo;Diameter Base Protocol,&rdquo; October&nbsp;2002.</span><span>)</span></a>  
</p>
<a name="anchor28"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.1.19"></a><h3>3.1.19.&nbsp;
Search Direction Type</h3>

<p>The following type allows the client to specify
          which direction to search for an AVP in the AVP
          list:
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
        typedef enum {
           AAA_FORWARD_SEARCH = 0,
           AAA_BACKWARD_SEARCH
        } AAASearchType;
</pre></div>
<a name="anchor29"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.1.20"></a><h3>3.1.20.&nbsp;
Accounting Types</h3>

<p>The following specifies the type of accounting message:
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
        typedef enum {
                AAA_ACCT_EVENT = 1,
                AAA_ACCT_START = 2,
                AAA_ACCT_INTERIM = 3,
                AAA_ACCT_STOP = 4
        } AAAAcctMessageType;
</pre></div>
<p>The accounting types have the following semantics:

	       </p>
<blockquote class="text"><dl>
<dt>AAA_ACCT_EVENT</dt>
<dd>
	             The event type is used to indicate that a one-time event has occurred.
	             
</dd>
<dt>AAA_ACCT_START</dt>
<dd>
	             The accounting start request is used to initiate an accounting session.
</dd>
<dt>AAA_ACCT_INTERIM</dt>
<dd>
	             Interim messages contains cumulative accounting information for the 
				 existing accounting session (started with an AAA_ACCT_START).  Please 
				 refer to <a class='info' href='#RFC3588'>[RFC3588]<span> (</span><span class='info'>Calhoun, Loughney, Guttman, Zorn, and Arkko, &ldquo;Diameter Base Protocol,&rdquo; October&nbsp;2002.</span><span>)</span></a> for details on the Diameter accounting
				 mechanisms.
</dd>
<dt>AAA_ACCT_STOP</dt>
<dd>
	             The Accounting stop request terminates a session started with AAA_ACCT_START.
</dd>
</dl></blockquote>

<a name="anchor30"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.2"></a><h3>3.2.&nbsp;
Structure Definitions</h3>

<a name="anchor31"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.2.1"></a><h3>3.2.1.&nbsp;
Dictionary Entry Definition</h3>

<p>The following structure is returned by the dictionary entry lookup
        functions. It contains information about a particular AVP in the 
        dictionary:
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
        typedef struct dictionaryEntry {
           AAA_AVPCode     avpCode;
           char*           avpName;
           AAA_AVPDataType avpType;
           AAAVendorId     vendorId;
           AAA_AVPFlag     flags;
        } AAADictionaryEntry;
</pre></div>
<a name="anchor32"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.2.2"></a><h3>3.2.2.&nbsp;
AVP Definition</h3>

<p>The following structure contains a message AVP in parsed form:
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
         typedef struct avp {
                 enum {
                         AAA_RADIUS,
                         AAA_DIAMETER
                 } packetType;
                 AAA_AVPCode code;
                 uint16_t length;
                 AAA_AVPFlag flags;
                 AAA_AVPDataType type;
                 AAAVendorId vendorId;
                 void* data;
         } AAA_AVP;
</pre></div>
<p>The fields have the following definitions:

        </p>
<blockquote class="text"><dl>
<dt>packetType:</dt>
<dd> Indicates whether the message is for Diameter
         or for Radius compatibility. If the AVP is for Radius, then
         the code, length, type, and data fields are the only valid fields
         in the structure; the other fields are all null. 
</dd>
<dt>code:</dt>
<dd> The AVP code. The type of the AVP can be determined
         by matching the AVP code with an AVP description from
         the dictionary.
</dd>
<dt>length:</dt>
<dd> The length of the AVP's data field.
</dd>
<dt>flags:</dt>
<dd> The AVP flags. 
</dd>
<dt>type:</dt>
<dd> The data type of the AVP's data.
</dd>
<dt>vendorId:</dt>
<dd> The vendor id, if the AVP is vendor-specific.
         If the AVP is standardized, the vendorId field is set to
         AAA_NO_VENDOR_ID.
</dd>
<dt>data:</dt>
<dd> The AVP data, in host byte order.
</dd>
</dl></blockquote>

<a name="anchor33"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.2.3"></a><h3>3.2.3.&nbsp;
AVP List</h3>

<p>The following structure is used for representing
         lists of AVPs on the message:
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
         typedef struct avpList{
                // API Private variables. Dependent on link list implementation
         } AAA_AVP_LIST;
</pre></div>
<p>AVPs are kept in ordered lists. 
         The client can use a search direction to indicated
         in which direction to search when trying to find an AVP.
</p>
<a name="anchor34"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.2.4"></a><h3>3.2.4.&nbsp;
Message Definition</h3>

<p>The following structure contains the full AAA message:
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
         typedef struct message {
                 AAAMsgFlag              flags;
                 AAACommandCode          commandCode;
                 AAAVendorId             vendorId;
                 AAAResultCode           resultCode;
                 AAA_IP_ADDR             originator;
                 AAA_IP_ADDR             sender;
                 AAA_AVP_LIST            *avpList;
                 AAA_AVP                 *proxyAVP;
                 AAAMsgIdentifier        identifier;
                 time_t                  secondsTillExpire;
                 time_t                  startTime;
                 void                    *appHandle;
         } AAAMessage;
</pre></div>
<p>The fields have the following definition:

        </p>
<blockquote class="text"><dl>
<dt>flags:</dt>
<dd> The message flags. Currently this field is always zero, since
         there are no flags defined for a Diameter message at this time.
</dd>
<dt>commandCode:</dt>
<dd> The command's message code.
</dd>
<dt>vendorId:</dt>
<dd> The vendor id of the vendor that defined the message.
</dd>
<dt>resultCode:</dt>
<dd> Code indicating the result of the client's request.
         This code is sent by the peer over the wire.
</dd>
<dt>originator:</dt>
<dd> The IP address of the message's originator.
</dd>
<dt>sender:</dt>
<dd> The IP address of the message's previous hop
         sender. This is only the same as originator if no
         proxy or broker peers are being used.
</dd>
<dt>avpList:</dt>
<dd> The list of AVPs in the message.
</dd>
<dt>proxyAVP:</dt>
<dd> The proxy's AVP, if any. Otherwise NULL.
</dd>
<dt>identifier:</dt>
<dd> The message's unique identifier.
</dd>
<dt>secondsTillExpire:</dt>
<dd> Number of seconds until the
         message expires.
</dd>
<dt>startTime:</dt>
<dd> The number of seconds at which the
         message was started.
</dd>
<dt>appHandle:</dt>
<dd> An identifier indicating for which
         client session the message is.
</dd>
</dl></blockquote>

<a name="anchor35"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.3"></a><h3>3.3.&nbsp;
Macros and Preprocessor Definitions</h3>

<p>The following definition reserves the vendor id of 0:
</p>
<p>#define AAA_NO_VENDOR_ID                                0
</p>
<a name="anchor36"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.4"></a><h3>3.4.&nbsp;
Functions</h3>

<a name="anchor37"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.4.1"></a><h3>3.4.1.&nbsp;
Initialization and Configuration</h3>

<p>This section contains definitions that perform initialization
         and configuration of the AAA library.
</p>
<a name="anchor38"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.4.1.1"></a><h3>3.4.1.1.&nbsp;
AAAOpen()</h3>

<p>The following function is used to open and configure the AAA library:
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
      AAAReturnCode AAAOpen(char *configFileName);
</pre></div>
<p>This function must be called before any other AAA function is called.
         Some of the operations that may be performed by AAAOpen() are: opening
         and loading the AVP and vendor dictionaries, opening connections with
         Diameter peers, loading  Diameter extension libraries, and registering
         Diameter callbacks. After AAAOpen() returns, the library must
         be ready for the client to open a session.
</p>
<p>The parameters are:

        </p>
<blockquote class="text"><dl>
<dt>configFileName:</dt>
<dd> The global configuration file name. If NULL or
         the empty string, use the default for this platform. The global
         configuration file must contain the vendor and AVP dictionary
         file names, and may contain other platform-specific 
         information needed to initialize and configure the Diameter peer.
</dd>
</dl></blockquote>

<p>Return values are:

        </p>
<blockquote class="text"><dl>
<dt>AAA_ERR_SUCCESS:</dt>
<dd> If initialization succeeded.
</dd>
<dt>AAA_ERR_ALREADY_INIT:</dt>
<dd> If the library is already initialized.
</dd>
<dt>AAA_ERR_NETWORK_ERROR:</dt>
<dd> If the host name can't be determined.
</dd>
<dt>AAA_ERR_NOMEM:</dt>
<dd> If no memory was available.
</dd>
<dt>AAA_ERR_CONFIG:</dt>
<dd> If processing the dictionary or configuration
         information failed.
</dd>
</dl></blockquote>

<a name="anchor39"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.4.1.2"></a><h3>3.4.1.2.&nbsp;
AAAClose()</h3>

<p>The following function closes the AAA library:
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
      AAAReturnCode
      AAAClose();
</pre></div>
<p>After this function is called, all other AAA functions are
         no longer operative.
</p>
<p>Return values are:

        </p>
<blockquote class="text"><dl>
<dt>AAA_ERR_SUCCESS:</dt>
<dd> If finalization succeeded.
</dd>
<dt>AAA_ERR_NOT_INITIALIZED:</dt>
<dd> If AAA was not initialized.
</dd>
</dl></blockquote>

<a name="anchor40"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.4.1.3"></a><h3>3.4.1.3.&nbsp;
AAAGetDefaultConfigFileName()</h3>

<p>The following returns the default configuration file name on the platform:
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
      const char *
      AAAGetDefaultConfigFileName();
</pre></div>
<p>The return value is a pointer to the full pathname for
         the file. The pointer value should not be deallocated because
         it is constant and does not change.
</p>
<a name="anchor41"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.4.2"></a><h3>3.4.2.&nbsp;
Registering Commands</h3>

<p>The functions in this section are used to register 
         callback functions defined in a Diameter application profile extension
         library. 
         The following typedef defines the interface
         between callback functions and the
         AAA library functions:
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
      typedef AAAReturnCode (*AAACallback)(AAAMessage *message);
</pre></div>
<p>Authors of Diameter extensions must define command callback
         functions having this interface.
</p>
<p>The parameters are:

        </p>
<blockquote class="text"><dl>
<dt>message:</dt>
<dd> The AAAMessage to be processed.
</dd>
</dl></blockquote>

<p>The return value is a status code giving
         the operation status.
</p>
<a name="anchor42"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.4.2.1"></a><h3>3.4.2.1.&nbsp;
AAARegisterCommandCallback()</h3>

<p>The following function is used to register command callbacks
         for processing AAA commands:
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
      AAACallbackHandle *
      AAARegisterCommandCallback(AAACommandCode commandCode,
                                 AAAVendorId vendorId,
                                 char *commandName,
                                 AAAExtensionId extensionId,
                                 AAACallback callback,
                                 AAACallbackLocation position);
</pre></div>
<p>The parameters are:

        </p>
<blockquote class="text"><dl>
<dt>commandCode:</dt>
<dd> The code of the command processed by the callback.
</dd>
<dt>vendorId:</dt>
<dd> The vendor id of the command.
</dd>
<dt>commandName:</dt>
<dd> A pointer to the name of the command.
</dd>
<dt>extensionId:</dt>
<dd> The id of the extension to which this command belongs.
</dd>
<dt>callback:</dt>
<dd> The callback function to perform processing.
</dd>
<dt>position:</dt>
<dd> The position of the callback in the chain.
</dd>
</dl></blockquote>

<p>The return value is a handle used when deregistering the callback,
         or NULL if an error occurred while registering the callback.
</p>
<a name="anchor43"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.4.2.2"></a><h3>3.4.2.2.&nbsp;
AAARegisterNoncommandCallback()</h3>

<p>The following callback registers an AAA callback to process all messages. 
         The callback is not associated with any command, but rather
         will process all messages as they come down the callback chain:
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
      AAACallbackHandle
      AAARegisterNoncommandCallback(AAACallback callback,
                                    AAACallbackLocation position);
</pre></div>
<p>The parameters are:

        </p>
<blockquote class="text"><dl>
<dt>callback:</dt>
<dd> The callback function to perform processing.
</dd>
<dt>position:</dt>
<dd> The position of the callback in the chain.
</dd>
</dl></blockquote>

<p>The return value is a handle used when deregistering the callback,
         or NULL if an error occurred while registering the callback.
</p>
<a name="anchor44"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.4.2.3"></a><h3>3.4.2.3.&nbsp;
AAADeregisterCommandCallback()</h3>

<p>The following function deregisters a command callback:
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
      AAAReturnCode
      AAADeregisterCommandCallback(AAACallbackHandle *handle);
</pre></div>
<p>The parameters are:

        </p>
<blockquote class="text"><dl>
<dt>handle:</dt>
<dd> The handle returned when the callback was registered.
</dd>
</dl></blockquote>

<p>The return values are:

        </p>
<blockquote class="text"><dl>
<dt>AAA_ERR_SUCCESS:</dt>
<dd> Returned upon completion.
</dd>
<dt>AAA_ERR_FAILURE:</dt>
<dd> if the callback is not registered.
</dd>
</dl></blockquote>

<a name="anchor45"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.4.2.4"></a><h3>3.4.2.4.&nbsp;
AAADeregisterNoncommandCallback()</h3>

<p>The following function is used to 
         deregister a noncommand callback:
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
      AAAReturnCode
      AAADeregisterNoncommandCallback(AAACallbackHandle *handle);
</pre></div>
<p>The parameters are:

        </p>
<blockquote class="text"><dl>
<dt>handle:</dt>
<dd> The handle returned when the callback was registered.
</dd>
</dl></blockquote>

<p>Return values are:

        </p>
<blockquote class="text"><dl>
<dt>AAA_ERR_SUCCESS:</dt>
<dd> Returned upon completion.
</dd>
<dt>AAA_ERR_FAILURE:</dt>
<dd> If the callback is not registered.
</dd>
</dl></blockquote>

<a name="anchor46"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.4.2.5"></a><h3>3.4.2.5.&nbsp;
AAARegisterExtension()</h3>

<p>The following function is used to register a Diameter 
         extension id. This function is typically called 
         when registering non-command specific callbacks. Extension ids for
         command-specific callbacks are registered when the callback
         is registered:
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
      AAAReturnCode
      AAARegisterExtension(AAAExtensionId extensionId);
</pre></div>
<p>The parameters are:

        </p>
<blockquote class="text"><dl>
<dt>extensionId:</dt>
<dd> The extension id.
</dd>
</dl></blockquote>

<p>The return codes are:

        </p>
<blockquote class="text"><dl>
<dt>AAA_ERR_SUCCESS:</dt>
<dd> If the registration was successful.
</dd>
<dt>AAA_ERR_NOMEM:</dt>
<dd> if a memory allocation failure occurred.
</dd>
</dl></blockquote>

<a name="anchor47"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.4.3"></a><h3>3.4.3.&nbsp;
Session and Server Management</h3>

<p>The functions in this section allow the
         client to open, close, and register
         sessions, and to obtain server identifiers.
</p>
<a name="anchor48"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.4.3.1"></a><h3>3.4.3.1.&nbsp;
AAAStartSession()</h3>

<p>The following function allows a client to start a session and identify it:
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
      AAAReturnCode
      AAAStartSession(AAASessionId **sessionId,
                      AAAApplicationId appHandle,
                      char *userName,
                      AAACallback abortCallback);
</pre></div>
<p>The parameters are:

        </p>
<blockquote class="text"><dl>
<dt>sessionId:</dt>
<dd> On return, a pointer to the session id for this session.
</dd>
<dt>appHandle:</dt>
<dd> An identifier for the client application starting the 
         session. This identifier is attached to messages so that the
         client callbacks can tell which messages belong to it.
</dd>
<dt>userName:</dt>
<dd>- The NAI of the user.
</dd>
<dt>abortCallback:</dt>
<dd> A function to be called if this session is aborted
         by the server.
</dd>
</dl></blockquote>

<p>Return values are:

        </p>
<blockquote class="text"><dl>
<dt>AAA_ERR_SUCCESS:</dt>
<dd> If the session was successfully started.
</dd>
<dt>AAA_ERR_NOMEM:</dt>
<dd> If a memory allocation failure occurred.
</dd>
</dl></blockquote>

<a name="anchor49"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.4.3.2"></a><h3>3.4.3.2.&nbsp;
AAARegisterPeerSession()</h3>

<p>The following function allows a client to register
         a peer session that it has discovered through 
         some other means, for example, by receiving
         an unsolicited message.
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
      AAAReturnCode
      AAARegisterPeerSession(AAASessionId **sessionId,
                             AAAApplicationId *appHandle,
                             AAAMessage *message,
                             char *userName,
                             char *hostName);
</pre></div>
<p>The parameters are:

        </p>
<blockquote class="text"><dl>
<dt>sessionId:</dt>
<dd> On return, a pointer to the local session id for the session.
</dd>
<dt>appHandle:</dt>
<dd> An identifier for the client application starting the 
         session. This identifier is attached to messages so that the
         client callbacks can tell which messages belong to it.
</dd>
<dt>message:</dt>
<dd> The message from the peer containing the session id.
</dd>
<dt>userName:</dt>
<dd>- The NAI of the user.
</dd>
<dt>hostName:</dt>
<dd> The originator of the Diameter message
</dd>
</dl></blockquote>

<p>Return values are:

        </p>
<blockquote class="text"><dl>
<dt>AAA_ERR_SUCCESS:</dt>
<dd> If the session was successfully registered.
</dd>
<dt>AAA_ERR_NOMEM:</dt>
<dd> If a memory allocation failure occurred.
</dd>
</dl></blockquote>

<a name="anchor50"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.4.3.3"></a><h3>3.4.3.3.&nbsp;
AAAEndSession()</h3>

<p>The following function, sent by a client, terminates a session:
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
      AAAReturnCode
      AAAEndSession(AAASessionId *sessionId);
</pre></div>
<p>The parameters are:

        </p>
<blockquote class="text"><dl>
<dt>sessionId:</dt>
<dd> A pointer to the session id for the session.
</dd>
</dl></blockquote>

<p>Return values are:

        </p>
<blockquote class="text"><dl>
<dt>AAA_ERR_SUCCESS:</dt>
<dd> If the session was successfully closed.
</dd>
<dt>AAA_ERR_NOT_FOUND:</dt>
<dd> If the handle is invalid.
</dd>
</dl></blockquote>

<a name="anchor51"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.4.3.4"></a><h3>3.4.3.4.&nbsp;
AAAAbortSession()</h3>

<p>The following function, sent by the server, terminates 
         a session:
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
      AAAReturnCode
      AAAAbortSession(AAASessionId *sessionId);
</pre></div>
<p>The parameters are:
         
        </p>
<blockquote class="text"><dl>
<dt>sessionId:</dt>
<dd> A pointer to the session id for the session.
</dd>
</dl></blockquote>

<p>Return values are:
         
        </p>
<blockquote class="text"><dl>
<dt>AAA_ERR_SUCCESS:</dt>
<dd> If the session was successfully closed.
</dd>
<dt>AAA_ERR_NOT_FOUND:</dt>
<dd> If the handle is invalid.
</dd>
</dl></blockquote>

<a name="anchor52"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.4.3.5"></a><h3>3.4.3.5.&nbsp;
AAALookupServer()</h3>

<p>The function looks up the AAA server based on IP address and port number.
         Server connections are created from the configuration file:
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
      AAAServer *
      AAALookupServer(AAA_IP_ADDR ipAddr);
</pre></div>
<p>The parameters are:
         
        </p>
<blockquote class="text"><dl>
<dt>ipAddr:</dt>
<dd> The IP address/Port/Family of the server.
</dd>
</dl></blockquote>

<p>The return value is either a valid server pointer or the 
         NULL if the server can't be found.
</p>
<a name="anchor53"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.4.3.6"></a><h3>3.4.3.6.&nbsp;
AAASetSessionMessageTimeout()</h3>

<p>The following function sets the timeout, in seconds, for all 
         AAAMessages in a particular session:
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
      AAAReturnCode
      AAASetSessionMessageTimeout(AAASessionId *id,
                                  time_t timeout);
</pre></div>
<p>The parameters are:
         
        </p>
<blockquote class="text"><dl>
<dt>id:</dt>
<dd> The session id for the session whose timeout should be changed.
</dd>
<dt>timeout:</dt>
<dd> The session timeout. The default timeout is 120 seconds.
</dd>
</dl></blockquote>

<p>The return values are:
         
        </p>
<blockquote class="text"><dl>
<dt>AAA_ERR_SUCCESS:</dt>
<dd> If setting the timeout succeeded.
</dd>
<dt>AAA_ERR_FAILURE:</dt>
<dd> If the setting the timeout failed.
</dd>
</dl></blockquote>

<a name="anchor54"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.4.3.7"></a><h3>3.4.3.7.&nbsp;
AAAGetDomainInterconnectType()</h3>

<p>The following function returns the domain interconnect type for
         a particular domain name and type of service:
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
      AAADomainInterconnect
      AAAGetDomainInterconnectType(AAAMessage *message,
                                   char *domainName,
                                   char *type);
</pre></div>
<p>The parameters are:

        </p>
<blockquote class="text"><dl>
<dt>domainName:</dt>
<dd> The name of the domain.
</dd>
<dt>type:</dt>
<dd> The type of service. This must be one of the strings "LOCAL",
         "PROXY", or "BROKER".
</dd>
</dl></blockquote>

<p>The return values are:
         
        </p>
<blockquote class="text"><dl>
<dt>AAA_ERR_SUCCESS:</dt>
<dd> If the domain interconnect type was retrieved.
</dd>
<dt>AAA_ERR_FAILURE:</dt>
<dd> If the command failed.
</dd>
</dl></blockquote>

<a name="anchor55"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.4.4"></a><h3>3.4.4.&nbsp;
Dictionary Lookup</h3>

<p>The functions in this section are used to look up AVPs
         and commands in the dictionary. The client is responsible
         for supplying the structure memory into which the
         dictionary information is copied.
</p>
<a name="anchor56"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.4.4.1"></a><h3>3.4.4.1.&nbsp;
AAADictionaryEntryFromAVPCode()</h3>

<p>This function looks up a dictionary entry using a command code and a
         vendor id:
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
      AAAReturnCode
      AAADictionaryEntryFromAVPCode(AAA_AVPCode avpCode,
                                    AAAVendorId vendorId,
                                    AAADictionaryEntry *Entry);
</pre></div>
<p>The parameters are:     
         
        </p>
<blockquote class="text"><dl>
<dt>avpCode:</dt>
<dd> The code number of the AVP.
</dd>
<dt>vendorId:</dt>
<dd> The vendor id of the AVP.
</dd>
<dt>Entry:</dt>
<dd> an AAADictionaryEntry structure for returning the entry.
</dd>
</dl></blockquote>

<p>The return value is one of:
         
        </p>
<blockquote class="text"><dl>
<dt>AAA_ERR_SUCCESS:</dt>
<dd> If the query succeeded.
</dd>
<dt>AAA_ERR_FAILURE:</dt>
<dd> If no matching dictionary entry was found.
</dd>
</dl></blockquote>

<a name="anchor57"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.4.4.2"></a><h3>3.4.4.2.&nbsp;
AAADictionaryEntryFromName()</h3>

<p>This function looks up a dictionary entry using command code 
         name and vendor id:
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
      AAAReturnCode
      AAADictionaryEntryFromName(char *avpName,
                                 AAAVendorId vendorId,
                                 AAADictionaryEntry *Entry);
</pre></div>
<p>The parameters are:
         
        </p>
<blockquote class="text"><dl>
<dt>avpName:</dt>
<dd> The name of the AVP.
</dd>
<dt>vendorId:</dt>
<dd> The vendor id of the AVP.
</dd>
<dt>Entry:</dt>
<dd> an AAADictionaryEntry structure for returning the entry.
</dd>
</dl></blockquote>

<p>The return value is one of:
         
        </p>
<blockquote class="text"><dl>
<dt>AAA_ERR_SUCCESS:</dt>
<dd> If the query succeeded.
</dd>
<dt>AAA_ERR_FAILURE:</dt>
<dd> If no matching dictionary entry was found.
</dd>
</dl></blockquote>

<a name="anchor58"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.4.4.3"></a><h3>3.4.4.3.&nbsp;
AAAValueFromName()</h3>

<p>This function looks up an AVP value using the AVP name and vendor name:
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
      AAAValue AAAValueFromName(char *avpName,
                                char *vendorName,
                                char *valueName);
</pre></div>
<p>The parameters are:
         
        </p>
<blockquote class="text"><dl>
<dt>avpName:</dt>
<dd> The name of the AVP.
</dd>
<dt>vendorName:</dt>
<dd> The name of the vendor.
</dd>
<dt>valueName:</dt>
<dd> The name of the value.
</dd>
</dl></blockquote>

<p>The return value is the id of the AVP, or AAA_ERR_NOT_FOUND if no
         match was found.
</p>
<a name="anchor59"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.4.4.4"></a><h3>3.4.4.4.&nbsp;
AAAValueFromAVPCode()</h3>

<p>This function looks up an AVP value using the AVP id and vendor id, 
         and the value name:
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
      AAAValue AAAValueFromAVPCode(AAA_AVPCode avpCode,
                                   AAAVendorId vendorId,
                                   char *valueName);
</pre></div>
<p>The parameters are:
         
        </p>
<blockquote class="text"><dl>
<dt>avpCode:</dt>
<dd> The code of the AVP.
</dd>
<dt>vendorId:</dt>
<dd> The id of the vendor.
</dd>
<dt>valueName:</dt>
<dd> The name of the value.
</dd>
</dl></blockquote>

<p>The return value is id of the AVP, or AAA_ERR_NOT_FOUND if no
         match was found.
</p>
<a name="anchor60"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.4.4.5"></a><h3>3.4.4.5.&nbsp;
AAALookupValueNameUsingValue()</h3>

<p>This function returns the AVP value name:
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
      const char *
      AAALookupValueNameUsingValue(AAA_AVPCode avpCode,
                                   AAAVendorId vendorId,
                                   AAAValue value);
</pre></div>
<p>The parameters are:
         
        </p>
<blockquote class="text"><dl>
<dt>avpCode:</dt>
<dd> The code of the AVP.
</dd>
<dt>vendorId:</dt>
<dd> The id of the vendor.
</dd>
<dt>value:</dt>
<dd> The value.
</dd>
</dl></blockquote>

<p>The value name is returned, or NULL if
         no match occurred.
</p>
<a name="anchor61"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.4.4.6"></a><h3>3.4.4.6.&nbsp;
AAAGetCommandCode()</h3>

<p>This function returns the command code and vendor id based on a string:
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
      AAAReturnCode
      AAAGetCommandCode(char *commandName,
                        AAACommandCode *commandCode,
                        AAAVendorId *vendorId);
</pre></div>
<p>The parameters are:
         
        </p>
<blockquote class="text"><dl>
<dt>commandName:</dt>
<dd> A string containing the command name.
</dd>
<dt>commandCode:</dt>
<dd> Pointer that on return holds the
         command code if the command was found.
</dd>
<dt>vendorId:</dt>
<dd> Pointer that on return holds the
         vendor id if the command was found.
</dd>
</dl></blockquote>

<p>The function returns AAA_ERR_SUCCESS when a command has been successfully
         retrieved, otherwise AAA_UNKNOWN_CMD is returned.
</p>
<a name="anchor62"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.4.5"></a><h3>3.4.5.&nbsp;
Message Management</h3>

<p>The functions in this section allow the client to
         create messages, add AVPs, and traverse AVP lists.
</p>
<a name="anchor63"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.4.5.1"></a><h3>3.4.5.1.&nbsp;
AAANewMessage()</h3>

<p>This function allocates an AAAMessage and returns a pointer to it. 
         If a command code is provided, this function adds the command code AVP.
         If the session identifier handle is provided, 
         the Session-Id AVP is also added. Lastly, if this message is
         allocated in response to a request, the request's message can be provided,  
         and the new message is initialized to match the request, for
         fields such as the identifier, the server identifier, etc. If this is
         a new message, the request parameter is NULL:
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
      AAAMessage *
      AAANewMessage(AAACommandCode commandCode,
                    AAAVendorId vendorId,
                    AAASessionId *sessionId,
                    AAAExtensionId extensionId,
                    AAAMessage *request);
</pre></div>
<p>The parameters are:
         
        </p>
<blockquote class="text"><dl>
<dt>commandCode:</dt>
<dd> The command code.
</dd>
<dt>vendorId:</dt>
<dd> The vendor identifier.
</dd>
<dt>sessionId:</dt>
<dd> Session identifier.
</dd>
<dt>extensionId:</dt>
<dd> The extension identifier.
</dd>
<dt>request:</dt>
<dd> A pointer to a request message, if this message is
         being allocated in response to a request.
</dd>
</dl></blockquote>

<p>The function returns a pointer to the message or NULL if a 
         failure occurred.
</p>
<a name="anchor64"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.4.5.2"></a><h3>3.4.5.2.&nbsp;
AAAFreeMessage()</h3>

<p>This function frees a message allocated through 
         AAANewMessage():
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
      AAAReturnCode
      AAAFreeMessage(AAAMessage **message);
</pre></div>
<p>The parameters are:
         
        </p>
<blockquote class="text"><dl>
<dt>message:</dt>
<dd> A pointer to a pointer to the allocated message.
</dd>
</dl></blockquote>

<p>The return value is the AAA status code AAA_ERR_SUCCESS.
</p>
<a name="anchor65"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.4.5.3"></a><h3>3.4.5.3.&nbsp;
AAARespondToMessage()</h3>

<p>This function is called to set the AAA Message                  
         to the appropriate values, and to inform the library            
         that this message is a locally generated response               
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
      AAAReturnCode
      AAARespondToMessage(AAAMessage* message,
                          AAACommandCode commandCode,
                          AAAVendorId vendorId,
                          AAAResultCode resultCode);
</pre></div>
<p>The parameters are:
         
        </p>
<blockquote class="text"><dl>
<dt>message:</dt>
<dd> The AAAMessage to respond to.
</dd>
<dt>commandCode:</dt>
<dd> The command code of the response.
</dd>
<dt>vendorId:</dt>
<dd> The vendor identifier (of the command code).
</dd>
<dt>resultCode:</dt>
<dd> The result code of the response.
</dd>
</dl></blockquote>

<p>The function returns AAA_ERR_SUCCESS upon completion, or AAA_ERR_PARAMETER
         if a NULL pointer was provided.
</p>
<a name="anchor66"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.4.5.4"></a><h3>3.4.5.4.&nbsp;
AAAAddProxyState()</h3>

<p>This function will add a Proxy-State AVP to                     
         a message, that contains the Fully Qualified Domain Name (FQDN)
         of the source of the message.
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
      AAAReturnCode
      AAAAddProxyState(AAAMessage *message);
</pre></div>
<p>The parameters are:
         
        </p>
<blockquote class="text"><dl>
<dt>message:</dt>
<dd> The AAAMessage to add state to.
</dd>
</dl></blockquote>

<p>The function returns AAA_ERR_SUCCESS upon completion, or
         AAA_ERR_FAILURE if an error occurred.
</p>
<a name="anchor67"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.4.5.5"></a><h3>3.4.5.5.&nbsp;
AAACreateAVP()</h3>

<p>This function creates an AVP and returns a pointer to it. The AVP
         is initialized from the arguments:
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
      AAAReturnCode
      AAACreateAVP(AAA_AVP **avp,
                   AAA_AVPCode code,
                   AAA_AVPFlag flags,
                   AAAVendorId vendorId,
                   char *data,
                   size_t length);
</pre></div>
<p>The parameters are:
         
        </p>
<blockquote class="text"><dl>
<dt>avp:</dt>
<dd> On return, contains a pointer to the allocated AVP, or NULL if
         no AVP was allocated. 
</dd>
<dt>code:</dt>
<dd> The AVP's code.
</dd>
<dt>flags:</dt>
<dd> Any AVP flags that must be passed.
</dd>
<dt>vendorId:</dt>
<dd> The vendor id of the AVP. If no vendor id, then
         AAA_NO_VENDOR_ID.
</dd>
<dt>data:</dt>
<dd> A buffer containing the AVP data.
</dd>
<dt>length:</dt>
<dd> The length of the data buffer.
</dd>
</dl></blockquote>

<p>Return values are:
         
        </p>
<blockquote class="text"><dl>
<dt>AAA_ERR_SUCCESS:</dt>
<dd> Upon success.
</dd>
<dt>AAA_ERR_PARAMETER:</dt>
<dd> If an invalid parameter was passed.
</dd>
<dt>AAA_ERR_PROTO:</dt>
<dd> If a protocol error occurred.
</dd>
<dt>AAA_ERR_NOMEM:</dt>
<dd> Indicating  a memory failure.
</dd>
</dl></blockquote>

<a name="anchor68"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.4.5.6"></a><h3>3.4.5.6.&nbsp;
AAACreateAndAddAVPToList()</h3>

<p>This function creates an AVP and adds it to an AVP list. It returns
         a pointer to the list in the avpList argument. If the avpList is NULL
         a new list is created. The new AVP is always added to the end of
         the list. The AVP is initialized from the arguments:
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
      AAAReturnCode
      AAACreateAndAddAVPToList(AAA_AVP_LIST **avpList,
                               AAA_AVPCode code,
                               AAA_AVPFlag flags,
                               AAAVendorId vendorId,
                               char *data,
                               size_t length);
</pre></div>
<p>The parameters are:
         
        </p>
<blockquote class="text"><dl>
<dt>avpList:</dt>
<dd> The list to which the AVP should be added.
</dd>
<dt>code:</dt>
<dd> The AVP's code.
</dd>
<dt>flags:</dt>
<dd> Any AVP flags that must be passed.
</dd>
<dt>vendorId:</dt>
<dd> The vendor id of the AVP. If no vendor id, then
         AAA_NO_VENDOR_ID.
</dd>
<dt>data:</dt>
<dd> A buffer containing the AVP data.
</dd>
<dt>length:</dt>
<dd> The length of the data buffer.
</dd>
</dl></blockquote>

<p>Return values are:
         
        </p>
<blockquote class="text"><dl>
<dt>AAA_ERR_SUCCESS:</dt>
<dd> Upon success.
</dd>
<dt>AAA_ERR_PARAMETER:</dt>
<dd> If an invalid parameter was passed.
</dd>
<dt>AAA_ERR_NOMEM:</dt>
<dd> Indicating  a memory failure.
</dd>
</dl></blockquote>

<a name="anchor69"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.4.5.7"></a><h3>3.4.5.7.&nbsp;
AAAAddAVPToList()</h3>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
      AAAReturnCode
      AAAAddAVPToList(AAA_AVP_LIST **avpList,
                      AAA_AVP *avp, AAA_AVP *position);
</pre></div>
<p>Insert the AVP avp into this avpList after position. If position is
         NULL, the AVP is added to the beginning of the list.
</p>
<p>If *avpList is NULL, a list will be allocated, and *avpList will point
         to it.
</p>
<p>The parameters are:
         
        </p>
<blockquote class="text"><dl>
<dt>avpList:</dt>
<dd> Pointer to a pointer for list. If *avpList is NULL, list memory is
         allocated.
</dd>
<dt>avp:</dt>
<dd> AAA_AVP to add to list.
</dd>
<dt>position:</dt>
<dd> AAA_AVP pointer to add data after, or NULL if the new AVP
         should go at the beginning of the list.
</dd>
</dl></blockquote>

<p>The return value is one of:
         
        </p>
<blockquote class="text"><dl>
<dt>AAA_ERR_SUCCESS:</dt>
<dd> Upon success.
</dd>
<dt>AAA_ERR_PARAMETER:</dt>
<dd> If an invalid parameter was passed.
</dd>
<dt>AAA_ERR_NOMEM:</dt>
<dd> Indicates a memory failure.
</dd>
</dl></blockquote>

<a name="anchor70"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.4.5.8"></a><h3>3.4.5.8.&nbsp;
AAAFindMatchingAVP()</h3>

<p>This function finds an AVP with matching code and vendor id. If none match,
         the function returns NULL:
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
      AAA_AVP *
      AAAFindMatchingAVP(AAA_AVP_LIST *avpList,
                         AAA_AVP *startAvp,
                         AAA_AVPCode avpCode,
                         AAAVendorId vendorId,
                         AAASearchType searchType);
</pre></div>
<p>The parameters are:
         
        </p>
<blockquote class="text"><dl>
<dt>avp:</dt>
<dd> A pointer to the head of the AVP list.
</dd>
<dt>avpCode:</dt>
<dd> The code of the sought after AVP.
</dd>
<dt>vendorId:</dt>
<dd> The vendor id of the sought after AVP.
</dd>
</dl></blockquote>

<p>The return value is a pointer to the found AVP, or NULL if none 
         is found.
</p>
<a name="anchor71"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.4.5.9"></a><h3>3.4.5.9.&nbsp;
AAAJoinAVPLists()</h3>

<p>The following function joins together two AVP lists:
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
      AAAReturnCode AAAJoinAVPLists(AAA_AVP_LIST *dest,
                                    AAA_AVP_LIST *source,
                                    AAA_AVP      *position);
</pre></div>
<p>The parameters are:
         
        </p>
<blockquote class="text"><dl>
<dt>dest:</dt>
<dd> The destination list  (All of the AVPs in source will be moved here).
</dd>
<dt>source:</dt>
<dd> The source list to be added to dest.
</dd>
<dt>position:</dt>
<dd> The position to add the AVPs to, or NULL for the beginning of the list.
</dd>
</dl></blockquote>

<p>The return value is one of:
         
        </p>
<blockquote class="text"><dl>
<dt>AAA_ERR_SUCCESS:</dt>
<dd> Upon success.
</dd>
<dt>AAA_ERR_PARAMETER:</dt>
<dd> If an invalid parameter was passed.
</dd>
</dl></blockquote>

<a name="anchor72"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.4.5.10"></a><h3>3.4.5.10.&nbsp;
AAARemoveAVPFromList()</h3>

<p>This function removes an AVP from a list:
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
      AAAReturnCode
      AAARemoveAVPFromList(AAA_AVP_LIST *avpList,
                           AAA_AVP *avp);
</pre></div>
<p>The parameters are:
         
        </p>
<blockquote class="text"><dl>
<dt>avpList:</dt>
<dd> The head of the list from which to 
         remove the AVP. 
</dd>
<dt>avp:</dt>
<dd> Contains a pointer to the AVP to remove. 
</dd>
</dl></blockquote>

<p>The return value is one of:
         
        </p>
<blockquote class="text"><dl>
<dt>AAA_ERR_SUCCESS:</dt>
<dd> Upon success.
</dd>
<dt>AAA_ERR_PARAMETER:</dt>
<dd> If an invalid parameter was passed.
</dd>
</dl></blockquote>

<a name="anchor73"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.4.5.11"></a><h3>3.4.5.11.&nbsp;
AAAFreeAVP()</h3>

<p>The function frees an AVP:
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
      AAAReturnCode
      AAAFreeAVP(AAA_AVP **avp);
</pre></div>
<p>The parameters are:
         
        </p>
<blockquote class="text"><dl>
<dt>avp:</dt>
<dd> Contains a pointer to a pointer to the AVP to free.
</dd>
</dl></blockquote>

<p>The return value is one of:
         
        </p>
<blockquote class="text"><dl>
<dt>AAA_ERR_SUCCESS:</dt>
<dd> Upon success.
</dd>
<dt>AAA_ERR_PARAMETER:</dt>
<dd> If an invalid parameter was passed.
</dd>
</dl></blockquote>

<a name="anchor74"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.4.5.12"></a><h3>3.4.5.12.&nbsp;
AAAGetFirstAVP()</h3>

<p>This function returns a pointer to the first AVP in the list:
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
      AAA_AVP *
      AAAGetFirstAVP(AAA_AVP_LIST *avpList);
</pre></div>
<p>The parameters are:
         
        </p>
<blockquote class="text"><dl>
<dt>avpList:</dt>
<dd> A pointer to the list.
</dd>
</dl></blockquote>

<p>The return value is a pointer to the found AVP, 
         or NULL if none is found.
</p>
<a name="anchor75"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.4.5.13"></a><h3>3.4.5.13.&nbsp;
AAAGetLastAVP()</h3>

<p>This function returns a pointer to the last AVP in the list:
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
      AAA_AVP *
      AAAGetLastAVP(AAA_AVP_LIST *avpList);
</pre></div>
<p>The parameters are:

        </p>
<blockquote class="text"><dl>
<dt>avpList:</dt>
<dd> A pointer to the list.
</dd>
</dl></blockquote>

<p>The function returns a pointer to the found AVP, 
         or NULL if none is found.
</p>
<a name="anchor76"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.4.5.14"></a><h3>3.4.5.14.&nbsp;
AAAGetNextAVP()</h3>

<p>This function returns a pointer to the next AVP in the list.
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
      AAA_AVP *
      AAAGetNextAVP(AAA_AVP *avp);
</pre></div>
<p>The parameters are:
         
        </p>
<blockquote class="text"><dl>
<dt>avp:</dt>
<dd> A pointer to the AVP prior to the one sought.
         It is assumed that AAA_AVP has internal private members that keep track of
         the next AAA_AVP element in the list.
</dd>
</dl></blockquote>

<p>The return value is the next AVP in the list, or NULL if
         the parameter is the last element in the list.
</p>
<a name="anchor77"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.4.5.15"></a><h3>3.4.5.15.&nbsp;
AAAGetPrevAVP()</h3>

<p>This function returns a pointer to the previous AVP in
         the list. It is assumed that AAA_AVP has internal private members 
         that keep track of the previous AAA_AVP element in the list.
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
      AAA_AVP *
      AAAGetPrevAVP(AAA_AVP *avp);
</pre></div>
<p>The parameters are:
         
        </p>
<blockquote class="text"><dl>
<dt>avp:</dt>
<dd> A pointer to the AVP after the one sought.
</dd>
</dl></blockquote>

<p>The return value is the previous AVP in the list or
         NULL if the parameter is the first element in the list.
</p>
<a name="anchor78"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.4.5.16"></a><h3>3.4.5.16.&nbsp;
AAAFreeAVPList()</h3>

<p>This function frees an AVP list structure including all contained AVPs
         if there are any. If the list is empty then only the AVP list data structure 
         itself is deleted. If successful, the list will point to NULL on return.
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
      AAAReturnCode
      AAAFreeAVPList(AAA_AVP_LIST **avpList);
</pre></div>
<p>The parameters are:
         
        </p>
<blockquote class="text"><dl>
<dt>avpList:</dt>
<dd> The list to be freed.
</dd>
</dl></blockquote>

<p>Return values are:
         
        </p>
<blockquote class="text"><dl>
<dt>AAA_ERR_SUCCESS:</dt>
<dd> Upon success.
</dd>
<dt>AAA_ERR_PARAMETER:</dt>
<dd> If an invalid parameter was passed.
</dd>
</dl></blockquote>

<a name="anchor79"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.4.5.17"></a><h3>3.4.5.17.&nbsp;
AAAConvertAVPToString()</h3>

<p>This function converts the data in the AVP to a format suitable
         for log or display functions.
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
      char *
      AAAConvertAVPToString(AAA_AVP *avp,
                            char *dest,
                            size_t destLen);
</pre></div>
<p>The parameters are:
         
        </p>
<blockquote class="text"><dl>
<dt>avp:</dt>
<dd> The AVP to display.
</dd>
<dt>dest:</dt>
<dd> A used supplied destination buffer.
</dd>
<dt>destLen:</dt>
<dd> The length of the user supplied buffer.
</dd>
</dl></blockquote>

<p>The return value is the passed in destination buffer.
</p>
<a name="anchor80"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.4.5.18"></a><h3>3.4.5.18.&nbsp;
AAASetMessageResultCode()</h3>

<p>This function decapsulates an encapsulated AVP,
         and populates the list with the correct pointers.
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
      AAAResultCode
      AAASetMessageResultCode(AAAMessage *message,
                              AAAResultCode resultCode);
</pre></div>
<p>The parameters are:
         
        </p>
<blockquote class="text"><dl>
<dt>message:</dt>
<dd> A pointer to the allocated message.
</dd>
<dt>resultCode:</dt>
<dd> The AAA Result Code
</dd>
</dl></blockquote>

<p> The return value is one of:
         
        </p>
<blockquote class="text"><dl>
<dt>AAA_ERR_SUCCESS:</dt>
<dd> Upon success.
</dd>
<dt>AAA_ERR_PARAMETER:</dt>
<dd> If an invalid parameter was passed.
</dd>
</dl></blockquote>

<a name="anchor81"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.4.6"></a><h3>3.4.6.&nbsp;
Message Control</h3>

<p>The following functions allow the client to direct
         a message to a particular server, determine 
         the server for a message, etc.
</p>
<a name="anchor82"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.4.6.1"></a><h3>3.4.6.1.&nbsp;
AAASetServer()</h3>

<p>This function sets the server to which the
         message is sent:
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
      AAAReturnCode
      AAASetServer(AAAMessage *message,
                   AAA_IP_ADDR host);
</pre></div>
<p>The parameters are:
         
        </p>
<blockquote class="text"><dl>
<dt>message:</dt>
<dd> The message to be sent.
</dd>
<dt>host:</dt>
<dd> The IP address / port / family of the server.
</dd>
</dl></blockquote>

<p>The return value is:
         
        </p>
<blockquote class="text"><dl>
<dt>AAA_ERR_SUCCESS:</dt>
<dd> If the server was found.
</dd>
<dt>AAA_ERR_NOT_FOUND:</dt>
<dd> If the server was not found.
</dd>
</dl></blockquote>

<a name="anchor83"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.4.6.2"></a><h3>3.4.6.2.&nbsp;
AAASendMessage()</h3>

<p>The following function transmitts a message. It will be sent
         to the server based on the routing criteria defined in <a class='info' href='#RFC3588'>[RFC3588]<span> (</span><span class='info'>Calhoun, Loughney, Guttman, Zorn, and Arkko, &ldquo;Diameter Base Protocol,&rdquo; October&nbsp;2002.</span><span>)</span></a>.
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
      AAAReturnCode
      AAASendMessage(AAAMessage *message);
</pre></div>
<p>The parameter is the message to send.
</p>
<p>The return codes are:
         
        </p>
<blockquote class="text"><dl>
<dt>AAA_ERR_SUCCESS:</dt>
<dd> Upon completion.
</dd>
<dt>AAA_ERR_FAILURE:</dt>
<dd> If an error occurred.
</dd>
</dl></blockquote>

<a name="anchor84"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.4.7"></a><h3>3.4.7.&nbsp;
Accounting</h3>

<p>The following functions allow the client to direct
         a message to a particular server, determine 
         the server for a message, etc.
</p>
<a name="anchor85"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.4.7.1"></a><h3>3.4.7.1.&nbsp;
AAASendAcctRequest()</h3>

<p>The following function sends an accounting message to an accounting
         server.
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
      AAAReturnCode
      AAASendAcctRequest(AAASessionId *aaaSessionId,
                         AAAExtensionId extensionId,
                         AAA_AVP_LIST *acctAvpList,
                         AAAAcctMessageType msgType);
</pre></div>
<p>The parameters are:
         
        </p>
<blockquote class="text"><dl>
<dt>aaaSessionId:</dt>
<dd> The session id that this accounting data corresponds to.
</dd>
<dt>extensionId:</dt>
<dd> The extension type associated with this accounting message.
</dd>
<dt>acctAvpList:</dt>
<dd> A list of AVPs to send in the accounting message.
</dd>
<dt>msgType:</dt>
<dd> The type of accounting message.
</dd>
</dl></blockquote>

<p>The return codes are:
         
        </p>
<blockquote class="text"><dl>
<dt>AAA_ERR_SUCCESS:</dt>
<dd> Upon completion.
</dd>
<dt>AAA_ERR_PARAMETER:</dt>
<dd> If a parameter is invalid.
</dd>
</dl></blockquote>

<a name="anchor86"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.5"></a><h3>3.5.&nbsp;
Implementation Notes</h3>

<p>The following are some implementation notes that library designers
         may want to keep in mind.
</p>
<a name="anchor87"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.6"></a><h3>3.6.&nbsp;
Grouped AVPs</h3>

<p>In order to create grouped AVPs, an application creates an AAA_AVP_LIST
         that is not attached to an AAAMessage structure (also known as an orphaned
         AAA_AVP_LIST). All of the necessary AVPs within the Group are added to
         the orphaned AAA_AVP_LIST using the existing list manipulation functions.
         Lastly, the grouped AVP is added to the AAAMessage structure.
</p>
<p>The following is an example that adds a Proxy-State Grouped AVP to an
         existing AAAMessage structure.
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>

     addProxyState(AAAMessage *message, ipaddr_t *ourAddress,
         void *state, size_t stateLen)
     {
             AAA_AVP_LIST *avpList = NULL;

             /*
              * Add the Proxy-Address AVP to the AAAList
              */
             if (AAACreateAndAddAVPToList(&amp;avpList,
                 DIAM_AVP_PROXY_ADDRESS, AAA_AVPI_FLAG_NONE,
                 NO_VENDOR_ID, (char *)ourAddress,
                 sizeof (ipaddr_t))) {
                     loggerSyslog(LOG_AVP_PROBLEMS,
                         "Unable to add Proxy-Address AVP");
                     return (AAA_ERR_FAILURE);
             }
             /*
              * Now we add the Proxy-Info AVP to the AAAList
              */
             if (AAACreateAndAddAVPToList(&amp;avpList,
                 DIAM_AVP_PROXY_INFO, AAA_AVPI_FLAG_NONE,
                 NO_VENDOR_ID, state, stateLen)) {
                     loggerSyslog(LOG_AVP_PROBLEMS,
                         "Unable to add Proxy-Info AVP");
                     return (AAA_ERR_FAILURE);
             }
             /*
              * Now the AAAList is added to the AAAMessage as
              * a Proxy-State AVP.
              */
             if (AAACreateAndAddAVPToList(&amp;message-&gt;avpList,
                 DIAM_AVP_PROXY_STATE, AAA_AVPI_FLAG_NONE,
                 NO_VENDOR_ID, (char *)avpList,
                 AAA_AVP_GROUPED_LENGTH)) {
                     loggerSyslog(LOG_AVP_PROBLEMS,
                         "Unable to add Proxy-State AVP");
                     return (AAA_ERR_FAILURE);
             }

             return (AAA_ERR_SUCCESS);
     }
</pre></div>
<p>As shown above, the procedures is to create a new AAA_AVP_LIST structure,
         adding all of the necessary AVPs that are within the Grouped AVP, then
         calling AAACreateAndAddAVPToList() to add the AAA_AVP_LIST as a Grouped
         AVP to the AAAMessage.
</p>
<p>Note that the AAA_AVP_LIST pointed to by orphaned avpList MUST NOT be
         accessed by the application after the Grouped avp has been created. The 
         list will be freed along with the AVP by the AAA Library.
</p>
<p>In order to parse a Grouped AVP, the AAA_AVP data field contains a 
         pointer to an AAA_AVP_LIST, as shown below.
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
     boolean_t
     isProxyStateOurs(AAA_AVP *proxyState, ipaddr_t *ourAddress)
     {
             AAA_AVP_LIST *avpList;
             AAA_AVP *proxyAddress;
             AAA_AVP *proxyInfo;
             ipaddr_t *proxyAddress;

             /*
              * Get the pointer to the Grouped AAA_AVP_LIST
              */
             avpList = (AAA_AVP_LIST *)proxyState-&gt;data;

             /*
              * First, for the Proxy-Address, and see if it is ours.
              */
             if ((proxyAddress = AAAFindMatchingAVP(avpList, NULL,
                 DIAM_AVP_PROXY_ADDRESS, NO_VENDOR_ID,
                 AAA_FORWARD_SEARCH)) != NULL) {
                     /*
                      * Check if this one is ours.
                      */
                     address2 = (ipaddr_t *)proxyAddress-&gt;data;
                     if (*address2 == *address) {
                             /*
                              * This one is ours... return TRUE
                              */
                             return (B_TRUE);
                     }
             }

             return (B_FALSE);
     }
</pre></div>
<a name="aaa_avp"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.7"></a><h3>3.7.&nbsp;
Extended AAA_AVP structure</h3>

<p>The AAA_AVP structure that is defined in this specification is
         a subset of the structure used by the internal library. The internal
         structure, known as the extended AAA_AVP, may contain many private
         fields, such as pointers to AAA_AVPs. Applications do not directly
         access the next (and previous) AAA_AVP pointers but
         instead access them via the AAAGetNextAVP() and AAAGetPreviousAVP()
         functions (see <a class='info' href='#visibility'>Section&nbsp;2.6<span> (</span><span class='info'>Structure Member Visibility</span><span>)</span></a>).
</p>
<p>The following is an example of an extended AAA_AVP structure:
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
         typedef struct {
                 // API Public variables here
         } AAA_AVP;
</pre></div><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
         typedef struct xavp {
                 AAA_AVP      avp;
                 struct xavp *next;
                 struct xavp *prev;
                 int          privateFlags;
         } Extended_AAA_Avp;
</pre></div>
<p>Of course, when AAACreateAVP is called, sufficient memory is allocated
         for the extended AAA_AVP structure, however the function returns a
         pointer to the AAA_AVP.
</p>
<a name="anchor88"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.8"></a><h3>3.8.&nbsp;
Avoiding AVP Copying</h3>

<p>The AAA_AVP struct does not provide an exact mapping to
         the Diameter protocol AVP packet format; however, library
         implementers can avoid having to copy the AVP data by
         putting a pointer to a packet format structure into
         a hidden part of the AAA_AVP struct. A pointer to
         the AVP data is then deposited into the AAA_AVP
         data field. This allows proper deallocation of the
         packet format structure when the AAA_AVP structure
         is deallocated.
</p>
<a name="anchor89"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.9"></a><h3>3.9.&nbsp;
Callback Processing Order</h3>

<p>The C API allows API clients to register message processors,
         or callbacks, that are 
         invoked before and after the bulk of the processing functions for
         a message. Only one pre- or post-processor is allowed for all
         incoming messages, regardless of command or extension type. If
         the API client adds another, any existing pre- and post-processors
         are removed. 
</p>
<p>Message processing can be best explained by the following diagram:
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
         +-------+     +-------+     +-------+     +-------+
         | First |     |  Any  |     |  Any  |     |  Last | Apps
         +-------+     +-------+     +-------+     +-------+
             ^             ^             ^             ^
           1 |           2 |           3 |           4 |
         +-------------------------------------------------+
         |                   AAA Library                   |
         +-------------------------------------------------+
                                 ^
                                 | MSG
</pre></div>
<p>In the above diagram, "First", "Any", and "Last" are added by the
         API client. The message processor labeled "First" is given
         access to the message before any other, the message processor "Last"
         after all others are finished. There is no guarantee on ordering
         for the other message processors. If the client adds a new "First"
         or "Last" message processor, AAA_ERR_ALREADY_REGISTERED error is
         returned. There is one "First" and "Last" processor for all commands regardless
         of type; whereas, the "Any" processors are command-specific.
</p>
<p>If one of the "Any" processors completes successfully, the message
         is not passed on any further. A successful
         completion means the success return code is returned from the
         C API callback, but the callback is responsible for freeing the 
         message before returning.
</p>
<a name="anchor90"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4"></a><h3>4.&nbsp;
Security Considerations</h3>

<p>This document describes an API and therefore depends on the security
     mechanisms defined in the Diameter protocol <a class='info' href='#RFC3588'>[RFC3588]<span> (</span><span class='info'>Calhoun, Loughney, Guttman, Zorn, and Arkko, &ldquo;Diameter Base Protocol,&rdquo; October&nbsp;2002.</span><span>)</span></a>. 
</p>
<a name="anchor91"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5"></a><h3>5.&nbsp;
IANA Considerations</h3>

<p>This document has no actions for IANA. 
</p>
<a name="anchor92"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6"></a><h3>6.&nbsp;
Acknowledgments</h3>

<p>The authors would like to thank James Kempf for his input 
       to this document.
</p>
<a name="rfc.references"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7"></a><h3>7.&nbsp;
References</h3>

<a name="rfc.references1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>7.1.&nbsp;Normative References</h3>
<table width="99%" border="0">
<tr><td class="author-text" valign="top"><a name="RFC3588">[RFC3588]</a></td>
<td class="author-text">Calhoun, Loughney, Guttman, Zorn, and Arkko, &ldquo;<a href="http://tools.ietf.org/html/rfc3588">Diameter Base Protocol</a>,&rdquo; RFC&nbsp;3588, October&nbsp;2002.</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC3493">[RFC3493]</a></td>
<td class="author-text">Gilligan, Thomson, Bound, McCann, and Stevens, &ldquo;<a href="http://tools.ietf.org/html/rfc3493">Basic Socket Interface Extensions for IPv6</a>,&rdquo; rfc&nbsp;3493, February&nbsp;2003.</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC2119">[RFC2119]</a></td>
<td class="author-text">Bradner, S., &ldquo;<a href="http://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>,&rdquo; BCP&nbsp;14, RFC&nbsp;2119, March&nbsp;1997.</td></tr>
</table>

<a name="rfc.references2"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>7.2.&nbsp;Informative References</h3>
<table width="99%" border="0">
<tr><td class="author-text" valign="top"><a name="XML">[XML]</a></td>
<td class="author-text">Frascone, Jones, and Guttman, &ldquo;<a href="http://www.ietf.org/internet-drafts/draft-frascone-xml-dictionary-00.txt">Diameter XML Dictionary</a>,&rdquo; draft-frascone-xml-dictionary-00 (work in progress), September&nbsp;2007.</td></tr>
</table>

<a name="rfc.authors"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>Authors' Addresses</h3>
<table width="99%" border="0" cellpadding="0" cellspacing="0">
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Victor Fajardo (editor)</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Toshiba America Research Inc.</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">One Telcordia Drive, #1S222</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Piscataway, NJ  08854</td></tr>
<tr><td class="author" align="right">Phone:&nbsp;</td>
<td class="author-text">+1 908-421-1845</td></tr>
<tr><td class="author" align="right">Fax:&nbsp;</td>
<td class="author-text"></td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:vfajardo@tari.toshiba.com">vfajardo@tari.toshiba.com</a></td></tr>
<tr cellpadding="3"><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Pat R. Calhoun</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Cisco Systems, Inc.</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">170 West Tasman</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">San Jose, CA  95134</td></tr>
<tr><td class="author" align="right">Phone:&nbsp;</td>
<td class="author-text">+1 408-853-5269</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:pacalhou@cisco.com">pacalhou@cisco.com</a></td></tr>
<tr cellpadding="3"><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">David Frascone</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Cisco Systems, Inc.</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">500 Northridge Drive, Suite 800</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Atlanta, GA  30350</td></tr>
<tr><td class="author" align="right">Phone:&nbsp;</td>
<td class="author-text">+1 678-352-2764</td></tr>
<tr><td class="author" align="right">Fax:&nbsp;</td>
<td class="author-text">+1 978-334-0249</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:dave@frascone.com">dave@frascone.com</a></td></tr>
</table>
</body></html>
