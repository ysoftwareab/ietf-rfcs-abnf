x0 = b7*128+b6*64+b5*32+b4*16+b3*8+b2*4+b1*2+b0
x1 = b15*128+b14*64+b13*32+b12*16+b11*8+b10*4+b9*2+b8

x3 = --------------------------,   y3 = ---------------------------
         1 + d * x1 * x2 * y1 * y2          1 - d * x1 * x2 * y1 * y2

b=256, the 255-bit encoding of GF(p) being the little-endian encoding
x = (u/v)        = u v  (u v^7)         (mod p)

A = (Y1-X1)*(Y2-X2)
B = (Y1+X1)*(Y2+X2)
C = T1*2*d*T2
D = Z1*2*Z2
E = B-A
F = D-C
G = D+C
H = B+A
X3 = E*F
Y3 = G*H
T3 = E*H
Z3 = F*G

x = (u/v)        = u  v (u^5 v^3)         (mod p)

A = Z1*Z2
B = A^2
C = X1*X2
D = Y1*Y2
E = d*C*D
F = B-E
G = B+E
H = (X1+X2)*(Y1+Y2)
X3 = A*G*(H-C-D)
Y3 = A*G*(D-C)
Z3 = F*G

p = 2**255 - 19

d = -121665 * modp_inv(121666) % p

q = 2**252 + 27742317777372353535851937790883648493

A = (P[1]-P[0])*(Q[1]-Q[0]) % p
B = (P[1]+P[0])*(Q[1]+Q[0]) % p
C = 2 * P[3] * Q[3] * d % p
D = 2 * P[2] * Q[2] % p
E = B-A
F = D-C
G = D+C
H = B+A
Q = (0, 1, 1, 0)  # Neutral element
Q = point_add(Q, P)
P = point_add(P, P)
modp_sqrt_m1 = pow(2, (p-1) // 4, p)

x2 = (y*y-1) * modp_inv(d*y*y+1)
x = pow(x2, (p+3) // 8, p)
x = x * modp_sqrt_m1 % p
x = p - x
g_y = 4 * modp_inv(5) % p
g_x = recover_x(g_y, 0)
G = (g_x, g_y, 1, g_x * g_y % p)

zinv = modp_inv(P[2])
x = P[0] * zinv % p
y = P[1] * zinv % p
y = int.from_bytes(s, "little")
sign = y >> 255
x = recover_x(y, sign)
h = sha512(secret)
a = int.from_bytes(h[:32], "little")
A = point_compress(point_mul(a, G))
r = sha512_modq(prefix + msg)
R = point_mul(r, G)
Rs = point_compress(R)
h = sha512_modq(Rs + A + msg)
s = (r + h * a) % q
A = point_decompress(public)
Rs = signature[:32]
R = point_decompress(Rs)
s = int.from_bytes(signature[32:], "little")
h = sha512_modq(Rs + public + msg)
sB = point_mul(s, G)
hA = point_mul(h, A)
p = 2**255 - 19


d = -121665 * modp_inv(121666) % p

q = 2**252 + 27742317777372353535851937790883648493


A = (P[1]-P[0])*(Q[1]-Q[0]) % p
B = (P[1]+P[0])*(Q[1]+Q[0]) % p
C = 2 * P[3] * Q[3] * d % p
D = 2 * P[2] * Q[2] % p
E = B-A
F = D-C
G = D+C
H = B+A
Q = (0, 1, 1, 0)  # Neutral element
Q = point_add(Q, P)
P = point_add(P, P)
modp_sqrt_m1 = pow(2, (p-1) // 4, p)


x2 = (y*y-1) * modp_inv(d*y*y+1)
x = pow(x2, (p+3) // 8, p)
x = x * modp_sqrt_m1 % p
x = p - x
g_y = 4 * modp_inv(5) % p
g_x = recover_x(g_y, 0)
G = (g_x, g_y, 1, g_x * g_y % p)


zinv = modp_inv(P[2])
x = P[0] * zinv % p
y = P[1] * zinv % p
y = int.from_bytes(s, "little")
sign = y >> 255
x = recover_x(y, sign)
h = sha512(secret)
a = int.from_bytes(h[:32], "little")
A = point_compress(point_mul(a, G))
r = sha512_modq(prefix + msg)
R = point_mul(r, G)
Rs = point_compress(R)
h = sha512_modq(Rs + A + msg)
s = (r + h * a) % q
A = point_decompress(public)
Rs = signature[:32]
R = point_decompress(Rs)
s = int.from_bytes(signature[32:], "little")
h = sha512_modq(Rs + public + msg)
sB = point_mul(s, G)
hA = point_mul(h, A)
zinv = modp_inv(P[2])
x = P[0] * zinv % p
y = P[1] * zinv % p
Z = (0, 1, 1, 0)
lineno = 0
line = sys.stdin.readline()
lineno = lineno + 1
fields = line.split(":")
secret = (binascii.unhexlify(fields[0]))[:32]
public = binascii.unhexlify(fields[1])
msg = binascii.unhexlify(fields[2])
signature = binascii.unhexlify(fields[3])[:64]

bad_msg = b"x"
bad_msg = munge_string(msg, len(msg) // 3, 4)
bad_signature = munge_string(signature, 20, 8)
bad_signature = munge_string(signature, 40, 16)
