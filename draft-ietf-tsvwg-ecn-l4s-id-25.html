<!DOCTYPE html>
<html lang="en" class="Internet-Draft">
<head>
<meta charset="utf-8">
<meta content="Common,Latin" name="scripts">
<meta content="initial-scale=1.0" name="viewport">
<title>Explicit Congestion Notification (ECN) Protocol for Very Low Queuing Delay (L4S)</title>
<meta content="Koen De Schepper" name="author">
<meta content="Bob Briscoe" name="author">
<meta content="
       This specification defines the protocol to be used for a new network
      service called low latency, low loss and scalable throughput (L4S). L4S
      uses an Explicit Congestion Notification (ECN) scheme at the IP layer
      that is similar to the original (or 'Classic') ECN approach, except as
      specified within. L4S uses 'scalable' congestion control, which induces
      much more frequent control signals from the network and it responds to
      them with much more fine-grained adjustments, so that very low
      (typically sub-millisecond on average) and consistently low queuing
      delay becomes possible for L4S traffic without compromising link
      utilization. Thus even capacity-seeking (TCP-like) traffic can have high
      bandwidth and very low delay at the same time, even during periods of
      high traffic load. 
       The L4S identifier defined in this document distinguishes L4S from
      'Classic' (e.g.Â TCP-Reno-friendly) traffic. It gives an incremental
      migration path so that suitably modified network bottlenecks can
      distinguish and isolate existing traffic that still follows the Classic
      behaviour, to prevent it degrading the low queuing delay and low loss of
      L4S traffic. This specification defines the rules that L4S transports
      and network elements need to follow with the intention that L4S flows
      neither harm each other's performance nor that of Classic traffic.
      Examples of new active queue management (AQM) marking algorithms and
      examples of new transports (whether TCP-like or real-time) are specified
      separately. 
    " name="description">
<meta content="xml2rfc 3.12.3" name="generator">
<meta content="Internet-Draft" name="keyword">
<meta content="I-D" name="keyword">
<meta content="draft-ietf-tsvwg-ecn-l4s-id-25" name="ietf.draft">
<!-- Generator version information:
  xml2rfc 3.12.3
    Python 3.6.12
    appdirs 1.4.4
    ConfigArgParse 1.5.3
    google-i18n-address 2.5.0
    html5lib 1.1
    intervaltree 3.1.0
    Jinja2 2.11.3
    kitchen 1.2.6
    lxml 4.8.0
    MarkupSafe 2.0.1
    pycountry 22.1.10
    pyflakes 2.4.0
    PyYAML 6.0
    requests 2.27.1
    setuptools 59.6.0
    six 1.16.0
    WeasyPrint 52.5
-->
<link href="/tmp/draft-ietf-tsvwg-ecn-l4s-id-25-4kny4f6_.xml" rel="alternate" type="application/rfc+xml">
<link href="#copyright" rel="license">
<style type="text/css">/*

  NOTE: Changes at the bottom of this file overrides some earlier settings.

  Once the style has stabilized and has been adopted as an official RFC style,
  this can be consolidated so that style settings occur only in one place, but
  for now the contents of this file consists first of the initial CSS work as
  provided to the RFC Formatter (xml2rfc) work, followed by itemized and
  commented changes found necssary during the development of the v3
  formatters.

*/

/* fonts */
@import url('https://fonts.googleapis.com/css?family=Noto+Sans'); /* Sans-serif */
@import url('https://fonts.googleapis.com/css?family=Noto+Serif'); /* Serif (print) */
@import url('https://fonts.googleapis.com/css?family=Roboto+Mono'); /* Monospace */

@viewport {
  zoom: 1.0;
  width: extend-to-zoom;
}
@-ms-viewport {
  width: extend-to-zoom;
  zoom: 1.0;
}
/* general and mobile first */
html {
}
body {
  max-width: 90%;
  margin: 1.5em auto;
  color: #222;
  background-color: #fff;
  font-size: 14px;
  font-family: 'Noto Sans', Arial, Helvetica, sans-serif;
  line-height: 1.6;
  scroll-behavior: smooth;
}
.ears {
  display: none;
}

/* headings */
#title, h1, h2, h3, h4, h5, h6 {
  margin: 1em 0 0.5em;
  font-weight: bold;
  line-height: 1.3;
}
#title {
  clear: both;
  border-bottom: 1px solid #ddd;
  margin: 0 0 0.5em 0;
  padding: 1em 0 0.5em;
}
.author {
  padding-bottom: 4px;
}
h1 {
  font-size: 26px;
  margin: 1em 0;
}
h2 {
  font-size: 22px;
  margin-top: -20px;  /* provide offset for in-page anchors */
  padding-top: 33px;
}
h3 {
  font-size: 18px;
  margin-top: -36px;  /* provide offset for in-page anchors */
  padding-top: 42px;
}
h4 {
  font-size: 16px;
  margin-top: -36px;  /* provide offset for in-page anchors */
  padding-top: 42px;
}
h5, h6 {
  font-size: 14px;
}
#n-copyright-notice {
  border-bottom: 1px solid #ddd;
  padding-bottom: 1em;
  margin-bottom: 1em;
}
/* general structure */
p {
  padding: 0;
  margin: 0 0 1em 0;
  text-align: left;
}
div, span {
  position: relative;
}
div {
  margin: 0;
}
.alignRight.art-text {
  background-color: #f9f9f9;
  border: 1px solid #eee;
  border-radius: 3px;
  padding: 1em 1em 0;
  margin-bottom: 1.5em;
}
.alignRight.art-text pre {
  padding: 0;
}
.alignRight {
  margin: 1em 0;
}
.alignRight > *:first-child {
  border: none;
  margin: 0;
  float: right;
  clear: both;
}
.alignRight > *:nth-child(2) {
  clear: both;
  display: block;
  border: none;
}
svg {
  display: block;
}
.alignCenter.art-text {
  background-color: #f9f9f9;
  border: 1px solid #eee;
  border-radius: 3px;
  padding: 1em 1em 0;
  margin-bottom: 1.5em;
}
.alignCenter.art-text pre {
  padding: 0;
}
.alignCenter {
  margin: 1em 0;
}
.alignCenter > *:first-child {
  border: none;
  /* this isn't optimal, but it's an existence proof.  PrinceXML doesn't
     support flexbox yet.
  */
  display: table;
  margin: 0 auto;
}

/* lists */
ol, ul {
  padding: 0;
  margin: 0 0 1em 2em;
}
ol ol, ul ul, ol ul, ul ol {
  margin-left: 1em;
}
li {
  margin: 0 0 0.25em 0;
}
.ulCompact li {
  margin: 0;
}
ul.empty, .ulEmpty {
  list-style-type: none;
}
ul.empty li, .ulEmpty li {
  margin-top: 0.5em;
}
ul.ulBare, li.ulBare {
  margin-left: 0em !important;
}
ul.compact, .ulCompact,
ol.compact, .olCompact {
  line-height: 100%;
  margin: 0 0 0 2em;
}

/* definition lists */
dl {
}
dl > dt {
  float: left;
  margin-right: 1em;
}
/* 
dl.nohang > dt {
  float: none;
}
*/
dl > dd {
  margin-bottom: .8em;
  min-height: 1.3em;
}
dl.compact > dd, .dlCompact > dd {
  margin-bottom: 0em;
}
dl > dd > dl {
  margin-top: 0.5em;
  margin-bottom: 0em;
}

/* links */
a {
  text-decoration: none;
}
a[href] {
  color: #22e; /* Arlen: WCAG 2019 */
}
a[href]:hover {
  background-color: #f2f2f2;
}
figcaption a[href],
a[href].selfRef {
  color: #222;
}
/* XXX probably not this:
a.selfRef:hover {
  background-color: transparent;
  cursor: default;
} */

/* Figures */
tt, code, pre, code {
  background-color: #f9f9f9;
  font-family: 'Roboto Mono', monospace;
}
pre {
  border: 1px solid #eee;
  margin: 0;
  padding: 1em;
}
img {
  max-width: 100%;
}
figure {
  margin: 0;
}
figure blockquote {
  margin: 0.8em 0.4em 0.4em;
}
figcaption {
  font-style: italic;
  margin: 0 0 1em 0;
}
@media screen {
  pre {
    overflow-x: auto;
    max-width: 100%;
    max-width: calc(100% - 22px);
  }
}

/* aside, blockquote */
aside, blockquote {
  margin-left: 0;
  padding: 1.2em 2em;
}
blockquote {
  background-color: #f9f9f9;
  color: #111; /* Arlen: WCAG 2019 */
  border: 1px solid #ddd;
  border-radius: 3px;
  margin: 1em 0;
}
cite {
  display: block;
  text-align: right;
  font-style: italic;
}

/* tables */
table {
  width: 100%;
  margin: 0 0 1em;
  border-collapse: collapse;
  border: 1px solid #eee;
}
th, td {
  text-align: left;
  vertical-align: top;
  padding: 0.5em 0.75em;
}
th {
  text-align: left;
  background-color: #e9e9e9;
}
tr:nth-child(2n+1) > td {
  background-color: #f5f5f5;
}
table caption {
  font-style: italic;
  margin: 0;
  padding: 0;
  text-align: left;
}
table p {
  /* XXX to avoid bottom margin on table row signifiers. If paragraphs should
     be allowed within tables more generally, it would be far better to select on a class. */
  margin: 0;
}

/* pilcrow */
a.pilcrow {
  color: #666; /* Arlen: AHDJ 2019 */
  text-decoration: none;
  visibility: hidden;
  user-select: none;
  -ms-user-select: none;
  -o-user-select:none;
  -moz-user-select: none;
  -khtml-user-select: none;
  -webkit-user-select: none;
  -webkit-touch-callout: none;
}
@media screen {
  aside:hover > a.pilcrow,
  p:hover > a.pilcrow,
  blockquote:hover > a.pilcrow,
  div:hover > a.pilcrow,
  li:hover > a.pilcrow,
  pre:hover > a.pilcrow {
    visibility: visible;
  }
  a.pilcrow:hover {
    background-color: transparent;
  }
}

/* misc */
hr {
  border: 0;
  border-top: 1px solid #eee;
}
.bcp14 {
  font-variant: small-caps;
}

.role {
  font-variant: all-small-caps;
}

/* info block */
#identifiers {
  margin: 0;
  font-size: 0.9em;
}
#identifiers dt {
  width: 3em;
  clear: left;
}
#identifiers dd {
  float: left;
  margin-bottom: 0;
}
/* Fix PDF info block run off issue */
@media print {
  #identifiers dd {
    float: none;
  }
}
#identifiers .authors .author {
  display: inline-block;
  margin-right: 1.5em;
}
#identifiers .authors .org {
  font-style: italic;
}

/* The prepared/rendered info at the very bottom of the page */
.docInfo {
  color: #666; /* Arlen: WCAG 2019 */
  font-size: 0.9em;
  font-style: italic;
  margin-top: 2em;
}
.docInfo .prepared {
  float: left;
}
.docInfo .prepared {
  float: right;
}

/* table of contents */
#toc  {
  padding: 0.75em 0 2em 0;
  margin-bottom: 1em;
}
nav.toc ul {
  margin: 0 0.5em 0 0;
  padding: 0;
  list-style: none;
}
nav.toc li {
  line-height: 1.3em;
  margin: 0.75em 0;
  padding-left: 1.2em;
  text-indent: -1.2em;
}
/* references */
.references dt {
  text-align: right;
  font-weight: bold;
  min-width: 7em;
}
.references dd {
  margin-left: 8em;
  overflow: auto;
}

.refInstance {
  margin-bottom: 1.25em;
}

.references .ascii {
  margin-bottom: 0.25em;
}

/* index */
.index ul {
  margin: 0 0 0 1em;
  padding: 0;
  list-style: none;
}
.index ul ul {
  margin: 0;
}
.index li {
  margin: 0;
  text-indent: -2em;
  padding-left: 2em;
  padding-bottom: 5px;
}
.indexIndex {
  margin: 0.5em 0 1em;
}
.index a {
  font-weight: 700;
}
/* make the index two-column on all but the smallest screens */
@media (min-width: 600px) {
  .index ul {
    -moz-column-count: 2;
    -moz-column-gap: 20px;
  }
  .index ul ul {
    -moz-column-count: 1;
    -moz-column-gap: 0;
  }
}

/* authors */
address.vcard {
  font-style: normal;
  margin: 1em 0;
}

address.vcard .nameRole {
  font-weight: 700;
  margin-left: 0;
}
address.vcard .label {
  font-family: "Noto Sans",Arial,Helvetica,sans-serif;
  margin: 0.5em 0;
}
address.vcard .type {
  display: none;
}
.alternative-contact {
  margin: 1.5em 0 1em;
}
hr.addr {
  border-top: 1px dashed;
  margin: 0;
  color: #ddd;
  max-width: calc(100% - 16px);
}

/* temporary notes */
.rfcEditorRemove::before {
  position: absolute;
  top: 0.2em;
  right: 0.2em;
  padding: 0.2em;
  content: "The RFC Editor will remove this note";
  color: #9e2a00; /* Arlen: WCAG 2019 */
  background-color: #ffd; /* Arlen: WCAG 2019 */
}
.rfcEditorRemove {
  position: relative;
  padding-top: 1.8em;
  background-color: #ffd; /* Arlen: WCAG 2019 */
  border-radius: 3px;
}
.cref {
  background-color: #ffd; /* Arlen: WCAG 2019 */
  padding: 2px 4px;
}
.crefSource {
  font-style: italic;
}
/* alternative layout for smaller screens */
@media screen and (max-width: 1023px) {
  body {
    padding-top: 2em;
  }
  #title {
    padding: 1em 0;
  }
  h1 {
    font-size: 24px;
  }
  h2 {
    font-size: 20px;
    margin-top: -18px;  /* provide offset for in-page anchors */
    padding-top: 38px;
  }
  #identifiers dd {
    max-width: 60%;
  }
  #toc {
    position: fixed;
    z-index: 2;
    top: 0;
    right: 0;
    padding: 0;
    margin: 0;
    background-color: inherit;
    border-bottom: 1px solid #ccc;
  }
  #toc h2 {
    margin: -1px 0 0 0;
    padding: 4px 0 4px 6px;
    padding-right: 1em;
    min-width: 190px;
    font-size: 1.1em;
    text-align: right;
    background-color: #444;
    color: white;
    cursor: pointer;
  }
  #toc h2::before { /* css hamburger */
    float: right;
    position: relative;
    width: 1em;
    height: 1px;
    left: -164px;
    margin: 6px 0 0 0;
    background: white none repeat scroll 0 0;
    box-shadow: 0 4px 0 0 white, 0 8px 0 0 white;
    content: "";
  }
  #toc nav {
    display: none;
    padding: 0.5em 1em 1em;
    overflow: auto;
    height: calc(100vh - 48px);
    border-left: 1px solid #ddd;
  }
}

/* alternative layout for wide screens */
@media screen and (min-width: 1024px) {
  body {
    max-width: 724px;
    margin: 42px auto;
    padding-left: 1.5em;
    padding-right: 29em;
  }
  #toc {
    position: fixed;
    top: 42px;
    right: 42px;
    width: 25%;
    margin: 0;
    padding: 0 1em;
    z-index: 1;
  }
  #toc h2 {
    border-top: none;
    border-bottom: 1px solid #ddd;
    font-size: 1em;
    font-weight: normal;
    margin: 0;
    padding: 0.25em 1em 1em 0;
  }
  #toc nav {
    display: block;
    height: calc(90vh - 84px);
    bottom: 0;
    padding: 0.5em 0 0;
    overflow: auto;
  }
  img { /* future proofing */
    max-width: 100%;
    height: auto;
  }
}

/* pagination */
@media print {
  body {

    width: 100%;
  }
  p {
    orphans: 3;
    widows: 3;
  }
  #n-copyright-notice {
    border-bottom: none;
  }
  #toc, #n-introduction {
    page-break-before: always;
  }
  #toc {
    border-top: none;
    padding-top: 0;
  }
  figure, pre {
    page-break-inside: avoid;
  }
  figure {
    overflow: scroll;
  }
  h1, h2, h3, h4, h5, h6 {
    page-break-after: avoid;
  }
  h2+*, h3+*, h4+*, h5+*, h6+* {
    page-break-before: avoid;
  }
  pre {
    white-space: pre-wrap;
    word-wrap: break-word;
    font-size: 10pt;
  }
  table {
    border: 1px solid #ddd;
  }
  td {
    border-top: 1px solid #ddd;
  }
}

/* This is commented out here, as the string-set: doesn't
   pass W3C validation currently */
/*
.ears thead .left {
  string-set: ears-top-left content();
}

.ears thead .center {
  string-set: ears-top-center content();
}

.ears thead .right {
  string-set: ears-top-right content();
}

.ears tfoot .left {
  string-set: ears-bottom-left content();
}

.ears tfoot .center {
  string-set: ears-bottom-center content();
}

.ears tfoot .right {
  string-set: ears-bottom-right content();
}
*/

@page :first {
  padding-top: 0;
  @top-left {
    content: normal;
    border: none;
  }
  @top-center {
    content: normal;
    border: none;
  }
  @top-right {
    content: normal;
    border: none;
  }
}

@page {
  size: A4;
  margin-bottom: 45mm;
  padding-top: 20px;
  /* The follwing is commented out here, but set appropriately by in code, as
     the content depends on the document */
  /*
  @top-left {
    content: 'Internet-Draft';
    vertical-align: bottom;
    border-bottom: solid 1px #ccc;
  }
  @top-left {
    content: string(ears-top-left);
    vertical-align: bottom;
    border-bottom: solid 1px #ccc;
  }
  @top-center {
    content: string(ears-top-center);
    vertical-align: bottom;
    border-bottom: solid 1px #ccc;
  }
  @top-right {
    content: string(ears-top-right);
    vertical-align: bottom;
    border-bottom: solid 1px #ccc;
  }
  @bottom-left {
    content: string(ears-bottom-left);
    vertical-align: top;
    border-top: solid 1px #ccc;
  }
  @bottom-center {
    content: string(ears-bottom-center);
    vertical-align: top;
    border-top: solid 1px #ccc;
  }
  @bottom-right {
      content: '[Page ' counter(page) ']';
      vertical-align: top;
      border-top: solid 1px #ccc;
  }
  */

}

/* Changes introduced to fix issues found during implementation */
/* Make sure links are clickable even if overlapped by following H* */
a {
  z-index: 2;
}
/* Separate body from document info even without intervening H1 */
section {
  clear: both;
}


/* Top align author divs, to avoid names without organization dropping level with org names */
.author {
  vertical-align: top;
}

/* Leave room in document info to show Internet-Draft on one line */
#identifiers dt {
  width: 8em;
}

/* Don't waste quite as much whitespace between label and value in doc info */
#identifiers dd {
  margin-left: 1em;
}

/* Give floating toc a background color (needed when it's a div inside section */
#toc {
  background-color: white;
}

/* Make the collapsed ToC header render white on gray also when it's a link */
@media screen and (max-width: 1023px) {
  #toc h2 a,
  #toc h2 a:link,
  #toc h2 a:focus,
  #toc h2 a:hover,
  #toc a.toplink,
  #toc a.toplink:hover {
    color: white;
    background-color: #444;
    text-decoration: none;
  }
}

/* Give the bottom of the ToC some whitespace */
@media screen and (min-width: 1024px) {
  #toc {
    padding: 0 0 1em 1em;
  }
}

/* Style section numbers with more space between number and title */
.section-number {
  padding-right: 0.5em;
}

/* prevent monospace from becoming overly large */
tt, code, pre, code {
  font-size: 95%;
}

/* Fix the height/width aspect for ascii art*/
pre.sourcecode,
.art-text pre {
  line-height: 1.12;
}


/* Add styling for a link in the ToC that points to the top of the document */
a.toplink {
  float: right;
  margin-right: 0.5em;
}

/* Fix the dl styling to match the RFC 7992 attributes */
dl > dt,
dl.dlParallel > dt {
  float: left;
  margin-right: 1em;
}
dl.dlNewline > dt {
  float: none;
}

/* Provide styling for table cell text alignment */
table td.text-left,
table th.text-left {
  text-align: left;
}
table td.text-center,
table th.text-center {
  text-align: center;
}
table td.text-right,
table th.text-right {
  text-align: right;
}

/* Make the alternative author contact informatio look less like just another
   author, and group it closer with the primary author contact information */
.alternative-contact {
  margin: 0.5em 0 0.25em 0;
}
address .non-ascii {
  margin: 0 0 0 2em;
}

/* With it being possible to set tables with alignment
  left, center, and right, { width: 100%; } does not make sense */
table {
  width: auto;
}

/* Avoid reference text that sits in a block with very wide left margin,
   because of a long floating dt label.*/
.references dd {
  overflow: visible;
}

/* Control caption placement */
caption {
  caption-side: bottom;
}

/* Limit the width of the author address vcard, so names in right-to-left
   script don't end up on the other side of the page. */

address.vcard {
  max-width: 30em;
  margin-right: auto;
}

/* For address alignment dependent on LTR or RTL scripts */
address div.left {
  text-align: left;
}
address div.right {
  text-align: right;
}

/* Provide table alignment support.  We can't use the alignX classes above
   since they do unwanted things with caption and other styling. */
table.right {
 margin-left: auto;
 margin-right: 0;
}
table.center {
 margin-left: auto;
 margin-right: auto;
}
table.left {
 margin-left: 0;
 margin-right: auto;
}

/* Give the table caption label the same styling as the figcaption */
caption a[href] {
  color: #222;
}

@media print {
  .toplink {
    display: none;
  }

  /* avoid overwriting the top border line with the ToC header */
  #toc {
    padding-top: 1px;
  }

  /* Avoid page breaks inside dl and author address entries */
  .vcard {
    page-break-inside: avoid;
  }

}
/* Tweak the bcp14 keyword presentation */
.bcp14 {
  font-variant: small-caps;
  font-weight: bold;
  font-size: 0.9em;
}
/* Tweak the invisible space above H* in order not to overlay links in text above */
 h2 {
  margin-top: -18px;  /* provide offset for in-page anchors */
  padding-top: 31px;
 }
 h3 {
  margin-top: -18px;  /* provide offset for in-page anchors */
  padding-top: 24px;
 }
 h4 {
  margin-top: -18px;  /* provide offset for in-page anchors */
  padding-top: 24px;
 }
/* Float artwork pilcrow to the right */
@media screen {
  .artwork a.pilcrow {
    display: block;
    line-height: 0.7;
    margin-top: 0.15em;
  }
}
/* Make pilcrows on dd visible */
@media screen {
  dd:hover > a.pilcrow {
    visibility: visible;
  }
}
/* Make the placement of figcaption match that of a table's caption
   by removing the figure's added bottom margin */
.alignLeft.art-text,
.alignCenter.art-text,
.alignRight.art-text {
   margin-bottom: 0;
}
.alignLeft,
.alignCenter,
.alignRight {
  margin: 1em 0 0 0;
}
/* In print, the pilcrow won't show on hover, so prevent it from taking up space,
   possibly even requiring a new line */
@media print {
  a.pilcrow {
    display: none;
  }
}
/* Styling for the external metadata */
div#external-metadata {
  background-color: #eee;
  padding: 0.5em;
  margin-bottom: 0.5em;
  display: none;
}
div#internal-metadata {
  padding: 0.5em;                       /* to match the external-metadata padding */
}
/* Styling for title RFC Number */
h1#rfcnum {
  clear: both;
  margin: 0 0 -1em;
  padding: 1em 0 0 0;
}
/* Make .olPercent look the same as <ol><li> */
dl.olPercent > dd {
  margin-bottom: 0.25em;
  min-height: initial;
}
/* Give aside some styling to set it apart */
aside {
  border-left: 1px solid #ddd;
  margin: 1em 0 1em 2em;
  padding: 0.2em 2em;
}
aside > dl,
aside > ol,
aside > ul,
aside > table,
aside > p {
  margin-bottom: 0.5em;
}
/* Additional page break settings */
@media print {
  figcaption, table caption {
    page-break-before: avoid;
  }
}
/* Font size adjustments for print */
@media print {
  body  { font-size: 10pt;      line-height: normal; max-width: 96%; }
  h1    { font-size: 1.72em;    padding-top: 1.5em; } /* 1*1.2*1.2*1.2 */
  h2    { font-size: 1.44em;    padding-top: 1.5em; } /* 1*1.2*1.2 */
  h3    { font-size: 1.2em;     padding-top: 1.5em; } /* 1*1.2 */
  h4    { font-size: 1em;       padding-top: 1.5em; }
  h5, h6 { font-size: 1em;      margin: initial; padding: 0.5em 0 0.3em; }
}
/* Sourcecode margin in print, when there's no pilcrow */
@media print {
  .artwork,
  .sourcecode {
    margin-bottom: 1em;
  }
}
/* Avoid narrow tables forcing too narrow table captions, which may render badly */
table {
  min-width: 20em;
}
/* ol type a */
ol.type-a { list-style-type: lower-alpha; }
ol.type-A { list-style-type: upper-alpha; }
ol.type-i { list-style-type: lower-roman; }
ol.type-I { list-style-type: lower-roman; }
/* Apply the print table and row borders in general, on request from the RPC,
and increase the contrast between border and odd row background sligthtly */
table {
  border: 1px solid #ddd;
}
td {
  border-top: 1px solid #ddd;
}
tr:nth-child(2n+1) > td {
  background-color: #f8f8f8;
}
/* Use style rules to govern display of the TOC. */
@media screen and (max-width: 1023px) {
  #toc nav { display: none; }
  #toc.active nav { display: block; }
}
/* Add support for keepWithNext */
.keepWithNext {
  break-after: avoid-page;
  break-after: avoid-page;
}
/* Add support for keepWithPrevious */
.keepWithPrevious {
  break-before: avoid-page;
}
/* Change the approach to avoiding breaks inside artwork etc. */
figure, pre, table, .artwork, .sourcecode  {
  break-before: auto;
  break-after: auto;
}
/* Avoid breaks between <dt> and <dd> */
dl {
  break-before: auto;
  break-inside: auto;
}
dt {
  break-before: auto;
  break-after: avoid-page;
}
dd {
  break-before: avoid-page;
  break-after: auto;
  orphans: 3;
  widows: 3
}
span.break, dd.break {
  margin-bottom: 0;
  min-height: 0;
  break-before: auto;
  break-inside: auto;
  break-after: auto;
}
/* Undo break-before ToC */
@media print {
  #toc {
    break-before: auto;
  }
}
/* Text in compact lists should not get extra bottim margin space,
   since that would makes the list not compact */
ul.compact p, .ulCompact p,
ol.compact p, .olCompact p {
 margin: 0;
}
/* But the list as a whole needs the extra space at the end */
section ul.compact,
section .ulCompact,
section ol.compact,
section .olCompact {
  margin-bottom: 1em;                    /* same as p not within ul.compact etc. */
}
/* The tt and code background above interferes with for instance table cell
   backgrounds.  Changed to something a bit more selective. */
tt, code {
  background-color: transparent;
}
p tt, p code, li tt, li code {
  background-color: #f8f8f8;
}
/* Tweak the pre margin -- 0px doesn't come out well */
pre {
   margin-top: 0.5px;
}
/* Tweak the comact list text */
ul.compact, .ulCompact,
ol.compact, .olCompact,
dl.compact, .dlCompact {
  line-height: normal;
}
/* Don't add top margin for nested lists */
li > ul, li > ol, li > dl,
dd > ul, dd > ol, dd > dl,
dl > dd > dl {
  margin-top: initial;
}
/* Elements that should not be rendered on the same line as a <dt> */
/* This should match the element list in writer.text.TextWriter.render_dl() */
dd > div.artwork:first-child,
dd > aside:first-child,
dd > figure:first-child,
dd > ol:first-child,
dd > div:first-child > pre.sourcecode,
dd > table:first-child,
dd > ul:first-child {
  clear: left;
}
/* fix for weird browser behaviour when <dd/> is empty */
dt+dd:empty::before{
  content: "\00a0";
}
/* Make paragraph spacing inside <li> smaller than in body text, to fit better within the list */
li > p {
  margin-bottom: 0.5em
}
/* Don't let p margin spill out from inside list items */
li > p:last-of-type {
  margin-bottom: 0;
}
</style>
<link href="rfc-local.css" rel="stylesheet" type="text/css">
<script type="application/javascript">async function addMetadata(){try{const e=document.styleSheets[0].cssRules;for(let t=0;t<e.length;t++)if(/#identifiers/.exec(e[t].selectorText)){const a=e[t].cssText.replace("#identifiers","#external-updates");document.styleSheets[0].insertRule(a,document.styleSheets[0].cssRules.length)}}catch(e){console.log(e)}const e=document.getElementById("external-metadata");if(e)try{var t,a="",o=function(e){const t=document.getElementsByTagName("meta");for(let a=0;a<t.length;a++)if(t[a].getAttribute("name")===e)return t[a].getAttribute("content");return""}("rfc.number");if(o){t="https://www.rfc-editor.org/rfc/rfc"+o+".json";try{const e=await fetch(t);a=await e.json()}catch(e){t=document.URL.indexOf("html")>=0?document.URL.replace(/html$/,"json"):document.URL+".json";const o=await fetch(t);a=await o.json()}}if(!a)return;e.style.display="block";const s="",d="https://datatracker.ietf.org/doc",n="https://datatracker.ietf.org/ipr/search",c="https://www.rfc-editor.org/info",l=a.doc_id.toLowerCase(),i=a.doc_id.slice(0,3).toLowerCase(),f=a.doc_id.slice(3).replace(/^0+/,""),u={status:"Status",obsoletes:"Obsoletes",obsoleted_by:"Obsoleted By",updates:"Updates",updated_by:"Updated By",see_also:"See Also",errata_url:"Errata"};let h="<dl style='overflow:hidden' id='external-updates'>";["status","obsoletes","obsoleted_by","updates","updated_by","see_also","errata_url"].forEach(e=>{if("status"==e){a[e]=a[e].toLowerCase();var t=a[e].split(" "),o=t.length,w="",p=1;for(let e=0;e<o;e++)p<o?w=w+r(t[e])+" ":w+=r(t[e]),p++;a[e]=w}else if("obsoletes"==e||"obsoleted_by"==e||"updates"==e||"updated_by"==e){var g,m="",b=1;g=a[e].length;for(let t=0;t<g;t++)a[e][t]&&(a[e][t]=String(a[e][t]).toLowerCase(),m=b<g?m+"<a href='"+s+"/rfc/".concat(a[e][t])+"'>"+a[e][t].slice(3)+"</a>, ":m+"<a href='"+s+"/rfc/".concat(a[e][t])+"'>"+a[e][t].slice(3)+"</a>",b++);a[e]=m}else if("see_also"==e){var y,L="",C=1;y=a[e].length;for(let t=0;t<y;t++)if(a[e][t]){a[e][t]=String(a[e][t]);var _=a[e][t].slice(0,3),v=a[e][t].slice(3).replace(/^0+/,"");L=C<y?"RFC"!=_?L+"<a href='"+s+"/info/"+_.toLowerCase().concat(v.toLowerCase())+"'>"+_+" "+v+"</a>, ":L+"<a href='"+s+"/info/"+_.toLowerCase().concat(v.toLowerCase())+"'>"+v+"</a>, ":"RFC"!=_?L+"<a href='"+s+"/info/"+_.toLowerCase().concat(v.toLowerCase())+"'>"+_+" "+v+"</a>":L+"<a href='"+s+"/info/"+_.toLowerCase().concat(v.toLowerCase())+"'>"+v+"</a>",C++}a[e]=L}else if("errata_url"==e){var R="";R=a[e]?R+"<a href='"+a[e]+"'>Errata exist</a> | <a href='"+d+"/"+l+"'>Datatracker</a>| <a href='"+n+"/?"+i+"="+f+"&submit="+i+"'>IPR</a> | <a href='"+c+"/"+l+"'>Info page</a>":"<a href='"+d+"/"+l+"'>Datatracker</a> | <a href='"+n+"/?"+i+"="+f+"&submit="+i+"'>IPR</a> | <a href='"+c+"/"+l+"'>Info page</a>",a[e]=R}""!=a[e]?"Errata"==u[e]?h+=`<dt>More info:</dt><dd>${a[e]}</dd>`:h+=`<dt>${u[e]}:</dt><dd>${a[e]}</dd>`:"Errata"==u[e]&&(h+=`<dt>More info:</dt><dd>${a[e]}</dd>`)}),h+="</dl>",e.innerHTML=h}catch(e){console.log(e)}else console.log("Could not locate metadata <div> element");function r(e){return e.charAt(0).toUpperCase()+e.slice(1)}}window.removeEventListener("load",addMetadata),window.addEventListener("load",addMetadata);</script>
</head>
<body>
<script src="metadata.min.js"></script>
<table class="ears">
<thead><tr>
<td class="left">Internet-Draft</td>
<td class="center">L4S ECN Protocol for V Low Queuing Delay</td>
<td class="right">March 2022</td>
</tr></thead>
<tfoot><tr>
<td class="left">De Schepper &amp; Briscoe</td>
<td class="center">Expires 5 September 2022</td>
<td class="right">[Page]</td>
</tr></tfoot>
</table>
<div id="external-metadata" class="document-information"></div>
<div id="internal-metadata" class="document-information">
<dl id="identifiers">
<dt class="label-workgroup">Workgroup:</dt>
<dd class="workgroup">Transport Services (tsv)</dd>
<dt class="label-internet-draft">Internet-Draft:</dt>
<dd class="internet-draft">draft-ietf-tsvwg-ecn-l4s-id-25</dd>
<dt class="label-published">Published:</dt>
<dd class="published">
<time datetime="2022-03-04" class="published">4 March 2022</time>
    </dd>
<dt class="label-intended-status">Intended Status:</dt>
<dd class="intended-status">Experimental</dd>
<dt class="label-expires">Expires:</dt>
<dd class="expires"><time datetime="2022-09-05">5 September 2022</time></dd>
<dt class="label-authors">Authors:</dt>
<dd class="authors">
<div class="author">
      <div class="author-name">K. De Schepper</div>
<div class="org">Nokia Bell Labs</div>
</div>
<div class="author">
      <div class="author-name">B. Briscoe, <span class="editor">Ed.</span>
</div>
<div class="org">Independent</div>
</div>
</dd>
</dl>
</div>
<h1 id="title">Explicit Congestion Notification (ECN) Protocol for Very Low Queuing Delay (L4S)</h1>
<section id="section-abstract">
      <h2 id="abstract"><a href="#abstract" class="selfRef">Abstract</a></h2>
<p id="section-abstract-1">This specification defines the protocol to be used for a new network
      service called low latency, low loss and scalable throughput (L4S). L4S
      uses an Explicit Congestion Notification (ECN) scheme at the IP layer
      that is similar to the original (or 'Classic') ECN approach, except as
      specified within. L4S uses 'scalable' congestion control, which induces
      much more frequent control signals from the network and it responds to
      them with much more fine-grained adjustments, so that very low
      (typically sub-millisecond on average) and consistently low queuing
      delay becomes possible for L4S traffic without compromising link
      utilization. Thus even capacity-seeking (TCP-like) traffic can have high
      bandwidth and very low delay at the same time, even during periods of
      high traffic load.<a href="#section-abstract-1" class="pilcrow">Â¶</a></p>
<p id="section-abstract-2">The L4S identifier defined in this document distinguishes L4S from
      'Classic' (e.g.Â TCP-Reno-friendly) traffic. It gives an incremental
      migration path so that suitably modified network bottlenecks can
      distinguish and isolate existing traffic that still follows the Classic
      behaviour, to prevent it degrading the low queuing delay and low loss of
      L4S traffic. This specification defines the rules that L4S transports
      and network elements need to follow with the intention that L4S flows
      neither harm each other's performance nor that of Classic traffic.
      Examples of new active queue management (AQM) marking algorithms and
      examples of new transports (whether TCP-like or real-time) are specified
      separately.<a href="#section-abstract-2" class="pilcrow">Â¶</a></p>
</section>
<div id="status-of-memo">
<section id="section-boilerplate.1">
        <h2 id="name-status-of-this-memo-4">
<a href="#name-status-of-this-memo-4" class="section-name selfRef">Status of This Memo</a>
        </h2>
<p id="section-boilerplate.1-1">
        This Internet-Draft is submitted in full conformance with the
        provisions of BCP 78 and BCP 79.<a href="#section-boilerplate.1-1" class="pilcrow">Â¶</a></p>
<p id="section-boilerplate.1-2">
        Internet-Drafts are working documents of the Internet Engineering Task
        Force (IETF). Note that other groups may also distribute working
        documents as Internet-Drafts. The list of current Internet-Drafts is
        at <span><a href="https://datatracker.ietf.org/drafts/current/">https://datatracker.ietf.org/drafts/current/</a></span>.<a href="#section-boilerplate.1-2" class="pilcrow">Â¶</a></p>
<p id="section-boilerplate.1-3">
        Internet-Drafts are draft documents valid for a maximum of six months
        and may be updated, replaced, or obsoleted by other documents at any
        time. It is inappropriate to use Internet-Drafts as reference
        material or to cite them other than as "work in progress."<a href="#section-boilerplate.1-3" class="pilcrow">Â¶</a></p>
<p id="section-boilerplate.1-4">
        This Internet-Draft will expire on 5 September 2022.<a href="#section-boilerplate.1-4" class="pilcrow">Â¶</a></p>
</section>
</div>
<div id="copyright">
<section id="section-boilerplate.2">
        <h2 id="name-copyright-notice-4">
<a href="#name-copyright-notice-4" class="section-name selfRef">Copyright Notice</a>
        </h2>
<p id="section-boilerplate.2-1">
            Copyright (c) 2022 IETF Trust and the persons identified as the
            document authors. All rights reserved.<a href="#section-boilerplate.2-1" class="pilcrow">Â¶</a></p>
<p id="section-boilerplate.2-2">
            This document is subject to BCP 78 and the IETF Trust's Legal
            Provisions Relating to IETF Documents
            (<span><a href="https://trustee.ietf.org/license-info">https://trustee.ietf.org/license-info</a></span>) in effect on the date of
            publication of this document. Please review these documents
            carefully, as they describe your rights and restrictions with
            respect to this document. Code Components extracted from this
            document must include Revised BSD License text as described in
            Section 4.e of the Trust Legal Provisions and are provided without
            warranty as described in the Revised BSD License.<a href="#section-boilerplate.2-2" class="pilcrow">Â¶</a></p>
</section>
</div>
<div id="toc">
<section id="section-toc.1">
        <a href="#" onclick="scroll(0,0)" class="toplink">â²</a><h2 id="name-table-of-contents-4">
<a href="#name-table-of-contents-4" class="section-name selfRef">Table of Contents</a>
        </h2>
<nav class="toc"><ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.1">
            <p id="section-toc.1-1.1.1"><a href="#section-1" class="xref">1</a>.Â Â <a href="#name-introduction-3" class="xref">Introduction</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.1.2.1">
                <p id="section-toc.1-1.1.2.1.1" class="keepWithNext"><a href="#section-1.1" class="xref">1.1</a>.Â Â <a href="#name-latency-loss-and-scaling-pr" class="xref">Latency, Loss and Scaling Problems</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.1.2.2">
                <p id="section-toc.1-1.1.2.2.1" class="keepWithNext"><a href="#section-1.2" class="xref">1.2</a>.Â Â <a href="#name-terminology-3" class="xref">Terminology</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.1.2.3">
                <p id="section-toc.1-1.1.2.3.1" class="keepWithNext"><a href="#section-1.3" class="xref">1.3</a>.Â Â <a href="#name-scope" class="xref">Scope</a></p>
</li>
            </ul>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.2">
            <p id="section-toc.1-1.2.1"><a href="#section-2" class="xref">2</a>.Â Â <a href="#name-choice-of-l4s-packet-identi" class="xref">Choice of L4S Packet Identifier: Requirements</a></p>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.3">
            <p id="section-toc.1-1.3.1"><a href="#section-3" class="xref">3</a>.Â Â <a href="#name-l4s-packet-identification" class="xref">L4S Packet Identification</a></p>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4">
            <p id="section-toc.1-1.4.1"><a href="#section-4" class="xref">4</a>.Â Â <a href="#name-transport-layer-behaviour-t" class="xref">Transport Layer Behaviour (the 'Prague Requirements')</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.1">
                <p id="section-toc.1-1.4.2.1.1"><a href="#section-4.1" class="xref">4.1</a>.Â Â <a href="#name-codepoint-setting" class="xref">Codepoint Setting</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.2">
                <p id="section-toc.1-1.4.2.2.1"><a href="#section-4.2" class="xref">4.2</a>.Â Â <a href="#name-prerequisite-transport-feed" class="xref">Prerequisite Transport Feedback</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.3">
                <p id="section-toc.1-1.4.2.3.1"><a href="#section-4.3" class="xref">4.3</a>.Â Â <a href="#name-prerequisite-congestion-res" class="xref">Prerequisite Congestion Response</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.3.2.1">
                    <p id="section-toc.1-1.4.2.3.2.1.1"><a href="#section-4.3.1" class="xref">4.3.1</a>.Â Â <a href="#name-guidance-on-congestion-resp" class="xref">Guidance on Congestion Response in the RFC Series</a></p>
</li>
                </ul>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.4">
                <p id="section-toc.1-1.4.2.4.1"><a href="#section-4.4" class="xref">4.4</a>.Â Â <a href="#name-filtering-or-smoothing-of-e" class="xref">Filtering or Smoothing of ECN Feedback</a></p>
</li>
            </ul>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.5">
            <p id="section-toc.1-1.5.1"><a href="#section-5" class="xref">5</a>.Â Â <a href="#name-network-node-behaviour" class="xref">Network Node Behaviour</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.5.2.1">
                <p id="section-toc.1-1.5.2.1.1"><a href="#section-5.1" class="xref">5.1</a>.Â Â <a href="#name-classification-and-re-marki" class="xref">Classification and Re-Marking Behaviour</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.5.2.2">
                <p id="section-toc.1-1.5.2.2.1"><a href="#section-5.2" class="xref">5.2</a>.Â Â <a href="#name-the-strength-of-l4s-ce-mark" class="xref">The Strength of L4S CE Marking Relative to Drop</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.5.2.3">
                <p id="section-toc.1-1.5.2.3.1"><a href="#section-5.3" class="xref">5.3</a>.Â Â <a href="#name-exception-for-l4s-packet-id" class="xref">Exception for L4S Packet Identification by Network Nodes with Transport-Layer Awareness</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.5.2.4">
                <p id="section-toc.1-1.5.2.4.1"><a href="#section-5.4" class="xref">5.4</a>.Â Â <a href="#name-interaction-of-the-l4s-iden" class="xref">Interaction of the L4S Identifier with other Identifiers</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.5.2.4.2.1">
                    <p id="section-toc.1-1.5.2.4.2.1.1"><a href="#section-5.4.1" class="xref">5.4.1</a>.Â Â <a href="#name-dualq-examples-of-other-ide" class="xref">DualQ Examples of Other Identifiers Complementing L4S Identifiers</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.5.2.4.2.1.2.1">
                        <p id="section-toc.1-1.5.2.4.2.1.2.1.1"><a href="#section-5.4.1.1" class="xref">5.4.1.1</a>.Â Â <a href="#name-inclusion-of-additional-tra" class="xref">Inclusion of Additional Traffic with L4S</a></p>
</li>
                      <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.5.2.4.2.1.2.2">
                        <p id="section-toc.1-1.5.2.4.2.1.2.2.1"><a href="#section-5.4.1.2" class="xref">5.4.1.2</a>.Â Â <a href="#name-exclusion-of-traffic-from-l" class="xref">Exclusion of Traffic From L4S Treatment</a></p>
</li>
                      <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.5.2.4.2.1.2.3">
                        <p id="section-toc.1-1.5.2.4.2.1.2.3.1"><a href="#section-5.4.1.3" class="xref">5.4.1.3</a>.Â Â <a href="#name-generalized-combination-of-" class="xref">Generalized Combination of L4S and Other Identifiers</a></p>
</li>
                    </ul>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.5.2.4.2.2">
                    <p id="section-toc.1-1.5.2.4.2.2.1"><a href="#section-5.4.2" class="xref">5.4.2</a>.Â Â <a href="#name-per-flow-queuing-examples-o" class="xref">Per-Flow Queuing Examples of Other Identifiers Complementing L4S Identifiers</a></p>
</li>
                </ul>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.5.2.5">
                <p id="section-toc.1-1.5.2.5.1"><a href="#section-5.5" class="xref">5.5</a>.Â Â <a href="#name-limiting-packet-bursts-from" class="xref">Limiting Packet Bursts from Links</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.5.2.5.2.1">
                    <p id="section-toc.1-1.5.2.5.2.1.1"><a href="#section-5.5.1" class="xref">5.5.1</a>.Â Â <a href="#name-limiting-packet-bursts-from-" class="xref">Limiting Packet Bursts from Links Fed by an L4S AQM</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.5.2.5.2.2">
                    <p id="section-toc.1-1.5.2.5.2.2.1"><a href="#section-5.5.2" class="xref">5.5.2</a>.Â Â <a href="#name-limiting-packet-bursts-from-l" class="xref">Limiting Packet Bursts from Links Upstream of an L4S AQM</a></p>
</li>
                </ul>
</li>
            </ul>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.6">
            <p id="section-toc.1-1.6.1"><a href="#section-6" class="xref">6</a>.Â Â <a href="#name-behaviour-of-tunnels-and-en" class="xref">Behaviour of Tunnels and Encapsulations</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.6.2.1">
                <p id="section-toc.1-1.6.2.1.1"><a href="#section-6.1" class="xref">6.1</a>.Â Â <a href="#name-no-change-to-ecn-tunnels-an" class="xref">No Change to ECN Tunnels and Encapsulations in General</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.6.2.2">
                <p id="section-toc.1-1.6.2.2.1"><a href="#section-6.2" class="xref">6.2</a>.Â Â <a href="#name-vpn-behaviour-to-avoid-limi" class="xref">VPN Behaviour to Avoid Limitations of Anti-Replay</a></p>
</li>
            </ul>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.7">
            <p id="section-toc.1-1.7.1"><a href="#section-7" class="xref">7</a>.Â Â <a href="#name-l4s-experiments" class="xref">L4S Experiments</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.7.2.1">
                <p id="section-toc.1-1.7.2.1.1"><a href="#section-7.1" class="xref">7.1</a>.Â Â <a href="#name-open-questions" class="xref">Open Questions</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.7.2.2">
                <p id="section-toc.1-1.7.2.2.1"><a href="#section-7.2" class="xref">7.2</a>.Â Â <a href="#name-open-issues-2" class="xref">Open Issues</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.7.2.3">
                <p id="section-toc.1-1.7.2.3.1"><a href="#section-7.3" class="xref">7.3</a>.Â Â <a href="#name-future-potential" class="xref">Future Potential</a></p>
</li>
            </ul>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.8">
            <p id="section-toc.1-1.8.1"><a href="#section-8" class="xref">8</a>.Â Â <a href="#name-iana-considerations-4" class="xref">IANA Considerations</a></p>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.9">
            <p id="section-toc.1-1.9.1"><a href="#section-9" class="xref">9</a>.Â Â <a href="#name-security-considerations-4" class="xref">Security Considerations</a></p>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.10">
            <p id="section-toc.1-1.10.1"><a href="#section-10" class="xref">10</a>.Â <a href="#name-acknowledgements-2" class="xref">Acknowledgements</a></p>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.11">
            <p id="section-toc.1-1.11.1"><a href="#section-11" class="xref">11</a>.Â <a href="#name-references-4" class="xref">References</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.11.2.1">
                <p id="section-toc.1-1.11.2.1.1"><a href="#section-11.1" class="xref">11.1</a>.Â Â <a href="#name-normative-references-4" class="xref">Normative References</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.11.2.2">
                <p id="section-toc.1-1.11.2.2.1"><a href="#section-11.2" class="xref">11.2</a>.Â Â <a href="#name-informative-references-4" class="xref">Informative References</a></p>
</li>
            </ul>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.12">
            <p id="section-toc.1-1.12.1"><a href="#appendix-A" class="xref">Appendix A</a>.Â Â <a href="#name-rationale-for-the-prague-l4" class="xref">Rationale for the 'Prague L4S Requirements'</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.12.2.1">
                <p id="section-toc.1-1.12.2.1.1"><a href="#appendix-A.1" class="xref">A.1</a>.Â Â <a href="#name-rationale-for-the-requireme" class="xref">Rationale for the Requirements for Scalable Transport Protocols</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.12.2.1.2.1">
                    <p id="section-toc.1-1.12.2.1.2.1.1"><a href="#appendix-A.1.1" class="xref">A.1.1</a>.Â Â <a href="#name-use-of-l4s-packet-identifie" class="xref">Use of L4S Packet Identifier</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.12.2.1.2.2">
                    <p id="section-toc.1-1.12.2.1.2.2.1"><a href="#appendix-A.1.2" class="xref">A.1.2</a>.Â Â <a href="#name-accurate-ecn-feedback" class="xref">Accurate ECN Feedback</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.12.2.1.2.3">
                    <p id="section-toc.1-1.12.2.1.2.3.1"><a href="#appendix-A.1.3" class="xref">A.1.3</a>.Â Â <a href="#name-capable-of-replacement-by-c" class="xref">Capable of Replacement by Classic Congestion Control</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.12.2.1.2.4">
                    <p id="section-toc.1-1.12.2.1.2.4.1"><a href="#appendix-A.1.4" class="xref">A.1.4</a>.Â Â <a href="#name-fall-back-to-classic-conges" class="xref">Fall back to Classic Congestion Control on Packet Loss</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.12.2.1.2.5">
                    <p id="section-toc.1-1.12.2.1.2.5.1"><a href="#appendix-A.1.5" class="xref">A.1.5</a>.Â Â <a href="#name-coexistence-with-classic-co" class="xref">Coexistence with Classic Congestion Control at Classic ECN bottlenecks</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.12.2.1.2.6">
                    <p id="section-toc.1-1.12.2.1.2.6.1"><a href="#appendix-A.1.6" class="xref">A.1.6</a>.Â Â <a href="#name-reduce-rtt-dependence" class="xref">Reduce RTT dependence</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.12.2.1.2.7">
                    <p id="section-toc.1-1.12.2.1.2.7.1"><a href="#appendix-A.1.7" class="xref">A.1.7</a>.Â Â <a href="#name-scaling-down-to-fractional-" class="xref">Scaling down to fractional congestion windows</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.12.2.1.2.8">
                    <p id="section-toc.1-1.12.2.1.2.8.1"><a href="#appendix-A.1.8" class="xref">A.1.8</a>.Â Â <a href="#name-measuring-reordering-tolera" class="xref">Measuring Reordering Tolerance in Time Units</a></p>
</li>
                </ul>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.12.2.2">
                <p id="section-toc.1-1.12.2.2.1"><a href="#appendix-A.2" class="xref">A.2</a>.Â Â <a href="#name-scalable-transport-protocol" class="xref">Scalable Transport Protocol Optimizations</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.12.2.2.2.1">
                    <p id="section-toc.1-1.12.2.2.2.1.1"><a href="#appendix-A.2.1" class="xref">A.2.1</a>.Â Â <a href="#name-setting-ect-in-control-pack" class="xref">Setting ECT in Control Packets and Retransmissions</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.12.2.2.2.2">
                    <p id="section-toc.1-1.12.2.2.2.2.1"><a href="#appendix-A.2.2" class="xref">A.2.2</a>.Â Â <a href="#name-faster-than-additive-increa" class="xref">Faster than Additive Increase</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.12.2.2.2.3">
                    <p id="section-toc.1-1.12.2.2.2.3.1"><a href="#appendix-A.2.3" class="xref">A.2.3</a>.Â Â <a href="#name-faster-convergence-at-flow-" class="xref">Faster Convergence at Flow Start</a></p>
</li>
                </ul>
</li>
            </ul>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.13">
            <p id="section-toc.1-1.13.1"><a href="#appendix-B" class="xref">Appendix B</a>.Â Â <a href="#name-compromises-in-the-choice-o" class="xref">Compromises in the Choice of L4S Identifier</a></p>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.14">
            <p id="section-toc.1-1.14.1"><a href="#appendix-C" class="xref">Appendix C</a>.Â Â <a href="#name-potential-competing-uses-fo" class="xref">Potential Competing Uses for the ECT(1) Codepoint</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.14.2.1">
                <p id="section-toc.1-1.14.2.1.1"><a href="#appendix-C.1" class="xref">C.1</a>.Â Â <a href="#name-integrity-of-congestion-fee" class="xref">Integrity of Congestion Feedback</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.14.2.2">
                <p id="section-toc.1-1.14.2.2.1"><a href="#appendix-C.2" class="xref">C.2</a>.Â Â <a href="#name-notification-of-less-severe" class="xref">Notification of Less Severe Congestion than CE</a></p>
</li>
            </ul>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.15">
            <p id="section-toc.1-1.15.1"><a href="#appendix-D" class="xref"></a><a href="#name-authors-addresses-4" class="xref">Authors' Addresses</a></p>
</li>
        </ul>
</nav>
</section>
</div>
<div id="l4sid_intro">
<section id="section-1">
      <h2 id="name-introduction-3">
<a href="#section-1" class="section-number selfRef">1. </a><a href="#name-introduction-3" class="section-name selfRef">Introduction</a>
      </h2>
<p id="section-1-1">This specification defines the protocol to be used for a new network
      service called low latency, low loss and scalable throughput (L4S). L4S
      uses an Explicit Congestion Notification (ECN) scheme at the IP layer
      with the same set of codepoint transitions as the original (or
      'Classic') Explicit Congestion Notification (ECNÂ <span>[<a href="#RFC3168" class="xref">RFC3168</a>]</span>). RFCÂ 3168 required an ECN mark to be equivalent
      to a drop, both when applied in the network and when responded to by a
      transport. Unlike Classic ECN marking, the network applies L4S marking
      more immediately and more aggressively than drop, and the transport
      response to each mark is reduced and smoothed relative to that for drop.
      The two changes counterbalance each other so that the throughput of an
      L4S flow will be roughly the same as a comparable non-L4S flow under the
      same conditions. Nonetheless, the much more frequent ECN control signals
      and the finer responses to these signals result in very low queuing
      delay without compromising link utilization, and this low delay can be
      maintained during high load. For instance, queuing delay under heavy and
      highly varying load with the example DCTCP/DualQ solution cited below on
      a DSL or Ethernet link is sub-millisecond on average and roughly 1 to 2
      milliseconds at the 99th percentile without losing link
      utilizationÂ <span>[<a href="#DualPI2Linux" class="xref">DualPI2Linux</a>]</span>, <span>[<a href="#DCttH19" class="xref">DCttH19</a>]</span>. Note that the inherent queuing delay while waiting
      to acquire a discontinuous medium such as WiFi has to be minimized in
      its own right, so it would be additional to the above (see section 6.3
      of the L4S architectureÂ <span>[<a href="#I-D.ietf-tsvwg-l4s-arch" class="xref">I-D.ietf-tsvwg-l4s-arch</a>]</span>).<a href="#section-1-1" class="pilcrow">Â¶</a></p>
<p id="section-1-2">L4S relies on 'scalable' congestion controls for these delay
      properties and for preserving low delay as flow rate scales, hence the
      name. The congestion control used in Data Center TCP (DCTCP) is an
      example of a scalable congestion control, but DCTCP is applicable solely
      to controlled environments like data centresÂ <span>[<a href="#RFC8257" class="xref">RFC8257</a>]</span>, because it is too aggressive to co-exist with
      existing TCP-Reno-friendly traffic. The DualQ Coupled AQM, which is
      defined in a complementary experimental specificationÂ <span>[<a href="#I-D.ietf-tsvwg-aqm-dualq-coupled" class="xref">I-D.ietf-tsvwg-aqm-dualq-coupled</a>]</span>, is an AQM framework that
      enables scalable congestion controls derived from DCTCP to co-exist with
      existing traffic, each getting roughly the same flow rate when they
      compete under similar conditions. Note that a scalable congestion
      control is still not safe to deploy on the Internet unless it satisfies
      the requirements listed in <a href="#l4sid_transport_req" class="xref">Section 4</a>.<a href="#section-1-2" class="pilcrow">Â¶</a></p>
<p id="section-1-3">L4S is not only for elastic (TCP-like) traffic - there are scalable
      congestion controls for real-time media, such as the L4S variant of the
      SCReAMÂ <span>[<a href="#RFC8298" class="xref">RFC8298</a>]</span> real-time media congestion
      avoidance technique (RMCAT). The factor that distinguishes L4S from
      Classic traffic is its behaviour in response to congestion. The
      transport wire protocol, e.g.Â TCP, QUIC, SCTP, DCCP, RTP/RTCP, is
      orthogonal (and therefore not suitable for distinguishing L4S from
      Classic packets).<a href="#section-1-3" class="pilcrow">Â¶</a></p>
<p id="section-1-4">The L4S identifier defined in this document is the key piece that
      distinguishes L4S from 'Classic' (e.g.Â Reno-friendly) traffic. It
      gives an incremental migration path so that suitably modified network
      bottlenecks can distinguish and isolate existing Classic traffic from
      L4S traffic to prevent the former from degrading the very low delay and
      loss of the new scalable transports, without harming Classic performance
      at these bottlenecks. Initial implementation of the separate parts of
      the system has been motivated by the performance benefits.<a href="#section-1-4" class="pilcrow">Â¶</a></p>
<div id="l4sid_problem">
<section id="section-1.1">
        <h3 id="name-latency-loss-and-scaling-pr">
<a href="#section-1.1" class="section-number selfRef">1.1. </a><a href="#name-latency-loss-and-scaling-pr" class="section-name selfRef">Latency, Loss and Scaling Problems</a>
        </h3>
<p id="section-1.1-1">Latency is becoming the critical performance factor for many
        (most?) applications on the public Internet, e.g.Â interactive
        Web, Web services, voice, conversational video, interactive video,
        interactive remote presence, instant messaging, online gaming, remote
        desktop, cloud-based applications, and video-assisted remote control
        of machinery and industrial processes. In the 'developed' world,
        further increases in access network bit-rate offer diminishing
        returns, whereas latency is still a multi-faceted problem. In the last
        decade or so, much has been done to reduce propagation time by placing
        caches or servers closer to users. However, queuing remains a major
        intermittent component of latency.<a href="#section-1.1-1" class="pilcrow">Â¶</a></p>
<p id="section-1.1-2">The Diffserv architecture provides Expedited ForwardingÂ <span>[<a href="#RFC3246" class="xref">RFC3246</a>]</span>, so that low latency traffic can jump the queue of
        other traffic. If growth in high-throughput latency-sensitive
        applications continues, periods with solely latency-sensitive traffic
        will become increasingly common on links where traffic aggregation is
        low. For instance, on the access links dedicated to individual sites
        (homes, small enterprises or mobile devices). These links also tend to
        become the path bottleneck under load. During these periods, if all
        the traffic were marked for the same treatment, at these bottlenecks
        Diffserv would make no difference. Instead, it becomes imperative to
        remove the underlying causes of any unnecessary delay.<a href="#section-1.1-2" class="pilcrow">Â¶</a></p>
<p id="section-1.1-3">The bufferbloat project has shown that excessively-large buffering
        ('bufferbloat') has been introducing significantly more delay than the
        underlying propagation time. These delays appear only intermittently
        -- only when a capacity-seeking (e.g.Â TCP) flow is long
        enough for the queue to fill the buffer, making every packet in other
        flows sharing the buffer sit through the queue.<a href="#section-1.1-3" class="pilcrow">Â¶</a></p>
<p id="section-1.1-4">Active queue management (AQM) was originally developed to solve
        this problem (and others). Unlike Diffserv, which gives low latency to
        some traffic at the expense of others, AQM controls latency for <em>all</em> traffic in a class. In general, AQM methods
        introduce an increasing level of discard from the buffer the longer
        the queue persists above a shallow threshold. This gives sufficient
        signals to capacity-seeking (aka.Â greedy) flows to keep the
        buffer empty for its intended purpose: absorbing bursts. However,
        REDÂ <span>[<a href="#RFC2309" class="xref">RFC2309</a>]</span> and other algorithms from the 1990s
        were sensitive to their configuration and hard to set correctly. So,
        this form of AQM was not widely deployed.<a href="#section-1.1-4" class="pilcrow">Â¶</a></p>
<p id="section-1.1-5">More recent state-of-the-art AQM methods,
        e.g.Â FQ-CoDelÂ <span>[<a href="#RFC8290" class="xref">RFC8290</a>]</span>, PIEÂ <span>[<a href="#RFC8033" class="xref">RFC8033</a>]</span>, Adaptive REDÂ <span>[<a href="#ARED01" class="xref">ARED01</a>]</span>, are
        easier to configure, because they define the queuing threshold in time
        not bytes, so it is invariant for different link rates. However, no
        matter how good the AQM, the sawtoothing sending window of a Classic
        congestion control will either cause queuing delay to vary or cause
        the link to be underutilized. Even with a perfectly tuned AQM, the
        additional queuing delay will be of the same order as the underlying
        speed-of-light delay across the network, thereby roughly doubling the
        total round-trip time.<a href="#section-1.1-5" class="pilcrow">Â¶</a></p>
<p id="section-1.1-6">If a sender's own behaviour is introducing queuing delay variation,
        no AQM in the network can 'un-vary' the delay without significantly
        compromising link utilization. Even flow-queuing (e.g.Â <span>[<a href="#RFC8290" class="xref">RFC8290</a>]</span>), which isolates one flow from another, cannot
        isolate a flow from the delay variations it inflicts on itself.
        Therefore those applications that need to seek out high bandwidth but
        also need low latency will have to migrate to scalable congestion
        control.<a href="#section-1.1-6" class="pilcrow">Â¶</a></p>
<p id="section-1.1-7">Altering host behaviour is not enough on its own though. Even if
        hosts adopt low latency behaviour (scalable congestion controls), they
        need to be isolated from the behaviour of existing Classic congestion
        controls that induce large queue variations. L4S enables that
        migration by providing latency isolation in the network and
        distinguishing the two types of packets that need to be isolated: L4S
        and Classic. L4S isolation can be achieved with a queue per flow
        (e.g.Â <span>[<a href="#RFC8290" class="xref">RFC8290</a>]</span>) but a DualQÂ <span>[<a href="#I-D.ietf-tsvwg-aqm-dualq-coupled" class="xref">I-D.ietf-tsvwg-aqm-dualq-coupled</a>]</span> is sufficient, and
        actually gives better tail latency. Both approaches are addressed in
        this document.<a href="#section-1.1-7" class="pilcrow">Â¶</a></p>
<p id="section-1.1-8">The DualQ solution was developed to make very low latency available
        without requiring per-flow queues at every bottleneck. This was
        because per-flow-queuing (FQ) has well-known downsides - not least the
        need to inspect transport layer headers in the network, which makes it
        incompatible with privacy approaches such as IPSec VPN tunnels, and
        incompatible with link layer queue management, where transport layer
        headers can be hidden, e.g.Â 5G.<a href="#section-1.1-8" class="pilcrow">Â¶</a></p>
<p id="section-1.1-9">Latency is not the only concern addressed by L4S: It was known when
        TCP congestion avoidance was first developed that it would not scale
        to high bandwidth-delay products (footnote 6 of Jacobson and
        KarelsÂ <span>[<a href="#TCP-CA" class="xref">TCP-CA</a>]</span>). Given regular broadband
        bit-rates over WAN distances are alreadyÂ <span>[<a href="#RFC3649" class="xref">RFC3649</a>]</span>
        beyond the scaling range of Reno congestion control, 'less unscalable'
        CubicÂ <span>[<a href="#RFC8312" class="xref">RFC8312</a>]</span> and CompoundÂ <span>[<a href="#I-D.sridharan-tcpm-ctcp" class="xref">I-D.sridharan-tcpm-ctcp</a>]</span> variants of TCP have been
        successfully deployed. However, these are now approaching their
        scaling limits. Unfortunately, fully scalable congestion controls such
        as DCTCPÂ <span>[<a href="#RFC8257" class="xref">RFC8257</a>]</span> outcompete Classic ECN
        congestion controls sharing the same queue, which is why they have
        been confined to private data centres or research testbeds.<a href="#section-1.1-9" class="pilcrow">Â¶</a></p>
<p id="section-1.1-10">It turns out that these scalable congestion control algorithms that
        solve the latency problem can also solve the scalability problem of
        Classic congestion controls. The finer sawteeth in the congestion
        window have low amplitude, so they cause very little queuing delay
        variation and the average time to recover from one congestion signal
        to the next (the average duration of each sawtooth) remains invariant,
        which maintains constant tight control as flow-rate scales. A
        background paperÂ <span>[<a href="#DCttH19" class="xref">DCttH19</a>]</span> gives the full
        explanation of why the design solves both the latency and the scaling
        problems, both in plain English and in more precise mathematical form.
        The explanation is summarised without the maths in Section 4 of the
        L4S architectureÂ <span>[<a href="#I-D.ietf-tsvwg-l4s-arch" class="xref">I-D.ietf-tsvwg-l4s-arch</a>]</span>.<a href="#section-1.1-10" class="pilcrow">Â¶</a></p>
</section>
</div>
<div id="l4sid_Terminology">
<section id="section-1.2">
        <h3 id="name-terminology-3">
<a href="#section-1.2" class="section-number selfRef">1.2. </a><a href="#name-terminology-3" class="section-name selfRef">Terminology</a>
        </h3>
<p id="section-1.2-1">The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
        "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and
        "OPTIONAL" in this document are to be interpreted as described in
        <span>[<a href="#RFC2119" class="xref">RFC2119</a>]</span>. In this document, these words will appear
        with that interpretation only when in ALL CAPS. Lower case uses of
        these words are not to be interpreted as carrying RFC-2119
        significance.<a href="#section-1.2-1" class="pilcrow">Â¶</a></p>
<p id="section-1.2-2">Note: The L4S architectureÂ <span>[<a href="#I-D.ietf-tsvwg-l4s-arch" class="xref">I-D.ietf-tsvwg-l4s-arch</a>]</span> repeats the following definitions,
        but if there are accidental differences those below take
        precedence.<a href="#section-1.2-2" class="pilcrow">Â¶</a></p>
<span class="break"></span><dl class="dlParallel" id="section-1.2-3">
          <dt id="section-1.2-3.1">Classic Congestion Control:</dt>
          <dd style="margin-left: 1.5em" id="section-1.2-3.2">A congestion control
            behaviour that can co-exist with standard RenoÂ <span>[<a href="#RFC5681" class="xref">RFC5681</a>]</span> without causing significantly negative impact
            on its flow rateÂ <span>[<a href="#RFC5033" class="xref">RFC5033</a>]</span>. With Classic
            congestion controls, such as Reno or Cubic, because flow rate has
            scaled since TCP congestion control was first designed in 1988, it
            now takes hundreds of round trips (and growing) to recover after a
            congestion signal (whether a loss or an ECN mark) as shown in the
            examples in section 5.1 of the L4S architectureÂ <span>[<a href="#I-D.ietf-tsvwg-l4s-arch" class="xref">I-D.ietf-tsvwg-l4s-arch</a>]</span> and in <span>[<a href="#RFC3649" class="xref">RFC3649</a>]</span>. Therefore control of queuing and utilization
            becomes very slack, and the slightest disturbances (e.g.Â from
            new flows starting) prevent a high rate from being attained.<a href="#section-1.2-3.2" class="pilcrow">Â¶</a>
</dd>
          <dd class="break"></dd>
<dt id="section-1.2-3.3">Scalable Congestion Control:</dt>
          <dd style="margin-left: 1.5em" id="section-1.2-3.4">A congestion control
            where the average time from one congestion signal to the next (the
            recovery time) remains invariant as the flow rate scales, all
            other factors being equal. This maintains the same degree of
            control over queueing and utilization whatever the flow rate, as
            well as ensuring that high throughput is robust to disturbances.
            For instance, DCTCP averages 2 congestion signals per round-trip
            whatever the flow rate, as do other recently developed scalable
            congestion controls, e.g.Â Relentless TCPÂ <span>[<a href="#Mathis09" class="xref">Mathis09</a>]</span>, TCP Prague <span>[<a href="#I-D.briscoe-iccrg-prague-congestion-control" class="xref">I-D.briscoe-iccrg-prague-congestion-control</a>]</span>, <span>[<a href="#PragueLinux" class="xref">PragueLinux</a>]</span>, BBRv2 <span>[<a href="#BBRv2" class="xref">BBRv2</a>]</span>, <span>[<a href="#I-D.cardwell-iccrg-bbr-congestion-control" class="xref">I-D.cardwell-iccrg-bbr-congestion-control</a>]</span> and the L4S
            variant of SCREAM for real-time mediaÂ <span>[<a href="#SCReAM" class="xref">SCReAM</a>]</span>,Â <span>[<a href="#RFC8298" class="xref">RFC8298</a>]</span>). See <a href="#l4sid_congestion_response" class="xref">Section 4.3</a> for more explanation.<a href="#section-1.2-3.4" class="pilcrow">Â¶</a>
</dd>
          <dd class="break"></dd>
<dt id="section-1.2-3.5">Classic service:</dt>
          <dd style="margin-left: 1.5em" id="section-1.2-3.6">The Classic service is intended for
            all the congestion control behaviours that co-exist with
            RenoÂ <span>[<a href="#RFC5681" class="xref">RFC5681</a>]</span> (e.g.Â Reno itself,
            CubicÂ <span>[<a href="#RFC8312" class="xref">RFC8312</a>]</span>, CompoundÂ <span>[<a href="#I-D.sridharan-tcpm-ctcp" class="xref">I-D.sridharan-tcpm-ctcp</a>]</span>, TFRCÂ <span>[<a href="#RFC5348" class="xref">RFC5348</a>]</span>). The term 'Classic queue' means a queue
            providing the Classic service.<a href="#section-1.2-3.6" class="pilcrow">Â¶</a>
</dd>
          <dd class="break"></dd>
<dt id="section-1.2-3.7">Low-Latency, Low-Loss Scalable throughput (L4S) service:</dt>
          <dd style="margin-left: 1.5em" id="section-1.2-3.8">
            <p id="section-1.2-3.8.1">The
            'L4S' service is intended for traffic from scalable congestion
            control algorithms, such as TCP Prague <span>[<a href="#I-D.briscoe-iccrg-prague-congestion-control" class="xref">I-D.briscoe-iccrg-prague-congestion-control</a>]</span>, which was
            derived from DCTCPÂ <span>[<a href="#RFC8257" class="xref">RFC8257</a>]</span>. The L4S service
            is for more general traffic than just TCP Prague -- it allows
            the set of congestion controls with similar scaling properties to
            Prague to evolve, such as the examples listed above (Relentless,
            SCReAM). The term 'L4S queue' means a queue providing the L4S
            service.<a href="#section-1.2-3.8.1" class="pilcrow">Â¶</a></p>
<p id="section-1.2-3.8.2">The terms Classic or L4S can also
            qualify other nouns, such as 'queue', 'codepoint', 'identifier',
            'classification', 'packet', 'flow'. For example: an L4S packet
            means a packet with an L4S identifier sent from an L4S congestion
            control.<a href="#section-1.2-3.8.2" class="pilcrow">Â¶</a></p>
<p id="section-1.2-3.8.3">Both Classic and L4S services can
            cope with a proportion of unresponsive or less-responsive traffic
            as well, but in the L4S case its rate has to be smooth enough or
            low enough not to build a queue (e.g.Â DNS, VoIP, game sync
            datagrams, etc).<a href="#section-1.2-3.8.3" class="pilcrow">Â¶</a></p>
</dd>
          <dd class="break"></dd>
<dt id="section-1.2-3.9">Reno-friendly:</dt>
          <dd style="margin-left: 1.5em" id="section-1.2-3.10">The subset of Classic traffic that is
            friendly to the standard Reno congestion control defined for TCP
            in <span>[<a href="#RFC5681" class="xref">RFC5681</a>]</span>. The TFRC spec.Â <span>[<a href="#RFC5348" class="xref">RFC5348</a>]</span> indirectly implies that 'friendly' is defined
            as "generally within a factor of two of the sending rate of a TCP
            flow under the same conditions". Reno-friendly is used here in
            place of 'TCP-friendly', given the latter has become imprecise,
            because the TCP protocol is now used with so many different
            congestion control behaviours, and Reno is used in non-TCP
            transports such as QUICÂ <span>[<a href="#RFC9000" class="xref">RFC9000</a>]</span>.<a href="#section-1.2-3.10" class="pilcrow">Â¶</a>
</dd>
          <dd class="break"></dd>
<dt id="section-1.2-3.11">Classic ECN:</dt>
          <dd style="margin-left: 1.5em" id="section-1.2-3.12">The original Explicit Congestion
            Notification (ECN) protocolÂ <span>[<a href="#RFC3168" class="xref">RFC3168</a>]</span>, which
            requires ECN signals to be treated the same as drops, both when
            generated in the network and when responded to by the sender. For
            L4S, the names used for the four codepoints of the 2-bit IP-ECN
            field are unchanged from those defined in <span>[<a href="#RFC3168" class="xref">RFC3168</a>]</span>: Not ECT, ECT(0), ECT(1) and CE, where ECT
            stands for ECN-Capable Transport and CE stands for Congestion
            Experienced. A packet marked with the CE codepoint is termed
            'ECN-marked' or sometimes just 'marked' where the context makes
            ECN obvious.<a href="#section-1.2-3.12" class="pilcrow">Â¶</a>
</dd>
          <dd class="break"></dd>
<dt id="section-1.2-3.13">Site:</dt>
          <dd style="margin-left: 1.5em" id="section-1.2-3.14">A home, mobile device, small enterprise or
            campus, where the network bottleneck is typically the access link
            to the site. Not all network arrangements fit this model but it is
            a useful, widely applicable generalization.<a href="#section-1.2-3.14" class="pilcrow">Â¶</a>
</dd>
        <dd class="break"></dd>
</dl>
</section>
</div>
<section id="section-1.3">
        <h3 id="name-scope">
<a href="#section-1.3" class="section-number selfRef">1.3. </a><a href="#name-scope" class="section-name selfRef">Scope</a>
        </h3>
<p id="section-1.3-1">The new L4S identifier defined in this specification is applicable
        for IPv4 and IPv6 packets (as for Classic ECNÂ <span>[<a href="#RFC3168" class="xref">RFC3168</a>]</span>). It is applicable for the unicast, multicast and
        anycast forwarding modes.<a href="#section-1.3-1" class="pilcrow">Â¶</a></p>
<p id="section-1.3-2">The L4S identifier is an orthogonal packet classification to the
        Differentiated Services Code Point (DSCP)Â <span>[<a href="#RFC2474" class="xref">RFC2474</a>]</span>. <a href="#l4sid_other_IDs" class="xref">Section 5.4</a> explains what
        this means in practice.<a href="#section-1.3-2" class="pilcrow">Â¶</a></p>
<p id="section-1.3-3">This document is intended for experimental status, so it does not
        update any standards track RFCs. Therefore it depends on <span>[<a href="#RFC8311" class="xref">RFC8311</a>]</span>, which is a standards track specification
        that:<a href="#section-1.3-3" class="pilcrow">Â¶</a></p>
<ul class="normal">
<li class="normal" id="section-1.3-4.1">updates the ECN proposed standardÂ <span>[<a href="#RFC3168" class="xref">RFC3168</a>]</span>
            to allow experimental track RFCs to relax the requirement that an
            ECN mark must be equivalent to a drop (when the network applies
            markings and/or when the sender responds to them). For instance,
            in the ABE experimentÂ <span>[<a href="#RFC8511" class="xref">RFC8511</a>]</span> this permits a
            sender to respond less to ECN marks than to drops;<a href="#section-1.3-4.1" class="pilcrow">Â¶</a>
</li>
          <li class="normal" id="section-1.3-4.2">changes the status of the experimental ECN nonceÂ <span>[<a href="#RFC3540" class="xref">RFC3540</a>]</span> to historic;<a href="#section-1.3-4.2" class="pilcrow">Â¶</a>
</li>
          <li class="normal" id="section-1.3-4.3">
            <p id="section-1.3-4.3.1">makes consequent updates to the following additional proposed
            standard RFCs to reflect the above two bullets:<a href="#section-1.3-4.3.1" class="pilcrow">Â¶</a></p>
<ul class="normal">
<li class="normal" id="section-1.3-4.3.2.1">ECN for RTPÂ <span>[<a href="#RFC6679" class="xref">RFC6679</a>]</span>;<a href="#section-1.3-4.3.2.1" class="pilcrow">Â¶</a>
</li>
              <li class="normal" id="section-1.3-4.3.2.2">the congestion control specifications of various DCCP
                congestion control identifier (CCID) profilesÂ <span>[<a href="#RFC4341" class="xref">RFC4341</a>]</span>, <span>[<a href="#RFC4342" class="xref">RFC4342</a>]</span>, <span>[<a href="#RFC5622" class="xref">RFC5622</a>]</span>.<a href="#section-1.3-4.3.2.2" class="pilcrow">Â¶</a>
</li>
            </ul>
</li>
        </ul>
<p id="section-1.3-5">This document is about identifiers that are used for interoperation
        between hosts and networks. So the audience is broad, covering
        developers of host transports and network AQMs, as well as covering
        how operators might wish to combine various identifiers, which would
        require flexibility from equipment developers.<a href="#section-1.3-5" class="pilcrow">Â¶</a></p>
</section>
</section>
</div>
<div id="l4sid_reqs">
<section id="section-2">
      <h2 id="name-choice-of-l4s-packet-identi">
<a href="#section-2" class="section-number selfRef">2. </a><a href="#name-choice-of-l4s-packet-identi" class="section-name selfRef">Choice of L4S Packet Identifier: Requirements</a>
      </h2>
<p id="section-2-1">This subsection briefly records the process that led to the chosen
      L4S identifier.<a href="#section-2-1" class="pilcrow">Â¶</a></p>
<p id="section-2-2">The identifier for packets using the Low Latency, Low Loss, Scalable
      throughput (L4S) service needs to meet the following requirements:<a href="#section-2-2" class="pilcrow">Â¶</a></p>
<ul class="normal">
<li class="normal" id="section-2-3.1">it SHOULD survive end-to-end between source and destination
          end-points: across the boundary between host and network, between
          interconnected networks, and through middleboxes;<a href="#section-2-3.1" class="pilcrow">Â¶</a>
</li>
        <li class="normal" id="section-2-3.2">it SHOULD be visible at the IP layer;<a href="#section-2-3.2" class="pilcrow">Â¶</a>
</li>
        <li class="normal" id="section-2-3.3">it SHOULD be common to IPv4 and IPv6 and transport-agnostic;<a href="#section-2-3.3" class="pilcrow">Â¶</a>
</li>
        <li class="normal" id="section-2-3.4">it SHOULD be incrementally deployable;<a href="#section-2-3.4" class="pilcrow">Â¶</a>
</li>
        <li class="normal" id="section-2-3.5">it SHOULD enable an AQM to classify packets encapsulated by outer
          IP or lower-layer headers;<a href="#section-2-3.5" class="pilcrow">Â¶</a>
</li>
        <li class="normal" id="section-2-3.6">it SHOULD consume minimal extra codepoints;<a href="#section-2-3.6" class="pilcrow">Â¶</a>
</li>
        <li class="normal" id="section-2-3.7">it SHOULD be consistent on all the packets of a transport layer
          flow, so that some packets of a flow are not served by a different
          queue to others.<a href="#section-2-3.7" class="pilcrow">Â¶</a>
</li>
      </ul>
<p id="section-2-4">Whether the identifier would be recoverable if the experiment failed
      is a factor that could be taken into account. However, this has not been
      made a requirement, because that would favour schemes that would be
      easier to fail, rather than those more likely to succeed.<a href="#section-2-4" class="pilcrow">Â¶</a></p>
<p id="section-2-5">It is recognised that any choice of identifier is unlikely to satisfy
      all these requirements, particularly given the limited space left in the
      IP header. Therefore a compromise will always be necessary, which is why
      all the above requirements are expressed with the word 'SHOULD' not
      'MUST'.<a href="#section-2-5" class="pilcrow">Â¶</a></p>
<p id="section-2-6">After extensive assessment of alternative schemes, "ECT(1) and CE
      codepoints" was chosen as the best compromise. Therefore this scheme is
      defined in detail in the following sections, while <a href="#l4sid_ECT1_CE" class="xref">Appendix B</a> records its pros and cons against the above
      requirements.<a href="#section-2-6" class="pilcrow">Â¶</a></p>
</section>
</div>
<div id="l4sid_identification">
<section id="section-3">
      <h2 id="name-l4s-packet-identification">
<a href="#section-3" class="section-number selfRef">3. </a><a href="#name-l4s-packet-identification" class="section-name selfRef">L4S Packet Identification</a>
      </h2>
<p id="section-3-1">The L4S treatment is an experimental track alternative packet marking
      treatment to the Classic ECN treatment in <span>[<a href="#RFC3168" class="xref">RFC3168</a>]</span>,
      which has been updated by <span>[<a href="#RFC8311" class="xref">RFC8311</a>]</span> to allow experiments
      such as the one defined in the present specification. <span>[<a href="#RFC4774" class="xref">RFC4774</a>]</span> discusses some of the issues and evaluation criteria
      when defining alternative ECN semantics. Like Classic ECN, L4S ECN
      identifies both network and host behaviour: it identifies the marking
      treatment that network nodes are expected to apply to L4S packets, and
      it identifies packets that have been sent from hosts that are expected
      to comply with a broad type of sending behaviour.<a href="#section-3-1" class="pilcrow">Â¶</a></p>
<p id="section-3-2">For a packet to receive L4S treatment as it is forwarded, the sender
      sets the ECN field in the IP header to the ECT(1) codepoint. See <a href="#l4sid_transport_req" class="xref">Section 4</a> for full transport layer behaviour
      requirements, including feedback and congestion response.<a href="#section-3-2" class="pilcrow">Â¶</a></p>
<p id="section-3-3">A network node that implements the L4S service always classifies
      arriving ECT(1) packets for L4S treatment and by default classifies CE
      packets for L4S treatment unless the heuristics described in <a href="#l4sid_identification_transport_aware" class="xref">Section 5.3</a> are employed. See <a href="#l4sid_network_req" class="xref">Section 5</a> for full network element behaviour
      requirements, including classification, ECN-marking and interaction of
      the L4S identifier with other identifiers and per-hop behaviours.<a href="#section-3-3" class="pilcrow">Â¶</a></p>
</section>
</div>
<div id="l4sid_transport_req">
<section id="section-4">
      <h2 id="name-transport-layer-behaviour-t">
<a href="#section-4" class="section-number selfRef">4. </a><a href="#name-transport-layer-behaviour-t" class="section-name selfRef">Transport Layer Behaviour (the 'Prague Requirements')</a>
      </h2>
<p id="section-4-1"></p>
<div id="l4sid_codepoint">
<section id="section-4.1">
        <h3 id="name-codepoint-setting">
<a href="#section-4.1" class="section-number selfRef">4.1. </a><a href="#name-codepoint-setting" class="section-name selfRef">Codepoint Setting</a>
        </h3>
<p id="section-4.1-1">A sender that wishes a packet to receive L4S treatment as it is
        forwarded, MUST set the ECN field in the IP header (v4 or v6) to the
        ECT(1) codepoint.<a href="#section-4.1-1" class="pilcrow">Â¶</a></p>
</section>
</div>
<div id="l4sid_feedback">
<section id="section-4.2">
        <h3 id="name-prerequisite-transport-feed">
<a href="#section-4.2" class="section-number selfRef">4.2. </a><a href="#name-prerequisite-transport-feed" class="section-name selfRef">Prerequisite Transport Feedback</a>
        </h3>
<p id="section-4.2-1">For a transport protocol to provide scalable congestion control
        (<a href="#l4sid_congestion_response" class="xref">Section 4.3</a>) it MUST provide feedback
        of the extent of CE marking on the forward path. When ECN was added to
        TCPÂ <span>[<a href="#RFC3168" class="xref">RFC3168</a>]</span>, the feedback method reported no
        more than one CE mark per round trip. Some transport protocols derived
        from TCP mimic this behaviour while others report the accurate extent
        of ECN marking. This means that some transport protocols will need to
        be updated as a prerequisite for scalable congestion control. The
        position for a few well-known transport protocols is given below.<a href="#section-4.2-1" class="pilcrow">Â¶</a></p>
<span class="break"></span><dl class="dlParallel" id="section-4.2-2">
          <dt id="section-4.2-2.1">TCP:</dt>
          <dd style="margin-left: 1.5em" id="section-4.2-2.2">Support for the accurate ECN feedback
            requirementsÂ <span>[<a href="#RFC7560" class="xref">RFC7560</a>]</span> (such as that provided
            by AccECNÂ <span>[<a href="#I-D.ietf-tcpm-accurate-ecn" class="xref">I-D.ietf-tcpm-accurate-ecn</a>]</span>) by
            both ends is a prerequisite for scalable congestion control in
            TCP. Therefore, the presence of ECT(1) in the IP headers even in
            one direction of a TCP connection will imply that both ends
            support accurate ECN feedback. However, the converse does not
            apply. So even if both ends support AccECN, either of the two ends
            can choose not to use a scalable congestion control, whatever the
            other end's choice.<a href="#section-4.2-2.2" class="pilcrow">Â¶</a>
</dd>
          <dd class="break"></dd>
<dt id="section-4.2-2.3">SCTP:</dt>
          <dd style="margin-left: 1.5em" id="section-4.2-2.4">A suitable ECN feedback mechanism for SCTP
            could add a chunk to report the number of received CE marks
            (e.g.Â <span>[<a href="#I-D.stewart-tsvwg-sctpecn" class="xref">I-D.stewart-tsvwg-sctpecn</a>]</span>), and update
            the ECN feedback protocol sketched out in Appendix A of the
            original standards track specification of SCTPÂ <span>[<a href="#RFC4960" class="xref">RFC4960</a>]</span>.<a href="#section-4.2-2.4" class="pilcrow">Â¶</a>
</dd>
          <dd class="break"></dd>
<dt id="section-4.2-2.5">RTP over UDP:</dt>
          <dd style="margin-left: 1.5em" id="section-4.2-2.6">A prerequisite for scalable congestion
            control is for both (all) ends of one media-level hop to signal
            ECN supportÂ <span>[<a href="#RFC6679" class="xref">RFC6679</a>]</span> and use the new generic
            RTCP feedback format of <span>[<a href="#RFC8888" class="xref">RFC8888</a>]</span>. The presence of
            ECT(1) implies that both (all) ends of that media-level hop
            support ECN. However, the converse does not apply. So each end of
            a media-level hop can independently choose not to use a scalable
            congestion control, even if both ends support ECN.<a href="#section-4.2-2.6" class="pilcrow">Â¶</a>
</dd>
          <dd class="break"></dd>
<dt id="section-4.2-2.7">QUIC:</dt>
          <dd style="margin-left: 1.5em" id="section-4.2-2.8">Support for sufficiently fine-grained ECN
            feedback is provided by the v1 IETF QUIC transportÂ <span>[<a href="#RFC9000" class="xref">RFC9000</a>]</span>.<a href="#section-4.2-2.8" class="pilcrow">Â¶</a>
</dd>
          <dd class="break"></dd>
<dt id="section-4.2-2.9">DCCP:</dt>
          <dd style="margin-left: 1.5em" id="section-4.2-2.10">The ACK vector in DCCPÂ <span>[<a href="#RFC4340" class="xref">RFC4340</a>]</span> is already sufficient to report the extent of
            CE marking as needed by a scalable congestion control.<a href="#section-4.2-2.10" class="pilcrow">Â¶</a>
</dd>
        <dd class="break"></dd>
</dl>
</section>
</div>
<div id="l4sid_congestion_response">
<section id="section-4.3">
        <h3 id="name-prerequisite-congestion-res">
<a href="#section-4.3" class="section-number selfRef">4.3. </a><a href="#name-prerequisite-congestion-res" class="section-name selfRef">Prerequisite Congestion Response</a>
        </h3>
<p id="section-4.3-1">As a condition for a host to send packets with the L4S identifier
        (ECT(1)), it SHOULD implement a congestion control behaviour that
        ensures that, in steady state, the average duration between induced
        ECN marks does not increase as flow rate scales up, all other factors
        being equal. This is termed a scalable congestion control. This
        invariant duration ensures that, as flow rate scales, the average
        period with no feedback information about capacity does not become
        excessive. It also ensures that queue variations remain small, without
        having to sacrifice utilization.<a href="#section-4.3-1" class="pilcrow">Â¶</a></p>
<p id="section-4.3-2">With a congestion control that sawtooths to probe capacity, this
        duration is called the recovery time, because each time the sawtooth
        yields, on average it take this time to recover to its previous high
        point. A scalable congestion control does not have to sawtooth, but it
        has to coexist with scalable congestion controls that do.<a href="#section-4.3-2" class="pilcrow">Â¶</a></p>
<p id="section-4.3-3">For instance, for DCTCPÂ <span>[<a href="#RFC8257" class="xref">RFC8257</a>]</span>, TCP Prague
        <span>[<a href="#I-D.briscoe-iccrg-prague-congestion-control" class="xref">I-D.briscoe-iccrg-prague-congestion-control</a>]</span>,Â <span>[<a href="#PragueLinux" class="xref">PragueLinux</a>]</span> and the L4S variant of SCReAMÂ <span>[<a href="#RFC8298" class="xref">RFC8298</a>]</span>, the average recovery time is always half a round
        trip (or half a reference round trip), whatever the flow rate.<a href="#section-4.3-3" class="pilcrow">Â¶</a></p>
<p id="section-4.3-4">As with all transport behaviours, a detailed specification
        (probably an experimental RFC) is expected for each congestion
        control, following the guidelines for specifying new congestion
        control algorithms inÂ <span>[<a href="#RFC5033" class="xref">RFC5033</a>]</span>. In addition it is
        expected to document these L4S-specific matters, specifically the
        timescale over which the proportionality is averaged, and control of
        burstiness. The recovery time requirement above is worded as a
        'SHOULD' rather than a 'MUST' to allow reasonable flexibility for such
        implementations.<a href="#section-4.3-4" class="pilcrow">Â¶</a></p>
<p id="section-4.3-5">The condition 'all other factors being equal', allows the recovery
        time to be different for different round trip times, as long as it
        does not increase with flow rate for any particular RTT.<a href="#section-4.3-5" class="pilcrow">Â¶</a></p>
<p id="section-4.3-6">Saying that the recovery time remains roughly invariant is
        equivalent to saying that the number of ECN CE marks per round trip
        remains invariant as flow rate scales, all other factors being equal.
        For instance, an average recovery time of half of 1 RTT is equivalent
        to 2 ECN marks per round trip. For those familiar with steady-state
        congestion response functions, it is also equivalent to say that the
        congestion window is inversely proportional to the proportion of bytes
        in packets marked with the CE codepoint (see section 2 of <span>[<a href="#PI2" class="xref">PI2</a>]</span>).<a href="#section-4.3-6" class="pilcrow">Â¶</a></p>
<p id="section-4.3-7">In order to coexist safely with other Internet traffic, a scalable
        congestion control MUST NOT tag its packets with the ECT(1) codepoint
        unless it complies with the following bulleted requirements:<a href="#section-4.3-7" class="pilcrow">Â¶</a></p>
<ol start="1" type="1" class="normal type-1" id="section-4.3-8">
<li id="section-4.3-8.1">A scalable congestion control MUST be capable of being replaced
            by a Classic congestion control (by application and/or by
            administrative control). If a Classic congestion control is
            activated, it will not tag its packets with the ECT(1) codepoint
            (see <a href="#l4sid_sec_replaceable" class="xref">Appendix A.1.3</a> for rationale).<a href="#section-4.3-8.1" class="pilcrow">Â¶</a>
</li>
          <li id="section-4.3-8.2">As well as responding to ECN markings, a scalable congestion
            control MUST react to packet loss in a way that will coexist
            safely with Classic congestion controls such as standard
            RenoÂ <span>[<a href="#RFC5681" class="xref">RFC5681</a>]</span>, as required by <span>[<a href="#RFC5033" class="xref">RFC5033</a>]</span> (see <a href="#l4sid_sec_fallback_on_loss" class="xref">Appendix A.1.4</a> for rationale).<a href="#section-4.3-8.2" class="pilcrow">Â¶</a>
</li>
          <li id="section-4.3-8.3">
            <p id="section-4.3-8.3.1">In uncontrolled environments, monitoring MUST be implemented to
            support detection of problems with an ECN-capable AQM at the path
            bottleneck that appears not to support L4S and might be in a
            shared queue. Such monitoring SHOULD be applied to live traffic
            that is using Scalable congestion control. Alternatively,
            monitoring need not be applied to live traffic, if monitoring has
            been arranged to cover the paths that live traffic takes through
            uncontrolled environments.<a href="#section-4.3-8.3.1" class="pilcrow">Â¶</a></p>
<p id="section-4.3-8.3.2">A function to
            detect the above problems with an ECN-capable AQM MUST also be
            implemented and used. The detection function SHOULD be capable of
            making the congestion control adapt its ECN-marking response in
            real-time to coexist safely with Classic congestion controls such
            as standard RenoÂ <span>[<a href="#RFC5681" class="xref">RFC5681</a>]</span>, as required by
            <span>[<a href="#RFC5033" class="xref">RFC5033</a>]</span>. This could be complemented by more
            detailed offline detection of potential problems. If only offline
            detection is used and potential problems with such an AQM are
            detected on certain paths, the scalable congestion control MUST be
            replaced by a Classic congestion control, at least for the problem
            paths.<a href="#section-4.3-8.3.2" class="pilcrow">Â¶</a></p>
<p id="section-4.3-8.3.3">See <a href="#l4sid_congestion_response_rfcs" class="xref">Section 4.3.1</a>, <a href="#l4sid_sec_fallback_on_classic_CE" class="xref">Appendix A.1.5</a> and the L4S
            operational guidanceÂ <span>[<a href="#I-D.ietf-tsvwg-l4sops" class="xref">I-D.ietf-tsvwg-l4sops</a>]</span>
            for rationale.<a href="#section-4.3-8.3.3" class="pilcrow">Â¶</a></p>
<p id="section-4.3-8.3.4">Note that a scalable
            congestion control is not expected to change to setting ECT(0)
            while it transiently adapts to coexist with Classic congestion
            controls, whereas a replacement congestion control that solely
            behaves in the Classic way will set ECT(0).<a href="#section-4.3-8.3.4" class="pilcrow">Â¶</a></p>
</li>
          <li id="section-4.3-8.4">In the range between the minimum likely RTT and typical RTTs
            expected in the intended deployment scenario, a scalable
            congestion control MUST converge towards a rate that is as
            independent of RTT as is possible without compromising stability
            or efficiency (see <a href="#l4sid_sec_RTT_dependence" class="xref">Appendix A.1.6</a> for
            rationale).<a href="#section-4.3-8.4" class="pilcrow">Â¶</a>
</li>
          <li id="section-4.3-8.5">A scalable congestion control SHOULD remain responsive to
            congestion when typical RTTs over the public Internet are
            significantly smaller because they are no longer inflated by
            queuing delay. It would be preferable for the minimum window of a
            scalable congestion control to be lower than 1 segment rather than
            use the timeout approach described for TCP in S.6.1.2 of the ECN
            specÂ <span>[<a href="#RFC3168" class="xref">RFC3168</a>]</span> (or an equivalent for other
            transports). However, a lower minimum is not set as a formal
            requirement for L4S experiments (see <a href="#l4sid_sec_min_cwnd" class="xref">Appendix A.1.7</a> for rationale).<a href="#section-4.3-8.5" class="pilcrow">Â¶</a>
</li>
          <li id="section-4.3-8.6">A scalable congestion control's loss detection SHOULD be
            resilient to reordering over an adaptive time interval that scales
            with throughput and adapts to reordering (as in RACKÂ <span>[<a href="#RFC8985" class="xref">RFC8985</a>]</span>), as opposed to counting only in fixed units of
            packets (as in the 3 DupACK rule of New RenoÂ <span>[<a href="#RFC5681" class="xref">RFC5681</a>]</span> and <span>[<a href="#RFC6675" class="xref">RFC6675</a>]</span>, which is not
            scalable). As data rates increase (e.g., due to new and/or
            improved technology), congestion controls that detect loss by
            counting in units of packets become more likely to incorrectly
            treat reordering events as congestion-caused loss events (see
            <a href="#l4sid_sec_reordering_tolerance" class="xref">Appendix A.1.8</a> for further
            rationale). This requirement does not apply to congestion controls
            that are solely used in controlled environments where the network
            introduces hardly any reordering.<a href="#section-4.3-8.6" class="pilcrow">Â¶</a>
</li>
          <li id="section-4.3-8.7">A scalable congestion control is expected to limit the queue
            caused by bursts of packets. It would not seem necessary to set
            the limit any lower than 10% of the minimum RTT expected in a
            typical deployment (e.g.Â additional queuing of roughly 250 us
            for the public Internet). This would be converted to a number of
            packets under the worst-case assumption that the bottleneck link
            capacity equals the current flow rate. No normative requirement to
            limit bursts is given here and, until there is more industry
            experience from the L4S experiment, it is not even known whether
            one is needed - it seems to be in an L4S sender's self-interest to
            limit bursts.<a href="#section-4.3-8.7" class="pilcrow">Â¶</a>
</li>
        </ol>
<p id="section-4.3-9">Each sender in a session can use a scalable congestion control
        independently of the congestion control used by the receiver(s) when
        they send data. Therefore there might be ECT(1) packets in one
        direction and ECT(0) or Not-ECT in the other.<a href="#section-4.3-9" class="pilcrow">Â¶</a></p>
<p id="section-4.3-10">Later (<a href="#l4sid_inclusion_dualq" class="xref">Section 5.4.1.1</a>) this document
        discusses the conditions for mixing other "'Safe' Unresponsive
        Traffic" (e.g.Â DNS, LDAP, NTP, voice, game sync packets) with L4S
        traffic. To be clear, although such traffic can share the same queue
        as L4S traffic, it is not appropriate for the sender to tag it as
        ECT(1), except in the (unlikely) case that it satisfies the above
        conditions.<a href="#section-4.3-10" class="pilcrow">Â¶</a></p>
<div id="l4sid_congestion_response_rfcs">
<section id="section-4.3.1">
          <h4 id="name-guidance-on-congestion-resp">
<a href="#section-4.3.1" class="section-number selfRef">4.3.1. </a><a href="#name-guidance-on-congestion-resp" class="section-name selfRef">Guidance on Congestion Response in the RFC Series</a>
          </h4>
<p id="section-4.3.1-1">RFCÂ 3168 requires the congestion responses to a CE-marked
          packet and a dropped packet to be the same. RFCÂ 8311 is a
          standards-track update to RFCÂ 3168 intended to enable
          experimentation with ECN, including the L4S experiment.
          RFCÂ 8311 allows an experimental congestion control's response
          to a CE-marked packet to differ from the response to a dropped
          packet, provided that the differences are documented in an
          experimental RFC, such as the present document.<a href="#section-4.3.1-1" class="pilcrow">Â¶</a></p>
<p id="section-4.3.1-2">BCPÂ 124Â <span>[<a href="#RFC4774" class="xref">RFC4774</a>]</span> gives guidance to
          protocol designers, when specifying alternative semantics for the
          ECN field. RFCÂ 8311 explained that it did not need to update
          the best current practice in BCPÂ 124 in order to relax the
          'equivalence with drop' requirement because, although BCPÂ 124
          quotes the same requirement from RFCÂ 3168, the BCP does not
          impose requirements based on it. BCPÂ 124 describes three
          options for incremental deployment, with Option 3 (in Section 4.3 of
          BCPÂ 124) best matching the L4S case. Option 3's requirement for
          end-nodes is that they respond to CE marks "in a way that is
          friendly to flows using IETF-conformant congestion control." This
          echoes other general congestion control requirements in the RFC
          series, for example <span>[<a href="#RFC5033" class="xref">RFC5033</a>]</span>, which says
          "...congestion controllers that have a significantly negative impact
          on traffic using standard congestion control may be suspect", or
          <span>[<a href="#RFC8085" class="xref">RFC8085</a>]</span> concerning UDP congestion control says
          "Bulk-transfer applications that choose not to implement TFRC or
          TCP-like windowing SHOULD implement a congestion control scheme that
          results in bandwidth (capacity) use that competes fairly with TCP
          within an order of magnitude."<a href="#section-4.3.1-2" class="pilcrow">Â¶</a></p>
<p id="section-4.3.1-3">The third normative bullet in <a href="#l4sid_congestion_response" class="xref">Section 4.3</a> above (which concerns L4S
          response to congestion from a Classic ECN AQM) aims to ensure that
          these 'coexistence' requirements are satisfied, but it makes some
          compromises. This subsection highlights and justifies those
          compromises and <a href="#l4sid_sec_fallback_on_classic_CE" class="xref">Appendix A.1.5</a>
          and the L4S operational guidanceÂ <span>[<a href="#I-D.ietf-tsvwg-l4sops" class="xref">I-D.ietf-tsvwg-l4sops</a>]</span> give detailed analysis, examples
          and references (the normative text in that bullet takes precedence
          if any informative elaboration leads to ambiguity). The approach is
          based on an assessment of the risk of harm, which is a combination
          of the prevalence of the conditions necessary for harm to occur, and
          the potential severity of the harm if they do.<a href="#section-4.3.1-3" class="pilcrow">Â¶</a></p>
<span class="break"></span><dl class="dlParallel" id="section-4.3.1-4">
            <dt id="section-4.3.1-4.1">Prevalence:</dt>
            <dd style="margin-left: 1.5em" id="section-4.3.1-4.2">
              <p id="section-4.3.1-4.2.1">There are three cases:<a href="#section-4.3.1-4.2.1" class="pilcrow">Â¶</a></p>
<ul class="normal">
<li class="normal" id="section-4.3.1-4.2.2.1">Drop Tail: Coexistence between L4S and Classic flows is
                  not in doubt where the bottleneck does not support any form
                  of ECN, which has remained by far the most prevalent case
                  since the ECN RFC was published in 2001.<a href="#section-4.3.1-4.2.2.1" class="pilcrow">Â¶</a>
</li>
                <li class="normal" id="section-4.3.1-4.2.2.2">L4S: Coexistence is not in doubt if the bottleneck
                  supports L4S.<a href="#section-4.3.1-4.2.2.2" class="pilcrow">Â¶</a>
</li>
                <li class="normal" id="section-4.3.1-4.2.2.3">
                  <p id="section-4.3.1-4.2.2.3.1">Classic ECNÂ <span>[<a href="#RFC3168" class="xref">RFC3168</a>]</span>: The
                  compromises centre around cases where the bottleneck
                  supports Classic ECN but not L4S. But it depends on which
                  sub-case:<a href="#section-4.3.1-4.2.2.3.1" class="pilcrow">Â¶</a></p>
<ul class="normal">
<li class="normal" id="section-4.3.1-4.2.2.3.2.1">Shared Queue with Classic ECN: The members of the
                      Transport Working group are not aware of any current
                      deployments of single-queue Classic ECN bottlenecks in
                      the Internet. Nonetheless, at the scale of the Internet,
                      rarity need not imply small numbers, nor that there will
                      be rarity in future.<a href="#section-4.3.1-4.2.2.3.2.1" class="pilcrow">Â¶</a>
</li>
                    <li class="normal" id="section-4.3.1-4.2.2.3.2.2">
                      <p id="section-4.3.1-4.2.2.3.2.2.1">Per-Flow-queues with Classic ECN: Most AQMs with
                      per-flow-queuing (FQ) deployed from 2012 onwards had
                      Classic ECN enabled by default, specifically
                      FQ-CoDelÂ <span>[<a href="#RFC8290" class="xref">RFC8290</a>]</span> and
                      COBALTÂ <span>[<a href="#COBALT" class="xref">COBALT</a>]</span>. But the compromises
                      only apply to the second of two further sub-cases:<a href="#section-4.3.1-4.2.2.3.2.2.1" class="pilcrow">Â¶</a></p>
<ul class="normal">
<li class="normal" id="section-4.3.1-4.2.2.3.2.2.2.1">With per-flow-queuing, co-existence between
                          Classic and L4S flows is not normally a problem,
                          because different flows are not meant to be in the
                          same queue (BCPÂ 124Â <span>[<a href="#RFC4774" class="xref">RFC4774</a>]</span> did not foresee the introduction
                          of per-flow-queuing, which appeared as a potential
                          isolation technique some eight years after the BCP
                          was published).<a href="#section-4.3.1-4.2.2.3.2.2.2.1" class="pilcrow">Â¶</a>
</li>
                        <li class="normal" id="section-4.3.1-4.2.2.3.2.2.2.2">However, the isolation between L4S and Classic
                          flows is not perfect in cases where the hashes of
                          flow IDs collide or where multiple flows within a
                          layer-3 VPN are encapsulated within one flow ID.<a href="#section-4.3.1-4.2.2.3.2.2.2.2" class="pilcrow">Â¶</a>
</li>
                      </ul>
</li>
                  </ul>
</li>
              </ul>
<p id="section-4.3.1-4.2.3">To summarize, the coexistence problem is confined to
              cases of imperfect flow isolation in an FQ, or in potential
              cases where a Classic ECN AQM has been deployed in a shared
              queue (see the L4S operational guidanceÂ <span>[<a href="#I-D.ietf-tsvwg-l4sops" class="xref">I-D.ietf-tsvwg-l4sops</a>]</span> for further details including
              recent surveys attempting to quantify prevalence). Further, if
              one of these cases does occur, the coexistence problem does not
              arise unless sources of Classic and L4S flows are simultaneously
              sharing the same bottleneck queue (e.g.Â different
              applications in the same household) and flows of each type have
              to be large enough to coincide for long enough for any
              throughput imbalance to have developed.<a href="#section-4.3.1-4.2.3" class="pilcrow">Â¶</a></p>
</dd>
            <dd class="break"></dd>
<dt id="section-4.3.1-4.3">Severity:</dt>
            <dd style="margin-left: 1.5em" id="section-4.3.1-4.4">Where long-running L4S and Classic flows
              coincide in a shared queue, testing of one L4S congestion
              control (TCP Prague) has found that the imbalance in average
              throughput between an L4S and a Classic flow can reach 25:1 in
              favour of L4S in the worst caseÂ <span>[<a href="#ecn-fallback" class="xref">ecn-fallback</a>]</span>. However, when capacity is most scarce,
              the Classic flow gets a higher proportion of the link, for
              instance over a 4 Mb/s link the throughput ratio is below ~10:1
              over paths with a base RTT below 100 ms, and falls below ~5:1
              for base RTTs below 20ms.<a href="#section-4.3.1-4.4" class="pilcrow">Â¶</a>
</dd>
          <dd class="break"></dd>
</dl>
<p id="section-4.3.1-5">These throughput ratios can clearly fall well outside current RFC
          guidance on coexistence. However, the tendency towards leaving a
          greater share for Classic flows at lower link rate and the very
          limited prevalence of the conditions necessary for harm to occur led
          to the possibility of allowing the RFC requirements to be
          compromised, albeit briefly:<a href="#section-4.3.1-5" class="pilcrow">Â¶</a></p>
<ul class="normal">
<li class="normal" id="section-4.3.1-6.1">The recommended approach is still to detect and adapt to a
              Classic ECN AQM in real-time, which is fully consistent with all
              the RFCs on coexistence. In other words, the "SHOULD"s in the
              third bullet of <a href="#l4sid_congestion_response" class="xref">Section 4.3</a> above
              expect the sender to implement something similar to the proof of
              concept code that detects the presence of a Classic ECN AQM and
              falls back to a Classic congestion response within a few round
              tripsÂ <span>[<a href="#ecn-fallback" class="xref">ecn-fallback</a>]</span>. However, although this
              code reliably detects a Classic ECN AQM, the current code can
              also wrongly categorize an L4S AQM as Classic, most often in
              cases when link rate is low or RTT is high. Although this is the
              safe way round, and although implementers are expected to be
              able to improve on this proof of concept, concerns have been
              raised that implementers might lose faith in such detection and
              disable it.<a href="#section-4.3.1-6.1" class="pilcrow">Â¶</a>
</li>
            <li class="normal" id="section-4.3.1-6.2">Therefore the third bullet in <a href="#l4sid_congestion_response" class="xref">Section 4.3</a> above allows a compromise
              where coexistence could diverge from the requirements in the RFC
              Series briefly, but mandatory monitoring is required, in order
              to detect such cases and trigger remedial action. This approach
              tolerates a brief divergence from the RFCs given the likely low
              prevalence and given harm here means a flow progresses more
              slowly than otherwise, but it does progress. The L4S operational
              guidanceÂ <span>[<a href="#I-D.ietf-tsvwg-l4sops" class="xref">I-D.ietf-tsvwg-l4sops</a>]</span> outlines a
              range of example remedial actions that include alterations
              either to the sender or to the network. However, the final
              normative requirement in the third bullet of <a href="#l4sid_congestion_response" class="xref">Section 4.3</a> above places ultimate
              responsibility for remedial action on the sender. If coexistence
              problems with a Classic ECN AQM are detected (implying they have
              not been resolved by the network), it says the sender "MUST"
              revert to a Classic congestion control."<a href="#section-4.3.1-6.2" class="pilcrow">Â¶</a>
</li>
          </ul>
<p id="section-4.3.1-7"><span>[<a href="#I-D.ietf-tsvwg-l4sops" class="xref">I-D.ietf-tsvwg-l4sops</a>]</span> also gives example
          ways in which L4S congestion controls can be rolled out initially in
          lower risk scenarios.<a href="#section-4.3.1-7" class="pilcrow">Â¶</a></p>
</section>
</div>
</section>
</div>
<section id="section-4.4">
        <h3 id="name-filtering-or-smoothing-of-e">
<a href="#section-4.4" class="section-number selfRef">4.4. </a><a href="#name-filtering-or-smoothing-of-e" class="section-name selfRef">Filtering or Smoothing of ECN Feedback</a>
        </h3>
<p id="section-4.4-1"><a href="#l4sid_Semantics" class="xref">Section 5.2</a> below specifies that an L4S AQM is
        expected to signal L4S ECN immediately, to avoid introducing delay due
        to filtering or smoothing. This contrasts with a Classic AQM, which
        filters out variations in the queue before signalling ECN marking or
        drop. In the L4S architectureÂ <span>[<a href="#I-D.ietf-tsvwg-l4s-arch" class="xref">I-D.ietf-tsvwg-l4s-arch</a>]</span>, responsibility for smoothing out
        these variations shifts to the sender's congestion control.<a href="#section-4.4-1" class="pilcrow">Â¶</a></p>
<p id="section-4.4-2">This shift of responsibility has the advantage that each sender can
        smooth variations over a timescale proportionate to its own RTT.
        Whereas, in the Classic approach, the network doesn't know the RTTs of
        any of the flows, so it has to smooth out variations for a worst-case
        RTT to ensure stability. For all the typical flows with shorter RTT
        than the worst-case, this makes congestion control unnecessarily
        sluggish.<a href="#section-4.4-2" class="pilcrow">Â¶</a></p>
<p id="section-4.4-3">This also gives an L4S sender the choice not to smooth, depending
        on its context (start-up, congestion avoidance, etc). Therefore, this
        document places no requirement on an L4S congestion control to smooth
        out variations in any particular way. Implementers are encouraged to
        openly publish the approach they take to smoothing, and the results
        and experience they gain during the L4S experiment.<a href="#section-4.4-3" class="pilcrow">Â¶</a></p>
</section>
</section>
</div>
<div id="l4sid_network_req">
<section id="section-5">
      <h2 id="name-network-node-behaviour">
<a href="#section-5" class="section-number selfRef">5. </a><a href="#name-network-node-behaviour" class="section-name selfRef">Network Node Behaviour</a>
      </h2>
<p id="section-5-1"></p>
<section id="section-5.1">
        <h3 id="name-classification-and-re-marki">
<a href="#section-5.1" class="section-number selfRef">5.1. </a><a href="#name-classification-and-re-marki" class="section-name selfRef">Classification and Re-Marking Behaviour</a>
        </h3>
<p id="section-5.1-1">A network node that implements the L4S service:<a href="#section-5.1-1" class="pilcrow">Â¶</a></p>
<ul class="normal">
<li class="normal" id="section-5.1-2.1">MUST classify arriving ECT(1) packets for L4S treatment, unless
            overridden by another classifier (e.g.,Â see <a href="#l4sid_exclusion_dualq" class="xref">Section 5.4.1.2</a>);<a href="#section-5.1-2.1" class="pilcrow">Â¶</a>
</li>
          <li class="normal" id="section-5.1-2.2">
            <p id="section-5.1-2.2.1">MUST classify arriving CE packets for L4S treatment as well,
            unless overridden by a another classifier or unless the exception
            referred to next applies;<a href="#section-5.1-2.2.1" class="pilcrow">Â¶</a></p>
<p id="section-5.1-2.2.2">CE packets might
            have originated as ECT(1) or ECT(0), but the above rule to
            classify them as if they originated as ECT(1) is the safe choice
            (see <a href="#l4sid_ECT1_CE" class="xref">Appendix B</a> for rationale). The exception
            is where some flow-aware in-network mechanism happens to be
            available for distinguishing CE packets that originated as ECT(0),
            as described in <a href="#l4sid_identification_transport_aware" class="xref">Section 5.3</a>, but there is no
            implication that such a mechanism is necessary.<a href="#section-5.1-2.2.2" class="pilcrow">Â¶</a></p>
</li>
        </ul>
<p id="section-5.1-3">An L4S AQM treatment follows similar codepoint transition rules to
        those in RFCÂ 3168. Specifically, the ECT(1) codepoint MUST NOT be
        changed to any other codepoint than CE, and CE MUST NOT be changed to
        any other codepoint. An ECT(1) packet is classified as ECN-capable
        and, if congestion increases, an L4S AQM algorithm will increasingly
        mark the ECN field as CE, otherwise forwarding packets unchanged as
        ECT(1). Necessary conditions for an L4S marking treatment are defined
        in <a href="#l4sid_Semantics" class="xref">Section 5.2</a>.<a href="#section-5.1-3" class="pilcrow">Â¶</a></p>
<p id="section-5.1-4">Under persistent overload an L4S marking treatment MUST begin
        applying drop to L4S traffic until the overload episode has subsided,
        as recommended for all AQM methods in <span>[<a href="#RFC7567" class="xref">RFC7567</a>]</span>
        (Section 4.2.1), which follows the similar advice in RFCÂ 3168
        (Section 7). During overload, it MUST apply the same drop probability
        to L4S traffic as it would to Classic traffic.<a href="#section-5.1-4" class="pilcrow">Â¶</a></p>
<p id="section-5.1-5">Where an L4S AQM is transport-aware, this requirement could be
        satisfied by using drop in only the most overloaded individual
        per-flow AQMs. In a DualQ with flow-aware queue protection
        (e.g.Â <span>[<a href="#I-D.briscoe-docsis-q-protection" class="xref">I-D.briscoe-docsis-q-protection</a>]</span>), this
        could be achieved by redirecting packets in those flows contributing
        most to the overload out of the L4S queue so that they are subjected
        to drop in the Classic queue.<a href="#section-5.1-5" class="pilcrow">Â¶</a></p>
<p id="section-5.1-6">For backward compatibility in uncontrolled environments, a network
        node that implements the L4S treatment MUST also implement an AQM
        treatment for the Classic service as defined in <a href="#l4sid_Terminology" class="xref">Section 1.2</a>. This Classic AQM treatment need not mark
        ECT(0) packets, but if it does, see <a href="#l4sid_Semantics" class="xref">Section 5.2</a>
        for the strengths of the markings relative to drop. It MUST classify
        arriving ECT(0) and Not-ECT packets for treatment by this Classic AQM
        (for the DualQ Coupled AQM, see the extensive discussion on
        classification in Sections 2.3 and 2.5.1.1 of <span>[<a href="#I-D.ietf-tsvwg-aqm-dualq-coupled" class="xref">I-D.ietf-tsvwg-aqm-dualq-coupled</a>]</span>).<a href="#section-5.1-6" class="pilcrow">Â¶</a></p>
<p id="section-5.1-7">In case unforeseen problems arise with the L4S experiment, it MUST
        be possible to configure an L4S implementation to disable the L4S
        treatment. Once disabled, all packets of all ECN codepoints will
        receive Classic treatment and ECT(1) packets MUST be treated as if
        they were Not-ECT.<a href="#section-5.1-7" class="pilcrow">Â¶</a></p>
</section>
<div id="l4sid_Semantics">
<section id="section-5.2">
        <h3 id="name-the-strength-of-l4s-ce-mark">
<a href="#section-5.2" class="section-number selfRef">5.2. </a><a href="#name-the-strength-of-l4s-ce-mark" class="section-name selfRef">The Strength of L4S CE Marking Relative to Drop</a>
        </h3>
<p id="section-5.2-1">The relative strengths of L4S CE and drop are irrelevant where AQMs
        are implemented in separate queues per-application-flow, which are
        then explicitly scheduled (e.g.Â with an FQ scheduler as in
        FQ-CoDelÂ <span>[<a href="#RFC8290" class="xref">RFC8290</a>]</span>). Nonetheless, the relationship
        between them needs to be defined for the coupling between L4S and
        Classic congestion signals in a DualQ Coupled AQMÂ <span>[<a href="#I-D.ietf-tsvwg-aqm-dualq-coupled" class="xref">I-D.ietf-tsvwg-aqm-dualq-coupled</a>]</span>, as below.<a href="#section-5.2-1" class="pilcrow">Â¶</a></p>
<p id="section-5.2-2">Unless an AQM node schedules application flows explicitly, the
        likelihood that the AQM drops a Not-ECT Classic packet (p_C) MUST be
        roughly proportional to the square of the likelihood that it would
        have marked it if it had been an L4S packet (p_L). That is<a href="#section-5.2-2" class="pilcrow">Â¶</a></p>
<ul class="normal ulEmpty">
<li class="normal ulEmpty" id="section-5.2-3.1">p_C ~= (p_L / k)^2<a href="#section-5.2-3.1" class="pilcrow">Â¶</a>
</li>
        </ul>
<p id="section-5.2-4">The constant of proportionality (k) does not have to be
        standardised for interoperability, but a value of 2 is RECOMMENDED.
        The term 'likelihood' is used above to allow for marking and dropping
        to be either probabilistic or deterministic.<a href="#section-5.2-4" class="pilcrow">Â¶</a></p>
<p id="section-5.2-5">This formula ensures that Scalable and Classic flows will converge
        to roughly equal congestion windows, for the worst case of Reno
        congestion control. This is because the congestion windows of Scalable
        and Classic congestion controls are inversely proportional to p_L and
        sqrt(p_C) respectively. So squaring p_C in the above formula
        counterbalances the square root that characterizes Reno-friendly
        flows.<a href="#section-5.2-5" class="pilcrow">Â¶</a></p>
<p id="section-5.2-6">Note that, contrary to RFCÂ 3168, an AQM implementing the L4S
        and Classic treatments does not mark an ECT(1) packet under the same
        conditions that it would have dropped a Not-ECT packet, as allowed by
        <span>[<a href="#RFC8311" class="xref">RFC8311</a>]</span>, which updates RFCÂ 3168. However, if it
        marks ECT(0) packets, it does so under the same conditions that it
        would have dropped a Not-ECT packetÂ <span>[<a href="#RFC3168" class="xref">RFC3168</a>]</span>.<a href="#section-5.2-6" class="pilcrow">Â¶</a></p>
<p id="section-5.2-7">Also, In the L4S architectureÂ <span>[<a href="#I-D.ietf-tsvwg-l4s-arch" class="xref">I-D.ietf-tsvwg-l4s-arch</a>]</span>, the sender, not the network, is
        responsible for smoothing out variations in the queue. So, an L4S AQM
        MUST signal congestion as soon as possible. Then, an L4S sender
        generally interprets CE marking as an unsmoothed signal.<a href="#section-5.2-7" class="pilcrow">Â¶</a></p>
<p id="section-5.2-8">This requirement does not prevent an L4S AQM from mixing in
        additional congestion signals that are smoothed, such as the signals
        from a Classic smoothed AQM that are coupled with unsmoothed L4S
        signals in the coupled DualQÂ <span>[<a href="#I-D.ietf-tsvwg-aqm-dualq-coupled" class="xref">I-D.ietf-tsvwg-aqm-dualq-coupled</a>]</span>. But only as long as the
        onset of congestion can be signalled immediately, and can be
        interpreted by the sender as if it has been signalled immediately,
        which is important for interoperability<a href="#section-5.2-8" class="pilcrow">Â¶</a></p>
</section>
</div>
<div id="l4sid_identification_transport_aware">
<section id="section-5.3">
        <h3 id="name-exception-for-l4s-packet-id">
<a href="#section-5.3" class="section-number selfRef">5.3. </a><a href="#name-exception-for-l4s-packet-id" class="section-name selfRef">Exception for L4S Packet Identification by Network Nodes with Transport-Layer Awareness</a>
        </h3>
<p id="section-5.3-1">To implement L4S packet classification, a network node does not
        need to identify transport-layer flows. Nonetheless, if an L4S network
        node classifies packets by their transport-layer flow ID and their ECN
        field, and if all the ECT packets in a flow have been ECT(0), the node
        MAY classify any CE packets in the same flow as if they were Classic
        ECT(0) packets. In all other cases, a network node MUST classify all
        CE packets as if they were ECT(1) packets. Examples of such other
        cases are: i) if no ECT packets have yet been identified in a flow;
        ii) if it is not desirable for a network node to identify
        transport-layer flows; or iii) if some ECT packets in a flow have been
        ECT(1) (this advice will need to be verified as part of L4S
        experiments).<a href="#section-5.3-1" class="pilcrow">Â¶</a></p>
</section>
</div>
<div id="l4sid_other_IDs">
<section id="section-5.4">
        <h3 id="name-interaction-of-the-l4s-iden">
<a href="#section-5.4" class="section-number selfRef">5.4. </a><a href="#name-interaction-of-the-l4s-iden" class="section-name selfRef">Interaction of the L4S Identifier with other Identifiers</a>
        </h3>
<p id="section-5.4-1">The examples in this section concern how additional identifiers
        might complement the L4S identifier to classify packets between
        class-based queues. Firstly <a href="#l4sid_iother_IDs_dualq" class="xref">Section 5.4.1</a>
        considers two queues, L4S and Classic, as in the Coupled DualQ
        AQMÂ <span>[<a href="#I-D.ietf-tsvwg-aqm-dualq-coupled" class="xref">I-D.ietf-tsvwg-aqm-dualq-coupled</a>]</span>, either
        alone (<a href="#l4sid_inclusion_dualq" class="xref">Section 5.4.1.1</a>) or within a larger
        queuing hierarchy (<a href="#l4sid_exclusion_dualq" class="xref">Section 5.4.1.2</a>). Then <a href="#l4sid_iother_IDs_fq" class="xref">Section 5.4.2</a> considers schemes that might combine
        per-flow 5-tuples with other identifiers.<a href="#section-5.4-1" class="pilcrow">Â¶</a></p>
<div id="l4sid_iother_IDs_dualq">
<section id="section-5.4.1">
          <h4 id="name-dualq-examples-of-other-ide">
<a href="#section-5.4.1" class="section-number selfRef">5.4.1. </a><a href="#name-dualq-examples-of-other-ide" class="section-name selfRef">DualQ Examples of Other Identifiers Complementing L4S Identifiers</a>
          </h4>
<p id="section-5.4.1-1"></p>
<div id="l4sid_inclusion_dualq">
<section id="section-5.4.1.1">
            <h5 id="name-inclusion-of-additional-tra">
<a href="#section-5.4.1.1" class="section-number selfRef">5.4.1.1. </a><a href="#name-inclusion-of-additional-tra" class="section-name selfRef">Inclusion of Additional Traffic with L4S</a>
            </h5>
<p id="section-5.4.1.1-1">In a typical case for the public Internet a network element
            that implements L4S in a shared queue might want to classify some
            low-rate but unresponsive traffic (e.g.Â DNS, LDAP, NTP,
            voice, game sync packets) into the low latency queue to mix with
            L4S traffic. In this case it would not be appropriate to call the
            queue an L4S queue, because it is shared by L4S and non-L4S
            traffic. Instead it will be called the low latency or L queue. The
            L queue then offers two different treatments:<a href="#section-5.4.1.1-1" class="pilcrow">Â¶</a></p>
<ul class="normal">
<li class="normal" id="section-5.4.1.1-2.1">The L4S treatment, which is a combination of the L4S AQM
                treatment and a priority scheduling treatment;<a href="#section-5.4.1.1-2.1" class="pilcrow">Â¶</a>
</li>
              <li class="normal" id="section-5.4.1.1-2.2">The low latency treatment, which is solely the priority
                scheduling treatment, without ECN-marking by the AQM.<a href="#section-5.4.1.1-2.2" class="pilcrow">Â¶</a>
</li>
            </ul>
<p id="section-5.4.1.1-3">To identify packets for just the scheduling treatment, it would
            be inappropriate to use the L4S ECT(1) identifier, because such
            traffic is unresponsive to ECN marking. Examples of relevant
            non-ECN identifiers are:<a href="#section-5.4.1.1-3" class="pilcrow">Â¶</a></p>
<ul class="normal">
<li class="normal" id="section-5.4.1.1-4.1">address ranges of specific applications or hosts configured
                to be, or known to be, safe, e.g.Â hard-coded IoT devices
                sending low intensity traffic;<a href="#section-5.4.1.1-4.1" class="pilcrow">Â¶</a>
</li>
              <li class="normal" id="section-5.4.1.1-4.2">certain low data-volume applications or protocols
                (e.g.Â ARP, DNS);<a href="#section-5.4.1.1-4.2" class="pilcrow">Â¶</a>
</li>
              <li class="normal" id="section-5.4.1.1-4.3">specific Diffserv codepoints that indicate traffic with
                limited burstiness such as the EF (Expedited
                ForwardingÂ <span>[<a href="#RFC3246" class="xref">RFC3246</a>]</span>),
                Voice-AdmitÂ <span>[<a href="#RFC5865" class="xref">RFC5865</a>]</span> or proposed NQB
                (Non-Queue-BuildingÂ <span>[<a href="#I-D.ietf-tsvwg-nqb" class="xref">I-D.ietf-tsvwg-nqb</a>]</span>)
                service classes or equivalent local-use DSCPs (see <span>[<a href="#I-D.briscoe-tsvwg-l4s-diffserv" class="xref">I-D.briscoe-tsvwg-l4s-diffserv</a>]</span>).<a href="#section-5.4.1.1-4.3" class="pilcrow">Â¶</a>
</li>
            </ul>
<p id="section-5.4.1.1-5">In summary, a network element that implements L4S in a shared
            queue MAY classify additional types of packets into the L queue
            based on identifiers other than the ECN field, but the types
            SHOULD be 'safe' to mix with L4S traffic, where 'safe' is
            explained in <a href="#l4sid_safe_unresponsive" class="xref">Section 5.4.1.1.1</a>.<a href="#section-5.4.1.1-5" class="pilcrow">Â¶</a></p>
<p id="section-5.4.1.1-6">A packet that carries one of these non-ECN identifiers to
            classify it into the L queue would not be subject to the L4S ECN
            marking treatment, unless it also carried an ECT(1) or CE
            codepoint. The specification of an L4S AQM MUST define the
            behaviour for packets with unexpected combinations of codepoints,
            e.g.Â a non-ECN-based classifier for the L queue, but ECT(0)
            in the ECN field (for examples see section 2.5.1.1 of the DualQ
            specÂ <span>[<a href="#I-D.ietf-tsvwg-aqm-dualq-coupled" class="xref">I-D.ietf-tsvwg-aqm-dualq-coupled</a>]</span>).<a href="#section-5.4.1.1-6" class="pilcrow">Â¶</a></p>
<p id="section-5.4.1.1-7">For clarity, non-ECN identifiers, such as the examples itemized
            above, might be used by some network operators who believe they
            identify non-L4S traffic that would be safe to mix with L4S
            traffic. They are not alternative ways for a host to indicate that
            it is sending L4S packets. Only the ECT(1) ECN codepoint indicates
            to a network element that a host is sending L4S packets (and CE
            indicates that it could have originated as ECT(1)). Specifically
            ECT(1) indicates that the host claims its behaviour satisfies the
            prerequisite transport requirements in <a href="#l4sid_transport_req" class="xref">Section 4</a>.<a href="#section-5.4.1.1-7" class="pilcrow">Â¶</a></p>
<p id="section-5.4.1.1-8">In order to include non-L4S packets in the L queue, a network
            node MUST NOT alter Not-ECT or ECT(0) in the IP-ECN field to an
            L4S identifier. This ensures that these codepoints survive for any
            potential use later on the network path.<a href="#section-5.4.1.1-8" class="pilcrow">Â¶</a></p>
<div id="l4sid_safe_unresponsive">
<section id="section-5.4.1.1.1">
              <h6 id="name-safe-unresponsive-traffic">
<a href="#section-5.4.1.1.1" class="section-number selfRef">5.4.1.1.1. </a><a href="#name-safe-unresponsive-traffic" class="section-name selfRef">'Safe' Unresponsive Traffic</a>
              </h6>
<p id="section-5.4.1.1.1-1">The above section requires unresponsive traffic to be 'safe'
              to mix with L4S traffic. Ideally this means that the sender
              never sends any sequence of packets at a rate that exceeds the
              available capacity of the bottleneck link. However, typically an
              unresponsive transport does not even know the bottleneck
              capacity of the path, let alone its available capacity.
              Nonetheless, an application can be considered safe enough if it
              paces packets out (not necessarily completely regularly) such
              that its maximum instantaneous rate from packet to packet stays
              well below a typical broadband access rate.<a href="#section-5.4.1.1.1-1" class="pilcrow">Â¶</a></p>
<p id="section-5.4.1.1.1-2">This is a vague but useful definition, because many low
              latency applications of interest, such as DNS, voice, game sync
              packets, RPC, ACKs, keep-alives, could match this
              description.<a href="#section-5.4.1.1.1-2" class="pilcrow">Â¶</a></p>
<p id="section-5.4.1.1.1-3">Low rate streams such as voice and game sync packets, might
              not use continuously adapting ECN-based congestion control, but
              they ought to at least use a 'circuit-breaker' style of
              congestion responseÂ <span>[<a href="#RFC8083" class="xref">RFC8083</a>]</span>. If the volume
              of traffic from unresponsive applications is high enough to
              overload the link, this will at least protect the capacity
              available to responsive applications. However, queuing delay in
              the L queue will probably rise to that controlled by the Classic
              (drop-based) AQM. If a network operator considers that such
              self-restraint is not enough, it might want to police the L
              queue (see Section 8.2 of the L4S architectureÂ <span>[<a href="#I-D.ietf-tsvwg-l4s-arch" class="xref">I-D.ietf-tsvwg-l4s-arch</a>]</span>).<a href="#section-5.4.1.1.1-3" class="pilcrow">Â¶</a></p>
</section>
</div>
</section>
</div>
<div id="l4sid_exclusion_dualq">
<section id="section-5.4.1.2">
            <h5 id="name-exclusion-of-traffic-from-l">
<a href="#section-5.4.1.2" class="section-number selfRef">5.4.1.2. </a><a href="#name-exclusion-of-traffic-from-l" class="section-name selfRef">Exclusion of Traffic From L4S Treatment</a>
            </h5>
<p id="section-5.4.1.2-1">To extend the above example, an operator might want to exclude
            some traffic from the L4S treatment for a policy reason,
            e.g.Â security (traffic from malicious sources) or commercial
            (e.g.Â initially the operator may wish to confine the benefits
            of L4S to business customers).<a href="#section-5.4.1.2-1" class="pilcrow">Â¶</a></p>
<p id="section-5.4.1.2-2">In this exclusion case, the classifier MUST classify on the
            relevant locally-used identifiers (e.g.Â source addresses)
            before classifying the non-matching traffic on the end-to-end L4S
            ECN identifier.<a href="#section-5.4.1.2-2" class="pilcrow">Â¶</a></p>
<p id="section-5.4.1.2-3">A network node MUST NOT alter the end-to-end L4S ECN identifier
            from L4S to Classic, because an operator decision to exclude
            certain traffic from L4S treatment is local-only. The end-to-end
            L4S identifier then survives for other operators to use, or
            indeed, they can apply their own policy, independently based on
            their own choice of locally-used identifiers. This approach also
            allows any operator to remove its locally-applied exclusions in
            future, e.g.Â if it wishes to widen the benefit of the L4S
            treatment to all its customers.<a href="#section-5.4.1.2-3" class="pilcrow">Â¶</a></p>
<p id="section-5.4.1.2-4">A network node that supports L4S but excludes certain packets
            carrying the L4S identifier from L4S treatment MUST still apply
            marking or dropping that is compatible with an L4S congestion
            response. For instance, it could either drop such packets with the
            same likelihood as Classic packets or it could ECN-mark them with
            a likelihood appropriate to L4S traffic (e.g.Â the coupled
            probability in a DualQ coupled AQM) but aiming for the Classic
            delay target. It MUST NOT ECN-mark such packets with a Classic
            marking probability, which could confuse the sender.<a href="#section-5.4.1.2-4" class="pilcrow">Â¶</a></p>
</section>
</div>
<section id="section-5.4.1.3">
            <h5 id="name-generalized-combination-of-">
<a href="#section-5.4.1.3" class="section-number selfRef">5.4.1.3. </a><a href="#name-generalized-combination-of-" class="section-name selfRef">Generalized Combination of L4S and Other Identifiers</a>
            </h5>
<p id="section-5.4.1.3-1">L4S concerns low latency, which it can provide for all traffic
            without differentiation and without <em>necessarily</em>
            affecting bandwidth allocation. Diffserv provides for
            differentiation of both bandwidth and low latency, but its control
            of latency depends on its control of bandwidth. The two can be
            combined if a network operator wants to control bandwidth
            allocation but it also wants to provide low latency - for any
            amount of traffic within one of these allocations of bandwidth
            (rather than only providing low latency by limiting bandwidth)
            <span>[<a href="#I-D.briscoe-tsvwg-l4s-diffserv" class="xref">I-D.briscoe-tsvwg-l4s-diffserv</a>]</span>.<a href="#section-5.4.1.3-1" class="pilcrow">Â¶</a></p>
<p id="section-5.4.1.3-2">The DualQ examples so far have been framed in the context of
            providing the default Best Efforts Per-Hop Behaviour (PHB) using
            two queues - a Low Latency (L) queue and a Classic (C) Queue. This
            single DualQ structure is expected to be the most common and
            useful arrangement. But, more generally, an operator might choose
            to control bandwidth allocation through a hierarchy of Diffserv
            PHBs at a node, and to offer one (or more) of these PHBs using a
            pair of queues for a low latency and a Classic variant of the
            PHB.<a href="#section-5.4.1.3-2" class="pilcrow">Â¶</a></p>
<p id="section-5.4.1.3-3">In the first case, if we assume that a network element provides
            no PHBs except the DualQ, if a packet carries ECT(1) or CE, the
            network element would classify it for the L4S treatment
            irrespective of its DSCP. And, if a packet carried (say) the EF
            DSCP, the network element could classify it into the L queue
            irrespective of its ECN codepoint. However, where the DualQ is in
            a hierarchy of other PHBs, the classifier would classify some
            traffic into other PHBs based on DSCP before classifying between
            the low latency and Classic queues (based on ECT(1), CE and
            perhaps also the EF DSCP or other identifiers as in the above
            example). <span>[<a href="#I-D.briscoe-tsvwg-l4s-diffserv" class="xref">I-D.briscoe-tsvwg-l4s-diffserv</a>]</span> gives a
            number of examples of such arrangements to address various
            requirements.<a href="#section-5.4.1.3-3" class="pilcrow">Â¶</a></p>
<p id="section-5.4.1.3-4"><span>[<a href="#I-D.briscoe-tsvwg-l4s-diffserv" class="xref">I-D.briscoe-tsvwg-l4s-diffserv</a>]</span> describes how
            an operator might use L4S to offer low latency as well as using
            Diffserv for bandwidth differentiation. It identifies two main
            types of approach, which can be combined: the operator might split
            certain Diffserv PHBs between L4S and a corresponding Classic
            service. Or it might split the L4S and/or the Classic service into
            multiple Diffserv PHBs. In either of these cases, a packet would
            have to be classified on its Diffserv and ECN codepoints.<a href="#section-5.4.1.3-4" class="pilcrow">Â¶</a></p>
<p id="section-5.4.1.3-5">In summary, there are numerous ways in which the L4S ECN
            identifier (ECT(1) and CE) could be combined with other
            identifiers to achieve particular objectives. The following
            categorization articulates those that are valid, but it is not
            necessarily exhaustive. Those tagged 'Recommended-standard-use'
            could be set by the sending host or a network. Those tagged
            'Local-use' would only be set by a network:<a href="#section-5.4.1.3-5" class="pilcrow">Â¶</a></p>
<ol start="1" type="1" class="normal type-1" id="section-5.4.1.3-6">
<li id="section-5.4.1.3-6.1">
                <p id="section-5.4.1.3-6.1.1">Identifiers Complementing the L4S Identifier<a href="#section-5.4.1.3-6.1.1" class="pilcrow">Â¶</a></p>
<ol start="1" type="a" class="normal type-a" id="section-5.4.1.3-6.1.2">
<li id="section-5.4.1.3-6.1.2.1">
                    <p id="section-5.4.1.3-6.1.2.1.1">Including More Traffic in the L Queue<a href="#section-5.4.1.3-6.1.2.1.1" class="pilcrow">Â¶</a></p>
<p id="section-5.4.1.3-6.1.2.1.2">(Could use Recommended-standard-use or
                    Local-use identifiers)<a href="#section-5.4.1.3-6.1.2.1.2" class="pilcrow">Â¶</a></p>
</li>
                  <li id="section-5.4.1.3-6.1.2.2">
                    <p id="section-5.4.1.3-6.1.2.2.1">Excluding Certain Traffic from the L Queue<a href="#section-5.4.1.3-6.1.2.2.1" class="pilcrow">Â¶</a></p>
<p id="section-5.4.1.3-6.1.2.2.2">(Local-use only)<a href="#section-5.4.1.3-6.1.2.2.2" class="pilcrow">Â¶</a></p>
</li>
                </ol>
</li>
              <li id="section-5.4.1.3-6.2">
                <p id="section-5.4.1.3-6.2.1">Identifiers to place L4S classification in a PHB
                Hierarchy<a href="#section-5.4.1.3-6.2.1" class="pilcrow">Â¶</a></p>
<p id="section-5.4.1.3-6.2.2">(Could use
                Recommended-standard-use or Local-use identifiers)<a href="#section-5.4.1.3-6.2.2" class="pilcrow">Â¶</a></p>
<ol start="1" type="a" class="normal type-a" id="section-5.4.1.3-6.2.3">
<li id="section-5.4.1.3-6.2.3.1">PHBs Before L4S ECN Classification<a href="#section-5.4.1.3-6.2.3.1" class="pilcrow">Â¶</a>
</li>
                  <li id="section-5.4.1.3-6.2.3.2">PHBs After L4S ECN Classification<a href="#section-5.4.1.3-6.2.3.2" class="pilcrow">Â¶</a>
</li>
                </ol>
</li>
            </ol>
</section>
</section>
</div>
<div id="l4sid_iother_IDs_fq">
<section id="section-5.4.2">
          <h4 id="name-per-flow-queuing-examples-o">
<a href="#section-5.4.2" class="section-number selfRef">5.4.2. </a><a href="#name-per-flow-queuing-examples-o" class="section-name selfRef">Per-Flow Queuing Examples of Other Identifiers Complementing L4S Identifiers</a>
          </h4>
<p id="section-5.4.2-1">At a node with per-flow queueing (e.g.Â FQ-CoDelÂ <span>[<a href="#RFC8290" class="xref">RFC8290</a>]</span>), the L4S identifier could complement the Layer-4
          flow ID as a further level of flow granularity (i.e.Â Not-ECT
          and ECT(0) queued separately from ECT(1) and CE packets). "Risk of
          reordering Classic CE packets" in <a href="#l4sid_ECT1_CE" class="xref">Appendix B</a>
          discusses the resulting ambiguity if packets originally marked
          ECT(0) are marked CE by an upstream AQM before they arrive at a node
          that classifies CE as L4S. It argues that the risk of reordering is
          vanishingly small and the consequence of such a low level of
          reordering is minimal.<a href="#section-5.4.2-1" class="pilcrow">Â¶</a></p>
<p id="section-5.4.2-2">Alternatively, it could be assumed that it is not in a flow's own
          interest to mix Classic and L4S identifiers. Then the AQM could use
          the ECN field to switch itself between a Classic and an L4S AQM
          behaviour within one per-flow queue. For instance, for ECN-capable
          packets, the AQM might consist of a simple marking threshold and an
          L4S ECN identifier might simply select a shallower threshold than a
          Classic ECN identifier would.<a href="#section-5.4.2-2" class="pilcrow">Â¶</a></p>
</section>
</div>
</section>
</div>
<div id="l4sid_bursts_links">
<section id="section-5.5">
        <h3 id="name-limiting-packet-bursts-from">
<a href="#section-5.5" class="section-number selfRef">5.5. </a><a href="#name-limiting-packet-bursts-from" class="section-name selfRef">Limiting Packet Bursts from Links</a>
        </h3>
<p id="section-5.5-1">As well as senders needing to limit packet bursts (<a href="#l4sid_congestion_response" class="xref">Section 4.3</a>), links need to limit the degree
        of burstiness they introduce. In both cases (senders and links) this
        is a tradeoff, because batch-handling of packets is done for good
        reason, e.g.Â processing efficiency or to make efficient use of
        medium acquisition delay. Some take the attitude that there is no
        point reducing burst delay at the sender below that introduced by
        links (or vice versa). However, delay reduction proceeds by cutting
        down 'the longest pole in the tent', which turns the spotlight on the
        next longest, and so on.<a href="#section-5.5-1" class="pilcrow">Â¶</a></p>
<p id="section-5.5-2">This document does not set any quantified requirements for links to
        limit burst delay, primarily because link technologies are outside the
        remit of L4S specifications. Nonetheless, the following two
        subsections outline opportunities for addressing bursty links in the
        process of L4S implementation and deployment.<a href="#section-5.5-2" class="pilcrow">Â¶</a></p>
<div id="l4sid_bursts_links_l4s">
<section id="section-5.5.1">
          <h4 id="name-limiting-packet-bursts-from-">
<a href="#section-5.5.1" class="section-number selfRef">5.5.1. </a><a href="#name-limiting-packet-bursts-from-" class="section-name selfRef">Limiting Packet Bursts from Links Fed by an L4S AQM</a>
          </h4>
<p id="section-5.5.1-1">It would not make sense to implement an L4S AQM that feeds into a
          particular link technology without also reviewing opportunities to
          reduce any form of burst delay introduced by that link technology.
          This would at least limit the bursts that the link would otherwise
          introduce into the onward traffic, which would cause jumpy feedback
          to the sender as well as potential extra queuing delay downstream.
          This document does not presume to even give guidance on an
          appropriate target for such burst delay until there is more industry
          experience of L4S. However, as suggested in <a href="#l4sid_congestion_response" class="xref">Section 4.3</a> it would not seem necessary to
          limit bursts lower than roughly 10% of the minimum base RTT expected
          in the typical deployment scenario (e.g.Â 250 us burst duration
          for links within the public Internet).<a href="#section-5.5.1-1" class="pilcrow">Â¶</a></p>
</section>
</div>
<div id="l4sid_bursts_links_l4s_upstream">
<section id="section-5.5.2">
          <h4 id="name-limiting-packet-bursts-from-l">
<a href="#section-5.5.2" class="section-number selfRef">5.5.2. </a><a href="#name-limiting-packet-bursts-from-l" class="section-name selfRef">Limiting Packet Bursts from Links Upstream of an L4S AQM</a>
          </h4>
<p id="section-5.5.2-1">The initial scope of the L4S experiment is to deploy L4S AQMs at
          bottlenecks and L4S congestion controls at senders. This is expected
          to highlight interactions with the most bursty upstream links and
          lead operators to tune down the burstiness of those links in their
          network that are configurable, or failing that, to have to
          compromise on the delay target of some L4S AQMs. It might also
          require specific redesign work relevant to the most problematic link
          types. Such knock-on effects of initial L4S deployment would all be
          part of the learning from the L4S experiment.<a href="#section-5.5.2-1" class="pilcrow">Â¶</a></p>
<p id="section-5.5.2-2">The details of such link changes are beyond the scope of the
          present document. Nonetheless, where L4S technology is being
          implemented on an outgoing interface of a device, it would make
          sense to consider opportunities for reducing bursts arriving at
          other incoming interface(s). For instance, where an L4S AQM is
          implemented to feed into the upstream WAN interface of a home
          gateway, there would be opportunities to alter the WiFi profiles
          sent out of any WiFi interfaces from the same device, in order to
          mitigate incoming bursts of aggregated WiFi frames from other WiFi
          stations.<a href="#section-5.5.2-2" class="pilcrow">Â¶</a></p>
</section>
</div>
</section>
</div>
</section>
</div>
<div id="l4sid_encaps">
<section id="section-6">
      <h2 id="name-behaviour-of-tunnels-and-en">
<a href="#section-6" class="section-number selfRef">6. </a><a href="#name-behaviour-of-tunnels-and-en" class="section-name selfRef">Behaviour of Tunnels and Encapsulations</a>
      </h2>
<div id="l4sid_encaps_no_change">
<section id="section-6.1">
        <h3 id="name-no-change-to-ecn-tunnels-an">
<a href="#section-6.1" class="section-number selfRef">6.1. </a><a href="#name-no-change-to-ecn-tunnels-an" class="section-name selfRef">No Change to ECN Tunnels and Encapsulations in General</a>
        </h3>
<p id="section-6.1-1">The L4S identifier is expected to work through and within any
        tunnel without modification, as long as the tunnel propagates the ECN
        field in any of the ways that have been defined since the first
        variant in the year 2001Â <span>[<a href="#RFC3168" class="xref">RFC3168</a>]</span>. L4S will also
        work with (but does not rely on) any of the more recent updates to ECN
        propagation in <span>[<a href="#RFC4301" class="xref">RFC4301</a>]</span>, <span>[<a href="#RFC6040" class="xref">RFC6040</a>]</span> or
        <span>[<a href="#I-D.ietf-tsvwg-rfc6040update-shim" class="xref">I-D.ietf-tsvwg-rfc6040update-shim</a>]</span>. However, it is
        likely that some tunnels still do not implement ECN propagation at
        all. In these cases, L4S will work through such tunnels, but within
        them the outer header of L4S traffic will appear as Classic.<a href="#section-6.1-1" class="pilcrow">Â¶</a></p>
<p id="section-6.1-2">AQMs are typically implemented where an IP-layer buffer feeds into
        a lower layer, so they are agnostic to link layer encapsulations.
        Where a bottleneck link is not IP-aware, the L4S identifier is still
        expected to work within any lower layer encapsulation without
        modification, as long it propagates the ECN field as defined for the
        link technology, for example for MPLSÂ <span>[<a href="#RFC5129" class="xref">RFC5129</a>]</span> or
        TRILLÂ <span>[<a href="#I-D.ietf-trill-ecn-support" class="xref">I-D.ietf-trill-ecn-support</a>]</span>. In some of
        these cases, e.g.Â layer-3 Ethernet switches, the AQM accesses the
        IP layer header within the outer encapsulation, so again the L4S
        identifier is expected to work without modification. Nonetheless, the
        programme to define ECN for other lower layers is still in
        progressÂ <span>[<a href="#I-D.ietf-tsvwg-ecn-encap-guidelines" class="xref">I-D.ietf-tsvwg-ecn-encap-guidelines</a>]</span>.<a href="#section-6.1-2" class="pilcrow">Â¶</a></p>
</section>
</div>
<div id="l4sid_VPN_anti-replay">
<section id="section-6.2">
        <h3 id="name-vpn-behaviour-to-avoid-limi">
<a href="#section-6.2" class="section-number selfRef">6.2. </a><a href="#name-vpn-behaviour-to-avoid-limi" class="section-name selfRef">VPN Behaviour to Avoid Limitations of Anti-Replay</a>
        </h3>
<p id="section-6.2-1">If a mix of L4S and Classic packets is sent into the same security
        association (SA) of a virtual private network (VPN), and if the VPN
        egress is employing the optional anti-replay feature, it could
        inappropriately discard Classic packets (or discard the records in
        Classic packets) by mistaking their greater queuing delay for a replay
        attack (see "Dropped Packets for Tunnels with Replay Protection
        Enabled" in <span>[<a href="#Heist21" class="xref">Heist21</a>]</span> for the potential performance
        impact). This known problem is common to both IPsecÂ <span>[<a href="#RFC4301" class="xref">RFC4301</a>]</span> and DTLSÂ <span>[<a href="#RFC6347" class="xref">RFC6347</a>]</span> VPNs, given
        they use similar anti-replay window mechanisms. The mechanism used can
        only check for replay within its window, so if the window is smaller
        than the degree of reordering, it can only assume there might be a
        replay attack and discard all the packets behind the trailing edge of
        the window. The specifications of IPsec AHÂ <span>[<a href="#RFC4302" class="xref">RFC4302</a>]</span> and ESPÂ <span>[<a href="#RFC4303" class="xref">RFC4303</a>]</span> suggest that
        an implementer scales the size of the anti-replay window with
        interface speed, and DTLS 1.3Â <span>[<a href="#I-D.ietf-tls-dtls13" class="xref">I-D.ietf-tls-dtls13</a>]</span> says "The receiver SHOULD pick a window
        large enough to handle any plausible reordering, which depends on the
        data rate." However, in practice, the size of a VPN's anti-replay
        window is not always scaled appropriately.<a href="#section-6.2-1" class="pilcrow">Â¶</a></p>
<p id="section-6.2-2">If a VPN carrying traffic participating in the L4S experiment
        experiences inappropriate replay detection, the foremost remedy would
        be to ensure that the egress is configured to comply with the above
        window-sizing requirements.<a href="#section-6.2-2" class="pilcrow">Â¶</a></p>
<p id="section-6.2-3">If an implementation of a VPN egress does not support a
        sufficiently large anti-replay window, e.g.Â due to hardware
        limitations, one of the temporary alternatives listed in order of
        preference below might be feasible instead:<a href="#section-6.2-3" class="pilcrow">Â¶</a></p>
<ul class="normal">
<li class="normal" id="section-6.2-4.1">If the VPN can be configured to classify packets into different
            SAs indexed by DSCP, apply the appropriate locally defined DSCPs
            to Classic and L4S packets. The DSCPs could be applied by the
            network (based on the least significant bit of the ECN field), or
            by the sending host. Such DSCPs would only need to survive as far
            as the VPN ingress.<a href="#section-6.2-4.1" class="pilcrow">Â¶</a>
</li>
          <li class="normal" id="section-6.2-4.2">
            <p id="section-6.2-4.2.1">If the above is not possible and it is necessary to use L4S,
            either of the following might be appropriate as a last
            resort:<a href="#section-6.2-4.2.1" class="pilcrow">Â¶</a></p>
<ul class="normal">
<li class="normal" id="section-6.2-4.2.2.1">disable anti-replay protection at the VPN egress, after
                considering the security implications (optional anti-replay is
                mandatory in both IPsec and DTLS);<a href="#section-6.2-4.2.2.1" class="pilcrow">Â¶</a>
</li>
              <li class="normal" id="section-6.2-4.2.2.2">configure the tunnel ingress not to propagate ECN to the
                outer, which would lose the benefits of L4S and Classic ECN
                over the VPN.<a href="#section-6.2-4.2.2.2" class="pilcrow">Â¶</a>
</li>
            </ul>
</li>
          </ul>
<p id="section-6.2-5">Modification to VPN implementations is outside the present scope,
        which is why this section has so far focused on reconfiguration.
        Although this document does not define any requirements for VPN
        implementations, determining whether there is a need for such
        requirements could be one aspect of L4S experimentation.<a href="#section-6.2-5" class="pilcrow">Â¶</a></p>
</section>
</div>
</section>
</div>
<section id="section-7">
      <h2 id="name-l4s-experiments">
<a href="#section-7" class="section-number selfRef">7. </a><a href="#name-l4s-experiments" class="section-name selfRef">L4S Experiments</a>
      </h2>
<p id="section-7-1">This section describes open questions that L4S Experiments ought to
      focus on. This section also documents outstanding open issues that will
      need to be investigated as part of L4S experimentation, given they could
      not be fully resolved during the WG phase. It also lists metrics that
      will need to be monitored during experiments (summarizing text elsewhere
      in L4S documents) and finally lists some potential future directions
      that researchers might wish to investigate.<a href="#section-7-1" class="pilcrow">Â¶</a></p>
<p id="section-7-2">In addition to this section, the DualQ specÂ <span>[<a href="#I-D.ietf-tsvwg-aqm-dualq-coupled" class="xref">I-D.ietf-tsvwg-aqm-dualq-coupled</a>]</span> sets operational and
      management requirements for experiments with DualQ Coupled AQMs; and
      General operational and management requirements for experiments with L4S
      congestion controls are given in <a href="#l4sid_transport_req" class="xref">Section 4</a>
      and <a href="#l4sid_network_req" class="xref">Section 5</a> above, e.g.Â co-existence and
      scaling requirements, incremental deployment arrangements.<a href="#section-7-2" class="pilcrow">Â¶</a></p>
<p id="section-7-3">The specification of each scalable congestion control will need to
      include protocol-specific requirements for configuration and monitoring
      performance during experiments. Appendix A of the guidelines in <span>[<a href="#RFC5706" class="xref">RFC5706</a>]</span> provides a helpful checklist.<a href="#section-7-3" class="pilcrow">Â¶</a></p>
<section id="section-7.1">
        <h3 id="name-open-questions">
<a href="#section-7.1" class="section-number selfRef">7.1. </a><a href="#name-open-questions" class="section-name selfRef">Open Questions</a>
        </h3>
<p id="section-7.1-1">L4S experiments would be expected to answer the following
        questions:<a href="#section-7.1-1" class="pilcrow">Â¶</a></p>
<ul class="normal">
<li class="normal" id="section-7.1-2.1">
            <p id="section-7.1-2.1.1">Have all the parts of L4S been deployed, and if so, what
            proportion of paths support it?<a href="#section-7.1-2.1.1" class="pilcrow">Â¶</a></p>
<ul class="normal">
<li class="normal" id="section-7.1-2.1.2.1">What types of L4S AQMs were deployed, e.g.Â FQ, coupled
                DualQ, uncoupled DualQ, other? And how prevalent was each?<a href="#section-7.1-2.1.2.1" class="pilcrow">Â¶</a>
</li>
              <li class="normal" id="section-7.1-2.1.2.2">Are the signalling patterns emitted by the deployed AQMs in
                any way different from those expected when the Prague
                requirements for endpoints were written?<a href="#section-7.1-2.1.2.2" class="pilcrow">Â¶</a>
</li>
            </ul>
</li>
          <li class="normal" id="section-7.1-2.2">Does use of L4S over the Internet result in significantly
            improved user experience?<a href="#section-7.1-2.2" class="pilcrow">Â¶</a>
</li>
          <li class="normal" id="section-7.1-2.3">Has L4S enabled novel interactive applications?<a href="#section-7.1-2.3" class="pilcrow">Â¶</a>
</li>
          <li class="normal" id="section-7.1-2.4">
            <p id="section-7.1-2.4.1">Did use of L4S over the Internet result in improvements to the
            following metrics:<a href="#section-7.1-2.4.1" class="pilcrow">Â¶</a></p>
<ul class="normal">
<li class="normal" id="section-7.1-2.4.2.1">queue delay (mean and 99th percentile) under various
                loads;<a href="#section-7.1-2.4.2.1" class="pilcrow">Â¶</a>
</li>
              <li class="normal" id="section-7.1-2.4.2.2">utilization;<a href="#section-7.1-2.4.2.2" class="pilcrow">Â¶</a>
</li>
              <li class="normal" id="section-7.1-2.4.2.3">starvation / fairness;<a href="#section-7.1-2.4.2.3" class="pilcrow">Â¶</a>
</li>
              <li class="normal" id="section-7.1-2.4.2.4">scaling range of flow rates and RTTs?<a href="#section-7.1-2.4.2.4" class="pilcrow">Â¶</a>
</li>
            </ul>
</li>
          <li class="normal" id="section-7.1-2.5">How dependent was the performance of L4S service on the
            bottleneck bandwidth or the path RTT?<a href="#section-7.1-2.5" class="pilcrow">Â¶</a>
</li>
          <li class="normal" id="section-7.1-2.6">How much do bursty links in the Internet affect L4S performance
            (see "Underutilization with Bursty Links" in <span>[<a href="#Heist21" class="xref">Heist21</a>]</span>) and how prevalent are they? How much
            limitation of burstiness from upstream links was needed and/or was
            realized - both at senders and at links, especially radio links or
            how much did L4S target delay have to be increased to accommodate
            the bursts (see bullet #7 in <a href="#l4sid_congestion_response" class="xref">Section 4.3</a> and <a href="#l4sid_bursts_links_l4s_upstream" class="xref">Section 5.5.2</a>)?<a href="#section-7.1-2.6" class="pilcrow">Â¶</a>
</li>
          <li class="normal" id="section-7.1-2.7">Is the initial experiment with mis-marked bursty traffic at
            high RTT (see "Underutilization with Bursty Traffic" in <span>[<a href="#Heist21" class="xref">Heist21</a>]</span>) indicative of similar problems at lower RTTs
            and, if so, how effective is the suggested remedy in Appendix A.1
            of the DualQ specÂ <span>[<a href="#I-D.ietf-tsvwg-aqm-dualq-coupled" class="xref">I-D.ietf-tsvwg-aqm-dualq-coupled</a>]</span> (or possible other
            remedies)?<a href="#section-7.1-2.7" class="pilcrow">Â¶</a>
</li>
          <li class="normal" id="section-7.1-2.8">
            <p id="section-7.1-2.8.1">Was per-flow queue protection typically (un)necessary?<a href="#section-7.1-2.8.1" class="pilcrow">Â¶</a></p>
<ul class="normal">
<li class="normal" id="section-7.1-2.8.2.1">How well did overload protection or queue protection
                work?<a href="#section-7.1-2.8.2.1" class="pilcrow">Â¶</a>
</li>
            </ul>
</li>
          <li class="normal" id="section-7.1-2.9">How well did L4S flows coexist with Classic flows when sharing
            a bottleneck?<a href="#section-7.1-2.9" class="pilcrow">Â¶</a>
</li>
          <li class="normal" id="section-7.1-2.10">
            <ul class="normal">
<li class="normal" id="section-7.1-2.10.1.1">How frequently did problems arise?<a href="#section-7.1-2.10.1.1" class="pilcrow">Â¶</a>
</li>
              <li class="normal" id="section-7.1-2.10.1.2">What caused any coexistence problems, and were any problems
                due to single-queue Classic ECN AQMs (this assumes
                single-queue Classic ECN AQMs can be distinguished from FQ
                ones)?<a href="#section-7.1-2.10.1.2" class="pilcrow">Â¶</a>
</li>
            </ul>
</li>
          <li class="normal" id="section-7.1-2.11">How prevalent were problems with the L4S service due to tunnels
            / encapsulations that do not support ECN decapsulation?<a href="#section-7.1-2.11" class="pilcrow">Â¶</a>
</li>
          <li class="normal" id="section-7.1-2.12">How easy was it to implement a fully compliant L4S congestion
            control, over various different transport protocols (TCP, QUIC,
            RMCAT, etc)?<a href="#section-7.1-2.12" class="pilcrow">Â¶</a>
</li>
        </ul>
<p id="section-7.1-3">Monitoring for harm to other traffic, specifically bandwidth
        starvation or excess queuing delay, will need to be conducted
        alongside all early L4S experiments. It is hard, if not impossible,
        for an individual flow to measure its impact on other traffic. So such
        monitoring will need to be conducted using bespoke monitoring across
        flows and/or across classes of traffic.<a href="#section-7.1-3" class="pilcrow">Â¶</a></p>
</section>
<section id="section-7.2">
        <h3 id="name-open-issues-2">
<a href="#section-7.2" class="section-number selfRef">7.2. </a><a href="#name-open-issues-2" class="section-name selfRef">Open Issues</a>
        </h3>
<ul class="normal">
<li class="normal" id="section-7.2-1.1">What is the best way forward to deal with L4S over single-queue
            Classic ECN AQM bottlenecks, given current problems with
            misdetecting L4S AQMs as Classic ECN AQMs? See the L4S operational
            guidanceÂ <span>[<a href="#I-D.ietf-tsvwg-l4sops" class="xref">I-D.ietf-tsvwg-l4sops</a>]</span>.<a href="#section-7.2-1.1" class="pilcrow">Â¶</a>
</li>
          <li class="normal" id="section-7.2-1.2">Fixing the poor Interaction between current L4S congestion
            controls and CoDel with only Classic ECN support during flow
            startup. Originally, this was due to a bug in the initialization
            of the congestion EWMA in the Linux implementation of TCP Prague.
            That was quickly fixed, which removed the main performance impact,
            but further improvement would be useful (either by modifying
            CoDel, Scalable congestion controls, or both).<a href="#section-7.2-1.2" class="pilcrow">Â¶</a>
</li>
        </ul>
</section>
<section id="section-7.3">
        <h3 id="name-future-potential">
<a href="#section-7.3" class="section-number selfRef">7.3. </a><a href="#name-future-potential" class="section-name selfRef">Future Potential</a>
        </h3>
<p id="section-7.3-1">Researchers might find that L4S opens up the following interesting
        areas for investigation:<a href="#section-7.3-1" class="pilcrow">Â¶</a></p>
<ul class="normal">
<li class="normal" id="section-7.3-2.1">Potential for faster convergence time and tracking of available
            capacity;<a href="#section-7.3-2.1" class="pilcrow">Â¶</a>
</li>
          <li class="normal" id="section-7.3-2.2">Potential for improvements to particular link technologies, and
            cross-layer interactions with them;<a href="#section-7.3-2.2" class="pilcrow">Â¶</a>
</li>
          <li class="normal" id="section-7.3-2.3">Potential for using virtual queues, e.g.Â to further reduce
            latency jitter, or to leave headroom for capacity variation in
            radio networks;<a href="#section-7.3-2.3" class="pilcrow">Â¶</a>
</li>
          <li class="normal" id="section-7.3-2.4">Development and specification of reverse path congestion
            control using L4S building bocks (e.g.Â AccECN, QUIC);<a href="#section-7.3-2.4" class="pilcrow">Â¶</a>
</li>
          <li class="normal" id="section-7.3-2.5">Once queuing delay is cut down, what becomes the 'second
            longest pole in the tent' (other than the speed of light)?<a href="#section-7.3-2.5" class="pilcrow">Â¶</a>
</li>
          <li class="normal" id="section-7.3-2.6">Novel alternatives to the existing set of L4S AQMs;<a href="#section-7.3-2.6" class="pilcrow">Â¶</a>
</li>
          <li class="normal" id="section-7.3-2.7">Novel applications enabled by L4S.<a href="#section-7.3-2.7" class="pilcrow">Â¶</a>
</li>
        </ul>
</section>
</section>
<div id="l4sid_IANA">
<section id="section-8">
      <h2 id="name-iana-considerations-4">
<a href="#section-8" class="section-number selfRef">8. </a><a href="#name-iana-considerations-4" class="section-name selfRef">IANA Considerations</a>
      </h2>
<p id="section-8-1">The 01 codepoint of the ECN Field of the IP header is specified by
      the present Experimental RFC. The process for an experimental RFC to
      assign this codepoint in the IP header (v4 and v6) is documented in
      Proposed Standard <span>[<a href="#RFC8311" class="xref">RFC8311</a>]</span>, which updates the Proposed
      Standard <span>[<a href="#RFC3168" class="xref">RFC3168</a>]</span>.<a href="#section-8-1" class="pilcrow">Â¶</a></p>
<p id="section-8-2">When the present document is published as an RFC, IANA is asked to
      update the 01 entry in the registry, "ECN Field (Bits 6-7)" to the
      following (see
      https://www.iana.org/assignments/dscp-registry/dscp-registry.xhtml#ecn-field
      ):<a href="#section-8-2" class="pilcrow">Â¶</a></p>
<table class="center" id="table-1">
        <caption><a href="#table-1" class="selfRef">Table 1</a></caption>
<thead>
          <tr>
            <th class="text-left" rowspan="1" colspan="1">Binary</th>
            <th class="text-left" rowspan="1" colspan="1">Keyword</th>
            <th class="text-left" rowspan="1" colspan="1">References</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td class="text-left" rowspan="1" colspan="1">01</td>
            <td class="text-left" rowspan="1" colspan="1">ECT(1) (ECN-Capable Transport(1))[1]</td>
            <td class="text-left" rowspan="1" colspan="1">
              <span>[<a href="#RFC8311" class="xref">RFC8311</a>]</span> [RFCÂ ErrataÂ 5399]
        [RFCXXXX]</td>
          </tr>
        </tbody>
      </table>
<p id="section-8-4">[XXXX is the number that the RFC Editor assigns to the
      present document (this sentence to be removed by the RFC Editor)].<a href="#section-8-4" class="pilcrow">Â¶</a></p>
</section>
</div>
<div id="l4sid_Security_Considerations">
<section id="section-9">
      <h2 id="name-security-considerations-4">
<a href="#section-9" class="section-number selfRef">9. </a><a href="#name-security-considerations-4" class="section-name selfRef">Security Considerations</a>
      </h2>
<p id="section-9-1">Approaches to assure the integrity of signals using the new
      identifier are introduced inÂ <a href="#l4sid_competing_integrity" class="xref">Appendix C.1</a>. See the security considerations in
      the L4S architectureÂ <span>[<a href="#I-D.ietf-tsvwg-l4s-arch" class="xref">I-D.ietf-tsvwg-l4s-arch</a>]</span> for
      further discussion of mis-use of the identifier, as well as extensive
      discussion of policing rate and latency in regard to L4S.<a href="#section-9-1" class="pilcrow">Â¶</a></p>
<p id="section-9-2">If the anti-replay window of a VPN egress is too small, it will
      mistake deliberate delay differences as a replay attack, and discard
      higher delay packets (e.g.Â Classic) carried within the same
      security association (SA) as low delay packets (e.g.Â L4S). <a href="#l4sid_VPN_anti-replay" class="xref">Section 6.2</a> recommends that VPNs used in L4S
      experiments are configured with a sufficiently large anti-replay window,
      as required by the relevant specifications. It also discusses other
      alternatives.<a href="#section-9-2" class="pilcrow">Â¶</a></p>
<p id="section-9-3">If a user taking part in the L4S experiment sets up a VPN without
      being aware of the above advice, and if the user allows anyone to send
      traffic into their VPN, they would open up a DoS vulnerability in which
      an attacker could induce the VPN's anti-replay mechanism to discard
      enough of the user's Classic (C) traffic (if they are receiving any) to
      cause a significant rate reduction. While the user is actively
      downloading C traffic, the attacker sends C traffic into the VPN to fill
      the remainder of the bottleneck link, then sends intermittent L4S
      packets to maximize the chance of exceeding the VPN's replay window. The
      user can prevent this attack by following the recommendations in <a href="#l4sid_VPN_anti-replay" class="xref">Section 6.2</a>.<a href="#section-9-3" class="pilcrow">Â¶</a></p>
<p id="section-9-4">The recommendation to detect loss in time units prevents the
      ACK-splitting attacks described in <span>[<a href="#Savage-TCP" class="xref">Savage-TCP</a>]</span>.<a href="#section-9-4" class="pilcrow">Â¶</a></p>
</section>
</div>
<section id="section-10">
      <h2 id="name-acknowledgements-2">
<a href="#section-10" class="section-number selfRef">10. </a><a href="#name-acknowledgements-2" class="section-name selfRef">Acknowledgements</a>
      </h2>
<p id="section-10-1">Thanks to Richard Scheffenegger, John Leslie, David Taeht,
      Jonathan Morton, Gorry Fairhurst, Michael Welzl, Mikael Abrahamsson and
      Andrew McGregor for the discussions that led to this specification.
      Ing-jyh (Inton) Tsang was a contributor to the early drafts of this
      document. And thanks to Mikael Abrahamsson, Lloyd Wood, Nicolas Kuhn,
      Greg White, Tom Henderson, David Black, Gorry Fairhurst, Brian
      Carpenter, Jake Holland, Rod Grimes, Richard Scheffenegger, Sebastian
      Moeller, Neal Cardwell, Praveen Balasubramanian, Reza Marandian Hagh,
      Pete Heist, Stuart Cheshire, Vidhi Goel, Mirja Kuehlewind and Ermin
      Sakic for providing help and reviewing this draft and thanks to Ingemar
      Johansson for reviewing and providing substantial text. Thanks to
      Sebastian Moeller for identifying the interaction with VPN anti-replay
      and to Jonathan Morton for identifying the attack based on this.
      Particular thanks to tsvwg chairs Gorry Fairhurst, David Black and Wes
      Eddy for patiently helping this and the other L4S drafts through the
      IETF process. <a href="#l4sps_tcp-prague-reqs" class="xref">Appendix A</a> listing the Prague
      L4S Requirements is based on text authored by Marcelo Bagnulo Braun that
      was originally an appendix to <span>[<a href="#I-D.ietf-tsvwg-l4s-arch" class="xref">I-D.ietf-tsvwg-l4s-arch</a>]</span>.
      That text was in turn based on the collective output of the attendees
      listed in the minutes of a 'bar BoF' on DCTCP Evolution during
      IETF-94Â <span>[<a href="#TCPPrague" class="xref">TCPPrague</a>]</span>.<a href="#section-10-1" class="pilcrow">Â¶</a></p>
<p id="section-10-2">The authors' contributions were part-funded by the European Community
      under its Seventh Framework Programme through the Reducing Internet
      Transport Latency (RITE) project (ICT-317700). The contribution of Koen
      De Schepper was also part-funded by the 5Growth and DAEMON EU H2020
      projects. Bob Briscoe was also funded partly by the Research Council of
      Norway through the TimeIn project, partly by CableLabs and partly by the
      Comcast Innovation Fund. The views expressed here are solely those of
      the authors.<a href="#section-10-2" class="pilcrow">Â¶</a></p>
</section>
<section id="section-11">
      <h2 id="name-references-4">
<a href="#section-11" class="section-number selfRef">11. </a><a href="#name-references-4" class="section-name selfRef">References</a>
      </h2>
<section id="section-11.1">
        <h3 id="name-normative-references-4">
<a href="#section-11.1" class="section-number selfRef">11.1. </a><a href="#name-normative-references-4" class="section-name selfRef">Normative References</a>
        </h3>
<dl class="references">
<dt id="RFC2119">[RFC2119]</dt>
        <dd>
<span class="refAuthor">Bradner, S.</span>, <span class="refTitle">"Key words for use in RFCs to Indicate Requirement Levels"</span>, <span class="seriesInfo">BCP 14</span>, <span class="seriesInfo">RFC 2119</span>, <span class="seriesInfo">DOI 10.17487/RFC2119</span>, <time datetime="1997-03" class="refDate">March 1997</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc2119">https://www.rfc-editor.org/info/rfc2119</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC3168">[RFC3168]</dt>
        <dd>
<span class="refAuthor">Ramakrishnan, K.</span>, <span class="refAuthor">Floyd, S.</span>, and <span class="refAuthor">D. Black</span>, <span class="refTitle">"The Addition of Explicit Congestion Notification (ECN) to IP"</span>, <span class="seriesInfo">RFC 3168</span>, <span class="seriesInfo">DOI 10.17487/RFC3168</span>, <time datetime="2001-09" class="refDate">September 2001</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc3168">https://www.rfc-editor.org/info/rfc3168</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC4774">[RFC4774]</dt>
        <dd>
<span class="refAuthor">Floyd, S.</span>, <span class="refTitle">"Specifying Alternate Semantics for the Explicit Congestion Notification (ECN) Field"</span>, <span class="seriesInfo">BCP 124</span>, <span class="seriesInfo">RFC 4774</span>, <span class="seriesInfo">DOI 10.17487/RFC4774</span>, <time datetime="2006-11" class="refDate">November 2006</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc4774">https://www.rfc-editor.org/info/rfc4774</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC6679">[RFC6679]</dt>
      <dd>
<span class="refAuthor">Westerlund, M.</span>, <span class="refAuthor">Johansson, I.</span>, <span class="refAuthor">Perkins, C.</span>, <span class="refAuthor">O'Hanlon, P.</span>, and <span class="refAuthor">K. Carlberg</span>, <span class="refTitle">"Explicit Congestion Notification (ECN) for RTP over UDP"</span>, <span class="seriesInfo">RFC 6679</span>, <span class="seriesInfo">DOI 10.17487/RFC6679</span>, <time datetime="2012-08" class="refDate">August 2012</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc6679">https://www.rfc-editor.org/info/rfc6679</a>&gt;</span>. </dd>
<dd class="break"></dd>
</dl>
</section>
<section id="section-11.2">
        <h3 id="name-informative-references-4">
<a href="#section-11.2" class="section-number selfRef">11.2. </a><a href="#name-informative-references-4" class="section-name selfRef">Informative References</a>
        </h3>
<dl class="references">
<dt id="A2DTCP">[A2DTCP]</dt>
        <dd>
<span class="refAuthor">Zhang, T.</span>, <span class="refAuthor">Wang, J.</span>, <span class="refAuthor">Huang, J.</span>, <span class="refAuthor">Huang, Y.</span>, <span class="refAuthor">Chen, J.</span>, and <span class="refAuthor">Y. Pan</span>, <span class="refTitle">"Adaptive-Acceleration Data Center TCP"</span>, <span class="seriesInfo">IEEE Transactions on Computers 64(6):1522-1533</span>, <time datetime="2015-06" class="refDate">June 2015</time>, <span>&lt;<a href="http://ieeexplore.ieee.org/xpl/articleDetails.jsp?arnumber=6871352">http://ieeexplore.ieee.org/xpl/articleDetails.jsp?arnumber=6871352</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="Ahmed19">[Ahmed19]</dt>
        <dd>
<span class="refAuthor">Ahmed, A.S.</span>, <span class="refTitle">"Extending TCP for Low Round Trip Delay"</span>, <span class="seriesInfo">Masters Thesis, Uni Oslo </span>, <time datetime="2019-08" class="refDate">August 2019</time>, <span>&lt;<a href="https://www.duo.uio.no/handle/10852/70966">https://www.duo.uio.no/handle/10852/70966</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="Alizadeh-stability">[Alizadeh-stability]</dt>
        <dd>
<span class="refAuthor">Alizadeh, M.</span>, <span class="refAuthor">Javanmard, A.</span>, and <span class="refAuthor">B. Prabhakar</span>, <span class="refTitle">"Analysis of DCTCP: Stability, Convergence, and Fairness"</span>, <span class="seriesInfo">ACM SIGMETRICS 2011 </span>, <time datetime="2011-06" class="refDate">June 2011</time>, <span>&lt;<a href="https://people.csail.mit.edu/alizadeh/papers/dctcp_analysis-sigmetrics11.pdf">https://people.csail.mit.edu/alizadeh/papers/dctcp_analysis-sigmetrics11.pdf</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="ARED01">[ARED01]</dt>
        <dd>
<span class="refAuthor">Floyd, S.</span>, <span class="refAuthor">Gummadi, R.</span>, and <span class="refAuthor">S. Shenker</span>, <span class="refTitle">"Adaptive RED: An Algorithm for Increasing the Robustness of RED's Active Queue Management"</span>, <span class="seriesInfo">ACIRI Technical Report </span>, <time datetime="2001-08" class="refDate">August 2001</time>, <span>&lt;<a href="http://www.icir.org/floyd/red.html">http://www.icir.org/floyd/red.html</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="BBRv2">[BBRv2]</dt>
        <dd>
<span class="refAuthor">Cardwell, N.</span>, <span class="refTitle">"BRTCP BBR v2 Alpha/Preview Release"</span>, <span class="seriesInfo">github repository; Linux congestion control module</span>, <span>&lt;<a href="https://github.com/google/bbr/blob/v2alpha/README.md">https://github.com/google/bbr/blob/v2alpha/README.md</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="COBALT">[COBALT]</dt>
        <dd>
<span class="refAuthor">Palmei, J.</span>, <span class="refAuthor">Gupta, S.</span>, <span class="refAuthor">Imputato, P.</span>, <span class="refAuthor">Morton, J.</span>, <span class="refAuthor">Tahiliani, M.</span>, <span class="refAuthor">Avallone, S.</span>, and <span class="refAuthor">D. Taht</span>, <span class="refTitle">"Design and Evaluation of COBALT Queue Discipline"</span>, <span class="seriesInfo">In Proc. IEEE Int'l Symp. on Local and Metropolitan Area Networks 2019, pp1--6</span>, <time datetime="2019" class="refDate">2019</time>, <span>&lt;<a href="https://doi.org/10.1109/LANMAN.2019.8847054">https://doi.org/10.1109/LANMAN.2019.8847054</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="DCttH19">[DCttH19]</dt>
        <dd>
<span class="refAuthor">De Schepper, K.</span>, <span class="refAuthor">Bondarenko, O.</span>, <span class="refAuthor">Tilmans, O.</span>, and <span class="refAuthor">B. Briscoe</span>, <span class="refTitle">"`Data Centre to the Home': Ultra-Low Latency for All"</span>, <span class="seriesInfo">Updated RITE project Technical Report </span>, <time datetime="2019-07" class="refDate">July 2019</time>, <span>&lt;<a href="https://bobbriscoe.net/pubs.html#DCttH_TR">https://bobbriscoe.net/pubs.html#DCttH_TR</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="DualPI2Linux">[DualPI2Linux]</dt>
        <dd>
<span class="refAuthor">Albisser, O.</span>, <span class="refAuthor">De Schepper, K.</span>, <span class="refAuthor">Briscoe, B.</span>, <span class="refAuthor">Tilmans, O.</span>, and <span class="refAuthor">H. Steen</span>, <span class="refTitle">"DUALPI2 - Low Latency, Low Loss and Scalable (L4S) AQM"</span>, <span class="seriesInfo">Proc. Linux Netdev 0x13 </span>, <time datetime="2019-03" class="refDate">March 2019</time>, <span>&lt;<a href="https://www.netdevconf.org/0x13/session.html?talk-DUALPI2-AQM">https://www.netdevconf.org/0x13/session.html?talk-DUALPI2-AQM</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="ecn-fallback">[ecn-fallback]</dt>
        <dd>
<span class="refAuthor">Briscoe, B.</span> and <span class="refAuthor">A.S. Ahmed</span>, <span class="refTitle">"TCP Prague Fall-back on Detection of a Classic ECN AQM"</span>, <span class="seriesInfo">bobbriscoe.net Technical Report TR-BB-2019-002</span>, <time datetime="2020-04" class="refDate">April 2020</time>, <span>&lt;<a href="https://arxiv.org/abs/1911.00710">https://arxiv.org/abs/1911.00710</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="Heist21">[Heist21]</dt>
        <dd>
<span class="refAuthor">Heist, P.</span> and <span class="refAuthor">J. Morton</span>, <span class="refTitle">"L4S Tests"</span>, <span class="seriesInfo">github README</span>, <time datetime="2021-05" class="refDate">May 2021</time>, <span>&lt;<a href="https://github.com/heistp/l4s-tests/">https://github.com/heistp/l4s-tests/</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="I-D.briscoe-docsis-q-protection">[I-D.briscoe-docsis-q-protection]</dt>
        <dd>
<span class="refAuthor">Briscoe, B.</span> and <span class="refAuthor">G. White</span>, <span class="refTitle">"The DOCSIS(r) Queue Protection Algorithm to Preserve Low Latency"</span>, <span class="refContent">Work in Progress</span>, <span class="seriesInfo">Internet-Draft, draft-briscoe-docsis-q-protection-02</span>, <time datetime="2022-01-31" class="refDate">31 January 2022</time>, <span>&lt;<a href="https://datatracker.ietf.org/doc/html/draft-briscoe-docsis-q-protection-02">https://datatracker.ietf.org/doc/html/draft-briscoe-docsis-q-protection-02</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="I-D.briscoe-iccrg-prague-congestion-control">[I-D.briscoe-iccrg-prague-congestion-control]</dt>
        <dd>
<span class="refAuthor">Schepper, K. D.</span>, <span class="refAuthor">Tilmans, O.</span>, and <span class="refAuthor">B. Briscoe</span>, <span class="refTitle">"Prague Congestion Control"</span>, <span class="refContent">Work in Progress</span>, <span class="seriesInfo">Internet-Draft, draft-briscoe-iccrg-prague-congestion-control-00</span>, <time datetime="2021-03-09" class="refDate">9 March 2021</time>, <span>&lt;<a href="https://datatracker.ietf.org/doc/html/draft-briscoe-iccrg-prague-congestion-control-00">https://datatracker.ietf.org/doc/html/draft-briscoe-iccrg-prague-congestion-control-00</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="I-D.briscoe-tsvwg-l4s-diffserv">[I-D.briscoe-tsvwg-l4s-diffserv]</dt>
        <dd>
<span class="refAuthor">Briscoe, B.</span>, <span class="refTitle">"Interactions between Low Latency, Low Loss, Scalable Throughput (L4S) and Differentiated Services"</span>, <span class="refContent">Work in Progress</span>, <span class="seriesInfo">Internet-Draft, draft-briscoe-tsvwg-l4s-diffserv-02</span>, <time datetime="2018-11-04" class="refDate">4 November 2018</time>, <span>&lt;<a href="https://datatracker.ietf.org/doc/html/draft-briscoe-tsvwg-l4s-diffserv-02">https://datatracker.ietf.org/doc/html/draft-briscoe-tsvwg-l4s-diffserv-02</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="I-D.cardwell-iccrg-bbr-congestion-control">[I-D.cardwell-iccrg-bbr-congestion-control]</dt>
        <dd>
<span class="refAuthor">Cardwell, N.</span>, <span class="refAuthor">Cheng, Y.</span>, <span class="refAuthor">Yeganeh, S. H.</span>, <span class="refAuthor">Swett, I.</span>, and <span class="refAuthor">V. Jacobson</span>, <span class="refTitle">"BBR Congestion Control"</span>, <span class="refContent">Work in Progress</span>, <span class="seriesInfo">Internet-Draft, draft-cardwell-iccrg-bbr-congestion-control-01</span>, <time datetime="2021-11-07" class="refDate">7 November 2021</time>, <span>&lt;<a href="https://datatracker.ietf.org/doc/html/draft-cardwell-iccrg-bbr-congestion-control-01">https://datatracker.ietf.org/doc/html/draft-cardwell-iccrg-bbr-congestion-control-01</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="I-D.ietf-tcpm-accurate-ecn">[I-D.ietf-tcpm-accurate-ecn]</dt>
        <dd>
<span class="refAuthor">Briscoe, B.</span>, <span class="refAuthor">KÃ¼hlewind, M.</span>, and <span class="refAuthor">R. Scheffenegger</span>, <span class="refTitle">"More Accurate ECN Feedback in TCP"</span>, <span class="refContent">Work in Progress</span>, <span class="seriesInfo">Internet-Draft, draft-ietf-tcpm-accurate-ecn-16</span>, <time datetime="2022-02-03" class="refDate">3 February 2022</time>, <span>&lt;<a href="https://datatracker.ietf.org/doc/html/draft-ietf-tcpm-accurate-ecn-16">https://datatracker.ietf.org/doc/html/draft-ietf-tcpm-accurate-ecn-16</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="I-D.ietf-tcpm-generalized-ecn">[I-D.ietf-tcpm-generalized-ecn]</dt>
        <dd>
<span class="refAuthor">Bagnulo, M.</span> and <span class="refAuthor">B. Briscoe</span>, <span class="refTitle">"ECN++: Adding Explicit Congestion Notification (ECN) to TCP Control Packets"</span>, <span class="refContent">Work in Progress</span>, <span class="seriesInfo">Internet-Draft, draft-ietf-tcpm-generalized-ecn-09</span>, <time datetime="2022-01-31" class="refDate">31 January 2022</time>, <span>&lt;<a href="https://datatracker.ietf.org/doc/html/draft-ietf-tcpm-generalized-ecn-09">https://datatracker.ietf.org/doc/html/draft-ietf-tcpm-generalized-ecn-09</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="I-D.ietf-tls-dtls13">[I-D.ietf-tls-dtls13]</dt>
        <dd>
<span class="refAuthor">Rescorla, E.</span>, <span class="refAuthor">Tschofenig, H.</span>, and <span class="refAuthor">N. Modadugu</span>, <span class="refTitle">"The Datagram Transport Layer Security (DTLS) Protocol Version 1.3"</span>, <span class="refContent">Work in Progress</span>, <span class="seriesInfo">Internet-Draft, draft-ietf-tls-dtls13-43</span>, <time datetime="2021-04-30" class="refDate">30 April 2021</time>, <span>&lt;<a href="https://datatracker.ietf.org/doc/html/draft-ietf-tls-dtls13-43">https://datatracker.ietf.org/doc/html/draft-ietf-tls-dtls13-43</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="I-D.ietf-trill-ecn-support">[I-D.ietf-trill-ecn-support]</dt>
        <dd>
<span class="refAuthor">Eastlake, D. E.</span> and <span class="refAuthor">B. Briscoe</span>, <span class="refTitle">"TRILL (TRansparent Interconnection of Lots of Links): ECN (Explicit Congestion Notification) Support"</span>, <span class="refContent">Work in Progress</span>, <span class="seriesInfo">Internet-Draft, draft-ietf-trill-ecn-support-07</span>, <time datetime="2018-02-25" class="refDate">25 February 2018</time>, <span>&lt;<a href="https://datatracker.ietf.org/doc/html/draft-ietf-trill-ecn-support-07">https://datatracker.ietf.org/doc/html/draft-ietf-trill-ecn-support-07</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="I-D.ietf-tsvwg-aqm-dualq-coupled">[I-D.ietf-tsvwg-aqm-dualq-coupled]</dt>
        <dd>
<span class="refAuthor">Schepper, K. D.</span>, <span class="refAuthor">Briscoe, B.</span>, and <span class="refAuthor">G. White</span>, <span class="refTitle">"DualQ Coupled AQMs for Low Latency, Low Loss and Scalable Throughput (L4S)"</span>, <span class="refContent">Work in Progress</span>, <span class="seriesInfo">Internet-Draft, draft-ietf-tsvwg-aqm-dualq-coupled-22</span>, <time datetime="2022-03-04" class="refDate">4 March 2022</time>, <span>&lt;<a href="https://datatracker.ietf.org/doc/html/draft-ietf-tsvwg-aqm-dualq-coupled-22">https://datatracker.ietf.org/doc/html/draft-ietf-tsvwg-aqm-dualq-coupled-22</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="I-D.ietf-tsvwg-ecn-encap-guidelines">[I-D.ietf-tsvwg-ecn-encap-guidelines]</dt>
        <dd>
<span class="refAuthor">Briscoe, B.</span> and <span class="refAuthor">J. Kaippallimalil</span>, <span class="refTitle">"Guidelines for Adding Congestion Notification to Protocols that Encapsulate IP"</span>, <span class="refContent">Work in Progress</span>, <span class="seriesInfo">Internet-Draft, draft-ietf-tsvwg-ecn-encap-guidelines-16</span>, <time datetime="2021-05-25" class="refDate">25 May 2021</time>, <span>&lt;<a href="https://datatracker.ietf.org/doc/html/draft-ietf-tsvwg-ecn-encap-guidelines-16">https://datatracker.ietf.org/doc/html/draft-ietf-tsvwg-ecn-encap-guidelines-16</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="I-D.ietf-tsvwg-l4s-arch">[I-D.ietf-tsvwg-l4s-arch]</dt>
        <dd>
<span class="refAuthor">Briscoe, B.</span>, <span class="refAuthor">Schepper, K. D.</span>, <span class="refAuthor">Bagnulo, M.</span>, and <span class="refAuthor">G. White</span>, <span class="refTitle">"Low Latency, Low Loss, Scalable Throughput (L4S) Internet Service: Architecture"</span>, <span class="refContent">Work in Progress</span>, <span class="seriesInfo">Internet-Draft, draft-ietf-tsvwg-l4s-arch-16</span>, <time datetime="2022-02-01" class="refDate">1 February 2022</time>, <span>&lt;<a href="https://datatracker.ietf.org/doc/html/draft-ietf-tsvwg-l4s-arch-16">https://datatracker.ietf.org/doc/html/draft-ietf-tsvwg-l4s-arch-16</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="I-D.ietf-tsvwg-l4sops">[I-D.ietf-tsvwg-l4sops]</dt>
        <dd>
<span class="refAuthor">White, G.</span>, <span class="refTitle">"Operational Guidance for Deployment of L4S in the Internet"</span>, <span class="refContent">Work in Progress</span>, <span class="seriesInfo">Internet-Draft, draft-ietf-tsvwg-l4sops-02</span>, <time datetime="2021-10-25" class="refDate">25 October 2021</time>, <span>&lt;<a href="https://datatracker.ietf.org/doc/html/draft-ietf-tsvwg-l4sops-02">https://datatracker.ietf.org/doc/html/draft-ietf-tsvwg-l4sops-02</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="I-D.ietf-tsvwg-nqb">[I-D.ietf-tsvwg-nqb]</dt>
        <dd>
<span class="refAuthor">White, G.</span> and <span class="refAuthor">T. Fossati</span>, <span class="refTitle">"A Non-Queue-Building Per-Hop Behavior (NQB PHB) for Differentiated Services"</span>, <span class="refContent">Work in Progress</span>, <span class="seriesInfo">Internet-Draft, draft-ietf-tsvwg-nqb-10</span>, <time datetime="2022-03-04" class="refDate">4 March 2022</time>, <span>&lt;<a href="https://datatracker.ietf.org/doc/html/draft-ietf-tsvwg-nqb-10">https://datatracker.ietf.org/doc/html/draft-ietf-tsvwg-nqb-10</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="I-D.ietf-tsvwg-rfc6040update-shim">[I-D.ietf-tsvwg-rfc6040update-shim]</dt>
        <dd>
<span class="refAuthor">Briscoe, B.</span>, <span class="refTitle">"Propagating Explicit Congestion Notification Across IP Tunnel Headers Separated by a Shim"</span>, <span class="refContent">Work in Progress</span>, <span class="seriesInfo">Internet-Draft, draft-ietf-tsvwg-rfc6040update-shim-14</span>, <time datetime="2021-05-25" class="refDate">25 May 2021</time>, <span>&lt;<a href="https://datatracker.ietf.org/doc/html/draft-ietf-tsvwg-rfc6040update-shim-14">https://datatracker.ietf.org/doc/html/draft-ietf-tsvwg-rfc6040update-shim-14</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="I-D.sridharan-tcpm-ctcp">[I-D.sridharan-tcpm-ctcp]</dt>
        <dd>
<span class="refAuthor">Sridharan, M.</span>, <span class="refAuthor">Tan, K.</span>, <span class="refAuthor">Bansal, D.</span>, and <span class="refAuthor">D. Thaler</span>, <span class="refTitle">"Compound TCP: A New TCP Congestion Control for High-Speed and Long Distance Networks"</span>, <span class="refContent">Work in Progress</span>, <span class="seriesInfo">Internet-Draft, draft-sridharan-tcpm-ctcp-02</span>, <time datetime="2008-11-11" class="refDate">11 November 2008</time>, <span>&lt;<a href="https://datatracker.ietf.org/doc/html/draft-sridharan-tcpm-ctcp-02">https://datatracker.ietf.org/doc/html/draft-sridharan-tcpm-ctcp-02</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="I-D.stewart-tsvwg-sctpecn">[I-D.stewart-tsvwg-sctpecn]</dt>
        <dd>
<span class="refAuthor">Stewart, R. R.</span>, <span class="refAuthor">Tuexen, M.</span>, and <span class="refAuthor">X. Dong</span>, <span class="refTitle">"ECN for Stream Control Transmission Protocol (SCTP)"</span>, <span class="refContent">Work in Progress</span>, <span class="seriesInfo">Internet-Draft, draft-stewart-tsvwg-sctpecn-05</span>, <time datetime="2014-01-15" class="refDate">15 January 2014</time>, <span>&lt;<a href="https://datatracker.ietf.org/doc/html/draft-stewart-tsvwg-sctpecn-05">https://datatracker.ietf.org/doc/html/draft-stewart-tsvwg-sctpecn-05</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="LinuxPacedChirping">[LinuxPacedChirping]</dt>
        <dd>
<span class="refAuthor">Misund, J.</span> and <span class="refAuthor">B. Briscoe</span>, <span class="refTitle">"Paced Chirping - Rethinking TCP start-up"</span>, <span class="seriesInfo">Proc. Linux Netdev 0x13 </span>, <time datetime="2019-03" class="refDate">March 2019</time>, <span>&lt;<a href="https://www.netdevconf.org/0x13/session.html?talk-chirp">https://www.netdevconf.org/0x13/session.html?talk-chirp</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="Mathis09">[Mathis09]</dt>
        <dd>
<span class="refAuthor">Mathis, M.</span>, <span class="refTitle">"Relentless Congestion Control"</span>, <span class="seriesInfo">PFLDNeT'09 </span>, <time datetime="2009-05" class="refDate">May 2009</time>, <span>&lt;<a href="http://www.hpcc.jp/pfldnet2009/Program_files/1569198525.pdf">http://www.hpcc.jp/pfldnet2009/Program_files/1569198525.pdf</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="Paced-Chirping">[Paced-Chirping]</dt>
        <dd>
<span class="refAuthor">Misund, J.</span>, <span class="refTitle">"Rapid Acceleration in TCP Prague"</span>, <span class="seriesInfo">Masters Thesis </span>, <time datetime="2018-05" class="refDate">May 2018</time>, <span>&lt;<a href="https://riteproject.files.wordpress.com/2018/07/misundjoakimmastersthesissubmitted180515.pdf">https://riteproject.files.wordpress.com/2018/07/misundjoakimmastersthesissubmitted180515.pdf</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="PI2">[PI2]</dt>
        <dd>
<span class="refAuthor">De Schepper, K.</span>, <span class="refAuthor">Bondarenko, O.</span>, <span class="refAuthor">Tsang, I.</span>, and <span class="refAuthor">B. Briscoe</span>, <span class="refTitle">"PI^2 : A Linearized AQM for both Classic and Scalable TCP"</span>, <span class="seriesInfo">Proc. ACM CoNEXT 2016 pp.105-119</span>, <time datetime="2016-12" class="refDate">December 2016</time>, <span>&lt;<a href="http://dl.acm.org/citation.cfm?doid=2999572.2999578">http://dl.acm.org/citation.cfm?doid=2999572.2999578</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="PragueLinux">[PragueLinux]</dt>
        <dd>
<span class="refAuthor">Briscoe, B.</span>, <span class="refAuthor">De Schepper, K.</span>, <span class="refAuthor">Albisser, O.</span>, <span class="refAuthor">Misund, J.</span>, <span class="refAuthor">Tilmans, O.</span>, <span class="refAuthor">KÃ¼hlewind, M.</span>, and <span class="refAuthor">A.S. Ahmed</span>, <span class="refTitle">"Implementing the `TCP Prague' Requirements for Low Latency Low Loss Scalable Throughput (L4S)"</span>, <span class="seriesInfo">Proc. Linux Netdev 0x13 </span>, <time datetime="2019-03" class="refDate">March 2019</time>, <span>&lt;<a href="https://www.netdevconf.org/0x13/session.html?talk-tcp-prague-l4s">https://www.netdevconf.org/0x13/session.html?talk-tcp-prague-l4s</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="QV">[QV]</dt>
        <dd>
<span class="refAuthor">Briscoe, B.</span> and <span class="refAuthor">P. Hurtig</span>, <span class="refTitle">"Up to Speed with Queue View"</span>, <span class="seriesInfo">RITE Technical Report D2.3; Appendix C.2</span>, <time datetime="2015-08" class="refDate">August 2015</time>, <span>&lt;<a href="https://riteproject.files.wordpress.com/2015/12/rite-deliverable-2-3.pdf">https://riteproject.files.wordpress.com/2015/12/rite-deliverable-2-3.pdf</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC2309">[RFC2309]</dt>
        <dd>
<span class="refAuthor">Braden, B.</span>, <span class="refAuthor">Clark, D.</span>, <span class="refAuthor">Crowcroft, J.</span>, <span class="refAuthor">Davie, B.</span>, <span class="refAuthor">Deering, S.</span>, <span class="refAuthor">Estrin, D.</span>, <span class="refAuthor">Floyd, S.</span>, <span class="refAuthor">Jacobson, V.</span>, <span class="refAuthor">Minshall, G.</span>, <span class="refAuthor">Partridge, C.</span>, <span class="refAuthor">Peterson, L.</span>, <span class="refAuthor">Ramakrishnan, K.</span>, <span class="refAuthor">Shenker, S.</span>, <span class="refAuthor">Wroclawski, J.</span>, and <span class="refAuthor">L. Zhang</span>, <span class="refTitle">"Recommendations on Queue Management and Congestion Avoidance in the Internet"</span>, <span class="seriesInfo">RFC 2309</span>, <span class="seriesInfo">DOI 10.17487/RFC2309</span>, <time datetime="1998-04" class="refDate">April 1998</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc2309">https://www.rfc-editor.org/info/rfc2309</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC2474">[RFC2474]</dt>
        <dd>
<span class="refAuthor">Nichols, K.</span>, <span class="refAuthor">Blake, S.</span>, <span class="refAuthor">Baker, F.</span>, and <span class="refAuthor">D. Black</span>, <span class="refTitle">"Definition of the Differentiated Services Field (DS Field) in the IPv4 and IPv6 Headers"</span>, <span class="seriesInfo">RFC 2474</span>, <span class="seriesInfo">DOI 10.17487/RFC2474</span>, <time datetime="1998-12" class="refDate">December 1998</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc2474">https://www.rfc-editor.org/info/rfc2474</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC3246">[RFC3246]</dt>
        <dd>
<span class="refAuthor">Davie, B.</span>, <span class="refAuthor">Charny, A.</span>, <span class="refAuthor">Bennet, J.C.R.</span>, <span class="refAuthor">Benson, K.</span>, <span class="refAuthor">Le Boudec, J.Y.</span>, <span class="refAuthor">Courtney, W.</span>, <span class="refAuthor">Davari, S.</span>, <span class="refAuthor">Firoiu, V.</span>, and <span class="refAuthor">D. Stiliadis</span>, <span class="refTitle">"An Expedited Forwarding PHB (Per-Hop Behavior)"</span>, <span class="seriesInfo">RFC 3246</span>, <span class="seriesInfo">DOI 10.17487/RFC3246</span>, <time datetime="2002-03" class="refDate">March 2002</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc3246">https://www.rfc-editor.org/info/rfc3246</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC3540">[RFC3540]</dt>
        <dd>
<span class="refAuthor">Spring, N.</span>, <span class="refAuthor">Wetherall, D.</span>, and <span class="refAuthor">D. Ely</span>, <span class="refTitle">"Robust Explicit Congestion Notification (ECN) Signaling with Nonces"</span>, <span class="seriesInfo">RFC 3540</span>, <span class="seriesInfo">DOI 10.17487/RFC3540</span>, <time datetime="2003-06" class="refDate">June 2003</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc3540">https://www.rfc-editor.org/info/rfc3540</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC3649">[RFC3649]</dt>
        <dd>
<span class="refAuthor">Floyd, S.</span>, <span class="refTitle">"HighSpeed TCP for Large Congestion Windows"</span>, <span class="seriesInfo">RFC 3649</span>, <span class="seriesInfo">DOI 10.17487/RFC3649</span>, <time datetime="2003-12" class="refDate">December 2003</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc3649">https://www.rfc-editor.org/info/rfc3649</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC4301">[RFC4301]</dt>
        <dd>
<span class="refAuthor">Kent, S.</span> and <span class="refAuthor">K. Seo</span>, <span class="refTitle">"Security Architecture for the Internet Protocol"</span>, <span class="seriesInfo">RFC 4301</span>, <span class="seriesInfo">DOI 10.17487/RFC4301</span>, <time datetime="2005-12" class="refDate">December 2005</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc4301">https://www.rfc-editor.org/info/rfc4301</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC4302">[RFC4302]</dt>
        <dd>
<span class="refAuthor">Kent, S.</span>, <span class="refTitle">"IP Authentication Header"</span>, <span class="seriesInfo">RFC 4302</span>, <span class="seriesInfo">DOI 10.17487/RFC4302</span>, <time datetime="2005-12" class="refDate">December 2005</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc4302">https://www.rfc-editor.org/info/rfc4302</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC4303">[RFC4303]</dt>
        <dd>
<span class="refAuthor">Kent, S.</span>, <span class="refTitle">"IP Encapsulating Security Payload (ESP)"</span>, <span class="seriesInfo">RFC 4303</span>, <span class="seriesInfo">DOI 10.17487/RFC4303</span>, <time datetime="2005-12" class="refDate">December 2005</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc4303">https://www.rfc-editor.org/info/rfc4303</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC4340">[RFC4340]</dt>
        <dd>
<span class="refAuthor">Kohler, E.</span>, <span class="refAuthor">Handley, M.</span>, and <span class="refAuthor">S. Floyd</span>, <span class="refTitle">"Datagram Congestion Control Protocol (DCCP)"</span>, <span class="seriesInfo">RFC 4340</span>, <span class="seriesInfo">DOI 10.17487/RFC4340</span>, <time datetime="2006-03" class="refDate">March 2006</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc4340">https://www.rfc-editor.org/info/rfc4340</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC4341">[RFC4341]</dt>
        <dd>
<span class="refAuthor">Floyd, S.</span> and <span class="refAuthor">E. Kohler</span>, <span class="refTitle">"Profile for Datagram Congestion Control Protocol (DCCP) Congestion Control ID 2: TCP-like Congestion Control"</span>, <span class="seriesInfo">RFC 4341</span>, <span class="seriesInfo">DOI 10.17487/RFC4341</span>, <time datetime="2006-03" class="refDate">March 2006</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc4341">https://www.rfc-editor.org/info/rfc4341</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC4342">[RFC4342]</dt>
        <dd>
<span class="refAuthor">Floyd, S.</span>, <span class="refAuthor">Kohler, E.</span>, and <span class="refAuthor">J. Padhye</span>, <span class="refTitle">"Profile for Datagram Congestion Control Protocol (DCCP) Congestion Control ID 3: TCP-Friendly Rate Control (TFRC)"</span>, <span class="seriesInfo">RFC 4342</span>, <span class="seriesInfo">DOI 10.17487/RFC4342</span>, <time datetime="2006-03" class="refDate">March 2006</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc4342">https://www.rfc-editor.org/info/rfc4342</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC4960">[RFC4960]</dt>
        <dd>
<span class="refAuthor">Stewart, R., Ed.</span>, <span class="refTitle">"Stream Control Transmission Protocol"</span>, <span class="seriesInfo">RFC 4960</span>, <span class="seriesInfo">DOI 10.17487/RFC4960</span>, <time datetime="2007-09" class="refDate">September 2007</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc4960">https://www.rfc-editor.org/info/rfc4960</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC5033">[RFC5033]</dt>
        <dd>
<span class="refAuthor">Floyd, S.</span> and <span class="refAuthor">M. Allman</span>, <span class="refTitle">"Specifying New Congestion Control Algorithms"</span>, <span class="seriesInfo">BCP 133</span>, <span class="seriesInfo">RFC 5033</span>, <span class="seriesInfo">DOI 10.17487/RFC5033</span>, <time datetime="2007-08" class="refDate">August 2007</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc5033">https://www.rfc-editor.org/info/rfc5033</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC5129">[RFC5129]</dt>
        <dd>
<span class="refAuthor">Davie, B.</span>, <span class="refAuthor">Briscoe, B.</span>, and <span class="refAuthor">J. Tay</span>, <span class="refTitle">"Explicit Congestion Marking in MPLS"</span>, <span class="seriesInfo">RFC 5129</span>, <span class="seriesInfo">DOI 10.17487/RFC5129</span>, <time datetime="2008-01" class="refDate">January 2008</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc5129">https://www.rfc-editor.org/info/rfc5129</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC5348">[RFC5348]</dt>
        <dd>
<span class="refAuthor">Floyd, S.</span>, <span class="refAuthor">Handley, M.</span>, <span class="refAuthor">Padhye, J.</span>, and <span class="refAuthor">J. Widmer</span>, <span class="refTitle">"TCP Friendly Rate Control (TFRC): Protocol Specification"</span>, <span class="seriesInfo">RFC 5348</span>, <span class="seriesInfo">DOI 10.17487/RFC5348</span>, <time datetime="2008-09" class="refDate">September 2008</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc5348">https://www.rfc-editor.org/info/rfc5348</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC5562">[RFC5562]</dt>
        <dd>
<span class="refAuthor">Kuzmanovic, A.</span>, <span class="refAuthor">Mondal, A.</span>, <span class="refAuthor">Floyd, S.</span>, and <span class="refAuthor">K. Ramakrishnan</span>, <span class="refTitle">"Adding Explicit Congestion Notification (ECN) Capability to TCP's SYN/ACK Packets"</span>, <span class="seriesInfo">RFC 5562</span>, <span class="seriesInfo">DOI 10.17487/RFC5562</span>, <time datetime="2009-06" class="refDate">June 2009</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc5562">https://www.rfc-editor.org/info/rfc5562</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC5622">[RFC5622]</dt>
        <dd>
<span class="refAuthor">Floyd, S.</span> and <span class="refAuthor">E. Kohler</span>, <span class="refTitle">"Profile for Datagram Congestion Control Protocol (DCCP) Congestion ID 4: TCP-Friendly Rate Control for Small Packets (TFRC-SP)"</span>, <span class="seriesInfo">RFC 5622</span>, <span class="seriesInfo">DOI 10.17487/RFC5622</span>, <time datetime="2009-08" class="refDate">August 2009</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc5622">https://www.rfc-editor.org/info/rfc5622</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC5681">[RFC5681]</dt>
        <dd>
<span class="refAuthor">Allman, M.</span>, <span class="refAuthor">Paxson, V.</span>, and <span class="refAuthor">E. Blanton</span>, <span class="refTitle">"TCP Congestion Control"</span>, <span class="seriesInfo">RFC 5681</span>, <span class="seriesInfo">DOI 10.17487/RFC5681</span>, <time datetime="2009-09" class="refDate">September 2009</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc5681">https://www.rfc-editor.org/info/rfc5681</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC5706">[RFC5706]</dt>
        <dd>
<span class="refAuthor">Harrington, D.</span>, <span class="refTitle">"Guidelines for Considering Operations and Management of New Protocols and Protocol Extensions"</span>, <span class="seriesInfo">RFC 5706</span>, <span class="seriesInfo">DOI 10.17487/RFC5706</span>, <time datetime="2009-11" class="refDate">November 2009</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc5706">https://www.rfc-editor.org/info/rfc5706</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC5865">[RFC5865]</dt>
        <dd>
<span class="refAuthor">Baker, F.</span>, <span class="refAuthor">Polk, J.</span>, and <span class="refAuthor">M. Dolly</span>, <span class="refTitle">"A Differentiated Services Code Point (DSCP) for Capacity-Admitted Traffic"</span>, <span class="seriesInfo">RFC 5865</span>, <span class="seriesInfo">DOI 10.17487/RFC5865</span>, <time datetime="2010-05" class="refDate">May 2010</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc5865">https://www.rfc-editor.org/info/rfc5865</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC5925">[RFC5925]</dt>
        <dd>
<span class="refAuthor">Touch, J.</span>, <span class="refAuthor">Mankin, A.</span>, and <span class="refAuthor">R. Bonica</span>, <span class="refTitle">"The TCP Authentication Option"</span>, <span class="seriesInfo">RFC 5925</span>, <span class="seriesInfo">DOI 10.17487/RFC5925</span>, <time datetime="2010-06" class="refDate">June 2010</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc5925">https://www.rfc-editor.org/info/rfc5925</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC6040">[RFC6040]</dt>
        <dd>
<span class="refAuthor">Briscoe, B.</span>, <span class="refTitle">"Tunnelling of Explicit Congestion Notification"</span>, <span class="seriesInfo">RFC 6040</span>, <span class="seriesInfo">DOI 10.17487/RFC6040</span>, <time datetime="2010-11" class="refDate">November 2010</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc6040">https://www.rfc-editor.org/info/rfc6040</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC6077">[RFC6077]</dt>
        <dd>
<span class="refAuthor">Papadimitriou, D., Ed.</span>, <span class="refAuthor">Welzl, M.</span>, <span class="refAuthor">Scharf, M.</span>, and <span class="refAuthor">B. Briscoe</span>, <span class="refTitle">"Open Research Issues in Internet Congestion Control"</span>, <span class="seriesInfo">RFC 6077</span>, <span class="seriesInfo">DOI 10.17487/RFC6077</span>, <time datetime="2011-02" class="refDate">February 2011</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc6077">https://www.rfc-editor.org/info/rfc6077</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC6347">[RFC6347]</dt>
        <dd>
<span class="refAuthor">Rescorla, E.</span> and <span class="refAuthor">N. Modadugu</span>, <span class="refTitle">"Datagram Transport Layer Security Version 1.2"</span>, <span class="seriesInfo">RFC 6347</span>, <span class="seriesInfo">DOI 10.17487/RFC6347</span>, <time datetime="2012-01" class="refDate">January 2012</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc6347">https://www.rfc-editor.org/info/rfc6347</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC6660">[RFC6660]</dt>
        <dd>
<span class="refAuthor">Briscoe, B.</span>, <span class="refAuthor">Moncaster, T.</span>, and <span class="refAuthor">M. Menth</span>, <span class="refTitle">"Encoding Three Pre-Congestion Notification (PCN) States in the IP Header Using a Single Diffserv Codepoint (DSCP)"</span>, <span class="seriesInfo">RFC 6660</span>, <span class="seriesInfo">DOI 10.17487/RFC6660</span>, <time datetime="2012-07" class="refDate">July 2012</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc6660">https://www.rfc-editor.org/info/rfc6660</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC6675">[RFC6675]</dt>
        <dd>
<span class="refAuthor">Blanton, E.</span>, <span class="refAuthor">Allman, M.</span>, <span class="refAuthor">Wang, L.</span>, <span class="refAuthor">Jarvinen, I.</span>, <span class="refAuthor">Kojo, M.</span>, and <span class="refAuthor">Y. Nishida</span>, <span class="refTitle">"A Conservative Loss Recovery Algorithm Based on Selective Acknowledgment (SACK) for TCP"</span>, <span class="seriesInfo">RFC 6675</span>, <span class="seriesInfo">DOI 10.17487/RFC6675</span>, <time datetime="2012-08" class="refDate">August 2012</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc6675">https://www.rfc-editor.org/info/rfc6675</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC7560">[RFC7560]</dt>
        <dd>
<span class="refAuthor">Kuehlewind, M., Ed.</span>, <span class="refAuthor">Scheffenegger, R.</span>, and <span class="refAuthor">B. Briscoe</span>, <span class="refTitle">"Problem Statement and Requirements for Increased Accuracy in Explicit Congestion Notification (ECN) Feedback"</span>, <span class="seriesInfo">RFC 7560</span>, <span class="seriesInfo">DOI 10.17487/RFC7560</span>, <time datetime="2015-08" class="refDate">August 2015</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc7560">https://www.rfc-editor.org/info/rfc7560</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC7567">[RFC7567]</dt>
        <dd>
<span class="refAuthor">Baker, F., Ed.</span> and <span class="refAuthor">G. Fairhurst, Ed.</span>, <span class="refTitle">"IETF Recommendations Regarding Active Queue Management"</span>, <span class="seriesInfo">BCP 197</span>, <span class="seriesInfo">RFC 7567</span>, <span class="seriesInfo">DOI 10.17487/RFC7567</span>, <time datetime="2015-07" class="refDate">July 2015</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc7567">https://www.rfc-editor.org/info/rfc7567</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC7713">[RFC7713]</dt>
        <dd>
<span class="refAuthor">Mathis, M.</span> and <span class="refAuthor">B. Briscoe</span>, <span class="refTitle">"Congestion Exposure (ConEx) Concepts, Abstract Mechanism, and Requirements"</span>, <span class="seriesInfo">RFC 7713</span>, <span class="seriesInfo">DOI 10.17487/RFC7713</span>, <time datetime="2015-12" class="refDate">December 2015</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc7713">https://www.rfc-editor.org/info/rfc7713</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC8033">[RFC8033]</dt>
        <dd>
<span class="refAuthor">Pan, R.</span>, <span class="refAuthor">Natarajan, P.</span>, <span class="refAuthor">Baker, F.</span>, and <span class="refAuthor">G. White</span>, <span class="refTitle">"Proportional Integral Controller Enhanced (PIE): A Lightweight Control Scheme to Address the Bufferbloat Problem"</span>, <span class="seriesInfo">RFC 8033</span>, <span class="seriesInfo">DOI 10.17487/RFC8033</span>, <time datetime="2017-02" class="refDate">February 2017</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc8033">https://www.rfc-editor.org/info/rfc8033</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC8083">[RFC8083]</dt>
        <dd>
<span class="refAuthor">Perkins, C.</span> and <span class="refAuthor">V. Singh</span>, <span class="refTitle">"Multimedia Congestion Control: Circuit Breakers for Unicast RTP Sessions"</span>, <span class="seriesInfo">RFC 8083</span>, <span class="seriesInfo">DOI 10.17487/RFC8083</span>, <time datetime="2017-03" class="refDate">March 2017</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc8083">https://www.rfc-editor.org/info/rfc8083</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC8085">[RFC8085]</dt>
        <dd>
<span class="refAuthor">Eggert, L.</span>, <span class="refAuthor">Fairhurst, G.</span>, and <span class="refAuthor">G. Shepherd</span>, <span class="refTitle">"UDP Usage Guidelines"</span>, <span class="seriesInfo">BCP 145</span>, <span class="seriesInfo">RFC 8085</span>, <span class="seriesInfo">DOI 10.17487/RFC8085</span>, <time datetime="2017-03" class="refDate">March 2017</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc8085">https://www.rfc-editor.org/info/rfc8085</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC8257">[RFC8257]</dt>
        <dd>
<span class="refAuthor">Bensley, S.</span>, <span class="refAuthor">Thaler, D.</span>, <span class="refAuthor">Balasubramanian, P.</span>, <span class="refAuthor">Eggert, L.</span>, and <span class="refAuthor">G. Judd</span>, <span class="refTitle">"Data Center TCP (DCTCP): TCP Congestion Control for Data Centers"</span>, <span class="seriesInfo">RFC 8257</span>, <span class="seriesInfo">DOI 10.17487/RFC8257</span>, <time datetime="2017-10" class="refDate">October 2017</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc8257">https://www.rfc-editor.org/info/rfc8257</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC8290">[RFC8290]</dt>
        <dd>
<span class="refAuthor">Hoeiland-Joergensen, T.</span>, <span class="refAuthor">McKenney, P.</span>, <span class="refAuthor">Taht, D.</span>, <span class="refAuthor">Gettys, J.</span>, and <span class="refAuthor">E. Dumazet</span>, <span class="refTitle">"The Flow Queue CoDel Packet Scheduler and Active Queue Management Algorithm"</span>, <span class="seriesInfo">RFC 8290</span>, <span class="seriesInfo">DOI 10.17487/RFC8290</span>, <time datetime="2018-01" class="refDate">January 2018</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc8290">https://www.rfc-editor.org/info/rfc8290</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC8298">[RFC8298]</dt>
        <dd>
<span class="refAuthor">Johansson, I.</span> and <span class="refAuthor">Z. Sarker</span>, <span class="refTitle">"Self-Clocked Rate Adaptation for Multimedia"</span>, <span class="seriesInfo">RFC 8298</span>, <span class="seriesInfo">DOI 10.17487/RFC8298</span>, <time datetime="2017-12" class="refDate">December 2017</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc8298">https://www.rfc-editor.org/info/rfc8298</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC8311">[RFC8311]</dt>
        <dd>
<span class="refAuthor">Black, D.</span>, <span class="refTitle">"Relaxing Restrictions on Explicit Congestion Notification (ECN) Experimentation"</span>, <span class="seriesInfo">RFC 8311</span>, <span class="seriesInfo">DOI 10.17487/RFC8311</span>, <time datetime="2018-01" class="refDate">January 2018</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc8311">https://www.rfc-editor.org/info/rfc8311</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC8312">[RFC8312]</dt>
        <dd>
<span class="refAuthor">Rhee, I.</span>, <span class="refAuthor">Xu, L.</span>, <span class="refAuthor">Ha, S.</span>, <span class="refAuthor">Zimmermann, A.</span>, <span class="refAuthor">Eggert, L.</span>, and <span class="refAuthor">R. Scheffenegger</span>, <span class="refTitle">"CUBIC for Fast Long-Distance Networks"</span>, <span class="seriesInfo">RFC 8312</span>, <span class="seriesInfo">DOI 10.17487/RFC8312</span>, <time datetime="2018-02" class="refDate">February 2018</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc8312">https://www.rfc-editor.org/info/rfc8312</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC8511">[RFC8511]</dt>
        <dd>
<span class="refAuthor">Khademi, N.</span>, <span class="refAuthor">Welzl, M.</span>, <span class="refAuthor">Armitage, G.</span>, and <span class="refAuthor">G. Fairhurst</span>, <span class="refTitle">"TCP Alternative Backoff with ECN (ABE)"</span>, <span class="seriesInfo">RFC 8511</span>, <span class="seriesInfo">DOI 10.17487/RFC8511</span>, <time datetime="2018-12" class="refDate">December 2018</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc8511">https://www.rfc-editor.org/info/rfc8511</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC8888">[RFC8888]</dt>
        <dd>
<span class="refAuthor">Sarker, Z.</span>, <span class="refAuthor">Perkins, C.</span>, <span class="refAuthor">Singh, V.</span>, and <span class="refAuthor">M. Ramalho</span>, <span class="refTitle">"RTP Control Protocol (RTCP) Feedback for Congestion Control"</span>, <span class="seriesInfo">RFC 8888</span>, <span class="seriesInfo">DOI 10.17487/RFC8888</span>, <time datetime="2021-01" class="refDate">January 2021</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc8888">https://www.rfc-editor.org/info/rfc8888</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC8985">[RFC8985]</dt>
        <dd>
<span class="refAuthor">Cheng, Y.</span>, <span class="refAuthor">Cardwell, N.</span>, <span class="refAuthor">Dukkipati, N.</span>, and <span class="refAuthor">P. Jha</span>, <span class="refTitle">"The RACK-TLP Loss Detection Algorithm for TCP"</span>, <span class="seriesInfo">RFC 8985</span>, <span class="seriesInfo">DOI 10.17487/RFC8985</span>, <time datetime="2021-02" class="refDate">February 2021</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc8985">https://www.rfc-editor.org/info/rfc8985</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC9000">[RFC9000]</dt>
        <dd>
<span class="refAuthor">Iyengar, J., Ed.</span> and <span class="refAuthor">M. Thomson, Ed.</span>, <span class="refTitle">"QUIC: A UDP-Based Multiplexed and Secure Transport"</span>, <span class="seriesInfo">RFC 9000</span>, <span class="seriesInfo">DOI 10.17487/RFC9000</span>, <time datetime="2021-05" class="refDate">May 2021</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc9000">https://www.rfc-editor.org/info/rfc9000</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="Savage-TCP">[Savage-TCP]</dt>
        <dd>
<span class="refAuthor">Savage, S.</span>, <span class="refAuthor">Cardwell, N.</span>, <span class="refAuthor">Wetherall, D.</span>, and <span class="refAuthor">T. Anderson</span>, <span class="refTitle">"TCP Congestion Control with a Misbehaving Receiver"</span>, <span class="seriesInfo">ACM SIGCOMM Computer Communication Review 29(5):71--78</span>, <time datetime="1999-10" class="refDate">October 1999</time>. </dd>
<dd class="break"></dd>
<dt id="SCReAM">[SCReAM]</dt>
        <dd>
<span class="refAuthor">Johansson, I.</span>, <span class="refTitle">"SCReAM"</span>, <span class="seriesInfo">github repository; </span>, <span>&lt;<a href="https://github.com/EricssonResearch/scream/blob/master/README.md">https://github.com/EricssonResearch/scream/blob/master/README.md</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="sub-mss-prob">[sub-mss-prob]</dt>
        <dd>
<span class="refAuthor">Briscoe, B.</span> and <span class="refAuthor">K. De Schepper</span>, <span class="refTitle">"Scaling TCP's Congestion Window for Small Round Trip Times"</span>, <span class="seriesInfo">BT Technical Report TR-TUB8-2015-002</span>, <time datetime="2015-05" class="refDate">May 2015</time>, <span>&lt;<a href="https://arxiv.org/abs/1904.07598">https://arxiv.org/abs/1904.07598</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="TCP-CA">[TCP-CA]</dt>
        <dd>
<span class="refAuthor">Jacobson, V.</span> and <span class="refAuthor">M.J. Karels</span>, <span class="refTitle">"Congestion Avoidance and Control"</span>, <span class="seriesInfo">Laurence Berkeley Labs Technical Report </span>, <time datetime="1988-11" class="refDate">November 1988</time>, <span>&lt;<a href="http://ee.lbl.gov/papers/congavoid.pdf">http://ee.lbl.gov/papers/congavoid.pdf</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="TCPPrague">[TCPPrague]</dt>
        <dd>
<span class="refAuthor">Briscoe, B.</span>, <span class="refTitle">"Notes: DCTCP evolution 'bar BoF': Tue 21 Jul 2015, 17:40, Prague"</span>, <span class="seriesInfo">tcpprague mailing list archive </span>, <time datetime="2015-07" class="refDate">July 2015</time>, <span>&lt;<a href="https://www.ietf.org/mail-archive/web/tcpprague/current/msg00001.html">https://www.ietf.org/mail-archive/web/tcpprague/current/msg00001.html</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="VCP">[VCP]</dt>
      <dd>
<span class="refAuthor">Xia, Y.</span>, <span class="refAuthor">Subramanian, L.</span>, <span class="refAuthor">Stoica, I.</span>, and <span class="refAuthor">S. Kalyanaraman</span>, <span class="refTitle">"One more bit is enough"</span>, <span class="seriesInfo">Proc. SIGCOMM'05, ACM CCR 35(4)37--48</span>, <time datetime="2005" class="refDate">2005</time>, <span>&lt;<a href="http://doi.acm.org/10.1145/1080091.1080098">http://doi.acm.org/10.1145/1080091.1080098</a>&gt;</span>. </dd>
<dd class="break"></dd>
</dl>
</section>
</section>
<div id="l4sps_tcp-prague-reqs">
<section id="appendix-A">
      <h2 id="name-rationale-for-the-prague-l4">
<a href="#appendix-A" class="section-number selfRef">Appendix A. </a><a href="#name-rationale-for-the-prague-l4" class="section-name selfRef">Rationale for the 'Prague L4S Requirements'</a>
      </h2>
<p id="appendix-A-1">This appendix is informative, not normative. It gives a list of
      modifications to current scalable congestion controls so that they can
      be deployed over the public Internet and coexist safely with existing
      traffic. The list complements the normative requirements in <a href="#l4sid_transport_req" class="xref">Section 4</a> that a sender has to comply with before
      it can set the L4S identifier in packets it sends into the Internet. As
      well as rationale for safety improvements (the requirements in <a href="#l4sid_transport_req" class="xref">Section 4</a>) this appendix also includes preferable
      performance improvements (optimizations).<a href="#appendix-A-1" class="pilcrow">Â¶</a></p>
<p id="appendix-A-2">The requirements and recommendations in <a href="#l4sid_transport_req" class="xref">Section 4</a>) have become know as the Prague L4S
      Requirements, because they were originally identified at an ad hoc
      meeting during IETF-94 in PragueÂ <span>[<a href="#TCPPrague" class="xref">TCPPrague</a>]</span>. They
      were originally called the 'TCP Prague Requirements', but they are not
      solely applicable to TCP, so the name and wording has been generalized
      for all transport protocols, and the name 'TCP Prague' is now used for a
      specific implementation of the requirements.<a href="#appendix-A-2" class="pilcrow">Â¶</a></p>
<p id="appendix-A-3">At the time of writing, DCTCPÂ <span>[<a href="#RFC8257" class="xref">RFC8257</a>]</span> is the
      most widely used scalable transport protocol. In its current form, DCTCP
      is specified to be deployable only in controlled environments. Deploying
      it in the public Internet would lead to a number of issues, both from
      the safety and the performance perspective. The modifications and
      additional mechanisms listed in this section will be necessary for its
      deployment over the global Internet. Where an example is needed, DCTCP
      is used as a base, but the requirements in <a href="#l4sid_transport_req" class="xref">Section 4</a> apply equally to other scalable
      congestion controls, covering adaptive real-time media, etc., not just
      capacity-seeking behaviours.<a href="#appendix-A-3" class="pilcrow">Â¶</a></p>
<section id="appendix-A.1">
        <h3 id="name-rationale-for-the-requireme">
<a href="#appendix-A.1" class="section-number selfRef">A.1. </a><a href="#name-rationale-for-the-requireme" class="section-name selfRef">Rationale for the Requirements for Scalable Transport Protocols</a>
        </h3>
<p id="appendix-A.1-1"></p>
<section id="appendix-A.1.1">
          <h4 id="name-use-of-l4s-packet-identifie">
<a href="#appendix-A.1.1" class="section-number selfRef">A.1.1. </a><a href="#name-use-of-l4s-packet-identifie" class="section-name selfRef">Use of L4S Packet Identifier</a>
          </h4>
<p id="appendix-A.1.1-1">Description: A scalable congestion control needs to distinguish
          the packets it sends from those sent by Classic congestion controls
          (see the precise normative requirement wording in <a href="#l4sid_codepoint" class="xref">Section 4.1</a>).<a href="#appendix-A.1.1-1" class="pilcrow">Â¶</a></p>
<p id="appendix-A.1.1-2">Motivation: It needs to be possible for a network node to
          classify L4S packets without flow state into a queue that applies an
          L4S ECN marking behaviour and isolates L4S packets from the queuing
          delay of Classic packets.<a href="#appendix-A.1.1-2" class="pilcrow">Â¶</a></p>
</section>
<section id="appendix-A.1.2">
          <h4 id="name-accurate-ecn-feedback">
<a href="#appendix-A.1.2" class="section-number selfRef">A.1.2. </a><a href="#name-accurate-ecn-feedback" class="section-name selfRef">Accurate ECN Feedback</a>
          </h4>
<p id="appendix-A.1.2-1">Description: The transport protocol for a scalable congestion
          control needs to provide timely, accurate feedback about the extent
          of ECN marking experienced by all packets (see the precise normative
          requirement wording in <a href="#l4sid_feedback" class="xref">Section 4.2</a>).<a href="#appendix-A.1.2-1" class="pilcrow">Â¶</a></p>
<p id="appendix-A.1.2-2">Motivation: Classic congestion controls only need feedback about
          the existence of a congestion episode within a round trip, not
          precisely how many packets were marked with ECN or dropped.
          Therefore, in 2001, when ECN feedback was added to TCPÂ <span>[<a href="#RFC3168" class="xref">RFC3168</a>]</span>, it could not inform the sender of more than one
          ECN mark per RTT. Since then, requirements for more accurate ECN
          feedback in TCP have been defined in <span>[<a href="#RFC7560" class="xref">RFC7560</a>]</span> and
          <span>[<a href="#I-D.ietf-tcpm-accurate-ecn" class="xref">I-D.ietf-tcpm-accurate-ecn</a>]</span> specifies a change to
          the TCP protocol to satisfy these requirements. Most other transport
          protocols already satisfy this requirement (see <a href="#l4sid_feedback" class="xref">Section 4.2</a>).<a href="#appendix-A.1.2-2" class="pilcrow">Â¶</a></p>
</section>
<div id="l4sid_sec_replaceable">
<section id="appendix-A.1.3">
          <h4 id="name-capable-of-replacement-by-c">
<a href="#appendix-A.1.3" class="section-number selfRef">A.1.3. </a><a href="#name-capable-of-replacement-by-c" class="section-name selfRef">Capable of Replacement by Classic Congestion Control</a>
          </h4>
<p id="appendix-A.1.3-1">Description: It needs to be possible to replace the
          implementation of a scalable congestion control with a Classic
          control (see the precise normative requirement wording in <a href="#l4sid_congestion_response" class="xref">Section 4.3</a>).<a href="#appendix-A.1.3-1" class="pilcrow">Â¶</a></p>
<p id="appendix-A.1.3-2">Motivation: L4S is an experimental protocol, therefore it seems
          prudent to be able to disable it at source in case of insurmountable
          problems, perhaps due to some unexpected interaction on a particular
          sender; over a particular path or network; with a particular
          receiver or even ultimately an insurmountable problem with the
          experiment as a whole.<a href="#appendix-A.1.3-2" class="pilcrow">Â¶</a></p>
</section>
</div>
<div id="l4sid_sec_fallback_on_loss">
<section id="appendix-A.1.4">
          <h4 id="name-fall-back-to-classic-conges">
<a href="#appendix-A.1.4" class="section-number selfRef">A.1.4. </a><a href="#name-fall-back-to-classic-conges" class="section-name selfRef">Fall back to Classic Congestion Control on Packet Loss</a>
          </h4>
<p id="appendix-A.1.4-1">Description: As well as responding to ECN markings in a scalable
          way, a scalable congestion control needs to react to packet loss in
          a way that will coexist safely with a Reno congestion
          controlÂ <span>[<a href="#RFC5681" class="xref">RFC5681</a>]</span> (see the precise normative
          requirement wording in <a href="#l4sid_congestion_response" class="xref">Section 4.3</a>).<a href="#appendix-A.1.4-1" class="pilcrow">Â¶</a></p>
<p id="appendix-A.1.4-2">Motivation: Part of the safety conditions for deploying a
          scalable congestion control on the public Internet is to make sure
          that it behaves properly when it builds a queue at a network
          bottleneck that has not been upgraded to support L4S. Packet loss
          can have many causes, but it usually has to be conservatively
          assumed that it is a sign of congestion. Therefore, on detecting
          packet loss, a scalable congestion control will need to fall back to
          Classic congestion control behaviour. If it does not comply, it
          could starve Classic traffic.<a href="#appendix-A.1.4-2" class="pilcrow">Â¶</a></p>
<p id="appendix-A.1.4-3">A scalable congestion control can be used for different types of
          transport, e.g.Â for real-time media or for reliable transport
          like TCP. Therefore, the particular Classic congestion control
          behaviour to fall back on will need to be dependent on the specific
          congestion control implementation. In the particular case of DCTCP,
          the DCTCP specificationÂ <span>[<a href="#RFC8257" class="xref">RFC8257</a>]</span> states that
          "It is RECOMMENDED that an implementation deal with loss episodes in
          the same way as conventional TCP." For safe deployment, <a href="#l4sid_congestion_response" class="xref">Section 4.3</a> requires any specification of a
          scalable congestion control for the public Internet to define the
          above requirement as a "MUST".<a href="#appendix-A.1.4-3" class="pilcrow">Â¶</a></p>
<p id="appendix-A.1.4-4">Even though a bottleneck is L4S capable, it might still become
          overloaded and have to drop packets. In this case, the sender may
          receive a high proportion of packets marked with the CE bit set and
          also experience loss. Current DCTCP implementations each react
          differently to this situation. At least one implementation reacts
          only to the drop signal (e.g.Â by halving the CWND) and at least
          another DCTCP implementation reacts to both signals (e.g.Â by
          halving the CWND due to the drop and also further reducing the CWND
          based on the proportion of marked packet). A third approach for the
          public Internet has been proposed that adjusts the loss response to
          result in a halving when combined with the ECN response. We believe
          that further experimentation is needed to understand what is the
          best behaviour for the public Internet, which may or not be one of
          these existing approaches.<a href="#appendix-A.1.4-4" class="pilcrow">Â¶</a></p>
</section>
</div>
<div id="l4sid_sec_fallback_on_classic_CE">
<section id="appendix-A.1.5">
          <h4 id="name-coexistence-with-classic-co">
<a href="#appendix-A.1.5" class="section-number selfRef">A.1.5. </a><a href="#name-coexistence-with-classic-co" class="section-name selfRef">Coexistence with Classic Congestion Control at Classic ECN bottlenecks</a>
          </h4>
<p id="appendix-A.1.5-1">Description: Monitoring has to be in place so that a non-L4S but
          ECN-capable AQM can be detected at path bottlenecks. This is in case
          such an AQM has been implemented in a shared queue, in which case
          any long-running scalable flow would predominate over any
          simultaneous long-running Classic flow sharing the queue. The
          precise requirement wording in <a href="#l4sid_congestion_response" class="xref">Section 4.3</a> is written so that such a
          problem could either be resolved in real-time, or via administrative
          intervention.<a href="#appendix-A.1.5-1" class="pilcrow">Â¶</a></p>
<p id="appendix-A.1.5-2">Motivation: Similarly to the discussion in <a href="#l4sid_sec_fallback_on_loss" class="xref">Appendix A.1.4</a>, this requirement in <a href="#l4sid_congestion_response" class="xref">Section 4.3</a> is a safety condition to ensure
          an L4S congestion control coexists well with Classic flows when it
          builds a queue at a shared network bottleneck that has not been
          upgraded to support L4S. Nonetheless, if necessary, it is considered
          reasonable to resolve such problems over management timescales
          (possibly involving human intervention) because:<a href="#appendix-A.1.5-2" class="pilcrow">Â¶</a></p>
<ul class="normal">
<li class="normal" id="appendix-A.1.5-3.1">although a Classic flow can considerably reduce its
              throughput in the face of a competing scalable flow, it still
              makes progress and does not starve;<a href="#appendix-A.1.5-3.1" class="pilcrow">Â¶</a>
</li>
            <li class="normal" id="appendix-A.1.5-3.2">implementations of a Classic ECN AQM in a queue that is
              intended to be shared are believed to be rare;<a href="#appendix-A.1.5-3.2" class="pilcrow">Â¶</a>
</li>
            <li class="normal" id="appendix-A.1.5-3.3">detection of such AQMs is not always clear-cut; so focused
              out-of-band testing (or even contacting the relevant network
              operator) would improve certainty.<a href="#appendix-A.1.5-3.3" class="pilcrow">Â¶</a>
</li>
          </ul>
<p id="appendix-A.1.5-4">Therefore, the relevant normative requirement (<a href="#l4sid_congestion_response" class="xref">Section 4.3</a>) is divided into three stages:
          monitoring, detection and action:<a href="#appendix-A.1.5-4" class="pilcrow">Â¶</a></p>
<span class="break"></span><dl class="dlParallel" id="appendix-A.1.5-5">
            <dt id="appendix-A.1.5-5.1">Monitoring:</dt>
            <dd style="margin-left: 1.5em" id="appendix-A.1.5-5.2">Monitoring involves collection of the
              measurement data to be analysed. Monitoring is expressed as a
              'MUST' for uncontrolled environments, although the placement of
              the monitoring function is left open. Whether monitoring has to
              be applied in real-time is expressed as a 'SHOULD'. This allows
              for the possibility that the operator of an L4S sender
              (e.g.Â a CDN) might prefer to test out-of-band for signs of
              Classic ECN AQMs, perhaps to avoid continually consuming
              resources to monitor live traffic.<a href="#appendix-A.1.5-5.2" class="pilcrow">Â¶</a>
</dd>
            <dd class="break"></dd>
<dt id="appendix-A.1.5-5.3">Detection:</dt>
            <dd style="margin-left: 1.5em" id="appendix-A.1.5-5.4">Detection involves analysis of the
              monitored data to detect the likelihood of a Classic ECN AQM.
              Detection can either directly detect actual coexistence problems
              between flows, or it can aim to identify AQM technologies that
              are likely to present coexistence problems, based on knowledge
              of AQMs deployed at the time. The requirements recommend that
              detection occurs live in real-time. However, detection is
              allowed to be deferred (e.g.Â it might involve further
              testing targeted at candidate AQMs);<a href="#appendix-A.1.5-5.4" class="pilcrow">Â¶</a>
</dd>
            <dd class="break"></dd>
<dt id="appendix-A.1.5-5.5">Action:</dt>
            <dd style="margin-left: 1.5em" id="appendix-A.1.5-5.6">
              <p id="appendix-A.1.5-5.6.1">This involves the act of switching the
              sender to a Classic congestion control. This might occur in
              real-time within the congestion control for the subsequent
              duration of a flow, or it might involve administrative action to
              switch to Classic congestion control for a specific interface or
              for a certain set of destination addresses.<a href="#appendix-A.1.5-5.6.1" class="pilcrow">Â¶</a></p>
<p id="appendix-A.1.5-5.6.2">Instead of the sender taking action itself, the
              operator of the sender (e.g.Â a CDN) might prefer to ask the
              network operator to modify the Classic AQM's treatment of L4S
              packets; or to ensure L4S packets bypass the AQM; or to upgrade
              the AQM to support L4S (see the L4S operational
              guidanceÂ <span>[<a href="#I-D.ietf-tsvwg-l4sops" class="xref">I-D.ietf-tsvwg-l4sops</a>]</span>). Once L4S
              flows no longer shared the Classic ECN AQM they would obviously
              no longer detect it, and the requirement to act on it would no
              longer apply.<a href="#appendix-A.1.5-5.6.2" class="pilcrow">Â¶</a></p>
</dd>
          <dd class="break"></dd>
</dl>
<p id="appendix-A.1.5-6">The whole set of normative requirements concerning Classic ECN
          AQMs in <a href="#l4sid_congestion_response" class="xref">Section 4.3</a> is worded so that
          it does not apply in controlled environments, such as private
          networks or data centre networks. CDN servers placed within an
          access ISP's network can be considered as a single controlled
          environment, but any onward networks served by the access network,
          including all the attached customer networks, would be unlikely to
          fall under the same degree of coordinated control. Monitoring is
          expressed as a 'MUST' for these uncontrolled segments of paths
          (e.g.Â beyond the access ISP in a home network), because there
          is a possibility that there might be a shared queue Classic ECN AQM
          in that segment. Nonetheless, the intent of the wording is to only
          require occasional monitoring of these uncontrolled regions, and not
          to burden CDN operators if monitoring never uncovers any potential
          problems.<a href="#appendix-A.1.5-6" class="pilcrow">Â¶</a></p>
<p id="appendix-A.1.5-7">More detailed discussion of all the above options and
          alternatives can be found in the L4S operational guidanceÂ <span>[<a href="#I-D.ietf-tsvwg-l4sops" class="xref">I-D.ietf-tsvwg-l4sops</a>]</span>.<a href="#appendix-A.1.5-7" class="pilcrow">Â¶</a></p>
<p id="appendix-A.1.5-8">Having said all the above, the approach recommended in <a href="#l4sid_congestion_response" class="xref">Section 4.3</a> is to monitor, detect and act
          in real-time on live traffic. A passive monitoring algorithm to
          detect a Classic ECN AQM at the bottleneck and fall back to Classic
          congestion control is described in an extensive technical
          reportÂ <span>[<a href="#ecn-fallback" class="xref">ecn-fallback</a>]</span>, which also provides a
          link to Linux source code, and a large online visualization of its
          evaluation results. Very briefly, the algorithm primarily monitors
          RTT variation using the same algorithm that maintains the mean
          deviation of TCP's smoothed RTT, but it smooths over a duration of
          the order of a Classic sawtooth. The outcome is also conditioned on
          other metrics such as the presence of CE marking and congestion
          avoidance phase having stabilized. The report also identifies
          further work to improve the approach, for instance improvements with
          low capacity links and combining the measurements with a cache of
          what had been learned about a path in previous connections. The
          report also suggests alternative approaches.<a href="#appendix-A.1.5-8" class="pilcrow">Â¶</a></p>
<p id="appendix-A.1.5-9">Although using passive measurements within live traffic (as
          above) can detect a Classic ECN AQM, it is much harder (perhaps
          impossible) to determine whether or not the AQM is in a shared
          queue. Nonetheless, this is much easier using active test traffic
          out-of-band, because two flows can be used. Section 4 of the same
          reportÂ <span>[<a href="#ecn-fallback" class="xref">ecn-fallback</a>]</span> describes a simple
          technique to detect a Classic ECN AQM and determine whether it is in
          a shared queue, summarized here.<a href="#appendix-A.1.5-9" class="pilcrow">Â¶</a></p>
<p id="appendix-A.1.5-10">An L4S-enabled test server could be set up so that, when a test
          client accesses it, it serves a script that gets the client to open
          two parallel long-running flows. It could serve one with a Classic
          congestion control (C, that sets ECT(0)) and one with a scalable CC
          (L, that sets ECT(1)). If neither flow induces any ECN marks, it can
          be presumed the path does not contain a Classic ECN AQM. If either
          flow induces some ECN marks, the server could measure the relative
          flow rates and round trip times of the two flows. <a href="#l4sid_tab_active_AQN_test" class="xref">Table 2</a> shows the AQM that can be
          inferred for various cases (presuming the AQM behaviours known at
          the time of writing).<a href="#appendix-A.1.5-10" class="pilcrow">Â¶</a></p>
<span id="name-out-of-band-testing-with-tw"></span><div id="l4sid_tab_active_AQN_test">
<table class="center" id="table-2">
            <caption>
<a href="#table-2" class="selfRef">Table 2</a>:
<a href="#name-out-of-band-testing-with-tw" class="selfRef">Out-of-band testing with two parallel flows. L:=L4S, C:=Classic.</a>
            </caption>
<thead>
              <tr>
                <th class="text-left" rowspan="1" colspan="1">Rate</th>
                <th class="text-left" rowspan="1" colspan="1">RTT</th>
                <th class="text-left" rowspan="1" colspan="1">Inferred AQM</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td class="text-left" rowspan="1" colspan="1">L &gt; C</td>
                <td class="text-left" rowspan="1" colspan="1">L = C</td>
                <td class="text-left" rowspan="1" colspan="1">Classic ECN AQM (FIFO)</td>
              </tr>
              <tr>
                <td class="text-left" rowspan="1" colspan="1">L = C</td>
                <td class="text-left" rowspan="1" colspan="1">L = C</td>
                <td class="text-left" rowspan="1" colspan="1">Classic ECN AQM (FQ)</td>
              </tr>
              <tr>
                <td class="text-left" rowspan="1" colspan="1">L = C</td>
                <td class="text-left" rowspan="1" colspan="1">L &lt; C</td>
                <td class="text-left" rowspan="1" colspan="1">FQ-L4S AQM</td>
              </tr>
              <tr>
                <td class="text-left" rowspan="1" colspan="1">L ~= C</td>
                <td class="text-left" rowspan="1" colspan="1">L &lt; C</td>
                <td class="text-left" rowspan="1" colspan="1">Coupled DualQ AQM</td>
              </tr>
            </tbody>
          </table>
</div>
<p id="appendix-A.1.5-12">Finally, we motivate the recommendation in <a href="#l4sid_congestion_response" class="xref">Section 4.3</a> that a scalable congestion
          control is not expected to change to setting ECT(0) while it adapts
          its behaviour to coexist with Classic flows. This is because the
          sender needs to continue to check whether it made the right decision
          - and switch back if it was wrong, or if a different link becomes
          the bottleneck:<a href="#appendix-A.1.5-12" class="pilcrow">Â¶</a></p>
<ul class="normal">
<li class="normal" id="appendix-A.1.5-13.1">If, as recommended, the sender changes only its behaviour but
              not its codepoint to Classic, its codepoint will still be
              compatible with either an L4S or a Classic AQM. If the
              bottleneck does actually support both, it will still classify
              ECT(1) into the same L4S queue, where the sender can measure
              that switching to Classic behaviour was wrong, so that it can
              switch back.<a href="#appendix-A.1.5-13.1" class="pilcrow">Â¶</a>
</li>
            <li class="normal" id="appendix-A.1.5-13.2">In contrast, if the sender changes both its behaviour and its
              codepoint to Classic, even if the bottleneck supports both, it
              will classify ECT(0) into the Classic queue, reinforcing the
              sender's incorrect decision so that it never switches back.<a href="#appendix-A.1.5-13.2" class="pilcrow">Â¶</a>
</li>
            <li class="normal" id="appendix-A.1.5-13.3">Also, not changing codepoint avoids the risk of being flipped
              to a different path by a load balancer or multipath routing that
              hashes on the whole of the ex-ToS byte (unfortunately still a
              common pathology).<a href="#appendix-A.1.5-13.3" class="pilcrow">Â¶</a>
</li>
          </ul>
<p id="appendix-A.1.5-14">Note that if a flow is configured to <em>only</em>
          use a Classic congestion control, it is then entirely appropriate
          not to use ECT(1).<a href="#appendix-A.1.5-14" class="pilcrow">Â¶</a></p>
</section>
</div>
<div id="l4sid_sec_RTT_dependence">
<section id="appendix-A.1.6">
          <h4 id="name-reduce-rtt-dependence">
<a href="#appendix-A.1.6" class="section-number selfRef">A.1.6. </a><a href="#name-reduce-rtt-dependence" class="section-name selfRef">Reduce RTT dependence</a>
          </h4>
<p id="appendix-A.1.6-1">Description: A scalable congestion control needs to reduce RTT
          bias as much as possible at least over the low to typical range of
          RTTs that will interact in the intended deployment scenario (see the
          precise normative requirement wording in <a href="#l4sid_congestion_response" class="xref">Section 4.3</a>).<a href="#appendix-A.1.6-1" class="pilcrow">Â¶</a></p>
<p id="appendix-A.1.6-2">Motivation: The throughput of Classic congestion controls is
          known to be inversely proportional to RTT, so one would expect flows
          over very low RTT paths to nearly starve flows over larger RTTs.
          However, Classic congestion controls have never allowed a very low
          RTT path to exist because they induce a large queue. For instance,
          consider two paths with base RTT 1Â ms and 100Â ms. If a
          Classic congestion control induces a 100Â ms queue, it turns
          these RTTs into 101Â ms and 200Â ms leading to a throughput
          ratio of about 2:1. Whereas if a scalable congestion control induces
          only a 1Â ms queue, the ratio is 2:101, leading to a throughput
          ratio of about 50:1.<a href="#appendix-A.1.6-2" class="pilcrow">Â¶</a></p>
<p id="appendix-A.1.6-3">Therefore, with very small queues, long RTT flows will
          essentially starve, unless scalable congestion controls comply with
          this requirement in <a href="#l4sid_congestion_response" class="xref">Section 4.3</a>.<a href="#appendix-A.1.6-3" class="pilcrow">Â¶</a></p>
<p id="appendix-A.1.6-4">The RTT bias in current Classic congestion controls works
          satisfactorily when the RTT is higher than typical, and L4S does not
          change that. So, there is no additional requirement in <a href="#l4sid_congestion_response" class="xref">Section 4.3</a> for high RTT L4S flows to
          remove RTT bias - they can but they don't have to.<a href="#appendix-A.1.6-4" class="pilcrow">Â¶</a></p>
</section>
</div>
<div id="l4sid_sec_min_cwnd">
<section id="appendix-A.1.7">
          <h4 id="name-scaling-down-to-fractional-">
<a href="#appendix-A.1.7" class="section-number selfRef">A.1.7. </a><a href="#name-scaling-down-to-fractional-" class="section-name selfRef">Scaling down to fractional congestion windows</a>
          </h4>
<p id="appendix-A.1.7-1">Description: A scalable congestion control needs to remain
          responsive to congestion when typical RTTs over the public Internet
          are significantly smaller because they are no longer inflated by
          queuing delay (see the precise normative requirement wording in
          <a href="#l4sid_congestion_response" class="xref">Section 4.3</a>).<a href="#appendix-A.1.7-1" class="pilcrow">Â¶</a></p>
<p id="appendix-A.1.7-2">Motivation: As currently specified, the minimum congestion window
          of ECN-capable TCP (and its derivatives) is expected to be 2 sender
          maximum segment sizes (SMSS), or 1 SMSS after a retransmission
          timeout. Once the congestion window reaches this minimum, if there
          is further ECN-marking, TCP is meant to wait for a retransmission
          timeout before sending another segment (see section 6.1.2 of the ECN
          specÂ <span>[<a href="#RFC3168" class="xref">RFC3168</a>]</span>). In practice, most known
          window-based congestion control algorithms become unresponsive to
          ECN congestion signals at this point. No matter how much ECN
          marking, the congestion window no longer reduces. Instead, the
          sender's lack of any further congestion response forces the queue to
          grow, overriding any AQM and increasing queuing delay (making the
          window large enough to become responsive again). This can result in
          a stable but deeper queue, or it might drive the queue to loss, then
          the retransmission timeout mechanism acts as a backstop.<a href="#appendix-A.1.7-2" class="pilcrow">Â¶</a></p>
<p id="appendix-A.1.7-3">Most window-based congestion controls for other transport
          protocols have a similar minimum window, albeit when measured in
          bytes for those that use smaller packets.<a href="#appendix-A.1.7-3" class="pilcrow">Â¶</a></p>
<p id="appendix-A.1.7-4">L4S mechanisms significantly reduce queueing delay so, over the
          same path, the RTT becomes lower. Then this problem becomes
          surprisingly commonÂ <span>[<a href="#sub-mss-prob" class="xref">sub-mss-prob</a>]</span>. This is
          because, for the same link capacity, smaller RTT implies a smaller
          window. For instance, consider a residential setting with an
          upstream broadband Internet access of 8Â Mb/s, assuming a max
          segment size of 1500Â B. Two upstream flows will each have the
          minimum window of 2Â SMSS if the RTT is 6Â ms or less, which
          is quite common when accessing a nearby data centre. So, any more
          than two such parallel TCP flows will become unresponsive to ECN and
          increase queuing delay.<a href="#appendix-A.1.7-4" class="pilcrow">Â¶</a></p>
<p id="appendix-A.1.7-5">Unless scalable congestion controls address the requirement in
          <a href="#l4sid_congestion_response" class="xref">Section 4.3</a> from the start, they will
          frequently become unresponsive to ECN, negating the low latency
          benefit of L4S, for themselves and for others.<a href="#appendix-A.1.7-5" class="pilcrow">Â¶</a></p>
<p id="appendix-A.1.7-6">That would seem to imply that scalable congestion controllers
          ought to be required to be able work with a congestion window less
          than 1Â SMSS. For instance, if an ECN-capable TCP gets an
          ECN-mark when it is already sitting at a window of 1Â SMSS,
          RFCÂ 3168 requires it to defer sending for a retransmission
          timeout. A less drastic but more complex mechanism can maintain a
          congestion window less than 1Â SMSS (significantly less if
          necessary), as described in <span>[<a href="#Ahmed19" class="xref">Ahmed19</a>]</span>. Other
          approaches are likely to be feasible.<a href="#appendix-A.1.7-6" class="pilcrow">Â¶</a></p>
<p id="appendix-A.1.7-7">However, the requirement in <a href="#l4sid_congestion_response" class="xref">Section 4.3</a> is worded as a "SHOULD" because
          it is believed that the existence of a minimum window is not all
          bad. When competing with an unresponsive flow, a minimum window
          naturally protects the flow from starvation by at least keeping some
          data flowing.<a href="#appendix-A.1.7-7" class="pilcrow">Â¶</a></p>
<p id="appendix-A.1.7-8">By stating the requirement to go lower than 1Â SMSS as a
          "SHOULD", while the requirement in RFCÂ 3168 still stands as
          well, we shall be able to watch the choices of minimum window evolve
          in different scalable congestion controllers.<a href="#appendix-A.1.7-8" class="pilcrow">Â¶</a></p>
</section>
</div>
<div id="l4sid_sec_reordering_tolerance">
<section id="appendix-A.1.8">
          <h4 id="name-measuring-reordering-tolera">
<a href="#appendix-A.1.8" class="section-number selfRef">A.1.8. </a><a href="#name-measuring-reordering-tolera" class="section-name selfRef">Measuring Reordering Tolerance in Time Units</a>
          </h4>
<p id="appendix-A.1.8-1">Description: When detecting loss, a scalable congestion control
          needs to be tolerant to reordering over an adaptive time interval,
          which scales with throughput, rather than counting only in fixed
          units of packets, which does not scale (see the precise normative
          requirement wording in <a href="#l4sid_congestion_response" class="xref">Section 4.3</a>).<a href="#appendix-A.1.8-1" class="pilcrow">Â¶</a></p>
<p id="appendix-A.1.8-2">Motivation: A primary purpose of L4S is scalable throughput (it's
          in the name). Scalability in all dimensions is, of course, also a
          goal of all IETF technology. The inverse linear congestion response
          in <a href="#l4sid_congestion_response" class="xref">Section 4.3</a> is necessary, but not
          sufficient, to solve the congestion control scalability problem
          identified in <span>[<a href="#RFC3649" class="xref">RFC3649</a>]</span>. As well as maintaining
          frequent ECN signals as rate scales, it is also important to ensure
          that a potentially false perception of loss does not limit
          throughput scaling.<a href="#appendix-A.1.8-2" class="pilcrow">Â¶</a></p>
<p id="appendix-A.1.8-3">End-systems cannot know whether a missing packet is due to loss
          or reordering, except in hindsight - if it appears later. So they
          can only deem that there has been a loss if a gap in the sequence
          space has not been filled, either after a certain number of
          subsequent packets has arrived (e.g.Â the 3 DupACK rule of
          standard TCP congestion controlÂ <span>[<a href="#RFC5681" class="xref">RFC5681</a>]</span>) or
          after a certain amount of time (e.g.Â the RACK
          approachÂ <span>[<a href="#RFC8985" class="xref">RFC8985</a>]</span>).<a href="#appendix-A.1.8-3" class="pilcrow">Â¶</a></p>
<p id="appendix-A.1.8-4">As we attempt to scale packet rate over the years:<a href="#appendix-A.1.8-4" class="pilcrow">Â¶</a></p>
<ul class="normal">
<li class="normal" id="appendix-A.1.8-5.1">Even if only <em>some</em> sending hosts
              still deem that loss has occurred by counting reordered packets,
              <em>all</em> networks will have to keep
              reducing the time over which they keep packets in order. If some
              link technologies keep the time within which reordering occurs
              roughly unchanged, then loss over these links, as perceived by
              these hosts, will appear to continually rise over the years.<a href="#appendix-A.1.8-5.1" class="pilcrow">Â¶</a>
</li>
            <li class="normal" id="appendix-A.1.8-5.2">In contrast, if all senders detect loss in units of time, the
              time over which the network has to keep packets in order stays
              roughly invariant.<a href="#appendix-A.1.8-5.2" class="pilcrow">Â¶</a>
</li>
          </ul>
<p id="appendix-A.1.8-6">Therefore hosts have an incentive to detect loss in time
          units (so as not to fool themselves too often into detecting losses
          when there are none). And for hosts that are changing their
          congestion control implementation to L4S, there is no downside to
          including time-based loss detection code in the change (loss
          recovery implemented in hardware is an exception, covered later).
          Therefore requiring L4S hosts to detect loss in time-based units
          would not be a burden.<a href="#appendix-A.1.8-6" class="pilcrow">Â¶</a></p>
<p id="appendix-A.1.8-7">If the requirement in <a href="#l4sid_congestion_response" class="xref">Section 4.3</a>
          were not placed on L4S hosts, even though it would be no burden on
          hosts to comply, all networks would face unnecessary uncertainty
          over whether some L4S hosts might be detecting loss by counting
          packets. Then <em>all</em> link technologies will
          have to unnecessarily keep reducing the time within which reordering
          occurs. That is not a problem for some link technologies, but it
          becomes increasingly challenging for other link technologies to
          continue to scale, particularly those relying on channel bonding for
          scaling, such as LTE, 5G and DOCSIS.<a href="#appendix-A.1.8-7" class="pilcrow">Â¶</a></p>
<p id="appendix-A.1.8-8">Given Internet paths traverse many link technologies, any scaling
          limit for these more challenging access link technologies would
          become a scaling limit for the Internet as a whole.<a href="#appendix-A.1.8-8" class="pilcrow">Â¶</a></p>
<p id="appendix-A.1.8-9">It might be asked how it helps to place this loss detection
          requirement only on L4S hosts, because networks will still face
          uncertainty over whether non-L4S flows are detecting loss by
          counting DupACKs. The answer is that those link technologies for
          which it is challenging to keep squeezing the reordering time will
          only need to do so for non-L4S traffic (which they can do because
          the L4S identifier is visible at the IP layer). Therefore, they can
          focus their processing and memory resources into scaling non-L4S
          (Classic) traffic. Then, the higher the proportion of L4S traffic,
          the less of a scaling challenge they will have.<a href="#appendix-A.1.8-9" class="pilcrow">Â¶</a></p>
<p id="appendix-A.1.8-10">To summarize, there is no reason for L4S hosts not to be part of
          the solution instead of part of the problem.<a href="#appendix-A.1.8-10" class="pilcrow">Â¶</a></p>
<p id="appendix-A.1.8-11">Requirement ("MUST") or recommendation ("SHOULD")? As explained
          above, this is a subtle interoperability issue between hosts and
          networks, which seems to need a "MUST". Unless networks can be
          certain that all L4S hosts follow the time-based approach, they
          still have to cater for the worst case - continually squeeze
          reordering into a smaller and smaller duration - just for hosts that
          might be using the counting approach. However, it was decided to
          express this as a recommendation, using "SHOULD". The main
          justification was that networks can still be fairly certain that L4S
          hosts will follow this recommendation, because following it offers
          only gain and no pain.<a href="#appendix-A.1.8-11" class="pilcrow">Â¶</a></p>
<p id="appendix-A.1.8-12">Details:<a href="#appendix-A.1.8-12" class="pilcrow">Â¶</a></p>
<p id="appendix-A.1.8-13">The speed of loss recovery is much more significant for short
          flows than long, therefore a good compromise is to adapt the
          reordering window; from a small fraction of the RTT at the start of
          a flow, to a larger fraction of the RTT for flows that continue for
          many round trips.<a href="#appendix-A.1.8-13" class="pilcrow">Â¶</a></p>
<p id="appendix-A.1.8-14">This is broadly the approach adopted by TCP RACK (Recent
          ACKnowledgements)Â <span>[<a href="#RFC8985" class="xref">RFC8985</a>]</span>. However, RACK
          starts with the 3 DupACK approach, because the RTT estimate is not
          necessarily stable. As long as the initial window is paced, such
          initial use of 3 DupACK counting would amount to time-based loss
          detection and therefore would satisfy the time-based loss detection
          recommendation of <a href="#l4sid_congestion_response" class="xref">Section 4.3</a>. This
          is because pacing of the initial window would ensure that 3 DupACKs
          early in the connection would be spread over a small fraction of the
          round trip.<a href="#appendix-A.1.8-14" class="pilcrow">Â¶</a></p>
<p id="appendix-A.1.8-15">As mentioned above, hardware implementations of loss recovery
          using DupACK counting exist (e.g.Â some implementations of
          RoCEv2 for RDMA). For low latency, these implementations can change
          their congestion control to implement L4S, because the congestion
          control (as distinct from loss recovery) is implemented in software.
          But they cannot easily satisfy this loss recovery requirement.
          However, it is believed they do not need to, because such
          implementations are believed to solely exist in controlled
          environments, where the network technology keeps reordering
          extremely low anyway. This is why controlled environments with
          hardly any reordering are excluded from the scope of the normative
          recommendation in <a href="#l4sid_congestion_response" class="xref">Section 4.3</a>.<a href="#appendix-A.1.8-15" class="pilcrow">Â¶</a></p>
<p id="appendix-A.1.8-16">Detecting loss in time units also prevents the ACK-splitting
          attacks described in <span>[<a href="#Savage-TCP" class="xref">Savage-TCP</a>]</span>.<a href="#appendix-A.1.8-16" class="pilcrow">Â¶</a></p>
</section>
</div>
</section>
<section id="appendix-A.2">
        <h3 id="name-scalable-transport-protocol">
<a href="#appendix-A.2" class="section-number selfRef">A.2. </a><a href="#name-scalable-transport-protocol" class="section-name selfRef">Scalable Transport Protocol Optimizations</a>
        </h3>
<p id="appendix-A.2-1"></p>
<section id="appendix-A.2.1">
          <h4 id="name-setting-ect-in-control-pack">
<a href="#appendix-A.2.1" class="section-number selfRef">A.2.1. </a><a href="#name-setting-ect-in-control-pack" class="section-name selfRef">Setting ECT in Control Packets and Retransmissions</a>
          </h4>
<p id="appendix-A.2.1-1">Description: This item concerns TCP and its derivatives
          (e.g.Â SCTP) as well as RTP/RTCPÂ <span>[<a href="#RFC6679" class="xref">RFC6679</a>]</span>.
          The original specification of ECN for TCP precluded the use of ECN
          on control packets and retransmissions. Similarly RFCÂ 6679
          precludes the use of ECT on RTCP datagrams, in case the path changes
          after it has been checked for ECN traversal. To improve performance,
          scalable transport protocols ought to enable ECN at the IP layer in
          TCP control packets (SYN, SYN-ACK, pure ACKs, etc.) and in
          retransmitted packets. The same is true for other transports,
          e.g.Â SCTP, RTCP.<a href="#appendix-A.2.1-1" class="pilcrow">Â¶</a></p>
<p id="appendix-A.2.1-2">Motivation (TCP): RFCÂ 3168 prohibits the use of ECN on these
          types of TCP packet, based on a number of arguments. This means
          these packets are not protected from congestion loss by ECN, which
          considerably harms performance, particularly for short flows.
          ECN++Â <span>[<a href="#I-D.ietf-tcpm-generalized-ecn" class="xref">I-D.ietf-tcpm-generalized-ecn</a>]</span> proposes
          experimental use of ECN on all types of TCP packet as long as AccECN
          feedbackÂ <span>[<a href="#I-D.ietf-tcpm-accurate-ecn" class="xref">I-D.ietf-tcpm-accurate-ecn</a>]</span> is
          available (which itself satisfies the accurate feedback requirement
          in <a href="#l4sid_feedback" class="xref">Section 4.2</a> for using a scalable congestion
          control).<a href="#appendix-A.2.1-2" class="pilcrow">Â¶</a></p>
<p id="appendix-A.2.1-3">Motivation (RTCP): L4S experiments in general will need to
          observe the rule in the RTP ECN specÂ <span>[<a href="#RFC6679" class="xref">RFC6679</a>]</span>
          that precludes ECT on RTCP datagrams. Nonetheless, as ECN usage
          becomes more widespread, it would be useful to conduct specific
          experiments with ECN-capable RTCP to gather data on whether such
          caution is necessary.<a href="#appendix-A.2.1-3" class="pilcrow">Â¶</a></p>
</section>
<section id="appendix-A.2.2">
          <h4 id="name-faster-than-additive-increa">
<a href="#appendix-A.2.2" class="section-number selfRef">A.2.2. </a><a href="#name-faster-than-additive-increa" class="section-name selfRef">Faster than Additive Increase</a>
          </h4>
<p id="appendix-A.2.2-1">Description: It would improve performance if scalable congestion
          controls did not limit their congestion window increase to the
          standard additive increase of 1Â SMSS per round tripÂ <span>[<a href="#RFC5681" class="xref">RFC5681</a>]</span> during congestion avoidance. The same is true for
          derivatives of TCP congestion control, including similar approaches
          used for real-time media.<a href="#appendix-A.2.2-1" class="pilcrow">Â¶</a></p>
<p id="appendix-A.2.2-2">Motivation: As currently definedÂ <span>[<a href="#RFC8257" class="xref">RFC8257</a>]</span>,
          DCTCP uses the traditional Reno additive increase in congestion
          avoidance phase. When the available capacity suddenly increases
          (e.g.Â when another flow finishes, or if radio capacity
          increases) it can take very many round trips to take advantage of
          the new capacity. TCP CubicÂ <span>[<a href="#RFC8312" class="xref">RFC8312</a>]</span> was
          designed to solve this problem, but as flow rates have continued to
          increase, the delay accelerating into available capacity has become
          prohibitive. See, for instance, the examples in Section 5.1 of the
          L4S architectureÂ <span>[<a href="#I-D.ietf-tsvwg-l4s-arch" class="xref">I-D.ietf-tsvwg-l4s-arch</a>]</span>. Even
          when out of its Reno-compatibility mode, every 8x scaling of Cubic's
          flow rate leads to 2x more acceleration delay.<a href="#appendix-A.2.2-2" class="pilcrow">Â¶</a></p>
<p id="appendix-A.2.2-3">In the steady state, DCTCP induces about 2 ECN marks per round
          trip, so it is possible to quickly detect when these signals have
          disappeared and seek available capacity more rapidly, while
          minimizing the impact on other flows (Classic and
          scalable)Â <span>[<a href="#LinuxPacedChirping" class="xref">LinuxPacedChirping</a>]</span>. Alternatively,
          approaches such as Adaptive Acceleration (A2DTCPÂ <span>[<a href="#A2DTCP" class="xref">A2DTCP</a>]</span>) have been proposed to address this problem in
          data centres, which might be deployable over the public
          Internet.<a href="#appendix-A.2.2-3" class="pilcrow">Â¶</a></p>
</section>
<section id="appendix-A.2.3">
          <h4 id="name-faster-convergence-at-flow-">
<a href="#appendix-A.2.3" class="section-number selfRef">A.2.3. </a><a href="#name-faster-convergence-at-flow-" class="section-name selfRef">Faster Convergence at Flow Start</a>
          </h4>
<p id="appendix-A.2.3-1">Description: It would improve performance if scalable congestion
          controls converged (reached their steady-state share of the
          capacity) faster than Classic congestion controls or at least no
          slower. This affects the flow start behaviour of any L4S congestion
          control derived from a Classic transport that uses TCP slow start,
          including those for real-time media.<a href="#appendix-A.2.3-1" class="pilcrow">Â¶</a></p>
<p id="appendix-A.2.3-2">Motivation: As an example, a new DCTCP flow takes longer than a
          Classic congestion control to obtain its share of the capacity of
          the bottleneck when there are already ongoing flows using the
          bottleneck capacity. In a data centre environment DCTCP takes about
          a factor of 1.5 to 2 longer to converge due to the much higher
          typical level of ECN marking that DCTCP background traffic induces,
          which causes new flows to exit slow start earlyÂ <span>[<a href="#Alizadeh-stability" class="xref">Alizadeh-stability</a>]</span>. In testing for use over the public
          Internet the convergence time of DCTCP relative to a regular
          loss-based TCP slow start is even less favourableÂ <span>[<a href="#Paced-Chirping" class="xref">Paced-Chirping</a>]</span> due to the shallow ECN marking threshold
          needed for L4S. It is exacerbated by the typically greater mismatch
          between the link rate of the sending host and typical Internet
          access bottlenecks. This problem is detrimental in general, but
          would particularly harm the performance of short flows relative to
          Classic congestion controls.<a href="#appendix-A.2.3-2" class="pilcrow">Â¶</a></p>
</section>
</section>
</section>
</div>
<div id="l4sid_ECT1_CE">
<section id="appendix-B">
      <h2 id="name-compromises-in-the-choice-o">
<a href="#appendix-B" class="section-number selfRef">Appendix B. </a><a href="#name-compromises-in-the-choice-o" class="section-name selfRef">Compromises in the Choice of L4S Identifier</a>
      </h2>
<p id="appendix-B-1">This appendix is informative, not normative. As explained in <a href="#l4sid_reqs" class="xref">Section 2</a>, there is insufficient space in the IP header (v4
      or v6) to fully accommodate every requirement. So the choice of L4S
      identifier involves tradeoffs. This appendix records the pros and cons
      of the choice that was made.<a href="#appendix-B-1" class="pilcrow">Â¶</a></p>
<p id="appendix-B-2">Non-normative recap of the chosen codepoint scheme:<a href="#appendix-B-2" class="pilcrow">Â¶</a></p>
<ul class="normal ulEmpty">
<li class="normal ulEmpty" id="appendix-B-3.1">
          <p id="appendix-B-3.1.1">Packets with ECT(1) and conditionally packets with CE signify L4S
          semantics as an alternative to the semantics of Classic
          ECNÂ <span>[<a href="#RFC3168" class="xref">RFC3168</a>]</span>, specifically:<a href="#appendix-B-3.1.1" class="pilcrow">Â¶</a></p>
<ul class="normal">
<li class="normal" id="appendix-B-3.1.2.1">The ECT(1) codepoint signifies that the packet was sent by an
              L4S-capable sender.<a href="#appendix-B-3.1.2.1" class="pilcrow">Â¶</a>
</li>
            <li class="normal" id="appendix-B-3.1.2.2">Given shortage of codepoints, both L4S and Classic ECN sides
              of an AQM have to use the same CE codepoint to indicate that a
              packet has experienced congestion. If a packet that had already
              been marked CE in an upstream buffer arrived at a subsequent
              AQM, this AQM would then have to guess whether to classify CE
              packets as L4S or Classic ECN. Choosing the L4S treatment is a
              safer choice, because then a few Classic packets might arrive
              early, rather than a few L4S packets arriving late.<a href="#appendix-B-3.1.2.2" class="pilcrow">Â¶</a>
</li>
            <li class="normal" id="appendix-B-3.1.2.3">Additional information might be available if the classifier
              were transport-aware. Then it could classify a CE packet for
              Classic ECN treatment if the most recent ECT packet in the same
              flow had been marked ECT(0). However, the L4S service ought not
              to need transport-layer awareness.<a href="#appendix-B-3.1.2.3" class="pilcrow">Â¶</a>
</li>
          </ul>
</li>
      </ul>
<p id="appendix-B-4">Cons:<a href="#appendix-B-4" class="pilcrow">Â¶</a></p>
<span class="break"></span><dl class="dlParallel" id="appendix-B-5">
        <dt id="appendix-B-5.1">Consumes the last ECN codepoint:</dt>
        <dd style="margin-left: 1.5em" id="appendix-B-5.2">The L4S service could
          potentially supersede the service provided by Classic ECN, therefore
          using ECT(1) to identify L4S packets could ultimately mean that the
          ECT(0) codepoint was 'wasted' purely to distinguish one form of ECN
          from its successor.<a href="#appendix-B-5.2" class="pilcrow">Â¶</a>
</dd>
        <dd class="break"></dd>
<dt id="appendix-B-5.3">ECN hard in some lower layers:</dt>
        <dd style="margin-left: 1.5em" id="appendix-B-5.4">It is not always
          possible to support the equivalent of an IP-ECN field in an AQM
          acting in a buffer below the IP layerÂ <span>[<a href="#I-D.ietf-tsvwg-ecn-encap-guidelines" class="xref">I-D.ietf-tsvwg-ecn-encap-guidelines</a>]</span>. Then, depending on
          the lower layer scheme, the L4S service might have to drop rather
          than mark frames even though they might encapsulate an ECN-capable
          packet.<a href="#appendix-B-5.4" class="pilcrow">Â¶</a>
</dd>
        <dd class="break"></dd>
<dt id="appendix-B-5.5">Risk of reordering Classic CE packets within a flow:</dt>
        <dd id="appendix-B-5.6" style="margin-left: 1.5em">
<div id="l4sid_CE_reordering">
          <p id="appendix-B-5.6.1">Classifying
          all CE packets into the L4S queue risks any CE packets that were
          originally ECT(0) being incorrectly classified as L4S. If there were
          delay in the Classic queue, these incorrectly classified CE packets
          would arrive early, which is a form of reordering. Reordering within
          a microflow can cause TCP senders (and senders of similar
          transports) to retransmit spuriously. However, the risk of spurious
          retransmissions would be extremely low for the following
          reasons:<a href="#appendix-B-5.6.1" class="pilcrow">Â¶</a></p>
<ol start="1" type="1" class="normal type-1" id="appendix-B-5.6.2">
<li id="appendix-B-5.6.2.1">It is quite unusual to experience queuing at more than one
              bottleneck on the same path (the available capacities have to be
              identical).<a href="#appendix-B-5.6.2.1" class="pilcrow">Â¶</a>
</li>
            <li id="appendix-B-5.6.2.2">In only a subset of these unusual cases would the first
              bottleneck support Classic ECN marking while the second
              supported L4S ECN marking, which would be the only scenario
              where some ECT(0) packets could be CE marked by an AQM
              supporting Classic ECN then the remainder experienced further
              delay through the Classic side of a subsequent L4S DualQ
              AQM.<a href="#appendix-B-5.6.2.2" class="pilcrow">Â¶</a>
</li>
            <li id="appendix-B-5.6.2.3">
              <p id="appendix-B-5.6.2.3.1">Even then, when a few packets are delivered early, it takes
              very unusual conditions to cause a spurious retransmission, in
              contrast to when some packets are delivered late. The first
              bottleneck has to apply CE-marks to at least N contiguous
              packets and the second bottleneck has to inject an uninterrupted
              sequence of at least N of these packets between two packets
              earlier in the stream (where N is the reordering window that the
              transport protocol allows before it considers a packet is
              lost).<a href="#appendix-B-5.6.2.3.1" class="pilcrow">Â¶</a></p>
<ul class="normal ulEmpty">
<li class="normal ulEmpty" id="appendix-B-5.6.2.3.2.1">For example consider N=3, and consider the sequence of
                  packets 100, 101, 102, 103,... and imagine that packets
                  150,151,152 from later in the flow are injected as follows:
                  100, 150, 151, 101, 152, 102, 103... If this were late
                  reordering, even one packet arriving out of sequence would
                  trigger a spurious retransmission, but there is no spurious
                  retransmission here with early reordering, because packet
                  101 moves the cumulative ACK counter forward before 3
                  packets have arrived out of order. Later, when packets 148,
                  149, 153... arrive, even though there is a 3-packet hole,
                  there will be no problem, because the packets to fill the
                  hole are already in the receive buffer.<a href="#appendix-B-5.6.2.3.2.1" class="pilcrow">Â¶</a>
</li>
              </ul>
</li>
            <li id="appendix-B-5.6.2.4">Even with the current TCP recommendation of N=3Â <span>[<a href="#RFC5681" class="xref">RFC5681</a>]</span> spurious retransmissions will be unlikely for
              all the above reasons. As RACKÂ <span>[<a href="#RFC8985" class="xref">RFC8985</a>]</span> is
              becoming widely deployed, it tends to adapt its reordering
              window to a larger value of N, which will make the chance of a
              contiguous sequence of N early arrivals vanishingly small.<a href="#appendix-B-5.6.2.4" class="pilcrow">Â¶</a>
</li>
            <li id="appendix-B-5.6.2.5">Even a run of 2 CE marks within a Classic ECN flow is
              unlikely, given FQ-CoDel is the only known widely deployed AQM
              that supports Classic ECN marking and it takes great care to
              separate out flows and to space any markings evenly along each
              flow.<a href="#appendix-B-5.6.2.5" class="pilcrow">Â¶</a>
</li>
          </ol>
<p id="appendix-B-5.6.3">It is extremely unlikely that the above set of 5
          eventualities that are each unusual in themselves would all happen
          simultaneously. But, even if they did, the consequences would hardly
          be dire: the odd spurious fast retransmission. Whenever the traffic
          source (a Classic congestion control) mistakes the reordering of a
          string of CE marks for a loss, one might think that it will reduce
          its congestion window as well as emitting a spurious retransmission.
          However, it would have already reduced its congestion window when
          the CE markings arrived early. If it is using ABEÂ <span>[<a href="#RFC8511" class="xref">RFC8511</a>]</span>, it might reduce cwnd a little more for a loss
          than for a CE mark. But it will revert that reduction once it
          detects that the retransmission was spurious.<a href="#appendix-B-5.6.3" class="pilcrow">Â¶</a></p>
<p id="appendix-B-5.6.4">In conclusion, the impact of early reordering on
          spurious retransmissions due to CE being ambiguous will generally be
          vanishingly small.<a href="#appendix-B-5.6.4" class="pilcrow">Â¶</a></p>
</div>
        </dd>
<dd class="break"></dd>
<dt id="appendix-B-5.7">Insufficient anti-replay window in some pre-existing VPNs:</dt>
        <dd style="margin-left: 1.5em" id="appendix-B-5.8">If
          delay is reduced for a subset of the flows within a VPN, the
          anti-replay feature of some VPNs is known to potentially mistake the
          difference in delay for a replay attack. <a href="#l4sid_VPN_anti-replay" class="xref">Section 6.2</a> recommends that the anti-replay
          window at the VPN egress is sufficiently sized, as required by the
          relevant specifications. However, in some VPN implementations the
          maximum anti-replay window is insufficient to cater for a large
          delay difference at prevailing packet rates. <a href="#l4sid_VPN_anti-replay" class="xref">Section 6.2</a> suggests alternative work-rounds
          for such cases, but end-users using L4S over a VPN will need to be
          able to recognize the symptoms of this problem, in order to seek out
          these work-rounds.<a href="#appendix-B-5.8" class="pilcrow">Â¶</a>
</dd>
        <dd class="break"></dd>
<dt id="appendix-B-5.9">Hard to distinguish Classic ECN AQM:</dt>
        <dd style="margin-left: 1.5em" id="appendix-B-5.10">
          <p id="appendix-B-5.10.1">With this scheme,
          when a source receives ECN feedback, it is not explicitly clear
          which type of AQM generated the CE markings. This is not a problem
          for Classic ECN sources that send ECT(0) packets, because an L4S AQM
          will recognize the ECT(0) packets as Classic and apply the
          appropriate Classic ECN marking behaviour.<a href="#appendix-B-5.10.1" class="pilcrow">Â¶</a></p>
<p id="appendix-B-5.10.2">However, in the absence of explicit disambiguation
          of the CE markings, an L4S source needs to use heuristic techniques
          to work out which type of congestion response to apply (see <a href="#l4sid_sec_fallback_on_classic_CE" class="xref">Appendix A.1.5</a>). Otherwise, if
          long-running Classic flow(s) are sharing a Classic ECN AQM
          bottleneck with long-running L4S flow(s), which then apply an L4S
          response to Classic CE signals, the L4S flows would outcompete the
          Classic flow(s). Experiments have shown that L4S flows can take
          about 20 times more capacity share than equivalent Classic flows.
          Nonetheless, as link capacity reduces (e.g.Â to 4 Mb/s), the
          inequality reduces. So Classic flows always make progress and are
          not starved.<a href="#appendix-B-5.10.2" class="pilcrow">Â¶</a></p>
<p id="appendix-B-5.10.3">When L4S was first proposed (in
          2015, 14 years after the Classic ECN specÂ <span>[<a href="#RFC3168" class="xref">RFC3168</a>]</span> was published), it was believed that Classic ECN
          AQMs had failed to be deployed, because research measurements had
          found little or no evidence of CE marking. In subsequent years
          Classic ECN was included in per-flow-queuing (FQ) deployments,
          however an FQ scheduler stops an L4S flow outcompeting Classic,
          because it enforces equality between flow rates. It is not known
          whether there have been any non-FQ deployments of Classic ECN AQMs
          in the subsequent years, or whether there will be in future.<a href="#appendix-B-5.10.3" class="pilcrow">Â¶</a></p>
<p id="appendix-B-5.10.4">An algorithm for detecting a Classic ECN AQM as soon
          as a flow stabilizes after start-up has been proposedÂ <span>[<a href="#ecn-fallback" class="xref">ecn-fallback</a>]</span> (see <a href="#l4sid_sec_fallback_on_classic_CE" class="xref">Appendix A.1.5</a> for a brief summary).
          Testbed evaluations of v2 of the algorithm have shown detection is
          reasonably good for Classic ECN AQMs, in a wide range of
          circumstances. However, although it can correctly detect an L4S ECN
          AQM in many circumstances, its is often incorrect at low link
          capacities and/or high RTTs. Although this is the safe way round,
          there is a danger that it will discourage use of the algorithm.<a href="#appendix-B-5.10.4" class="pilcrow">Â¶</a></p>
</dd>
        <dd class="break"></dd>
<dt id="appendix-B-5.11">Non-L4S service for control packets:</dt>
        <dd style="margin-left: 1.5em" id="appendix-B-5.12">Solely for the
          case of TCP, the Classic ECN RFCsÂ <span>[<a href="#RFC3168" class="xref">RFC3168</a>]</span> and
          <span>[<a href="#RFC5562" class="xref">RFC5562</a>]</span> require a sender to clear the ECN field to
          Not-ECT on retransmissions and on certain control packets
          specifically pure ACKs, window probes and SYNs. When L4S packets are
          classified by the ECN field, these TCP control packets would not be
          classified into an L4S queue, and could therefore be delayed
          relative to the other packets in the flow. This would not cause
          reordering (because retransmissions are already out of order, and
          these control packets typically carry no data). However, it would
          make critical TCP control packets more vulnerable to loss and delay.
          To address this problem, ECN++Â <span>[<a href="#I-D.ietf-tcpm-generalized-ecn" class="xref">I-D.ietf-tcpm-generalized-ecn</a>]</span> proposes an experiment in
          which all TCP control packets and retransmissions are ECN-capable as
          long as appropriate ECN feedback is available in each case.<a href="#appendix-B-5.12" class="pilcrow">Â¶</a>
</dd>
      <dd class="break"></dd>
</dl>
<p id="appendix-B-6">Pros:<a href="#appendix-B-6" class="pilcrow">Â¶</a></p>
<span class="break"></span><dl class="dlParallel" id="appendix-B-7">
        <dt id="appendix-B-7.1">Should work e2e:</dt>
        <dd style="margin-left: 1.5em" id="appendix-B-7.2">The ECN field generally propagates
          end-to-end across the Internet without being wiped or mangled, at
          least over fixed networks. Unlike the DSCP, the setting of the ECN
          field is at least meant to be forwarded unchanged by networks that
          do not support ECN.<a href="#appendix-B-7.2" class="pilcrow">Â¶</a>
</dd>
        <dd class="break"></dd>
<dt id="appendix-B-7.3">Should work in tunnels:</dt>
        <dd style="margin-left: 1.5em" id="appendix-B-7.4">The L4S identifiers work
          across and within any tunnel that propagates the ECN field in any of
          the variant ways it has been defined since ECN-tunneling was first
          specified in the year 2001Â <span>[<a href="#RFC3168" class="xref">RFC3168</a>]</span>. However,
          it is likely that some tunnels still do not implement ECN
          propagation at all.<a href="#appendix-B-7.4" class="pilcrow">Â¶</a>
</dd>
        <dd class="break"></dd>
<dt id="appendix-B-7.5">Should work for many link technologies:</dt>
        <dd style="margin-left: 1.5em" id="appendix-B-7.6">At most, but
          not all, path bottlenecks there is IP-awareness, so that L4S AQMs
          can be located where the IP-ECN field can be manipulated.
          Bottlenecks at lower layer nodes without IP-awareness either have to
          use drop to signal congestion or a specific congestion notification
          facility has to be defined for that link technology, including
          propagation to and from IP-ECN. The programme to define these is
          progressing and in each case so far the scheme already defined for
          ECN inherently supports L4S as well (see <a href="#l4sid_encaps_no_change" class="xref">Section 6.1</a>).<a href="#appendix-B-7.6" class="pilcrow">Â¶</a>
</dd>
        <dd class="break"></dd>
<dt id="appendix-B-7.7">Could migrate to one codepoint:</dt>
        <dd style="margin-left: 1.5em" id="appendix-B-7.8">If all Classic ECN
          senders eventually evolve to use the L4S service, the ECT(0)
          codepoint could be reused for some future purpose, but only once use
          of ECT(0) packets had reduced to zero, or near-zero, which might
          never happen.<a href="#appendix-B-7.8" class="pilcrow">Â¶</a>
</dd>
        <dd class="break"></dd>
<dt id="appendix-B-7.9">L4 not required:</dt>
        <dd style="margin-left: 1.5em" id="appendix-B-7.10">Being based on the ECN field, this
          scheme does not need the network to access transport layer flow
          identifiers. Nonetheless, it does not preclude solutions that
          do.<a href="#appendix-B-7.10" class="pilcrow">Â¶</a>
</dd>
      <dd class="break"></dd>
</dl>
</section>
</div>
<section id="appendix-C">
      <h2 id="name-potential-competing-uses-fo">
<a href="#appendix-C" class="section-number selfRef">Appendix C. </a><a href="#name-potential-competing-uses-fo" class="section-name selfRef">Potential Competing Uses for the ECT(1) Codepoint</a>
      </h2>
<p id="appendix-C-1">The ECT(1) codepoint of the ECN field has already been assigned once
      for the ECN nonceÂ <span>[<a href="#RFC3540" class="xref">RFC3540</a>]</span>, which has now been
      categorized as historicÂ <span>[<a href="#RFC8311" class="xref">RFC8311</a>]</span>. ECN is probably
      the only remaining field in the Internet Protocol that is common to IPv4
      and IPv6 and still has potential to work end-to-end, with tunnels and
      with lower layers. Therefore, ECT(1) should not be reassigned to a
      different experimental use (L4S) without carefully assessing competing
      potential uses. These fall into the following categories:<a href="#appendix-C-1" class="pilcrow">Â¶</a></p>
<div id="l4sid_competing_integrity">
<section id="appendix-C.1">
        <h3 id="name-integrity-of-congestion-fee">
<a href="#appendix-C.1" class="section-number selfRef">C.1. </a><a href="#name-integrity-of-congestion-fee" class="section-name selfRef">Integrity of Congestion Feedback</a>
        </h3>
<p id="appendix-C.1-1">Receiving hosts can fool a sender into downloading faster by
        suppressing feedback of ECN marks (or of losses if retransmissions are
        not necessary or available otherwise).<a href="#appendix-C.1-1" class="pilcrow">Â¶</a></p>
<p id="appendix-C.1-2">The historic ECN nonce protocolÂ <span>[<a href="#RFC3540" class="xref">RFC3540</a>]</span>
        proposed that a TCP sender could set either of ECT(0) or ECT(1) in
        each packet of a flow and remember the sequence it had set. If any
        packet was lost or congestion marked, the receiver would miss that bit
        of the sequence. An ECN Nonce receiver had to feed back the least
        significant bit of the sum, so it could not suppress feedback of a
        loss or mark without a 50-50 chance of guessing the sum
        incorrectly.<a href="#appendix-C.1-2" class="pilcrow">Â¶</a></p>
<p id="appendix-C.1-3">It is highly unlikely that ECT(1) will be needed for integrity
        protection in future. The ECN Nonce RFCÂ <span>[<a href="#RFC3540" class="xref">RFC3540</a>]</span>
        as been reclassified as historic, partly because other ways have been
        developed to protect feedback integrity of TCP and other
        transportsÂ <span>[<a href="#RFC8311" class="xref">RFC8311</a>]</span> that do not consume a
        codepoint in the IP header. For instance:<a href="#appendix-C.1-3" class="pilcrow">Â¶</a></p>
<ul class="normal">
<li class="normal" id="appendix-C.1-4.1">the sender can test the integrity of the receiver's feedback by
            occasionally setting the IP-ECN field to a value normally only set
            by the network. Then it can test whether the receiver's feedback
            faithfully reports what it expects (see para 2 of Section 20.2 of
            the ECN specÂ <span>[<a href="#RFC3168" class="xref">RFC3168</a>]</span>. This works for loss
            and it will work for the accurate ECN feedbackÂ <span>[<a href="#RFC7560" class="xref">RFC7560</a>]</span> intended for L4S.<a href="#appendix-C.1-4.1" class="pilcrow">Â¶</a>
</li>
          <li class="normal" id="appendix-C.1-4.2">A network can enforce a congestion response to its ECN markings
            (or packet losses) by auditing congestion exposure
            (ConEx)Â <span>[<a href="#RFC7713" class="xref">RFC7713</a>]</span>. Whether the receiver or a
            downstream network is suppressing congestion feedback or the
            sender is unresponsive to the feedback, or both, ConEx audit can
            neutralise any advantage that any of these three parties would
            otherwise gain.<a href="#appendix-C.1-4.2" class="pilcrow">Â¶</a>
</li>
          <li class="normal" id="appendix-C.1-4.3">The TCP authentication option (TCP-AOÂ <span>[<a href="#RFC5925" class="xref">RFC5925</a>]</span>) can be used to detect any tampering with TCP
            congestion feedback (whether malicious or accidental). TCP's
            congestion feedback fields are immutable end-to-end, so they are
            amenable to TCP-AO protection, which covers the main TCP header
            and TCP options by default. However, TCP-AO is often too brittle
            to use on many end-to-end paths, where middleboxes can make
            verification fail in their attempts to improve performance or
            security, e.g.Â by resegmentation or shifting the sequence
            space.<a href="#appendix-C.1-4.3" class="pilcrow">Â¶</a>
</li>
        </ul>
</section>
</div>
<section id="appendix-C.2">
        <h3 id="name-notification-of-less-severe">
<a href="#appendix-C.2" class="section-number selfRef">C.2. </a><a href="#name-notification-of-less-severe" class="section-name selfRef">Notification of Less Severe Congestion than CE</a>
        </h3>
<p id="appendix-C.2-1">Various researchers have proposed to use ECT(1) as a less severe
        congestion notification than CE, particularly to enable flows to fill
        available capacity more quickly after an idle period, when another
        flow departs or when a flow starts, e.g.Â VCPÂ <span>[<a href="#VCP" class="xref">VCP</a>]</span>, Queue View (QV)Â <span>[<a href="#QV" class="xref">QV</a>]</span>.<a href="#appendix-C.2-1" class="pilcrow">Â¶</a></p>
<p id="appendix-C.2-2">Before assigning ECT(1) as an identifier for L4S, we must carefully
        consider whether it might be better to hold ECT(1) in reserve for
        future standardisation of rapid flow acceleration, which is an
        important and enduring problemÂ <span>[<a href="#RFC6077" class="xref">RFC6077</a>]</span>.<a href="#appendix-C.2-2" class="pilcrow">Â¶</a></p>
<p id="appendix-C.2-3">Pre-Congestion Notification (PCN) is another scheme that assigns
        alternative semantics to the ECN field. It uses ECT(1) to signify a
        less severe level of pre-congestion notification than CEÂ <span>[<a href="#RFC6660" class="xref">RFC6660</a>]</span>. However, the ECN field only takes on the PCN
        semantics if packets carry a Diffserv codepoint defined to indicate
        PCN marking within a controlled environment. PCN is required to be
        applied solely to the outer header of a tunnel across the controlled
        region in order not to interfere with any end-to-end use of the ECN
        field. Therefore a PCN region on the path would not interfere with the
        L4S service identifier defined in <a href="#l4sid_identification" class="xref">Section 3</a>.<a href="#appendix-C.2-3" class="pilcrow">Â¶</a></p>
</section>
</section>
<div id="authors-addresses">
<section id="appendix-D">
      <h2 id="name-authors-addresses-4">
<a href="#name-authors-addresses-4" class="section-name selfRef">Authors' Addresses</a>
      </h2>
<address class="vcard">
        <div dir="auto" class="left"><span class="fn nameRole">Koen De Schepper</span></div>
<div dir="auto" class="left"><span class="org">Nokia Bell Labs</span></div>
<div dir="auto" class="left"><span class="locality">Antwerp</span></div>
<div dir="auto" class="left"><span class="country-name">Belgium</span></div>
<div class="email">
<span>Email:</span>
<a href="mailto:koen.de_schepper@nokia.com" class="email">koen.de_schepper@nokia.com</a>
</div>
<div class="url">
<span>URI:</span>
<a href="https://www.bell-labs.com/usr/koen.de_schepper" class="url">https://www.bell-labs.com/usr/koen.de_schepper</a>
</div>
</address>
<address class="vcard">
        <div dir="auto" class="left"><span class="fn nameRole">Bob Briscoe (<span class="role">editor</span>)</span></div>
<div dir="auto" class="left"><span class="org">Independent</span></div>
<div dir="auto" class="left"><span class="country-name">United Kingdom</span></div>
<div class="email">
<span>Email:</span>
<a href="mailto:ietf@bobbriscoe.net" class="email">ietf@bobbriscoe.net</a>
</div>
<div class="url">
<span>URI:</span>
<a href="http://bobbriscoe.net/" class="url">http://bobbriscoe.net/</a>
</div>
</address>
</section>
</div>
<script>const toc = document.getElementById("toc");
toc.querySelector("h2").addEventListener("click", e => {
  toc.classList.toggle("active");
});
toc.querySelector("nav").addEventListener("click", e => {
  toc.classList.remove("active");
});
</script>
</body>
</html>
