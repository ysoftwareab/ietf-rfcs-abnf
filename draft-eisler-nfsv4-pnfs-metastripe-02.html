<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="en"><head><title>Metadata Striping for pNFS</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="description" content="Metadata Striping for pNFS">
<meta name="generator" content="xml2rfc v1.35 (http://xml.resource.org/)">
<meta name="viewport" content="width=600;" />
<style type='text/css'><!--
        body {
                font-family: verdana, charcoal, helvetica, arial, sans-serif;
                font-size: 85%;
		max-width: 60em; 
		color: #000; background-color: #FFF;
                margin: 2em;
        }
        h1, h2, h3, h4, h5, h6 {
                font-family: helvetica, monaco, "MS Sans Serif", arial, sans-serif;
                font-weight: bold; font-style: normal;
        }
        h1 { color: #900; background-color: transparent; text-align: right; }
        h3 { color: #333; background-color: transparent; }

        td.RFCbug {
                font-size: x-small; text-decoration: none;
                width: 30px; height: 30px; padding-top: 2px;
                text-align: justify; vertical-align: middle;
                background-color: #000;
        }
        td.RFCbug span.RFC {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: bold; color: #666;
        }
        td.RFCbug span.hotText {
                font-family: charcoal, monaco, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: normal; text-align: center; color: #FFF;
        }

        table.TOCbug { width: 30px; height: 15px; }
        td.TOCbug {
                text-align: center; width: 30px; height: 15px;
                color: #FFF; background-color: #900;
        }
        td.TOCbug a {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, sans-serif;
                font-weight: bold; font-size: x-small; text-decoration: none;
                color: #FFF; background-color: transparent;
        }

        td.header {
                font-family: arial, helvetica, sans-serif; font-size: x-small;
                vertical-align: top; width: 33%;
                color: #FFF; background-color: #666;
        }
        td.author { font-weight: bold; font-size: x-small; margin-left: 4em; }
        td.author-text { font-size: x-small; }

        /* info code from SantaKlauss at http://www.madaboutstyle.com/tooltip2.html */
        a.info {
                /* This is the key. */
                position: relative;
                z-index: 24;
                text-decoration: none;
        }
        a.info:hover {
                z-index: 25;
                color: #FFF; background-color: #900;
        }
        a.info span { display: none; }
        a.info:hover span.info {
                /* The span will display just on :hover state. */
                display: block;
                position: absolute;
                font-size: smaller;
                top: 2em; left: -5em; width: 15em;
                padding: 2px; border: 1px solid #333;
                color: #900; background-color: #EEE;
                text-align: left;
        }

        a { font-weight: bold; }
        a:link    { color: #900; background-color: transparent; }
        a:visited { color: #633; background-color: transparent; }
        a:active  { color: #633; background-color: transparent; }

        p { margin-left: 2em; margin-right: 2em; }
        p.copyright { font-size: x-small; }
        p.toc { font-size: 85%;
		max-width: 60em; 
		font-weight: bold; margin-left: 3em; }
        table.toc { margin: 0 0 0 3em; padding: 0; border: 0; vertical-align: text-top; }
        td.toc { font-size: 85%;
		max-width: 60em; 
		font-weight: bold; vertical-align: text-top; }

        ol.text { margin-left: 2em; margin-right: 2em; }
        ul.text { margin-left: 2em; margin-right: 2em; }
        li      { margin-left: 3em; }

        /* RFC-2629 <spanx>s and <artwork>s. */
        em     { font-style: italic; }
        strong { font-weight: bold; }
        dfn    { font-weight: bold; font-style: normal; }
        cite   { font-weight: normal; font-style: normal; }
        tt     { color: #036; }
        tt, pre, pre dfn, pre em, pre cite, pre span {
                font-family: "Courier New", Courier, monospace; font-size: small;
        }
        pre {
                text-align: left; padding: 4px;
                color: #000; background-color: #CCC;
        }
        pre dfn  { color: #900; }
        pre em   { color: #66F; background-color: #FFC; font-weight: normal; }
        pre .key { color: #33C; font-weight: bold; }
        pre .id  { color: #900; }
        pre .str { color: #000; background-color: #CFF; }
        pre .val { color: #066; }
        pre .rep { color: #909; }
        pre .oth { color: #000; background-color: #FCF; }
        pre .err { background-color: #FCC; }

        /* RFC-2629 <texttable>s. */
        table.all, table.full, table.headers, table.none {
                font-size: 85%;
		max-width: 60em; 
		text-align: center; border-width: 2px;
                vertical-align: top; border-collapse: collapse;
        }
        table.all, table.full { border-style: solid; border-color: black; }
        table.headers, table.none { border-style: none; }
        th {
                font-weight: bold; border-color: black;
                border-width: 2px 2px 3px 2px;
        }
        table.all th, table.full th { border-style: solid; }
        table.headers th { border-style: none none solid none; }
        table.none th { border-style: none; }
        table.all td {
                border-style: solid; border-color: #333;
                border-width: 1px 2px;
        }
        table.full td, table.headers td, table.none td { border-style: none; }

        hr { height: 1px; }
        hr.insert {
                width: 80%; border-style: none; border-width: 0;
                color: #CCC; background-color: #CCC;
        }
--></style>
</head>
<body>
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<table summary="layout" width="66%" border="0" cellpadding="0" cellspacing="0"><tr><td><table summary="layout" width="100%" border="0" cellpadding="2" cellspacing="1">
<tr><td class="header">NFSv4</td><td class="header">M. Eisler</td></tr>
<tr><td class="header">Internet-Draft</td><td class="header">NetApp</td></tr>
<tr><td class="header">Intended status: Standards Track</td><td class="header">October 18, 2010</td></tr>
<tr><td class="header">Expires: April 21, 2011</td><td class="header">&nbsp;</td></tr>
</table></td></tr></table>
<h1><br />Metadata Striping for pNFS<br />draft-eisler-nfsv4-pnfs-metastripe-02.txt</h1>

<h3>Abstract</h3>

<p>
      This Internet-Draft describes a means to add metadata striping to
      pNFS.
      
</p>
<h3>Requirements Language</h3>

<p>The key words &quot;MUST&quot;, &quot;MUST NOT&quot;,
&quot;REQUIRED&quot;, &quot;SHALL&quot;, &quot;SHALL NOT&quot;,
&quot;SHOULD&quot;, &quot;SHOULD NOT&quot;, &quot;RECOMMENDED&quot;,
&quot;MAY&quot;, and &quot;OPTIONAL&quot; in this document are to be
interpreted as described in <a class='info' href='#RFC2119'>RFC 2119<span> (</span><span class='info'>Bradner, S., &ldquo;Key words for use in RFCs to Indicate Requirement Levels,&rdquo; March&nbsp;1997.</span><span>)</span></a> [1].

</p>
<h3>Status of this Memo</h3>
<p>
This Internet-Draft is submitted  in full
conformance with the provisions of BCP&nbsp;78 and BCP&nbsp;79.</p>
<p>
Internet-Drafts are working documents of the Internet Engineering
Task Force (IETF).  Note that other groups may also distribute
working documents as Internet-Drafts.  The list of current
Internet-Drafts is at http://datatracker.ietf.org/drafts/current/.</p>
<p>
Internet-Drafts are draft documents valid for a maximum of six months
and may be updated, replaced, or obsoleted by other documents at any time.
It is inappropriate to use Internet-Drafts as reference material or to cite
them other than as &ldquo;work in progress.&rdquo;</p>
<p>
This Internet-Draft will expire on April 21, 2011.</p>

<h3>Copyright Notice</h3>
<p>
Copyright (c) 2010 IETF Trust and the persons identified as the
document authors.  All rights reserved.</p>
<p>
This document is subject to BCP 78 and the IETF Trust's Legal
Provisions Relating to IETF Documents
(http://trustee.ietf.org/license-info) in effect on the date of
publication of this document.  Please review these documents
carefully, as they describe your rights and restrictions with respect
to this document. Code Components extracted from this document must
include Simplified BSD License text as described in Section 4.e of
the Trust Legal Provisions and are provided without warranty as
described in the Simplified BSD License.</p>
<a name="toc"></a><br /><hr />
<h3>Table of Contents</h3>
<p class="toc">
<a href="#intro">1.</a>&nbsp;
Introduction and Motivation<br />
<a href="#anchor1">2.</a>&nbsp;
Terminology<br />
<a href="#anchor2">3.</a>&nbsp;
Scope of Metadata Striping<br />
<a href="#anchor3">4.</a>&nbsp;
The Definition of Metadata Striping Layout<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor4">4.1.</a>&nbsp;
Name of Metadata Striping Layout Type<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor5">4.2.</a>&nbsp;
Value of Metadata Striping Layout Type<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor6">4.3.</a>&nbsp;
Definition of the da_addr_body Field of the device_addr4 Data Type<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor7">4.4.</a>&nbsp;
Definition of the loh_body Field of the layouthint4 Data Type<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#layout">4.5.</a>&nbsp;
Definition of the loc_body Field of the layout_content4 Data Type<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor8">4.6.</a>&nbsp;
Definition of the lou_body Field of the layoutupdate4 Data Type<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor9">4.7.</a>&nbsp;
Storage Access Protocols<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor10">4.8.</a>&nbsp;
Revocation of Layouts<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor11">4.9.</a>&nbsp;
Stateids<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor12">4.10.</a>&nbsp;
Lease Terms<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor13">4.11.</a>&nbsp;
Layout Operations Sent to an L-MDS<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor14">4.12.</a>&nbsp;
Filehandles in Metadata Layouts<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor15">4.13.</a>&nbsp;
READ and WRITE Operations<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor16">4.14.</a>&nbsp;
Recovery<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor18">4.14.1.</a>&nbsp;
Failure and Restart of Client<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor19">4.14.2.</a>&nbsp;
Failure and Restart of Server<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor20">4.14.3.</a>&nbsp;
Failure and Restart of Storage Device<br />
<a href="#anchor21">5.</a>&nbsp;
Negotiation<br />
<a href="#anchor22">6.</a>&nbsp;
Operational Recommendation for Deployment<br />
<a href="#acks">7.</a>&nbsp;
Acknowledgements<br />
<a href="#securityconsider">8.</a>&nbsp;
Security Considerations<br />
<a href="#ianaconsider">9.</a>&nbsp;
IANA Considerations<br />
<a href="#rfc.references1">10.</a>&nbsp;
Normative References<br />
<a href="#rfc.authors">&#167;</a>&nbsp;
Author's Address<br />
</p>
<br clear="all" />

<a name="intro"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1"></a><h3>1.&nbsp;
Introduction and Motivation</h3>

<p>


The NFSv4.1 specification describes pNFS <a class='info' href='#I-D.ietf-nfsv4-minorversion1'>[2]<span> (</span><span class='info'>Shepler, S., Eisler, M., and D. Noveck, &ldquo;NFS Version 4 Minor Version 1,&rdquo; Sep&nbsp;2008.</span><span>)</span></a>. In NFSv4.1, pNFS
is limited to the data contents of regular files. The
content of regular files is distributed (striped) across
multiple storage devices. Metadata is not distributed or
striped, and indeed, the model presented in the NFSv4.1
specification is that of a single metadata server.

This document describes a means to add metadata striping to pNFS,
which includes the notion of multiple metadata servers. With metadata
striping, multiple metadata servers may work together to provide
a higher parallel performance.


</p>
<p>
This document does not require a new minor version of NFSv4. Instead, it
requires a new layout type.


</p>
<p>
 The XDR description is provided in this document in a way
 that makes it simple for the reader to extract into a ready
 to compile form. The reader can feed this document into the
 following shell script to produce the machine readable XDR
 description of the metadata layout:

</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
#!/bin/sh
grep "^  *///" | sed 's?^  *///  ??' | sed 's?^.*///??'

</pre></div>
<p>
I.e. if the above script is stored in a file called
"extract.sh", and this document is in a file called
"spec.txt", then the reader can do:


</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
 sh extract.sh &lt; spec.txt &gt; md.x
</pre></div>
<p>
 The effect of the script is to remove leading white space
 from each line of the specification, plus a sentinel sequence of "///".

</p>
<a name="anchor1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2"></a><h3>2.&nbsp;
Terminology</h3>

<p>
</p>
<ul class="text">
<li>
  Initial Metadata Server (I-MDS).
  The I-MDS is the metadata server the client
  obtains a filehandle from prior to acquiring
  any layout on the file.

 
</li>
<li>
  Layout Metadata Server (L-MDS). The L-MDS
  is the metadata server the client obtains a filehandle from after
  direction from a layout.
 
</li>
<li>
  Regular file: An object of file type NF4REG or NF4NAMEDATTR.
 
</li>
</ul><p>

</p>
<a name="anchor2"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3"></a><h3>3.&nbsp;
Scope of Metadata Striping</h3>

<p>
 This proposal assumes a model where there are two or more
 servers capable of supporting NFSv4.1 operations. At least
 one server is an I-MDS, and the I-MDS should be thought of
 as a normal NFSv4.1 server, with the additional capability
 of granting metadata layouts on demand. The I-MDS might
 also be capable of granting non-metadata layouts, but this
 is irrelevant to the scope of metadata striping. The model
 also requires at least one additional server, an L-MDS,
 that is capable of supporting NFSv4.1 operations that are
 directed to the server by the I-MDS. It is permissible for
 an I-MDS to also be an L-MDS, and an L-MDS to also be an
 I-MDS. Indeed, a simple submodel is for every NFSv4.1
 server in a set to be both an I-MDS and L-MDS.


</p>
<p>
 Metadata striping applies to all NFSv4.1 operations that
 operate on file objects.
 These operations can be broken down into three
 classes:
 </p>
<ul class="text">
<li>
   Filehandle-only. These are operations that take just
   filehandles as arguments, i.e. the current filehandle,
   or both the current filehandle and the saved filehandle,
   and no component names of files. When a client obtains a
   filehandle of an file object from an NFS server, it can
   obtain a metadata layout that indicates the optimal
   destination in the network to send filehandle-only operations for that
   file object. For example, after obtaining the filehandle via OPEN,
   and the metadata layout via LAYOUTGET, the client wants to
   get a byte range lock on the file. The client sends the LOCK
   request to the network address specified in the metadata
   layout.

 
</li>
<li>
  Name-based. These are operations that take one or two filehandles
  (i.e. the current file handle, or both the current file handle
  and the saved filehandle) and one or two component names of files.
  When a client obtains a filehandle of a file object that is of type
  directory, it can obtain a metadata layout that indicates the
  optimal destinations in the network to send name-based operations for
  that directory. The optimal destinations MUST apply to the
  current filehandle that the operation uses. In other words, for
  LINK and RENAME, which take both the saved filehandle and the
  current filehandle as parameters, the pNFS client would
  use the metadata layout of the target directory (indicated in
  the current filehandle) for guidance where to send the operation.
  Note that if an L-MDS accepts a LINK or RENAME operation, the L-MDS
  MUST perform the operation atomically. If it cannot, then the
  L-MDS MUST return the error NFS4ERR_XDEV, and the client MUST
  send the operation to the I-MDS.

  <br />
<br />


  The choice of destination is a function of the
  name the client is requesting. For example, after the client 
  obtains the filehandle of a directory via LOOKUP and the metadata
  layout via LAYOUTGET, the client wants to open a regular file
  within the directory. As with the LAYOUT4_NFSV4_1_FILES layout
  type, the client has a list network addresses to which to send requests.
  With the LAYOUT4_NFSV4_1_FILES layout, the choice of the index in
  the list of network addresses was computed from the offset of the
  read or write request. With the metadata layout, the choice of
  the index is derived from the name (or some other method, such
  as the name and one or more attributes of the directory,
  such as the filehandle, fileid, etc.) passed to OPEN.

 
</li>
<li>
  Directory-reading. These are operations that take one
  filehandle and return the contents of a directory (currently,
  NFSv4 has just one such operation, READDIR).
  When a client obtains a filehandle of a file object that is of type
  directory, it can obtain a metadata layout that indicates the
  optimal destination in the network to send directory reading operations
  for that directory. For example, after the client obtains the filehandle
  of a directory via LOOKUP and the metadata layout via LAYOUTGET, the
  client wants to read the directory. As with the LAYOUT4_NFSV4_1_FILES
  layout type, the client has a list network addresses to which to send requests.
  With the LAYOUT4_NFSV4_1_FILES layout, the choice of the index in
  list of network addresses was computed from the offset of the
  read or write request. Since directories have cookies which
  resemble offsets, the choice of the index is computed from the
  the "cookie" argument to the operation.
 
</li>
</ul><p>

</p>
<a name="anchor3"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4"></a><h3>4.&nbsp;
The Definition of Metadata Striping Layout</h3>

<a name="anchor4"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.1"></a><h3>4.1.&nbsp;
Name of Metadata Striping Layout Type</h3>

<p>
 The name of the metadata striping layout type is LAYOUT4_METADATA.

</p>
<a name="anchor5"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.2"></a><h3>4.2.&nbsp;
Value of Metadata Striping Layout Type</h3>

<p>
 The value of the metadata striping layout type is TBD1.

</p>
<a name="anchor6"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.3"></a><h3>4.3.&nbsp;
Definition of the da_addr_body Field of the device_addr4 Data Type</h3>
<br /><hr class="insert" />
<a name="addr"></a>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
///  %#include "nfs4_prot.h"
///  union md_layout_addr4 switch (bool mdla_simple) {
///    case TRUE:
///      multipath_list4              mdla_simple_addr;
///    case FALSE:
///      nfsv4_1_file_layout_ds_addr4 mdla_complex_addr;
///  };

</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;1&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>
If mdla_simple is TRUE, the remainder of the device address contains a
list of elements (mdla_simple_addr), where each element
represents a network address of an L-MDS which can
serve equally as the target of metadata operations
(typically the filehandle-only operations). See Section 13.5 of <a class='info' href='#I-D.ietf-nfsv4-minorversion1'>[2]<span> (</span><span class='info'>Shepler, S., Eisler, M., and D. Noveck, &ldquo;NFS Version 4 Minor Version 1,&rdquo; Sep&nbsp;2008.</span><span>)</span></a> for
a description of how the multipath_list4 data type supports multi-pathing.


</p>
<p>
If mdla_simple
is FALSE, the remainder of the device address is the same as the
LAYOUT4_NFSV4_1_FILES device address, consisting of an
array of lists of L-MDSes servers
(nflda_multipath_ds_list), and an array of indices
(nflda_stripe_indices).  Each element of
nflda_multipath_ds_list contains one or more subelements,
and each subelement represents a network address of
an L-MDS which may serve equally as the
target of name-based and directory-reading operations (see Section
13.5 of <a class='info' href='#I-D.ietf-nfsv4-minorversion1'>[2]<span> (</span><span class='info'>Shepler, S., Eisler, M., and D. Noveck, &ldquo;NFS Version 4 Minor Version 1,&rdquo; Sep&nbsp;2008.</span><span>)</span></a>).  The
number of elements in nflda_multipath_ds_list array might
be different than the stripe count. The stripe count is the
number of elements in nflda_stripe_indices.
The value
of each element of nflda_stripe_indices is an index into
nflda_multipath_ds_list, and thus the value of each element
of nflda_stripe_indices MUST be less than the number of
elements in nflda_multipath_ds_list.


</p>
<a name="anchor7"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.4"></a><h3>4.4.&nbsp;
Definition of the loh_body Field of the layouthint4 Data Type</h3>
<br /><hr class="insert" />
<a name="loh_body"></a>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
///  enum md_layout_hint_care4 {
///         MD4_CARE_STRIPE_UNIT_SIZE    = 0x040,
///         MD4_CARE_STRIPE_CNT_NAMEOPS  = 0x080,
///         MD4_CARE_STRIPE_CNT_DIRRDOPS = 0x100
///  };
///  %
///  %/* Encoded in the loh_body field of type layouthint4: */
///  %
///  struct md_layouthint4 {
///         uint32_t        mdlh_care;
///         count4          mdlh_stripe_cnt_nameops;
///         count4          mdlh_stripe_cnt_dirrdops;
///         nfs_cookie4     mdlh_stripe_unit_size;
///  };
</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;2&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>
The layout-type specific content for the LAYOUT4_METDATA
layout type is composed of four fields. The first field,
mdlh_care, is a set of flags indicating which values of the
hint the client cares about. If MD4_CARE_STRIPE_CNT_NAMEOPS
is set, then the client indicates in the second field,
mdlh_stripe_cnt_nameops the preferred stripe count for
name-based operations. If MD4_CARE_STRIPE_CNT_DIRRDOPS is
set, then the client indicates in the third field,
mdlh_stripe_cnt_dirrdops, the preferred stripe count for
directory-reading operations. If MD4_CARE_STRIPE_UNIT_SIZE
is set, then the client indicates in the fourth field,
mdlh_stripe_unit_size, the preferred stripe unit size for
directory-reading operations.


</p>
<a name="layout"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.5"></a><h3>4.5.&nbsp;
Definition of the loc_body Field of the layout_content4 Data Type</h3>
<br /><hr class="insert" />
<a name="layout_idl"></a>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
///  struct md_layout_fhonly {
///    deviceid4   mdlf_devid;
///    nfs_fh4     mdlf_fh&lt;1&gt;;
///  };
///
///  struct md_layout_namebased {
///    deviceid4   mdln_devid;
///    uint32_t    mdln_namebased_alg;
///    uint32_t    mdln_first_index;
///    nfs_fh4     mdln_fh_list&lt;&gt;;
///  };
///
///  union md_layout_dirread_fhlist
///        switch (bool mdldf_use_namebased) {
///    case TRUE:
///      void;
///    case FALSE:
///      nfs_fh4     mdldf_fh_list&lt;&gt;;
///  };
///
///  struct md_layout_dirread {
///    deviceid4                mdld_devid;
///    nfs_cookie4              mdld_first_cookie;
///    nfs_cookie4              mdld_unit_size;
///    uint32_t                 mdld_first_index;
///    md_layout_dirread_fhlist mdld_fh_list;
///  };
///
///  struct md_layout4 {
///    md_layout_fhonly    mdl_fhops_layout&lt;1&gt;;
///    md_layout_namebased mdl_nameops_layout&lt;1&gt;;
///    md_layout_dirread   mdl_dirrdops_layout_segments&lt;&gt;;
///  };

</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;3&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>
The reply to a successful LAYOUTGET request MUST contain exactly one element
in logr_layout. The element contains the metadata layout.
The metadata layout consists of three variable length arrays. At least one
of the arrays MUST be of non-zero length.
</p>
<ul class="text">
<li>
  mdl_fhops_layout. This is an array of up to one element.
  If there is one element, the element indicates the
  preferred set L-MDSes as the target of filehandle-only operations.
  The element contains two fields, mdlf_devid, the pNFS device ID of
  the L-MDS
  and mdlf_fh, an array of up to one filehandle.

  <br />
<br />


  When the client receives a layout that has a
  mdl_fhops_layout array with one element, it uses
  GETDEVICEINFO to map mdlf_devid to a device address,
  of data type md_layout_addr4. The value of the device address field
  mdla_simple MUST be TRUE. The client can then select any
  element in mdla_simple_addr to send a filehandle-only
  operation. The field mdlf_devid MUST map to a device
  address with mdla_simple set to TRUE.  The current
  filehandle REQUIRED for use with the filehandle-only
  operation is either mdlf_fh[0] (if and only if mdlf_fh has one
  element) or it is the filehandle the pNFS client used
  as the current filehandle to the LAYOUTGET operation
  that returned the metadata layout.

  
 
</li>
<li>
  mdl_nameops_layout. This is an array of up to one element.
  If there is one element, the element indicates the
  preferred set of L-MDS servers to as the target of name-based operations.
  The list of L-MDSes is mapped from the mdln_devid device ID.
  The array mdln_fh_list is used to select a filehandle for accessing
  an L-MDS. The number of elements in this array MUST be one of three values:
  
<ul class="text">
<li>
   Zero. The means that filehandles used for each L-MDS are the same as
   the filehandle used as the current filehandle to LAYOUTGET.
  
</li>
<li>
   One. This means that every L-MDS uses filehandle in mdln_fh_list[0].
  
</li>
<li>
   The same number of elements as
   mdla_complex_addr.nflda_multipath_ds_list. Thus, when
   sending a name-based operation to any L-MDS in
   mdla_complex_addr.nflda_multipath_ds_list[X], the
   filehandle in mdln_fh_list[X] MUST be used.

  
</li>
</ul>
  The field mdld_first_index is the index into the first element of the 
  of mdla_complex_addr.nflda_stripe_indices array to use. The field 
  mdln_namebased_alg identifies the algorithm used to compute the
  actual element in the mdla_complex_addr.nflda_stripe_indices array to use.

  <br />
<br />


  When the client receives a layout that has a 
  mdl_nameops_layout array with one element, it uses
  GETDEVICEINFO to map mdln_devid to a device address of data type md_layout_addr4.
  The value of the device address field mdla_simple MUST be set to
  FALSE. 

  <br />
<br />


  The client determines the filehandle and the set of L-MDS network
  addresses to send a name-based operation via the following algorithm:

<br /><hr class="insert" />
<a name="name-based-alg"></a>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>

let F be the function designated by
  mdln_namebased_alg;

let X = (x1, x2, x3, ...) some set of inputs for
  function F, such that x1 SHOULD be the
  component name of the file;

stripe_unit_number = F(X);
stripe_count = number of elements in
  mdla_complex_addr.nflda_stripe_indices;

j = (stripe_unit_number + mdln_first_index) %
  stripe_count;

idx = nflda_stripe_indices[j];

fh_count = number of elements in mdln_fh_list;
lmds_count = number of elements in
mdla_complex_addr.nflda_multipath_ds_list;

switch (fh_count) {
case lmds_count:
  fh = mdln_fh_list[idx];
  break;

case 1:
  fh = mdln_fh_list[0];
  break;

case 0:
  fh = current filehandle passed to LAYOUTGET;
  break;

default:
  throw a fatal exception;
  break;
}

address_list =
  mdla_complex_addr.nflda_multipath_ds_list[idx];
</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;4&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

   The client would then select an L-MDS from address_list, and send
   the name-based operation using the filehandle specified in fh.

  <br />
<br />


   If value of stripe_count is one, then in the above, the value of
   the stripe_unit_number derived from mdln_namebased_alg and
   the value of mdln_first_index will not change the index into
   nflda_stripe_indices because that index will always be zero.
   Hence when stripe_count is one, the value mdln_namedbased_alg
   does not matter. Thus, when 
   mdla_complex_addr.nflda_stripe_indices has a length of one,
   the client MUST ignore the value of mdln_namebased_alg. This
   means that all name-based operations on the directory can be
   be sent any among the set of L-MDSes indicated in one element of
   mdla_complex_addr.nflda_multipath_ds_list. This serves the
   common case of where whole directories are distributed across
   a set L-MDSes, but the directories themselves are not striped.

 
</li>
<li>
  mdl_dirops_layout_segments. This is an array of zero or
  more elements.  Each element indicates the preferred set
  of L-MDSes as the preferred destination for directory
  reading operations and the pattern over which directory
  reading operations iterates over the L-MDSes. The set of L-MDSes is
  mapped from the value of the device ID in the field
  mdld_devid.
  The field mdld_first_cookie indicates the
  first directory entry cookie that a directory reading
  operation can use for the first unit of the pattern in this element. E.g.,
  the value of mdld_first_cookie can be used as the value of
  the "cookie" field in READDIR4args. In the first element,
  mdld_first_cookie MUST be zero. The
  last cookie that can be used on the pattern can be no
  higher than one less than the value of mdld_first_cookie of the
  next element. If there is no next element, then the
  pattern is valid for all cookies from mdld_first_cookie
  through NFS4_UINT64_MAX inclusive. The field mdld_unit_size
  indicates the maximum number of cookies that can be read
  from each unit of a pattern, and thus indicates the lowest
  value of the "cookie" field in READDIR4args for each unit
  after the first unit. For example, if mdld_unit_size is
  100000, and mdld_first_cookie is zero, then value of the
  "cookie" field in the READDIR4args of the READDIR operation sent
  to the second unit MUST be greater than or equal to 100000, and
  less than 200000.
  The field mdld_fh_list is used to select a filehandle for
  accessing an L-MDS. It is a switched union with a boolean
  discriminator mdldf_use_namebased. If mdldf_use_namebased
  is TRUE, then the array mdl_nameops_layout MUST be of length equal
  to one and the filehandle MUST be selected from
  mdl_nameops_layout.mdln_fh_list. Note however, that the
  device address MUST still be mapped from mdld_devid and not
  mdln_devid.
 
</li>
<li>
  If mdldf_use_namebased is FALSE, then mlld_fh_list is present,
  and number of elements in mdld_fh_list MUST be one of three values:
  
<ul class="text">
<li>
   Zero. The means that filehandles used for each L-MDS are the same as
   the filehandle used as the current filehandle to LAYOUTGET.
  
</li>
<li>
   One. This means that every L-MDS uses the filehandle in mdld_fh_list[0].
  
</li>
<li>
   The same number of elements as
   mdld_complex_addr.nflda_multipath_ds_list. Thus, when
   sending a directory-reading operation to any L-MDS in
   mdld_complex_addr.nflda_multipath_ds_list[X], the
   filehandle in mdld_fh_list[X] MUST be used.

  
</li>
</ul>
  The field mdld_first_index is the index into the first element of the 
  mdld_complex_addr.nflda_stripe_indices array to use.
  <br />
<br />


  When the client receives a layout that has a 
  mdl_dirops_layout_segments array with more than zero elements, it uses
  GETDEVICEINFO to map the mdln_devid of each element of the array
  to a device address of data type md_layout_addr4.
  The value of the device address field mdla_simple MUST be set to
  FALSE. The client determines the filehandle and the set of L-MDS network
  addresses to send a name-based operation via the following algorithm:

<br /><hr class="insert" />
<a name="dir-read-alg"></a>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
let cookie_arg be the cookie the pNFS client will
  use as the value of the cookie argument to a
  directory reading operation;

segment_count = number of elements in
  mdl_dirrdops_layout_segments;

find index k, such that (cookie_arg &gt;=
  mdl_dirrdops_layout_segments[k].mdld_first_cookie)
  &amp;&amp; ((k == (segment_count - 1)) || (cookie_arg
  &lt; mdl_dirrdops_layout_segments[k+1]));

relative_cookie = cookie_arg -
  mdl_dirrdops_layout_segments[k].mdld_first_cookie;

address = the result of GETDEVICEINFO on
  mdl_dirrdops_layout_segments[k].mdld_devid;

i = floor(relative_cookie /
  mdl_dirrdops_layout_segments[k].mdld_unit_size);

stripe_count = number of elements in
  address.mdla_complex_addr.nflda_stripe_indices;

j = (stripe_unit_number + mdld_first_index) % stripe_count;

idx = nflda_stripe_indices[j];
lmds_count = number of elements in
    address.mdla_complex_addr.nflda_multipath_ds_list;

if (mdl_dirrdops_layout_segments[k].
    mdldf_use_namebased == TRUE) {
  fh_count = number of elements in mdl_nameops_layout[0].mdln_fh_list;
    address.mdla_complex_addr.nflda_multipath_ds_list;
} else {
  fh_count = number of elements in
    mdl_dirrdops_layout_segments[k].mdld_fh_list.
      mdldf_fh_list;
}

switch (fh_count) {
  case lmds_count:
    if (mdl_dirrdops_layout_segments[k].
        mdldf_use_namebased == TRUE) {
      fh = mdln_fh_list[idx];
    } else {
      fh = mdl_dirrdops_layout_segments[k].mdld_fh_list.
        mdldf_fh_list[idx];
    }
    break;

  case 1:
    if (mdl_dirrdops_layout_segments[k].
        mdldf_use_namebased == TRUE) {
      fh = mdln_fh_list[0];
    } else {
      fh = mdl_dirrdops_layout_segments[k].mdld_fh_list.
        mdldf_fh_list[0];
    }
    break;

  case 0:
    fh = current filehandle passed to LAYOUTGET;
    break;

  default:
    throw a fatal exception;
    break;
}

address_list =  address.mdla_complex_addr.
  nflda_multipath_ds_list[idx];
</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;5&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

   The client would then select an L-MDS from address_list, and send
   the directory-reading operation using the filehandle specified in fh.
   When the client is reading the beginning of the directory, cookie_arg is
   always zero. Subsequent directory-reading operations to read the rest
   of the directory will use the last cookie returned by the L-MDS.
   An MDS returning a metadata layout SHOULD return cookies that can
   be used directly to the I-MDS that returned the layout. However this might
   not always be possible. For example, the directory design of the filesystem
   of the MDS, might not return cookies in ascending order, or any order at
   all for that matter. Whereas, striping by definition requires an ordering.
   In such cases, if a directory is restriped while a pNFS client is reading
   its contents from the L-MDSes, it is possible that client will be unable
   to complete reading the directory, and as a result an error is returned to
   process reading the directory. To mitigate this, servers that have
   sent a CB_LAYOUTRECALL on the directory SHOULD NOT
   revoke the layout as long as they detect that the client is completing
   a read of the entire directory. Once a client has received a CB_LAYOUTRECALL,
   it SHOULD NOT send a directory-reading operation to an L-MDS with a cookie argument
   of zero. If the server has sent a CB_LAYOUTRECALL, the L-MDS
   SHOULD reject requests to read the directory that have
   a cookie argument zero and return the error NFS4ERR_PNFS_NO_LAYOUT.
 
</li>
</ul><p>

</p>
<a name="anchor8"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.6"></a><h3>4.6.&nbsp;
Definition of the lou_body Field of the layoutupdate4 Data Type</h3>
<br /><hr class="insert" />
<a name="lou_body"></a>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
///  %/*
///  % * LAYOUT4_METADATA.
///  % * Encoded in the lou_body field of type layoutupdate4:
///  % *      Nothing. lou_body is a zero length array of octets.
///  % */
///  %
</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;6&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>
The LAYOUT4_METADATA layout type has no content for lou_body filed of
the layoutupdate4 data type.

</p>
<a name="anchor9"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.7"></a><h3>4.7.&nbsp;
Storage Access Protocols</h3>

<p>
The LAYOUT4_METADATA layout type uses NFSv4.1 operations
(and potentially, operations of higher minor versions of
NFSv4, subject to the definition of a minor version of
NFSv4) to access striped metadata. The LAYOUT4_METADATA
does not affect access to storage devices. Thus a client
might be able to obtain both a LAYOUT4_METADATA layout, and
a non-LAYOUT4_METADATA layout type (e.g.,
LAYOUT4_NFSV4_1_FILES, LAYOUT4_OSD2_OBJECTS, or
LAYOUT4_BLOCK_VOLUME) on the same regular file. Of course,
for a non-regular file, a pNFS client will be unable to get
layouts of types LAYOUT4_NFSV4_1_FILES,
LAYOUT4_OSD2_OBJECTS, or LAYOUT4_BLOCK_VOLUME).


</p>
<a name="anchor10"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.8"></a><h3>4.8.&nbsp;
Revocation of Layouts</h3>

<p>

 Servers MAY revoke layouts of type LAYOUT4_METADATA. A client
 detects if layout has been revoked if the operation is rejected
 with NFS4ERR_PNFS_NO_LAYOUT. In NFSv4.1, the
 error NFS4ERR_PNFS_NO_LAYOUT could be returned only by READ and WRITE.
 When the server returns a layout of type LAYOUT4_METADATA, the set
 of operations that can return NFS4ERR_PNFS_NO_LAYOUT is:
 ACCESS, CLOSE, COMMIT, CREATE, DELEGRETURN, GETATTR, LINK,
 LOCK, LOCKT, LOCKU, LOOKUP, LOOKUPP, NVERIFY, OPEN,
 OPENATTR, OPEN_DOWNGRADE, READ, READDIR, READLINK, REMOVE,
 RENAME, SECINFO, SETATTR, VERIFY, WRITE,
 GET_DIR_DELEGATION, SECINFO, SECINFO_NO_NAME, and WANT_DELEGATION.


</p>
<a name="anchor11"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.9"></a><h3>4.9.&nbsp;
Stateids</h3>

<p>
 The pNFS specification for LAYOUT4_NFSV4_1_FILES states
 data servers MUST be aware of the stateids granted by
 MDS so that the stateids passed to READ and WRITE can be 
 properly validated. This requirement extends to the LAYOUT4_METADATA
 layout type: the L-MDS MUST be aware of any non-layout
 stateids granted by the I-MDS, if and only if the
 client is in contact the L-MDS under direction of a metadata layout
 returned by the I-MDS, and the I-MDS has not recalled or revoked that
 layout. In addition, because an L-MDS can accept operations
 like OPEN and LOCK that create or modify stateids, the I-MDS
 MUST be aware of stateids that an L-MDS has returned to
 a client, if and only if the I-MDS granted the client a
 metadata layout that directed the client to the L-MDS.

</p>
<p>
 In some cases, one L-MDS MUST be aware of a stateid generated
 by another L-MDS.
 For example a client can obtain a stateid from the L-MDS serving
 as the destination of name-based operations, which
 includes OPEN. However operations that use the stateid will be
 filehandle-only operations, and the L-MDS the OPEN operation
 is sent to might differ from the L-MDS the LOCK operation
 for the same target file is sent to.

</p>
<a name="anchor12"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.10"></a><h3>4.10.&nbsp;
Lease Terms</h3>

<p>
  Any state the client obtains from an I-MDS or L-MDS is
  guaranteed to last for an interval lasting as long
  as the maximum of the lease_time attribute of the
  the I-MDS, and any L-MDS the client is directed to as
  the result of a metadata layout. The client has a lease
  for each client ID it has with an I-MDS or L-MDS, and each
  lease MUST be renewed separately for each client ID.

</p>
<a name="anchor13"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.11"></a><h3>4.11.&nbsp;
Layout Operations Sent to an L-MDS</h3>

<p>
 An L-MDS MAY allow a LAYOUTGET operation. One reason the
 L-MDS might allow a LAYOUTGET operation is to allow
 hierarchical striping. For example, for name-based
 operations, the pNFS server might use a radix tree, (which
 the field mdln_namebased_alg would indicate). The first
 four bytes of the component name would be combined to form
 a 32 bit stripe_unit_number. Once the client contacted the
 L-MDS, it would repeat the algorithm on the second
 four bytes of the component, and so on until the
 component name was exhausted.

</p>
<p>
 One an L-MDS grants a layout, the client MUST use only
 the L-MDS that granted to the layout to send LAYOUTUPDATE,
 LAYOUTCOMMIT, and LAYOUTRETURN.

</p>
<a name="anchor14"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.12"></a><h3>4.12.&nbsp;
Filehandles in Metadata Layouts</h3>

<p>
 The filehandles returned in a metadata layout are subject
 to becoming stale at any time. The L-MDS SHOULD NOT
 return NFS4ERR_STALE unless the I-MDS has recalled or
 revoked the corresponding layout.

</p>
<a name="anchor15"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.13"></a><h3>4.13.&nbsp;
READ and WRITE Operations</h3>

<p>
 READ and WRITE are filehandle-only operations, and
 thus 
 the pNFS client SHOULD attempt to obtain a non-metadata
 layout for a regular file. If it cannot, then it MAY
 use the metadata layout to send READ and WRITE operations
 to an L-MDS. An L-MDS MUST accept a READ or WRITE
 operation if the layout the I-MDS returned to the client
 included a filehandle-only layout.


</p>
<a name="anchor16"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.14"></a><h3>4.14.&nbsp;
Recovery</h3>

<p>
<a class='info' href='#comment.Comment.1'>[Comment.1]<span> (</span><span class='info'>it is likely this section will follow that of the files layout type  specified in the NFSv4.1 specification.</span><span>)</span></a><a name='anchor17'></a>
</p>
<a name="anchor18"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.14.1"></a><h3>4.14.1.&nbsp;
Failure and Restart of Client</h3>

<p>TBD
</p>
<a name="anchor19"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.14.2"></a><h3>4.14.2.&nbsp;
Failure and Restart of Server</h3>

<p>TBD
</p>
<a name="anchor20"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.14.3"></a><h3>4.14.3.&nbsp;
Failure and Restart of Storage Device</h3>

<p>TBD
</p>
<a name="anchor21"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5"></a><h3>5.&nbsp;
Negotiation</h3>

<p>
 An pNFS client sends a GETATTR operation for
 attribute fs_layout_type.  If the reply contains
 the metadata layout type, then metadata striping
 is supported, subject to further verification by
 a LAYOUTGET operation.  If not, the client
 cannot use metadata striping.


</p>
<a name="anchor22"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6"></a><h3>6.&nbsp;
Operational Recommendation for Deployment</h3>

<p>
 Deploy the metadata striping layout when it is anticipated that the
 workload will involve a high fraction of non-I/O operations on filehandles.

</p>
<a name="acks"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7"></a><h3>7.&nbsp;
Acknowledgements</h3>

<p>
Brent Welch had the idea of returning a separate
device ID for filehandle-only operations in the
metadata layout. Pranoop Erasani, Dave Noveck,
and Richard Jernigan provided valuable feedback.


</p>
<a name="securityconsider"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.8"></a><h3>8.&nbsp;
Security Considerations</h3>

<p>
The security considerations of Section 13.12 of 
<a class='info' href='#I-D.ietf-nfsv4-minorversion1'>[2]<span> (</span><span class='info'>Shepler, S., Eisler, M., and D. Noveck, &ldquo;NFS Version 4 Minor Version 1,&rdquo; Sep&nbsp;2008.</span><span>)</span></a> which are specific
to data servers apply to lMDSes. In addition, each lMDS server and client
are, respectively, a complete NFSv4.1 server and client, and so the
security considerations of 
<a class='info' href='#I-D.ietf-nfsv4-minorversion1'>[2]<span> (</span><span class='info'>Shepler, S., Eisler, M., and D. Noveck, &ldquo;NFS Version 4 Minor Version 1,&rdquo; Sep&nbsp;2008.</span><span>)</span></a> apply to any client or server 
using the metadata layout type.


</p>
<a name="ianaconsider"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.9"></a><h3>9.&nbsp;
IANA Considerations</h3>

<p>
      This specification requires an addition to the Layout Types registry described in Section 22.4 of <a class='info' href='#I-D.ietf-nfsv4-minorversion1'>[2]<span> (</span><span class='info'>Shepler, S., Eisler, M., and D. Noveck, &ldquo;NFS Version 4 Minor Version 1,&rdquo; Sep&nbsp;2008.</span><span>)</span></a>. The five fields added
      to the registy are:
      </p>
<ol class="text">
<li>
       Name of layout type: LAYOUT4_METADATA
      
</li>
<li>
       Value of layout type: TBD1.
      
</li>
<li>
       Standards Track RFC that describes this layout: RFCTBD2, which
       is the RFC of this document.
      
</li>
<li>
       How the RFC Introduces the specification: L.
      
</li>
<li>
       Minor versions of NFSv4 that can use the layout type: 1.
      
</li>
</ol><p>
   
</p>
<p>
    This specification requires the creation of a registry of hash algorithms
    for supporting the field mdln_namebased_alg. Details TBD. 
   
</p>
<a name="rfc.references1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>10.&nbsp;Normative References</h3>
<table width="99%" border="0">
<tr><td class="author-text" valign="top"><a name="RFC2119">[1]</a></td>
<td class="author-text"><a href="mailto:sob@harvard.edu">Bradner, S.</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>,&rdquo; RFC&nbsp;2119, March&nbsp;1997 (<a href="ftp://ftp.isi.edu/in-notes/rfc2119.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="I-D.ietf-nfsv4-minorversion1">[2]</a></td>
<td class="author-text">Shepler, S., Eisler, M., and D. Noveck, &ldquo;<a href="http://www.ietf.org/internet-drafts/draft-ietf-nfsv4-minorversion1-26.txt">NFS Version 4 Minor Version 1</a>,&rdquo; draft-ietf-nfsv4-minorversion1-26 (work in progress), Sep&nbsp;2008 (<a href="http://www.ietf.org/internet-drafts/draft-ietf-nfsv4-minorversion1-26.txt">TXT</a>).</td></tr>
</table>

<a name="rfc.authors"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>Author's Address</h3>
<table width="99%" border="0" cellpadding="0" cellspacing="0">
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Mike Eisler</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">NetApp</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">5765 Chase Point Circle</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Colorado Springs, CO  80919</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">US</td></tr>
<tr><td class="author" align="right">Phone:&nbsp;</td>
<td class="author-text">+1-719-599-9026</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:mike@eisler.com">mike@eisler.com</a></td></tr>
</table>
</body></html>
