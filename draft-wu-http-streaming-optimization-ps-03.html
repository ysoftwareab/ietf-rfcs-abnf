<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="en"><head><title>Problem Statement for
    HTTP Streaming</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="description" content="Problem Statement for
    HTTP Streaming">
<meta name="generator" content="xml2rfc v1.35 (http://xml.resource.org/)">
<meta name="viewport" content="width=600;" />
<style type='text/css'><!--
        body {
                font-family: verdana, charcoal, helvetica, arial, sans-serif;
                font-size: 85%;
		max-width: 60em; 
		color: #000; background-color: #FFF;
                margin: 2em;
        }
        h1, h2, h3, h4, h5, h6 {
                font-family: helvetica, monaco, "MS Sans Serif", arial, sans-serif;
                font-weight: bold; font-style: normal;
        }
        h1 { color: #900; background-color: transparent; text-align: right; }
        h3 { color: #333; background-color: transparent; }

        td.RFCbug {
                font-size: x-small; text-decoration: none;
                width: 30px; height: 30px; padding-top: 2px;
                text-align: justify; vertical-align: middle;
                background-color: #000;
        }
        td.RFCbug span.RFC {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: bold; color: #666;
        }
        td.RFCbug span.hotText {
                font-family: charcoal, monaco, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: normal; text-align: center; color: #FFF;
        }

        table.TOCbug { width: 30px; height: 15px; }
        td.TOCbug {
                text-align: center; width: 30px; height: 15px;
                color: #FFF; background-color: #900;
        }
        td.TOCbug a {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, sans-serif;
                font-weight: bold; font-size: x-small; text-decoration: none;
                color: #FFF; background-color: transparent;
        }

        td.header {
                font-family: arial, helvetica, sans-serif; font-size: x-small;
                vertical-align: top; width: 33%;
                color: #FFF; background-color: #666;
        }
        td.author { font-weight: bold; font-size: x-small; margin-left: 4em; }
        td.author-text { font-size: x-small; }

        /* info code from SantaKlauss at http://www.madaboutstyle.com/tooltip2.html */
        a.info {
                /* This is the key. */
                position: relative;
                z-index: 24;
                text-decoration: none;
        }
        a.info:hover {
                z-index: 25;
                color: #FFF; background-color: #900;
        }
        a.info span { display: none; }
        a.info:hover span.info {
                /* The span will display just on :hover state. */
                display: block;
                position: absolute;
                font-size: smaller;
                top: 2em; left: -5em; width: 15em;
                padding: 2px; border: 1px solid #333;
                color: #900; background-color: #EEE;
                text-align: left;
        }

        a { font-weight: bold; }
        a:link    { color: #900; background-color: transparent; }
        a:visited { color: #633; background-color: transparent; }
        a:active  { color: #633; background-color: transparent; }

        p { margin-left: 2em; margin-right: 2em; }
        p.copyright { font-size: x-small; }
        p.toc { font-size: 85%;
		max-width: 60em; 
		font-weight: bold; margin-left: 3em; }
        table.toc { margin: 0 0 0 3em; padding: 0; border: 0; vertical-align: text-top; }
        td.toc { font-size: 85%;
		max-width: 60em; 
		font-weight: bold; vertical-align: text-top; }

        ol.text { margin-left: 2em; margin-right: 2em; }
        ul.text { margin-left: 2em; margin-right: 2em; }
        li      { margin-left: 3em; }

        /* RFC-2629 <spanx>s and <artwork>s. */
        em     { font-style: italic; }
        strong { font-weight: bold; }
        dfn    { font-weight: bold; font-style: normal; }
        cite   { font-weight: normal; font-style: normal; }
        tt     { color: #036; }
        tt, pre, pre dfn, pre em, pre cite, pre span {
                font-family: "Courier New", Courier, monospace; font-size: small;
        }
        pre {
                text-align: left; padding: 4px;
                color: #000; background-color: #CCC;
        }
        pre dfn  { color: #900; }
        pre em   { color: #66F; background-color: #FFC; font-weight: normal; }
        pre .key { color: #33C; font-weight: bold; }
        pre .id  { color: #900; }
        pre .str { color: #000; background-color: #CFF; }
        pre .val { color: #066; }
        pre .rep { color: #909; }
        pre .oth { color: #000; background-color: #FCF; }
        pre .err { background-color: #FCC; }

        /* RFC-2629 <texttable>s. */
        table.all, table.full, table.headers, table.none {
                font-size: 85%;
		max-width: 60em; 
		text-align: center; border-width: 2px;
                vertical-align: top; border-collapse: collapse;
        }
        table.all, table.full { border-style: solid; border-color: black; }
        table.headers, table.none { border-style: none; }
        th {
                font-weight: bold; border-color: black;
                border-width: 2px 2px 3px 2px;
        }
        table.all th, table.full th { border-style: solid; }
        table.headers th { border-style: none none solid none; }
        table.none th { border-style: none; }
        table.all td {
                border-style: solid; border-color: #333;
                border-width: 1px 2px;
        }
        table.full td, table.headers td, table.none td { border-style: none; }

        hr { height: 1px; }
        hr.insert {
                width: 80%; border-style: none; border-width: 0;
                color: #CCC; background-color: #CCC;
        }
--></style>
</head>
<body>
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<table summary="layout" width="66%" border="0" cellpadding="0" cellspacing="0"><tr><td><table summary="layout" width="100%" border="0" cellpadding="2" cellspacing="1">
<tr><td class="header">Network Working Group</td><td class="header">Q. Wu</td></tr>
<tr><td class="header">Internet-Draft</td><td class="header">R. Huang</td></tr>
<tr><td class="header">Intended status: Standards Track</td><td class="header">Huawei</td></tr>
<tr><td class="header">Expires: April 28, 2011</td><td class="header">October 25, 2010</td></tr>
</table></td></tr></table>
<h1><br />Problem Statement for
    HTTP Streaming<br />draft-wu-http-streaming-optimization-ps-03</h1>

<h3>Abstract</h3>

<p>HTTP Streaming allows breaking the live contents or stored contents
      into several chunks/fragments and supplying them in order to the client.
      However streaming long duration and high quality media over the internet
      to satisfy the real time streaming requirements has several Challenges
      when we require the client to access the same media content with the
      common Quality experience at any device, anytime, anywhere. This
      document explores problems inherent in HTTP streaming. Several issues
      regarding network support for HTTP Streaming have been raised, which
      include QoE improvement offering to streaming video over Internet,
      efficient delivery, Playback control and real time streaming media
      synchronization support.
</p>
<h3>Status of this Memo</h3>
<p>
This Internet-Draft is submitted  in full
conformance with the provisions of BCP&nbsp;78 and BCP&nbsp;79.</p>
<p>
Internet-Drafts are working documents of the Internet Engineering
Task Force (IETF).  Note that other groups may also distribute
working documents as Internet-Drafts.  The list of current
Internet-Drafts is at http://datatracker.ietf.org/drafts/current/.</p>
<p>
Internet-Drafts are draft documents valid for a maximum of six months
and may be updated, replaced, or obsoleted by other documents at any time.
It is inappropriate to use Internet-Drafts as reference material or to cite
them other than as &ldquo;work in progress.&rdquo;</p>
<p>
This Internet-Draft will expire on April 28, 2011.</p>

<h3>Copyright Notice</h3>
<p>
Copyright (c) 2010 IETF Trust and the persons identified as the
document authors.  All rights reserved.</p>
<p>
This document is subject to BCP 78 and the IETF Trust's Legal
Provisions Relating to IETF Documents
(http://trustee.ietf.org/license-info) in effect on the date of
publication of this document.  Please review these documents
carefully, as they describe your rights and restrictions with respect
to this document. Code Components extracted from this document must
include Simplified BSD License text as described in Section 4.e of
the Trust Legal Provisions and are provided without warranty as
described in the Simplified BSD License.</p>
<p>
This document may contain material from IETF Documents or IETF
Contributions published or made publicly available before November
10, 2008.  The person(s) controlling the copyright in some of this
material may not have granted the IETF Trust the right to allow
modifications of such material outside the IETF Standards Process.
Without obtaining an adequate license from the person(s) controlling
the copyright in such materials, this document may not be modified
outside the IETF Standards Process, and derivative works of it may
not be created outside the IETF Standards Process, except to format
it for publication as an RFC or to translate it into languages other
than English.</p>
<a name="toc"></a><br /><hr />
<h3>Table of Contents</h3>
<p class="toc">
<a href="#anchor1">1.</a>&nbsp;
Introduction<br />
<a href="#anchor2">2.</a>&nbsp;
Terminology<br />
<a href="#sec.3">3.</a>&nbsp;
Architecture of HTTP Streaming System<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor3">3.1.</a>&nbsp;
Functions of Streaming Components<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor4">3.2.</a>&nbsp;
Functions of Distribution Components<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor5">3.3.</a>&nbsp;
Functions of Client Components<br />
<a href="#anchor6">4.</a>&nbsp;
Existing Work and Model<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor7">4.1.</a>&nbsp;
Media Fragments URI<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor8">4.2.</a>&nbsp;
Media Presentation Description<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor9">4.3.</a>&nbsp;
Playback Control on media fragments<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor10">4.4.</a>&nbsp;
Server Push<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor11">4.5.</a>&nbsp;
Existing HTTP Streaming Model(Client Pull Model)<br />
<a href="#anchor12">5.</a>&nbsp;
Analysis of different use cases<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor13">5.1.</a>&nbsp;
Live Streaming Media broadcast<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor14">5.2.</a>&nbsp;
“Multi-Screen” Service Delivery<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor15">5.3.</a>&nbsp;
Content Publishing between Servers<br />
<a href="#anchor16">6.</a>&nbsp;
Aspects of Problem<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor17">6.1.</a>&nbsp;
Inefficient Streaming Content Delivery<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor18">6.2.</a>&nbsp;
No QoE Guaranteed Support<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor19">6.3.</a>&nbsp;
No QoS Control and Feedback Support<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor20">6.4.</a>&nbsp;
No Streaming Content Distribution and Discovery Support<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor21">6.5.</a>&nbsp;
Lacking Streaming media Synchronization support<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor22">6.6.</a>&nbsp;
No Multicast Support<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor23">6.7.</a>&nbsp;
Inadequate Streaming Playback Control<br />
<a href="#anchor24">7.</a>&nbsp;
Scope of the problem<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor25">7.1.</a>&nbsp;
Enhanced HTTP Streaming Pull model<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor26">7.2.</a>&nbsp;
HTTP Streaming Push model<br />
<a href="#anchor27">8.</a>&nbsp;
Security Considerations<br />
<a href="#anchor28">9.</a>&nbsp;
Acknowledgement<br />
<a href="#rfc.references1">10.</a>&nbsp;
References<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#rfc.references1">10.1.</a>&nbsp;
Normative References<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#rfc.references2">10.2.</a>&nbsp;
Informative References<br />
<a href="#rfc.authors">&#167;</a>&nbsp;
Authors' Addresses<br />
</p>
<br clear="all" />

<a name="anchor1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1"></a><h3>1.&nbsp;
Introduction</h3>

<p>Streaming service is described as transmission of data over network
      as a steady continuous stream, allowing playback to proceed while
      subsequent data is being received, which may utilize multiple transport
      protocols for data delivery. HTTP streaming refers to the streaming
      service wherein the HTTP protocol is used for basic transport of media
      data. One example of HTTP streaming is progressive download streaming
      which allows the user to access content using existing infrastructure
      before the data transfer is complete. 
</p>
<p>In recent years, HTTP streaming system has been widely used on the
      Internet for the delivery of multimedia content. There are several
      reasons for this industry trend, for example:<br />
<br />
</p>
<ul class="text">
<li>Existing Media Streaming protocols often have difficulty getting
          around firewalls because they are commonly based on UDP with unusual
          port numbers. HTTP streaming has no such problems because firewalls
          know to pass HTTP packets through well-known port 80.<br />
<br />

</li>
<li>Due to the success of Web, both HTTP server and HTTP client are
          quite common in industry, which means that building a HTTP based
          media delivery system may have less cost compared to those using
          dedicated media server/client and intermediaries.<br />
<br />

</li>
</ul>

<p>In order to better support the streaming characteristics, such as
      trick modes, adaptation to resolutions, some approaches have been
      commonly adopted in current HTTP streaming systems. For example, media
      segmentation method separates the whole media content to a series of
      small chunks and supplies them to the client through a sequence of HTTP
      responses. Segmentation allows the client to seek to different piece of
      media content, change the bit-rate of the next-to-fetch chunk, as well
      as enables reducing the overall transmission delay in case that one TCP
      connection trying to resend the lost packet before sending anything
      further.
</p>
<p>With media segmentation support, existing HTTP streaming technology
      (e.g., progressive download HTTP streaming) is characterized as:<br />
<br />
</p>
<ul class="text">
<li>Client based pull schemes that is, the client firstly acquires a
          manifest file containing the reference (e.g. URI) to each media
          chunks from the streaming server, then requests the media chunks by
          forming a sequence of HTTP request messages to the server. This
          client based pull model more relies on client to handle buffer and
          playback during download. <br />
<br />

</li>
<li>Relying on existing web infrastructure, i.e., no special server
          and intermediaries are required other than a standard HTTP Server
          and HTTP caches/proxies.<br />
<br />

</li>
</ul>

<p>However streaming long duration and high quality media over the
      internet to offer TV experience at any device and satisfy the real time
      streaming requirements faces several unique Challenges when there are no
      network capabilities available for HTTP Streaming:<br />
<br />
</p>
<ul class="text">
<li>In client pull model, there will be additional round trips
          between the client and the server for manifest file update before
          the client can request each new chunk, which could risk the
          real-time feature of live streaming.<br />
<br />

</li>
<li>Lack of QoE guarantee on the packet switching based Internet and
          hard to offer better experience than TV viewing. Compared to the
          dedicated IPTV system, the HTTP streaming based on the best-effort
          Internet may suffer more from network transition. For example, when
          a user switches live channel or start VoD, there is no guarantee on
          startup time.<br />
<br />

</li>
<li>Lack of Feedback on Quality of data delivery. e.g., there is no
          streaming quality control mechanisms like RTCP to report QoE metrics
          that are important to the HTTP streaming system for control or
          diagnostic purpose. <br />
<br />

</li>
<li>Lack of QoS Control. For example, there is no QoS difference
          between high speed Internet traffic and Streaming over Internet
          traffic and hard for QoS surcharges on consumer broadband
          subscription.<br />
<br />

</li>
<li>Lacking multicast support.<br />
<br />

</li>
</ul>

<p>With these above challenges, the typical user experience with the
      existing HTTP streaming schemes may be limited by unacceptable latency
      and waiting time, better effort quality, buffering delays or
      interruption, etc, and inadequate playback control, especially for live
      broadcast. Therefore these existing streaming schemes is more applicable
      to recorded contents viewing that offers a better experience over slower
      connections for recorded contents viewer. Especially, in the case of
      “Multi-Screen”, the service provider intends to provide a common user
      experience when the user enjoys the media content across PCs, TVs, and
      smart-phones. Therefore, HTTP streaming over the Internet without some
      optimization on network transport for QoE improvement may lead
      difficulty for the service provider to comply the service level
      agreements (SLAs) between service provider and users.
</p>
<p>This document explores problems inherent in HTTP streaming. Several
      issues regarding network support for HTTP Streaming have been raised,
      which include QoS improvement offering to streaming video over Internet,
      efficient delivery, playback control and real time streaming media
      synchronization support etc. The following sections described
      architecture of HTTP streaming system, introduce related works and model
      on HTTP streaming, analyze some use cases in HTTP streaming and list the
      potential problems when providing better streaming quality over the
      Internet.
</p>
<a name="anchor2"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2"></a><h3>2.&nbsp;
Terminology</h3>

<p>The keywords "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
      "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
      document are to be interpreted as described in <a class='info' href='#RFC2119'>[RFC2119]<span> (</span><span class='info'>Bradner, S., &ldquo;Key words for use in RFCs to Indicate Requirement Levels,&rdquo; March&nbsp;1997.</span><span>)</span></a>.
</p>
<p></p>
<blockquote class="text"><dl>
<dt>Push Model:</dt>
<dd>The model that allows the server keep
          pushing data packets to the client.<br />

</dd>
<dt>Pull Model:</dt>
<dd>The model that allows the client keep
          pulling data packets from the server.<br />

</dd>
<dt>Live Streaming:</dt>
<dd>Live events can be streamed over the
          Internet with the help of broadcast software which encodes the live
          source and delivers the resulting stream to the server. The server
          then transfers the stream. So the user experiences the event as it
          happens.<br />

</dd>
<dt>On-Demand Streaming:</dt>
<dd>To provide "anytime" access to
          media content, client is allowed to select and playback on
          demand.<br />

</dd>
<dt>Progressive Download:</dt>
<dd> A mode that allow client
          playback the media file while the file is downloading, after only a
          few seconds wait for buffering, the process of collecting the first
          part of a media file before playing.<br />

</dd>
<dt>Adaptive Streaming:</dt>
<dd>Adaptive streaming is a process
          that adjusts the quality of a video delivered to a client based on
          the changing network conditions to ensure the best possible viewer
          experience.<br />

</dd>
</dl></blockquote>

<a name="sec.3"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3"></a><h3>3.&nbsp;
Architecture of HTTP Streaming System</h3>

<p><a class='info' href='#fig1'>Figure&nbsp;1<span> (</span><span class='info'>Reference Architecture for HTTP Streaming</span><span>)</span></a> shows reference Architecture for HTTP
      Streaming in general case. The Architecture should comprise the
      following components:<br />
<br />

</p><br /><hr class="insert" />
<a name="fig1"></a>
<div style='display: table; width: 0; margin-left: auto; margin-right: auto'><pre>
+--Streaming--+        +-Distribution+       +-  Client -+
|  Component  |        |  Component  |       | Component |
|  +-------+  |        | +--------+  |       |  +------+ |
|  | Media |  |        | |  HTTP  |  |       |  | HTTP | |
|  |Encoder|  |        | | Proxy/ |  |       |  |Client| |
|  +-------+  |        | | Server |  |       |  +------+ |
| +---------+ |-------&gt;| +--------+  |------&gt;|           |
| |Streaming| |        | +-------+   |       |           |
| |Segmenter| |&lt;-------| |Network|   |&lt;------|+---------+|
| +---------+ |        | | Cache |   |       ||Streaming||
|  +------+   |        | +-------+   |       ||  Client ||
|  | HTTP |   |        | +---------+ |       |+---------+|
|  |Server|   |        | |Streaming| |       |           |
|  +------+   |        | | Engine  | |       +-----------+
+-------------+        | +---------+ |
                       +-------------+
</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;1: Reference Architecture for HTTP Streaming&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p></p>
<ul class="text">
<li>Streaming Component<br />
<br />

</li>
<li>Distribution Component<br />
<br />

</li>
<li>Client Component<br />
<br />

</li>
</ul>

<a name="anchor3"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.1"></a><h3>3.1.&nbsp;
Functions of Streaming Components</h3>
<br /><hr class="insert" />
<a name="fig2"></a>
<div style='display: table; width: 0; margin-left: auto; margin-right: auto'><pre>
+--------------------+----------------------------------------------+
| Function           |                       Role                   |
+--------------------+----------------------------------------------+
| Media Encoder      | Encode  the media and encapsulate with       |
|                    | specific streaming formats for delivery      |
| -                  | -                                            |
| Streaming          | divide the input media into a series of small|
| Segementer         | chunks;Create index file containing reference|
|                    | to each chunks                               |
| -                  | -                                            |
| HTTP Server        | handles HTTP request from client and respond |
|                    | to HTTP connections                          |
+--------------------+----------------------------------------------+
</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;2: Functions of Streaming Component&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<a name="anchor4"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.2"></a><h3>3.2.&nbsp;
Functions of Distribution Components</h3>
<br /><hr class="insert" />
<a name="fig3"></a>
<div style='display: table; width: 0; margin-left: auto; margin-right: auto'><pre>
+--------------------+----------------------------------------------+
| Function           |                       Role                   |
+--------------------+----------------------------------------------+
| Network Cache      | Cache the data                               |
|                    |                                              |
| -                  | -                                            |
| Streaming          | Distinguish between regular HTTP traffic and |
|   Engine           | HTTP Streaming Traffic; Enable HTTP Streaming|
|                    |                 localized                    |
| -                  | -                                            |
| HTTP Proxy/        | Handles HTTP request from client;Forward data|
|   Server           | to client or respond to HTTP connections     |
+--------------------+----------------------------------------------+
</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;3: Functions of Distribution Component&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<a name="anchor5"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.3"></a><h3>3.3.&nbsp;
Functions of Client Components</h3>
<br /><hr class="insert" />
<a name="fig4"></a>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
+--------------------+----------------------------------------------+
| Function           |                       Role                   |
+--------------------+----------------------------------------------+
| Streaming          |                                              |
|   Client           | Handle Streaming Playout and Buffer          |
|                    |                                              |
| -                  | -                                            |
|    HTTP            | Initialize HTTP Connection                   |
|   Client           |                                              |
+--------------------+----------------------------------------------+
</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;4: Functions of Client Components&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<a name="anchor6"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4"></a><h3>4.&nbsp;
Existing Work and Model</h3>

<p>Based on the architecture described in <a class='info' href='#sec.3'>Section&nbsp;3<span> (</span><span class='info'>Architecture of HTTP Streaming System</span><span>)</span></a>,
      a growing number of works have been done to build HTTP streaming system
      with the intend to provide more streaming characteristics such as URI
      for media fragment, media presentation description, playback control
      etc. Also how existing HTTP Streaming model(i.e., client pull model) has
      been discussed.
</p>
<a name="anchor7"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.1"></a><h3>4.1.&nbsp;
Media Fragments URI</h3>

<p>W3C Media Fragments Working Group extends URI defined in <a class='info' href='#RFC3986'>[RFC3986]<span> (</span><span class='info'>Berners-Lee, T., Fielding, R., and L. Masinter, &ldquo;Uniform Resource Identifier (URI): Generic Syntax,&rdquo; January&nbsp;2005.</span><span>)</span></a>and specifies some new semantics of URI
        fragments and URI queries <a class='info' href='#MediaFragments'>[MediaFragments]<span> (</span><span class='info'>W3C, &ldquo;Media Fragments,&rdquo; .</span><span>)</span></a> which
        is used to identify media fragments. The client can use such Media
        Fragments URI component to retrieve one fragment following the
        previous fragment from the server. However such component is not
        extensible to convey more important streaming information about
        bandwidth utilization, quality control and buffer management.
        Therefore it is a big challenge to use the existing web infrastructure
        with such component to deliver streaming contents with QoE
        guaranteed.
</p>
<a name="anchor8"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.2"></a><h3>4.2.&nbsp;
Media Presentation Description</h3>

<p> <a class='info' href='#I.D-pantos-http-live-streaming'>[I.D&#8209;pantos&#8209;http&#8209;live&#8209;streaming]<span> (</span><span class='info'>Pantos, R. and W. May, &ldquo;HTTP Live Streaming,&rdquo; June&nbsp;2010.</span><span>)</span></a>formerly
        defines media presentation format by extending M3U Playlist files and
        defining additional flags. 3GPP TS 26.234 also centers around media
        presentation format and specifies Semantics of Media presentation
        description for HTTP Adaptive Streaming <a class='info' href='#TS26.234'>[TS26.234]<span> (</span><span class='info'>3GPP Standard, &ldquo;Transparent end-to-end Packet-switched Streaming Service           (PSS);Protocols and codecs (Release 9),&rdquo; March&nbsp;2010.</span><span>)</span></a>, which contains metadata required by the
        client(i.e., Smartphone) to construct appropriate URIs <a class='info' href='#RFC3986'>[RFC3986]<span> (</span><span class='info'>Berners-Lee, T., Fielding, R., and L. Masinter, &ldquo;Uniform Resource Identifier (URI): Generic Syntax,&rdquo; January&nbsp;2005.</span><span>)</span></a>to access segments and to provide the
        streaming service to the user. We refer to this media presentation
        description as playlist component. With such component support, client
        can poll the new data in chunks one by one. However without client
        request using HTTP, the server will not push the new data to the
        client, therefore it may not meet the real-time requirements when
        streaming live media to clients only relying on client poll model to
        deliver high quality streaming contents across the best-effort
        Internet, especially when experiencing network transition. More survey
        on MPD and client pull model can be found in <a class='info' href='#GapAnalysis'>[GapAnalysis]<span> (</span><span class='info'>Zong, N., &ldquo;Survey and Gap Analysis for HTTP Streaming Systems,&rdquo; October&nbsp;2010.</span><span>)</span></a>
</p>
<a name="anchor9"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.3"></a><h3>4.3.&nbsp;
Playback Control on media fragments</h3>

<p>W3C HTML5 Working Group has incorporated video playback features
        into HTML5 Specification which we refer to as local playback control.
        Such local playback capability has been previously dependent on
        third-party browser plug-ins. Now HTML5 specification lifts video
        playback out of the generic &lt;object&gt; element and put it into
        specialized &lt;video&gt; handlers. With such playback control
        support, implementers can choose to create their own controls with
        plain old HTML, CSS, and JavaScript. However this playback control can
        not be used to control streaming contents which are not downloaded to
        the browser client. Another example of playback control is trick mode
        support specified in 3GPP HTTP Adaptive Streaming <a class='info' href='#TS26.234'>[TS26.234]<span> (</span><span class='info'>3GPP Standard, &ldquo;Transparent end-to-end Packet-switched Streaming Service           (PSS);Protocols and codecs (Release 9),&rdquo; March&nbsp;2010.</span><span>)</span></a>, where the client can implement seeking by
        locating the corresponding chunk by using the information acquired in
        MPD. More survey on playback control can also be found in
        [GapAnalysis]
</p>
<a name="anchor10"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.4"></a><h3>4.4.&nbsp;
Server Push</h3>

<p>W3C Server Sent Push specification defines an API for opening an
        HTTP connection for receiving push notifications from a server.
        However there is no server-push protocol to be defined in IETF, which
        can be used to work with Server Sent Push API developed by W3C. IETF
        Hybi working group specifies websocket protocol, as one complementary
        work, W3C specifies websocket API. This websocket technology provides
        two-way communication with servers that does not rely on opening
        multiple HTTP connections. However it still lacks capability to push
        real time streaming data from the server-side to the client.
</p>
<a name="anchor11"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.5"></a><h3>4.5.&nbsp;
Existing HTTP Streaming Model(Client Pull Model)</h3>

<p>In the HTTP Streaming Pull model, the Distribution component does
        not take a stab into HTTP Streaming traffic. The Streaming Content
        flows directly from the server to the Client. Adaptive HTTP Streaming
        specified in 3GPP is one typical example of pull model. In the
        adaptive HTTP Streaming, the video streaming application is decoupled
        from existing web infrastructure However, how the streaming contents
        is distributed from dedicated streaming server to HTTP Server is
        unspecified. This put Streaming live video feeds problematic. Internet
        streams created from live video feeds are usually fraught with
        glitches and interruptions. Once again, image quality, size and
        features are sacrificed because of limited encoding CPU resources and
        the absolute need to “keep up” with the live feed.
</p><br /><hr class="insert" />
<a name="fig5"></a>
<div style='display: table; width: 0; margin-left: auto; margin-right: auto'><pre>
  Streaming                                       +-   HTTP  -+
 + Server  --+                                   Streaming Client
 |           |                                    |  +------+ |
 | +-------+ |                     HTTP           |  | HTTP | |
 | | Media | |                     Proxy          |  |Client| |
 | |Encoder| |       +------+      +------+       |  +------+ |
 | +-------+ |       | HTTP |------+------+------&gt;|           |
 |+---------+|       |Server|&lt;-----+------+-------|           |
 ||Streaming||       +------+      +------+       |+---------+|
 ||Segmenter||                                    ||Streaming||
 |+---------+|                                    ||  Client ||
 |           |                                    |+---------+|
 |           |                                    |           |
 +-----------+                                    +-----------+
</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;5: Pull model for HTTP Streaming&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<a name="anchor12"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5"></a><h3>5.&nbsp;
Analysis of different use cases</h3>

<a name="anchor13"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.1"></a><h3>5.1.&nbsp;
Live Streaming Media broadcast</h3>

<p>Today, live video streaming technologies are widely used in
        broadcasting news, connecting friends and relatives in online chat
        rooms, conducting businesses online face to face, selling products and
        services, teaching online courses, monitoring properties, showing
        movies online, and so on. Current HTTP streaming (both live streaming
        and VoD) is based on the pull model in which the client pulls a
        sequence of chunks one after another from the server, based on the
        manifest file produced by the server describing currently available
        chunks. The pull model gives a better control of media delivery,
        better handling of chunk scheduling, as well as buffer management on
        the client's side. In the case of live streaming, the server will need
        to update the manifest file frequently once a new chunk of live media
        becomes available. This may cause a major concern in time-sensitive
        scenario. There will be two additional round trips between the client
        and the server for manifest file update before the client can request
        each new chunk, which could risk the real-time feature of live
        streaming.
</p>
<p>HTTP server push model, on the other hand, enables the server to
        actively and continuously push chunks to the client once a new chunk
        is available on the server, without the round trips between the client
        and the server for manifest file update. In this sense, push model
        could be more efficient and a better candidate for time-sensitive
        scenario.
</p>
<a name="anchor14"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.2"></a><h3>5.2.&nbsp;
“Multi-Screen” Service Delivery</h3>

<p>With the existing deployment today, the services like Network DVR
        and TV/Video anywhere are generally limited as to the types of device
        that they support, or the level of integration and interactivity
        between screens. “Multi-Screen” Service provides a common user
        experience across PCs, TVs, Smartphones, Tablets that enable consumers
        to access the same media content and quality of experience (QoE) on
        any device, anytime and anywhere. Such multi-Screen Experience is
        lacking for end user in the services like Network DVR and TV/Video
        anywhere. Since all the clients have browser support, it is obviously
        one best choice to choose HTTP Streaming to deliver Multi-Screen
        Service. However utilizing HTTP Streaming to deliver Multi-Screen
        Service and meet the real time streaming requirements face several
        great challenges, which include:<br />
<br />
</p>
<blockquote class="text"><dl>
<dt>Startup delay:</dt>
<dd><br />

<ul class="text">
<li>Compared to the dedicated IPTV system, the HTTP streaming
                based on the best-effort Internet may suffer more from network
                transition. Although the client buffer can mitigate the
                overall effect of network transition, there is lack of
                guarantee on startup delay, which is an important QoE metric.
                For example, when a user switches live channel, the current
                group of pictures (GoP) and initialization information for
                decoders (a.k.a. Reference Information (RI)) of the media
                content need to be acquired by the client ASAP to start
                playback. Rapid Acquisition of Multicast Session (RAMS) [RAMS]
                defined in IETF AVT WG aims to address the similar problem in
                the case of MPEG2-TS over RTP transmission by storing the
                important RTP packets for quick startup in intermediary node
                and feeding the packets to the client with high priority.
                Unfortunately, there is no mechanism so far to improve the
                transmission of the important HTTP packets, hence may
                introduce a long delay to start the playback in the scenario
                of HTTP streaming.<br />
<br />

</li>
<li>With the intermediary nodes, it is possible that the
                important HTTP packets, e.g. those including current GoP and
                RI of the media content can be stored before the client
                switches live channel or start VoD. Then it could be possible
                to reduce the startup delay on the client by transmitting
                these packets to the client from the intermediaries, which are
                closer to the client than the normal HTTP server. Furthermore,
                the intermediaries could transmit these packets with higher
                priority than other HTTP packets, or faster than playback
                bit-rate, to achieve further QoE enhancement on the client
                side.<br />
<br />

</li>
</ul>
</dd>
<dt>QoE feedback:</dt>
<dd><br />

<blockquote class="text"><dl>
<dt></dt>
<dd>In IPTV system, RTCP is responsible for sending the
                feedback about the media transmission quality to the media
                server. In the case of HTTP streaming, due to reliable data
                transmission provided by TCP, QoE metrics related to data
                transport such as packet loss are not relevant. However, some
                QoE metrics at session level, such as startup delay are still
                important to the HTTP streaming system for monitoring or
                diagnostic purpose. Unfortunately, there is no such quality
                monitoring mechanisms (e.g. like RTCP report) in current HTTP
                streaming system. To provide a high-quality service for the
                user, monitoring and analyzing the system's overall
                performance is extremely important, since offering the
                performance monitoring capability can help diagnose the
                potential network impairment. Furthermore QoE feedback
                mechanisms will facilitate in root cause analysis and verify
                compliance of service level agreements (SLAs) between service
                providers and users.<br />

</dd>
</dl></blockquote>
</dd>
</dl></blockquote>

<a name="anchor15"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.3"></a><h3>5.3.&nbsp;
Content Publishing between Servers</h3>

<p>HTTP Streaming can be used in the CDN to optimize content delivery.
        Content Publisher may utilize HTTP Streaming to publish the popular
        contents on the Streaming sever to the Web Server or Proxy, which, in
        turn, reduce bandwidth requirements and server load, improve the
        client response times for content stored in the cache. Also when the
        web cache fails to provide the contents that have greatest demand to
        the requester (e.g., Client), the web cache can use HTTP Streaming
        protocol to retrieve the contents from the web server and cache them
        on the web proxy waiting for the next request from the requester.
</p>
<a name="anchor16"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6"></a><h3>6.&nbsp;
Aspects of Problem</h3>

<p>The Real time streaming service (e.g., RTSP) is superior in handling
      thousands of concurrent streams simultaneously, e.g., flexible responses
      to network congestion, efficient bandwidth utilization, and high quality
      performance. However streaming long duration and high quality media over
      the internet to offer TV experience at any device and satisfy the real
      time streaming requirements faces several unique Challenges. 
</p>
<a name="anchor17"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.1"></a><h3>6.1.&nbsp;
Inefficient Streaming Content Delivery</h3>

<p>HTTP is not streaming protocol but can be used to distribute small
        chunked contents in order, e.g., transmit any media contents relying
        on time-based operation. However Client polling for each new data in
        chunks may not be efficient way to deliver high-quality streaming
        video content across the Internet for the following reasons:<br />
<br />
</p>
<ul class="text">
<li>Clients today send a significant amount of redundant data in
            the form of HTTP headers. Because a single web page may require 50
            or 100 sub-requests, this data is significant. It is desirable to
            compress the headers which may save a significant amount of
            latency and bandwidth compared to HTTP.<br />
<br />

</li>
<li>Clients can not request certain resources to be delivered
            first. This may cause the problem of congesting the network
            channel with non-critical resources when a high-priority request
            is pending.<br />
<br />

</li>
<li>HTTP relies solely on multiple connections for concurrency.
            This causes several problems, including additional round trips for
            connection setup, slow-start delays, and a constant rationing by
            the client where it tries to avoid opening too many connections to
            a single server.<br />
<br />

</li>
<li>Since HTTP is operated over TCP, it is much more likely to
            cause major packet drop-outs and greater delay due to TCP with the
            characteristic which keeps TCP trying to resend the lost packet
            before sending anything further. Thus HTTP streaming protocols
            suffer from the inefficient communication established by TCP’s
            design and they are not well suited for delivering nearly the same
            amount of streams as UDP transmission or RTSP transmission. When
            network congestion happens, the transport may be degraded due to
            poor communication between client and server or slow response of
            the server for the transmission rate changes.<br />
<br />

</li>
<li>Client polling may keep waiting for the arrival of data in
            response to the previous request before sending the next new
            request.<br />
<br />

</li>
<li>In the case of live streaming, the server will need to update
            the manifest file frequently once a new chunk of live media
            becomes available. This may cause a major concern in
            time-sensitive scenario. There will be additional round trips
            between the client and the server for manifest file update before
            the client can request each new chunk, which could risk the
            real-time feature of live streaming.<br />
<br />

</li>
</ul>

<p>Therefore it is desirable to offer better transport for streaming
        contents delivery.
</p>
<a name="anchor18"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.2"></a><h3>6.2.&nbsp;
No QoE Guaranteed Support</h3>

<p>Due to the lack of QoE guarantee on the packet switching based
        Internet, the internet streaming can only provide best effort quality
        to consumers.
</p>
<p>This may have the following effects that are not desirable:<br />
<br />
</p>
<ul class="text">
<li>The quality of Internet media streaming may significantly
            degrade due to rising usage and concurrent streaming delivery. The
            Internet traffic generated by HTTP streaming may exhibit
            burstiness extremely or other dynamics changes.<br />
<br />

</li>
<li>The filling of the client play-out buffer, which is used to
            smooth jitter caused by network bandwidth fluctuation, may further
            increase user’s waiting time.<br />
<br />

</li>
<li>Streaming service tends to over-utilize the CPU and bandwidth
            resource to provide better services to end users, which may be not
            desirable and effective way to improve the quality of streaming
            media delivery, in worse case, the server may not have enough
            bandwidth to support all of the client connections. When CPU
            resources are exhausted or insufficient, the server must
            sacrifice/downgrade quality to enable the process to keep pace
            with live contents rendering for viewing. Therefore the content
            owner is forced to limit quality or viewing experience in order to
            support live streams.<br />
<br />

</li>
<li>when MBR(i.e., Multiple Bit Rate) encoding is supported, the
            encoder usually generates multiple streams with different bit
            rates for the same media content, and encapsulates all these
            streams together, which needs additional processing capability and
            a possibly large storage and in worse case, may cause streaming
            session to suffer various quality downgrading, e.g., switching
            from high bit rate stream to low bit rate stream, rebufferring
            when the functionality of MBR is poorly utilized.<br />
<br />

</li>
</ul>

<p>A study conducted by StreamGuard.net examined more than 2,400
        different Internet video streams. They concluded that:<br />
<br />
</p>
<ul class="text">
<li>51% of stream viewers were frustrated with the
            experience.<br />
<br />

</li>
<li>17% of streams have an immediate fatal error.<br />
<br />

</li>
<li>25% take between 5 and 10 seconds to start playing, and stop to
            rebuffer before the video is finished.<br />
<br />

</li>
</ul>

<p>With current technologies, dial-up users do not typically attempt
        video streaming and broadband users often give up after prolonged
        waits or unresponsiveness due to regular rebuffering.
</p>
<a name="anchor19"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.3"></a><h3>6.3.&nbsp;
No QoS Control and Feedback Support</h3>

<p>The usage of streaming media is rapidly increasing on the web. To
        provide a high-quality service for the user, QoS control such as
        monitoring and analyzing the system's overall performance is extremely
        important, since offering the performance monitoring capability can
        help diagnose the potential network impairment, facilitate in root
        cause analysis and verify compliance of service level agreements
        (SLAs) between Internet Service Providers (ISPs) and content
        provider.
</p>
<p>In the current HTTP streaming technology, it fails to give the
        server feedback about the experience the user actually had while
        watching a particular video. This is because the server controls all
        processes and it is impossible to track everything from the server
        side.
</p>
<p>Consequently, the server may be paying to stream content that is
        rarely or never watched. Alternatively, the server may have a video
        that continually fails to start or content that rebuffers continually.
        But the Content owner or encoder receives none of this information
        because there is no way to track it.
</p>
<p>Therefore it is desirable to allow the server view detailed
        statistics using the system's extensive network, quality, and usage
        monitoring capabilities. This detailed statistics can be in the form
        of real-time quality of service metrics data.
</p>
<a name="anchor20"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.4"></a><h3>6.4.&nbsp;
No Streaming Content Distribution and Discovery Support</h3>

<p>Unlike standard web pages and graphics and P2P Streaming data,
        streaming video files may not be cacheable by web cache servers on the
        network or by the browser on your local hard drive. Therefore how to
        distribute the streaming video files to the distributed component in
        the Content Delivery Network and how the distribution server serves
        the Client with these streaming video files are still problematic
        issues.
</p>
<a name="anchor21"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.5"></a><h3>6.5.&nbsp;
Lacking Streaming media Synchronization support</h3>

<p>In the push model, the client just passively accepts what the
        server pushes out and always knows how the live stream is progressing.
        However if the client’s clock is running slower than the encoder’s
        clock, buffer overflow will happen, i.e., the client is not consuming
        samples as fast as the encoder is producing them. As samples get
        pushed to the client, more and more get buffered, and the buffer size
        keeps growing over time. This can cause the client to slow down packet
        processing and eventually run out of memory. On the other hand, if a
        client’s clock is running faster than the encoder’s clock, the client
        has to either keep re-buffering or tune down its clock. To detect this
        case, the client needs to distinguish this condition from others that
        could also cause buffer underflow, e.g. network congestion. This
        determination is often difficult to implement in a valid and
        authoritative manner. The client would need to run statistics over an
        extended period of time to detect a pattern that’s most likely caused
        by clock drift rather than something else. Even with that, false
        detection can still happen. 
</p>
<p>In the pull model, the client is the one who initiates all the
        fragment requests and it needs to know the right timing information
        for each fragment in order to do the right scheduling [Smooth
        Streaming]. Given that the server is stateless in the pull model and
        the client could communicate with any server for the same streaming
        session, it has become more challenging. The solution is to always
        rely on the encoder’s clock for computing timing information for each
        fragment and design a timing mechanism that’s stateless and
        cacheable.
</p>
<p>With the pull model for HTTP Streaming, The client is driving all
        the requests and it will only request the fragments that it needs and
        can handle. In other words, the client’s buffer is always synchronized
        to the client’s clock and never gets out of control. Currently most of
        existing streaming schemes are based on pull model. However the side
        effect of this type of clock drift would be that the client could
        slowly fall behind, especially when transitioning from a “live” client
        to a DVR client (playing something stored in the past). 
</p>
<a name="anchor22"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.6"></a><h3>6.6.&nbsp;
No Multicast Support</h3>

<p>HTTP is sent over TCP and only supports unicast which may increase
        processing overhead by 30% in contrast with using multicast
        transmission.
</p>
<a name="anchor23"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.7"></a><h3>6.7.&nbsp;
Inadequate Streaming Playback Control</h3>

<p>Playback control allows user interact with streaming contents to
        control presentation operation (e.g., fast forward, rewind, scrub,
        time-shift, or play in slow motion). RTSP streaming provides such
        capability to control and navigate the streaming session when the
        client receives the streaming contents. Unlike RTSP streaming, current
        HTTP streaming technologies do not provide such capability for
        playback control that users are accustomed to with DVD or television
        viewing, which significantly impacts the viewing experience.
</p>
<p>This also has the following effects that are not desirable:<br />
<br />
</p>
<ul class="text">
<li>When the user requests media fragments that correspond to the
            content’s new time index and the media fragments from that point
            forward, the client can not have the possibility to change the
            time position for playback and select another stream for rendering
            with acceptable quality. <br />
<br />

</li>
<li>The user can not seek through media content whilst viewing the
            content with acceptable quality.<br />
<br />

</li>
<li>When the user requests to watch the relevant fragments rather
            than having to watch the full videos and manually scroll for the
            relevant fragments, the client can not have the possibility of
            jumping to another point within the media clip or between the
            media fragments with acceptable quality (i.e., random
            access).<br />
<br />

</li>
<li>When the media content the user requests to watch is live
            stream and needs to be interrupted in the middle, e.g., when the
            user takes a phone call, the client can not have the possibility
            to pause or resume the streaming session with acceptable quality
            after it has been invoked. <br />
<br />

</li>
<li>When the user begins to see the content at the new time point,
            if the media fragments retrieved when changing position require
            the same quality as the media fragments currently being played, it
            will result in poor user experience with longer startups
            latency.<br />
<br />

</li>
<li>When there are different formats corresponding to the terminal
            capabilities and user preferences available for contents, the
            client has no capability to select one format for which the
            content will be streamed.<br />
<br />

</li>
<li>When the user doesn’t have time to watch all the streaming
            contents and want to skip trivial part and jump to the key part,
            the client does not provide the capability for selective preview
            or navigation control.<br />
<br />

</li>
<li>When the server wants to replace the currently transmitted
            video stream with a lower bit-rate version of the same video
            stream, the server has no capability to notify this to the
            client.<br />
<br />

</li>
</ul>

<a name="anchor24"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7"></a><h3>7.&nbsp;
Scope of the problem</h3>

<p>Goal: Develop interoperable solutions that offer more efficient
      transport for real time streaming media and allows interoperability with
      other existing streaming techniques.
</p>
<p>Possible Directions forward:<br />
<br />
</p>
<ul class="text">
<li>Specify how an application running over HTTP should operate in
          order to be able to support HTTP streaming and avoid certain
          challenges/issues<br />
<br />

</li>
<li>Extend websocket protocol to support HTTP Streaming and avoid
          certain challenges/issues<br />
<br />

</li>
<li>Build a different protocol to HTTP like RTMP for streaming
          data<br />
<br />

</li>
<li>Specify a different transport layer for HTTP to avoid the
          problems<br />
<br />

</li>
<li>Other suggestions from working group via mailing list or ad-hoc
          meeting<br />
<br />

</li>
</ul>

<p>Possible Models to be built:
</p>
<a name="anchor25"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.1"></a><h3>7.1.&nbsp;
Enhanced HTTP Streaming Pull model</h3>

<p>Unlike the basic pull model defined in section 5.1, the interface
        between the Streaming Server and the Distribution Server is defined.
        HTTP Streaming schemes is used for data transport between two servers.
        Also the Distribution Component is introduced with Streaming support
        to provide a "hint" to the server/cache as to which chunk the client
        is likely to request next then the distribution component could elect
        to retrieve that chunk ahead of it actually being requested to keep
        the response latency (or some other factor) more consistent and avoid
        additional bit rate switches. 
</p><br /><hr class="insert" />
<a name="fig6"></a>
<div style='display: table; width: 0; margin-left: auto; margin-right: auto'><pre>
  Streaming             +-Distribution+
 + Server  --+          |  Component  |           HTTP Streaming
 |           |          | +--------+  |           +-- Client--+
 | +-------+ |  HTTP    | |  HTTP  |  |   HTTP    |           |
 | | Media | |Streaming | | Proxy/ |  | Streaming |  +------+ |
 | |Encoder| | Traffic  | | Server |  |  Traffic  |  | HTTP | |
 | +-------+ |---------&gt;| +--------+  |----------&gt;|  |Client| |
 |+---------+|          | +-------+   |           |  +------+ |
 ||Streaming||          | |Network|   |           |           |
 ||Segmenter||&lt;-------- | | Cache |   |&lt;----------|           |
 |+---------+|  Pull    | +-------+   HTTP Request|+---------+|
 | +------+  |          | +---------+ |           ||Streaming||
 | | HTTP |  |          | |Streaming| |           ||  Client ||
 | |Server|  |          | | Engine  | |           |+---------+|
 | +------+  |          | +---------+ |           |           |
 +-----------+          +-------------+           +-----------+
</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;6: Enhanced Pull model with involvement of Distribution Component&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<a name="anchor26"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.2"></a><h3>7.2.&nbsp;
HTTP Streaming Push model</h3>

<p>In the push model, there may have one or more than one Distribution
        Servers placed between HTTP Streaming Server and HTTP Streaming
        Client. 
</p>
<p>When the Distribution Server does not get involved in HTTP
        Streaming, Streaming Content flows directly from the server to the
        Client. The server keeps pushing the latest data packets to the client
        and the client just passively receives everything. The distribution
        server is just responsible for forwarding stream as all the other HTTP
        proxies do. 
</p>
<p>When the Distribution Server gets involved in HTTP Streaming, The
        HTTP Streaming Server keeps pushing the latest data packets to the
        client, in the meanwhile, the HTTP Streaming server may also push the
        data packets to the distribution server for caching when there is
        enough interest from clients on the same streams. When the new client
        requests the same data packets as the previous client and the data
        packets requested is cached on the distribution server, the
        distribution server can terminate this request on behalf of the HTTP
        Streaming server and push the requested data cached on itself to this
        new client.
</p><br /><hr class="insert" />
<a name="fig7"></a>
<div style='display: table; width: 0; margin-left: auto; margin-right: auto'><pre>
  Streaming           +-Distribution+
 + Server  --+        |  Component  |         HTTP Streaming
 |           |        | +--------+  |         +-- Client--+
 | +-------+ |        | |  HTTP  |  |         |           |
 | | Media | |        | | Proxy/ |  |         |  +------+ |
 | |Encoder| |        | | Server |  |         |  | HTTP | |
 | +-------+ |        | +--------+  |         |  |Client| |
 |+---------+|        | +-------+   |         |  +------+ |
 ||Streaming||        | |Network|   |         |           |
 ||Segmenter||        | | Cache |   |         |           |
 |+---------+|        | +-------+   |         |+---------+|
 | +------+  |        | +---------+ |         ||Streaming||
 | | HTTP |  |        | |Streaming| |         ||  Client ||
 | |Server|  |        | | Engine  | |         |+---------+|
 | +------+  |        | +---------+ |         |           |
 +-----------+        +-------------+         +-----------+
                            Push
               ------------------------------&gt;
                Push   HTTP Streaming
              -------&gt;               HTTP Request
                                     &lt;+++++++
                                       Push
                                     --------&gt;
</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;7: Push model for HTTP Streaming&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<a name="anchor27"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.8"></a><h3>8.&nbsp;
Security Considerations</h3>

<p>In order to protect the content against theft or unauthorized use,
      the possible desirable features include:<br />
<br />
</p>
<ul class="text">
<li>Authorize users to view a stream once or an unlimited number of
          times.<br />
<br />

</li>
<li>Permit unlimited viewings but restrict viewing to a particular
          machine, a region of the world, or within a limit period of
          time.<br />
<br />

</li>
<li>Permit viewing but not copying or allow only one copy with a
          timestamp that prevents viewing after a certain time.<br />
<br />

</li>
<li>Charge per view or per unit of time, per episode, or view.<br />
<br />

</li>
</ul>

<a name="anchor28"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.9"></a><h3>9.&nbsp;
Acknowledgement</h3>

<p>The authors would like to thank David A. Bryan, Ning Zong,Bill Ver
      Steeg, Ali Begen, Colin Perkins, Roni Even, Daniel Park, Henry
      Sinnreich, Wenbo Zhu, Lars Eggert, Spencer Dawkins, Ben Niven-Jenkins,
      Marshall Eubanks, Kathy McEwen for their suggestions and inputs on this
      document. Also Thanks Thomas Stockhammer,Luby, Michael, Mark Watson for
      their precious comments.
</p>
<a name="rfc.references"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.10"></a><h3>10.&nbsp;
References</h3>

<a name="rfc.references1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>10.1.&nbsp;Normative References</h3>
<table width="99%" border="0">
<tr><td class="author-text" valign="top"><a name="RFC2326">[RFC2326]</a></td>
<td class="author-text"><a href="mailto:schulzrinne@cs.columbia.edu">Schulzrinne, H.</a>, <a href="mailto:anup@netscape.com">Rao, A.</a>, and <a href="mailto:robla@real.com">R. Lanphier</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc2326">Real Time Streaming Protocol (RTSP)</a>,&rdquo; RFC&nbsp;2326, April&nbsp;1998 (<a href="http://www.rfc-editor.org/rfc/rfc2326.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC2119">[RFC2119]</a></td>
<td class="author-text"><a href="mailto:sob@harvard.edu">Bradner, S.</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>,&rdquo; BCP&nbsp;14, RFC&nbsp;2119, March&nbsp;1997 (<a href="http://www.rfc-editor.org/rfc/rfc2119.txt">TXT</a>, <a href="http://xml.resource.org/public/rfc/html/rfc2119.html">HTML</a>, <a href="http://xml.resource.org/public/rfc/xml/rfc2119.xml">XML</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC1945">[RFC1945]</a></td>
<td class="author-text"><a href="mailto:timbl@w3.org">Berners-Lee, T.</a>, <a href="mailto:fielding@ics.uci.edu">Fielding, R.</a>, and <a href="mailto:frystyk@w3.org">H. Nielsen</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc1945">Hypertext Transfer Protocol -- HTTP/1.0</a>,&rdquo; RFC&nbsp;1945, May&nbsp;1996 (<a href="http://www.rfc-editor.org/rfc/rfc1945.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC3986">[RFC3986]</a></td>
<td class="author-text"><a href="mailto:timbl@w3.org">Berners-Lee, T.</a>, <a href="mailto:fielding@gbiv.com">Fielding, R.</a>, and <a href="mailto:LMM@acm.org">L. Masinter</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc3986">Uniform Resource Identifier (URI): Generic Syntax</a>,&rdquo; STD&nbsp;66, RFC&nbsp;3986, January&nbsp;2005 (<a href="http://www.rfc-editor.org/rfc/rfc3986.txt">TXT</a>, <a href="http://xml.resource.org/public/rfc/html/rfc3986.html">HTML</a>, <a href="http://xml.resource.org/public/rfc/xml/rfc3986.xml">XML</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="TS26.234">[TS26.234]</a></td>
<td class="author-text">3GPP Standard, &ldquo;Transparent end-to-end Packet-switched Streaming Service
          (PSS);Protocols and codecs (Release 9),&rdquo; 3GPP TS 26.234&nbsp;, March&nbsp;2010.</td></tr>
</table>

<a name="rfc.references2"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>10.2.&nbsp;Informative References</h3>
<table width="99%" border="0">
<tr><td class="author-text" valign="top"><a name="RAMS">[RAMS]</a></td>
<td class="author-text">VerSteeg , B., Begen , A., VanCaenegem, T., and Z. Vax, &ldquo;<a href="http://www.ietf.org/internet-drafts/draft-ietf-avt-rapid-acquisition-for-rtp-16.txt">Unicast-Based Rapid Acquisition of Multicast RTP
          Sessions</a>,&rdquo; draft-ietf-avt-rapid-acquisition-for-rtp-16 (work in progress), October&nbsp;2010.</td></tr>
<tr><td class="author-text" valign="top"><a name="I.D-pantos-http-live-streaming">[I.D-pantos-http-live-streaming]</a></td>
<td class="author-text">Pantos, R. and W. May, &ldquo;HTTP Live Streaming,&rdquo; June&nbsp;2010.</td></tr>
<tr><td class="author-text" valign="top"><a name="GapAnalysis">[GapAnalysis]</a></td>
<td class="author-text">Zong, N., &ldquo;Survey and Gap Analysis for HTTP Streaming Systems,&rdquo; October&nbsp;2010.</td></tr>
<tr><td class="author-text" valign="top"><a name="J.1080">[J.1080]</a></td>
<td class="author-text">ITU-T, &ldquo;Quality of experience requirements for IPTV services,&rdquo; Recommendation ITU T G.1080&nbsp;.</td></tr>
<tr><td class="author-text" valign="top"><a name="I-D.ietf-pmol-metrics-framework-02">[I-D.ietf-pmol-metrics-framework-02]</a></td>
<td class="author-text">Clark, A., &ldquo;Framework for Performance Metric Development.&rdquo;</td></tr>
<tr><td class="author-text" valign="top"><a name="HTML5">[HTML5]</a></td>
<td class="author-text">W3C, &ldquo;HTML5,&rdquo; http://www.w3.org/TR/html5/video.html#media-elements&nbsp;.</td></tr>
<tr><td class="author-text" valign="top"><a name="ServerSentEvent">[ServerSentEvent]</a></td>
<td class="author-text">W3C, &ldquo;Server Sent Event,&rdquo; http://www.w3.org/TR/eventsource/&nbsp;.</td></tr>
<tr><td class="author-text" valign="top"><a name="MediaFragments">[MediaFragments]</a></td>
<td class="author-text">W3C, &ldquo;Media Fragments,&rdquo; http://www.w3.org/2008/WebVideo/Fragments/WD-media-fragments-spec/&nbsp;.</td></tr>
<tr><td class="author-text" valign="top"><a name="SmoothStreaming">[SmoothStreaming]</a></td>
<td class="author-text">Microsoft, &ldquo;Smooth Streaming,&rdquo; http://blogs.iis.net/samzhang/archive/2009/03/27/live-smooth-streaming-design-thoughts.aspx&nbsp;.</td></tr>
</table>

<a name="rfc.authors"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>Authors' Addresses</h3>
<table width="99%" border="0" cellpadding="0" cellspacing="0">
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Qin Wu</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Huawei</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">101 Software Avenue, Yuhua District</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Nanjing, Jiangsu  210012</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">China</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:sunseawq@huawei.com">sunseawq@huawei.com</a></td></tr>
<tr cellpadding="3"><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Rachel Huang</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Huawei</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">101 Software Avenue, Yuhua District</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Nanjing, Jiangsu  210012</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">China</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:Rachel@huawei.com">Rachel@huawei.com</a></td></tr>
</table>
</body></html>
