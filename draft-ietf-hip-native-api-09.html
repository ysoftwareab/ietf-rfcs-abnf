<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="en"><head><title>Basic Socket Interface Extensions for Host Identity Protocol (HIP)</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="description" content="Basic Socket Interface Extensions for Host Identity Protocol (HIP)">
<meta name="generator" content="xml2rfc v1.35 (http://xml.resource.org/)">
<meta name="viewport" content="width=600;" />
<style type='text/css'><!--
        body {
                font-family: verdana, charcoal, helvetica, arial, sans-serif;
                font-size: 85%;
		max-width: 40em; 
		color: #000; background-color: #FFF;
                margin: 2em;
        }
        h1, h2, h3, h4, h5, h6 {
                font-family: helvetica, monaco, "MS Sans Serif", arial, sans-serif;
                font-weight: bold; font-style: normal;
        }
        h1 { color: #900; background-color: transparent; text-align: right; }
        h3 { color: #333; background-color: transparent; }

        td.RFCbug {
                font-size: x-small; text-decoration: none;
                width: 30px; height: 30px; padding-top: 2px;
                text-align: justify; vertical-align: middle;
                background-color: #000;
        }
        td.RFCbug span.RFC {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: bold; color: #666;
        }
        td.RFCbug span.hotText {
                font-family: charcoal, monaco, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: normal; text-align: center; color: #FFF;
        }

        table.TOCbug { width: 30px; height: 15px; }
        td.TOCbug {
                text-align: center; width: 30px; height: 15px;
                color: #FFF; background-color: #900;
        }
        td.TOCbug a {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, sans-serif;
                font-weight: bold; font-size: x-small; text-decoration: none;
                color: #FFF; background-color: transparent;
        }

        td.header {
                font-family: arial, helvetica, sans-serif; font-size: x-small;
                vertical-align: top; width: 33%;
                color: #FFF; background-color: #666;
        }
        td.author { font-weight: bold; font-size: x-small; margin-left: 4em; }
        td.author-text { font-size: x-small; }

        /* info code from SantaKlauss at http://www.madaboutstyle.com/tooltip2.html */
        a.info {
                /* This is the key. */
                position: relative;
                z-index: 24;
                text-decoration: none;
        }
        a.info:hover {
                z-index: 25;
                color: #FFF; background-color: #900;
        }
        a.info span { display: none; }
        a.info:hover span.info {
                /* The span will display just on :hover state. */
                display: block;
                position: absolute;
                font-size: smaller;
                top: 2em; left: -5em; width: 15em;
                padding: 2px; border: 1px solid #333;
                color: #900; background-color: #EEE;
                text-align: left;
        }

        a { font-weight: bold; }
        a:link    { color: #900; background-color: transparent; }
        a:visited { color: #633; background-color: transparent; }
        a:active  { color: #633; background-color: transparent; }

        p { margin-left: 2em; margin-right: 2em; }
        p.copyright { font-size: x-small; }
        p.toc { font-size: 85%;
		max-width: 40em; 
		font-weight: bold; margin-left: 3em; }
        table.toc { margin: 0 0 0 3em; padding: 0; border: 0; vertical-align: text-top; }
        td.toc { font-size: 85%;
		max-width: 40em; 
		font-weight: bold; vertical-align: text-top; }

        ol.text { margin-left: 2em; margin-right: 2em; }
        ul.text { margin-left: 2em; margin-right: 2em; }
        li      { margin-left: 3em; }

        /* RFC-2629 <spanx>s and <artwork>s. */
        em     { font-style: italic; }
        strong { font-weight: bold; }
        dfn    { font-weight: bold; font-style: normal; }
        cite   { font-weight: normal; font-style: normal; }
        tt     { color: #036; }
        tt, pre, pre dfn, pre em, pre cite, pre span {
                font-family: "Courier New", Courier, monospace; font-size: small;
        }
        pre {
                text-align: left; padding: 4px;
                color: #000; background-color: #CCC;
        }
        pre dfn  { color: #900; }
        pre em   { color: #66F; background-color: #FFC; font-weight: normal; }
        pre .key { color: #33C; font-weight: bold; }
        pre .id  { color: #900; }
        pre .str { color: #000; background-color: #CFF; }
        pre .val { color: #066; }
        pre .rep { color: #909; }
        pre .oth { color: #000; background-color: #FCF; }
        pre .err { background-color: #FCC; }

        /* RFC-2629 <texttable>s. */
        table.all, table.full, table.headers, table.none {
                font-size: 85%;
		max-width: 40em; 
		text-align: center; border-width: 2px;
                vertical-align: top; border-collapse: collapse;
        }
        table.all, table.full { border-style: solid; border-color: black; }
        table.headers, table.none { border-style: none; }
        th {
                font-weight: bold; border-color: black;
                border-width: 2px 2px 3px 2px;
        }
        table.all th, table.full th { border-style: solid; }
        table.headers th { border-style: none none solid none; }
        table.none th { border-style: none; }
        table.all td {
                border-style: solid; border-color: #333;
                border-width: 1px 2px;
        }
        table.full td, table.headers td, table.none td { border-style: none; }

        hr { height: 1px; }
        hr.insert {
                width: 80%; border-style: none; border-width: 0;
                color: #CCC; background-color: #CCC;
        }
--></style>
</head>
<body>
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<table summary="layout" width="66%" border="0" cellpadding="0" cellspacing="0"><tr><td><table summary="layout" width="100%" border="0" cellpadding="2" cellspacing="1">
<tr><td class="header">Host Identity Protocol</td><td class="header">M. Komu</td></tr>
<tr><td class="header">Internet-Draft</td><td class="header">Helsinki Institute for Information</td></tr>
<tr><td class="header">Intended status: Experimental</td><td class="header">Technology</td></tr>
<tr><td class="header">Expires: March 14, 2010</td><td class="header"> Henderson</td></tr>
<tr><td class="header">&nbsp;</td><td class="header">The Boeing Company</td></tr>
<tr><td class="header">&nbsp;</td><td class="header">September 10, 2009</td></tr>
</table></td></tr></table>
<h1><br />Basic Socket Interface Extensions for Host Identity Protocol (HIP)<br />draft-ietf-hip-native-api-09</h1>

<h3>Status of this Memo</h3>
<p>
This Internet-Draft is submitted to IETF in full
conformance with the provisions of BCP&nbsp;78 and BCP&nbsp;79.
This document may not be modified, and derivative works of it may
not be created, except to format it for publication as an RFC or
to translate it into languages other than English.</p>
<p>
Internet-Drafts are working documents of the Internet Engineering
Task Force (IETF), its areas, and its working groups.
Note that other groups may also distribute working documents as
Internet-Drafts.</p>
<p>
Internet-Drafts are draft documents valid for a maximum of six months
and may be updated, replaced, or obsoleted by other documents at any time.
It is inappropriate to use Internet-Drafts as reference material or to cite
them other than as &ldquo;work in progress.&rdquo;</p>
<p>
The list of current Internet-Drafts can be accessed at
<a href='http://www.ietf.org/ietf/1id-abstracts.txt'>http://www.ietf.org/ietf/1id-abstracts.txt</a>.</p>
<p>
The list of Internet-Draft Shadow Directories can be accessed at
<a href='http://www.ietf.org/shadow.html'>http://www.ietf.org/shadow.html</a>.</p>
<p>
This Internet-Draft will expire on March 14, 2010.</p>

<h3>Copyright Notice</h3>
<p>
Copyright (c) 2009 IETF Trust and the persons identified as the
document authors.  All rights reserved.</p>
<p>
This document is subject to BCP 78 and the IETF Trust's Legal
Provisions Relating to IETF Documents in effect on the date of
publication of this document (http://trustee.ietf.org/license-info).
Please review these documents carefully, as they describe your
rights and restrictions with respect to this document.</p>

<h3>Abstract</h3>

<p>This document defines extensions to the current sockets API for
     the Host Identity Protocol (HIP). The extensions focus on the use of
     public-key based identifiers discovered via DNS resolution, but
     define also interfaces for manual bindings between HITs and
     locators.  With the extensions, the application can also support
     more relaxed security models where the communication can be
     non-HIP based, according to local policies. The extensions in
     this document are experimental and provide basic tools for
     further experimentation with policies.
</p><a name="toc"></a><br /><hr />
<h3>Table of Contents</h3>
<p class="toc">
<a href="#sec:intro">1.</a>&nbsp;
Introduction<br />
<a href="#sec:terminology">2.</a>&nbsp;
Terminology<br />
<a href="#sec:name_res">3.</a>&nbsp;
Name Resolution Process<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec:resolver">3.1.</a>&nbsp;
Interaction with the Resolver<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec:no-resolver">3.2.</a>&nbsp;
Interaction without a Resolver<br />
<a href="#sec:syntax">4.</a>&nbsp;
API Syntax and Semantics<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec:sock">4.1.</a>&nbsp;
Socket Family and Address Structure Extensions<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec:getaddrinfo">4.2.</a>&nbsp;
Extensions to Resolver Data Structures<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec:getsock">4.3.</a>&nbsp;
The Use of getsockname and getpeername Functions<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec:sockopt">4.4.</a>&nbsp;
Selection of Source HIT Type<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec:types">4.5.</a>&nbsp;
Verification of HIT Type<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec:explicit">4.6.</a>&nbsp;
Explicit Handling of Locators<br />
<a href="#anchor1">5.</a>&nbsp;
Summary of New Definitions<br />
<a href="#sec:iana">6.</a>&nbsp;
IANA Considerations<br />
<a href="#sec:security">7.</a>&nbsp;
Security Considerations<br />
<a href="#anchor2">8.</a>&nbsp;
Contributors<br />
<a href="#sec:acknowledgements">9.</a>&nbsp;
Acknowledgements<br />
<a href="#rfc.references1">10.</a>&nbsp;
Normative References<br />
<a href="#rfc.authors">&#167;</a>&nbsp;
Authors' Addresses<br />
</p>
<br clear="all" />

<a name="sec:intro"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1"></a><h3>1.&nbsp;
Introduction</h3>

<p>
This document defines the C-based sockets Application Programming
Interface (API) extensions for handling HIP-based identifiers
explicitly in HIP-aware applications. It is up to the applications, or
high-level programming languages or libraries, to manage the
identifiers. The extensions in this document are mainly related to the
use case in which a DNS resolution step has occurred prior to the
creation of a new socket, and assumes that the system has cached
or is otherwise able to resolve identifiers to locators (IP addresses).
The DNS extensions for HIP are described in <a class='info' href='#RFC5205'>[RFC5205]<span> (</span><span class='info'>Nikander, P. and J. Laganier, &ldquo;Host Identity Protocol (HIP) Domain Name System (DNS) Extensions,&rdquo; April&nbsp;2008.</span><span>)</span></a>.
The extensions also cover the case in which an application may want
to explicitly provide suggested locators with the identifiers, including
supporting the opportunistic case in which the system does not know
the peer host identity.

</p>
<p>The Host Identity Protocol (HIP) <a class='info' href='#RFC4423'>[RFC4423]<span> (</span><span class='info'>Moskowitz, R. and P. Nikander, &ldquo;Host Identity Protocol (HIP) Architecture,&rdquo; May&nbsp;2006.</span><span>)</span></a> proposes
a new cryptographic namespace by separating the roles of end-point
identifiers and locators by introducing a new namespace to the
TCP/IP stack. SHIM6 <a class='info' href='#I-D.ietf-shim6-proto'>[I&#8209;D.ietf&#8209;shim6&#8209;proto]<span> (</span><span class='info'>Nordmark, E. and M. Bagnulo, &ldquo;Shim6: Level 3 Multihoming Shim Protocol for IPv6,&rdquo; February&nbsp;2009.</span><span>)</span></a> is another
protocol based on an identity-locator split.
The APIs specified in this document are specific to HIP, but
have been designed as much as possible so
as not to preclude its use with other protocols. The use of these APIs with
other protocols is, nevertheless, for further study.

</p>
<p>
The APIs in this document are based on IPv6 addresses with the ORCHID prefix
<a class='info' href='#RFC4843'>[RFC4843]<span> (</span><span class='info'>Nikander, P., Laganier, J., and F. Dupont, &ldquo;An IPv6 Prefix for Overlay Routable Cryptographic Hash Identifiers (ORCHID),&rdquo; April&nbsp;2007.</span><span>)</span></a>. ORCHIDs are derived from Host Identifiers
using a hash and fitting the result into an IPv6 address. Such addresses are
called Host Identity Tags (HITs) and they can be distinguished from other
IPv6 addresses via the ORCHID prefix.

</p>
<p>
Applications can observe the HIP layer and its identifiers in the
networking stacks with varying degrees of visibility. <a class='info' href='#RFC5338'>[RFC5338]<span> (</span><span class='info'>Henderson, T., Nikander, P., and M. Komu, &ldquo;Using the Host Identity Protocol with Legacy Applications,&rdquo; September&nbsp;2008.</span><span>)</span></a> discusses the lowest levels
of visibility in which applications are completely unaware of
the underlying HIP layer. Such HIP-unaware applications in some circumstances use HIP-based
identifiers, such as LSIs or HITs, instead of IPv4 or IPv6 addresses
and cannot observe the identifier-locator bindings.

</p>
<p>
This document specifies extensions to <a class='info' href='#RFC3493'>[RFC3493]<span> (</span><span class='info'>Gilligan, R., Thomson, S., Bound, J., McCann, J., and W. Stevens, &ldquo;Basic Socket Interface Extensions for IPv6,&rdquo; February&nbsp;2003.</span><span>)</span></a> to
define a new socket address family, AF_HIP. Similarly to other address
families, AF_HIP can be used as an alias for PF_HIP. The extensions also
describe a new socket address structure for sockets using
HITs explicitly and describe how the socket calls
in <a class='info' href='#RFC3493'>[RFC3493]<span> (</span><span class='info'>Gilligan, R., Thomson, S., Bound, J., McCann, J., and W. Stevens, &ldquo;Basic Socket Interface Extensions for IPv6,&rdquo; February&nbsp;2003.</span><span>)</span></a> are adapted or extended as a result.

</p>
<p>Some applications may accept incoming communications from any
identifier. Other applications may initiate outgoing communications
without the knowledge of the peer identifier in Opportunistic Mode (section 4.1.6 in <a class='info' href='#RFC5201'>[RFC5201]<span> (</span><span class='info'>Moskowitz, R., Nikander, P., Jokela, P., and T. Henderson, &ldquo;Host Identity Protocol,&rdquo; April&nbsp;2008.</span><span>)</span></a>) by just relying on a peer locator.  This
document describes how to address both situations using "wildcards"
as described in <a class='info' href='#sec:wildcards'>Section&nbsp;4.1.1<span> (</span><span class='info'>HIP Wildcard Addresses</span><span>)</span></a>.

</p>
<p>There are two related API documents. Multihoming and explicit
   locator-handling related APIs are defined in <a class='info' href='#I-D.ietf-shim6-multihome-shim-api'>[I&#8209;D.ietf&#8209;shim6&#8209;multihome&#8209;shim&#8209;api]<span> (</span><span class='info'>Komu, M., Bagnulo, M., Slavov, K., and S. Sugimoto, &ldquo;Socket Application Program Interface (API) for Multihoming Shim,&rdquo; February&nbsp;2010.</span><span>)</span></a>. IPsec-related policy
   attributes and channel binding APIs are defined in <a class='info' href='#I-D.ietf-btns-c-api'>[I&#8209;D.ietf&#8209;btns&#8209;c&#8209;api]<span> (</span><span class='info'>Richardson, M., Williams, N., Komu, M., and S. Tarkoma, &ldquo;C-Bindings for IPsec Application Programming Interfaces,&rdquo; March&nbsp;2009.</span><span>)</span></a>. Most of the extensions defined in this
   document can be used independently of the two mentioned API
   documents.

</p>
<p>
The identity-locator split introduced by HIP introduces some policy
related challenges with datagram oriented sockets, opportunistic mode,
and manual bindings between HITs and locators.  The extensions in this
document are of an experimental nature and provide basic tools for
experimenting with policies. Policy related issues are left for
further experimentation.

</p>
<p>
To recap, the extensions in this document have three goals. The first goal
is to allow HIP-aware applications to open sockets to other hosts based on
the HITs alone, presuming that the underlying system can resolve the HITs
to addresses used for initial contact.  The second
goal is that applications can explicitly initiate communications
with unknown peer identifiers.  The third goal is to illustrate how
HIP-aware applications can use the SHIM API
<a class='info' href='#I-D.ietf-shim6-multihome-shim-api'>[I&#8209;D.ietf&#8209;shim6&#8209;multihome&#8209;shim&#8209;api]<span> (</span><span class='info'>Komu, M., Bagnulo, M., Slavov, K., and S. Sugimoto, &ldquo;Socket Application Program Interface (API) for Multihoming Shim,&rdquo; February&nbsp;2010.</span><span>)</span></a> to manually
map locators to HITs.

</p>
<a name="sec:terminology"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2"></a><h3>2.&nbsp;
Terminology</h3>

<p>The terms used in this document are summarized in <a class='info' href='#tbl:terms'>Table&nbsp;1</a>.
</p><br /><hr class="insert" />
<a name="tbl:terms"></a>
<table class="full" align="center" border="0" cellpadding="2" cellspacing="2">
<col align="left"><col align="left">
<tr><th align="left">Term</th><th align="left">Explanation</th></tr>
<tr>
<td align="left">HIP</td>
<td align="left">Host Identity Protocol</td>
</tr>
<tr>
<td align="left">HIT</td>
<td align="left">Host Identity Tag, a 100-bit hash of a public key with a 28 bit prefix</td>
</tr>
<tr>
<td align="left">LSI</td>
<td align="left">Local Scope Identifier, a local, 32-bit descriptor for a given 
          public key.</td>
</tr>
<tr>
<td align="left">Locator</td>
<td align="left">Routable IPv4 or IPv6 address used at the lower layers</td>
</tr>
</table>
<br clear="all" />
<table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Table 1&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<a name="sec:name_res"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3"></a><h3>3.&nbsp;
Name Resolution Process</h3>

<p>This section provides an overview of how the API can be used.  First,
       the case in which a resolver is involved in name resolution is
       described, and then the case in which no resolver is involved
       is described.
    
</p>
<a name="sec:resolver"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.1"></a><h3>3.1.&nbsp;
Interaction with the Resolver</h3>

<p>Before an application can establish network communications with
       the entity named by a given FQDN or relative host name, the
       application must translate the name into the corresponding
       identifier(s). DNS-based hostname-to-identifier translation is
       illustrated in <a class='info' href='#fig:resolver_path'>Figure&nbsp;1</a>. The
       application calls the resolver in step (a) to resolve an FQDN
       to one or more socket addresses within the PF_HIP family.
       The resolver, in turn, queries the DNS in step (b) to
       map the FQDN to
       one or more HIP RRs with the HIT and HI and possibly rendezvous
       server of the Responder, and also (in parallel or sequentially) to
       resolve the FQDN into possibly one or more A and AAAA records.
       It should be noted that the FQDN may map to
       multiple host identifiers and
       locators, and this step may involve multiple DNS transactions,
       including queries for A, AAAA, HI and possibly other resource records.
       The DNS server responds with a list of HIP resource records
       in step (c). Optionally in step (d), the
       resolver caches the HIT-to-locator mapping with the HIP
       module. The resolver converts the HIP records to HITs and
       returns the HITs to the application contained in
       HIP socket address structures
       in step (e). Depending on the parameters for the resolver call,
       the resolver may return also other socket address structures
       to the application.
       Finally, the application receives the socket address structure(s)
       from the resolver and uses them in socket calls such as connect()
       in step (f).
    
</p><br /><hr class="insert" />
<a name="fig:resolver_path"></a>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
                                           +----------+
                                           |          |
                                           |   DNS    |
                                           |          |
                                           +----------+
                                               ^  |
                                b. QNAME=FQDN  |  | c. HIP and
                                               |  |    A/AAAA
                                               |  v    RR(s)
    +-------------+ a. getaddrinfo(&lt;FQDN&gt;)  +----------+
    |             |------------------------&gt;|          |
    | Application |                         | Resolver |
    |             |&lt;------------------------|          |
    +-------------+        e. &lt;HITs&gt;        +----------+
            |                                    |
            |                                    | d. HIP and
            | f. connect(&lt;HIT&gt;)                  |    A/AAAA
            |    or any other socket call        |    RR(s)
            v                                    v
     +----------+                           +----------+
     |          |                           |          |
     |  TCP/IP  |                           |   HIP    |
     |  Stack   |                           |          |
     +----------+                           +----------+
</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;1&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>
In practice, the resolver functionality can be implemented in different
ways. For example, it may be implemented in existing resolver
libraries or as a HIP-aware interposing agent.

</p>
<a name="sec:no-resolver"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.2"></a><h3>3.2.&nbsp;
Interaction without a Resolver</h3>

<p>
The extensions in this document focus on the use of the resolver to
map host names to HITs and locators in HIP-aware applications.
The resolver may implicitly associate a HIT with the corresponding
locator(s) by communicating the HIT-to-IP mapping to the
HIP daemon. However, it is possible that an application operates
directly on a peer HIT without interacting with the resolver. In
such a case, the application may resort to the system to map the peer
HIT to an IP address. Alternatively, the application can explicitly
map the HIT to an IP address using socket options as specified in <a class='info' href='#sec:explicit'>Section&nbsp;4.6<span> (</span><span class='info'>Explicit Handling of Locators</span><span>)</span></a>. Full support for all of
the extensions defined in this draft requires a number of shim socket options
<a class='info' href='#I-D.ietf-shim6-multihome-shim-api'>[I&#8209;D.ietf&#8209;shim6&#8209;multihome&#8209;shim&#8209;api]<span> (</span><span class='info'>Komu, M., Bagnulo, M., Slavov, K., and S. Sugimoto, &ldquo;Socket Application Program Interface (API) for Multihoming Shim,&rdquo; February&nbsp;2010.</span><span>)</span></a> to be implemented by
the system.

</p>
<a name="sec:syntax"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4"></a><h3>4.&nbsp;
API Syntax and Semantics</h3>

<p>In this section, we describe the native HIP APIs using the
       syntax of the C programming language. We limit the description
       to the interfaces and data structures that are either modified
       or completely new because the native HIP APIs are otherwise
       identical to the sockets API <a class='info' href='#POSIX'>[POSIX]<span> (</span><span class='info'>Institute of Electrical and Electronics Engineers, &ldquo;IEEE Std. 1003.1-2001 Standard for Information Technology -                Portable Operating System Interface (POSIX),&rdquo; Dec&nbsp;2001.</span><span>)</span></a>.
       
</p>
<a name="sec:sock"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.1"></a><h3>4.1.&nbsp;
Socket Family and Address Structure Extensions</h3>

<p>The sockets API extensions define a new protocol family, PF_HIP, and
        a new address family, AF_HIP.   The AF_HIP and PF_HIP constants are aliases to
        each other.  These definitions shall be defined as a result of including
        &lt;sys/socket.h&gt;.
</p>
<p>When the socket() function is called with PF_HIP as the first argument (domain), it attempts to create a socket for HIP communication.
     If HIP is not supported, socket() follows its default behaviour and returns -1 and sets errno to EAFNOSUPPORT.
</p>
<p><a class='info' href='#fig:sockaddr_hip'>Figure&nbsp;2</a> shows the recommended implementation of the socket address
        structure for HIP in POSIX.1.g format.
</p><br /><hr class="insert" />
<a name="fig:sockaddr_hip"></a>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
        #include &lt;netinet/hip.h&gt;

        typedef struct in6_addr hip_hit_t;

        struct sockaddr_hip {
                  uint8_t        ship_len;
                  sa_family_t    ship_family;
                  in_port_t      ship_port;
                  uint32_t       ship_flags;
´                 hip_hit_t      ship_hit;
        };
</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;2&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>uint8_t ship_len:
       This field is optional in POSIX.1.g (and 4.3BSD-RENO).
       The field defines the length of the structure. Implementations that
       do not define this field typically embed the information in the
       following ship_family field.
    
</p>
<p>sa_family_t ship_family:
      This mandatory field identifies this as a sockaddr_hip structure.
      It overlays the sa_family field of the sockaddr structure.
      Its value must be AF_HIP.
</p>
<p>in_port_t ship_port:
      This mandatory field contains the transport protocol port number.
      It is handled in the same way as the sin_port field of the sockaddr_in structure.
      The port number is stored in network byte order.
</p>
<p>uint32_t ship_flags:
      This mandatory bit field contains auxiliary flags.
      This document does not define any flags.
      This field is included for future extensions.
</p>
<p>hip_hit_t ship_hit:
      This mandatory field contains the end-point identifier.
      When the system passes a sockaddr_hip structure to the application, the value of this field is set to a valid HIT, IPv4, or IPv6 address, as discussed in <a class='info' href='#sec:types'>Section&nbsp;4.5<span> (</span><span class='info'>Verification of HIT Type</span><span>)</span></a>.
      When the application passes a sockaddr_hip structure to the system, this field must be set to a HIT or a wildcard address as discussed in <a class='info' href='#sec:wildcards'>Section&nbsp;4.1.1<span> (</span><span class='info'>HIP Wildcard Addresses</span><span>)</span></a>.
</p>
<p>Some applications rely on system level access control, either
        implicit or explicit (such as the accept_filter() function found on
        BSD-based systems), but such discussion is out of scope.
        Other applications implement access control
        themselves by using the HITs.

        Applications operating on sockaddr_hip structures can use memcmp()
        or similar function to compare the ship_hit fields.



        It should be also noted that different connection attempts between
        the same two hosts can result in different HITs because a host
        is allowed to have multiple HITs.
     
</p>
<a name="sec:wildcards"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.1.1"></a><h3>4.1.1.&nbsp;
HIP Wildcard Addresses</h3>

<p>HIP wildcard addresses are similar to IPv4 and IPv6 wildcard addresses.
    They can be used instead of specific HITs in the ship_hit field for local and remote end-points in socket API calls such
    as bind(), connect(), sendto(), sendmsg().
</p>
<p>In order to bind to all local IPv4 and IPv6 addresses and HIP HITs, the ship_hit field must be set to HIP_ENDPOINT_ANY.
    In order to bind to all local HITs, ship_hit must contain HIP_HIT_ANY.
    To only bind to all local public HITs, the ship_hit field must be HIP_HIT_ANY_PUB.
    The value HIP_HIT_ANY_TMP binds a socket to all local anonymous identifiers only as specified in <a class='info' href='#RFC4423'>[RFC4423]<span> (</span><span class='info'>Moskowitz, R. and P. Nikander, &ldquo;Host Identity Protocol (HIP) Architecture,&rdquo; May&nbsp;2006.</span><span>)</span></a>.

    The system may label anonymous identifiers as such depending on whether they have been published or not.
    After binding a socket via one of the HIP_HIT_ANY_* wildcard addresses, the application is guaranteed to receive only HIP-based data flows.
    With the HIP_ENDPOINT_ANY wildcard address, the socket accepts HIP, IPv6, and IPv4-based data flows.
</p>
<p>When a socket is bound or connected via a sockaddr_hip structure, i.e. the PF_HIP protocol family, the system returns only addresses of the AF_HIP family, i.e. sockaddr_hip structures, for this socket.
    This applies to all functions which provide addresses to the application, such as accept() or recvfrom().
    If the data flow is based on HIP, the ship_hit field contains the peer's HIT.
    For a non-HIP IPv6 data flow, the field contains the peer's IPv6 address.
    For a non-HIP IPv4 data flow, the field contains the peer's IPv4 address in IPv4-mapped IPv6 address format as described in section 3.7 of <a class='info' href='#RFC3493'>[RFC3493]<span> (</span><span class='info'>Gilligan, R., Thomson, S., Bound, J., McCann, J., and W. Stevens, &ldquo;Basic Socket Interface Extensions for IPv6,&rdquo; February&nbsp;2003.</span><span>)</span></a>.
    <a class='info' href='#sec:types'>Section&nbsp;4.5<span> (</span><span class='info'>Verification of HIT Type</span><span>)</span></a> describes how the application can verify the type of the address returned by the socket API calls.
</p>
<p>An application uses the socket API as follows to set up a connection or to send messages in HIP Opportunistic Mode (cf. <a class='info' href='#RFC5201'>[RFC5201]<span> (</span><span class='info'>Moskowitz, R., Nikander, P., Jokela, P., and T. Henderson, &ldquo;Host Identity Protocol,&rdquo; April&nbsp;2008.</span><span>)</span></a>).
    First, the application associates a socket with at least one IP address of the destination peer via setting the SHIM_LOCLIST_PEER_PREF socket option.
    It then uses outgoing socket functions such as connect(), sendto(), or sendmsg() with the HIP_ENDPOINT_ANY or HIP_HIT_ANY wildcard address in the ship_hit field of the sockaddr_hip structure.
    With the HIP_HIT_ANY address,
    the underlying system allows only HIP-based data flows with the
    corresponding socket.  For incoming packets, the system
    discards all non-HIP-related traffic arriving at the socket.
    For outgoing packets, the system returns -1 in the socket call and
    sets errno to an appropriate error type when the system failed to
    deliver the packet over
    a HIP-based data channel.
    The semantics of using the HIP_ENDPOINT_ANY are the subject of further experimentation in the context of opportunistic mode.
    Such use may result in a data flow either with or without HIP.
</p>
<a name="sec:getaddrinfo"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.2"></a><h3>4.2.&nbsp;
Extensions to Resolver Data Structures</h3>

<p>The HIP APIs introduce a new address family, AF_HIP, that
         HIP-aware applications can use to control the address type returned
         from the getaddrinfo() function <a class='info' href='#RFC3493'>[RFC3493]<span> (</span><span class='info'>Gilligan, R., Thomson, S., Bound, J., McCann, J., and W. Stevens, &ldquo;Basic Socket Interface Extensions for IPv6,&rdquo; February&nbsp;2003.</span><span>)</span></a>.
         The getaddrinfo() function uses a data structure called addrinfo
         in its "hints" and "res" argument which is described in more
         detail in the next section. The addrinfo data structure is
         illustrated in <a class='info' href='#fig:addrinfo'>Figure&nbsp;3</a>.
      
</p><br /><hr class="insert" />
<a name="fig:addrinfo"></a>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
       #include &lt;netdb.h&gt;

       struct addrinfo {
           int       ai_flags;          /* e.g. AI_CANONNAME */
           int       ai_family;         /* e.g. AF_HIP */
           int       ai_socktype;       /* e.g. SOCK_STREAM */
           int       ai_protocol;       /* 0 or IPPROTO_HIP */
           socklen_t ai_addrlen;        /* size of *ai_addr  */
           struct    sockaddr *ai_addr; /* sockaddr_hip */
           char     *ai_canonname;     /* canon. name of the host */
           struct    addrinfo *ai_next; /* next endpoint */
           int       ai_eflags;         /* RFC5014 extension */
       };
</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;3&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>
        An application resolving with the ai_family field set to
        AF_UNSPEC in the hints argument may receive any kind of socket
        address structures, including sockaddr_hip.  When the
        application wants to receive only HITs contained in
        sockaddr_hip structures, it should set the ai_family field to
        AF_HIP.
        Otherwise, the resolver does not return any sockaddr_hip structures.
        The resolver returns EAI_FAMILY when AF_HIP is not supported.
     
</p>
<p>The resolver ignores the AI_PASSIVE flag when the application sets the family
        in hints to AF_HIP.
     
</p>
<p>
         The system may have a HIP-aware interposing DNS agent as
         described in section 3.2 in <a class='info' href='#RFC5338'>[RFC5338]<span> (</span><span class='info'>Henderson, T., Nikander, P., and M. Komu, &ldquo;Using the Host Identity Protocol with Legacy Applications,&rdquo; September&nbsp;2008.</span><span>)</span></a>. In
         such a case, the DNS agent may, according to local policy, return
         transparently LSIs or HITs
         in sockaddr_in and sockaddr_in6 structures when available.
         A HIP-aware application can override this local policy in two ways.
         First, the application can set the family to AF_HIP in the hints
         argument of getaddrinfo() when it requests only sockaddr_hip
         structures. Second, the application can set
         AI_NO_HIT flag to prevent the resolver from returning HITs in
         any kind of data structures.
      
</p>
<p>
	 When getaddrinfo() returns resolved outputs in the output "res" argument,
         it sets the family to AF_HIP when the related structure is
         sockaddr_hip.
      
</p>
<a name="sec:resolver_usage"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.2.1"></a><h3>4.2.1.&nbsp;
Resolver Usage</h3>

<p>A HIP-aware application creates the sockaddr_hip structures
	 manually or obtains them from the resolver. The explicit
	 configuration of locators is described in <a class='info' href='#I-D.ietf-shim6-multihome-shim-api'>[I&#8209;D.ietf&#8209;shim6&#8209;multihome&#8209;shim&#8209;api]<span> (</span><span class='info'>Komu, M., Bagnulo, M., Slavov, K., and S. Sugimoto, &ldquo;Socket Application Program Interface (API) for Multihoming Shim,&rdquo; February&nbsp;2010.</span><span>)</span></a>. This document
	 defines "automated" resolver extensions for getaddrinfo()
	 resolver <a class='info' href='#RFC3493'>[RFC3493]<span> (</span><span class='info'>Gilligan, R., Thomson, S., Bound, J., McCann, J., and W. Stevens, &ldquo;Basic Socket Interface Extensions for IPv6,&rdquo; February&nbsp;2003.</span><span>)</span></a>. Other resolver calls, such
	 as gethostbyname() and getservbyname() are not defined in this
	 document. The getaddrinfo resolver interface is shown in
	 <a class='info' href='#fig:getaddrinfo'>Figure&nbsp;4</a>.
</p><br /><hr class="insert" />
<a name="fig:getaddrinfo"></a>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
        #include &lt;netdb.h&gt;

        int getaddrinfo(const char *nodename,
                        const char *servname,
                        const struct addrinfo *hints,
                        struct addrinfo **res)
        void free_addrinfo(struct addrinfo *res)
</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;4&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>As described in <a class='info' href='#RFC3493'>[RFC3493]<span> (</span><span class='info'>Gilligan, R., Thomson, S., Bound, J., McCann, J., and W. Stevens, &ldquo;Basic Socket Interface Extensions for IPv6,&rdquo; February&nbsp;2003.</span><span>)</span></a>, the getaddrinfo()
           function takes the nodename, servname, and hints as its
           input arguments. It places the result of the query into the
           res output argument. The return value is zero on success, or a
           non-zero error value on error. The nodename argument
           specifies the host name to be resolved; a NULL argument
           denotes the HITs of the local host. The servname parameter
           declares the
           port number to be set in the socket addresses in the res
           output argument. Both the nodename and servname cannot be
           NULL at the same time.
</p>
<p>The input argument "hints" acts like a filter that defines
           the attributes required from the resolved endpoints. A NULL
           hints argument indicates that any kind of endpoints are
           acceptable.
</p>
<p>The output argument "res" is dynamically allocated by the
           resolver.  The application frees the res argument with the
           free_addrinfo function. The res argument contains a linked
           list of the resolved endpoints. The linked list contains
           only sockaddr_hip structures when the input argument has
           the family set to AF_HIP. When the family is zero,
           the list contains
           sockaddr_hip structures before sockaddr_in and sockaddr_in6
           structures.
        
</p>
<p>The resolver can return a HIT which maps to multiple
           locators. The resolver may cache the locator mappings with
           the HIP module. The HIP module manages the multiple
           locators according to system policies of the host.  The
           multihoming document <a class='info' href='#I-D.ietf-shim6-multihome-shim-api'>[I&#8209;D.ietf&#8209;shim6&#8209;multihome&#8209;shim&#8209;api]<span> (</span><span class='info'>Komu, M., Bagnulo, M., Slavov, K., and S. Sugimoto, &ldquo;Socket Application Program Interface (API) for Multihoming Shim,&rdquo; February&nbsp;2010.</span><span>)</span></a> describes how
           an application can override system default policies.
        
</p>
<p>
           It should be noted that the application can
           configure the HIT explicitly without setting the locator or
           the resolver can fail to resolve any locator. In this
           scenario, the application relies on the system to map the
           HIT to an IP address. When the system fails to provide the
           mapping, it returns -1 in the called sockets API
           function to the application and sets errno to EADDRNOTAVAIL.
       
</p>
<a name="sec:getsock"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.3"></a><h3>4.3.&nbsp;
The Use of getsockname and getpeername Functions</h3>

<p>The sockaddr_hip structure does not contain a HIT when the
       application uses the HIP_HIT_ANY_* or HIP_ENDPOINT_ANY
       constants. In such a case, the application can discover the
       local and peer HITs using the getsockname() and getpeername()
       functions after the socket is connected.  The functions
       getsockname() and getpeername() always output a sockaddr_hip
       structure when the family of the socket is AF_HIP. The
       application should be prepared to handle also IPv4 and IPv6
       addresses in the ship_hit field as described in
       <a class='info' href='#sec:sock'>Section&nbsp;4.1<span> (</span><span class='info'>Socket Family and Address Structure Extensions</span><span>)</span></a> in the context of the
       HIP_ENDPOINT_ANY constant.
</p>
<a name="sec:sockopt"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.4"></a><h3>4.4.&nbsp;
Selection of Source HIT Type</h3>

<p>A client-side application can choose its source HIT by
       e.g. querying all of the local HITs with getaddrinfo() and
       associating one of them with the socket using bind(). This
       section describes another method for a client-side application
       to affect the selection of the source HIT type where the
       application does not call bind() explicitly. Instead, the
       application just specifies the preferred requirements for the source HIT
       type.
    
</p>
<p>
      The Socket API for Source Address Selection <a class='info' href='#RFC5014'>[RFC5014]<span> (</span><span class='info'>Nordmark, E., Chakrabarti, S., and J. Laganier, &ldquo;IPv6 Socket API for Source Address Selection,&rdquo; September&nbsp;2007.</span><span>)</span></a>
      defines socket options to allow applications to influence source address
      selection mechanisms.  In some cases, HIP-aware applications may
      want to influence source HIT selection; in particular, whether
      an outbound connection should use a published or anonymous HIT.
      Similar to IPV6_ADDR_PREFERENCES defined in <a class='info' href='#RFC5014'>[RFC5014]<span> (</span><span class='info'>Nordmark, E., Chakrabarti, S., and J. Laganier, &ldquo;IPv6 Socket API for Source Address Selection,&rdquo; September&nbsp;2007.</span><span>)</span></a>, the
      socket option HIT_PREFERENCES is defined for
      HIP-based sockets.  This socket option can be used with
      setsockopt() and getsockopt() calls to set and get the HIT
      selection preferences affecting a HIP-enabled socket.  The
      socket option value (optval) is a 32-bit unsigned integer
      argument.  The argument consists of a number of flags where each
      flag indicates an address selection preference that modifies one
      of the rules in the default HIT selection; these flags are shown in
      <a class='info' href='#tbl:src_hit'>Table&nbsp;2</a>.
    
</p><br /><hr class="insert" />
<a name="tbl:src_hit"></a>
<table class="full" align="center" border="0" cellpadding="2" cellspacing="2">
<col align="left"><col align="left">
<tr><th align="left">Socket Option</th><th align="left">Purpose</th></tr>
<tr>
<td align="left">HIP_PREFER_SRC_HIT_TMP</td>
<td align="left">Prefer an anonymous HIT</td>
</tr>
<tr>
<td align="left">HIP_PREFER_SRC_HIT_PUBLIC</td>
<td align="left">Prefer a public HIT</td>
</tr>
</table>
<br clear="all" />
<table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Table 2&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>
     If the system is unable to assign the type of HIT that is
     requested, at HIT selection time, the socket call (connect(),
     sendto(), or sendmsg()) will fail and errno will be set to
     EINVAL.  If the application tries to set both of the above flags
     for the same socket, this also results in the error EINVAL.
   
</p>
<a name="sec:types"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.5"></a><h3>4.5.&nbsp;
Verification of HIT Type</h3>

<p>An application that uses the HIP_ENDPOINT_ANY constant may want to
        check whether the actual communications was based on HIP or not.
        Also, the application may want
        to verify whether a HIT belonging to the local host is public or anonymous. The
        application accomplishes this using a new function called
        sockaddr_is_srcaddr() which is illustrated in <a class='info' href='#fig:sockaddr_is_srcaddr'>Figure&nbsp;5</a>.
     
</p><br /><hr class="insert" />
<a name="fig:sockaddr_is_srcaddr"></a>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
      #include &lt;netinet/hip.h&gt;

      short sockaddr_is_srcaddr(struct sockaddr *srcaddr,
                                uint64_t flags);
</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;5&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>The sockaddr_is_srcaddr() function operates in the same way as the
        inet6_is_srcaddr() function <a class='info' href='#RFC5014'>[RFC5014]<span> (</span><span class='info'>Nordmark, E., Chakrabarti, S., and J. Laganier, &ldquo;IPv6 Socket API for Source Address Selection,&rdquo; September&nbsp;2007.</span><span>)</span></a> which
        can be used to verify the type of an address belonging to the
        local host. The difference is that the sockaddr_is_srcaddr()
        function handles sockaddr_hip structures in addition to
        sockaddr_in6, and possibly other socket structures in
        further extensions. Also, the length of the flags argument is 64-bits instead
        of 32 bits because the new function handles the same flags as
        defined in <a class='info' href='#RFC5014'>[RFC5014]<span> (</span><span class='info'>Nordmark, E., Chakrabarti, S., and J. Laganier, &ldquo;IPv6 Socket API for Source Address Selection,&rdquo; September&nbsp;2007.</span><span>)</span></a> in addition to
        two HIP-specific flags,
        HIP_PREFER_SRC_HIT_TMP and HIP_PREFER_SRC_HIT_PUBLIC. With these
        two flags, the application can distinguish
        anonymous HITs from public HITs.
     
</p>
<p>When given an AF_INET6 socket, sockaddr_is_srcaddr() behaves as
        inet6_is_srcaddr() function as described in <a class='info' href='#RFC5014'>[RFC5014]<span> (</span><span class='info'>Nordmark, E., Chakrabarti, S., and J. Laganier, &ldquo;IPv6 Socket API for Source Address Selection,&rdquo; September&nbsp;2007.</span><span>)</span></a>.
        With an AF_HIP socket, the function returns 1 when the HIT contained in the socket
        address structure corresponds to a valid HIT of the local host and
        the HIT satisfies the given flags.
        The function returns -1 when
        the HIT does not belong to the local host or the flags are not valid.
        The function returns 0 when the preference flags are valid but the
        HIT does not match the given flags.
        The function also returns
        0 on a sockaddr_hip structure containing a HIP_ENDPOINT_ANY or HIP_HIT_ANY_* wildcard.
     
</p>
<p>The sockaddr_is_srcaddr() interface applies only to local HITs.
        Applications can
        call the function hip_is_hit() to verify that the given
        hit_hit_t pointer has the HIT prefix. The
        function is illustrated in <a class='info' href='#fig:sockaddr_is_hit'>Figure&nbsp;6</a>.
     
</p><br /><hr class="insert" />
<a name="fig:sockaddr_is_hit"></a>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
      #include &lt;netinet/hip.h&gt;

      short hip_is_hit(hip_hit_t *hit);
</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;6&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>The hip_is_hit() function returns 1 when the given argument
        contains the HIT prefix. The function returns -1 on error and
        sets errno appropriately.
        The function returns 0 when the argument does not have the HIT prefix.
        The function also returns
        0 when the argument is a HIP_ENDPOINT_ANY or HIP_HIT_ANY_* wildcard.
     
</p>
<a name="sec:explicit"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.6"></a><h3>4.6.&nbsp;
Explicit Handling of Locators</h3>

<p>
         The system resolver, or the HIP module, maps HITs to locators
         implicitly. However, some applications may want to specify
         initial locator mappings explicitly. In such a case, the
         application first creates a socket with AF_HIP as the domain
         argument. Second, the application may get or set locator information
         with one of the following shim socket options
         as defined in the multihoming extensions in <a class='info' href='#I-D.ietf-shim6-multihome-shim-api'>[I&#8209;D.ietf&#8209;shim6&#8209;multihome&#8209;shim&#8209;api]<span> (</span><span class='info'>Komu, M., Bagnulo, M., Slavov, K., and S. Sugimoto, &ldquo;Socket Application Program Interface (API) for Multihoming Shim,&rdquo; February&nbsp;2010.</span><span>)</span></a>. The related socket
         options are summarized briefly in <a class='info' href='#tbl:shim'>Table&nbsp;3</a>.
         
</p><br /><hr class="insert" />
<a name="tbl:shim"></a>
<table class="full" align="center" border="0" cellpadding="2" cellspacing="2">
<col align="left"><col align="left">
<tr><th align="left">optname</th><th align="left">description</th></tr>
<tr>
<td align="left">SHIM_LOC_LOCAL_PREF</td>
<td align="left">Get or set the preferred locator on the local side for the context
     associated with the socket.</td>
</tr>
<tr>
<td align="left">SHIM_LOC_PEER_PREF</td>
<td align="left">Get or set the preferred locator on the remote side for the context
     associated with the socket.</td>
</tr>
<tr>
<td align="left">SHIM_LOCLIST_LOCAL</td>
<td align="left">Get or set a list of locators associated with the local EID.</td>
</tr>
<tr>
<td align="left">SHIM_LOCLIST_PEER</td>
<td align="left">Get or set a list of locators associated with the peer's EID.</td>
</tr>
<tr>
<td align="left">SHIM_LOC_LOCAL_SEND</td>
<td align="left">Set or get the default source locator of outgoing IP packets.</td>
</tr>
<tr>
<td align="left">SHIM_LOC_PEER_SEND</td>
<td align="left">Set or get the default destination locator of  outgoing IP packets.</td>
</tr>
</table>
<br clear="all" />
<table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Table 3&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>As an example of locator mappings, a connection-oriented
   application creates a HIP-based socket and sets the
   SHIM_LOCLIST_PEER socket option on the socket.  The HIP module uses
   the first address contained in the option if multiple are provided.
   If the application provides one or more addresses in the
   SHIM_LOCLIST_PEER setsockopt call, the system should not connect to
   the host via another destination address, in case the application
   intends to restrict the range of addresses permissible as a policy
   choice.  The application can override the default peer locator by
   setting the SHIM_LOC_PEER_PREF socket option if necessary. Finally,
   the application provides a specific HIT in the ship_hit field of
   the sockaddr_hip in the connect() system call.  If the system
   cannot reach the HIT at one of the addresses provided, the outbound
   socket API functions (connect, sendmsg, etc.)  return -1 and set
   errno to EINVALIDLOCATOR.

</p>
<p>
  Applications may also choose to associate local addresses with
  sockets.  The procedures specified in <a class='info' href='#I-D.ietf-shim6-multihome-shim-api'>[I&#8209;D.ietf&#8209;shim6&#8209;multihome&#8209;shim&#8209;api]<span> (</span><span class='info'>Komu, M., Bagnulo, M., Slavov, K., and S. Sugimoto, &ldquo;Socket Application Program Interface (API) for Multihoming Shim,&rdquo; February&nbsp;2010.</span><span>)</span></a> are followed in this
  case.

</p>
<p>
  Another use case is to use the opportunistic mode
  when the destination HIT is specified as a wildcard. The application
  sets one or more destination addresses using the
  SHIM_LOCLIST_PEER socket option as described earlier in this section and then calls
  connect() with the wildcard HIT. The connect() call returns -1 and
  sets errno to EADDRNOTAVAIL when the application connects to a
  wildcard without specifying any destination address.

</p>
<p>
  Applications using datagram-oriented sockets can use ancillary data
  to control the locators, as described in detail in <a class='info' href='#I-D.ietf-shim6-multihome-shim-api'>[I&#8209;D.ietf&#8209;shim6&#8209;multihome&#8209;shim&#8209;api]<span> (</span><span class='info'>Komu, M., Bagnulo, M., Slavov, K., and S. Sugimoto, &ldquo;Socket Application Program Interface (API) for Multihoming Shim,&rdquo; February&nbsp;2010.</span><span>)</span></a>.

</p>
<a name="anchor1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5"></a><h3>5.&nbsp;
Summary of New Definitions</h3>

<p>
<a class='info' href='#tbl:defs'>Table&nbsp;4</a> summarizes the new constants and
structures defined in this document.

</p><br /><hr class="insert" />
<a name="tbl:defs"></a>
<table class="full" align="center" border="0" cellpadding="2" cellspacing="2">
<col align="left"><col align="left">
<tr><th align="left">Header</th><th align="left">Definition</th></tr>
<tr>
<td align="left">&lt;sys/socket.h&gt;</td>
<td align="left">AF_HIP</td>
</tr>
<tr>
<td align="left">&lt;sys/socket.h&gt;</td>
<td align="left">PF_HIP</td>
</tr>
<tr>
<td align="left">&lt;netinet/in.h&gt;</td>
<td align="left">IPPROTO_HIP</td>
</tr>
<tr>
<td align="left">&lt;netinet/hip.h&gt;</td>
<td align="left">HIP_HIT_ANY</td>
</tr>
<tr>
<td align="left">&lt;netinet/hip.h&gt;</td>
<td align="left">HIP_HIT_ANY_PUB</td>
</tr>
<tr>
<td align="left">&lt;netinet/hip.h&gt;</td>
<td align="left">HIP_HIT_ANY_TMP</td>
</tr>
<tr>
<td align="left">&lt;netinet/hip.h&gt;</td>
<td align="left">HIP_ENDPOINT_ANY</td>
</tr>
<tr>
<td align="left">&lt;netinet/hip.h&gt;</td>
<td align="left">HIP_HIT_PREFERENCES</td>
</tr>
<tr>
<td align="left">&lt;netinet/hip.h&gt;</td>
<td align="left">hip_hit_t</td>
</tr>
<tr>
<td align="left">&lt;netdb.h&gt;</td>
<td align="left">AI_NO_HIT</td>
</tr>
<tr>
<td align="left">&lt;netinet/hip.h&gt;</td>
<td align="left">sockaddr_hip</td>
</tr>
<tr>
<td align="left">&lt;netinet/hip.h&gt;</td>
<td align="left">sockaddr_is_srcaddr()</td>
</tr>
<tr>
<td align="left">&lt;netinet/hip.h&gt;</td>
<td align="left">hip_is_hit()</td>
</tr>
</table>
<br clear="all" />
<table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Table 4&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<a name="sec:iana"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6"></a><h3>6.&nbsp;
IANA Considerations</h3>

<p>No IANA considerations.
</p>
<a name="sec:security"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7"></a><h3>7.&nbsp;
Security Considerations</h3>

<p>The HIP_ENDPOINT_ANY constant can be used to accept incoming or
    create outgoing data flows without HIP. The application should use
    the sockaddr_is_srcaddr() function to validate the type of the
    connection in order to e.g. inform the user of the lack of
    HIP-based security. The use of the HIP_HIT_ANY_* constants is
    recommended in security-critical applications and systems.
</p>
<p>It should be noted that the wildcards described in this document
       are not suitable for identifying end-hosts. Instead, applications
       should use getsockname() and getpeername() as described in
       <a class='info' href='#sec:getsock'>Section&nbsp;4.3<span> (</span><span class='info'>The Use of getsockname and getpeername Functions</span><span>)</span></a> to identify an end-host.
</p>
<p>Future proofing of HITs was discussed during the design of this API.
       If HITs longer than 128-bits are required at the application layer,
       this will require explicit support from the applications because
       they can store or cache HITs with their explicit sizes.
       To support longer HITs, further extensions of this API may define
       an additional flag for getaddrinfo()
       to generate different kind of socket address structures for HIP.
</p>
<a name="anchor2"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.8"></a><h3>8.&nbsp;
Contributors</h3>

<p>Thanks for Jukka Ylitalo and Pekka Nikander for their original
    contribution, time and effort to the native HIP APIs. Thanks for
    Yoshifuji Hideaki and Stefan G&ouml;tz for their contributions to this document.
    
</p>
<a name="sec:acknowledgements"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.9"></a><h3>9.&nbsp;
Acknowledgements</h3>

<p>
    Kristian Slavov, Julien Laganier, Jaakko Kangasharju, Mika Kousa,
    Jan Melen, Andrew McGregor, Sasu Tarkoma, Lars Eggert, Joe Touch,
    Antti Jarvinen, Anthony Joseph, Teemu Koponen, Jari Arkko, Ari
    Keranen, Juha-Matti Tapio, Shinta Sugimoto, Philip Matthews,
    Joakim Koskela, Jeff Ahrenholz, Tobias Heer, Stefan Gotz and Gonzalo Camarillo have provided
    valuable ideas and
    feedback. Thanks also for the APPS area folks, including Stephane
    Bortzmeyer, Chris Newman, Tony Finch, "der Mouse" and Keith Moore.
    
</p>
<a name="rfc.references1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>10.&nbsp;Normative References</h3>
<table width="99%" border="0">
<tr><td class="author-text" valign="top"><a name="I-D.ietf-btns-c-api">[I-D.ietf-btns-c-api]</a></td>
<td class="author-text">Richardson, M., Williams, N., Komu, M., and S. Tarkoma, &ldquo;<a href="http://www.ietf.org/internet-drafts/draft-ietf-btns-c-api-04.txt">C-Bindings for IPsec Application Programming Interfaces</a>,&rdquo; draft-ietf-btns-c-api-04 (work in progress), March&nbsp;2009 (<a href="http://www.ietf.org/internet-drafts/draft-ietf-btns-c-api-04.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="I-D.ietf-shim6-multihome-shim-api">[I-D.ietf-shim6-multihome-shim-api]</a></td>
<td class="author-text">Komu, M., Bagnulo, M., Slavov, K., and S. Sugimoto, &ldquo;<a href="http://www.ietf.org/internet-drafts/draft-ietf-shim6-multihome-shim-api-13.txt">Socket Application Program Interface (API) for Multihoming Shim</a>,&rdquo; draft-ietf-shim6-multihome-shim-api-13 (work in progress), February&nbsp;2010 (<a href="http://www.ietf.org/internet-drafts/draft-ietf-shim6-multihome-shim-api-13.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="I-D.ietf-shim6-proto">[I-D.ietf-shim6-proto]</a></td>
<td class="author-text">Nordmark, E. and M. Bagnulo, &ldquo;<a href="http://www.ietf.org/internet-drafts/draft-ietf-shim6-proto-12.txt">Shim6: Level 3 Multihoming Shim Protocol for IPv6</a>,&rdquo; draft-ietf-shim6-proto-12 (work in progress), February&nbsp;2009 (<a href="http://www.ietf.org/internet-drafts/draft-ietf-shim6-proto-12.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="POSIX">[POSIX]</a></td>
<td class="author-text">Institute of Electrical and Electronics Engineers, &ldquo;IEEE Std. 1003.1-2001 Standard for Information Technology -
               Portable Operating System Interface (POSIX),&rdquo; Dec&nbsp;2001.</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC3493">[RFC3493]</a></td>
<td class="author-text">Gilligan, R., Thomson, S., Bound, J., McCann, J., and W. Stevens, &ldquo;<a href="http://tools.ietf.org/html/rfc3493">Basic Socket Interface Extensions for IPv6</a>,&rdquo; RFC&nbsp;3493, February&nbsp;2003 (<a href="http://www.rfc-editor.org/rfc/rfc3493.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4423">[RFC4423]</a></td>
<td class="author-text">Moskowitz, R. and P. Nikander, &ldquo;<a href="http://tools.ietf.org/html/rfc4423">Host Identity Protocol (HIP) Architecture</a>,&rdquo; RFC&nbsp;4423, May&nbsp;2006 (<a href="http://www.rfc-editor.org/rfc/rfc4423.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4843">[RFC4843]</a></td>
<td class="author-text">Nikander, P., Laganier, J., and F. Dupont, &ldquo;<a href="http://tools.ietf.org/html/rfc4843">An IPv6 Prefix for Overlay Routable Cryptographic Hash Identifiers (ORCHID)</a>,&rdquo; RFC&nbsp;4843, April&nbsp;2007 (<a href="http://www.rfc-editor.org/rfc/rfc4843.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC5014">[RFC5014]</a></td>
<td class="author-text">Nordmark, E., Chakrabarti, S., and J. Laganier, &ldquo;<a href="http://tools.ietf.org/html/rfc5014">IPv6 Socket API for Source Address Selection</a>,&rdquo; RFC&nbsp;5014, September&nbsp;2007 (<a href="http://www.rfc-editor.org/rfc/rfc5014.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC5201">[RFC5201]</a></td>
<td class="author-text">Moskowitz, R., Nikander, P., Jokela, P., and T. Henderson, &ldquo;<a href="http://tools.ietf.org/html/rfc5201">Host Identity Protocol</a>,&rdquo; RFC&nbsp;5201, April&nbsp;2008 (<a href="http://www.rfc-editor.org/rfc/rfc5201.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC5205">[RFC5205]</a></td>
<td class="author-text">Nikander, P. and J. Laganier, &ldquo;<a href="http://tools.ietf.org/html/rfc5205">Host Identity Protocol (HIP) Domain Name System (DNS) Extensions</a>,&rdquo; RFC&nbsp;5205, April&nbsp;2008 (<a href="http://www.rfc-editor.org/rfc/rfc5205.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC5338">[RFC5338]</a></td>
<td class="author-text">Henderson, T., Nikander, P., and M. Komu, &ldquo;<a href="http://tools.ietf.org/html/rfc5338">Using the Host Identity Protocol with Legacy Applications</a>,&rdquo; RFC&nbsp;5338, September&nbsp;2008 (<a href="http://www.rfc-editor.org/rfc/rfc5338.txt">TXT</a>).</td></tr>
</table>

<a name="rfc.authors"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>Authors' Addresses</h3>
<table width="99%" border="0" cellpadding="0" cellspacing="0">
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Miika Komu</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Helsinki Institute for Information Technology</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Metsanneidonkuja 4</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Helsinki</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Finland</td></tr>
<tr><td class="author" align="right">Phone:&nbsp;</td>
<td class="author-text">+358503841531</td></tr>
<tr><td class="author" align="right">Fax:&nbsp;</td>
<td class="author-text">+35896949768</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:miika@iki.fi">miika@iki.fi</a></td></tr>
<tr><td class="author" align="right">URI:&nbsp;</td>
<td class="author-text"><a href="http://www.iki.fi/miika/">http://www.iki.fi/miika/</a></td></tr>
<tr cellpadding="3"><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Thomas Henderson</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">The Boeing Company</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">P.O. Box 3707</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Seattle, WA</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">USA</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:thomas.r.henderson@boeing.com">thomas.r.henderson@boeing.com</a></td></tr>
</table>
</body></html>
