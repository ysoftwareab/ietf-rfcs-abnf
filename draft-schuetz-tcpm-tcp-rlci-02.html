<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="en"><head><title>TCP Response to Lower-Layer Connectivity-Change Indications</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="description" content="TCP Response to Lower-Layer Connectivity-Change Indications">
<meta name="keywords" content="TCP, retransmission trigger, connectivity indication, immediate retransmission, intermittent connectivity, mobility">
<meta name="generator" content="xml2rfc v1.35 (http://xml.resource.org/)">
<meta name="viewport" content="width=600;" />
<style type='text/css'><!--
        body {
                font-family: verdana, charcoal, helvetica, arial, sans-serif;
                font-size: 85%;
		max-width: 40em; 
		color: #000; background-color: #FFF;
                margin: 2em;
        }
        h1, h2, h3, h4, h5, h6 {
                font-family: helvetica, monaco, "MS Sans Serif", arial, sans-serif;
                font-weight: bold; font-style: normal;
        }
        h1 { color: #900; background-color: transparent; text-align: right; }
        h3 { color: #333; background-color: transparent; }

        td.RFCbug {
                font-size: x-small; text-decoration: none;
                width: 30px; height: 30px; padding-top: 2px;
                text-align: justify; vertical-align: middle;
                background-color: #000;
        }
        td.RFCbug span.RFC {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: bold; color: #666;
        }
        td.RFCbug span.hotText {
                font-family: charcoal, monaco, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: normal; text-align: center; color: #FFF;
        }

        table.TOCbug { width: 30px; height: 15px; }
        td.TOCbug {
                text-align: center; width: 30px; height: 15px;
                color: #FFF; background-color: #900;
        }
        td.TOCbug a {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, sans-serif;
                font-weight: bold; font-size: x-small; text-decoration: none;
                color: #FFF; background-color: transparent;
        }

        td.header {
                font-family: arial, helvetica, sans-serif; font-size: x-small;
                vertical-align: top; width: 33%;
                color: #FFF; background-color: #666;
        }
        td.author { font-weight: bold; font-size: x-small; margin-left: 4em; }
        td.author-text { font-size: x-small; }

        /* info code from SantaKlauss at http://www.madaboutstyle.com/tooltip2.html */
        a.info {
                /* This is the key. */
                position: relative;
                z-index: 24;
                text-decoration: none;
        }
        a.info:hover {
                z-index: 25;
                color: #FFF; background-color: #900;
        }
        a.info span { display: none; }
        a.info:hover span.info {
                /* The span will display just on :hover state. */
                display: block;
                position: absolute;
                font-size: smaller;
                top: 2em; left: -5em; width: 15em;
                padding: 2px; border: 1px solid #333;
                color: #900; background-color: #EEE;
                text-align: left;
        }

        a { font-weight: bold; }
        a:link    { color: #900; background-color: transparent; }
        a:visited { color: #633; background-color: transparent; }
        a:active  { color: #633; background-color: transparent; }

        p { margin-left: 2em; margin-right: 2em; }
        p.copyright { font-size: x-small; }
        p.toc { font-size: 85%;
		max-width: 40em; 
		font-weight: bold; margin-left: 3em; }
        table.toc { margin: 0 0 0 3em; padding: 0; border: 0; vertical-align: text-top; }
        td.toc { font-size: 85%;
		max-width: 40em; 
		font-weight: bold; vertical-align: text-top; }

        ol.text { margin-left: 2em; margin-right: 2em; }
        ul.text { margin-left: 2em; margin-right: 2em; }
        li      { margin-left: 3em; }

        /* RFC-2629 <spanx>s and <artwork>s. */
        em     { font-style: italic; }
        strong { font-weight: bold; }
        dfn    { font-weight: bold; font-style: normal; }
        cite   { font-weight: normal; font-style: normal; }
        tt     { color: #036; }
        tt, pre, pre dfn, pre em, pre cite, pre span {
                font-family: "Courier New", Courier, monospace; font-size: small;
        }
        pre {
                text-align: left; padding: 4px;
                color: #000; background-color: #CCC;
        }
        pre dfn  { color: #900; }
        pre em   { color: #66F; background-color: #FFC; font-weight: normal; }
        pre .key { color: #33C; font-weight: bold; }
        pre .id  { color: #900; }
        pre .str { color: #000; background-color: #CFF; }
        pre .val { color: #066; }
        pre .rep { color: #909; }
        pre .oth { color: #000; background-color: #FCF; }
        pre .err { background-color: #FCC; }

        /* RFC-2629 <texttable>s. */
        table.all, table.full, table.headers, table.none {
                font-size: 85%;
		max-width: 40em; 
		text-align: center; border-width: 2px;
                vertical-align: top; border-collapse: collapse;
        }
        table.all, table.full { border-style: solid; border-color: black; }
        table.headers, table.none { border-style: none; }
        th {
                font-weight: bold; border-color: black;
                border-width: 2px 2px 3px 2px;
        }
        table.all th, table.full th { border-style: solid; }
        table.headers th { border-style: none none solid none; }
        table.none th { border-style: none; }
        table.all td {
                border-style: solid; border-color: #333;
                border-width: 1px 2px;
        }
        table.full td, table.headers td, table.none td { border-style: none; }

        hr { height: 1px; }
        hr.insert {
                width: 80%; border-style: none; border-width: 0;
                color: #CCC; background-color: #CCC;
        }
--></style>
</head>
<body>
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<table summary="layout" width="66%" border="0" cellpadding="0" cellspacing="0"><tr><td><table summary="layout" width="100%" border="0" cellpadding="2" cellspacing="1">
<tr><td class="header">TCPM Working Group</td><td class="header">S. Schuetz</td></tr>
<tr><td class="header">Internet-Draft</td><td class="header">NEC</td></tr>
<tr><td class="header">Intended status: Experimental</td><td class="header">N. Koutsianas</td></tr>
<tr><td class="header">Expires: May 22, 2008</td><td class="header">L. Eggert</td></tr>
<tr><td class="header">&nbsp;</td><td class="header">Nokia</td></tr>
<tr><td class="header">&nbsp;</td><td class="header">W. Eddy</td></tr>
<tr><td class="header">&nbsp;</td><td class="header">Verizon</td></tr>
<tr><td class="header">&nbsp;</td><td class="header">Y. Swami</td></tr>
<tr><td class="header">&nbsp;</td><td class="header">Nokia</td></tr>
<tr><td class="header">&nbsp;</td><td class="header">K. Le</td></tr>
<tr><td class="header">&nbsp;</td><td class="header">NSN</td></tr>
<tr><td class="header">&nbsp;</td><td class="header">November 19, 2007</td></tr>
</table></td></tr></table>
<h1><br />TCP Response to Lower-Layer Connectivity-Change Indications<br />draft-schuetz-tcpm-tcp-rlci-02</h1>

<h3>Status of this Memo</h3>
<p>
By submitting this Internet-Draft,
each author represents that any applicable patent or other IPR claims of which
he or she is aware have been or will be disclosed,
and any of which he or she becomes aware will be disclosed,
in accordance with Section&nbsp;6 of BCP&nbsp;79.
This document may not be modified,
and derivative works of it may not be created,
except to publish it as an RFC and to translate it into languages other
than English.</p>
<p>
Internet-Drafts are working documents of the Internet Engineering
Task Force (IETF), its areas, and its working groups.
Note that other groups may also distribute working documents as
Internet-Drafts.</p>
<p>
Internet-Drafts are draft documents valid for a maximum of six months
and may be updated, replaced, or obsoleted by other documents at any time.
It is inappropriate to use Internet-Drafts as reference material or to cite
them other than as &ldquo;work in progress.&rdquo;</p>
<p>
The list of current Internet-Drafts can be accessed at
<a href='http://www.ietf.org/ietf/1id-abstracts.txt'>http://www.ietf.org/ietf/1id-abstracts.txt</a>.</p>
<p>
The list of Internet-Draft Shadow Directories can be accessed at
<a href='http://www.ietf.org/shadow.html'>http://www.ietf.org/shadow.html</a>.</p>
<p>
This Internet-Draft will expire on May 22, 2008.</p>

<h3>Abstract</h3>

<p>
When the path characteristics between two hosts change abruptly, TCP can experience significant delays before resuming transmission in an efficient manner or TCP can behave unfairly to competing traffic. This document describes TCP extensions that improve transmission behavior in response to advisory, lower-layer connectivity-change indications. The proposed TCP extensions modify the local behavior of TCP and introduce a new TCP option to signal locally received connectivity-change indications to remote peers. Performance gains result from a more efficient transmission behavior and there is no difference in aggressiveness in comparison to a newly-started connection.
		
</p><a name="toc"></a><br /><hr />
<h3>Table of Contents</h3>
<p class="toc">
<a href="#anchor1">1.</a>&nbsp;
Introduction<br />
<a href="#anchor2">2.</a>&nbsp;
Motivation and Overview<br />
<a href="#anchor3">3.</a>&nbsp;
Connectivity-Change Indications<br />
<a href="#sec-tcp-response-cci">4.</a>&nbsp;
TCP Response to Connectivity-Change Indications<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec-option">4.1.</a>&nbsp;
Connectivity-Change Indication TCP Option<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#procgen">4.2.</a>&nbsp;
Generation and Processing of Connectivity-Change Indication TCP Options<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec-cong-resp">4.3.</a>&nbsp;
Re-Probing Path Characteristics<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec-rxnow">4.4.</a>&nbsp;
Speculative Retransmission<br />
<a href="#anchor4">5.</a>&nbsp;
Discussion<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor5">5.1.</a>&nbsp;
Triggered Segment Transmission During Steady-State<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor6">5.2.</a>&nbsp;
Impact of Packet Loss<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor7">5.3.</a>&nbsp;
Use of Limited Transmit with RLCI<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor8">5.4.</a>&nbsp;
Simultaneous processing of connectivity-change indications<br />
<a href="#anchor9">6.</a>&nbsp;
Security Considerations<br />
<a href="#ianacons">7.</a>&nbsp;
IANA Considerations<br />
<a href="#anchor10">8.</a>&nbsp;
Acknowledgments<br />
<a href="#rfc.references1">9.</a>&nbsp;
References<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#rfc.references1">9.1.</a>&nbsp;
Normative References<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#rfc.references2">9.2.</a>&nbsp;
Informative References<br />
<a href="#classification">Appendix&nbsp;A.</a>&nbsp;
Background: Classification of Connectivity Disruptions<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#short">A.1.</a>&nbsp;
Short Connectivity Disruptions<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#long">A.2.</a>&nbsp;
Long Connectivity Disruptions<br />
<a href="#anchor13">Appendix&nbsp;B.</a>&nbsp;
Document Revision History<br />
<a href="#rfc.authors">&#167;</a>&nbsp;
Authors' Addresses<br />
<a href="#rfc.copyright">&#167;</a>&nbsp;
Intellectual Property and Copyright Statements<br />
</p>
<br clear="all" />

<a name="anchor1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1"></a><h3>1.&nbsp;
Introduction</h3>

<p>
The Transmission Control Protocol (TCP) <a class='info' href='#RFC0793'>[RFC0793]<span> (</span><span class='info'>Postel, J., &ldquo;Transmission Control Protocol,&rdquo; September&nbsp;1981.</span><span>)</span></a> generally assumes that the end-to-end path between two hosts has characteristics that are relatively stable over the lifetime of a connection. Although TCP's congestion control algorithms <a class='info' href='#RFC2581'>[RFC2581]<span> (</span><span class='info'>Allman, M., Paxson, V., and W. Stevens, &ldquo;TCP Congestion Control,&rdquo; April&nbsp;1999.</span><span>)</span></a> can adapt to changes to the path characteristics after several round-trip times, they fail to support efficient operation in the few round-trip times immediately after a significant path change. This is due to the granularity of TCP's sampling mechanisms. Significant changes to path connectivity include loss or reestablishment of connectivity, and drastic, abrupt changes in round-trip time (RTT) or available bandwidth. Connectivity changes that occur on such short time-scales are becoming more common, due to host mobility or intermittent network attachment. 
		
</p>
<p>
This document describes a set of complementary TCP extensions that improve behavior when transmitting over paths whose characteristics can change on short time-scales. TCP implementations that support these extensions respond to receiving generic, link-technology-independent, per-connection connectivity-change indications from lower layers. A connectivity-change indication signals that the characteristics of the end-to-end path between the local node and its peer have changed in some undefined way. The response mechanisms proposed for TCP act on this information in a conservative fashion. The specific response depends on the state of a connection.
		
</p>
<p>
It is important to note that this addition of response mechanisms to lower-layer information is following an established precedent. TCP and other transport protocols already react to information and signals from lower layers; the proposed connectivity-change indications thus extend an established interface between layers in the protocol stack. TCP measures the end-to-end path to implicitly derive network-layer information. TCP also directly reacts to network-layer signals delivered via ICMP, for example, "Port Unreachable" or the now-deprecated "Source Quench" <a class='info' href='#RFC1122'>[RFC1122]<span> (</span><span class='info'>Braden, R., &ldquo;Requirements for Internet Hosts - Communication Layers,&rdquo; October&nbsp;1989.</span><span>)</span></a>. Explicit Congestion Notification (ECN) <a class='info' href='#RFC3168'>[RFC3168]<span> (</span><span class='info'>Ramakrishnan, K., Floyd, S., and D. Black, &ldquo;The Addition of Explicit Congestion Notification (ECN) to IP,&rdquo; September&nbsp;2001.</span><span>)</span></a> and Quick-Start <a class='info' href='#RFC4782'>[RFC4782]<span> (</span><span class='info'>Floyd, S., Allman, M., Jain, A., and P. Sarolahti, &ldquo;Quick-Start for TCP and IP,&rdquo; January&nbsp;2007.</span><span>)</span></a> are other sources of network-layer information for which response mechanisms for TCP have been defined. Connectivity-change indications are yet another source of lower-layer information that TCP can use to improve its operation. 
		
</p>
<p>
A second important point to note is that the TCP response mechanisms to connectivity-change indications are purely optional efficiency improvements. In the absence of connectivity-change indications, a TCP that implements these changes behaves identically to an unmodified TCP. When lower layers provide connectivity-change indications that trigger the response mechanisms, they enhance TCP operation based on the explicit lower-layer information that is signaled. These response mechanisms do not increase the aggressiveness of TCP.
 		
</p>
<p>
Note that the IAB has recently described architectural issues of "link indications" <a class='info' href='#RFC4907'>[RFC4907]<span> (</span><span class='info'>Aboba, B., &ldquo;Architectural Implications of Link Indications,&rdquo; June&nbsp;2007.</span><span>)</span></a>. The authors feel that this term is not quite accurate in this environment, because transport mechanisms should remain link-technology-agnostic. However, transport protocols have always acted on network-layer information and signals, such as measured path characteristics or ICMP-signaled conditions. Because of the growing proliferation of shim layers between the traditional network and transport layers, this document uses the term "lower-layer indication" to remain independent of specific network or shim layers.
		
</p>
<p>
Note that it is currently an open question as to whether additional lower-layer indications can provide further information to transport protocols. Also, this document only describes response mechanisms for TCP, although other transport protocols may benefit from similar response mechanisms to react to connectivity-change indications.
		
</p>
<p>
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in <a class='info' href='#RFC2119'>[RFC2119]<span> (</span><span class='info'>Bradner, S., &ldquo;Key words for use in RFCs to Indicate Requirement Levels,&rdquo; March&nbsp;1997.</span><span>)</span></a>.
	
</p>
<a name="anchor2"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2"></a><h3>2.&nbsp;
Motivation and Overview</h3>

<p>
Several proposed network-layer extensions support host mobility, including Mobile IPv4 <a class='info' href='#RFC3344'>[RFC3344]<span> (</span><span class='info'>Perkins, C., &ldquo;IP Mobility Support for IPv4,&rdquo; August&nbsp;2002.</span><span>)</span></a>, Mobile IPv6 <a class='info' href='#RFC3775'>[RFC3775]<span> (</span><span class='info'>Johnson, D., Perkins, C., and J. Arkko, &ldquo;Mobility Support in IPv6,&rdquo; June&nbsp;2004.</span><span>)</span></a> and HIP <a class='info' href='#I-D.ietf-hip-mm'>[I&#8209;D.ietf&#8209;hip&#8209;mm]<span> (</span><span class='info'>Henderson, T., &ldquo;End-Host Mobility and Multihoming with the Host Identity Protocol,&rdquo; March&nbsp;2007.</span><span>)</span></a>. Typically, they shield transport-layer protocols from mobility events and enable them to sustain established connections across mobility events. However, the path characteristics that established connections experience after a mobility event may have changed drastically and on short time-scales. Congestion control, RTT and path-MTU state gathered over an old path before the move generally have no meaning for the new path. Because TCP uses stale information when resuming transmission over the new path, it can be either too aggressive or highly inefficient.  Similar conditions may be found when fail-overs occur for multihomed hosts through the shim6 protocol.  Some background on the types of scenarios that the technology described in this document is designed to work within is found in <a class='info' href='#classification'>Appendix&nbsp;A<span> (</span><span class='info'>Background: Classification of Connectivity Disruptions</span><span>)</span></a>.
	
</p>
<p>
TCP already forces a slow-start restart in some cases where the network state becomes unknown, such as after an idle period or heavy losses. A first part of the response specified in this document involves a similar return to initial slow-start state in response to connectivity-change indications that are received while a connection is transmitting in steady-state. Note that this behavior is more conservative than the standard TCP response or lack of response. Some performance gains with the proposed mechanisms are due to either avoiding overloading the new path, which typically incurs an RTO, or using slow-start to quickly detect new capacity far above the point where steady-state had previously been near.
		
</p>
<p>
A second response component improves TCP operation in the presence of temporary connectivity disruptions. These disruptions can occur independently of mobility events and, for example, may be due to insufficient wireless access coverage or nomadic computer use. Connectivity disruptions can severely decrease TCP performance. The main reason for this decrease is TCP's retransmission behavior after a connectivity disruption <a class='info' href='#SCHUETZ'>[SCHUETZ]<span> (</span><span class='info'>Schuetz, S., Eggert, L., Schmid, S., and M. Brunner, &ldquo;Protocol Enhancements for Intermittently Connected Hosts,&rdquo; July&nbsp;2005.</span><span>)</span></a>. TCP uses periodic retransmission attempts in exponentially increasing intervals, which can unnecessarily delay retransmissions after connectivity returns. In the extreme case, TCP connections can even abort, if the disruption is longer than the TCP "user timeout." (Connection aborts are out of scope for this document but can be prevented by the TCP User Timeout Option <a class='info' href='#I-D.ietf-tcpm-tcp-uto'>[I&#8209;D.ietf&#8209;tcpm&#8209;tcp&#8209;uto]<span> (</span><span class='info'>Eggert, L. and F. Gont, &ldquo;TCP User Timeout Option,&rdquo; January&nbsp;2009.</span><span>)</span></a>.)
	
</p>
<p>
This second response action executes when receiving a connectivity-change indication while a connection is stalled in exponential back-off. It improves TCP retransmission behavior after connectivity is restored through an immediate speculative retransmission attempt
			<a class='info' href='#comment.footnote-1'>[footnote-1]<span> (</span><span class='info'>The authors have heard the idea of triggering retransmits based on connectivity events of directly-connected links being attributed to Phil Karn (&quot;kick&quot; operation in the KAQ9 TCP stack).  A thread from the PILC mailing list in 2000 discusses some thoughts on this (http://www.isi.edu/pilc/list/archive/0691.html).</span><span>)</span></a><a name='footnote-1'></a>.
Similar to the first response component, the second one also increases TCP performance through a more intelligent transmission behavior that uses periods of connectivity more efficiently. In comparison to startup of a new connection, it does not cause significant amounts of additional traffic and it does not change TCP's congestion control algorithms.
		
</p>
<p>
Finally, this draft specifies a third response component, which is a new TCP option that notifies the connection's remote peer of a connectivity-change event detected locally. This is useful because connectivity-change indications typically require appropriate responses at both ends of a connection, but may only be received or detected by one end. The other parts of the response to a connectivity-change indication are independent of the indication's source (locally notified or remotely signaled) and depend only on the specific indication and the state of the connection for which it was received.
		
</p>
<a name="anchor3"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3"></a><h3>3.&nbsp;
Connectivity-Change Indications</h3>

<p>
The focus of this document is on specifying TCP response mechanisms to lower-layer connectivity-change indications. This section briefly describes how different network- and shim-layer mechanisms underneath the transport layer may provide these connectivity-change indications to TCP. This section is included for clarification only; details on connectivity indication sources are out of scope of this document.
	
</p>
<p>
When lower layers detect a connectivity-change event, they generate corresponding connectivity-change indications. Lower-layer events that could trigger such an indication include (but are not limited to): 
	</p>
<ul class="text">
<li>
the IP address of the local outbound interface used for a given connection has changed, e.g., due to DHCP <a class='info' href='#RFC2131'>[RFC2131]<span> (</span><span class='info'>Droms, R., &ldquo;Dynamic Host Configuration Protocol,&rdquo; March&nbsp;1997.</span><span>)</span></a> or IPv6 router advertisements <a class='info' href='#RFC2460'>[RFC2460]<span> (</span><span class='info'>Deering, S. and R. Hinden, &ldquo;Internet Protocol, Version 6 (IPv6) Specification,&rdquo; December&nbsp;1998.</span><span>)</span></a>
		
</li>
<li>
link-layer connectivity of the local outbound interface used for a given connection has changed, e.g., link-layer "link up" event <a class='info' href='#RFC4957'>[RFC4957]<span> (</span><span class='info'>Krishnan, S., Montavont, N., Njedjou, E., Veerepalli, S., and A. Yegin, &ldquo;Link-Layer Event Notifications for Detecting Network Attachments,&rdquo; August&nbsp;2007.</span><span>)</span></a>
		
</li>
<li>
the local outbound interface used for a given connection has changed, due to routing changes or link-layer connectivity changes at other interfaces (including tunnel establishment or teardown, e.g., in response to IKE events <a class='info' href='#RFC4306'>[RFC4306]<span> (</span><span class='info'>Kaufman, C., &ldquo;Internet Key Exchange (IKEv2) Protocol,&rdquo; December&nbsp;2005.</span><span>)</span></a>) 
		
</li>
<li>
a Mobile IP binding update has completed <a class='info' href='#RFC3775'>[RFC3775]<span> (</span><span class='info'>Johnson, D., Perkins, C., and J. Arkko, &ldquo;Mobility Support in IPv6,&rdquo; June&nbsp;2004.</span><span>)</span></a>
		
</li>
<li>
a HIP readdressing update has completed <a class='info' href='#I-D.ietf-hip-mm'>[I&#8209;D.ietf&#8209;hip&#8209;mm]<span> (</span><span class='info'>Henderson, T., &ldquo;End-Host Mobility and Multihoming with the Host Identity Protocol,&rdquo; March&nbsp;2007.</span><span>)</span></a>
		
</li>
<li>
a path-change signal from the network has arrived (possible in theory, depends on network capabilities)
		
</li>
<li>
other notifications as defined by the IETF's Detecting Network Attachment (DNA) working group have occurred <a class='info' href='#RFC4957'>[RFC4957]<span> (</span><span class='info'>Krishnan, S., Montavont, N., Njedjou, E., Veerepalli, S., and A. Yegin, &ldquo;Link-Layer Event Notifications for Detecting Network Attachments,&rdquo; August&nbsp;2007.</span><span>)</span></a>
		
</li>
</ul><p>
Note that the list above only describes some potential sources for connectivity-change events. Other sources exist, but the details on when to generate such events are out of the scope of this document, which focuses on the TCP response mechanisms when such events are received.	
	
</p>
<a name="sec-tcp-response-cci"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4"></a><h3>4.&nbsp;
TCP Response to Connectivity-Change Indications</h3>

<p>
A TCP connection can receive a connectivity-change indication (CCI) either from its local stack ("local CCI") or through a new "connectivity-change indication TCP option" from its peer ("remote CCI"). <a class='info' href='#sec-option'>Section&nbsp;4.1<span> (</span><span class='info'>Connectivity-Change Indication TCP Option</span><span>)</span></a> specifies this new TCP option. In either case, upon reception of a CCI, the TCP response mechanisms defined in this document immediately re-probe path characteristics. They do this by either performing a speculative retransmission or by sending a single segment of new data or a pure ACK, depending on whether the connection is currently stalled in exponential back-off or transmitting in steady-state, respectively. A connection is "stalled in exponential back-off", if at least one segment was retransmitted due to a RTO expiration but has not been ACK'ed yet. 
	
</p>
<p>
The remainder of this section first defines the format of the new CCI option in <a class='info' href='#sec-option'>Section&nbsp;4.1<span> (</span><span class='info'>Connectivity-Change Indication TCP Option</span><span>)</span></a> and then describes the two TCP response mechanisms triggered by receiving CCIs - re-probing path characteristics and speculative retransmission - in <a class='info' href='#sec-cong-resp'>Section&nbsp;4.3<span> (</span><span class='info'>Re-Probing Path Characteristics</span><span>)</span></a> and <a class='info' href='#sec-rxnow'>Section&nbsp;4.4<span> (</span><span class='info'>Speculative Retransmission</span><span>)</span></a>.
	
</p>
<p>
The RLCI mechanisms defined in this document depend on the TCP Timestamps option (TSopt) <a class='info' href='#RFC1323'>[RFC1323]<span> (</span><span class='info'>Jacobson, V., Braden, B., and D. Borman, &ldquo;TCP Extensions for High Performance,&rdquo; May&nbsp;1992.</span><span>)</span></a>. Consequently, it is REQUIRED that an end host that wishes to use the RLCI mechanisms for TCP connection negotiate the use of TCP Timestamps options with its peer. If this negotiation fails, a host MUST NOT use RLCI mechanisms for a connection. TCP Timestamps options are needed by the RLCI mechanisms during the following operations:
		
</p>
<p>
		</p>
<ul class="text">
<li>
To re-probe the path characteristics after a connectivity-change indication. A host uses the TS Echo Reply (TSecr) field of a TCP Timestamps option to distinguish whether incoming ACKs are for segments that have been transmitted before or after CCI.
		
</li>
<li>
To identify a new remote CCI. A host uses the TS Value (TSval) field of an incoming TCP Timestamps option to distinguish a new remote CCI from the delayed reception of an old one. As a result, last remote CCI is defined as the one received with the highest TS Value.
		
</li>
</ul><p>
	
</p>
<p>
<a class='info' href='#procgen'>Section&nbsp;4.2<span> (</span><span class='info'>Generation and Processing of Connectivity-Change Indication TCP Options</span><span>)</span></a> and <a class='info' href='#sec-cong-resp'>Section&nbsp;4.3<span> (</span><span class='info'>Re-Probing Path Characteristics</span><span>)</span></a> give more details about how RLCI mechanisms use TCP Timestamps options. 
	
</p>
<p>
An implementation of the RLCI mechanism defined in this document maintains nine new state variables per TCP connection. <a class='info' href='#comment.footnote-2'>[footnote-2]<span> (</span><span class='info'>Although this specification introduces eight new per-connection state variables, a preliminary implementation of an earlier revision of this mechanism [I-D.swami-tcp-lmdr] only required around a hundred lines of kernel code.</span><span>)</span></a><a name='footnote-2'></a> 
		</p>
<blockquote class="text"><dl>
<dt>LOCAL_CCI</dt>
<dd>
It is a 1-bit counter, having an initial value of 0, used for distinguishing the existence of a new local CCI. It changes value every time a new local CCI received from the local stack starts being processed. 
			
</dd>
<dt>REMOTE_CCI</dt>
<dd>
It holds a copy of the last CCI value advertised by the peer through a CCI TCP option. This is a 1-bit counter initialized to 0 and is updated in response to remote CCIs according to the rules defined in <a class='info' href='#procgen'>Section&nbsp;4.2<span> (</span><span class='info'>Generation and Processing of Connectivity-Change Indication TCP Options</span><span>)</span></a>.
			
</dd>
<dt>LOCAL_CCI_STATUS</dt>
<dd>
It holds the status of the local CCI. It can have three possible values: LOCAL_CCI_IDLE (0), LOCAL_CCI_NEW (1), LOCAL_CCI_ECHO_ACK (2). The initial value is LOCAL_CCI_IDLE.
			
</dd>
<dt>REMOTE_CCI_STATUS</dt>
<dd>
It holds the status of the last remote CCI advertised by the peer through a CCI TCP option. It is a Boolean variable that can have 2 possible values: REMOTE_CCI_IDLE (0), REMOTE_CCI_ECHO (1). The initial value is REMOTE_CCI_IDLE.
			
</dd>
<dt>LAST_CCI_TIME</dt>
<dd>
It holds the local time when the last CCI (either local or remote) was received. It is updated every time either LOCAL_CCI or REMOTE_CCI is modified.
			
</dd>
<dt>REMOTE_CCI_PEER_TIME</dt>
<dd>
This variable is used in order to distinguish the new remote CCIs from the retransmissions of the past ones. It holds the TS Value (TSval) of the Timestamps option of the segment advertising the last remote CCI. It is initialized when receiving the first segment from the peer and it is updated every time REMOTE_CCI is modified. 
			
</dd>
<dt>LOCAL_CCI_PEER_ECHO_TIME</dt>
<dd>
This variable is used in order to distinguish the echo of a new local CCI from the delayed retransmissions of echoes of older local CCIs. It holds the TS Value (TSval) of the Timestamps option of the segment echoed the last local CCI. It is initialized when receiving the first segment from the peer and it is updated every time LOCAL_CCI_STATUS changes from LOCAL_CCI_NEW to LOCAL_CCI_ECHO_ACK. 
			
</dd>
<dt>CCI_SNDMAX</dt>
<dd>
Retains the highest sequence number transmitted when the most recent CCI (either local or remote) was received.
			
</dd>
<dt>CCI_CONTROLLED_CWND</dt>
<dd>
It is a Boolean variable that sets an additional condition controlling the increment of the congestion window. Having an initial value of false, it is updated according to the rules defined in <a class='info' href='#procgen'>Section&nbsp;4.2<span> (</span><span class='info'>Generation and Processing of Connectivity-Change Indication TCP Options</span><span>)</span></a>.
			
</dd>
</dl></blockquote><p>
	
</p>
<a name="sec-option"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.1"></a><h3>4.1.&nbsp;
Connectivity-Change Indication TCP Option</h3>

<p>
Connectivity-change indications (CCIs) are generally asymmetric, i.e., they may occur or be detected by one end but not the other. The basic idea behind the CCI TCP option is to signal the occurrence of local CCIs to the other end, in order to allow it to respond appropriately. Note that this assumes that paths will generally be symmetric, meaning that a CCI received by one end for its path to the peer will imply that the characteristics of the reverse path have also changed. 
	
</p><br /><hr class="insert" />
<a name="fig-cci-opt"></a>
<div style='display: table; width: 0; margin-left: auto; margin-right: auto'><pre>
                     1                   2
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3
+---------------+---------------+-----+-+-+---+-+
|               |               |  R  | | |   |E|
|   Kind = X    |  Length = 3   |  E  |C|E| C |C|
|               |               |  S  | |C| S |S|
+---------------+---------------+-----+-+-+---+-+
</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;1: Format of the connectivity-change indication TCP option.&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>
<a class='info' href='#fig-cci-opt'>Figure&nbsp;1<span> (</span><span class='info'>Format of the connectivity-change indication TCP option.</span><span>)</span></a> shows the format of the CCI TCP option. It contains these fields:
			</p>
<blockquote class="text"><dl>
<dt>Kind (8 bits)</dt>
<dd>
The TCP option number X <a class='info' href='#RFC0793'>[RFC0793]<span> (</span><span class='info'>Postel, J., &ldquo;Transmission Control Protocol,&rdquo; September&nbsp;1981.</span><span>)</span></a> allocated by IANA upon publication of this document (see <a class='info' href='#ianacons'>Section&nbsp;7<span> (</span><span class='info'>IANA Considerations</span><span>)</span></a>).
			
</dd>
<dt>Length (8 bits)</dt>
<dd>
Length of the TCP option in octets <a class='info' href='#RFC0793'>[RFC0793]<span> (</span><span class='info'>Postel, J., &ldquo;Transmission Control Protocol,&rdquo; September&nbsp;1981.</span><span>)</span></a>; its value MUST be 3.			

</dd>
<dt>RES (3 bits)</dt>
<dd>
Reserved bits. The sender SHOULD set these to zero and the receiver MUST ignore them.

   			
</dd>
<dt>C (1 bit)</dt>
<dd>
 Current value of LOCAL_CCI of the end sending the option.

			
</dd>
<dt>EC (1 bit)</dt>
<dd>
Echoed value of C, i.e., the current value of REMOTE_CCI of the end sending the option.
			
</dd>
<dt>CS (2 bit)</dt>
<dd>
Current value of LOCAL_CCI_STATUS of the end sending the option.
			
</dd>
<dt>ECS (1 bit)</dt>
<dd>
Current value of REMOTE_CCI_STATUS of the end sending the option.
			
</dd>
</dl></blockquote><p>
		
</p>
<p>
CCI TCP option contains two single-bit fields (C and EC) used for distinguishing new CCIs from delayed retransmissions of the old ones. It also contains some flags representing the status of each CCI. These flags are used for a 3-way handshake that ensures that both parties have been informed of a new CCI. At the beginning of a connection, LOCAL_CCI and REMOTE_CCI MUST be set to 0. LOCAL_CCI_STATUS and REMOTE_CCI_STATUS MUST be set to LOCAL_CCI_IDLE and REMOTE_CCI_IDLE, respectively.
		
</p>
<p>
A host opening a connection includes a CCI option in its SYN segment with C := 0, CS := LOCAL_CCI_IDLE, EC := 0 and ECS := REMOTE_CCI_IDLE in order to advertise support for the CCI mechanism. A host receiving a SYN segment MUST NOT include a CCI option in its SYN-ACK, unless it has received a CCI option in the corresponding SYN. In case a host has received a CCI option in the SYN segment, it MUST echo the same CCI option in its SYN-ACK segment, i.e., it MUST set C := 0, CS := LOCAL_CCI_IDLE, EC := 0 and ECS := REMOTE_CCI_IDLE. A host MUST NOT process any following CCI options unless one was included in both the SYN and SYN-ACK and both peers have enabled TCP Timestamps for the connection.
		
</p>
<p>
After the SYN exchange, a host SHOULD send a CCI option only if receiving a new local CCI, or in response to receiving a new CCI option from the other end. <a class='info' href='#sec-initiator'>Section&nbsp;4.2.1<span> (</span><span class='info'>Initiator Mode Processing</span><span>)</span></a> and <a class='info' href='#sec-responder'>Section&nbsp;4.2.2<span> (</span><span class='info'>Responder Mode Processing</span><span>)</span></a> describe the processing rules in detail.
		
</p>
<p>
A host MUST send a CCI option in all outgoing segments whenever LOCAL_CCI_STATUS is not LOCAL_CCI_IDLE or REMOTE_CCI_STATUS is not REMOTE_CCI_IDLE. A host MUST NOT send a CCI option when LOCAL_CCI_STATUS is LOCAL_CCI_IDLE and REMOTE_CCI_STATUS is REMOTE_CCI_IDLE, i.e., when the host is not currently processing any CCI. The only exceptions to that rule are SYN and SYN-ACK segments. Whenever sending any CCI option, C MUST be set to the current LOCAL_CCI, EC MUST be set to the current REMOTE_CCI, CS MUST be set to LOCAL_CCI_STATUS and ECS MUST be set to REMOTE_CCI_STATUS, respectively.
		
</p>
<a name="procgen"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.2"></a><h3>4.2.&nbsp;
Generation and Processing of Connectivity-Change Indication TCP Options</h3>

<p>
Processing of a connectivity-change indication can be separated into two parts:
		</p>
<ol class="text">
<li>
Processing in "initiator" mode, i.e., when a host receives a local CCI and forwards it to the other end through a CCI option.
			
</li>
<li>
Processing in "responder" mode, i.e., when a host that receives a remote CCI in  a CCI option from the other end. 
			
</li>
</ol><p>
<a class='info' href='#sec-initiator'>Section&nbsp;4.2.1<span> (</span><span class='info'>Initiator Mode Processing</span><span>)</span></a> and <a class='info' href='#sec-responder'>Section&nbsp;4.2.2<span> (</span><span class='info'>Responder Mode Processing</span><span>)</span></a> describe the state machines at an initiator and a responder, respectively. Note that a single host can be both initiator and responder at the same time, if a local CCI happens to occur while processing for a remote CCI is ongoing, or vice versa..
		
</p>
<p>
The following events, conditions and actions are used in the definition of the two state machines:
		
</p>
<p>
Events:
			</p>
<blockquote class="text"><dl>
<dt>E_LOCAL_CCI</dt>
<dd>
Local end received a local CCI. 
				
</dd>
<dt>E_REMOTE_CCI</dt>
<dd>
Local end received information about a remote CCI, i.e., received a TCP segment that includes a CCI TCP option.			
				
</dd>
<dt>E_SEGMENT_SENT</dt>
<dd>
Local end sent a TCP segment that includes the CCI option.
				
</dd>
</dl></blockquote><p>
		
</p>
<p>
Conditions:
			</p>
<blockquote class="text"><dl>
<dt>C_NEW_REMOTE_CCI</dt>
<dd>
A received CCI option signals a new remote CCI, i.e., C != REMOTE_CCI, CS == LOCAL_CCI_NEW and the TSval of the Timestamps option of the received segment is greater than the current REMOTE_CCI_PEER_TIME (TSval > REMOTE_CCI_PEER_TIME).
				
</dd>
<dt>C_ECHOED_LOCAL_CCI</dt>
<dd>
A received CCI option echoes the last local CCI, i.e., EC == LOCAL_CCI, ECS == REMOTE_CCI_ECHO and the TSval of the Timestamps option of the received segment is greater than the current LOCAL_CCI_PEER_ECHO_TIME (TSval > LOCAL_CCI_PEER_ECHO_TIME).
				
</dd>
<dt>C_ECHOED_REMOTE_CCI</dt>
<dd>
A received CCI option acknowledges that the peer has received the echo of its last local CCI, i.e., C == REMOTE_CCI,  CS == LOCAL_CCI_ECHO_ACK and the TSval of the Timestamps option of the received segment is greater than the current REMOTE_CCI_PEER_TIME (TSval > REMOTE_CCI_PEER_TIME).
				
</dd>
</dl></blockquote><p>
		
</p>
<p>
Actions:
			</p>
<blockquote class="text"><dl>
<dt>A_TGL_LOCAL_CCI</dt>
<dd>
Toggle LOCAL_CCI.
				
</dd>
<dt>A_TGL_REMOTE_CCI</dt>
<dd>
Toggle REMOTE_CCI.
				
</dd>
<dt>A_REPROBE_PATH</dt>
<dd>
 TCP discards all congestion control information gathered on the current path, initializes them to the defaults and re-probes path characteristics based only on the segments transmitted after this event, as  described in <a class='info' href='#sec-cong-resp'>Section&nbsp;4.3<span> (</span><span class='info'>Re-Probing Path Characteristics</span><span>)</span></a>. In other words, CCI_CONTROLLED_CWND := 1, LAST_CCI_TIME := current local time, CCI_SNDMAX := highest sequence number transmitted so far and the congestion control state (CWND and SS_THRESH), round-trip time measurement (RTTM) state and RTO timer are reset to the initial values for a new connection.  Additionally, if the connection is stalled in exponential back-off, TCP MUST act as if RTO had expired and start the speculative retransmission procedure described at <a class='info' href='#sec-rxnow'>Section&nbsp;4.4<span> (</span><span class='info'>Speculative Retransmission</span><span>)</span></a>. 
				
</dd>
<dt>A_FORCE_SEND</dt>
<dd>
Force transmission of a segment that MUST include a CCI option, in order to inform the other peer about the local CCI. If the connection is stalled in exponential back-off, this is taken care of by the speculative retransmission procedure described at <a class='info' href='#sec-rxnow'>Section&nbsp;4.4<span> (</span><span class='info'>Speculative Retransmission</span><span>)</span></a>. If the connection is in steady-state and there is new data to be sent, TCP MUST immediately send a single segment of new data. If there is no new data to be sent, TCP MUST immediately send a pure ACK.
				
</dd>
<dt>A_UPD_CCI_PEER_TIME</dt>
<dd>
 Set REMOTE_CCI_PEER_TIME to the TSval value of the TCP Timestamps option of the received segment.
				
</dd>
<dt>A_UPD_CCI_PEER_E_TIME</dt>
<dd>
 Set LOCAL_CCI_PEER_ECHO_TIME to the TSval value of the TCP Timestamps option of the received segment.
				
</dd>
</dl></blockquote><p>
		
</p>
<a name="sec-initiator"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.2.1"></a><h3>4.2.1.&nbsp;
Initiator Mode Processing</h3>

<p>
This section describes the initiator mode processing of a TCP host implementing RLCI. In initiator mode, a host signals the occurrence of a local CCI to its peer, until the peer echoes reception of that CCI. After receiving the echo, the host needs to acknowledge the echo reception, resulting in a 3-way handshake. <a class='info' href='#fig-init-state-machine'>Figure&nbsp;2<span> (</span><span class='info'>State machine for initiator processing.</span><span>)</span></a> shows the corresponding state machine.
			
</p>
<p>
At the beginning of a connection, i.e., before the first local CCI occurs, LOCAL_CCI is 0 and LOCAL_CCI_STATUS is LOCAL_CCI_IDLE. This remains the case until TCP receives a local CCI (E_LOCAL_CCI). 
			
</p>
<p>
When that happens, TCP toggles LOCAL_CCI (A_TGL_LOCAL_CCI), sets LOCAL_CCI_STATUS := LOCAL_CCI_NEW, starts re-probing the new path (A_REPROBE_PATH) and forces a segment to be sent to the peer (A_FORCE_SEND).
			
</p>
<p>
Note that all subsequently transmitted segments MUST contain a CCI option until LOCAL_CCI_STATUS becomes LOCAL_CCI_IDLE. After the host receives the echo of the local CCI (C_ECHOED_LOCAL_CCI), it updates LOCAL_CCI_PEER_ECHO_TIME (A_UPD_CCI_PEER_E_TIME) and sets LOCAL_CCI_STATUS := LOCAL_CCI_ECHO_ACK. The initiator remains in this state until it can send a segment with the CCI option (E_SEGMENT_SENT) that acknowledges reception of the CCI echo. At that time, it sets LOCAL_CCI_STATUS := LOCAL_CCI_IDLE.
			
</p>
<p>
The transition from LOCAL_CCI_IDLE to LOCAL_CCI_ECHO_ACK occurs if a segment acknowledging the reception of a CCI echo is lost, and the initiator retransmits the echo acknowledgment.
			
</p>
<p>
When a local CCI occurs (E_LOCAL_CCI) while LOCAL_CCI_STATUS != LOCAL_CCI_IDLE, the host MUST ignore it and MUST NOT toggle LOCAL_CCI, because it is already processing another local CCI. 
			
</p>
<p>
			<br /><hr class="insert" />
<a name="fig-init-state-machine"></a>
</p>
<div style='display: table; width: 0; margin-left: auto; margin-right: auto'><pre>


        E_LOCAL_CCI =&gt;
        A_TGL_LOCAL_CCI        E_REMOTE_CCI
        A_REPROBE_PATH         C_ECHOED_LOCAL_CCI=&gt;
        A_FORCE_SEND           A_UPD_CCI_PEER_E_TIME
        +----------------+    +----------------+
        |                |    |                |
        |                |    |                |
        |                |    |                |
        |                V    |                V
+----------------+  +----------------+  +----------------+
|                |  |                |  |                |
|LOCAL_CCI_STATUS|  |LOCAL_CCI_STATUS|  |LOCAL_CCI_STATUS|
|       ==       |  |       ==       |  |       ==       |
|LOCAL_CCI_IDLE  |  |LOCAL_CCI_NEW   |  |LOCAL_CCI_ECHO_ |
|                |  |                |  |ACK             |
+----------------+  +----------------+  +----------------+
       ^  |                                   ^  |
       |  |                                   |  |
       |  +-----------------------------------+  |
       |           E_REMOTE_CCI                  |
       |           C_ECHOED_LOCAL_CCI            |
       |                                         |
       |                                         |
       +-----------------------------------------+
                      E_SEGMENT_SENT


</pre></div><p>
<table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;2: State machine for initiator processing.&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

			
</p>
<a name="sec-responder"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.2.2"></a><h3>4.2.2.&nbsp;
Responder Mode Processing</h3>

<p>
This section describes the responder mode processing of CCIs for a TCP host implementing the CCI TCP option. In responder mode, a host echoes the last received remote CCI to its peer, until it can be sure that the peer correctly received the echo. <a class='info' href='#fig-resp-state-machine'>Figure&nbsp;3<span> (</span><span class='info'>State machine for responder processing.</span><span>)</span></a> shows the corresponding state machine.
			
</p>
<p>
At the beginning of a connection, REMOTE_CCI is 0 and REMOTE_CCI_STATUS is REMOTE_CCI_IDLE, i.e., the local host is not processing any remote CCIs.
			
</p>
<p>
When TCP receives a segment with a CCI TCP option (E_REMOTE_CCI) signaling a new remote CCI (C_NEW_REMOTE_CCI), it toggles REMOTE_CCI (A_TGL_REMOTE_CCI), changes REMOTE_CCI_STATUS to REMOTE_CCI_ECHO, updates REMOTE_CCI_PEER_TIME according to TSval (A_UPD_CCI_PEER_TIME), starts re-probing the new path (A_REPROBE_PATH) and forces a segment to be sent to the peer (A_FORCE_SEND).
			
</p>
<p>
Note that all subsequently transmitted segments MUST contain a CCI TCP option until REMOTE_CCI_STATUS is again REMOTE_CCI_IDLE. This transition occurs when the peer acknowledges the reception of the CCI echo (C_ECHOED_REMOTE_CCI). 
			
</p>
<p>
			<br /><hr class="insert" />
<a name="fig-resp-state-machine"></a>
</p>
<div style='display: table; width: 0; margin-left: auto; margin-right: auto'><pre>

       E_REMOTE_CCI             E_REMOTE_CCI
       C_NEW_REMOTE_CCI =&gt;      C_NEW_REMOTE_CCI =&gt;
       A_TGL_REMOTE_CCI         A_TGL_REMOTE_CCI
       A_UPD_CCI_PEER_TIME      A_UPD_CCI_PEER_TIME
       A_REPROBE_PATH           A_REPROBE_PATH
       A_FORCE_SEND             A_FORCE_SEND
       +-----------------+      +-------------+
       |                 |      |             |
       |                 V      |             |
+-----------------+  +-----------------+      |
|REMOTE_CCI_STATUS|  |REMOTE_CCI_STATUS|      |
|        ==       |  |        ==       |      |
|REMOTE_CCI_IDLE  |  |REMOTE_CCI_ECHO  |      |
+-----------------+  +-----------------+      |
        ^                 |     ^             |
        |                 |     |             |
        +-----------------+     +-------------+
         E_REMOTE_CCI
         C_ECHOED_REMOTE_CCI

</pre></div><p>
<table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;3: State machine for responder processing.&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

			
</p>
<p>
If TCP receives a new remote CCI while REMOTE_CCI_STATUS == REMOTE_CCI_ECHO, this indicates that the acknowledgment of a previous CCI echo may have been lost and that the peer had a new CCI occur. In this case, TCP MUST perform the same actions as if REMOTE_CCI_STATUS == REMOTE_CCI_IDLE.
		
</p>
<a name="sec-cong-resp"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.3"></a><h3>4.3.&nbsp;
Re-Probing Path Characteristics</h3>

<p>
When a TCP connection receives a CCI, it MUST re-probe path characteristics in order to prevent causing congestion by transmitting based on stale path state. In principle, this occurs similarly to the initial slow-start: The sender MUST NOT transmit more than the default initial window (INIT_WINDOW) of data after a CCI is received and it MUST reset the congestion control state (CWND and SS_THRESH), round-trip time measurement (RTTM) state and RTO timer, as if this were a new connection <a class='info' href='#RFC2581'>[RFC2581]<span> (</span><span class='info'>Allman, M., Paxson, V., and W. Stevens, &ldquo;TCP Congestion Control,&rdquo; April&nbsp;1999.</span><span>)</span></a><a class='info' href='#RFC2988'>[RFC2988]<span> (</span><span class='info'>Paxson, V. and M. Allman, &ldquo;Computing TCP's Retransmission Timer,&rdquo; November&nbsp;2000.</span><span>)</span></a>. If Path MTU Discovery (PMTUD) is in use, the PMTUD state MUST also be reset <a class='info' href='#RFC1191'>[RFC1191]<span> (</span><span class='info'>Mogul, J. and S. Deering, &ldquo;Path MTU discovery,&rdquo; November&nbsp;1990.</span><span>)</span></a><a class='info' href='#RFC1981'>[RFC1981]<span> (</span><span class='info'>McCann, J., Deering, S., and J. Mogul, &ldquo;Path MTU Discovery for IP version 6,&rdquo; August&nbsp;1996.</span><span>)</span></a><a class='info' href='#RFC4821'>[RFC4821]<span> (</span><span class='info'>Mathis, M. and J. Heffner, &ldquo;Packetization Layer Path MTU Discovery,&rdquo; March&nbsp;2007.</span><span>)</span></a>.
	
</p>
<p>
One difference to an initial slow-start is that after a CCI, the connection may have segments in flight towards the destination along a previous path. Therefore, after a CCI, TCP MUST ignore any ACKs received for data that was sent before the CCI and it MUST update the congestion window solely based on ACKs for data that was sent after the CCI occurred.
	
</p>
<p>
The mechanism used for distinguishing ACKs for data sent after a CCI occurred from ACKs for data sent before a CCI occurred uses TCP Timestamps options. When a host receives a new CCI (either local or remote), LAST_CCI_TIME MUST be set to the current local time, CCI_SNDMAX MUST be set to the highest sequence number transmitted so far and CCI_CONTROLLED_CWND MUST be set to true.
	
</p>
<p>
While CCI_CONTROLLED_CWND == true, TCP MUST update the congestion window based only on inbound ACKs that contain a TS Echo Reply (TSecr) value greater than or equal to LAST_CCI_TIME. Any inbound ACK with a TS Echo Reply (TSecr) value less than LAST_CCI_TIME MUST NOT cause an update to the congestion window, even if it advances the window. If CCI_CONTROLLED_CWND is true and the host receives an ACK with a sequence number greater than or equal to CCI_SNDMAX, CCI_CONTROLLED_CWND MUST be set to false and the congestion control algorithm MUST begin to process all ACKs normally, without checking their Timestamps options. 
	
</p>
<a name="sec-rxnow"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.4"></a><h3>4.4.&nbsp;
Speculative Retransmission</h3>

<p>
The basic idea behind the speculative retransmission is to allow TCP to resume stalled connections as soon as it receives an indication that connectivity to previously unreachable peers may have returned. 
	
</p>
<p>
When a TCP connection receives a connectivity-change indication - either from the local stack or in a connectivity-change TCP option from the peer - and is currently stalled in exponential back-off, it MUST immediately initiate the standard retransmission procedure, just as if the RTO for the connection had expired.
	
</p>
<a name="anchor4"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5"></a><h3>5.&nbsp;
Discussion</h3>

<p>
This section discusses some design choices of the RLCI mechanism that can affect TCP performance under certain circumstances.
	
</p>
<a name="anchor5"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.1"></a><h3>5.1.&nbsp;
Triggered Segment Transmission During Steady-State</h3>

<p>
A TCP stack that implements RLCI and receives a local connectivity-change indication immediately sends a TCP segment (A_FORCE_SEND) in order to inform the peer of the CCI, after resetting all path information (A_REPROBE_PATH). When TCP is stalled in exponential back-off, this is taken care of by the  speculative retransmission procedure that is triggered by the connectivity-change indication. 
	
</p>
<p>
On the other hand, when TCP is in steady-state, it sends a new segment (A_FORCE_SEND) if there is any new data queued for transmission. As usual, the number of the unacknowledged segments is limited by CWND. However, CWND has just been reset to its initial value. This means that there is a possibility that the transmission sends a segment that is outside the current congestion window. Although this behavior may appear to be aggressive, it is in fact as conservative as a newly starting connection, because only a single unacknowledged segment is sent along the path after CCI.
	
</p>
<a name="anchor6"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.2"></a><h3>5.2.&nbsp;
Impact of Packet Loss</h3>

<p>
If a connection is in exponential back-off when a connectivity-change indication occurs, TCP considers all unacknowledged segments to be lost and the speculative retransmission procedure immediately starts.
	
</p>
<p>
On the other hand, if the connection is in steady-state when a CCI occurs, TCP considers all unacknowledged segments to still be in flight and continues sending new data. Depending on what caused a CCI, four scenarios are possible that differ in what happens to segments and ACKs in flight:
	
</p>
<p>
</p>
<ol class="text">
<li>
All (or at least the vast majority of) segments and ACKs in flight reach their respective destinations, i.e., there are no losses. In this case, TCP acts as if a new connection had started and re-probes the new path.

</li>
<li>
Some of the ACKs in flight from the receiver to sender are lost. In this case, TCP behaves exactly as above, because a cumulative ACK for the new segment sent along the path after the CCI acknowledges all the previous unacknowledged segments.

</li>
<li>
Some of the data segments in flight from the sender to the receiver are lost. In this case, the new data segment transmitted after the CCI causes a duplicate ACK. As this duplicate ACK does not cause TCP to send another data segment, the connection stalls and a RTO occurs. After RTO, the standard retransmission procedure takes place with SS_THRESH equal to INITIAL_WINDOW/2 (i.e., the minimum allowed). This disables slow start and causes a severely decreased performance. A possible solution is to execute the speculative retransmission procedure after receiving a CCI even if the connection is in steady-state.

</li>
<li>
Some of the data segments and some of the ACKs that are in flight are lost. This case is similar to the previous one.

</li>
</ol><p>
	
</p>
<p>

In all these cases, it is also possible that the path delay changes significantly after the CCI, reordering data segments and ACKs that are still in flight with ones sent after the CCI. These reorderings appear to TCP as losses, and may result in the connection experiencing one of the above cases even if there was no actual packet loss.

</p>
<a name="anchor7"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.3"></a><h3>5.3.&nbsp;
Use of Limited Transmit with RLCI</h3>

<p>
As described at the previous section, when connection is in steady-state, a connectivity-change indication (CCI) resets all path information of TCP and causes one new data segment to be sent. In case of significant data segments loss before CCI, the new data segment transmitted after CCI causes a duplicate ACK. As this duplicate ACK does not trigger TCP to send another data segment, the connection stalls and an RTO occurs. 

</p>
<p>
Limited Transmit <a class='info' href='#RFC3042'>[RFC3042]<span> (</span><span class='info'>Allman, M., Balakrishnan, H., and S. Floyd, &ldquo;Enhancing TCP's Loss Recovery Using Limited Transmit,&rdquo; January&nbsp;2001.</span><span>)</span></a> can be used in case of packet loss in order to cause the transmission of three duplicate ACKs and trigger the fast retransmission procedure. As it must not cause an amount of outstanding data more than the congestion window plus two segments, it cannot always be used after a CCI due to the initialized CWND. If the connection has more outstanding data than INITIAL_WINDOW plus two segments before a CCI, resetting of CWND to the initial value after CCI causes an amount of outstanding data greater than the new CWND plus two segments and disables Limited Transmit.

</p>
<p>
A modified Limited Transmit algorithm can be used in combination with RLCI:

</p>
<blockquote class="text"><dl>
<dt>If CCI_CONTROLLED_CWND is true:</dt>
<dd>
Limited Transmit Algorithm as described at <a class='info' href='#RFC3042'>[RFC3042]<span> (</span><span class='info'>Allman, M., Balakrishnan, H., and S. Floyd, &ldquo;Enhancing TCP's Loss Recovery Using Limited Transmit,&rdquo; January&nbsp;2001.</span><span>)</span></a> should be followed but without checking the amount of outstanding data, i.e., if TCP sender has previously unsent data queued for transmission it should transmit new data upon the arrival of the first two consecutive duplicate ACKs when the receiver's advertised window allows this transmission.
				
</dd>
<dt>If CCI_CONTROLLED_CWND is false:</dt>
<dd>
Limited Transmit Algorithm as described at <a class='info' href='#RFC3042'>[RFC3042]<span> (</span><span class='info'>Allman, M., Balakrishnan, H., and S. Floyd, &ldquo;Enhancing TCP's Loss Recovery Using Limited Transmit,&rdquo; January&nbsp;2001.</span><span>)</span></a> should be followed.
				
</dd>
</dl></blockquote>
<p>
When fast retransmission procedure is triggered by the modified Limited Transmit after a CCI, SS_THRESH is set to INITIAL_WINDOW/2 (i.e., the minimum allowed) as CWND before fast retransmission was equal to INITIAL_WINDOW. As a result, slow-start is disabled causing decreased TCP performance.

</p>
<p>
A minor modification can keep SS_THRESH unmodified in the previous case, i.e., if CCI_CONTROLLED_CWND == true and CWND == INITIAL_WINDOW, keep SS_THRESH unmodified (having its initial value) upon the reception of the third duplicate ACK that triggers the fast retransmission procedure.

</p>
<a name="anchor8"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.4"></a><h3>5.4.&nbsp;
Simultaneous processing of connectivity-change indications</h3>

<p>
As mentioned in <a class='info' href='#sec-initiator'>Section&nbsp;4.2.1<span> (</span><span class='info'>Initiator Mode Processing</span><span>)</span></a>, if a local CCI occurs (E_LOCAL_CCI) while LOCAL_CCI_STATUS !=  LOCAL_CCI_IDLE, the host MUST ignore it, because it is already processing another local CCI. As a result, it cannot be processed more than one local CCI at each end any time. As every remote CCI at one end is triggered by a local CCI at the other end, it cannot be processed more than one remote CCI at each end any time.
	
</p>
<p>
On the other hand, if both hosts receive connectivity-change indications from their local stacks (local CCIs) at almost the same time, there is a possibility of simultaneous processing of local and remote CCIs at both ends. In that case, path re-probing is triggered twice at each end in a very short time that can be lower than RTT. As this does not improve TCP performance, it can be avoided by triggering the A_REPROBE_PATH action only if CCI_CONTROLLED_CWND == false.
	
</p>
<a name="anchor9"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6"></a><h3>6.&nbsp;
Security Considerations</h3>

<p>
The only foreseen security considerations with the techniques presented in this document result from either an attacker's ability to spoof valid TCP segments with options that seemingly indicate connectivity changes, or an attacker's ability to generate bogus connectivity-change indications locally.  An attacker might produce a stream of such false indicators that could keep a connection in slow-start at the initial window.  One possible defense against this type of attack is to rate-limit the response to connectivity indicators (whether local or remote).  This is also probably less serious than other attacks such an empowered adversary could perform, like resetting the connection or injecting data.  A similar effect could be achieved without the new option by forging duplicate ACKs that would keep a sender in loss recovery.  If both sets of IP addresses, port numbers, and sequence numbers are guessable for a connection, then the connection should employ other measures <a class='info' href='#RFC4953'>[RFC4953]<span> (</span><span class='info'>Touch, J., &ldquo;Defending TCP Against Spoofing Attacks,&rdquo; July&nbsp;2007.</span><span>)</span></a> for protection against
spoofed segments.
	
</p>
<a name="ianacons"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7"></a><h3>7.&nbsp;
IANA Considerations</h3>

<p>
This section is to be interpreted according to <a class='info' href='#I-D.narten-iana-considerations-rfc2434bis'>[I&#8209;D.narten&#8209;iana&#8209;considerations&#8209;rfc2434bis]<span> (</span><span class='info'>Narten, T. and H. Alvestrand, &ldquo;Guidelines for Writing an IANA Considerations Section in RFCs,&rdquo; March&nbsp;2008.</span><span>)</span></a>.
	
</p>
<p>This document does not define any new namespaces. It requests that IANA allocate a new 8-bit TCP option number for the CCI option from the registry maintained at
http://www.iana.org/assignments/tcp-parameters.
</p>
<a name="anchor10"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.8"></a><h3>8.&nbsp;
Acknowledgments</h3>

<p>
This draft combines and obsoletes <a class='info' href='#I-D.swami-tcp-lmdr'>[I&#8209;D.swami&#8209;tcp&#8209;lmdr]<span> (</span><span class='info'>Swami, Y., &ldquo;Lightweight Mobility Detection and Response (LMDR) Algorithm for TCP,&rdquo; March&nbsp;2006.</span><span>)</span></a> and <a class='info' href='#I-D.eggert-tcpm-tcp-retransmit-now'>[I&#8209;D.eggert&#8209;tcpm&#8209;tcp&#8209;retransmit&#8209;now]<span> (</span><span class='info'>Eggert, L., &ldquo;TCP Extensions for Immediate Retransmissions,&rdquo; June&nbsp;2005.</span><span>)</span></a>. The authors would like to thank Mark Allman, Marcus Brunner, Shashikant Maheshwari, Kacheong Poon, Juergen Quittek, Stefan Schmid and Joe Touch for their comments and suggestions on this draft as well as the two original drafts.
	
</p>
<p>
Simon Schuetz is partly funded by Ambient Networks, a research project supported by the European Commission under its Sixth Framework Program.
	
</p>
<p>
Wesley Eddy's work on this document was performed at NASA's Glenn Research
Center, while in support of the NASA Space Communications Architecture Working
Group (SCAWG), and the FAA/Eurocontrol Future Communications Study (FCS).
	
</p>
<a name="rfc.references"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.9"></a><h3>9.&nbsp;
References</h3>

<a name="rfc.references1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>9.1.&nbsp;Normative References</h3>
<table width="99%" border="0">
<tr><td class="author-text" valign="top"><a name="I-D.narten-iana-considerations-rfc2434bis">[I-D.narten-iana-considerations-rfc2434bis]</a></td>
<td class="author-text">Narten, T. and H. Alvestrand, &ldquo;<a href="http://www.ietf.org/internet-drafts/draft-narten-iana-considerations-rfc2434bis-09.txt">Guidelines for Writing an IANA Considerations Section in RFCs</a>,&rdquo; draft-narten-iana-considerations-rfc2434bis-09 (work in progress), March&nbsp;2008 (<a href="http://www.ietf.org/internet-drafts/draft-narten-iana-considerations-rfc2434bis-09.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC0793">[RFC0793]</a></td>
<td class="author-text">Postel, J., &ldquo;<a href="http://tools.ietf.org/html/rfc793">Transmission Control Protocol</a>,&rdquo; STD&nbsp;7, RFC&nbsp;793, September&nbsp;1981 (<a href="http://www.rfc-editor.org/rfc/rfc793.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC1191">[RFC1191]</a></td>
<td class="author-text"><a href="mailto:mogul@decwrl.dec.com">Mogul, J.</a> and <a href="mailto:deering@xerox.com">S. Deering</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc1191">Path MTU discovery</a>,&rdquo; RFC&nbsp;1191, November&nbsp;1990 (<a href="http://www.rfc-editor.org/rfc/rfc1191.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC1323">[RFC1323]</a></td>
<td class="author-text"><a href="mailto:van@CSAM.LBL.GOV">Jacobson, V.</a>, <a href="mailto:Braden@ISI.EDU">Braden, B.</a>, and <a href="mailto:dab@cray.com">D. Borman</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc1323">TCP Extensions for High Performance</a>,&rdquo; RFC&nbsp;1323, May&nbsp;1992 (<a href="http://www.rfc-editor.org/rfc/rfc1323.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC1981">[RFC1981]</a></td>
<td class="author-text"><a href="mailto:mccann@zk3.dec.com">McCann, J.</a>, <a href="mailto:deering@parc.xerox.com">Deering, S.</a>, and <a href="mailto:mogul@pa.dec.com">J. Mogul</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc1981">Path MTU Discovery for IP version 6</a>,&rdquo; RFC&nbsp;1981, August&nbsp;1996 (<a href="http://www.rfc-editor.org/rfc/rfc1981.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC2119">[RFC2119]</a></td>
<td class="author-text"><a href="mailto:sob@harvard.edu">Bradner, S.</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>,&rdquo; BCP&nbsp;14, RFC&nbsp;2119, March&nbsp;1997 (<a href="http://www.rfc-editor.org/rfc/rfc2119.txt">TXT</a>, <a href="http://xml.resource.org/public/rfc/html/rfc2119.html">HTML</a>, <a href="http://xml.resource.org/public/rfc/xml/rfc2119.xml">XML</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC2581">[RFC2581]</a></td>
<td class="author-text"><a href="mailto:mallman@grc.nasa.gov">Allman, M.</a>, <a href="mailto:vern@aciri.org">Paxson, V.</a>, and <a href="mailto:rstevens@kohala.com">W. Stevens</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc2581">TCP Congestion Control</a>,&rdquo; RFC&nbsp;2581, April&nbsp;1999 (<a href="http://www.rfc-editor.org/rfc/rfc2581.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC2988">[RFC2988]</a></td>
<td class="author-text">Paxson, V. and M. Allman, &ldquo;<a href="http://tools.ietf.org/html/rfc2988">Computing TCP's Retransmission Timer</a>,&rdquo; RFC&nbsp;2988, November&nbsp;2000 (<a href="http://www.rfc-editor.org/rfc/rfc2988.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC3042">[RFC3042]</a></td>
<td class="author-text">Allman, M., Balakrishnan, H., and S. Floyd, &ldquo;<a href="http://tools.ietf.org/html/rfc3042">Enhancing TCP's Loss Recovery Using Limited Transmit</a>,&rdquo; RFC&nbsp;3042, January&nbsp;2001 (<a href="http://www.rfc-editor.org/rfc/rfc3042.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4821">[RFC4821]</a></td>
<td class="author-text">Mathis, M. and J. Heffner, &ldquo;<a href="http://tools.ietf.org/html/rfc4821">Packetization Layer Path MTU Discovery</a>,&rdquo; RFC&nbsp;4821, March&nbsp;2007 (<a href="http://www.rfc-editor.org/rfc/rfc4821.txt">TXT</a>).</td></tr>
</table>

<a name="rfc.references2"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>9.2.&nbsp;Informative References</h3>
<table width="99%" border="0">
<tr><td class="author-text" valign="top"><a name="DUKE">[DUKE]</a></td>
<td class="author-text">Duke, M., Henderson, T., and J. Meegan, &ldquo;Experience with ``Link-UP Notification'' Over a Mobile Satellite Link,&rdquo; ACM Computer Communication Review,&nbsp;Vol. 34, No. 3, July&nbsp;2004.</td></tr>
<tr><td class="author-text" valign="top"><a name="EDDY">[EDDY]</a></td>
<td class="author-text">Eddy, W. and Y. Swami, &ldquo;Adapting End-host Congestion Control for Mobility,&rdquo; NASA Glenn Research Center Technical Report,&nbsp;CR-2005-213838, July&nbsp;2005.</td></tr>
<tr><td class="author-text" valign="top"><a name="I-D.dawkins-trigtran-linkup">[I-D.dawkins-trigtran-linkup]</a></td>
<td class="author-text">Dawkins, S., &ldquo;<a href="http://www.ietf.org/internet-drafts/draft-dawkins-trigtran-linkup-01.txt">End-to-end, Implicit 'Link-Up' Notification</a>,&rdquo; draft-dawkins-trigtran-linkup-01 (work in progress), October&nbsp;2003 (<a href="http://www.ietf.org/internet-drafts/draft-dawkins-trigtran-linkup-01.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="I-D.eggert-tcpm-tcp-retransmit-now">[I-D.eggert-tcpm-tcp-retransmit-now]</a></td>
<td class="author-text">Eggert, L., &ldquo;<a href="http://www.ietf.org/internet-drafts/draft-eggert-tcpm-tcp-retransmit-now-02.txt">TCP Extensions for Immediate Retransmissions</a>,&rdquo; draft-eggert-tcpm-tcp-retransmit-now-02 (work in progress), June&nbsp;2005 (<a href="http://www.ietf.org/internet-drafts/draft-eggert-tcpm-tcp-retransmit-now-02.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="I-D.ietf-hip-mm">[I-D.ietf-hip-mm]</a></td>
<td class="author-text">Henderson, T., &ldquo;<a href="http://www.ietf.org/internet-drafts/draft-ietf-hip-mm-05.txt">End-Host Mobility and Multihoming with the Host Identity Protocol</a>,&rdquo; draft-ietf-hip-mm-05 (work in progress), March&nbsp;2007 (<a href="http://www.ietf.org/internet-drafts/draft-ietf-hip-mm-05.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="I-D.ietf-tcpimpl-restart">[I-D.ietf-tcpimpl-restart]</a></td>
<td class="author-text">Hughes, A., Touch, J., and J. Heidemann, &ldquo;Issues in TCP Slow-Start Restart After Idle,&rdquo; draft-ietf-tcpimpl-restart-00&nbsp;(work in progress), March&nbsp;1998.</td></tr>
<tr><td class="author-text" valign="top"><a name="I-D.ietf-tcpm-tcp-uto">[I-D.ietf-tcpm-tcp-uto]</a></td>
<td class="author-text">Eggert, L. and F. Gont, &ldquo;<a href="http://www.ietf.org/internet-drafts/draft-ietf-tcpm-tcp-uto-11.txt">TCP User Timeout Option</a>,&rdquo; draft-ietf-tcpm-tcp-uto-11 (work in progress), January&nbsp;2009 (<a href="http://www.ietf.org/internet-drafts/draft-ietf-tcpm-tcp-uto-11.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="I-D.swami-tcp-lmdr">[I-D.swami-tcp-lmdr]</a></td>
<td class="author-text">Swami, Y., &ldquo;<a href="http://www.ietf.org/internet-drafts/draft-swami-tcp-lmdr-07.txt">Lightweight Mobility Detection and Response (LMDR) Algorithm for TCP</a>,&rdquo; draft-swami-tcp-lmdr-07 (work in progress), March&nbsp;2006 (<a href="http://www.ietf.org/internet-drafts/draft-swami-tcp-lmdr-07.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="KOODLI">[KOODLI]</a></td>
<td class="author-text">Koodli, R. and C. Perkins, &ldquo;Fast Handovers and Context Transfers in Mobile Networks,&rdquo; ACM Computer Communication Review,&nbsp;Vol. 31, No. 5, October&nbsp;2001.</td></tr>
<tr><td class="author-text" valign="top"><a name="OTT">[OTT]</a></td>
<td class="author-text">Ott, J. and D. Kutscher, &ldquo;OTT Internet: IEEE 802.11b for Automobile Users,&rdquo; Proc. Infocom&nbsp;2004, March&nbsp;2004.</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC1122">[RFC1122]</a></td>
<td class="author-text"><a href="mailto:Braden@ISI.EDU">Braden, R.</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc1122">Requirements for Internet Hosts - Communication Layers</a>,&rdquo; STD&nbsp;3, RFC&nbsp;1122, October&nbsp;1989 (<a href="http://www.rfc-editor.org/rfc/rfc1122.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC2131">[RFC2131]</a></td>
<td class="author-text"><a href="mailto:droms@bucknell.edu">Droms, R.</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc2131">Dynamic Host Configuration Protocol</a>,&rdquo; RFC&nbsp;2131, March&nbsp;1997 (<a href="http://www.rfc-editor.org/rfc/rfc2131.txt">TXT</a>, <a href="http://xml.resource.org/public/rfc/html/rfc2131.html">HTML</a>, <a href="http://xml.resource.org/public/rfc/xml/rfc2131.xml">XML</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC2460">[RFC2460]</a></td>
<td class="author-text"><a href="mailto:deering@cisco.com">Deering, S.</a> and <a href="mailto:hinden@iprg.nokia.com">R. Hinden</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc2460">Internet Protocol, Version 6 (IPv6) Specification</a>,&rdquo; RFC&nbsp;2460, December&nbsp;1998 (<a href="http://www.rfc-editor.org/rfc/rfc2460.txt">TXT</a>, <a href="http://xml.resource.org/public/rfc/html/rfc2460.html">HTML</a>, <a href="http://xml.resource.org/public/rfc/xml/rfc2460.xml">XML</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC3168">[RFC3168]</a></td>
<td class="author-text">Ramakrishnan, K., Floyd, S., and D. Black, &ldquo;<a href="http://tools.ietf.org/html/rfc3168">The Addition of Explicit Congestion Notification (ECN) to IP</a>,&rdquo; RFC&nbsp;3168, September&nbsp;2001 (<a href="http://www.rfc-editor.org/rfc/rfc3168.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC3344">[RFC3344]</a></td>
<td class="author-text">Perkins, C., &ldquo;<a href="http://tools.ietf.org/html/rfc3344">IP Mobility Support for IPv4</a>,&rdquo; RFC&nbsp;3344, August&nbsp;2002 (<a href="http://www.rfc-editor.org/rfc/rfc3344.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC3775">[RFC3775]</a></td>
<td class="author-text">Johnson, D., Perkins, C., and J. Arkko, &ldquo;<a href="http://tools.ietf.org/html/rfc3775">Mobility Support in IPv6</a>,&rdquo; RFC&nbsp;3775, June&nbsp;2004 (<a href="http://www.rfc-editor.org/rfc/rfc3775.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC3819">[RFC3819]</a></td>
<td class="author-text">Karn, P., Bormann, C., Fairhurst, G., Grossman, D., Ludwig, R., Mahdavi, J., Montenegro, G., Touch, J., and L. Wood, &ldquo;<a href="http://tools.ietf.org/html/rfc3819">Advice for Internet Subnetwork Designers</a>,&rdquo; BCP&nbsp;89, RFC&nbsp;3819, July&nbsp;2004 (<a href="http://www.rfc-editor.org/rfc/rfc3819.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4306">[RFC4306]</a></td>
<td class="author-text">Kaufman, C., &ldquo;<a href="http://tools.ietf.org/html/rfc4306">Internet Key Exchange (IKEv2) Protocol</a>,&rdquo; RFC&nbsp;4306, December&nbsp;2005 (<a href="http://www.rfc-editor.org/rfc/rfc4306.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4782">[RFC4782]</a></td>
<td class="author-text">Floyd, S., Allman, M., Jain, A., and P. Sarolahti, &ldquo;<a href="http://tools.ietf.org/html/rfc4782">Quick-Start for TCP and IP</a>,&rdquo; RFC&nbsp;4782, January&nbsp;2007 (<a href="http://www.rfc-editor.org/rfc/rfc4782.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4907">[RFC4907]</a></td>
<td class="author-text">Aboba, B., &ldquo;<a href="http://tools.ietf.org/html/rfc4907">Architectural Implications of Link Indications</a>,&rdquo; RFC&nbsp;4907, June&nbsp;2007 (<a href="http://www.rfc-editor.org/rfc/rfc4907.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4953">[RFC4953]</a></td>
<td class="author-text">Touch, J., &ldquo;<a href="http://tools.ietf.org/html/rfc4953">Defending TCP Against Spoofing Attacks</a>,&rdquo; RFC&nbsp;4953, July&nbsp;2007 (<a href="http://www.rfc-editor.org/rfc/rfc4953.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4957">[RFC4957]</a></td>
<td class="author-text">Krishnan, S., Montavont, N., Njedjou, E., Veerepalli, S., and A. Yegin, &ldquo;<a href="http://tools.ietf.org/html/rfc4957">Link-Layer Event Notifications for Detecting Network Attachments</a>,&rdquo; RFC&nbsp;4957, August&nbsp;2007 (<a href="http://www.rfc-editor.org/rfc/rfc4957.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="SCHUETZ">[SCHUETZ]</a></td>
<td class="author-text">Schuetz, S., Eggert, L., Schmid, S., and M. Brunner, &ldquo;Protocol Enhancements for Intermittently Connected Hosts,&rdquo; ACM Computer Communication Review,&nbsp;Vol. 35, No. 3, July&nbsp;2005.</td></tr>
<tr><td class="author-text" valign="top"><a name="SCOTT">[SCOTT]</a></td>
<td class="author-text">Scott, J. and G. Mapp, &ldquo;Link layer-based TCP optimization for disconnecting networks,&rdquo; ACM Computer Communication Review,&nbsp;Vol. 33, No. 5, October&nbsp;2003.</td></tr>
</table>

<a name="rfc.comments"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>Editorial Comments</h3>
<table border="0">
<tr><td class="author-text" valign="top">
<a class="info" href="#footnote-1">
footnote-1</a><a name="comment.footnote-1"></a>:
</td><td class="author-text">
The authors have heard the idea of triggering retransmits based on connectivity events of directly-connected links being attributed to Phil Karn ("kick" operation in the KAQ9 TCP stack).  A thread from the PILC mailing list in 2000 discusses some thoughts on this (http://www.isi.edu/pilc/list/archive/0691.html).</td></tr>
<tr><td class="author-text" valign="top">
<a class="info" href="#footnote-2">
footnote-2</a><a name="comment.footnote-2"></a>:
</td><td class="author-text">
Although this specification introduces eight new per-connection state variables, a preliminary implementation of an earlier revision of this mechanism [I-D.swami-tcp-lmdr] only required around a hundred lines of kernel code.</td></tr>
</table>

<a name="classification"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.A"></a><h3>Appendix A.&nbsp;
Background: Classification of Connectivity Disruptions</h3>

<p>
Connectivity disruptions can occur in many different situations. They can be due to wireless interference, movement out of a wireless coverage area, switching between access networks, or simply due to unplugging an Ethernet cable. Depending on the situation in which they occur, the implications of connectivity disruptions are different and must be handled appropriately. This section attempts to classify different types of connectivity disruptions and discusses their implications and impact on TCP.
	
</p>
<p>
Two main properties of connectivity disruptions affect how TCP reacts to them: their duration and whether the path characteristics have significantly changed after they end. This document distinguishes between "short" and "long" disruptions and "changed" and "unchanged" path characteristics. Note that these two categories are orthogonal to each other, i.e., four types of connectivity disruptions exist.
	
</p>
<p>
Connectivity disruptions are "short" for a given TCP connection, if connectivity returns before the RTO fires for the first time, i.e., when TCP is still in steady-state. In this case, standard TCP recovers lost data segments through Fast Retransmit and lost ACKs through successfully delivered later ACKs. <a class='info' href='#short'>Appendix&nbsp;A.1<span> (</span><span class='info'>Short Connectivity Disruptions</span><span>)</span></a> briefly describes this case.
	
</p>
<p>
Connectivity disruptions are "long" for a given TCP connection, if the RTO fires at least once before connectivity returns, i.e., when TCP is in exponential back-off. In this case, TCP can be inefficient in its retransmission scheme, as described in <a class='info' href='#long'>Appendix&nbsp;A.2<span> (</span><span class='info'>Long Connectivity Disruptions</span><span>)</span></a>.
	
</p>
<p>
Whether or not path characteristics change when connectivity returns is a second important factor for TCP's retransmission scheme. Standard TCP implicitly assumes that path characteristics remain unchanged across short disruptions by performing Fast Retransmit using the path parameters collected before the disruption. For long disruptions, standard TCP is more conservative and performs slow-start, re-probing the path characteristics from scratch. However, the standard behavior can be inefficient due to when it is initiated.
	
</p>
<p>
These implicit assumptions can cause standard TCP to misbehave or perform inefficiently in some scenarios. <a class='info' href='#standard-behavior'>Figure&nbsp;4<span> (</span><span class='info'>Standard TCP behavior.</span><span>)</span></a> illustrates the standard TCP behavior.
	
</p><br /><hr class="insert" />
<a name="standard-behavior"></a>
<div style='display: table; width: 0; margin-left: auto; margin-right: auto'><pre>
         +-----------------------+-----------------------+
Short    | Fast Retransmit using | Fast Retransmit using |
Duration | currently collected   | currently collected   |
&lt; RTO    | path characteristics  | path characteristics  |
         +-----------------------+-----------------------+
Long     |                       |                       |
Duration | Slow-start            | Slow-start            |
&gt;= RTO   |                       |                       |
         +-----------------------+-----------------------+
             Unchanged Path          Changed Path
             Characteristics         Characteristics

</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;4: Standard TCP behavior.&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<a name="short"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.A.1"></a><h3>A.1.&nbsp;
Short Connectivity Disruptions</h3>

<p>

One common cause of short connectivity disruptions that result in a change of
the end-to-end path characteristics is transparent network layer mobility, via
protocols such as Mobile IP, NEMO, or HIP.  These protocols generally hide mobility events from the transport layer, but cannot mask the resulting changes to the end-to-end path that established TCP connections transmit over.

		
</p>
<p>

Consider a Mobile IP scenario as shown in <a class='info' href='#fig-path-change'>Figure&nbsp;5<span> (</span><span class='info'>Mobility example.</span><span>)</span></a>. At time T, a mobile node MN attaches to access network
Net-1, connected to the Internet through access router AR-1 and has the care-of
address &lt;Net-1, MN&gt;.  It establishes a TCP connection to the
correspondent node CN.  While MN attaches to AR-1, packets between CN and
&lt;Net-1, MN&gt; follow PATH-1 (via Cloud-1 and AR-1). Assume
that at some time T+1, MN moves and then attaches to Net-2, which is
reachable through AR-2 with the care-of address &lt;Net-2, MN&gt;.  While MN attaches to AR-2, all packets between CN and &lt;Net-2, MN&gt; follow
PATH-2 (through Cloud-2 and AR-2).


</p><br /><hr class="insert" />
<a name="fig-path-change"></a>
<div style='display: table; width: 0; margin-left: auto; margin-right: auto'><pre>

             &lt;---------PATH-1----------&gt;

              /---------\   +------+
              |         |   |      | Net-1
          +---+ Cloud-1 +---+ AR-1 +-----&gt; MN (time=T)
          |   |         |   |      |
          |   \----+----/   +---+--+        |
          |        |                        |
CN &lt;------+        | PATH-3                 |
          |        |                        |
          |   /----V----\   +-------+       V
          |   |         |   |       |
          +---+ Cloud-2 +---+ AR-2  +-----&gt; MN (time=T+1)
              |         |   |       | Net-2
              \---------/   +-------+

             &lt;--------PATH-2-----------&gt;
</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;5: Mobility example.&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>
During a transient disconnected period, MN may have disconnected from Net-1 and not yet attached to Net-2. Consequently, AR-1 may not be able to deliver packets to MN.  This could result in a burst of packet losses.  Several approaches for "fast" or "seamless" handovers exist that involve adding machinery to the ARs to buffer and redirect packets originally sent to Net-1 towards Net-2, rather than dropping them (e.g., <a class='info' href='#KOODLI'>[KOODLI]<span> (</span><span class='info'>Koodli, R. and C. Perkins, &ldquo;Fast Handovers and Context Transfers in Mobile Networks,&rdquo; October&nbsp;2001.</span><span>)</span></a>).

               
</p>
<p>

 As long as MN remains in Net-1, standard congestion control algorithms
<a class='info' href='#RFC2581'>[RFC2581]<span> (</span><span class='info'>Allman, M., Paxson, V., and W. Stevens, &ldquo;TCP Congestion Control,&rdquo; April&nbsp;1999.</span><span>)</span></a> are sufficient. However, once MN moves from Net-1 to
Net-2, two different scenarios are possible depending on network
topology:

		
</p>
<p>
</p>
<ul class="text">
<li>

In the first scenario, with standard Mobile IPv4, all packets destined to &lt;Net-1, MN&gt;
are dropped by AR-1 once MN has moved.  Since the latency involved
in establishing a new tunnel to the HA is on the order of the RTT (2*RTT in case of Mobile IPv6), roughly an entire window's worth of data and ACKs will be dropped by AR-1.  Because of this burst loss, CN and MN are likely to incur
expensive retransmission timeouts.

                
</li>
<li>

In the second scenario, with a fast handover mechanism in place, losses are masked through buffering and tunneling between routers AR-1 and AR-2.  The exact sequence of buffering and forwarding between the ARs is not guaranteed to occur in a manner consistent with the available bandwidth of PATH-3 or conformant to TCP's clocking expectations.  This can cause TCP's behavior over PATH-2 to be based on the unrelated properties of PATH-1 and PATH-3.

                
</li>
</ul><p>

</p>
<p>

After attaching to Net-2, reception of stale ACKs (for data sent on PATH-1) will cause MN to incorrectly inflate its congestion window.  These stale ACKs do not provide any indication of the congestion along PATH-2. CN's congestion window becomes similarly inflated by ACKs that MN sends for data segments redirected over PATH-3.  If the congestion windows from PATH-1 are already too big for PATH-2, this can overload Net-2 or PATH-2, causing packet loss and timeouts.

               
</p>
<p>

On the other hand, if the available bandwidth along PATH-2 is greater than along PATH-1, and if the sender is in congestion avoidance, it will need potentially many RTTs before utilizing the available path capacity.  This is due to relatively slow bandwidth increase during congestion avoidance caused by a stale SS_THRESH. (See <a class='info' href='#EDDY'>[EDDY]<span> (</span><span class='info'>Eddy, W. and Y. Swami, &ldquo;Adapting End-host Congestion Control for Mobility,&rdquo; July&nbsp;2005.</span><span>)</span></a> for details.)

		
</p>
<a name="long"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.A.2"></a><h3>A.2.&nbsp;
Long Connectivity Disruptions</h3>

<p>
For long disruptions, standard TCP performs slow-start after connectivity returns, because the retransmission timeout (RTO) has expired. This conservative strategy avoids overloading the new path. However, TCP's general exponential back-off retransmission strategy can time these slow-starts such that performance decreases.
		
</p>
<p>
When a long connectivity disruption occurs along the path between a host and its peer while the host is transmitting data, it stops receiving ACKs. After the RTO expires, the host attempts to retransmit the first unacknowledged segment. TCP implementations that follow the recommended RTO management proposed in <a class='info' href='#RFC2988'>[RFC2988]<span> (</span><span class='info'>Paxson, V. and M. Allman, &ldquo;Computing TCP's Retransmission Timer,&rdquo; November&nbsp;2000.</span><span>)</span></a> double the RTO after each retransmission attempt until it exceeds 60 seconds. This scheme causes a host to attempt to retransmit across established connections roughly once a minute. (More frequently during the first minute or two of the connectivity disruption, while the RTO is still being backed off.)
		
</p>
<p>
When the long connectivity disruption ends, standard TCP implementations still wait until the RTO expires before attempting retransmission. <a class='info' href='#default-rto'>Figure&nbsp;6<span> (</span><span class='info'>Standard TCP behavior in the presence of disrupted connectivity.</span><span>)</span></a> illustrates this behavior. Depending on when connectivity becomes available again, this can waste up to a minute of connectivity for TCPs that implement the recommended RTO management described in <a class='info' href='#RFC2988'>[RFC2988]<span> (</span><span class='info'>Paxson, V. and M. Allman, &ldquo;Computing TCP's Retransmission Timer,&rdquo; November&nbsp;2000.</span><span>)</span></a>. For TCP implementations that do not implement <a class='info' href='#RFC2988'>[RFC2988]<span> (</span><span class='info'>Paxson, V. and M. Allman, &ldquo;Computing TCP's Retransmission Timer,&rdquo; November&nbsp;2000.</span><span>)</span></a>, even longer connectivity periods may be wasted. For example, Linux uses 120 seconds as the maximum RTO by default.
		
</p><br /><hr class="insert" />
<a name="default-rto"></a>
<div style='display: table; width: 0; margin-left: auto; margin-right: auto'><pre>
Sequence
number      X = Successfully transmitted segment
 ^          O = Lost segment
 |     :                     :              : X
 |     :                     :              :X
 |     OO O  O    O        O :              X
 |    X:                     :              :
 |   X :                     :&lt;------------&gt;:
 |  X  :                     :    Wasted    :
 | X   :                     :  connection  :
 |X    :                     :     time     :
 +-----:---------------------:--------------:--------&gt;
       :                     :              :       Time
  Connectivity          Connectivity       TCP
     gone                  back         retransmit
</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;6: Standard TCP behavior in the presence of disrupted connectivity.&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>
This retransmission behavior is not efficient, especially in scenarios where connectivity periods are short and connectivity disruptions are frequent <a class='info' href='#OTT'>[OTT]<span> (</span><span class='info'>Ott, J. and D. Kutscher, &ldquo;OTT Internet: IEEE 802.11b for Automobile Users,&rdquo; March&nbsp;2004.</span><span>)</span></a>. Experiments show that TCP performance across a path with frequent disruptions is significantly worse, compared to a similar path without disruptions <a class='info' href='#SCHUETZ'>[SCHUETZ]<span> (</span><span class='info'>Schuetz, S., Eggert, L., Schmid, S., and M. Brunner, &ldquo;Protocol Enhancements for Intermittently Connected Hosts,&rdquo; July&nbsp;2005.</span><span>)</span></a>.
		
</p>
<p>
In the ideal case, TCP would attempt a retransmission as soon as connectivity to its peer was re-established. <a class='info' href='#ideal-rto'>Figure&nbsp;7<span> (</span><span class='info'>Ideal TCP behavior in the presence of disrupted connectivity</span><span>)</span></a> illustrates the ideal behavior.
		
</p><br /><hr class="insert" />
<a name="ideal-rto"></a>
<div style='display: table; width: 0; margin-left: auto; margin-right: auto'><pre>
Sequence
number      X = Successfully transmitted segment
 ^          O = Lost segment
 |     :                     : X            :
 |     :                     :X             :
 |     OO O  O    O        O X              :
 |    X:                     :              :
 |   X :                     :&lt;------------&gt;:
 |  X  :                     :  Efficiency  :
 | X   :                     :  improvement :
 |X    :                     :              :
 +-----:---------------------:--------------:--------&gt;
       :                     :              :       Time
  Connectivity          Connectivity      Next
     gone             back := immediate  scheduled
                       TCP retransmit   retransmit
</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;7: Ideal TCP behavior in the presence of disrupted connectivity&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>
The ideal behavior is difficult to achieve for arbitrary connectivity disruptions. One obviously problematic approach would use higher-frequency retransmission attempts to enable earlier detection of whether connectivity has returned. This can generate significant amounts of extra traffic. Other proposals attempt to trigger faster retransmissions by retransmitting buffered or newly-crafted segments from inside the network <a class='info' href='#SCOTT'>[SCOTT]<span> (</span><span class='info'>Scott, J. and G. Mapp, &ldquo;Link layer-based TCP optimization for disconnecting networks,&rdquo; October&nbsp;2003.</span><span>)</span></a><a class='info' href='#I-D.dawkins-trigtran-linkup'>[I&#8209;D.dawkins&#8209;trigtran&#8209;linkup]<span> (</span><span class='info'>Dawkins, S., &ldquo;End-to-end, Implicit 'Link-Up' Notification,&rdquo; October&nbsp;2003.</span><span>)</span></a><a class='info' href='#DUKE'>[DUKE]<span> (</span><span class='info'>Duke, M., Henderson, T., and J. Meegan, &ldquo;Experience with ``Link-UP Notification'' Over a Mobile Satellite Link,&rdquo; July&nbsp;2004.</span><span>)</span></a><a class='info' href='#RFC3819'>[RFC3819]<span> (</span><span class='info'>Karn, P., Bormann, C., Fairhurst, G., Grossman, D., Ludwig, R., Mahdavi, J., Montenegro, G., Touch, J., and L. Wood, &ldquo;Advice for Internet Subnetwork Designers,&rdquo; July&nbsp;2004.</span><span>)</span></a>. 
		
</p>
<p>
Note that scenarios exist where path characteristics remain unchanged after long connectivity disruptions. In this case, even an intelligently scheduled slow-start is inefficient, because TCP could safely resume transmitting at the old rate instead of slow-starting. Although originally developed to avoid line-rate bursts, techniques for the well-known "slow-start after idle" case <a class='info' href='#I-D.ietf-tcpimpl-restart'>[I&#8209;D.ietf&#8209;tcpimpl&#8209;restart]<span> (</span><span class='info'>Hughes, A., Touch, J., and J. Heidemann, &ldquo;Issues in TCP Slow-Start Restart After Idle,&rdquo; March&nbsp;1998.</span><span>)</span></a> may be useful to further improve performance after a disruption ends in such a scenario. This document does not currently describe this additional optimization, and an open question remains on how unchanged path characteristics after long connectivity disruptions could be validated by an end host.
		
</p>
<a name="anchor13"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.B"></a><h3>Appendix B.&nbsp;
Document Revision History</h3>
<table class="full" align="center" border="0" cellpadding="2" cellspacing="2">
<col align="left"><col align="left" width="85%">
<tr><th align="left">Revision</th><th align="left">Comments</th></tr>
<tr>
<td align="left">02</td>
<td align="left">Major modification to the RLCI mechanism for implementing a 3-way handshake that ensures that both peers are informed about a connectivity-change indication. CCI TCP option format, RLCI variables maintained by the TCP peers and the related state machines are affected by that modification.</td>
</tr>
<tr>
<td align="left">&nbsp;</td>
<td align="left">&nbsp;</td>
</tr>
<tr>
<td align="left">01</td>
<td align="left">Major revision of the description of the  connectivity-change indication TCP option and its processing in <a class='info' href='#sec-tcp-response-cci'>Section&nbsp;4<span> (</span><span class='info'>TCP Response to Connectivity-Change Indications</span><span>)</span></a>.  Other formatting changes to the document include moving some background material to the appendix.</td>
</tr>
<tr>
<td align="left">&nbsp;</td>
<td align="left">&nbsp;</td>
</tr>
<tr>
<td align="left">00</td>
<td align="left">Initial version. This document is a merge of and obsoletes <a class='info' href='#I-D.eggert-tcpm-tcp-retransmit-now'>[I&#8209;D.eggert&#8209;tcpm&#8209;tcp&#8209;retransmit&#8209;now]<span> (</span><span class='info'>Eggert, L., &ldquo;TCP Extensions for Immediate Retransmissions,&rdquo; June&nbsp;2005.</span><span>)</span></a> and <a class='info' href='#I-D.swami-tcp-lmdr'>[I&#8209;D.swami&#8209;tcp&#8209;lmdr]<span> (</span><span class='info'>Swami, Y., &ldquo;Lightweight Mobility Detection and Response (LMDR) Algorithm for TCP,&rdquo; March&nbsp;2006.</span><span>)</span></a>. </td>
</tr>
</table>
<br clear="all" />

<a name="rfc.authors"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>Authors' Addresses</h3>
<table width="99%" border="0" cellpadding="0" cellspacing="0">
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Simon Schuetz</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">NEC Laboratories Europe</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Kurfuerstenanlage 36</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Heidelberg  69115</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Germany</td></tr>
<tr><td class="author" align="right">Phone:&nbsp;</td>
<td class="author-text">+49 6221 4342 165</td></tr>
<tr><td class="author" align="right">Fax:&nbsp;</td>
<td class="author-text">+49 6221 4342 155</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:simon.schuetz@nw.neclab.eu">simon.schuetz@nw.neclab.eu</a></td></tr>
<tr><td class="author" align="right">URI:&nbsp;</td>
<td class="author-text"><a href="http://www.nw.neclab.eu">http://www.nw.neclab.eu</a></td></tr>
<tr cellpadding="3"><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Nikolaos Koutsianas</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Nokia Research Center</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">P.O. Box 407</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Nokia Group  00045</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Finland</td></tr>
<tr><td class="author" align="right">Phone:&nbsp;</td>
<td class="author-text">+358 50 48 36197</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:nikolaos.koutsianas@nokia.com">nikolaos.koutsianas@nokia.com</a></td></tr>
<tr cellpadding="3"><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Lars Eggert</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Nokia Research Center</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">P.O. Box 407</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Nokia Group  00045</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Finland</td></tr>
<tr><td class="author" align="right">Phone:&nbsp;</td>
<td class="author-text">+358 50 48 24461</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:lars.eggert@nokia.com">lars.eggert@nokia.com</a></td></tr>
<tr><td class="author" align="right">URI:&nbsp;</td>
<td class="author-text"><a href="http://research.nokia.com/people/lars_eggert/">http://research.nokia.com/people/lars_eggert/</a></td></tr>
<tr cellpadding="3"><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Wesley M. Eddy</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Verizon Federal Network Systems</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">NASA Glenn Research Center</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">21000 Brookpark Road, MS 54-5</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Cleveland, OH  44135</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">USA</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:weddy@grc.nasa.gov">weddy@grc.nasa.gov</a></td></tr>
<tr cellpadding="3"><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Yogesh Prem Swami</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Nokia Research Center, Dallas</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">955 Page Mill Road</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Palo Alto, California  94304</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">USA</td></tr>
<tr><td class="author" align="right">Phone:&nbsp;</td>
<td class="author-text">+1 972 374 0669</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:yogesh.swami@nokia.com">yogesh.swami@nokia.com</a></td></tr>
<tr cellpadding="3"><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Khiem Le</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Nokia Siemens Networks</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">6000 Connection Drive</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Irving, TX  75039</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">USA</td></tr>
<tr><td class="author" align="right">Phone:&nbsp;</td>
<td class="author-text">+1 972 342 3502</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:khiem.le@nsn.com">khiem.le@nsn.com</a></td></tr>
</table>
<a name="rfc.copyright"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>Full Copyright Statement</h3>
<p class='copyright'>
Copyright &copy; The IETF Trust (2007).</p>
<p class='copyright'>
This document is subject to the rights,
licenses and restrictions contained in BCP&nbsp;78,
and except as set forth therein,
the authors retain all their rights.</p>
<p class='copyright'>
This document and the information contained herein are provided
on an &ldquo;AS IS&rdquo; basis and THE CONTRIBUTOR,
THE ORGANIZATION HE/SHE REPRESENTS
OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY, THE IETF TRUST
AND THE INTERNET ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT
THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY
IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR
PURPOSE.</p>
<h3>Intellectual Property</h3>
<p class='copyright'>
The IETF takes no position regarding the validity or scope of any
Intellectual Property Rights or other rights that might be claimed
to pertain to the implementation or use of the technology
described in this document or the extent to which any license
under such rights might or might not be available; nor does it
represent that it has made any independent effort to identify any
such rights.
Information on the procedures with respect to
rights in RFC documents can be found in BCP&nbsp;78 and BCP&nbsp;79.</p>
<p class='copyright'>
Copies of IPR disclosures made to the IETF Secretariat and any
assurances of licenses to be made available,
or the result of an attempt made to obtain a general license or
permission for the use of such proprietary rights by implementers or
users of this specification can be obtained from the IETF on-line IPR
repository at <a href='http://www.ietf.org/ipr'>http://www.ietf.org/ipr</a>.</p>
<p class='copyright'>
The IETF invites any interested party to bring to its attention
any copyrights,
patents or patent applications,
or other
proprietary rights that may cover technology that may be required
to implement this standard.
Please address the information to the IETF at <a href='mailto:ietf-ipr@ietf.org'>ietf-ipr@ietf.org</a>.</p>
</body></html>
