r = GG.RandomScalar()
E = r * A
F = r * C
hashInput = A || B || C || D || E || F
cbytes = Hash(hashInput)
c = GG.HashToGroup(cbytes)
z = r + k * c
hashInput = A || B || C || D || proof.E || proof.F
cbytes = Hash(hashInput)
c = GG.HashToGroup(cbytes)
cBE = cB + proof.E
cDF = cD + proof.F
zA = proof.z * A
zC = proof.z * C
pkVerified = PKVerify(pkM, pkT, pkProofs)

output = Finalize(input, blind, evaluatedElement, blindedElement, pkT, proof)

ais = []
his = []
h = GG.NewGroupGenerator()
a0 = GG.RandomScalar()
ai = GG.RandomScalar()
hi = GG.ScalarMult(h, ais[i])
P0 = GG.ScalarBaseMult(a0)
skM = (a0, ais)
pkM = (GG.g, h, metadataBits, P0, his)
pis = []
pi = skM.a0
keyBits = len(metadata)
pi = pi * skM[i]
skT = pi
pkT = GG.ScalarMultBase(skT)
pkProofs = GenProofs(metadata, pis, skM, pkM)
proofs = []
numProofs = len(pis)
previousPi = pkM.P0
Pi = GG.ScalarBaseMult(pis[i])
proofi = DLEQProve(skM.ais[i], pkM.h, pkM.his[i], previousPi, Pi)
previousPi = Pi
previousPi = pkM.P0
proofVerified = True
Pi = proof.Pi
verified = DLEQVerify(pkM.h, pkM.his[i], previousPi, Pi, proof)
proofVerified = proofVerified & verified
previousPi = Pi
