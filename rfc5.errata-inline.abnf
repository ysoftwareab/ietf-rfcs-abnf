file = mesdecl $declaration $procedure "FINISH";

procedure =

           procname (

              (

                 type "FUNCTION" /

                 "PROCEDURE" ) .id (type .id / -empty)) /

              "CO-ROUTINE") ' /

           $declaration labeledst $(labeledst ';) "endp.";

labeledst = ((left arrow symbol).id ': / .empty) statement;

type = "INTEGER" / "REAL" ;

procname = .id;

declaration = numbertype / structuredtype / label / lcl2uhr /
numbertype = : ("REAL" / "INTEGER") ("CONSTANT" conlist /
conlist =

         .id '(left arrow symbol)constant

         $('. .id '(left arrow symbol)constant);

varlist =

         .id ('(left arrow symbol)constant / .empty)

         $('. .id('(left arrow symbol)constant / .empty));

idlist = .id $('. .id);

structuredtype = (tree" / "pointer" / "buffer" ) idlist;

label = "LABEL1" idlist;

pipetype = PIPE" pairedids $(', pairedids);

pairedids = .id .id;

procname = .id;

integerv = .id;

pipename = .id;

labelv = .id;

exp = "IF" conjunct "THEN" exp "ELSE" exp;

sum = term (

         '+ sum /

         '- sum /

         -empty);

term = factor (

         '* term /

         '/ term /

         '(up arrow symbol) term /

         .empty);

factor = '- factor / bitop;

bitop = compliment (

         '/' bitop /

         '/'\ bitop /

         '& bitop / (

         .empty);

compliment = "--" primary / primary;

primary =

         constant /

         builtin /

         variable / (

         block /

         '( exp ');

variable = .id (

         '(symbol for left arrow) exp /

         '( block ') /

         .empty);

constant =  integer / real / string;

builtin =

         mesinfo /

         cortnin /

         ("MIN" / "MAX") exp $('. exp) '/ ;

conjunct = disjunct ("AND" conjunct / .empty);

disjunct = negation ("OR" negation / .empty);

negation = "NOT" relation / relation;

relation =

         '( conjunct ') /

         sum (

           "<=" sum /

           ">=" sum /

           '< sum /

           '> sum /

           '= sum /

           '" sum /

           .empty);

statement = conditional / unconditional;

unconditional = loopst / cases / cibtrikst / uist / treest /
conditional = "IF" conjunct "THEN" unconditional (

         "ELSE" conditional /

         .empty);

block = "begin" exp $('; exp) "end";

treest = setpntr / insertpntr / deletepntr;

setpntr = "set" "pointer" pntrname "to" pntrexp;

pntrexp = direction pntrexp / pntrname;

insertpntr = "insert" pntrexp "as"

         (("left" / "right") "brother") /

         (("first" / "last: ) "daughter") "of" pntrexp;

direction =

         "up" /

         "down" /

         "forward" /

         "backward: /

         "head" /

         "tail";

plantree = "replace" pntrname "with" pntrexp;

deletepntr = "delete: pntrname;

tree = '( tree1 ') ;

tree1 = nodename $nodename ;

nodename = terminal / '( tree1 ');

terminal = treename / buffername / point ername;

treename = id;

treedecl = "pointer" .id / "tree" .id;

controlst = gost / subst / loopstr / casest;

gost = "GO" "TO" (labelv / .id);

assignlabel = "ASSIGN" .id "TO" labelv;

subst = callst / returnst / cortnout;

callst = "CALL" procname (exp / .emptyu);

returnst = "RETURN" (exp / .empty);

cortnout = "STUFF" exp "IN" pipename;

cortnin = "FETCH" pipename;

loopst = whilest / untilst / forst;

whilest = "WHILE" conjunct "DO" statement;

untilst = "UNTIL" conjunct "DO" statement;

forst = "FOR" integerv '- exp ("BY" exp / .empty) "TO" exp

casest = ithcasest / condcasest;

ithcasest = "ITHCASE" exp "OF" "BEGIN" statement $(';
condcasest = "CASE" exp "OF" "BEGIN" condcs $('; condcs)
condcs = conjunct ': statement;

null = "NULL";

iost = messagest / dspyst ;

messagest = buildmes / demand;

buildmest = startmes / appendmes / sendmes;

startmes = "start" "message";

appendmes = "append" "message" "byute" exp;

sendmes = "send" "message";

demandmes = "demand" "Message";

mesinfo =

         "get" "message" "byte"

         "message1" "length" /

         "message" empty: '?;

mesdecl = "message" "bytes" "are" ,byn "bits" long" '..

dspyst = startbuffer / bufappend / estab;

bufappend = "append" bufstuff $('& bufstuff);

bufstuff = :

         "parameters" dspyparm $('. dspyparm) /

         "character" exp /

         "string"1 strilng /

         "vector" ("from" exp ':exp / .empty) "to" exp '. exp /

         "position" (onoff / .empty) "beam" "to" exp '= exp/

         curve" ;

onoff = "on" / "off";

estab = "establish" buffername;

