XML Digital Signatures Working Group               D. Eastlake,
INTERNET-DRAFT                                             IBM
draft-ietf-xmldsig-core-03.txt                       J. Reagle,
Expires July 04, 2000                                   W3C/MIT
                                                       D. Solo,
                                                      Citigroup

                         XML-Signature Core Syntax
                                      
Copyright Notice

   Copyright (c) 2000 The Internet Society & W3C (MIT, INRIA, Keio), All
   Rights Reserved.
   
IETF Status of this Memo

   This document is an Internet-Draft and is in full conformance with all
   provisions of Section 10 of RFC2026.
   
   Internet-Drafts are working documents of the Internet Engineering Task
   Force (IETF), its areas, and its working groups. Note that other
   groups may also distribute working documents as Internet-Drafts.
   
   Internet-Drafts are draft documents valid for a maximum of six months
   and may be updated, replaced, or obsoleted by other documents at any
   time. It is inappropriate to use Internet- Drafts as reference
   material or to cite them other than as "work in progress."
   
   The list of current Internet-Drafts can be accessed at
   http://www.ietf.org/ietf/1id-abstracts.txt
   
   The list of Internet-Draft Shadow Directories can be accessed at
   http://www.ietf.org/shadow.html.
   
W3C Status of this document

   This document is a production of the joint IETF/W3C XML Signature
   Working Group.
   
   http://www.w3.org/Signature
   
   The comparable html draft of this version may be found at
   
   http://www.w3.org/TR/2000/WD-xmldsig-core-20000104/
   
   The latest version of this draft series may be found at:
   
   http://www.w3.org/TR/xmldsig-core
   
   This is a public WG Draft. This draft includes many improvements to
   the exposition. Few design changes have been made, the most
   significant change is a move from the ObjectReference to the Reference
   element type. This version includes the experimental use of XML Schema
   and XML entity references and DTD declarations. The XML schema
   declarations within the specification may contain errors, though the

Eastlke, Reagle, Solo					[Page 1]


Internet Draft		XML-Signature Core Syntax	January 2000


   complete WG schema definition does validate to the Schema DTD. We
   expect the final draft will include a DTD and schema. We hope to issue
   a Working Group last call soon, and an institutuional (IETF/W3C) last
   call as soon as possible afterwards.
   
   Please send comments to the editors and cc: the list
   <w3c-ietf-xmldsig@w3.org>. Publication as a Working Draft does not
   imply endorsement by the W3C membership or IESG. This is a draft
   document and may be updated, replaced or obsoleted by other documents
   at any time. It is inappropriate to cite W3C Drafts as other than
   "work in progress." A list of current W3C working drafts can be found
   at http://www.w3.org/TR
   
   Patent disclosures relevant to this specification may be found on the
   WG's patent disclosure page.
   
Abstract

   This document specifies digital signature processing rules and XML
   syntax. XML Signatures provide integrity, message authentication,
   and/or signer authentication services for data of any type, whether
   located within the XML that includes the signature or elsewhere.
   
Table of Contents

    1. Introduction
         1. Editorial Conventions
         2. Design Philosophy
         3. Namespaces and Identifiers
         4. Versions
    2. Signature Overview
         1. The Signature Element
         2. The SignedInfo Element
         3. The Reference Element
         4. The Manifest and Package Elements
         5. The SignatureProperties Element
    3. Core Signature Syntax
         1. The Signature element
         2. The SignatureValue Element
         3. The SignedInfo Element
         4. The KeyInfo Element
         5. The Object Element
    4. Additional Signature Syntax
         1. The Manifest and Package Elements
         2. The SignatureProperties Element
         3. Processing Instructions
         4. Comments in dsig Elements
    5. Algorithms
         1. Algorithm Identifiers, Parameters, and Implementation
            Requirements
         2. Message Digests
         3. Message Authentication Codes
         4. Signature Algorithms

Eastlke, Reagle, Solo					[Page 2]


Internet Draft		XML-Signature Core Syntax	January 2000


         5. Canonicalization Algorithms
         6. Transform Algorithms
    6. Processing Rules
         1. Generation
         2. Signature Validation
    7. Security Considerations
         1. Only What is Signed is Secure
         2. Only What is "Seen" Should be Signed
         3. Check the Security Model
         4. Algorithms, Key Lengths, Etc.
    8. Example Syntax
    9. Schema
   10. Definitions
   11. Other Useful Types (normative)
   12. References
   13. Acknowledgements (non-normative)
   14. Open Issues (non-normative)
     _________________________________________________________________
   
1.0 Introduction

   This document specifies XML syntax and processing rules for creating
   and representing digital signatures. XML Signatures can be applied to
   any digital content (data object) including XML or other data.
   Furthermore, an XML Signature may be applied to the content of one or
   more resources: enveloped or envoloping signatures are over data
   within the same XML document as the signature; detached signatures are
   over data  referenced externally via a URI.
   
   This document also defines other useful types including methods of
   referencing collections of resources, and key management and algorithm
   definitions.
   
  1.1 Editorial Conventions
  
   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
   document are to be interpreted as described in [RFC2119].
   
   This document includes a list of open issues which are still being
   addressed by the working group and may include editorial comments
   within the text.
   
  1.2 Design Philosophy
  
   The design philosophy and requirements of this specification are
   addressed in the XML-Signature Requirements document
   [XML-Signature-RD].
   
  1.3 Namespaces and Identifiers
  
   The XML namespace [XML-ns] URI that MUST be used by experimental
   implementations of this dated specification is:

Eastlke, Reagle, Solo					[Page 3]


Internet Draft		XML-Signature Core Syntax	January 2000


   
   xmlns="http://www.w3.org/2000/01/xmldsig/"
   
   This namespace is also used as the prefix for algorithm identifiers
   used by this specification. While applications MUST support XML and
   XML-namespaces, the use of internal entities [XML] or our "dsig" XML
   namespace prefix and defaulting/scoping conventions are OPTIONAL; we
   use these facilities so as to provide compact and readable examples.
   
   This specification uses Uniform  Resource Identifiers [URI] to
   identify resources, algorithms, and semantics. The URI in the
   namespace declaration above is also used as a prefix for URIs under
   the control of this specification. For resources not under the control
   of this specification, we use the designated Uniform Resource Names
   [URN] or Uniform Resource Locators [URL] defined by the external
   specification. If an external specification has not allocated itself a
   Uniform Resource Identifier we allocate an identifier under our own
   namespace. For instance:
   
   SignatureProperties is identified and defined by this specifications
          namespace
          http://www.w3.org/2000/01/xmldsig/SignatureProperties
          
   XSLT is identified and defined by an external namespace
          http://www.w3.org/TR/1999/PR-xslt-19991008
          
   SHA1 is identified via this specification's namespace and defined via
          a normative reference
          http://www.w3.org/2000/01/xmldsig/SHA1
          FIPS PUB 180-1. Secure Hash Standard. U.S. Department of
          Commerce/National Institute of Standards and Technology.
          
   This specification uses both XML Schemas [XML-schema] and DTDs [XML];
   while the DTD is presently more buggy, it will likely be the normative
   definition. Readers unfamiliar with DTD syntax may wish to refer to
   Ron Bourret's "Declaring Elements and Attributes in an XML DTD."
   
   Finally, in order to provide for terse namespace declarations we use
   XML internal entities [XML]as macros within URIs. For instance:
   
   <?xml version="1.0" ?>
   <!DOCTYPE Signature SYSTEM "xmldsig.dtd" [
   <!ENTITY dsig 'http://www.w3.org/2000/01/xmldsig/'>]>
     ...
     <SignedInfo>
       <SignatureMethod Algorithm="&dsig;/dsaWithSHA-1"/>
       ...
     </SignedInfo>
   
   Security Comment: XML processors will automatically expand entity
   declarations prior to signature generation. Consequently, this feature
   does not permit a substitution attack whereby an attacker replaces the
   entity declaration with another so as to change the meaning of the

Eastlke, Reagle, Solo					[Page 4]


Internet Draft		XML-Signature Core Syntax	January 2000


   signature. However, since this specification presently permits a
   CanonicalizationMethod of null over SignedInfo, entity declarations
   will not be expanded in those instances (or where the schema is not
   present) and we have not completely assessed the security risk.
   
  1.4 Versions
  
   No provision is made for an explicit version number in this syntax. If
   a future version is needed, it is expected to use a different
   Namespace.
   
2.0 Signature Overview

   This section provides an overview of XML digital signature syntax and
   processing; the formal specification is in section-3: Core Signature
   Syntax. We assume the reader is familiar with basic digital signature
   and XML concepts.
   
   In this section, an informal representation is used to describe the
   structure of the XML signature syntax. This representation omits many
   attributes and details. The following suffix symbols are used to
   represent the number of times elements may occur: "?" denotes zero or
   one occurance; "+" denotes one or more occurances; and "*" denotes
   zero or more occurances.
   
  2.1 The Signature Element
  
   XML Signatures are very flexible and can sign arbitrary digital
   content (data objects). An XML Signature is applied via an
   indirection. Data objects are digested; the resulting value is placed
   in an element (with other information) and that element is then
   digested and cryptographically signed. While the data object(s) are
   not directly operated on by a cryptographic algorithm, we still refer
   to the signature as being over the data object(s). Frequently, content
   is obtained by dereferencing an identified resource. Within an XML
   document, signatures are related to data objects via IDREFs [XML] and
   the data can be included within an envoloping signature or can enclose
   an enveloped signature. Signatures are related to external data
   objects via URIs [URI] and the signature and data object are said to
   be detached.
   
   XML digital signatures are represented by the Signature element which
   has the following structure:
   
   <Signature>
     (SignedInfo)
     (SignatureValue)
     (KeyInfo)?
     (Object)*
   </Signature>
   
   The required SignedInfo element is the information which is actually
   signed. SignedInfo includes a list of References to data objects and

Eastlke, Reagle, Solo					[Page 5]


Internet Draft		XML-Signature Core Syntax	January 2000


   their calculated digest value. The core validation consists of two
   mandatory processes: validation of the signature over SignedInfo and
   validation of each Reference digest within SignedInfo. The algorithms
   used in calculating the SignatureValue are also included in the signed
   information while the SignatureValue element is outside SignedInfo.
   
   KeyInfo indicates what key is to be used to validate the signature.
   Possible forms for identification include certificates, key names, and
   key agreement algorithms and information -- we define only a few.
   KeyInfo is optional for two reasons. First, KeyInfo might contain
   information the signer does not wish to reveal to all signature
   verifiers. Second, the information may be known within the
   application's context and need not be represented explicitly. However,
   if the signer wishes to bind the keying information to the signature,
   a Reference can easily identify and include the KeyInfo as part of the
   signature.
   
   Object is an optional element for including the signed resources
   within the signature document. The Object can be optionally typed
   and/or encoded.
   
   Signature properties, such as time of signing, can be optionally
   included in a SignatureProperties within Object. (These properties are
   traditionally called signature "attributes" although that term in that
   context has no relationship to the XML term "attribute".)
   SignatureProperties can be included within an Object and signed at the
   signer's discretion.
   
  2.2 The SignedInfo Element
  
   The SignedInfo element has the structure indicated below.
   
   <Signature>
     <SignedInfo>
       (CanonicalizationMethod)?
       (SignatureMethod)
       (Reference)+
     </SignedInfo>
     (SignatureValue)
     (KeyInfo)?
     (Object)*
   </Signature>
   
   The CanonicalizationMethod is the algorithm which is used to
   canonicalize the SignedInfo element before it is digested as part of
   the signature operation. In the absence of a CanonicalizationMethod
   element, no canonicalization is done.
   
   The SignatureMethod is the algorithm used to convert the canonicalized
   SignedInfo into the SignatureValue. It is a combination of a digest
   algorithm and a key dependent algorithm and possibly other algorithms
   such as padding, for example RSA-SHA1 or HMAC-SHA1. The algorithm
   names are signed to resist attacks based on substituting a weaker

Eastlke, Reagle, Solo					[Page 6]


Internet Draft		XML-Signature Core Syntax	January 2000


   algorithm.
   
   To promote application interoperability we specify mandatory to
   implement canonicalization, digest, and signature algorithms. We
   specify additional algorithms as recommended or optional and the
   signature design permits arbitrary signer algorithm specification.
   
   Each Reference element includes the digest method and resulting digest
   value calculated over the identified data object. It also may include
   transformations that produce the input to the digest operation. A data
   object is signed by computing its digest value and a signature over
   that value. The signature is later checked via reference and signature
   validation.
   
  2.3 The Reference Element
  
   The Reference element has the structure indicated below.
   
   ...
   <SignedInfo>
      (CanonicalizationMethod)?
      (SignatureMethod)
      (<Reference (URI=|IDREF=)? Type=?>
        (Transforms)?
        (DigestMethod)
        (DigestValue)
      </Reference>)+
   </SignedInfo>
   ...
   
   The optional URI/IDREF attribute of Reference idenitifies the data
   object to be signed. This attribute may be omitted on at most one
   Reference in a Signature.
   
   This identification, along with the transforms, are a description
   provided by the signer on how to obtain the signed resource in the
   form it was digested (i.e. the digested content). The verifier (i.e.,
   relying party) may obtain the digested content in another method so
   long as the digest verifies. In particular, the verifier may obtain
   the content from a different location (particularly a local store)
   other than that specified in the URI/IDREF.
   
   The optional Type attribute provides information about the content of
   the resource identified by URI/IDREF. In particular, it can indicate
   that it contains a SignatureProperties, Manifest, or Package element.
   This information need not be used nor verified by the receiving
   application.
   
   Transforms is an optional ordered list of processing steps that are
   applied to the resource's content before it is digested. Transforms
   can include arbitrary specifications such as canonicalization,
   encoding/decoding (including compression/inflation), XSLT and XPath.
   XPath transforms permit the signer to derive an XML document that

Eastlke, Reagle, Solo					[Page 7]


Internet Draft		XML-Signature Core Syntax	January 2000


   omits portions of the source document. Consequently those excluded
   portions can change without affecting signature validity (this is how
   the Working Group satisfied the requirement of signing portions of a
   document.) For example, if the resource being signed encloses the
   signature itself, such a transform must be used to exclude the
   signature value from its own computation  If no Transforms element is
   present, the resource's content is digested directly.
   
   Arbritrary user specified transforms are permitted. To promote
   interoperability, we specify mandatory to implement canonicalization
   and decoding transformation algorithms. Additional canonicalization,
   coding, XSLT, and XPath based transform algorithms are specified as
   recommended or optional;
   
   DigestMethod is the algorithm applied to the data, after Transforms is
   applied if specified, to yield the DigestValue. The signing of the
   DigestValue is what bind's a resources content to the signer's key.
   
  2.4 The Manifest and Package Elements
  
   The Manifest and Package elements are included to meet requirements
   not directly addressed by this document. The level of indirection
   provided by these elements readily meets these requirements. Two
   examples follow.
   
   First, applications frequently need to efficiently sign multiple data
   objects. This requirement can be achieved by including multiple
   References within SignedInfo. However, some applications may not want
   the core validation behaviour associated with this approach: each
   Reference within SignedInfo undergoes reference validation -- the
   DigestValues are checked. Some applications may wish to reserve
   reference validation decision logic to themselves. For example, an
   application might receive a signature valid SignedInfo element that
   includes three References. If a single Reference fails (the identified
   data object when digested does not yield the specified DigestValue)
   the signature would fail core validation. However, the application may
   wish to treat the signature over the two valid References as valid.
   Second, consider an application where many signatures (using different
   keys) are applied to thousands of documents. An inefficient solution
   is to have a seperate signature (per key) repeatedly applied to a
   large SignedInfo element (with thousands of References); this is very
   redundant.
   
   To address these requirements, additional element types have been
   defined which may be referenced by SignedInfo References. First, the
   Manifest element may contain a collection of References and Objects,
   but leaves reference validation up to the application. Second,
   multiple signatures over the thousands of  References need only point
   to a single Manifest with the many references.
   
   The structure of Manifest, which reuses the Reference and Object
   elements described above, is as follows:
   

Eastlke, Reagle, Solo					[Page 8]


Internet Draft		XML-Signature Core Syntax	January 2000


   <Manifest>
     (Reference)+
     (Object)*
   </Manifest>
   
   A Package is syntactically identical to a Manifest, and may appear
   anywhere a Manifest may appear, but asserts the identity of each of
   its Reference elements after Transforms application.
   
   Manifest and Package may appear as the content of an Object.
   
  2.5 The SignatureProperties Element
  
   This specification does not address mechanisms for making statements
   or assertions. Instead, this whole document singly defines what it
   means for something to be signed by an XML Signature (message
   authentication, integrity, and/or signer authentication). Applications
   that wish to represent other semantics must rely upon other
   technologies, such as [XML, XML-schema, RDF]. However, we do define a
   SignatureProperties element type for the inclusion of assertions about
   how the signature was produced (e.g., the time of signing or the
   serial number of hardware used in cryptographic processes). We do not
   define those element types however, they may, or may not be, signed
   via a Reference, as desired.
   
   <SignatureProperties>
     (SignatureProperty Target= )+
   </SignatureProperties>
   
   The structure of SignatureProperties is shown above. Any content about
   the signature generation may be located within the SignatureProperty
   element. The mandatory Target attribute references the element to
   which the property applies. In particular, target may include a
   reference to a SignedInfo or Reference element.
   
3.0 Core Signature Syntax

   The general structure of an XML signature is described in section-2:
   Signature Overview. This section provides detailed syntax of the core
   signature features and actual examples. Features described in this
   section are mandatory to implement unless otherwise indicated. The
   syntax is defined via [XML-Schema] with the following XML preamble,
   declaration, and internal entity:
   
   Schema Definition:
   <?xml version='1.0'?>
   <!DOCTYPE schema
     SYSTEM
   'http://www.w3.org/TR/1999/WD-xmlschema-1-19991217/structures.dtd'
     [
     <!ENTITY dsig 'http://www.w3.org/2000/01/xmldsig/'>
     ]>
   <schema targetNamespace='http://www.w3.org/2000/01/xmldsig/'

Eastlke, Reagle, Solo					[Page 9]


Internet Draft		XML-Signature Core Syntax	January 2000


           version='0.1'
           xmlns='http://www.w3.org/1999/XMLSchema'>
   
  3.1 The Signature element
  
   The Signature element is the root element of a XML Signature. A simple
   example of a complete signature follows:
   
   Example:
   
   <!DOCTYPE Signature [
   <!ENTITY dsig 'http://www.w3.org/2000/01/xmldsig/'>]>
   <Signature xmlns="http://www.w3.org/2000/01/xmldsig/">
     <SignedInfo>
       <CanonicalizationMethod
        Algorithm="http://www.w3.org/1999/07/WD-xml-c14n-19990729"/>
       <SignatureMethod Algorithm="&dsig;/dsaWithSHA-1"/>
       <Reference Location="http://www.mypage.com">
         <DigestMethod Algorithm="&dsig;/sha1"/>
         <DigestValue encoding="&dsig;/base64">a23bcd43</DigestValue>
       </Reference>
     </SignedInfo>
     <SignatureValue>dd2323dd</SignatureValue>
     <KeyInfo>
        <KeyName>Solo</KeyName>
     </KeyInfo>
   </Signature>
   
   Note: this example will be revised to include generated hash/signature
   values that validate.
   
   Schema Definition:
   <element name='Signature'>
     <type content='elementOnly'>
       <group order='seq' minOccurs='1' maxOccurs='1'>
         <element ref='SignedInfo' minOccurs='1' maxOccurs='1'/>
         <element ref='SignatureValue' minOccurs='1' maxOccurs='1'/>
         <element ref='KeyInfo' minOccurs='0' maxOccurs='1'/>
         <element ref='Object' minOccurs='0' maxOccurs='*'/>
       </group>
       <attribute name='Id' type='ID' minOccurs='0' maxOccurs='1'/>
     </type>
   </element>
   
   DTD:
   <!ELEMENT Signature (SignedInfo, SignatureValue, KeyInfo?, Object*)>
   <!ATTLIST SignedInfo
             Id     ID        #IMPLIED>
   
  3.2 The SignatureValue Element
  
   The SignatureValue element contains the actual value of the digital
   signature. The encoding of this value is determined by

Eastlke, Reagle, Solo					[Page 10]


Internet Draft		XML-Signature Core Syntax	January 2000


   SignatureMethod. Base64 [MIME] is the encoding method for all
   SignatureMethods specified within this specification. The ability to
   define a SignatureMethod and SignatureValue pair which includes
   multiple distinct signatures is explicitly permitted (e.g.
   "rsawithsha-1 and ecdsawithsha-1").
   
   Schema Definition:
   <element name='SignatureValue' type='string'/>
   
   DTD:
   <!ELEMENT SignatureValue CDATA >
   
  3.3 The SignedInfo Element
  
   The structure of SignedInfo includes the canonicalization algorithm
   (if any), a signature algorithm, and one or more references to
   objects. The SignedInfo element may contain an optional ID attribute
   that will allow it to be referenced by other signatures and objects.
   
   Schema Definition:
   <element name='SignedInfo'>
     <type content='elementOnly'>
       <group order='seq' minOccurs='1' maxOccurs='1'>
         <element ref='CanonicalizationMethod' minOccurs='0'
   maxOccurs='1'/>
         <element ref='SignatureMethod' minOccurs='1' maxOccurs='1'/>
         <element ref='Reference' minOccurs='1' maxOccurs='*'/>
       </group>
       <attribute name='Id' type='ID' minOccurs='0' maxOccurs='1'/>
     </type>
   </element>
   
   DTD:
   <!ELEMENT SignedInfo(CanonicalizationMethod, SignatureMethod,
   Reference+ ) >
   <!ATTLIST SignedInfo
             Id     ID        #IMPLIED >
   
   SignedInfo does not include explicit signature properties (such as
   signing time, signing device, etc.). If an application needs to
   associate properties with the signature or digest, it may include such
   information in an Object element that is referenced by a Reference.
   See the SignatureProperties element below.
   
    3.3.1 The CanonicalizationMethod Element
    
   CanonicalizationMethod is an optional element which specifies the
   canonicalization algorithm applied to the SignedInfo element prior to
   performing signature calculations. This element uses the general
   structure here for algorithms described in section-5.1: Algorithm
   Identifiers. Possible options may include a minimal algorithm (CRLF
   and charset normalization), or more extensive operations such as
   [XML-C14N]. If the CanonicalizationMethod is omitted, no change is

Eastlke, Reagle, Solo					[Page 11]


Internet Draft		XML-Signature Core Syntax	January 2000


   made to SignedInfo.
   
   Schema Definition:
   <element name='CanonicalizationMethod'>
     <type content='elementOnly'>
       <element ref='Parameter' minOccurs='1' maxOccurs='1'/>
       <attribute name='Algorithm' type='uri' minOccurs='1'
   maxOccurs='1'/>
   <type>
   </element>
   
   DTD:
   <!ELEMENT CanonicalizationMethod Parameter* >
   <!ATTLIST CanonicalizationMethod
             Algorithm CDATA #REQUIRED >
   
    3.3.2 The SignatureMethod Element
    
   SignatureMethod is a required element which specifies the algorithm
   used for signature generation and validation. This algorithm
   identifies all cryptographic functions involved in the signature
   operation (e.g. hashing, public key algorithms, MACs, padding, etc.).
   This element uses the general structure here for algorithms described
   in section 5.1.   While there is a single identifier, that identifier
   may specify a format containing multiple distinct signature values.
   
   Schema Definition:
   <element name='SignatureMethod'>
     <type content='elementOnly'>
       <element ref='Parameter' minOccurs='0' maxOccurs='*'/>
       <attribute name='Algorithm' type='uri' minOccurs='1'
   maxOccurs='1'/>
   </type>
   </element>
   
   DTD:
   <!ELEMENT SignatureMethod Parameter* >
   <!ATTLIST SignatureMethod
             Algorithm CDATA #REQUIRED >
   
    3.3.3 The Reference Element
    
   Reference is an element that may occur one or more times. It specifies
   a digest algorithm and digest value, and optionally the object being
   signed, the type of the object, and/or a list of transforms to be
   applied prior to digesting. The identification, and transforms are
   information provided to inform the verifier how the digested content
   (i.e., the input to the digest method) may be created. The type
   attribute facilitates the processing of referenced data. For example,
   while this specification makes no requirements over external data, an
   application may wish to signal that the referent is a Manifest. An
   optional ID attribute permits a Reference to be easily referenced from
   elsewhere.

Eastlke, Reagle, Solo					[Page 12]


Internet Draft		XML-Signature Core Syntax	January 2000


   
   Schema Definition:
   <element name='Reference'>
     <type content='elementOnly'>
       <group order='seq' minOccurs='1' maxOccurs='1'>
         <element ref='Transforms' minOccurs='0' maxOccurs='1'/>
         <element ref='DigestMethod' minOccurs='1' maxOccurs='1'/>
         <element ref='DigestValue' minOccurs='1' maxOccurs='1'/>
       </group>
       <attribute name='Id' type='ID' minOccurs='0' maxOccurs='1'/>
       <attribute name='URI' type='uri' minOccurs='0' maxOccurs='1'/>
       <attribute name='IDREF' type='IDREF' minOccurs='0' maxOccurs='1'/>
       <attribute name='Type' type='uri' minOccurs='0' maxOccurs='1'/>
     </type>
   </element>
   
   DTD:
   <!ELEMENT ObjectReference ( Transforms?, DigestMethod, DigestValue ) >
   <!ATTLIST ObjectReference
             Id         ID       #IMPLIED
              URI       CDATA    #IMPLIED
             IDREF     CDATA     #IMPLIED
             Type       CDATA    #IMPLIED>
   <!--      The values of URI and Type conform
             to the productions specified by [URI] -->
   
   The URI/IDREF attribute identifies a data object using a URI [URI] or
   IDREF [XML]. We distinguish between URIs and IDREFs so as to provide
   expositional clarity and ease signature processing. Note there is some
   confusion about URIs and fragment identifiers. As specified by RFC2396
   [URI], URIs can be used in conjunction with a fragment identifier by
   use of a separating pound symbol '#', but the URI proper does not
   include the fragment identifier. (The meaning of the fragment is
   defined by the resource's MIME type). URI/IDREF only permits a 'clean'
   URI or IDREF; fragment identification is specified under Transforms.
   This choice permits References to identify a fragment of a document
   that is encoded: the Reference identifies the resource, the first
   Transform specifies decoding, the second Transform specifies the
   fragement.
   
   Note that a null URI (URI="") is permitted and identifies the document
   the reference is in (the root element).
   
   If the URI/IDREF attribute is omitted all-together, the receiving
   application is expected to know the identity of the object. For
   example, a lightweight data protocol might ommit this attribute given
   the identity of the object is part of the application context. This
   attribute may be omitted from at most one Reference in any particular
   SignedInfo, Manifest, or Package.
   
   The digest algorithm is applied to the data octets being secured.
   Typically that is done by locating (possibly using the URI/IDREF if
   provided) the data and transforming it. If the data is an XML

Eastlke, Reagle, Solo					[Page 13]


Internet Draft		XML-Signature Core Syntax	January 2000


   document, the document is assumed to be unparsed prior to the
   application of Transforms. If there are no Transforms, then the data
   is passed to the digest algorithm unmodified.
   
   The optional Type attribute contains information about the type of
   object being signed (e.g. manifest, package, signature properties,
   document). This is represented as a URI. For example:
   
   Type="&dsig;/Manifest"
   Type="&dsig;/SignatureProperty"
   
    3.3.3.1 The Transforms Element
    
   Transforms is an optional element that contains one or more operations
   to be performed on an indicated data object prior to digest
   calculation. (These operations are different from the
   CanonicalizationMethod specified in the Signature which is applied to
   SignedInfo.) If the Transforms element is omitted, no operations are
   indicated.
   
   The Transforms element contains an ordered list of Transform elements.
   The output of each Transform serves as input to the next Transform.
   The input to the first Transform is the source data. The output from
   the last Transform is the input for the DigestMethod algorithm. When
   transforms are applied the signer is not signing the native (original)
   document but the resulting (transformed) document [sec-7.2: Only What
   is "Seen" Should be Signed].
   
   Each Transform consists of an Algorithm attribute, optional Type and
   Charset attributes, and content parameters, if any, appropriate for
   the given algorithm. The Algorithm attribute value specifies the name
   of the algorithm to be performed, and the Transform content provides
   additional data to govern the algorithm's processing of the input
   resource.
   
   The optional Type and Charset (IANA registered character set)
   attributes are made available to algorithms which need and are
   otherwise unable to deduce that information about the data they are
   processing.
   
   Schema Definition:
   <element name='Transforms' >
     <type content='elementOnly'>
       <element ref='Transform' minOccurs='1' maxOccurs='*'/>
     </type>
   </element>
   <element name='Transform'>
     <type content='elementOnly'>
       <element ref='Parameter' minOccurs='0' maxOccurs='*'/>
       <attribute name='Algorithm' type='string' minOccurs='1'
   maxOccurs='1'/>
       <attribute name='Type' type='uri' minOccurs='0' maxOccurs='1'/>
       <attribute name='Charset' type='string' minOccurs='0'

Eastlke, Reagle, Solo					[Page 14]


Internet Draft		XML-Signature Core Syntax	January 2000


   maxOccurs='1'/>
     </type>
   </element>
   
   DTD:
   <!ELEMENT Transforms Transform+>
   <!ELEMENT Transform ANY> <!-- Including dsig:Parameter -->
   <!ATTLIST Transform
             Algorithm   CDATA     #REQUIRED
             Type         CDATA    #IMPLIED
             Charset      CDATA    #IMPLIED >
   <!--      The Type conforms to the
             productions specified by [URI] -->
   
   Examples of transforms include but are not limited to base-64 decoding
   [MIME], canonicalization [XML-c14n], XPath filtering [Xpath], and XSLT
   [XSLT]. The generic definition of the Transform element also allows
   application-specific transform algorithms. For example, the transform
   could be a decompression routine given by a Java class appearing as a
   base-64 encoded parameter to the Java Transform algorithm. However,
   applications should refrain from using application-specific transforms
   if they wish their signatures to be verifiable outside of their
   application domain. Section 5-6: Transform Algorithms defines the list
   of standard transformations.
   
    3.3.3.2 The DigestMethod Element
    
   DigestMethod is a required element which identifies the digest
   algorithm to be applied to the signed object. This element uses the
   general structure here for algorithms specified in section-5.1:
   Algorithm Identifiers.
   
   Schema Definition:
   <element name='DigestMethod'>
     <type content='elementOnly'>
       <element ref='Parameter' minOccurs='0' maxOccurs='*'/>
       <attribute name='Algorithm' type='uri' minOccurs='1'
   maxOccurs='1'/>
     </type>
   </element>
   
   DTD:
   <!ELEMENT DigestMethod Parameter* >
   <!ATTLIST DigestMethod
             Algorithm CDATA #REQUIRED >
        <!-- Where CDATA conforms to the
             productions specified by [URI] -->
   
    3.3.3.3 The DigestValue Element
    
   DigestValue is an element which contains the encoded value of the
   digest. The optional Encoding attribute gives the encoding method
   which defaults to Base 64 [MIME].

Eastlke, Reagle, Solo					[Page 15]


Internet Draft		XML-Signature Core Syntax	January 2000


   
   Schema Definition:
   <element name='DigestValue'>
     <type source='string'>
       <attribute name='Encoding' type='uri' default='&dsig;/Base64'
       minOccurs='0' maxOccurs='1'/>
     </type>
   </element>
   
   DTD:
   <!ELEMENT DigestValue CDATA>
   <!-- base64 encoded signature value -->
   
  3.4 The KeyInfo Element
  
   KeyInfo may contain keys, names, certificates and other public key
   management information (such as inband key distribution or agreement
   data or data supporting any other method.) This specification defines
   a few simple types but applications may place their own key
   identification and exchange semantics within this element through the
   XML-namespace facility. [XML-namespace]
   
   Schema Definition:
   <element name='KeyInfo'>
     <type content='elementOnly'>
       <group order='choice' minOccurs='1' maxOccurs='1'>
         <element name='KeyName' type='string'/>
         <element name='KeyValue' type='string'/>
         <element name='SubjectName' type='string'/>
         <element name='RetrievalMethod' type='string'/>
         <element ref='X509Data'/>
         <element ref='PGPData'/>
         <element name='MgmtData' type='string' minOccurs='0'
   maxOccurs='1'/>
         <any/>
       </group>
       <attribute name='Id' type='ID' minOccurs='0' maxOccurs='1'/>
     </type>
   </element>
   
   DTD:
   <!ELEMENT KeyInfo (KeyName | KeyValue | SubjectName
             | RetrievalMethod | x509Data | PGPData
             | MgmtData)* )>
   <!ATTLIST KeyInfo
             Id         ID       #IMPLIED>
   <!ELEMENT KeyName (#PCDATA)>
   <!ELEMENT KeyValue (#PCDATA)>
   <!ELEMENT SubjectName (#PCDATA) >
   <!ELEMENT RetrievalMethod (#PCDATA) >
   
   KeyInfo is an optional element which enables the recipient(s) to
   obtain the key(s) needed to validate the signature. If omitted, the

Eastlke, Reagle, Solo					[Page 16]


Internet Draft		XML-Signature Core Syntax	January 2000


   recipient is expected to be able to identify the key based on
   application context information. This element contains one KeyInfo
   data element providing information for the recipient(s). Applications
   may define and use any mechanism they choose through inclusion of
   elements from a different namespace.
   
   Compliant versions implementing KeyInfo MUST implement KeyValue, and
   SHOULD implement RetrievalMethod.
     * KeyName contains an identifier for the key which may be useful to
       the recipient. This may be a name, index, etc.
     * KeyValue contains the actual key(s) used to validate the
       signature. If the key is sent in protected form, the MgmtData
       element should be used. Specific types must be defined for each
       algorithm type (see algorithms).
     * SubjectName contains one or more names for the sender. Forms to be
       supported include a simple name string, encoded DN, email address,
       etc.
     * RetrievalMethod is a URI which may be used to obtain key and/or
       certificate information. The URI should contain the complete
       string for retrieving the key needed for this message (rather than
       a generic URI).
     * X509Data contains an identifier of the key/cert used for
       validation (either an IssuerSerial value, a subject name, or a
       subjectkeyID) and an optional collection of certificates and
       revocation/status information which may be used by the recipient.
       IssuerSerial contains the encoded issuer name (RFC 2253) along
       with the serial number.
     * PGPData data associated with a PGP key.
     * MgmtData contains in-band key distribution or agreement data.
       Examples may include DH key exchange, RSA key encryption etc.
       
   Schema Definition:
   <element name='X509Data'>
     <type content='elementOnly'>
       <group order='seq' minOccurs='1' maxOccurs='1'>
         <group order='choice' minOccurs='1' maxOccurs='1'>
           <element ref='X509IssuerSerial'/>
           <element name='X509SKI' type='string'/>
           <element name='X509Name' type='string'/>
         </group>
         <element name='X509Certificate' type='string' minOccurs='0'
   maxOccurs='1'/>
         <element name='X509CRL' type='string' minOccurs='0'
   maxOccurs='1'/>
       <group>
     </type>
   </element>
     <element name='X509IssuerSerial'>
       <type content='elementOnly'>
         <group order='seq' minOccurs='1' maxOccurs='1'>
           <element name='X509Name' type='string' minOccurs='1'
   maxOccurs='1'/>
           <element name='X509SerialNumber' type='string' minOccurs='1'

Eastlke, Reagle, Solo					[Page 17]


Internet Draft		XML-Signature Core Syntax	January 2000


                    maxOccurs='1'/>
         </group>
       </type>
     </element>
   <element name='PGPData'>
     <type content='elementOnly'>
       <group order='seq' minOccurs='1' maxOccurs='1'>
         <element name='PGPKeyID' type='string' minOccurs='1'
   maxOccurs='1'/>
         <element name='PGPKeyPacket' type='string' minOccurs='1'
   maxOccurs='1'/>
       </group>
     </type>
   </element>
   
   DTD:
   <!ELEMENT X509Data ((X509IssuerSerial | X509SKI | X509Name),
                       (X509Certificate | X509CRL)* ) >
   <!ELEMENT X509IssuerSerial (X509Name, X509SerialNumber)>
   <!ELEMENT X509Name (#PCDATA)>
   <!-- Where the name is encoded accroding to RFC 2253 -->
   <!ELEMENT X509SerialNumber (#PCDATA)>
   <!-- Where the data is the serial number encoded as a decimal integer
   -->
   <!ELEMENT X509SKI (#PCDATA)>
   <!-- Where the data consists of the SKI base64 encoded -->
   <!ELEMENT X509Certificate (#PCDATA)>
   <!-- Where the data conists of the base64 encoded certificate -->
   <!ELEMENT X509CRL (#PCDATA)>
   <!-- Where the data consists of the base64 encoded CRL -->
   <!ELEMENT PGPData (PGPKeyID, PGPKeyPacket?)>
   <!ELEMENT PGPKeyID (#PCDATA)>
   <!-- Where the data conists of the hex encoding of the key ID. -->
   <!ELEMENT PGPKeyPacket (#PCDATA)>
   <!-- Where the data consists of the base64 encoded key packet --->
   <!ELEMENT MgmtData (#PCDATA)>
   
  3.5 The Object Element
  
   Object is an optional element which may occur one or more times. When
   present, this element may contain any data. The Object element may
   include optional type, ID, and encoding attributes.
   
   The Object's ID is commonly referenced from an Reference in
   SignedInfo, Manifest or Package. This element is typically used for
   envoloping signatures where the object being signed is to be included
   in the signature document. The digest is calculated over the entire
   Object element including start and end tags.
   
   Note, if the application wishes to exclude the <Object> tags from the
   digest calculation the Reference must identify the acual data object
   (easy for XML documents) or a transform must be used to remove the
   Object tags (likely where the data object is non-XML). Exclusion of

Eastlke, Reagle, Solo					[Page 18]


Internet Draft		XML-Signature Core Syntax	January 2000


   the object tags may be desired for cases where one wants the signature
   to remain valid if the data object is moved from inside a signature to
   outside the signature (or vice-versa), or where the content of the
   Object is an encoding of an original binary document and it is desired
   to extract and decode so as to sign the original bitwise
   representation.
   
   Schema Definition:
   <element name='Object' >
     <type content='mixed'>
       <attribute name='Id' type='ID' minOccurs='0' maxOccurs='1'/>
       <attribute name='Type' type='uri' minOccurs='0' maxOccurs='1'/>
       <attribute name='Encoding' type='uri' minOccurs='0'
   maxOccurs='1'/>
     </type>
   </element>
   
   DTD:
   <!ELEMENT Object ANY>
   <!ATTLIST Object
             Id         ID       #IMPLIED
             Type       CDATA    #IMPLIED
             Encoding  CDATA     #IMPLIED >
        <!-- Where type and encoding CDATA conforms to the
             productions specified by [URI] -->
   
  3.6 The Parameter Element
  
   Algorithms are provided with parameters and input data, when
   necessary, by having Parameter elements in the content of the
   algorithm element. Algorithms also have implicit input, such as the
   canonicalized SignedInfo for SignatureMethod and the transformed data
   for DigestMethod.
   
   Where more than one Parameter appears, they are passed to the
   algorithm as an ordered vector corresponding to the order they appear
   in the algorithm element content.
   
   Schema Definition:
   <element name='Parameter'>
     <type content='mixed'>
       <attribute name='Encoding' type='uri' minOccurs='0'
   maxOccurs='1'/>
     </type>
   </element>
   
   DTD:
   <!ELEMENT Parameter #PCDATA>
   <!ATTLIST Parameter
             Encoding  CDATA     #IMPLIED >
   <!--   Encoding CDATA conforms to the productions
          specified by [URI] -->
   

Eastlke, Reagle, Solo					[Page 19]


Internet Draft		XML-Signature Core Syntax	January 2000


4.0 Additional Signature Syntax

   This section describes the optional to implement Manifest,
   SignatureProperties, and Package elements and describes the handling
   of XML Processing Instructions and Comments. With respect to the
   elements Manifest, SignatureProperties, and Package, this section
   specifies syntax and little behaviour -- it is left to the
   application. These elements can appear anywhere the parent's content
   model permits; the signature content model only permits them within
   Object.
   
  4.1 The Manifest and Package Elements
  
   The Manifest element provides a list of References. The difference
   from the list in SignedInfo is that it is application defined which,
   if any, of the digests are actually checked against the objects
   referenced and what to do if the object is inaccessible or the digest
   compare fails. If a Manifest is pointed to from SignedInfo, the digest
   over the Manifest itself will be checked by the core signature
   validation behavior. The digests within such a Manifest are checked at
   application discretion. If a Manifest is referenced from another
   Manifest, even the overall digest of this two level deep Manifest
   might not be checked.
   
   A Package is syntactically identical to a Manifest, and may appear
   anywhere a Manifest may appear, but asserts the identity of each of
   its Reference elements after Transforms application. The testing of
   this relationship and consequent action is at the discretion of the
   applicaiton.
   
   Schema Definition:
   <element name='Manifest'>
     <type content='elementOnly'>
       <group order='seq' minOccurs='1' maxOccurs='1'>
         <element ref='Reference' minOccurs='1' maxOccurs='*'/>
         <element ref='Object' minOccurs='0' maxOccurs='*'/>
       </group>
       <attribute name='Id' type='ID' minOccurs='0' maxOccurs='1'/>
     </type>
   </element>
   <element name='Package'>
     <type content='elementOnly'>
       <group order='seq' minOccurs='1' maxOccurs='1'>
         <element ref='Reference' minOccurs='1' maxOccurs='*'/>
         <element ref='Object' minOccurs='0' maxOccurs='*'/>
       </group>
       <attribute name='Id' type='ID' minOccurs='0' maxOccurs='1'/>
     </type>
   </element>
   
   DTD:
   <!ELEMENT Manifest ( (Reference | Object )+ ) >
   <!ATTLIST Manifest

Eastlke, Reagle, Solo					[Page 20]


Internet Draft		XML-Signature Core Syntax	January 2000


             Id     ID        #IMPLIED >
   <!ELEMENT Package ( (Reference | Object )+ ) >
   <!ATTLIST Package
             Id     ID        #IMPLIED >
   
  4.2 The SignatureProperties Element
  
   Additional information items concerning the generation of the
   signature(s) can be placed in a SignatureProperty element (i.e.,
   date/time stamp or the serial number of cryptographic hardware used in
   signature generation.)
   
   Schema Definition:
   <element name='SignatureProperties'>
     <type content='elementOnly'>
       <element ref='SignatureProperty' minOccurs='1' maxOccurs='*'/>
       <attribute name='Id' type='ID' minOccurs='0' maxOccurs='1'/>
     </type>
   </element>
   <element name='SignatureProperty'>
     <type content='mixed'>
       <attribute name='Target' type='IDREF' minOccurs='1'
   maxOccurs='1'/>
     </type>
   </element>
   
   DTD:
   <!ELEMENT SignatureProperties SignatureProperty >
   <!ATTLIST SignatureProperties
             Id     ID        #IMPLIED>
   <!ELEMENT SignatureProperty ANY >
   <!ATTLIST SignatureProperty
             Target    IDREF    #REQUIRED >
   
  4.3 Processing Instructions
  
   TDB - will specify the use, if any, of XML processing instructions by
   this specification and the handling of PIs appearing within elements
   specified in this document.
   
  4.4 Comments in dsig Elements
  
   TDB - will specify the use, if any, and handling of XML comments
   appearing within elements specified in this document.
   
5.0 Algorithms

   This section identifies algorithms used with the XML digital signature
   standard. Entries contain the identifier to be used in Signature
   elements, a reference to the formal specification, and definitions,
   where applicable, for the representation of keys and the results of
   cryptographic operations.
   

Eastlke, Reagle, Solo					[Page 21]


Internet Draft		XML-Signature Core Syntax	January 2000


  5.1 Algorithm Identifiers, Parameters, and Implementation Requirements
  
   Algorithms are identified by URIs that appear as an attribute to the
   element that identifies the algorithms' role (DigestMethod, Transform,
   SignatureMethod, or CanonicalizationMethod). All algorithms used
   herein take parameters but in many cases the parameters are implicit.
   For example, a SignatureMethod is implicitly given two parameters: the
   keying info and the output of CanonicalizationMethod (or SignedInfo
   directly if there is no CanonicalizationMethod). Explicit additional
   parameters to an algorithm appear as content elements within the
   algorithm role element. Such parameter elements have a descriptive
   element name, which is frequently algorithm specific, and MUST be in
   an algorithm specific namespace.
   
   This specification defines a set of algorithms, their URIs, and
   requirements for implementation. Requirements are specified over
   implementation, not over requirements for signature use. Furthermore,
   the mechanism is extensible, alternative algorithms may be used by
   signature applications.
   
   Algorithm Type Algorithm Requirements Algorithm URI
   Digest
     SHA1 REQUIRED http://www.w3.org/2000/01/xmldsig/sha1
   Encoding
     Base64 REQUIRED http://www.w3.org/2000/01/xmldsig/base64
     QuotedPrintable RECOMMENDED http://www.w3.org/2000/01/xmldsig/qp
   MAC
     HMAC-SHA1 REQUIRED http://www.w3.org/2000/01/xmldsig/hmac-sha1
   Signature
     DSAwithSHA1 (DSS) REQUIRED http://www.w3.org/2000/01/xmldsig/dsa
     RSAwithSHA1 RECOMMENDED http://www.w3.org/2000/01/xmldsig/rsa-sha1
     ECDSAwithSHA1 OPTIONAL http://www.w3.org/2000/01/xmldsig/ecdsa
   Canonicalization
     minimal REQUIRED http://www.w3.org/2000/01/xmldsig/minimal
     XML-Canonicalization RECOMMENDED
   http://www.w3.org/TR/1999/WD-xml-c14n-19991115
   Transform
     XSLT RECOMMENDED http://www.w3.org/TR/1999/REC-xslt-19991116
     XPath RECOMMENDED http://www.w3.org/TR/1999/REC-xpath-19991116
     XPointer RECOMMENDED http://www.w3.org/TR/1999/WD-xptr-19991206
     Java OPTIONAL urn:ECMA-org:java
   
   Note that the normative identifier is the complete URIs in the table
   though they are frequently abbreviated in XML syntax as
   "&dsig;/hmac".
   
  5.2 Message Digests
  
   Only one digest algorithm is defined herein. However, it is expected
   that one or more additional strong digest algorithms will be developed
   in connection with the US Advanced Encryption Standard effort. Use of
   MD5 [MD5] is NOT RECOMMENDED because recent advances in cryptography
   have cast doubt on its strength.

Eastlke, Reagle, Solo					[Page 22]


Internet Draft		XML-Signature Core Syntax	January 2000


   
   Digest algorithms take as an implicit parameter a byte string to be
   digested.
   
    5.2.1 SHA-1
    
   Identifier:
          http://www.w3.org/2000/01/xmldsig/sha1
          
   The SHA-1 algorithm [SHA-1] takes no explicit parameters. An example
   of an SHA-1 DigestAlg element is:
   
   <DigestMethod Algorithm="&dsig;/sha1"/>
   
   A SHA-1 digest is a 160-bit string. The content of the DigestValue
   element shall be the base64 encoding of this bit string viewed as a
   20-octet octet stream. Example, the DigestValue element for the
   message digest:
   
   A9993E36 4706816A BA3E2571 7850C26C 9CD0D89D
   
   from Appendix A of the SHA-1 standard would be:
   
   <DigestValue>qZk+NkcGgWq6PiVxeFDCbJzQ2J0=</DigestValue>
   
  5.3 Message Authentication Codes
  
   MAC algorithms take two implicit parameters, their keying material
   determined from KeyInfo and the byte stream output by
   CanonicalizationMethod or SignedInfo directly if there is no
   CanonicalizationMethod. MACs and signature algorithms are
   syntactically identical but a MAC implies a shared secret key.
   
    5.3.1 HMAC
    
   Identifier:
          http://www.w3.org/2000/01/xmldsig/hmac-sha1
          
   The HMAC algorithm [RFC2104:HMAC] takes the truncation length in bits
   as a parameter. An example of an HMAC SignatureMethod element:
   
   <SignatureMethod Algorithm="&dsig;/hmac-sha1">
     <hmac-outputlength xmlns="&dsig;/hmac-sha1">
        128
     </hmac-outputlength>
   </SignatureMethod>
   
   The output of the HMAC algorithm is ultimately the output (possibly
   truncated) of the chosen digest algorithm. This value shall be base64
   encoded in the same straightforward fashion as the output of the
   digest algorithms. Example: the SignatureValue element for the
   HMAC-MD5 digest
   

Eastlke, Reagle, Solo					[Page 23]


Internet Draft		XML-Signature Core Syntax	January 2000


   9294727A 3638BB1C 13F48EF8 158BFC9D
   
   from the test vectors in [HMAC] would be
   
   <SignatureValue>kpRyejY4uxwT9I74FYv8nQ==</SignatureValue>
   
  5.4 Signature Algorithms
  
   Signature algorithms take two implicit parameters, their keying
   material determined from KeyInfo and the byte stream output by
   CanonicalizationMethod or SignedInfo directly if there is no
   CanonicalizationMethod. Signature and MAC algorithms are syntactically
   identical but a signature implies public key cryptography.
   
   Note: the schema and DTD declarations within this section are not yet
   part of sec-9: schemas.
   
    5.4.1 DSA
    
   Identifier:
          http://www.w3.org/2000/01/xmldsig/dsa
          
   The DSA algorithm [DSA] takes no explicit parameters. An example of a
   DSA SignatureMethod element is:
   
   <SignatureMethod Algorithm="&dsig;/dsa"/>
   
   The output of the DSA algorithm consists of a pair of integers usually
   referred by the pair (r, s). The signature value shall consist of the
   base64 encoding of the concatenation of two octet-streams that
   respectively result from the octet-encoding of the values r and s.
   Integer to octet-stream conversion shall be done according to the
   I2OSP operation defined in the RFC 2437 [RSA] specification with a k
   parameter equal to 20. Example: the SignatureValue element for a DSA
   signature (r, s) with values specified in hexadecimal
   
   r = 8BAC1AB6 6410435C B7181F95 B16AB97C 92B341C0
   s = 41E2345F 1F56DF24 58F426D1 55B4BA2D B6DCD8C8
   
   from the example in Appendix 5 of the DSS standard would be
   
   <SignatureValue
   >i6watmQQQ1y3GB+VsWq5fJKzQcBB4jRfH1bfJFj0JtFVtLotttzYyA==</SignatureVa
   lue>
   
   DSA key values have the following set of fields: P, Q, G and Y are
   mandatory when appearing as a key value, J, seed and pgenCounter are
   optional but SHOULD be present. (The seed and pgenCounter fields MUST
   both either appear or be absent). All parameters are encoded as base64
   values.
   
   Schema:
   <element name='DSSKeyValue'>

Eastlke, Reagle, Solo					[Page 24]


Internet Draft		XML-Signature Core Syntax	January 2000


     <type content='elementOnly'>
       <group order='seq' minOccurs='1' maxOccurs='1'>
         <element name='P' type='string' minOccurs='1' maxOccurs='1'/>
         <element name='Q' type='string' minOccurs='1' maxOccurs='1'/>
         <element name='G' type='string' minOccurs='1' maxOccurs='1'/>
         <element name='Y' type='string' minOccurs='1' maxOccurs='1'/>
         <element name='J' type='string' minOccurs='0' maxOccurs='1'/>
       </group>
       <group order='seq' minOccurs='0' maxOccurs='1'>
         <element name='seed' type='string' minOccurs='1' maxOccurs='1'/>
         <element name='pgenCounterQ' type='string'   minOccurs='1'
   maxOccurs='1'/>
       </group>
     </type>
   </element>
   
   DTD:
   <!ELEMENT DssKeyValue (P, Q, G, Y, J?, (seed, pgenCounter)?) >
   <!-- Each of these fields consists a CDATA
        where the data is base64 encoded -->
   
    5.4.2 RSA
    
   Identifier:
          http://www.w3.org/2000/01/xmldsig/rsa-sha1
          
   The expression "RSA algorithm" as used in this document refers to the
   RSASSA-PKCS1-v1_5 algorithm described in  RFC 2437 [RSA]. The RSA
   algorithm takes no parameters. An example of an RSA SignatureMethod
   element is:
   
   <SignatureMethod Algorithm="&dsig;/rsa-sha1"/>
   
   The output of the RSA algorithm is an octet string. The SignatureValue
   content for an RSA signature shall be the base64 encoding of this
   octet string. Example: TBD
   
   RSA key values have two fields: Modulus and Exponent.
   
   Schema:
   <element name='RSAKeyValue'>
     <type content='elementOnly'>
       <element name='Modulus' type='string' minOccurs='1'
   maxOccurs='1'/>
       <element name='Exponent' type='string' minOccurs='1'
   maxOccurs='1'/>
     </type>
   </element>
   
   DTD:
   <!ELEMENT RSAKeyValue ( Modulus, Exponent ) >
   <!-- Each field contains a CDATA which is the
        value for that item base64 encoded -->

Eastlke, Reagle, Solo					[Page 25]


Internet Draft		XML-Signature Core Syntax	January 2000


   
    5.4.3 ECDSA
    
   The expression ECDSA  [ECDSA] as used in this document refers to the
   signature algorithms specified in ANSI X9.62.  Additional details are
   to be provided.
   
  5.5 Canonicalization Algorithms
  
    5.5.1 Null Canonicalization
    
   Null canonicalization, i.e., no modification whatsoever, can be
   achieved for digested data by simply not putting any canonicalization
   in the Transforms element (omitting it entirely if no other tranforms
   are needed) for a data object or omitting CanonicalizationMethod for
   SignedInfo.
   
    5.5.2 Minimal Canonicalization
    
   Identifier:
          http://www.w3.org/2000/01/xmldsig/minimal
          
   The algorithm identifier for the minimal canonicalization is
   &dsig;/minimal. An example of a minimal canonicalization element is:
   
   <CanonicalizationMethod Algorithm="&dsig;/minimal"/>
   
   The minimal canonicalization algorithm:
     * converts the character encoding to UTF-8, removing the encoding
       pseudo-attribute
     * normalizes line endings
       
    5.5.3 Canonical XML
    
   Identifier:
          http://www.w3.org/TR/1999/WD-xml-c14n-19991115
          
   An example of an XML canonicalization element is:
   
   <CanonicalizationMethod
   Algorithm="http://www.w3.org/TR/1999/WD-xml-c14n-19991115"/>
   
   The normative specificatin of Canonical XML is [XML-c14n].
   
  5.6 Transform Algorithms
  
   A Transform algorithm has three implicit parameters. The first is a
   byte stream from the Reference or as the output of an earlier
   Transform. The second and third are the optional MimeType and Charset
   attributes that can be specified on the Transform element.
   
   Application developers are strongly encouraged to support all
   transforms listed in this section as RECOMMENDED unless the

Eastlke, Reagle, Solo					[Page 26]


Internet Draft		XML-Signature Core Syntax	January 2000


   application environment has resource constraints that would make such
   support impractical. The working group goal is to maximize application
   interoperability on XML signatures, and the working group expects
   ubiquitous availability of software to support these transforms that
   can be incorporated into applications without extensive development.
   
    5.6.1 Canonicalization
    
   Any canonicalization algorithm that can be used for
   CanonicalizationMethod can be used as a Transform.
   
    5.6.2 Base-64 and Quoted-Printable Decoding
    
   Identifiers:
          http://www.w3.org/2000/01/xmldsig/base-64
          http://www.w3.org/2000/01/xmldsig/qp
          
   The normative specification for base 64 and quoted-printable decoding
   transforms is [MIME]. The base-64 Transform element has no content.
   The input is base-64 decoded by this algorithm. This transform is
   useful if an application needs to sign the raw data associated with
   base-64 encoded content of an element.
   
    5.6.3 XPath Filtering
    
   Identifier:
          http://www.w3.org/TR/1999/REC-xpath-19991116
          
   The Transform element content MUST conform to the XML Path Language
   [XPath] syntax. XPath is a language for addressing parts of an XML
   document. Hence, an XPath expression MUST be applied to an entire
   well-formed XML document.
   
   Note: The current output of a Reference's IDREF cannot be used as
   input to an XPath transform. The XPath transform could be defined to
   provide an XML declaration when one is found not to exist since the
   encoding attribute could be set equal to the XPath transform's Charset
   attribute. However, there is currently no way to communicate the
   correct byte order mark to the transform. For security reasons, a
   default cannot be selected.
   
   The XPath transform applies the W3C XML canonicalization [XML-C14N] to
   the input resource. This ensures all entity reference substitutions
   and attribute normalizations are performed in a manner consistent with
   a validating XML processor. Linefeeds are normalized, and CDATA
   sections are eliminated. The types of quotes around attributes are
   normalized, and the order of attributes is defined. Namespace
   attributes are created in descendant elements that use namespace
   definitions. All of these modifications are necessary to achieve a
   consistent interpretation of the XPath expression and a consistent
   output of the XPath transform.
   
   Finally, the XPath expression is evaluated assuming that the entity

Eastlke, Reagle, Solo					[Page 27]


Internet Draft		XML-Signature Core Syntax	January 2000


   references created by canonicalization have been replaced by the
   corresponding entity values and that each block of consecutive text
   characters has been replaced by a single text node.
   
   The result of the XPath is a string, boolean, number, or node-set. If
   the result of the XPath expression is a string, then the string is the
   output of the XPath transform. If the XPath result is a boolean or
   number, then the result is converted to a string using the XPath
   string() function. If the result of the XPath expression is a
   node-set, then the output of the transform is a string containing the
   text rendering of the nodes in the node-set. The nodes are selected
   for rendering based on the document order (as defined in [XPath]) of
   the canonicalized input resource. The text rendering is performed in
   accordance with [XML-C14N].
   
   It is RECOMMENDED that the XPath be constructed such that the result
   of this operation is a well-formed XML document. This should be the
   case if root element of the input resource is included by the XPath
   (even if a number of its descendant elements and attributes are
   omitted by the XPath).
   
    5.6.4 XPointer Filtering
    
   Identifier:
          http://www.w3.org/TR/1999/WD-xptr-19991206
          
   The Transform element content MUST conform to the XML Pointer Language
   [XPointer] syntax.
   
   The processing rules for XPointer filtering are identical to those for
   XPath filtering (stated above), except that the additional
   functionality offered by XPointer can be utilized in constructing the
   output.
   
    5.6.5 XSLT Transform
    
   Identifier:
          http://www.w3.org/TR/1999/REC-xslt-19991116
          
   The Transform element content MUST conform to the XSL Transforms
   [XSLT] language syntax. The processing rules for the XSLT transform
   are stated in the XSLT specification [XSLT].
   
    5.6.6 Java Transform
    
   The Algorithm value for the Java transform is urn:ECMA-org:java.
   
   Details to be determined.
   
   Although the Algorithm attribute of a Transform can take
   application-specific values, having a Java transform seems to be the
   most reasonable way to allow application-specific transforms that can
   be processed outside of the application domain.

Eastlke, Reagle, Solo					[Page 28]


Internet Draft		XML-Signature Core Syntax	January 2000


   
6.0 Processing rules

   These sections describe the operations to be performed as part of
   signature generation and validation. The description is of a logical
   behavior and does not specify an order of execution, nor specify
   discrete steps.
   
  6.1 Generation
  
    1. apply Transforms determined by application to each object being
       signed.
    2. calculate digest over each transformed object
    3. create Reference element(s) including location of object, digest,
       digest algorithm, and transform elements, if required.
    4. create SignedInfo element with SignatureMethod,
       CanonicalizationMethod if required, and Reference(s).
    5. canonicalize and calculate signature over SignedInfo based on
       algorithms in step 4.
    6. construct signature document with SignedInfo, Object (s) (if
       desired, encoding may be different than that used for signing),
       KeyInfo (if required), and SignatureValue.
       
  6.2 Core Validation
  
   Validating an XML signature consists of two mandatory processing
   steps. These are signature validation, the cryptographic validation of
   the signature calculated over SignedInfo; and reference validation,
   the verification of the digest contained in each Reference in
   SignedInfo. Both steps MUST be performed as part of all XML signature
   validations.
   
    6.2.1 Signature Validation
    
    1. canonicalize the SignedInfo element based on the
       CanonicalizationMethod, if any, in SignedInfo.
    2. obtain the validation keying info from KeyInfo or externally.
    3. validate the SignatureValue based on the SignatureMethod in the
       SignedInfo element, the key obtained in step 2, and the results of
       step 1. Digest calculation is performed over the SignedInfo
       element including start and end tags.
       
    6.2.2 Reference Validation
    
    1. For each object reference in SignedInfo, obtain digested content
       (this may be obtained by locating object and applying Transforms
       to the specified resource based on each Reference(s) in the
       SignedInfo element. Each transform is applied in order from left
       to right to the object with the output of each transform being the
       input to the next.).
    2. calculate digest over each transformed signed object(s)  based on
       the algorithm in Reference(s).
    3. compare value against DigestValue in SignedInfo for each reference

Eastlke, Reagle, Solo					[Page 29]


Internet Draft		XML-Signature Core Syntax	January 2000


       (if any mismatch, validation fails).
       
   Any processing beyond cryptographic validation (e.g. certificate
   validation, applicability decisions, time related processing) is
   outside the scope of this specification.
   
7.0 Security Considerations

   The XML Signature specification provides a very flexible digital
   signature mechanism. Implementors must give consideration to the
   application threat models and to the following factors.
   
  7.1 Only What is Signed is Secure
  
   A requirement of this specification is to permit signatures to "apply
   to a part or totality of a XML document." [3.1.3 XML-Signature-RD] The
   Transforms mechanism meets this requirement by permitting one to sign
   a document derived from processing the identified source document. For
   instance, applications that wish to sign a form, but permit users to
   enter field data without invalidating the form itself might use XPath
   [XPath] to select only those portions the user does not change.
   However, Transforms may be arbitrarly specified and may include
   canonicalization instructions or even XSLT transformations. We stress
   that the signature is placed over the derived document, and those
   portions that were excluded by transformation can be arbitrarily
   modified and the signature will still validate! This is a feature,
   though one that is used at the application's risk. (Some applications
   may not be willing to trust such signatures all-together.)
   
   Furthermore, core validation behaviour does not confirm that the
   signed resource was obtained by applying transforms to the specified
   source document. This behaviour is left to the application as core
   validation only checks the digest values of the source document and
   the signature over SignedInfo. If this fact is important, then
   additional information (such as by including References to both the
   original and transformed documents) is needed. 
   
  7.2 Only What is "Seen" Should be Signed
  
   If signing is intended to convey the judgment or consent of an
   automated mechanism or person concerning some information, then it is
   normally necessary to secure as exactly as practical the information
   that was presented to that mechanism or person. Note that this can be
   accomplished by literally signing what was presented, for example the
   screen images shown a user. However, this may result in data which it
   is difficult for subsequent software to manipulate. It can be
   effective instead to secure the full data along with whatever filters,
   style sheets, or the like were used to control the part of the
   information that was presented.
   
  7.3 Check the Security Model
  
   This standard specifies public key signatures and secret key keyed

Eastlke, Reagle, Solo					[Page 30]


Internet Draft		XML-Signature Core Syntax	January 2000


   hash authentication codes. These have substantially different security
   models. Furthermore, it permits user specified additions which may
   have other models.
   
   With public key signatures, any number of parties can hold the public
   key and verify signatures while only the parties with the secret key
   can create signatures. The number of holders of the secret key should
   be minimized and preferably be one. Confidence by verifiers in the
   public key they are using and its binding to the entity or
   capabilities represented by the corresponding secret key is an
   important issue, usually addressed by certificate or online authority
   systems.
   
   Keyed hash authentication codes, based on secret keys, are typically
   much more efficient in terms of the computational effort required but
   have the characteristic that all verifiers need to have possession of
   the same key as the signer. Thus any verifier can forge signatures.
   
   This standard permits user provided signature algorithms and keying
   information designators. Such user provided algorithms may have
   further different security models. For example, methods involving
   biometrics usually depend on a "key" which is a physical
   characteristic of the user and thus can not be changed the way public
   or secret keys can be and may have other security model differences.
   
  7.4 Key Lengths, Algorithms, Etc.
  
   The strength of a particular signature depends on all links in the
   security chain. This includes the signature and digest algorithms
   used, the strength of the key generation [RFC1750] and the size of the
   key, the security of key and certificate authentication and
   distribution mechanisms, protection of all cryptographic processing
   from hostile observation and tampering, etc. The security of an
   overall system would also depend on the security and integrity of its
   operating procedures, its personnel, and on the administrative
   enforcement of those procedures. The factors listed in this paragraph,
   while critical to the overall security of a system, are mostly beyond
   the scope of this document.
   
8.0 Example syntax

   <Signature xmlns="http://www.w3.org/1999/11/xmldsig-core">
     <SignedInfo ID="5">
       <CanonicalizationMethod
        Algorithm="http://www.w3.org/1999/07/WD-xml-c14n-19990729"/>
       <SignatureMethod Algorithm="&dsig;/dsa"/>
       <Reference URI="http://www.mypage.com">
         <Transforms>
            <Transform Algorithm="&dsig;/null">
            <Encoding Algorithm="&dsig;/base64"/>
         </Transforms>
         <DigestMethod Algorithm="&dsig;/sha1"/>
         <DigestValue>a23bcd43</DigestValue>

Eastlke, Reagle, Solo					[Page 31]


Internet Draft		XML-Signature Core Syntax	January 2000


       </Reference>
       <Reference IDREF="timestamp"
          Type="&dsig;/signatureattributes">
         <Transforms>
            <CanonicalizationMethod name="http://..."/>
         </Transforms>
         <DigestMethod Algorithm="&dsig;/sha1"/>
         <DigestValue>a53uud43</DigestValue>
       </Reference>
     </SignedInfo>
     <SignatureValue>dd2323dd</SignatureValue>
     <Object ID="timestamp"
      type="&dsig;/SignatureProperties" >
       <SignatureProperties>
         <SignatureProperty>
         <timestamp about="5"
          xmlns="http://www.ietf.org/rfcXXXX.txt">
           <date>19990908</date>
           <time>14:34:34:34</time>
         </timestamp>
         </SignatureProperty>
       </SignatureProperties>
     </Object>
     <KeyInfo>
        <keyname>Solo</keyname>
     </KeyInfo>
   </Signature>
   
9.0 Schema

   http://www.w3.org/TR/2000/WD-xmldsig-core-20000104/xmldsig-core-schema
   .xml
   
10 Definitions

   Authentication, Message
          "A signature should identify what is signed, making it
          impracticable to falsify or alter either the signed matter or
          the signature without detection." [Digital Signature
          Guidelines, ABA]
          
   Authentication, Signer
          "A signature should indicate who signed a document, message or
          record, and should be difficult for another person to produce
          without authorization." [Digital Signature Guidelines, ABA] See
          non-repudiation.
          
   Core
          The syntax and processing defined by this specification,
          including core validation. We use this term to distinguish
          other markup, processing, and applications semantics from our
          own.
          

Eastlke, Reagle, Solo					[Page 32]


Internet Draft		XML-Signature Core Syntax	January 2000


   Data Object (Content/Document)
          The actual binary/octet data being operated on (transformed,
          digested, or signed) by an application -- frequently an HTTP
          entity [HTTP]. Note that the proper noun Objectdesignates a
          specific XML element. Occasionally we refer to a data object as
          a document or as a resource's content. The term element content
          is used to describe the data between XML start and end tags
          [XML]. The term XML document is used to describe data objects
          which conform to the XML specification [XML].
          
   Integrity
          The inability to change a message without also changing the
          signature value. See message authentication.
          
   Non-repudiation
          The inability of a key holder to assert that their key was not
          associated with a message given a strong signature algorithm.
          (This definition speaks nothing of the number of key holders,
          the key length, whether the key is comprised, whether the
          signature was coerced, etc.) See signer authentication.
          
   Object
          An XML Signature element wherein arbitrary (non-core) data may
          be placed. An Object element is merely one type of digital data
          (or document) that can be signed via a Reference.
          
   Resource
          "A resource can be anything that has identity. Familiar
          examples include an electronic document, an image, a service
          (e.g., 'today's weather report for Los Angeles'), and a
          collection of other resources.... The resource is the
          conceptual mapping to an entity or set of entities, not
          necessarily the entity which corresponds to that mapping at any
          particular instance in time. Thus, a resource can remain
          constant even when its content---the entities to which it
          currently corresponds---changes over time, provided that the
          conceptual mapping is not changed in the process." [URI] In
          order to avoid a collision of the term entity within the URI
          and XML specifications, we use the term data object, content or
          document to refer to the actual bits being operated upon.
          
   Signature
          A value generated from the application of a key to a message
          via a cryptographic algorithm such that it has the properties
          of signer authentication, integrity, and non-repudiation.
          
   Signature, Detached
          The signature is over external content identified via a URI.
          Cosequently, the signature is "detached" from the content it
          signs.
          
   Signature, Enveloping
          The signature is over content found within the signature itself

Eastlke, Reagle, Solo					[Page 33]


Internet Draft		XML-Signature Core Syntax	January 2000


          via an IDREF to an Object element. The Signature provides the
          root XML document element.
          
   Signature, Enveloped
          The signature is over the XML content that contains the
          signature as an element. The content provides the root XML
          document element. Obviously, enveloped signatures must take
          care not to include their own value in the calculation of the
          SignatureValue.
          
   Transform
          The processing of a byte stream from source content to derived
          content. Typical transforms include XML Canonicalization,
          XPath, and XSLT.
          
   Validation, Core
          The core processing requirements of this specification
          requiring signature validation and SignedInfo reference
          validation.
          
   Validation, Reference
          The hash value of the identified and transformed content,
          specified by Reference, matches its specified DigetsValue.
          
   Validation, Signature
          The SignatureValue matches the result of processing SignedInfo
          with  CanonicalizationMethod and SignatureMethod as specified
          in 6.2.
          
   Validation, Trust/Application
          The application determines that the semantics associated with a
          signature are valid. For example, an application may validate
          the time stamps or the integrity of the signer key -- though
          this behvaiour is external to this core specification.
          
11.0 Other Useful Types (normative)

   We define the following URIs for use in identifying XML resources that
   include non-core but signature related semantics.
   
   http://www.w3.org/1999/11/xmldsig-core/SignatureProperties
          designates that the referenced resource is a statement about
          the referring signature.
          
   http://www.w3.org/1999/11/xmldsig-core/Manifest
          designates that the referenced resource is a collection of
          other resources.
          
   http://www.w3.org/1999/11/xmldsig-core/Package
          designates that the referenced resources is a collection of
          other resources and the creator of that collection asserts that
          the specified resources, when transformed as specified, yield
          the same exact content.

Eastlke, Reagle, Solo					[Page 34]


Internet Draft		XML-Signature Core Syntax	January 2000


          
12.0 References

   ABA
          Digital Signature Guidelines.
          http://www.abanet.org/scitech/ec/isc/dsgfree.html
          
   DOMHASH
          Internet Draft. Digest Values for DOM (DOMHASH)
          http://search.ietf.org/internet-drafts/draft-hiroshi-dom-hash-0
          1.txt .
          
   DSS
          FIPS PUB 186-1. Digital Signature Standard (DSS). U.S.
          Department of Commerce/National Institute of Standards and
          Technology.
          http://www.ietf.org/rfc/rfc2104.txt
          
   ECSDA
          ?ANSI X9.62
          
   HMAC
          RFC 2104. HMAC: Keyed-Hashing for Message Authentication. H.
          Krawczyk, M. Bellare, R. Canetti. INFORMATIONAL.
          
   HTTP
          RFC 2616.Hypertext Transfer Protocol -- HTTP/1.1. J. Gettys, J.
          Mogul, H. Frystyk, L. Masinter, P. Leach, T. Berners-Lee.
          http://www.ietf.org/rfc/rfc2616.txt
          
   MD5
          RFC 1321. The MD5 Message-Digest Algorithm. R. Rivest.
          INFORMATIONAL.
          http://www.ietf.org/rfc/rfc1321.txt
          
   MIME
          RFC 2045. Multipurpose Internet Mail Extensions (MIME) Part
          One: Format of Internet Message Bodies. N. Freed & N.
          Borenstein. DRAFT STANDARD.
          http://www.ietf.org/rfc/rfc2045.txt
          
   RDF
          RDF Schema
          http://www.w3.org/TR/1999/PR-rdf-schema-19990303
          RDF Model and Syntax
          http://www.w3.org/TR/1999/REC-rdf-syntax-19990222
          
   RFC1750
          RFC1750 -- Randomness Recommendations for Security.
          http://www.ietf.org/rfc/rfc1750.txt
          
   RFC2119
          RFC2119 -- Key words for use in RFCs to Indicate Requirement

Eastlke, Reagle, Solo					[Page 35]


Internet Draft		XML-Signature Core Syntax	January 2000


          Levels.
          http://www.ietf.org/rfc/rfc2119.txt
          
   RSA
          RFC 2437. PKCS #1: RSA Cryptography Specifications Version 2.0.
          B. Kaliski, J. Staddon. INFORMATIONAL.
          http://www.ietf.org/rfc/rfc2432.txt
          
   SHA-1
          FIPS PUB 180-1. Secure Hash Standard. U.S. Department of
          Commerce/National Institute of Standards and Technology.
          http://csrc.nist.gov/fips/fip180-1.pdf
          
   URI
          RFC2396 - Uniform Resource Identifiers (URI): Generic Syntax
          http://www.ietf.org/rfc/rfc2396.txt
          
   URL
          RFC1738. Uniform Resource Locators (URL). Berners-Lee, T.,
          Masinter, L., and M. McCahill . December 1994.
          http://www.ietf.org/rfc/rfc1738.txt
          
   URN
          RFC 2141. URN Syntax. R. Moats. PROPOSED STANDARD.
          ftp://ftp.isi.edu/in-notes/rfc2141.txt
          RFC 2611. URN Namespace Definition Mechanisms. L. Daigle, D.
          van Gulik, R. Iannella, P. Falstrom. BEST CURRENT PRACTICE.
          ftp://ftp.isi.edu/in-notes/rfc2611.txt
          
   XLink
          XML Linking Language
          http://www.w3.org/1999/07/WD-xlink-19990726
          
   XML
          Extensible Markup Language (XML) Recommendation.
          http://www.w3.org/TR/1998/REC-xml-19980210
          
   XML-c14n
          Canonical XML. W3C Working Draft
          http://www.w3.org/TR/1999/WD-xml-c14n-19991115
          
   XML-ns
          Namespaces in XML
          http://www.w3.org/TR/1999/REC-xml-names-19990114
          
   XPath
          XML Path Language (XPath)Version 1.0. W3C Proposed
          Recommendation
          http://www.w3.org/TR/1999/PR-xpath-19991008
          
   XPointer
          XML Pointer Language (XPointer). W3C Working Draft.
          http://www.w3.org/1999/07/WD-xptr-19990709

Eastlke, Reagle, Solo					[Page 36]


Internet Draft		XML-Signature Core Syntax	January 2000


          
   XML-schema
          XML Schema Part 1: Structures
          http://www.w3.org/TR/1999/WD-xmlschema-1-19991217/
          XML Schema Part 2: Datatypes
          http://www.w3.org/TR/1999/WD-xmlschema-2-19991217/
          
   XML-Signature-RD
          XML-Signature Requirements
          http://www.w3.org/1999/08/WD-xmldsig-requirements-990820
          
   XSL
          Extensible Stylesheet Language (XSL) W3C Working Draft
          http://www.w3.org/TR/1999/WD-xsl-19990421
          
   XSLT
          XSL Transforms (XSLT) Version 1.0. W3C Proposed Recommendation
          http://www.w3.org/TR/1999/PR-xslt-19991008
          
   WebData
          Web Architecture: Describing and Exchanging Data.
          http://www.w3.org/1999/04/WebData
          
13.0 Acknowledgements (non-normative)

     * Milton Anderson, FSTC
     * Mark Bartel, JetForm Corporation (Author)
     * John Boyer, UWI.com (Author)
     * Richard Brown, Globeset
     * Donald Eastlake 3rd, IBM (Chair, Editor)
     * Barb Fox, Microsoft (Author)
     * Phillip Hallam-Baker, VeriSign Inc
     * Richard Himes, US Courts
     * Joseph Reagle, W3C (Chair, Editor)
     * Ed Simon , Entrust Technologies Inc.
     * Chris Smithies, PenOp
     * David Solo, Citigroup (Editor)
     * Winchel Todd Vincent III, GSU
     * Greg Whitehead, Signio Inc.
       
14.0 Open Issues (non-normative)

    1. More detail for KeyInfo types, based on IETF'46, we need proposals
       for the actual XML'ized algorithm parameters.
    2. Make sure we are consistent with respect to types, algorithm IDs,
       URIs, etc.
    3. The signature data structures specified in this document are not
       yet associated with a data model.





Eastlke, Reagle, Solo					[Page 37]

