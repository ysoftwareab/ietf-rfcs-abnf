<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="en"><head><title>A New Forking Mechanism for
Session Initiation Protocol (SIP)</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="description" content="A New Forking Mechanism for
Session Initiation Protocol (SIP)">
<meta name="keywords" content="SUBSCRIBE, PUBLISH, forking">
<meta name="generator" content="xml2rfc v1.35 (http://xml.resource.org/)">
<meta name="viewport" content="width=600;" />
<style type='text/css'><!--
        body {
                font-family: verdana, charcoal, helvetica, arial, sans-serif;
                font-size: 85%;
		max-width: 40em; 
		color: #000; background-color: #FFF;
                margin: 2em;
        }
        h1, h2, h3, h4, h5, h6 {
                font-family: helvetica, monaco, "MS Sans Serif", arial, sans-serif;
                font-weight: bold; font-style: normal;
        }
        h1 { color: #900; background-color: transparent; text-align: right; }
        h3 { color: #333; background-color: transparent; }

        td.RFCbug {
                font-size: x-small; text-decoration: none;
                width: 30px; height: 30px; padding-top: 2px;
                text-align: justify; vertical-align: middle;
                background-color: #000;
        }
        td.RFCbug span.RFC {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: bold; color: #666;
        }
        td.RFCbug span.hotText {
                font-family: charcoal, monaco, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: normal; text-align: center; color: #FFF;
        }

        table.TOCbug { width: 30px; height: 15px; }
        td.TOCbug {
                text-align: center; width: 30px; height: 15px;
                color: #FFF; background-color: #900;
        }
        td.TOCbug a {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, sans-serif;
                font-weight: bold; font-size: x-small; text-decoration: none;
                color: #FFF; background-color: transparent;
        }

        td.header {
                font-family: arial, helvetica, sans-serif; font-size: x-small;
                vertical-align: top; width: 33%;
                color: #FFF; background-color: #666;
        }
        td.author { font-weight: bold; font-size: x-small; margin-left: 4em; }
        td.author-text { font-size: x-small; }

        /* info code from SantaKlauss at http://www.madaboutstyle.com/tooltip2.html */
        a.info {
                /* This is the key. */
                position: relative;
                z-index: 24;
                text-decoration: none;
        }
        a.info:hover {
                z-index: 25;
                color: #FFF; background-color: #900;
        }
        a.info span { display: none; }
        a.info:hover span.info {
                /* The span will display just on :hover state. */
                display: block;
                position: absolute;
                font-size: smaller;
                top: 2em; left: -5em; width: 15em;
                padding: 2px; border: 1px solid #333;
                color: #900; background-color: #EEE;
                text-align: left;
        }

        a { font-weight: bold; }
        a:link    { color: #900; background-color: transparent; }
        a:visited { color: #633; background-color: transparent; }
        a:active  { color: #633; background-color: transparent; }

        p { margin-left: 2em; margin-right: 2em; }
        p.copyright { font-size: x-small; }
        p.toc { font-size: 85%;
		max-width: 40em; 
		font-weight: bold; margin-left: 3em; }
        table.toc { margin: 0 0 0 3em; padding: 0; border: 0; vertical-align: text-top; }
        td.toc { font-size: 85%;
		max-width: 40em; 
		font-weight: bold; vertical-align: text-top; }

        ol.text { margin-left: 2em; margin-right: 2em; }
        ul.text { margin-left: 2em; margin-right: 2em; }
        li      { margin-left: 3em; }

        /* RFC-2629 <spanx>s and <artwork>s. */
        em     { font-style: italic; }
        strong { font-weight: bold; }
        dfn    { font-weight: bold; font-style: normal; }
        cite   { font-weight: normal; font-style: normal; }
        tt     { color: #036; }
        tt, pre, pre dfn, pre em, pre cite, pre span {
                font-family: "Courier New", Courier, monospace; font-size: small;
        }
        pre {
                text-align: left; padding: 4px;
                color: #000; background-color: #CCC;
        }
        pre dfn  { color: #900; }
        pre em   { color: #66F; background-color: #FFC; font-weight: normal; }
        pre .key { color: #33C; font-weight: bold; }
        pre .id  { color: #900; }
        pre .str { color: #000; background-color: #CFF; }
        pre .val { color: #066; }
        pre .rep { color: #909; }
        pre .oth { color: #000; background-color: #FCF; }
        pre .err { background-color: #FCC; }

        /* RFC-2629 <texttable>s. */
        table.all, table.full, table.headers, table.none {
                font-size: 85%;
		max-width: 40em; 
		text-align: center; border-width: 2px;
                vertical-align: top; border-collapse: collapse;
        }
        table.all, table.full { border-style: solid; border-color: black; }
        table.headers, table.none { border-style: none; }
        th {
                font-weight: bold; border-color: black;
                border-width: 2px 2px 3px 2px;
        }
        table.all th, table.full th { border-style: solid; }
        table.headers th { border-style: none none solid none; }
        table.none th { border-style: none; }
        table.all td {
                border-style: solid; border-color: #333;
                border-width: 1px 2px;
        }
        table.full td, table.headers td, table.none td { border-style: none; }

        hr { height: 1px; }
        hr.insert {
                width: 80%; border-style: none; border-width: 0;
                color: #CCC; background-color: #CCC;
        }
--></style>
</head>
<body>
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<table summary="layout" width="66%" border="0" cellpadding="0" cellspacing="0"><tr><td><table summary="layout" width="100%" border="0" cellpadding="2" cellspacing="1">
<tr><td class="header">Sipping</td><td class="header">D. Worley</td></tr>
<tr><td class="header">Internet-Draft</td><td class="header">Nortel Networks</td></tr>
<tr><td class="header">Intended status: Standards Track</td><td class="header">March 04, 2009</td></tr>
<tr><td class="header">Expires: September 5, 2009</td><td class="header">&nbsp;</td></tr>
</table></td></tr></table>
<h1><br />A New Forking Mechanism for
Session Initiation Protocol (SIP)<br />draft-worley-sipping-forking-03</h1>

<h3>Status of this Memo</h3>
<p>
This Internet-Draft is submitted to IETF in full
conformance with the provisions of BCP&nbsp;78 and BCP&nbsp;79.</p>
<p>
Internet-Drafts are working documents of the Internet Engineering
Task Force (IETF), its areas, and its working groups.
Note that other groups may also distribute working documents as
Internet-Drafts.</p>
<p>
Internet-Drafts are draft documents valid for a maximum of six months
and may be updated, replaced, or obsoleted by other documents at any time.
It is inappropriate to use Internet-Drafts as reference material or to cite
them other than as &ldquo;work in progress.&rdquo;</p>
<p>
The list of current Internet-Drafts can be accessed at
<a href='http://www.ietf.org/ietf/1id-abstracts.txt'>http://www.ietf.org/ietf/1id-abstracts.txt</a>.</p>
<p>
The list of Internet-Draft Shadow Directories can be accessed at
<a href='http://www.ietf.org/shadow.html'>http://www.ietf.org/shadow.html</a>.</p>
<p>
This Internet-Draft will expire on September 5, 2009.</p>

<h3>Copyright Notice</h3>
<p>
Copyright (c) 2009 IETF Trust and the persons identified as the
document authors.  All rights reserved.</p>
<p>
This document is subject to BCP 78 and the IETF Trust's Legal
Provisions Relating to IETF Documents in effect on the date of
publication of this document (http://trustee.ietf.org/license-info).
Please review these documents carefully, as they describe your
rights and restrictions with respect to this document.</p>

<h3>Abstract</h3>

<p>
The rules for SIP proxies are organized so that when a UAC sends an
out-of-dialog request, even if the request is forked to a number of
UASs, (usually) only one UAS will accept the request, and only the
final response from that UAS will be returned to the UAC.  This
forking mechanism is optimal for an INVITE intended to connect one
human user with another human uses, but is poor for requests that have
a "one to many" nature, especially PUBLISH and SUBSCRIBE requests, but
also including some INVITEs.  This document proposes an alternative
forking mechanism that better supports "one to many" requests, and
that mechanism be the standardized meaning of the (existing but weakly
specified) "Request-Disposition: no-cancel, parallel" header.

</p><a name="toc"></a><br /><hr />
<h3>Table of Contents</h3>
<p class="toc">
<a href="#introduction">1.</a>&nbsp;
Introduction<br />
<a href="#current">2.</a>&nbsp;
The current forking mechanism<br />
<a href="#problems">3.</a>&nbsp;
Problems with the current forking mechanism<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#diagnostics">3.1.</a>&nbsp;
Determinism and diagnosis<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#publish">3.2.</a>&nbsp;
PUBLISH<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#subscribe">3.3.</a>&nbsp;
SUBSCRIBE<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#intercom">3.4.</a>&nbsp;
Intercom<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#conferencing">3.5.</a>&nbsp;
Conferencing<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#messaging">3.6.</a>&nbsp;
Messaging<br />
<a href="#mechanism">4.</a>&nbsp;
A new proxy forking mechanism<br />
<a href="#traceroute">5.</a>&nbsp;
Using the new forking mechanism for routing diagnosis<br />
<a href="#uri-list">6.</a>&nbsp;
Relationship to URI-list services<br />
<a href="#3841">7.</a>&nbsp;
Upward compatibility relative to RFC 3841<br />
<a href="#anchor1">8.</a>&nbsp;
Security considerations<br />
<a href="#ack">9.</a>&nbsp;
Acknowledgments<br />
<a href="#revision">10.</a>&nbsp;
Revision history<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#00-01">10.1.</a>&nbsp;
Changes from draft-worley-sipping-forking-00 to draft-worley-siping-forking-01<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#01-02">10.2.</a>&nbsp;
Changes from draft-worley-sipping-forking-01 to draft-worley-siping-forking-02<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#02-03">10.3.</a>&nbsp;
Changes from draft-worley-sipping-forking-02 to draft-worley-siping-forking-03<br />
<a href="#rfc.references1">11.</a>&nbsp;
Normative references<br />
<a href="#rfc.authors">&#167;</a>&nbsp;
Author's Address<br />
</p>
<br clear="all" />

<a name="introduction"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1"></a><h3>1.&nbsp;
Introduction</h3>

<p>
When a UAC sends an out-of-dialog request, it may pass through many
proxies, which may fork the request and deliver copies of it to
several UASs.
The rules for SIP proxies are organized so that (usually) only one UAS
will accept the request, and only the final response from that UAS
will be returned to the UAC.
This process produces results which are optimal for INVITEs, which are
intended to connect one human user with another human user.
But this process is not optimal in other circumstances, especially
SUBSCRIBE and PUBLISH requests, where an automaton UAC wishes to send
information to or receive information from a set of automaton UASs.

</p>
<p>
In particular, these requests would perform better if they were forked
using mechanism that differs in these ways:
</p>
<ol class="text">
<li>
the
request is forked immediately (parallelly) to all targets, regardless of the
"q" values of the contact URIs,

</li>
<li>
the request is forked to all
applicable UASs, even after one UAS has accepted the request, and

</li>
<li>
all final responses from all UASs are
returned to the UAC, rather than being consolidated into one final
response.

</li>
</ol><p>

</p>
<p>
We propose that the above forking process be considered the
standardized definition
of the header "Request-Disposition: no-cancel, parallel"
<a class='info' href='#ref-prefs'>[ref&#8209;prefs]<span> (</span><span class='info'>Rosenberg, J., Schulzrinne, H., and P. Kyzivat, &ldquo;Caller Preferences for the Session Initiation Protocol (SIP),&rdquo; August&nbsp;2004.</span><span>)</span></a>,
so that a UAC can request that a request be forked using this
alternative mechanism.

</p>
<a name="current"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2"></a><h3>2.&nbsp;
The current forking mechanism</h3>

<p>
The rules for SIP proxies in RFC 3261 <a class='info' href='#ref-sip'>[ref&#8209;sip]<span> (</span><span class='info'>Rosenberg, J., Schulzrinne, H., Camarillo, G., Johnston, A., Peterson, J., Sparks, R., Handley, M., and E. Schooler, &ldquo;SIP: Session Initiation Protocol,&rdquo; June&nbsp;2002.</span><span>)</span></a> are organized
so that for any out-of-dialog request, (usually) only one UAS accepts the
request and only its final response is received by the UAC.  
(Within-dialog requests are intrinsically routed to a single
destination, the remote target.)

</p>
<p>
In order to accomplish this, various requirements are placed on
proxies:
If a proxy receives a 2xx response
from one UAS to which it has forked the request, it must send no further
copies of the request to other UASs.
If the request was an INVITE, it must immediately
CANCEL all other forked copies of the request.
A proxy should (normally) consolidate all final
responses it receives from UASs into one "best response" to be
forwarded to the UAC.

</p>
<p>
The principle that the proxy ensures that only one UAS accepts the
request 
is enforced only approximately -- Due to parallel forking,
the request may be sent to two UASs simultaneously, and they may both
accept it.
If the request method is not INVITE, the proxy will choose one of the
responses to send to the UAC and discard the other.
If the request method is INVITE, the proxy is required to forward both
2xx responses to
the UAC, so that it can be aware that two dialogs were established at
the UASs.
In that case, the UAC usually sends BYEs to terminate any
dialogs beyond the one created by the first 2xx response it receives.

</p>
<p>
This behavior for proxies was specified in RFC 3261 because it is optimal for
most INVITEs, which
are intended to create a communication path between one human user and
another human user.
There are problems with this forking mechanism when establishing
other kinds of communication sessions.

</p>
<a name="problems"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3"></a><h3>3.&nbsp;
Problems with the current forking mechanism</h3>

<p>
The currently specified behavior for proxies is less useful in many
situations other than an ordinary INVITE.

</p>
<a name="diagnostics"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.1"></a><h3>3.1.&nbsp;
Determinism and diagnosis</h3>

<p>
The current forking mechanism is admirably suited for offloading the
work of dealing with the multiple destination UASs to the proxy that
is nearest the point of forking.
But ipso facto, it hides any failures or unexpected behaviors from
the UAC, making it difficult for a human or automaton located at the
UAC to diagnose request routing problems
without having administrative access to every proxy along the route.
(And it is impossible to determine the identity of a proxy that is
involved without already having administrative access to the
"upstream" proxies.)
In addition, because of the "race" between two UASs that are willing
to accept a request, the outcome of the request can be
non-deterministic, so a series of diagnostic requests may produce
inconsistent responses.

</p>
<a name="publish"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.2"></a><h3>3.2.&nbsp;
PUBLISH</h3>

<p>
The 
PUBLISH <a class='info' href='#ref-publish'>[ref&#8209;publish]<span> (</span><span class='info'>Niemi, A., &ldquo;Session Initiation Protocol (SIP) Extension for Event State Publication,&rdquo; October&nbsp;2004.</span><span>)</span></a> 
and SUBSCRIBE <a class='info' href='#ref-subscribe'>[ref&#8209;subscribe]<span> (</span><span class='info'>Roach, A., &ldquo;Session Initiation Protocol (SIP)-Specific Event Notification,&rdquo; June&nbsp;2002.</span><span>)</span></a> requests seem admirably
suited for an automaton UAC to distribute information to, or retrieve
information from, a set of automaton UASs.
But the current forking mechanism makes it impossible for the UAC to
reliably send one request to all members of a set of UASs that are the
forking targets of one URI.

</p>
<p>
This is evident for  PUBLISH requests, which carry the information to
be disseminated.
If the PUBLISH is
intended to send information to a particular UA, the request-URI
could specify that UA.  But there is currently no way to reliably
disseminate information to all of the UAs that are the destinations
for a particular AOR; all that is guaranteed is that at least one UAS
will receive the information.
For most PUBLISH requests, it would be preferable for the request to be
distributed to all forking targets.

</p>
<a name="subscribe"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.3"></a><h3>3.3.&nbsp;
SUBSCRIBE</h3>

<p>
Any method which attempts to gather information from a group of UAs
(such as SUBSCRIBE) has similar problems as PUBLISH, but the use of
SUBSCRIBE to establish subscriptions at the UASs, which then send
NOTIFY requests, makes the situation even messier:  Because the method
is not INVITE, all 2xx responses are consolidated into one response by
the proxies.  This often delays the 2xx response from reaching the UAC
until after the
NOTIFYs sent by the UASs reach the UAC.  In practice, the UAC can only
determine the set of subscriptions that it has created by watching
for the NOTIFYs that they send.

</p>
<p>
In the prototypical example of the pick-up by a user on
a phone of a call ringing on another phone <a class='info' href='#ref-pickup'>[ref&#8209;pickup]<span> (</span><span class='info'>Worley, D., &ldquo;Call Pickup Examples in SIP,&rdquo; March&nbsp;2007.</span><span>)</span></a>,
the phone executing the pick-up sends a SUBSCRIBE to the AOR for the
extension to be
picked up.  The proxy forks this SUBSCRIBE to all the phones that have
an appearance of the extension, and each UAS phone sends a NOTIFY
detailing the early dialogs on that phone.  This information enables
the executing phone to find the dialog which it must pick up,
regardless of the UA on which the dialog is currently ringing.

</p>
<p>
If all incoming calls to that AOR are parallel-forked, all of these
subscriptions will return the same set of dialogs, so how the
SUBSCRIBE is forked is not important.  
(Actually, the different UASs will return homologous sets of early
dialogs, with the same Call-Id's and from-tags, but different to-tags.)
But if the different
UAs for the AOR are serially forked, the dialog will be ringing
on only one UA at a time, and it is important that the
SUBSCRIBE that is searching for that dialog be forked simultaneously
to all of the UAs for the AOR.
The current forking mechanism does not make this possible.

</p>
<a name="intercom"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.4"></a><h3>3.4.&nbsp;
Intercom</h3>

<p>
Another situation in which it would be preferable for all potential
targets to receive the request is in an "intercom" feature of an
office phone system, where an
audio stream is distributed to all the phones in the system, to be
output through a speaker on each phone.
To implement an intercom request as a single INVITE from the
UAC, the single INVITE must be forked to all of targets for 
request-URI, and the UAC must be able to establish dialogs with all of
them.

</p>
<a name="conferencing"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.5"></a><h3>3.5.&nbsp;
Conferencing</h3>

<p>
A more subtle case where connecting to all targets would be useful is
the routing of an INVITE generated by a conference system which forks
to multiple targets. <a class='info' href='#ref-conference'>[ref&#8209;conference]<span> (</span><span class='info'>Rosenberg, J., &ldquo;A Framework for Conferencing with the Session Initiation Protocol,&rdquo; February&nbsp;2006.</span><span>)</span></a>
Sometimes such an INVITE is intended to contact a single human, but at
other times, its request-URI routes to many humans, and the
intention is to include all of them in the conference.
Including multiple respondents in the conference is straightforward
to achieve if the forking process allows dialogs to be established
with all the UASs, by simply including all of the dialogs in the
conference.

</p>
<p>
Another example shows there are additional
complications in this situation.  Consider sending an
initial INVITE to the alias sip:sales@example.com, if you want to
have a conference with all your sales personnel.  This alias in turn
resolves to the AORs sip:alice@example.com, sip:bob@example.com, and 
sip:colin@example.com.  It is natural to fork the INVITE in parallel
to all these targets.

</p>
<p>
Now, if sip:alice@example.com resolves to two contacts (desk phone
and cell phone, maybe) with differing q-values, what should happen?
Should the INVITE be forked in the normal (probably serial) manner to
these contacts?  (That is probably the best way to reach Alice.)
Or should both contacts receive the INVITE via parallel forking?

</p>
<p>
Further complications can be introduced by assuming that
sip:sales@example.com initially is forked to
sip:sales-tokyo@example.com, sip:sales-ciudad-mexico@example.com, and
sip:sales-new-york@example.com, each of which then forks to individual
salespeople at those offices, and then assuming that each
salesperson's AOR is forwarded through several proxies before reaching
the UAs.

</p>
<p>
It might be possible to mark the INVITE such that the  forking of
sip:sales@example.com is
done in parallel according to the new scheme, and that the forking of
each resulting AOR is done in the traditional manner, but it seems to me that
such variants are endless, and it would be impossible to specify them all in a
systematic way.
And in any case, the UAC doesn't reliably know the downstream forking
structure.

</p>
<a name="messaging"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.6"></a><h3>3.6.&nbsp;
Messaging</h3>

<p>
Some "messaging" applications would be better served by forking to all
available UASs than by the current forking mechanism.  The MESSAGE
<a class='info' href='#ref-message'>[ref&#8209;message]<span> (</span><span class='info'>Campbell, B., Mahy, R., and C. Jennings, &ldquo;Session Initiation Protocol (SIP) Extension for Instant Messaging,&rdquo; February&nbsp;2005.</span><span>)</span></a>
request can be used to send SMS-style short messages, and in many
cases, it would be preferable to fork them to all UAs for the AOR, as
a UA might accept the request even if its user is not present (and
store the message for display to the user later).  So we wish to
distribute the MESSAGE to all UAs, not being able to predict which one
can first deliver the message to the user.

</p>
<p>
Similarly, a UAC that supports the MSRP messaging protocol <a class='info' href='#ref-msrp'>[ref&#8209;msrp]<span> (</span><span class='info'>Campbell, B., Mahy, R., and C. Jennings, &ldquo;The Message Session Relay Protocol (MSRP),&rdquo; September&nbsp;2007.</span><span>)</span></a> as a media session type may, like many instant
messaging clients, be willing 
to support simultaneous messaging sessions, and so would prefer
to issue INVITEs with a meaning much like an INVITE to a voice
conference. <a class='info' href='#conferencing'>Section&nbsp;3.5<span> (</span><span class='info'>Conferencing</span><span>)</span></a>

</p>
<a name="mechanism"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4"></a><h3>4.&nbsp;
A new proxy forking mechanism</h3>

<p>
Because the current forking mechanism is ideal for single-session
INVITEs, it should not be discontinued.
But there is a need for a new forking mechanism that can be applied to
requests which the UAS wants to establish dialogs with all possible targets.
The alternative forking mechanism differs from the current forking
mechanism in three ways:

</p>
<p>
</p>
<ol class="text">
<li>
A proxy simultaneously sends copies of the request to all targets in
the contact set,
regardless of whether any targets have already returned final responses, and
regardless of any specified "q" values in any contact set.

</li>
<li>
A proxy does not send CANCELs to other legs of a forked INVITE when
one leg returns a 2xx response.

</li>
<li>
A proxy returns all final responses to the requester immediately when
they are received (much as a stateless proxy would),
rather than holding them and consolidating them into one response.

</li>
</ol><p>

</p>
<p>
One possibility for activating this mechanism would be to have the
proxy choose the
forking mechanism based on the method of the request.
But this is undesirable for several reasons:  (1) It requires every
proxy in the signaling path to know the proper treatment of every
method that a UAC might send.  (2) The example of an INVITE generated
by a conference system (<a class='info' href='#conferencing'>Section&nbsp;3.5<span> (</span><span class='info'>Conferencing</span><span>)</span></a>) shows 
that the best processing of requests depends on more factors
than just the method.
(3) Making proxy behavior dependent on the request method violates
separation of concerns, warning that it would tend to interfere with
later SIP extensions.

</p>
<p>
Thus, we need to define a mechanism which a UAC can use mark requests
for its desired desired forking mechanism.
For upward compatibility, requests which are not marked must be
processed as specified in RFC 3261.
Requests which are marked for the alternative forking mechanism, but
which are forked by a proxy which does not understand the alternative
mechanism, will still be processed as in RFC 3261, but that causes no
loss of functionality relative to the current situation.
The "Request-Disposition: no-cancel parallel" header defined in RFC 3841
<a class='info' href='#ref-prefs'>[ref&#8209;prefs]<span> (</span><span class='info'>Rosenberg, J., Schulzrinne, H., and P. Kyzivat, &ldquo;Caller Preferences for the Session Initiation Protocol (SIP),&rdquo; August&nbsp;2004.</span><span>)</span></a> appears to be the natural way to activate this mechanism.

</p>
<a name="traceroute"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5"></a><h3>5.&nbsp;
Using the new forking mechanism for routing diagnosis</h3>

<p>
TCP/IP networking has evolved a rich set of tools for diagnosing
network problems, such as ping, traceroute, nslookup, dig, and
telnet.  Some of these tools depend on features of the TCP/IP protocol
suite that were added to specifically support diagnostics, whereas
others exploit the protocol suite in ways not imagined when it was
designed.
Currently, few diagnostic tools exist for SIP networking other than
the OPTIONS request for testing end-to-end connectivity.
In particular, it is hard for a UA to trace the routing of a SIP
request; tracing usually requires administrative access to the
proxies involved.

</p>
<p>
A simple "traceroute" can be made by sending a series of OPTIONS
requests with Max-Forwards values starting at one and increasing by
one.  Each OPTIONS request will be penetrate one step further along
the proxy chain before being returned as either a 2xx (OK) or 483 (Too
Many Hops) response.  (See section 11.2 of <a class='info' href='#ref-sip'>[ref&#8209;sip]<span> (</span><span class='info'>Rosenberg, J., Schulzrinne, H., Camarillo, G., Johnston, A., Peterson, J., Sparks, R., Handley, M., and E. Schooler, &ldquo;SIP: Session Initiation Protocol,&rdquo; June&nbsp;2002.</span><span>)</span></a>.)
But each step of the process can return only one response (OPTIONS
being a non-INVITE request), thus hiding most information about any
forking that may be occurring.

</p>
<p>
Using the new forking mechanism, the responses to this series of
OPTIONS requests would
show evidence of the forking that is involved the the request's path, as
the responses from each request would span the breadth of the forking
at the specified depth in the routing tree.

</p>
<p>
However, a 483 response is not guaranteed to contain much
information about the SIP agent which generated the response.
Nor is it required to contain much information about
the request as it appeared at that agent.  In particular, knowing the
request-URI from the request at that point would be invaluable, as
would knowing the Via headers, which allow the routing tree to be
reconstructed automatically.
But if SIP agents implement <a class='info' href='#ref-hop'>[ref&#8209;hop]<span> (</span><span class='info'>Lawrence, S., Hawrylyshen, A., and R. Sparks, &ldquo;Diagnostic Responses for SIP Hop Limit Errors,&rdquo; June&nbsp;2006.</span><span>)</span></a> and generate 483
responses that return the headers of the failing
request, the collection of
483 responses would provide detailed information about how the request
had been routed.

</p>
<a name="uri-list"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6"></a><h3>6.&nbsp;
Relationship to URI-list services</h3>

<p>
The new forking mechanism can be compared to the "URI-list services" mechanism
<a class='info' href='#ref-uri-services'>[ref&#8209;uri&#8209;services]<span> (</span><span class='info'>Camarillo, G. and A. Roach, &ldquo;Framework and Security Considerations for                Session Initiation Protocol (SIP) URI-List Services,&rdquo; October&nbsp;2008.</span><span>)</span></a>.
In both cases, a server downstream from the UAC sends copies of the request
to a set of destinations.  In URI-list services, this server is
a specialized URI-list server; in this proposal, the server is a SIP
proxy operating in a special mode.
The biggest difference is that in URI-list services, the list of
targets is determined directly by the UAC 
by providing a URI-list (or a reference to one), which allows the UAC
to create the list of targets on an ad-hoc basis; whereas in this
proposal, the list of targets must be the set of
contacts for a SIP URI that is interpreted by a proxy, which allows the list to be
maintained by the proxy independently of any UAC that might use it.
(This independence is what creates the diagnosis problem <a class='info' href='#diagnostics'>Section&nbsp;3.1<span> (</span><span class='info'>Determinism and diagnosis</span><span>)</span></a>.)

</p>
<a name="3841"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7"></a><h3>7.&nbsp;
Upward compatibility relative to RFC 3841</h3>

<p>
After writing the 00 version of this Internet-Draft, the author discovered that
RFC 3841 <a class='info' href='#ref-prefs'>[ref&#8209;prefs]<span> (</span><span class='info'>Rosenberg, J., Schulzrinne, H., and P. Kyzivat, &ldquo;Caller Preferences for the Session Initiation Protocol (SIP),&rdquo; August&nbsp;2004.</span><span>)</span></a> has defined the
Request-Disposition header so that the header 
"Request-Disposition: no-cancel, parallel" header has nearly the
semantics that this draft proposes: 
Features 1 and 2 of <a class='info' href='#mechanism'>Section&nbsp;4<span> (</span><span class='info'>A new proxy forking mechanism</span><span>)</span></a> are specifically
included in <a class='info' href='#ref-prefs'>[ref&#8209;prefs]<span> (</span><span class='info'>Rosenberg, J., Schulzrinne, H., and P. Kyzivat, &ldquo;Caller Preferences for the Session Initiation Protocol (SIP),&rdquo; August&nbsp;2004.</span><span>)</span></a>, whereas feature 3 (final
responses are forwarded immediately) seems to be
included only by implication from feature 2 (proxy does not cancel
forks upon receiving a 2xx from another fork).
But that RFC is rather sketchy about the exact significance of the Request-Disposition
header, so if we standardize the meaning of that header to be the
forking mechanism defined here, we must worry about upward
compatibility with any previous implementations of "Request-Disposition:
no-cancel, parallel" -- which may more closely resemble RFC 3261 forking.

</p>
<p>
The most visible difference between this forking mechanism and possible
previous implementations of RFC 3841 is that a UAC may receive
multiple responses to a single request.
If it is an INVITE request, RFC 3261 allows that multiple responses
might be received, though only if they are all 2xx responses.
But multiple responses from a non-INVITE request would also possible if
the proxy that forks the request is stateless, or if 
a response was processed by a different proxy in a replicated
set of proxies than processed the request.
These situations are probably not quite within the RFC 3261
specification, but seem like they could easily arise in practice, and
UACs should already be able to handle them.

</p>
<p>
In general, the significant problem would be in the UAC processing
responses and reporting them to the application that invokes the SIP
stack.
But in information publishing or gathering operations, response
processing is not particularly important.
When publishing information, the application will not be monitoring
the responses, as it does not manage its connection to any particular
destination.  Any reported success or failure from any particular
destination will not change the behavior of the publisher, as there is
little it can do to adjust to the failure of one UAS.
In information gathering, the responses to a SUBSCRIBE request are
not important either, as the significant information comes from the
NOTIFY requests that are sent by the created subscriptions, and each of
those is processed separately by the SIP stack already.

</p>
<p>
So it seems that we can safely assume that any previously implemented
UAC that uses "Request-Disposition: no-cancel, parallel" will work acceptably if
a proxy uses this new forking mechanism in response to that header.

</p>
<a name="anchor1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.8"></a><h3>8.&nbsp;
Security considerations</h3>

<p>
This mechanism presents no security considerations that are known to the author.

</p>
<a name="ack"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.9"></a><h3>9.&nbsp;
Acknowledgments</h3>

<p>
The author would like to thank Scott Lawrence and Michael Procter for
their comments and advice.

</p>
<a name="revision"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.10"></a><h3>10.&nbsp;
Revision history</h3>

<a name="00-01"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.10.1"></a><h3>10.1.&nbsp;
Changes from draft-worley-sipping-forking-00 to draft-worley-siping-forking-01</h3>

<p>
</p>
<blockquote class="text">
<p>
Added "Session Initiation Protocol (SIP)" to the title.

</p>
<p>
Updated contact information.

</p>
<p>
Adopted "Request-Disposition: parallel" as the indicator for the new
forking mechanism, and added discussion of upward compatibility relative to
previous implementations of RFC 3841.

</p>
<p>
Expanded on the example of a conference call to
sip:sales@example.com to show how complex the situation can become.

</p>
<p>
Added comparison with URI-list services.

</p>
<p>
Added Security considerations, Acknowledgments, and Revision history
sections.  Re-titled References section as Normative references.

</p>
<p>
Updated references to draft-ietf-simple-publish-01, RFC 4353,
draft-ietf-simple-message-sessions-14, and 
draft-ietf-sip-hop-limit-diagnostics-02.  Added references to
draft-worley-sipping-pickup-01, draft-ietf-sipping-uri-services-05,
and RFC 3841.

</p>
<p>
Added statement that this I-D intends to create a standardized
definition for the "Request-Disposition: parallel" header.

</p>
</blockquote><p>

</p>
<a name="01-02"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.10.2"></a><h3>10.2.&nbsp;
Changes from draft-worley-sipping-forking-01 to draft-worley-siping-forking-02</h3>

<p>
</p>
<blockquote class="text">
<p>
Updated contact information.

</p>
<p>
Changed "Request-Disposition: parallel" to
"Request-Disposition: no-cancel, parallel", which includes more of the
desired behavior by reference to <a class='info' href='#ref-prefs'>[ref&#8209;prefs]<span> (</span><span class='info'>Rosenberg, J., Schulzrinne, H., and P. Kyzivat, &ldquo;Caller Preferences for the Session Initiation Protocol (SIP),&rdquo; August&nbsp;2004.</span><span>)</span></a>.

</p>
<p>
Updated references to Internet-Drafts.

</p>
</blockquote><p>

</p>
<a name="02-03"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.10.3"></a><h3>10.3.&nbsp;
Changes from draft-worley-sipping-forking-02 to draft-worley-siping-forking-03</h3>

<p>
</p>
<blockquote class="text">
<p>
Updated contact information.

</p>
<p>
Updated references.

</p>
</blockquote><p>

</p>
<a name="rfc.references1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>11.&nbsp;Normative references</h3>
<table width="99%" border="0">
<tr><td class="author-text" valign="top"><a name="ref-sip">[ref-sip]</a></td>
<td class="author-text">Rosenberg, J., Schulzrinne, H., Camarillo, G., Johnston, A., Peterson, J., Sparks, R., Handley, M., and E. Schooler, &ldquo;<a href="http://tools.ietf.org/html/rfc3261">SIP: Session Initiation Protocol</a>,&rdquo; RFC&nbsp;3261, June&nbsp;2002 (<a href="ftp://ftp.isi.edu/in-notes/rfc3261.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="ref-subscribe">[ref-subscribe]</a></td>
<td class="author-text">Roach, A., &ldquo;<a href="http://tools.ietf.org/html/rfc3265">Session Initiation Protocol (SIP)-Specific Event Notification</a>,&rdquo; RFC&nbsp;3265, June&nbsp;2002 (<a href="ftp://ftp.isi.edu/in-notes/rfc3265.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="ref-publish">[ref-publish]</a></td>
<td class="author-text">Niemi, A., &ldquo;<a href="http://tools.ietf.org/html/rfc3903">Session Initiation Protocol (SIP) Extension for Event State Publication</a>,&rdquo; RFC&nbsp;3903, October&nbsp;2004 (<a href="ftp://ftp.isi.edu/in-notes/rfc3903.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="ref-conference">[ref-conference]</a></td>
<td class="author-text">Rosenberg, J., &ldquo;<a href="http://tools.ietf.org/html/rfc4353">A Framework for Conferencing with the Session Initiation Protocol</a>,&rdquo; RFC&nbsp;4353, February&nbsp;2006 (<a href="http://www.ietf.org/rfc/rfc4353.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="ref-message">[ref-message]</a></td>
<td class="author-text">Campbell, B., Mahy, R., and C. Jennings, &ldquo;<a href="http://tools.ietf.org/html/rfc3428">Session Initiation Protocol (SIP) Extension for Instant Messaging</a>,&rdquo; RFC&nbsp;3428, February&nbsp;2005 (<a href="ftp://ftp.isi.edu/in-notes/rfc3428.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="ref-msrp">[ref-msrp]</a></td>
<td class="author-text">Campbell, B., Mahy, R., and C. Jennings, &ldquo;<a href="http://tools.ietf.org/html/rfc4975">The Message Session Relay Protocol (MSRP)</a>,&rdquo; RFC&nbsp;4975, September&nbsp;2007 (<a href="ftp://ftp.isi.edu/in-notes/rfc4975.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="ref-hop">[ref-hop]</a></td>
<td class="author-text">Lawrence, S., Hawrylyshen, A., and R. Sparks, &ldquo;<a href="http://tools.ietf.org/html/draft-ietf-sip-hop-limit-diagnostics-03.txt">Diagnostic Responses for SIP Hop Limit Errors</a>,&rdquo; I-D&nbsp;draft-ietf-sip-hop-limit-diagnostics-03 (expired), June&nbsp;2006.</td></tr>
<tr><td class="author-text" valign="top"><a name="ref-pickup">[ref-pickup]</a></td>
<td class="author-text">Worley, D., &ldquo;<a href="http://tools.ietf.org/html/draft-worley-sipping-pickup-03.txt">Call Pickup Examples in SIP</a>,&rdquo; I-D&nbsp;draft-worley-sipping-pickup-03 (expired), March&nbsp;2007.</td></tr>
<tr><td class="author-text" valign="top"><a name="ref-uri-services">[ref-uri-services]</a></td>
<td class="author-text">Camarillo, G. and A. Roach, &ldquo;<a href="http://tools.ietf.org/html/rfc5363">Framework and Security Considerations for
               Session Initiation Protocol (SIP) URI-List Services</a>,&rdquo; RFC&nbsp;5363, October&nbsp;2008 (<a href="ftp://ftp.isi.edu/in-notes/rfc5363.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="ref-prefs">[ref-prefs]</a></td>
<td class="author-text">Rosenberg, J., Schulzrinne, H., and P. Kyzivat, &ldquo;<a href="http://tools.ietf.org/html/rfc3841">Caller Preferences for the Session Initiation Protocol (SIP)</a>,&rdquo; RFC&nbsp;3841, August&nbsp;2004 (<a href="ftp://ftp.isi.edu/in-notes/rfc3841.txt">TXT</a>).</td></tr>
</table>

<a name="rfc.authors"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>Author's Address</h3>
<table width="99%" border="0" cellpadding="0" cellspacing="0">
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Dale R. Worley</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Nortel Networks Corp.</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">600 Technology Park Dr.</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Billerica, MA  01821</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">US</td></tr>
<tr><td class="author" align="right">Phone:&nbsp;</td>
<td class="author-text">+1 978 288 5505</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:dworley@nortel.com">dworley@nortel.com</a></td></tr>
<tr><td class="author" align="right">URI:&nbsp;</td>
<td class="author-text"><a href="http://www.nortel.com">http://www.nortel.com</a></td></tr>
</table>
</body></html>
