






Internet Draft                                             Andy Bierman
                                                     Cisco Systems, Inc.
                                                       12 February 2002


                  Structure of Management Information:
                            Data Structures


                    <draft-bierman-sming-ds-02.txt>





Status of this Memo

This document is an Internet-Draft and is in full conformance with all
provisions of Section 10 of RFC2026 [RFC2026].

Internet-Drafts are working documents of the Internet Engineering Task
Force (IETF), its areas, and its working groups.  Note that other groups
may also distribute working documents as Internet-Drafts.

Internet-Drafts are draft documents valid for a maximum of six months
and may be updated, replaced, or obsoleted by other documents at any
time.  It is inappropriate to use Internet- Drafts as reference material
or to cite them other than as "work in progress".

The list of current Internet-Drafts can be accessed at
http://www.ietf.org/ietf/1id-abstracts.txt

The list of Internet-Draft Shadow Directories can be accessed at
http://www.ietf.org/shadow.html.

Distribution of this document is unlimited. Please send comments to the
SMIng WG mailing list <sming@ops.ietf.org>.

1.  Copyright Notice

Copyright (C) The Internet Society (2002).  All Rights Reserved.















Internet Draft             SMI Data Structures         February 12, 2002


2.  Abstract

This memo defines a portion of the Structure of Management Information
(SMI) for use with network management protocols in the Internet
community.  In particular, it describes a new structure and naming
scheme for network management information, allowing the specification of
arbitrarily complex hierarchical data structures.

3.  Table of Contents

1 Copyright Notice ................................................    1
2 Abstract ........................................................    2
3 Table of Contents ...............................................    2
4 The SNMP Network Management Framework ...........................    3
5 Overview ........................................................    4
5.1 Terms .........................................................    4
5.2 Design Objectives .............................................    5
5.3 Data Structure Constructs .....................................    6
5.4 Relationship to SMIv2 .........................................    7
5.5 Hierarchical Instance Naming ..................................    8
5.6 Object Conformance Information ................................   12
5.7 SMI-DS Data Object Usage Examples .............................   13
5.7.1 InetAddress Example .........................................   14
5.7.2 Generic High Capacity Counter Example .......................   16
5.7.3 Converted SMIv2 TABLE Example ...............................   18
5.8 Data Structure Augmentations ..................................   20
5.9 SYNTAX POINTER Clause .........................................   29
5.10 UNIQUE-SCOPE Clause ..........................................   29
6 Definitions .....................................................   32
6.1 Conformance Information Module ................................   32
6.2 Namespaces ....................................................   36
6.3 Syntax ........................................................   36
7 Information Modules .............................................   44
8 Appendix A: SMIv2 Compatibility .................................   45
8.1 Common Constructs .............................................   45
8.2 SMIv2 to SMI-DS Module Conversion .............................   45
8.3 SMI-DS to SMIv2 Module Conversion .............................   53
8.4 Compatibility Guidelines ......................................   53
9 Appendix B: Complete MODULE Example .............................   55
10 Appendix C: ConformanceInfo STRUCT Example .....................   62
11 Appendix D: Open Issues ........................................   64
12 Appendix E: Discussion of SMIng Objectives .....................   66
13 Security Considerations ........................................   82
14 Intellectual Property ..........................................   83
15 Acknowledgements ...............................................   83





Expires August 12, 2002                                         [Page 2]





Internet Draft             SMI Data Structures         February 12, 2002


16 References .....................................................   84
17 Author's Address ...............................................   86
18 Full Copyright Statement .......................................   88

4.  The SNMP Network Management Framework

   The SNMP Management Framework presently consists of five major
   components:

    o   An overall architecture, described in RFC 2571 [RFC2571].

    o   Mechanisms for describing and naming objects and events for the
        purpose of management. The first version of this Structure of
        Management Information (SMI) is called SMIv1 and described in
        RFC 1155 [RFC1155], RFC 1212 [RFC1212] and RFC 1215 [RFC1215].
        The second version, called SMIv2, is described in RFC 2578
        [RFC2578], RFC 2579 [RFC2579] and RFC 2580 [RFC2580].

    o   Message protocols for transferring management information. The
        first version of the SNMP message protocol is called SNMPv1 and
        described in RFC 1157 [RFC1157]. A second version of the SNMP
        message protocol, which is not an Internet standards track
        protocol, is called SNMPv2c and described in RFC 1901 [RFC1901]
        and RFC 1906 [RFC1906].  The third version of the message
        protocol is called SNMPv3 and described in RFC 1906 [RFC1906],
        RFC 2572 [RFC2572] and RFC 2574 [RFC2574].

    o   Protocol operations for accessing management information. The
        first set of protocol operations and associated PDU formats is
        described in RFC 1157 [RFC1157]. A second set of protocol
        operations and associated PDU formats is described in RFC 1905
        [RFC1905].

    o   A set of fundamental applications described in RFC 2573
        [RFC2573] and the view-based access control mechanism described
        in RFC 2575 [RFC2575].

   A more detailed introduction to the current SNMP Management Framework
   can be found in RFC 2570 [RFC2570].

   Managed objects are accessed via a virtual information store, termed
   the Management Information Base or MIB.  Objects in the MIB are
   defined using the mechanisms defined in the SMI.

   This memo does not specify a MIB module.





Expires August 12, 2002                                         [Page 3]





Internet Draft             SMI Data Structures         February 12, 2002


5.  Overview

There is a need for a standardized way of defining complex data
structures for the representation of management information, which can
be utilized with existing and future versions of SNMP. The SMIv2 data
model is based on groups of rectangular tables, which are related
because they share one or more INDEX clause components. This model
provides a single containment layer per table, because all the objects
in a conceptual row must be simple types (e.g., Integer32,
SnmpAdminString, Counter64).

The practice of spreading a multi-layer data structure across several
rectangular tables causes MIB modules to be much too verbose, hard to
understand, and even harder to implement.  The containment relationships
between tables are usually described in INDEX clauses and various
DESCRIPTION clauses.

This practice has a negative impact on agent implementations, which are
harder to implement and test, due to row creation and row activation
ordering issues.  This practice adds complexity to management
application development as well.

Software development and human readability would benefit from a data
definition language which more closely represents the basic data
structures that exist in almost all programming languages.

[ed. - This revision is intended to introduce the SMI Data Structure
concepts and is not yet defined in sufficient detail to be suitable as a
formal specification.]

5.1.  Terms

The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
"SHOULD", "SHOULD NOT", "RECOMMENDED",  "MAY", and "OPTIONAL" in this
document are to be interpreted as described in RFC 2119. [RFC2119]

This document uses some terms that need introduction:

Complex Data Object
     This term refers to any data object which provides some sort of
     containment for other data objects, which is any variable construct
     other than SCALAR (e.g. ARRAY, UNION, or STRUCT).

Data Object
     This term refers to any SMI Data Structure variable declaration, at





Expires August 12, 2002                                         [Page 4]





Internet Draft             SMI Data Structures         February 12, 2002


     any level of containment.

MIB Object
     This term generically refers to a SMIv2 OBJECT-TYPE macro
     definition.  It may also refer to an SMI Data Structure definition.

OID  This is a shorthand term for 'OBJECT IDENTIFIER'.

Scalar
     This term refers to a non-tabular SMIv2 MIB object.

SCALAR
     This term refers to any accessible data object with a syntax that
     resolves to a SMI base type. To avoid confusion, the term appears
     in capital letters when referring to any data object definition
     which represents a base type.

SMI Data Structure (SMI-DS)
     This term refers to the concepts and definitions defined in this
     document.

5.2.  Design Objectives

The working group objectives for this work are detailed in the SMIng
Objectives document [RFC3216].  (Refer to Appendix E for a detailed
discussion of each accepted objective.)

The primary high-level design goals of this work are:

   - Significantly enhance the usefulness of the SMI as a network
     management data definition language, by creating a modern
     programming language like data model supporting complex
     containment.

   - Enhance SMI object instance naming to support complex hierarchical
     data structures, while remaining backwardly-compatible with SMIv2
     naming.

   - Improve readability by enhancing reusability and removing as much
     redundant text as possible. The SMI should be as easy to use as
     possible, for the largest number of people. Therefore, a priority
     hierarchy can be established, starting with MIB readers, then MIB
     writers, management software developers, and MIB compiler writers.







Expires August 12, 2002                                         [Page 5]





Internet Draft             SMI Data Structures         February 12, 2002


   - Maintain 100% forward and backward translation compatibility with
     SMIv2.  It must be possible to convert all valid SMIv2 constructs
     to SMI-DS constructs without loss of semantics (i.e forward
     compatibility). It must also be possible to translate any SMI-DS
     construct to one or more SMIv2 constructs, if the associated
     feature(s) exist in SMIv2.  Refer to Appendix A for details on
     SMIv2 <--> SMI-DS translations.

   - Preserve as many of the SMIv2 mechanisms and 'installed knowledge-
     base' as possible.  There will a transition period lasting several
     years, in which SMIv2 MIBs will be converted to SMIv3 format.  It
     is important that MIB readers and writers be able to understand
     both SMI syntaxes during this period, and so it will be beneficial
     to keep them as close as possible.  Clauses that have not changed
     at all in semantics between SMI versions should maintain the same
     syntax.  [ed. - I actually prefer the NMRG C++ like syntax, but I
     think it's more important to make the transition to a new SMI as
     easy as possible for MIB readers and writers.]

   - Make sure accessible data objects (i.e. SCALARs) can be used with
     existing versions of SNMP.

There are some relevant topics which not design objectives addressed by
this draft:

   - Compatibility with any version of ASN.1.

   - Equally weighted importance for support of COPS-PR and SNMP.  There
     is a huge disparity in deployment of applications utilizing these
     protocols. The solution space is biased in favor of SNMP because
     that will benefit the largest number of people.

  -  Idiot proof MIB design. Data structures can help better organize
     the information found in a MIB, but they can't prevent bad design
     choices or badly written DESCRIPTION clauses.

5.3.  Data Structure Constructs

There are four basic constructs available in the SMI-DS language for the
definition of data objects.

SCALAR
     This construct is conceptually equivalent to an OBJECT-TYPE macro
     definition for an accessible MIB object in SMIv2, except a SCALAR
     can be defined at any level of containment. A SCALAR type





Expires August 12, 2002                                         [Page 6]





Internet Draft             SMI Data Structures         February 12, 2002


     definition or variable declaration resolves to any SMIng base type.
     In SMI-DS, all other constructs must eventually resolve to some
     number of these objects, and only SCALAR data objects are actually
     accessible via a management protocol.

ARRAY
     This construct provides a multi-dimensional array structure,
     similar to the SEQUENCE construct in SMIv2.  However, instead of
     one flat 'row' consisting of only accessible base-type MIB objects,
     an ARRAY can consist of an arbitrary mix of any of the four types
     of data object constructs.  Only base type data objects can be used
     in an ARRAY INDEX clause (the same ones as in SMIv2), and the rules
     for encoding INDEX clause base types in OIDs are the same as for
     SMIv2.

UNION
     This construct provides a mechanism to conceptually allow a single
     object definition to contain one of potentially several different
     construct definitions.  Only one of these constructs is actually
     instantiated at any time by the agent. Unlike a union in the C
     language, the unused union members cannot be accessed at all (no
     'cast' operator in SMI).

STRUCT
     This construct provides a mechanism to group an arbitrary number of
     data constructs (of any type), allowing a theoretically unlimited
     number of data containment layers.  It is similar to the ARRAY
     construct, except there is no INDEX clause.

5.4.  Relationship to SMIv2

Whenever possible, existing SMIv2 macros or clauses have been used
without modification.  Two exceptions are the TEXTUAL-CONVENTION and
OBJECT-TYPE macros. In order to reinforce and support a data model more
aligned with popular programming concepts and practices, these macros
have been replaced by the TYPEDEF and VAR macros (respectively).  Strong
emphasis is placed on the separation of potentially reusable type
definitions and variable declarations. The ASN.1 tabular data model is
replaced with a 'hierarchical containment' data model, which is more
similar to the 'native' data representation used by the managed device.

The type of declarations that can be made in an SMI-DS module do not
really change at all, but some constructs have changed. The major
differences between an SMIv2 construct and the equivalent SMI-DS
construct are listed in the table below:





Expires August 12, 2002                                         [Page 7]





Internet Draft             SMI Data Structures         February 12, 2002


          SMIv2                     SMI-DS
   ---------------------     ---------------------
   TEXTUAL-CONVENTION        TYPEDEF SCALAR
   scalar OBJECT-TYPE        VAR SCALAR
   tabular OBJECT-TYPE       VAR ARRAY
   INDEX { a, b, c }         expanded INDEX clause,
                                 one per INDEX component
   AUGMENTS { fooEntry }     VAR STRUCT bar AUGMENTS fooEntry
   table clone because not
       every row augmented   VAR STRUCT bar SPARSE-AUGMENTS
                                 fooEntry
   set of OBJECT-IDENTIFIER  NODES
       macros defining
       branches in the MIB
       module
   NOTIFICATION-TYPE         NOTIFICATION

Notification semantics have not changed at all, although the syntax has
changed slightly to make them more consistent with the TYPEDEF and VAR
macros.  The ASN.1 specific SEQUENCE macro, and the 'FooTable' and
'FooEntry' OBJECT-TYPE definitions that start every SMIv2 table are
removed. OBJECT IDENTIFIERs which are actually sub-tree node specifiers
for that MIB module are now specified in a NODES macro, to distinguish
them from OBJECT IDENTIFIERs which are declared as OID Registration
values. The basic SYNTAX clause has not changed at all, except that a
new variant is provided to specify a typed OID pointer (see section
5.9).

Many constructs do not change at all, such as the IMPORTS, MODULE-
IDENTITY, MAX-ACCESS, STATUS, DESCRIPTION, REFERENCE, DEFVAL, OBJECTS,
and MODULE-COMPLIANCE macros.

5.5.  Hierarchical Instance Naming

In order to fully utilize the capabilities of arbitrary containment, a
new way of naming object instances is needed, which is designed for
hierarchical data structures instead of tables, without changing the OID
values for any existing SMIv2 objects which are converted to the SMI-DS
object naming format.

Since it's possible for accessible objects to exist in the same
containment structure as non-accessible objects, it is not possible to
name SMI-DS objects with a 'flat' model. SMIv2 assumes all accessible
objects in the same containment structure have the same number of object
identifier components, and the exact same format for all instance





Expires August 12, 2002                                         [Page 8]





Internet Draft             SMI Data Structures         February 12, 2002


identifier components.  This assumption cannot be made for SMI-DS object
naming.

This new naming scheme can help reduce implementation complexity for
agent and application developers for SNMP Set operations.  Currently,
associated attributes can be spread across multiple tables, (possibly
sharing major indexes) each with their own RowStatus and set of 'SNMP
callback' functions. This design approach can get relatively
complicated, especially if 'createAndWait' and 'notInService' RowStatus
values are supported.  By allowing complex containment instead of
unfolding data structures into tables, implementation of high-level Set
operations can be simplified for both agent and application developers.

The basic format of an OID for an SMI-DS data object is not changed from
SMIv2. OIDs are constructed left to right. The left fragment contains
static OID values which indicate the name of a node in the MIB tree.
The right fragment contains potentially dynamic OID values which
represent the instance identifier for the node specified by the left
fragment.

In order to provide MIB object conformance information at runtime,
previously unused portions of the MIB tree are now specified to be
pseudo-objects. Each of these pseudo-OIDs identifies a conceptual
structure, called the 'ConformanceInfo' STRUCT (see section 5.6), which
can be retrieved in the same manner as any other MIB object.

SCALAR Data Object Naming
-------------------------

   A SCALAR variable declaration is named as follows:

      <oidBase>.0

    where:

      <oidBase> is a well-formed OID base fragment.

SCALAR ComplianceInfo Naming
----------------------------

   The conformance information STRUCT associated with each
   SCALAR variable declaration is named as follows:

      <oidBase>.0.0






Expires August 12, 2002                                         [Page 9]





Internet Draft             SMI Data Structures         February 12, 2002


   See section 6.1 for the specification of the 'ConformanceInfo'
   TYPEDEF.

Non-SCALAR Static Sub-Identifier Naming
---------------------------------------

   The basic structure of the static portion of the OID
   is the same for both naming variants of a Complex Data Object.

      <oidBase>.<compatNode>.<childNode> [.<childNode> ...]

    where:

      <oidBase> is a well-formed OID base fragment,
          (also called the left anchor).

      <compatNode> is a component for maintaining compatibility
          with SMIv2 naming for tabular objects. It is also used
          to help identify meta-data for each MIB object.

      <childNode> is the data object child node identifier, which
          must be an INTEGER between 1 and 4294967295. (Similar
          to a column identifier in an SMIv2 table.)

Non-SCALAR Data Object Naming
-----------------------------

   A Complex Data Object variable declaration is named as follows:

      <oidBase>.1.<childNode> [.<childNode> ...] [.<indexNode> ...]

    where:

      <oidBase> is defined above

      <compatNode> contains the value 1.

      <childNode> is defined above

      <indexNode> is present only if the variable declaration
          resolves to a type that contains any ARRAY constructs,
          and MUST be an INTEGER between 0 and 4294967295.
          (Similar to an instance identifier in an SMIv2 table.)

Non-SCALAR ComplianceInfo Naming





Expires August 12, 2002                                        [Page 10]





Internet Draft             SMI Data Structures         February 12, 2002


--------------------------------

   The conformance information STRUCT associated with each accessible
   node within a complex data object variable declaration is named
   as follows:

      <oidBase>.0.<childNode> [.<childNode> ...]

    where

      <oidBase> is defined above

      <compatNode> contains the value 0.

      <childNode> is defined above

   The resulting OID names the conformance information STRUCT for the
   variable with the same value <oidBase> and the same <childNode>
   sub-identifiers.

ARRAY INDEX ComplianceInfo Naming
---------------------------------

   The conformance information STRUCT associated with each
   INDEX clause within an ARRAY data object variable declaration
   is named as follows:

      <oidBase>.0.0.<indexId>

    where

      <oidBase> is defined above, and must represent the base
          identifier of an ARRAY construct. The INDEX clauses defined
          by <indexId> are numbered 1 to N, starting with the first
          INDEX clause in the ARRAY specified by <oidBase>.

      <compatNode> contains the value 0.

      <childNode> contains the value 0.

      <indexId> identifies the INDEX clause for which the
          ConformanceInfo STRUCT applies.  The indexId MUST be
          an INTEGER between 1 and 2147483647, and represents the
          position of the INDEX clause. Note that the units are
          INDEX clauses, not the individual <indexNode> octets.





Expires August 12, 2002                                        [Page 11]





Internet Draft             SMI Data Structures         February 12, 2002


   The resulting OID names the conformance information STRUCT for
   the INDEX clause with the same positional value, for the ARRAY
   variable specified by <oidBase>.

SMI-DS OID Construction
-----------------------

OIDs are constructed in an iterative manner, using two conceptual
buffers:

base buffer
     used for building the static portion of an OID, left to right.
     This buffer contains the <oidBase>, <compatNode>, and all
     <childNode> identifiers.

index buffer
     used for building a sequence of ARRAY indexes, (left to right),
     similar to the instance identifier portion of an SMIv2 OID for a
     tabular object. This buffer contains all the <indexNode>
     identifiers.

The expansion algorithm for <childNode> is repeated if it represents a
complex data object. If it represents an ARRAY construct, then all
<indexNode> components for this array type are appended to index buffer.

The algorithm terminates when a SCALAR data object is encountered.  The
index buffer is then appended to the base buffer, to form the complete
instance identifier for a specific variable declaration.

5.6.  Object Conformance Information

Conformance Statements for SMIv2 [RFC2580] provides the MODULE-
COMPLIANCE macro which allows the MIB writer to define different
conformance levels, to specify various subsets of the full functionality
defined in the MIB module.  Unfortunately, an NMS application developer
cannot easily determine the exact conformance level by any given agent
implementation, even those that are following the standard correctly.
For example, it is not always easy to determine if an agent implements
the full semantics of an object, or the semantics refined by one of
potentially several OBJECT clauses (in different MODULE-COMPLIANCE
macros).

The AGENT-CAPABILITIES macro allows an SNMP developer to determine
conformance information for specific objects for a particular release of
a particular product.  Unfortunately, this information is not available





Expires August 12, 2002                                        [Page 12]





Internet Draft             SMI Data Structures         February 12, 2002


in any form from the agent. Instead, it is maintained as a text file by
the network administrator.

SMI-DS utilizes a portion of the MIB sub-tree to provide conformance and
variance information for each accessible data object and each INDEX
clause in a (potentially nested) ARRAY variable declaration.

A small set of 'pseudo' MIB objects in a 'ConformanceInfo' STRUCT is
defined for each accessible object supported by the application. These
appear the same as MIB objects in every way 'on-the-wire', but they are
implicitly defined for every corresponding accessible MIB object, and
there is no conformance information available for the ConformanceInfo
objects themselves.  These pseudo-objects are only instantiated for
corresponding 'real' data objects which are actually implemented by the
agent, not for every object listed in every MIB module implemented by
the agent. In other words, if the agent would return a 'noSuchObject'
exception for a particular data object, then it would return a
'noSuchInstance' exception for any of the corresponding ConformanceInfo
pseudo-objects.

The following objects are contained in the ConformanceInfo STRUCT, which
is defined in detail in section 6.1:

confModuleCompliance
     An OID pointer to MODULE-COMPLIANCE macro pertaining to the object,
     as implemented by the agent.

confLevel
     An enumerated integer describing the basic conformance level to the
     object specification, as implemented by the agent.

confVariation
     A structure containing two strings describing the variation from
     the specification, as implemented by the agent.  The
     'confVarSyntax' string contains the SYNTAX clause within the
     VARIATION clause that would be present in an AGENT-CAPABILITIES
     macro for the specified object. The optional 'confVarDescr' string
     contains the DESCRIPTION clause within the VARIATION clause that
     would be present in an AGENT-CAPABILITIES macro for the specified
     object.

5.7.  SMI-DS Data Object Usage Examples

The following sections introduce some examples of simple data structures
that are currently achieved with relatively verbose text in TEXTUAL-





Expires August 12, 2002                                        [Page 13]





Internet Draft             SMI Data Structures         February 12, 2002


CONVENTION and OBJECT-TYPE DESCRIPTION clauses using SMIv2.  Refer to
Appendix B for an example of a (somewhat) complete SMI-DS module.

5.7.1.  InetAddress Example

The Internet Address textual conventions defined in the "Textual
Conventions for Internet Network Addresses" MIB module [RFC2851] defines
several variants of an Internet address (InetAddress), and a control
object (InetAddressType) to distinguish which variant is actually
present in an InetAddress object instance.  This construct may be more
concisely and properly represented in SMI-DS by a structure containing
the control object and a union of all the address variants.

-- a union of all the InetAddress types

TYPEDEF UNION InetAddressUnion {
    DESCRIPTION
       "Internet address in 4 different representations."

    SCALAR ipUnknown {
       SYNTAX      OCTET STRING (SIZE (0..65535))
       MAX-ACCESS  read-only
       STATUS      current
       DESCRIPTION
           "Represents an Internet address using an externally
            defined format. The associated InetAddressType
            object value is 'unknown(0)'."
    } ::= 1

    SCALAR ipv4Addr {
       SYNTAX      InetAddressIPv4
       MAX-ACCESS  read-only
       STATUS      current
       DESCRIPTION
           "Represents an IPv4 Internet address. The
            associated InetAddressType object value
            is 'ipv4(1)'."
    } ::= 2

    SCALAR ipv6Addr {
       SYNTAX      InetAddressIPv6
       MAX-ACCESS  read-only
       STATUS      current
       DESCRIPTION
           "Represents an IPv6 Internet address. The





Expires August 12, 2002                                        [Page 14]





Internet Draft             SMI Data Structures         February 12, 2002


            associated InetAddressType object value
            is 'ipv6(2)'."
    } ::= 3

    SCALAR ipDnsAddr {
       SYNTAX      InetAddressDNS
       MAX-ACCESS  read-only
       STATUS      current
       DESCRIPTION
           "Represents an DNS domain name.  The associated
            InetAddressType object value is 'dns(16)'."
    } ::= 4
}

TYPEDEF STRUCT HostInetAddress {
    DESCRIPTION
       "Internet address for an end-station host, adhering
        to the SMIv2 'associated objects' design approach."

    SCALAR addrType {
       SYNTAX      InetAddressType
       MAX-ACCESS  read-only
       STATUS      current
       DESCRIPTION
           "The type of Internet address."
    } ::= 1

    UNION addr {
       SYNTAX      InetAddressUnion
       STATUS      current
       DESCRIPTION
           "The Internet address."
    } ::= 2
}

VAR STRUCT myAddress {
    SYNTAX      HostInetAddress
    STATUS      current
    DESCRIPTION
        "Internet address of this host."
} ::= { someBase 1 }

VAR UNION newAddress {
    SYNTAX      InetAddressUnion
    STATUS      current





Expires August 12, 2002                                        [Page 15]





Internet Draft             SMI Data Structures         February 12, 2002


    DESCRIPTION
        "Example of the new way to represent a union variable,
         without the use of an associated InetAddressType object."
} ::= { someBase 2 }

Note 1) The accessible object instances defined within this structure
(addrType, ipUnknown, ipv4Addr, ipv6Addr, etc.)  have different lengths:

  myAddress                ::= { someBase 1 }
  myAddress.addrType       ::= { myAddress 1 1 }
  myAddress.addr           ::= { myAddress 1 2 }
  myAddress.addr.ipUnknown ::= { myAddress 1 2 1 }
  myAddress.addr.ipv4Addr  ::= { myAddress 1 2 2 }
  myAddress.addr.ipv6Addr  ::= { myAddress 1 2 3 }
  myAddress.addr.dnsAddr   ::= { myAddress 1 2 4 }

  newAddress               ::= { someBase 2 }
  newAddress.ipUnknown     ::= { newAddress 1 1 }
  newAddress.ipv4Addr      ::= { newAddress 1 2 }
  newAddress.ipv6Addr      ::= { newAddress 1 3 }
  newAddress.dnsAddr       ::= { newAddress 1 4 }


Note 2) The addrType field is not actually needed for simple variable
declarations, because UNION constructs are instantiated with at most one
accessible member.  In the example above, a GetNext Request for
'myAddress.addr' or 'newAddress' will return only one type of
InetAddress string from the InetAddressUnion.  The associated
InetAddressType variable is needed only when used together with the
InetAddress (generic string form) as INDEX components in an ARRAY.

Note 3) Just like a TEXTUAL-CONVENTION in SMIv2, a TYPEDEF has no
instances associated with it and therefore no MIB root assigned.  It is
only when a a variable of a particular type is declared (and therefore
assigned a MIB root) that the full OID for a data object is known.

5.7.2.  Generic High Capacity Counter Example

There are many MIBs that contain up to the three OBJECT-TYPE macro
definitions for every high capacity counter, in order to accommodate
SNMPv1 implementations without support for Counter64 and 32-bit
implementations without any high capacity support at all.

A type definition (GenericCounter) for a union that contains an object
for each of the three scenarios would better represent the intended





Expires August 12, 2002                                        [Page 16]





Internet Draft             SMI Data Structures         February 12, 2002


semantics of this design, and use less text within data structure
definitions than an SMIv2 version. Note that a discriminator object is
not needed for a union, because the agent (or management application)
will instantiate at most one of the variants.

TYPEDEF UNION GenericCounter {
    DESCRIPTION
       "Generic counter for all versions of SNMP."

    SCALAR c32 {
       SYNTAX      Counter32
       MAX-ACCESS  read-only
       STATUS      current
       DESCRIPTION
           "The Counter32 representation of the counter."
    } ::= 1

    SCALAR c64 {
       SYNTAX      Counter64
       MAX-ACCESS  read-only
       STATUS      current
       DESCRIPTION
           "The Counter64 representation of the counter."
    } ::= 2

    STRUCT c32pair {
        DESCRIPTION
            "Pair of Counter32 objects to represent a 64-bit
             counter."

        SCALAR c32low {
            SYNTAX      Counter32
            MAX-ACCESS  read-only
            STATUS      deprecated
            DESCRIPTION
                "The lower 32 bits of a 64 bit counter."
        } ::= 1

        SCALAR c32hi {
            SYNTAX      Counter32
            MAX-ACCESS  read-only
            STATUS      deprecated
            DESCRIPTION
                "The upper 32 bits of a 64 bit counter."
        } ::= 2





Expires August 12, 2002                                        [Page 17]





Internet Draft             SMI Data Structures         February 12, 2002


    } ::= 3
}

VAR UNION myCounter {
    SYNTAX      GenericCounter
    STATUS      current
    DESCRIPTION
       "An example generic counter variable."
} ::= { someBase 3 }

Note 1) Inline vs. external type definition: The 'c32pair' STRUCT could
have been defined as a separate type and a STRUCT declared with a SYNTAX
clause that referenced that type (e.g.  <struct-ref-type-decl> form of
the STRUCT declaration).  The instance numbering works out the same
either way.

The following OIDs would be possible for the 'myCounter' variable
declaration:

   myCounter                ::= { someBase 3 }
   myCounter.c32            ::= { myCounter 1 1 }
   myCounter.c64            ::= { myCounter 1 2 }
   myCounter.c32pair        ::= { myCounter 1 3 }
   myCounter.c32pair.c32low ::= { myCounter 1 3 1 }
   myCounter.c32pair.c32hi  ::= { myCounter 1 3 2 }

Note 2) Even though only one node of a UNION can be instantiated at any
given time, a GetNext Request for a UNION which contains other complex
data objects can cause multiple instances to be returned from that sub-
tree, as with the 'c32low' and 'c32hi' SCALARs in the example above.

Note 3) Only the STATUS clauses for SCALAR data object definitions are
relevant for compliance section usage.  However, the above example
raises issues regarding a complex data object which contains a mixture
of current, deprecated, and obsolete SCALARs. (Is the STATUS of the
GenericCounter UNION itself current or deprecated?)

5.7.3.  Converted SMIv2 TABLE Example

The following example shows how two objects from the ifTable [RFC2233]
would be defined in SMI-DS syntax.  Note that in in this example, the
interface table is modeled directly as a variable declaration, without
using a TYPEDEF.  This practice is discouraged for new MIB definitions.

-- this is modeled as an ARRAY variable, rather than





Expires August 12, 2002                                        [Page 18]





Internet Draft             SMI Data Structures         February 12, 2002


-- an ARRAY containing a TYPEDEF'ed structure, to preserve
-- compatibility with SMIv2

VAR ARRAY ifTable {
    DESCRIPTION
        "A list of interface entries.  The number of entries
         is given by the value of ifNumber."

    INDEX ifIndex {
        SYNTAX  InterfaceIndex       -- range of the INDEX
        MAX-ACCESS  read-only        -- allow proper SMIv2 translation
        SIZE    (0..2147483647)      -- range of the instances
        DESCRIPTION
            "A unique value, greater than zero, for each
             interface.  It is recommended that values are assigned
             contiguously starting from 1.  The value for each
             interface sub-layer must remain constant at least from
             one re-initialization of the entity's network
             management system to the next re-initialization."
    } ::= 1

    SCALAR ifDescr {
        SYNTAX      DisplayString (SIZE (0..255))
        MAX-ACCESS  read-only
        STATUS      current
        DESCRIPTION
            "A textual string containing information about the
             interface.  This string should include the name of the
             manufacturer, the product name and the version of the
             interface hardware/software."
    } ::= 2

    SCALAR ifType {
        SYNTAX      IANAifType
        MAX-ACCESS  read-only
        STATUS      current
        DESCRIPTION
            "The type of interface.  Additional values for ifType
             are assigned by the Internet Assigned Numbers
             Authority (IANA), through updating the syntax of the
             IANAifType textual convention."
    } ::= 3

    -- rest of ifTable SCALARs would follow
} ::= { interfaces 2 }





Expires August 12, 2002                                        [Page 19]





Internet Draft             SMI Data Structures         February 12, 2002


Note 1) The object naming and semantics are identical to the SMIv2
version. The OIDs for instance number '17' are shown:

  ifTable                  ::= { interfaces 2 }
  ifTable[17]              ::= Not Available
  ifTable[17].ifIndex      ::= { ifTable 1 1 17 }
  ifTable[17].ifDescr      ::= { ifTable 1 2 17 }
  ifTable[17].ifType       ::= { ifTable 1 3 17 }

Note 2) The SIZE clause is needed because the number of instances
allowed in an ARRAY is independent of the range specified by the SYNTAX
clause.

Note 3) For backward compatibility with SMIv2, INDEX clauses are allowed
to be assigned a node number within the ARRAY where they are defined.
This value must not be assigned to any other INDEX or any data object
node defined in the same ARRAY. If this node assignment is missing, the
INDEX clause will not be assigned a node number. For backward
compatibility with SMIv2, INDEX clauses need to be either assigned node
numbers within the containing ARRAY, unless the 'EXTERN' keyword is
present.

Note 4) In order to allow for an IfEntry TYPEDEF, and a separate ifEntry
ARRAY variable declaration, the INDEX clause would have to be 'fixed' to
specify the container in which the <N> node number applies, instead of
implying the container where the INDEX clause is defined.

Note 5) The MAX-ACCESS clause is allowed for INDEX macros, to provide a
way to automatically convert an SMI-DS INDEX to an SMIv2 object with a
MAX-ACCESS clause other than the the normal value of 'not-accessible'.
The MAX-ACCESS clause can only be present in an INDEX if the node
assignment clause is also present (i.e. no direct access is possible
unless an OID is assigned).  The MAX-ACCESS clause should only be used
if a value other than 'not-accessible' is required.

5.8.  Data Structure Augmentations

SMIv2 allows for MIB tables to be conceptually extended over time,
without modifying the original MIB table definition, using the AUGMENTS
clause.  This is usually done to allow vendor extensions to standard
MIBs, or to avoid editing a 'stable' RFC.

In SMI-DS, the concept of AUGMENTS is preserved and adapted for use with
complex data objects, in order to maintain backward compatibility with
SMIv2.  Only variable declarations for ARRAY data objects can be





Expires August 12, 2002                                        [Page 20]





Internet Draft             SMI Data Structures         February 12, 2002


augmented.

In addition to the AUGMENTS clause, which models 1:1 existence
relationships between two ARRAY variables, a SPARSE-AUGMENTS clause is
provides to model conditional 1:1 existence relationships between the
augmenting STRUCT variable and the augmented ARRAY variable.

In order to maintain consistent syntax and semantics, the conceptual
augmenting container is a STRUCT, not an ARRAY, because the augmenting
variable cannot add any new INDEX clauses to the augmented ARRAY
variable. The STRUCT is treated as an 'unwrapped STRUCT' when the
AUGMENTS (or SPARSE-AUGMENTS) keyword is present, and it is conceptually
converted to an ARRAY variable by adding the INDEX clause(s) from the
augmented variable.

The AUGMENTS construct defines one or more nodes which are conceptually
added to the outermost containment layer of the augmented ARRAY
variable.  The augmenting ARRAY variable inherits all of the index
components of that ARRAY (exactly as with SMIv2).  In SMI-DS, the
augmented INDEX clauses are conceptually copied as 'EXTERN' INDEX
clauses (i.e. OID assignment, if any, stays in augmented ARRAY).

A variant of the AUGMENTS construct is provided (called SPARSE-AUGMENTS)
for situations in which a static subset of an existing ARRAY is
augmented.  It is almost identical to the AUGMENTS clause, except the
SPARSE-AUGMENTS has two additional clauses:

SPARSE-CONDITION
     Provides a textual description of the static condition(s) under
     which a given augmenting instance should be instantiated.

SPARSE-EXPRESSION
     Provides a Boolean expression which can be machine-parsed (if
     available) of the condition(s) described in the SPARSE-CONDITION
     clause.

AUGMENTS Example
----------------

The following trivial example shows how some high-capacity counters and
time-related attributes might be added to an existing array of packet
statistics.

TYPEDEF ARRAY InetHostStats {
    DESCRIPTION





Expires August 12, 2002                                        [Page 21]





Internet Draft             SMI Data Structures         February 12, 2002


        "Example of a IP host stats table."

    EXTERN INDEX ifIndex {
        SYNTAX  InterfaceIndex       -- range of the INDEX
        SIZE    (0..65535)           -- range of the instances
        DESCRIPTION
            "The interface source for these statistics."
    }     -- the node # clause is not allowed if EXTERN kw present

    INDEX inetAddrType {
        SYNTAX  InetAddressType
        SIZE    (0..65535)
        DESCRIPTION
            "The IP address type for the array entry.
             The InetAddressType values 'unknown(1)' and
             'dns(16)' are not allowed."
    } ::= 1     -- not-accessible, unused node # for SMIv2 compat.

    INDEX inetAddr {
        SYNTAX  InetAddress
        SIZE    (0..65535)
        DESCRIPTION
            "The IP address for the array entry."
    } ::= 2      -- not-accessible, unused node # for SMIv2 compat.

    SCALAR inPkts {
       SYNTAX      Counter32
       MAX-ACCESS  read-only
       STATUS      current
       DESCRIPTION
          "The number of packets received by the specified host
           on the specified interface."
    } ::= 3

    SCALAR outPkts {
       SYNTAX      Counter32
       MAX-ACCESS  read-only
       STATUS      current
       DESCRIPTION
          "The number of packets transmitted by the specified
           host on the specified interface."
    } ::= 4

    -- Octet counters removed to make example shorter
}





Expires August 12, 2002                                        [Page 22]





Internet Draft             SMI Data Structures         February 12, 2002


-- variable declaration for a InetHostStats data collection

VAR ARRAY ipStats {
    SYNTAX      InetHostStats
    STATUS      current
    DESCRIPTION
       "The IP host statistics for this network device."
} ::= { someBase 4 }

-- a struct containing additional information for each
-- set of counters

TYPEDEF STRUCT HostStatsTimeData {
    DESCRIPTION
        "Add some times related objects associated with
         each set of counters."

    SCALAR createTime {
       SYNTAX      TimeStamp
       MAX-ACCESS  read-only
       STATUS      current
       DESCRIPTION
          "The value of sysUpTime at the time this set of
           counters was created."
    } ::= 1

    SCALAR updateInterval {
       SYNTAX      Unsigned32
       UNITS       "milliseconds"
       MAX-ACCESS  read-only
       STATUS      current
       DESCRIPTION
          "The average amount of time that elapses between
           internal polling intervals for this counter set.
           A value of zero indicates that the counter set
           values are not polled internally."
    } ::= 2
}

-- Augment the ipStats variable with the ipXStats variable:
--    - 2 HC packet counters
--    - a HostStatsTimeData STRUCT
--    - an ARRAY of InetPortNumber packet counters
-- This is done as a variable instead of a TYPEDEF for
-- demonstration purposes





Expires August 12, 2002                                        [Page 23]





Internet Draft             SMI Data Structures         February 12, 2002


VAR STRUCT ipXStats AUGMENTS ipStats {
    DESCRIPTION
        "Adds HC counters and additional information to
         the ipStats statistics."

    SCALAR inHCPkts {
        SYNTAX      Counter64
        MAX-ACCESS  read-only
        STATUS      current
        DESCRIPTION
            "The number of packets received by the specified
             host on the specified interface."
    } ::= 1

    SCALAR outHCPkts {
        SYNTAX      Counter64
        MAX-ACCESS  read-only
        STATUS      current
        DESCRIPTION
            "The number of packets transmitted by the specified
             host on the specified interface."
    } ::= 2

    -- Octet counters removed to make example shorter

    STRUCT timeData {
        SYNTAX      HostStatsTimeData
        STATUS      current
        DESCRIPTION
            "Additional time-related information."
    } ::= 3

    ARRAY portStats {
        DESCRIPTION
            "Extend the ARRAY with InetPort statistics."

        INDEX inetPort {
            SYNTAX  InetPortNumber
            SIZE    (0..65535)
            DESCRIPTION
                "The Internet port number for the array entry."
        } ::= 1

        UNION uInPkts {
            SYNTAX GenericCounter





Expires August 12, 2002                                        [Page 24]





Internet Draft             SMI Data Structures         February 12, 2002


            MAX-ACCESS  read-only
            STATUS      current
            DESCRIPTION
                "The number of packets received by the specified host
                 on the specified port."
        } ::= 2

        UNION uOutPkts {
            SYNTAX GenericCounter
            MAX-ACCESS  read-only
            STATUS      current
            DESCRIPTION
                "The number of packets transmitted by the specified
                 host on the specified port."
        } ::= 3

        -- Octet counters removed to make example shorter
    } ::= 4
} ::= { someBase 5 }

Note 1) The STRUCT keyword is somewhat redundant because this is the
only data structure type that may be used for augmentations, It is
present to keep the syntax consistent.

Note 2) The contents of the augmenting STRUCT are conceptually added to
the outer-most ARRAY of the augmented data object, not the STRUCT
itself.  The following example lists the potential OID values for each
of the fields in the 'ipStats' and 'ipXStats' variables in the example
above.

In this example only the instances for interface 17, InetAddressType
'ipv4(1)', InetAddress '192.168.0.1', and InetPortNumber '80' are shown.

   ipStats                     ::=   { someBase 4 }
   ipStats[17]                 ::=   Not Available
   ipStats[17][1]              ::=   Not Available
   ipStats[17][1][192.168.0.1] ::=   Not Available

   ipStats[17][1][192.168.0.1].inPkts ::=
       { ipStats 1 3 17 1 4 192 168 0 1 }

   ipStats[17][1][192.168.0.1].outPkts ::=
       { ipStats 1 4 17 1 4 192 168 0 1 }

   ipXStats                    ::=   { someBase 5 }





Expires August 12, 2002                                        [Page 25]





Internet Draft             SMI Data Structures         February 12, 2002


   ipXStats[17][1][192.168.0.1].inHCPkts ::=
       { ipXStats 1 1 17 1 4 192 168 0 1 }

   ipXStats[17][1][192.168.0.1].outHCPkts ::=
       { ipXStats 1 2 17 1 4 192 168 0 1 }

   ipXStats[17][1][192.168.0.1].timeData ::=
       { ipXStats 1 3 17 1 4 192 168 0 1 }    (not-accessible)

   ipXStats[17][1][192.168.0.1].timeData.createTime ::=
       { ipXStats 1 3 1 17 1 4 192 168 0 1 }

   ipXStats[17][1][192.168.0.1].timeData.updateInterval ::=
       { ipXStats 1 3 2 17 1 4 192 168 0 1 }

   ipXStats[17][1][192.168.0.1].portStats ::=
       { ipXStats 1 4 17 1 4 192 168 0 1 }    (not-accessible)

   ipXStats[17][1][192.168.0.1].portStats[80] ::= Not Available

   ipXStats[17][1][192.168.0.1].portStats[80].uInPkts ::=
       { ipXStats 1 4 2 17 1 4 192 168 0 1 80 }   (not-accessible)

   ipXStats[17][1][192.168.0.1].portStats[80].uInPkts.c32 ::=
       { ipXStats 1 4 2 1 17 1 4 192 168 0 1 80 }

   ipXStats[17][1][192.168.0.1].portStats[80].uInPkts.c64 ::=
       { ipXStats 1 4 2 2 17 1 4 192 168 0 1 80 }

   ipXStats[17][1][192.168.0.1].portStats[80].uInPkts.c32pair ::=
       { ipXStats 1 4 2 3 17 1 4 192 168 0 1 80 } (not-accessible)

   ipXStats[17][1][192.168.0.1].portStats[80].uInPkts.c32pair.c32low ::=
       { ipXStats 1 4 2 3 1 17 1 4 192 168 0 1 80 }

   ipXStats[17][1][192.168.0.1].portStats[80].uInPkts.c32pair.c32hi ::=
       { ipXStats 1 4 2 3 2 17 1 4 192 168 0 1 80 }

   ipXStats[17][1][192.168.0.1].portStats[80].uOutPkts ::=
       { ipXStats 1 4 3 17 1 4 192 168 0 1 80 }   (not-accessible)

   ipXStats[17][1][192.168.0.1].portStats[80].uOutPkts.c32 ::=
       { ipXStats 1 4 3 1 17 1 4 192 168 0 1 80 }

   ipXStats[17][1][192.168.0.1].portStats[80].uOutPkts.c64 ::=





Expires August 12, 2002                                        [Page 26]





Internet Draft             SMI Data Structures         February 12, 2002


       { ipXStats 1 4 3 2 17 1 4 192 168 0 1 80 }

   ipXStats[17][1][192.168.0.1].portStats[80].uOutPkts.c32pair ::=
       { ipXStats 1 4 3 3 17 1 4 192 168 0 1 80 } (not-accessible)

   ipXStats[17][1][192.168.0.1].portStats[80].uOutPkts.c32pair.c32low ::=
       { ipXStats 1 4 3 3 1 17 1 4 192 168 0 1 80 }

   ipXStats[17][1][192.168.0.1].portStats[80].uOutPkts.c32pair.c32hi ::=
       { ipXStats 1 4 3 3 2 17 1 4 192 168 0 1 80 }

Note 3) Although arbitrary levels of nested containment are
theoretically possible, SNMP varbind size limitations and common sense
design practices set practical limits on the complexity of data object
definitions.

Note 4) The SPPI provides an EXTENDS mechanism, which allows new SCALAR
objects to be defined in a table which conceptually adds INDEX
components to an existing table. This mechanism is accomplished by
defining an additional ARRAY (with the new INDEX components and objects)
in an AUGMENTS clause, like the 'portStats' example above.

SPARSE-AUGMENTS Example
-----------------------

The following example shows how a STRUCT containing information about
physical sensors may sparsely augment the entPhysicalTable [RFC2737].
The augmentation is defined as a TYPEDEF for demonstration purposes. The
augmenting variable simply references the TYPEDEF via the SYNTAX clause,
instead of defining the objects directly in the entSensorEntry variable.
This allows the augmenting data structure to be reused.

TYPEDEF STRUCT EntSensorData {

    DESCRIPTION
        "Information about a particular physical sensor.
         An entry in this table describes the
         present reading of a sensor, the measurement units
         and scale, and sensor operational status. ... "

    SCALAR entSensorType {
        SYNTAX        EntitySensorDataType
        MAX-ACCESS    read-only
        STATUS        current
        DESCRIPTION





Expires August 12, 2002                                        [Page 27]





Internet Draft             SMI Data Structures         February 12, 2002


            "The type of data returned by the associated
             entSensorValue object. ..."
    } ::= 1

    SCALAR entSensorScale {
        SYNTAX        EntitySensorDataScale
        MAX-ACCESS    read-only
        STATUS        current
        DESCRIPTION
            "The exponent to apply to values returned by the
              associated entSensorValue object. ..."
    } ::= 2

    -- rest of entSensorEntry objects would follow ...
}

VAR STRUCT entSensorData SPARSE-AUGMENTS entPhysicalEntry {

    SPARSE-CONDITION
        "An entSensorData object exists for each entPhysicalEntry
         for which the entPhysicalClass object value is 'sensor(8)'."
    SPARSE-EXPRESSION
        "entPhysicalClass.$1 == sensor(8)"

    SYNTAX EntSensorData
    STATUS current
    DESCRIPTION
        "Adds the ability to read physical sensor values
         to the Entity MIB."
    REFERENCE
        "RFC 2737, section 3."

} ::= { someBase 6 }

Note 1) The AUGMENTS and SPARSE-AUGMENTS constructs are very similar to
the STRUCT variable declaration construct, since they are treated
(conceptually) as a special kind of STRUCT variable.

Note 2) SMI-DS objects can augment SMIv2 tables, since the SMIv2 <-->
SMI-DS conversion algorithms are transparent.  Should there be a mode
that allows the augmented variable object descriptor to be a value that
would be accepted in an SMIv2 AUGMENTS clause (e.g. 'entPhysicalEntry'
in the example above)?

Note 3) The following OIDs would be possible for the 'entSensorEntry'





Expires August 12, 2002                                        [Page 28]





Internet Draft             SMI Data Structures         February 12, 2002


augmentation. The instances for entPhysicalIndex == 17 are shown in this
example:

   entSensorData                    ::= { someBase 6 }
   entSensorData[17]                ::= Not Available
   entSensorData[17].entSensorType  ::= { entSensorData 1 1 17 }
   entSensorData[17].entSensorScale ::= { entSensorData 1 2 17 }


5.9.  SYNTAX POINTER Clause

The 'VariablePointer' and 'RowPointer' TEXTUAL-CONVENTIONs [RFC2579]
provide semantic constraints on the generic OBJECT IDENTIFIER, but they
can only be used to point to a variable or row of any type, not a
specific type.

SMI-DS provides a modified SYNTAX clause for object declarations, in
order to specify an OID that must reference a MIB object (SCALAR or
complex data object) of a particular type.

The form "SYNTAX POINTER <type-name>" specifies an OID which should
contain only those values that de-reference to the same type as defined
by <type-name>.

For example, if the RMON DataSource TC [RFC2021] was written in SMI-DS,
the POINTER construct might be used as follows:

TYPEDEF SCALAR DataSource {
    SYNTAX POINTER InterfaceIndex
    STATUS current
    DESCRIPTION
        "Identifies the source of the data that the associated
         function is configured to analyze. This source can be any
         interface on this device. ...
         For example, if an entry were to receive data from
         interface #1, this object would be set to ifIndex.1."
}

Refer to section 6.3 for details on the 'SYNTAX POINTER' clause.

5.10.  UNIQUE-SCOPE Clause

An optional clause called 'UNIQUE-SCOPE' is available to declare the
appropriate value scope for the indicated SCALAR object or INDEX clause.
The choices are:





Expires August 12, 2002                                        [Page 29]





Internet Draft             SMI Data Structures         February 12, 2002


Internet
     The values for this object SHOULD have the same semantics across
     any two devices (e.g. anywhere in the Internet).

Domain
     The values for this object SHOULD have the same semantics across
     any two devices in the same administrative domain.

Device
     The values for this object SHOULD have the same semantics within
     the same managed device.

There is no default value, so if the UNIQUE-SCOPE clause is missing,
then no value scope information is provided.

The RMON-2 protocolDirTable [RFC2021] is used to provide an example of
the UNIQUE-SCOPE clause:

VAR ARRAY protocolDirEntry {

    DESCRIPTION
        "RMON-2 protocol directory example."

    INDEX protocolDirID {
        SYNTAX      OCTET STRING
        SIZE (0..2147483647)
        DESCRIPTION
            "A unique identifier for a particular protocol.  Standard
             identifiers will be defined in a manner such that they
             can often be used as specifications for new protocols - i.e.
             a tree-structured assignment mechanism that matches the ..."
        UNIQUE-SCOPE "Internet"
    } ::= 1

    INDEX protocolDirParameters {
        SYNTAX      OCTET STRING
        SIZE (0..2147483647)
        DESCRIPTION
            "A set of parameters for the associated protocolDirID.
             See the associated RMON2 Protocol Identifiers document
             for a description of the possible parameters. ..."
        UNIQUE-SCOPE "Internet"
    ::= 2

    SCALAR protocolDirLocalIndex {





Expires August 12, 2002                                        [Page 30]





Internet Draft             SMI Data Structures         February 12, 2002


        SYNTAX      Integer32 (1..2147483647)
        MAX-ACCESS  read-only
    STATUS      current
    DESCRIPTION
        "The locally arbitrary, but unique identifier associated
        with this protocolDir entry. ...

        The specific value is meaningful only within a given SNMP
        entity. A protocolDirLocalIndex must not be re-used until the
        next agent-restart in the event the protocol directory entry
        is deleted."
        UNIQUE-SCOPE "Device"
    ::= 3

    -- other INDEX clause and MIB objects would follow ...
} ::= { protocolDir 2 }

It may not always be possible to determine the correct value for all
potential applications of a given SCALAR or INDEX object. It such cases,
this clause should be omitted.

Refer to section 6.3 for details on the 'UNIQUE-SCOPE' clause.




























Expires August 12, 2002                                        [Page 31]





Internet Draft             SMI Data Structures         February 12, 2002


6.  Definitions

The follow sections specify the SMI Data Structures syntax and
semantics.

[ed. -- this section is intentionally incomplete, because this revision
is meant to introduce the SMI Data Structures concepts, syntax, and
examples.  Complete specification to the level of SMIv2 is TBD.]

6.1.  Conformance Information Module

The 'ConformanceLevel' TYPEDEF describes the basic level of conformance
for a specific MIB object, as implemented by the agent.

The 'ConformanceInfo' structure contains the runtime-retrievable
conformance information for a specific MIB object.

Refer to Appendix C for ConformanceInfo STRUCT examples.

MODULE CONF-TYPES-MIB {

IMPORTS
        MODULE-IDENTITY, mib-2
                FROM SNMPv2-SMI;

-- the MODULE-IDENTITY macro is not changed at all

confTypesMIB MODULE-IDENTITY
    LAST-UPDATED    "200202110000Z"
    ORGANIZATION    "TBD"
    CONTACT-INFO
            "TBD"
    DESCRIPTION
            "Contains data types which describe the conformance
             level for a specific data object."
    REVISION  "200111150000Z"
       DESCRIPTION
            "Initial version."
  ::= { mib-2 xxx }   -- unassigned


-- the following enumeration describes the basic conformance
-- and affects the interpretation of conformance variance data.

TYPEDEF SCALAR ConformanceLevel {





Expires August 12, 2002                                        [Page 32]





Internet Draft             SMI Data Structures         February 12, 2002


    SYNTAX INTEGER {
                    none(1)
                    other(2),
                    minConformance(3),
                    fullConformance(4)
                   }
    STATUS current
    DESCRIPTION
       "An indication of the conformance level for a particular MIB
        object.

        The value 'none' indicated that the agent does not implement
        any of the required semantics for the associated object.
        E.g., counter objects that always return zero, string
        objects that always return a zero-length string (but should
        not), hard-wired (potentially incorrect) enumerations or
        gauges.

        The value 'other' indicates that the implementation complies
        with the semantics of the associated object in a manner that
        varies from the specification in some way.

        The value 'minConformance' indicates that the implementation
        complies with the semantics of the associated object as
        refined by an OBJECT clause within a MODULE-COMPLIANCE macro.

        The value 'fullConformance' indicates that the implementation
        complies with the semantics of the associated object as
        defined by the data definition for the object."
   REFERENCE
       "RFC 2580, section 5."
}

TYPEDEF STRUCT ConformanceInfo {
    DESCRIPTION
        "Describes the specific conformance level for an
         associated MIB object."

    SCALAR confModuleCompliance {
       SYNTAX      OBJECT IDENTIFIER
       MAX-ACCESS  read-only
       STATUS      current
       DESCRIPTION
          "Identifies the MODULE-COMPLIANCE macro name for the
           associated data object. If no appropriate value can





Expires August 12, 2002                                        [Page 33]





Internet Draft             SMI Data Structures         February 12, 2002


           be determined, then the agent will return '0.0'"
       REFERENCE
          "RFC 2580, section 5.5."
    } ::= 1

    SCALAR confLevel {
       SYNTAX      ConformanceLevel
       MAX-ACCESS  read-only
       STATUS      current
       DESCRIPTION
          "Indicates the basic level of conformance for the
           associated data object."

           If this object contains the value 'other', then
           the confVariation structure SHOULD be present for
           the associated data object.

           If this object contains the value 'minConformance'
           or 'none' then the confVariation structure MAY be
           present for the associated data object.

           If this object contains the value 'fullConformance'
           then the confVariation structure SHOULD NOT be
           present for the associated data object."
       REFERENCE
          "RFC 2580, section 5."
    } ::= 2

    STRUCT confVariation {
        DESCRIPTION
            "Specifies any variation in conformance for the
             associated data object. This structure SHOULD
             only be present if the implementation actually
             varies from the specification for the associated
             MIB object."

        SCALAR confVarSyntax {
            SYNTAX      OCTET STRING (SIZE (0..65535))
            MAX-ACCESS  read-only
            STATUS      current
            DESCRIPTION
                "A textual representation of the syntactical
                 variation described by this variation structure.

                 If the associated confLevel object is equal to





Expires August 12, 2002                                        [Page 34]





Internet Draft             SMI Data Structures         February 12, 2002


                 'other', then this string SHOULD contain the
                 the same value as the SYNTAX clause within a
                 VARIATION clause of an AGENT-CAPABILITIES macro.

                 If the associated confLevel object is equal to
                 'minConformance', then this string SHOULD contain
                 the same value as the SYNTAX, WRITE-SYNTAX, and/or
                 MIN-ACCESS clauses present within the OBJECT clause
                 of a MODULE-COMPLIANCE macro. The actual keyword (e.g.
                 'SYNTAX') SHOULD precede the quoted string value.
                 Multiple clauses MAY be concatenated within a
                 single string. [TBD - separation char sequence]."
            REFERENCE
                 "RFC 2580, sections 5.4.3 and 6.5.2."
        } ::= 1

        SCALAR confVarDescr {
            SYNTAX      OCTET STRING (SIZE (0..65535))
            MAX-ACCESS  read-only
            STATUS      current
            DESCRIPTION
                "An optional description of the object variance.

                 If the associated confLevel object is equal to
                 'other', then this string SHOULD contain the
                 same value as the DESCRIPTION clause within a
                 VARIATION clause of an AGENT-CAPABILITIES macro.

                 If the associated confLevel object is equal to
                 'minConformance', then this string SHOULD contain
                 the same value as the DESCRIPTION clause within the
                 OBJECT clause of a MODULE-COMPLIANCE macro.

                 The agent MAY choose to return a truncated version
                 of this string, including a zero-length string."
            REFERENCE
                 "RFC 2580, sections 5.4.3 and 6.5.2."
        } ::= 2
    } ::= 3
}

   -- No MODULE-COMPLIANCE macro because only TYPEDEFs specified

}  -- END CONF-TYPES-MIB






Expires August 12, 2002                                        [Page 35]





Internet Draft             SMI Data Structures         February 12, 2002


6.2.  Namespaces

The type names and variable names used in SMI Data Structures are
contained is the same namespace, identical to the SMIv2 namespace for
OBJECT-TYPE descriptors, and shared with SMIv2. Reserved keywords in
SMI-DS or SMIv2 MUST NOT be used as type names or object descriptors.

Ideally, every data object containment level would define its own
namespace, in a truly hierarchical fashion.  However, this would not be
compatible with existing SMIv2 practices, and would require changes to
the IMPORTS, MODULE-COMPLIANCE and OBJECT-GROUP macros to support.

[ed. - further definition of namespaces TBD]

6.3.  Syntax

[ed. - the following ad-hoc syntax definition is a first-pass attempt,
and obviously needs ABNF definition, and a detailed mappings and rules
section for each construct.  At this time, any construct which is
equivalent to the SMIv2 version is not fully specified.]

-- top level construction

<module> ::=

    "MODULE" <module-name> "{"
        <imports-decl>
        <module-identity-decl>
        [<nodes-decl>]
        [<module-decl> ...]
        [<compliance-section>]
    "}"

<imports-decl> ::=  (same as SMIv2)

<module-identity-decl> ::=  (same as SMIv2)

<nodes-decl> ::=

    "NODES" "{"
       [<node-decl> ...]
    "}"

<node-decl> ::=






Expires August 12, 2002                                        [Page 36]





Internet Draft             SMI Data Structures         February 12, 2002


    ( <object-identifier> | <object-identity> )

<object-identifier> ::= (SMIv2 OBJECT IDENTIFIER clause)

<object-identity> ::= (SMIv2 OBJECT-IDENTITY clause)


<module-decl> ::=

    (<typedef-decl> | <var-decl> | <notification-decl> )

<typedef-decl> ::=

    "TYPEDEF" ( <scalar-typedef> | <array-typedef> |
                <union-typedef> | <struct-typedef> )

<var-decl> ::=

    "VAR" ( <scalar-var-decl> | <array-var-decl> |
            <union-var-decl>  | <struct-var-decl> |
            <augments-decl> )

<scalar-typedef> ::=

    "SCALAR" <type-name> <scalar-type-core-decl>

<type-name> ::=

    (same rules as for SMIv2 TEXTUAL-CONVENTION descriptors)

<scalar-type-core-decl> ::=

    "{"
        [<display-part>]
        <syntax-clause>
        [<units-clause>]
        <status-clause>
        <description-clause>
        [<reference-clause>]
        [<defval-clause>]
     "}"

-- same as <scalar-type-core-decl> but with <max-access-clause>
-- and <unique-clause> added






Expires August 12, 2002                                        [Page 37]





Internet Draft             SMI Data Structures         February 12, 2002


<scalar-var-core-decl> ::=

    "{"
        [<display-part>]
        <syntax-clause>
        [<units-clause>]
        <max-access-clause>
        <status-clause>
        <description-clause>
        [<reference-clause>]
        [<defval-clause>]
        [<unique-clause>]
     "}"

<display-part> ::=   (same as SMIv2 DIPLAY-HINT)

<syntax-clause> ::=

   ( <plain-syntax-clause> | <pointer-syntax-clause> )

<plain-syntax-clause> ::=

   (same as SMIv2, plus 64-bit numbers and float data types)

<pointer-syntax-clause> ::=

   "SYNTAX" "POINTER" <type-name>

<units-clause> ::= (same as SMIv2)

<max-access-clause> ::= (same as SMIv2)

<status-clause> ::= (same as SMIv2)

<unique-clause> ::=

    "UNIQUE-SCOPE"  """ <unique-type> """

<unique-type> ::=
    ( "Internet" | "Domain" | "Device" )

<description-clause> ::= (same as SMIv2)

<reference-clause> ::= (same as SMIv2)






Expires August 12, 2002                                        [Page 38]





Internet Draft             SMI Data Structures         February 12, 2002


<defval-clause> ::= (same as SMIv2)

<scalar-type-decl> ::=

    "SCALAR" <object-descriptor> <scalar-core-decl>
        "::=" <N>

<object-descriptor> ::=

    (same rules as for SMIv2 OBJECT-TYPE descriptors)

<N> ::= an INTEGER in the range (1..4294967295)

<scalar-var-decl> ::=

    "SCALAR" <object-descriptor> <scalar-var-core-decl>
        "::=" <oid-assignment>

<oid-assignment> ::=  (same as SMIv2)

<array-typedef> ::=

    "ARRAY" <type-name> <array-inline-core-decl>

<array-inline-core-decl> ::=
    "{"
       <description-clause>
       [<reference-clause>]
       <index-decl> [<index-decl> ...]
       <object-decl> [<object-decl> ...]
    "}"

<index-decl> ::=

    ["IMPLIED"] ["EXTERN"] "INDEX" <object-descriptor> "{"
        <syntax-clause>
        [<max-access-clause>]
        <size-clause>
        <description-clause>
        [<reference-clause>]
        [<unique-clause>]
    "}" [ "::=" <N> ]

<size-clause> ::=  "(" ( <fixed-size> | <variable-size> ) ")"






Expires August 12, 2002                                        [Page 39]





Internet Draft             SMI Data Structures         February 12, 2002


<fixed-size> ::= INTEGER between (1 .. 2147483647)

<variable-size> ::= <size-number> ".." <size-number>

    (where the second <size-number> must be larger than
     the first <size-number>)

<size-number> ::= INTEGER between (0 .. 2147483647)

<object-decl> ::=

    ( <scalar-type-decl> | <array-type-decl> |
      <union-type-decl>  | <struct-type-decl> )

<array-type-decl> ::=

    ( <array-inline-type-decl> | <array-ref-type-decl> )

<array-inline-type-decl> ::=

    "ARRAY" <object-descriptor> <array-inline-core-decl>
         "::=" <N>

<array-ref-type-decl> ::=

    "ARRAY" <object-descriptor> <array-ref-core-decl>
        "::=" <N>

<array-ref-core-decl> ::=

    "{"
       <syntax-clause>
       <status-clause>
       <description-clause>
       [<reference-clause>]
    "}"

<array-var-decl> ::=

   ( <array-inline-var-decl> | <array-ref-var-decl> )

<array-inline-var-decl> ::=

    "ARRAY" <object-descriptor> <array-inline-core-decl>
        "::=" <oid-assignment>





Expires August 12, 2002                                        [Page 40]





Internet Draft             SMI Data Structures         February 12, 2002


<array-ref-var-decl> ::=

    "ARRAY" <object-descriptor> <array-ref-core-decl>
        "::=" <oid-assignment>

<union-typedef> ::=

    "UNION" <type-name> <union-inline-core-decl>

<union-inline-core-decl> ::=

    "{"
        <description-clause>
        [<reference-clause>]
        <object-decl> [<object-decl> ...]
    "}"

<union-type-decl> ::=

    ( <union-inline-type-decl> | <union-ref-type-decl> )

<union-inline-type-decl> ::=

    "UNION" <object-descriptor> <union-inline-core-decl>
        "::=" <N>

<union-ref-type-decl> ::=

    "UNION" <object-descriptor> <union-ref-core-decl>
        "::=" <N>

<union-ref-core-decl> ::=

    "{"
        <syntax-clause>
        <status-clause>
        <description-clause>
        [<reference-clause>]
    "}"

<union-var-decl> ::=

    ( <union-inline-var-decl> | <union-ref-var-decl> )

<union-inline-var-decl> ::=





Expires August 12, 2002                                        [Page 41]





Internet Draft             SMI Data Structures         February 12, 2002


    "UNION" <object-descriptor> <union-inline-core-decl>
        "::=" <oid-assignment>

<union-ref-var-decl> ::=

    "UNION" <object-descriptor> <union-ref-core-decl>
        "::=" <oid-assignment>

<struct-typedef> ::=

    "STRUCT" <type-name> <struct-inline-core-decl>

<struct-inline-core-decl> ::=

    "{"
        <description-clause>
        [<reference-clause>]
        <object-decl>  [<object-decl> ...]
    "}"

<struct-type-decl> ::=

    ( <struct-inline-type-decl> | <struct-ref-type-decl> )

<struct-inline-type-decl> ::=

    "STRUCT" <object-descriptor> <struct-inline-core-decl>
        "::=" <N>

<struct-ref-type-decl> ::=

    "STRUCT" <object-descriptor> <struct-ref-core-decl>
        "::=" <N>

<struct-ref-core-decl> ::=

    "{"
        <syntax-clause>
        <status-clause>
        <description-clause>
        [<reference-clause>]
    "}"

<struct-var-decl> ::=






Expires August 12, 2002                                        [Page 42]





Internet Draft             SMI Data Structures         February 12, 2002


    ( <struct-inline-var-decl> | <struct-ref-var-decl> )

<struct-inline-var-decl> ::=

    "STRUCT" <object-descriptor> <struct-inline-core-decl>
        "::=" <oid-assignment>

<struct-ref-var-decl> ::=

    "STRUCT" <object-descriptor> <struct-ref-core-decl>
        "::=" <oid-assignment>

<augments-decl> ::=

    ( <plain-augments-decl> | <sparse-augments-decl> )

<plain-augments-decl> ::=

    "STRUCT" <object-descriptor> "AUGMENTS" <object-descriptor> "{"
        <augments-core-decl>
    "}" "::=" <oid-assignment>

<augments-core-decl> ::=

    ( <augments-inline-core-decl> | <augments-ref-core-decl> )

<augments-inline-core-decl> ::=

    <description-clause>
    [<reference-clause>]
    <object-decl>  [<object-decl> ...]

<augments-ref-core-decl> ::=

    <syntax-clause>
    <status-clause>
    <description-clause>
    [<reference-clause>]

<sparse-augments-decl> ::=

    "STRUCT" <object-descriptor> "SPARSE-AUGMENTS" <object-descriptor> "{"
        <sparse-condition>
        [<sparse-expression>]
        <augments-core-decl>





Expires August 12, 2002                                        [Page 43]





Internet Draft             SMI Data Structures         February 12, 2002


    "}" "::=" <oid-assignment>

<sparse-condition> ::=

   "SPARSE-CONDITION" """ Text """

<sparse-expression> ::=

   "SPARSE-EXPRESSION" """ <boolean-expr> """

<boolean-expr> ::=

   ASCII programming expression language TBD. Should be a
   subset of SNMPCONF PolicyScript for PolicyCondition scripts.
   Need to construct static expressions with only the visible
   attributes that are not intended to change during operation.
   E.g. "(ifType.$1 != propVirtual(53))" or
   "entPhysicalClass.$1 == sensor(8)".

<notification-decl> ::=

    "NOTIFICATION" <object-descriptor> "{"
        [<objects-part>]
        <status-clause>
        <description-clause>
        [<reference-clause>]
    "}" "::=" <oid-assignment>

<objects-part> ::=

    "OBJECTS" "{" <object-descriptor>
                  [ "," <object-descriptor> ...] "}"

<compliance-section> ::= (same as SMIv2)

-- END


7.  Information Modules

TBD - This section (and 7 more) need to be completed by adapting
sections 3 - 10 of SMIv2 [RFC2578].








Expires August 12, 2002                                        [Page 44]





Internet Draft             SMI Data Structures         February 12, 2002


8.  Appendix A: SMIv2 Compatibility

It is important to advance SMI features in a way that maximizes the
reusability of existing SMIv2-based development work and training.
Several SMI-DS features are intended to provide mechanisms for automatic
(or semi-automatic) translations between SMIv2 and SMI-DS definitions.

8.1.  Common Constructs

The following macros and clauses are identical in SMIv2 and SMI-DS, and
therefore no translation is required. Clauses listed here are not
mentioned in the sections describing macro conversions that utilize
these clauses.

  - DEFVAL
  - DESCRIPTION
  - DISPLAY-HINT
  - IMPORTS
  - MAX-ACCESS
  - MODULE-COMPLIANCE  (all clauses)
  - MODULE-IDENTITY    (all clauses)
  - OBJECT-IDENTITY
  - OBJECT-IDENTIFIER
  - OBJECTS
  - REFERENCE
  - STATUS
  - UNITS


8.2.  SMIv2 to SMI-DS Module Conversion

The following SMIv2 macros, clauses and keywords require some
conversion:

  - BEGIN
  - DEFINITIONS
  - END
  - INDEX
  - NOTIFICATION-TYPE
  - OBJECT-TYPE
  - SEQUENCE
  - TEXTUAL-CONVENTION

Module Container
----------------





Expires August 12, 2002                                        [Page 45]





Internet Draft             SMI Data Structures         February 12, 2002


The information module BEGIN and END constructs are translated as
follows:

 a) change 'BEGIN' and 'END' to '{' and '}'
 b) remove 'DEFINITIONS ::='

 e.g.

    FOO-MIB DEFINITIONS ::= BEGIN
        ...
    END

 is changed to:

    MODULE FOO-MIB {
        ...
    }


OBJECT IDENTIFIERs
------------------

The OBJECT IDENTIFIER declarations (that typically precede any OBJECT-
TYPE macros) to identify sub-tree nodes within the module are grouped
together and placed in a NODES construct as follows:

 a) add 'NODES {' before the first node <node-decl> definition
 b) add '} after the last <node-decl> definition

 e.g.

    fooMibObjects          OBJECT IDENTIFIER ::= { fooMIB 1 }
    fooMibNotifications    OBJECT IDENTIFIER ::= { fooMIB 2 }
    fooMibdsmonConformance OBJECT IDENTIFIER ::= { fooMIB 3 }

 is changed to:

    NODES {
        fooMibObjects          OBJECT IDENTIFIER ::= { fooMIB 1 }
        fooMibNotifications    OBJECT IDENTIFIER ::= { fooMIB 2 }
        fooMibdsmonConformance OBJECT IDENTIFIER ::= { fooMIB 3 }
    }


TEXTUAL-CONVENTIONs





Expires August 12, 2002                                        [Page 46]





Internet Draft             SMI Data Structures         February 12, 2002


-------------------

The TEXTUAL-CONVENTION macro is replaced by the TYPEDEF macro, which can
be used to define complex data types, in addition to the refinement of
base types.  The TEXTUAL-CONVENTION macro is replaced with the TYPEDEF
macro as follows:

 a) prefix type name with 'TYPEDEF SCALAR ' and append it with ' {'

 b) remove '::= TEXTUAL-CONVENTION'

 c) The SYNTAX clause can be modified to refine another SCALAR
    TYPEDEF, or an OBJECT IDENTIFIER type can be changed to
    a typed OID pointer (e.g. 'SYNTAX POINTER FooType')

 d) a UNITS clause may be added if appropriate

 e) a DEFVAL clause may be added if appropriate

 f) end TYPEDEF macro with a '}' token

 e.g:

    FooString ::= TEXTUAL-CONVENTION
        STATUS current
        DESCRIPTION
            "This data type is used to model an administratively
             controlled textual string."
        SYNTAX OCTET STRING (SIZE (0..127))

 is changed to:

    TYPEDEF SCALAR FooString {
        SYNTAX OCTET STRING (SIZE (0..127))
        STATUS current
        DESCRIPTION
            "This data type is used to model an administratively
             controlled textual string."
    }


OBJECT-TYPE Macro
-----------------







Expires August 12, 2002                                        [Page 47]





Internet Draft             SMI Data Structures         February 12, 2002


The generic OBJECT-TYPE macro is replaced with the VAR macro.

Scalar Objects
--------------

The scalar OBJECT-TYPE macro is replaced with the 'VAR SCALAR' macro as
follows:

 a) prefix scalar name with 'VAR SCALAR ' and append it with ' {'

 b) remove '::= OBJECT-TYPE'

 c) The SYNTAX clause of OBJECT IDENTIFIER can be changed to a
    typed OID pointer (e.g. 'SYNTAX POINTER FooType')

 d) a UNIQUE-SCOPE clause may be added if appropriate

 e) prefix '::= <oid-assignment>' with a '}' token

 e.g.,

    sysUpTime OBJECT-TYPE
        SYNTAX      TimeTicks
        MAX-ACCESS  read-only
        STATUS      current
        DESCRIPTION
            "The time (in hundredths of a second) since the network
            management portion of the system was last re-initialized."
        ::= { system 3 }

 is replaced with:

    VAR SCALAR sysUpTime {
        SYNTAX      TimeTicks
        MAX-ACCESS  read-only
        STATUS      current
        DESCRIPTION
            "The time (in hundredths of a second) since the network
            management portion of the system was last re-initialized."
    } ::= { system 3 }


Tabular Objects
---------------






Expires August 12, 2002                                        [Page 48]





Internet Draft             SMI Data Structures         February 12, 2002


The tabular OBJECT-TYPE macro is replaced with the 'VAR ARRAY' macro as
follows:

 a) The contents of the SEQUENCE can be converted in three ways:
    1) placed directly in a VAR ARRAY macro
    2) placed in a STRUCT TYPEDEF and a data node of that type
       declared in the VAR ARRAY macro
    3) placed an ARRAY TYPEDEF, including the INDEX, and a
       variable of this type declared with the VAR ARRAY macro.
    The direct method (1) is shown here.

 b) The OBJECT-TYPE macro for the table itself (e.g. fooTable)
    is transformed into a VAR ARRAY declaration by extracting
    the object descriptor, prefixing it with 'VAR ARRAY ' and
    appending it with ' {'. The DESCRIPTION clause should be
    transferred and modified as needed.

 c) The OBJECT-CLAUSE for the table entry (e.g. fooEntry) is
    discarded except for the INDEX clause, and any information
    from the DESCRIPTION clause is transferred and modified as
    needed.

 d) If the AUGMENTS clause appears instead of an INDEX clause,
    then the 'VAR ARRAY' OBJECT-TYPE macro is modified to
    be an AUGMENTS variable declaration, using the object
    descriptor named in the SMIv2 AUGMENTS clause. E.g.,

     'AUGMENTS { ifEntry }'

   is changed to:

     'VAR ARRAY fooTable AUGMENTS ifEntry {'

 e) For each object descriptor in the SMIv2 INDEX clause, an
    SMI-DS INDEX clause is constructed:
     - A descriptor for an object in other tables is converted to
       an 'EXTERN INDEX' clause.
     - A descriptor for an object defined in the table is
       converted to an 'INDEX' clause, and the node number
       within the ASN.1 SEQUENCE (e.g. 3 in { fooEntry 3 }'),
       is used for the value of <N> in the node assignment sub-clause.
     - If the descriptor is preceded by the 'IMPLIED' keyword,
       then the 'IMPLIED' keyword precedes the 'INDEX' keyword.
     - If the MAX-ACCESS for the index object is a value other than
       'not-accessible', then that clause must be transferred to





Expires August 12, 2002                                        [Page 49]





Internet Draft             SMI Data Structures         February 12, 2002


       the new INDEX clause.
     - Determine if the SIZE clause should indicate a fixed size
       or a variable size array.
     - For variable-sized arrays, the lower bound of the SIZE clause
       should be '0' if the ARRAY is allowed to be empty, or '1' if
       at least one entry must exist, etc. The upper bound of the SIZE
       clause should be several orders of magnitude higher than the
       number of expected instances of this array index (per parent
       instance). If no value can be selected, the value '2147483647'
       should be used.

 f) For each OBJECT-TYPE macro for a non-INDEX column, an <object-decl>
    for a 'SCALAR' is created.
     - prefix object descriptor with 'VAR SCALAR ' and append it
       with ' {'
     - remove '::= OBJECT-TYPE'
     - The SYNTAX clause of OBJECT IDENTIFIER can be changed to a
       typed OID pointer (e.g. 'SYNTAX POINTER FooType')
     - a UNIQUE-SCOPE clause may be added if appropriate
     - replace '::= { fooEntry <N> }' with  '} ::= <N>'

 g) prefix a '}' token to the node assignment for the table itself
    (e.g. 'fooTable'), which becomes the node assignment for the
    ARRAY variable declaration.

 E.g. (Note: IF-MIB [RFC2233] example DESCRIPTION clauses truncated),

    ifStackTable  OBJECT-TYPE
        SYNTAX        SEQUENCE OF IfStackEntry
        MAX-ACCESS    not-accessible
        STATUS        current
        DESCRIPTION
            "The table containing information on the relationships
             between the multiple sub-layers of network interfaces..."
        ::= { ifMIBObjects 2 }

    ifStackEntry  OBJECT-TYPE
        SYNTAX        IfStackEntry
        MAX-ACCESS    not-accessible
        STATUS        current
        DESCRIPTION
            "Information on a particular relationship between two
             sub-layers, specifying that one sub-layer runs on
             'top' of the other sub-layer.  Each sub-layer
             corresponds to a conceptual row in the ifTable."





Expires August 12, 2002                                        [Page 50]





Internet Draft             SMI Data Structures         February 12, 2002


        INDEX { ifStackHigherLayer, ifStackLowerLayer }
        ::= { ifStackTable 1 }

    IfStackEntry ::=
       SEQUENCE {
           ifStackHigherLayer  Integer32,
           ifStackLowerLayer   Integer32,
           ifStackStatus       RowStatus
        }

   ifStackHigherLayer  OBJECT-TYPE
        SYNTAX        Integer32
        MAX-ACCESS    not-accessible
        STATUS        current
        DESCRIPTION
            "The value of ifIndex corresponding to the higher
            sub-layer of the relationship, i.e., the sub-layer..."
        ::= { ifStackEntry 1 }

   ifStackLowerLayer  OBJECT-TYPE
        SYNTAX        Integer32
        MAX-ACCESS    not-accessible
        STATUS        current
        DESCRIPTION
               "The value of ifIndex corresponding to the lower sub-
               layer of the relationship, i.e., the sub-layer which ..."
        ::= { ifStackEntry 2 }

   ifStackStatus  OBJECT-TYPE
       SYNTAX         RowStatus
       MAX-ACCESS     read-create
       STATUS         current
       DESCRIPTION
               "The status of the relationship between two sub-
               layers. ..."
       ::= { ifStackEntry 3 }

 is replaced with:

    VAR ARRAY ifStackTable {
        DESCRIPTION
            "The table containing information on the relationships
             between the multiple sub-layers of network interfaces...

             Information on a particular relationship between two





Expires August 12, 2002                                        [Page 51]





Internet Draft             SMI Data Structures         February 12, 2002


             sub-layers, specifying that one sub-layer runs on
             'top' of the other sub-layer.  Each sub-layer
             corresponds to a conceptual row in the ifTable."

        INDEX ifStackHigherLayer {
            SYNTAX        Integer32
            STATUS        current
            DESCRIPTION
                "The value of ifIndex corresponding to the higher
                 sub-layer of the relationship, i.e., the sub-layer..."
        } ::= 1

        INDEX ifStackLowerLayer {
            SYNTAX        Integer32
            STATUS        current
            DESCRIPTION
                "The value of ifIndex corresponding to the lower sub-
                layer of the relationship, i.e., the sub-layer which ..."
        }  ::= 2

        SCALAR ifStackStatus {
            SYNTAX         RowStatus
            MAX-ACCESS     read-create
            STATUS         current
            DESCRIPTION
                "The status of the relationship between two sub-
                 layers. ..."
        } ::= 3
   ::= { ifMIBObjects 2 }

Notifications
-------------

The SMIv2 NOTIFICATION-TYPE macro is replaced with the NOTIFICATION
macro as follows:

 a) prefix notification name with 'NOTIFICATION ' and append it with ' {'

 b) remove '::= NOTIFICATION-TYPE'

 c) prefix '::= <oid-assignment>' with a '}' token

 e.g.

    linkUp NOTIFICATION-TYPE





Expires August 12, 2002                                        [Page 52]





Internet Draft             SMI Data Structures         February 12, 2002


        OBJECTS { ifIndex, ifAdminStatus, ifOperStatus }
        STATUS  current
        DESCRIPTION
            "A linkDown trap signifies that the SNMPv2 entity,
             acting in an agent role, has detected that the
             ifOperStatus object for one of its communication links
             left the down state and transitioned into some other
             state (but not into the notPresent state).  This other
             state is indicated by the included value of
             ifOperStatus."
       ::= { snmpTraps 4 }

 is replaced with:

    NOTIFICATION linkUp {
        OBJECTS { ifIndex, ifAdminStatus, ifOperStatus }
        STATUS  current
        DESCRIPTION
            "A linkDown trap signifies that the SNMPv2 entity,
             acting in an agent role, has detected that the
             ifOperStatus object for one of its communication links
             left the down state and transitioned into some other
             state (but not into the notPresent state).  This other
             state is indicated by the included value of
             ifOperStatus."
    } ::= { snmpTraps 4 }


8.3.  SMI-DS to SMIv2 Module Conversion

Just as with the transition from SMIv1 to SMIv2, not all new constructs
can be efficiently mapped backward (from SMI-DS to SMIv2). Since some
new clauses are designed to extract information buried in DESCRIPTION
clauses or comments, it is to be expected that backward conversion
consists of putting this information back where it came from.

[Guidelines for unfolding tables TBD]

8.4.  Compatibility Guidelines

The following guidelines are provided to assist MIB writers create SMI-
DS modules that can be properly mapped backward into SMIv2 syntax and
semantics.







Expires August 12, 2002                                        [Page 53]





Internet Draft             SMI Data Structures         February 12, 2002


ARRAYs
------

Even though it is optional, a node assignment SHOULD be made for an
INDEX clause. Just as with SMIv2, the node assignment for an INDEX can
only occur in one place. All other uses of the INDEX object MUST be made
by reference (e.g. 'EXTERN INDEX' in SMI-DS).

The IMPLIED keyword SHOULD NOT be used, except to convert an SMIv2 table
which has an IMPLIED INDEX component to SMI-DS.  Only one IMPLIED
keyword can be used, and it MUST be in the innermost ARRAY construct, if
nested ARRAYs are defined.  The IMPLIED keyword severely limits the
ability to reuse a TYPEDEF containing it, and SHOULD NOT be used in type
definitions.




































Expires August 12, 2002                                        [Page 54]





Internet Draft             SMI Data Structures         February 12, 2002


9.  Appendix B: Complete MODULE Example

The following example shows a somewhat complete MIB module, adapted from
the Remote Monitoring Extensions for Differentiated Services document
[DSMON-MIB].  Refer to that document to compare the SMIv2 and SMI-DS
definitions.

This is not a transparent conversion of the SMIv2 version, but rather an
'upgraded' version, in which the containment features (such as STRUCTs
and nested ARRAYs) are utilized. The intent is to demonstrate how a
read-create data structure spread over three tables with SMIv2 can be
defined as a single structure with SMI-DS.

-- the MODULE starts out differently than SMIv2 so MIB
-- compilers can tell immediately the type of module

MODULE DSMON-MIB {

-- partial IMPORTS, only for the aggregation control objects

IMPORTS
        MODULE-IDENTITY, Integer32, Counter32
                FROM SNMPv2-SMI
        MODULE-COMPLIANCE, OBJECT-GROUP
                FROM SNMPv2-CONF
        RowStatus, TimeStamp, TruthValue
                FROM SNMPv2-TC
        OwnerString, rmon
                FROM RMON-MIB
        SnmpAdminString
                FROM SNMP-FRAMEWORK-MIB
        Dscp
                FROM DIFFSERV-DSCP-TC;

-- the MODULE-IDENTITY macro is not changed at all

dsmonMIB MODULE-IDENTITY
    LAST-UPDATED    "200111050000Z"
    ORGANIZATION    "IETF RMONMIB Working Group"
    CONTACT-INFO
            "Same as SMIv2"
    DESCRIPTION
            "Same as SMIv2"
    REVISION  "200111050000Z"
       DESCRIPTION





Expires August 12, 2002                                        [Page 55]





Internet Draft             SMI Data Structures         February 12, 2002


            "Same as SMIv2"
  ::= { rmon 26 }


-- a NODES clause is added to formalize and more easily find
-- the OBJECT IDENTIFIER MIB root nodes defined in a MIB MODULE
-- this list is allowed to be empty

NODES {
    dsmonObjects       OBJECT IDENTIFIER ::= { dsmonMIB 1 }
    dsmonNotifications OBJECT IDENTIFIER ::= { dsmonMIB 2 }
    dsmonConformance   OBJECT IDENTIFIER ::= { dsmonMIB 3 }

    dsmonAggObjects    OBJECT IDENTIFIER ::= { dsmonObjects 1 }

    -- the following objects removed from the example
    dsmonStatsObjects  OBJECT IDENTIFIER ::= { dsmonObjects 2 }
    dsmonPdistObjects  OBJECT IDENTIFIER ::= { dsmonObjects 3 }
    dsmonHostObjects   OBJECT IDENTIFIER ::= { dsmonObjects 4 }
    dsmonCapsObjects   OBJECT IDENTIFIER ::= { dsmonObjects 5 }
    dsmonMatrixObjects OBJECT IDENTIFIER ::= { dsmonObjects 6 }
}

-- converted DsmonCounterAggGroupIndex TC to a TYPEDEF

TYPEDEF SCALAR DsmonCounterAggGroupIndex {
    SYNTAX Integer32 (0..2147483647)
    STATUS current
    DESCRIPTION
       "This TC describes a data type which identifies a DSMON
        counter aggregation group, ..."
}

-- converted DsmonCounterAggProfileIndex TC to a TYPEDEF

TYPEDEF SCALAR DsmonCounterAggProfileIndex {
    SYNTAX Integer32 (1..2147483647)
    STATUS current
    DESCRIPTION
        "This TC describes a data type which identifies a DSMON
         counter aggregation profile, ..."
}

-- converted dsmonAggProfileTable






Expires August 12, 2002                                        [Page 56]





Internet Draft             SMI Data Structures         February 12, 2002


TYPEDEF ARRAY DsmonCounterAggProfile {
    DESCRIPTION
        "Controls the setup of a single aggregation profile,
         for which every DSCP value MUST be configured
         into exactly one aggregation group. ..."

    INDEX dsmonAggProfileDSCP {
        SYNTAX  Dscp
        SIZE    (64)     -- fixed array of 64 entries
        DESCRIPTION
            "The specific DSCP value which is configured in an
             aggregation group by this entry."
    } ::= 1

    SCALAR dsmonAggGroupIndex {
        SYNTAX      DsmonCounterAggGroupIndex
        MAX-ACCESS  read-write
        STATUS      current
        DESCRIPTION
            "The aggregation group which contains this DSCP value. ..."
        DEFVAL { 0 }
    } ::= 2
}

-- converted dsmonAggGroupTable

TYPEDEF ARRAY DsmonCounterAggGroup {
    DESCRIPTION
        "Controls the setup of a single aggregation profile,
         for which every DSCP value MUST be configured
         into exactly one aggregation group. ..."

    INDEX dsmonAggGroupIndex {
        SYNTAX  DsmonCounterAggGroupIndex   -- range of the INDEX
        SIZE    (0..2147483647)         -- range of the instances
        DESCRIPTION
            "The specific Aggregation Group which is represented
             group by each entry."
    } ::= 1

    SCALAR dsmonAggGroupDescr {
        SYNTAX      SnmpAdminString (SIZE(0..64))
        MAX-ACCESS  read-create
        STATUS      current
        DESCRIPTION





Expires August 12, 2002                                        [Page 57]





Internet Draft             SMI Data Structures         February 12, 2002


            "An administratively assigned description of the
             aggregation group identified by this entry. ..."
    } ::= 2
}

-- converted dsmonAggControlTable

TYPEDEF STRUCT DsmonCounterAggControl {
    DESCRIPTION
        "Provides an overall description and control
      point for a single aggregation control configuration. ..."

    SCALAR dsmonAggControlDescr {
        SYNTAX      SnmpAdminString (SIZE(0..64))
        MAX-ACCESS  read-create
        STATUS      current
        DESCRIPTION
            "An administratively assigned description of the aggregation
            profile identified by this entry. ..."
    } ::= 1

    ARRAY aggProfile {
        SYNTAX      DsmonCounterAggProfile
        STATUS      current
        DESCRIPTION
           "A set of DSCP to Aggregation Group mappings."
    } ::= 2

    ARRAY aggGroup {
        SYNTAX      DsmonCounterAggGroup
        STATUS      current
        DESCRIPTION
            "A set of Aggregation Group descriptions."
    } ::= 3

    SCALAR dsmonAggControlOwner {
        SYNTAX     OwnerString
        MAX-ACCESS read-create
        STATUS     current
        DESCRIPTION
            "The entity that configured this object and is therefore
            using the resources assigned to it."
    } ::= 4

    SCALAR dsmonAggControlStatus {





Expires August 12, 2002                                        [Page 58]





Internet Draft             SMI Data Structures         February 12, 2002


        SYNTAX      RowStatus
        MAX-ACCESS  read-create
        STATUS      current
        DESCRIPTION
            "The status of this entire aggregation control object. ..."
    } ::= 5
}

--
-- variable declarations for the 4 scalars in this group
--

VAR SCALAR dsmonMaxAggGroups {
    SYNTAX      Integer32 (2..64)
    MAX-ACCESS  read-only
    STATUS      current
    DESCRIPTION
        "The maximum number of aggregation groups that this agent
         can support. ..."
} ::= { dsmonAggObjects 1 }

VAR SCALAR dsmonAggControlLocked {
    SYNTAX      TruthValue
    MAX-ACCESS  read-write
    STATUS      current
    DESCRIPTION
        "Controls the setup of aggregation groups for this agent. ..."
} ::= { dsmonAggObjects 2 }

VAR SCALAR dsmonAggControlChanges {
    SYNTAX      Counter32
    MAX-ACCESS  read-only
    STATUS      current
    DESCRIPTION
        "This object counts the number of times the value of the
         dsmonAggControlLocked object has changed. ..."
} ::= { dsmonAggObjects 3 }

VAR SCALAR dsmonAggControlLastChangeTime {
    SYNTAX      TimeStamp
    MAX-ACCESS  read-only
    STATUS      current
    DESCRIPTION
        "This object identifies the value of sysUpTime at the moment
         the dsmonAggControlLocked object was last modified. ..."





Expires August 12, 2002                                        [Page 59]





Internet Draft             SMI Data Structures         February 12, 2002


} ::= { dsmonAggObjects 4 }

-- finishing the dsmonAggControlTable by allowing multiple
-- instances of an aggregation control block

VAR ARRAY dsmonAggProfiles {
    STATUS      current
    DESCRIPTION
        "A collection of DSMON aggregation control profiles. ..."
    INDEX  dsmonAggControlIndex {
        SYNTAX  DsmonCounterAggProfileIndex
        SIZE    (1..2147483647)      -- variable sized array
        DESCRIPTION
            "The specific Counter Aggregation Profile which is
             represented by each entry."
    } ::= 1

    STRUCT aggControl {
        SYNTAX DsmonCounterAggControl
        STATUS current
        DESCRIPTION
           "The DSMON Counter Aggregation Control entry for
            each profile."
    } ::= 2
} ::= { dsmonAggObjects 5 }

-- No NOTIFICATION-TYPE macros defined in this module

-- Compliance section (currently unchanged from SMIv2)

dsmonCounterAggControlCompliance MODULE-COMPLIANCE
    STATUS  current
    DESCRIPTION
            "Example compliance for the aggregation control
             portion of the DSMON-MIB module."
    MODULE  -- this module
        MANDATORY-GROUPS { dsmonCounterAggControlGroup }

    ::= { dsmonCompliances 1 }

dsmonCounterAggControlGroup OBJECT-GROUP
    OBJECTS {
             dsmonMaxAggGroups,
             dsmonAggControlLocked,
             dsmonAggControlChanges,





Expires August 12, 2002                                        [Page 60]





Internet Draft             SMI Data Structures         February 12, 2002


             dsmonAggControlLastChangeTime,
             dsmonAggControlDescr,
             dsmonAggControlOwner,
             dsmonAggControlStatus,
             dsmonAggGroupIndex,
             dsmonAggGroupDescr
    }
    STATUS  current
    DESCRIPTION
            "A collection of objects used to configure and manage
            aggregation groups for DSMON collection purposes."
    ::= { dsmonGroups 1 }

}   -- END DSMON-MIB MODULE

Note 1) The following example shows the difference between SMIv2 naming
and SMI-DS naming, for the OBJECT IDENTIFIERS in the DSMON-MIB module
example above.

 Object Instance Examples
------------------------------
 O=Old (SMIv2), N=New (SMI-DS)

dsmonAggGroup scalars:
   dsmonMaxAggGroups
     O: dsmonAggObjects.1.0
     N: dsmonAggObjects.1.0
   dsmonAggControlLocked
     O: dsmonAggObjects.2.0
     N: dsmonAggObjects.2.0
   dsmonAggControlChanges
     O: dsmonAggObjects.3.0
     N: dsmonAggObjects.3.0
   dsmonAggControlLastChangeTime
     O: dsmonAggObjects.4.0
     N: dsmonAggObjects.4.0

dsmonAggControlTable example for row 77:
   dsmonAggControlDescr
     O: dsmonAggObjects.5.1.2.77
     N: dsmonAggObjects.5.1.2.1.77
   dsmonAggControlOwner
     O: dsmonAggObjects.5.1.3.77
     N: dsmonAggObjects.5.1.2.4.77
   dsmonAggControlStatus





Expires August 12, 2002                                        [Page 61]





Internet Draft             SMI Data Structures         February 12, 2002


     O: dsmonAggObjects.5.1.3.77
     N: dsmonAggObjects.5.1.2.5.77

dsmonAggProfileTable example for row 77.22:
   dsmonAggGroupIndex
     O: dsmonAggObjects.6.1.2.77.22
     N: dsmonAggObjects.5.1.2.2.2.77.22

dsmonAggGroupTable example for row 77.44:
   dsmonAggGroupDescr
     O: dsmonAggObjects.7.1.1.77.44
     N: dsmonAggObjects.5.1.2.3.2.77.44
   dsmonAggGroupStatus
     O: dsmonAggObjects.7.1.2.77.44
     N: not needed because dsmonAggControlStatus
        controls an entire dsmonAggControl data object

Note 1) Scalar object naming does not change at all

Note 2) DSMON Counter Aggregation control requires three tables in SMIv2
(dsmonAggObjects.5 - 7) and one in SMI-DS (dsmonAggObjects.5). This
allows the subordinate RowStatus object (dsmonAggGroupStatus) to be
removed. It also allows the agent to identify the complete hierarchical
position of any object instance by inspection. These implementation
benefits (and others) can help significantly to reduce the software
development costs for complex MIBs.

10.  Appendix C: ConformanceInfo STRUCT Example

The following pseudo-MIB objects would be returned by an agent that
implemented the 'ipStats' ARRAY variable (in the example in section
5.8). For demonstration purposes, the only object fully implemented is
'inPkts', and only instances for IPv4 addresses and ifIndex values less
than 64K will be found in the table.

Example ConformanceInfo STRUCT for ipStats ARRAY
------------------------------------------------

 ifIndex INDEX partial implementation
 ------------------------------------

   confModuleCompliance(ipStats.ifIndex) ::= { ipStats 0 0 1 1 1 }
      == OID('ifCompliance2')

   confLevel(ipStats.ifIndex)            ::= { ipStats 0 0 1 1 2 }





Expires August 12, 2002                                        [Page 62]





Internet Draft             SMI Data Structures         February 12, 2002


      == INTEGER('other(2)')

   confVarSyntax(ipStats.ifIndex)        ::= { ipStats 0 0 1 1 3 1 }
      == STRING('SYNTAX "Integer32 (1..65535)"')

   confVarDescr(ipStats.ifIndex)          ::= { ipStats 0 0 1 1 3 2 }
      == STRING('Values above 65535 are not supported')

 inetAddrType INDEX partial implementation
 -----------------------------------------

   confModuleCompliance(ipStats.inetAddrType) ::= { ipStats 0 0 2 1 1 }
      == OID('ipStatsCompliances.1')

   confLevel(ipStats.inetAddrType)            ::= { ipStats 0 0 2 1 2 }
      == INTEGER('other(2)')

   confVarSyntax(ipStats.inetAddrType)        ::= { ipStats 0 0 2 1 3 1 }
      == STRING('SYNTAX "INTEGER { ipv4(1) }"')

   confVarDescr(ipStats.inetAddrType)         ::= { ipStats 0 0 2 1 3 2 }
      == STRING('Only IPv4 addresses are supported')

 inetAddr INDEX full implementation
 ----------------------------------

   confModuleCompliance(ipStats.inetAddr)     ::= { ipStats 0 0 3 1 1 }
      == OID('ipStatsCompliances.1')

   confLevel(ipStats.inetAddr)                ::= { ipStats 0 0 3 1 2 }
      == INTEGER('fullConformance(4)')

   confVarSyntax(ipStats.inetAddr)            ::= { ipStats 0 0 3 1 3 1 }
      == noSuchInstance exception

   confVarDescr(ipStats.inetAddr)             ::= { ipStats 0 0 3 1 3 2 }
      == noSuchInstance exception

 inPkts counter full implementation
 ----------------------------------

   confModuleCompliance(ipStats.inPkts)  ::= { ipStats 0 1 1 1 }
      == OID('ipStatsCompliances.1')

   confLevel(ipStats.inPkts)             ::= { ipStats 0 1 1 2 }





Expires August 12, 2002                                        [Page 63]





Internet Draft             SMI Data Structures         February 12, 2002


      == INTEGER('fullConformance(4)')

   confVarSyntax(ipStats.inPkts)         ::= { ipStats 0 1 1 3 1 }
      == noSuchInstance exception

   confVarDescr(ipStats.inPkts)          ::= { ipStats 0 1 1 3 2 }
      == noSuchInstance exception

 outPkts counter not really implemented
 --------------------------------------

   confModuleCompliance(ipStats.outPkts) ::= { ipStats 0 2 1 1 }
      == OID('ipStatsCompliances.1')

   confLevel(ipStats.outPkts)            ::= { ipStats 0 2 1 2 }
      == INTEGER('none(1)')

   confVarSyntax(ipStats.outPkts)        ::= { ipStats 0 2 1 3 1 }
      == STRING('')   -- empty string because no appropriate value

   confVarDescr(ipStats.outPkts)         ::= { ipStats 0 2 1 3 2 }
      == STRING('Always returns zero')

Note 1) MODULE-COMPLIANCE and AGENT-CAPABILITIES information is not
currently available for INDEX clauses, but they are supported here as if
RFC 2580 provided these features.

Note 2) The <compatNode> for the ConformanceInfo STRUCT is added into
the OID as it is expanded and an OID constructed for each node, which is
why an extra '1' exists in the STRUCT expansion (e.g. after the 'ipStats
0 2' in the outPkts example). It's not clear if the extra '1' is really
needed here, but it is added for consistency.

11.  Appendix D: Open Issues

The following open issues (in no particular order) need to be addressed.

1) SPPI Merge

The SPPI/SMIv2 merge that the SMIng WG is supposed to accomplish is not
widely supported. The high level issue that must be addressed is whether
the WG is solving a problem that operators and vendors care about. Given
that there are currently so few PIBs in use compared to MIBs, it seems
highly unlikely that there's any significant problem managing both types
of information modules.  Does the IESG think the number of PIBs will





Expires August 12, 2002                                        [Page 64]





Internet Draft             SMI Data Structures         February 12, 2002


dramatically increase in the near future, and is somehow trying to
prevent a problem before it starts?

The biggest issue is SPPI OID naming.  There is no market justification
whatsoever to incur any significant complexity hit to support different
data naming schemes for different protocols. The IETF already has a hard
time getting vendors to implement standard MIBs, and making them harder
to use for the sake of SPPI will make matters worse.

Experts in COPS-PR and SPPI should determine how SPPI naming, tabular
data model, and various SPPI clauses should be integrated into SMI-DS.
This should be done in a way that does not impact the overall complexity
or ease of use as an SMIv2 replacement, possibly contained in a separate
document.

2) Conformance Granularity

The concept of MIB conformance may need to change to better handle the
complexity created by the type definition and containment features of
SMI-DS. MODULE-COMPLIANCE macros for complex data objects may need to
allow for automatic conformance update mechanisms. The 'copy-by-
reference' property of nested data structures needs to somehow translate
to the conformance section. E.g. if 'fooObject1' is deprecated and
updated with 'fooObject2' in the 'FooStruct', then the update occurs
everywhere a 'FooStruct' is nested. The MODULE-COMPLIANCE needs to be
updated somehow for every VAR declaration that is, or has an embedded
'FooStruct'.

3) Conformance Instance Overlap

Since descriptors can occur in TYPEDEFs, they are not unique for
conformance purposes (as raised by Randy Presuhn in SLC).  An efficient
MODULE-COMPLIANCE mechanism is needed to provide conformance info for
each VAR and NOTIFICATION declaration, not for each accessible object
descriptor. This way, object descriptors can have different conformance
requirements at the granularity of the VAR macro.

4) Runtime ConformanceInfo

The ability to identify the 'conformance expectations' for every object
should help application developers, but it may have some impact on other
SNMP components, such as VACM. It has a non-trivial impact on agent
development tools and SNMP engines w/ command responder applications.
This concept and its issues need to be discussed further.






Expires August 12, 2002                                        [Page 65]





Internet Draft             SMI Data Structures         February 12, 2002


5) SMIv2 Merge Issues

Sections 3 - 10 of RFC 2578 need to be adapted and added into this
document. The extensive set of implementation rules and guidelines needs
to be updated and clarified.  Complete 'ASN.1 free' syntax needs to be
finished, along with the SMIv2 compatibility and transformation
guidelines.

6) Base Data Type Extensions

The data types defined in the 'SMIng Core Modules' document should be
used by this document somehow.

7) SMI Syntax

Although it is tempting to completely change the syntax for the data
definition language to benefit potential 'new users', this would
increase overall complexity for new and old users of the SMI. There are
many more MIB modules now then April 1993, when SMIv2 was first
published as RFC 1442. It took years to convert all the standards track
modules from SMIv1 to SMIv2, and it will probably take years to convert
them all from SMIv2 to SMIv3. During the transition, operators and
developers need to know both syntax variants, and it will help a great
deal if they are similar to each other.

8) SPARSE-AUGMENTS

The SPARSE-EXPRESSION clause is intended to provide an 80/20 solution
for the machine readable augments condition. The expression syntax needs
to be very simple, since most augmentation conditions are static and not
complex.  There should be no attempt made to create a comprehensive
syntax to address the 20% case that won't be simple to express.  In
these cases, the SPASE-EXPRESSION should be empty and the SPARSE-
CONDITION text used to describe the condition(s).

12.  Appendix E: Discussion of SMIng Objectives

This section lists each accepted design objective described in the SMIng
Objectives document [SMING_OBJ], and explains how SMI-DS addresses the
objective.

4.1.1 The Set of Specification Documents [Yes]

Description
     SMIv2 is defined in three documents, based on an obsolete ITU ASN.1





Expires August 12, 2002                                        [Page 66]





Internet Draft             SMI Data Structures         February 12, 2002


     specification.  SPPI is defined in one document, based on SMIv2.
     The core of SMIng must be defined in one document and must be
     independent of external specifications.

Fulfillment
     SMI-DS can meet this objective by simply placing as much text as
     desired in a single document.

4.1.2 Textual Representation [Yes]

Description
     SMIng definitions must be represented in a textual format.

Fulfillment
     SMI-DS meets this objective because it is specified using only
     textual characters.

4.1.3 Human Readability [Yes]

Description
     The syntax must make it easy for humans to directly read and write
     SMIng modules.  It must be possible for SMIng module authors to
     produce SMIng modules with text editing tools.

Fulfillment
     The SMI-DS syntax is very close (or identical) to SMIv2 in all
     respects, so it will be easy for MIB authors and readers to use.

4.1.4 Rigorously Defined Syntax [Yes - TBD]

Description
     There must be a rigorously defined syntax for the SMIng language.

Fulfillment
     Once the features (and the syntax for those features) are
     finalized, all SMI-DS constructs will be rigorously defined,
     including the constructs which do not change from SMIv2.

4.1.5 Accessibility [Yes]

Description
     Attribute definitions must indicate whether attributes can be read,
     written, created, deleted, and whether they are accessible for
     notifications, or are not accessible.  Align PIB-ACCESS and MAX-
     ACCESS, and PIB-MIN-ACCESS and MIN-ACCESS.





Expires August 12, 2002                                        [Page 67]





Internet Draft             SMI Data Structures         February 12, 2002


Fulfillment
     The MAX-ACCESS clause is retained from SMIv2. PIB versions of these
     constructs do not really differ in semantics, just in name.  PIBs
     and MIBs use the same MAX-ACCESS clause.

4.1.6 Language Extensibility [Maybe]

Description
     The language must have characteristics, so that future modules can
     contain information of future syntax without breaking original
     SMIng parsers.

Fulfillment
     Although this objective benefits very few people, it can be
     achieved by rigorously defining the SMI-DS syntax so that a parser
     can always determine where a construct begins and ends.

4.1.7 Special Characters in Text [No]

Description
     Allow an escaping mechanism to encode special characters, e.g.
     double quotes and new-line characters, in text such as DESCRIPTIONs
     or REFERENCEs.

Fulfillment
     Currently there are no mechanisms added to these SMIv2 constructs
     used without modification in SMI-DS. It is not clear why forcing
     the author to use single quotes is unreasonable. Not sure why this
     is a problem.  Adding cryptic character sequences conflicts with
     objective 4.1.3.

4.1.8 Naming [Yes]

Description
     SMIng must provide mechanisms to uniquely identify attributes,
     groups of attributes, and events.  It is necessary to specify how
     name collisions are handled.

Fulfillment
     SMI-DS meets all these requirements. Namespaces are handled the
     same as in SMIv2.

4.1.9 Namespace Control [Yes]







Expires August 12, 2002                                        [Page 68]





Internet Draft             SMI Data Structures         February 12, 2002


Description
     There must be a hierarchical, centrally-controlled namespace for
     standard named items, and a distributed namespace must be supported
     to allow vendor-specific naming and to assure unique module names
     across vendors and organizations.

Fulfillment
     SMI-DS meets this requirement by providing true hierarchical
     naming, which is compatible with SMIv2 objects. Enterprise-specific
     definitions and augmentations are supported.

4.1.10 Modules [Yes]

Description
     SMIng must provide a mechanism for uniquely identifying a module,
     and specifying the status, contact person, revision information,
     and the purpose of a module.  SMIng must provide mechanisms to
     group definitions into modules and it must provide rules for
     referencing definitions from other modules.

Fulfillment
     SMI-DS information modules are conceptually identical to SMIv2
     information modules, including the IMPORTS clause.

4.1.11 Module Conformance [Yes]

Description
     SMIng must provide mechanisms to detail the minimum requirements
     implementers must meet to claim conformance to a standard based on
     the module.

Fulfillment
     SMI-DS conformance constructs (such as MAX-ACCESS, MODULE-
     COMPLIANCE, OBJECT-GROUP, NOTIFICATION-GROUP) are unchanged from
     SMIv2.

4.1.12 Arbitrary Unambiguous Identities [Yes]

Description
     SMI allows the use of OBJECT-IDENTITIES to define unambiguous
     identities without the need of a central registry.  SMI uses OIDs
     to represent values that represent references to such identities.
     SMIng needs a similar mechanism (a statement to register
     identities, and a base type to represent values).






Expires August 12, 2002                                        [Page 69]





Internet Draft             SMI Data Structures         February 12, 2002


Fulfillment
     Base type semantics (including OBJECT IDENTIFIER) are unchanged
     from SMIv2.

4.1.13 Protocol Independence [Yes - TBD]

Description
     SMIng must define data definitions in support of the SNMP and COPS-
     PR protocols.  SMIng may define data definitions in support of
     other protocols.

Fulfillment
     SMI-DS is fully compatible with SMIv2 and the SNMP protocol.
     Specific mapping algorithms for COPS-PR object naming are TBD.

4.1.14 Protocol Mapping [Yes]

Description
     The SMIng working group, in accordance with the working group
     charter, will define mappings of protocol independent data
     definitions to protocols based upon installed implementations.  The
     SMIng working group can define mappings to other protocols as long
     as this does not impede the progress on other objectives.

Fulfillment
     As long as the protocol is actually independent of the data
     definition language and its naming scheme (as advertised with
     SNMP), accessible data objects (i.e. SCALARs) can be manipulated in
     the same manner as accessible SMIv2 objects.

4.1.15 Translation to Other Data Definition Languages [Yes - TBD]

Description
     SMIng language constructs must, wherever possible, be translatable
     to SMIv2 and SPPI.  At the time of standardization of a SMIng
     language, existing SMIv2 MIBs and SPPI PIBs on the standards track
     will not be required to be translated to the SMIng language.  New
     MIBs/PIBs will be defined using the SMIng language.

Fulfillment
     Algorithms can be specified to convey each SMI-DS construct to one
     or more SMIv2 constructs. Complex nesting must be unfolded into a
     set of associated SMIv2 tables, each table corresponding to the
     accessible objects at a given nest level of the SMI-DS object.
     Existing SMIv2 tables can easily be converted to SMI-DS using the





Expires August 12, 2002                                        [Page 70]





Internet Draft             SMI Data Structures         February 12, 2002


     ARRAY construct.

4.1.16 Base Data Types  [Yes]

Description
     SMIng must support the base data types Integer32, Unsigned32,
     Integer64, Unsigned64, Enumeration, Bits, OctetString, and OID.

Fulfillment
     The SMIv2 base data types are unchanged in SMI-DS.  The Integer64
     and Unsigned64 base data types will also be added.

4.1.17 Enumerations [Yes]

Description
     SMIng must provide support for enumerations.  Enumerated values
     must be a part of the enumeration definition.

Fulfillment
     SMI-DS provides enumerated INTEGERs, unchanged from SMIv2.

4.1.18 Discriminated Unions [Yes]

Description
     SMIng must support discriminated unions.

Fulfillment
     SMI-DS provides the UNION construct to explicitly define (in a
     manner that can be machine-parsed) a group of objects with the
     characteristics of a discriminated union. A STRUCT can be defined
     which includes the discriminator SCALAR object and the UNION
     object, to further express these semantics. (See HostInetAddress
     example in section 5.6).

4.1.19 Instance Pointers [Yes]

Description
     SMIng must allow specifying pointers to instances (i.e., a pointer
     to a particular attribute in a row).

Fulfillment
     The concept of a 'row' does not apply to SMI-DS, only to SMIv2,
     however OBJECT IDENTIFIER data objects can point to accessible
     SMIv2 tabular objects, and object names for SMIv2 tables do not
     change when translated to SMI-DS format.





Expires August 12, 2002                                        [Page 71]





Internet Draft             SMI Data Structures         February 12, 2002


4.1.20 Row Pointers [Yes]

Description
     SMIng must allow specifying pointers to rows.

Fulfillment
     The concept of a 'row' does not apply to SMI-DS, only to SMIv2,
     however OBJECT IDENTIFIER data objects can point to SMIv2 rows, and
     object names for SMIv2 tables do not change when translated to SMI-
     DS format.

4.1.21 Constraints on Pointers [Yes]

Description
     SMIng must allow specifying the types of objects to which a pointer
     may point.

Fulfillment
     A new variant of the SYNTAX clause is defined which restricts a
     particular data type that the OID pointer.  E.g., "SYNTAX POINTER
     FooObject" or "SYNTAX POINTER InetAddress", would actually define
     an OBJECT IDENTIFIER.

4.1.22 Base Type Set [Yes]

Description
     SMIng must support a fixed set of base types of fixed size and
     precision.  The list of base types must not be extensible unless
     the SMI itself changes.

Fulfillment
     SMI-DS uses a fixed set of base data types.

4.1.23 Extended Data Types [Yes]

Description
     SMIng must support a mechanism to derive new types, which provide
     additional semantics (e.g., Counters, Gauges, Strings, etc.), from
     base types.  It may be desirable to also allow the derivation of
     new types from derived types.  New types must be as restrictive or
     more restrictive than the types that they are specializing.

Fulfillment
     SMI-DS provides the TYPEDEF construct to specify complex or derived
     data types. SCALAR definitions can derive attributes from a base





Expires August 12, 2002                                        [Page 72]





Internet Draft             SMI Data Structures         February 12, 2002


     type or another derived type.

4.1.24 Units, Formats, and Default Values of Defined Types and
Attributes [Yes]

Description
     In SMIv2 OBJECT-TYPE definitions may contain UNITS and DEFVAL
     clauses and TEXTUAL-CONVENTIONs may contain DISPLAY-HINTs.  In a
     similar fashion units and default values must be applicable to
     defined types and format information must be applicable to
     attributes.

Fulfillment
     SMI-DS retains the UNITS, DEFVAL, and DISPLAY-HINT clauses for all
     SCALAR data type definitions and variable declarations.

4.1.25 Table Existence Relationships [Yes]

Description
     SMIng must support INDEX, AUGMENTS, and EXTENDS in the SNMP/COPS-PR
     protocol mappings.

Fulfillment
     These concepts have been included in SMI-DS, and AUGMENTS has been
     extended to any non-SCALAR TYPEDEF.  The EXTENDS construct is
     achieved by simply augmenting an existing ARRAY with a another
     (nested) ARRAY.

4.1.26 Table Existence Relationships [Yes]

Description
     SMIng must support EXPANDS and REORDERS relationships in the
     SNMP/COPS-PR protocol mappings.

Fulfillment
     SMI-DS is not a table-oriented data definition language like SMIv2
     or SPPI. Complex data objects are defined in a nested manner to
     convey a hierarchical relationship. The EXPANDS and REORDERS
     clauses are only meaningful in this table-oriented framework.
     However, the DESCRIPTION clause is provided to express semantics
     such as EXPANDS and REORDERS.

4.1.27 Attribute Groups [Yes]







Expires August 12, 2002                                        [Page 73]





Internet Draft             SMI Data Structures         February 12, 2002


Description
     An attribute group is a named, reusable set of attributes that are
     meaningful together.  It can be reused as the type of attributes in
     other attribute groups (see also Section 4.1.28).  This is similar
     to `structs' in C.

Fulfillment
     SMI-DS provides the STRUCT macro for this purpose.

4.1.28 Containment [Yes]

Description
     SMIng must provide support for the creation of new attribute groups
     from attributes of more basic types and potentially other attribute
     groups.

Fulfillment
     SMI-DS allows arbitrary nesting of STRUCT, ARRAY, and UNION type
     definitions.

4.1.29 Single Inheritance [Yes]

Description
     SMIng must provide support for mechanisms to extend attribute
     groups through single inheritance.

Fulfillment
     SMI-DS allows new complex types to contain other complex types, by
     reference, i.e. the contained data object inherits all attributes
     from the type as defined in another TYPEDEF (and AUGMENTS, if any).

4.1.30 Reusable vs. Final Attribute Groups [Yes]

Description
     SMIng must differentiate between "final" and reusable attribute
     groups, where the reuse of attribute groups covers inheritance and
     containment.

Fulfillment
     SMI-DS provides the TYPEDEF macro to create reusable definitions,
     and variable declarations to identify 'final' attribute groups.

4.1.31 Events [Yes]







Expires August 12, 2002                                        [Page 74]





Internet Draft             SMI Data Structures         February 12, 2002


Description
     SMIng must provide mechanisms to define events which identify
     significant state changes.

Fulfillment
     The NOTIFICATION macro is used (slightly modified NOTIFICATION-TYPE
     macro.

4.1.32 Creation/Deletion [Maybe]

Description
     SMIng must support a mechanism to define creation/deletion
     operations for instances.  Specific creation/deletion errors, such
     as INSTALL-ERRORS, must be supported.

Fulfillment
     A new data objected RowStatus could be defined, or the existing
     RowStatus simply used 'as-is' with data objects.  This objective is
     very 'table-oriented' and protocol-specific.  SMI-DS is intended to
     be protocol-independent.

4.1.33 Range and Size Constraints [Yes]

Description
     SMIng must allow specifying range and size constraints where
     applicable.

Fulfillment
     The SYNTAX clause is unchanged from SMIv2, which includes a range
     construct. A new SIZE construct has been added for ARRAY data types
     (INDEX clause) to identify array size constraints. The number of
     allowed instances for a particular INDEX is not required to be the
     same as the range of the INDEX variable itself. Fixed and variable
     sized arrays can be specified with this clause.

4.1.34 Uniqueness [Yes]

Description
     SMIng must allow the specification of uniqueness constraints on
     attributes.  SMIng must allow the specification of multiple
     independent uniqueness constraints.

Fulfillment
     Instance identifiers are of course unique.  The UNIQUE-SCOPE and
     DESCRIPTION clauses are available to specify uniqueness





Expires August 12, 2002                                        [Page 75]





Internet Draft             SMI Data Structures         February 12, 2002


     characteristics for any SCALAR data type or INDEX component.

4.1.35 Extension Rules [No]

Description
     SMIng must provide clear rules how one can extend SMIng modules
     without causing interoperability problems "over the wire".

Fulfillment
     The final version of SMI-DS will include a rigorous syntax, but
     there are no plans for an explicit EXTENSION construct, to allow
     SMI-DS to be extended in an distributed and uncontrolled manner.
     The SMI should only be changed in very careful and controlled
     manner, by an IETF WG (e.g. SMIng).

4.1.36 Deprecate Use of IMPLIED Keyword [Yes]

Description
     The SMIng SNMP mapping must deprecate the use of the IMPLIED
     indexing schema.

Fulfillment
     The IMPLIED keyword is deprecated in the SMI-DS INDEX construct.

4.1.37 No Redundancy [Yes]

Description
     The SMIng language must avoid redundancy.

Fulfillment
     SMI-DS remove any clause that is always the same value in all
     situations (e.g. MAX-ACCESS clause for the fooTable and fooEntry
     OBJECT-TYPE macros is always not-accessible, so only SCALAR data
     objects have a MAX-ACCESS clause).  The 'fooEntry' definition is
     removed entirely, and since SMI-DS is data object, not table
     oriented, there is no need for the ASN.1 'FooEntry SEQUENCE'
     construct.  Basic containment relationships are implied by the
     complex data types themselves (nested ARRAY, UNION, STRUCT) rather
     than by using lots of verbose OBJECT-TYPE DESCRIPTION clauses to
     declare the containment relationships between various OBJECT-TYPE
     macros.

4.1.38 Compliance and Conformance [Yes]







Expires August 12, 2002                                        [Page 76]





Internet Draft             SMI Data Structures         February 12, 2002


Description
     SMIng must provide a mechanism for compliance and conformance
     specifications for protocol-independent definitions as well as for
     protocol mappings.

Fulfillment
     The SMI-DS module compliance section is unchanged from SMIv2.  Just
     like SMIv2, only accessible (SCALAR) objects are listed in this
     section.

4.1.39 Allow Refinement of All Definitions in Conformance Statements
[Yes - TBD]

Description
     SMIv2, RFC 2580, Section 3.1 says: <para removed> The last sentence
     forbids to put a not-accessible INDEX object into an OBJECT-GROUP.
     Hence, you can not refine its syntax in a compliance definition.
     For more details, see http://www.ibr.cs.tu-bs.de/ietf/smi-errata/.

Fulfillment
     The arbitrary rules for SMIv2 can be changed, as they are adapted
     to SMI-DS. It is understood that every SMIv2 construct used in SMI-
     DS is subject to bugfixes.

4.1.40 Categories [No]

Description
     SMIng must provide a mechanism to group definitions into subject
     categories.  Concrete instances may only exist in the scope of a
     given subject category or context.

Fulfillment
     SMI-DS currently has no such construct.  This would require
     management and coordination of the set of categories, and therefore
     further thought.  Such a construct could be added if required.

4.1.41 Core Language Keywords vs. Defined Identifiers [No - TBD]

Description
     In SMI and SPPI modules some language keywords (macros and a number
     of basetypes) have to be imported from different SMI language
     defining modules, e.g.  OBJECT-TYPE, MODULE-IDENTITY, Integer32
     must to be imported from SNMPv2-SMI and TEXTUAL- CONVENTION must be
     imported from SNMPv2-TC, if used.  MIB authors are continuously
     confused about these import rules.  In SMIng only defined





Expires August 12, 2002                                        [Page 77]





Internet Draft             SMI Data Structures         February 12, 2002


     identifiers must be imported.  All SMIng language keywords must be
     implicitly known and there must not be a need to import them from
     any module.

Fulfillment
     Currently, the SMI-DS IMPORTS clause is unchanged from SMIv2.  It
     would be a mistake to forbid IMPORTS of base data types, since this
     is just one more thing for authors to get wrong.  The burden of
     listing all external definitions, including base types, in the
     IMPORTS clause is not a problem worth solving. The SMI-DS rules
     could be changed to make IMPORTS of base types forbidden, optional,
     or mandatory, whatever is required.

4.1.42 Instance Naming  [Maybe - TBD]

Description
     Instance naming in SMIv2 and SPPI is different.  SMIng must align
     the instance naming (either in the protocol neutral model or the
     protocol mappings).

Fulfillment
     SMI-DS instance naming is compatible with SMIv2. It is not clear
     what additions are needed to support SPPI naming as well.

4.1.43 Length of Identifiers [Yes - TBD]

Description
     The allowed length of the various kinds of identifiers must be
     extended from the current `should not exceed 32' (maybe even from
     the `must not exceed 64') rule.

Fulfillment
     All the arbitrary SMIv2 rules are subject to removal or repair as
     they are transferred to SMI-DS. The maximum descriptor length an
     agent must accept will be extended to 64.

4.1.44 Assign OIDs in the Protocol Mappings [No]

Description
     SMIng must not assign OIDs to reusable definition of attributes,
     attribute groups, events, etc.  Instead, SNMP and COPS-PR mappings
     must assign OIDs to the mapped items.

Fulfillment
     Although TYPEDEF definitions actually meet this requirement because





Expires August 12, 2002                                        [Page 78]





Internet Draft             SMI Data Structures         February 12, 2002


     only variable declarations can have complete OID assignments, it
     would be a critical mistake to separate data object naming from the
     data definition itself.  There is no justification whatsoever for
     the management transport protocol to dictate the naming
     characteristics of the data definition language.

4.2.1 Methods [No]

Description
     SMIng should support a mechanism to define method signatures
     (parameters, return values, exception) that are implemented on
     agents.

Fulfillment
     SMI-DS defines a data definition language with sufficient power to
     be used as a platform for object-oriented network management
     definitions in the future (ala C --> C++ transition).

4.2.2 Unions [Yes]

Description
     Allows an attribute to contain one of many types of values.  The
     lack of unions has also lead to relatively complex sparse table
     work-around in some DISMAN mid-level managers.  Despite from
     discriminated unions (see Section 4.1.18), this kind of union has
     no accompanied explicit discriminator attribute that selects the
     union's type of value.

Fulfillment
     SMI-DS provides the UNION macro for this purpose.

4.2.3 Float Data Types [Yes]

Description
     SMIng should support the base data types Float32, Float64,
     Float128.

Fulfillment
     SMI-DS will support a Float data type. Is is not clear that 3
     variants are needed though.

4.2.4 Comments [Yes]

Description
     The syntax of comments should be well defined, unambiguous and





Expires August 12, 2002                                        [Page 79]





Internet Draft             SMI Data Structures         February 12, 2002


     intuitive to most people, e.g., the C++/Java `//' syntax.

Fulfillment
     The ASN.1 comment meets these requirements and is used unchanged
     from SMIv2. There is no community requirement to use Java style
     comments. The use of 2 dashes for a 'start of comment' token is not
     any better or worse than 2 slashes. Not a change worth making.

4.2.5 Referencing Tagged Rows [No]

Description
     PIB and MIB row attributes reference a group of entries in another
     table.  SPPI formalizes this by introducing PIB-TAG and PIB-
     REFERENCES clauses.  This functionality should be retained in
     SMIng.

Fulfillment
     SMI-DS does not use a table-oriented data model, so these
     constructs do not apply.

4.2.6 Arrays [Yes]

Description
     SMIng should allow the definition of a SEQUENCE OF attributes or
     attribute groups (Section 4.1.27).

Fulfillment
     SMI-DS provides the ARRAY macro for this purpose.

4.2.7 Internationalization [No - TBD]

Description
     Informational text (DESCRIPTION, REFERENCE, ...) should allow
     i18nized encoding, probably UTF-8.

Fulfillment
     SMI-DS used the DESCRIPTION and REFERENCE clauses unchanged from
     SMIv2. Changes to these clauses could be made if required, but
     unless standard (IETF) information modules are written in a
     language other than English, this only applies to vendor MIBs.

4.2.8 Separate Data Modelling from Management Protocol Mapping [Yes]

Description
     It should be possible to separate the domain specific data





Expires August 12, 2002                                        [Page 80]





Internet Draft             SMI Data Structures         February 12, 2002


     modelling work from the network management protocol specific work.

Fulfillment
     The SMI-DS data definitions are protocol independent. Mappings
     (where applicable) will be defined for SNMP, because SMIv2 is
     intended to function with SNMP, and SMI-DS is intended to replace
     SMIv2. Mapping rules for other protocols are certainly possible,
     but are not included in this document.










































Expires August 12, 2002                                        [Page 81]





Internet Draft             SMI Data Structures         February 12, 2002


13.  Security Considerations

This document defines a structure for management data and therefore does
not expose any management information from a particular device. However,
accessible data objects defined with the mechanisms defined in this
document should be given the same security consideration as objects
specified with SMIv2, when being transferred with SNMP.

SNMPv1 by itself is not a secure environment.  Even if the network
itself is secure (for example by using IPSec), even then, there is no
control as to who on the secure network is allowed to access and GET/SET
(read/change/create/delete) the objects in this MIB.

It is recommended that the implementors consider the security features
as provided by the SNMPv3 framework.  Specifically, the use of the User-
based Security Model RFC 2574 [RFC2574] and the View-based Access
Control Model RFC 2575 [RFC2575] is recommended.

It is then a customer/user responsibility to ensure that the SNMP entity
giving access to an instance of this MIB, is properly configured to give
access to the objects only to those principals (users) that have
legitimate rights to indeed GET or SET (change/create/delete) them.




























Expires August 12, 2002                                        [Page 82]





Internet Draft             SMI Data Structures         February 12, 2002


14.  Intellectual Property

The IETF takes no position regarding the validity or scope of any
intellectual property or other rights that might be claimed to  pertain
to the implementation or use of the technology described in this
document or the extent to which any license under such rights might or
might not be available; neither does it represent that it has made any
effort to identify any such rights.  Information on the IETF's
procedures with respect to rights in standards-track and standards-
related documentation can be found in BCP-11.  Copies of claims of
rights made available for publication and any assurances of licenses to
be made available, or the result of an attempt made to obtain a general
license or permission for the use of such proprietary rights by
implementors or users of this specification can be obtained from the
IETF Secretariat.

The IETF invites any interested party to bring to its attention any
copyrights, patents or patent applications, or other proprietary rights
which may cover technology that may be required to practice this
standard.  Please address the information to the IETF Executive
Director.

15.  Acknowledgements

Portions of the existing SMI RFCs, SMIng drafts, and the ANSI C
Programming Language inspired many of the concepts discussed in this
memo.























Expires August 12, 2002                                        [Page 83]





Internet Draft             SMI Data Structures         February 12, 2002


16.  References

[DSMON-MIB]
     Bierman, A., "Remote Monitoring MIB Extensions for Differentiated
     Services", Work in progress (draft-ietf-rmonmib-dsmon-mib-09.txt),
     Cisco Systems, Inc., November 2001.

[RFC1155]
     Rose, M., and K. McCloghrie, "Structure and Identification of
     Management Information for TCP/IP-based Internets", RFC 1155,
     Performance Systems International, Hughes LAN Systems, May 1990.

[RFC1157]
     Case, J., Fedor, M., Schoffstall, M., and J. Davin, "Simple Network
     Management Protocol", RFC 1157, SNMP Research, Performance Systems
     International, Performance Systems International, MIT Laboratory
     for Computer Science, May 1990.

[RFC1212]
     Rose, M., and K. McCloghrie, "Concise MIB Definitions", RFC 1212,
     Performance Systems International, Hughes LAN Systems, March 1991.

[RFC1215]
     M. Rose, "A Convention for Defining Traps for use with the SNMP",
     RFC 1215, Performance Systems International, March 1991.

[RFC1901]
     SNMPv2 Working Group, Case, J., McCloghrie, K., Rose, M., and S.
     Waldbusser, "Introduction to Community-based SNMPv2", RFC 1901,
     SNMP Research, Inc., Cisco Systems, Inc., Dover Beach Consulting,
     Inc., International Network Services, January 1996.

[RFC1905]
     SNMPv2 Working Group, Case, J., McCloghrie, K., Rose, M., and S.
     Waldbusser, "Protocol Operations for Version 2 of the Simple
     Network Management Protocol (SNMPv2)", RFC 1905, SNMP Research,
     Inc., Cisco Systems, Inc., Dover Beach Consulting, Inc.,
     International Network Services, January 1996.

[RFC1906]
     SNMPv2 Working Group, Case, J., McCloghrie, K., Rose, M., and S.
     Waldbusser, "Transport Mappings for Version 2 of the Simple Network
     Management Protocol (SNMPv2)", RFC 1906, SNMP Research, Inc., Cisco
     Systems, Inc., Dover Beach Consulting, Inc., International Network
     Services, January 1996.





Expires August 12, 2002                                        [Page 84]





Internet Draft             SMI Data Structures         February 12, 2002


[RFC2021]
     S. Waldbusser, "Remote Network Monitoring Management Information
     Base Version 2 using SMIv2", RFC 2021, INS, January 1997.

[RFC2026]
     Bradner, S., "The Internet Standards Process -- Revision 3", RFC
     2026, Harvard University, October, 1996.

[RFC2119]
     S. Bradner, "Key words for use in RFCs to Indicate Requirement
     Levels" RFC 2119, Harvard University, March 1997.

[RFC2233]
     McCloghrie, K., and F. Kastenholz, "The Interfaces Group MIB using
     SMIv2", RFC 2233, Cisco Systems, FTP Software, November 1997.

[RFC2570]
     Case, J., Mundy, R., Partain, D., and B. Stewart, "Introduction to
     Version 3 of the Internet-standard Network Management Framework",
     RFC 2570, SNMP Research, Inc., TIS Labs at Network Associates,
     Inc., Ericsson, Cisco Systems, April 1999.

[RFC2571]
     Harrington, D., Presuhn, R., and B. Wijnen, "An Architecture for
     Describing SNMP Management Frameworks", RFC 2571, Cabletron
     Systems, Inc., BMC Software, Inc., IBM T. J. Watson Research, April
     1999.

[RFC2572]
     Case, J., Harrington D., Presuhn R., and B. Wijnen, "Message
     Processing and Dispatching for the Simple Network Management
     Protocol (SNMP)", RFC 2572, SNMP Research, Inc., Cabletron Systems,
     Inc., BMC Software, Inc., IBM T. J. Watson Research, April 1999.

[RFC2573]
     Levi, D., Meyer, P., and B. Stewart, "SNMPv3 Applications", RFC
     2573, SNMP Research, Inc., Secure Computing Corporation, Cisco
     Systems, April 1999.

[RFC2574]
     Blumenthal, U., and B. Wijnen, "User-based Security Model (USM) for
     version 3 of the Simple Network Management Protocol (SNMPv3)", RFC
     2574, IBM T. J. Watson Research, April 1999.







Expires August 12, 2002                                        [Page 85]





Internet Draft             SMI Data Structures         February 12, 2002


[RFC2575]
     Wijnen, B., Presuhn, R., and K. McCloghrie, "View-based Access
     Control Model (VACM) for the Simple Network Management Protocol
     (SNMP)", RFC 2575, IBM T. J. Watson Research, BMC Software, Inc.,
     Cisco Systems, Inc., April 1999.

[RFC2578]
     McCloghrie, K., Perkins, D., Schoenwaelder, J., Case, J., Rose, M.,
     and S. Waldbusser, "Structure of Management Information Version 2
     (SMIv2)", RFC 2578, STD 58, Cisco Systems, SNMPinfo, TU
     Braunschweig, SNMP Research, First Virtual Holdings, International
     Network Services, April 1999.

[RFC2579]
     McCloghrie, K., Perkins, D., Schoenwaelder, J., Case, J., Rose, M.,
     and S. Waldbusser, "Textual Conventions for SMIv2", RFC 2579, STD
     58, Cisco Systems, SNMPinfo, TU Braunschweig, SNMP Research, First
     Virtual Holdings, International Network Services, April 1999.

[RFC2580]
     McCloghrie, K., Perkins, D., Schoenwaelder, J., Case, J., Rose, M.,
     and S. Waldbusser, "Conformance Statements for SMIv2", RFC 2580,
     STD 58, Cisco Systems, SNMPinfo, TU Braunschweig, SNMP Research,
     First Virtual Holdings, International Network Services, April 1999.

[RFC2737]
     McCloghrie, K., and A. Bierman, "Entity MIB (Version 2)", RFC 2737,
     Cisco Systems, Inc., December 1999.

[RFC2851]
     Daniele, M., Haberman, B., Routhier, S., and J. Schoenwaelder,
     "Textual Conventions for Internet Network Addresses", RFC 2851,
     Compaq Computer Corporation, Nortel Networks, Wind River Systems,
     Inc., TU Braunschweig, June 2000.

[RFC3216]
     Elliot, C., Harrington, D., Jason, J., Schoenwaelder, J., Strauss,
     F., and W. Weiss, "SMIng Objectives", RFC 3216, Cisco Systems,
     Enterasys Networks, Intel Corporation, TU Braunschweig, Ellacoya
     Networks, December 2001.

17.  Author's Address

     Andy Bierman
     Cisco Systems, Inc.





Expires August 12, 2002                                        [Page 86]





Internet Draft             SMI Data Structures         February 12, 2002


     170 West Tasman Drive
     San Jose, CA USA 95134
     Phone: +1 408-527-3711
     Email: abierman@cisco.com














































Expires August 12, 2002                                        [Page 87]





Internet Draft             SMI Data Structures         February 12, 2002


18.  Full Copyright Statement

Copyright (C) The Internet Society (2002).  All Rights Reserved.

This document and translations of it may be copied and furnished to
others, and derivative works that comment on or otherwise explain it or
assist in its implementation may be prepared, copied, published and
distributed, in whole or in part, without restriction of any kind,
provided that the above copyright notice and this paragraph are included
on all such copies and derivative works.  However, this document itself
may not be modified in any way, such as by removing the copyright notice
or references to the Internet Society or other Internet organizations,
except as needed for the purpose of developing Internet standards in
which case the procedures for copyrights defined in the Internet
Standards process must be followed, or as required to translate it into
languages other than English.

The limited permissions granted above are perpetual and will not be
revoked by the Internet Society or its successors or assigns.

This document and the information contained herein is provided on an "AS
IS" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING TASK
FORCE DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT
LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT
INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR
FITNESS FOR A PARTICULAR PURPOSE.
























Expires August 12, 2002                                        [Page 88]

