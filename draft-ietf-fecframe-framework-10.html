<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="en"><head><title>Forward Error Correction (FEC)
    Framework</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="description" content="Forward Error Correction (FEC)
    Framework">
<meta name="generator" content="xml2rfc v1.35 (http://xml.resource.org/)">
<meta name="viewport" content="width=600;" />
<style type='text/css'><!--
        body {
                font-family: verdana, charcoal, helvetica, arial, sans-serif;
                font-size: 85%;
		max-width: 60em; 
		color: #000; background-color: #FFF;
                margin: 2em;
        }
        h1, h2, h3, h4, h5, h6 {
                font-family: helvetica, monaco, "MS Sans Serif", arial, sans-serif;
                font-weight: bold; font-style: normal;
        }
        h1 { color: #900; background-color: transparent; text-align: right; }
        h3 { color: #333; background-color: transparent; }

        td.RFCbug {
                font-size: x-small; text-decoration: none;
                width: 30px; height: 30px; padding-top: 2px;
                text-align: justify; vertical-align: middle;
                background-color: #000;
        }
        td.RFCbug span.RFC {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: bold; color: #666;
        }
        td.RFCbug span.hotText {
                font-family: charcoal, monaco, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: normal; text-align: center; color: #FFF;
        }

        table.TOCbug { width: 30px; height: 15px; }
        td.TOCbug {
                text-align: center; width: 30px; height: 15px;
                color: #FFF; background-color: #900;
        }
        td.TOCbug a {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, sans-serif;
                font-weight: bold; font-size: x-small; text-decoration: none;
                color: #FFF; background-color: transparent;
        }

        td.header {
                font-family: arial, helvetica, sans-serif; font-size: x-small;
                vertical-align: top; width: 33%;
                color: #FFF; background-color: #666;
        }
        td.author { font-weight: bold; font-size: x-small; margin-left: 4em; }
        td.author-text { font-size: x-small; }

        /* info code from SantaKlauss at http://www.madaboutstyle.com/tooltip2.html */
        a.info {
                /* This is the key. */
                position: relative;
                z-index: 24;
                text-decoration: none;
        }
        a.info:hover {
                z-index: 25;
                color: #FFF; background-color: #900;
        }
        a.info span { display: none; }
        a.info:hover span.info {
                /* The span will display just on :hover state. */
                display: block;
                position: absolute;
                font-size: smaller;
                top: 2em; left: -5em; width: 15em;
                padding: 2px; border: 1px solid #333;
                color: #900; background-color: #EEE;
                text-align: left;
        }

        a { font-weight: bold; }
        a:link    { color: #900; background-color: transparent; }
        a:visited { color: #633; background-color: transparent; }
        a:active  { color: #633; background-color: transparent; }

        p { margin-left: 2em; margin-right: 2em; }
        p.copyright { font-size: x-small; }
        p.toc { font-size: 85%;
		max-width: 60em; 
		font-weight: bold; margin-left: 3em; }
        table.toc { margin: 0 0 0 3em; padding: 0; border: 0; vertical-align: text-top; }
        td.toc { font-size: 85%;
		max-width: 60em; 
		font-weight: bold; vertical-align: text-top; }

        ol.text { margin-left: 2em; margin-right: 2em; }
        ul.text { margin-left: 2em; margin-right: 2em; }
        li      { margin-left: 3em; }

        /* RFC-2629 <spanx>s and <artwork>s. */
        em     { font-style: italic; }
        strong { font-weight: bold; }
        dfn    { font-weight: bold; font-style: normal; }
        cite   { font-weight: normal; font-style: normal; }
        tt     { color: #036; }
        tt, pre, pre dfn, pre em, pre cite, pre span {
                font-family: "Courier New", Courier, monospace; font-size: small;
        }
        pre {
                text-align: left; padding: 4px;
                color: #000; background-color: #CCC;
        }
        pre dfn  { color: #900; }
        pre em   { color: #66F; background-color: #FFC; font-weight: normal; }
        pre .key { color: #33C; font-weight: bold; }
        pre .id  { color: #900; }
        pre .str { color: #000; background-color: #CFF; }
        pre .val { color: #066; }
        pre .rep { color: #909; }
        pre .oth { color: #000; background-color: #FCF; }
        pre .err { background-color: #FCC; }

        /* RFC-2629 <texttable>s. */
        table.all, table.full, table.headers, table.none {
                font-size: 85%;
		max-width: 60em; 
		text-align: center; border-width: 2px;
                vertical-align: top; border-collapse: collapse;
        }
        table.all, table.full { border-style: solid; border-color: black; }
        table.headers, table.none { border-style: none; }
        th {
                font-weight: bold; border-color: black;
                border-width: 2px 2px 3px 2px;
        }
        table.all th, table.full th { border-style: solid; }
        table.headers th { border-style: none none solid none; }
        table.none th { border-style: none; }
        table.all td {
                border-style: solid; border-color: #333;
                border-width: 1px 2px;
        }
        table.full td, table.headers td, table.none td { border-style: none; }

        hr { height: 1px; }
        hr.insert {
                width: 80%; border-style: none; border-width: 0;
                color: #CCC; background-color: #CCC;
        }
--></style>
</head>
<body>
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<table summary="layout" width="66%" border="0" cellpadding="0" cellspacing="0"><tr><td><table summary="layout" width="100%" border="0" cellpadding="2" cellspacing="1">
<tr><td class="header">FEC Framework Working Group</td><td class="header">M. Watson</td></tr>
<tr><td class="header">Internet-Draft</td><td class="header">Netflix, Inc.</td></tr>
<tr><td class="header">Intended status: Standards Track</td><td class="header">September 7, 2010</td></tr>
<tr><td class="header">Expires: March 11, 2011</td><td class="header">&nbsp;</td></tr>
</table></td></tr></table>
<h1><br />Forward Error Correction (FEC)
    Framework<br />draft-ietf-fecframe-framework-10</h1>

<h3>Abstract</h3>

<p>This document describes a framework for using forward error
      correction (FEC) codes with applications in public and private IP
      networks to provide protection against packet loss. The framework
      supports applying Forward Error Correction to arbitrary packet flows
      over unreliable transport and is primarily intended for real-time, or
      streaming, media. This framework can be used to define Content Delivery
      Protocols that provide Forward Error Correction for streaming media
      delivery or other packet flows. Content Delivery Protocols defined using
      this framework can support any FEC Scheme (and associated FEC codes)
      which is compliant with various requirements defined in this document.
      Thus, Content Delivery Protocols can be defined which are not specific
      to a particular FEC Scheme and FEC Schemes can be defined which are not
      specific to a particular Content Delivery Protocol.
</p>
<h3>Status of this Memo</h3>
<p>
This Internet-Draft is submitted  in full
conformance with the provisions of BCP&nbsp;78 and BCP&nbsp;79.</p>
<p>
Internet-Drafts are working documents of the Internet Engineering
Task Force (IETF).  Note that other groups may also distribute
working documents as Internet-Drafts.  The list of current
Internet-Drafts is at http://datatracker.ietf.org/drafts/current/.</p>
<p>
Internet-Drafts are draft documents valid for a maximum of six months
and may be updated, replaced, or obsoleted by other documents at any time.
It is inappropriate to use Internet-Drafts as reference material or to cite
them other than as &ldquo;work in progress.&rdquo;</p>
<p>
This Internet-Draft will expire on March 11, 2011.</p>

<h3>Copyright Notice</h3>
<p>
Copyright (c) 2010 IETF Trust and the persons identified as the
document authors.  All rights reserved.</p>
<p>
This document is subject to BCP 78 and the IETF Trust's Legal
Provisions Relating to IETF Documents
(http://trustee.ietf.org/license-info) in effect on the date of
publication of this document.  Please review these documents
carefully, as they describe your rights and restrictions with respect
to this document. Code Components extracted from this document must
include Simplified BSD License text as described in Section 4.e of
the Trust Legal Provisions and are provided without warranty as
described in the Simplified BSD License.</p>
<p>
This document may contain material from IETF Documents or IETF
Contributions published or made publicly available before November
10, 2008.  The person(s) controlling the copyright in some of this
material may not have granted the IETF Trust the right to allow
modifications of such material outside the IETF Standards Process.
Without obtaining an adequate license from the person(s) controlling
the copyright in such materials, this document may not be modified
outside the IETF Standards Process, and derivative works of it may
not be created outside the IETF Standards Process, except to format
it for publication as an RFC or to translate it into languages other
than English.</p>
<a name="toc"></a><br /><hr />
<h3>Table of Contents</h3>
<p class="toc">
<a href="#anchor1">1.</a>&nbsp;
Introduction<br />
<a href="#anchor2">2.</a>&nbsp;
Definitions/Abbreviations<br />
<a href="#anchor3">3.</a>&nbsp;
Architecture Overview<br />
<a href="#anchor4">4.</a>&nbsp;
Procedural overview<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor5">4.1.</a>&nbsp;
General<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#senderoperation">4.2.</a>&nbsp;
Sender Operation<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#receiveroperation">4.3.</a>&nbsp;
Receiver Operation<br />
<a href="#anchor6">5.</a>&nbsp;
Protocol Specification<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor7">5.1.</a>&nbsp;
General<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sourceblock">5.2.</a>&nbsp;
Structure of the source block<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sourcepackets">5.3.</a>&nbsp;
Packet format for FEC Source packets<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor8">5.3.1.</a>&nbsp;
Generic Explicit Source FEC Payload Id<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#repairpackets">5.4.</a>&nbsp;
Packet Format for FEC Repair packets<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor9">5.4.1.</a>&nbsp;
Packet Format for FEC Repair packets over RTP<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#config">5.5.</a>&nbsp;
FEC Framework Configuration Information<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#fecscheme">5.6.</a>&nbsp;
FEC Scheme requirements<br />
<a href="#anchor10">6.</a>&nbsp;
Feedback<br />
<a href="#TransportProtocols">7.</a>&nbsp;
Transport Protocols<br />
<a href="#anchor11">8.</a>&nbsp;
Congestion Control<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#normativecongestion">8.1.</a>&nbsp;
Normative requirements<br />
<a href="#anchor12">9.</a>&nbsp;
Security Considerations<br />
<a href="#iana">10.</a>&nbsp;
IANA Considerations<br />
<a href="#anchor13">11.</a>&nbsp;
Acknowledgments<br />
<a href="#rfc.references1">12.</a>&nbsp;
References<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#rfc.references1">12.1.</a>&nbsp;
Normative references<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#rfc.references2">12.2.</a>&nbsp;
Informative references<br />
<a href="#rfc.authors">&#167;</a>&nbsp;
Author's Address<br />
</p>
<br clear="all" />

<a name="anchor1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1"></a><h3>1.&nbsp;
Introduction</h3>

<p>Many applications have a requirement to transport a continuous stream
      of packetized data from a source (sender) to one or more destinations
      (receivers) over networks which do not provide guaranteed packet
      delivery. Primary examples are real-time, or streaming, media
      applications such as broadcast, multicast or on-demand audio, video or
      multimedia.
</p>
<p>Forward Error Correction is a well-known technique for improving
      reliability of packet transmission over networks which do not provide
      guaranteed packet delivery, especially in multicast and broadcast
      applications. The FEC Building Block defined in <a class='info' href='#RFC5052'>[RFC5052]<span> (</span><span class='info'>Watson, M., Luby, M., and L. Vicisano, &ldquo;Forward Error Correction (FEC) Building Block,&rdquo; August&nbsp;2007.</span><span>)</span></a> provides a framework for definition of Content
      Delivery Protocols (CDPs) for object delivery (including, primarily,
      file delivery) which make use of separately defined FEC Schemes. Any CDP
      defined according to the requirements of the FEC Building Block can then
      easily be used with any FEC Scheme which is also defined according to
      the requirements of the FEC Building Block. (Note that the term "Forward
      Erasure Correction" is sometimes used, 'erasures' being a type of error
      in which data is lost and this loss can be detected, rather than being
      received in corrupted form - the focus of this document is strictly on
      erasures, however the term Forward Error Correction is more widely
      used).
</p>
<p>This document defines a framework for the definition of CDPs which
      provide for FEC protection of arbitrary packet flows over unreliable
      transports such as UDP. As such, this document complements the FEC
      Building Block of <a class='info' href='#RFC5052'>[RFC5052]<span> (</span><span class='info'>Watson, M., Luby, M., and L. Vicisano, &ldquo;Forward Error Correction (FEC) Building Block,&rdquo; August&nbsp;2007.</span><span>)</span></a>, by providing for the
      case of arbitrary packet flows over unreliable transport, the same kind
      of framework as that document provides for object delivery. This
      document does not define a complete Content Delivery Protocol, but
      rather defines only those aspects that are expected to be common to all
      Content Delivery Protocols based on this framework.
</p>
<p>This framework does not define how the flows to be protected are
      determined, nor how the details of the protected flows and the FEC
      streams which protect them are communicated from sender to receiver. It
      is expected that any complete Content Delivery Protocol specification
      which makes use of this framework will address these signalling
      requirements. However, this document does specify the information which
      is required by the FEC Framework at the sender and receiver - for
      example details of the flows to be FEC protected, the flow(s) that will
      carry the FEC protection data and an opaque container for
      FEC-Scheme-specific information.
</p>
<p>FEC Schemes designed for use with this framework must fulfil a number
      of requirements defined in this document. Note that these requirements
      are different from those defined in <a class='info' href='#RFC5052'>[RFC5052]<span> (</span><span class='info'>Watson, M., Luby, M., and L. Vicisano, &ldquo;Forward Error Correction (FEC) Building Block,&rdquo; August&nbsp;2007.</span><span>)</span></a> for
      FEC Schemes for object delivery. However there is a great deal of
      commonality and FEC Schemes defined for object delivery may be easily
      adapted for use with the framework defined here.
</p>
<p>Since the RTP protocol layer is used over UDP, this framework can be
      applied to RTP flows as well. FEC repair packets may be sent directly
      over UDP or over RTP. The latter approach has the advantage that RTP
      instrumentation, based on RTCP, can be used for the repair flow.
      Additionally, the post-repair RTCP extended report <a class='info' href='#RFC5725'>[RFC5725]<span> (</span><span class='info'>Begen, A., Hsu, D., and M. Lague, &ldquo;Post-Repair Loss RLE Report Block Type for RTP Control Protocol (RTCP) Extended Reports (XRs),&rdquo; February&nbsp;2010.</span><span>)</span></a> may be used to obtain information about the
      loss rate after FEC recovery.
</p>
<p>The use of RTP for repair flows is defined for each FEC Scheme by
      defining an RTP Payload Format for that particular FEC Scheme (possibly
      in the same document).
</p>
<a name="anchor2"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2"></a><h3>2.&nbsp;
Definitions/Abbreviations</h3>

<p></p>
<blockquote class="text"><dl>
<dt>'ADU Flow'</dt>
<dd>A sequence of ADUs associated with a
          transport layer flow identifier (such as the standard 5-tuple {
          Source IP Address, Source Transport Port, Destination IP Address,
          Destination Transport Port, Transport Protocol } in the case of
          UDP)
</dd>
<dt>'AL-FEC'</dt>
<dd>Application Layer Forward Error
          Correction
</dd>
<dt>'Application Data Unit'</dt>
<dd>The unit of source data
          provided as payload to the transport layer
</dd>
<dt>'Application protocol'</dt>
<dd>Control protocol used to
          establish and control the source data flow being protected - e.g.
          RTSP.
</dd>
<dt>'Content Delivery Protocol (CDP)'</dt>
<dd>A complete
          application protocol specification which, through the use of the
          framework defined in this document, is able to make use of FEC
          Schemes to provide Forward Error Correction capabilities
</dd>
<dt>'FEC'</dt>
<dd>Forward Error Correction.
</dd>
<dt>'FEC Code'</dt>
<dd>An algorithm for encoding data such that
          the encoded data flow is resilient to data loss (Note: in general
          FEC Codes may also be used to make a data flow resilient to
          corruption, but that is not considered here).
</dd>
<dt>'FEC Framework'</dt>
<dd>A protocol framework for definition of
          Content Delivery Protocols using FEC, such as the framework defined
          in this document.
</dd>
<dt>'FEC Framework Configuration Information'</dt>
<dd>Information
          which controls the operation of the FEC Framework.
</dd>
<dt>'FEC Payload ID'</dt>
<dd>Information which identifies the
          contents of a packet with respect to the FEC Scheme.
</dd>
<dt>'FEC Repair Packet'</dt>
<dd>At a sender (respectively, at a
          receiver) a payload submitted to (respectively, received from) the
          Transport protocol containing one or more repair symbols along with
          a Repair FEC Payload ID and possibly an RTP header.
</dd>
<dt>'FEC Scheme'</dt>
<dd>A specification which defines the
          additional protocol aspects required to use a particular FEC code
          with the FEC Framework, or, in the context of RMT, with the RMT FEC
          Building Block.
</dd>
<dt>'FEC Source Packet'</dt>
<dd>At a sender (respectively, at a
          receiver) a payload submitted to (respectively, received from) the
          Transport protocol containing an ADU along with an optional Source
          FEC Payload ID.
</dd>
<dt>'Protection amount'</dt>
<dd>The relative increase in data sent
          due to the use of FEC.
</dd>
<dt>'Repair data flow'</dt>
<dd>The packet flow or flows carrying
          forward error correction data
</dd>
<dt>'Repair FEC Payload ID'</dt>
<dd>An FEC Payload ID specifically
          for use with repair packets.
</dd>
<dt>'Source data flow'</dt>
<dd>The packet flow or flows to which
          FEC protection is to be applied. A source data flow consists of
          ADUs.
</dd>
<dt>'Source FEC Payload ID'</dt>
<dd>An FEC Payload ID specifically
          for use with source packets.
</dd>
<dt>'Source protocol'</dt>
<dd>A protocol used for the source data
          flow being protected - e.g. RTP.
</dd>
<dt>'Transport protocol'</dt>
<dd>The protocol used for transport
          of the source and repair data flows - e.g. UDP, DCCP.
</dd>
</dl></blockquote><p>The following definitions are aligned with <a class='info' href='#RFC5052'>[RFC5052]<span> (</span><span class='info'>Watson, M., Luby, M., and L. Vicisano, &ldquo;Forward Error Correction (FEC) Building Block,&rdquo; August&nbsp;2007.</span><span>)</span></a></p>
<blockquote class="text"><dl>
<dt>'Code rate'</dt>
<dd>the ratio between the number of source
          symbols and the number of encoding symbols. By definition, the code
          rate is such that: 0 &lt; code rate &lt;= 1. A code rate close to 1
          indicates that a small number of repair symbols have been produced
          during the encoding process.
</dd>
<dt>'Encoding symbol'</dt>
<dd>unit of data generated by the
          encoding process. With systematic codes, source symbols are part of
          the encoding symbols.
</dd>
<dt>'Packet Erasure Channel'</dt>
<dd>a communication path where
          packets are either dropped (e.g., by a congested router, or because
          the number of transmission errors exceeds the correction
          capabilities of the physical layer codes) or received. When a packet
          is received, it is assumed that this packet is not corrupted.
</dd>
<dt>'Repair symbol'</dt>
<dd>encoding symbol that is not a source
          symbol.
</dd>
<dt>'Source Block'</dt>
<dd>group of ADUs which are to be FEC
          protected as a single block.
</dd>
<dt>'Source symbol'</dt>
<dd>unit of data used during the encoding
          process.
</dd>
<dt>'Systematic code'</dt>
<dd>FEC code in which the source symbols
          are part of the encoding symbols. The Reed-Solomon codes introduced
          in this document are systematic.
</dd>
</dl></blockquote>

<p>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
      "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
      document are to be interpreted as described in <a class='info' href='#RFC2119'>[RFC2119]<span> (</span><span class='info'>Bradner, S., &ldquo;Key words for use in RFCs to Indicate Requirement Levels,&rdquo; March&nbsp;1997.</span><span>)</span></a>.
</p>
<a name="anchor3"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3"></a><h3>3.&nbsp;
Architecture Overview</h3>

<p>The FEC Framework is described in terms of an additional layer
      between the transport layer (e.g. UDP or DCCP) and protocols running
      over this transport layer. Examples of such protocols are RTP, RTCP,
      etc. As such, the data path interface between the FEC Framework and both
      underlying and overlying layers can be thought of as being the same as
      the standard interface to the transport layer - i.e. the data exchanged
      consists of datagram payloads each associated with a single ADU flow
      identified (in the case of UDP) by the standard 5-tuple { Source IP
      Address, Source Transport Port, Destination IP Address, Destination
      Transport Port, Transport Protocol }. In the case that RTP is used for
      the repair flows, the source and repair data may be multiplexed using
      RTP onto a single UDP flow and must consequently be demultiplexed at the
      receiver. There are various ways in which this multiplexing can be done,
      for example as described in <a class='info' href='#RFC4588'>[RFC4588]<span> (</span><span class='info'>Rey, J., Leon, D., Miyazaki, A., Varsa, V., and R. Hakenberg, &ldquo;RTP Retransmission Payload Format,&rdquo; July&nbsp;2006.</span><span>)</span></a>.
</p>
<p>It is important to understand that the main purpose of the FEC
      Framework architecture is to allocate functional responsibilities to
      separately documented components in such a way that specific instances
      of the components can be combined in different ways to describe
      different protocols.
</p>
<p>The FEC Framework makes use of an FEC Scheme, in a similar sense to
      that defined in <a class='info' href='#RFC5052'>[RFC5052]<span> (</span><span class='info'>Watson, M., Luby, M., and L. Vicisano, &ldquo;Forward Error Correction (FEC) Building Block,&rdquo; August&nbsp;2007.</span><span>)</span></a> and uses the terminology
      of that document. The FEC Scheme defines the FEC encoding and decoding
      and defines the protocol fields and procedures used to identify packet
      payload data in the context of the FEC Scheme. The interface between the
      FEC Framework and an FEC Scheme, which is described in this document, is
      a logical one, which exists for specification purposes only. At an
      encoder, the FEC Framework passes ADUs to the FEC Scheme for FEC
      encoding. The FEC Scheme returns repair symbols with their associated
      Repair FEC Payload IDs, and in some case Source FEC Payload IDs,
      depending on the FEC Scheme. At a decoder, the FEC Framework passes
      transport packet payloads (source and repair) to the FEC Scheme and the
      FEC Scheme returns additional recovered source packet payloads.
</p>
<p>This document defines certain FEC Framework Configuration Information
      which MUST be available to both sender and receiver(s). For example,
      this information includes the specification of the ADU flows which are
      to be FEC protected, specification of the ADU flow(s) which will carry
      the FEC protection (repair) data and the relationship(s) between these
      source and repair flows (i.e. which source flow(s) are protected by each
      repair flow. The FEC Framework Configuration Information also includes
      information fields which are specific to the FEC Scheme. This
      information is analogous to the FEC Object Transmission Information
      defined in <a class='info' href='#RFC5052'>[RFC5052]<span> (</span><span class='info'>Watson, M., Luby, M., and L. Vicisano, &ldquo;Forward Error Correction (FEC) Building Block,&rdquo; August&nbsp;2007.</span><span>)</span></a>.
</p>
<p>The FEC Framework does not define how the FEC Framework Configuration
      Information for the stream is communicated from sender to receiver. This
      must be defined by any Content Delivery Protocol specification as
      described in the following sections.
</p>
<p>In this architecture we assume that the interface to the transport
      layer supports the concepts of data units (referred to here as
      Application Data Units) to be transported and identification of ADU
      flows on which those data units are transported. Since this is an
      interface internal to the architecture, we do not specify this interface
      explicitly. We do require that ADU flows which are distinct from the
      transport layer point of view (for example, distinct UDP flows as
      identified by the UDP source/destination ports/addresses) are also
      distinct on the interface between the transport layer and the FEC
      Framework.
</p>
<p>As noted above, RTP flows are a specific example of ADU flows which
      might be protected by the FEC Framework. From the FEC Framework point of
      view, RTP source flows are ADU flows like any other, with the RTP header
      included within the ADU.
</p>
<p>Depending on the FEC Scheme, RTP may also be used as a transport for
      repair packet flows. In this case an FEC Scheme must define an RTP
      Payload Format for the repair data.
</p>
<p>The architecture outlined above is illustrated in the <a class='info' href='#architecturefigure'>Figure&nbsp;1<span> (</span><span class='info'>FEC Framework Architecture</span><span>)</span></a>. In this architecture, two RTP
      instances are shown, for the source and repair data respectively. This
      is because the use of RTP for the source data is separate from and
      independent of the use of RTP for the repair data. The appearance of two
      RTP instances is more natural when you consider that in many FEC codes,
      the repair payload contains repair data calculated across the RTP
      headers of the source packets. Thus a repair packet carried over RTP
      starts with an RTP header of its own which is followed (after the Repair
      Payload ID) by repair data containing bytes which protect the source RTP
      headers (as well as repair data for the source RTP payloads).
</p><br /><hr class="insert" />
<a name="architecturefigure"></a>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
  +--------------------------------------------+
  |                 Application                |
  +--------------------------------------------+
                         |
                         |
                         |
+ - - - - - - - - - - - - - - - - - - - - - - - -+
| +--------------------------------------------+ |
  |            Application Layer               |
| +--------------------------------------------+ |
                       |                  |
| + -- -- -- -- -- -- -- -- -- -- --+     |      |
  |  RTP (optional)                 |     |
| |                                 |     |-Configuration/Coordination
  +- -- -- -- -- -- -- -- -- -- -- -+     |
|                    |                    |      |
                     | ADU flows          |
|                    |                    v      |
  +--------------------------------------------+     +----------------+
| |      FEC Framework (this document)         |&lt;---&gt;|   FEC Scheme   |
  +--------------------------------------------+     +----------------+
|                |               |               |
          Source |        Repair |
|                |               |               |
  +-- -- -- -- --|-- --+ -- -- -- -- -- + -- --+
| |  RTP         |     | RTP processing |      |&lt;--- Optional
  |              |     +-- -- -- |- -- -+      |       - dependent on
| |        +-- -- -- -- -- -- -- |--+          | |       FEC Scheme
  |        |  RTP (de)multiplexing  |          |
| +-- -- -- --- -- -- -- -- -- -- -- -- -- -- -+ |
                       |
| +--------------------------------------------+ |
  |          Transport Layer (e.g. UDP)        |
| +--------------------------------------------+ |
                       |
| +--------------------------------------------+ |
  |                  IP                        |
| +--------------------------------------------+ |
 Content Delivery Protocol
+ - - - - - - - - - - - - - - -  - - - - - - - - +</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;1: FEC Framework Architecture&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>The contents of the transport payload for repair packets is fully
      defined by the FEC Scheme. For a specific FEC Scheme, a means MAY be
      defined for repair data to be carried over RTP, in which case the repair
      packet payload format starts with the RTP header. This corresponds to
      defining an RTP Payload Format for the specific FEC Scheme. Guidelines
      for writers of RTP Payload Formats are provided in <a class='info' href='#RFC2736'>[RFC2736]<span> (</span><span class='info'>Handley, M. and C. Perkins, &ldquo;Guidelines for Writers of RTP Payload Format Specifications,&rdquo; December&nbsp;1999.</span><span>)</span></a>.
</p>
<p>The use of RTP for repair packets is independent of the protocols
      used for source packets: if RTP is used for source packets then repair
      packets may or may not use RTP and vice versa (although it is unlikely
      that there are useful scenarios where non-RTP source flows are protected
      by RTP repair flows). FEC Schemes are expected to recover entire
      transport payloads for recovered source packets in all cases. For
      example if RTP is used for source flows, the FEC Scheme is expected to
      recover the entire UDP payload, including the RTP header.
</p>
<a name="anchor4"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4"></a><h3>4.&nbsp;
Procedural overview</h3>

<a name="anchor5"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.1"></a><h3>4.1.&nbsp;
General</h3>

<p>The mechanism defined in this document does not place any
        restrictions on the Application Data Units which can be protected
        together, except that the Application Data Unit is carried over a
        supported transport protocol (See <a class='info' href='#TransportProtocols'>Section&nbsp;7<span> (</span><span class='info'>Transport Protocols</span><span>)</span></a>). The data may be from multiple
        Source Data Flows that are protected jointly. The FEC framework
        handles the Source Data Flows as a sequence of 'source blocks' each
        consisting of a set of Application Data Units, possibly from multiple
        Source Data Flows which are to be protected together. For example,
        each source block may be constructed from those Application Data Units
        related to a particular segment in time of the flow.
</p>
<p>At the sender, the FEC Framework passes the payloads for a given
        block to the FEC Scheme for FEC encoding. The FEC Scheme performs the
        FEC encoding operation and returns the following information: </p>
<ul class="text">
<li>optionally, FEC Payload IDs for each of the source payloads
            (encoded according to an FEC-Scheme-specific format)
</li>
<li>one or more FEC repair packet payloads
</li>
<li>FEC Payload IDs for each of the repair packet payloads (encoded
            according to an FEC-Scheme-specific format)
</li>
</ul><p>The FEC framework then performs two operations: Firstly, it
        appends the FEC payload IDs, if provided, to each of the Application
        Data Units, and sends the resulting packets, known as 'FEC source
        packets', to the receiver and secondly it places the provided 'FEC
        repair packet payloads' and corresponding 'FEC Repair Payload IDs'
        appropriately to construct 'FEC repair packets' and send them to the
        receiver. Note that FEC repair packets MAY be sent to a different
        multicast group or groups from the source packets.
</p>
<p>This document does not define how the sender determines which
        Application Data Units are included in which source blocks or the
        sending order and timing of FEC source and FEC repair packets. A
        specific Content Delivery Protocol MAY define this mapping or it MAY
        be left as implementation dependent at the sender. However, a CDP
        specification MUST define how a receiver determines a minimum length
        of time that it should wait to receive FEC repair packets for any
        given source block. FEC Schemes MAY define limitations on this
        mapping, such as maximum size of source blocks, but SHOULD NOT attempt
        to define specific mappings. The sequence of operations at the sender
        is described in more detail in <a class='info' href='#senderoperation'>Section&nbsp;4.2<span> (</span><span class='info'>Sender Operation</span><span>)</span></a>.
</p>
<p>At the receiver, original Application Data Units are recovered by
        the FEC Framework directly from any FEC Source Packets received simply
        by removing the Source FEC Payload ID, if present. The receiver also
        passes the contents of the received Application Data Units, plus their
        FEC Payload IDs to the FEC Scheme for possible decoding.
</p>
<p>If any Application Data Units related to a given source block have
        been lost, then the FEC Scheme may perform FEC decoding to recover the
        missing Application Data Units (assuming sufficient FEC Source and FEC
        Repair packets related to that source block have been received).
</p>
<p>Note that the receiver may need to buffer received source packets
        to allow time for the FEC Repair packets to arrive and FEC decoding to
        be performed before some or all of the received or recovered packets
        are passed to the application. If such a buffer is not provided, then
        the application must be able to deal with the severe re-ordering of
        packets that may occur. However, such buffering is Content Delivery
        Protocol and/or implementation-specific and is not specified here. The
        receiver operation is described in more detail in <a class='info' href='#receiveroperation'>Section&nbsp;4.3<span> (</span><span class='info'>Receiver Operation</span><span>)</span></a>
</p>
<p>The FEC Source packets MUST contain information which identifies
        the source block and the position within the source block (in terms
        specific to the FEC Scheme) occupied by the Application Data Unit.
        This information is known as the 'Source FEC Payload ID'. The FEC
        Scheme is responsible for defining and interpreting this information.
        This information MAY be encoded into a specific field within the FEC
        Source packet format defined in this specification, called the
        Explicit Source FEC Payload ID field. The exact contents and format of
        the Explicit Source FEC Payload ID field are defined by the FEC
        Scheme. Alternatively, the FEC Scheme MAY define how the Source FEC
        Payload ID is derived from other fields within the source packets.
        This document defines the way that the Explicit Source FEC Payload ID
        field is appended to source packets to form FEC Source packets.
</p>
<p>The FEC Repair packets MUST contain information which identifies
        the source block and the relationship between the contained repair
        payloads and the original source block. This is known as the 'Repair
        FEC Payload ID'. This information MUST be encoded into a specific
        field, the Repair FEC Payload ID field, the contents and format of
        which are defined by the FEC Scheme.
</p>
<p>The FEC Scheme MAY use different FEC Payload ID field formats for
        FEC Source packets and FEC Repair packets.
</p>
<a name="senderoperation"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.2"></a><h3>4.2.&nbsp;
Sender Operation</h3>

<p>It is assumed that the sender has constructed or received original
        data packets for the session. These may be RTP, RTCP, MIKEY or indeed
        any other type of packet. The following operations, illustrated in
        <a class='info' href='#senderfigure'>Figure&nbsp;2<span> (</span><span class='info'>Sender operation</span><span>)</span></a>, for the case of UDP repair flows
        and <a class='info' href='#senderfigurertp'>Figure&nbsp;3<span> (</span><span class='info'>Sender operation with RTP repair flows</span><span>)</span></a> for the case of RTP repair
        flows, describe a possible way to generate compliant FEC Source packet
        and FEC repair packet streams: </p>
<blockquote class="text">
<p>1. Application Data Units are provided by the application.
</p>
<p>2. A source block is constructed as specified in <a class='info' href='#sourceblock'>Section&nbsp;5.2<span> (</span><span class='info'>Structure of the source block</span><span>)</span></a>.
</p>
<p>3. The source block is passed to the FEC Scheme for FEC
            encoding. The Source FEC Payload ID information of each Source
            packet is determined by the FEC Scheme. If required by the FEC
            Scheme the Source FEC Payload ID is encoded into the Explicit
            Source FEC Payload ID field.
</p>
<p>4. The FEC Scheme performs FEC Encoding, generating repair
            packet payloads from a source block and a Repair FEC Payload ID
            field for each repair payload.
</p>
<p>5. The Explicit Source FEC Payload IDs (if used), Repair FEC
            Payload IDs and repair packet payloads are provided back from the
            FEC Scheme to the FEC Framework.
</p>
<p>6. The FEC Framework constructs FEC Source packets according to
            <a class='info' href='#sourcepackets'>Section&nbsp;5.3<span> (</span><span class='info'>Packet format for FEC Source packets</span><span>)</span></a> and FEC Repair packets
            according to <a class='info' href='#repairpackets'>Section&nbsp;5.4<span> (</span><span class='info'>Packet Format for FEC Repair packets</span><span>)</span></a> using the FEC
            Payload IDs and repair packet payloads provided by the FEC
            Scheme.
</p>
<p>7. The FEC Source and FEC Repair packets are sent using normal
            transport layer procedures. The port(s) and multicast group(s) to
            be used for FEC Repair packets are defined in the FEC Framework
            Configuration Information. The FEC Source packets are sent using
            the same ADU flow identification information as would have been
            used for the original source packets if the FEC Framework were not
            present (for example, in the UDP case, the UDP source and
            destination addresses and ports on the IP datagram carrying the
            Source Packet will be the same whether or not the FEC Framework is
            applied).
</p>
</blockquote>
<br /><hr class="insert" />
<a name="senderfigure"></a>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
+----------------------+
|     Application      |
+----------------------+
           |
           | (1) Application Data Units
           |
           v
+----------------------+                           +------------------+
|    FEC Framework     |                           |                  |
|                      |--------------------------&gt;|   FEC Scheme     |
|(2) Construct source  |   (3) Source Block        |                  |
|    blocks            |                           | (4) FEC Encoding |
|(6) Construct FEC src |&lt;--------------------------|                  |
|    packets and FEC   |                           |                  |
|    repair packets    |(5) Ex src FEC Payload Ids,|                  |
+----------------------+    Repair FEC Payload Ids,+------------------+
           |                Repair symbols
           |
           | (7) FEC Source packets and FEC repair packets
           v
+----------------------+
|   Transport Layer    |
|     (e.g. UDP )      |
+----------------------+
</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;2: Sender operation&nbsp;</b></font><br /></td></tr></table><hr class="insert" />
<br /><hr class="insert" />
<a name="senderfigurertp"></a>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
+----------------------+
|     Application      |
+----------------------+
           |
           | (1) Application Data Units
           v
+----------------------+                           +------------------+
|    FEC Framework     |                           |                  |
|                      |--------------------------&gt;|   FEC Scheme     |
|(2) Construct source  |    (3) Source Block       |                  |
|    blocks            |                           | (4) FEC Encoding |
|(6) Construct FEC src |&lt;--------------------------|                  |
|    packets and FEC   |                           |                  |
|    repair payloads   |(5) Ex src FEC Payload Ids,|                  |
+----------------------+    Repair FEC Payload Ids,+------------------+
    |             |         Repair symbols
    |(7) Source   |
    |             |(7') Repair RTP payloads
    |   + -- -- -- -- -+
    |   |     RTP      |
    |   +-- -- -- -- --+
    v             v
+----------------------+
|   Transport Layer    |
|     (e.g. UDP )      |
+----------------------+
</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;3: Sender operation with RTP repair flows&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<a name="receiveroperation"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.3"></a><h3>4.3.&nbsp;
Receiver Operation</h3>

<p>The following describes a possible receiver algorithm, illustrated
        in <a class='info' href='#receiverfigure'>Figure&nbsp;4<span> (</span><span class='info'>Receiver Operation</span><span>)</span></a> and <a class='info' href='#receiverfigurertp'>Figure&nbsp;5<span> (</span><span class='info'>Receiver Operation</span><span>)</span></a> for the case of RTP repair flows,
        when receiving an FEC source or repair packet: </p>
<blockquote class="text">
<p>1. FEC Source Packets and FEC Repair packets are received and
            passed to the FEC Framework. The type of packet (Source or Repair)
            and the Source Data Flow to which it belongs (in the case of
            source packets) is indicated by the ADU flow information which
            identifies the flow at the transport layer (for example source and
            destination ports and addresses in the case of UDP).
</p>
<p>1a. In the special case that RTP is used for repair packets and
            source and repair packets are multiplexed onto the same UDP flow,
            then RTP demultiplexing is required to demultiplex source and
            repair flows. However, RTP processing is applied only to the
            repair packets at this stage: source packets continue to be
            handled as UDP payloads (i.e. including their RTP headers).
</p>
<p>2. The FEC Framework extracts the Explicit Source FEC Payload
            ID field (if present) from FEC Source Packets and the Repair FEC
            Payload ID from FEC Repair Packets.
</p>
<p>3. The Explicit Source FEC Payload IDs (if present), Repair FEC
            Payload IDs, FEC Source payloads and FEC Repair payloads are
            passed to the FEC Scheme.
</p>
<p>4. The FEC Scheme uses the received FEC Payload IDs (and
            derived FEC Source Payload IDs in the case that the Explicit
            Source FEC Payload ID field is not used) to group source and
            repair packets into source blocks. If at least one source packet
            is missing from a source block, and at least one repair packet has
            been received for the same source block then FEC decoding may be
            performed in order to recover missing source payloads. The FEC
            Scheme determines whether source packets have been lost and
            whether enough data for decoding of any or all of the missing
            source payloads in the source block has been received.
</p>
<p>5. The FEC Scheme returns the Application Data Units to the FEC
            Framework in the form of source blocks containing received and
            decoded Application Data Units and indications of any Application
            Data Units which were missing and could not be decoded.
</p>
<p>6. The FEC Framework passes the received and recovered
            Application Data Units to the application.
</p>
</blockquote><p>Note that the description above defines functionality
        responsibilities but does not imply a specific set of timing
        relationships. For example, ADUs may be provided to the application as
        soon as they are received or recovered (and hence potentially
        out-of-order) or they may be buffered and delivered to the application
        in-order.
</p><br /><hr class="insert" />
<a name="receiverfigure"></a>

<p>
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
+----------------------+
|     Application      |
+----------------------+
           ^
           | (6) Application Data Units
           |
+----------------------+                            +------------------+
|   FEC Framework      |                            |                  |
|                      |&lt;---------------------------|   FEC Scheme     |
|(2)Extract FEC Payload| (5) Application Data Units |                  |
|   IDs and pass IDs &amp; |                            | (4) FEC Decoding |
|   Payloads to FEC    |---------------------------&gt;|                  |
|   Scheme             | (3) Ex src FEC Payload IDs,|                  |
+----------------------+     FEC Repair Payload IDs,+------------------+
           ^                 FEC Source Payloads,
           |                 FEC Repair Payloads
           |
           | (1) FEC Source packets and FEC repair packets
           |
+----------------------+
|   Transport Layer    |
|     (e.g. UDP )      |
+----------------------+</pre></div>
<p>
</p><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;4: Receiver Operation&nbsp;</b></font><br /></td></tr></table><hr class="insert" />
<br /><hr class="insert" />
<a name="receiverfigurertp"></a>

<p>
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
+----------------------+
|     Application      |
+----------------------+
           ^
           | (6) Application Data Units
           |
+----------------------+                            +------------------+
|   FEC Framework      |                            |                  |
|                      |&lt;---------------------------|   FEC Scheme     |
|(2)Extract FEC Payload| (5) Application Data Units |                  |
|   IDs and pass IDs &amp; |                            | (4) FEC Decoding |
|   Payloads to FEC    |---------------------------&gt;|                  |
|   Scheme             | (3) Ex src FEC Payload IDs,|                  |
+----------------------+     FEC Repair Payload IDs,+------------------+
    ^             ^          FEC Source Payloads,
    |             |          FEC Repair Payloads
    |Source pkts  |
    |             |(1a) FEC repair payloads
+-- |- -- -- -- -- -- -+
|RTP| | RTP processing |
|   | +-- -- -- --|-- -+
| +-- -- -- -- -- |--+ |
| | RTP demux        | |
+-- -- -- -- -- -- -- -+
           |  (1) FEC Source packets and FEC repair packets
+----------------------+
|   Transport Layer    |
|     (e.g. UDP )      |
+----------------------+</pre></div>
<p>
</p><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;5: Receiver Operation&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>Note that the above procedure may result in a situation in which
        not all ADUs are recovered.
</p>
<p>Source packets which are correctly received and those which are
        reconstructed MAY be delivered to the application out of order and in
        a different order from the order of arrival at the receiver.
        Alternatively, buffering and packet re-ordering MAY be applied to
        re-order received and reconstructed source packets into the order they
        were placed into the source block, if that is necessary according to
        the application.
</p>
<a name="anchor6"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5"></a><h3>5.&nbsp;
Protocol Specification</h3>

<a name="anchor7"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.1"></a><h3>5.1.&nbsp;
General</h3>

<p>This section specifies the protocol elements for the FEC Framework.
        Three components of the protocol are defined in this document and are
        described in the following sections: </p>
<blockquote class="text">
<p>1. Construction of a source block from Application Data Units.
            The FEC code will be applied to this source block to produce the
            repair payloads.
</p>
<p>2. A format for packets containing source data.
</p>
<p>3. A format for packets containing repair data.
</p>
</blockquote><p>The operation of the FEC Framework is governed by certain FEC
        Framework Configuration Information. This configuration information is
        also defined in this section. A complete protocol specification that
        uses this framework MUST specify the means to determine and
        communicate this information between sender and receiver.
</p>
<a name="sourceblock"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.2"></a><h3>5.2.&nbsp;
Structure of the source block</h3>

<p>The FEC Framework and FEC Scheme exchange Application Data Units in
        the form of source blocks. A source block is generated by the FEC
        Framework from an ordered sequence of Application Data Units. The
        allocation of Application Data Units to blocks is dependent on the
        application. Note that some Application Data Units may not be included
        in any block. Each Source Block provided to the FEC scheme consists of
        an ordered sequence of Application Data Units where the following
        information is provided for each ADU: </p>
<ul class="text">
<li>A description of the Source Data Flow with which the
            Application Data Unit is associated (See 6.5)
</li>
<li>The Application Data Unit itself
</li>
<li>The length of the Application Data Unit
</li>
</ul>

<p>
</p>
<a name="sourcepackets"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.3"></a><h3>5.3.&nbsp;
Packet format for FEC Source packets</h3>

<p>The packet format for FEC Source packets MUST be used to transport
        the payload of an original source packet. As depicted in <a class='info' href='#sourcepacketfigure'>Figure&nbsp;6<span> (</span><span class='info'>Structure of the FEC packet format for FEC Source packets</span><span>)</span></a>, it consists of the original
        packet, optionally followed by the Explicit Source FEC Payload ID
        field. The FEC Scheme determines whether the Explicit Source FEC
        Payload ID field is required. This determination is specific to each
        ADU flow.
</p><br /><hr class="insert" />
<a name="sourcepacketfigure"></a>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
+------------------------------------+
|             IP header              |
+------------------------------------+
|          Transport header          |
+------------------------------------+
|        Application Data Unit       |
+------------------------------------+
|   Explicit Source FEC Payload ID   |
+------------------------------------+
</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;6: Structure of the FEC packet format for FEC Source packets&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>The FEC Source packets MUST be sent using the same ADU flow as
        would have been used for the original source packets if the FEC
        Framework were not present. The transport payload of the FEC Source
        packet MUST consist of the Application Data Unit followed by the
        Explicit Source FEC Payload ID field, if required.
</p>
<p>The Explicit Source FEC Payload ID field contains information
        required to associate the source packet with a source block and for
        the operation of the FEC algorithm and is defined by the FEC Scheme.
        The format of the Source FEC Payload ID field is defined by the FEC
        Scheme. Note that in the case that the FEC Scheme or CDP defines a
        means to derive the Source FEC Payload ID from other information in
        the packet (for example a sequence number used by the application
        protocol), then the Source FEC Payload ID field is not included in the
        packet. In this case the original source packet and FEC Source Packet
        are identical.
</p>
<p>In applications where avoidance of IP packet fragmentation is a
        goal, Content Delivery Protocols SHOULD consider the Explicit Source
        FEC Payload ID size when determining the size of Application Data
        Units that will be delivered using the FEC Framework. This is because
        the addition of the Explicit Source FEC Payload ID increases the
        packet length.
</p>
<p>Note: The Explicit Source FEC Payload ID is placed at the end of
        the packet so that in the case that Robust Header Compression <a class='info' href='#RFC3095'>[RFC3095]<span> (</span><span class='info'>Bormann, C., Burmeister, C., Degermark, M., Fukushima, H., Hannu, H., Jonsson, L-E., Hakenberg, R., Koren, T., Le, K., Liu, Z., Martensson, A., Miyazaki, A., Svanbro, K., Wiebke, T., Yoshimura, T., and H. Zheng, &ldquo;RObust Header Compression (ROHC): Framework and four profiles: RTP, UDP, ESP, and uncompressed,&rdquo; July&nbsp;2001.</span><span>)</span></a> or other header compression mechanisms are
        used and in the case that a ROHC profile is defined for the protocol
        carried within the transport payload (for example RTP), then ROHC will
        still be applied for the FEC Source packets. Applications that may be
        used with this Framework should consider that FEC Schemes may add this
        Explicit Source FEC Payload ID and thereby increase the packet
        size.
</p>
<p>In many applications, support for Forward Error Correction is added
        to a pre-existing protocol and in this case use of the Explicit Source
        FEC Payload ID may break backwards compatibility, since source packets
        are modified.
</p>
<a name="anchor8"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.3.1"></a><h3>5.3.1.&nbsp;
Generic Explicit Source FEC Payload Id</h3>

<p>In order to apply FEC protection using multiple FEC Schemes to a
          single source flow all schemes must use the same Explicit Source FEC
          Payload Id format. In order to enable this, it is RECOMMENDED that
          FEC Schemes support the Generic Explicit Source FEC Payload Id
          format described below.
</p>
<p>The Generic Explicit Source FEC Payload Id has length of 2 bytes
          and consists of an unsigned packet sequence number in network byte
          order. The allocation of sequence numbers to packets is independent
          of any FEC Scheme and of the Source Block construction, except that
          the use of this sequence number places a constraint on source block
          construction. Source packets within a given source block MUST have
          consecutive sequence numbers (where consecutive includes wrap-around
          from the maximum value which can be represented in 2 bytes - 65535 -
          to 0). Sequence numbers SHOULD NOT be reused until all values in the
          sequence number space have been used.
</p>
<a name="repairpackets"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.4"></a><h3>5.4.&nbsp;
Packet Format for FEC Repair packets</h3>

<p>The packet format for FEC Repair packets is shown in <a class='info' href='#repairpacketfigure'>Figure&nbsp;7<span> (</span><span class='info'>Packet format for repair packets</span><span>)</span></a>. The transport payload consists of
        a Repair FEC Payload ID field followed by repair data generated in the
        FEC encoding process. <br /><hr class="insert" />
<a name="repairpacketfigure"></a>
</p>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
+------------------------------------+
|             IP header              |
+------------------------------------+
|          Transport header          |
+------------------------------------+
|       Repair FEC Payload ID        |
+------------------------------------+
|          Repair Symbols            |
+------------------------------------+
</pre></div><p>
<table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;7: Packet format for repair packets&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

</p>
<p>The Repair FEC Payload ID field contains information required for
        the operation of the FEC algorithm at the receiver. This information
        is defined by the FEC Scheme. The format of the Repair FEC Payload ID
        field is defined by the FEC Scheme.
</p>
<a name="anchor9"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.4.1"></a><h3>5.4.1.&nbsp;
Packet Format for FEC Repair packets over RTP</h3>

<p>For FEC Schemes which specify the use of RTP for repair packets,
          the packet format for repair packets includes an RTP header as shown
          in <a class='info' href='#repairpacketfigureRTP'>Figure&nbsp;8<span> (</span><span class='info'>Packet format for repair packets</span><span>)</span></a>.
</p>
<p><br /><hr class="insert" />
<a name="repairpacketfigureRTP"></a>
</p>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
+------------------------------------+
|             IP header              |
+------------------------------------+
|      Transport header (UDP)        |
+------------------------------------+
|             RTP Header             |
+------------------------------------+
|       Repair FEC Payload ID        |
+------------------------------------+
|          Repair Symbols            |
+------------------------------------+
</pre></div><p>
<table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;8: Packet format for repair packets&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

</p>
<a name="config"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.5"></a><h3>5.5.&nbsp;
FEC Framework Configuration Information</h3>

<p>The FEC Framework Configuration Information is information that the
        FEC Framework needs in order to apply FEC protection to the ADU flows.
        A complete Content Delivery Protocol specification that uses the
        framework specified here MUST include details of how this information
        is derived and communicated between sender and receiver.
</p>
<p>The FEC Framework Configuration Information includes identification
        of the set of Source Data Flows. For example, in the case of UDP, each
        Source Data Flow is uniquely identified by a tuple { Source IP
        Address, Destination IP Address, Source UDP port, Destination UDP port
        }. Note that in some applications some of these fields may contain
        wildcards, so that the flow is identified by a subset of the fields
        and in particular in many applications the limited tuple { Destination
        IP Address, Destination UDP port } is sufficient.
</p>
<p>A single instance of the FEC Framework provides FEC protection for
        packets of the specified set of Source Data Flows, by means of one or
        more packet flows consisting of repair packets. The FEC Framework
        Configuration Information includes, for each instance of the FEC
        Framework: </p>
<blockquote class="text">
<p>1. Identification of the packet flow(s) carrying FEC Repair
            packets, known as the FEC repair flow(s).
</p>
<p>2. For each Source Data Flow protected by the FEC repair
            flow(s): </p>
<blockquote class="text">
<p>a. Definition of the Source Data Flow carrying source
                packets (for example, by means of a tuple as described above
                for UDP).
</p>
<p>b. An integer identifier for this Source Data Flow. This
                identifier MUST be unique amongst all Source Data Flows which
                are protected by the same FEC repair flow.
</p>
</blockquote>

<p>3. The FEC Encoding ID, identifying the FEC Scheme
</p>
<p>4. The length of the Explicit Source FEC Payload Id, in
            bytes
</p>
<p>5. Zero or more FEC-Scheme-specific information elements, each
            consisting of a name and a value where the valid element names and
            value ranges are defined by the FEC Scheme
</p>
</blockquote>

<p>Multiple instances of the FEC Framework, with separate and
        independent FEC Framework Configuration Information, may be present at
        a sender or receiver. A single instance of the FEC Framework protects
        packets of the Source Data Flows identified in (2) above i.e. all
        packets sent on those flows MUST be FEC Source packets as defined in
        <a class='info' href='#sourcepackets'>Section&nbsp;5.3<span> (</span><span class='info'>Packet format for FEC Source packets</span><span>)</span></a>. A single Source Data Flow may be
        protected by multiple instances of the FEC Framework.
</p>
<p>The integer flow identifier identified in 2(b) is a "shorthand" to
        identify source flows between the FEC Framework and the FEC Scheme.
        The reason for defining this as an integer, and including it in the
        FEC Framework Configuration Information is so that the FEC Scheme at
        the sender and receiver may use it to identify the source flow with
        which a recovered packet is associated. The integer flow identifier
        may therefore take the place of the complete flow description (e.g.
        UDP 4-tuple).
</p>
<p>Whether and how this flow identifier is used is defined by the FEC
        Scheme. Since source packets are directly associated with a flow by
        virtue of their packet headers, this identifier need not be carried in
        source packets. Since repair packets may provide protection for
        multiple source flows, repair packets would either not carry the
        identifier at all or may carry multiple identifiers. However, in any
        case, the flow identifier associated with a particular source packet
        may be recovered from the repair packets as part of an FEC decoding
        operation. Integer flow identifiers SHOULD be allocated starting from
        zero and increasing by one for each flow.
</p>
<p>A single FEC repair flow provides repair packets for a single
        instance of the FEC Framework. Other packets MUST NOT be sent within
        this flow i.e. all packets in the FEC repair flow MUST be FEC repair
        packets as defined in <a class='info' href='#repairpackets'>Section&nbsp;5.4<span> (</span><span class='info'>Packet Format for FEC Repair packets</span><span>)</span></a> and MUST
        relate to the same FEC Framework instance.
</p>
<p>In the case that RTP is used for repair packets, the identification
        of the repair packet flow MAY also include the RTP Payload Type to be
        used for repair packets.
</p>
<p>FEC Scheme-specific information elements MAY be encoded into a text
        string for transport within Content Delivery Protocols. See Section
        4.5 of <a class='info' href='#I-D.ietf-fecframe-sdp-elements'>[I&#8209;D.ietf&#8209;fecframe&#8209;sdp&#8209;elements]<span> (</span><span class='info'>Begen, A., &ldquo;Session Description Protocol (SDP) Elements for FEC Framework,&rdquo; August&nbsp;2010.</span><span>)</span></a> for the
        ABNF <a class='info' href='#RFC5234'>[RFC5234]<span> (</span><span class='info'>Crocker, D. and P. Overell, &ldquo;Augmented BNF for Syntax Specifications: ABNF,&rdquo; January&nbsp;2008.</span><span>)</span></a> syntax.
</p>
<a name="fecscheme"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.6"></a><h3>5.6.&nbsp;
FEC Scheme requirements</h3>

<p>In order to be used with this framework, an FEC Scheme MUST be
        capable of processing data arranged into blocks of Application Data
        Units (source blocks).
</p>
<p>A specification for a new FEC scheme MUST include the following
        things: </p>
<ol class="text">
<li>The FEC Encoding ID value that uniquely identifies the FEC
            scheme. This value MUST be registered with IANA as described in
            <a class='info' href='#iana'>Section&nbsp;10<span> (</span><span class='info'>IANA Considerations</span><span>)</span></a>.
</li>
<li>The type, semantics and encoding format of the Repair FEC
            Payload ID.
</li>
<li>The name, type, semantics and text value encoding rules for
            zero or more FEC Scheme-specific FEC Framework Configuration
            Information elements. Names must conform to the <tt>name</tt> production and values encodings to the
            <tt>value</tt> production defined in <a class='info' href='#config'>Section&nbsp;5.5<span> (</span><span class='info'>FEC Framework Configuration Information</span><span>)</span></a>
</li>
<li>A full specification of the FEC code. <br />
<br />
This specification MUST precisely define the
            valid FEC-Scheme-Specific FEC Framework Configuration Information
            values, the valid FEC Payload ID values and the valid packet
            payload sizes (where packet payload refers to the space within a
            packet dedicated to carrying encoding symbol bytes). <br />
<br />
Furthermore, given a source block as defined in
            <a class='info' href='#sourceblock'>Section&nbsp;5.2<span> (</span><span class='info'>Structure of the source block</span><span>)</span></a>, valid values of the
            FEC-Scheme-Specific FEC Framework Configuration Information, a
            valid Repair FEC Payload ID value and a valid packet payload size,
            the specification MUST uniquely define the values of the encoding
            symbol bytes to be included in the repair packet payload of a
            packet with the given Repair FEC Payload ID value.<br />
<br />
A common and simple way to specify the FEC code
            to the required level of detail is to provide a precise
            specification of an encoding algorithm which, given a source
            block, valid values of the FEC-Scheme-Specific FEC Framework
            Configuration Information, a valid Repair FEC Payload ID value and
            a valid packet payload size as input produces the exact value of
            the encoding symbol bytes as output.
</li>
<li>A description of practical encoding and decoding
            algorithms.<br />
<br />
This description need not be
            to the same level of detail as for the encoding above, however it
            must be sufficient to demonstrate that encoding and decoding of
            the code is both possible and practical.
</li>
</ol>

<p>FEC scheme specifications MAY additionally define the following:
        </p>
<ol class="text">
<li>Type, semantics and encoding format of an Explicit Source FEC
            Payload ID.
</li>
</ol>

<p>Whenever an FEC scheme specification defines an 'encoding format'
        for an element, this must be defined in terms of a sequence of bytes
        which can be embedded within a protocol. The length of the encoding
        format MUST either be fixed or it must be possible to derive the
        length from examining the encoded bytes themselves. For example, the
        initial bytes may include some kind of length indication.
</p>
<p>FEC scheme specifications SHOULD use the terminology defined in
        this document and SHOULD follow the following format: </p>
<blockquote class="text"><dl>
<dt>1. Introduction</dt>
<dd>&lt;describe the use-cases addressed
            by this FEC scheme&gt;<br />

</dd>
<dt>2. Formats and Codes</dt>
<dd>
<blockquote class="text"><dl>
<dt>2.1 Source FEC Payload ID(s)</dt>
<dd>&lt;Either, define
                the type and format of the Explicit Source FEC Payload ID, or
                define how Source FEC Payload ID information is derived from
                source packets&gt;<br />

</dd>
<dt>2.2 Repair FEC Payload Id</dt>
<dd>&lt;Define the type
                and format of the Repair FEC Payload ID&gt;
</dd>
<dt>2.3 FEC Framework Configuration Information</dt>
<dd>&lt;Define
                the names, types and text value encoding formats of the FEC
                Scheme-specific FEC Framework configuration information
                elements&gt;
</dd>
</dl></blockquote>
</dd>
<dt>3. Procedures</dt>
<dd>&lt;describe any procedures which are
            specific to this FEC scheme, in particular derivation and
            interpretation of the fields in the FEC Payload ID and FEC
            Scheme-specific FEC Framework configuration information.&gt;
</dd>
<dt>4. FEC code specification</dt>
<dd>&lt;provide a complete
            specification of the FEC Code&gt;
</dd>
</dl></blockquote>

<p>Specifications MAY include additional sections, for example,
        examples.
</p>
<p>Each FEC scheme MUST be specified independently of all other FEC
        schemes; for example, in a separate specification or a completely
        independent section of larger specification (except, of course, a
        specification of one FEC Scheme may include portions of another by
        reference).
</p>
<p>Where an RTP Payload Format is defined for repair data for a
        specific FEC Scheme, the RTP Payload Format and the FEC Scheme MAY be
        specified within the same document.
</p>
<a name="anchor10"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6"></a><h3>6.&nbsp;
Feedback</h3>

<p>Many applications require some kind of feedback on transport
      performance: how much data arrived at the receiver, at what rate, when
      etc. When FEC is added to such applications, feedback mechanisms may
      also need to be enhanced to report on the performance of the FEC (for
      example how much lost data was recovered by the FEC).
</p>
<p>When used to provide instrumentation for engineering purposes, it is
      important to remember that FEC is generally applied to relatively small
      blocks of data (in the sense that each block is transmitted over a
      relatively small period of time) and so feedback information averaged
      over longer periods of time than the FEC block transmission time will
      likely not provide sufficient information for engineering purposes. For
      example see <a class='info' href='#RFC5725'>[RFC5725]<span> (</span><span class='info'>Begen, A., Hsu, D., and M. Lague, &ldquo;Post-Repair Loss RLE Report Block Type for RTP Control Protocol (RTCP) Extended Reports (XRs),&rdquo; February&nbsp;2010.</span><span>)</span></a>.
</p>
<p>Applications which used feedback for congestion control purposes MUST
      calculate such feedback on the basis of packets received before FEC
      recovery is applied. If this requirement conflicts with other uses of
      the feedback information then the application MUST be enhanced to
      support both information calculated pre- and post- FEC recovery. This is
      to ensure that congestion control mechanisms operate correctly based on
      congestion indications received from the network, rather than on
      post-FEC recovery information which would give an inaccurate picture of
      congestion conditions.
</p>
<p>New applications which require such feedback SHOULD use RTP/RTCP
      <a class='info' href='#RFC3550'>[RFC3550]<span> (</span><span class='info'>Schulzrinne, H., Casner, S., Frederick, R., and V. Jacobson, &ldquo;RTP: A Transport Protocol for Real-Time Applications,&rdquo; July&nbsp;2003.</span><span>)</span></a>.
</p>
<a name="TransportProtocols"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7"></a><h3>7.&nbsp;
Transport Protocols</h3>

<p>This framework is intended to be used to define Content Delivery
      Protocols which operate over transport protocols which provide an
      unreliable datagram service, including in particular the User Datagram
      Protocol (UDP) and the Datagram Congestion Control Protocol (DCCP).
</p>
<a name="anchor11"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.8"></a><h3>8.&nbsp;
Congestion Control</h3>

<p>This section starts with a informative section on the motivation of
      the normative requirements for congestion control, which are spelled out
      in <a class='info' href='#normativecongestion'>Section&nbsp;8.1<span> (</span><span class='info'>Normative requirements</span><span>)</span></a>. </p>
<blockquote class="text">
<p>Informative Note: The enforcement of Congestion Control (CC)
          principles has gained a lot of momentum in the IETF over the recent
          years. While the need of CC over the open Internet is unquestioned,
          and the goal of TCP friendliness is generally agreed for most (but
          not all) applications, the subject of congestion detection and
          measurement in heterogeneous networks can hardly be considered as
          solved. Most congestion control algorithms detect and measure
          congestion by taking (primarily or exclusively) the packet loss rate
          into account. This appears to be inappropriate in environments where
          a large percentage of the packet losses are the result of link-layer
          errors and independent of the network load. Note that such
          environments exist in the "open Internet", as well as in "closed" IP
          based networks. An example for the former would be the use of
          IP/UDP/RTP based streaming from an Internet-connected streaming
          server to a device attached to the Internet using cellular
          technology.
</p>
<p>The authors of this draft are primarily interested in
          applications where the application reliability requirements and
          end-to-end reliability of the network differ, such that it warrants
          higher layer protection of the packet stream - for example due to
          the presence of unreliable links in the end-to-end path - and where
          real-time, scalability or other constraints prohibit the use of
          higher layer (transport or application) feedback. A typical example
          for such applications is multicast and broadcast streaming or
          multimedia transmission over heterogeneous networks. In other cases,
          application reliability requirements may be so high that the
          required end-to-end reliability is difficult to achieve even over
          wired networks. Furthermore the end-to-end network reliability may
          not be known in advance.
</p>
<p>This FEC framework is not proposed, nor intended, as a QoS
          enhancement tool to combat losses resulting from highly congested
          networks. It should not be used for such purposes.
</p>
<p>In order to prevent such mis-use, one approach would be to leave
          standardisation to bodies most concerned with the problem described
          above. However, the IETF defines base standards used by several
          bodies, including DVB, 3GPP, 3GPP2, all of which appear to share the
          environment and the problem described.
</p>
<p>Another approach would be to write a clear applicability
          statement - for example restricting use of the framework to networks
          with wireless links. However, there may be applications where the
          use of FEC may be justified to combat congestion-induced packet
          losses - particularly in lightly loaded networks, where congestion
          is the result of relatively rare random peaks in instantaneous
          traffic load - thereby intentionally violating congestion control
          principles. One possible example for such an application could be a
          no-matter-what, brute-force FEC protection of traffic generated as
          an emergency signal.
</p>
<p>We propose a third approach, which is to require at a minimum
          that the use of this framework with any given application, in any
          given environment, does not cause congestion issues which the
          application alone would not itself cause i.e. the use of this
          framework must not make things worse.
</p>
<p>Taking above considerations into account, <a class='info' href='#normativecongestion'>Section&nbsp;8.1<span> (</span><span class='info'>Normative requirements</span><span>)</span></a> specifies a small set of
          constraints for the FEC, which are mandatory for all senders
          compliant with this FEC framework. Further restrictions may be
          imposed for certain Content Delivery Protocols. In this it follows
          the spirit of the congestion control section of RTP and its
          Audio-Visual Profile (RFC3550/STD64 and RFC3551/STD65).
</p>
<p>One of the constraints effectively limits the bandwidth for the
          FEC protected packet stream to be no more than roughly twice as high
          as the original, non-FEC protected packet stream. This disallows the
          (static or dynamic) use of excessively strong FEC to combat high
          packet loss rates, which may otherwise be chosen by naively
          implemented dynamic FEC-strength selection mechanisms. We
          acknowledge that there may be a few exotic applications, e.g. IP
          traffic from space-based senders, or senders in certain hardened
          military devices, which would warrant a higher FEC strength.
          However, in this specification we give preference to the overall
          stability and network friendliness of the average application, and
          for those a factor of 2 appears to be appropriate.
</p>
<p>A second constraint requires that the FEC protected packet stream
          be in compliance with the congestion control in use for the
          application and network in question.
</p>
</blockquote>

<a name="normativecongestion"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.8.1"></a><h3>8.1.&nbsp;
Normative requirements</h3>

<p>The bandwidth of FEC Repair packet flows MUST NOT exceed the
        bandwidth of the source packet flows being protected. In addition,
        whenever the source packet flow bandwidth is adapted due to the
        operation of congestion control mechanisms, the FEC repair packet flow
        bandwidth MUST be similarly adapted.
</p>
<a name="anchor12"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.9"></a><h3>9.&nbsp;
Security Considerations</h3>

<p>The application of FEC protection to a stream does not provide any
      kind of security protection.
</p>
<p>If security services are required for the stream, then they MUST
      either be applied to the original source data before FEC protection is
      applied, or to both the source and repair data, after FEC protection has
      been applied.
</p>
<p>If integrity protection is applied to source packets before FEC
      protection is applied, and no further integrity protection is applied to
      repair packets, then a denial of service attack is possible if an
      attacker is in a position to inject fake repair transport payloads. If
      received by a receiver, such fake repair transport payloads could cause
      incorrect FEC decoding resulting in incorrect Application Data Units
      being passed up to the application protocol. A similar attack may be
      possible if an attacker is in a position to inject fake FEC Framework
      Configuration Information or fake FEC Payload IDs. Such incorrect
      decoded Application Data Units would then be detected by the source
      integrity protection and discarded, resulting in partial or complete
      denial of service. Therefore, in such environments, integrity protection
      MUST also be applied to the FEC repair transport payloads, FEC Framework
      Configuration Information and FEC Payload IDs, for example using IPsec
      to integrity protect all packets. Receivers MUST also verify the
      integrity of source symbols before including the source symbols into the
      source block for FEC purposes.
</p>
<p>It is possible that multiple streams with different confidentiality
      requirements (for example, the streams may be visible to different sets
      of users) can be FEC protected by a single repair stream. This scenario
      is not recommended, since resources will be used to distribute and FEC
      decode encrypted data which cannot then be decrypted by at least some
      receivers. However, in this scenario, confidentiality protection MUST be
      applied before FEC encoding of the streams, otherwise repair transport
      payload may be used by a receiver to decode unencrypted versions of
      source streams which they do not have permissions to view.
</p>
<a name="iana"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.10"></a><h3>10.&nbsp;
IANA Considerations</h3>

<p>FEC Schemes for use with this framework may be identified in
      protocols using FEC Encoding IDs. Values of FEC Encoding IDs are subject
      to IANA registration. They are in the registry named "FEC Framework
      (FECFRAME) FEC Encoding IDs" located at time of publication at
      &lt;tbd&gt;.
</p>
<p>The values that can be assigned within the FEC Framework (FECFRAME)
      FEC Encoding ID registry are numeric indexes in the range [0, 255],
      boundaries included. Assignment requests are granted on a "IETF
      Consensus" basis as defined in<a class='info' href='#RFC5226'>[RFC5226]<span> (</span><span class='info'>Narten, T. and H. Alvestrand, &ldquo;Guidelines for Writing an IANA Considerations Section in RFCs,&rdquo; May&nbsp;2008.</span><span>)</span></a> . <a class='info' href='#fecscheme'>Section&nbsp;5.6<span> (</span><span class='info'>FEC Scheme requirements</span><span>)</span></a> defines explicit requirements that documents
      defining new FEC Encoding IDs should meet.
</p>
<a name="anchor13"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.11"></a><h3>11.&nbsp;
Acknowledgments</h3>

<p>This document is based in part on <a class='info' href='#I-D.watson-tsvwg-fec-sf'>[I&#8209;D.watson&#8209;tsvwg&#8209;fec&#8209;sf]<span> (</span><span class='info'>Watson, M., &ldquo;Forward Error Correction (FEC) Streaming Framework,&rdquo; July&nbsp;2005.</span><span>)</span></a> and so thanks are due to the
      additional authors of that document, Mike Luby, Magnus Westerlund and
      Stephan Wenger. That document was in turn based on the FEC streaming
      protocol defined by 3GPP in <a class='info' href='#MBMSTS'>[MBMSTS]<span> (</span><span class='info'>3GPP, &ldquo;Multimedia Broadcast/Multicast Service (MBMS); Protocols and           codecs,&rdquo; April&nbsp;2005.</span><span>)</span></a> and thus
      thanks are also due to the participants in 3GPP TSG SA working group 4.
      Further thanks are due to the members of the FECFRAME working group for
      their comments and review.
</p>
<a name="rfc.references"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.12"></a><h3>12.&nbsp;
References</h3>

<a name="rfc.references1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>12.1.&nbsp;Normative references</h3>
<table width="99%" border="0">
<tr><td class="author-text" valign="top"><a name="RFC2119">[RFC2119]</a></td>
<td class="author-text"><a href="mailto:sob@harvard.edu">Bradner, S.</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>,&rdquo; BCP&nbsp;14, RFC&nbsp;2119, March&nbsp;1997 (<a href="http://www.rfc-editor.org/rfc/rfc2119.txt">TXT</a>, <a href="http://xml.resource.org/public/rfc/html/rfc2119.html">HTML</a>, <a href="http://xml.resource.org/public/rfc/xml/rfc2119.xml">XML</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC3095">[RFC3095]</a></td>
<td class="author-text">Bormann, C., Burmeister, C., Degermark, M., Fukushima, H., Hannu, H., Jonsson, L-E., Hakenberg, R., Koren, T., Le, K., Liu, Z., Martensson, A., Miyazaki, A., Svanbro, K., Wiebke, T., Yoshimura, T., and H. Zheng, &ldquo;<a href="http://tools.ietf.org/html/rfc3095">RObust Header Compression (ROHC): Framework and four profiles: RTP, UDP, ESP, and uncompressed</a>,&rdquo; RFC&nbsp;3095, July&nbsp;2001 (<a href="http://www.rfc-editor.org/rfc/rfc3095.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC5052">[RFC5052]</a></td>
<td class="author-text">Watson, M., Luby, M., and L. Vicisano, &ldquo;<a href="http://tools.ietf.org/html/rfc5052">Forward Error Correction (FEC) Building Block</a>,&rdquo; RFC&nbsp;5052, August&nbsp;2007 (<a href="http://www.rfc-editor.org/rfc/rfc5052.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC3550">[RFC3550]</a></td>
<td class="author-text">Schulzrinne, H., Casner, S., Frederick, R., and V. Jacobson, &ldquo;<a href="http://tools.ietf.org/html/rfc3550">RTP: A Transport Protocol for Real-Time Applications</a>,&rdquo; STD&nbsp;64, RFC&nbsp;3550, July&nbsp;2003 (<a href="http://www.rfc-editor.org/rfc/rfc3550.txt">TXT</a>, <a href="http://www.rfc-editor.org/rfc/rfc3550.ps">PS</a>, <a href="http://www.rfc-editor.org/rfc/rfc3550.pdf">PDF</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC5226">[RFC5226]</a></td>
<td class="author-text">Narten, T. and H. Alvestrand, &ldquo;<a href="http://tools.ietf.org/html/rfc5226">Guidelines for Writing an IANA Considerations Section in RFCs</a>,&rdquo; BCP&nbsp;26, RFC&nbsp;5226, May&nbsp;2008 (<a href="http://www.rfc-editor.org/rfc/rfc5226.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC5234">[RFC5234]</a></td>
<td class="author-text">Crocker, D. and P. Overell, &ldquo;<a href="http://tools.ietf.org/html/rfc5234">Augmented BNF for Syntax Specifications: ABNF</a>,&rdquo; STD&nbsp;68, RFC&nbsp;5234, January&nbsp;2008 (<a href="http://www.rfc-editor.org/rfc/rfc5234.txt">TXT</a>).</td></tr>
</table>

<a name="rfc.references2"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>12.2.&nbsp;Informative references</h3>
<table width="99%" border="0">
<tr><td class="author-text" valign="top"><a name="I-D.watson-tsvwg-fec-sf">[I-D.watson-tsvwg-fec-sf]</a></td>
<td class="author-text">Watson, M., &ldquo;<a href="http://www.ietf.org/internet-drafts/draft-watson-tsvwg-fec-sf-00.txt">Forward Error Correction (FEC) Streaming Framework</a>,&rdquo; draft-watson-tsvwg-fec-sf-00 (work in progress), July&nbsp;2005 (<a href="http://www.ietf.org/internet-drafts/draft-watson-tsvwg-fec-sf-00.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC5725">[RFC5725]</a></td>
<td class="author-text">Begen, A., Hsu, D., and M. Lague, &ldquo;<a href="http://tools.ietf.org/html/rfc5725">Post-Repair Loss RLE Report Block Type for RTP Control Protocol (RTCP) Extended Reports (XRs)</a>,&rdquo; RFC&nbsp;5725, February&nbsp;2010 (<a href="http://www.rfc-editor.org/rfc/rfc5725.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4588">[RFC4588]</a></td>
<td class="author-text">Rey, J., Leon, D., Miyazaki, A., Varsa, V., and R. Hakenberg, &ldquo;<a href="http://tools.ietf.org/html/rfc4588">RTP Retransmission Payload Format</a>,&rdquo; RFC&nbsp;4588, July&nbsp;2006 (<a href="http://www.rfc-editor.org/rfc/rfc4588.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC2736">[RFC2736]</a></td>
<td class="author-text"><a href="mailto:mjh@aciri.org">Handley, M.</a> and <a href="mailto:C.Perkins@cs.ucl.ac.uk">C. Perkins</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc2736">Guidelines for Writers of RTP Payload Format Specifications</a>,&rdquo; BCP&nbsp;36, RFC&nbsp;2736, December&nbsp;1999 (<a href="http://www.rfc-editor.org/rfc/rfc2736.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="I-D.ietf-fecframe-sdp-elements">[I-D.ietf-fecframe-sdp-elements]</a></td>
<td class="author-text">Begen, A., &ldquo;<a href="http://www.ietf.org/internet-drafts/draft-ietf-fecframe-sdp-elements-08.txt">Session Description Protocol (SDP) Elements for FEC Framework</a>,&rdquo; draft-ietf-fecframe-sdp-elements-08 (work in progress), August&nbsp;2010 (<a href="http://www.ietf.org/internet-drafts/draft-ietf-fecframe-sdp-elements-08.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="MBMSTS">[MBMSTS]</a></td>
<td class="author-text">3GPP, &ldquo;<a href="http://www.3gpp.org/ftp/Specs/html-info/26346.htm">Multimedia Broadcast/Multicast Service (MBMS); Protocols and
          codecs</a>,&rdquo; 3GPP TS&nbsp;26.346, April&nbsp;2005.</td></tr>
</table>

<a name="rfc.authors"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>Author's Address</h3>
<table width="99%" border="0" cellpadding="0" cellspacing="0">
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Mark Watson</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Netflix, Inc.</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">100 Winchester Circle</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Los Gatos, CA, CA  95032</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">U.S.A.</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:watsonm@netflix.com">watsonm@netflix.com</a></td></tr>
</table>
</body></html>
