TAC_PLUS_UNENCRYPTED_FLAG == 0x0

   In this case, the packet body is encrypted by XOR-ing it byte-wise
   with a pseudo random pad.


   ENCRYPTED {data} == data ^ pseudo_pad


   The pad is generated by concatenating a series of MD5 hashes (each 16
   bytes long) and truncating it to the length of the input data.

   Whenever used in this document, MD5 refers to the "RSA Data Security,
   Inc. MD5 Message-Digest Algorithm" as specified in [3].


pseudo_pad = {MD5_1 [,MD5_2 [ ... ,MD5_n]]} truncated to len(data)



MD5_1 = MD5{session_id, key, version, seq_no}

MD5_2 = MD5{session_id, key, version, seq_no, MD5_1}

    ....

MD5_n = MD5{session_id, key, version, seq_no, MD5_n-1}


TAC_PLUS_UNENCRYPTED_FLAG == 0x1

   In this case, the entire packet body is in cleartext. Encryption and
   decryption are null operations. This method should only be used for
   debugging. It does not provide data protection or authentication and
   is highly susceptible to packet spoofing. Implementing this encryp-
   tion method is optional.

   NOTE: implementations should take care not to skip decryption simply
   because an incoming packet indicates that it is not encrypted.

   After a packet body is decrypted, the lengths of the component values
   in the packet should be summed and checked against the cleartext
   datalength value from the header. Any packets which fail this check
   should be discarded and an error signalled. Commonly such failures
   may be expected to be seen when there are mismatched keys between the
   NAS and the TACACS+ server.

   If an error must be declared but the type of the incoming packet can-
   not be determined, a packet with the identical cleartext header but
   with a sequence number incremented by one and the length set to zero
   may be returned to indicate an error.

   6.  Body types

   All further discussions of TACACS+ packet bodies assumes that any
   encryption/decryption has already been performed. From here on, we
   are only concerned with the cleartext data.

   There are several constant fields in many of the following bodies. A
   few merit mention here as they apply to most packet bodies.

   The user is the username or user id that is authenticated or being
   authenticated.
action      = TAC_PLUS_AUTHEN_LOGIN

priv_lvl    = implementation dependent

authen_type = not used

service     = TAC_PLUS_AUTHEN_SVC_ENABLE


action      =   TAC_PLUS_AUTHEN_LOGIN

authen_type =   TAC_PLUS_AUTHEN_TYPE_ASCII


action        =   TAC_PLUS_AUTHEN_LOGIN

authen_type   =   TAC_PLUS_AUTHEN_TYPE_PAP
minor_version =   0x1


action        =   TAC_PLUS_AUTHEN_LOGIN

authen_type   =   TAC_PLUS_AUTHEN_TYPE_CHAP

minor_version =   0x1


action        =   TAC_PLUS_AUTHEN_LOGIN

authen_type   =   TAC_PLUS_AUTHEN_TYPE_ARAP

minor_version =   0x1


action        =   TAC_PLUS_AUTHEN_SENDAUTH

authen_type   =   TAC_PLUS_AUTHEN_TYPE_PAP

minor_version =   0x1


action        = TAC_PLUS_AUTHEN_SENDAUTH

authen_type   = TAC_PLUS_AUTHEN_TYPE_CHAP

minor_version = 0x1


action      =   TAC_PLUS_AUTHEN_SENDAUTH

authen_type =   TAC_PLUS_AUTHEN_TYPE_ASCII

authen_type =   TAC_PLUS_AUTHEN_TYPE_ARAP

action      =   TAC_PLUS_AUTHEN_CHPASS

authen_type =   TAC_PLUS_AUTHEN_TYPE_ASCII


action      =   TAC_PLUS_AUTHEN_CHPASS

authen_type =   TAC_PLUS_AUTHEN_TYPE_PAP

authen_type =   TAC_PLUS_AUTHEN_TYPE_CHAP
action      =   TAC_PLUS_AUTHEN_CHPASS

authen_type =   TAC_PLUS_AUTHEN_TYPE_ARAP


service=shell and cmd=NULL

service=shell and cmd=NULL

service=shell and cmd=NULL
