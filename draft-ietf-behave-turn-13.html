<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="en"><head><title>Traversal Using Relays around NAT (TURN): Relay
    Extensions to Session Traversal Utilities for NAT (STUN)</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="description" content="Traversal Using Relays around NAT (TURN): Relay
    Extensions to Session Traversal Utilities for NAT (STUN)">
<meta name="keywords" content="NAT, TURN, STUN, ICE">
<meta name="generator" content="xml2rfc v1.35 (http://xml.resource.org/)">
<meta name="viewport" content="width=600;" />
<style type='text/css'><!--
        body {
                font-family: verdana, charcoal, helvetica, arial, sans-serif;
                font-size: 85%;
		max-width: 40em; 
		color: #000; background-color: #FFF;
                margin: 2em;
        }
        h1, h2, h3, h4, h5, h6 {
                font-family: helvetica, monaco, "MS Sans Serif", arial, sans-serif;
                font-weight: bold; font-style: normal;
        }
        h1 { color: #900; background-color: transparent; text-align: right; }
        h3 { color: #333; background-color: transparent; }

        td.RFCbug {
                font-size: x-small; text-decoration: none;
                width: 30px; height: 30px; padding-top: 2px;
                text-align: justify; vertical-align: middle;
                background-color: #000;
        }
        td.RFCbug span.RFC {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: bold; color: #666;
        }
        td.RFCbug span.hotText {
                font-family: charcoal, monaco, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: normal; text-align: center; color: #FFF;
        }

        table.TOCbug { width: 30px; height: 15px; }
        td.TOCbug {
                text-align: center; width: 30px; height: 15px;
                color: #FFF; background-color: #900;
        }
        td.TOCbug a {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, sans-serif;
                font-weight: bold; font-size: x-small; text-decoration: none;
                color: #FFF; background-color: transparent;
        }

        td.header {
                font-family: arial, helvetica, sans-serif; font-size: x-small;
                vertical-align: top; width: 33%;
                color: #FFF; background-color: #666;
        }
        td.author { font-weight: bold; font-size: x-small; margin-left: 4em; }
        td.author-text { font-size: x-small; }

        /* info code from SantaKlauss at http://www.madaboutstyle.com/tooltip2.html */
        a.info {
                /* This is the key. */
                position: relative;
                z-index: 24;
                text-decoration: none;
        }
        a.info:hover {
                z-index: 25;
                color: #FFF; background-color: #900;
        }
        a.info span { display: none; }
        a.info:hover span.info {
                /* The span will display just on :hover state. */
                display: block;
                position: absolute;
                font-size: smaller;
                top: 2em; left: -5em; width: 15em;
                padding: 2px; border: 1px solid #333;
                color: #900; background-color: #EEE;
                text-align: left;
        }

        a { font-weight: bold; }
        a:link    { color: #900; background-color: transparent; }
        a:visited { color: #633; background-color: transparent; }
        a:active  { color: #633; background-color: transparent; }

        p { margin-left: 2em; margin-right: 2em; }
        p.copyright { font-size: x-small; }
        p.toc { font-size: 85%;
		max-width: 40em; 
		font-weight: bold; margin-left: 3em; }
        table.toc { margin: 0 0 0 3em; padding: 0; border: 0; vertical-align: text-top; }
        td.toc { font-size: 85%;
		max-width: 40em; 
		font-weight: bold; vertical-align: text-top; }

        ol.text { margin-left: 2em; margin-right: 2em; }
        ul.text { margin-left: 2em; margin-right: 2em; }
        li      { margin-left: 3em; }

        /* RFC-2629 <spanx>s and <artwork>s. */
        em     { font-style: italic; }
        strong { font-weight: bold; }
        dfn    { font-weight: bold; font-style: normal; }
        cite   { font-weight: normal; font-style: normal; }
        tt     { color: #036; }
        tt, pre, pre dfn, pre em, pre cite, pre span {
                font-family: "Courier New", Courier, monospace; font-size: small;
        }
        pre {
                text-align: left; padding: 4px;
                color: #000; background-color: #CCC;
        }
        pre dfn  { color: #900; }
        pre em   { color: #66F; background-color: #FFC; font-weight: normal; }
        pre .key { color: #33C; font-weight: bold; }
        pre .id  { color: #900; }
        pre .str { color: #000; background-color: #CFF; }
        pre .val { color: #066; }
        pre .rep { color: #909; }
        pre .oth { color: #000; background-color: #FCF; }
        pre .err { background-color: #FCC; }

        /* RFC-2629 <texttable>s. */
        table.all, table.full, table.headers, table.none {
                font-size: 85%;
		max-width: 40em; 
		text-align: center; border-width: 2px;
                vertical-align: top; border-collapse: collapse;
        }
        table.all, table.full { border-style: solid; border-color: black; }
        table.headers, table.none { border-style: none; }
        th {
                font-weight: bold; border-color: black;
                border-width: 2px 2px 3px 2px;
        }
        table.all th, table.full th { border-style: solid; }
        table.headers th { border-style: none none solid none; }
        table.none th { border-style: none; }
        table.all td {
                border-style: solid; border-color: #333;
                border-width: 1px 2px;
        }
        table.full td, table.headers td, table.none td { border-style: none; }

        hr { height: 1px; }
        hr.insert {
                width: 80%; border-style: none; border-width: 0;
                color: #CCC; background-color: #CCC;
        }
--></style>
</head>
<body>
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<table summary="layout" width="66%" border="0" cellpadding="0" cellspacing="0"><tr><td><table summary="layout" width="100%" border="0" cellpadding="2" cellspacing="1">
<tr><td class="header">BEHAVE WG</td><td class="header">J. Rosenberg</td></tr>
<tr><td class="header">Internet-Draft</td><td class="header">Cisco</td></tr>
<tr><td class="header">Intended status: Standards Track</td><td class="header">R. Mahy</td></tr>
<tr><td class="header">Expires: August 29, 2009</td><td class="header">(Unaffiliated)</td></tr>
<tr><td class="header">&nbsp;</td><td class="header">P. Matthews</td></tr>
<tr><td class="header">&nbsp;</td><td class="header">Alcatel-Lucent</td></tr>
<tr><td class="header">&nbsp;</td><td class="header">February 25, 2009</td></tr>
</table></td></tr></table>
<h1><br />Traversal Using Relays around NAT (TURN): Relay
    Extensions to Session Traversal Utilities for NAT (STUN)<br />draft-ietf-behave-turn-13</h1>

<h3>Status of this Memo</h3>
<p>
This Internet-Draft is submitted to IETF in full
conformance with the provisions of BCP&nbsp;78 and BCP&nbsp;79.</p>
<p>
Internet-Drafts are working documents of the Internet Engineering
Task Force (IETF), its areas, and its working groups.
Note that other groups may also distribute working documents as
Internet-Drafts.</p>
<p>
Internet-Drafts are draft documents valid for a maximum of six months
and may be updated, replaced, or obsoleted by other documents at any time.
It is inappropriate to use Internet-Drafts as reference material or to cite
them other than as &ldquo;work in progress.&rdquo;</p>
<p>
The list of current Internet-Drafts can be accessed at
<a href='http://www.ietf.org/ietf/1id-abstracts.txt'>http://www.ietf.org/ietf/1id-abstracts.txt</a>.</p>
<p>
The list of Internet-Draft Shadow Directories can be accessed at
<a href='http://www.ietf.org/shadow.html'>http://www.ietf.org/shadow.html</a>.</p>
<p>
This Internet-Draft will expire on August 29, 2009.</p>

<h3>Copyright Notice</h3>
<p>
Copyright (c) 2009 IETF Trust and the persons identified as the
document authors.  All rights reserved.</p>
<p>
This document is subject to BCP 78 and the IETF Trust's Legal
Provisions Relating to IETF Documents in effect on the date of
publication of this document (http://trustee.ietf.org/license-info).
Please review these documents carefully, as they describe your
rights and restrictions with respect to this document.</p>

<h3></h3>

<p>This document may contain material from IETF  
      Documents or IETF Contributions published or made publicly available  
      before November 10, 2008. The person(s) controlling the copyright in  
      some of this material may not have granted the IETF Trust the right to  
      allow modifications of such material outside the IETF Standards  
      Process. Without obtaining an adequate license from the person(s)  
      controlling the copyright in such materials, this document may not be  
      modified outside the IETF Standards Process, and derivative works of  
      it may not be created outside the IETF Standards Process, except to  
      format it for publication as an RFC or to translate it into languages  
      other than English. 
</p>
<h3>Abstract</h3>

<p>If a host is located behind a NAT, then in certain situations it can
      be impossible for that host to communicate directly with other hosts
      (peers). In these situations, it is necessary for the host to use the
      services of an intermediate node that acts as a communication relay.
      This specification defines a protocol, called TURN (Traversal Using
      Relays around NAT), that allows the host to control the operation of the
      relay and to exchange packets with its peers using the relay. TURN
      differs from some other relay control protocols in that it allows a
      client to communicate with multiple peers using a single relay
      address.
</p>
<p>The TURN protocol was designed to be used as part of the ICE
      (Interactive Connectivity Establishment) approach to NAT traversal,
      though it can be also used without ICE.
</p><a name="toc"></a><br /><hr />
<h3>Table of Contents</h3>
<p class="toc">
<a href="#anchor1">1.</a>&nbsp;
Introduction<br />
<a href="#sec-overview">2.</a>&nbsp;
Overview of Operation<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec-transports">2.1.</a>&nbsp;
Transports<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor2">2.2.</a>&nbsp;
Allocations<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec-permission-overview">2.3.</a>&nbsp;
Permissions<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor3">2.4.</a>&nbsp;
Send Mechanism<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor4">2.5.</a>&nbsp;
Channels<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor5">2.6.</a>&nbsp;
Other Features<br />
<a href="#anchor6">3.</a>&nbsp;
Terminology<br />
<a href="#sec-general-behavior">4.</a>&nbsp;
General Behavior<br />
<a href="#sec-allocations">5.</a>&nbsp;
Allocations<br />
<a href="#sec-create-allocation">6.</a>&nbsp;
Creating an Allocation<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec-send-allocate">6.1.</a>&nbsp;
Sending an Allocate Request<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec-rcv-allocate">6.2.</a>&nbsp;
Receiving an Allocate Request<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor7">6.3.</a>&nbsp;
Receiving an Allocate Success Response<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor8">6.4.</a>&nbsp;
Receiving an Allocate Error Response<br />
<a href="#sec-refreshing-allocation">7.</a>&nbsp;
Refreshing an Allocation<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor9">7.1.</a>&nbsp;
Sending a Refresh Request<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor10">7.2.</a>&nbsp;
Receiving a Refresh Request<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor11">7.3.</a>&nbsp;
Receiving a Refresh Response<br />
<a href="#sec-permissions">8.</a>&nbsp;
Permissions<br />
<a href="#anchor12">9.</a>&nbsp;
CreatePermission<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor13">9.1.</a>&nbsp;
Forming a CreatePermission request<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor14">9.2.</a>&nbsp;
Receiving a CreatePermission request<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor15">9.3.</a>&nbsp;
Receiving a CreatePermission response<br />
<a href="#sec-sendanddata">10.</a>&nbsp;
Send and Data Methods<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec-forming-indication">10.1.</a>&nbsp;
Forming a Send Indication<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor16">10.2.</a>&nbsp;
Receiving a Send Indication<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec-sending-data-indication">10.3.</a>&nbsp;
Receiving a UDP Datagram<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor17">10.4.</a>&nbsp;
Receiving a Data Indication<br />
<a href="#sec-channels">11.</a>&nbsp;
Channels<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor18">11.1.</a>&nbsp;
Sending a ChannelBind Request<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec-receiving-ChannelBind">11.2.</a>&nbsp;
Receiving a ChannelBind Request<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor19">11.3.</a>&nbsp;
Receiving a ChannelBind Response<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec-channeldata-msg">11.4.</a>&nbsp;
The ChannelData Message<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec-sending-channeldata-msg">11.5.</a>&nbsp;
Sending a ChannelData Message<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor20">11.6.</a>&nbsp;
Receiving a ChannelData Message<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec-channel-relaying">11.7.</a>&nbsp;
Relaying Data from the Peer<br />
<a href="#sec-ip-header-fields">12.</a>&nbsp;
IP Header Fields<br />
<a href="#sec-stun-methods">13.</a>&nbsp;
New STUN Methods<br />
<a href="#sec-stun-attributes">14.</a>&nbsp;
New STUN Attributes<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#channelnums">14.1.</a>&nbsp;
CHANNEL-NUMBER<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor21">14.2.</a>&nbsp;
LIFETIME<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor22">14.3.</a>&nbsp;
XOR-PEER-ADDRESS<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor23">14.4.</a>&nbsp;
DATA<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor24">14.5.</a>&nbsp;
XOR-RELAYED-ADDRESS<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor25">14.6.</a>&nbsp;
EVEN-PORT<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec-requested-transport">14.7.</a>&nbsp;
REQUESTED-TRANSPORT<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor26">14.8.</a>&nbsp;
DONT-FRAGMENT<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor27">14.9.</a>&nbsp;
RESERVATION-TOKEN<br />
<a href="#sec-stun-errors">15.</a>&nbsp;
New STUN Error Response Codes<br />
<a href="#anchor28">16.</a>&nbsp;
Detailed Example<br />
<a href="#sec-security">17.</a>&nbsp;
Security Considerations<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor29">17.1.</a>&nbsp;
Outsider Attacks<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor30">17.1.1.</a>&nbsp;
Obtaining Unauthorized Allocations<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor31">17.1.2.</a>&nbsp;
Offline Dictionary Attacks<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor32">17.1.3.</a>&nbsp;
Faked Refreshes and Permissions<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor33">17.1.4.</a>&nbsp;
Fake Data<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor34">17.1.5.</a>&nbsp;
Impersonating a Server<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor35">17.1.6.</a>&nbsp;
Eavesdropping Traffic<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor36">17.1.7.</a>&nbsp;
TURN loop attack<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec-firewall">17.2.</a>&nbsp;
Firewall Considerations<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor37">17.2.1.</a>&nbsp;
Faked Permissions<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor38">17.2.2.</a>&nbsp;
Blacklisted IP Addresses<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor39">17.2.3.</a>&nbsp;
Running Servers on Well-Known Ports<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor40">17.3.</a>&nbsp;
Insider Attacks<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor41">17.3.1.</a>&nbsp;
DoS Against TURN Server<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor42">17.3.2.</a>&nbsp;
Anonymous Relaying of Malicious Traffic<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor43">17.3.3.</a>&nbsp;
Manipulating other Allocations<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor44">17.4.</a>&nbsp;
Other Considerations<br />
<a href="#anchor45">18.</a>&nbsp;
IANA Considerations<br />
<a href="#anchor46">19.</a>&nbsp;
IAB Considerations<br />
<a href="#anchor47">20.</a>&nbsp;
Open Issues<br />
<a href="#anchor48">21.</a>&nbsp;
Changes from Previous Versions<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor49">21.1.</a>&nbsp;
Changes from -12 to -13<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor50">21.2.</a>&nbsp;
Changes from -11 to -12<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor51">21.3.</a>&nbsp;
Changes from -10 to -11<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor52">21.4.</a>&nbsp;
Changes from -09 to -10<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor53">21.5.</a>&nbsp;
Changes from -08 to -09<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor54">21.6.</a>&nbsp;
Changes from -07 to -08<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor55">21.7.</a>&nbsp;
Changes from -06 to -07<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor56">21.8.</a>&nbsp;
Changes from -05 to -06<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor57">21.9.</a>&nbsp;
Changes from -04 to -05<br />
<a href="#anchor58">22.</a>&nbsp;
Acknowledgements<br />
<a href="#rfc.references1">23.</a>&nbsp;
References<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#rfc.references1">23.1.</a>&nbsp;
Normative References<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#rfc.references2">23.2.</a>&nbsp;
Informative References<br />
<a href="#rfc.authors">&#167;</a>&nbsp;
Authors' Addresses<br />
</p>
<br clear="all" />

<a name="anchor1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1"></a><h3>1.&nbsp;
Introduction</h3>

<p>A host behind a NAT may wish to exchange packets with other hosts,
      some of which may also be behind NATs. To do this, the hosts involved
      can use 'Hole Punching' techniques (see <a class='info' href='#RFC5128'>[RFC5128]<span> (</span><span class='info'>Srisuresh, P., Ford, B., and D. Kegel, &ldquo;State of Peer-to-Peer (P2P) Communication across Network Address Translators (NATs),&rdquo; March&nbsp;2008.</span><span>)</span></a>)
      in an attempt discover a direct communication path; that is, a
      communication path that goes from host to another through intervening
      NATs and routers, but does not traverse any relays.
</p>
<p>As described in <a class='info' href='#RFC5128'>[RFC5128]<span> (</span><span class='info'>Srisuresh, P., Ford, B., and D. Kegel, &ldquo;State of Peer-to-Peer (P2P) Communication across Network Address Translators (NATs),&rdquo; March&nbsp;2008.</span><span>)</span></a> and <a class='info' href='#RFC4787'>[RFC4787]<span> (</span><span class='info'>Audet, F. and C. Jennings, &ldquo;Network Address Translation (NAT) Behavioral Requirements for Unicast UDP,&rdquo; January&nbsp;2007.</span><span>)</span></a>, hole punching techniques will fail if both
      hosts are behind NATs that are not well-behaved. For example, if both
      hosts are behind NATs that have a mapping behavior of "address dependent
      mapping" or "address and port dependent mapping", then hole punching
      techniques generally fail.
</p>
<p>When a direct communication path cannot be found, it is necessary to
      use the services of an intermediate host that acts as a relay for the
      packets. This relay typically sits in the public Internet and relays
      packets between two hosts that both sit behind NATs.
</p>
<p>This specification defines a protocol, called TURN, that allows a
      host behind a NAT (called the TURN client) to request that another host
      (called the TURN server) act as a relay. The client can arrange for the
      server to relay packets to and from certain other hosts (called peers)
      and can control aspects of how the relaying is done. The client does
      this by obtaining an IP address and port on the server, called the
      relayed-transport-address. When a peer sends a packet to the
      relayed-transport-address, the server relays the packet to the client.
      When the client sends a data packet to the server, the server relays it
      to the appropriate peer using the relayed-transport-address as the
      source.
</p>
<p>A client using TURN must have some way to communicate the
      relayed-transport-address to its peers, and to learn each peer's IP
      address and port (more precisely, each peer's server-reflexive transport
      address, see <a class='info' href='#sec-overview'>Section&nbsp;2<span> (</span><span class='info'>Overview of Operation</span><span>)</span></a>). How this is done is
      out of the scope of the TURN protocol. One way this might be done is for
      the client and peers to exchange e-mail messages. Another way is for the
      client and its peers to use a special-purpose 'introduction' or
      'rendezvous' protocol (see <a class='info' href='#RFC5128'>[RFC5128]<span> (</span><span class='info'>Srisuresh, P., Ford, B., and D. Kegel, &ldquo;State of Peer-to-Peer (P2P) Communication across Network Address Translators (NATs),&rdquo; March&nbsp;2008.</span><span>)</span></a> for more
      details).
</p>
<p>If TURN is used with ICE <a class='info' href='#I-D.ietf-mmusic-ice'>[I&#8209;D.ietf&#8209;mmusic&#8209;ice]<span> (</span><span class='info'>Rosenberg, J., &ldquo;Interactive Connectivity Establishment (ICE): A Protocol for Network Address Translator (NAT) Traversal for Offer/Answer Protocols,&rdquo; October&nbsp;2007.</span><span>)</span></a>,
      then the relayed-transport-address and the IP addresses and ports of the
      peers are included in the ICE candidate information which the rendezvous
      protocol must carry. For example, if TURN and ICE are used as part of a
      multimedia solution using SIP <a class='info' href='#RFC3261'>[RFC3261]<span> (</span><span class='info'>Rosenberg, J., Schulzrinne, H., Camarillo, G., Johnston, A., Peterson, J., Sparks, R., Handley, M., and E. Schooler, &ldquo;SIP: Session Initiation Protocol,&rdquo; June&nbsp;2002.</span><span>)</span></a>, then SIP
      serves the role of the rendezvous protocol, carrying the ICE candidate
      information inside the body of SIP messages. If TURN and ICE are used
      with some other rendezvous protocol, then <a class='info' href='#I-D.rosenberg-mmusic-ice-nonsip'>[I&#8209;D.rosenberg&#8209;mmusic&#8209;ice&#8209;nonsip]<span> (</span><span class='info'>Rosenberg, J., &ldquo;Guidelines for Usage of Interactive Connectivity Establishment (ICE) by non  Session Initiation Protocol (SIP) Protocols,&rdquo; July&nbsp;2008.</span><span>)</span></a> provides guidance on
      the services the rendezvous protocol must perform.
</p>
<p>Though the use of a TURN server to enable communication between two
      hosts behind NATs is very likely to work, it comes at a high cost to the
      provider of the TURN server, since the server typically needs a high
      bandwidth connection to the Internet . As a consequence, it is best to
      use a TURN server only when a direct communication path cannot be found.
      When the client and a peer use ICE to determine the communication path,
      ICE will use hole punching techniques to search for a direct path first
      and only use a TURN server when a direct path cannot be found.
</p>
<p>TURN was originally invented to support multimedia sessions signaled
      using SIP. Since SIP supports forking, TURN supports multiple peers per
      relayed-transport-address; a feature not supported by other approaches
      (e.g., SOCKS <a class='info' href='#RFC1928'>[RFC1928]<span> (</span><span class='info'>Leech, M., Ganis, M., Lee, Y., Kuris, R., Koblas, D., and L. Jones, &ldquo;SOCKS Protocol Version 5,&rdquo; March&nbsp;1996.</span><span>)</span></a>). However, care has been
      taken to make sure that TURN is suitable for other types of
      applications.
</p>
<p>TURN was designed as one piece in the larger ICE approach to NAT
      traversal. Implementors of TURN are urged to investigate ICE and
      seriously consider using it for their application. However, it is
      possible to use TURN without ICE.
</p>
<p>TURN is an extension to the STUN (Session Traversal Utilities for NAT
      <a class='info' href='#RFC5389'>[RFC5389]<span> (</span><span class='info'>Rosenberg, J., Mahy, R., Matthews, P., and D. Wing, &ldquo;Session Traversal Utilities for NAT (STUN),&rdquo; October&nbsp;2008.</span><span>)</span></a>) protocol. Most, though not all, TURN
      messages are STUN-formatted messages. A reader of this document should
      be familiar with STUN.
</p>
<a name="sec-overview"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2"></a><h3>2.&nbsp;
Overview of Operation</h3>

<p>This section gives an overview of the operation of TURN. It is
      non-normative.
</p>
<p>In a typical configuration, a TURN client is connected to a <a class='info' href='#RFC1918'>private network<span> (</span><span class='info'>Rekhter, Y., Moskowitz, R., Karrenberg, D., Groot, G., and E. Lear, &ldquo;Address Allocation for Private Internets,&rdquo; February&nbsp;1996.</span><span>)</span></a> [RFC1918] and through one or more NATs to
      the public Internet. On the public Internet is a TURN server. Elsewhere
      in the Internet are one or more peers that the TURN client wishes to
      communicate with. These peers may or may not be behind one or more NATs.
      The client uses the server as a relay to send packets to these peers and
      to receive packets from these peers.
</p><br /><hr class="insert" />
<a name="fig-turn-model"></a>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>                                        Peer A
                                        Server-Reflexive    +---------+
                                        Transport Address   |         |
                                        192.0.2.150:32102   |         |
                                            |              /|         |
                          TURN              |            / ^|  Peer A |
    Client's              Server            |           /  ||         |
    Host Transport        Transport         |         //   ||         |
    Address               Address           |       //     |+---------+
   10.1.1.2:49721       192.0.2.15:3478     |+-+  //     Peer A
            |               |               ||N| /       Host Transport
            |   +-+         |               ||A|/        Address
            |   | |         |               v|T|     192.168.100.2:49582
            |   | |         |               /+-+
 +---------+|   | |         |+---------+   /              +---------+
 |         ||   |N|         ||         | //               |         |
 | TURN    |v   | |         v| TURN    |/                 |         |
 | Client  |----|A|----------| Server  |------------------|  Peer B |
 |         |    | |^         |         |^                ^|         |
 |         |    |T||         |         ||                ||         |
 +---------+    | ||         +---------+|                |+---------+
                | ||                    |                |
                | ||                    |                |
                +-+|                    |                |
                   |                    |                |
                   |                    |                |
             Client's                   |            Peer B
             Server-Reflexive    Relayed             Transport
             Transport Address   Transport Address   Address
             192.0.2.1:7000      192.0.2.15:50000     192.0.2.210:49191
</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;1&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>
</p>
<p><a class='info' href='#fig-turn-model'>Figure&nbsp;1</a> shows a typical deployment. In
      this figure, the TURN client and the TURN server are separated by a NAT,
      with the client on the private side and the server on the public side of
      the NAT. This NAT is assumed to be a &ldquo;bad&rdquo; NAT; for example,
      it might have a mapping property of address-and-port-dependent mapping
      (see <a class='info' href='#RFC4787'>[RFC4787]<span> (</span><span class='info'>Audet, F. and C. Jennings, &ldquo;Network Address Translation (NAT) Behavioral Requirements for Unicast UDP,&rdquo; January&nbsp;2007.</span><span>)</span></a> for a description of what this
      means).
</p>
<p>The client talks to the server from a (IP address, port) combination
      called the client's HOST TRANSPORT ADDRESS. (The combination of an IP
      address and port is called a TRANSPORT ADDRESS).
</p>
<p>The client sends TURN messages from its host transport address to a
      transport address on the TURN server which is known as the TURN SERVER
      TRANSPORT ADDRESS. The client learns the server&rsquo;s transport
      address through some unspecified means (e.g., configuration), and this
      address is typically used by many clients simultaneously.
</p>
<p>Since the client is behind a NAT, the server sees packets from the
      client as coming from a transport address on the NAT itself. This
      address is known as the client&rsquo;s SERVER-REFLEXIVE transport
      address; packets sent by the server to the client&rsquo;s
      server-reflexive transport address will be forwarded by the NAT to the
      client&rsquo;s host transport address.
</p>
<p>The client uses TURN commands to create and manipulate an ALLOCATION
      on the server. An allocation is a data structure on the server, an
      important component of which is a RELAYED TRANSPORT ADDRESS. The relayed
      transport address for the allocation is a transport address on the
      server which is used to send and receive packets to the peers.
</p>
<p>Once an allocation is created, the client can send application data
      to the server along with an indication of which peer the data is to be
      sent to, and the server will relay this data to the appropriate peer.
      The client sends the application data to the server inside a TURN
      message; at the server, the data is extracted from the TURN message and
      sent to the peer in a UDP datagram. In the reverse direction, a peer can
      send application data in a UDP datagram to the relayed transport address
      for the allocation; the server will then encapsulate this data inside a
      TURN message and send it to the client along with an indication of which
      peer sent the data. Since the TURN message always contains an indication
      of which peer the client is communicating with, the client can use a
      single allocation to communicate with multiple peers.
</p>
<p>When the peer is behind a NAT, then the client must identify the peer
      using its server-reflexive transport address rather than its host
      transport address. For example, to application data to peer A in the
      example above, the client must specify 192.0.2.150:32102 (peer A's
      server-reflexive transport address) rather than 192.168.100.2:49582
      (peer A's host transport address).
</p>
<p>Each allocation on the server belongs to a single client and has
      exactly one relayed transport address which is used only by that
      allocation. Thus when a packet arrives at a relayed transport address on
      the server, the server knows which client the data is intended for.
      However, the client may have multiple allocations on a server at the
      same time.
</p>
<a name="sec-transports"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2.1"></a><h3>2.1.&nbsp;
Transports</h3>

<p>TURN as defined in this specification always uses UDP between the
        server and the peer. However, this specification allows the use of any
        one of UDP, TCP, or TLS over TCP to carry the TURN messages between
        the client and the server.
</p><table class="full" align="center" border="0" cellpadding="2" cellspacing="2">
<col align="center"><col align="center">
<tr><th align="center">TURN client to TURN server</th><th align="center">TURN server to peer</th></tr>
<tr>
<td align="center">UDP</td>
<td align="center">UDP</td>
</tr>
<tr>
<td align="center">TCP</td>
<td align="center">UDP</td>
</tr>
<tr>
<td align="center">TLS over TCP</td>
<td align="center">UDP</td>
</tr>
</table>
<br clear="all" />

<p>If TCP or TLS over TCP is used between the client and the server,
        then the server will convert between these transports and UDP
        transport when relaying data to/from the peer.
</p>
<p>TURN supports TCP transport between the client and the server
        because some firewalls are configured to block UDP entirely. These
        firewalls block UDP but not TCP in part because TCP has properties
        that make the intention of the nodes being protected by the firewall
        more obvious to the firewall. For example, TCP has a three-way
        handshake that makes in clearer that the protected node really wishes
        to have that particular connection established, while for UDP the best
        the firewall can do is guess which flows are desired by using
        filtering rules. Also, TCP has explicit connection teardown, while for
        UDP the firewall has to use timers to guess when the flow is
        finished.
</p>
<p>TURN supports TLS over TCP transport between the client and the
        server because TLS provides additional security properties not
        provided by TURN's default digest authentication; properties which
        some clients may wish to take advantage of. In particular, TLS
        provides a way for the client to ascertain that it is talking to the
        server that it intended to, and also provides for confidentiality of
        TURN control messages. TURN does not require TLS because the overhead
        of using TLS is higher than that of digest authentication; for
        example, using TLS likely means that most application data will be
        doubly encrypted (once by TLS and once to ensure it is still encrypted
        in the UDP datagram).
</p>
<p>There is a planned extension to TURN to add support for TCP between
        the server and the peers <a class='info' href='#I-D.ietf-behave-turn-tcp'>[I&#8209;D.ietf&#8209;behave&#8209;turn&#8209;tcp]<span> (</span><span class='info'>Perreault, S. and J. Rosenberg, &ldquo;Traversal Using Relays around NAT (TURN) Extensions for TCP Allocations,&rdquo; March&nbsp;2010.</span><span>)</span></a>. For this reason,
        allocations that use UDP between the server and the peers are known as
        UDP allocations, while allocations that use TCP between the server and
        the peers are known as TCP allocations. This specification describes
        only UDP allocations.
</p>
<p>TURN as defined in this specification only supports IPv4. All IP
        addresses in this specification must be IPv4 addresses. However, there
        is a planned extension to TURN to add support for IPv6 and for
        relaying between IPv4 and IPv6 <a class='info' href='#I-D.ietf-behave-turn-ipv6'>[I&#8209;D.ietf&#8209;behave&#8209;turn&#8209;ipv6]<span> (</span><span class='info'>Camarillo, G., Novo, O., and S. Perreault, &ldquo;Traversal Using Relays around NAT (TURN) Extension for IPv6,&rdquo; March&nbsp;2010.</span><span>)</span></a>.
</p>
<p>In some applications for TURN, the client may send and receive
        packets other than TURN packets on the host transport address it uses
        to communicate with the server. This can happen, for example, when
        using TURN with ICE. In these cases, the client can distinguish TURN
        packets from other packets by examining the source address of the
        arriving packet: those arriving from the TURN server will be TURN
        packets.
</p>
<a name="anchor2"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2.2"></a><h3>2.2.&nbsp;
Allocations</h3>

<p>To create an allocation on the server, the client uses an Allocate
        transaction. The client sends a Allocate request to the server, and
        the server replies with an Allocate success response containing the
        allocated relayed transport address. The client can include attributes
        in the Allocate request that describe the type of allocation it
        desires (e.g., the lifetime of the allocation). Since relaying data
        may require lots of bandwidth, the server typically requires that the
        client authenticate itself using STUN&rsquo;s long-term credential
        mechanism, to show that it is authorized to use the server.
</p>
<p>Once a relayed transport address is allocated, a client must keep
        the allocation alive. To do this, the client periodically sends a
        Refresh request to the server. TURN deliberately uses a different
        method (Refresh rather than Allocate) for refreshes to ensure that the
        client is informed if the allocation vanishes for some reason.
</p>
<p>The frequency of the Refresh transaction is determined by the
        lifetime of the allocation. The client can request a lifetime in the
        Allocate request and may modify its request in a Refresh request, and
        the server always indicates the actual lifetime in the response. The
        client must issue a new Refresh transaction within 'lifetime' seconds
        of the previous Allocate or Refresh transaction. Once a client no
        longer wishes to use an Allocation, it should delete the allocation
        using a Refresh request with a requested lifetime of 0.
</p>
<p>Both the server and client keep track of a value known as the
        5-TUPLE. At the client, the 5-tuple consists of the client's host
        transport address, the server transport address, and the transport
        protocol used by the client to communicate with the server. At the
        server, the 5-tuple value is the same except that the client's host
        transport address is replaced by the client's server-reflexive
        address, since that is the client's address as seen by the server.
</p>
<p>Both the client and the server remember the 5-tuple used in the
        Allocate request. Subsequent messages between the client and the
        server uses the same 5-tuple. In this way, the client and server know
        which allocation is being referred to. If the client wishes to
        allocate a second relayed transport address, it must create a second
        allocation using a different 5-tuple (e.g., by using a different
        client host address or port).
</p>
<p></p>
<blockquote class="text">
<p>NOTE: While the terminology used in this document refers to
            5-tuples, the TURN server can store whatever identifier it likes
            that yields identical results. Specifically, an implementation may
            use a file-descriptor in place of a 5-tuple to represent a TCP
            connection
</p>
</blockquote>
<br /><hr class="insert" />
<a name="fig-allocate"></a>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>TURN                                 TURN           Peer          Peer
client                               server          A             B
  |-- Allocate request ---------------&gt;|             |             |
  |                                    |             |             |
  |&lt;--------------- Allocate failure --|             |             |
  |                 (401 Unauthorized) |             |             |
  |                                    |             |             |
  |-- Allocate request ---------------&gt;|             |             |
  |                                    |             |             |
  |&lt;---------- Allocate success resp --|             |             |
  |            (192.0.2.15:50000)      |             |             |
  //                                   //            //            //
  |                                    |             |             |
  |-- Refresh request ----------------&gt;|             |             |
  |                                    |             |             |
  |&lt;----------- Refresh success resp --|             |             |
  |                                    |             |             |
</pre></div>
<p>
</p><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;2&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>In <a class='info' href='#fig-allocate'>Figure&nbsp;2</a>, the client sends an
        Allocate request to the server without credentials. Since the server
        requires that all requests be authenticated using STUN's long-term
        credential mechanism, the server rejects the request with a 401
        (Unauthorized) error code. The client then tries again, this time
        including credentials (not shown). This time, the server accepts the
        Allocate request and returns an Allocate success response containing
        (amongst other things) the relayed transport address assigned to the
        allocation. Sometime later the client decides to refresh the
        allocation and thus sends a Refresh request to the server. The refresh
        is accepted and the server replies with a Refresh success
        response.
</p>
<a name="sec-permission-overview"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2.3"></a><h3>2.3.&nbsp;
Permissions</h3>

<p>To ease concerns amongst enterprise IT administrators that TURN
        could be used to bypass corporate firewall security, TURN includes the
        notion of permissions. TURN permissions mimic the address-restricted
        filtering mechanism of NATs that comply with <a class='info' href='#RFC4787'>[RFC4787]<span> (</span><span class='info'>Audet, F. and C. Jennings, &ldquo;Network Address Translation (NAT) Behavioral Requirements for Unicast UDP,&rdquo; January&nbsp;2007.</span><span>)</span></a>.
</p>
<p>An allocation can have zero or more permissions. Each permission
        consists of an IP address and a lifetime. When the server receives a
        UDP datagram on the allocation's relayed transport address, it first
        checks the list of permissions. If the source IP address of the
        datagram matches a permission, the application data is relayed to the
        client, otherwise the UDP datagram is silently discarded.
</p>
<p>A permission expires after 5 minutes if it is not refreshed. There
        is no way to explicitly delete a permission.
</p>
<p>The client can install or refresh a permission using either a
        CreatePermission request or a ChannelBind request. Using the
        CreatePermission request, multiple permissions can be installed or
        refreshed with a single request. For security reasons, permissions can
        only be installed or refreshed by transactions that can be
        authenticated; thus Send indications and ChannelData messages (which
        are used to send data to peers) do not install or refresh any
        permissions.
</p>
<p>Note that permissions are within the context of an allocation, so
        adding or expiring a permission in one allocation does not affect
        other allocations.
</p>
<a name="anchor3"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2.4"></a><h3>2.4.&nbsp;
Send Mechanism</h3>

<p>There are two mechanisms for the client and peers to exchange
        application data using the TURN server. The first mechanism uses the
        Send and Data methods, the second way uses channels. Common to both
        ways is the ability of the client to communicate with multiple peers
        using a single allocated relayed transport address; thus both ways
        include a means for the client to indicate to the server which peer to
        forward the data to, and for the server to indicate which peer sent
        the data.
</p>
<p>The Send mechanism uses Send and Data indications. Send indications
        are used to send application data from the client to the server, while
        Data indications are used to send application data from the server to
        the client.
</p>
<p>When using the Send mechanism, the client sends a Send indication
        to the TURN server containing (a) an XOR-PEER-ADDRESS attribute
        specify the (server-reflexive) transport address of the peer and (b) a
        DATA attribute holding the application data. When the TURN server
        receives the Send indication, it extracts the application data from
        the DATA attribute and sends it in a UDP datagram to the peer, using
        the allocated relay address as the source address. Note that there is
        no need to specify the relayed transport address, since it is implied
        by the 5-tuple used for the Send indication.
</p>
<p>In the reverse direction, UDP datagrams arriving at the relayed
        transport address on the TURN server are converted into Data
        indications and sent to the client, with the server-reflexive
        transport address of the peer included in an XOR-PEER-ADDRESS
        attribute and the data itself in a DATA attribute. Since the relayed
        transport address uniquely identified the allocation, the server knows
        which client to relay the data to.
</p>
<p>Send and Data indications cannot be authenticated, since the
        Long-Term Credential Mechanism of STUN does not support authenticating
        indications. This is not as big an issue as it might first appear,
        since the client-to-server leg is only half of the total path to the
        peer; applications that want proper security need to use encryption or
        similar to protect their data in the UDP datagrams between the server
        and the peer. However, to prevent attackers from injecting rogue Send
        indications to arbitrary destinations, TURN requires that a client
        install a permission to a peer before sending data to it using a Send
        indication.
</p><br /><hr class="insert" />
<a name="fig-send-data"></a>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>TURN                                 TURN           Peer          Peer
client                               server          A             B
  |                                    |             |             |
  |-- CreatePermission req (Peer A) --&gt;|             |             |
  |&lt;-- CreatePermission success resp --|             |             |
  |                                    |             |             |
  |--- Send ind (Peer A)--------------&gt;|             |             |
  |                                    |=== data ===&gt;|             |
  |                                    |             |             |
  |                                    |&lt;== data ====|             |
  |&lt;-------------- Data ind (Peer A) --|             |             |
  |                                    |             |             |
  |                                    |             |             |
  |--- Send ind (Peer B)--------------&gt;|             |             |
  |                                    | dropped     |             |
  |                                    |             |             |
  |                                    |&lt;== data ==================|
  |                            dropped |             |             |
  |                                    |             |             |
</pre></div>
<p>
</p><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;3&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>In <a class='info' href='#fig-send-data'>Figure&nbsp;3</a>, the client has already
        created an allocation and now wishes to send data to its peers. The
        client first creates a permission by sending the server a
        CreatePermission request specifying peer A's (server reflexive) IP
        address in the XOR-PEER-ADDRESS attribute; if this was not done, the
        server would not relay data between the client and the server. The
        client then sends data to Peer A using a Send indication; at the
        server, the application data is extracted and forwarded in a UDP
        datagram to Peer A, using the relayed transport address as the source
        transport address. When a UDP datagram from Peer A is received at the
        relayed transport address, the contents are placed into a Data
        indication and forwarded to the client. Later, the client attempts to
        exchange data with Peer B, however no permission has been installed
        for Peer B, so the Send indication from the client and the UDP
        datagram from the peer are both dropped by the server.
</p>
<a name="anchor4"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2.5"></a><h3>2.5.&nbsp;
Channels</h3>

<p>For some applications (e.g. Voice over IP), the 36 bytes of
        overhead that a Send indication or Data indication adds to the
        application data can substantially increase the bandwidth required
        between the client and the server. To remedy this, TURN offers a
        second way for the client and server to associate data with a specific
        peer.
</p>
<p>This second way uses an alternate packet format known as the
        ChannelData message. The ChannelData message does not use the STUN
        header used by other TURN messages, but instead has a 4-byte header
        that includes a number known as a channel number. Each channel number
        in use is bound to a specific peer and thus serves as a shorthand for
        the peer's host transport address.
</p>
<p>To bind a channel to a peer, the client sends a ChannelBind request
        to the server, and includes an unbound channel number and the
        transport address of the peer. Once the channel is bound, the client
        can use a ChannelData message to send the server data destined for the
        peer. Similarly, the server can relay data from that peer towards the
        client using a ChannelData message.
</p>
<p>Channel bindings last for 10 minutes unless refreshed. Channel
        bindings are refreshed by sending another ChannelBind request
        rebinding the channel to the peer. Like permissions (but unlike
        allocations), there is no way to explicitly delete a channel binding;
        the client must simply wait for it to time out.
</p><br /><hr class="insert" />
<a name="fig-channels"></a>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>TURN                                 TURN           Peer          Peer
client                               server          A             B
  |                                    |             |             |
  |-- ChannelBind req ----------------&gt;|             |             |
  | (Peer A to 0x4001)                 |             |             |
  |                                    |             |             |
  |&lt;---------- ChannelBind succ resp --|             |             |
  |                                    |             |             |
  |-- [0x4001] data ------------------&gt;|             |             |
  |                                    |=== data ===&gt;|             |
  |                                    |             |             |
  |                                    |&lt;== data ====|             |
  |&lt;------------------ [0x4001] data --|             |             |
  |                                    |             |             |
  |--- Send ind (Peer A)--------------&gt;|             |             |
  |                                    |=== data ===&gt;|             |
  |                                    |             |             |
  |                                    |&lt;== data ====|             |
  |&lt;------------------ [0x4001] data --|             |             |
  |                                    |             |             |
</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;4&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>shows the channel mechanism in use. The client has already created
        an allocation and now wishes to bind a channel to peer A. To do this,
        the client sends a ChannelBind request to the server, specifying the
        transport address of Peer A and a channel number (0x4001). After that,
        the client can send application data encapsulated inside ChannelData
        messages to Peer A: this is shown as "[0x4001] data" where 0x4001 is
        the channel number. When the ChannelData message arrives at the
        server, the server transfers the data to a UDP datagram and sends it
        to the peer A, as indicated by the channel number. When peer A sends a
        UDP datagram to the relayed transport address, the data is placed
        inside a ChannelData message and sent to the client.
</p>
<p>Once a channel has been bound, the client is free to intermix
        ChannelData messages and Send indications. In the figure, the client
        later decides to use a Send indication rather than a ChannelData
        message to send additional data to peer A. The client might decide to
        do this, for example, so it can use the DONT-FRAGMENT attribute (see
        the next section). However, once a channel is bound, the server will
        always use a ChannelData message, as shown in the call flow.
</p>
<p>Note that ChannelData messages can only be used for peers to which
        the client has bound a channel. In the example above, Peer A has been
        bound to a channel, but Peer B has not, so application data to and
        from Peer B would use the Send mechanism.
</p>
<a name="anchor5"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2.6"></a><h3>2.6.&nbsp;
Other Features</h3>

<p>This section describes a few other features of TURN.
</p>
<p>Old versions of RTP <a class='info' href='#RFC3550'>[RFC3550]<span> (</span><span class='info'>Schulzrinne, H., Casner, S., Frederick, R., and V. Jacobson, &ldquo;RTP: A Transport Protocol for Real-Time Applications,&rdquo; July&nbsp;2003.</span><span>)</span></a> required that
        the RTP stream be on an even port number and the associated RTCP
        stream, if present, be on the next highest port. To allow clients to
        work with nodes that still require this, TURN allows the client to
        request that the server allocate a relayed-transport-address with an
        even port number, and to optionally request the server reserve the
        next-highest port number for a subsequent allocation.
</p>
<p>If appropriate, a TURN server can reject an Allocate request with
        the suggestion that the client try an alternative server.
</p>
<p>TURN is designed so that the server can be implemented as an
        application that runs in userland under commonly available operating
        systems and which does not requiring special privileges. This design
        decision has the following implications:</p>
<ul class="text">
<li>The value of the Diff-Serv field may not be preserved across
            the server;
</li>
<li>The TTL field may be reset, rather than decremented, across the
            server;
</li>
<li>The ECN field may be reset by the server;
</li>
<li>ICMP messages are not relayed by the server;
</li>
<li>Path MTU Discovery does not work, except in the limited way
            available using the DONT-FRAGMENT attribute (see below); and
</li>
<li>There is no end-to-end fragmentation, since the packet is
            re-assembled at the server.
</li>
</ul><p>Future work may specify alternate TURN semantics that address
        these limitations.
</p>
<p>To provide a limited form of Path MTU discovery, TURN has a
        DONT-FRAGMENT attribute. The client may include this attribute in a
        Send indication to specify that the server set the DF (Don't Fragment)
        bit in the UDP datagram that it sends to the peer. Since some servers
        may be unable to set the DF bit, the client should also include this
        attribute in the Allocate request; servers that do not support this
        feature will reject the Allocate request. Note that, because the
        server does not relay ICMP messages, the client may need to use a Path
        MTU discovery algorithm based on the one in <a class='info' href='#RFC4821'>[RFC4821]<span> (</span><span class='info'>Mathis, M. and J. Heffner, &ldquo;Packetization Layer Path MTU Discovery,&rdquo; March&nbsp;2007.</span><span>)</span></a>.
</p>
<a name="anchor6"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3"></a><h3>3.&nbsp;
Terminology</h3>

<p>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
      "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
      document are to be interpreted as described in <a class='info' href='#RFC2119'>RFC 2119<span> (</span><span class='info'>Bradner, S., &ldquo;Key words for use in RFCs to Indicate Requirement Levels,&rdquo; March&nbsp;1997.</span><span>)</span></a> [RFC2119].
</p>
<p>Readers are expected to be familiar with <a class='info' href='#RFC5389'>[RFC5389]<span> (</span><span class='info'>Rosenberg, J., Mahy, R., Matthews, P., and D. Wing, &ldquo;Session Traversal Utilities for NAT (STUN),&rdquo; October&nbsp;2008.</span><span>)</span></a> and the terms defined there.
</p>
<p>The following terms are used in this document:
</p>
<p></p>
<blockquote class="text"><dl>
<dt>TURN:</dt>
<dd>The protocol spoken between a TURN client and a
          TURN server. It is an extension to the STUN protocol <a class='info' href='#RFC5389'>[RFC5389]<span> (</span><span class='info'>Rosenberg, J., Mahy, R., Matthews, P., and D. Wing, &ldquo;Session Traversal Utilities for NAT (STUN),&rdquo; October&nbsp;2008.</span><span>)</span></a>. The protocol allows a client to allocate
          and use a relayed transport address.
</dd>
<dt>TURN client:</dt>
<dd>A STUN client that implements this
          specification.
</dd>
<dt>TURN server:</dt>
<dd>A STUN server that implements this
          specification. It relays data between a TURN client and its
          peer(s).
</dd>
<dt>Peer:</dt>
<dd>A host with which the TURN client wishes to
          communicate. The TURN server relays traffic between the TURN client
          and its peer(s). The peer does not interact with the TURN server
          using the protocol defined in this document; rather, the peer
          receives data sent by the TURN server and the peer sends data
          towards the TURN server.
</dd>
<dt>Transport Address:</dt>
<dd>The combination of an IP address
          and a port.
</dd>
<dt>Host Transport Address:</dt>
<dd>A transport address on a
          client or a peer.
</dd>
<dt>Server-Reflexive Transport Address:</dt>
<dd>A transport
          address on the "public side" of a NAT. This address is allocated by
          the NAT to correspond to a specific host transport address.
</dd>
<dt>Relayed Transport Address:</dt>
<dd>A transport address on the
          TURN server that is used for relaying packets between the client and
          a peer. A peer sends to this address on the TURN server, and the
          packet is then relayed to the client.
</dd>
<dt>TURN Server Transport Address:</dt>
<dd>A transport address on
          the TURN server that is used for sending TURN messages to the
          server. This is the transport address that the client uses to
          communicate with the server.
</dd>
<dt>Peer Transport Address:</dt>
<dd>The transport address of the
          peer as seen by the server. When the peer is behind a NAT, this is
          the peer's server-reflexive transport address.
</dd>
<dt>Allocation:</dt>
<dd>The relayed transport address granted to a
          client through an Allocate request, along with related state, such
          as permissions and expiration timers.
</dd>
<dt>5-tuple:</dt>
<dd>The combination (client IP address and port,
          server IP address and port, and transport protocol (currently one of
          UDP, TCP, or TLS)) used to communicate between the client and the
          server. The 5-tuple uniquely identifies this communication stream.
          The 5-tuple also uniquely identifies the Allocation on the
          server.
</dd>
<dt>Channel:</dt>
<dd>A channel number and associated peer
          transport address. Once a channel number is bound to a peer's
          transport address, the client and server can use the more
          bandwidth-efficient ChannelData message to exchange data.
</dd>
<dt>Permission:</dt>
<dd>The IP address and transport protocol (but
          not the port) of a peer that is permitted to send traffic to the
          TURN server and have that traffic relayed to the TURN client. The
          TURN server will only forward traffic to its client from peers that
          match an existing permission.
</dd>
<dt>Realm</dt>
<dd>A string used to describe the server or a
          context within the server. The realm tells the client which username
          and password combination to use to authenticate requests.
</dd>
<dt>Nonce</dt>
<dd>A string chosen at random by the server and
          included in the message-digest. To prevent reply attacks, the server
          should change the nonce regularly.
</dd>
</dl></blockquote>

<a name="sec-general-behavior"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4"></a><h3>4.&nbsp;
General Behavior</h3>

<p>This section contains general TURN processing rules that apply to all
      TURN messages.
</p>
<p>TURN is an extension to STUN. All TURN messages, with the exception
      of the ChannelData message, are STUN-formatted messages. All the base
      processing rules described in <a class='info' href='#RFC5389'>[RFC5389]<span> (</span><span class='info'>Rosenberg, J., Mahy, R., Matthews, P., and D. Wing, &ldquo;Session Traversal Utilities for NAT (STUN),&rdquo; October&nbsp;2008.</span><span>)</span></a> apply to
      STUN-formatted messages. This means that all the message-forming and
      -processing descriptions in this document are implicitly prefixed with
      the rules of <a class='info' href='#RFC5389'>[RFC5389]<span> (</span><span class='info'>Rosenberg, J., Mahy, R., Matthews, P., and D. Wing, &ldquo;Session Traversal Utilities for NAT (STUN),&rdquo; October&nbsp;2008.</span><span>)</span></a>.
</p>
<p>In addition, the server SHOULD demand that all requests from the
      client be authenticated, using the Long-Term Credential mechanism
      described in <a class='info' href='#RFC5389'>[RFC5389]<span> (</span><span class='info'>Rosenberg, J., Mahy, R., Matthews, P., and D. Wing, &ldquo;Session Traversal Utilities for NAT (STUN),&rdquo; October&nbsp;2008.</span><span>)</span></a>, and the client MUST be
      prepared to authenticate requests if required. Note that this
      authentication mechanism applies only to requests and cannot be used to
      authenticate indications, thus indications in TURN are never
      authenticated. If the server requires requests to be authenticated, then
      the server's administrator MUST choose a realm value that will uniquely
      identify the username and password combination that the client must use,
      even if the client uses multiple servers under different
      administrations. The server's administrator MAY choose to allocate a
      unique username to each client, or MAY choose to allocate the same
      username to more than one client (for example, to all clients from the
      same department or company). For each allocation, the server SHOULD
      generate a new random nonce when the allocation is first attempted
      following the randomness recommendations in <a class='info' href='#RFC4086'>[RFC4086]<span> (</span><span class='info'>Eastlake, D., Schiller, J., and S. Crocker, &ldquo;Randomness Requirements for Security,&rdquo; June&nbsp;2005.</span><span>)</span></a> and SHOULD expire the nonce at least once every
      hour during the lifetime of the allocation.
</p>
<p>All requests after the initial Allocate must use the same username as
      that used to create the allocation, to prevent attackers from hijacking
      the client's allocation. Specifically, if the server requires the use of
      the Long-Term Credential mechanism, and if a non-Allocate request passes
      authentication under this mechanism, and if the 5-tuple identifies an
      existing allocation, but the request does not use the same username as
      used to create the allocation, then the request MUST be rejected with a
      441 (Wrong Credentials) error.
</p>
<p>When a TURN message arrives at the server from the client, the server
      uses the 5-tuple in the message to identify the associated allocation.
      For all TURN messages (including ChannelData) EXCEPT an Allocate
      request, if the 5-tuple does not identify an existing allocation, then
      the message MUST either be rejected with a 437 Allocation Mismatch error
      (if it is a request), or silently ignored (if it is an indication or a
      ChannelData message). A client receiving a 437 error response to a
      request other than Allocate MUST assume the allocation no longer
      exists.
</p>
<p>The client SHOULD include the SOFTWARE attribute in all Allocate and
      Refresh requests and MAY include it in any other requests or
      indications. The server SHOULD include the SOFTWARE attribute in all
      Allocate and Refresh responses (either success or failure) and MAY
      include it in other responses or indications. The client and the server
      MAY include the FINGERPRINT attribute in any STUN-formatted messages
      defined in this document.
</p>
<p>TURN does not use the backwards-compatibility mechanism described in
      <a class='info' href='#RFC5389'>[RFC5389]<span> (</span><span class='info'>Rosenberg, J., Mahy, R., Matthews, P., and D. Wing, &ldquo;Session Traversal Utilities for NAT (STUN),&rdquo; October&nbsp;2008.</span><span>)</span></a>.
</p>
<p>By default, TURN runs on the same ports as STUN: 3478 for TURN over
      UDP and TCP, and 5349 for TURN over TLS. However, TURN has its own set
      of SRV service names: "turn" for UDP and TCP, and "turns" for TLS.
      Either the SRV procedures or the ALTERNATE-SERVER procedures, both
      described in <a class='info' href='#sec-create-allocation'>Section&nbsp;6<span> (</span><span class='info'>Creating an Allocation</span><span>)</span></a>, can be used
      to run TURN on a different port.
</p>
<p>TURN as defined in this specification only supports IPv4. The
      client's IP address, the server's IP address and all IP addresses
      appearing in a relayed-transport-address MUST be IPv4 addresses.
</p>
<p>When UDP transport is used between the client and the server, the
      client will retransmit a request if it does not receive a response
      within a certain timeout period. Because of this, the server may receive
      two (or more) requests with the same 5-tuple and same transaction id.
      STUN requires that the server recognize this case and treat the request
      as idempotent (see <a class='info' href='#RFC5389'>[RFC5389]<span> (</span><span class='info'>Rosenberg, J., Mahy, R., Matthews, P., and D. Wing, &ldquo;Session Traversal Utilities for NAT (STUN),&rdquo; October&nbsp;2008.</span><span>)</span></a>). Some implementations
      may choose to meet this requirement by remembering all received requests
      and the corresponding responses for 40 seconds. Other implementations
      may choose to reprocess the request and arrange that such reprocessing
      returns essentially the same response. To aid implementors who choose
      the latter approach (the so-called "stateless stack approach"), this
      specification includes some implementation notes on how this might be
      done. Implementations are free to choose either approach or choose some
      other approach that gives the same results.
</p>
<p>When TCP transport is used between the client and the server, it is
      possible that a bit error will cause a length field in a TURN packet to
      become corrupted, causing the receiver to lose synchronization with the
      incoming stream of TURN messages. A client or server which detects a
      long sequence of invalid TURN messages over TCP transport SHOULD close
      the corresponding TCP connection to help the other end detect this
      situation more rapidly.
</p>
<p>To mitigate either intentional or unintentional denial-of-service
      attacks against the server by clients with valid usernames and
      passwords, it is RECOMMENDED that the server impose limits on both the
      number of allocations active at one time for a given username and on the
      amount of bandwidth those allocations can use. The server should reject
      new allocations that would exceed the limit on the allowed number of
      allocations active at one time with a 486 (Allocation Quota Exceeded)
      (see <a class='info' href='#sec-rcv-allocate'>Section&nbsp;6.2<span> (</span><span class='info'>Receiving an Allocate Request</span><span>)</span></a>), and should discard
      application data traffic that exceeds the bandwidth quota.
</p>
<a name="sec-allocations"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5"></a><h3>5.&nbsp;
Allocations</h3>

<p>All TURN operations revolve around allocations, and all TURN messages
      are associated with an allocation. An allocation conceptually consists
      of the following state data:</p>
<ul class="text">
<li>the relayed transport address
</li>
<li>The 5-tuple: (client's IP address, client's port, server IP
          address, server port, transport protocol)
</li>
<li>the authentication information
</li>
<li>the time-to-expiry
</li>
<li>A list of permissions
</li>
<li>A list of channel to peer bindings
</li>
</ul><p>The relayed transport address is the transport address
      allocated by the server for communicating with peers, while the 5-tuple
      describes the communication path between the client and the server. On
      the client, the 5-tuple uses the client's host transport address, while
      on the server the 5-tuple uses the client's server-reflexive transport
      address.
</p>
<p>Both the relayed-transport-address and the 5-tuple MUST be unique
      across all allocations, so either one can be used to uniquely identify
      the allocation.
</p>
<p>The authentication information (e.g., username, password, realm, and
      nonce) are used to both verify subsequent requests and to compute the
      message integrity of responses. The username, realm, and nonce values
      are initially those used in the authenticated Allocate request that
      creates the allocation, though the server can change the nonce value
      during the lifetime of the allocation using a 438 (Stale Nonce) reply.
      Note that rather than storing the password explicitly, it may be
      desirable for security reasons for the server to store the key value
      which is an MD5 hash over the username, realm and password (see <a class='info' href='#RFC5389'>[RFC5389]<span> (</span><span class='info'>Rosenberg, J., Mahy, R., Matthews, P., and D. Wing, &ldquo;Session Traversal Utilities for NAT (STUN),&rdquo; October&nbsp;2008.</span><span>)</span></a>).
</p>
<p>The time-to-expiry is the time in seconds left until the allocation
      expires. Each Allocate or Refresh transaction sets this timer, which
      then ticks down towards 0. By default, each Allocate or Refresh
      transaction resets this timer to 600 seconds (10 minutes), but the
      client can request a different value in the Allocate and Refresh
      request. Allocations can only be refreshed using the Refresh request;
      sending data to a peer does not refresh an allocation. When an
      allocation expires, the state data associated with the allocation can be
      freed.
</p>
<p>The list of permissions is described in <a class='info' href='#sec-permissions'>Section&nbsp;8<span> (</span><span class='info'>Permissions</span><span>)</span></a> and the list of channels is described
      in <a class='info' href='#sec-channels'>Section&nbsp;11<span> (</span><span class='info'>Channels</span><span>)</span></a>.
</p>
<a name="sec-create-allocation"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6"></a><h3>6.&nbsp;
Creating an Allocation</h3>

<p>An allocation on the server is created using an Allocate
      transaction.
</p>
<a name="sec-send-allocate"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.1"></a><h3>6.1.&nbsp;
Sending an Allocate Request</h3>

<p>The client forms an Allocate request as follows.
</p>
<p>The client first picks a host transport address. It is RECOMMENDED
        that the client pick a currently-unused transport address, typically
        by allowing the underlying OS to pick a currently-unused port for a
        new socket.
</p>
<p>The client then picks a transport protocol to use between the
        client and the server. The transport protocol MUST be one of UDP, TCP,
        or TLS over TCP. Since this specification only allows UDP between the
        server and the peers, it is RECOMMENDED that the client pick UDP
        unless it has a reason to use a different transport. One reason to
        pick a different transport would be that the client believes, either
        through configuration or by experiment, that it is unable to contact
        any TURN server using UDP. See <a class='info' href='#sec-transports'>Section&nbsp;2.1<span> (</span><span class='info'>Transports</span><span>)</span></a>
        for more discussion.
</p>
<p>The client also picks a server transport address, which SHOULD be
        done as follows. The client receives (perhaps through configuration) a
        domain name for a TURN server. The client then uses the DNS procedures
        described in <a class='info' href='#RFC5389'>[RFC5389]<span> (</span><span class='info'>Rosenberg, J., Mahy, R., Matthews, P., and D. Wing, &ldquo;Session Traversal Utilities for NAT (STUN),&rdquo; October&nbsp;2008.</span><span>)</span></a>, but using an SRV service
        name of "turn" (or "turns" for TURN over TLS) instead of "stun" (or
        "stuns"). For example, to find servers in the example.com domain, the
        client performs a lookup for '_turn._udp.example.com',
        '_turn._tcp.example.com', and '_turns._tcp.example.com' if the client
        wants to communicate with the server using UDP, TCP, or TLS over TCP,
        respectively.
</p>
<p>The client MUST include a REQUESTED-TRANSPORT attribute in the
        request. This attribute specifies the transport protocol between the
        server and the peers (note that this is NOT the transport protocol
        that appears in the 5-tuple). In this specification, the
        REQUESTED-TRANSPORT type is always UDP. This attribute is included to
        allow future extensions specify other protocols.
</p>
<p>If the client wishes the server to initialize the time-to-expiry
        field of the allocation to some value other the default lifetime, then
        it MAY include a LIFETIME attribute specifying its desired value. This
        is just a request, and the server may elect to use a different value.
        Note that the server will ignore requests to initialize the field to
        less than the default value.
</p>
<p>If the client wishes to later use the DONT-FRAGMENT attribute in
        one or more Send indications on this allocation, then the client
        SHOULD include the DONT-FRAGMENT attribute in the Allocate request.
        This allows the client to test whether this attribute is supported by
        the server.
</p>
<p>If the client requires the port number of the relayed-transport
        address be even, the client includes the EVEN-PORT attribute. If this
        attribute is not included, then the port can be even or odd. By
        setting the R bit in the EVEN-PORT attribute to 1, the client can
        request that the server reserve the next highest port number (on the
        same IP address) for a subsequent allocation. If the R bit is 0, no
        such request is made.
</p>
<p>The client MAY also include a RESERVATION-TOKEN attribute in the
        request to ask the server to use a previously reserved port for the
        allocation. If the RESERVATION-TOKEN attribute is included, then the
        client MUST omit the EVEN-PORT attribute.
</p>
<p>Once constructed, the client sends the Allocate request on the
        5-tuple.
</p>
<a name="sec-rcv-allocate"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.2"></a><h3>6.2.&nbsp;
Receiving an Allocate Request</h3>

<p>When the server receives an Allocate request, it performs the
        following checks:</p>
<ol class="text">
<li>The server SHOULD require that the request be authenticated
            using the Long-Term Credential mechanism of <a class='info' href='#RFC5389'>[RFC5389]<span> (</span><span class='info'>Rosenberg, J., Mahy, R., Matthews, P., and D. Wing, &ldquo;Session Traversal Utilities for NAT (STUN),&rdquo; October&nbsp;2008.</span><span>)</span></a>.
</li>
<li>The server checks if the 5-tuple is currently in use by an
            existing allocation. If yes, the server rejects the request with a
            437 (Allocation Mismatch) error.
</li>
<li>The server checks if the request contain a REQUESTED-TRANSPORT
            attribute. If the REQUESTED-TRANSPORT attribute is not included or
            is malformed, the server rejects the request with a 400 (Bad
            Request) error. Otherwise, if the attribute is included but
            specifies a protocol other that UDP, the server rejects the
            request with a 442 (Unsupported Transport Protocol) error.
</li>
<li>The request may contain a DONT-FRAGMENT attribute. If it does,
            but the server does not support sending UDP datagrams with the DF
            bit set to 1 (see <a class='info' href='#sec-ip-header-fields'>Section&nbsp;12<span> (</span><span class='info'>IP Header Fields</span><span>)</span></a>),
            then the server treats the DONT-FRAGMENT attribute in the Allocate
            request as an unknown comprehension-required attribute.
</li>
<li>The server checks if the request contains an EVEN-PORT
            attribute. If yes, then the server checks that it satisfy the
            request. If the server cannot satisfy the request, then the server
            rejects the request with a 508 (Insufficient Port Capacity)
            error.
</li>
<li>The server checks if the request contains a RESERVATION-TOKEN
            attribute. If yes, and the request also contains a EVEN-PORT
            attribute, then the server rejects the request with a 400 (Bad
            Request) error. Otherwise it checks to see if the token is valid
            (i.e., the token is in range and has not expired, and the
            corresponding relayed transport address is still available). If
            the token is not valid for some reason, the server rejects the
            request with a 508 (Insufficient Port Capacity) error.
</li>
<li>At any point, the server MAY choose to reject the request with
            a 486 (Allocation Quota Reached) error if it feels the client is
            trying to exceed some locally-defined allocation quota. The server
            is free to define this allocation quota any way it wishes, but
            SHOULD define it based on the username used to authenticate the
            request, and not on the client's transport address.
</li>
<li>Also at any point, the server MAY choose to reject the request
            with a 300 (Try Alternate) error if it wishes to redirect the
            client to a different server. The use of this error code and
            attribute follow the specification in <a class='info' href='#RFC5389'>[RFC5389]<span> (</span><span class='info'>Rosenberg, J., Mahy, R., Matthews, P., and D. Wing, &ldquo;Session Traversal Utilities for NAT (STUN),&rdquo; October&nbsp;2008.</span><span>)</span></a>, with the modification that a TURN server
            MAY return this error code and attribute in unauthenticated error
            responses as well as in authenticated error responses.
</li>
</ol>

<p>If all the checks pass, the server creates the allocation. The
        5-tuple is set to the 5-tuple from the Allocate request, while the
        list of permissions and the list of channels are initially empty.
</p>
<p>The server chooses a relayed-transport-address for the allocation
        as follows:</p>
<ul class="text">
<li>If the request contains an EVEN-PORT attribute with the R bit
            set to 0, then the server allocates a relayed-transport-address
            with an even port number.
</li>
<li>If the request contains an EVEN-PORT attribute with the R bit
            set to 1, then the server looks for a pair of port numbers N and
            N+1 on the same IP address, where N is even. Port N is used in the
            current allocation, while the relayed transport address with port
            N+1 is assigned a token and reserved for a future allocation. The
            server MUST hold this reservation for at least 30 seconds, and MAY
            choose to hold longer (e.g. until the allocation with port N
            expires). The server then includes the token in a
            RESERVATION-TOKEN attribute in the success response.
</li>
<li>If the request contains a RESERVATION-TOKEN, the server uses
            the previously-reserved transport address corresponding to the
            included token (if it is still available). Note that the
            reservation is a server-wide reservation and is not specific to a
            particular allocation, since the Allocate request containing the
            RESERVATION-TOKEN uses a different 5-tuple than the Allocate
            request that made the reservation. The 5-tuple for the Allocate
            request containing the RESERVATION-TOKEN attribute can be any
            allowed 5-tuple; it can use a different client IP address and
            port, a different transport protocol, and even different server IP
            address and port (provided, of course, that the server IP address
            and port is one that the server is listening for TURN requests
            on).
</li>
<li>Otherwise, the server allocates any available
            relayed-transport-address.
</li>
</ul>

<p>In all cases, the server SHOULD only allocate ports from the range
        49152 &ndash; 65535 (the Dynamic and/or Private Port range <a class='info' href='#Port-Numbers'>[Port&#8209;Numbers]<span> (</span><span class='info'>, &ldquo;IANA Port Numbers Registry,&rdquo; .</span><span>)</span></a>), unless the TURN server application
        knows, through some means not specified here, that other applications
        running on the same host as the TURN server application will not be
        impacted by allocating ports outside this range. This condition can
        often be satisfied by running the TURN server application on a
        dedicated machine and/or by arranging that any other applications on
        the machine allocate ports before the TURN server application starts.
        In any case, the TURN server SHOULD NOT allocate ports in the range 0
        - 1023 (the Well-Known Port range) to discourage clients from using
        TURN to run standard services.
</p>
<p></p>
<blockquote class="text">
<p>NOTE: The IETF is currently investigating the topic of
            randomized port assignments to avoid certain types of attacks (see
            <a class='info' href='#I-D.ietf-tsvwg-port-randomization'>[I&#8209;D.ietf&#8209;tsvwg&#8209;port&#8209;randomization]<span> (</span><span class='info'>Larsen, M. and F. Gont, &ldquo;Transport Protocol Port Randomization Recommendations,&rdquo; April&nbsp;2010.</span><span>)</span></a>). It is
            strongly recommended that a TURN implementor keep abreast of this
            topic and, if appropriate, implement a randomized port assignment
            algorithm. This is especially applicable to servers that choose to
            pre-allocate a number of ports from the underlying OS and then
            later assign them to allocations; for example, a server may choose
            this technique to implement the EVEN-PORT attribute.
</p>
</blockquote>

<p>The server determines the initial value of the time-to-expiry field
        as follows. If the request contains a LIFETIME attribute, and the
        proposed lifetime value is greater than the default lifetime, and the
        proposed lifetime value is otherwise acceptable to the server, then
        the server uses that value. Otherwise, the server uses the default
        lifetime. It is RECOMMENDED that the server impose a maximum lifetime
        of no more than 3600 seconds (1 hour). Servers that implement
        allocation quotas or charge users for allocations in some way may wish
        to use a smaller maximum lifetime (perhaps as small as the default
        lifetime) to more quickly remove orphaned allocations (that is,
        allocations where the corresponding client has crashed or terminated
        or the client connection has been lost for some reason). Also note
        that the time-to-expiry is recomputed with each successful Refresh
        request, and thus the value computed here applies only until the first
        refresh.
</p>
<p>Once the allocation is created, the server replies with a success
        response. The success response contains:</p>
<ul class="text">
<li>A XOR-RELAYED-ADDRESS attribute containing the relayed
            transport address;
</li>
<li>A LIFETIME attribute containing the current value of the
            time-to-expiry timer;
</li>
<li>A RESERVATION-TOKEN attribute (if a second relayed transport
            address was reserved).
</li>
<li>An XOR-MAPPED-ADDRESS attribute containing the client's IP
            address and port (from the 5-tuple).
</li>
</ul>

<p></p>
<blockquote class="text">
<p>NOTE: The XOR-MAPPED-ADDRESS attribute is included in the
            response as a convenience to the client. TURN itself does not make
            use of this value, but clients running ICE can often need this
            value and can thus avoid having to do an extra Binding transaction
            with some STUN server to learn it.
</p>
</blockquote>

<p>The response (either success or error) is sent back to the client
        on the 5-tuple.
</p>
<p></p>
<blockquote class="text">
<p>NOTE: Implementations may implement the idempotency of the
            Allocate request over UDP using the so-called "stateless stack
            approach" as follows. To detect retransmissions when the original
            request was successful in creating an allocation, the server can
            store the transaction id that created the request with the
            allocation data and compare it with incoming Allocate requests on
            the same 5-tuple. Once such a request is detected, the server can
            stop parsing the request and immediately generate a success
            response. When building this response, the value of the LIFETIME
            attribute can be taken from the time-to-expiry field in the
            allocate state data, even though this value may differ slightly
            from the LIFETIME value originally returned. In addition, the
            server may need to store an indication of any reservation token
            returned in the original response, so that this may be returned in
            any retransmitted responses.
</p>
<p>For the case where the original request was unsuccessful in
            creating an allocation, the server may choose to do nothing
            special. Note, however, that there is a rare case where the server
            rejects the original request but accepts the retransmitted request
            (because conditions have changed in the brief intervening time
            period). If the client receives the first failure response, it
            will ignore the second (success) response and believe that an
            allocation was not created. An allocation created in this matter
            will eventually timeout, since the client will not refresh it.
            Furthermore, if the client later retries with the same 5-tuple but
            different transaction id, it will receive a 437 (Allocation
            Mismatch), which will cause it to retry with a different 5-tuple.
            The server may use a smaller maximum lifetime value to minimize
            the lifetime of allocations "orphaned" in this manner.
</p>
</blockquote>

<a name="anchor7"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.3"></a><h3>6.3.&nbsp;
Receiving an Allocate Success Response</h3>

<p>If the client receives an Allocate success response, then it MUST
        check that the mapped address and the relayed transport address are in
        an address family that the client understands and is prepared to deal
        with. This specification only covers the case where these two
        addresses are IPv4 addresses. If these two addresses are not in an
        address family that the client is prepared to deal with, then the
        client MUST delete the allocation (<a class='info' href='#sec-refreshing-allocation'>Section&nbsp;7<span> (</span><span class='info'>Refreshing an Allocation</span><span>)</span></a>) and MUST NOT attempt to
        create another allocation on that server until it believes the
        mismatch has been fixed.
</p>
<p></p>
<blockquote class="text">
<p>The IETF is currently considering mechanisms for transitioning
            between IPv4 and IPv6 that could result in a client originating an
            Allocate request over IPv6, but the request would arrive at the
            server over IPv4, or vica-versa. Hence the importance of this
            check.
</p>
</blockquote>

<p>Otherwise, the client creates its own copy of the allocation data
        structure to track what is happening on the server. In particular, the
        client needs to remember the actual lifetime received back from the
        server, rather than the value sent to the server in the request. The
        client must also remember the 5-tuple used for the request and the
        username and password it used to authenticate the request to ensure
        that it reuses them for subsequent messages. The client also needs to
        track the channels and permissions it establishes on the server.
</p>
<p>The client will probably wish to send the relayed transport address
        to peers (using some method not specified here) so the peers can
        communicate with it. The client may also wish to use the
        server-reflexive address it receives in the XOR-MAPPED-ADDRESS
        attribute in its ICE processing.
</p>
<a name="anchor8"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.4"></a><h3>6.4.&nbsp;
Receiving an Allocate Error Response</h3>

<p>If the client receives an Allocate error response, then the
        processing depends on the actual error code returned:</p>
<ul class="text">
<li>(Request timed out): There is either a problem with the server,
            or a problem reaching the server with the chosen transport. The
            client considers the current transaction as having failed but MAY
            choose to retry the Allocate request using a different transport
            (e.g., TCP instead of UDP).
</li>
<li>300 (Try Alternate): The server would like the client to use
            the server specified in the ALTERNATE-SERVER attribute instead.
            The client considers the current transaction as having failed, but
            SHOULD try the Allocate request with the alternate server before
            trying any other servers (e.g., other servers discovered using the
            SRV procedures). When trying the Allocate request with the
            alternate server, the client follows the ALTERNATE-SERVER
            procedures specified in <a class='info' href='#RFC5389'>[RFC5389]<span> (</span><span class='info'>Rosenberg, J., Mahy, R., Matthews, P., and D. Wing, &ldquo;Session Traversal Utilities for NAT (STUN),&rdquo; October&nbsp;2008.</span><span>)</span></a> with the
            following changes: the client SHOULD accept unauthenticated error
            responses containing the 300 (Try Alternate) error code, the
            client MUST ensure that the realm value received from the
            alternate server is as expected, the client MUST use the same
            transport protocol to the alternate server as it used to the
            original server, and the client MUST use the same username and
            password as it would have with the original server. The latter
            checks protect against an attacker sending the client an
            unauthenticated Allocate error response that redirects the client
            to some totally different and unexpected server.
</li>
<li>400 (Bad Request): The server believes the client's request is
            malformed for some reason. The client considers the current
            transaction as having failed. The client MAY notify the user or
            operator and SHOULD NOT retry the request with this server until
            it believes the problem has been fixed.
</li>
<li>401 (Unauthorized): If the client has followed the procedures
            of the Long-Term Credential mechanism and still gets this error,
            then the server is not accepting the client's credentials. In this
            case, the client considers the current transaction as having
            failed and SHOULD notify the user or operator. The client SHOULD
            NOT send any further requests to this server until it believes the
            problem has been fixed.
</li>
<li>403 (Forbidden): The request is valid, but the server is
            refusing to perform it, likely due to administrative restrictions.
            The client considers the current transaction as having failed. The
            client MAY notify the user or operator and SHOULD NOT retry the
            same request with this server until it believes the problem has
            been fixed.
</li>
<li>420 (Unknown Attribute): If the client included a DONT-FRAGMENT
            attribute in the request and the server rejected the request with
            a 420 error code and listed the DONT-FRAGMENT attribute in the
            UNKNOWN-ATTRIBUTES attribute in the error response, then the
            client now knows that the server does not support the
            DONT-FRAGMENT attribute. The client considers the current
            transaction as having failed but MAY choose to retry the Allocate
            request without the DONT-FRAGMENT attribute.
</li>
<li>437 (Allocation Mismatch): This indicates that the client has
            picked a 5-tuple which the server sees as already in use. One way
            this could happen is if an intervening NAT assigned a mapped
            transport address that was used by another client which recently
            crashed. The client considers the current transaction as having
            failed. The client SHOULD pick another client transport address
            and retry the Allocate request (using a different transaction id).
            The client SHOULD try three different client transport addresses
            before giving up on this server. Once the client gives up on the
            server, it SHOULD NOT try to create another allocation on the
            server for 2 minutes.
</li>
<li>438 (Stale Nonce): See the procedures for the Long-Term
            Credential mechanism <a class='info' href='#RFC5389'>[RFC5389]<span> (</span><span class='info'>Rosenberg, J., Mahy, R., Matthews, P., and D. Wing, &ldquo;Session Traversal Utilities for NAT (STUN),&rdquo; October&nbsp;2008.</span><span>)</span></a>.
</li>
<li>441 (Wrong Credentials): The client should not receive this
            error in response to a Allocate request. The client MAY notify the
            user or operator and SHOULD NOT retry the same request with this
            server until it believes the problem has been fixed.
</li>
<li>442 (Unsupported Transport Address): The client should not
            receive this error in response to a request for a UDP allocation.
            The client MAY notify the user or operator and SHOULD NOT
            reattempt the request with this server until it believes the
            problem has been fixed.
</li>
<li>486 (Allocation Quota Reached): The server is currently unable
            to create any more allocations with this username. The client
            considers the current transaction as having failed. The client
            SHOULD wait at least 1 minute before trying to create any more
            allocations on the server.
</li>
<li>508 (Insufficient Port Capacity): The server has no more
            relayed transport addresses available, or has none with the
            requested properties, or the one that was reserved is no longer
            available. The client considers the current operation as having
            failed. If the client is using either the EVEN-PORT or the
            RESERVATION-TOKEN attribute, then the client MAY choose to remove
            or modify this attribute and try again immediately. Otherwise, the
            client SHOULD wait at least 1 minute before trying to create any
            more allocations on this server.
</li>
</ul>

<a name="sec-refreshing-allocation"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7"></a><h3>7.&nbsp;
Refreshing an Allocation</h3>

<p>A Refresh transaction can be used to either (a) refresh an existing
      allocation and update its time-to-expiry, or (b) delete an existing
      allocation.
</p>
<p>If a client wishes to continue using an allocation, then the client
      MUST refresh it before it expires. It is suggested that the client
      refresh the allocation roughly 1 minute before it expires. If a client
      no longer wishes to use an allocation, then it SHOULD explicitly delete
      the allocation. A client MAY also refresh an allocation at any time for
      other reasons.
</p>
<a name="anchor9"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.1"></a><h3>7.1.&nbsp;
Sending a Refresh Request</h3>

<p>If the client wishes to immediately delete an existing allocation,
        it includes a LIFETIME attribute with a value of 0. All other forms of
        the request refresh the allocation.
</p>
<p>The Refresh transaction updates the time-to-expiry timer of an
        allocation. If the client wishes the server to set the time-to-expiry
        timer to something other than the default lifetime, it includes a
        LIFETIME attribute with the requested value. The server then computes
        a new time-to-expiry value in the same way as it does for an Allocate
        transaction, with the exception that a requested lifetime of 0 causes
        the server to immediately delete the allocation.
</p>
<a name="anchor10"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.2"></a><h3>7.2.&nbsp;
Receiving a Refresh Request</h3>

<p>When the server receives a Refresh request, it processes as per
        <a class='info' href='#sec-general-behavior'>Section&nbsp;4<span> (</span><span class='info'>General Behavior</span><span>)</span></a> plus the specific rules
        mentioned here.
</p>
<p>The server computes a value called the "desired lifetime" as
        follows: If the request contains a LIFETIME attribute and the
        attribute value is 0, then the desired lifetime is 0. Otherwise, if
        the request contains a LIFETIME attribute and the attribute value is
        greater than the default lifetime, and if the attribute value is
        otherwise acceptable to the server, then the desired lifetime is the
        attribute value. Otherwise the desired lifetime is the default
        value.
</p>
<p>Subsequent processing depends on the desired lifetime value:</p>
<ul class="text">
<li>If desired lifetime is 0, then the request succeeds and the
            allocation is deleted.
</li>
<li>If the desired lifetime is non-zero, then the request succeeds
            and the allocation's time-to-expiry is set to the desired
            lifetime
</li>
</ul><p>If the request succeeds, then server sends a success response
        containing:</p>
<ul class="text">
<li>A LIFETIME attribute containing the current value of the
            time-to-expiry timer.
</li>
</ul>

<p>
</p>
<p></p>
<blockquote class="text">
<p>NOTE: A server need not do anything special to implement
            idempotency of Refresh requests over UDP using the "stateless
            stack approach". Retransmitted Refresh requests with a non-zero
            desired lifetime will simply refresh the allocation. A
            retransmitted Refresh request with a zero desired lifetime will
            cause a 437 (Allocation Mismatch) response if the allocation has
            already been deleted, but the client will treat this as equivalent
            to a success response (see below).
</p>
</blockquote>

<a name="anchor11"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.3"></a><h3>7.3.&nbsp;
Receiving a Refresh Response</h3>

<p>If the client receives a success response to its Refresh request
        with a non-zero lifetime, it updates its copy of the allocation data
        structure with the time-to-expiry value contained in the response.
</p>
<p>If the client receives a 437 (Allocation Mismatch) error response
        to a request to delete the allocation, then the allocation no longer
        exists and it should consider its request as having effectively
        succeeded.
</p>
<a name="sec-permissions"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.8"></a><h3>8.&nbsp;
Permissions</h3>

<p>For each allocation, the server keeps a list of zero or more
      permissions. Each permission consists of an IP address which uniquely
      identifies the permission, and an associated time-to-expiry. The IP
      address describes a set of peers that are allowed to send data to the
      client, and the time-to-expiry is the number of seconds until the
      permission expires.
</p>
<p>By sending either CreatePermission requests or ChannelBind requests,
      the client can cause the server to install or refresh a permission for a
      given IP address. This causes one of two things to happen:</p>
<ul class="text">
<li>If no permission for that IP address exists, then a permission is
          created with the given IP address and a time-to-expiry equal to the
          default permission lifetime.
</li>
<li>If a permission for that IP address already exists, then the
          lifetime for that permission is reset to the default permission
          lifetime.
</li>
</ul><p>The default permission lifetime MUST be 300 seconds (= 5
      minutes).
</p>
<p>Each permission&rsquo;s time-to-expiry decreases down once per second
      until it reaches 0, at which point the permission expires and is
      deleted.
</p>
<p>CreatePermission and ChannelBind requests may be freely intermixed on
      a permission. A given permission may be installed or refreshed at one
      point in time with a CreatePermission request, and then refreshed with a
      ChannelBind request at a different point in time, or vice-versa.
</p>
<p>When a UDP datagram arrives at the relayed transport address for the
      allocation, the server checks the list of permissions for that
      allocation. If there is a permission with an IP address that is equal to
      the source IP address of the UDP datagram, then the UDP datagram can be
      relayed to the client. Otherwise, the UDP datagram is silently
      discarded. Note that only IP addresses are compared; port numbers are
      irrelevant.
</p>
<p>The permissions for one allocation are totally unrelated to the
      permissions for a different allocation. If an allocation expires, all
      its permissions expire with it.
</p>
<p></p>
<blockquote class="text">
<p>NOTE: Though TURN permissions expire after 5 minutes, many NATs
          deployed at the time of publication expire their UDP bindings
          considerably faster. Thus an application using TURN will probably
          wish to send some sort of keep-alive traffic at a much faster rate.
          Applications using ICE should follow the keep-alive guidelines of
          ICE <a class='info' href='#I-D.ietf-mmusic-ice'>[I&#8209;D.ietf&#8209;mmusic&#8209;ice]<span> (</span><span class='info'>Rosenberg, J., &ldquo;Interactive Connectivity Establishment (ICE): A Protocol for Network Address Translator (NAT) Traversal for Offer/Answer Protocols,&rdquo; October&nbsp;2007.</span><span>)</span></a>, and applications not
          using ICE are advised to do something similar.
</p>
</blockquote>

<a name="anchor12"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.9"></a><h3>9.&nbsp;
CreatePermission</h3>

<p>TURN supports two ways for the client to install or refresh
      permissions on the server. This section describes one way: the
      CreatePermission request.
</p>
<p>A CreatePermission request may be used in conjunction with either the
      Send mechanism in <a class='info' href='#sec-sendanddata'>Section&nbsp;10<span> (</span><span class='info'>Send and Data Methods</span><span>)</span></a> or the Channel
      mechanism in <a class='info' href='#sec-channels'>Section&nbsp;11<span> (</span><span class='info'>Channels</span><span>)</span></a>.
</p>
<a name="anchor13"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.9.1"></a><h3>9.1.&nbsp;
Forming a CreatePermission request</h3>

<p>The client who wishes to install or refresh one or more permissions
        can send a CreatePermission request to the server.
</p>
<p>When forming a CreatePermission request, the client MUST include at
        least one XOR-PEER-ADDRESS attribute, and MAY include more than one
        such attribute. The IP address portion of each XOR-PEER-ADDRESS
        attribute contains the IP address for which a permission should be
        installed or refreshed. The port portion of each XOR-PEER-ADDRESS
        attribute will be ignored and can be any arbitrary value. The various
        XOR-PEER-ADDRESS attributes can appear in any order.
</p>
<a name="anchor14"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.9.2"></a><h3>9.2.&nbsp;
Receiving a CreatePermission request</h3>

<p>When the server receives the CreatePermission request, it processes
        as per <a class='info' href='#sec-general-behavior'>Section&nbsp;4<span> (</span><span class='info'>General Behavior</span><span>)</span></a> plus the specific
        rules mentioned here.
</p>
<p>The message is checked for validity. The CreatePermission request
        MUST contain at least XOR-PEER-ADDRESS attribute and MAY contain
        multiple such attributes. If no such attribute exists, or if any of
        these attributes are invalid, then a 400 (Bad Request) error is
        returned. If the request is valid, but the server is unable to satisfy
        the request due to some capacity limit or similar, then a 508
        (Insufficient Capacity) error is returned.
</p>
<p>The server MAY impose restrictions on the IP address and port
        values allowed in the XOR-PEER-ADDRESS attribute -- if a value is not
        allowed, the server rejects the request with a 403 (Forbidden)
        error.
</p>
<p>If the message is valid and the server is capable of carrying out
        the request, then the server installs or refreshes a permission for
        the IP address contained in each XOR-PEER-ADDRESS attribute as
        described in <a class='info' href='#sec-permissions'>Section&nbsp;8<span> (</span><span class='info'>Permissions</span><span>)</span></a>. The port portion
        of each attribute is ignored and may be any arbitrary value.
</p>
<p>The server then responds with a CreatePermission success response.
        There are no mandatory attributes in the success response.
</p>
<p></p>
<blockquote class="text">
<p>NOTE: A server need not do anything special to implement
            idempotency of CreatePermission requests over UDP using the
            "stateless stack approach". Retransmitted CreatePermission
            requests will simply refresh the permissions.
</p>
</blockquote>

<a name="anchor15"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.9.3"></a><h3>9.3.&nbsp;
Receiving a CreatePermission response</h3>

<p>If the client receives a valid CreatePermission success response,
        then the client updates its data structures to indicate that the
        permissions have been installed or refreshed.
</p>
<a name="sec-sendanddata"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.10"></a><h3>10.&nbsp;
Send and Data Methods</h3>

<p>TURN supports two mechanisms for sending and receiving data from
      peers. This section describes the use of the Send and Data mechanism,
      while <a class='info' href='#sec-channels'>Section&nbsp;11<span> (</span><span class='info'>Channels</span><span>)</span></a> describes the use of the
      Channel mechanism.
</p>
<a name="sec-forming-indication"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.10.1"></a><h3>10.1.&nbsp;
Forming a Send Indication</h3>

<p>The client can use a Send indication to pass data to the server for
        relaying to a peer. A client may use a Send indication even if a
        channel is bound to that peer. However the client MUST ensure that
        there is a permission installed for the IP address of the peer to
        which the Send indication is being sent; this prevents a third party
        from using a TURN server to send data to arbitrary destinations.
</p>
<p>When forming a Send indication, the client MUST include a
        XOR-PEER-ADDRESS attribute and a DATA attribute. The XOR-PEER-ADDRESS
        attribute contains the transport address of the peer to which the data
        is to be sent, and the DATA attribute contains the actual application
        data to be sent to the peer.
</p>
<p>The client MAY include a DONT-FRAGMENT attribute in the Send
        indication if it wishes the server to set the DF bit on the UDP
        datagram sent to the peer.
</p>
<a name="anchor16"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.10.2"></a><h3>10.2.&nbsp;
Receiving a Send Indication</h3>

<p>When the server receives a Send indication, it processes as per
        <a class='info' href='#sec-general-behavior'>Section&nbsp;4<span> (</span><span class='info'>General Behavior</span><span>)</span></a> plus the specific rules
        mentioned here.
</p>
<p>The message is first checked for validity. The Send indication MUST
        contain both a XOR-PEER-ADDRESS attribute and a DATA attribute. If one
        of these attributes is missing or invalid, then the message is
        discarded. Note that the DATA attribute is allowed to contain zero
        bytes of data.
</p>
<p>The Send indication may also contain the DONT-FRAGMENT attribute.
        If the server is unable to set the DF bit on outgoing UDP datagrams
        when this attribute is present, then the server acts as if the
        DONT-FRAGMENT attribute is an unknown comprehension-required attribute
        (and thus the Send indication is discarded).
</p>
<p>The server also checks that there is a permission installed for the
        IP address contained in the XOR-PEER-ADDRESS attribute. If no such
        permission exists, the message is discarded. Note that a Send
        indication never causes the server to refresh the permission.
</p>
<p>The server MAY impose restrictions on the IP address and port
        values allowed in the XOR-PEER-ADDRESS attribute -- if a value is not
        allowed, the server silently discards the Send indication.
</p>
<p>If everything is OK, then the server forms a UDP datagram as
        follows:</p>
<ul class="text">
<li>the source transport address is the relayed transport address
            of the allocation, where the allocation is determined by the
            5-tuple on which the Send indication arrived;
</li>
<li>the destination transport address is taken from the
            XOR-PEER-ADDRESS attribute;
</li>
<li>the data following the UDP header is the contents of the value
            field of the DATA attribute.
</li>
</ul>

<p>The handling of the DONT-FRAGMENT attribute (if present), is
        described in <a class='info' href='#sec-ip-header-fields'>Section&nbsp;12<span> (</span><span class='info'>IP Header Fields</span><span>)</span></a>.
</p>
<p>The resulting UDP datagram is then sent to the peer.
</p>
<a name="sec-sending-data-indication"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.10.3"></a><h3>10.3.&nbsp;
Receiving a UDP Datagram</h3>

<p>When the server receives a UDP datagram at a currently allocated
        relayed transport address, the server looks up the allocation
        associated with the relayed transport address. It then checks to see
        if relaying is permitted, as described in <a class='info' href='#sec-permissions'>Section&nbsp;8<span> (</span><span class='info'>Permissions</span><span>)</span></a>.
</p>
<p>If relaying is permitted, then the server checks if there is a
        channel bound to the peer that sent the UDP datagram (see <a class='info' href='#sec-channels'>Section&nbsp;11<span> (</span><span class='info'>Channels</span><span>)</span></a>). If a channel is bound, then processing
        proceeds as described in <a class='info' href='#sec-channel-relaying'>Section&nbsp;11.7<span> (</span><span class='info'>Relaying Data from the Peer</span><span>)</span></a>.
</p>
<p>If relaying is permitted but no channel is bound to the peer, then
        the server forms and sends a Data indication. The Data indication MUST
        contain both a XOR-PEER-ADDRESS and a DATA attribute. The DATA
        attribute is set to the value of the &lsquo;data octets&rsquo; field
        from the datagram, and the XOR-PEER-ADDRESS attribute is set to the
        source transport address of the received UDP datagram. The Data
        indication is then sent on the 5-tuple associated with the
        allocation.
</p>
<a name="anchor17"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.10.4"></a><h3>10.4.&nbsp;
Receiving a Data Indication</h3>

<p>When the client receives a Data indication, it checks that the Data
        indication contains both a XOR-PEER-ADDRESS and a DATA attribute, and
        discards the indication if it does not. The client SHOULD also check
        that the XOR-PEER-ADDRESS attribute value contains an IP address with
        which the client believes there is an active permission, and discard
        the Data indication otherwise. Note that the DATA attribute is allowed
        to contain zero bytes of data.
</p>
<p></p>
<blockquote class="text">
<p>NOTE: The latter check protects the client against an attacker
            who somehow manages to trick the server into installing
            permissions not desired by the client.
</p>
</blockquote>

<p>If the Data indication passes the above checks, the client delivers
        the data octets inside the DATA attribute to the application, along
        with an indication that they were received from the peer whose
        transport address is given by the XOR-PEER-ADDRESS attribute.
</p>
<a name="sec-channels"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.11"></a><h3>11.&nbsp;
Channels</h3>

<p>Channels provide a way for the client and server to send application
      data using ChannelData messages, which have less overhead than Send and
      Data indications.
</p>
<p>The ChannelData message (see <a class='info' href='#sec-channeldata-msg'>Section&nbsp;11.4<span> (</span><span class='info'>The ChannelData Message</span><span>)</span></a>) starts with a two-byte field that
      carries the channel number. The values of this field are allocated as
      follows:</p>
<blockquote class="text">
<p>0x0000 through 0x3FFF: These values can never be used for channel
          numbers.
</p>
<p>0x4000 through 0x7FFF: These values are the allowed channel
          numbers (16,383 possible values)
</p>
<p>0x8000 through 0xFFFF: These values are reserved for future
          use.
</p>
</blockquote><p>Because of this division, ChannelData messages can be
      distinguished from STUN-formatted messages (e.g., Allocate request, Send
      indication, etc) by examining the first two bits of the message:</p>
<blockquote class="text">
<p>0b00: STUN-formatted message (since the first two bits of a
          STUN-formatted message are always zero)
</p>
<p>0b01: ChannelData message (since the channel number is the first
          field in the ChannelData message and channel numbers fall in the
          range 0x4000 - 0x7FFF)
</p>
<p>0b10: Reserved
</p>
<p>0b11: Reserved
</p>
</blockquote><p>The reserved values may be used in the future to extend the
      range of channel numbers. Thus an implementation MUST NOT assume that a
      TURN message always starts with a 0 bit.
</p>
<p>Channel bindings are always initiated by the client. The client can
      bind a channel to a peer at any time during the lifetime of the
      allocation. The client may bind a channel to a peer before exchanging
      data with it, or after exchanging data with it (using Send and Data
      indications) for some time, or may choose never to bind a channel to it.
      The client can also bind channels to some peers while not binding
      channels to other peers.
</p>
<p>Channel bindings are specific to an allocation, so that the use of a
      channel number or peer transport address in a channel binding in one
      allocation has no impact on their use in a different allocation. If an
      allocation expires, all its channel bindings expire with it.
</p>
<p>A channel binding consists of:</p>
<ul class="text">
<li>A channel number;
</li>
<li>A transport address (of the peer);
</li>
<li>A time-to-expiry timer.
</li>
</ul><p>Within the context of an allocation, a channel binding is
      uniquely identified either by the channel number or by the peer's
      transport address. Thus the same channel cannot be bound to two
      different transport addresses, nor can the same transport address be
      bound to two different channels.
</p>
<p>A channel binding lasts for 10 minutes unless refreshed. Refreshing
      the binding (by the server receiving a ChannelBind request rebinding the
      channel to the same peer) resets the time-to-expiry timer back to 10
      minutes.
</p>
<p>When the channel binding expires, the channel becomes unbound. Once
      unbound, the channel number can be bound to a different transport
      address, and the transport address can be bound to a different channel
      number. To prevent race conditions, the client MUST wait 5 minutes after
      the channel binding expires before attempting to bind the channel number
      to a different transport address or the transport address to a different
      channel number.
</p>
<p>When binding a channel to a peer, the client SHOULD be prepared to
      receive ChannelData messages on the channel from the server as soon as
      it has sent the ChannelBind request. Over UDP, it is possible for the
      client to receive ChannelData messages from the server before it
      receives a ChannelBind success response.
</p>
<p>In the other direction, the client MAY elect to send ChannelData
      messages before receiving the ChannelBind success response. Doing so,
      however, runs the risk of having the ChannelData messages dropped by the
      server if the ChannelBind request does not succeed for some reason
      (e.g., packet lost if the request is sent over UDP, or the server being
      unable to fulfill the request). A client that wishes to be safe should
      either queue the data, or use Send indications until the channel binding
      is confirmed.
</p>
<a name="anchor18"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.11.1"></a><h3>11.1.&nbsp;
Sending a ChannelBind Request</h3>

<p>A channel binding is created or refreshed using a ChannelBind
        transaction. A ChannelBind transaction also creates or refreshes a
        permission towards the peer.
</p>
<p>To initiate the ChannelBind transaction, the client forms a
        ChannelBind request. The channel to be bound is specified in a
        CHANNEL-NUMBER attribute, and the peer's transport address is
        specified in a XOR-PEER-ADDRESS attribute. <a class='info' href='#sec-receiving-ChannelBind'>Section&nbsp;11.2<span> (</span><span class='info'>Receiving a ChannelBind Request</span><span>)</span></a> describes the restrictions
        on these attributes.
</p>
<p>Rebinding a channel to the same transport address that it is
        already bound to provides a way to refresh a channel binding and the
        corresponding permission without sending data to the peer. Note
        however, that permissions need to be refreshed more frequently than
        channels.
</p>
<a name="sec-receiving-ChannelBind"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.11.2"></a><h3>11.2.&nbsp;
Receiving a ChannelBind Request</h3>

<p>When the server receives a ChannelBind request, it processes as per
        <a class='info' href='#sec-general-behavior'>Section&nbsp;4<span> (</span><span class='info'>General Behavior</span><span>)</span></a> plus the specific rules
        mentioned here.
</p>
<p>The server checks the following:</p>
<ul class="text">
<li>The request contains both a CHANNEL-NUMBER and a
            XOR-PEER-ADDRESS attribute;
</li>
<li>The channel number is in the range 0x4000 through 0x7FFE
            (inclusive);
</li>
<li>The channel number is not currently bound to a different
            transport address (same transport address is OK);
</li>
<li>The transport address is not currently bound to a different
            channel number.
</li>
</ul>

<p>If any of these tests fail, the server replies with a 400 (Bad
        Request) error.
</p>
<p>The server MAY impose restrictions on the IP address and port
        values allowed in the XOR-PEER-ADDRESS attribute -- if a value is not
        allowed, the server rejects the request with a 403 (Forbidden)
        error.
</p>
<p>If the request is valid, but the server is unable to fulfill the
        request due to some capacity limit or similar, the server replies with
        a 508 (Insufficient Capacity) error.
</p>
<p>Otherwise, the server replies with a ChannelBind success response.
        There are no required attributes in a successful ChannelBind
        response.
</p>
<p>If the server can satisfy the request, then the server creates or
        refreshes the channel binding using the channel number in the
        CHANNEL-NUMBER attribute and the transport address in the
        XOR-PEER-ADDRESS attribute. The server also installs or refreshes a
        permission for the IP address in the XOR-PEER-ADDRESS attribute as
        described in <a class='info' href='#sec-permissions'>Section&nbsp;8<span> (</span><span class='info'>Permissions</span><span>)</span></a>.
</p>
<p></p>
<blockquote class="text">
<p>NOTE: A server need not do anything special to implement
            idempotency of ChannelBind requests over UDP using the "stateless
            stack approach". Retransmitted ChannelBind requests will simply
            refresh the channel binding and the corresponding permission.
            Furthermore, the client must wait 5 minutes before binding a
            previously bound channel number or peer address to a different
            channel, eliminating the possibility that the transaction would
            initially fail but succeed on a retransmission.
</p>
</blockquote>

<a name="anchor19"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.11.3"></a><h3>11.3.&nbsp;
Receiving a ChannelBind Response</h3>

<p>When the client receives a ChannelBind success response, it updates
        its data structures to record that the channel binding is now active.
        It also updates its data structures to record that the corresponding
        permission has been installed or refreshed.
</p>
<p>If the client receives a ChannelBind failure response that
        indicates that the channel information is out-of-sync between the
        client and the server (e.g., an unexpected 400 "Bad Request"
        response), then it is RECOMMENDED that the client immediately delete
        the allocation and start afresh with a new allocation.
</p>
<a name="sec-channeldata-msg"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.11.4"></a><h3>11.4.&nbsp;
The ChannelData Message</h3>

<p>The ChannelData message is used to carry application data between
        the client and the server. It has the following format:
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|         Channel Number        |            Length             |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                                                               |
/                       Application Data                        /
/                                                               /
|                                                               |
|                               +-------------------------------+
|                               |
+-------------------------------+</pre></div>
<p>The Channel Number field specifies the number of the channel on
        which the data is traveling, and thus the address of the peer that is
        sending or is to receive the data.
</p>
<p>The Length field specifies the length in bytes of the application
        data field (i.e., it does not include the size of the ChannelData
        header). Note that 0 is a valid length.
</p>
<p>The Application Data field carries the data the client is trying to
        send to the peer, or that the peer is sending to the client.
</p>
<a name="sec-sending-channeldata-msg"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.11.5"></a><h3>11.5.&nbsp;
Sending a ChannelData Message</h3>

<p>Once a client has bound a channel to a peer, then when the client
        has data to send to that peer it may use either a ChannelData message
        or a Send indication; that is, the client is not obligated to use the
        channel when it exists and may freely intermix the two message types
        when sending data to the peer. The server, on the other hand, MUST use
        the ChannelData message if a channel has been bound to the peer.
</p>
<p>The fields of the ChannelData message are filled in as described in
        <a class='info' href='#sec-channeldata-msg'>Section&nbsp;11.4<span> (</span><span class='info'>The ChannelData Message</span><span>)</span></a>.
</p>
<p>Over stream transports, the ChannelData message MUST be padded to a
        multiple of four bytes in order to ensure the alignment of subsequent
        messages. The padding is not reflected in the length field of the
        ChannelData message, so the actual size of a ChannelData message
        (including padding) is (4 + Length) rounded up to the nearest multiple
        of 4. Over UDP, the padding is not required but MAY be included.
</p>
<p>The ChannelData message is then sent on the 5-tuple associated with
        the allocation.
</p>
<a name="anchor20"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.11.6"></a><h3>11.6.&nbsp;
Receiving a ChannelData Message</h3>

<p>The receiver of the ChannelData message uses the first two bits to
        distinguish it from STUN-formatted messages, as described above. If
        the message uses a value in the reserved range (0x8000 through
        0xFFFF), then the message is silently discarded.
</p>
<p>If the ChannelData message is received in a UDP datagram, and if
        the UDP datagram is too short to contain the claimed length of the
        ChannelData message (i.e., the UDP header length field value is less
        than the ChannelData header length field value + 4 + 8), then the
        message is silently discarded.
</p>
<p>If the ChannelData message is received over TCP or over TLS over
        TCP, then the actual length of the ChannelData message is as described
        in <a class='info' href='#sec-sending-channeldata-msg'>Section&nbsp;11.5<span> (</span><span class='info'>Sending a ChannelData Message</span><span>)</span></a>.
</p>
<p>If the ChannelData message is received on a channel which is not
        bound to any peer, then the message is silently discarded.
</p>
<p>On the client, it is RECOMMENDED that the client discard the
        ChannelData message if the client believes there is no active
        permission towards the peer. On the server, the receipt of a
        ChannelData message MUST NOT refresh either the channel binding or the
        permission towards the peer.
</p>
<p>On the server, if no errors are detected, the server relays the
        application data to the peer by forming a UDP datagram as
        follows:</p>
<ul class="text">
<li>the source transport address is the relayed transport address
            of the allocation, where the allocation is determined by the
            5-tuple on which the ChannelData message arrived;
</li>
<li>the destination transport address is the transport address to
            which the channel is bound;
</li>
<li>the data following the UDP header is the contents of the data
            field of the ChannelData message.
</li>
</ul><p>The resulting UDP datagram is then sent to the peer. Note
        that if the Length field in the ChannelData message is 0, then there
        will be no data in the UDP datagram, but the UDP datagram is still
        formed and sent.
</p>
<a name="sec-channel-relaying"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.11.7"></a><h3>11.7.&nbsp;
Relaying Data from the Peer</h3>

<p>When the server receives a UDP datagram on the relayed transport
        address associated with an allocation, the server processes it as
        described in <a class='info' href='#sec-sending-data-indication'>Section&nbsp;10.3<span> (</span><span class='info'>Receiving a UDP Datagram</span><span>)</span></a>. If
        that section indicates that a ChannelData message should be sent
        (because there is a channel bound to the peer that sent to UDP
        datagram), then the server forms and sends a ChannelData message as
        described in <a class='info' href='#sec-sending-channeldata-msg'>Section&nbsp;11.5<span> (</span><span class='info'>Sending a ChannelData Message</span><span>)</span></a>.
</p>
<a name="sec-ip-header-fields"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.12"></a><h3>12.&nbsp;
IP Header Fields</h3>

<p>This section describes how the server sets various fields in the IP
      header when relaying between the client and the peer or vica-versa. The
      descriptions in this section apply: (a) when the server sends a UDP
      datagram to the peer, or (b) when the server sends a Data indication or
      ChannelData message to the client over UDP transport. The descriptions
      in this section do not apply to TURN messages sent over TCP or TLS
      transport from the server to the client.
</p>
<p>The descriptions below have two parts: a preferred behavior and an
      alternate behavior. The server SHOULD implement the preferred behavior,
      but if that is not possible for a particular field, then it SHOULD
      implement the alternative behavior.
</p>
<p>Time to Live (TTL) field</p>
<blockquote class="text">
<p>Preferred Behavior: If the incoming value is 0, then the drop the
          incoming packet. Otherwise set the outgoing Time to Live/Hop Count
          to one less than the incoming value.
</p>
<p>Alternate Behavior: Set the outgoing value to the default for
          outgoing packets.
</p>
</blockquote><br />
<br />


<p>Diff-Serv Code Point (DSCP) field <a class='info' href='#RFC2474'>[RFC2474]<span> (</span><span class='info'>Nichols, K., Blake, S., Baker, F., and D. Black, &ldquo;Definition of the Differentiated Services Field (DS Field) in the IPv4 and IPv6 Headers,&rdquo; December&nbsp;1998.</span><span>)</span></a></p>
<blockquote class="text">
<p>Preferred Behavior: Set the outgoing value to the incoming value,
          unless the server includes a differentiated services classifier and
          marker <a class='info' href='#RFC2474'>[RFC2474]<span> (</span><span class='info'>Nichols, K., Blake, S., Baker, F., and D. Black, &ldquo;Definition of the Differentiated Services Field (DS Field) in the IPv4 and IPv6 Headers,&rdquo; December&nbsp;1998.</span><span>)</span></a>.
</p>
<p>Alternate Behavior: Set the outgoing value to a fixed value,
          which by default is Best Effort unless configured otherwise.
</p>
<p>In both cases, if the server is immediately adjacent to a
          differentiated services classifier and marker, then DSCP MAY be set
          to any arbitrary value in the direction towards the classifier.
</p>
</blockquote>

<p><br />
<br />

</p>
<p>Explicit Congestion Notification (ECN) field <a class='info' href='#RFC3168'>[RFC3168]<span> (</span><span class='info'>Ramakrishnan, K., Floyd, S., and D. Black, &ldquo;The Addition of Explicit Congestion Notification (ECN) to IP,&rdquo; September&nbsp;2001.</span><span>)</span></a></p>
<blockquote class="text">
<p>Preferred Behavior: Set the outgoing value to the incoming value,
          UNLESS the server is doing Active Queue Management, the incoming ECN
          field is ECT(1) (=0b01) or ECT(0) (=0b10), and the server wishes to
          indicate that congestion has been experienced, in which case set the
          outgoing value to CE (=0b11).
</p>
<p>Alternate Behavior: Set the outgoing value to Not-ECT
          (=0b00).
</p>
</blockquote>

<p><br />
<br />

</p>
<p>IPv4 Fragmentation fields</p>
<blockquote class="text">
<p>Preferred Behavior: </p>
<blockquote class="text">
<p>When the server sends a packet to a peer in response to a
              Send indication containing the DONT-FRAGMENT attribute, then set
              the DF bit in the outgoing IP header to 1. In all other cases
              when sending an outgoing packet containing application data
              (e.g., Data indication, ChannelData message, or DONT-FRAGMENT
              attribute not included in the Send indication), copy the DF bit
              from the DF bit of the incoming packet that contained the
              application data.
</p>
<p>Set the other fragmentation fields (Identification, MF,
              Fragment Offset) as appropriate for a packet originating from
              the server.
</p>
</blockquote>

<p>Alternate Behavior: As described in the Preferred Behavior,
          except always assume the incoming DF bit is 0.
</p>
<p>In both the Preferred and Alternate Behaviors, the resulting
          packet may be too large for the outgoing link. If this is the case,
          then the normal fragmentation rules apply <a class='info' href='#RFC1122'>[RFC1122]<span> (</span><span class='info'>Braden, R., &ldquo;Requirements for Internet Hosts - Communication Layers,&rdquo; October&nbsp;1989.</span><span>)</span></a>.
</p>
</blockquote>

<p><br />
<br />

</p>
<p>IPv4 Options</p>
<blockquote class="text">
<p>Preferred Behavior: The outgoing packet is sent without any IPv4
          options.
</p>
<p>Alternate Behavior: Same as preferred.
</p>
</blockquote>

<a name="sec-stun-methods"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.13"></a><h3>13.&nbsp;
New STUN Methods</h3>

<p>This section lists the codepoints for the new STUN methods defined in
      this specification. See elsewhere in this document for the semantics of
      these new methods.
</p>
<p>
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>  0x003  :  Allocate          (only request/response semantics defined)
  0x004  :  Refresh           (only request/response semantics defined)
  0x006  :  Send              (only indication semantics defined)
  0x007  :  Data              (only indication semantics defined)
  0x008  :  CreatePermission  (only request/response semantics defined
  0x009  :  ChannelBind       (only request/response semantics defined)

</pre></div>
<a name="sec-stun-attributes"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.14"></a><h3>14.&nbsp;
New STUN Attributes</h3>

<p>This STUN extension defines the following new
        attributes:
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
  0x000C: CHANNEL-NUMBER
  0x000D: LIFETIME
  0x0010: Reserved (was BANDWIDTH)
  0x0012: XOR-PEER-ADDRESS
  0x0013: DATA
  0x0016: XOR-RELAYED-ADDRESS
  0x0018: EVEN-PORT
  0x0019: REQUESTED-TRANSPORT
  0x001A: DONT-FRAGMENT
  0x0021: Reserved (was TIMER-VAL)
  0x0022: RESERVATION-TOKEN
</pre></div>
<a name="channelnums"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.14.1"></a><h3>14.1.&nbsp;
CHANNEL-NUMBER</h3>

<p>The CHANNEL-NUMBER attribute contains the number of the channel. It
        is a 16-bit unsigned integer, followed by a two-octet RFFU (Reserved
        For Future Use) field which MUST be set to 0 on transmission and MUST
        be ignored on reception.
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
   0                   1                   2                   3
   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |        Channel Number         |         RFFU = 0              |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre></div>
<a name="anchor21"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.14.2"></a><h3>14.2.&nbsp;
LIFETIME</h3>

<p>The LIFETIME attribute represents the duration for which the server
        will maintain an allocation in the absence of a refresh. It is a
        32-bit unsigned integral value representing the number of seconds
        remaining until expiration.
</p>
<a name="anchor22"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.14.3"></a><h3>14.3.&nbsp;
XOR-PEER-ADDRESS</h3>

<p>The XOR-PEER-ADDRESS specifies the address and port of the peer as
        seen from the TURN server. (In other words, the peer's
        server-reflexive transport address if the peer is behind a NAT). It is
        encoded in the same way as XOR-MAPPED-ADDRESS <a class='info' href='#RFC5389'>[RFC5389]<span> (</span><span class='info'>Rosenberg, J., Mahy, R., Matthews, P., and D. Wing, &ldquo;Session Traversal Utilities for NAT (STUN),&rdquo; October&nbsp;2008.</span><span>)</span></a>.
</p>
<a name="anchor23"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.14.4"></a><h3>14.4.&nbsp;
DATA</h3>

<p>The DATA attribute is present in all Send and Data indications. The
        contents of DATA attribute is the application data (that is, the data
        that would immediately follow the UDP header if the data was been sent
        directly between the client and the peer).
</p>
<a name="anchor24"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.14.5"></a><h3>14.5.&nbsp;
XOR-RELAYED-ADDRESS</h3>

<p>The XOR-RELAYED-ADDRESS is present in Allocate responses. It
        specifies the address and port that the server allocated to the
        client. It is encoded in the same way as XOR-MAPPED-ADDRESS <a class='info' href='#RFC5389'>[RFC5389]<span> (</span><span class='info'>Rosenberg, J., Mahy, R., Matthews, P., and D. Wing, &ldquo;Session Traversal Utilities for NAT (STUN),&rdquo; October&nbsp;2008.</span><span>)</span></a>.
</p>
<a name="anchor25"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.14.6"></a><h3>14.6.&nbsp;
EVEN-PORT</h3>

<p>This attribute allows the client to request that the port in the
        relayed-transport-address be even, and (optionally) that the server
        reserve the next-higher port number. The attribute is 8 bits long. Its
        format is:
</p>
<p>
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>   0
   0 1 2 3 4 5 6 7
  +-+-+-+-+-+-+-+-+
  |R|    RFFU     |
  +-+-+-+-+-+-+-+-+</pre></div>
<p>
</p>
<p>The attribute contains a single 1-bit flag:</p>
<blockquote class="text"><dl>
<dt>R:</dt>
<dd>If 1, the server is requested to reserve the next
            higher port number (on the same IP address) for a subsequent
            allocation. If 0, no such reservation is requested.
</dd>
</dl></blockquote><p>The other 7 bits of the attribute must be set to zero on
        transmission and ignored on reception.
</p>
<a name="sec-requested-transport"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.14.7"></a><h3>14.7.&nbsp;
REQUESTED-TRANSPORT</h3>

<p>This attribute is used by the client to request a specific
        transport protocol for the allocated transport address. It has the
        following format:
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>   0                   1                   2                   3
   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |    Protocol   |                    RFFU                       |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre></div>
<p>The Protocol field specifies the desired protocol. The codepoints
        used in this field are taken from those allowed in the Protocol field
        in the IPv4 header and the NextHeader field in the IPv6 header <a class='info' href='#Protocol-Numbers'>[Protocol&#8209;Numbers]<span> (</span><span class='info'>, &ldquo;IANA Protocol Numbers Registry,&rdquo; 2005.</span><span>)</span></a>. This specification only allows the
        use of codepoint 17 (User Datagram Protocol).
</p>
<p>The RFFU field MUST be set to zero on transmission and MUST be
        ignored on reception. It is reserved for future uses.
</p>
<a name="anchor26"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.14.8"></a><h3>14.8.&nbsp;
DONT-FRAGMENT</h3>

<p>This attribute is used by the client to request that the server set
        the DF (Don't Fragment) bit in the IP header when relaying the
        application data onward to the peer. This attribute has no value part
        and thus the attribute length field is 0.
</p>
<a name="anchor27"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.14.9"></a><h3>14.9.&nbsp;
RESERVATION-TOKEN</h3>

<p>The RESERVATION-TOKEN attribute contains a token that uniquely
        identifies a relayed transport address being held in reserve by the
        server. The server includes this attribute in a success response to
        tell the client about the token, and the client includes this
        attribute in a subsequent Allocate request to request the server use
        that relayed transport address for the allocation.
</p>
<p>The attribute value is a 64-bit-long field containing the token
        value.
</p>
<a name="sec-stun-errors"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.15"></a><h3>15.&nbsp;
New STUN Error Response Codes</h3>

<p>This document defines the following new error response codes:</p>
<blockquote class="text"><dl>
<dt>403</dt>
<dd>(Forbidden): The request was valid, but cannot be
          performed due to administrative or similar restrictions.
</dd>
<dt>437</dt>
<dd>(Allocation Mismatch): A request was received by
          the server that requires an allocation to be in place, but there is
          none, or a request was received which requires no allocation, but
          there is one.
</dd>
<dt>441</dt>
<dd>(Wrong Credentials): The credentials in the
          (non-Allocate) request, though otherwise acceptable to the server,
          do not match those used to create the allocation.
</dd>
<dt>442</dt>
<dd>(Unsupported Transport Protocol): The Allocate
          request asked the server to use a transport protocol between the
          server and the peer that the server does not support. NOTE: This
          does NOT refer to the transport protocol used in the 5-tuple.
</dd>
<dt>486</dt>
<dd>(Allocation Quota Reached): No more allocations
          using this username can be created at the present time.
</dd>
<dt>508</dt>
<dd>(Insufficient Capacity): The server is unable to
          carry out the request due to some capacity limit being reached. In
          an Allocate response, this could be due to the server having no more
          relayed transport addresses available right now, or having none with
          the requested properties, or the one that corresponds to the
          specified reservation token is not available.
</dd>
</dl></blockquote>

<a name="anchor28"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.16"></a><h3>16.&nbsp;
Detailed Example</h3>

<p>This section gives a example of the use of TURN, showing in detail
      the contents of the messages exchanged. The example uses the network
      diagram shown in the Overview (<a class='info' href='#fig-turn-model'>Figure&nbsp;1</a>).
</p>
<p>For each message, the attributes included in the message and their
      values are shown. For convenience, values are shown in a human-readable
      format rather than showing the actual octets; for example
      "XOR-RELAYED-ADDRESS=192.0.2.15:9000" shows that the XOR-RELAYED-ADDRESS
      attribute is included with an address of 192.0.2.15 and a port of 9000,
      here the address and port are shown before the xor-ing is done. For
      attributes with string-like values (e.g. SOFTWARE="Example client,
      version 1.03" and NONCE="adl7W7PeDU4hKE72jdaQvbAMcr6h39sm"), the value
      of the attribute is shown in quotes for readability, but these quotes do
      not appear in the actual value.
</p>
<p>
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>TURN                                 TURN           Peer          Peer
client                               server          A             B
  |                                    |             |             |
  |--- Allocate request --------------&gt;|             |             |
  |    Transaction-Id=0xA56250D3F17ABE679422DE85     |             |
  |    SOFTWARE="Example client, version 1.03"       |             |
  |    LIFETIME=3600 (1 hour)          |             |             |
  |    REQUESTED-TRANSPORT=17 (UDP)    |             |             |
  |    DONT-FRAGMENT                   |             |             |
  |                                    |             |             |
  |&lt;-- Allocate error response --------|             |             |
  |    Transaction-Id=0xA56250D3F17ABE679422DE85     |             |
  |    SOFTWARE="Example server, version 1.17"       |             |
  |    ERROR-CODE=401 (Unauthorized)   |             |             |
  |    REALM="example.com"             |             |             |
  |    NONCE="adl7W7PeDU4hKE72jdaQvbAMcr6h39sm"      |             |
  |                                    |             |             |
  |--- Allocate request --------------&gt;|             |             |
  |    Transaction-Id=0xC271E932AD7446A32C234492     |             |
  |    SOFTWARE="Example client 1.03"  |             |             |
  |    LIFETIME=3600 (1 hour)          |             |             |
  |    REQUESTED-TRANSPORT=17 (UDP)    |             |             |
  |    DONT-FRAGMENT                   |             |             |
  |    USERNAME="George"               |             |             |
  |    REALM="example.com"             |             |             |
  |    NONCE="adl7W7PeDU4hKE72jdaQvbAMcr6h39sm"      |             |
  |    MESSAGE-INTEGRITY=...           |             |             |
  |                                    |             |             |
  |&lt;-- Allocate success response ------|             |             |
  |    Transaction-Id=0xC271E932AD7446A32C234492     |             |
  |    SOFTWARE="Example server, version 1.17"       |             |
  |    LIFETIME=1200 (20 minutes)      |             |             |
  |    XOR-RELAYED-ADDRESS=192.0.2.15:50000          |             |
  |    XOR-MAPPED-ADDRESS=192.0.2.1:7000             |             |
  |    MESSAGE-INTEGRITY=...           |             |             |
</pre></div>
<p>
</p>
<p>The client begins by selecting a host transport address to use for
      the TURN session; in this example the client has selected 10.1.1.2:49721
      as shown in <a class='info' href='#fig-turn-model'>Figure&nbsp;1</a>. The client then sends
      an Allocate request to the server at the server transport address. The
      client randomly selects a 96-bit transaction id of
      0xA56250D3F17ABE679422DE85 for this transaction; this is encoded in the
      transaction id field in the fixed header. The client includes a SOFTWARE
      attribute that gives information about the client's software; here the
      value is "Example client, version 1.03" to indicate that this is version
      1.03 of something called the Example client. The client includes the
      LIFETIME attribute because it wishes the allocation to have a longer
      lifetime than the default of 10 minutes; the value of this attribute is
      3600 seconds, which corresponds to 1 hour. The client must always
      include a REQUESTED-TRANSPORT attribute in an Allocate request and the
      only value allowed by this specification is 17, which indicates UDP
      transport between the server and the peers. The client also includes the
      DONT-FRAGMENT attribute because it wishes to use the DONT-FRAGMENT
      attribute later in Send indications; this attribute consists of only an
      attribute header, there is no value part. We assume the client has not
      recently interacted with the server, thus the client does not include
      USERNAME, REALM, NONCE, or MESSAGE-INTEGRITY attribute. Finally, note
      that the order of attributes in a message is arbitrary (except for the
      MESSAGE-INTEGRITY and FINGERPRINT attributes) and the client could have
      used a different order.
</p>
<p>The server follows the recommended practice in this specification of
      requiring all requests to be authenticated. Thus when the server
      receives the initial Allocate request, it rejects the request because
      the request does not contain the authentication attributes. Following
      the procedures of the Long-Term Credential Mechanism of STUN <a class='info' href='#RFC5389'>[RFC5389]<span> (</span><span class='info'>Rosenberg, J., Mahy, R., Matthews, P., and D. Wing, &ldquo;Session Traversal Utilities for NAT (STUN),&rdquo; October&nbsp;2008.</span><span>)</span></a>, the server includes an ERROR-CODE attribute
      with a value of 401 (Unauthorized), a REALM attribute that specifies the
      authentication realm used by the server (in this case, the server's
      domain "example.com"), and a nonce value in a NONCE attribute. The
      server also includes a SOFTWARE attribute that gives information about
      the server's software.
</p>
<p>The client, upon receipt of the 401 error, re-attempts the Allocate
      request, this time including the authentication attributes. The client
      selects a new transaction id, and then populates the new Allocate
      request with the same attributes as before. The client includes a
      USERNAME attribute and uses the realm value received from the server to
      help it determine which value to use; here the client is configured to
      use the username "George" for the realm "example.com". The client also
      includes the REALM and NONCE attributes, which are just copied from the
      401 error response. Finally, the client includes a MESSAGE-INTEGRITY
      attribute as the last attribute in the message, whose value is an
      HMAC-SHA1 hash over the contents of the message (shown as just "..."
      above); this HMAC-SHA1 computation also covers a password value, thus an
      attacker cannot compute the message integrity value without somehow
      knowing the secret password.
</p>
<p>The server, upon receipt of the authenticated Allocate request,
      checks that everything is OK, then creates an allocation. The server
      replies with an Allocate success response. The server includes a
      LIFETIME attribute giving the lifetime of the allocation; here, the
      server as reduced the client's requested 1 hour lifetime to just 20
      minutes, because this particular server doesn't allow lifetimes longer
      than 20 minutes. The server includes an XOR-RELAYED-ADDRESS attribute
      whose value is the relayed transport address of the allocation. The
      server includes an XOR-MAPPED-ADDRESS attribute whose value is the
      server-reflexive address of the client; this value is not used otherwise
      in TURN but is returned as a convenience to the client. The server
      includes a MESSAGE-INTEGRITY attribute to authenticate the response and
      to insure its integrity; note that the response does not contain the
      USERNAME, REALM, and NONCE attributes. The server also includes a
      SOFTWARE attribute.
</p>
<p>
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>TURN                                 TURN           Peer          Peer
client                               server          A             B
  |--- CreatePermission request ------&gt;|             |             |
  |    Transaction-Id=0xE5913A8F460956CA277D3319     |             |
  |    XOR-PEER-ADDRESS=192.0.2.150:0  |             |             |
  |    USERNAME="George"               |             |             |
  |    REALM="example.com"             |             |             |
  |    NONCE="adl7W7PeDU4hKE72jdaQvbAMcr6h39sm"      |             |
  |    MESSAGE-INTEGRITY=...           |             |             |
  |                                    |             |             |
  |&lt;-- CreatePermission success resp.--|             |             |
  |    Transaction-Id=0xE5913A8F460956CA277D3319     |             |
  |    MESSAGE-INTEGRITY=...           |             |             |
</pre></div>
<p>
</p>
<p>The client then creates a permission towards peer A in preparation
      for sending it some application data. This is done through a
      CreatePermission request. The XOR-PEER-ADDRESS attribute contains the IP
      address for which a permission is established (the IP address of peer
      A); note that the port number in the attribute is ignored when used in a
      CreatePermission request, and here it has been set to 0; also note how
      the client uses Peer A's server-reflexive IP address and not its
      (private) host address. The client uses the same username, realm, and
      nonce values as in the previous request on the allocation. Though it is
      allowed to do so, the client has chosen not to include a SOFTWARE
      attribute in this request.
</p>
<p>The server receives the CreatePermission request, creates the
      corresponding permission, and then replies with a CreatePermission
      success response. Like the client, the server chooses not to include the
      SOFTWARE attribute in its reply. Again, note how success responses
      contain a MESSAGE-INTEGRITY attribute (assuming the server uses the
      Long-Term Credential Mechanism), but no USERNAME, REALM, and NONCE
      attributes.
</p>
<p>
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>TURN                                 TURN           Peer          Peer
client                               server          A             B
  |--- Send indication ---------------&gt;|             |             |
  |    Transaction-Id=0x1278E9ACA2711637EF7D3328     |             |
  |    XOR-PEER-ADDRSSS=192.0.2.150:32102            |             |
  |    DONT-FRAGMENT                   |             |             |
  |    DATA=...                        |             |             |
  |                                    |-- UDP dgm -&gt;|             |
  |                                    |  data=...   |             |
  |                                    |             |             |
  |                                    |&lt;- UDP dgm --|             |
  |                                    |  data=...   |             |
  |&lt;-- Data indication ----------------|             |             |
  |    Transaction-Id=0x8231AE8F9242DA9FF287FEFF     |             |
  |    XOR-PEER-ADDRSSS=192.0.2.150:32102            |             |
  |    DATA=...                        |             |             |
</pre></div>
<p>
</p>
<p>The client now sends application data to Peer A using a Send
      indication. Peer A's server-reflexive transport address is specified in
      the XOR-PEER-ADDRESS attribute, and the application data (shown here as
      just "...") is specified in the DATA attribute. The client is doing a
      form of path MTU discovery at the application layer and thus specifies
      (by including the DONT-FRAGMENT attribute) that the server should set
      the DF bit in the UDP datagram send to the peer. Indications cannot be
      authenticated using the Long-Term Credential Mechanism of STUN, so no
      MESSAGE-INTEGRITY attribute is included in the message. An application
      wishing to ensure that its data is not altered or forged must
      integrity-protect its data at the application level.
</p>
<p>Upon receipt of the Send indication, the server extracts the
      application data and sends it in a UDP datagram to Peer A, with the
      relayed-transport-address as the source transport address of the
      datagram, and with the DF bit set as requested. Note that, had the
      client not previously established a permission for Peer A's
      server-reflexive IP address, then the server would have silently
      discarded the Send indication instead.
</p>
<p>Peer A then replies with its own UDP datagram containing application
      data. The datagram is sent to the relayed-transport-address on the
      server. When this arrives, the server creates a Data indication
      containing the source of the UDP datagram in the XOR-PEER-ADDRESS
      attribute, and the data from the UDP datagram in the DATA attribute. The
      resulting Data indication is then sent to the client.
</p>
<p>
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>TURN                                 TURN           Peer          Peer
client                               server          A             B
  |--- ChannelBind request -----------&gt;|             |             |
  |    Transaction-Id=0x6490D3BC175AFF3D84513212     |             |
  |    CHANNEL-NUMBER=0x4000           |             |             |
  |    XOR-PEER-ADDRESS=192.0.2.210:49191            |             |
  |    USERNAME="George"               |             |             |
  |    REALM="example.com"             |             |             |
  |    NONCE="adl7W7PeDU4hKE72jdaQvbAMcr6h39sm"      |             |
  |    MESSAGE-INTEGRITY=...           |             |             |
  |                                    |             |             |
  |&lt;-- ChannelBind success response ---|             |             |
  |    Transaction-Id=0x6490D3BC175AFF3D84513212     |             |
  |    MESSAGE-INTEGRITY=...           |             |             |
</pre></div>
<p>
</p>
<p>The client now binds a channel to Peer B, specifying a free channel
      number (0x4000) in the CHANNEL-NUMBER attribute, and Peer B's transport
      address in the XOR-PEER-ADDRESS attribute. As before, the client re-uses
      the username, realm, and nonce from its last request in the message.
</p>
<p>Upon receipt of the request, the server binds the channel number to
      the peer, installs a permission for Peer B's IP address, and then
      replies with ChannelBind success response.
</p>
<p>
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>TURN                                 TURN           Peer          Peer
client                               server          A             B
  |--- ChannelData -------------------&gt;|             |             |
  |    Channel-number=0x4000           |--- UDP datagram ---------&gt;|
  |    Data=...                        |    Data=...               |
  |                                    |             |             |
  |                                    |&lt;-- UDP datagram ----------|
  |                                    |    Data=... |             |
  |&lt;-- ChannelData --------------------|             |             |
  |    Channel-number=0x4000           |             |             |
  |    Data=...                        |             |             |
</pre></div>
<p>
</p>
<p>The client now sends a ChannelData message to the server with data
      destined for Peer B. The ChannelData message is not a STUN message, and
      thus has no transaction id. Instead, its fixed header has only two
      fields: channel number and data; here the channel number field is 0x4000
      (the channel the client just bound to Peer B). When the server receives
      the ChannelData message, it checks that the channel is currently bound
      (which it is) and then sends the data onward to Peer B in a UDP
      datagram, using the relayed-transport-address as the source transport
      address and 192.0.2.210:49191 (the value of the XOR-PEER-ADDRESS
      attribute in the ChannelBind request) as the destination transport
      address.
</p>
<p>Later, Peer B sends a UDP datagram back to the
      relayed-transport-address. This causes the server to send a ChannelData
      message to the client containing the data from the UDP datagram. The
      server knows which client to send the ChannelData message to because of
      the relayed-transport-address the UDP datagram arrived at, and knows to
      use channel 0x4000 because this is the channel bound to
      192.0.2.210:49191. Note that if there had not been any channel number
      bound to that address, the server would have used a Data indication
      instead.
</p>
<p>
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>TURN                                 TURN           Peer          Peer
client                               server          A             B
  |--- Refresh request ---------------&gt;|             |             |
  |    Transaction-Id=0x0864B3C27ADE9354B4312414     |             |
  |    SOFTWARE="Example client 1.03"  |             |             |
  |    USERNAME="George"               |             |             |
  |    REALM="example.com"             |             |             |
  |    NONCE="adl7W7PeDU4hKE72jdaQvbAMcr6h39sm"      |             |
  |    MESSAGE-INTEGRITY=...           |             |             |
  |                                    |             |             |
  |&lt;-- Refresh error response ---------|             |             |
  |    Transaction-Id=0x0864B3C27ADE9354B4312414     |             |
  |    SOFTWARE="Example server, version 1.17"       |             |
  |    ERROR-CODE=438 (Stale Nonce)    |             |             |
  |    REALM="example.com"             |             |             |
  |    NONCE="npSw1Xw239bBwGYhjNWgz2yH47sxB2j"       |             |
  |                                    |             |             |
  |--- Refresh request ---------------&gt;|             |             |
  |    Transaction-Id=0x427BD3E625A85FC731DC4191     |             |
  |    SOFTWARE="Example client 1.03"  |             |             |
  |    USERNAME="George"               |             |             |
  |    REALM="example.com"             |             |             |
  |    NONCE="npSw1Xw239bBwGYhjNWgz2yH47sxB2j"       |             |
  |    MESSAGE-INTEGRITY=...           |             |             |
  |                                    |             |             |
  |&lt;-- Refresh success response -------|             |             |
  |    Transaction-Id=0x427BD3E625A85FC731DC4191     |             |
  |    SOFTWARE="Example server, version 1.17"       |             |
  |    LIFETIME=600 (10 minutes)       |             |             |
</pre></div>
<p>
</p>
<p>Sometime before the 20 minute lifetime is up, the client refreshes
      the allocation. This is done using a Refresh request. As before, the
      client includes the latest username, realm, and nonce values in the
      request. The client also includes the SOFTWARE attribute, following the
      recommended practice of always including this attribute in Allocate and
      Refresh messages. When the server receives the Refresh request, it
      notices that the nonce value has expired, and so replies with 438 (Stale
      Nonce) error given a new nonce value. The client then reattempts the
      request, this time with the new nonce value. This second attempt is
      accepted, and the server replies with a success response. Note that the
      client did not include a LIFETIME attribute in the request, so the
      server refreshes the allocation for the default lifetime of 10 minutes
      (as can be seen by the LIFETIME attribute in the success response).
</p>
<p>
</p>
<a name="sec-security"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.17"></a><h3>17.&nbsp;
Security Considerations</h3>

<p>This section considers attacks that are possible in a TURN
      deployment, and discusses how they are mitigated by mechanisms in the
      protocol or recommended practices in the implementation.
</p>
<a name="anchor29"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.17.1"></a><h3>17.1.&nbsp;
Outsider Attacks</h3>

<p>Outsider attacks are ones where the attacker has no credentials in
        the system, and is attempting to disrupt the service seen by the
        client or the server.
</p>
<a name="anchor30"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.17.1.1"></a><h3>17.1.1.&nbsp;
Obtaining Unauthorized Allocations</h3>

<p>An attacker might wish to obtain allocations on a TURN server for
          any number of nefarious purposes. A TURN server provides a mechanism
          for sending and receiving packets while cloaking the actual IP
          address of the client. This makes TURN servers an attractive target
          for attackers who wish to use it to mask their true identity.
</p>
<p>An attacker might also wish to simply utilize the services of a
          TURN server without paying for them. Since TURN services require
          resources from the provider, it is anticipated that their usage will
          come with a cost.
</p>
<p>These attacks are prevented using the digest authentication
          mechanism which allows the TURN server to determine the identity of
          the requestor and whether the requestor is allowed to obtain the
          allocation.
</p>
<a name="anchor31"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.17.1.2"></a><h3>17.1.2.&nbsp;
Offline Dictionary Attacks</h3>

<p>The digest authentication mechanism used by TURN is subject to
          offline dictionary attacks. An attacker that is capable of
          eavesdropping on a message exchange between a client and server can
          determine the password by trying a number of candidate passwords and
          seeing if one of them is correct. This attack works when the
          passwords are low entropy, such as a word from the dictionary. This
          attack can be mitigated by using strong passwords with large
          entropy. In situations where even stronger mitigation is required,
          TLS transport between the client and the server can be used.
</p>
<a name="anchor32"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.17.1.3"></a><h3>17.1.3.&nbsp;
Faked Refreshes and Permissions</h3>

<p>An attacker might wish to attack an active allocation by sending
          it a Refresh request with an immediate expiration, in order to
          delete it and disrupt service to the client. This is prevented by
          authentication of refreshes. Similarly, an attacker wishing to send
          CreatePermission requests to create permissions to undesirable
          destinations is prevented from doing so through authentication. The
          motivations for such an attack are described in <a class='info' href='#sec-firewall'>Section&nbsp;17.2<span> (</span><span class='info'>Firewall Considerations</span><span>)</span></a>.
</p>
<a name="anchor33"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.17.1.4"></a><h3>17.1.4.&nbsp;
Fake Data</h3>

<p>An attacker might wish to send data to the client or the peer, as
          if they came from the peer or client respectively. To do that, the
          attacker can send the client a faked Data Indication or ChannelData
          message, or send the TURN server a faked Send Indication or
          ChannelData message.
</p>
<p>Indeed, since indications and ChannelData messages are not
          authenticated, this attack is not prevented by TURN. However, this
          attack is generally present in IP-based communications and is not
          substantially worsened by TURN. Consider an normal, non-TURN IP
          session between hosts A and B. An attacker can send packets to B as
          if they came from A by sending packets towards A with a spoofed IP
          address of B. This attack requires the attacker to know the IP
          addresses of A and B. With TURN, an attacker wishing to send packets
          towards a client using a Data indication needs to know its IP
          address (and port), the IP address and port of the TURN server, and
          the IP address and port of the peer (for inclusion in the
          XOR-PEER-ADDRESS attribute). To send a fake ChannelData message to a
          client, an attacker needs to know the IP address and port of the
          client, the IP address and port of the TURN server, and the channel
          number. This particular combination is mildly more guessable than in
          the non-TURN case.
</p>
<p>These attacks are more properly mitigated by application layer
          authentication techniques. In the case of real time traffic, usage
          of SRTP <a class='info' href='#RFC3711'>[RFC3711]<span> (</span><span class='info'>Baugher, M., McGrew, D., Naslund, M., Carrara, E., and K. Norrman, &ldquo;The Secure Real-time Transport Protocol (SRTP),&rdquo; March&nbsp;2004.</span><span>)</span></a> prevents these attacks.
</p>
<p>In some situations, the TURN server may be situated in the
          network such that it is able to send to hosts that the client cannot
          directly send to. This can happen, for example, if the server is
          located behind a firewall that allows packets from outside the
          firewall to be delivered to the server, but not to other hosts
          behind the firewall. In these situations, an attacker could send the
          server a Send indication with an XOR-PEER-ADDRESS attribute
          containing the transport address of one of the other hosts behind
          the firewall. If the server was to allow relaying of traffic to
          arbitrary peers, then this would provide a way for the attacker to
          attack arbitrary hosts behind the firewall.
</p>
<p>To mitigate this attack, TURN requires that the client establish
          a permission to a host before sending it data. Thus an attacker can
          only attack hosts that the client is already communicating with,
          unless the attacker is able to create authenticated requests.
          Furthermore, the server administrator may configure the server to
          restrict the range of IP addresses and ports that it will relay data
          to. To provide even greater security, the server administrator can
          require that the client use TLS for all communication between the
          client and the server.
</p>
<a name="anchor34"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.17.1.5"></a><h3>17.1.5.&nbsp;
Impersonating a Server</h3>

<p>When a client learns a relayed address from a TURN server, it
          uses that relayed address in application protocols to receive
          traffic. Therefore, an attacker wishing to intercept or redirect
          that traffic might try to impersonate a TURN server and provide the
          client with a faked relayed address.
</p>
<p>This attack is prevented through the digest authentication
          mechanism, which provides message integrity for responses in
          addition to verifying that they came from the server. Furthermore,
          an attacker cannot replay old server responses as the transaction ID
          in the STUN header prevents this. Replay attacks are further
          thwarted through frequent changes to the nonce value.
</p>
<a name="anchor35"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.17.1.6"></a><h3>17.1.6.&nbsp;
Eavesdropping Traffic</h3>

<p>TURN concerns itself primarily with authentication and message
          integrity. Confidentiality is only a secondary concern, as TURN
          control messages do not include information that is particularly
          sensitive. The primary protocol content of the messages is the IP
          address of the peer. If it is important to prevent an eavesdropper
          on a TURN connection from learning this, TURN can be run over
          TLS.
</p>
<p>Confidentiality for the application data relayed by TURN is best
          provided by the application protocol itself, since running TURN over
          TLS does not protect application data between the server and the
          peer. If confidentiality of application data is important, then the
          application should encrypt or otherwise protect its data. For
          example, for real time media, confidentiality can be provided by
          using SRTP.
</p>
<a name="anchor36"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.17.1.7"></a><h3>17.1.7.&nbsp;
TURN loop attack</h3>

<p>An attacker might attempt to cause data packets to loop
          indefinitely between two TURN servers. The attack goes as follows.
          First, the attacker sends an Allocate request to server A, using the
          source address of server B. Server A will send its response to
          server B, and for the attack to succeed, the attacker must have the
          ability to either view or guess the contents of this response, so
          that the attacker can learn the allocated relayed-transport-address.
          The attacker then sends an Allocate request to server B, using the
          source address of server A. Again, the attacker must be able to view
          or guess the contents of the response, so it can send learn the
          allocated relayed-transport-address. Using the same spoofed source
          address technique, the attacker then binds a channel number on
          server A to the relayed-transport-address on server B, and similarly
          binds the same channel number on server B to the
          relayed-transport-address on server A. Finally, the attacker sends a
          ChannelData message to server A.
</p>
<p>The result is a data packet that loops from the
          relayed-transport-address on server A to the
          relayed-transport-address on server B, then from server B's
          transport address to server A's transport address, and then around
          the loop again.
</p>
<p>This attack is mitigated as follows. By requiring all requests to
          be authenticated and/or by randomizing the port number allocated for
          the relayed-transport-address, the server forces the attacker to
          either intercept or view responses sent to a third party (in this
          case, the other server) so that the attacker can authenticate the
          requests and learn the relayed-transport-address. Without one of
          these two measures, an attacker can guess the contents of the
          responses without needing to see them, which makes the attack much
          easier to perform. Furthermore, by requiring authenticated requests,
          the server forces the attacker to have credentials acceptable to the
          server, which turns this from an outsider attack into an insider
          attack and allows the attack to be traced back to the client
          initiating it.
</p>
<p>The attack can be further mitigated by imposing a per-username
          limit on the bandwidth used to relay data by allocations owned by
          that username, to limit the impact of this attack on other
          allocations. More mitigation can be achieved by decrementing the TTL
          when relaying data packets (if the underlying OS allows this).
</p>
<a name="sec-firewall"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.17.2"></a><h3>17.2.&nbsp;
Firewall Considerations</h3>

<p>A key aspect of TURN's security considerations is that it should
        not weaken the protections afforded by firewalls deployed between a
        client and a TURN server. It is anticipated that TURN servers will
        often be present on the public Internet, and clients may often be
        inside enterprise networks with corporate firewalls. If TURN servers
        provide a 'backdoor' for reaching into the enterprise, TURN will be
        blocked by these firewalls.
</p>
<p>TURN servers therefore emulate the behavior of NAT devices which
        implement address-dependent filtering <a class='info' href='#RFC4787'>[RFC4787]<span> (</span><span class='info'>Audet, F. and C. Jennings, &ldquo;Network Address Translation (NAT) Behavioral Requirements for Unicast UDP,&rdquo; January&nbsp;2007.</span><span>)</span></a>,
        a property common in many firewalls as well. When a NAT or firewall
        implements this behavior, packets from an outside IP address are only
        allowed to be sent to an internal IP address and port if the internal
        IP address and port had recently sent a packet to that outside IP
        address. TURN servers introduce the concept of permissions, which
        provide exactly this same behavior on the TURN server. An attacker
        cannot send a packet to a TURN server and expect it to be relayed
        towards the client, unless the client has tried to contact the
        attacker first.
</p>
<p>It is important to note that some firewalls have policies which are
        even more restrictive than address-dependent filtering. Firewalls can
        also be configured with address and port dependent filtering, or can
        be configured to disallow inbound traffic entirely. In these cases, if
        a client is allowed to connect the TURN server, communications to the
        client will be less restrictive than what the firewall would normally
        allow.
</p>
<a name="anchor37"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.17.2.1"></a><h3>17.2.1.&nbsp;
Faked Permissions</h3>

<p>In firewalls and NAT devices, permissions are granted implicitly
          through the traversal of a packet from the inside of the network
          towards the outside peer. Thus, a permission cannot, by definition,
          be created by any entity except one inside the firewall or NAT. With
          TURN, this restriction no longer holds. Since the TURN server sits
          outside the firewall, at attacker outside the firewall can now send
          a message to the TURN server and try to create a permission for
          itself.
</p>
<p>This attack is prevented because all messages which create
          permissions (i.e., ChannelBind and CreatePermission) are
          authenticated.
</p>
<a name="anchor38"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.17.2.2"></a><h3>17.2.2.&nbsp;
Blacklisted IP Addresses</h3>

<p>Many firewalls can be configured with blacklists which prevent a
          client behind the firewall from sending packets to, or receiving
          packets from, ranges of blacklisted IP addresses. This is
          accomplished by inspecting the source and destination addresses of
          packets entering and exiting the firewall, respectively.
</p>
<p>If a client connects to a TURN server, it will be able to bypass
          such blacklisting policies and communicate with IP addresses which
          the firewall would otherwise restrict. This is a problem for other
          protocols that provide tunneling functions, such as VPNs. It is
          possible to build TURN-aware firewalls which inspect TURN messages,
          and check the IP address of the correspondent. TURN messages to
          offending destinations can then be rejected. TURN is designed so
          that this inspection can be done statelessly.
</p>
<a name="anchor39"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.17.2.3"></a><h3>17.2.3.&nbsp;
Running Servers on Well-Known Ports</h3>

<p>A malicious client behind a firewall might try to connect to a
          TURN server and obtain an allocation which it then uses to run a
          server. For example, a client might try to run a DNS server or FTP
          server.
</p>
<p>This is not possible in TURN. A TURN server will never accept
          traffic from a peer which the client itself has not contacted. Thus,
          peers cannot just connect to the allocated port in order to obtain
          the service.
</p>
<a name="anchor40"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.17.3"></a><h3>17.3.&nbsp;
Insider Attacks</h3>

<p>In insider attacks, a client has legitimate credentials but defies
        the trust relationship that goes with those credentials. These attacks
        cannot be prevented by cryptographic means but need to be considered
        in the design of the protocol.
</p>
<a name="anchor41"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.17.3.1"></a><h3>17.3.1.&nbsp;
DoS Against TURN Server</h3>

<p>A client wishing to disrupt service to other clients might obtain
          an allocation and then flood it with traffic, in an attempt to swamp
          the server and prevent it from servicing other legitimate clients.
          This is mitigated by the recommendation that the server limit the
          amount of bandwidth it will relay for a given username. This won't
          prevent a client from sending a large amount of traffic, but it
          allows the server to immediately discard traffic in excess.
</p>
<p>Since each allocation uses a port number on the IP address of the
          TURN server, the number of allocations on a server is finite. An
          attacker might attempt to consume all of them by requesting a large
          number of allocations. This is prevented by the recommendation that
          the server impose a limit of the number of allocations active at a
          time for a given username.
</p>
<a name="anchor42"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.17.3.2"></a><h3>17.3.2.&nbsp;
Anonymous Relaying of Malicious Traffic</h3>

<p>TURN servers provide a degree of anonymization. A client can send
          data to correspondent peers without revealing their own IP
          addresses. TURN servers may therefore become attractive vehicles for
          attackers to launch attacks against targets without fear of
          detection. Indeed, it is possible for a client to chain together
          multiple TURN servers, such that any number of relays can be used
          before a target receives a packet.
</p>
<p>Administrators who are worried about this attack can maintain
          logs which capture the actual source IP and port of the client, and
          perhaps even every permission that client installs. This will allow
          for forensic tracing to determine the original source, should it be
          discovered that an attack is being relayed through a TURN
          server.
</p>
<a name="anchor43"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.17.3.3"></a><h3>17.3.3.&nbsp;
Manipulating other Allocations</h3>

<p>An attacker might attempt to disrupt service to other users of
          the TURN server by sending Refresh requests or CreatePermission
          requests which (through source address spoofing) appear to be coming
          from another user of the TURN server. TURN prevents this by
          requiring that the credentials used in CreatePermission, Refresh,
          and ChannelBind messages match those used to create the initial
          allocation. Thus, the fake requests from the attacker will be
          rejected.
</p>
<a name="anchor44"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.17.4"></a><h3>17.4.&nbsp;
Other Considerations</h3>

<p>Any relay addresses learned through an Allocate request will not
        operate properly with IPSec Authentication Header (AH) <a class='info' href='#RFC4302'>[RFC4302]<span> (</span><span class='info'>Kent, S., &ldquo;IP Authentication Header,&rdquo; December&nbsp;2005.</span><span>)</span></a> in transport or tunnel mode. However,
        tunnel-mode IPSec ESP <a class='info' href='#RFC4303'>[RFC4303]<span> (</span><span class='info'>Kent, S., &ldquo;IP Encapsulating Security Payload (ESP),&rdquo; December&nbsp;2005.</span><span>)</span></a> should still
        operate.
</p>
<a name="anchor45"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.18"></a><h3>18.&nbsp;
IANA Considerations</h3>

<p>Since TURN is an extension to STUN <a class='info' href='#RFC5389'>[RFC5389]<span> (</span><span class='info'>Rosenberg, J., Mahy, R., Matthews, P., and D. Wing, &ldquo;Session Traversal Utilities for NAT (STUN),&rdquo; October&nbsp;2008.</span><span>)</span></a>,
      the methods, attributes and error codes defined in this specification
      are new methods, attributes, and error codes for STUN. This section
      requests IANA to add these new protocol elements to the IANA registry of
      STUN protocol elements.
</p>
<p>The codepoints for the new STUN methods defined in this specification
      are listed in <a class='info' href='#sec-stun-methods'>Section&nbsp;13<span> (</span><span class='info'>New STUN Methods</span><span>)</span></a>.
</p>
<p>The codepoints for the new STUN attributes defined in this
      specification are listed in <a class='info' href='#sec-stun-attributes'>Section&nbsp;14<span> (</span><span class='info'>New STUN Attributes</span><span>)</span></a>.
</p>
<p>The codepoints for the new STUN error codes defined in this
      specification are listed in <a class='info' href='#sec-stun-errors'>Section&nbsp;15<span> (</span><span class='info'>New STUN Error Response Codes</span><span>)</span></a>.
</p>
<p>IANA is requested to allocate the SRV service name of "turn" for TURN
      over UDP or TCP, and the service name of "turns" for TURN over TLS.
</p>
<p>IANA is requested to create a registry for TURN channel numbers,
      initially populated as follows:</p>
<blockquote class="text">
<p>0x0000 through 0x3FFF: Not available for use, since they conflict
          with the STUN header.
</p>
<p>0x4000 through 0x7FFF: A TURN implementation is free to use
          channel numbers in this range.
</p>
<p>0x8000 through 0xFFFF: Reserved.
</p>
</blockquote><p>Any change to this registry must be made through an IETF
      Standards Action.
</p>
<a name="anchor46"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.19"></a><h3>19.&nbsp;
IAB Considerations</h3>

<p>The IAB has studied the problem of "Unilateral Self Address Fixing",
      which is the general process by which a client attempts to determine its
      address in another realm on the other side of a NAT through a
      collaborative protocol reflection mechanism <a class='info' href='#RFC3424'>[RFC3424]<span> (</span><span class='info'>Daigle, L. and IAB, &ldquo;IAB Considerations for UNilateral Self-Address Fixing (UNSAF) Across Network Address Translation,&rdquo; November&nbsp;2002.</span><span>)</span></a>. The TURN extension is an example of a protocol
      that performs this type of function. The IAB has mandated that any
      protocols developed for this purpose document a specific set of
      considerations. These considerations and the responses for TURN are
      documented in this section.
</p>
<p>Consideration 1: Precise definition of a specific, limited-scope
      problem that is to be solved with the UNSAF proposal. A short term fix
      should not be generalized to solve other problems. Such generalizations
      lead to the prolonged dependence on and usage of the supposed short term
      fix -- meaning that it is no longer accurate to call it "short
      term".
</p>
<p>Response: TURN is a protocol for communication between a relay (=
      TURN server) and its client. The protocol allows a client that is behind
      a NAT to obtain and use a public IP address on the relay. As a
      convenience to the client, TURN also allows the client to determine its
      server-reflexive transport address.
</p>
<p>Consideration 2: Description of an exit strategy/transition plan. The
      better short term fixes are the ones that will naturally see less and
      less use as the appropriate technology is deployed.
</p>
<p>Response: TURN will no longer be needed once there are no longer any
      NATs. The need for TURN will also decrease as the number of NATs with
      the mapping property of Endpoint-Independent Mapping <a class='info' href='#RFC4787'>[RFC4787]<span> (</span><span class='info'>Audet, F. and C. Jennings, &ldquo;Network Address Translation (NAT) Behavioral Requirements for Unicast UDP,&rdquo; January&nbsp;2007.</span><span>)</span></a> increases.
</p>
<p>Consideration 3: Discussion of specific issues that may render
      systems more "brittle". For example, approaches that involve using data
      at multiple network layers create more dependencies, increase debugging
      challenges, and make it harder to transition.
</p>
<p>Response: TURN is "brittle" in that it requires the NAT bindings
      between the client and the server to be maintained unchanged for the
      lifetime of the allocation. This is typically done using keep-alives. If
      this is not done, then the client will lose its allocation and can no
      longer exchange data with its peers.
</p>
<p>Consideration 4: Identify requirements for longer term, sound
      technical solutions; contribute to the process of finding the right
      longer term solution.
</p>
<p>Response: The need for TURN will be reduced once NATs implement the
      recommendations for NAT UDP behavior documented in <a class='info' href='#RFC4787'>[RFC4787]<span> (</span><span class='info'>Audet, F. and C. Jennings, &ldquo;Network Address Translation (NAT) Behavioral Requirements for Unicast UDP,&rdquo; January&nbsp;2007.</span><span>)</span></a>. Applications are also strongly urged to use
      ICE <a class='info' href='#I-D.ietf-mmusic-ice'>[I&#8209;D.ietf&#8209;mmusic&#8209;ice]<span> (</span><span class='info'>Rosenberg, J., &ldquo;Interactive Connectivity Establishment (ICE): A Protocol for Network Address Translator (NAT) Traversal for Offer/Answer Protocols,&rdquo; October&nbsp;2007.</span><span>)</span></a> to communicate with
      peers; though ICE uses TURN, it does so only as a last resort, and uses
      it in a controlled manner.
</p>
<p>Consideration 5: Discussion of the impact of the noted practical
      issues with existing deployed NATs and experience reports.
</p>
<p>Response: Some NATs deployed today exhibit a mapping behavior other
      than Endpoint-Independent mapping. These NATs are difficult to work
      with, as they make it difficult or impossible for protocols like ICE to
      use server-reflexive transport addresses on those NATs. A client behind
      such a NAT is often forced to use a relay protocol like TURN because
      "UDP hole punching" techniques <a class='info' href='#RFC5128'>[RFC5128]<span> (</span><span class='info'>Srisuresh, P., Ford, B., and D. Kegel, &ldquo;State of Peer-to-Peer (P2P) Communication across Network Address Translators (NATs),&rdquo; March&nbsp;2008.</span><span>)</span></a> do not
      work.
</p>
<a name="anchor47"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.20"></a><h3>20.&nbsp;
Open Issues</h3>

<p>Note to RFC Editor: Please remove this section prior to publication
      of this document as an RFC.
</p>
<p>This section lists the known issues in this version of the
      specification.
</p>
<p>(No known issues at this time).
</p>
<a name="anchor48"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.21"></a><h3>21.&nbsp;
Changes from Previous Versions</h3>

<p>Note to RFC Editor: Please remove this section prior to publication
      of this document as an RFC.
</p>
<p>This section lists the technical and major editorial changes between
      the various versions of this specification. Minor editorial changes are
      not described.
</p>
<a name="anchor49"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.21.1"></a><h3>21.1.&nbsp;
Changes from -12 to -13</h3>

<p></p>
<ul class="text">
<li>Added a new error code: 403 (Forbidden).
</li>
<li>When processing a CreatePermission or ChannelBind request
            containing a XOR-PEER-ADDRESS attribute, the server is allow to
            reject certain IP address and port combinations for administrative
            or other reasons by returning a 403 (Forbidden) error.
</li>
<li>Added a request to IANA to establish a registery for channel
            numbers.
</li>
<li>Clarified the usage of the nonce value: a new random nonce
            SHOULD be selected for each Allocate attempt, and the nonce SHOULD
            be expired at least once an hour. Referenced <a class='info' href='#RFC4086'>[RFC4086]<span> (</span><span class='info'>Eastlake, D., Schiller, J., and S. Crocker, &ldquo;Randomness Requirements for Security,&rdquo; June&nbsp;2005.</span><span>)</span></a> for guidelines on selecting the nonce
            value.
</li>
<li>Made a number of minor editoral changes.
</li>
</ul>

<a name="anchor50"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.21.2"></a><h3>21.2.&nbsp;
Changes from -11 to -12</h3>

<p></p>
<ul class="text">
<li>Changed the port numbers used in the examples for the client,
            the peers, and the relayed-transport-address to put them in the
            Dynamic port range. They were previously in the Registered port
            range, which was arguably unrealistic.
</li>
<li>Noted that the XOR-MAPPED-ADDRESS attribute is defined in RFC
            5389.
</li>
<li>Used the codepoint names (Not-ECT, ECT(0), ECT(1), and CE) when
            talking about the ECN field.
</li>
<li>Updated the Introduction to note that the client must not only
            communicate its relayed-transport-address to the peers, but also
            learn the peers' server-reflexive transport addresses. As a
            result, removed the suggestion that the client could use a webpage
            to communicate with its peers.
</li>
<li>Added a description of the "TURN Loop attack" and its
            mitigation to the Security Considerations section.
</li>
<li>Fixed some errors in the examples in the Overview section. They
            had not been updated to be consistent with the change introduced
            in version -11 that a permission must be created before a client
            can send data to a peer.
</li>
<li>In the Additional Features subsection of the Overview, reworded
            the discussion of what end-to-end features are preserved by TURN.
            The previous text said that a number of features did not work, but
            as of version -11, these features _may_ work. At the same time,
            added a sentence noting that any Path MTU Discovery mechanism
            using the DONT-FRAGMENT attribute will not receive ICMP messages
            and will thus have to use techniques like those described in <a class='info' href='#RFC4821'>[RFC4821]<span> (</span><span class='info'>Mathis, M. and J. Heffner, &ldquo;Packetization Layer Path MTU Discovery,&rdquo; March&nbsp;2007.</span><span>)</span></a>.
</li>
<li>Added the recommendation that, when TCP transport is used
            between the client and the server, both ends should close the
            connection if they notice a long sequence of invalid TURN
            messages. A likely cause of this is an undetected bit error
            corrupting a length field somewhere.
</li>
<li>Reworded the paragraph explaining that channel bindings are
            per-allocation to further stress this point.
</li>
<li>In the discussion on setting the fragmentation fields, added a
            sentence saying that the client or server should follow the normal
            rules for fragmentation as described in <a class='info' href='#RFC1122'>[RFC1122]<span> (</span><span class='info'>Braden, R., &ldquo;Requirements for Internet Hosts - Communication Layers,&rdquo; October&nbsp;1989.</span><span>)</span></a>.
</li>
</ul>

<a name="anchor51"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.21.3"></a><h3>21.3.&nbsp;
Changes from -10 to -11</h3>

<p></p>
<ul class="text">
<li>Clarified that, when the client is redirected to an alternate
            server, the client uses the same transport protocol to the
            alternate server as it did to the original server.
</li>
<li>Clarified the information that the server needs to store to
            authenticate requests and to compute the message-integrity on
            responses. Noted that the server need not store the password
            explicitly, but can instead store the key value, which may be
            desirable for security reasons.
</li>
<li>Clarified that TURN runs on the same ports as TURN by default,
            but noted that a server can use a different port because TURN has
            its own SRV service names. Strengthened the language for using the
            SRV procedures from "typically" to "SHOULD". Also added a sentence
            in the IANA considerations section requesting that IANA reserve
            the service names for TURN; previously they were described in the
            text but not mentioned in the IANA considerations section.
</li>
<li>Added a detailed example, complete with attributes and their
            values, of the use of TURN.
</li>
<li>Reduced the range of channel numbers. Channel numbers now range
            from 0x4000 through 0x7FFF. Values in the range 0x8000 through
            0xFFFF are now reserved.
</li>
<li>Rewrote the IAB Considerations section to directly address the
            considerations listed in <a class='info' href='#RFC3424'>[RFC3424]<span> (</span><span class='info'>Daigle, L. and IAB, &ldquo;IAB Considerations for UNilateral Self-Address Fixing (UNSAF) Across Network Address Translation,&rdquo; November&nbsp;2002.</span><span>)</span></a>.
</li>
<li>Generalized the 508 error code so it can be used for any sort
            of capacity-related problem. This error code was previously
            allowed only in Allocate responses, but is now also allowed in
            CreatePermission and ChannelBind responses to indicate that the
            server is unable to carry out the request due to some capacity
            problem.
</li>
<li>Changed the syntax of the CreatePermission request to allow
            multiple XOR-PEER-ADDRESS attributes to appear in the message, so
            that multiple permissions can be created or refreshed at the same
            time.
</li>
<li>Added the restriction that the server must already have a
            permission installed for the IP address in the XOR-PEER-ADDRESS
            attribute of a Send indication, otherwise the Send indication is
            ignored by the server.
</li>
<li>Put back the preferred behaviors into <a class='info' href='#sec-ip-header-fields'>Section&nbsp;12<span> (</span><span class='info'>IP Header Fields</span><span>)</span></a>, reversing the change made
            in version -10.
</li>
<li>Explicitly allow the server to restrict the range of IP
            addresses and ports it is willing to relay data too.
</li>
</ul>

<a name="anchor52"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.21.4"></a><h3>21.4.&nbsp;
Changes from -09 to -10</h3>

<p></p>
<ul class="text">
<li>Changed the recommendation for using the SOFTWARE attribute.
            Previously its use was recommended in all requests and responses;
            now it is only recommended in Allocate and Refresh requests and
            responses, though it may appear elsewhere. Also, version -09
            incorrectly referred to this attribute as "SOFTWARE-TYPE".
</li>
<li>Changed the name of the PEER-ADDRESS and RELAYED-ADDRESS
            attributes to XOR-PEER-ADDRESS and XOR-RELAYED-ADDRESS
            respectively for consistency with other specifications.
</li>
<li>Removed the concept of a "preserving" allocation. All
            allocations are now non-preserving. This simplifies the base
            specification and allows it to advance more rapidly; see the
            discussion in the BEHAVE meeting of 29 July 2008. The concept of a
            preserving allocation will be advanced as an extension to TURN. As
            part of this change, the P bit in the REQUESTED-PROPS attribute,
            the ICMP attribute, and ICMP message relaying was removed.
            Further, in <a class='info' href='#sec-ip-header-fields'>Section&nbsp;12<span> (</span><span class='info'>IP Header Fields</span><span>)</span></a>, the
            preferred behaviors were removed, leaving the alternate behaviors
            as the specified behaviors.
</li>
<li>Replaced the REQUESTED-PROPS attribute with the EVEN-PORT
            attribute. The new attribute lacks the feature of the old
            attribute of being an alternate way to specify new allocation
            properties. As a consequence, the only way to specify a new
            allocation property is to define a new attribute.
</li>
<li>Added text recommending that the client check that the IP
            address in XOR-PEER-ADDRESS attribute in a received Data
            indication is one with which the client believes there is an
            active permission. Similarly, it is recommended that the client
            check that a permission exist when receiving a ChannelData
            message.
</li>
<li>Added text recommending that the client delete the allocation
            if it receives a ChannelBind failure response on an unbound
            channel.
</li>
<li>Added the CreatePermission request/response transaction which
            adds or updates permissions, and removed the ability for Send
            indications and ChannelBind messages to install or update
            permissions. The net effect is that only authenticate-able
            messages (i.e., CreatePermission requests and ChannelBind
            requests) can install or refresh permissions; unauthenticate-able
            Send indications and ChannelData messages do not.
</li>
<li>Removed all support for IPv6. All IPv6 support, including ways
            of relaying between IPv4 and IPv6, will now be covered in <a class='info' href='#I-D.ietf-behave-turn-ipv6'>[I&#8209;D.ietf&#8209;behave&#8209;turn&#8209;ipv6]<span> (</span><span class='info'>Camarillo, G., Novo, O., and S. Perreault, &ldquo;Traversal Using Relays around NAT (TURN) Extension for IPv6,&rdquo; March&nbsp;2010.</span><span>)</span></a>.
</li>
<li>Reserved attribute code point 0x0021. This was previously used
            for the TIMER-VAL attribute, which was removed when the
            SetActiveDestination feature was removed.
</li>
<li>Added the DONT-FRAGMENT attribute which allows the client to
            request that the server set the DF bit when sending the UDP
            datagram to the peer. This attribute may appear in both Allocate
            requests and Send indications.
</li>
<li>Changed how the ALTERNATE-SERVER attribute is used. The
            attribute can no longer be used with any error code, but must be
            used with 300 (Try Alternative). It can now appear in
            unauthenticated responses, however there are restrictions around
            how the subsequent Allocate request is authenticated.
</li>
<li>Reworked the details of how idempotency of requests is handled,
            making it clear that the stack can either remember all
            transactions for 40 seconds, or can handle this using the
            so-called "stateless stack approach". Made some changes to the
            semantics of the Allocate, Refresh, and ChannelBind requests as a
            consequence.
</li>
<li>Added the requirement that a client cannot re-use previously
            bound channel number or transport address until 5 minutes after
            the channel binding expires. This avoids various race
            conditions.
</li>
<li>Removed the requirement that an allocation cannot be re-used
            within 2 minutes of having been deleted. This requirement was put
            in place to prevent mis-delivered packets but is no longer seen as
            having any real value.
</li>
<li>Added a recommendation that the server impose quotas on both
            the number of allocations and the amount of bandwidth a given
            username can use at one time. These quotas help protect against
            denial-of-service attacks.
</li>
<li>Completely rewrote the security considerations section.
</li>
<li>Made quite a few changes to the descriptive text in both the
            Overview and the normative text to try to further clarify
            concepts.
</li>
</ul>

<a name="anchor53"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.21.5"></a><h3>21.5.&nbsp;
Changes from -08 to -09</h3>

<p></p>
<ul class="text">
<li>Added text to properly define the ICMP attribute. This
            attribute was introduced in TURN-08, but not fully defined due to
            an oversight. Clarified that the attribute can appear in a Data
            indication, but not a Send indication. Added text to the section
            on receiving a Data indication that points out that this attribute
            may be present.
</li>
<li>Changed the wording around the handling of the DSCP field to
            allow the server to set the DSCP to an arbitrary value if the next
            hop is a Diff-Serv classifier and marker.
</li>
<li>When the server generates a 508 response due to an unsupported
            flag in the REQUESTED-PROPS attribute, the server now includes the
            REQUESTED-PROPS attribute in the response with all the flags it
            supports set to 1. This allows the client to see if the server
            does not understand one of its flags. Similarly, the client is now
            allowed to immediately retry the request if it modifies the
            included REQUESTED-PROPS attribute.
</li>
<li>Clarified that the REQUESTED-PROPS attribute can be used in
            conjunction with the RESERVATION-TOKEN attribute as long as both
            the E and R bits are 0. The spec previously contradicted itself on
            this point.
</li>
<li>Clarified that when the server receives a ChannelData message
            with a length field of 0, it sends a UDP Datagram to the peer that
            contains no application data.
</li>
<li>Rewrote some text around relaying incoming UDP Datagrams to
            avoid duplication of text in the Data indication and Channel
            sections.
</li>
<li>Added a note that points out that the on-going work on
            randomizing port allocations <a class='info' href='#I-D.ietf-tsvwg-port-randomization'>[I&#8209;D.ietf&#8209;tsvwg&#8209;port&#8209;randomization]<span> (</span><span class='info'>Larsen, M. and F. Gont, &ldquo;Transport Protocol Port Randomization Recommendations,&rdquo; April&nbsp;2010.</span><span>)</span></a> may be
            applicable to TURN.
</li>
<li>Clarified that the Allocate request containing a
            RESERVATION-TOKEN attribute can use any 5-tuple, and that 5-tuple
            need not have any specific relationship to the 5-tuple of the
            Allocate request that created the reservation.
</li>
<li>Added a note that discusses retransmitted Allocate requests
            over UDP where the first request receives a failure response, but
            the second receives a success response. The server may elect to
            remember transmitted failure responses to avoid this
            situation.
</li>
<li>Added text about the usage of the SOFTWARE-TYPE attribute
            (formerly known as the SERVER attribute) in TURN messages.
</li>
<li>Rewrote the text in the Overview that motivates why TURN
            supports TCP and TLS between the client and the server. The
            previous text had been identified by various readers as inadequate
            and misleading.
</li>
<li>Rewrote the section how a server handles a Refresh request to
            clarify processing in various error conditions. The new text makes
            it clear that it is OK to delete a non-existent allocation. It
            also clarifies how to handle retransmissions of Refresh requests
            over UDP.
</li>
<li>Renamed the "RELAY-ADDRESS" attribute to "RELAYED-ADDRESS",
            since the text consistently uses the term "relayed transport
            address" for the concept and ICE uses the term "relayed
            candidate".
</li>
<li>Changed the codepoint assigned to the error code "Wrong
            Credentials" from 438 to 441 to avoid a conflict with the "Stale
            Nonce" error code of STUN.
</li>
<li>Changed the text to consistently use non-capitalized "request",
            "response" and "indication", except in headings, error code names,
            etc.
</li>
<li>Added a note mentioning that TURN packets can be demuxed from
            other packets arriving on the same socket by looking at the
            5-tuple of the arriving packet.
</li>
<li>Clarified that there are no required attributes is a
            ChannelBind success response.
</li>
</ul>

<a name="anchor54"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.21.6"></a><h3>21.6.&nbsp;
Changes from -07 to -08</h3>

<p></p>
<ul class="text">
<li>Removed the BANDWIDTH attribute and all associated text
            (including error code 507 "Insufficient Bandwidth Capacity"), as
            the requirements for this feature were not clear and it was felt
            the feature could be easily added later.
</li>
<li>Changed the format of the REQUESTED-PROPS attribute from a
            one-byte field to a set of bit flags. Changed the semantics of the
            unused portion of the value from RFFU to "MUST be 0" to give a
            more desirable behavior when new flags are defined.
</li>
<li>Introduced the concept of Preserving vs. Non-Preserving
            allocations. As a result, completely revamped the rules for how to
            set the fields in the IP header, and added rules for relaying ICMP
            messages when the allocation is Preserving.
</li>
</ul>

<a name="anchor55"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.21.7"></a><h3>21.7.&nbsp;
Changes from -06 to -07</h3>

<p></p>
<ul class="text">
<li>Rewrote the General Behavior section, making various changes in
            the process.
</li>
<li>Changed the usage of authentication from MUST to SHOULD.
</li>
<li>Changed the requirement that subsequent requests use the same
            username and password from MUST to SHOULD to allow for the
            possibility of changing the credentials using some unspecified
            mechanism.
</li>
<li>Introduced a 438 (Wrong Credentials) error which is used when a
            non-Allocate request authenticates but does not use the same
            username and password as the Allocate request. Having a separate
            error code for this case avoids the client being confused over
            what the error actually is.
</li>
<li>The server must now prevent the relayed transport address and
            the 5-tuple from being reused in different allocations for 2
            minutes after the allocation expires.
</li>
<li>Changed the usage of FINGERPRINT from MUST NOT to MAY, to allow
            for the possible multiplexing of TURN with some other
            protocol.
</li>
<li>Rewrote much of the section on Allocations, splitting it into
            three new sections (one on allocations in general, one on creating
            an allocation, and one on refreshing an allocation).
</li>
<li>Replaced the mechanism for requesting relayed transport
            addresses with specific properties. The new mechanism is less
            powerful: a client can request an even port, or a pair of ports,
            but cannot request a single odd port or a specific port as was
            possible under the old mechanism. Nor can the client request a
            specific IP address.
</li>
<li>Changed the rules for handling ALTERNATE-SERVER, removing the
            requirement that the referring server have "positive knowledge"
            about the state of the alternate server. The new rules instead
            rely on text in STUN to prevent referral loops.
</li>
<li>Changed the rules for allocation lifetimes. Allocations
            lifetimes are now a minimum of 10 minutes; the client can ask for
            longer values, but requests for shorter values are ignored. The
            text now recommends that the client refresh an allocation one
            minute before it expires.
</li>
<li>Put in temporary procedures for handling the BANDWIDTH
            attribute, modelled on the LIFETIME attribute. These procedures
            are mostly placeholders and likely to change in the next
            revision.
</li>
<li>Added a detailed description of how a client reacts to the
            various errors it can receive in reply to an Allocate request.
            This replaces the various descriptions that were previously
            scattered throughout the document, which were inconsistent and
            sometimes contradictory.
</li>
<li>Added a new section that gives the normative rules for
            permissions.
</li>
<li>Changed the rules around permission lifetimes. The text used to
            recommend a value of one minute; it MUST now be 5 minutes.
</li>
<li>Removed the errors "Channel Missing or Invalid", "Peer Address
            Missing or Invalid" and "Lifetime Malformed or Invalid" and used
            400 "Bad Request" instead.
</li>
<li>Rewrote portions of the section on Send and Data indications
            and the section on Channels to try to make the client vs. server
            behavior clearer.
</li>
<li>Channel bindings now expire after 10 minutes, and must be
            refreshed to keep them alive.
</li>
<li>Binding a channel now installs or refreshes a permission for
            the IP address of corresponding peer.
</li>
<li>Changed the wording describing the situation when the client
            sends a ChannelData message before receiving the ChannelBind
            success response. -06 said that client SHOULD NOT do this; -07 now
            says that a client MAY, but describes the consequences of doing
            it.
</li>
<li>Added a section discussing the setting of fields in the IP
            header.
</li>
<li>Replaced the REQUESTED-PORT-PROPS attribute with the
            REQUESTED-PROPS attribute that has a different format and
            semantics, but reuses the same code point.
</li>
<li>Replaced the REQUESTED-IP attribute with the RESERVATION-TOKEN
            attribute, which has a different format and semantics, but reuses
            the same code point.
</li>
<li>Removed error codes 443 and 444, and replaced them with 508
            (Insufficient Port Capacity). Also changed the error text for code
            507 from "Insufficient Capacity" to "Insufficient Bandwidth
            Capacity".
</li>
</ul>

<a name="anchor56"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.21.8"></a><h3>21.8.&nbsp;
Changes from -05 to -06</h3>

<p></p>
<ul class="text">
<li>Changed the mechanism for allocating channels to the one
            proposed by Eric Rescorla at the Dec 2007 IETF meeting.
</li>
<li>Removed the framing mechanism (which was used to frame all
            messages) and replaced it with the ChannelData message. As part of
            this change, noted that the demux of ChannelData messages from
            TURN messages can be done using the first two bits of the
            message.
</li>
<li>Rewrote the sections on transmitted and receiving data as a
            result of the above to changes, splitting it into a section on
            Send and Data indications and a separate section on channels.
</li>
<li>Clarified the handling of Allocate request messages. In
            particular, subsequent Allocate request messages over UDP with the
            same transaction id are not an error but a retransmission.
</li>
<li>Restricted the range of ports available for allocation to the
            Dynamic and/or Private Port range, and noted when ports outside
            this range can be used.
</li>
<li>Changed the format of the REQUESTED-TRANSPORT attribute. The
            previous version used 00 for UDP and 01 for TCP; the new version
            uses protocol numbers from the IANA protocol number registry. The
            format of the attribute also changed.
</li>
<li>Made a large number of changes to the non-normative portion of
            the document to reflect technical changes and improve the
            presentation.
</li>
<li>Added the Issues section.
</li>
</ul>

<a name="anchor57"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.21.9"></a><h3>21.9.&nbsp;
Changes from -04 to -05</h3>

<p></p>
<ul class="text">
<li>Removed the ability to allocate addresses for TCP relaying.
            This is now covered in a separate document. However, communication
            between the client and the server can still run over TCP or
            TLS/TCP. This resulted in the removal of the Connect method and
            the TIMER-VAL and CONNECT-STAT attributes.
</li>
<li>Added the concept of channels. All communication between the
            client and the server flows on a channel. Channels are numbered
            0..65535. Channel 0 is used for TURN messages, while the remaining
            channels are used for sending unencapsulated data to/from a remote
            peer. This concept adds a new Channel Confirmation method and a
            new CHANNEL-NUMBER attribute. The new attribute is also used in
            the Send and Data methods.
</li>
<li>The framing mechanism formally used just for stream-oriented
            transports is now also used for UDP, and the former Type and
            Reserved fields in the header have been replaced by a Channel
            Number field. The length field is zero when running over UDP.
</li>
<li>TURN now runs on its own port, rather than using the STUN port.
            The use of channels requires this.
</li>
<li>Removed the SetActiveDestination concept. This has been
            replaced by the concept of channels.
</li>
<li>Changed the allocation refresh mechanism. The new mechanism
            uses a new Refresh method, rather than repeating the Allocation
            transaction.
</li>
<li>Changed the syntax of SRV requests for secure transport. The
            new syntax is "_turns._tcp" rather than the old "_turn._tls". This
            change mirrors the corresponding change in STUN SRV syntax.
</li>
<li>Renamed the old REMOTE-ADDRESS attribute to PEER-ADDRESS, and
            changed it to use the XOR-MAPPED-ADDRESS format.
</li>
<li>Changed the RELAY-ADDRESS attribute to use the
            XOR-MAPPED-ADDRESS format (instead of the MAPPED-ADDRESS
            format)).
</li>
<li>Renamed the 437 error code from "No Binding" to "Allocation
            Mismatch".
</li>
<li>Added a discussion of what happens if a client's public binding
            on its outermost NAT changes.
</li>
<li>The document now consistently uses the term "peer" as the name
            of a remote endpoint with which the client wishes to
            communicate.
</li>
<li>Rewrote much of the document to describe the new concepts. At
            the same time, tried to make the presentation clearer and less
            repetitive.
</li>
</ul>

<a name="anchor58"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.22"></a><h3>22.&nbsp;
Acknowledgements</h3>

<p>The authors would like to thank the various participants in the
      BEHAVE working group for their many comments on this draft. Marc
      Petit-Huguenin, Remi Denis-Courmont, Jason Fischl, Derek MacDonald,
      Scott Godin, Cullen Jennings, Lars Eggert, Magnus Westerlund, Benny
      Prijono, and Eric Rescorla have been particularly helpful, with Eric
      also suggesting the channel allocation mechanism, and Cullen suggesting
      the REQUESTED-PORT-PROPS mechanism. Christian Huitema was an early
      contributor to this document and was a co-author on the first few
      drafts. Finally, the authors would like to thank Dan Wing for both his
      contributions to the text and his huge help in restarting progress on
      this draft after work had stalled.
</p>
<a name="rfc.references"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.23"></a><h3>23.&nbsp;
References</h3>

<a name="rfc.references1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>23.1.&nbsp;Normative References</h3>
<table width="99%" border="0">
<tr><td class="author-text" valign="top"><a name="RFC5389">[RFC5389]</a></td>
<td class="author-text">Rosenberg, J., Mahy, R., Matthews, P., and D. Wing, &ldquo;<a href="http://tools.ietf.org/html/rfc5389">Session Traversal Utilities for NAT (STUN)</a>,&rdquo; RFC&nbsp;5389, October&nbsp;2008 (<a href="http://www.rfc-editor.org/rfc/rfc5389.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC2119">[RFC2119]</a></td>
<td class="author-text"><a href="mailto:sob@harvard.edu">Bradner, S.</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>,&rdquo; BCP&nbsp;14, RFC&nbsp;2119, March&nbsp;1997 (<a href="http://www.rfc-editor.org/rfc/rfc2119.txt">TXT</a>, <a href="http://xml.resource.org/public/rfc/html/rfc2119.html">HTML</a>, <a href="http://xml.resource.org/public/rfc/xml/rfc2119.xml">XML</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC2474">[RFC2474]</a></td>
<td class="author-text"><a href="mailto:kmn@cisco.com">Nichols, K.</a>, <a href="mailto:slblake@torrentnet.com">Blake, S.</a>, <a href="mailto:fred@cisco.com">Baker, F.</a>, and <a href="mailto:black_david@emc.com">D. Black</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc2474">Definition of the Differentiated Services Field (DS Field) in the IPv4 and IPv6 Headers</a>,&rdquo; RFC&nbsp;2474, December&nbsp;1998 (<a href="http://www.rfc-editor.org/rfc/rfc2474.txt">TXT</a>, <a href="http://xml.resource.org/public/rfc/html/rfc2474.html">HTML</a>, <a href="http://xml.resource.org/public/rfc/xml/rfc2474.xml">XML</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC3168">[RFC3168]</a></td>
<td class="author-text">Ramakrishnan, K., Floyd, S., and D. Black, &ldquo;<a href="http://tools.ietf.org/html/rfc3168">The Addition of Explicit Congestion Notification (ECN) to IP</a>,&rdquo; RFC&nbsp;3168, September&nbsp;2001 (<a href="http://www.rfc-editor.org/rfc/rfc3168.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC1122">[RFC1122]</a></td>
<td class="author-text"><a href="mailto:Braden@ISI.EDU">Braden, R.</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc1122">Requirements for Internet Hosts - Communication Layers</a>,&rdquo; STD&nbsp;3, RFC&nbsp;1122, October&nbsp;1989 (<a href="http://www.rfc-editor.org/rfc/rfc1122.txt">TXT</a>).</td></tr>
</table>

<a name="rfc.references2"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>23.2.&nbsp;Informative References</h3>
<table width="99%" border="0">
<tr><td class="author-text" valign="top"><a name="RFC1918">[RFC1918]</a></td>
<td class="author-text"><a href="mailto:yakov@cisco.com">Rekhter, Y.</a>, <a href="mailto:rgm3@is.chrysler.com">Moskowitz, R.</a>, <a href="mailto:Daniel.Karrenberg@ripe.net">Karrenberg, D.</a>, <a href="mailto:GeertJan.deGroot@ripe.net">Groot, G.</a>, and <a href="mailto:lear@sgi.com">E. Lear</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc1918">Address Allocation for Private Internets</a>,&rdquo; BCP&nbsp;5, RFC&nbsp;1918, February&nbsp;1996 (<a href="http://www.rfc-editor.org/rfc/rfc1918.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC3424">[RFC3424]</a></td>
<td class="author-text">Daigle, L. and IAB, &ldquo;<a href="http://tools.ietf.org/html/rfc3424">IAB Considerations for UNilateral Self-Address Fixing (UNSAF) Across Network Address Translation</a>,&rdquo; RFC&nbsp;3424, November&nbsp;2002 (<a href="http://www.rfc-editor.org/rfc/rfc3424.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4787">[RFC4787]</a></td>
<td class="author-text">Audet, F. and C. Jennings, &ldquo;<a href="http://tools.ietf.org/html/rfc4787">Network Address Translation (NAT) Behavioral Requirements for Unicast UDP</a>,&rdquo; BCP&nbsp;127, RFC&nbsp;4787, January&nbsp;2007 (<a href="http://www.rfc-editor.org/rfc/rfc4787.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="I-D.ietf-mmusic-ice">[I-D.ietf-mmusic-ice]</a></td>
<td class="author-text">Rosenberg, J., &ldquo;<a href="http://www.ietf.org/internet-drafts/draft-ietf-mmusic-ice-19.txt">Interactive Connectivity Establishment (ICE): A Protocol for Network Address Translator (NAT) Traversal for Offer/Answer Protocols</a>,&rdquo; draft-ietf-mmusic-ice-19 (work in progress), October&nbsp;2007 (<a href="http://www.ietf.org/internet-drafts/draft-ietf-mmusic-ice-19.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="I-D.ietf-behave-turn-tcp">[I-D.ietf-behave-turn-tcp]</a></td>
<td class="author-text">Perreault, S. and J. Rosenberg, &ldquo;<a href="http://www.ietf.org/internet-drafts/draft-ietf-behave-turn-tcp-06.txt">Traversal Using Relays around NAT (TURN) Extensions for TCP Allocations</a>,&rdquo; draft-ietf-behave-turn-tcp-06 (work in progress), March&nbsp;2010 (<a href="http://www.ietf.org/internet-drafts/draft-ietf-behave-turn-tcp-06.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="I-D.ietf-behave-turn-ipv6">[I-D.ietf-behave-turn-ipv6]</a></td>
<td class="author-text">Camarillo, G., Novo, O., and S. Perreault, &ldquo;<a href="http://www.ietf.org/internet-drafts/draft-ietf-behave-turn-ipv6-09.txt">Traversal Using Relays around NAT (TURN) Extension for IPv6</a>,&rdquo; draft-ietf-behave-turn-ipv6-09 (work in progress), March&nbsp;2010 (<a href="http://www.ietf.org/internet-drafts/draft-ietf-behave-turn-ipv6-09.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="I-D.ietf-tsvwg-port-randomization">[I-D.ietf-tsvwg-port-randomization]</a></td>
<td class="author-text">Larsen, M. and F. Gont, &ldquo;<a href="http://www.ietf.org/internet-drafts/draft-ietf-tsvwg-port-randomization-07.txt">Transport Protocol Port Randomization Recommendations</a>,&rdquo; draft-ietf-tsvwg-port-randomization-07 (work in progress), April&nbsp;2010 (<a href="http://www.ietf.org/internet-drafts/draft-ietf-tsvwg-port-randomization-07.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC5128">[RFC5128]</a></td>
<td class="author-text">Srisuresh, P., Ford, B., and D. Kegel, &ldquo;<a href="http://tools.ietf.org/html/rfc5128">State of Peer-to-Peer (P2P) Communication across Network Address Translators (NATs)</a>,&rdquo; RFC&nbsp;5128, March&nbsp;2008 (<a href="http://www.rfc-editor.org/rfc/rfc5128.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC1928">[RFC1928]</a></td>
<td class="author-text"><a href="mailto:mleech@bnr.ca">Leech, M.</a>, Ganis, M., Lee, Y., Kuris, R., Koblas, D., and L. Jones, &ldquo;<a href="http://tools.ietf.org/html/rfc1928">SOCKS Protocol Version 5</a>,&rdquo; RFC&nbsp;1928, March&nbsp;1996 (<a href="http://www.rfc-editor.org/rfc/rfc1928.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC3550">[RFC3550]</a></td>
<td class="author-text">Schulzrinne, H., Casner, S., Frederick, R., and V. Jacobson, &ldquo;<a href="http://tools.ietf.org/html/rfc3550">RTP: A Transport Protocol for Real-Time Applications</a>,&rdquo; STD&nbsp;64, RFC&nbsp;3550, July&nbsp;2003 (<a href="http://www.rfc-editor.org/rfc/rfc3550.txt">TXT</a>, <a href="http://www.rfc-editor.org/rfc/rfc3550.ps">PS</a>, <a href="http://www.rfc-editor.org/rfc/rfc3550.pdf">PDF</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC3711">[RFC3711]</a></td>
<td class="author-text">Baugher, M., McGrew, D., Naslund, M., Carrara, E., and K. Norrman, &ldquo;<a href="http://tools.ietf.org/html/rfc3711">The Secure Real-time Transport Protocol (SRTP)</a>,&rdquo; RFC&nbsp;3711, March&nbsp;2004 (<a href="http://www.rfc-editor.org/rfc/rfc3711.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4302">[RFC4302]</a></td>
<td class="author-text">Kent, S., &ldquo;<a href="http://tools.ietf.org/html/rfc4302">IP Authentication Header</a>,&rdquo; RFC&nbsp;4302, December&nbsp;2005 (<a href="http://www.rfc-editor.org/rfc/rfc4302.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4303">[RFC4303]</a></td>
<td class="author-text">Kent, S., &ldquo;<a href="http://tools.ietf.org/html/rfc4303">IP Encapsulating Security Payload (ESP)</a>,&rdquo; RFC&nbsp;4303, December&nbsp;2005 (<a href="http://www.rfc-editor.org/rfc/rfc4303.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4821">[RFC4821]</a></td>
<td class="author-text">Mathis, M. and J. Heffner, &ldquo;<a href="http://tools.ietf.org/html/rfc4821">Packetization Layer Path MTU Discovery</a>,&rdquo; RFC&nbsp;4821, March&nbsp;2007 (<a href="http://www.rfc-editor.org/rfc/rfc4821.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC3261">[RFC3261]</a></td>
<td class="author-text">Rosenberg, J., Schulzrinne, H., Camarillo, G., Johnston, A., Peterson, J., Sparks, R., Handley, M., and E. Schooler, &ldquo;<a href="http://tools.ietf.org/html/rfc3261">SIP: Session Initiation Protocol</a>,&rdquo; RFC&nbsp;3261, June&nbsp;2002 (<a href="http://www.rfc-editor.org/rfc/rfc3261.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="I-D.rosenberg-mmusic-ice-nonsip">[I-D.rosenberg-mmusic-ice-nonsip]</a></td>
<td class="author-text">Rosenberg, J., &ldquo;<a href="http://www.ietf.org/internet-drafts/draft-rosenberg-mmusic-ice-nonsip-01.txt">Guidelines for Usage of Interactive Connectivity Establishment (ICE) by non  Session Initiation Protocol (SIP) Protocols</a>,&rdquo; draft-rosenberg-mmusic-ice-nonsip-01 (work in progress), July&nbsp;2008 (<a href="http://www.ietf.org/internet-drafts/draft-rosenberg-mmusic-ice-nonsip-01.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4086">[RFC4086]</a></td>
<td class="author-text">Eastlake, D., Schiller, J., and S. Crocker, &ldquo;<a href="http://tools.ietf.org/html/rfc4086">Randomness Requirements for Security</a>,&rdquo; BCP&nbsp;106, RFC&nbsp;4086, June&nbsp;2005 (<a href="http://www.rfc-editor.org/rfc/rfc4086.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="Port-Numbers">[Port-Numbers]</a></td>
<td class="author-text">&ldquo;<a href="http://www.iana.org/assignments/port-numbers">IANA Port Numbers Registry</a>.&rdquo;</td></tr>
<tr><td class="author-text" valign="top"><a name="Protocol-Numbers">[Protocol-Numbers]</a></td>
<td class="author-text">&ldquo;<a href="http://www.iana.org/assignments/protocol-numbers">IANA Protocol Numbers Registry</a>,&rdquo; 2005.</td></tr>
</table>

<a name="rfc.authors"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>Authors' Addresses</h3>
<table width="99%" border="0" cellpadding="0" cellspacing="0">
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Jonathan Rosenberg</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Cisco Systems, Inc.</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Edison, NJ</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">USA</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:jdrosen@cisco.com">jdrosen@cisco.com</a></td></tr>
<tr><td class="author" align="right">URI:&nbsp;</td>
<td class="author-text"><a href="http://www.jdrosen.net">http://www.jdrosen.net</a></td></tr>
<tr cellpadding="3"><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Rohan Mahy</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">(Unaffiliated)</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:rohan@ekabal.com">rohan@ekabal.com</a></td></tr>
<tr cellpadding="3"><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Philip Matthews</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Alcatel-Lucent</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">600 March Road</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Ottawa, Ontario  </td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Canada</td></tr>
<tr><td class="author" align="right">Phone:&nbsp;</td>
<td class="author-text"></td></tr>
<tr><td class="author" align="right">Fax:&nbsp;</td>
<td class="author-text"></td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:philip_matthews@magma.ca">philip_matthews@magma.ca</a></td></tr>
<tr><td class="author" align="right">URI:&nbsp;</td>
<td class="author-text"><a href=""></a></td></tr>
</table>
</body></html>
