<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="en"><head><title>An Architecture for Network Management using NETCONF and YANG</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="description" content="An Architecture for Network Management using NETCONF and YANG">
<meta name="generator" content="xml2rfc v1.35 (http://xml.resource.org/)">
<meta name="viewport" content="width=600;" />
<style type='text/css'><!--
        body {
                font-family: verdana, charcoal, helvetica, arial, sans-serif;
                font-size: 85%;
		max-width: 60em; 
		color: #000; background-color: #FFF;
                margin: 2em;
        }
        h1, h2, h3, h4, h5, h6 {
                font-family: helvetica, monaco, "MS Sans Serif", arial, sans-serif;
                font-weight: bold; font-style: normal;
        }
        h1 { color: #900; background-color: transparent; text-align: right; }
        h3 { color: #333; background-color: transparent; }

        td.RFCbug {
                font-size: x-small; text-decoration: none;
                width: 30px; height: 30px; padding-top: 2px;
                text-align: justify; vertical-align: middle;
                background-color: #000;
        }
        td.RFCbug span.RFC {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: bold; color: #666;
        }
        td.RFCbug span.hotText {
                font-family: charcoal, monaco, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: normal; text-align: center; color: #FFF;
        }

        table.TOCbug { width: 30px; height: 15px; }
        td.TOCbug {
                text-align: center; width: 30px; height: 15px;
                color: #FFF; background-color: #900;
        }
        td.TOCbug a {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, sans-serif;
                font-weight: bold; font-size: x-small; text-decoration: none;
                color: #FFF; background-color: transparent;
        }

        td.header {
                font-family: arial, helvetica, sans-serif; font-size: x-small;
                vertical-align: top; width: 33%;
                color: #FFF; background-color: #666;
        }
        td.author { font-weight: bold; font-size: x-small; margin-left: 4em; }
        td.author-text { font-size: x-small; }

        /* info code from SantaKlauss at http://www.madaboutstyle.com/tooltip2.html */
        a.info {
                /* This is the key. */
                position: relative;
                z-index: 24;
                text-decoration: none;
        }
        a.info:hover {
                z-index: 25;
                color: #FFF; background-color: #900;
        }
        a.info span { display: none; }
        a.info:hover span.info {
                /* The span will display just on :hover state. */
                display: block;
                position: absolute;
                font-size: smaller;
                top: 2em; left: -5em; width: 15em;
                padding: 2px; border: 1px solid #333;
                color: #900; background-color: #EEE;
                text-align: left;
        }

        a { font-weight: bold; }
        a:link    { color: #900; background-color: transparent; }
        a:visited { color: #633; background-color: transparent; }
        a:active  { color: #633; background-color: transparent; }

        p { margin-left: 2em; margin-right: 2em; }
        p.copyright { font-size: x-small; }
        p.toc { font-size: 85%;
		max-width: 60em; 
		font-weight: bold; margin-left: 3em; }
        table.toc { margin: 0 0 0 3em; padding: 0; border: 0; vertical-align: text-top; }
        td.toc { font-size: 85%;
		max-width: 60em; 
		font-weight: bold; vertical-align: text-top; }

        ol.text { margin-left: 2em; margin-right: 2em; }
        ul.text { margin-left: 2em; margin-right: 2em; }
        li      { margin-left: 3em; }

        /* RFC-2629 <spanx>s and <artwork>s. */
        em     { font-style: italic; }
        strong { font-weight: bold; }
        dfn    { font-weight: bold; font-style: normal; }
        cite   { font-weight: normal; font-style: normal; }
        tt     { color: #036; }
        tt, pre, pre dfn, pre em, pre cite, pre span {
                font-family: "Courier New", Courier, monospace; font-size: small;
        }
        pre {
                text-align: left; padding: 4px;
                color: #000; background-color: #CCC;
        }
        pre dfn  { color: #900; }
        pre em   { color: #66F; background-color: #FFC; font-weight: normal; }
        pre .key { color: #33C; font-weight: bold; }
        pre .id  { color: #900; }
        pre .str { color: #000; background-color: #CFF; }
        pre .val { color: #066; }
        pre .rep { color: #909; }
        pre .oth { color: #000; background-color: #FCF; }
        pre .err { background-color: #FCC; }

        /* RFC-2629 <texttable>s. */
        table.all, table.full, table.headers, table.none {
                font-size: 85%;
		max-width: 60em; 
		text-align: center; border-width: 2px;
                vertical-align: top; border-collapse: collapse;
        }
        table.all, table.full { border-style: solid; border-color: black; }
        table.headers, table.none { border-style: none; }
        th {
                font-weight: bold; border-color: black;
                border-width: 2px 2px 3px 2px;
        }
        table.all th, table.full th { border-style: solid; }
        table.headers th { border-style: none none solid none; }
        table.none th { border-style: none; }
        table.all td {
                border-style: solid; border-color: #333;
                border-width: 1px 2px;
        }
        table.full td, table.headers td, table.none td { border-style: none; }

        hr { height: 1px; }
        hr.insert {
                width: 80%; border-style: none; border-width: 0;
                color: #CCC; background-color: #CCC;
        }
--></style>
</head>
<body>
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<table summary="layout" width="66%" border="0" cellpadding="0" cellspacing="0"><tr><td><table summary="layout" width="100%" border="0" cellpadding="2" cellspacing="1">
<tr><td class="header">Network Working Group</td><td class="header">P. Shafer</td></tr>
<tr><td class="header">Internet-Draft</td><td class="header">Juniper Networks</td></tr>
<tr><td class="header">Intended status: Informational</td><td class="header">June 23, 2010</td></tr>
<tr><td class="header">Expires: December 25, 2010</td><td class="header">&nbsp;</td></tr>
</table></td></tr></table>
<h1><br />An Architecture for Network Management using NETCONF and YANG<br />draft-ietf-netmod-arch-07</h1>

<h3>Abstract</h3>

<p>
NETCONF gives access to native capabilities of the
devices within a network, defining methods for manipulating
configuration databases, retrieving operational data, and invoking
specific operations.  YANG provides the means to define the content
carried via NETCONF, both data and operations.  Using both
technologies, standard modules can be defined to give interoperability
and commonality to devices, while still allowing devices to express
their unique capabilities.
	
</p>
<p>
This document describes how NETCONF and YANG help build network
management applications that meet the needs of network operators.
	
</p>
<h3>Status of this Memo</h3>
<p>
This Internet-Draft is submitted  in full
conformance with the provisions of BCP&nbsp;78 and BCP&nbsp;79.</p>
<p>
Internet-Drafts are working documents of the Internet Engineering
Task Force (IETF).  Note that other groups may also distribute
working documents as Internet-Drafts.  The list of current
Internet-Drafts is at http://datatracker.ietf.org/drafts/current/.</p>
<p>
Internet-Drafts are draft documents valid for a maximum of six months
and may be updated, replaced, or obsoleted by other documents at any time.
It is inappropriate to use Internet-Drafts as reference material or to cite
them other than as &ldquo;work in progress.&rdquo;</p>
<p>
This Internet-Draft will expire on December 25, 2010.</p>

<h3>Copyright Notice</h3>
<p>
Copyright (c) 2010 IETF Trust and the persons identified as the
document authors.  All rights reserved.</p>
<p>
This document is subject to BCP 78 and the IETF Trust's Legal
Provisions Relating to IETF Documents
(http://trustee.ietf.org/license-info) in effect on the date of
publication of this document.  Please review these documents
carefully, as they describe your rights and restrictions with respect
to this document. Code Components extracted from this document must
include Simplified BSD License text as described in Section 4.e of
the Trust Legal Provisions and are provided without warranty as
described in the Simplified BSD License.</p>
<p>
This document may contain material from IETF Documents or IETF
Contributions published or made publicly available before November
10, 2008.  The person(s) controlling the copyright in some of this
material may not have granted the IETF Trust the right to allow
modifications of such material outside the IETF Standards Process.
Without obtaining an adequate license from the person(s) controlling
the copyright in such materials, this document may not be modified
outside the IETF Standards Process, and derivative works of it may
not be created outside the IETF Standards Process, except to format
it for publication as an RFC or to translate it into languages other
than English.</p>
<a name="toc"></a><br /><hr />
<h3>Table of Contents</h3>
<p class="toc">
<a href="#anchor1">1.</a>&nbsp;
Introduction<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor2">1.1.</a>&nbsp;
Origins of NETCONF and YANG<br />
<a href="#anchor3">2.</a>&nbsp;
Elements of the Architecture<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor4">2.1.</a>&nbsp;
NETCONF<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor5">2.1.1.</a>&nbsp;
NETCONF Transport Mappings<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor6">2.2.</a>&nbsp;
YANG<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor7">2.2.1.</a>&nbsp;
Constraints<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor8">2.2.2.</a>&nbsp;
Flexibility<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor9">2.2.3.</a>&nbsp;
Extensibility Model<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor10">2.3.</a>&nbsp;
YANG Translations<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor11">2.3.1.</a>&nbsp;
YIN<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor12">2.3.2.</a>&nbsp;
DSDL (Relax NG)<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor13">2.4.</a>&nbsp;
YANG Types<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor14">2.5.</a>&nbsp;
IETF Guidelines<br />
<a href="#anchor15">3.</a>&nbsp;
Working with YANG<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor16">3.1.</a>&nbsp;
Building NETCONF- and YANG-based Solutions<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor17">3.2.</a>&nbsp;
Addressing Operator Requirements<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor18">3.3.</a>&nbsp;
Roles in Building Solutions<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor19">3.3.1.</a>&nbsp;
Modeler<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor20">3.3.2.</a>&nbsp;
Reviewer<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor21">3.3.3.</a>&nbsp;
Device Developer<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor24">3.3.4.</a>&nbsp;
Application Developer<br />
<a href="#modeling">4.</a>&nbsp;
Modeling Considerations<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor28">4.1.</a>&nbsp;
Default Values<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor29">4.2.</a>&nbsp;
Compliance<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor30">4.3.</a>&nbsp;
Data Distinctions<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor31">4.3.1.</a>&nbsp;
Background<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor32">4.3.2.</a>&nbsp;
Definitions<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor36">4.3.3.</a>&nbsp;
Implications<br />
<a href="#anchor40">5.</a>&nbsp;
Security Considerations<br />
<a href="#anchor41">6.</a>&nbsp;
IANA Considerations<br />
<a href="#rfc.references1">7.</a>&nbsp;
Normative References<br />
<a href="#rfc.authors">&#167;</a>&nbsp;
Author's Address<br />
</p>
<br clear="all" />

<a name="anchor1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1"></a><h3>1.&nbsp;
Introduction</h3>

<a name="anchor2"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1.1"></a><h3>1.1.&nbsp;
Origins of NETCONF and YANG</h3>

<p>
Networks are increasing in complexity and capacity, as well as the
density of the services deployed upon them.  Uptime, reliability, and
predictable latency requirements drive the need for automation.  The
problems with network management are not simple.  They are complex and
intricate.  But these problems must be solved for networks to meet the
stability needs of existing services while incorporating new services
in a world where the growth of networks is exhausting the supply
of qualified networking engineers.
    
</p>
<p>
In June of 2002, Internet Architecture Board (IAB) held a workshop on
Network Management (<a class='info' href='#RFC3535'>[RFC3535]<span> (</span><span class='info'>Schoenwaelder, J., &ldquo;Overview of the 2002 IAB Network Management Workshop,&rdquo; May&nbsp;2003.</span><span>)</span></a>).  The members of this workshop made a
number of observations and recommendations for the IETF&#039;s
consideration concerning the issues operators were facing in their
network management-related work as well as issues they were having
with the direction of the IETF activities in this area.
    
</p>
<p>
The output of this workshop was focused on current problems.  The
observations were reasonable and straight forward, including the
need for transactions, rollback, low implementation costs, and the
ability to save and restore the device&#039;s configuration data.  Many of
the observations give insight into the problems operators were
having with existing network management solutions, such as the lack of
full coverage of device capabilities and the ability to distinguish
between configuration data and other types of data.
    
</p>
<p>
Based on these directions, the NETCONF working group was formed and
the Network Configuration (NETCONF) protocol was created.  This
protocol defines a simple mechanism where network management
applications, acting as clients, can invoke operations on the devices,
which act as servers.  The NETCONF specification defines a small set
of operations, but goes out of its way to avoid making any
requirements on the data carried in those operations, preferring to
allow the protocol to carry any data.  This &quot;data model agnostic&quot;
approach allows data models to be defined independently.
    
</p>
<p>
But lacking a means of defining data models, the NETCONF protocol was
not usable for standards-based work.  Existing data modeling languages
such as XSD and Relax NG were considered, but were rejected because
the problem domains have little natural overlap.  Defining a protocol
which is encoded in XML is a distinct problem from defining an XML
document.
    
</p>
<p>
In 2007 and 2008, the issue of a data modeling language for NETCONF
was discussed in the OPS and APPS areas of IETF 70 and 71, and a
design team was tasked with creating a requirements document (expired
I-D draft-presuhn-rcdml-03.txt).  After discussing the available
options at the CANMOD BoF at IETF71, the community wrote a charter for
the NETMOD working group.  An excellent description of this time
period is available at
http://www.mail-archive.com/ietf@ietf.org/msg37006.html
    
</p>
<p>
In 2008 and 2009, the NETMOD working group produced a specification
for YANG (<a class='info' href='#RFCYANG'>[RFCYANG]<span> (</span><span class='info'>Bjorklund, M., Ed., &ldquo;YANG - A data modeling language for the Network Configuration Protocol (NETCONF),&rdquo; .</span><span>)</span></a>) as a means for defining data models for NETCONF,
allowing both standard and proprietary data models to be published in
a form that is easily digestible by human readers and satisfies many of
the issues raised in the IAB NM workshop.  This brings NETCONF to a
point where is can be used to develop standards within the IETF.
    
</p>
<p>
YANG allows a modeler to create a data model, to define the
organization of the data in that model, and to define constraints on
that data.  Once published, the YANG module acts as a contract between
the client and server, with both parties understanding how their peer
will expect them to behave.  A client knows how to create valid data
for the server, and knows what data will be sent from the server.  A
server knows the rules that govern the data and how it should behave.
    
</p>
<p>
YANG also incorporates a level of extensibility and flexibility
not present in other model languages.  New modules can augment the
data hierarchies defined in other modules, seemlessly adding data at
appropriate places in the existing data organization.  YANG also
allows new statements to be defined, allowing the language itself to
be expanded in a consistent way.
    
</p>
<p>
This document presents an architecture for YANG, describing how
YANG-related technologies work and how solutions built on them can
address the network management problem domain.
    
</p>
<a name="anchor3"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2"></a><h3>2.&nbsp;
Elements of the Architecture</h3>

<a name="anchor4"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2.1"></a><h3>2.1.&nbsp;
NETCONF</h3>

<p>
NETCONF defines an XML-based remote procedure call (RPC) mechanism
that leverages the simplicity and availability of high-quality XML
parsers.  XML gives a rich, flexible, hierarchical, standard
representation of data that matches the needs of networking devices.
NETCONF carries configuration data and operations as requests and
replies using RPCs encoded in XML over a connection-oriented
transport.
    
</p>
<p>
XML&#039;s hierarchical data representation allows complex networking data
to be rendered in a natural way.  For example, the following
configuration places interfaces in OSPF areas.  The &lt;ospf&gt; element
contains a list of &lt;area&gt; elements, each of which contain a list of
&lt;interface&gt; elements.  The &lt;name&gt; element identifies the specific area
or interface.  Additional configuration for each area or interface
appears directly inside the appropriate element.
    
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
      &lt;ospf xmlns="http://example.org/netconf/ospf"&gt;

        &lt;area&gt;
          &lt;name&gt;0.0.0.0&lt;/name&gt;

          &lt;interface&gt;
            &lt;name&gt;ge-0/0/0.0&lt;/name&gt;
            &lt;!-- The priority for this interface --&gt;
            &lt;priority&gt;30&lt;/priority&gt;
            &lt;metric&gt;100&lt;/metric&gt;
            &lt;dead-interval&gt;120&lt;/dead-interval&gt;
          &lt;/interface&gt;

          &lt;interface&gt;
            &lt;name&gt;ge-0/0/1.0&lt;/name&gt;
            &lt;metric&gt;140&lt;/metric&gt;
          &lt;/interface&gt;
        &lt;/area&gt;

        &lt;area&gt;
          &lt;name&gt;10.1.2.0&lt;/name&gt;

          &lt;interface&gt;
            &lt;name&gt;ge-0/0/2.0&lt;/name&gt;
            &lt;metric&gt;100&lt;/metric&gt;
          &lt;/interface&gt;

          &lt;interface&gt;
            &lt;name&gt;ge-0/0/3.0&lt;/name&gt;
            &lt;metric&gt;140&lt;/metric&gt;
            &lt;dead-interval&gt;120&lt;/dead-interval&gt;
          &lt;/interface&gt;
        &lt;/area&gt;
      &lt;/ospf&gt;
</pre></div>
<p>
NETCONF includes mechanisms for controlling configuration datastores.
Each datastore is a specific collection of configuration data that can
be used as source or target of the configuration-related operations.
The device can indicate whether it has a distinct &quot;startup&quot;
configuration datastore, whether the current or &quot;running&quot; datastore is
directly writable, or whether there is a &quot;candidate&quot; configuration
datastore where configuration changes can be made that will not affect
the device until a &quot;commit&#8209;configuration&quot; operation is invoked.
    
</p>
<p>
NETCONF defined operations that are invoked as RPCs from the client
(the application) to the server (running on the device).  The
following table lists these operations:
    
</p><table class="full" align="center" border="0" cellpadding="2" cellspacing="2">
<col align="left"><col align="left">
<tr><th align="left">Operation</th><th align="left">Description</th></tr>
<tr>
<td align="left">commit</td>
<td align="left">Commits the &quot;candidate&quot; configuration to &quot;running&quot;</td>
</tr>
<tr>
<td align="left">copy-config</td>
<td align="left">Copy one configuration datastore to another</td>
</tr>
<tr>
<td align="left">edit-config</td>
<td align="left">Change the contents of a configuration database</td>
</tr>
<tr>
<td align="left">get-config</td>
<td align="left">Retrieve all or part of a configuration datastore</td>
</tr>
<tr>
<td align="left">lock</td>
<td align="left">Prevent changes to a datastore from another party</td>
</tr>
<tr>
<td align="left">unlock</td>
<td align="left">Release a lock on a datastore</td>
</tr>
</table>
<br clear="all" />

<p>
NETCONF&#039;s &quot;capability&quot; mechanism allows the device to announce the set
of capabilities that the device supports, including protocol
operations, datastores, data models, and other abilities.  These are
announced during session establishment as part of the &lt;hello&gt; message.
A client can inspect the hello message to determine what the device is
capable of and how to interact with the device to perform the desired
tasks.
    
</p>
<p>
NETCONF also defines a means of sending asynchronous notifications
from the server to the client, described in <a class='info' href='#RFC5277'>[RFC5277]<span> (</span><span class='info'>Chisholm, S. and H. Trevino, &ldquo;NETCONF Event Notifications,&rdquo; July&nbsp;2008.</span><span>)</span></a>.
    
</p>
<p>
In addition, NETCONF can fetch state data, receive notifications, and
invoke additional RPC methods defined as part of a capability.  Complete
information about NETCONF can be found in <a class='info' href='#RFC4741'>[RFC4741]<span> (</span><span class='info'>Enns, R., &ldquo;NETCONF Configuration Protocol,&rdquo; December&nbsp;2006.</span><span>)</span></a>.
    
</p>
<a name="anchor5"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2.1.1"></a><h3>2.1.1.&nbsp;
NETCONF Transport Mappings</h3>

<p>
NETCONF can run over any transport protocol that meets the
requirements defined in RFC4741, including
    
</p>
<p>
 </p>
<ul class="text">
<li>
connection-oriented operation
 
</li>
<li>
authentication
 
</li>
<li>
integrity
 
</li>
<li>
confidentiality
 
</li>
</ul><p>

</p>
<p>
<a class='info' href='#RFC4742'>[RFC4742]<span> (</span><span class='info'>Wasserman, M. and T. Goddard, &ldquo;Using the NETCONF Configuration Protocol over Secure SHell (SSH),&rdquo; December&nbsp;2006.</span><span>)</span></a> defines an mapping for the SSH protocol, which is the
mandatory transport protocol.  Others include SOAP (<a class='info' href='#RFC4743'>[RFC4743]<span> (</span><span class='info'>Goddard, T., &ldquo;Using NETCONF over the Simple Object Access Protocol (SOAP),&rdquo; December&nbsp;2006.</span><span>)</span></a>),
BEEP (<a class='info' href='#RFC4744'>[RFC4744]<span> (</span><span class='info'>Lear, E. and K. Crozier, &ldquo;Using the NETCONF Protocol over the Blocks Extensible Exchange Protocol (BEEP),&rdquo; December&nbsp;2006.</span><span>)</span></a>), and TLS (<a class='info' href='#RFC5539'>[RFC5539]<span> (</span><span class='info'>Badra, M., &ldquo;NETCONF over Transport Layer Security (TLS),&rdquo; May&nbsp;2009.</span><span>)</span></a>).
    
</p>
<a name="anchor6"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2.2"></a><h3>2.2.&nbsp;
YANG</h3>

<p>
YANG is a data modeling language for NETCONF.  It allows the
description of hierarchies of data nodes (&quot;nodes&quot;) and the
constraints that exist among them.  YANG defines data models and how
to manipulate those models via NETCONF protocol operations.
    
</p>
<p>
Each YANG module defines a data model, uniquely identified by a
namespace URI.  These data models are extensible in a manner that
allows tight integration of standard data models and proprietary data
models.  Models are built from organizational containers, lists of
data nodes and data node forming leafs of the data tree.
    
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
    module example-ospf {
        namespace "http://example.org/netconf/ospf";
        prefix ospf;

        import network-types {  // Access another module's def'ns
            prefix nett;
        }

        container ospf {   // Declare the top-level tag
            list area {    // Declare a list of "area" nodes
                key name;  // The key "name" identifies list members
                leaf name {
                    type nett:area-id;
                }
                list interface {
                    key name;
                    leaf name {
                        type nett:interface-name;
                    }
                    leaf priority {
                        description "Designated router priority";
                        type uint8;  // The type is a constraint on
                                     // valid values for "priority".
                    }
                    leaf metric {
                        type uint16 {
                            range 1..65535;
                        }
                    }
                    leaf dead-interval {
                        units seconds;
                        type uint16 {
                            range 1..65535;
                        }
                    }
                }
            }
        }
    }
</pre></div>
<p>
A YANG module defines a data model in terms of the data, its
hierarchical organization, and the constraints on that data.  YANG
defines how this data is represented in XML and how that data is used
in NETCONF operations.
    
</p>
<p>
The following table briefly describes some common YANG statements:
    
</p><table class="full" align="center" border="0" cellpadding="2" cellspacing="2">
<col align="left"><col align="left">
<tr><th align="left">Statement</th><th align="left">Description</th></tr>
<tr>
<td align="left">augment</td>
<td align="left">Extends existing data hierarchies</td>
</tr>
<tr>
<td align="left">choice</td>
<td align="left">Defines mutually exclusive alternatives</td>
</tr>
<tr>
<td align="left">container</td>
<td align="left">Defines a layer of the data hierarchy</td>
</tr>
<tr>
<td align="left">extension</td>
<td align="left">Allows new statements to be added to YANG</td>
</tr>
<tr>
<td align="left">feature</td>
<td align="left">Indicates parts of the model are optional</td>
</tr>
<tr>
<td align="left">grouping</td>
<td align="left">Groups data definitions into reusable sets</td>
</tr>
<tr>
<td align="left">key</td>
<td align="left">Defines the key leafs for lists</td>
</tr>
<tr>
<td align="left">leaf</td>
<td align="left">Defines a leaf node in the data hierarchy</td>
</tr>
<tr>
<td align="left">leaf-list</td>
<td align="left">A leaf node that can appear multiple times</td>
</tr>
<tr>
<td align="left">list</td>
<td align="left">A hierarchy that can appear multiple times</td>
</tr>
<tr>
<td align="left">notification</td>
<td align="left">Defines  notification</td>
</tr>
<tr>
<td align="left">rpc</td>
<td align="left">Defines input and output parameters for an RPC operation</td>
</tr>
<tr>
<td align="left">typedef</td>
<td align="left">Defines a new type</td>
</tr>
<tr>
<td align="left">uses</td>
<td align="left">Incorporates the contents of a &quot;grouping&quot;</td>
</tr>
</table>
<br clear="all" />

<a name="anchor7"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2.2.1"></a><h3>2.2.1.&nbsp;
Constraints</h3>

<p>
YANG allows the modeler to add constraints to the data model to
prevent impossible or illogical data.  These constraints give clients
information about the data being sent from the device, and also allow
the client to know as much as possible about the data the device will
accept, so the client can send correct data.  These constraints apply
to configuration data, but can also be used for rpc and notification
data.
    
</p>
<p>
The principal constraint is the &quot;type&quot; statement, which limits the
contents of a leaf node to that of the named type.  The following
table briefly describes some other common YANG constraints:
    
</p><table class="full" align="center" border="0" cellpadding="2" cellspacing="2">
<col align="left"><col align="left">
<tr><th align="left">Statement</th><th align="left">Description</th></tr>
<tr>
<td align="left">length</td>
<td align="left">Limits the length of a string</td>
</tr>
<tr>
<td align="left">mandatory</td>
<td align="left">Requires the node appear</td>
</tr>
<tr>
<td align="left">max-elements</td>
<td align="left">Limits the number of instances in a list</td>
</tr>
<tr>
<td align="left">min-elements</td>
<td align="left">Limits the number of instances in a list</td>
</tr>
<tr>
<td align="left">must</td>
<td align="left">XPath expression must be true</td>
</tr>
<tr>
<td align="left">pattern</td>
<td align="left">Regular expression must be satisfied</td>
</tr>
<tr>
<td align="left">range</td>
<td align="left">Value must appear in range</td>
</tr>
<tr>
<td align="left">reference</td>
<td align="left">Value must appear elsewhere in the data</td>
</tr>
<tr>
<td align="left">unique</td>
<td align="left">Value must be unique within the data</td>
</tr>
<tr>
<td align="left">when</td>
<td align="left">Node is only present when XPath expression is true</td>
</tr>
</table>
<br clear="all" />

<p>
The &quot;must&quot; and &quot;when&quot; statements use XPath expressions to specify
conditions that are semantically evaluated against the data hierarchy,
but neither the client nor the server are required to implement the
XPath specification.  Instead they can use any means to ensure these
conditions are met.
    
</p>
<a name="anchor8"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2.2.2"></a><h3>2.2.2.&nbsp;
Flexibility</h3>

<p>
YANG uses the &quot;union&quot; type and the &quot;choice&quot; and &quot;feature&quot; statements
to give modelers flexibility in defining their data models.  The
&quot;union&quot; type allows a single leaf to accept multiple types, like an
integer or the word &quot;unbounded&quot;:
    
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
  type union {
      type int32;
      type enumeration {
          enum "unbounded";
      }
  }
</pre></div>
<p>
The &quot;choice&quot; statement lists a set of mutually exclusive nodes, so a
valid configuration can choose any one node (or case).  The &quot;feature&quot;
statement allows the modeler to identify parts of the model which can
be optional, and allows the device to indicate whether it implements
these optional portions.
    
</p>
<p>
The &quot;deviation&quot; statement allows the device, to indicate parts of a
YANG module which the device does not faithfully implement.  While
devices are encouraged to fully abide according to the contract
presented in the YANG module, real world situations may force the
device to break the contract.  Deviations give a means of declaring
this limitation, rather than leaving it to be discovered via run-time
errors.
    
</p>
<a name="anchor9"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2.2.3"></a><h3>2.2.3.&nbsp;
Extensibility Model</h3>

<p>
XML includes the concept of namespaces, allowing XML elements from
different sources to be combined in the same hierarchy without
risking collision.  YANG modules define content for specific
namespaces, but one module may augment the definition of another module,
introducing elements from that module&#039;s namespace into the first
module&#039;s hierarchy.
    
</p>
<p>
Since one module can augment another module&#039;s definition, hierarchies
of definitions are allowed to grow, as definitions from multiple
sources are added to the base hierarchy.  These augmentations are
qualified using the namespace of the source module, helping to avoid
issues with name conflicts as the modules change over time.
    
</p>
<p>
For example, if the above OSPF configuration were the standard, a
vendor module may augment this with vendor-specific extensions.
    
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
    module vendorx-ospf {
        namespace "http://vendorx.example.com/ospf";
        prefix vendorx;

        import example-ospf {
            prefix ospf;
        }

        augment /ospf:ospf/ospf:area/ospf:interfaces {
            leaf no-neighbor-down-notification {
                type empty;
                description "Don't inform other protocols about"
                          + " neighbor down events";
            }
        }
    }
</pre></div>
<p>
The &lt;no&#8209;neighbor&#8209;down&#8209;notification&gt; element is then placed in the
vendorx namespace:
    
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
    &lt;ospf xmlns="http://example.org/netconf/ospf"&gt;

      &lt;area&gt;
        &lt;name&gt;0.0.0.0&lt;/name&gt;

        &lt;interface&gt;
          &lt;name&gt;ge-0/0/0.0&lt;/name&gt;
          &lt;priority&gt;30&lt;/priority&gt;
          &lt;vendorx:no-neighbor-down-notification/&gt;
        &lt;/interface&gt;

      &lt;/area&gt;
    &lt;/ospf&gt;
</pre></div>
<p>
Augmentations are seamlessly integrated with base modules, allowing
them to be fetched, archived, loaded, and deleted within their natural
hierarchy.  If a client application asks for the configuration for a
specific OSPF area, it will receive the sub-hierarchy for
that area, complete with any augmentated data.
    
</p>
<a name="anchor10"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2.3"></a><h3>2.3.&nbsp;
YANG Translations</h3>

<p>
The YANG data modeling language is the central piece of a group of
related technologies.  The YANG language itself, described in <a class='info' href='#RFCYANG'>[RFCYANG]<span> (</span><span class='info'>Bjorklund, M., Ed., &ldquo;YANG - A data modeling language for the Network Configuration Protocol (NETCONF),&rdquo; .</span><span>)</span></a>,
defines the syntax of the language and its statements, the meaning of
those statements, and how to combine them to build the hierarchy of
nodes that describe a data model.
    
</p>
<p>
That document also defines the &quot;on the wire&quot; XML content for NETCONF
operations on data models defined in YANG modules.  This includes the
basic mapping between YANG data tree nodes and XML elements, as well
as mechanisms used in &lt;edit&#8209;config&gt; content to manipulate that data,
such as arranging the order of nodes within a list.
    
</p>
<p>
YANG uses a syntax that is regular and easily described, primarily
designed for human readability.  YANG&#039;s syntax is friendly to email,
diff, patch, and the constraints of RFC formatting.
    
</p>
<a name="anchor11"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2.3.1"></a><h3>2.3.1.&nbsp;
YIN</h3>

<p>
In some environments, incorporating a YANG parser may not be an
acceptable option.  For those scenarios, an XML grammar for YANG is
defined as YIN (YANG Independent Notation).  YIN allows the use
of XML parsers which are readily available in both open source and
commercial versions.  Conversion between YANG and YIN is direct,
loss-less and reversible.  YANG statements are converted to XML
elements, preserving the structure and content of YANG, but enabling
the use of off-the-shelf XML parsers rather than requiring the
integration of a YANG parser.  YIN maintains complete semantic
equivalence with YANG.
    
</p>
<a name="anchor12"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2.3.2"></a><h3>2.3.2.&nbsp;
DSDL (Relax NG)</h3>

<p>
Since NETCONF content is encoded in XML, it is natural to use XML
schema languages for their validation. To facilitate this, YANG
offers a standardized mapping of YANG modules into Document Schema
Description Languages (<a class='info' href='#RFCYANGDSDL'>[RFCYANGDSDL]<span> (</span><span class='info'>Lhotka, L., Mahy, R., and S. Chishom, &ldquo;Mapping YANG to Document Schema Definition Languages and Validating NETCONF Content,&rdquo; .</span><span>)</span></a>).
    
</p>
<p>
DSDL is considered to be the best choice for the given purpose
because it addresses not only grammar and datatypes of XML
documents but also semantic constraints and rules for modifying
information set of the document.
    
</p>
<p>
In addition, DSDL offers formal means for coordinating multiple
independent schemas and specifying how to apply the schemas to the
various parts of the document. This is useful since YANG content
is typically composed of multiple vocabularies.
    
</p>
<a name="anchor13"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2.4"></a><h3>2.4.&nbsp;
YANG Types</h3>

<p>
YANG supports a number of builtin types, and allows additional types
to be derived from those types in an extensible manner.  New types can
add additional restrictions to allowable data values.
    
</p>
<p>
A standard type library for use by YANG is available <a class='info' href='#RFCYANGTYPES'>[RFCYANGTYPES]<span> (</span><span class='info'>Schoenwaelder, J., &ldquo;Common YANG Data Types,&rdquo; .</span><span>)</span></a>.
These YANG modules define commonly used data types for IETF-related
standards.
    
</p>
<a name="anchor14"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2.5"></a><h3>2.5.&nbsp;
IETF Guidelines</h3>

<p>
A set of additional guidelines are defined that indicate desirable
usage for authors and reviewers of standards track specifications
containing YANG data model modules (<a class='info' href='#RFCYANGUSAGE'>[RFCYANGUSAGE]<span> (</span><span class='info'>Bierman, A., &ldquo;Guidelines for Authors and Reviewers of YANG Data Model Documents,&rdquo; .</span><span>)</span></a>).  These
guidelines should be used as a basis for reviews of other YANG data
model documents.
    
</p>
<a name="anchor15"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3"></a><h3>3.&nbsp;
Working with YANG</h3>

<a name="anchor16"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.1"></a><h3>3.1.&nbsp;
Building NETCONF- and YANG-based Solutions</h3>

<p>
In the typical YANG-based solution, the client and server are driven
by the content of YANG modules.  The server includes the definitions
of the modules as meta-data that is available to the NETCONF engine.
This engine processes incoming requests, uses the meta-data to parse
and verify the request, performs the requested operation, and returns
the results to the client.
    
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
                    +----------------------------+
                    |Server (device)             |
                    |    +--------------------+  |
                    |    |      configuration |  |
         +----+     |    |     ---------------|  |
         |YANG|+    |    | m d  state data    |  |
         |mods||+   |    | e a ---------------|  |
         +----+|| -----&gt; | t t  notifications |  |
          +----+|   |    | a a ---------------|  |
           +----+   |    |      operations    |  |
                    |    +--------------------+  |
                    |           ^                |
                    |           |                |
                    |           v                |
  +------+          |     +-------------+        |
  |      | -------------&gt; |             |        |
  |Client| &lt;rpc&gt;    |     |  NETCONF    |        |
  | (app)|          |     |   engine    |        |
  |      | &lt;------------  |             |        |
  +------+ &lt;rpc-reply&gt;    +-------------+        |
                    |       /        \           |
                    |      /          \          |
                    |     /            \         |
                    | +--------+   +---------+   |
                    | | config |   |system   |+  |
                    | |  data- |   |software ||+ |
                    | |   base |   |component||| |
                    | +--------+   +---------+|| |
                    |               +---------+| |
                    |                +---------+ |
                    +----------------------------+
</pre></div>
<p>
To use YANG, YANG modules must be defined to model the specific
problem domain.  These modules are then loaded, compiled, or coded
into the server. 
    
</p>
<p>
The sequence of events for the typical client/server interaction is as
follows: 
    
</p>
<p>
 </p>
<ul class="text">
<li>
A client application ([C]) opens a NETCONF session to the server
(device) ([S])
 
</li>
<li>
[C] and [S] exchange &lt;hello&gt; messages containing the list of
capabilities supported by each side, allowing [C] to learn the modules
supported by [S]
 
</li>
<li>
[C] builds and sends an operation defined in the YANG module,
encoded in XML, within NETCONF&#039;s &lt;rpc&gt; element
 
</li>
<li>
[S] receives and parses the &lt;rpc&gt; element
 
</li>
<li>
[S] verifies the contents of the request against the data model
defined in the YANG module
 
</li>
<li>
[S] performs the requested operation, possibly changing the
configuration database
 
</li>
<li>
[S] builds the response, containing the response, any requested
data, and any errors
 
</li>
<li>
[S] sends the response, encoded in XML, within NETCONF&#039;s &lt;rpc&#8209;reply&gt;
element
 
</li>
<li>
[C] receives and parses the &lt;rpc&#8209;reply&gt; element
 
</li>
<li>
[C] inspects the response and processes it as needed
 
</li>
</ul><p>

</p>
<p>
Note that there is no requirement for the client or server to process
the YANG modules in this way.  The server may hard code the contents
of the data model, rather than handle the content via a generic
engine.  Or the client may be targeted at the specific YANG model,
rather than being driven generically.  Such a client might be a simple
shell script that stuffs arguments into an XML payload template and
sends it to the server.
    
</p>
<a name="anchor17"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.2"></a><h3>3.2.&nbsp;
Addressing Operator Requirements</h3>

<p>
YANG addresses many of the issues raised in the IAB NM workshop.
    
</p>
<p>
 </p>
<ul class="text">
<li>
Ease of use: YANG is designed to be human friendly, simple and
readable.  Many tricky issues remain due to the complexity of the
problem domain, but YANG strives to make them more visible and easier
to deal with.
 
</li>
<li>
Configuration and state data:  YANG clearly divides
configuration data from other types of data.
 
</li>
<li>
Transactions: NETCONF provides a simple transaction mechanism.
 
</li>
<li>
Generation of deltas: A YANG module gives enough information to
generate the delta needed to change between two configuration data
sets.
 
</li>
<li>
Dump and restore: NETCONF gives the ability to save and restore
configuration data.  This can also performed for a specific YANG
module.
 
</li>
<li>
Network-wide configuration:  NETCONF supports robust network-wide
configuration transactions via the confirmed-commit capability.
 
</li>
<li>
Text-friendly: YANG modules are very text friendly, as is the data
they define.
 
</li>
<li>
Configuration handling: NETCONF addresses the ability to distinguish
between distributing configuration data and activating it.
 
</li>
<li>
Task-oriented: A YANG module can define specific tasks as RPC
operations.  A client can choose to invoke the RPC operation or to
access any underlying data directly.
 
</li>
<li>
Full coverage: YANG modules can be defined that give full coverage
to all the native abilities of the device.  Giving this access
avoids the need to resort to the command line interface (CLI)
using tools such as Expect.
 
</li>
<li>
Timeliness: YANG modules can be tied to CLI operations, so all
native operations and data are immediately available.
 
</li>
<li>
Implementation difficulty: YANG&#039;s flexibility enables modules that
can be more easily implemented.  Adding &quot;features&quot; and replacing
&quot;third normal form&quot; with a natural data hierarchy should reduce
complexity.
 
</li>
<li>
Simple data modeling language: YANG has sufficient power to be
usable in other situations.  In particular, on-box API and native CLI
can be integrated to achieve simplification of the infrastructure.
 
</li>
<li>
Internationalization: YANG uses UTF-8 encoded unicode characters.
 
</li>
<li>
Event correlation: YANG integrates RPC operations, notification,
configuration and state data, enabling internal
references.  For example, a field in a notification can be tagged as
pointing to a BGP peer, and the client application can easily find
that peer in the configuration data.
 
</li>
<li>
Implementation costs: Significant effort has been made to keep
implementation costs as low as possible.
 
</li>
<li>
Human friendly syntax: YANG&#039;s syntax is optimized for the reader,
specifically the reviewer on the basis that this is the most common
human interaction.
 
</li>
<li>
Post-processing: Use of XML will maximize the opportunities for
post-processing of data, possibly using XML-based technologies like
XPath, XQuery, and XSLT.
 
</li>
<li>
Semantic mismatch: Richer, more descriptive data models will reduce
the possibility of semantic mismatch.  With the ability to define new
primitives, YANG modules will be more specific in content, allowing
more enforcement of rules and constraints.
 
</li>
<li>
Security: NETCONF runs over transport protocols secured by SSH or
TLS, allowing secure communications and authentication using
well-trusted technology.  The secure transport can use existing key
and credential management infrastructure, reducing deployment costs.
 
</li>
<li>
Reliable: NETCONF and YANG are solid and reliable technologies.
NETCONF is connection based, and includes automatic recovery
mechanisms when the connection is lost.
 
</li>
<li>
Delta friendly: YANG-based models support operations that are delta
friendly.  Add, change, insert, and delete operations are all well
defined.
 
</li>
<li>
Method-oriented: YANG allows new RPC operations to be defined,
including an operation name, which is essentially a method.  The input
and output parameters of the RPC operations are also defined in the
YANG module.
 
</li>
</ul><p>

</p>
<a name="anchor18"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.3"></a><h3>3.3.&nbsp;
Roles in Building Solutions</h3>

<p>
Building NETCONF- and YANG-based solutions requires interacting with
many distinct groups.  Modelers must understand how to build useful
models that give structure and meaning to data while maximizing the
flexibility of that data to &quot;future proof&quot; their work.  Reviewers need
to quickly determine if that structure is accurate.  Device developers
need to code that data model into their devices, and application
developers need to code their applications to take advantage of that
data model.  There are a variety of strategies for performing each
piece of this work.  This section discusses some of those strategies.
    
</p>
<a name="anchor19"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.3.1"></a><h3>3.3.1.&nbsp;
Modeler</h3>

<p>
The modeler defines a data model based on their in-depth knowledge of
the problem domain being modeled.  This model should be as simple as
possible, but should balance complexity with expressiveness.  The
organization of the model should target not only the current model,
but should allow for extensibility from other modules and for
adaptability to future changes.
    
</p>
<p>
Additional modeling issues are discussed in <a class='info' href='#modeling'>Section&nbsp;4<span> (</span><span class='info'>Modeling Considerations</span><span>)</span></a>.
    
</p>
<a name="anchor20"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.3.2"></a><h3>3.3.2.&nbsp;
Reviewer</h3>

<p>
The reviewer role is perhaps the most important and the time
reviewers are willing to give is precious.  To help the reviewer, YANG
stresses readability, with a human-friendly syntax, natural
data hierarchy, and simple, concise statements.
    
</p>
<a name="anchor21"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.3.3"></a><h3>3.3.3.&nbsp;
Device Developer</h3>

<p>
The YANG model tells the device developer what data is being modeled.
The developer reads the YANG models and writes code that supports the
model.  The model describes the data hierarchy and associated
constraints, and the description and reference material helps the
developer understand how to transform the models view into the
device&#039;s native implementation.
    
</p>
<a name="anchor22"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.3.3.1"></a><h3>3.3.3.1.&nbsp;
Generic Content Support</h3>

<p>
The YANG model can be compiled into a YANG-based engine for either the
client or server side.  Incoming data can be validated, as can
outgoing data.  The complete configuration datastore may be validated
in accordance with the constraints described in the data model.
    
</p>
<p>
Serializers and deserializers for generating and receiving NETCONF
content can be driven by the meta-data in the model.  As data is
received, the meta-data is consulted to ensure the validity of
incoming XML elements.
    
</p>
<a name="anchor23"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.3.3.2"></a><h3>3.3.3.2.&nbsp;
XML &quot;over the wire&quot; Definitions</h3>

<p>
The YANG module dictates the XML encoding sent &quot;over the wire&quot;, though
actual transmission should be encrypted so as not to appear as
readable text on the physical media.  The rules that define the
encoding are fixed, so the YANG module can be used to ascertain
whether a specific NETCONF payload is obeying the rules.
    
</p>
<a name="anchor24"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.3.4"></a><h3>3.3.4.&nbsp;
Application Developer</h3>

<p>
The YANG module tells the application developer what data can be
modeled.  Developers can inspect the modules and take one of three
distinct views.  In this section, we will consider them and the impact
of YANG on their design.  In the real world, most applications are a
mixture of these approaches.
    
</p>
<a name="anchor25"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.3.4.1"></a><h3>3.3.4.1.&nbsp;
Hard Coded</h3>

<p>
An application can be coded against the specific, well-known contents
of YANG modules, implementing their organization, rules, and logic
directly with explicit knowledge.  For example, a script could be
written to change the domain name of a set of devices using a standard
YANG module that includes such a leaf node.  This script takes the
new domain name as an argument and inserts it into a string containing the
rest of the XML encoding as required by the YANG module.  This content
is then sent via NETCONF to each of the devices.
    
</p>
<p>
This type of application is useful for small, fixed problems where the
cost and complexity of flexibility is overwhelmed by the ease of hard
coding direct knowledge into the application.
    
</p>
<a name="anchor26"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.3.4.2"></a><h3>3.3.4.2.&nbsp;
Bottom Up</h3>

<p>
An application may take a generic, bottom up approach to
configuration, concentrating on the device&#039;s data directly and
treating that data without specific understanding.
    
</p>
<p>
YANG modules may be used to drive the operation of the YANG equivalent
of a &quot;MIB Browser&quot;.  Such an application manipulates the device&#039;s
configuration data based on the data organization contained in the
YANG module.  For example, a GUI may present a straight-forward
visualization where elements of the YANG hierarchy are depicted in a
hierarchy of folders or GUI panels.  Clicking on a line expands to the
contents of the matching XML hierarchy.
    
</p>
<p>
This type of GUI can easily be built by generating XSLT stylesheets
from the YANG data models.  An XSLT engine can then be used to turn
configuration data into a set of web pages.
    
</p>
<p>
The YANG modules allow the application to enforce a set of
constraints without understanding the semantics of the YANG
module.  
    
</p>
<a name="anchor27"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.3.4.3"></a><h3>3.3.4.3.&nbsp;
Top Down</h3>

<p>
In contrast to the bottom-up approach, the top-down approach allows
the application to take a view of the configuration data which is
distinct from the standard and/or proprietary YANG modules.  The
application is free to construct its own model for data organization
and to present this model to the user.  When the application needs to
transmit data to a device, the application transforms its data from
the problem-oriented view of the world into the data needed for that
particular device.  This transformation is under the control and
maintenance of the application, allowing the transformation to be
changed and updated without affecting the device.
    
</p>
<p>
For example, an application could be written that models VPNs in a
network-oriented view.  The application would need to transform these
high-level VPN definitions into the configuration data that would be
handed to any particular device within a VPN.
    
</p>
<p>
Even in this approach, YANG is useful since it can be used to model
the VPN.  For example, the following VPN straw-man models a list of
VPNs, each with a protocol, a topology, a list of member interfaces,
and a list of classifiers.
    
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
    list example-bgpvpn {
        key name;
        leaf name { ... }
        leaf protocol {
            type enumeration {
                enum bgpvpn;
                enum l2vpn;
            }
        }
        leaf topology {
            type enumeration {
                enum hub-n-spoke;
                enum mesh;
            }
        }
        list members {
            key "device interface";
            leaf device { ... }
            leaf interface { ... }
        }
        list classifiers {
            ...
        }
    }
</pre></div>
<p>
The application can use such a YANG module to drive its operation,
building VPN instances in a database and then pushing the
configuration for those VPNs to individual devices using either a
standard device model (e.g. example-bgpvpn.yang) or by transforming that
standard device content into some proprietary format for devices that
do not support that standard.
    
</p>
<a name="modeling"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4"></a><h3>4.&nbsp;
Modeling Considerations</h3>

<p>
This section discusses considerations the modeler should be aware of
while developing models in YANG.
    
</p>
<a name="anchor28"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.1"></a><h3>4.1.&nbsp;
Default Values</h3>

<p>
The concept of default values is simple, but their details,
representation, and interaction with configuration data can be
difficult issues.  NETCONF leaves default values as a data model
issue, and YANG gives flexibility to the device implementation in
terms of how default values are handled.  The requirement is that the
device &quot;MUST operationally behave as if the leaf was present in the
data tree with the default value as its value&quot;.  This gives the device
implementation choices in how default values are handled.
    
</p>
<p>
One choice is to view the configuration as a set of instructions for
how the device should be configured.  If a data value that is given as
part of those instructions is the default value, then it should be
retained as part of the configuration, but if it is not explicitly given,
then the value is not considered to be part of configuration.
    
</p>
<p>
Another choice is to trim values that are identical to the default
values, implicitly removing them from the configuration database.
The act of setting a leaf to it&#039;s default value effectively deletes
that leaf.
    
</p>
<p>
The device could also choose to report all default values, regardless
of whether they were explicitly set.  This choice eases the work of
a client that needs default values, but may significantly increase the
size of the configuration data.
    
</p>
<p>
These choices reflect the default handling schemes of widely deployed
networking devices and supporting them allows YANG to reduce
implementation and deployment costs of YANG-based models.
    
</p>
<p>
When the client retrieves data from the device, it must be prepared to
handle the absence of leaf nodes with the default value, since the
server is not required to send such leaf elements.  This permits the
device to implement either of the first two default handling schemes
given above.
    
</p>
<p>
Regardless of the implementation choice, the device can support the
&quot;with&#8209;defaults&quot; capability (<a class='info' href='#RFCWITHDEFAULTS'>[RFCWITHDEFAULTS]<span> (</span><span class='info'>Bierman, A. and B. Lengyel, &ldquo;With-defaults capability for NETCONF,&rdquo; .</span><span>)</span></a>) and give the client the
ability to select the desired handling of default values.
    
</p>
<p>
When evaluating the XPath expressions for constraints like &quot;must&quot; and
&quot;when&quot;, the evaluation context for the expressions will include any
appropriate default values, so the modeler can depend on consistent
behavior from all devices.
    
</p>
<a name="anchor29"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.2"></a><h3>4.2.&nbsp;
Compliance</h3>

<p>
In developing good data models, there are many conflicting interests
the data modeler must keep in mind.  Modelers need to be aware of five
issues with models and devices:
    
</p>
<p>
 </p>
<ul class="text">
<li>
usefulness
 
</li>
<li>
compliance
 
</li>
<li>
flexibility
 
</li>
<li>
extensibility
 
</li>
<li>
deviations
 
</li>
</ul><p>

</p>
<p>
For a model to be interesting, it must be useful, solving a problem in
a more direct or more powerful way than can be accomplished without
the model.  The model should maximize the usefulness of the model
with in the problem domain.
    
</p>
<p>
Modelers should build models that maximize the number of devices that
can faithfully implement the model.  If the model is drawn too
narrowly, or includes too many assumptions about the device, then the
difficulty and cost of accurately implementing the model will lead to
low quality implementations, interoperability issues, and will reduce
the value of the model.
    
</p>
<p>
Modelers can use the &quot;feature&quot; statement in their models to give the
device some flexibility by partitioning their model and allowing the
device to indicate which portions of the model are implemented on the
device.  For example, if the model includes some a &quot;logging&quot; feature , a
device with no storage facilities for the log can tell the client that
it does not support this feature of the model.
    
</p>
<p>
Models can be extended via the &quot;augment&quot; statement, and the modeler
should consider how their model is likely to be extended.  These
augmentations can be defined by vendors, applications, or standards
bodies.
    
</p>
<p>
Deviations are a means of allowing the devices to indicate where its
implementation is not in full compliance with the model.  For example,
once a model is published, an implementer may decide to make a
particular node configurable, where the standard model
describes it as state data.  The implementation reports the value
normally and may declare a deviation that this device behaves in a
different manner than the standard.  Applications capable of
discovering this deviation can make allowances, but applications that
do not discover the deviation can continue treating the implementation
as if it were compliant.
    
</p>
<p>
Rarely, implementations may make decisions that prevent compliance
with the standard.  Such occasions are regrettable, but they remain a
part of reality, and modelers and application writers ignore them at
their own risk.  An implementation that emits an integer leaf as
&quot;cow&quot; would be difficult to manage, but applications should expect to
encounter such misbehaving devices in the field.
    
</p>
<p>
Despite this, both client and server should view the YANG module as a
contract, with both sides agreeing to abide by the terms.  The modeler
should be explicit about the terms of such a contract, and both client
and server implementations should strive to faithfully and accurately
implement the data model described in the YANG module.
    
</p>
<a name="anchor30"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.3"></a><h3>4.3.&nbsp;
Data Distinctions</h3>

<p>
The distinction between configuration data, operational state data,
and statistics is important to understand for data model writers and
people who plan to extend the NETCONF protocol. This section first
discusses some background and then provides a definition and some
examples.
    
</p>
<a name="anchor31"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.3.1"></a><h3>4.3.1.&nbsp;
Background</h3>

<p>
During the IAB NM workshop, operators did formulate the following two
requirements:
    
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
 2.  It is necessary to make a clear distinction between
     configuration data, data that describes operational state
     and statistics.  Some devices make it very hard to determine
     which parameters were administratively configured and which
     were obtained via other mechanisms such as routing
     protocols.

 3.  It is required to be able to fetch separately configuration
     data, operational state data, and statistics from devices,
     and to be able to compare these between devices.
</pre></div>
<p>
The NETCONF protocol defined in RFC 4741 distinguishes two types
of data, namely configuration data and state data:
    
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
   Configuration data is the set of writable data that is
   required to transform a system from its initial default state
   into its current state.

   State data is the additional data on a system that is not
   configuration data such as read-only status information and
   collected statistics.
</pre></div>
<p>
NETCONF does not follow the distinction formulated by the operators
between configuration data, operational state data, and statistical
data, since it considers state data to include both statistics and
operational state data.
    
</p>
<a name="anchor32"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.3.2"></a><h3>4.3.2.&nbsp;
Definitions</h3>

<p>
Below is a definition for configuration data, operational state data,
and statistical data. The definition borrows from previous work.
    
</p>
<p>
 </p>
<ul class="text">
<li>
Configuration data is the set of writable data that is required to
transform a system from its initial default state into its current
state. <a class='info' href='#RFC4741'>[RFC4741]<span> (</span><span class='info'>Enns, R., &ldquo;NETCONF Configuration Protocol,&rdquo; December&nbsp;2006.</span><span>)</span></a>
 
</li>
<li>
Operational state data is a set of data that has been obtained by
the system at runtime and influences the system&#039;s behaviour similar
to configuration data. In contrast to configuration data,
operational state is transient and modified by interactions with
internal components or other systems via specialized protocols.
 
</li>
<li>
Statistical data is the set of read-only data created by a system
itself. It describes the performance of the system and its
components.
 
</li>
</ul><p>

</p>
<p>
The following examples help to clarify the difference between
configuration data, operational state data and statistical data.
    
</p>
<a name="anchor33"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.3.2.1"></a><h3>4.3.2.1.&nbsp;
Example 1: IP Routing Table</h3>

<p>
IP routing tables can contain entries that are statically configured
(configuration data) as well as entries obtained from routing
protocols such as OSPF (operational state data). In addition, a
routing engine might collect statistics like how often a particular
routing table entry has been used.
    
</p>
<a name="anchor34"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.3.2.2"></a><h3>4.3.2.2.&nbsp;
Example 2: Interfaces</h3>

<p>
Network interfaces usually come with a large number of attributes
that are specific to the interface type and in some cases specific to
the cable plugged into an interface. Examples are the maximum
transmission unit of an interface or the speed detected by an Ethernet
interface.
    
</p>
<p>
In many deployments, systems use the interface attributes detected
when an interface is initialized. As such, these attributes constitute
operational state. However, there are usually provisions to overwrite
the discovered attributes with static configuration data, like for
example configuring the interface MTU to use a specific value or
forcing an Ethernet interface to run at a given speed.
    
</p>
<p>
The system will record statistics (counters) measuring the number of
packets, bytes, and errors received and transmitted on each interface.
    
</p>
<a name="anchor35"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.3.2.3"></a><h3>4.3.2.3.&nbsp;
Example 3: Account Information</h3>

<p>
Systems usually maintain static configuration information about the
accounts on the system. In addition, systems can obtain information
about accounts from other sources (e.g. LDAP, NIS) dynamically,
leading to operational state data. Information about account usage are
examples of statistic data.
    
</p>
<p>
Note that configuration data supplied to a system in order to create a
new account might be supplemented with additional configuration
information determined by the system when the account is being created
(such as a unique account id). Even though the system might create
such information, it usually becomes part of the static configuration
of the system since this data is not transient.
    
</p>
<a name="anchor36"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.3.3"></a><h3>4.3.3.&nbsp;
Implications</h3>

<p>
The primary focus of YANG is configuration data.  There is no single
mechanism defined for the separation of operational state data and
statistics since NETCONF treats them both as state data.  This section
describes several different options for addressing this issue.
    
</p>
<a name="anchor37"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.3.3.1"></a><h3>4.3.3.1.&nbsp;
Data Models</h3>

<p>
The first option is to have data models that explicitly
differentiate between configuration data and operational state data.
This leads to duplication of data structures and might not scale well
from a modeling perspective.
    
</p>
<p>
For example, the configured duplex value and the operational duplex
value would be distinct leafs in the data model.
    
</p>
<a name="anchor38"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.3.3.2"></a><h3>4.3.3.2.&nbsp;
Additional Operations to Retrieve Operational State</h3>

<p>
The NETCONF protocol can be extended with new protocol operations that
specifically allow the retrieval of all operational state, e.g. by
introducing a &lt;get&#8209;ops&gt; operation (and perhaps also a &lt;get&#8209;stats&gt;
operation).
    
</p>
<a name="anchor39"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.3.3.3"></a><h3>4.3.3.3.&nbsp;
Introduction of an Operational State Datastore</h3>

<p>
Another option could be to introduce a new &quot;configuration&quot; data store
that represents the operational state. A &lt;get&#8209;config&gt; operation on the
&lt;operational&gt; data store would then return the operational state
determining the behaviour of the box instead of its static and
explicit configuration state.
    
</p>
<a name="anchor40"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5"></a><h3>5.&nbsp;
Security Considerations</h3>

<p>
This document discusses an architecture for network management
using NETCONF and YANG. It has no security impact on the Internet.
    
</p>
<a name="anchor41"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6"></a><h3>6.&nbsp;
IANA Considerations</h3>

<p>
This document has no actions for IANA.
    
</p>
<a name="rfc.references1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>7.&nbsp;Normative References</h3>
<table width="99%" border="0">
<tr><td class="author-text" valign="top"><a name="RFC3535">[RFC3535]</a></td>
<td class="author-text">Schoenwaelder, J., &ldquo;<a href="http://tools.ietf.org/html/rfc3535">Overview of the 2002 IAB Network Management Workshop</a>,&rdquo; RFC&nbsp;3535, May&nbsp;2003 (<a href="ftp://ftp.rfc-editor.org/in-notes/rfc3535.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4741">[RFC4741]</a></td>
<td class="author-text">Enns, R., &ldquo;<a href="http://tools.ietf.org/html/rfc4741">NETCONF Configuration Protocol</a>,&rdquo; RFC&nbsp;4741, December&nbsp;2006 (<a href="ftp://ftp.isi.edu/in-notes/rfc4741.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4742">[RFC4742]</a></td>
<td class="author-text">Wasserman, M. and T. Goddard, &ldquo;<a href="http://tools.ietf.org/html/rfc4742">Using the NETCONF Configuration Protocol over Secure SHell (SSH)</a>,&rdquo; RFC&nbsp;4742, December&nbsp;2006 (<a href="http://www.rfc-editor.org/rfc/rfc4742.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4743">[RFC4743]</a></td>
<td class="author-text">Goddard, T., &ldquo;<a href="http://tools.ietf.org/html/rfc4743">Using NETCONF over the Simple Object Access Protocol (SOAP)</a>,&rdquo; RFC&nbsp;4743, December&nbsp;2006 (<a href="http://www.rfc-editor.org/rfc/rfc4743.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4744">[RFC4744]</a></td>
<td class="author-text">Lear, E. and K. Crozier, &ldquo;<a href="http://tools.ietf.org/html/rfc4744">Using the NETCONF Protocol over the Blocks Extensible Exchange Protocol (BEEP)</a>,&rdquo; RFC&nbsp;4744, December&nbsp;2006 (<a href="http://www.rfc-editor.org/rfc/rfc4744.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC5277">[RFC5277]</a></td>
<td class="author-text">Chisholm, S. and H. Trevino, &ldquo;<a href="http://tools.ietf.org/html/rfc5277">NETCONF Event Notifications</a>,&rdquo; RFC&nbsp;5277, July&nbsp;2008 (<a href="http://www.rfc-editor.org/rfc/rfc5277.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC5539">[RFC5539]</a></td>
<td class="author-text">Badra, M., &ldquo;<a href="http://tools.ietf.org/html/rfc5539">NETCONF over Transport Layer Security (TLS)</a>,&rdquo; RFC&nbsp;5539, May&nbsp;2009 (<a href="http://www.rfc-editor.org/rfc/rfc5539.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFCWITHDEFAULTS">[RFCWITHDEFAULTS]</a></td>
<td class="author-text">Bierman, A. and B. Lengyel, &ldquo;<a href="http://www.ietf.org/internet-drafts/draft-ietf-netconf-with-defaults-09.txt.txt">With-defaults capability for NETCONF</a>,&rdquo; draft-ietf-netconf-with-defaults-09.txt (work in progress).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFCYANG">[RFCYANG]</a></td>
<td class="author-text">Bjorklund, M., Ed., &ldquo;<a href="http://www.ietf.org/internet-drafts/draft-ietf-netmod-yang-13.txt">YANG - A data modeling language for the Network Configuration Protocol (NETCONF)</a>,&rdquo; draft-ietf-netmod-yang-13 (work in progress).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFCYANGDSDL">[RFCYANGDSDL]</a></td>
<td class="author-text">Lhotka, L., Mahy, R., and S. Chishom, &ldquo;<a href="http://www.ietf.org/internet-drafts/draft-ietf-netmod-dsdl-map-05.txt">Mapping YANG to Document Schema Definition Languages and Validating NETCONF Content</a>,&rdquo; draft-ietf-netmod-dsdl-map-05 (work in progress).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFCYANGTYPES">[RFCYANGTYPES]</a></td>
<td class="author-text">Schoenwaelder, J., &ldquo;<a href="http://www.ietf.org/internet-drafts/draft-ietf-netmod-yang-types-09.txt.txt">Common YANG Data Types</a>,&rdquo; draft-ietf-netmod-yang-types-09.txt (work in progress).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFCYANGUSAGE">[RFCYANGUSAGE]</a></td>
<td class="author-text">Bierman, A., &ldquo;<a href="http://www.ietf.org/internet-drafts/draft-ietf-netmod-yang-usage-05.txt.txt">Guidelines for Authors and Reviewers of YANG Data Model Documents</a>,&rdquo; draft-ietf-netmod-yang-usage-05.txt (work in progress).</td></tr>
</table>

<a name="rfc.authors"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>Author's Address</h3>
<table width="99%" border="0" cellpadding="0" cellspacing="0">
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Phil Shafer</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Juniper Networks</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:phil@juniper.net">phil@juniper.net</a></td></tr>
</table>
</body></html>
