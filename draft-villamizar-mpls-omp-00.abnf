LossComp = 10 * sqrt(Loss{Link});
LossComp = 3;
PathEquivLoad = 0;
Load = LinkEquivLoad{Link}
PathEquivLoad = Load;
PathSetMaxLoad = 0;
Load = PathEquivLoad{Path};
PathSetEquivLoad = Load;
PathSetEquivLoad = Load;
PathSetMaxLoad = Load;
Load = PathSetEquivLoad{PathSet};
TotalTraffic = 0;
TotalCapacity = 0;
Capacity = LinkCapacity{Link};
Capacity = LinkCapacity{Link};
Then = PathSetArray{PathSet,Util};
Elapsed = NOW - Then;
LoadComp = (Util - MIN_NEW_PATH)
                  / (MAX_NEW_PATH - MIN_NEW_PATH);
NewPaths = FindAlternatePath(PathSet);
MostCapacity = 0;
ExcessCapacity = LinkCapacity{Link}
                          * (1 - PathEquivLoad{NewPath});
Capacity = ExcessCapacity;
Capacity = ExcessCapacity;
MostCapacity = Capacity;
BestNewPath = NewPath;
Load = PathSetEquivLoad{PathSet};
NewPaths = SPF(Egress{PathSet});
PathExcessCapacity = ExcessCapacity(NewPath);
TotalExcessCapacity = PathExcessCapacity;
Excess = ExcessCapacity(Path);
TargetShare = NEW_LOAD_EPSILON;
TargetShare2 = HASH_SPACE_SIZE * NEW_LOAD_FRACTION
                (PathExcessCapacity / TotalExcessCapacity);
TargetShare = TargetShare2;
TargetIncr = NEW_MOVE_EPSILON;
TargetIncr2 = HASH_SPACE_SIZE * NEW_MOVE_FRACTION
              (PathExcessCapacity / TotalExcessCapacity);
TargetIncr = TargetIncr2;
TotalCapacity = 0;
Shares = TargetShare
                  * Capacity{Path} / TotalCapacity;
Shares = TrafficShare{PathSet,Path};
MaxLoad = PathSetMaxLoad{PathSet};
Elapsed = NOW - PathSetBelowMax{PathSet};
Traffic = 0;
ExcessCapacity = 0;
Excess = ExcessCapacity(Path);
TimeToDeletion = PATH_DEL_PERSIST
              * (1 + (Traffic / ExcessCapacity));
HighCost = 0;
Cost = PathLinkCosts(Path);
PathToDelete = Path;
HighCost = Cost;
LowShare = TrafficShare{PathSet,Path};
TargetShare = TrafficShare{PathSet,PathToDelete};
Shares = TargetShare
                      * Capacity{Path} / TotalCapacity;
Shares = 1;
Shares = TrafficShare{PathSet,PathToDelete};
