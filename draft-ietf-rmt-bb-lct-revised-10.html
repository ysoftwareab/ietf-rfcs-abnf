<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="en"><head><title>Layered Coding Transport (LCT) Building
    Block</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="description" content="Layered Coding Transport (LCT) Building
    Block">
<meta name="keywords" content="RFC, Request for Comments, I-D, Internet-Draft, XML, Extensible Markup Language">
<meta name="generator" content="xml2rfc v1.35 (http://xml.resource.org/)">
<meta name="viewport" content="width=600;" />
<style type='text/css'><!--
        body {
                font-family: verdana, charcoal, helvetica, arial, sans-serif;
                font-size: 85%;
		max-width: 40em; 
		color: #000; background-color: #FFF;
                margin: 2em;
        }
        h1, h2, h3, h4, h5, h6 {
                font-family: helvetica, monaco, "MS Sans Serif", arial, sans-serif;
                font-weight: bold; font-style: normal;
        }
        h1 { color: #900; background-color: transparent; text-align: right; }
        h3 { color: #333; background-color: transparent; }

        td.RFCbug {
                font-size: x-small; text-decoration: none;
                width: 30px; height: 30px; padding-top: 2px;
                text-align: justify; vertical-align: middle;
                background-color: #000;
        }
        td.RFCbug span.RFC {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: bold; color: #666;
        }
        td.RFCbug span.hotText {
                font-family: charcoal, monaco, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: normal; text-align: center; color: #FFF;
        }

        table.TOCbug { width: 30px; height: 15px; }
        td.TOCbug {
                text-align: center; width: 30px; height: 15px;
                color: #FFF; background-color: #900;
        }
        td.TOCbug a {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, sans-serif;
                font-weight: bold; font-size: x-small; text-decoration: none;
                color: #FFF; background-color: transparent;
        }

        td.header {
                font-family: arial, helvetica, sans-serif; font-size: x-small;
                vertical-align: top; width: 33%;
                color: #FFF; background-color: #666;
        }
        td.author { font-weight: bold; font-size: x-small; margin-left: 4em; }
        td.author-text { font-size: x-small; }

        /* info code from SantaKlauss at http://www.madaboutstyle.com/tooltip2.html */
        a.info {
                /* This is the key. */
                position: relative;
                z-index: 24;
                text-decoration: none;
        }
        a.info:hover {
                z-index: 25;
                color: #FFF; background-color: #900;
        }
        a.info span { display: none; }
        a.info:hover span.info {
                /* The span will display just on :hover state. */
                display: block;
                position: absolute;
                font-size: smaller;
                top: 2em; left: -5em; width: 15em;
                padding: 2px; border: 1px solid #333;
                color: #900; background-color: #EEE;
                text-align: left;
        }

        a { font-weight: bold; }
        a:link    { color: #900; background-color: transparent; }
        a:visited { color: #633; background-color: transparent; }
        a:active  { color: #633; background-color: transparent; }

        p { margin-left: 2em; margin-right: 2em; }
        p.copyright { font-size: x-small; }
        p.toc { font-size: 85%;
		max-width: 40em; 
		font-weight: bold; margin-left: 3em; }
        table.toc { margin: 0 0 0 3em; padding: 0; border: 0; vertical-align: text-top; }
        td.toc { font-size: 85%;
		max-width: 40em; 
		font-weight: bold; vertical-align: text-top; }

        ol.text { margin-left: 2em; margin-right: 2em; }
        ul.text { margin-left: 2em; margin-right: 2em; }
        li      { margin-left: 3em; }

        /* RFC-2629 <spanx>s and <artwork>s. */
        em     { font-style: italic; }
        strong { font-weight: bold; }
        dfn    { font-weight: bold; font-style: normal; }
        cite   { font-weight: normal; font-style: normal; }
        tt     { color: #036; }
        tt, pre, pre dfn, pre em, pre cite, pre span {
                font-family: "Courier New", Courier, monospace; font-size: small;
        }
        pre {
                text-align: left; padding: 4px;
                color: #000; background-color: #CCC;
        }
        pre dfn  { color: #900; }
        pre em   { color: #66F; background-color: #FFC; font-weight: normal; }
        pre .key { color: #33C; font-weight: bold; }
        pre .id  { color: #900; }
        pre .str { color: #000; background-color: #CFF; }
        pre .val { color: #066; }
        pre .rep { color: #909; }
        pre .oth { color: #000; background-color: #FCF; }
        pre .err { background-color: #FCC; }

        /* RFC-2629 <texttable>s. */
        table.all, table.full, table.headers, table.none {
                font-size: 85%;
		max-width: 40em; 
		text-align: center; border-width: 2px;
                vertical-align: top; border-collapse: collapse;
        }
        table.all, table.full { border-style: solid; border-color: black; }
        table.headers, table.none { border-style: none; }
        th {
                font-weight: bold; border-color: black;
                border-width: 2px 2px 3px 2px;
        }
        table.all th, table.full th { border-style: solid; }
        table.headers th { border-style: none none solid none; }
        table.none th { border-style: none; }
        table.all td {
                border-style: solid; border-color: #333;
                border-width: 1px 2px;
        }
        table.full td, table.headers td, table.none td { border-style: none; }

        hr { height: 1px; }
        hr.insert {
                width: 80%; border-style: none; border-width: 0;
                color: #CCC; background-color: #CCC;
        }
--></style>
</head>
<body>
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<table summary="layout" width="66%" border="0" cellpadding="0" cellspacing="0"><tr><td><table summary="layout" width="100%" border="0" cellpadding="2" cellspacing="1">
<tr><td class="header">Reliable Multicast Transport (RMT)</td><td class="header"> Luby</td></tr>
<tr><td class="header">Working Group</td><td class="header"> Watson</td></tr>
<tr><td class="header">Internet-Draft</td><td class="header"> Vicisano</td></tr>
<tr><td class="header">Obsoletes: <a href='http://tools.ietf.org/html/rfc3451'>3451</a> (if&nbsp;approved)</td><td class="header">Qualcomm Inc.</td></tr>
<tr><td class="header">Intended status: Standards Track</td><td class="header">July 13, 2009</td></tr>
<tr><td class="header">Expires: January 14, 2010</td><td class="header">&nbsp;</td></tr>
</table></td></tr></table>
<h1><br />Layered Coding Transport (LCT) Building
    Block<br />draft-ietf-rmt-bb-lct-revised-10</h1>

<h3>Status of this Memo</h3>
<p>
This Internet-Draft is submitted to IETF in full
conformance with the provisions of BCP&nbsp;78 and BCP&nbsp;79.</p>
<p>
Internet-Drafts are working documents of the Internet Engineering
Task Force (IETF), its areas, and its working groups.
Note that other groups may also distribute working documents as
Internet-Drafts.</p>
<p>
Internet-Drafts are draft documents valid for a maximum of six months
and may be updated, replaced, or obsoleted by other documents at any time.
It is inappropriate to use Internet-Drafts as reference material or to cite
them other than as &ldquo;work in progress.&rdquo;</p>
<p>
The list of current Internet-Drafts can be accessed at
<a href='http://www.ietf.org/ietf/1id-abstracts.txt'>http://www.ietf.org/ietf/1id-abstracts.txt</a>.</p>
<p>
The list of Internet-Draft Shadow Directories can be accessed at
<a href='http://www.ietf.org/shadow.html'>http://www.ietf.org/shadow.html</a>.</p>
<p>
This Internet-Draft will expire on January 14, 2010.</p>

<h3>Copyright Notice</h3>
<p>
Copyright (c) 2009 IETF Trust and the persons identified as the
document authors.  All rights reserved.</p>
<p>
This document is subject to BCP 78 and the IETF Trust's Legal
Provisions Relating to IETF Documents in effect on the date of
publication of this document (http://trustee.ietf.org/license-info).
Please review these documents carefully, as they describe your
rights and restrictions with respect to this document.</p>

<h3>Abstract</h3>

<p>The Layered Coding Transport (LCT) Bulding Block provides transport
      level support for reliable content delivery and stream delivery
      protocols. LCT is specifically designed to support protocols using IP
      multicast, but also provides support to protocols that use unicast. LCT
      is compatible with congestion control that provides multiple rate
      delivery to receivers and is also compatible with coding techniques that
      provide reliable delivery of content. This document obsoletes RFC
      3451.
</p><a name="toc"></a><br /><hr />
<h3>Table of Contents</h3>
<p class="toc">
<a href="#anchor1">1.</a>&nbsp;
Introduction<br />
<a href="#anchor2">2.</a>&nbsp;
Rationale<br />
<a href="#anchor3">3.</a>&nbsp;
Functionality<br />
<a href="#applicability">4.</a>&nbsp;
Applicability<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor4">4.1.</a>&nbsp;
Environmental Requirements and Considerations<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor5">4.2.</a>&nbsp;
Delivery service models<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor6">4.3.</a>&nbsp;
Congestion Control<br />
<a href="#anchor7">5.</a>&nbsp;
Packet Header Fields<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor8">5.1.</a>&nbsp;
LCT header format<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#HeaderExtensions">5.2.</a>&nbsp;
Header-Extension Fields<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor9">5.2.1.</a>&nbsp;
General<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor10">5.2.2.</a>&nbsp;
EXT_TIME Header Extension<br />
<a href="#anchor11">6.</a>&nbsp;
Operations<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#SenderOperation">6.1.</a>&nbsp;
Sender Operation<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#receiver">6.2.</a>&nbsp;
Receiver Operation<br />
<a href="#otherbb">7.</a>&nbsp;
Requirements from Other Building Blocks<br />
<a href="#anchor12">8.</a>&nbsp;
Security Considerations<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor13">8.1.</a>&nbsp;
Session and object multiplexing and termination<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor14">8.2.</a>&nbsp;
Time synchronization<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor15">8.3.</a>&nbsp;
Data transport<br />
<a href="#anchor16">9.</a>&nbsp;
IANA Considerations<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor17">9.1.</a>&nbsp;
Namespace declaration for LCT Header Extension Types<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#IANAValues">9.2.</a>&nbsp;
LCT Header Extension Type registration<br />
<a href="#anchor18">10.</a>&nbsp;
Acknowledgments<br />
<a href="#changes">11.</a>&nbsp;
Changes from RFC 3451<br />
<a href="#rfc.references1">12.</a>&nbsp;
References<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#rfc.references1">12.1.</a>&nbsp;
Normative References<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#rfc.references2">12.2.</a>&nbsp;
Informative References<br />
<a href="#rfc.authors">&#167;</a>&nbsp;
Authors' Addresses<br />
</p>
<br clear="all" />

<a name="anchor1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1"></a><h3>1.&nbsp;
Introduction</h3>

<p>Layered Coding Transport (LCT) provides transport level support for
      reliable content delivery and stream delivery protocols. Layered Coding
      Transport is specifically designed to support protocols using IP
      multicast, but also provides support to protocols that use unicast.
      Layered Coding Transport is compatible with congestion control that
      provides multiple rate delivery to receivers and is also compatible with
      coding techniques that provide reliable delivery of content.
</p>
<p>This document describes a building block as defined in <a class='info' href='#RFC3048'>[RFC3048]<span> (</span><span class='info'>Whetten, B., Vicisano, L., Kermode, R., Handley, M., Floyd, S., and M. Luby, &ldquo;Reliable Multicast Transport Building Blocks for One-to-Many Bulk-Data Transfer,&rdquo; January&nbsp;2001.</span><span>)</span></a>. This document is a product of the IETF RMT WG
      and follows the general guidelines provided in <a class='info' href='#RFC3269'>[RFC3269]<span> (</span><span class='info'>Kermode, R. and L. Vicisano, &ldquo;Author Guidelines for Reliable Multicast Transport (RMT) Building Blocks and Protocol Instantiation documents,&rdquo; April&nbsp;2002.</span><span>)</span></a>.
</p>
<p><a class='info' href='#RFC3451'>[RFC3451]<span> (</span><span class='info'>Luby, M., Gemmell, J., Vicisano, L., Rizzo, L., Handley, M., and J. Crowcroft, &ldquo;Layered Coding Transport (LCT) Building Block,&rdquo; December&nbsp;2002.</span><span>)</span></a>, which was published in the
      "Experimental" category and which is obsoleted by this document,
      contained a previous version of the protocol.
</p>
<p>This Proposed Standard specification is thus based on and backwards
      compatible with the protocol defined in <a class='info' href='#RFC3451'>[RFC3451]<span> (</span><span class='info'>Luby, M., Gemmell, J., Vicisano, L., Rizzo, L., Handley, M., and J. Crowcroft, &ldquo;Layered Coding Transport (LCT) Building Block,&rdquo; December&nbsp;2002.</span><span>)</span></a>
      updated according to accumulated experience and growing protocol
      maturity since its original publication. Said experience applies both to
      this specification itself and to congestion control strategies related
      to the use of this specification.
</p>
<p>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
      "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
      document are to be interpreted as described in <a class='info' href='#RFC2119'>[RFC2119]<span> (</span><span class='info'>Bradner, S., &ldquo;Key words for use in RFCs to Indicate Requirement Levels,&rdquo; March&nbsp;1997.</span><span>)</span></a>.
</p>
<a name="anchor2"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2"></a><h3>2.&nbsp;
Rationale</h3>

<p>LCT provides transport level support for massively scalable protocols
      using the IP multicast network service. The support that LCT provides is
      common to a variety of very important applications, including reliable
      content delivery and streaming applications.
</p>
<p>An LCT session comprises multiple channels originating at a single
      sender that are used for some period of time to carry packets pertaining
      to the transmission of one or more objects that can be of interest to
      receivers. The logic behind defining a session as originating from a
      single sender is that this is the right granularity to regulate packet
      traffic via congestion control. One rationale for using multiple
      channels within the same session is that there are massively scalable
      congestion control protocols that use multiple channels per session.
      These congestion control protocols are considered to be layered because
      a receiver joins and leaves channels in a layered order during its
      participation in the session. The use of layered channels is also useful
      for streaming applications.
</p>
<p>There are coding techniques that provide massively scalable
      reliability and asynchronous delivery which are compatible with both
      layered congestion control and with LCT. When all are combined the
      result is a massively scalable reliable asynchronous content delivery
      protocol that is network friendly. LCT also provides functionality that
      can be used for other applications as well, e.g., layered streaming
      applications.
</p>
<p>LCT avoids providing functionality that is not massively scalable.
      For example, LCT does not provide any mechanisms for sending information
      from receivers to senders, although this does not rule out protocols
      that both use LCT and do require sending information from receivers to
      senders.
</p>
<p>LCT includes general support for congestion control that must be
      used. It does not, however, specify which congestion control should be
      used. The rationale for this is that congestion control must be provided
      by any protocol that is network friendly, and yet the different
      applications that can use LCT will not have the same requirements for
      congestion control. For example, a content delivery protocol may strive
      to use all available bandwidth between receivers and the sender. It
      must, therefore, drastically back off its rate when there is competing
      traffic. On the other hand, a streaming delivery protocol may strive to
      maintain a constant rate instead of trying to use all available
      bandwidth, and it may not back off its rate as fast when there is
      competing traffic.
</p>
<p>Beyond support for congestion control, LCT provides a number of
      fields and supports functionality commonly required by many protocols.
      For example, LCT provides a Transmission Session ID that can be used to
      identify which session each received packet belongs to. This is
      important because a receiver may be joined to many sessions
      concurrently, and thus it is very useful to be able to demultiplex
      packets as they arrive according to which session they belong to. As
      another example, LCT provides optional support for identifying which
      object each packet is carrying information about.
</p>
<a name="anchor3"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3"></a><h3>3.&nbsp;
Functionality</h3>

<p>An LCT session consists of a set of logically grouped LCT channels
      associated with a single sender carrying packets with LCT headers for
      one or more objects. An LCT channel is defined by the combination of a
      sender and an address associated with the channel by the sender. A
      receiver joins a channel to start receiving the data packets sent to the
      channel by the sender, and a receiver leaves a channel to stop receiving
      data packets from the channel.
</p>
<p>LCT is meant to be combined with other building blocks so that the
      resulting overall protocol is massively scalable. Scalability refers to
      the behavior of the protocol in relation to the number of receivers and
      network paths, their heterogeneity, and the ability to accommodate
      dynamically variable sets of receivers. Scalability limitations can come
      from memory or processing requirements, or from the amount of feedback
      control and redundant data packet traffic generated by the protocol. In
      turn, such limitations may be a consequence of the features that a
      complete reliable content delivery or stream delivery protocol is
      expected to provide.
</p>
<p>The LCT header provides a number of fields that are useful for
      conveying in-band session information to receivers. One of the required
      fields is the Transmission Session ID (TSI), which allows the receiver
      of a session to uniquely identify received packets as part of the
      session. Another required field is the Congestion Control Information
      (CCI), which allows the receiver to perform the required congestion
      control on the packets received within the session. Other LCT fields
      provide optional but often very useful additional information for the
      session. For example, the Transport Object Identifier (TOI) identifies
      which object the packet contains data for and flags are included for
      indicating the close of the session and the close of sending packets for
      an object. Header extensions can carry additional fields that for
      example can be used for packet authentication or to convey various kinds
      of timing information: the Sender Current Time (SCT) conveys the time
      when the packet was sent from the sender to the receiver, the Expected
      Residual Time (ERT) conveys the amount of time the session or
      transmission object will be continued for, and Session Last Change
      conveys the time when objects have been added, modified or removed from
      the session.
</p>
<p>LCT provides support for congestion control. Congestion control MUST
      be used that conforms to <a class='info' href='#RFC2357'>[RFC2357]<span> (</span><span class='info'>Mankin, A., Romanov, A., Bradner, S., and V. Paxson, &ldquo;IETF Criteria for Evaluating Reliable Multicast Transport and Application Protocols,&rdquo; June&nbsp;1998.</span><span>)</span></a> between
      receivers and the sender for each LCT session. Congestion control refers
      to the ability to adapt throughput to the available bandwidth on the
      path from the sender to a receiver, and to share bandwidth fairly with
      competing flows such as TCP. Thus, the total flow of packets flowing to
      each receiver participating in an LCT session MUST NOT compete unfairly
      with existing flow adaptive protocols such as TCP.
</p>
<p>A multiple rate or a single rate congestion control protocol can be
      used with LCT. For multiple rate protocols, a session typically consists
      of more than one channel and the sender sends packets to the channels in
      the session at rates that do not depend on the receivers. Each receiver
      adjusts its reception rate during its participation in the session by
      joining and leaving channels dynamically depending on the available
      bandwidth to the sender independent of all other receivers. Thus, for
      multiple rate protocols, the reception rate of each receiver may vary
      dynamically independent of the other receivers.
</p>
<p>For single rate protocols, a session typically consists of one
      channel and the sender sends packets to the channel at variable rates
      over time depending on feedback from receivers. Each receiver remains
      joined to the channel during its participation in the session. Thus, for
      single rate protocols, the reception rate of each receiver may vary
      dynamically but in coordination with all receivers.
</p>
<p>Generally, a multiple rate protocol is preferable to a single rate
      protocol in a heterogeneous receiver environment, since generally it
      more easily achieves scalability to many receivers and provides higher
      throughput to each individual receiver. Use of the multiple rate
      congestion control scheme defined in <a class='info' href='#RFC3738'>[RFC3738]<span> (</span><span class='info'>Luby, M. and V. Goyal, &ldquo;Wave and Equation Based Rate Control (WEBRC) Building Block,&rdquo; April&nbsp;2004.</span><span>)</span></a> is
      RECOMMENDED. Alternative multiple rate congestion control protocols are
      described in <a class='info' href='#VIC1998'>[VIC1998]<span> (</span><span class='info'>Vicisano, L., Rizzo, L., and J. Crowcroft, &ldquo;TCP-like Congestion Control for Layered Multicast Data           Transfer,&rdquo; March&nbsp;1998.</span><span>)</span></a> and<a class='info' href='#BYE2000'>[BYE2000]<span> (</span><span class='info'>Byers, J., Frumin, M., Horn, G., Luby, M., Mitzenmacher, M., Rotter, A., and W. Shaver, &ldquo;FLID-DL: Congestion Control for Layered Multicast,&rdquo; November&nbsp;2000.</span><span>)</span></a>. A possible single rate congestion control protocol is described
      in <a class='info' href='#RIZ2000'>[RIZ2000]<span> (</span><span class='info'>Rizzo, L., &ldquo;PGMCC: A TCP-friendly single-rate multicast congestion           control scheme,&rdquo; August&nbsp;2000.</span><span>)</span></a>.
</p>
<p>Layered coding refers to the ability to produce a coded stream of
      packets that can be partitioned into an ordered set of layers. The
      coding is meant to provide some form of reliability, and the layering is
      meant to allow the receiver experience (in terms of quality of playout,
      or overall transfer speed) to vary in a predictable way depending on how
      many consecutive layers of packets the receiver is receiving.
</p>
<p>The concept of layered coding was first introduced with reference to
      audio and video streams. For example, the information associated with a
      TV broadcast could be partitioned into three layers, corresponding to
      black and white, color, and HDTV quality. Receivers can experience
      different quality without the need for the sender to replicate
      information in the different layers.
</p>
<p>The concept of layered coding can be naturally extended to reliable
      content delivery protocols when Forward Error Correction (FEC)
      techniques are used for coding the data stream. Descriptions of this can
      be found in <a class='info' href='#RIZ1997a'>[RIZ1997a]<span> (</span><span class='info'>Rizzo, L., &ldquo;Effective Erasure Codes for Reliable Computer Communication           Protocols,&rdquo; April&nbsp;1997.</span><span>)</span></a>, <a class='info' href='#RIZ1997b'>[RIZ1997b]<span> (</span><span class='info'>Rizzo, L. and L. Vicisano, &ldquo;Reliable Multicast Data Distribution protocol based on           software FEC techniques,&rdquo; June&nbsp;1997.</span><span>)</span></a>, <a class='info' href='#GEM2000'>[GEM2000]<span> (</span><span class='info'>Gemmell, J., Schooler, E., and J. Gray, &ldquo;Fcast Multicast File Distribution,&rdquo; January&nbsp;2000.</span><span>)</span></a>, <a class='info' href='#VIC1998'>[VIC1998]<span> (</span><span class='info'>Vicisano, L., Rizzo, L., and J. Crowcroft, &ldquo;TCP-like Congestion Control for Layered Multicast Data           Transfer,&rdquo; March&nbsp;1998.</span><span>)</span></a> and <a class='info' href='#BYE1998'>[BYE1998]<span> (</span><span class='info'>Byers, J., Luby, M., Mitzenmacher, M., and A. Rege, &ldquo;Fountain Approach to Reliable Distribution of Bulk           Data,&rdquo; September&nbsp;1998.</span><span>)</span></a>. By using
      FEC, the data stream is transformed in such a way that reconstruction of
      a data object does not depend on the reception of specific data packets,
      but only on the number of different packets received. As a result, by
      increasing the number of layers a receiver is receiving from, the
      receiver can reduce the transfer time accordingly. Using FEC to provide
      reliability can increase scalability dramatically in comparison to other
      methods for providing reliability. More details on the use of FEC for
      reliable content delivery can be found in <a class='info' href='#RFC3453'>[RFC3453]<span> (</span><span class='info'>Luby, M., Vicisano, L., Gemmell, J., Rizzo, L., Handley, M., and J. Crowcroft, &ldquo;The Use of Forward Error Correction (FEC) in Reliable Multicast,&rdquo; December&nbsp;2002.</span><span>)</span></a>.
</p>
<p>Reliable protocols aim at giving guarantees on the reliable delivery
      of data from the sender to the intended recipients. Guarantees vary from
      simple packet data integrity to reliable delivery of a precise copy of
      an object to all intended recipients. Several reliable content delivery
      protocols have been built on top of IP multicast using methods other
      than FEC, but scalability was not the primary design goal for many of
      them.
</p>
<p>Two of the key difficulties in scaling reliable content delivery
      using IP multicast are dealing with the amount of data that flows from
      receivers back to the sender, and the associated response (generally
      data retransmissions) from the sender. Protocols that avoid any such
      feedback, and minimize the amount of retransmissions, can be massively
      scalable. LCT can be used in conjunction with FEC codes or a layered
      codec to achieve reliability with little or no feedback.
</p>
<p>Protocol instantiations (PIs) MAY be built by combining the LCT
      framework with other components. A complete protocol instantiation that
      uses LCT MUST include a congestion control protocol that is compatible
      with LCT and that conforms to <a class='info' href='#RFC2357'>[RFC2357]<span> (</span><span class='info'>Mankin, A., Romanov, A., Bradner, S., and V. Paxson, &ldquo;IETF Criteria for Evaluating Reliable Multicast Transport and Application Protocols,&rdquo; June&nbsp;1998.</span><span>)</span></a>. A complete
      protocol instantiation that uses LCT MAY include a scalable reliability
      protocol that is compatible with LCT, it MAY include an session control
      protocol that is compatible with LCT, and it MAY include other protocols
      such as security protocols.
</p>
<a name="applicability"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4"></a><h3>4.&nbsp;
Applicability</h3>

<p>An LCT session comprises a logically related set of one or more LCT
      channels originating at a single sender. The channels are used for some
      period of time to carry packets containing LCT headers, and these
      headers pertain to the transmission of one or more objects that can be
      of interest to receivers.
</p>
<p>LCT is most applicable for delivery of objects or streams in a
      session of substantial length, i.e., objects or streams that range in
      aggregate length from hundreds of kilobytes to many gigabytes, and where
      the duration of the session is on the order of tens of seconds or
      more.
</p>
<p>As an example, an LCT session could be used to deliver a TV program
      using three LCT channels. Receiving packets from the first LCT channel
      could allow black and white reception. Receiving the first two LCT
      channels could also permit color reception. Receiving all three channels
      could allow HDTV quality reception. Objects in this example could
      correspond to individual TV programs being transmitted.
</p>
<p>As another example, a reliable LCT session could be used to reliably
      deliver hourly-updated weather maps (objects) using ten LCT channels at
      different rates, using FEC coding. A receiver may join and concurrently
      receive packets from subsets of these channels, until it has enough
      packets in total to recover the object, then leave the session (or
      remain connected listening for session description information only)
      until it is time to receive the next object. In this case, the quality
      metric is the time required to receive each object.
</p>
<p>Before joining a session, the receivers must obtain enough of the
      session description to start the session. This includes the relevant
      session parameters needed by a receiver to participate in the session,
      including all information relevant to congestion control. The session
      description is determined by the sender, and is typically communicated
      to the receivers out-of-band. In some cases, as described later, parts
      of the session description that are not required to initiate a session
      MAY be included in the LCT header or communicated to a receiver
      out-of-band after the receiver has joined the session.
</p>
<p>An encoder MAY be used to generate the data that is placed in the
      packet payload in order to provide reliability. A suitable decoder is
      used to reproduce the original information from the packet payload.
      There MAY be a reliability header that follows the LCT header if such an
      encoder and decoder is used. The reliability header helps to describe
      the encoding data carried in the payload of the packet. The format of
      the reliability header depends on the coding used, and this is
      negotiated out-of-band. As an example, one of the FEC headers described
      in <a class='info' href='#RFC5052'>[RFC5052]<span> (</span><span class='info'>Watson, M., Luby, M., and L. Vicisano, &ldquo;Forward Error Correction (FEC) Building Block,&rdquo; August&nbsp;2007.</span><span>)</span></a> could be used.
</p>
<p>For LCT, when multiple rate congestion control is used, congestion
      control is achieved by sending packets associated with a given session
      to several LCT channels. Individual receivers dynamically join one or
      more of these channels, according to the network congestion as seen by
      the receiver. LCT headers include an opaque field which MUST be used to
      convey congestion control information to the receivers. The actual
      congestion control scheme to use with LCT is negotiated out-of-band.
      Some examples of congestion control protocols that may be suitable for
      content delivery are described in <a class='info' href='#VIC1998'>[VIC1998]<span> (</span><span class='info'>Vicisano, L., Rizzo, L., and J. Crowcroft, &ldquo;TCP-like Congestion Control for Layered Multicast Data           Transfer,&rdquo; March&nbsp;1998.</span><span>)</span></a>, <a class='info' href='#BYE2000'>[BYE2000]<span> (</span><span class='info'>Byers, J., Frumin, M., Horn, G., Luby, M., Mitzenmacher, M., Rotter, A., and W. Shaver, &ldquo;FLID-DL: Congestion Control for Layered Multicast,&rdquo; November&nbsp;2000.</span><span>)</span></a>, and <a class='info' href='#RFC3738'>[RFC3738]<span> (</span><span class='info'>Luby, M. and V. Goyal, &ldquo;Wave and Equation Based Rate Control (WEBRC) Building Block,&rdquo; April&nbsp;2004.</span><span>)</span></a>. Other
      congestion controls may be suitable when LCT is used for a streaming
      application.
</p>
<p>This document does not specify and restrict the type of exchanges
      between LCT (or any protocol instantiation built on top of LCT) and an
      upper application. Some upper APIs may use an object-oriented approach,
      where the only possible unit of data exchanged between LCT (or any
      protocol instantiation built on top of LCT) and an application, either
      at a source or at a receiver, is an object. Other APIs may enable a
      sending or receiving application to exchange a subset of an object with
      LCT (or any PI built on top of LCT), or may even follow a streaming
      model. These considerations are outside the scope of this document.
</p>
<a name="anchor4"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.1"></a><h3>4.1.&nbsp;
Environmental Requirements and Considerations</h3>

<p>LCT is intended for congestion controlled delivery of objects and
        streams (both reliable content delivery and streaming of multimedia
        information).
</p>
<p>LCT can be used with both multicast and unicast delivery. LCT
        requires connectivity between a sender and receivers but does not
        require connectivity from receivers to a sender. LCT inherently works
        with all types of networks, including LANs, WANs, Intranets, the
        Internet, asymmetric networks, wireless networks, and satellite
        networks. Thus, the inherent raw scalability of LCT is unlimited.
        However, when other specific applications are built on top of LCT,
        then these applications by their very nature may limit scalability.
        For example, if an application requires receivers to retrieve out of
        band information in order to join a session, or an application allows
        receivers to send requests back to the sender to report reception
        statistics, then the scalability of the application is limited by the
        ability to send, receive, and process this additional data.
</p>
<p>LCT requires receivers to be able to uniquely identify and
        demultiplex packets associated with an LCT session. In particular,
        there MUST be a Transport Session Identifier (TSI) associated with
        each LCT session. The TSI is scoped by the IP address of the sender,
        and the IP address of the sender together with the TSI MUST uniquely
        identify the session. If the underlying transport is UDP as described
        in <a class='info' href='#RFC0768'>[RFC0768]<span> (</span><span class='info'>Postel, J., &ldquo;User Datagram Protocol,&rdquo; August&nbsp;1980.</span><span>)</span></a>, then the 16-bit UDP source port
        number MAY serve as the TSI for the session. The TSI value MUST be the
        same in all places it occurs within a packet. If there is no
        underlying TSI provided by the network, transport or any other layer,
        then the TSI MUST be included in the LCT header.
</p>
<p>LCT is presumed to be used with an underlying network or transport
        service that is a "best effort" service that does not guarantee packet
        reception or packet reception order, and which does not have any
        support for flow or congestion control. For example, the Any-Source
        Multicast (ASM) model of IP multicast as defined in <a class='info' href='#RFC1112'>[RFC1112]<span> (</span><span class='info'>Deering, S., &ldquo;Host extensions for IP multicasting,&rdquo; August&nbsp;1989.</span><span>)</span></a> is such a "best effort" network service.
        While the basic service provided by <a class='info' href='#RFC1112'>[RFC1112]<span> (</span><span class='info'>Deering, S., &ldquo;Host extensions for IP multicasting,&rdquo; August&nbsp;1989.</span><span>)</span></a> is
        largely scalable, providing congestion control or reliability should
        be done carefully to avoid severe scalability limitations, especially
        in the presence of heterogeneous sets of receivers.
</p>
<p>There are currently two models of multicast delivery, the
        Any-Source Multicast (ASM) model as defined in <a class='info' href='#RFC1112'>[RFC1112]<span> (</span><span class='info'>Deering, S., &ldquo;Host extensions for IP multicasting,&rdquo; August&nbsp;1989.</span><span>)</span></a> and the Source- Specific Multicast (SSM)
        model as defined in <a class='info' href='#RFC4607'>[RFC4607]<span> (</span><span class='info'>Holbrook, H. and B. Cain, &ldquo;Source-Specific Multicast for IP,&rdquo; August&nbsp;2006.</span><span>)</span></a>. LCT works with
        both multicast models, but in a slightly different way with somewhat
        different environmental concerns. When using ASM, a sender S sends
        packets to a multicast group G, and the LCT channel address consists
        of the pair (S,G), where S is the IP address of the sender and G is a
        multicast group address. When using SSM, a sender S sends packets to
        an SSM channel (S,G), and the LCT channel address coincides with the
        SSM channel address.
</p>
<p>A sender can locally allocate unique SSM channel addresses, and
        this makes allocation of LCT channel addresses easy with SSM. To
        allocate LCT channel addresses using ASM, the sender must uniquely
        chose the ASM multicast group address across the scope of the group,
        and this makes allocation of LCT channel addresses more difficult with
        ASM.
</p>
<p>LCT channels and SSM channels coincide, and thus the receiver will
        only receive packets sent to the requested LCT channel. With ASM, the
        receiver joins an LCT channel by joining a multicast group G, and all
        packets sent to G, regardless of the sender, may be received by the
        receiver. Thus, SSM has compelling security advantages over ASM for
        prevention of denial of service attacks. In either case, receivers
        SHOULD use packet authentication mechanisms to mitigate such attacks
        (See <a class='info' href='#receiver'>Section&nbsp;6.2<span> (</span><span class='info'>Receiver Operation</span><span>)</span></a> and <a class='info' href='#otherbb'>Section&nbsp;7<span> (</span><span class='info'>Requirements from Other Building Blocks</span><span>)</span></a>).
</p>
<p>Some networks are not amenable to some congestion control protocols
        that could be used with LCT. In particular, for a satellite or
        wireless network, there may be no mechanism for receivers to
        effectively reduce their reception rate since there may be a fixed
        transmission rate allocated to the session.
</p>
<p>LCT is compatible with both IPv4 and IPv6 as no part of the packet
        is IP version specific.
</p>
<a name="anchor5"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.2"></a><h3>4.2.&nbsp;
Delivery service models</h3>

<p>LCT can support several different delivery service models. Two
        examples are briefly described here.
</p>
<p></p>
<blockquote class="text"><dl>
<dt>Push service model</dt>
<dd>
</dd>
<dt></dt>
<dd><br />
 One way a push service model can be
            used for reliable content delivery is to deliver a series of
            objects. For example, a receiver could join the session and
            dynamically adapt the number of LCT channels the receiver is
            joined to until enough packets have been received to reconstruct
            an object. After reconstructing the object the receiver may stay
            in the session and wait for the transmission of the next
            object.
</dd>
<dt></dt>
<dd><br />
 The push model is particularly
            attractive in satellite networks and wireless networks. In these
            cases, a session may consist of one fixed rate LCT channel.
</dd>
<dt></dt>
<dd><br />
A push service model can be used for
            example for reliable delivery of a large object such as a 100 GB
            file. The sender could send a Session Description announcement to
            a control channel and receivers could monitor this channel and
            join a session whenever a Session Description of interest arrives.
            Upon receipt of the Session Description, each receiver could join
            the session to receive packets until enough packets have arrived
            to reconstruct the object, at which point the receiver could
            report back to the sender that its reception was completed
            successfully. The sender could decide to continue sending packets
            for the object to the session until all receivers have reported
            successful reconstruction or until some other condition has been
            satisfied.
</dd>
<dt></dt>
<dd><br />
 There are several features ALC
            provides to support the push model. For example, the sender can
            optionally include an Expected Residual Time (ERT) in the packet
            header extension that indicates the expected remaining time of
            packet transmission for either the single object carried in the
            session or for the object identified by the Transmission Object
            Identifier (TOI) if there are multiple objects carried in the
            session. This can be used by receivers to determine if there is
            enough time remaining in the session to successfully receive
            enough additional packets to recover the object. If for example
            there is not enough time, then the push application may have
            receivers report back to the sender to extend the transmission of
            packets for the object for enough time to allow the receivers to
            obtain enough packets to reconstruct the object. The sender could
            then include an ERT based on the extended object transmission time
            in each subsequent packet header for the object. As other
            examples, the LCT header optionally can contain a Close Session
            flag that indicates when the sender is about to end sending packet
            to the session and a Close Object flag that indicates when the
            sender is about to end sending packets to the session for the
            object identified by the Transmission Object ID. However, these
            flags are not a completely reliable mechanism and thus the Close
            Session flag should only be used as a hint of when the session is
            about to close and the Close Object flag should only be used as a
            hint of when transmission of packets for the object is about to
            end.<br />
<br />

</dd>
<dt>On-demand content delivery model</dt>
<dd>
</dd>
<dt></dt>
<dd><br />
 For an on-demand content delivery
            service model, senders typically transmit for some given time
            period selected to be long enough to allow all the intended
            receivers to join the session and recover the object. For example
            a popular software update might be transmitted using LCT for
            several days, even though a receiver may be able to complete the
            download in one hour total of connection time, perhaps spread over
            several intervals of time. In this case the receivers join the
            session at any point in time when it is active. Receivers leave
            the session when they have received enough packets to recover the
            object. The receivers, for example, obtain a Session Description
            by contacting a web server.
</dd>
<dt></dt>
<dd><br />
 In this case the receivers join the
            session, and dynamically adapt the number of LCT channels they
            subscribe to according to the available bandwidth. Receivers then
            drop from the session when they have received enough packets to
            recover the object.
</dd>
<dt></dt>
<dd><br />
 As an example, assume that an object
            is 50 MB. The sender could send 1 KB packets to the first LCT
            channel at 50 packets per second, so that receivers using just
            this LCT channel could complete reception of the object in 1,000
            seconds in absence of loss, and would be able to complete
            reception even in presence of some substantial amount of losses
            with the use of coding for reliability. Furthermore, the sender
            could use a number of LCT channels such that the aggregate rate of
            1 KB packets to all LCT channels is 1,000 packets per second, so
            that a receiver could be able to complete reception of the object
            in as little 50 seconds (assuming no loss and that the congestion
            control mechanism immediately converges to the use of all LCT
            channels).<br />
<br />

</dd>
<dt>Other service models</dt>
<dd>
</dd>
<dt></dt>
<dd><br />
 There are many other delivery service
            models that LCT can be used for that are not covered above. As
            examples, a live streaming or an on-demand archival content
            streaming service model. A description of the many potential
            applications, the appropriate delivery service model, and the
            additional mechanisms to support such functionalities when
            combined with LCT is beyond the scope of this document. This
            document only attempts to describe the minimal common scalable
            elements to these diverse applications using LCT as the delivery
            transport.
</dd>
</dl></blockquote>

<a name="anchor6"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.3"></a><h3>4.3.&nbsp;
Congestion Control</h3>

<p>The specific congestion control protocol to be used for LCT
        sessions depends on the type of content to be delivered. While the
        general behavior of the congestion control protocol is to reduce the
        throughput in presence of congestion and gradually increase it in the
        absence of congestion, the actual dynamic behavior (e.g. response to
        single losses) can vary.
</p>
<p>It is RECOMMENDED that the congestion control mechanism specified
        in <a class='info' href='#RFC3738'>[RFC3738]<span> (</span><span class='info'>Luby, M. and V. Goyal, &ldquo;Wave and Equation Based Rate Control (WEBRC) Building Block,&rdquo; April&nbsp;2004.</span><span>)</span></a> be used. Some alternative possible
        congestion control protocols for reliable content delivery using LCT
        are described in <a class='info' href='#VIC1998'>[VIC1998]<span> (</span><span class='info'>Vicisano, L., Rizzo, L., and J. Crowcroft, &ldquo;TCP-like Congestion Control for Layered Multicast Data           Transfer,&rdquo; March&nbsp;1998.</span><span>)</span></a> and <a class='info' href='#BYE2000'>[BYE2000]<span> (</span><span class='info'>Byers, J., Frumin, M., Horn, G., Luby, M., Mitzenmacher, M., Rotter, A., and W. Shaver, &ldquo;FLID-DL: Congestion Control for Layered Multicast,&rdquo; November&nbsp;2000.</span><span>)</span></a>. Different delivery service models might
        require different congestion control protocols.
</p>
<a name="anchor7"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5"></a><h3>5.&nbsp;
Packet Header Fields</h3>

<p>Packets sent to an LCT session MUST include an "LCT header". The LCT
      header format is described below.
</p>
<p>Other building blocks MAY describe some of the same fields as
      described for the LCT header. It is RECOMMENDED that protocol
      instantiations using multiple building blocks include shared fields at
      most once in each packet. Thus, for example, if another building block
      is used with LCT that includes the optional Expected Residual Time
      field, then the Expected Residual Time field SHOULD be carried in each
      packet at most once.
</p>
<p>The position of the LCT header within a packet MUST be specified by
      any protocol instantiation that uses LCT.
</p>
<a name="anchor8"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.1"></a><h3>5.1.&nbsp;
LCT header format</h3>

<p>The LCT header is of variable size, which is specified by a length
        field in the third byte of the header. In the LCT header, all integer
        fields are carried in "big-endian" or "network order" format, that is,
        most significant byte (octet) first. Bits designated as "padding" or
        "reserved" (r) MUST by set to 0 by senders and ignored by receivers in
        this version of the specification. Unless otherwise noted, numeric
        constants in this specification are in decimal (base 10).
</p>
<p>The format of the default LCT header is depicted in <a class='info' href='#defheadfig'>Figure&nbsp;1<span> (</span><span class='info'>Default LCT header format</span><span>)</span></a>.
</p><br /><hr class="insert" />
<a name="defheadfig"></a>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
     0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |   V   | C |PSI|S| O |H|Res|A|B|   HDR_LEN     | Codepoint (CP)|
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    | Congestion Control Information (CCI, length = 32*(C+1) bits)  |
    |                          ...                                  |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |  Transport Session Identifier (TSI, length = 32*S+16*H bits)  |
    |                          ...                                  |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |   Transport Object Identifier (TOI, length = 32*O+16*H bits)  |
    |                          ...                                  |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |                Header Extensions (if applicable)              |
    |                          ...                                  |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;1: Default LCT header format&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>The function and length of each field in the default LCT header is
        the following.
</p>
<p></p>
<blockquote class="text"><dl>
<dt>LCT version number (V): 4 bits</dt>
<dd>
</dd>
<dt></dt>
<dd>Indicates the LCT version number. The LCT version number for
            this specification is 1.
</dd>
<dt>Congestion control flag (C): 2 bits</dt>
<dd>
</dd>
<dt></dt>
<dd>C=0 indicates the Congestion Control Information (CCI) field is
            32-bits in length. C=1 indicates the CCI field is 64-bits in
            length. C=2 indicates the CCI field is 96-bits in length. C=3
            indicates the CCI field is 128-bits in length.
</dd>
<dt>Protocol Specific Indication (PSI): 2 bits</dt>
<dd>
</dd>
<dt></dt>
<dd>The usage of these bits, if any, is specific to each Protocol
            Instantiation that uses the LCT Building Block. If no Protocol
            Instantiation-specific usage of these bits is defined, then a
            sender MUST set them to zero and a receiver MUST ignore these
            bits.
</dd>
<dt>Transport Session Identifier flag (S): 1 bit</dt>
<dd>
</dd>
<dt></dt>
<dd>This is the number of full 32-bit words in the TSI field. The
            TSI field is 32*S + 16*H bits in length, i.e. the length is either
            0 bits, 16 bits, 32 bits, or 48 bits.
</dd>
<dt>Transport Object Identifier flag (O): 2 bits</dt>
<dd>
</dd>
<dt></dt>
<dd>This is the number of full 32-bit words in the TOI field. The
            TOI field is 32*O + 16*H bits in length, i.e., the length is
            either 0 bits, 16 bits, 32 bits, 48 bits, 64 bits, 80 bits, 96
            bits, or 112 bits.
</dd>
<dt>Half-word flag (H): 1 bit</dt>
<dd>
</dd>
<dt></dt>
<dd>The TSI and the TOI fields are both multiples of 32 bits plus
            16*H bits in length. This allows the TSI and TOI field lengths to
            be multiples of a half-word (16 bits), while ensuring that the
            aggregate length of the TSI and TOI fields is a multiple of 32
            bits.
</dd>
<dt>Reserved (Res): 2 bits</dt>
<dd>
</dd>
<dt></dt>
<dd>These bits are reserved. In this version of the specification,
            they MUST be set to zero by senders and MUST be ignored by
            receivers.
</dd>
<dt>Close Session flag (A): 1 bit</dt>
<dd>
</dd>
<dt></dt>
<dd>Normally, A is set to 0. The sender MAY set A to 1 when
            termination of transmission of packets for the session is
            imminent. A MAY be set to 1 in just the last packet transmitted
            for the session, or A MAY be set to 1 in the last few seconds of
            packets transmitted for the session. Once the sender sets A to 1
            in one packet, the sender SHOULD set A to 1 in all subsequent
            packets until termination of transmission of packets for the
            session. A received packet with A set to 1 indicates to a receiver
            that the sender will immediately stop sending packets for the
            session. When a receiver receives a packet with A set to 1 the
            receiver SHOULD assume that no more packets will be sent to the
            session.
</dd>
<dt>Close Object flag (B): 1 bit</dt>
<dd>
</dd>
<dt></dt>
<dd>Normally, B is set to 0. The sender MAY set B to 1 when
            termination of transmission of packets for an object is imminent.
            If the TOI field is in use and B is set to 1 then termination of
            transmission for the object identified by the TOI field is
            imminent. If the TOI field is not in use and B is set to 1 then
            termination of transmission for the one object in the session
            identified by out-of-band information is imminent. B MAY be set to
            1 in just the last packet transmitted for the object, or B MAY be
            set to 1 in the last few seconds packets transmitted for the
            object. Once the sender sets B to 1 in one packet for a particular
            object, the sender SHOULD set B to 1 in all subsequent packets for
            the object until termination of transmission of packets for the
            object. A received packet with B set to 1 indicates to a receiver
            that the sender will immediately stop sending packets for the
            object. When a receiver receives a packet with B set to 1 then it
            SHOULD assume that no more packets will be sent for the object to
            the session.
</dd>
<dt>LCT header length (HDR_LEN): 8 bits</dt>
<dd>
</dd>
<dt></dt>
<dd>Total length of the LCT header in units of 32-bit words. The
            length of the LCT header MUST be a multiple of 32-bits. This field
            can be used to directly access the portion of the packet beyond
            the LCT header, i.e., to the first other header if it exists, or
            to the packet payload if it exists and there is no other header,
            or to the end of the packet if there are no other headers or
            packet payload.
</dd>
<dt>Codepoint (CP): 8 bits</dt>
<dd>
</dd>
<dt></dt>
<dd>An opaque identifier which is passed to the packet payload
            decoder to convey information on the codec being used for the
            packet payload. The mapping between the codepoint and the actual
            codec is defined on a per session basis and communicated
            out-of-band as part of the session description information. The
            use of the CP field is similar to the Payload Type (PT) field in
            RTP headers as described in <a class='info' href='#RFC3550'>[RFC3550]<span> (</span><span class='info'>Schulzrinne, H., Casner, S., Frederick, R., and V. Jacobson, &ldquo;RTP: A Transport Protocol for Real-Time Applications,&rdquo; July&nbsp;2003.</span><span>)</span></a>.
</dd>
<dt>Congestion Control Information (CCI): 32, 64, 96 or 128 bits</dt>
<dd>
</dd>
<dt></dt>
<dd>Used to carry congestion control information. For example, the
            congestion control information could include layer numbers,
            logical channel numbers, and sequence numbers. This field is
            opaque for the purpose of this specification.
</dd>
<dt></dt>
<dd>This field MUST be 32 bits if C=0.
</dd>
<dt></dt>
<dd>This field MUST be 64 bits if C=1.
</dd>
<dt></dt>
<dd>This field MUST be 96 bits if C=2.
</dd>
<dt></dt>
<dd>This field MUST be 128 bits if C=3.
</dd>
<dt>Transport Session Identifier (TSI): 0, 16, 32 or 48 bits</dt>
<dd>
</dd>
<dt></dt>
<dd>The TSI uniquely identifies a session among all sessions from a
            particular sender. The TSI is scoped by the IP address of the
            sender, and thus the IP address of the sender and the TSI together
            uniquely identify the session. Although a TSI in conjunction with
            the IP address of the sender always uniquely identifies a session,
            whether or not the TSI is included in the LCT header depends on
            what is used as the TSI value. If the underlying transport is UDP,
            then the 16 bit UDP source port number MAY serve as the TSI for
            the session. If the TSI value appears multiple times in a packet
            then all occurrences MUST be the same value. If there is no
            underlying TSI provided by the network, transport or any other
            layer, then the TSI MUST be included in the LCT header.
</dd>
<dt></dt>
<dd>The TSI MUST be unique among all sessions served by the sender
            during the period when the session is active, and for a large
            period of time preceding and following when the session is active.
            A primary purpose of the TSI is to prevent receivers from
            inadvertently accepting packets from a sender that belong to
            sessions other than the sessions receivers are subscribed to. For
            example, suppose a session is deactivated and then another session
            is activated by a sender and the two sessions use an overlapping
            set of channels. A receiver that connects and remains connected to
            the first session during this sender activity could possibly
            accept packets from the second session as belonging to the first
            session if the TSI for the two sessions were identical. The
            mapping of TSI field values to sessions is outside the scope of
            this document and is to be done out-of-band.
</dd>
<dt></dt>
<dd>The length of the TSI field is 32*S + 16*H bits. Note that the
            aggregate lengths of the TSI field plus the TOI field is a
            multiple of 32 bits.
</dd>
<dt>Transport Object Identifier (TOI): 0, 16, 32, 48, 64, 80, 96 or 112       bits.</dt>
<dd>
</dd>
<dt></dt>
<dd>This field indicates which object within the session this
            packet pertains to. For example, a sender might send a number of
            files in the same session, using TOI=0 for the first file, TOI=1
            for the second one, etc. As another example, the TOI may be a
            unique global identifier of the object that is being transmitted
            from several senders concurrently, and the TOI value may be the
            output of a hash function applied to the object. The mapping of
            TOI field values to objects is outside the scope of this document
            and is to be done out-of-band. The TOI field MUST be used in all
            packets if more than one object is to be transmitted in a session,
            i.e. the TOI field is either present in all the packets of a
            session or is never present.
</dd>
<dt></dt>
<dd>The length of the TOI field is 32*O + 16*H bits. Note that the
            aggregate lengths of the TSI field plus the TOI field is a
            multiple of 32 bits.
</dd>
</dl></blockquote>

<a name="HeaderExtensions"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.2"></a><h3>5.2.&nbsp;
Header-Extension Fields</h3>

<a name="anchor9"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.2.1"></a><h3>5.2.1.&nbsp;
General</h3>

<p>Header Extensions are used in LCT to accommodate optional header
          fields that are not always used or have variable size. Examples of
          the use of Header Extensions include:
</p>
<p></p>
<ul class="text">
<li>Extended-size versions of already existing header fields.
</li>
<li>Sender and Receiver authentication information.
</li>
<li>Transmission of timing information.
</li>
</ul>

<p>The presence of Header Extensions can be inferred by the LCT
          header length (HDR_LEN): if HDR_LEN is larger than the length of the
          standard header then the remaining header space is taken by Header
          Extension fields.
</p>
<p>If present, Header Extensions MUST be processed to ensure that
          they are recognized before performing any congestion control
          procedure or otherwise accepting a packet. The default action for
          unrecognized header extensions is to ignore them. This allows the
          future introduction of backward-compatible enhancements to LCT
          without changing the LCT version number. Non backward-compatible
          header extensions CANNOT be introduced without changing the LCT
          version number.
</p>
<p>There are two formats for Header Extension fields, as depicted in
          <a class='info' href='#addheadfig'>Figure&nbsp;2<span> (</span><span class='info'>Format of additional headers</span><span>)</span></a>. The first format is used for
          variable-length extensions, with Header Extension Type (HET) values
          between 0 and 127. The second format is used for fixed length (one
          32-bit word) extensions, using HET values from 127 to 255.
</p><br /><hr class="insert" />
<a name="addheadfig"></a>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
     0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |  HET (&lt;=127)  |       HEL     |                               |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+                               +
    .                                                               .
    .              Header Extension Content (HEC)                   .
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

     0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |  HET (&gt;=128)  |       Header Extension Content (HEC)          |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;2: Format of additional headers&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>The explanation of each sub-field is the following:
</p>
<p></p>
<blockquote class="text"><dl>
<dt>Header Extension Type (HET): 8 bits</dt>
<dd>
</dd>
<dt></dt>
<dd>The type of the Header Extension. This document defines a
              number of possible types. Additional types may be defined in
              future versions of this specification. HET values from 0 to 127
              are used for variable-length Header Extensions. HET values from
              128 to 255 are used for fixed-length 32-bit Header
              Extensions.
</dd>
<dt>Header Extension Length (HEL): 8 bits</dt>
<dd>
</dd>
<dt></dt>
<dd>The length of the whole Header Extension field, expressed in
              multiples of 32-bit words. This field MUST be present for
              variable-length extensions (HET between 0 and 127) and MUST NOT
              be present for fixed-length extensions (HET between 128 and
              255).
</dd>
<dt>Header Extension Content (HEC): variable length</dt>
<dd>
</dd>
<dt></dt>
<dd>The content of the Header Extension. The format of this sub-
              field depends on the Header Extension type. For fixed-length
              Header Extensions, the HEC is 24 bits. For variable-length
              Header Extensions, the HEC field has variable size, as specified
              by the HEL field. Note that the length of each Header Extension
              field MUST be a multiple of 32 bits. Also note that the total
              size of the LCT header, including all Header Extensions and all
              optional header fields, cannot exceed 255 32-bit words.
</dd>
</dl></blockquote>

<p>The following LCT Header Extensions are defined by this
          specification:
</p>
<p></p>
<blockquote class="text"><dl>
<dt>EXT_NOP, HET=0</dt>
<dd>No-Operation extension. The
              information present in this extension field MUST be ignored by
              receivers.
</dd>
<dt>EXT_AUTH, HET=1</dt>
<dd>Packet authentication extension.
              Information used to authenticate the sender of the packet. The
              format of this Header Extension and its processing is outside
              the scope of this document and is to be communicated out-of-band
              as part of the session description.
</dd>
<dt></dt>
<dd>It is RECOMMENDED that senders provide some form of packet
              authentication. If EXT_AUTH is present, whatever packet
              authentication checks that can be performed immediately upon
              reception of the packet SHOULD be performed before accepting the
              packet and performing any congestion control-related action on
              it.
</dd>
<dt></dt>
<dd>Some packet authentication schemes impose a delay of several
              seconds between when a packet is received and when the packet is
              fully authenticated. Any congestion control related action that
              is appropriate SHOULD NOT be postponed by any such full packet
              authentication.
</dd>
<dt>EXT_TIME, HET=2</dt>
<dd>Time Extension. This extension is
              used to carry several types of timing information. It includes
              general purpose timing information, namely the Sender Current
              Time (SCT), Expected Residual Time (ERT) and Sender Last Change
              (SLC) time extensions described in the present document. It can
              also be used for timing information with narrower applicability
              (e.g. defined for a single Protocol Instantiation); in this case
              it will be described in a separate document.
</dd>
</dl></blockquote>

<p>All senders and receivers implementing LCT MUST support the
          EXT_NOP Header Extension and MUST recognize EXT_AUTH and EXT_TIME,
          but are not required to be able to parse their content.
</p>
<a name="anchor10"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.2.2"></a><h3>5.2.2.&nbsp;
EXT_TIME Header Extension</h3>

<p>This section defines the timing header extensions with general
          applicability. The time values carried in this header extension are
          related to the server's wall clock. The server MUST maintain
          consistent relative time during a session (i.e. insignificant clock
          drift). For some applications, system or even global synchronization
          of server wall clock may be desirable, such as using the Network
          Time Protocol (NTP) <a class='info' href='#RFC1305'>[RFC1305]<span> (</span><span class='info'>Mills, D., &ldquo;Network Time Protocol (Version 3) Specification, Implementation,&rdquo; March&nbsp;1992.</span><span>)</span></a> to ensure actual
          time relative to 00:00 hours GMT, January 1st 1900. Such
          session-external synchronization is outside the scope of this
          document.
</p>
<p>The EXT_TIME Header Extension uses the format depicted in <a class='info' href='#exttimefigure'>Figure&nbsp;3<span> (</span><span class='info'>EXT_TIME Header Extension format</span><span>)</span></a>
</p><br /><hr class="insert" />
<a name="exttimefigure"></a>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |     HET = 2   |    HEL &gt;= 1   |         Use (bit field)       |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                       first time value                        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   ...            (other time values (optional)                  ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;3: EXT_TIME Header Extension format&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>The "Use" bit field indicates the semantic of the following 32
          bit time value(s).
</p>
<p>It is divided into two parts: </p>
<ul class="text">
<li>8 bits are reserved for general purpose timing information.
              These information are applicable to any protocol which makes use
              of LCT.
</li>
<li>8 bits are reserved for PI specific timing information. These
              information are out of the scope of this document.
</li>
</ul>

<p>The format of the "Use" bit field is depicted in <a class='info' href='#exttimeuseigure'>Figure&nbsp;4<span> (</span><span class='info'>&quot;Use&quot; bit field format</span><span>)</span></a>.
</p><br /><hr class="insert" />
<a name="exttimeuseigure"></a>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
                     2                                       3
     6   7   8   9   0   1   2   3   4   5   6   7   8   9   0   1
   +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
   |SCT|SCT|ERT|SLC|   reserved    |          PI-specific          |
   |Hi |Low|   |   |    by LCT     |              use              |
   +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+

</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;4: &quot;Use&quot; bit field format&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>Several "time value" fields MAY be present in a given EXT_TIME
          Header Extension, as specified in the "Use-field". When several
          "time value" fields are present, they MUST appear in the order
          specified by the associated flag position in the "Use-field": first
          SCT-High (if present), then SCT-Low (if present), then ERT (if
          present), then SLC (if present). Receivers SHOULD ignore additional
          fields within the EXT_TIME Header Extension which they do not
          support.
</p>
<p>The fields for the general purpose EXT_TIME timing information
          are:
</p>
<p>Sender Current Time (SCT): SCT High flag, SCT Low flag,
          corresponding time value (one or two 32 bit words) </p>
<blockquote class="text">
<p>This timing information represents the current time at the
              sender at the time this packet was transmitted.
</p>
<p>When the SCT-High flag is set, the associated 32 bit time
              value provides an unsigned integer representing the time in
              seconds of the sender's wall clock. In the particular case where
              NTP is used, these 32 bits provide an unsigned integer
              representing the time in seconds relative to 00:00 hours GMT,
              January 1st 1900, (i.e. the most significant 32 bits of a full
              64 bit NTP time value). In that case, handling of wraparound of
              the 32 bit time is outside the scope of NTP and LCT.
</p>
<p>When the SCT-Low flag is set, the associated 32 bit time
              value provides an unsigned integer representing a multiple of
              1/2^^32 of a second, in order to allow sub-second precision.
              When the SCT-Low flag is set, the SCT-High flag MUST be set too.
              In the particular case where NTP is used, these 32 bits provide
              the 32 least significant bits of a 64 bit NTP timestamp.
</p>
</blockquote>

<p>Expected Residual Time (ERT): ERT flag, corresponding 32 bit time
          value </p>
<blockquote class="text">
<p>This timing information represents the sender expected
              residual transmission time for the transmission of the current
              object. If the packet containing the ERT timing information also
              contains the TOI field, then ERT refers to the object
              corresponding to the TOI field, otherwise it refers to the only
              object in the session.
</p>
<p>When the ERT flag is set, it it expressed as a number of
              seconds. The 32 bits provide an unsigned integer representing
              this number of seconds.
</p>
</blockquote>

<p>Session Last Changed (SLC): SLC flag, corresponding 32 bit time
          value </p>
<blockquote class="text">
<p>The Session Last Changed time value is the server wall clock
              time, in seconds, at which the last change to session data
              occurred. That is, it expresses the time at which the last (most
              recent) Transport Object addition, modification or removal was
              made for the delivery session. In the case of modifications and
              additions it indicates that new data will be transported which
              was not transported prior to this time. In the case of removals,
              SLC indicates that some prior data will no longer be
              transported.
</p>
<p>When the SLC flag is set, the associated 32 bit time value
              provides an unsigned integer representing a time in seconds. In
              the particular case where NTP is used, these 32 bits provide an
              unsigned integer representing the time in seconds relative to
              00:00 hours GMT, January 1st 1900, (i.e. the most significant 32
              bits of a full 64 bit NTP time value). In that case, handling of
              wraparound of the 32 bit time is outside the scope of NTP and
              LCT.
</p>
<p>In some cases, it may be appropriate that a packet containing
              a EXT_TIME Header Extension with an SLC information also contain
              a SCT-High information.
</p>
</blockquote>

<p>Reserved by LCT for future use (4 bits): </p>
<blockquote class="text">
<p>In this version of the specification, these bits MUST be set
              to zero by senders and MUST be ignored by receivers.
</p>
</blockquote>

<p>PI-specific use (8 bits): </p>
<blockquote class="text">
<p>These bits are out of the scope of this document. The bits
              that are not specified by the PI built on top of LCT SHOULD be
              set to zero.
</p>
</blockquote>

<p>The total EXT_TIME length is carried in the HEL, since this
          Header Extension is of variable length. It also enables clients to
          skip this Header Extension altogether if not supported (but
          recognized).
</p>
<a name="anchor11"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6"></a><h3>6.&nbsp;
Operations</h3>

<a name="SenderOperation"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.1"></a><h3>6.1.&nbsp;
Sender Operation</h3>

<p>Before joining an LCT session a receiver MUST obtain a session
        description. The session description MUST include:
</p>
<p></p>
<ul class="text">
<li>The sender IP address;
</li>
<li>The number of LCT channels;
</li>
<li>The addresses and port numbers used for each LCT channel;
</li>
<li>The Transport Session ID (TSI) to be used for the session;
</li>
<li>Enough information to determine the congestion control protocol
            being used;
</li>
<li>Enough information to determine the packet authentication
            scheme being used if it is being used.
</li>
</ul>

<p>The session description could also include, but is not limited
        to:
</p>
<p></p>
<ul class="text">
<li>The data rates used for each LCT channel;
</li>
<li>The length of the packet payload;
</li>
<li>The mapping of TOI value(s) to objects for the session;
</li>
<li>Any information that is relevant to each object being
            transported, such as when it will be available within the session,
            for how long, and the length of the object;
</li>
</ul>

<p>Protocol instantiations using LCT MAY place additional requirements
        on what must be included in the session description. For example, a
        protocol instantiation might require that the data rates for each
        channel, or the mapping of TOI value(s) to objects for the session, or
        other information related to other headers that might be required to
        be included in the session description.
</p>
<p>The session description could be in a form such as SDP as defined
        in <a class='info' href='#RFC4566'>[RFC4566]<span> (</span><span class='info'>Handley, M., Jacobson, V., and C. Perkins, &ldquo;SDP: Session Description Protocol,&rdquo; July&nbsp;2006.</span><span>)</span></a>, or another format appropriate to a
        particular application. It might be carried in a session announcement
        protocol such as SAP as defined in <a class='info' href='#RFC2974'>[RFC2974]<span> (</span><span class='info'>Handley, M., Perkins, C., and E. Whelan, &ldquo;Session Announcement Protocol,&rdquo; October&nbsp;2000.</span><span>)</span></a>,
        obtained using a proprietary session control protocol, located on a
        Web page with scheduling information, or conveyed via E-mail or other
        out-of-band methods. Discussion of session description format, and
        distribution of session descriptions is beyond the scope of this
        document.
</p>
<p>Within an LCT session, a sender using LCT transmits a sequence of
        packets, each in the format defined above. Packets are sent from a
        sender using one or more LCT channels which together constitute a
        session. Transmission rates may be different in different channels and
        may vary over time. The specification of the other building block
        headers and the packet payload used by a complete protocol
        instantiation using LCT is beyond the scope of this document. This
        document does not specify the order in which packets are transmitted,
        nor the organization of a session into multiple channels. Although
        these issues affect the efficiency of the protocol, they do not affect
        the correctness nor the inter-operability of LCT between senders and
        receivers.
</p>
<p>Several objects can be carried within the same LCT session. In this
        case, each object MUST be identified by a unique TOI. Objects MAY be
        transmitted sequentially, or they MAY be transmitted concurrently. It
        is good practice to only send objects concurrently in the same session
        if the receivers that participate in that portion of the session have
        interest in receiving all the objects. The reason for this is that it
        wastes bandwidth and networking resources to have receivers receive
        data for objects that they have no interest in.
</p>
<p>Typically, the sender(s) continues to send packets in a session
        until the transmission is considered complete. The transmission may be
        considered complete when some time has expired, a certain number of
        packets have been sent, or some out-of-band signal (possibly from a
        higher level protocol) has indicated completion by a sufficient number
        of receivers.
</p>
<p>For the reasons mentioned above, this document does not pose any
        restriction on packet sizes. However, network efficiency
        considerations recommend that the sender uses an as large as possible
        packet payload size, but in such a way that packets do not exceed the
        network's maximum transmission unit size (MTU), or when fragmentation
        coupled with packet loss might introduce severe inefficiency in the
        transmission.
</p>
<p>It is recommended that all packets have the same or very similar
        sizes, as this can have a severe impact on the effectiveness of
        congestion control schemes such as the ones described in <a class='info' href='#VIC1998'>[VIC1998]<span> (</span><span class='info'>Vicisano, L., Rizzo, L., and J. Crowcroft, &ldquo;TCP-like Congestion Control for Layered Multicast Data           Transfer,&rdquo; March&nbsp;1998.</span><span>)</span></a>, <a class='info' href='#BYE2000'>[BYE2000]<span> (</span><span class='info'>Byers, J., Frumin, M., Horn, G., Luby, M., Mitzenmacher, M., Rotter, A., and W. Shaver, &ldquo;FLID-DL: Congestion Control for Layered Multicast,&rdquo; November&nbsp;2000.</span><span>)</span></a>, and <a class='info' href='#RFC3738'>[RFC3738]<span> (</span><span class='info'>Luby, M. and V. Goyal, &ldquo;Wave and Equation Based Rate Control (WEBRC) Building Block,&rdquo; April&nbsp;2004.</span><span>)</span></a>. A sender of packets using LCT MUST implement
        the sender- side part of one of the congestion control schemes that is
        in accordance with <a class='info' href='#RFC2357'>[RFC2357]<span> (</span><span class='info'>Mankin, A., Romanov, A., Bradner, S., and V. Paxson, &ldquo;IETF Criteria for Evaluating Reliable Multicast Transport and Application Protocols,&rdquo; June&nbsp;1998.</span><span>)</span></a> using the Congestion
        Control Information field provided in the LCT header, and the
        corresponding receiver congestion control scheme is to be communicated
        out-of-band and MUST be implemented by any receivers participating in
        the session.
</p>
<a name="receiver"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.2"></a><h3>6.2.&nbsp;
Receiver Operation</h3>

<p>Receivers can operate differently depending on the delivery service
        model. For example, for an on demand service model, receivers may join
        a session, obtain the necessary packets to reproduce the object, and
        then leave the session. As another example, for a streaming service
        model, a receiver may be continuously joined to a set of LCT channels
        to download all objects in a session.
</p>
<p>To be able to participate in a session, a receiver MUST obtain the
        relevant session description information as listed in <a class='info' href='#SenderOperation'>Section&nbsp;6.1<span> (</span><span class='info'>Sender Operation</span><span>)</span></a>.
</p>
<p>If packet authentication information is present in an LCT header,
        it SHOULD be used as specified in <a class='info' href='#HeaderExtensions'>Section&nbsp;5.2<span> (</span><span class='info'>Header-Extension Fields</span><span>)</span></a>. To be able to be a receiver in a
        session, the receiver MUST be able to process the LCT header. The
        receiver MUST be able to discard, forward, store or process the other
        headers and the packet payload. If a receiver is not able to process a
        LCT header, it MUST drop from the session.
</p>
<p>To be able to participate in a session, a receiver MUST implement
        the congestion control protocol specified in the session description
        using the Congestion Control Information field provided in the LCT
        header. If a receiver is not able to implement the congestion control
        protocol used in the session, it MUST NOT join the session. When the
        session is transmitted on multiple LCT channels, receivers MUST
        initially join channels according to the specified startup behavior of
        the congestion control protocol. For a multiple rate congestion
        control protocol that uses multiple channels, this typically means
        that a receiver will initially join only a minimal set of LCT
        channels, possibly a single one, that in aggregate are carrying
        packets at a low rate. This rule has the purpose of preventing
        receivers from starting at high data rates.
</p>
<p>Several objects can be carried either sequentially or concurrently
        within the same LCT session. In this case, each object is identified
        by a unique TOI. Note that even if a server stops sending packets for
        an old object before starting to transmit packets for a new object,
        both the network and the underlying protocol layers can cause some
        reordering of packets, especially when sent over different LCT
        channels, and thus receivers SHOULD NOT assume that the reception of a
        packet for a new object means that there are no more packets in
        transit for the previous one, at least for some amount of time.
</p>
<p>A receiver MAY be concurrently joined to multiple LCT sessions from
        one or more senders. The receiver MUST perform congestion control on
        each such LCT session. If the congestion control protocol allows the
        receiver some flexibility in terms of its actions within a session
        then the receiver MAY make choices to optimize the packet flow
        performance across the multiple LCT sessions, as long as the receiver
        still adheres to the congestion control rules for each LCT session
        individually.
</p>
<a name="otherbb"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7"></a><h3>7.&nbsp;
Requirements from Other Building Blocks</h3>

<p>As described in <a class='info' href='#RFC3048'>[RFC3048]<span> (</span><span class='info'>Whetten, B., Vicisano, L., Kermode, R., Handley, M., Floyd, S., and M. Luby, &ldquo;Reliable Multicast Transport Building Blocks for One-to-Many Bulk-Data Transfer,&rdquo; January&nbsp;2001.</span><span>)</span></a>, LCT is a building
      block that is intended to be used, in conjunction with other building
      blocks, to help specify a protocol instantiation. A congestion control
      building block that uses the Congestion Control information field within
      the LCT header MUST be used by any protocol instantiation that uses LCT,
      and other building blocks MAY also be used, such as a reliability
      building block.
</p>
<p>The congestion control MUST be applied to the LCT session as an
      entity, i.e., over the aggregate of the traffic carried by all of the
      LCT channels associated with the LCT session. The Congestion Control
      Information field in the LCT header is an opaque field that is reserved
      to carry information related to congestion control. There MAY also be
      congestion control Header Extension fields that carry additional
      information related to congestion control.
</p>
<p>The particular layered encoder and congestion control protocols used
      with LCT have an impact on the performance and applicability of LCT. For
      example, some layered encoders used for video and audio streams can
      produce a very limited number of layers, thus providing a very coarse
      control in the reception rate of packets by receivers in a session. When
      LCT is used for reliable data transfer, some FEC codecs are inherently
      limited in the size of the object they can encode, and for objects
      larger than this size the reception overhead on the receivers can grow
      substantially.
</p>
<p>A more in-depth description of the use of FEC in Reliable Multicast
      Transport (RMT) protocols is given in <a class='info' href='#RFC3453'>[RFC3453]<span> (</span><span class='info'>Luby, M., Vicisano, L., Gemmell, J., Rizzo, L., Handley, M., and J. Crowcroft, &ldquo;The Use of Forward Error Correction (FEC) in Reliable Multicast,&rdquo; December&nbsp;2002.</span><span>)</span></a>.
      Some of the FEC codecs that MAY be used in conjunction with LCT for
      reliable content delivery are specified in <a class='info' href='#RFC5052'>[RFC5052]<span> (</span><span class='info'>Watson, M., Luby, M., and L. Vicisano, &ldquo;Forward Error Correction (FEC) Building Block,&rdquo; August&nbsp;2007.</span><span>)</span></a>. The Codepoint field in the LCT header is an
      opaque field that can be used to carry information related to the
      encoding of the packet payload.
</p>
<p>LCT also requires receivers to obtain a session description, as
      described in <a class='info' href='#SenderOperation'>Section&nbsp;6.1<span> (</span><span class='info'>Sender Operation</span><span>)</span></a> The session
      description could be in a form such as SDP as defined in <a class='info' href='#RFC4566'>[RFC4566]<span> (</span><span class='info'>Handley, M., Jacobson, V., and C. Perkins, &ldquo;SDP: Session Description Protocol,&rdquo; July&nbsp;2006.</span><span>)</span></a>, or another format appropriate to a particular
      application and may be distributed with SAP as defined in <a class='info' href='#RFC2974'>[RFC2974]<span> (</span><span class='info'>Handley, M., Perkins, C., and E. Whelan, &ldquo;Session Announcement Protocol,&rdquo; October&nbsp;2000.</span><span>)</span></a>, using HTTP, or in other ways. It is
      RECOMMENDED that an authentication protocol be used to deliver the
      session description to receivers to ensure the correct session
      description arrives.
</p>
<p>It is RECOMMENDED that LCT implementors use some packet
      authentication scheme to protect the protocol from attacks. An example
      of a possibly suitable scheme is described in <a class='info' href='#Perrig2001'>[Perrig2001]<span> (</span><span class='info'>Perrig, A., Canetti, R., Song, D., and J. Tyger, &ldquo;Efficient and Secure Source Authentication for           Multicast,&rdquo; February&nbsp;2001.</span><span>)</span></a>.
</p>
<p>Some protocol instantiations that use LCT MAY use building blocks
      that require the generation of feedback from the receivers to the
      sender. However, the mechanism for doing this is outside the scope of
      LCT.
</p>
<a name="anchor12"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.8"></a><h3>8.&nbsp;
Security Considerations</h3>

<p>LCT is a Building Block as defined in <a class='info' href='#RFC3048'>[RFC3048]<span> (</span><span class='info'>Whetten, B., Vicisano, L., Kermode, R., Handley, M., Floyd, S., and M. Luby, &ldquo;Reliable Multicast Transport Building Blocks for One-to-Many Bulk-Data Transfer,&rdquo; January&nbsp;2001.</span><span>)</span></a>
      and as such does not define a complete protocol. Protocol Instantiations
      which use the LCT building block MUST address the potential
      vulnerabilities described in the following sections. For an example, see
      <a class='info' href='#I-D.ietf-rmt-pi-alc-revised'>[I&#8209;D.ietf&#8209;rmt&#8209;pi&#8209;alc&#8209;revised]<span> (</span><span class='info'>Luby, M., Watson, M., and L. Vicisano, &ldquo;Asynchronous Layered Coding (ALC) Protocol Instantiation,&rdquo; November&nbsp;2009.</span><span>)</span></a>
</p>
<p>Protocol Instantiations could address the vulnerabilities described
      below by taking measures to prevent receivers from accepting incorrect
      packets, for example by using a source authentication and content
      integrity mechanism. See also <a class='info' href='#receiver'>Section&nbsp;6.2<span> (</span><span class='info'>Receiver Operation</span><span>)</span></a> and <a class='info' href='#otherbb'>Section&nbsp;7<span> (</span><span class='info'>Requirements from Other Building Blocks</span><span>)</span></a> for discussion of packet authentication
      requirements.
</p>
<p>Note that for correct operation LCT assumes availability of session
      description information (see <a class='info' href='#applicability'>Section&nbsp;4<span> (</span><span class='info'>Applicability</span><span>)</span></a> and
      <a class='info' href='#otherbb'>Section&nbsp;7<span> (</span><span class='info'>Requirements from Other Building Blocks</span><span>)</span></a>). Incorrect or maliciously modified
      session description information may result in receivers being unable to
      correctly receive the session content, or that receivers inadvertently
      try to receive at a much higher rate than they are capable of, thereby
      disrupting traffic in portions of the network. Protocol Instantiations
      MUST address this potential vulnerability, for example by providing
      source authentication and integrity mechanisms for the session
      description. Additionally, these mechanisms MUST allow the receivers to
      securely verify the correspondence between session description and LCT
      data packets.
</p>
<p>The following sections consider further each of the services provided
      by LCT:
</p>
<a name="anchor13"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.8.1"></a><h3>8.1.&nbsp;
Session and object multiplexing and termination</h3>

<p>The Transport Session Identifier, Transport Object Identifier in
        the LCT header provide for multiplexing of sessions and objects.
        Modification of these fields by an attacker could have the effect of
        depriving a session or object of data and potentially directing
        incorrect data to another session or object, in both cases effecting a
        denial-of-service attack.
</p>
<p>Additionally, injection of forged packets with fake TSI or TOI
        values may cause receivers to allocate resources for additional
        sessions or objects, again potentially effecting a DoS attack.
</p>
<p>The Close Object and Close Session bits in the LCT header provide
        for signaling of the end of a session or object. Modification of these
        fields by an attacker could cause receivers to incorrectly behave as
        if the session or object had ended, resulting in a denial-of-service
        attack, or conversely to continue to unnecessarily utilize resources
        after the session or object has ended (although resource utilisation
        in this case is largely an implementation issue).
</p>
<p>As a result of the above vulnerabilities, these fields MUST be
        protected by Protocol Instantiation security mechanisms (for example
        source authentication and data integrity mechanisms).
</p>
<a name="anchor14"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.8.2"></a><h3>8.2.&nbsp;
Time synchronization</h3>

<p>The SCT and ERT mechanisms provide rudimentary time synchronization
        features which can both be subject to attacks. Indeed an attacker can
        easily de-synchronize clients, sending erroneous SCT information, or
        mount a DoS attack by informing all clients that the session (resp. a
        particular object) is about to be closed.
</p>
<p>As a result of the above vulnerabilities, these fields MUST be
        protected by Protocol Instantiation security mechanisms (for example
        source authentication and data integrity mechanisms).
</p>
<a name="anchor15"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.8.3"></a><h3>8.3.&nbsp;
Data transport</h3>

<p>The LCT protocol provides for transport of information for other
        Building Blocks, specifically the PSI field for the Protocol
        Instantiation, the Congestion Control field for the Congestion Control
        Building Block, the Codepoint field for the FEC Building Block, the
        EXT-AUTH Header Extension (used by the Protocol Instantiation) and the
        packet payload itself.
</p>
<p>Modification of any of these fields by an attacker may result in a
        Denial-of-service attack. In particular, modification of the Codepoint
        or packet payload may prevent successful reconstruction or cause
        inaccurate reconstruction of large portions of an object by receivers.
        Modification of the Congestion Control field may cause receivers to
        attempt to receive at an incorrect rate, potentially worsening or
        causing a congestion situation and thereby effecting a DoS attack.
</p>
<p>As a result of the above vulnerabilities, these fields MUST be
        protected by Protocol Instantiation security mechanisms (for example
        source authentication and data integrity mechanisms).
</p>
<a name="anchor16"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.9"></a><h3>9.&nbsp;
IANA Considerations</h3>

<a name="anchor17"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.9.1"></a><h3>9.1.&nbsp;
Namespace declaration for LCT Header Extension Types</h3>

<p>This document defines a new namespace for "LCT Header Extension
        Types". Values in this namespace are integers between 0 and 255
        inclusive.
</p>
<p>Values in the range 0 to 63 (inclusive) are reserved for use for
        variable length LCT Header Extensions and assignments shall be made
        through "IETF Review" as defined in <a class='info' href='#RFC5226'>[RFC5226]<span> (</span><span class='info'>Narten, T. and H. Alvestrand, &ldquo;Guidelines for Writing an IANA Considerations Section in RFCs,&rdquo; May&nbsp;2008.</span><span>)</span></a>.
</p>
<p>Values in the range 64 to 127 (inclusive) are reserved for variable
        length LCT Header Extensions and assignments shall be made on the
        "Specification Required" basis as defined in <a class='info' href='#RFC5226'>[RFC5226]<span> (</span><span class='info'>Narten, T. and H. Alvestrand, &ldquo;Guidelines for Writing an IANA Considerations Section in RFCs,&rdquo; May&nbsp;2008.</span><span>)</span></a>.
</p>
<p>Values in the range 128 to 191 (inclusive) are reserved for use for
        fixed length LCT Header Extensions and assignments shall be made
        through "IETF Review" as defined in <a class='info' href='#RFC5226'>[RFC5226]<span> (</span><span class='info'>Narten, T. and H. Alvestrand, &ldquo;Guidelines for Writing an IANA Considerations Section in RFCs,&rdquo; May&nbsp;2008.</span><span>)</span></a>.
</p>
<p>Values in the range 192 to 255 (inclusive) are reserved for fixed
        length LCT Header Extensions and assignments shall be made on the
        "Specification Required" basis as defined in <a class='info' href='#RFC5226'>[RFC5226]<span> (</span><span class='info'>Narten, T. and H. Alvestrand, &ldquo;Guidelines for Writing an IANA Considerations Section in RFCs,&rdquo; May&nbsp;2008.</span><span>)</span></a>.
</p>
<p>Initial values for the LCT Header Extension Type registry are
        defined in <a class='info' href='#IANAValues'>Section&nbsp;9.2<span> (</span><span class='info'>LCT Header Extension Type registration</span><span>)</span></a>.
</p>
<p>Note that the previous Experimental version of this specification
        reserved values in the ranges [64, 127] and [192, 255] for Protocol
        Instantiation-specific LCT Header Extensions. In the interest of
        simplification and since there were no overlapping allocations of
        these LCT Header Extension Type values by Protocol Instantiations,
        this document specifies a single flat space for LCT Header Extension
        Types.
</p>
<a name="IANAValues"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.9.2"></a><h3>9.2.&nbsp;
LCT Header Extension Type registration</h3>

<p>This document registers three values in the LCT Header Extension
        Type namespace as follows:
</p><table class="full" align="center" border="0" cellpadding="2" cellspacing="2">
<col align="left"><col align="left"><col align="left">
<tr><th align="left">Value</th><th align="left">Name</th><th align="left">Reference</th></tr>
<tr>
<td align="left">0</td>
<td align="left">EXT_NOP</td>
<td align="left">This specification</td>
</tr>
<tr>
<td align="left">1</td>
<td align="left">EXT_AUTH</td>
<td align="left">This specification</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">EXT_TIME</td>
<td align="left">This specification</td>
</tr>
</table>
<br clear="all" />

<a name="anchor18"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.10"></a><h3>10.&nbsp;
Acknowledgments</h3>

<p>This specification is substantially based on RFC 3451 <a class='info' href='#RFC3451'>[RFC3451]<span> (</span><span class='info'>Luby, M., Gemmell, J., Vicisano, L., Rizzo, L., Handley, M., and J. Crowcroft, &ldquo;Layered Coding Transport (LCT) Building Block,&rdquo; December&nbsp;2002.</span><span>)</span></a> and thus credit for the authorship of this
      document is primarily due to the authors of RFC 3450: Mike Luby, Jim
      Gemmel, Lorenzo Vicisano, Luigi Rizzo and Jon Crowcroft. Bruce
      Lueckenhoff, Hayder Radha and Justin Chapweske also contributed to RFC
      3451. Additional thanks are due to Vincent Roca, Rod Walsh and Toni
      Paila for contributions to this update to Proposed Standard.
</p>
<a name="changes"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.11"></a><h3>11.&nbsp;
Changes from RFC 3451</h3>

<p>This section summarises the changes that were made from the
      Experimental version of this specification published as RFC 3451 <a class='info' href='#RFC3451'>[RFC3451]<span> (</span><span class='info'>Luby, M., Gemmell, J., Vicisano, L., Rizzo, L., Handley, M., and J. Crowcroft, &ldquo;Layered Coding Transport (LCT) Building Block,&rdquo; December&nbsp;2002.</span><span>)</span></a>: </p>
<ul class="text">
<li>Removed the 'Statement of Intent' from the introduction (The
          statement of intent was meant to clarify the "Experimental" status
          of RFC 3451.)
</li>
<li>Inclusion of material from ALC which is applicable in the more
          general LCT context
</li>
<li>Creation of an IANA registry for LCT Header Extensions
</li>
<li>Allocation of the 2 &lsquo;reserved&rsquo; bits in the LCT header
          as &ldquo;Protocol Specific Indication&rdquo; &ndash; usage to be
          defined by protocol instantiations
</li>
<li>Removal of the Sender Current Time and Expected Residual Time LCT
          header fields.
</li>
<li>Inclusion of a new Header Extension, EXT_TIME, to replace the SCT
          and ERT and provide for future extension of timing capabilities.
</li>
</ul>

<a name="rfc.references"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.12"></a><h3>12.&nbsp;
References</h3>

<a name="rfc.references1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>12.1.&nbsp;Normative References</h3>
<table width="99%" border="0">
<tr><td class="author-text" valign="top"><a name="RFC0768">[RFC0768]</a></td>
<td class="author-text">Postel, J., &ldquo;<a href="http://tools.ietf.org/html/rfc768">User Datagram Protocol</a>,&rdquo; STD&nbsp;6, RFC&nbsp;768, August&nbsp;1980 (<a href="http://www.rfc-editor.org/rfc/rfc768.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC1112">[RFC1112]</a></td>
<td class="author-text"><a href="mailto:deering@PESCADERO.STANFORD.EDU">Deering, S.</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc1112">Host extensions for IP multicasting</a>,&rdquo; STD&nbsp;5, RFC&nbsp;1112, August&nbsp;1989 (<a href="http://www.rfc-editor.org/rfc/rfc1112.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC2119">[RFC2119]</a></td>
<td class="author-text"><a href="mailto:sob@harvard.edu">Bradner, S.</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>,&rdquo; BCP&nbsp;14, RFC&nbsp;2119, March&nbsp;1997 (<a href="http://www.rfc-editor.org/rfc/rfc2119.txt">TXT</a>, <a href="http://xml.resource.org/public/rfc/html/rfc2119.html">HTML</a>, <a href="http://xml.resource.org/public/rfc/xml/rfc2119.xml">XML</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC5052">[RFC5052]</a></td>
<td class="author-text">Watson, M., Luby, M., and L. Vicisano, &ldquo;<a href="http://tools.ietf.org/html/rfc5052">Forward Error Correction (FEC) Building Block</a>,&rdquo; RFC&nbsp;5052, August&nbsp;2007 (<a href="http://www.rfc-editor.org/rfc/rfc5052.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC5226">[RFC5226]</a></td>
<td class="author-text">Narten, T. and H. Alvestrand, &ldquo;<a href="http://tools.ietf.org/html/rfc5226">Guidelines for Writing an IANA Considerations Section in RFCs</a>,&rdquo; BCP&nbsp;26, RFC&nbsp;5226, May&nbsp;2008 (<a href="http://www.rfc-editor.org/rfc/rfc5226.txt">TXT</a>).</td></tr>
</table>

<a name="rfc.references2"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>12.2.&nbsp;Informative References</h3>
<table width="99%" border="0">
<tr><td class="author-text" valign="top"><a name="BYE1998">[BYE1998]</a></td>
<td class="author-text">Byers, J., Luby, M., Mitzenmacher, M., and A. Rege, &ldquo;Fountain Approach to Reliable Distribution of Bulk
          Data,&rdquo; Proceedings ACM SIGCOMM'98, Vancouver, Canada&nbsp;, September&nbsp;1998.</td></tr>
<tr><td class="author-text" valign="top"><a name="BYE2000">[BYE2000]</a></td>
<td class="author-text">Byers, J., Frumin, M., Horn, G., Luby, M., Mitzenmacher, M., Rotter, A., and W. Shaver, &ldquo;FLID-DL: Congestion Control for Layered Multicast,&rdquo; Proceedings of Second International Workshop on Networked Group Communications (NGC 2000), Palo Alto, CA&nbsp;, November&nbsp;2000.</td></tr>
<tr><td class="author-text" valign="top"><a name="GEM2000">[GEM2000]</a></td>
<td class="author-text">Gemmell, J., Schooler, E., and J. Gray, &ldquo;Fcast Multicast File Distribution,&rdquo; IEEE Network, Vol. 14, No. 1, pp. 58-68&nbsp;, January&nbsp;2000.</td></tr>
<tr><td class="author-text" valign="top"><a name="I-D.ietf-rmt-pi-alc-revised">[I-D.ietf-rmt-pi-alc-revised]</a></td>
<td class="author-text">Luby, M., Watson, M., and L. Vicisano, &ldquo;<a href="http://www.ietf.org/internet-drafts/draft-ietf-rmt-pi-alc-revised-10.txt">Asynchronous Layered Coding (ALC) Protocol Instantiation</a>,&rdquo; draft-ietf-rmt-pi-alc-revised-10 (work in progress), November&nbsp;2009 (<a href="http://www.ietf.org/internet-drafts/draft-ietf-rmt-pi-alc-revised-10.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="Perrig2001">[Perrig2001]</a></td>
<td class="author-text">Perrig, A., Canetti, R., Song, D., and J. Tyger, &ldquo;Efficient and Secure Source Authentication for
          Multicast,&rdquo; Network and Distributed System Security Symposium, NDSS 2001, pp. 35-46&nbsp;, February&nbsp;2001.</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC1305">[RFC1305]</a></td>
<td class="author-text"><a href="mailto:mills@udel.edu">Mills, D.</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc1305">Network Time Protocol (Version 3) Specification, Implementation</a>,&rdquo; RFC&nbsp;1305, March&nbsp;1992 (<a href="http://www.rfc-editor.org/rfc/rfc1305.txt">TXT</a>, <a href="http://www.rfc-editor.org/rfc/rfc1305.pdf">PDF</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC2357">[RFC2357]</a></td>
<td class="author-text"><a href="mailto:mankin@isi.edu">Mankin, A.</a>, <a href="mailto:allyn@mci.net">Romanov, A.</a>, <a href="mailto:sob@harvard.edu">Bradner, S.</a>, and <a href="mailto:vern@ee.lbl.gov">V. Paxson</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc2357">IETF Criteria for Evaluating Reliable Multicast Transport and Application Protocols</a>,&rdquo; RFC&nbsp;2357, June&nbsp;1998 (<a href="http://www.rfc-editor.org/rfc/rfc2357.txt">TXT</a>, <a href="http://xml.resource.org/public/rfc/html/rfc2357.html">HTML</a>, <a href="http://xml.resource.org/public/rfc/xml/rfc2357.xml">XML</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC2974">[RFC2974]</a></td>
<td class="author-text">Handley, M., Perkins, C., and E. Whelan, &ldquo;<a href="http://tools.ietf.org/html/rfc2974">Session Announcement Protocol</a>,&rdquo; RFC&nbsp;2974, October&nbsp;2000 (<a href="http://www.rfc-editor.org/rfc/rfc2974.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC3048">[RFC3048]</a></td>
<td class="author-text">Whetten, B., Vicisano, L., Kermode, R., Handley, M., Floyd, S., and M. Luby, &ldquo;<a href="http://tools.ietf.org/html/rfc3048">Reliable Multicast Transport Building Blocks for One-to-Many Bulk-Data Transfer</a>,&rdquo; RFC&nbsp;3048, January&nbsp;2001 (<a href="http://www.rfc-editor.org/rfc/rfc3048.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC3269">[RFC3269]</a></td>
<td class="author-text">Kermode, R. and L. Vicisano, &ldquo;<a href="http://tools.ietf.org/html/rfc3269">Author Guidelines for Reliable Multicast Transport (RMT) Building Blocks and Protocol Instantiation documents</a>,&rdquo; RFC&nbsp;3269, April&nbsp;2002 (<a href="http://www.rfc-editor.org/rfc/rfc3269.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC3451">[RFC3451]</a></td>
<td class="author-text">Luby, M., Gemmell, J., Vicisano, L., Rizzo, L., Handley, M., and J. Crowcroft, &ldquo;<a href="http://tools.ietf.org/html/rfc3451">Layered Coding Transport (LCT) Building Block</a>,&rdquo; RFC&nbsp;3451, December&nbsp;2002 (<a href="http://www.rfc-editor.org/rfc/rfc3451.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC3453">[RFC3453]</a></td>
<td class="author-text">Luby, M., Vicisano, L., Gemmell, J., Rizzo, L., Handley, M., and J. Crowcroft, &ldquo;<a href="http://tools.ietf.org/html/rfc3453">The Use of Forward Error Correction (FEC) in Reliable Multicast</a>,&rdquo; RFC&nbsp;3453, December&nbsp;2002 (<a href="http://www.rfc-editor.org/rfc/rfc3453.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC3550">[RFC3550]</a></td>
<td class="author-text">Schulzrinne, H., Casner, S., Frederick, R., and V. Jacobson, &ldquo;<a href="http://tools.ietf.org/html/rfc3550">RTP: A Transport Protocol for Real-Time Applications</a>,&rdquo; STD&nbsp;64, RFC&nbsp;3550, July&nbsp;2003 (<a href="http://www.rfc-editor.org/rfc/rfc3550.txt">TXT</a>, <a href="http://www.rfc-editor.org/rfc/rfc3550.ps">PS</a>, <a href="http://www.rfc-editor.org/rfc/rfc3550.pdf">PDF</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC3738">[RFC3738]</a></td>
<td class="author-text">Luby, M. and V. Goyal, &ldquo;<a href="http://tools.ietf.org/html/rfc3738">Wave and Equation Based Rate Control (WEBRC) Building Block</a>,&rdquo; RFC&nbsp;3738, April&nbsp;2004 (<a href="http://www.rfc-editor.org/rfc/rfc3738.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4566">[RFC4566]</a></td>
<td class="author-text">Handley, M., Jacobson, V., and C. Perkins, &ldquo;<a href="http://tools.ietf.org/html/rfc4566">SDP: Session Description Protocol</a>,&rdquo; RFC&nbsp;4566, July&nbsp;2006 (<a href="http://www.rfc-editor.org/rfc/rfc4566.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4607">[RFC4607]</a></td>
<td class="author-text">Holbrook, H. and B. Cain, &ldquo;<a href="http://tools.ietf.org/html/rfc4607">Source-Specific Multicast for IP</a>,&rdquo; RFC&nbsp;4607, August&nbsp;2006 (<a href="http://www.rfc-editor.org/rfc/rfc4607.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RIZ1997a">[RIZ1997a]</a></td>
<td class="author-text">Rizzo, L., &ldquo;Effective Erasure Codes for Reliable Computer Communication
          Protocols,&rdquo; ACM SIGCOMM Computer Communication Review, Vol.27, No.2, pp.24-36&nbsp;, April&nbsp;1997.</td></tr>
<tr><td class="author-text" valign="top"><a name="RIZ1997b">[RIZ1997b]</a></td>
<td class="author-text">Rizzo, L. and L. Vicisano, &ldquo;Reliable Multicast Data Distribution protocol based on
          software FEC techniques,&rdquo; Proceedings of the Fourth IEEE Workshop on the Architecture and Implementation of High Performance Communication Systems, HPCS'97, Chalkidiki Greece&nbsp;, June&nbsp;1997.</td></tr>
<tr><td class="author-text" valign="top"><a name="RIZ2000">[RIZ2000]</a></td>
<td class="author-text">Rizzo, L., &ldquo;PGMCC: A TCP-friendly single-rate multicast congestion
          control scheme,&rdquo; Proceedings of SIGCOMM 2000, Stockholm Sweden&nbsp;, August&nbsp;2000.</td></tr>
<tr><td class="author-text" valign="top"><a name="VIC1998">[VIC1998]</a></td>
<td class="author-text">Vicisano, L., Rizzo, L., and J. Crowcroft, &ldquo;TCP-like Congestion Control for Layered Multicast Data
          Transfer,&rdquo; IEEE Infocom'98, San Francisco, CA&nbsp;, March&nbsp;1998.</td></tr>
</table>

<a name="rfc.authors"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>Authors' Addresses</h3>
<table width="99%" border="0" cellpadding="0" cellspacing="0">
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Michael Luby</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Qualcomm Inc.</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">3165 Kifer Rd.</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Santa Clara, CA  95051</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">US</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:luby@qualcomm.com">luby@qualcomm.com</a></td></tr>
<tr cellpadding="3"><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Mark Watson</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Qualcomm Inc.</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">3165 Kifer Rd.</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Santa Clara, CA  95051</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">US</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:watson@qualcomm.com">watson@qualcomm.com</a></td></tr>
<tr cellpadding="3"><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Lorenzo Vicisano</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Qualcomm Inc.</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">3165 Kifer Rd.</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Santa Clara, CA  95051</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">US</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:vicisano@qualcomm.com">vicisano@qualcomm.com</a></td></tr>
</table>
</body></html>
