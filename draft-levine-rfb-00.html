<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="en"><head><title>The Remote Framebuffer Protocol</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="description" content="The Remote Framebuffer Protocol">
<meta name="keywords" content="vnc, rfb, remote framebuffer, remote GUI">
<meta name="generator" content="xml2rfc v1.35 (http://xml.resource.org/)">
<meta name="viewport" content="width=600;" />
<style type='text/css'><!--
        body {
                font-family: verdana, charcoal, helvetica, arial, sans-serif;
                font-size: 85%;
		max-width: 40em; 
		color: #000; background-color: #FFF;
                margin: 2em;
        }
        h1, h2, h3, h4, h5, h6 {
                font-family: helvetica, monaco, "MS Sans Serif", arial, sans-serif;
                font-weight: bold; font-style: normal;
        }
        h1 { color: #900; background-color: transparent; text-align: right; }
        h3 { color: #333; background-color: transparent; }

        td.RFCbug {
                font-size: x-small; text-decoration: none;
                width: 30px; height: 30px; padding-top: 2px;
                text-align: justify; vertical-align: middle;
                background-color: #000;
        }
        td.RFCbug span.RFC {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: bold; color: #666;
        }
        td.RFCbug span.hotText {
                font-family: charcoal, monaco, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: normal; text-align: center; color: #FFF;
        }

        table.TOCbug { width: 30px; height: 15px; }
        td.TOCbug {
                text-align: center; width: 30px; height: 15px;
                color: #FFF; background-color: #900;
        }
        td.TOCbug a {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, sans-serif;
                font-weight: bold; font-size: x-small; text-decoration: none;
                color: #FFF; background-color: transparent;
        }

        td.header {
                font-family: arial, helvetica, sans-serif; font-size: x-small;
                vertical-align: top; width: 33%;
                color: #FFF; background-color: #666;
        }
        td.author { font-weight: bold; font-size: x-small; margin-left: 4em; }
        td.author-text { font-size: x-small; }

        /* info code from SantaKlauss at http://www.madaboutstyle.com/tooltip2.html */
        a.info {
                /* This is the key. */
                position: relative;
                z-index: 24;
                text-decoration: none;
        }
        a.info:hover {
                z-index: 25;
                color: #FFF; background-color: #900;
        }
        a.info span { display: none; }
        a.info:hover span.info {
                /* The span will display just on :hover state. */
                display: block;
                position: absolute;
                font-size: smaller;
                top: 2em; left: -5em; width: 15em;
                padding: 2px; border: 1px solid #333;
                color: #900; background-color: #EEE;
                text-align: left;
        }

        a { font-weight: bold; }
        a:link    { color: #900; background-color: transparent; }
        a:visited { color: #633; background-color: transparent; }
        a:active  { color: #633; background-color: transparent; }

        p { margin-left: 2em; margin-right: 2em; }
        p.copyright { font-size: x-small; }
        p.toc { font-size: 85%;
		max-width: 40em; 
		font-weight: bold; margin-left: 3em; }
        table.toc { margin: 0 0 0 3em; padding: 0; border: 0; vertical-align: text-top; }
        td.toc { font-size: 85%;
		max-width: 40em; 
		font-weight: bold; vertical-align: text-top; }

        ol.text { margin-left: 2em; margin-right: 2em; }
        ul.text { margin-left: 2em; margin-right: 2em; }
        li      { margin-left: 3em; }

        /* RFC-2629 <spanx>s and <artwork>s. */
        em     { font-style: italic; }
        strong { font-weight: bold; }
        dfn    { font-weight: bold; font-style: normal; }
        cite   { font-weight: normal; font-style: normal; }
        tt     { color: #036; }
        tt, pre, pre dfn, pre em, pre cite, pre span {
                font-family: "Courier New", Courier, monospace; font-size: small;
        }
        pre {
                text-align: left; padding: 4px;
                color: #000; background-color: #CCC;
        }
        pre dfn  { color: #900; }
        pre em   { color: #66F; background-color: #FFC; font-weight: normal; }
        pre .key { color: #33C; font-weight: bold; }
        pre .id  { color: #900; }
        pre .str { color: #000; background-color: #CFF; }
        pre .val { color: #066; }
        pre .rep { color: #909; }
        pre .oth { color: #000; background-color: #FCF; }
        pre .err { background-color: #FCC; }

        /* RFC-2629 <texttable>s. */
        table.all, table.full, table.headers, table.none {
                font-size: 85%;
		max-width: 40em; 
		text-align: center; border-width: 2px;
                vertical-align: top; border-collapse: collapse;
        }
        table.all, table.full { border-style: solid; border-color: black; }
        table.headers, table.none { border-style: none; }
        th {
                font-weight: bold; border-color: black;
                border-width: 2px 2px 3px 2px;
        }
        table.all th, table.full th { border-style: solid; }
        table.headers th { border-style: none none solid none; }
        table.none th { border-style: none; }
        table.all td {
                border-style: solid; border-color: #333;
                border-width: 1px 2px;
        }
        table.full td, table.headers td, table.none td { border-style: none; }

        hr { height: 1px; }
        hr.insert {
                width: 80%; border-style: none; border-width: 0;
                color: #CCC; background-color: #CCC;
        }
--></style>
</head>
<body>
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<table summary="layout" width="66%" border="0" cellpadding="0" cellspacing="0"><tr><td><table summary="layout" width="100%" border="0" cellpadding="2" cellspacing="1">
<tr><td class="header">Internet Engineering Task Force</td><td class="header">T. Richardson</td></tr>
<tr><td class="header">Internet-Draft</td><td class="header">RealVNC Ltd.</td></tr>
<tr><td class="header">Intended status: Informational</td><td class="header">J. Levine</td></tr>
<tr><td class="header">Expires: May 22, 2009</td><td class="header">Taughannock Networks</td></tr>
<tr><td class="header">&nbsp;</td><td class="header">November 18, 2008</td></tr>
</table></td></tr></table>
<h1><br />The Remote Framebuffer Protocol<br />draft-levine-rfb-00</h1>

<h3>Status of this Memo</h3>
<p>
By submitting this Internet-Draft,
each author represents that any applicable patent or other IPR claims of which
he or she is aware have been or will be disclosed,
and any of which he or she becomes aware will be disclosed,
in accordance with Section&nbsp;6 of BCP&nbsp;79.
This document may not be modified,
and derivative works of it may not be created.</p>
<p>
Internet-Drafts are working documents of the Internet Engineering
Task Force (IETF), its areas, and its working groups.
Note that other groups may also distribute working documents as
Internet-Drafts.</p>
<p>
Internet-Drafts are draft documents valid for a maximum of six months
and may be updated, replaced, or obsoleted by other documents at any time.
It is inappropriate to use Internet-Drafts as reference material or to cite
them other than as &ldquo;work in progress.&rdquo;</p>
<p>
The list of current Internet-Drafts can be accessed at
<a href='http://www.ietf.org/ietf/1id-abstracts.txt'>http://www.ietf.org/ietf/1id-abstracts.txt</a>.</p>
<p>
The list of Internet-Draft Shadow Directories can be accessed at
<a href='http://www.ietf.org/shadow.html'>http://www.ietf.org/shadow.html</a>.</p>
<p>
This Internet-Draft will expire on May 22, 2009.</p>

<h3>Abstract</h3>

<p>RFB ("remote framebuffer") is a simple protocol for remote access
	to graphical user interfaces which allows a client to view and
	control a window system on another computer.
	Because it works at the framebuffer
	level RFB is applicable to all windowing systems and applications.
	This document describes the protocol used to communicate between
	an RFB client and RFB server.
	RFB is the protocol used in VNC, Virtual Network Computing.
      
</p><a name="toc"></a><br /><hr />
<h3>Table of Contents</h3>
<p class="toc">
<a href="#anchor1">1.</a>&nbsp;
Introduction<br />
<a href="#anchor2">2.</a>&nbsp;
Initial Connection<br />
<a href="#anchor3">3.</a>&nbsp;
Display Protocol<br />
<a href="#anchor4">4.</a>&nbsp;
Input Protocol<br />
<a href="#anchor5">5.</a>&nbsp;
Representation of Pixel Data<br />
<a href="#anchor6">6.</a>&nbsp;
Protocol Versions and Extensions<br />
<a href="#anchor7">7.</a>&nbsp;
Protocol Messages<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor8">7.1.</a>&nbsp;
Handshake Messages<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor9">7.1.1.</a>&nbsp;
ProtocolVersion Handshake<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#securityhs">7.1.2.</a>&nbsp;
Security Handshake<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor10">7.1.3.</a>&nbsp;
SecurityResult Handshake<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sectypes">7.2.</a>&nbsp;
Security Types<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor11">7.2.1.</a>&nbsp;
None<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#vncauth">7.2.2.</a>&nbsp;
VNC Authentication<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#initmsgs">7.3.</a>&nbsp;
Initialization Messages<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor12">7.3.1.</a>&nbsp;
ClientInit<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#serverinit">7.3.2.</a>&nbsp;
ServerInit<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#pixelformat">7.4.</a>&nbsp;
Pixel Format Data Structure<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor13">7.5.</a>&nbsp;
Client to Server Messages<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#setpixelformat">7.5.1.</a>&nbsp;
SetPixelFormat<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor14">7.5.2.</a>&nbsp;
SetEncodings<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor15">7.5.3.</a>&nbsp;
FramebufferUpdateRequest<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor16">7.5.4.</a>&nbsp;
KeyEvent<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor17">7.5.5.</a>&nbsp;
PointerEvent<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor18">7.5.6.</a>&nbsp;
ClientCutText<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor19">7.6.</a>&nbsp;
Server to Client Messages<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor20">7.6.1.</a>&nbsp;
FramebufferUpdate<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#setcolormapentries">7.6.2.</a>&nbsp;
SetColorMapEntries<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor21">7.6.3.</a>&nbsp;
Bell<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor22">7.6.4.</a>&nbsp;
ServerCutText<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#encodings">7.7.</a>&nbsp;
Encodings<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor23">7.7.1.</a>&nbsp;
Raw Encoding<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor24">7.7.2.</a>&nbsp;
CopyRect Encoding<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor25">7.7.3.</a>&nbsp;
RRE Encoding<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor26">7.7.4.</a>&nbsp;
Hextile Encoding<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor27">7.7.5.</a>&nbsp;
TRLE encoding<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor28">7.7.6.</a>&nbsp;
ZRLE encoding<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#pseudo-encodings">7.8.</a>&nbsp;
Pseudo-Encodings<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor29">7.8.1.</a>&nbsp;
Cursor pseudo-encoding<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor30">7.8.2.</a>&nbsp;
DesktopSize pseudo-encoding<br />
<a href="#anchor31">8.</a>&nbsp;
Security<br />
<a href="#Acknowledgements">9.</a>&nbsp;
Acknowledgements<br />
<a href="#rfc.references1">10.</a>&nbsp;
References<br />
<a href="#oldver">Appendix&nbsp;A.</a>&nbsp;
Differences in earlier protocol versions<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor33">A.1.</a>&nbsp;
Differences in the version 3.3 protocol<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor34">A.2.</a>&nbsp;
Differences in the version 3.7 protocol<br />
<a href="#rfc.authors">&#167;</a>&nbsp;
Authors' Addresses<br />
<a href="#rfc.copyright">&#167;</a>&nbsp;
Intellectual Property and Copyright Statements<br />
</p>
<br clear="all" />

<a name="anchor1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1"></a><h3>1.&nbsp;
Introduction</h3>

<p>RFB ("remote framebuffer") is a simple protocol for remote
	access to graphical user interfaces.  Because it works at the
	framebuffer level it is applicable to all windowing systems
	and applications, including X11, Windows and Macintosh.  RFB
	is the protocol used in VNC (Virtual Network Computing).
	The protocol is widely implemented and has had fairly good
	interoperability.
      
</p>
<p>The remote endpoint where the user sits (typically with a
	display, keyboard, and pointer) is called the RFB client or
	viewer.  The endpoint where changes to the framebuffer
	originate (i.e., the windowing system and applications) is
	known as the RFB server.
</p>
<p>RFB is a "thin client" protocol.  The emphasis in the
	design of the RFB protocol is to make very few requirements of
	the client.  In this way, clients can run on the widest range
	of hardware, and the task of implementing a client is made as
	simple as possible.
</p>
<p>The protocol also makes the client stateless.  If a client
	disconnects from a given server and subsequently reconnects to
	that same server, the state of the user interface is
	preserved.  Furthermore, a different client endpoint can be
	used to connect to the same RFB server.  At the new endpoint,
	the user will see exactly the same graphical user interface as
	at the original endpoint.  In effect, the interface to the
	user's applications becomes completely mobile.  Wherever
	suitable network connectivity exists, the user can access
	their own personal applications, and the state of these
	applications is preserved between accesses from different
	locations.  This provides the user with a familiar, uniform
	view of the computing infrastructure wherever they go.
</p>
<p>The RFB protocol has evolved over the past decade, and has
	been implemented several times, including at least one open
	source version.  This document describes the RFB protocol as
	actually implemented, so that future implementers can
	interoperate with existing clients and servers.
</p>
<a name="anchor2"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2"></a><h3>2.&nbsp;
Initial Connection</h3>

<p>An RFB server is typically a long-lived process that
	maintains the state of a framebuffer.  RFB clients typically
	connect, communicate with the server for a period of time to
	use and manipulate the framebuffer, then disconnect.  A
	subsequent RFB session will then pick up where a prior session
	left off, with the state of the framebuffer intact.
</p>
<p>An RFB client contacts the server on TCP port 5900.  On
	systems with multiple RFB servers, server N typically listens
	on port 5900+N, analogous to the way that X Window servers
	listen on port 6000+N.
</p>
<p>Some browser-based clients use a Java application to run the
	RFB protocol.  RFB servers sometimes provide a simple HTTP
	server on port 5800 that provides the requisite Java
	applet.
</p>
<p>In some cases, the initial roles of the client and server are
	reversed, with the RFB client listening on port 5500, and the
	RFB server contacting the RFB client.  Once the connection is
	established, the two sides take their normal roles, with the
	RFB server sending the first handshake message.
</p>
<p>IANA has allocated port 5900 to the RFB protocol; the other
	port numbers have been used informally and do not match IANA
	allocations.
</p>
<a name="anchor3"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3"></a><h3>3.&nbsp;
Display Protocol</h3>

<p>The display side of the protocol is based around a single
	graphics primitive: "put a rectangle of pixel data at a given
	x,y position".  This might seem an inefficient way of drawing
	many user interface components.  However, allowing various
	different encodings for the pixel data gives us a large degree
	of flexibility in how to trade off various parameters such as
	network bandwidth, client drawing speed and server processing
	speed.
</p>
<p>A sequence of these rectangles makes
	a framebuffer update (or
	simply update).  An update
	represents a change from one valid framebuffer state to
	another, so in some ways is similar to a frame of video.  The
	rectangles in an update are usually but not always disjoint.
</p>
<p>The update protocol is demand-driven by the client.  That is,
	an update is only sent from the server to the client in
	response to an explicit request from the client.  This gives
	the protocol an adaptive quality.  The slower the client and
	the network are, the lower the rate of updates.  With typical
	applications, changes to the same area of the framebuffer tend
	to happen soon after one another.  With a slow client or
	network, transient states of the framebuffer can be ignored,
	resulting in less network traffic and less drawing for the
	client.
</p>
<p>After the initial handshake sequence, the protocol is asynchronous,
	with each side sending messages as needed.  The
	server must not send unsolicited updates.  An update must only be
	sent in response to a request from the client.  When several requests
	from the client are outstanding, a single update from the server may
	satisfy all of them.
</p>
<a name="anchor4"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4"></a><h3>4.&nbsp;
Input Protocol</h3>

<p>The input side of the protocol is based on a standard
	workstation model of a keyboard and multi-button pointing
	device.  Input events are simply sent to the server by the
	client whenever the user presses a key or pointer button, or
	whenever the pointing device is moved.  These input events can
	also be synthesised from other non-standard I/O devices.  For
	example, a pen-based handwriting recognition engine might
	generate keyboard events.
      
</p>
<a name="anchor5"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5"></a><h3>5.&nbsp;
Representation of Pixel Data</h3>

<p>Initial interaction between the RFB client and server
	involves a negotiation of the format and encoding of the pixel
	data that will be sent.  This negotiation has been designed to
	make the job of the client as easy as possible.  The server
	must always be able to supply pixel data in the form the
	client wants.  However if the client is able to cope equally
	with several different formats or encodings, it may choose one
	which is easier for the server to produce.
      
</p>
<p>Pixel format refers to the representation of individual
	colors by pixel values.  The most common pixel formats are
	24-bit or 16-bit "true color", where bit-fields within the
	pixel value translate directly to red, green and blue
	intensities, and 8-bit "color map" (palette) where the pixel values
	are indices into a 256 entry table that contains the actual RGB
	intensities.
      
</p>
<p>Encoding refers to the way that a rectangle of pixel data
	will be sent to the client.  Every rectangle of pixel data is
	prefixed by a header giving the X,Y position of the rectangle
	on the screen, the width and height of the rectangle, and an
	encoding type which specifies the encoding of the pixel data.
	The data itself then follows using the specified encoding.
      
</p>
<p>The encoding types defined at present are: Raw, CopyRect, RRE,
	TRLE, Hextile, and ZRLE.
	In practice current servers use the ZRLE, TRLE,
	and CopyRect encodings since they provide the best
	compression for typical desktops.
	Clients generally also support Hextile, which was often used by
	older RFB servers that didn't support TRLE.
	See <a class='info' href='#encodings'>Section&nbsp;7.7<span> (</span><span class='info'>Encodings</span><span>)</span></a> for a
	description of each of the encodings.
      
</p>
<a name="anchor6"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6"></a><h3>6.&nbsp;
Protocol Versions and Extensions</h3>

<p>The RFB protocol has evolved through three published versions: 3.3, 3.7, and 3.8.
	This document primarily documents the final version 3.8; differences from the
	earlier versions, which are minor, are described in <a class='info' href='#oldver'>Appendix&nbsp;A<span> (</span><span class='info'>Differences in earlier protocol versions</span><span>)</span></a>.
	Under no circumstances should an implementation use a protocol version
	number other than one defined in this document. Over the years, different
	implementations of RFB have attempted to use different version numbers to add
	undocumented extensions, with the result being that to interoperate,
	any unknown 3.x version must be treated as 3.3, so it is not possible to add
	a 3.9 or higher version in a backward compatible fashion.
	Future evolution of RFB will use 4.x version numbers.
      
</p>
<p>It is not necessary to change the protocol version number to extend the protocol.
	The protocol can be extended within an existing version by:
</p>
<p></p>
<blockquote class="text"><dl>
<dt>New encodings</dt>
<dd>
	  A new encoding type can be added to the protocol
	  relatively easily while maintaining compatibility with existing clients and
	  servers.  Existing servers will simply ignore requests for a new encoding which
	  they don't support.  Existing clients will never request the new encoding so
	  will never see rectangles encoded that way.
	
</dd>
<dt>Pseudo encodings</dt>
<dd>
	  In addition to genuine encodings, a client can request
	  a "pseudo-encoding" to declare to the server that it supports a certain
	  extension to the protocol.  A server which does not support the extension will
	  simply ignore the pseudo-encoding.  Note that this means the client must assume
	  that the server does not support the extension until it gets some
	  extension-specific confirmation from the server.  See
	  <a class='info' href='#pseudo-encodings'>Section&nbsp;7.8<span> (</span><span class='info'>Pseudo-Encodings</span><span>)</span></a> for a description of current pseudo-encodings.
	
</dd>
<dt>New security types</dt>
<dd>
	  Adding a new security type gives full
	  flexibility in modifying the behavior of the protocol without sacrificing
	  compatibility with existing clients and servers.  A client and server which
	  agree on a new security type can effectively talk whatever protocol they like
	  after that - it doesn't necessarily have to be anything like the RFB protocol.
	
</dd>
</dl></blockquote><p>
      
</p>
<p>RealVNC maintains a registry of encoding and security type IDs
	available at http://www.realvnc.com/rfbids.html.
	Implementers may contact RealVNC to obtain an ID for a new type.
</p>
<a name="anchor7"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7"></a><h3>7.&nbsp;
Protocol Messages</h3>

<p>The RFB protocol can operate over any reliable transport, either byte-stream or
    message-based.  It usually operates over a TCP/IP connection.  There are
    three stages to the protocol.  First is the handshaking phase, the purpose of
    which is to agree upon the protocol version and the type of security to be
    used.  The second stage is an initialisation phase where the client and server
    exchange ClientInit and ServerInit messages.  The final stage is
    the normal protocol interaction.  The client can send whichever messages it
    wants, and may receive messages from the server as a result.  All these
    messages begin with a message-type byte, followed by message-specific data.
  
</p>
<p>The following descriptions of protocol messages use the basic
    types U8, U16, U32, S8, S16, and S32.  These represent
    respectively 8, 16 and 32-bit unsigned integers and 8, 16 and
    32-bit signed integers.  All multiple byte integers (other than
    pixel values themselves) are in big endian order (most significant
    byte first).
    Some messages use arrays of the basic types, with the number of
    entries in the array determined from fields preceding the array.
  
</p>
<p>The type PIXEL means a pixel value of bytesPerPixel bytes,
    where bytesPerPixel is the number of bits-per-pixel divided by 8.
    The bits-per-pixel is agreed by the client and server,
    either in the ServerInit message (<a class='info' href='#serverinit'>Section&nbsp;7.3.2<span> (</span><span class='info'>ServerInit</span><span>)</span></a>)
    or a SetPixelFormat message (<a class='info' href='#setpixelformat'>Section&nbsp;7.5.1<span> (</span><span class='info'>SetPixelFormat</span><span>)</span></a>).
    See <a class='info' href='#pixelformat'>Section&nbsp;7.4<span> (</span><span class='info'>Pixel Format Data Structure</span><span>)</span></a> for the detailed description of
    the pixel format.
  
</p>
<a name="anchor8"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.1"></a><h3>7.1.&nbsp;
Handshake Messages</h3>

<p>When an RFB client and server first connect, they exchange a sequence of
      handshake messages that determine the protocol version, what type of connection
      security if any to use, a password check if the security type requires it,
      and some initialization information.
</p>
<a name="anchor9"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.1.1"></a><h3>7.1.1.&nbsp;
ProtocolVersion Handshake</h3>

<p>Handshaking begins by the server sending the client a
	ProtocolVersion message.  This lets the client know which is
	the highest RFB protocol version number supported by the
	server.  The client then replies with a similar message giving
	the version number of the protocol which should actually be
	used (which may be different to that quoted by the server).  A
	client should never request a protocol version higher than
	that offered by the server.  It is intended that both clients
	and servers may provide some level of backwards compatibility
	by this mechanism.
</p>
<p>The only published protocol versions at this time are 3.3,
	3.7, and 3.8.  Other version numbers are reported by some
	servers and clients, but should be interpreted as 3.3.
	Addition of a new encoding or pseudo-encoding type does not
	require a change in protocol version, since a server can
	simply ignore encodings it does not understand.
</p>
<p>The ProtocolVersion message consists of 12 bytes interpreted
	as a string of ASCII characters in the format "RFB xxx.yyy\n"
	where xxx and yyy are the major and minor version numbers,
	left padded with zeros:
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
    RFB 003.008\n (hex 52 46 42 20 30 30 33 2e 30 30 38 0a)
</pre></div>
<a name="securityhs"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.1.2"></a><h3>7.1.2.&nbsp;
Security Handshake</h3>

<p>Once the protocol version has been decided, the server and
	client must agree on the type of security to be used on the
	connection.  The server lists the security types which it
	supports:
      
</p><table class="full" align="center" border="0" cellpadding="2" cellspacing="2">
<col align="left"><col align="left"><col align="left">
<tr><th align="left">No. of bytes</th><th align="left">Type [Value]</th><th align="left">Description</th></tr>
<tr>
<td align="left">1</td>
<td align="left">U8</td>
<td align="left">number-of-security-types</td>
</tr>
<tr>
<td align="left">number-of-security-types</td>
<td align="left">U8 array</td>
<td align="left">security-types</td>
</tr>
</table>
<br clear="all" />

<p>If the server listed at least one valid security type
	supported by the client, the client sends back a single byte
	indicating which security type is to be used on the
	connection:
      
</p><table class="full" align="center" border="0" cellpadding="2" cellspacing="2">
<col align="left"><col align="left"><col align="left">
<tr><th align="left">No. of bytes</th><th align="left">Type [Value]</th><th align="left">Description</th></tr>
<tr>
<td align="left">1</td>
<td align="left">U8</td>
<td align="left">security-type
	</td>
</tr>
</table>
<br clear="all" />

<p>If number-of-security-types is zero, then for some reason the
	connection failed (e.g. the server cannot support the desired
	protocol version).  This is followed by a string describing
	the reason (where a string is specified as a length followed
	by that many ASCII characters):
      
</p><table class="full" align="center" border="0" cellpadding="2" cellspacing="2">
<col align="left"><col align="left"><col align="left">
<tr><th align="left">No. of bytes</th><th align="left">Type [Value]</th><th align="left">Description</th></tr>
<tr>
<td align="left">4</td>
<td align="left">U32</td>
<td align="left">reason-length</td>
</tr>
<tr>
<td align="left"> reason-length</td>
<td align="left">U8 array</td>
<td align="left">reason-string</td>
</tr>
</table>
<br clear="all" />

<p>The server closes the connection after sending the reason-string.
	
</p>
<p style='text-align: center'>The security types defined in this document are:
</p><table class="full" align="center" border="0" cellpadding="2" cellspacing="2">
<col align="left"><col align="left">
<tr><th align="left">Number</th><th align="left">Name</th></tr>
<tr>
<td align="left">0</td>
<td align="left">Invalid</td>
</tr>
<tr>
<td align="left">1</td>
<td align="left">None</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">VNC Authentication</td>
</tr>
</table>
<br clear="all" />

<p>Other security types exist but are not publicly documented.
	
</p>
<p>Once the security-type has been decided, data specific to
	  that security-type follows (see
	  <a class='info' href='#sectypes'>Section&nbsp;7.2<span> (</span><span class='info'>Security Types</span><span>)</span></a> for details).  At the end of the
	  security handshaking phase, the protocol normally continues
	  with the SecurityResult message.
	
</p>
<p>Note that after the security handshaking phase, it is
	  possible that further communication is over an encrypted or
	  otherwise altered channel if the two ends agree on an extended
	  security type beyond the ones described here.
	
</p>
<a name="anchor10"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.1.3"></a><h3>7.1.3.&nbsp;
SecurityResult Handshake</h3>

<p>The server sends a word to inform the client whether the
	security handshaking was successful.
      
</p><table class="full" align="center" border="0" cellpadding="2" cellspacing="2">
<col align="left"><col align="left"><col align="left">
<tr><th align="left">No. of bytes</th><th align="left">Type [Value]</th><th align="left">Description</th></tr>
<tr>
<td align="left">4</td>
<td align="left">U32</td>
<td align="left"> status:</td>
</tr>
<tr>
<td align="left">&nbsp;</td>
<td align="left">0</td>
<td align="left">OK</td>
</tr>
<tr>
<td align="left">&nbsp;</td>
<td align="left">1</td>
<td align="left">failed</td>
</tr>
</table>
<br clear="all" />

<p>If successful, the protocol passes to the initialization phase
	(<a class='info' href='#initmsgs'>Section&nbsp;7.3<span> (</span><span class='info'>Initialization Messages</span><span>)</span></a>).
      
</p>
<p>
	If unsuccessful, the server sends a string
	describing the reason for the failure, and then closes the connection:
      
</p><table class="full" align="center" border="0" cellpadding="2" cellspacing="2">
<col align="left"><col align="left"><col align="left">
<tr><th align="left">No. of bytes</th><th align="left">Type [Value]</th><th align="left">Description</th></tr>
<tr>
<td align="left">4</td>
<td align="left">U32</td>
<td align="left">reason-length</td>
</tr>
<tr>
<td align="left"> reason-length</td>
<td align="left">U8 array</td>
<td align="left">reason-string</td>
</tr>
</table>
<br clear="all" />

<a name="sectypes"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.2"></a><h3>7.2.&nbsp;
Security Types</h3>

<p>Two security types are defined here.
</p>
<a name="anchor11"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.2.1"></a><h3>7.2.1.&nbsp;
None</h3>

<p>No authentication is needed.
      The protocol continues with the  SecurityResult message.
    
</p>
<a name="vncauth"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.2.2"></a><h3>7.2.2.&nbsp;
VNC Authentication</h3>

<p>VNC authentication is to be used.
      The server sends a random 16-byte challenge:
    
</p><table class="full" align="center" border="0" cellpadding="2" cellspacing="2">
<col align="left"><col align="left"><col align="left">
<tr><th align="left">No. of bytes</th><th align="left">Type [Value]</th><th align="left">Description</th></tr>
<tr>
<td align="left">16</td>
<td align="left">U8</td>
<td align="left">challenge</td>
</tr>
</table>
<br clear="all" />

<p>The client encrypts the challenge with DES, using a password
      supplied by the user as the key.  To form the key, the password
      is truncated to eight characters, or padded with null bytes on
      the right.  The client then sends the resulting 16-byte
      response:
    
</p><table class="full" align="center" border="0" cellpadding="2" cellspacing="2">
<col align="left"><col align="left"><col align="left">
<tr><th align="left">No. of bytes</th><th align="left">Type [Value]</th><th align="left">Description</th></tr>
<tr>
<td align="left">16</td>
<td align="left">U8</td>
<td align="left">response</td>
</tr>
</table>
<br clear="all" />

<p>The protocol continues with the  SecurityResult message.
</p>
<p>This type of authentication is known to be cryptographically
      weak for the modern Internet; many
      implementations will want to use a stronger security.
</p>
<a name="initmsgs"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.3"></a><h3>7.3.&nbsp;
Initialization Messages</h3>

<p>Once the client and server agree on and perhaps validate a security type,
    the protocol passes to the initialization stage.
    The client sends a ClientInit
    message. Then the server sends a ServerInit message.
  
</p>
<a name="anchor12"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.3.1"></a><h3>7.3.1.&nbsp;
ClientInit</h3>
<table class="full" align="center" border="0" cellpadding="2" cellspacing="2">
<col align="left"><col align="left"><col align="left">
<tr><th align="left">No. of bytes</th><th align="left">Type [Value]</th><th align="left">Description</th></tr>
<tr>
<td align="left">1</td>
<td align="left">U8</td>
<td align="left"> shared-flag</td>
</tr>
</table>
<br clear="all" />

<p>Shared-flag is non-zero (true) if the server should try to share
      the desktop by leaving other clients connected, zero (false) if it
      should give exclusive access to this client by disconnecting all other
      clients.
</p>
<a name="serverinit"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.3.2"></a><h3>7.3.2.&nbsp;
ServerInit</h3>

<p>After receiving the ClientInit message, the server sends a
      ServerInit message.  This tells the client the width and height of the
      server's framebuffer, its pixel format and the name associated with
      the desktop:
</p><table class="full" align="center" border="0" cellpadding="2" cellspacing="2">
<col align="left"><col align="left"><col align="left">
<tr><th align="left">No. of bytes</th><th align="left">Type [Value]</th><th align="left">Description</th></tr>
<tr>
<td align="left">2</td>
<td align="left">U16</td>
<td align="left">framebuffer-width in pixels</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">U16</td>
<td align="left">framebuffer-height in pixels</td>
</tr>
<tr>
<td align="left">16</td>
<td align="left">PIXEL_FORMAT</td>
<td align="left">server-pixel-format</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left">U32</td>
<td align="left">name-length</td>
</tr>
<tr>
<td align="left">name-length</td>
<td align="left">U8 array</td>
<td align="left">name-string</td>
</tr>
</table>
<br clear="all" />

<p>Server-pixel-format specifies the server's natural pixel format.  This
      pixel format will be used unless the client requests a different format using
      the  SetPixelFormat message (<a class='info' href='#setpixelformat'>Section&nbsp;7.5.1<span> (</span><span class='info'>SetPixelFormat</span><span>)</span></a>).
    
</p>
<a name="pixelformat"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.4"></a><h3>7.4.&nbsp;
Pixel Format Data Structure</h3>

<p>Several server to client messages include a PIXEL_FORMAT,
    a 16 byte structure that describes the way a pixel is transmited.
</p><table class="full" align="center" border="0" cellpadding="2" cellspacing="2">
<col align="left"><col align="left"><col align="left">
<tr><th align="left">No. of bytes</th><th align="left">Type [Value]</th><th align="left">Description</th></tr>
<tr>
<td align="left">1</td>
<td align="left">U8</td>
<td align="left">bits-per-pixel</td>
</tr>
<tr>
<td align="left">1</td>
<td align="left">U8</td>
<td align="left">depth</td>
</tr>
<tr>
<td align="left">1</td>
<td align="left">U8</td>
<td align="left">big-endian-flag</td>
</tr>
<tr>
<td align="left">1</td>
<td align="left">U8</td>
<td align="left">true-color-flag</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">U16</td>
<td align="left">red-max</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">U16</td>
<td align="left">green-max</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">U16</td>
<td align="left">blue-max</td>
</tr>
<tr>
<td align="left">1</td>
<td align="left">U8</td>
<td align="left">red-shift</td>
</tr>
<tr>
<td align="left">1</td>
<td align="left">U8</td>
<td align="left">green-shift</td>
</tr>
<tr>
<td align="left">1</td>
<td align="left">U8</td>
<td align="left">blue-shift</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left">&nbsp;</td>
<td align="left">padding</td>
</tr>
</table>
<br clear="all" />

<p>Bits-per-pixel is the number of bits used for each pixel value
    on the wire.  This must be greater than or equal to the depth
    which is the number of useful bits in the pixel value.
    Currently bits-per-pixel must be 8, 16 or 32.  Big-endian-flag
    is non-zero (true) if multi-byte pixels are interpreted as big
    endian.  Although the depth should be consistent with the
    bits-per-pixel and the various -max values, clients do not use
    it when interpreting pixel data.
  
</p>
<p>If true-color-flag is non-zero (true) then the last six items
    specify how to extract the red, green and blue intensities from
    the pixel value.  Red-max is the maximum red value and must
    be 2^N - 1 where N is the number of bits used for red.  Note the
    -max values are always in big endian order.  Red-shift is the number of
    shifts needed to get the red value in a pixel to the least
    significant bit.  Green-max, green-shift and blue-max,
    blue-shift are similar for green and blue.  For example, to find
    the red value (between 0 and red-max) from a given pixel, do the
    following:
  
</p>
<p></p>
<ul class="text">
<li>
	Swap the pixel value according to big-endian-flag, e.g., if
	big-endian-flag is zero (false) and host byte order is big
	endian, then swap.
      
</li>
<li>
	Shift right by red-shift.
      
</li>
<li>
	AND with  red-max (in host byte order).
      
</li>
</ul>

<p>If true-color-flag is zero (false) then the server uses pixel
    values which are not directly composed from the red, green and
    blue intensities, but which serve as indices into a color map.
    Entries in the color map are set by the server using the
    SetColorMapEntries message (See <a class='info' href='#setcolormapentries'>Section&nbsp;7.6.2<span> (</span><span class='info'>SetColorMapEntries</span><span>)</span></a>).
  
</p>
<a name="anchor13"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.5"></a><h3>7.5.&nbsp;
Client to Server Messages</h3>

<p>The client to server message types defined in this document are:
</p><table class="full" align="center" border="0" cellpadding="2" cellspacing="2">
<col align="left"><col align="left">
<tr><th align="left">Number</th><th align="left">Name</th></tr>
<tr>
<td align="left">0</td>
<td align="left">SetPixelFormat</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">SetEncodings</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left">FramebufferUpdateRequest</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left">KeyEvent</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left">PointerEvent</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left">ClientCutText</td>
</tr>
</table>
<br clear="all" />

<p>Other message types exist but are not publicly documented.
    Before sending a message other than those described in this
    document a client must have determined that the server supports
    the relevant extension by receiving an appropriate
    extension-specific confirmation from the server.
  
</p>
<a name="setpixelformat"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.5.1"></a><h3>7.5.1.&nbsp;
SetPixelFormat</h3>

<p>Sets the format in which pixel values should be sent in
      FramebufferUpdate messages.  If the client does not send a
      SetPixelFormat message then the server sends pixel values in its
      natural format as specified in the ServerInit message
      (<a class='info' href='#serverinit'>Section&nbsp;7.3.2<span> (</span><span class='info'>ServerInit</span><span>)</span></a>).
    
</p>
<p>If true-color-flag is zero (false) then this indicates that a
      "color map" is to be used.  The server can set any of the entries in
      the color map using the SetColorMapEntries message
      (<a class='info' href='#setcolormapentries'>Section&nbsp;7.6.2<span> (</span><span class='info'>SetColorMapEntries</span><span>)</span></a>).  Immediately after the client
      has sent this message the contents of the
      color map are undefined, even if entries had
      previously been set by the server.
    
</p><table class="full" align="center" border="0" cellpadding="2" cellspacing="2">
<col align="left"><col align="left"><col align="left">
<tr><th align="left">No. of bytes</th><th align="left">Type [Value]</th><th align="left">Description</th></tr>
<tr>
<td align="left">1</td>
<td align="left">U8  [0]</td>
<td align="left">message-type</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left">&nbsp;</td>
<td align="left">padding</td>
</tr>
<tr>
<td align="left">16</td>
<td align="left">PIXEL_FORMAT</td>
<td align="left">pixel-format</td>
</tr>
</table>
<br clear="all" />

<p style='text-align: center'>PIXEL_FORMAT is as described in <a class='info' href='#pixelformat'>Section&nbsp;7.4<span> (</span><span class='info'>Pixel Format Data Structure</span><span>)</span></a>.
</p>
<a name="anchor14"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.5.2"></a><h3>7.5.2.&nbsp;
SetEncodings</h3>

<p>Sets the encoding types in which pixel data can be sent by the
      server.  The order of the encoding types given in this message
      is a hint by the client as to its preference (the first encoding
      specified being most preferred).  The server may or may not
      choose to make use of this hint.  Pixel data may always be sent
      in raw encoding even if not specified explicitly here.
    
</p>
<p>In addition to genuine encodings, a client can request
      "pseudo-encodings" to declare to the server that it supports
      certain extensions to the protocol.  A server which does not
      support the extension will simply ignore the pseudo-encoding.
      Note that this means the client must assume that the server does
      not support the extension until it gets some extension-specific
      confirmation from the server.
    
</p>
<p>See <a class='info' href='#encodings'>Section&nbsp;7.7<span> (</span><span class='info'>Encodings</span><span>)</span></a> for a description of
      each encoding and <a class='info' href='#pseudo-encodings'>Section&nbsp;7.8<span> (</span><span class='info'>Pseudo-Encodings</span><span>)</span></a> for
      the meaning of pseudo-encodings.
    
</p><table class="full" align="center" border="0" cellpadding="2" cellspacing="2">
<col align="left"><col align="left"><col align="left">
<tr><th align="left">No. of bytes</th><th align="left">Type [Value]</th><th align="left">Description</th></tr>
<tr>
<td align="left">1</td>
<td align="left">U8  [2]</td>
<td align="left">message-type</td>
</tr>
<tr>
<td align="left">1</td>
<td align="left">&nbsp;</td>
<td align="left">padding</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">U16</td>
<td align="left">number-of-encodings
      </td>
</tr>
</table>
<br clear="all" />

<p>followed by  number-of-encodings repetitions of the following:
</p><table class="full" align="center" border="0" cellpadding="2" cellspacing="2">
<col align="left"><col align="left"><col align="left">
<tr><th align="left">No. of bytes</th><th align="left">Type [Value]</th><th align="left">Description</th></tr>
<tr>
<td align="left">4</td>
<td align="left">S32</td>
<td align="left">encoding-type</td>
</tr>
</table>
<br clear="all" />

<a name="anchor15"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.5.3"></a><h3>7.5.3.&nbsp;
FramebufferUpdateRequest</h3>

<p>Notifies the server that the client is interested in the area
      of the framebuffer specified by x-position, y-position, width
      and height.  The server usually responds to a
      FramebufferUpdateRequest by sending a FramebufferUpdate.  A
      single FramebufferUpdate may be sent in reply to several
      FramebufferUpdateRequests.
    
</p>
<p>The server assumes that the client keeps a copy of all parts of
      the framebuffer in which it is interested.  This means that
      normally the server only needs to send incremental updates to
      the client.
    
</p>
<p>If the client has lost the contents of a particular area which
      it needs, then the client sends a FramebufferUpdateRequest with
      incremental set to zero (false).  This requests that the server
      send the entire contents of the specified area as soon as
      possible.  The area will not be updated using the CopyRect
      encoding.
    
</p>
<p>If the client has not lost any contents of the area in which it
      is interested, then it sends a FramebufferUpdateRequest with
      incremental set to non-zero (true).  If and when there are
      changes to the specified area of the framebuffer, the server
      will send a FramebufferUpdate.  Note that there may be an
      indefinite period between the FramebufferUpdateRequest and the
      FramebufferUpdate.
    
</p>
<p>In the case of a fast client, the client may want to regulate
      the rate at which it sends incremental FramebufferUpdateRequests
      to avoid excessive network traffic.
    
</p><table class="full" align="center" border="0" cellpadding="2" cellspacing="2">
<col align="left"><col align="left"><col align="left">
<tr><th align="left">No. of bytes</th><th align="left">Type [Value]</th><th align="left">Description</th></tr>
<tr>
<td align="left">1</td>
<td align="left">U8  [3]</td>
<td align="left">message-type</td>
</tr>
<tr>
<td align="left">1</td>
<td align="left">U8</td>
<td align="left">incremental</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">U16</td>
<td align="left"> x-position</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">U16</td>
<td align="left"> y-position</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">U16</td>
<td align="left"> width</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">U16</td>
<td align="left"> height</td>
</tr>
</table>
<br clear="all" />

<a name="anchor16"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.5.4"></a><h3>7.5.4.&nbsp;
KeyEvent</h3>

<p>A key press or release.   Down-flag is non-zero (true) if the key is now
      pressed, zero (false) if it is now released. The  key itself is specified
      using the "keysym" values defined by the X Window System, even if the
      client or server is not running X.
    
</p><table class="full" align="center" border="0" cellpadding="2" cellspacing="2">
<col align="left"><col align="left"><col align="left">
<tr><th align="left">No. of bytes</th><th align="left">Type [Value]</th><th align="left">Description</th></tr>
<tr>
<td align="left">1</td>
<td align="left">U8  [4]</td>
<td align="left">message-type</td>
</tr>
<tr>
<td align="left">1</td>
<td align="left">U8</td>
<td align="left">down-flag</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">&nbsp;</td>
<td align="left">padding</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left">U32</td>
<td align="left">key</td>
</tr>
</table>
<br clear="all" />

<p>For most ordinary keys, the keysym is the same as the
      corresponding ASCII value.  For full details, see
      <a class='info' href='#XLIBREF'>[XLIBREF]<span> (</span><span class='info'>Nye, A., &ldquo;XLIB Reference Manual R5,&rdquo; June&nbsp;1994.</span><span>)</span></a> or see the header file
      &lt;X11/keysymdef.h&gt; in the X Window System distribution.
      Some other common keys are:
    
</p><table class="full" align="center" border="0" cellpadding="2" cellspacing="2">
<col align="left"><col align="left">
<tr><th align="left">Key name</th><th align="left">Keysym value (hex)</th></tr>
<tr>
<td align="left">BackSpace</td>
<td align="left">0xff08</td>
</tr>
<tr>
<td align="left">Tab</td>
<td align="left">0xff09</td>
</tr>
<tr>
<td align="left">Return or Enter</td>
<td align="left">0xff0d</td>
</tr>
<tr>
<td align="left">Escape</td>
<td align="left">0xff1b</td>
</tr>
<tr>
<td align="left">Insert</td>
<td align="left">0xff63</td>
</tr>
<tr>
<td align="left">Delete</td>
<td align="left">0xffff</td>
</tr>
<tr>
<td align="left">Home</td>
<td align="left">0xff50</td>
</tr>
<tr>
<td align="left">End</td>
<td align="left">0xff57</td>
</tr>
<tr>
<td align="left">Page Up</td>
<td align="left">0xff55</td>
</tr>
<tr>
<td align="left">Page Down</td>
<td align="left">0xff56</td>
</tr>
<tr>
<td align="left">Left</td>
<td align="left">0xff51</td>
</tr>
<tr>
<td align="left">Up</td>
<td align="left">0xff52</td>
</tr>
<tr>
<td align="left">Right</td>
<td align="left">0xff53</td>
</tr>
<tr>
<td align="left">Down</td>
<td align="left">0xff54</td>
</tr>
<tr>
<td align="left"> </td>
<td align="left"> </td>
</tr>
<tr>
<td align="left">F1</td>
<td align="left">0xffbe</td>
</tr>
<tr>
<td align="left">F2</td>
<td align="left">0xffbf</td>
</tr>
<tr>
<td align="left">F3</td>
<td align="left">0xffc0</td>
</tr>
<tr>
<td align="left">F4</td>
<td align="left">0xffc1</td>
</tr>
<tr>
<td align="left">...</td>
<td align="left">...</td>
</tr>
<tr>
<td align="left">F12</td>
<td align="left">0xffc9</td>
</tr>
<tr>
<td align="left">Shift (left)</td>
<td align="left">0xffe1</td>
</tr>
<tr>
<td align="left">Shift (right)</td>
<td align="left">0xffe2</td>
</tr>
<tr>
<td align="left">Control (left)</td>
<td align="left">0xffe3</td>
</tr>
<tr>
<td align="left">Control (right)</td>
<td align="left">0xffe4</td>
</tr>
<tr>
<td align="left">Meta (left)</td>
<td align="left">0xffe7</td>
</tr>
<tr>
<td align="left">Meta (right)</td>
<td align="left">0xffe8</td>
</tr>
<tr>
<td align="left">Alt (left)</td>
<td align="left">0xffe9</td>
</tr>
<tr>
<td align="left">Alt (right)</td>
<td align="left">0xffea</td>
</tr>
</table>
<br clear="all" />

<p>The interpretation of keysyms is a complex area.  In order to
      be as widely interoperable as possible the following guidelines
      should be followed:
    
</p>
<p></p>
<ul class="text">
<li>
	  The "shift state" (i.e. whether either of the Shift
	  keysyms is down) should only be used as a hint when
	  interpreting a keysym.  For example, on a US keyboard the
	  '#' character is shifted, but on a UK keyboard it is not.  A
	  server with a US keyboard receiving a '#' character from a
	  client with a UK keyboard will not have been sent any shift
	  presses.  In this case, it is likely that the server will
	  internally need to simulate a shift press on its local
	  system in order to get a '#' character and not a '3'.
	
</li>
<li>
	  The difference between upper and lower case keysyms is
	  significant.  This is unlike some of the keyboard processing
	  in the X Window System which treats them as the same.  For
	  example, a server receiving an uppercase 'A' keysym without
	  any shift presses should interpret it as an uppercase 'A'.
	  Again this may involve an internal simulated shift
	  press.
</li>
<li>
	  Servers should ignore "lock" keysyms such as CapsLock and
	  NumLock where possible.  Instead they should interpret each
	  character-based keysym according to its case.
</li>
<li>
	  Unlike Shift, the state of modifier keys such as Control and
	  Alt should be taken as modifying the interpretation of other
	  keysyms.  Note that there are no keysyms for ASCII control
	  characters such as Ctrl-A - these should be generated by
	  viewers sending a Control press followed by an 'a' press.
	
</li>
<li>
	  On a viewer where modifiers like Control and Alt can also be
	  used to generate character-based keysyms, the viewer may
	  need to send extra "release" events in order that the
	  keysym is interpreted correctly.  For example, on a German
	  PC keyboard, Ctrl-Alt-Q generates the '@' character.  In
	  this case, the viewer needs to send simulated release events
	  for Control and Alt in order that the '@' character is
	  interpreted correctly, since Ctrl-Alt-@ may mean
	  something completely different to the server.
	
</li>
<li>
	  There is no universal standard for "backward tab" in the X
	  Window System.  On some systems shift+tab gives the keysym
	  "ISO_Left_Tab", on others it gives a private "BackTab" keysym
	  and on others it gives "Tab" and applications tell from the shift
	  state that it means backward-tab rather than forward-tab.  In the RFB
	  protocol the latter approach is preferred.  Viewers should generate a
	  shifted Tab rather than ISO_Left_Tab.  However, to be
	  backwards-compatible with existing viewers, servers should also
	  recognise ISO_Left_Tab as meaning a shifted Tab.
</li>
<li>
	  Modern versions of the X Window system handle keysyms for
	  Unicode characters, consisting of the Unicode character with
	  the hex 1000000 bit set.
	  For maximum compatibility, if a key has both a Unicode and
	  a legacy encoding, clients should send the legacy encoding.
</li>
</ul>

<a name="anchor17"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.5.5"></a><h3>7.5.5.&nbsp;
PointerEvent</h3>

<p>Indicates either pointer movement or a pointer button press
	or release.  The pointer is now at ( x-position, y-position),
	and the current state of buttons 1 to 8 are represented by
	bits 0 to 7 of button-mask respectively, 0 meaning up, 1
	meaning down (pressed).
      
</p>
<p>On a conventional mouse, buttons 1, 2 and 3 correspond to the
	left, middle and right buttons on the mouse.  On a wheel
	mouse, each step of the wheel upwards is represented by a
	press and release of button 4, and each step downwards is
	represented by a press and release of button 5.
      
</p><table class="full" align="center" border="0" cellpadding="2" cellspacing="2">
<col align="left"><col align="left"><col align="left">
<tr><th align="left">No. of bytes</th><th align="left">Type [Value]</th><th align="left">Description</th></tr>
<tr>
<td align="left">1</td>
<td align="left">U8  [5]</td>
<td align="left">message-type</td>
</tr>
<tr>
<td align="left">1</td>
<td align="left">U8</td>
<td align="left">button-mask</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">U16</td>
<td align="left">x-position</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">U16</td>
<td align="left">y-position</td>
</tr>
</table>
<br clear="all" />

<a name="anchor18"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.5.6"></a><h3>7.5.6.&nbsp;
ClientCutText</h3>

<p>RFB provides limited support for synchronizing the "cut buffer" of
	selected text between client and server.
	This message tells the server that the client has new
	ISO 8859-1 (Latin-1) text in its cut
	buffer.  Ends of lines are represented by the newline
	character (hex 0a) alone.  No carriage-return (hex 0d) is used.
	There is no way to transfer text outside the Latin-1
	character set.
</p><table class="full" align="center" border="0" cellpadding="2" cellspacing="2">
<col align="left"><col align="left"><col align="left">
<tr><th align="left">No. of bytes</th><th align="left">Type [Value]</th><th align="left">Description</th></tr>
<tr>
<td align="left">1</td>
<td align="left">U8  [6]</td>
<td align="left">message-type</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left">&nbsp;</td>
<td align="left">padding</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left">U32</td>
<td align="left">length</td>
</tr>
<tr>
<td align="left"> length</td>
<td align="left">U8 array</td>
<td align="left">text</td>
</tr>
</table>
<br clear="all" />

<a name="anchor19"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.6"></a><h3>7.6.&nbsp;
Server to Client Messages</h3>

<p>The server to client message types defined in this document are:
</p><table class="full" align="center" border="0" cellpadding="2" cellspacing="2">
<col align="left"><col align="left">
<tr><th align="left">Number</th><th align="left">Name</th></tr>
<tr>
<td align="left">0</td>
<td align="left">FramebufferUpdate</td>
</tr>
<tr>
<td align="left">1</td>
<td align="left">SetColorMapEntries</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">Bell</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left">ServerCutText</td>
</tr>
</table>
<br clear="all" />

<p>Other private message types exist but are not publicly
    documented. Before sending a message other than those described in
    this document a server must have determined that the client
    supports the relevant extension by receiving some
    extension-specific confirmation from the client - usually a
    request for a given pseudo-encoding.
</p>
<a name="anchor20"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.6.1"></a><h3>7.6.1.&nbsp;
FramebufferUpdate</h3>

<p>A framebuffer update consists of a sequence of rectangles of
      pixel data which the client should put into its framebuffer.  It
      is sent in response to a FramebufferUpdateRequest from the
      client.  Note that there may be an indefinite period between the
      FramebufferUpdateRequest and the FramebufferUpdate.
</p><table class="full" align="center" border="0" cellpadding="2" cellspacing="2">
<col align="left"><col align="left"><col align="left">
<tr><th align="left">No. of bytes</th><th align="left">Type [Value]</th><th align="left">Description</th></tr>
<tr>
<td align="left">1</td>
<td align="left">U8  [0]</td>
<td align="left">message-type</td>
</tr>
<tr>
<td align="left">1</td>
<td align="left">&nbsp;</td>
<td align="left">padding</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">U16</td>
<td align="left">number-of-rectangles</td>
</tr>
</table>
<br clear="all" />

<p>This header is followed by number-of-rectangles rectangles of pixel
      data.  Each rectangle starts with a rectangle header:
    
</p><table class="full" align="center" border="0" cellpadding="2" cellspacing="2">
<col align="left"><col align="left"><col align="left">
<tr><th align="left">No. of bytes</th><th align="left">Type [Value]</th><th align="left">Description</th></tr>
<tr>
<td align="left">2</td>
<td align="left">U16</td>
<td align="left">x-position</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">U16</td>
<td align="left">y-position</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">U16</td>
<td align="left">width</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">U16</td>
<td align="left">height</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left">S32</td>
<td align="left">encoding-type</td>
</tr>
</table>
<br clear="all" />

<p>The rectangle header is
      followed by the pixel data in the specified encoding.  See
      <a class='info' href='#encodings'>Section&nbsp;7.7<span> (</span><span class='info'>Encodings</span><span>)</span></a> for the format of the data
      for each encoding and <a class='info' href='#pseudo-encodings'>Section&nbsp;7.8<span> (</span><span class='info'>Pseudo-Encodings</span><span>)</span></a>
      for the meaning of pseudo-encodings.
    
</p>
<a name="setcolormapentries"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.6.2"></a><h3>7.6.2.&nbsp;
SetColorMapEntries</h3>

<p>When the pixel format uses a "color map", this message tells
      the client that the specified pixel values should be mapped to
      the given RGB values.
      Note that this message may only update part of the color map.  This
      message should not be sent by the server until after the client has sent
      at least one FramebufferUpdateRequest, and only when the agreed pixel
      format uses a color map.
    
</p>
<p>Color map values are always 16 bits, with the range of values running
      from 0 to 65535, regardless of the display hardware in use.
      The color map value for white, for example, is 65535,65535,65535.
</p>
<p>The message starts with a header describing the range of colormap
      entries to be updated.
</p><table class="full" align="center" border="0" cellpadding="2" cellspacing="2">
<col align="left"><col align="left"><col align="left">
<tr><th align="left">No. of bytes</th><th align="left">Type [Value]</th><th align="left">Description</th></tr>
<tr>
<td align="left">1</td>
<td align="left">U8  [1]</td>
<td align="left">message-type</td>
</tr>
<tr>
<td align="left">1</td>
<td align="left">&nbsp;</td>
<td align="left">padding</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">U16</td>
<td align="left">first-color</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">U16</td>
<td align="left">number-of-colors</td>
</tr>
</table>
<br clear="all" />

<p>This header is followed by number-of-colors RGB values, each
      of which is in this format:
</p><table class="full" align="center" border="0" cellpadding="2" cellspacing="2">
<col align="left"><col align="left"><col align="left">
<tr><th align="left">No. of bytes</th><th align="left">Type [Value]</th><th align="left">Description</th></tr>
<tr>
<td align="left">2</td>
<td align="left">U16</td>
<td align="left">red</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">U16</td>
<td align="left">green</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">U16</td>
<td align="left">blue</td>
</tr>
</table>
<br clear="all" />

<a name="anchor21"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.6.3"></a><h3>7.6.3.&nbsp;
Bell</h3>

<p>Make an audible signal on the client if it provides one.
</p><table class="full" align="center" border="0" cellpadding="2" cellspacing="2">
<col align="left"><col align="left"><col align="left">
<tr><th align="left">No. of bytes</th><th align="left">Type [Value]</th><th align="left">Description</th></tr>
<tr>
<td align="left">1</td>
<td align="left">U8  [2]</td>
<td align="left">message-type</td>
</tr>
</table>
<br clear="all" />

<a name="anchor22"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.6.4"></a><h3>7.6.4.&nbsp;
ServerCutText</h3>

<p>The server has new ISO 8859-1 (Latin-1) text in its cut buffer.
    Ends of lines are represented by the newline character
    (hex 0a) alone.  No carriage-return (hex 0d) is used.  There is
    no way to transfer text outside the Latin-1 character set.
</p><table class="full" align="center" border="0" cellpadding="2" cellspacing="2">
<col align="left"><col align="left"><col align="left">
<tr><th align="left">No. of bytes</th><th align="left">Type [Value]</th><th align="left">Description</th></tr>
<tr>
<td align="left">1</td>
<td align="left">U8  [3]</td>
<td align="left">message-type</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left">&nbsp;</td>
<td align="left">padding</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left">U32</td>
<td align="left">length</td>
</tr>
<tr>
<td align="left"> length</td>
<td align="left">U8 array</td>
<td align="left">text</td>
</tr>
</table>
<br clear="all" />

<a name="encodings"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.7"></a><h3>7.7.&nbsp;
Encodings</h3>

<p>The encodings defined in this document are:
</p><table class="full" align="center" border="0" cellpadding="2" cellspacing="2">
<col align="left"><col align="left">
<tr><th align="left">Number</th><th align="left">Name</th></tr>
<tr>
<td align="left">0</td>
<td align="left">Raw</td>
</tr>
<tr>
<td align="left">1</td>
<td align="left">CopyRect</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">RRE</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left">Hextile</td>
</tr>
<tr>
<td align="left">15</td>
<td align="left">TRLE</td>
</tr>
<tr>
<td align="left">16</td>
<td align="left">ZRLE</td>
</tr>
<tr>
<td align="left">-239</td>
<td align="left">Cursor pseudo-encoding</td>
</tr>
<tr>
<td align="left">-223</td>
<td align="left">DesktopSize pseudo-encoding</td>
</tr>
</table>
<br clear="all" />

<p>Other encoding types exist but are not publicly documented.
</p>
<a name="anchor23"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.7.1"></a><h3>7.7.1.&nbsp;
Raw Encoding</h3>

<p>The simplest encoding type is raw pixel data.  In this case the
      data consists of width*height pixel values (where width and
      height are the width and height of the rectangle).  The values
      simply represent each pixel in left-to-right scan line order.
      All RFB clients must be able to handle pixel data in this raw
      encoding, and RFB servers should only produce raw encoding
      unless the client specifically asks for some other encoding
      type.
</p><table class="full" align="center" border="0" cellpadding="2" cellspacing="2">
<col align="left"><col align="left"><col align="left">
<tr><th align="left">No. of bytes</th><th align="left">Type [Value]</th><th align="left">Description</th></tr>
<tr>
<td align="left">width*height*bytesPerPixel</td>
<td align="left">PIXEL array</td>
<td align="left">pixels</td>
</tr>
</table>
<br clear="all" />

<a name="anchor24"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.7.2"></a><h3>7.7.2.&nbsp;
CopyRect Encoding</h3>

<p>The CopyRect (copy rectangle) encoding is a very simple and
      efficient encoding which can be used when the client already has the
      same pixel data elsewhere in its framebuffer.  The encoding on the
      wire simply consists of an X,Y coordinate.  This gives a position in
      the framebuffer from which the client can copy the rectangle of pixel
      data.  This can be used in a variety of situations, the most common
      of which are when the user moves a window across the screen, and when
      the contents of a window are scrolled.
    
</p><table class="full" align="center" border="0" cellpadding="2" cellspacing="2">
<col align="left"><col align="left"><col align="left">
<tr><th align="left">No. of bytes</th><th align="left">Type [Value]</th><th align="left">Description</th></tr>
<tr>
<td align="left">2</td>
<td align="left">U16</td>
<td align="left">src-x-position</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">U16</td>
<td align="left"> src-y-position</td>
</tr>
</table>
<br clear="all" />

<p>For maximum compatibility the source rectangle of a CopyRect
      should not include
      pixels updated by previous entries in the same FramebufferUpdate
      message.
</p>
<a name="anchor25"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.7.3"></a><h3>7.7.3.&nbsp;
RRE Encoding</h3>

<p>Note: RRE encoding is obsolescent. In general,
      ZRLE and TRLE encoding are more compact.
</p>
<p>RRE stands for rise-and-run-length encoding. As its name
      implies, it is essentially a two-dimensional analogue of
      run-length encoding.  RRE-encoded rectangles arrive at the
      client in a form which can be rendered immediately
      by the simplest of graphics engines.  RRE is not
      appropriate for complex desktops, but can be useful in some
      situations.
</p>
<p>The basic idea behind RRE is the partitioning of a rectangle of
      pixel data into rectangular subregions (subrectangles) each of
      which consists of pixels of a single value and the union of
      which comprises the original rectangular region.  The
      near-optimal partition of a given rectangle into such
      subrectangles is relatively easy to compute.
    
</p>
<p>The encoding consists of a background pixel value, Vb
      (typically the most prevalent pixel value in the rectangle) and
      a count N, followed by a list of N subrectangles, each of which
      consists of a tuple &lt;v,x,y,w,h&gt; where v (which should be
      different from Vb) is the pixel value, (x,y) are the coordinates
      of the subrectangle relative to the top-left corner of the
      rectangle, and (w,h) are the width and height of the
      subrectangle.  The client can render the original rectangle by
      drawing a filled rectangle of the background pixel value and
      then drawing a filled rectangle corresponding to each
      subrectangle.
</p>
<p>On the wire, the data begins with the header:
</p><table class="full" align="center" border="0" cellpadding="2" cellspacing="2">
<col align="left"><col align="left"><col align="left">
<tr><th align="left">No. of bytes</th><th align="left">Type [Value]</th><th align="left">Description</th></tr>
<tr>
<td align="left">4</td>
<td align="left">U32</td>
<td align="left"> number-of-subrectangles</td>
</tr>
<tr>
<td align="left">bytesPerPixel</td>
<td align="left">PIXEL</td>
<td align="left"> background-pixel-value</td>
</tr>
</table>
<br clear="all" />

<p>This is followed by number-of-subrectangles instances of the
      following structure:
    
</p><table class="full" align="center" border="0" cellpadding="2" cellspacing="2">
<col align="left"><col align="left"><col align="left">
<tr><th align="left">No. of bytes</th><th align="left">Type [Value]</th><th align="left">Description</th></tr>
<tr>
<td align="left">bytesPerPixel</td>
<td align="left">PIXEL</td>
<td align="left">subrect-pixel-value</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">U16</td>
<td align="left">x-position</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">U16</td>
<td align="left">y-position</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">U16</td>
<td align="left">width</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">U16</td>
<td align="left">height</td>
</tr>
</table>
<br clear="all" />

<a name="anchor26"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.7.4"></a><h3>7.7.4.&nbsp;
Hextile Encoding</h3>

<p>Note: Hextile encoding is obsolescent. In general,
      ZRLE and TRLE encoding are more compact.
</p>
<p>Hextile is a variation on RRE.  Rectangles are split up into
      16x16 tiles, allowing the dimensions of the subrectangles to be
      specified in 4 bits each, 16 bits in total.  The rectangle is
      split into tiles starting at the top left going in
      left-to-right, top-to-bottom order.  The encoded contents of the
      tiles simply follow one another in the predetermined order.  If
      the width of the whole rectangle is not an exact multiple of 16
      then the width of the last tile in each row will be
      correspondingly smaller.  Similarly if the height of the whole
      rectangle is not an exact multiple of 16 then the height of each
      tile in the final row will also be smaller.
    
</p>
<p>Each tile is either encoded as raw pixel data, or as a
      variation on RRE.  Each tile has a background pixel value, as
      before.  However, the background pixel value does not need to be
      explicitly specified for a given tile if it is the same as the
      background of the previous tile.  If all of the subrectangles of
      a tile have the same pixel value, this can be specified once as
      a foreground pixel value for the whole tile.  As with the
      background, the foreground pixel value can be left unspecified,
      meaning it is carried over from the previous tile.
    
</p>
<p>The data consists of each tile encoded in order.  Each tile
      begins with a subencoding type byte, which is a mask made up of a
      number of bits:
</p><table class="full" align="center" border="0" cellpadding="2" cellspacing="2">
<col align="left"><col align="left"><col align="left">
<tr><th align="left">No. of bytes</th><th align="left">Type [Value]</th><th align="left">Description</th></tr>
<tr>
<td align="left">1</td>
<td align="left">U8</td>
<td align="left">subencoding-mask:</td>
</tr>
<tr>
<td align="left">&nbsp;</td>
<td align="left">   [1]</td>
<td align="left">Raw</td>
</tr>
<tr>
<td align="left">&nbsp;</td>
<td align="left">   [2]</td>
<td align="left">BackgroundSpecified</td>
</tr>
<tr>
<td align="left">&nbsp;</td>
<td align="left">   [4]</td>
<td align="left">ForegroundSpecified</td>
</tr>
<tr>
<td align="left">&nbsp;</td>
<td align="left">   [8]</td>
<td align="left">AnySubrects</td>
</tr>
<tr>
<td align="left">&nbsp;</td>
<td align="left">  [16]</td>
<td align="left">SubrectsColored</td>
</tr>
</table>
<br clear="all" />

<p>If the Raw bit is set then the other bits are irrelevant;
      width*height pixel values follow (where width and height are
      the width and height of the tile).  Otherwise the other bits in
      the mask are as follows:
</p>
<p></p>
<blockquote class="text"><dl>
<dt>BackgroundSpecified</dt>
<dd>
	  If set, a pixel value of bytesPerPixel bytes follows which
	  specifies the background color for this tile.
	  The first non-raw tile in a rectangle must have this bit
	  set.  If this bit isn't set then the background is the same
	  as the last tile.
</dd>
<dt>ForegroundSpecified</dt>
<dd>
	  If set, a pixel value of bytesPerPixel bytes follows which
	  specifies the foreground color to be used for all
	  subrectangles in this tile.
</dd>
<dt></dt>
<dd>If this bit is set then the SubrectsColored bit must be zero.
</dd>
<dt>AnySubrects</dt>
<dd>
	  If set, a single byte follows giving the number of
	  subrectangles following.  If not set, there are no
	  subrectangles (i.e.  the whole tile is just solid background
	  color).
</dd>
<dt>SubrectsColored</dt>
<dd>
	  If set then each subrectangle is preceded by a pixel value
	  giving the color of that subrectangle, so a subrectangle is:
	
</dd><table class="full" align="center" border="0" cellpadding="2" cellspacing="2">
<col align="left"><col align="left"><col align="left">
<tr><th align="left">No. of bytes</th><th align="left">Type [Value]</th><th align="left">Description</th></tr>
<tr>
<td align="left">bytesPerPixel</td>
<td align="left">PIXEL</td>
<td align="left">subrect-pixel-value</td>
</tr>
<tr>
<td align="left">1</td>
<td align="left">U8</td>
<td align="left"> x-and-y-position</td>
</tr>
<tr>
<td align="left">1</td>
<td align="left">U8</td>
<td align="left"> width-and-height</td>
</tr>
</table>
<br clear="all" />

<dt></dt>
<dd>If not set, all subrectangles are the same color, the
	  foreground color; if the ForegroundSpecified bit wasn't set then the
	  foreground is the same as the last tile.  A subrectangle is:
	
</dd><table class="full" align="center" border="0" cellpadding="2" cellspacing="2">
<col align="left"><col align="left"><col align="left">
<tr><th align="left">No. of bytes</th><th align="left">Type [Value]</th><th align="left">Description</th></tr>
<tr>
<td align="left">1</td>
<td align="left">U8</td>
<td align="left"> x-and-y-position</td>
</tr>
<tr>
<td align="left">1</td>
<td align="left">U8</td>
<td align="left"> width-and-height</td>
</tr>
</table>
<br clear="all" />

</dl></blockquote>

<p>The position and size of each subrectangle is specified in two
      bytes, x-and-y-position and width-and-height.  The
      most-significant four bits of x-and-y-position specify the X
      position, the least-significant specify the Y position.  The
      most-significant four bits of width-and-height specify the width
      minus one, the least-significant specify the height minus one.
    
</p>
<a name="anchor27"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.7.5"></a><h3>7.7.5.&nbsp;
TRLE encoding</h3>

<p>TRLE stands for Tiled Run-Length Encoding, and combines tiling,
      palettisation and run-length encoding.  The rectangle is divided
      into tiles of 16x16 pixels in left-to-right, top-to-bottom
      order, similar to hextile.  If the width of the rectangle is not
      an exact multiple of 16 then the width of the last tile in each
      row is smaller, and if the height of the rectangle is not an
      exact multiple of 16 then the height of each tile in the final
      row is smaller.
    
</p>
<p>TRLE makes use of a new type CPIXEL
      (compressed pixel).  This is the same as a PIXEL for the agreed
      pixel format, except where true-color-flag is non-zero,
      bits-per-pixel is 32, depth is 24 or less and all of the bits
      making up the red, green and blue intensities fit in either the
      least significant 3 bytes or the most significant 3 bytes.  In
      this case a CPIXEL is only 3 bytes long, and contains the least
      significant or the most significant 3 bytes as appropriate.
      bytesPerCPixel is the number of bytes in a CPIXEL.
    
</p>
<p>Each tile begins with a subencoding type byte.  The top bit
      of this byte is set if the tile has been run-length encoded, clear
      otherwise.  The bottom seven bits indicate the size of the palette
      used: zero means no palette, one means that the tile is of a single
      color, and 2 to 127 indicate a palette of that size.  The special values
      129 and 127 indicate that the palette is to be reused from the
      previous tile, with and without RLE respectively.
      
</p>
<p>Note: in this discussion, the div(a,b) function means the result
    of dividing a/b truncated to an integer.
  
</p>
<p>The possible values of subencoding are:
</p>
<blockquote class="text"><dl>
<dt>0</dt>
<dd>Raw pixel data.  width*height pixel values follow
    (where width and height are the width and height of the tile):
  
</dd><table class="full" align="center" border="0" cellpadding="2" cellspacing="2">
<col align="left"><col align="left"><col align="left">
<tr><th align="left">No. of bytes</th><th align="left">Type [Value]</th><th align="left">Description</th></tr>
<tr>
<td align="left">width*height*BytesPerCPixel</td>
<td align="left">CPIXEL array</td>
<td align="left">pixels</td>
</tr>
</table>
<br clear="all" />

<dt>1</dt>
<dd>A solid tile consisting of a single color.  The pixel
    value follows:
  
</dd><table class="full" align="center" border="0" cellpadding="2" cellspacing="2">
<col align="left"><col align="left"><col align="left">
<tr><th align="left">No. of bytes</th><th align="left">Type [Value]</th><th align="left">Description</th></tr>
<tr>
<td align="left">bytesPerCPixel</td>
<td align="left">CPIXEL</td>
<td align="left">pixelValue</td>
</tr>
</table>
<br clear="all" />

<dt>2 to 16</dt>
<dd>Packed palette types.  The palleteSize is the
    value of the subencoding, which is followed by the palette,
    consisting of paletteSize pixel values.  The packed pixels
    follow, with each pixel represented as a bit field yielding a
    0-based index into the palette.  For
    paletteSize 2, a 1-bit field is used, for paletteSize 3 or 4 a
    2-bit field is used, and for paletteSize from 5 to 16 a 4-bit field
    is used.  The bit fields are packed into bytes, with the most significant
    bits representing the leftmost pixel (i.e. big endian).  For tiles
    not a multiple of 8, 4 or 2 pixels wide (as appropriate), padding
    bits are used to align each row to an exact number of bytes.
  
</dd><table class="full" align="center" border="0" cellpadding="2" cellspacing="2">
<col align="left"><col align="left"><col align="left">
<tr><th align="left">No. of bytes</th><th align="left">Type [Value]</th><th align="left">Description</th></tr>
<tr>
<td align="left">paletteSize*bytesPerCPixel</td>
<td align="left">CPIXEL array</td>
<td align="left">palette</td>
</tr>
<tr>
<td align="left">m</td>
<td align="left">U8 array</td>
<td align="left">packedPixels</td>
</tr>
</table>
<br clear="all" />

<dt></dt>
<dd>where m is the number of bytes representing the packed pixels.  For
    paletteSize of 2 this is div(width+7,8)*height, for
    paletteSize of 3 or 4 this is div(width+3,4)*height, or for
    paletteSize of 5 to 16 this is div(width+1,2)*height.
  
</dd>
<dt>17 to 126</dt>
<dd>Unused. (Packed palettes of these sizes would
    offer no advantage over palette RLE).
</dd>
<dt>127</dt>
<dd>Packed palette with the palette reused from the previous
    tile.  The subencoding byte is
    followed by the packed pixels as described above for packed palette
    types.
</dd>
<dt>128</dt>
<dd>Plain RLE.  The data
    consists of a number of runs, repeated
    until the tile is done.  Runs may continue from the end of one row
    to the beginning of the next.  Each run is a represented by a
    single pixel value followed by the length of the run.  The length
    is represented as one or more bytes.  The length is calculated as
    one more than the sum of all the bytes representing the length.
    Any byte value other than 255 indicates the final byte.  So for
    example length 1 is represented as [0], 255 as [254], 256 as
    [255,0], 257 as [255,1], 510 as [255,254], 511 as [255,255,0] and
    so on.
  
</dd><table class="full" align="center" border="0" cellpadding="2" cellspacing="2">
<col align="left"><col align="left"><col align="left">
<tr><th align="left">No. of bytes</th><th align="left">Type [Value]</th><th align="left">Description</th></tr>
<tr>
<td align="left">bytesPerCPixel</td>
<td align="left">CPIXEL</td>
<td align="left">pixelValue</td>
</tr>
<tr>
<td align="left">div(runLength - 1, 255)</td>
<td align="left">U8 array</td>
<td align="left">255</td>
</tr>
<tr>
<td align="left">1</td>
<td align="left">U8</td>
<td align="left">(runLength-1) mod 255</td>
</tr>
</table>
<br clear="all" />

<dt>129</dt>
<dd>Palette RLE with the palette reused from the previous
    tile.  Followed by a number of runs, repeated until the tile is done, as
    described below for 130 to 255.
  
</dd>
<dt>130 to 255</dt>
<dd>Palette RLE.  Followed by the palette, consisting
    of paletteSize = (subencoding - 128) pixel values:
  
</dd><table class="full" align="center" border="0" cellpadding="2" cellspacing="2">
<col align="left"><col align="left"><col align="left">
<tr><th align="left">No. of bytes</th><th align="left">Type [Value]</th><th align="left">Description</th></tr>
<tr>
<td align="left">paletteSize*bytesPerCPixel</td>
<td align="left">CPIXEL array</td>
<td align="left">palette</td>
</tr>
</table>
<br clear="all" />

<dt></dt>
<dd>Following the palette is, as with plain RLE, of a number of runs,
    repeated until the tile
    is done.  A run of length one is represented simply by a palette index:
  
</dd><table class="full" align="center" border="0" cellpadding="2" cellspacing="2">
<col align="left"><col align="left"><col align="left">
<tr><th align="left">No. of bytes</th><th align="left">Type [Value]</th><th align="left">Description</th></tr>
<tr>
<td align="left">1</td>
<td align="left">U8</td>
<td align="left">paletteIndex</td>
</tr>
</table>
<br clear="all" />

<dt></dt>
<dd>A run of length more than one is represented by a palette index
    with the top bit set, followed by the length of the run as for
    plain RLE.
  
</dd><table class="full" align="center" border="0" cellpadding="2" cellspacing="2">
<col align="left"><col align="left"><col align="left">
<tr><th align="left">No. of bytes</th><th align="left">Type [Value]</th><th align="left">Description</th></tr>
<tr>
<td align="left">1</td>
<td align="left">U8</td>
<td align="left">paletteIndex + 128</td>
</tr>
<tr>
<td align="left">div(runLength - 1, 255)</td>
<td align="left">U8 array</td>
<td align="left">255</td>
</tr>
<tr>
<td align="left">1</td>
<td align="left">U8</td>
<td align="left">(runLength-1) mod 255</td>
</tr>
</table>
<br clear="all" />

</dl></blockquote>
<a name="anchor28"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.7.6"></a><h3>7.7.6.&nbsp;
ZRLE encoding</h3>

<p>ZRLE stands for Zlib (see <a class='info' href='#RFC1950'>[RFC1950]<span> (</span><span class='info'>Deutsch, L. and J-L. Gailly, &ldquo;ZLIB Compressed Data Format Specification version 3.3,&rdquo; May&nbsp;1996.</span><span>)</span></a> and
    <a class='info' href='#RFC1951'>[RFC1951]<span> (</span><span class='info'>Deutsch, P., &ldquo;DEFLATE Compressed Data Format Specification version 1.3,&rdquo; May&nbsp;1996.</span><span>)</span></a>) Run-Length Encoding, and combines an
    encoding similar to TRLE with zlib compression.  On the wire, the
    rectangle consists of zlib-compressed data which continues until
    the end of the message.  A single zlib "stream" object is used
    for a given RFB protocol connection, so that ZRLE rectangles must
    be encoded and decoded strictly in order.

</p><table class="full" align="center" border="0" cellpadding="2" cellspacing="2">
<col align="left"><col align="left"><col align="left">
<tr><th align="left">No. of bytes</th><th align="left">Type [Value]</th><th align="left">Description</th></tr>
<tr>
<td align="left">length</td>
<td align="left">U8 array</td>
<td align="left">zlibData</td>
</tr>
</table>
<br clear="all" />

<p>The zlibData when uncompressed represents tiles in left-to-right,
    top-to-bottom order, similar to TRLE, but with a tile size of
    64x64 pixels.  If the width of the rectangle is not an exact
    multiple of 64 then the width of the last tile in each row is
    smaller, and if the height of the rectangle is not an exact
    multiple of 64 then the height of each tile in the final row is
    smaller.
  
</p>
<p>The tiles are encoded in exactly the same way as TRLE, except
    that subencoding may not take the values 127 or 129, i.e. palettes
    cannot be reused between tiles.
  
</p>
<p>
    The server flushes the zlib stream to a byte boundary
    at the end of each ZRLE encoded message.
    It need not flush the stream between tiles within a message.
    Since the zlibData for a single message can potentially be quite large,
    clients can incrementally decode and interpret the zlibData but
    must not assume that encoded tile data is byte aligned.
</p>
<a name="pseudo-encodings"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.8"></a><h3>7.8.&nbsp;
Pseudo-Encodings</h3>

<p>An update rectangle with a "pseudo-encoding" does not directly represent
     pixel data but instead allows the server to send arbitrary data to the
     client.  How this data is interpreted depends on the pseudo-encoding.
  
</p>
<a name="anchor29"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.8.1"></a><h3>7.8.1.&nbsp;
Cursor pseudo-encoding</h3>

<p>A client which requests the Cursor pseudo-encoding is declaring
      that it is capable of drawing a pointer cursor locally.  This
      can significantly improve perceived performance over slow links.
      The server sets the cursor shape by sending a rectangle
      with the Cursor pseudo-encoding as part of an update.  The
      rectangle's x-position and y-position indicate the
      hotspot of the cursor, and width and height indicate the width
      and height of the cursor in pixels.  The data consists of
      width*height raw pixel values followed by a shape bitmask, with
      one bit corresponding to each pixel in the cursor rectangle.
      The bitmask
      consists of left-to-right, top-to-bottom scan lines, where each
      scan line is padded to a whole number of bytes
      div(width+7,8).
      Within each byte the most significant bit
      represents the leftmost pixel, with a 1-bit meaning the
      corresponding pixel in the cursor is valid.
    
</p><table class="full" align="center" border="0" cellpadding="2" cellspacing="2">
<col align="left"><col align="left"><col align="left">
<tr><th align="left">No. of bytes</th><th align="left">Type [Value]</th><th align="left">Description</th></tr>
<tr>
<td align="left">width*height*bytesPerPixel</td>
<td align="left">PIXEL array</td>
<td align="left">cursor-pixels</td>
</tr>
<tr>
<td align="left">div(width+7,8)*height</td>
<td align="left">U8 array</td>
<td align="left">bitmask</td>
</tr>
</table>
<br clear="all" />

<a name="anchor30"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.8.2"></a><h3>7.8.2.&nbsp;
DesktopSize pseudo-encoding</h3>

<p>A client which requests the DesktopSize pseudo-encoding is
    declaring that it is capable of coping with a change in the
    framebuffer width and height.  The server changes the desktop
    size by sending a rectangle with the DesktopSize
    pseudo-encoding as the last rectangle in an update.  The
    rectangle's x-position and y-position are ignored, and
    width and height indicate the new width and height of the
    framebuffer.
    
</p>
<p>There is no further data associated with the rectangle.
    After changing the desktop size, the server must assume that the client no
    longer has the previous framebuffer contents.  This will usually result in
    a complete update of the framebuffer at the next update.  However for
    maximum interoperability with existing servers the client should preserve
    the top-left portion of the framebuffer between the old and new sizes.
    
</p>
<a name="anchor31"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.8"></a><h3>8.&nbsp;
Security</h3>

<p>The RFB protocol as defined here provides no security beyond the optional
    and cryptographically weak
    password check described in <a class='info' href='#vncauth'>Section&nbsp;7.2.2<span> (</span><span class='info'>VNC Authentication</span><span>)</span></a>.
    In particular, it provides no protection against observation of or tampering
    with the data stream.
</p>
<p>Security methods beyond those described here may be used to protect the
    integrity of the data.
    The client and server might agree to use an extended security type to
    encrypt the session, or the session might be transmitted over a secure
    channel such as <a class='info' href='#RFC4301'>IPSEC<span> (</span><span class='info'>Kent, S. and K. Seo, &ldquo;Security Architecture for the Internet Protocol,&rdquo; December&nbsp;2005.</span><span>)</span></a> [RFC4301] or
    <a class='info' href='#RFC4254'>SSH<span> (</span><span class='info'>Ylonen, T. and C. Lonvick, &ldquo;The Secure Shell (SSH) Connection Protocol,&rdquo; January&nbsp;2006.</span><span>)</span></a> [RFC4254].
    
</p>
<a name="Acknowledgements"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.9"></a><h3>9.&nbsp;
Acknowledgements</h3>

<p>James Weatherall, Andy Harter and Ken Wood also contributed to
    the design of the RFB protocol.
</p>
<a name="rfc.references1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>10.&nbsp;References</h3>
<table width="99%" border="0">
<tr><td class="author-text" valign="top"><a name="RFC1950">[RFC1950]</a></td>
<td class="author-text"><a href="mailto:ghost@aladdin.com">Deutsch, L.</a> and J-L. Gailly, &ldquo;<a href="http://tools.ietf.org/html/rfc1950">ZLIB Compressed Data Format Specification version 3.3</a>,&rdquo; RFC&nbsp;1950, May&nbsp;1996 (<a href="http://www.rfc-editor.org/rfc/rfc1950.txt">TXT</a>, <a href="http://www.rfc-editor.org/rfc/rfc1950.ps">PS</a>, <a href="http://www.rfc-editor.org/rfc/rfc1950.pdf">PDF</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC1951">[RFC1951]</a></td>
<td class="author-text"><a href="mailto:ghost@aladdin.com">Deutsch, P.</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc1951">DEFLATE Compressed Data Format Specification version 1.3</a>,&rdquo; RFC&nbsp;1951, May&nbsp;1996 (<a href="http://www.rfc-editor.org/rfc/rfc1951.txt">TXT</a>, <a href="http://www.rfc-editor.org/rfc/rfc1951.ps">PS</a>, <a href="http://www.rfc-editor.org/rfc/rfc1951.pdf">PDF</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4254">[RFC4254]</a></td>
<td class="author-text">Ylonen, T. and C. Lonvick, &ldquo;<a href="http://tools.ietf.org/html/rfc4254">The Secure Shell (SSH) Connection Protocol</a>,&rdquo; RFC&nbsp;4254, January&nbsp;2006 (<a href="http://www.rfc-editor.org/rfc/rfc4254.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4301">[RFC4301]</a></td>
<td class="author-text">Kent, S. and K. Seo, &ldquo;<a href="http://tools.ietf.org/html/rfc4301">Security Architecture for the Internet Protocol</a>,&rdquo; RFC&nbsp;4301, December&nbsp;2005 (<a href="http://www.rfc-editor.org/rfc/rfc4301.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="XLIBREF">[XLIBREF]</a></td>
<td class="author-text">Nye, A., &ldquo;XLIB Reference Manual R5,&rdquo; June&nbsp;1994.</td></tr>
</table>

<a name="oldver"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.A"></a><h3>Appendix A.&nbsp;
Differences in earlier protocol versions</h3>

<p>For maximum interoperability, clients and servers should be prepared
	to fall back to the earlier 3.3 and 3.7 versions of the RFB protocol.
	Any version reported other than 3.7 or 3.8 should be treated as 3.3.
</p>
<p>All of the differences occur in the initial handshake phase.
	Once the session reaches the ClientInit and ServerInit messages,
	all three protocol versions are identical.
	Even within a protocol version, clients and servers may support
	different subsets of the encoding and pseudo-encoding types.
</p>
<a name="anchor33"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.A.1"></a><h3>A.1.&nbsp;
Differences in the version 3.3 protocol</h3>

<p>The ProtocolVersion message is:

      </p>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
    RFB 003.003\n (hex 52 46 42 20 30 30 33 2e 30 30 33 0a)
</pre></div><p>

</p>
<p>In the <a class='info' href='#securityhs'>security handshake<span> (</span><span class='info'>Security Handshake</span><span>)</span></a>,
	rather than a two-way negotiation
	the server decides the security type and sends a single word:
</p><table class="full" align="center" border="0" cellpadding="2" cellspacing="2">
<col align="left"><col align="left"><col align="left">
<tr><th align="left">No. of bytes</th><th align="left">Type  [Value]</th><th align="left">Description</th></tr>
<tr>
<td align="left">4</td>
<td align="left">U32</td>
<td align="left">security-type</td>
</tr>
</table>
<br clear="all" />

<p>The security-type may only take the value 0, 1 or 2.  A value
	of 0 means that the connection has failed and is followed by a string
	giving the reason, as described in <a class='info' href='#securityhs'>Section&nbsp;7.1.2<span> (</span><span class='info'>Security Handshake</span><span>)</span></a>.
      
</p>
<p>If the security-type is 1, for no authentication, the server does
	not send the SecurityResult message but proceeds directly to
	the <a class='info' href='#initmsgs'>initialization messages.<span> (</span><span class='info'>Initialization Messages</span><span>)</span></a>
</p>
<p>In <a class='info' href='#vncauth'>VNC Authentication<span> (</span><span class='info'>VNC Authentication</span><span>)</span></a>, if the
	authentication fails, the server sends the SecurityResult
	message, but does not send an error message before closing the
	connection.
</p>
<a name="anchor34"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.A.2"></a><h3>A.2.&nbsp;
Differences in the version 3.7 protocol</h3>

<p>The ProtocolVersion message is:

      </p>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
    RFB 003.007\n (hex 52 46 42 20 30 30 33 2e 30 30 37 0a)
</pre></div><p>

</p>
<p>After the security handshake,
	if the security-type is 1, for no authentication, the server does
	not send the SecurityResult message but proceeds directly to
	the <a class='info' href='#initmsgs'>initialization messages.<span> (</span><span class='info'>Initialization Messages</span><span>)</span></a>
</p>
<p>In <a class='info' href='#vncauth'>VNC Authentication<span> (</span><span class='info'>VNC Authentication</span><span>)</span></a>, if the
	authentication fails, the server sends the SecurityResult
	message, but does not send an error message before closing the
	connection.
</p>
<a name="rfc.authors"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>Authors' Addresses</h3>
<table width="99%" border="0" cellpadding="0" cellspacing="0">
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Tristan Richardson</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">RealVNC Ltd.</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Betjeman House, 104 Hills Road</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Cambridge  CB2 1LQ</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">UK</td></tr>
<tr><td class="author" align="right">Phone:&nbsp;</td>
<td class="author-text">+44 1223 310410</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:standards@realvnc.com">standards@realvnc.com</a></td></tr>
<tr><td class="author" align="right">URI:&nbsp;</td>
<td class="author-text"><a href="http://www.realvnc.com">http://www.realvnc.com</a></td></tr>
<tr cellpadding="3"><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">John Levine</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Taughannock Networks</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">PO Box 727</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Trumansburg, NY  14886</td></tr>
<tr><td class="author" align="right">Phone:&nbsp;</td>
<td class="author-text">+1 607 330 5711</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:standards@taugh.com">standards@taugh.com</a></td></tr>
<tr><td class="author" align="right">URI:&nbsp;</td>
<td class="author-text"><a href="http://www.taugh.com">http://www.taugh.com</a></td></tr>
</table>
<a name="rfc.copyright"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>Full Copyright Statement</h3>
<p class='copyright'>
Copyright &copy; The IETF Trust (2008).</p>
<p class='copyright'>
This document is subject to the rights,
licenses and restrictions contained in BCP&nbsp;78,
and except as set forth therein,
the authors retain all their rights.</p>
<p class='copyright'>
This document and the information contained herein are provided
on an &ldquo;AS IS&rdquo; basis and THE CONTRIBUTOR,
THE ORGANIZATION HE/SHE REPRESENTS
OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY, THE IETF TRUST
AND THE INTERNET ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT
THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY
IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR
PURPOSE.</p>
<h3>Intellectual Property</h3>
<p class='copyright'>
The IETF takes no position regarding the validity or scope of any
Intellectual Property Rights or other rights that might be claimed
to pertain to the implementation or use of the technology
described in this document or the extent to which any license
under such rights might or might not be available; nor does it
represent that it has made any independent effort to identify any
such rights.
Information on the procedures with respect to
rights in RFC documents can be found in BCP&nbsp;78 and BCP&nbsp;79.</p>
<p class='copyright'>
Copies of IPR disclosures made to the IETF Secretariat and any
assurances of licenses to be made available,
or the result of an attempt made to obtain a general license or
permission for the use of such proprietary rights by implementers or
users of this specification can be obtained from the IETF on-line IPR
repository at <a href='http://www.ietf.org/ipr'>http://www.ietf.org/ipr</a>.</p>
<p class='copyright'>
The IETF invites any interested party to bring to its attention
any copyrights,
patents or patent applications,
or other
proprietary rights that may cover technology that may be required
to implement this standard.
Please address the information to the IETF at <a href='mailto:ietf-ipr@ietf.org'>ietf-ipr@ietf.org</a>.</p>
</body></html>
