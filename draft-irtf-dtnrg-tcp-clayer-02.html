<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="en"><head><title>Delay Tolerant Networking TCP Convergence Layer Protocol</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="description" content="Delay Tolerant Networking TCP Convergence Layer Protocol">
<meta name="generator" content="xml2rfc v1.35 (http://xml.resource.org/)">
<meta name="viewport" content="width=600;" />
<style type='text/css'><!--
        body {
                font-family: verdana, charcoal, helvetica, arial, sans-serif;
                font-size: 85%;
		max-width: 40em; 
		color: #000; background-color: #FFF;
                margin: 2em;
        }
        h1, h2, h3, h4, h5, h6 {
                font-family: helvetica, monaco, "MS Sans Serif", arial, sans-serif;
                font-weight: bold; font-style: normal;
        }
        h1 { color: #900; background-color: transparent; text-align: right; }
        h3 { color: #333; background-color: transparent; }

        td.RFCbug {
                font-size: x-small; text-decoration: none;
                width: 30px; height: 30px; padding-top: 2px;
                text-align: justify; vertical-align: middle;
                background-color: #000;
        }
        td.RFCbug span.RFC {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: bold; color: #666;
        }
        td.RFCbug span.hotText {
                font-family: charcoal, monaco, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: normal; text-align: center; color: #FFF;
        }

        table.TOCbug { width: 30px; height: 15px; }
        td.TOCbug {
                text-align: center; width: 30px; height: 15px;
                color: #FFF; background-color: #900;
        }
        td.TOCbug a {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, sans-serif;
                font-weight: bold; font-size: x-small; text-decoration: none;
                color: #FFF; background-color: transparent;
        }

        td.header {
                font-family: arial, helvetica, sans-serif; font-size: x-small;
                vertical-align: top; width: 33%;
                color: #FFF; background-color: #666;
        }
        td.author { font-weight: bold; font-size: x-small; margin-left: 4em; }
        td.author-text { font-size: x-small; }

        /* info code from SantaKlauss at http://www.madaboutstyle.com/tooltip2.html */
        a.info {
                /* This is the key. */
                position: relative;
                z-index: 24;
                text-decoration: none;
        }
        a.info:hover {
                z-index: 25;
                color: #FFF; background-color: #900;
        }
        a.info span { display: none; }
        a.info:hover span.info {
                /* The span will display just on :hover state. */
                display: block;
                position: absolute;
                font-size: smaller;
                top: 2em; left: -5em; width: 15em;
                padding: 2px; border: 1px solid #333;
                color: #900; background-color: #EEE;
                text-align: left;
        }

        a { font-weight: bold; }
        a:link    { color: #900; background-color: transparent; }
        a:visited { color: #633; background-color: transparent; }
        a:active  { color: #633; background-color: transparent; }

        p { margin-left: 2em; margin-right: 2em; }
        p.copyright { font-size: x-small; }
        p.toc { font-size: 85%;
		max-width: 40em; 
		font-weight: bold; margin-left: 3em; }
        table.toc { margin: 0 0 0 3em; padding: 0; border: 0; vertical-align: text-top; }
        td.toc { font-size: 85%;
		max-width: 40em; 
		font-weight: bold; vertical-align: text-top; }

        ol.text { margin-left: 2em; margin-right: 2em; }
        ul.text { margin-left: 2em; margin-right: 2em; }
        li      { margin-left: 3em; }

        /* RFC-2629 <spanx>s and <artwork>s. */
        em     { font-style: italic; }
        strong { font-weight: bold; }
        dfn    { font-weight: bold; font-style: normal; }
        cite   { font-weight: normal; font-style: normal; }
        tt     { color: #036; }
        tt, pre, pre dfn, pre em, pre cite, pre span {
                font-family: "Courier New", Courier, monospace; font-size: small;
        }
        pre {
                text-align: left; padding: 4px;
                color: #000; background-color: #CCC;
        }
        pre dfn  { color: #900; }
        pre em   { color: #66F; background-color: #FFC; font-weight: normal; }
        pre .key { color: #33C; font-weight: bold; }
        pre .id  { color: #900; }
        pre .str { color: #000; background-color: #CFF; }
        pre .val { color: #066; }
        pre .rep { color: #909; }
        pre .oth { color: #000; background-color: #FCF; }
        pre .err { background-color: #FCC; }

        /* RFC-2629 <texttable>s. */
        table.all, table.full, table.headers, table.none {
                font-size: 85%;
		max-width: 40em; 
		text-align: center; border-width: 2px;
                vertical-align: top; border-collapse: collapse;
        }
        table.all, table.full { border-style: solid; border-color: black; }
        table.headers, table.none { border-style: none; }
        th {
                font-weight: bold; border-color: black;
                border-width: 2px 2px 3px 2px;
        }
        table.all th, table.full th { border-style: solid; }
        table.headers th { border-style: none none solid none; }
        table.none th { border-style: none; }
        table.all td {
                border-style: solid; border-color: #333;
                border-width: 1px 2px;
        }
        table.full td, table.headers td, table.none td { border-style: none; }

        hr { height: 1px; }
        hr.insert {
                width: 80%; border-style: none; border-width: 0;
                color: #CCC; background-color: #CCC;
        }
--></style>
</head>
<body>
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<table summary="layout" width="66%" border="0" cellpadding="0" cellspacing="0"><tr><td><table summary="layout" width="100%" border="0" cellpadding="2" cellspacing="1">
<tr><td class="header">Delay Tolerant Networking Research</td><td class="header">M. Demmer</td></tr>
<tr><td class="header">Group</td><td class="header">UC Berkeley</td></tr>
<tr><td class="header">Internet-Draft</td><td class="header">J. Ott</td></tr>
<tr><td class="header">Intended status: Experimental</td><td class="header">Helsinki University of Technology</td></tr>
<tr><td class="header">Expires: May 7, 2009</td><td class="header">November 03, 2008</td></tr>
</table></td></tr></table>
<h1><br />Delay Tolerant Networking TCP Convergence Layer Protocol<br />draft-irtf-dtnrg-tcp-clayer-02.txt</h1>

<h3>Status of this Memo</h3>
<p>
By submitting this Internet-Draft,
each author represents that any applicable patent or other IPR claims of which
he or she is aware have been or will be disclosed,
and any of which he or she becomes aware will be disclosed,
in accordance with Section&nbsp;6 of BCP&nbsp;79.</p>
<p>
Internet-Drafts are working documents of the Internet Engineering
Task Force (IETF), its areas, and its working groups.
Note that other groups may also distribute working documents as
Internet-Drafts.</p>
<p>
Internet-Drafts are draft documents valid for a maximum of six months
and may be updated, replaced, or obsoleted by other documents at any time.
It is inappropriate to use Internet-Drafts as reference material or to cite
them other than as &ldquo;work in progress.&rdquo;</p>
<p>
The list of current Internet-Drafts can be accessed at
<a href='http://www.ietf.org/ietf/1id-abstracts.txt'>http://www.ietf.org/ietf/1id-abstracts.txt</a>.</p>
<p>
The list of Internet-Draft Shadow Directories can be accessed at
<a href='http://www.ietf.org/shadow.html'>http://www.ietf.org/shadow.html</a>.</p>
<p>
This Internet-Draft will expire on May 7, 2009.</p>

<h3>Abstract</h3>

<p>
         This document describes the protocol for the TCP-based
         Convergence Layer for Delay Tolerant Networking (DTN).
      
</p><a name="toc"></a><br /><hr />
<h3>Table of Contents</h3>
<p class="toc">
<a href="#anchor1">1.</a>&nbsp;
Introduction<br />
<a href="#anchor2">2.</a>&nbsp;
Definitions<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor3">2.1.</a>&nbsp;
Definitions Relating to the Bundle Protocol<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor4">2.2.</a>&nbsp;
Definitions specific to the TCPCL Protocol<br />
<a href="#sec:general_description">3.</a>&nbsp;
General Protocol Description<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec:example">3.1.</a>&nbsp;
Example message exchange<br />
<a href="#sec:connection_establishment">4.</a>&nbsp;
Connection Establishment<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec:contact_header">4.1.</a>&nbsp;
Contact Header<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec:negotiation">4.2.</a>&nbsp;
Validation and parameter negotiation<br />
<a href="#anchor5">5.</a>&nbsp;
Established Connection Operation<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec:types">5.1.</a>&nbsp;
Message Type Codes<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec:bundle_data">5.2.</a>&nbsp;
Bundle Data Transmission<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec:acks">5.3.</a>&nbsp;
Bundle Acknowledgments<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec:refusal">5.4.</a>&nbsp;
Bundle Refusal<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec:keepalive">5.5.</a>&nbsp;
Keepalive Messages<br />
<a href="#sec:termination">6.</a>&nbsp;
Connection Termination<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec:shutdown">6.1.</a>&nbsp;
Shutdown Message<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec:idle">6.2.</a>&nbsp;
Idle Connection Shutdown<br />
<a href="#anchor6">7.</a>&nbsp;
Requirements notation<br />
<a href="#anchor7">8.</a>&nbsp;
Security Considerations<br />
<a href="#anchor8">9.</a>&nbsp;
IANA Considerations<br />
<a href="#rfc.references1">10.</a>&nbsp;
References<br />
<a href="#rfc.authors">&#167;</a>&nbsp;
Authors' Addresses<br />
<a href="#rfc.copyright">&#167;</a>&nbsp;
Intellectual Property and Copyright Statements<br />
</p>
<br clear="all" />

<a name="anchor1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1"></a><h3>1.&nbsp;
Introduction</h3>

<p>
   This document describes the TCP-based convergence layer protocol for
   Delay Tolerant Networking (TCPCL). Delay Tolerant Networking is an
   end-to-end architecture providing communications in and/or through
   highly stressed environments, including those with intermittent
   connectivity, long and/or variable delays, and high bit error
   rates. More detailed descriptions of the rationale and capabilities
   of these networks can be found in the <a class='info' href='#refs.dtnarch'>Delay-Tolerant Network Architecture<span> (</span><span class='info'>Cerf et al, V., &ldquo;Delay-Tolerant Network Architecture,&rdquo; April&nbsp;2007.</span><span>)</span></a> [refs.dtnarch] RFC.

</p>
<p>
   An important goal of the DTN architecture is to accommodate a wide
   range of networking technologies and environments. The protocol
   used for DTN communications is the <a class='info' href='#refs.bundleproto'>Bundling Protocol (BP)<span> (</span><span class='info'>Scott, K. and S. Burleigh, &ldquo;Bundle Protocol Specification,&rdquo; November&nbsp;2007.</span><span>)</span></a> [refs.bundleproto], an application-layer protocol that
   is used to construct a store-and-forward overlay network. As
   described in the bundle protocol specification, it requires the
   services of a "convergence layer adapter" (CLA) to send and receive
   bundles using an underlying internet protocol. This document
   describes one such convergence layer adapter that uses the
   well-known Transmission Control Protocol (TCP).  This convergence
   layer is referred to as TCPCL.

</p>
<p>
   The locations of the TCPCL and the BP in the Internet model protocol
   stack are shown in <a class='info' href='#fig:protocol_stack'>Figure&nbsp;1<span> (</span><span class='info'>The locations of the bundle protocol and the TCP         convergence layer protocol in the Internet protocol stack</span><span>)</span></a>. In
   particular, both the BP and the TCPCL reside above the transport
   layer, i.e., at the application layer.

</p><br /><hr class="insert" />
<a name="fig:protocol_stack"></a>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
   +-------------------------+
   |     DTN Application     | -\
   +-------------------------|   |
   |  Bundle Protocol (BP)   |   -&gt; Application Layer
   +-------------------------+   |
   | TCP Conv. Layer (TCPCL) | -/
   +-------------------------+
   |          TCP            | ---&gt; Transport Layer
   +-------------------------+
   |           IP            | ---&gt; Network Layer
   +-------------------------+
   |   Link-Layer Protocol   | ---&gt; Link Layer
   +-------------------------+
   |    Physical Medium      | ---&gt; Physical Layer
   +-------------------------+
</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;1: The locations of the bundle protocol and the TCP
        convergence layer protocol in the Internet protocol stack&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>
   This document describes the format of the protocol data units
   passed between entities participating in TCPCL communications. This
   document does not address:

</p>
<p>
</p>
<blockquote class="text"><dl>
<dt></dt>
<dd>
      The format of protocol data units of the bundling protocol, as
      those are defined elsewhere <a class='info' href='#refs.bundleproto'>[refs.bundleproto]<span> (</span><span class='info'>Scott, K. and S. Burleigh, &ldquo;Bundle Protocol Specification,&rdquo; November&nbsp;2007.</span><span>)</span></a>.
   
</dd>
<dt></dt>
<dd>
</dd>
<dt></dt>
<dd>
      Mechanisms for locating or identifying other bundle nodes within
      an internet.
   
</dd>
<dt></dt>
<dd>
</dd>
<dt></dt>
<dd>
</dd>
</dl></blockquote><p>

</p>
<p>
   Note that this document describes version 3 of the protocol.
   Versions 0, 1, and 2 were never specified in any Internet Draft,
   RFC, or any other public document. These prior versions of the
   protocol were, however, implemented in
   the <a class='info' href='#refs.dtnimpl'>DTN reference
   implementation<span> (</span><span class='info'>DTNRG, &ldquo;Delay Tolerant Networking Reference Implementation,&rdquo; .</span><span>)</span></a> [refs.dtnimpl], in prior releases, hence the current version
   number reflects the existence of those prior versions.

</p>
<a name="anchor2"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2"></a><h3>2.&nbsp;
Definitions</h3>

<a name="anchor3"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2.1"></a><h3>2.1.&nbsp;
Definitions Relating to the Bundle Protocol</h3>

<p>The following set of definitions are abbreviated versions of those
   which appear in the <a class='info' href='#refs.bundleproto'>Bundle
   Protocol Specification<span> (</span><span class='info'>Scott, K. and S. Burleigh, &ldquo;Bundle Protocol Specification,&rdquo; November&nbsp;2007.</span><span>)</span></a> [refs.bundleproto]. To the extent in which terms appear
   in both documents, they are intended to have the same meaning.

</p>
<p>
</p>
<blockquote class="text"><dl>
<dt>Bundle --</dt>
<dd>A bundle is a protocol data unit of the DTN
      bundle protocol.
   
</dd>
<dt></dt>
<dd>
</dd>
<dt>Bundle payload --</dt>
<dd>A bundle payload (or simply
      "payload") is the application data whose conveyance to the
      bundle's destination is the purpose for the transmission of a
      given bundle.
   
</dd>
<dt></dt>
<dd>
</dd>
<dt>Fragment --</dt>
<dd>A fragment is a bundle whose payload
      contains a range of bytes from another bundle's payload.
   
</dd>
<dt></dt>
<dd>
</dd>
<dt>Bundle node --</dt>
<dd>A bundle node (or simply a "node") is
      any entity that can send and/or receive bundles. The particular
      instantiation of this entity is deliberately unconstrained,
      allowing for implementations in software libraries, long-running
      processes, or even hardware. One component of the bundle node is
      the implementation of a convergence layer adapter.
   
</dd>
<dt></dt>
<dd>
</dd>
<dt>Convergence layer adapter --</dt>
<dd>A convergence layer
      adapter (CLA) sends and receives bundles utilizing the services
      of some 'native' link, network, or internet protocol. This document describes the
      manner in which a CLA sends and receives bundles when using the
      TCP protocol for inter-node communication.
   
</dd>
<dt></dt>
<dd>
</dd>
<dt>Self Describing Numeric Value --</dt>
<dd>A self describing
      numeric value (SDNV) is a variable length encoding for integer
      values, defined in the bundle protocol specification.
   
</dd>
<dt></dt>
<dd>
</dd>
</dl></blockquote><p>

</p>
<a name="anchor4"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2.2"></a><h3>2.2.&nbsp;
Definitions specific to the TCPCL Protocol</h3>

<p>This section contains definitions that are interpreted to be
   specific to the operation of the TCPCL protocol, as described
   below.

</p>
<blockquote class="text"><dl>
<dt></dt>
<dd>
</dd>
<dt>TCP Connection --</dt>
<dd>A TCP connection refers to a
      transport connection using TCP as the transport protocol.
   
</dd>
<dt></dt>
<dd>
</dd>
<dt>TCPCL Connection --</dt>
<dd>A TCPCL connection
      (as opposed to a TCP connection)
      is a TCPCL communication relationship between two bundle
      nodes. The lifetime of a TCPCL connection is one-to-one with the lifetime
      of an underlying TCP connection.  Therefore a TCPCL connection is
      initiated when a bundle node initiates a TCP connection to be
      established for the purposes of bundle communication. A TCPCL connection is
      terminated when the TCP connection ends, due either to one or
      both nodes actively terminating the TCP connection or due to network
      errors causing a failure of the TCP connection. For the remainder of this
      document, the term "connection" without the prefix "TCPCL" shall refer
      to a TCPCL connection.
   
</dd>
<dt></dt>
<dd>
</dd>
<dt>Connection parameters --</dt>
<dd>The connection parameters
      are a set of values used to affect the operation of the TCPCL
      for a given connection. The manner in which these parameters are
      conveyed to the bundle node and thereby to the TCPCL is
      implementation-dependent. However, the mechanism by which two
      bundle nodes exchange and negotiate the values to be used for a
      given session is described in Section <a class='info' href='#sec:negotiation'>Section&nbsp;4.2<span> (</span><span class='info'>Validation and parameter negotiation</span><span>)</span></a>.
   
</dd>
<dt></dt>
<dd>
</dd>
<dt>Connection initiator --</dt>
<dd>The connection initiator is
      the bundle node that causes the establishment of a new
      connection by creating a new TCP connection (for example, by using
      the connect() call in the BSD sockets API) and then following
      the procedures described in <a class='info' href='#sec:connection_establishment'>Section&nbsp;4<span> (</span><span class='info'>Connection Establishment</span><span>)</span></a>.
   
</dd>
<dt></dt>
<dd>
</dd>
<dt>Connection acceptor --</dt>
<dd>The connection acceptor is the
      bundle node that establishes a connection in response to an
      active connection attempt by another bundle node (for example,
      by using the listen() and accept() calls of the BSD sockets API)
      and then following the procedures described in <a class='info' href='#sec:connection_establishment'>Section&nbsp;4<span> (</span><span class='info'>Connection Establishment</span><span>)</span></a>.
   
</dd>
<dt></dt>
<dd>
</dd>
<dt>Transmission --</dt>
<dd>Transmission refers to the procedures
      and mechanisms (described below) for conveyance of a bundle from
      one node to another.
   
</dd>
<dt></dt>
<dd>
</dd>
<dt></dt>
<dd>
</dd>
</dl></blockquote>
<a name="sec:general_description"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3"></a><h3>3.&nbsp;
General Protocol Description</h3>

<p>
   This protocol provides bundle conveyance over a TCP connection and
   specifies the encapsulation of bundles as well as procedures for
   TCP connection setup and teardown.  The general operation of the protocol
   is as follows:

</p>
<p>
   First one node establishes a TCPCL connection to the other by
   initiating a TCP connection.  After setup of the TCP connection is
   complete, an initial contact header is exchanged in both directions
   to set parameters of the TCPCL connection and exchange a singleton
   endpoint identifier for each node (not the singleton EID of any
   application running on the node), to denote the bundle-layer
   identity of each DTN node.  This is used to assist in routing and
   forwarding messages, e.g., to prevent loops.

</p>
<p>
   Once the TCPCL connection is established and configured in this
   way, bundles can be transmitted in either direction.  Each bundle
   is transmitted in one or more logical segments of formatted bundle
   data.  Each logical data segment consists of a DATA_SEGMENT message
   header, an SDNV containing the length of the segment, and finally
   the byte range of the bundle data. The choice of the length to use
   for segments is an implementation matter.  The first segment for a
   bundle must set the 'start' flag and the last one must set the
   'end' flag in the DATA_SEGMENT message header.

</p>
<p>
   An optional feature of the protocol is for the receiving node to
   send acknowledgments as bundle data segments arrive (ACK_SEGMENT).
   The rationale behind these acknowledgments is to enable the sender
   node to determine how much of the bundle has been received, so that
   in case the connection is interrupted, it can perform reactive
   fragmentation to avoid re-sending the already transmitted part of
   the bundle.

</p>
<p>
   When acknowledgments are enabled, then for each data segment that
   is received, the receiving node sends an ACK_SEGMENT code followed
   by an SDNV containing the cumulative length of the bundle that has
   been received. Note that in the case of concurrent bidirectional
   transmission, then ack segments may be interleaved with data
   segments.

</p>
<p>
   Another optional feature is that a receiver may interrupt the
   transmission of a bundle at any point in time by replying with a
   negative acknowledgment (REFUSE_BUNDLE) which causes the sender to
   stop transmission of the current bundle, after completing
   transmission of a partially sent data segment.  Note: This enables
   a cross-layer optimization in that it
   allows a receiver that detects that it already has received a certain
   bundle to interrupt transmission as early as possible and thus save
   transmission capacity for other bundles.

</p>
<p>
   For connections that are idle, a KEEPALIVE message may optionally
   be sent at a negotiated interval.  This is used to convey liveness
   information.

</p>
<p>
   Finally, before connections close, a SHUTDOWN message is sent on
   the channel.  After sending a SHUTDOWN message, the sender of this
   message may send further acknowledgments (ACK_SEGMENT or
   REFUSE_BUNDLE) but no further data messages (DATA_SEGMENT).  A
   SHUTDOWN message may also be used to refuse a connection setup by a
   peer.

</p>
<a name="sec:example"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.1"></a><h3>3.1.&nbsp;
Example message exchange</h3>

<p>
   The following figure visually depicts the protocol exchange for
   a simple session, showing the connection establishment, and the
   transmission of a single bundle split into three data segments
   (of lengths L1, L2, and L3) from Node A to Node B.

</p>
<p>
   Note that the sending node may transmit multiple DATA_SEGMENT
   messages without necessarily waiting for the corresponding
   ACK_SEGMENT responses. This enables pipelining of messages on a
   channel. Although this example only demonstrates a single bundle
   transmission, it is also possible to pipeline multiple DATA_SEGMENT
   messages for different bundles without necessarily waiting for
   ACK_SEGMENT messages to be returned for each one.  However,
   interleaving data segments from different bundles is not allowed.

</p>
<p>
   No errors or rejections are shown in this example.

</p><br /><hr class="insert" />
<a name="fig:example_flow"></a>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
             Node A                              Node B
             ======                              ======

   +-------------------------+         +-------------------------+
   |     Contact Header      | -&gt;   &lt;- |     Contact Header      |
   +-------------------------+         +-------------------------+

   +-------------------------+
   |   DATA_SEGMENT (start)  | -&gt;
   |    SDNV length [L1]     | -&gt;
   |    Bundle Data 0..L1    | -&gt;
   +-------------------------+
   +-------------------------+         +-------------------------+
   |     DATA_SEGMENT        | -&gt;   &lt;- |       ACK_SEGMENT       |
   |    SDNV length [L2]     | -&gt;   &lt;- |     SDNV length [L1]    |
   |    Bundle Data L1..L2   | -&gt;      +-------------------------+
   +-------------------------+
   +-------------------------+         +-------------------------+
   |    DATA_SEGMENT (end)   | -&gt;   &lt;- |       ACK_SEGMENT       |
   |     SDNV length [L3]    | -&gt;   &lt;- |   SDNV length [L1+L2]   |
   |    Bundle Data L2..L3   | -&gt;      +-------------------------+
   +-------------------------+
                                       +-------------------------+
                                    &lt;- |       ACK_SEGMENT       |
                                    &lt;- |  SDNV length [L1+L2+L3] |
                                       +-------------------------+

   +-------------------------+         +-------------------------+
   |       SHUTDOWN          | -&gt;   &lt;- |         SHUTDOWN        |
   +-------------------------+         +-------------------------+
</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;2: A simple visual example of the flow of protocol
        messages on a single TCP session between two nodes (A and B)&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<a name="sec:connection_establishment"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4"></a><h3>4.&nbsp;
Connection Establishment</h3>

<p>
   For bundle transmissions to occur using the TCPCL, a TCPCL
   connection must first be established between communicating nodes.
   The manner in which a bundle node makes the decision to establish
   such a connection is implementation-dependent.  For example, some
   connections may be opened proactively and maintained for as long as
   is possible given the network conditions, while other connections
   may be opened only when there is a bundle that is queued for
   transmission and the routing algorithm selects a certain next hop
   node.

</p>
<p>
   To establish a TCPCL connection, a node must first establish a TCP
   connection with the intended peer node, typically by using the
   services provided by the operating system.  Port number 4556 has
   been assigned by IANA as the well-known port number for the TCP
   convergence layer.  Other port numbers MAY be used per local
   configuration.  Determining a peer's port number (if different
   from the well-known TCPCL port) is up to the implementation.

</p>
<p>
   If the node is unable to establish a TCP connection for any reason,
   then it is an implementation matter to determine how to handle the
   connection failure.  A node MAY decide to re-attempt to establish
   the connection, perhaps.  If it does so, it MUST NOT overwhelm its
   target with repeated connection attempts.  Therefore, the node MUST
   retry the connection setup only after some delay and it SHOULD use
   a (binary) exponential backoff mechanism to increase this delay in
   case of repeated failures.

</p>
<p>
   The node MAY declare failure after one or more connection attempts
   and MAY attempt to find an alternate route for bundle data.  Such
   decisions are up to the higher layer (i.e., the BP).

</p>
<p>
   Once a TCP connection is established, the connection initiator MUST
   immediately transmit a contact header over the TCP connection.  The
   connection acceptor MUST also immediately transmit a contact
   header over the TCP connection.  The format of the contact header
   is described in <a class='info' href='#sec:contact_header'>Section&nbsp;4.1<span> (</span><span class='info'>Contact Header</span><span>)</span></a>).

</p>
<p>
   Upon receipt of the contact header, both nodes perform the
   validation and negotiation procedures defined in
   <a class='info' href='#sec:negotiation'>Section&nbsp;4.2<span> (</span><span class='info'>Validation and parameter negotiation</span><span>)</span></a>

</p>
<p>
   After receiving the contact header from the other node, either node
   MAY also refuse the connection by sending a SHUTDOWN message.  If
   connection setup is refused a reason MUST be included in the
   SHUTDOWN message. 

</p>
<a name="sec:contact_header"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.1"></a><h3>4.1.&nbsp;
Contact Header</h3>

<p>
Once a TCP connection is established, both parties exchange a contact
header. This section describes the format of the contact header and
the meaning of its fields.

</p><br /><hr class="insert" />
<a name="fig:contact_header"></a>

<p>
      The format for the Contact Header is as follows:
   
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
                     1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 3 3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+---------------+---------------+---------------+---------------+
|                          magic='dtn!'                         |
+---------------+---------------+---------------+---------------+
|     version   |     flags     |      keepalive_interval       |
+---------------+---------------+---------------+---------------+
|                     local EID length (SDNV)                   |
+---------------+---------------+---------------+---------------+
|                                                               |
+                      local EID (variable)                     +
|                                                               |
+---------------+---------------+---------------+---------------+
</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;3: Contact Header Format&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>
The fields of the contact header are:

</p>
<p>
</p>
<blockquote class="text"><dl>
<dt>magic:</dt>
<dd> A four byte field that always contains the
      byte sequence 0x64 0x74 0x6e 0x21, i.e. the text string "dtn!".
   
</dd>
<dt></dt>
<dd>
</dd>
<dt>version:</dt>
<dd> A one byte field value containing the
      current version of the protocol.
   
</dd>
<dt></dt>
<dd>
</dd>
<dt>flags:</dt>
<dd> A one byte field containing optional
      connection flags. The first five bits are unused and MUST be set
      to zero upon transmission and MUST be ignored upon reception.
      The last three bits are interpreted as shown in table <a class='info' href='#contact:flags'>Table&nbsp;1<span> (</span><span class='info'>Contact Header Flags</span><span>)</span></a> below.
   
</dd>
<dt></dt>
<dd>
</dd>
<dt>keepalive_interval:</dt>
<dd> A two byte integer field
      containing the number of seconds between exchanges of keepalive
      messages on the connection (see <a class='info' href='#sec:keepalive'>Section&nbsp;5.5<span> (</span><span class='info'>Keepalive Messages</span><span>)</span></a>).
      This value is in network byte order, as are all other multi-byte
      fields described in this protocol.
   
</dd>
<dt></dt>
<dd>
</dd>
<dt>local eid length:</dt>
<dd> A variable length SDNV field
      containing the length of the endpoint identifier (EID) for some
      singleton endpoint in which the sending node is a member.  A
      four byte SDNV is depicted for clarity of the figure.
   
</dd>
<dt></dt>
<dd>
</dd>
<dt>local EID:</dt>
<dd> An octet string containing the EID
      of some singleton endpoint in which the sending node is a
      member, in the canonical format of &lt;scheme
      name&gt;:&lt;scheme-specific part&gt;. A eight byte EID
      is shown the clarity of the figure.
   
</dd>
<dt></dt>
<dd>
</dd>
</dl></blockquote><p>

</p><br /><hr class="insert" />
<a name="contact:flags"></a>
<table class="full" align="center" border="0" cellpadding="2" cellspacing="2">
<col align="center"><col align="left">
<tr><th align="center">Value</th><th align="left">Meaning</th></tr>
<tr>
<td align="center">00000001</td>
<td align="left">Request acknowledgment of bundle segments.</td>
</tr>
<tr>
<td align="center">00000010</td>
<td align="left">Request enabling of reactive fragmentation.</td>
</tr>
<tr>
<td align="center">00000100</td>
<td align="left">Indicate support for negative acknowledgments. This flag MUST
      NOT be set to '1' unless support for acknowledgments is also
      indicated.
   </td>
</tr>
</table>
<br clear="all" />
<table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Table 1: Contact Header Flags&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>
   The manner in which values are configured and chosen for the
   various flags and parameters in the contact header is
   implementation dependent.

</p>
<a name="sec:negotiation"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.2"></a><h3>4.2.&nbsp;
Validation and parameter negotiation</h3>

<p>
Upon reception of the contact header, both the TCPCL connection
initiator and the TCPCL connection acceptor follow the following
procedures for ensuring the validity of the TCPCL connection and to
negotiate values for the connection parameters.

</p>
<p>
If the magic string is not present or is not valid, the connection
MUST be terminated.  The intent of the magic string is to provide a
some protection against an inadvertent TCP connection by a different
protocol than the one described in this document.  To prevent a flood
of repeated connections from a misconfigured application, a node MAY
elect to hold an invalid connection open and idle for some time before
closing it.

</p>
<p>
If a node receives a contact header containing a version that is
greater than the current version of the protocol that the node
implements, then the node SHOULD interpret all fields and messages as
it would normally.  If a node receives a contact header with a version
that is lower than the version of the protocol that the node
implements, the node may either terminate the connection due to the
version mismatch, or may adapt its operation to conform to the older
version of the protocol.  This decision is an implementation matter.

</p>
<p>
A node calculates the parameters for a TCPCL connection by negotiating
the values from its own preferences (conveyed by the contact header it
sent) with the preferences of the peer node (expressed in the contact
header that it received).  This negotiation should proceed in the
following manner:

</p>
<blockquote class="text"><dl>
<dt></dt>
<dd>
</dd>
<dt></dt>
<dd>The segment acknowledgments enabled parameter is set to true
      iff the corresponding flag is set in both contact headers.
   
</dd>
<dt></dt>
<dd>
</dd>
<dt></dt>
<dd>The reactive fragmentation enabled parameter is set to true iff
      the corresponding flag is set in both contact headers.
   
</dd>
<dt></dt>
<dd>
</dd>
<dt></dt>
<dd>Negative acknowledgments to interrupt transmission (actually:
   refuse reception) of a bundle may only be used iff both peers
   indicate support for negative acknowledgments in their contact
   header.
   
</dd>
<dt></dt>
<dd>
</dd>
<dt></dt>
<dd>The keepalive_interval parameter is set to the minimum
      value from both contact headers.  If one or both contact headers
      contains the value zero, then the keepalive feature (described
      in <a class='info' href='#sec:keepalive'>Section&nbsp;5.5<span> (</span><span class='info'>Keepalive Messages</span><span>)</span></a>) is disabled.
   
</dd>
<dt></dt>
<dd>
</dd>
</dl></blockquote>
<p>
Once this process of parameter negotiation is completed, the protocol
defines no additional mechanism to change the parameters of an
established connection; to effect such a change, the connection MUST
be terminated and a new connection established.

</p>
<a name="anchor5"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5"></a><h3>5.&nbsp;
Established Connection Operation</h3>

<p>
This section describes the protocol operation for the duration of an
established connection, including the mechanisms for transmitting
bundles over the connection.

</p>
<a name="sec:types"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.1"></a><h3>5.1.&nbsp;
Message Type Codes</h3>

<p>
After the initial exchange of a contact header, all messages
transmitted over the connection are identified by a one octet header with
the following structure:

</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
    0 1 2 3 4 5 6 7
   +-+-+-+-+-+-+-+-+
   | type  | flags |
   +-+-+-+-+-+-+-+-+
</pre></div>
<blockquote class="text"><dl>
<dt>type:</dt>
<dd>Indicates the type of the message as per
      <a class='info' href='#types:codes'>Table&nbsp;2<span> (</span><span class='info'>TCPCL Header Types</span><span>)</span></a> below
</dd>
<dt></dt>
<dd>
</dd>
<dt>flags:</dt>
<dd>Optional flags defined on a per message type basis.
</dd>
</dl></blockquote>
<p>
   The types and values for the message type code are as follows.

</p><br /><hr class="insert" />
<a name="types:codes"></a>
<table class="full" align="center" border="0" cellpadding="2" cellspacing="2">
<col align="center" width="25%"><col align="left" width="5%"><col align="left" width="70%">
<tr><th align="center">Type</th><th align="left">Code</th><th align="left">Comment</th></tr>
<tr>
<td align="center">DATA_SEGMENT</td>
<td align="left">0x1</td>
<td align="left">Indicates the transmission of a segment of bundle data,
      described in <a class='info' href='#sec:bundle_data'>Section&nbsp;5.2<span> (</span><span class='info'>Bundle Data Transmission</span><span>)</span></a>.</td>
</tr>
<tr>
<td align="center">&nbsp;</td>
<td align="left">&nbsp;</td>
<td align="left">&nbsp;</td>
</tr>
<tr>
<td align="center">ACK_SEGMENT</td>
<td align="left">0x2</td>
<td align="left">Acknowledges reception of a data segment, described in
      <a class='info' href='#sec:acks'>Section&nbsp;5.3<span> (</span><span class='info'>Bundle Acknowledgments</span><span>)</span></a></td>
</tr>
<tr>
<td align="center">&nbsp;</td>
<td align="left">&nbsp;</td>
<td align="left">&nbsp;</td>
</tr>
<tr>
<td align="center">REFUSE_BUNDLE</td>
<td align="left">0x3</td>
<td align="left">Indicates that the transmission of the current bundle shall be
      stopped, described in <a class='info' href='#sec:refusal'>Section&nbsp;5.4<span> (</span><span class='info'>Bundle Refusal</span><span>)</span></a>.</td>
</tr>
<tr>
<td align="center">&nbsp;</td>
<td align="left">&nbsp;</td>
<td align="left">&nbsp;</td>
</tr>
<tr>
<td align="center">KEEPALIVE</td>
<td align="left">0x4</td>
<td align="left">Keepalive message for the connection, described in
      <a class='info' href='#sec:keepalive'>Section&nbsp;5.5<span> (</span><span class='info'>Keepalive Messages</span><span>)</span></a>.</td>
</tr>
<tr>
<td align="center">&nbsp;</td>
<td align="left">&nbsp;</td>
<td align="left">&nbsp;</td>
</tr>
<tr>
<td align="center">SHUTDOWN</td>
<td align="left">0x5</td>
<td align="left">Indicates that one of the nodes participating in the connection
      wishes to cleanly terminate the connection, described in
      <a class='info' href='#sec:termination'>Section&nbsp;6<span> (</span><span class='info'>Connection Termination</span><span>)</span></a>.</td>
</tr>
<tr>
<td align="center">&nbsp;</td>
<td align="left">&nbsp;</td>
<td align="left">&nbsp;</td>
</tr>
</table>
<br clear="all" />
<table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Table 2: TCPCL Header Types&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<a name="sec:bundle_data"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.2"></a><h3>5.2.&nbsp;
Bundle Data Transmission</h3>
<br /><hr class="insert" />
<a name="fig:data_message"></a>

<p>
      Each bundle is transmitted in one or more data segments. The
      format of a data segment message follows:
   
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
                        1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 3 3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |  0x1  |0|0|S|E|   length ...    |  contents....               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;4: Format of bundle data segment messages&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>
   The type portion of the message header contains the value 0x1.

</p>
<p>
   The flags portion of the message header octet contains two optional
   values in the two low-order bits, denoted 'S' and 'E' above. The
   'S' bit MUST be set to one iff it precedes the transmission of the
   first segment of a new bundle.  The 'E' bit MUST be set to one when
   transmitting the last segment of a bundle.

</p>
<p>
   Determining the size of the segment is an implementation matter.
   In particular, a node may, based on local policy or configuration,
   only ever transmit bundle data in a single segment, in which case
   both the 'S' and 'E' bits MUST be set to one.  However, a node MUST
   be able to receive a bundle that has been transmitted in any
   segment size.

</p>
<p>
   In the bundle protocol specification, a single bundle comprises a
   primary bundle block, a payload block, and zero or more additional
   bundle blocks.  The relationship between the protocol blocks and
   the convergence layer segments is an implementation-specific
   decision.  In particular, a segment MAY contain more than one
   protocol block; alternatively, a single protocol block (such as the
   payload) MAY be split into multiple segments.

</p>
<p>
   However, a single segment MUST NOT contain data of more than a
   single bundle.

</p>
<p>
   Once a transmission of a bundle has commenced, the node MUST only
   send segments containing sequential portions of that bundle until
   it sends a segment with the 'E' bit set.

</p>
<p>
   Following the message header, the length field is an SDNV
   containing the number of bytes of bundle data that are transmitted
   in this segment. Following this length is the actual data contents.

</p>
<a name="sec:acks"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.3"></a><h3>5.3.&nbsp;
Bundle Acknowledgments</h3>

<p>
   Although the TCP transport provides reliable transfer of data
   between transport peers, the typical BSD sockets interface provides
   no means to inform a sending application of when the receiving
   application has processed some amount of transmitted data.  Thus
   after transmitting some data, a bundle protocol agent needs an
   additional mechanism to determine whether the receiving agent has
   successfully received the segment.

</p>
<p>
   To this end, the TCPCL protocol offers an optional feature whereby
   a receiving node transmits acknowledgments of reception of data
   segments.  This feature is enabled if and only if during the
   exchange of contact headers, both parties set the flag to indicate
   that segment acknowledgments are enabled (see <a class='info' href='#sec:contact_header'>Section&nbsp;4.1<span> (</span><span class='info'>Contact Header</span><span>)</span></a>).  If so, then the receiver MUST
   transmit a bundle acknowledgment header when it successfully
   receives each data segment.

</p><br /><hr class="insert" />
<a name="fig:ack_message"></a>

<p>
      The format of a bundle acknowledgment is as follows:
   
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
                        1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 3 3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |  0x2  |0|0|0|0|   acknowledged length ...                     |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;5: Format of bundle acknowledgement messages&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>
   To transmit an acknowledgment, a node first transmits a message
   header with the ACK_SEGMENT type code and all flags set to zero,
   then transmits an SDNV containing the cumulative length of the
   received segment(s) of the current bundle.

</p>
<p>
   For example, suppose the sending node transmits four segments of
   bundle data with lengths 100, 200, 500, and 1000
   respectively. After receiving the first segment, the node sends an
   acknowledgment of length 100.  After the second segment is
   received, the node sends an acknowledgment of length 300. The third
   and fourth acknowledgments are of length 800 and 1800 respectively.

</p>
<a name="sec:refusal"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.4"></a><h3>5.4.&nbsp;
Bundle Refusal</h3>

<p>
   As bundles may be large, the TCPCL supports an optional mechanisms
   by which a receiving node may indicate to the sender that it does
   not want to receive the corresponding bundle.

</p>
<p>
   To do so, upon receiving a DATA_SEGMENT message, the node MAY
   transmit a REFUSE_BUNDLE message.  As data segments and
   acknowledgments may cross on the wire, the data segment (and thus
   the bundle) that is being refused is implicitly identified by the
   sequence in which positive and negative acknowledgments are
   received.

</p>
<p>
   The receiver MUST have acknowledged (positively or negatively) all
   other received DATA_SEGMENTs before the one to be refused so that
   the sender can identify the bundles accepted and refused by means
   of a simple FIFO list of segments and acknowledgments.

</p>
<p>
   The bundle refusal MAY be sent before the entire data segment is
   received.  If a sender receives a REFUSE_BUNDLE message, the sender
   MUST complete the transmission of any partially-sent DATA_SEGMENT
   message (so that the receiver stays in sync).  The sender MUST NOT
   commence transmission of any further segments of the rejected
   bundle subsequently.  Note, however, that this requirement does not
   ensure that a node will not receive another DATA_SEGMENT for the
   same bundle after transmitting a REFUSE_BUNDLE message since
   messages may cross on the wire; if this happens, subsequent
   segments of the bundle SHOULD be refused with a REFUSE_BUNDLE
   message, too.

</p>
<p>
   Note: If a bundle transmission if aborted in this way, the receiver
   may not receive a segment with the 'E' flag set to '1' for the
   aborted bundle.  The beginning of the next bundle is identified by
   the 'S' bit set to '1', indicating the start of a new bundle.

</p>
<a name="sec:keepalive"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.5"></a><h3>5.5.&nbsp;
Keepalive Messages</h3>

<p>
   The protocol includes a provision for transmission of keepalive
   messages over the TCP connection to help determine if the
   connection has been disrupted.

</p>
<p>
   As described in <a class='info' href='#sec:contact_header'>Section&nbsp;4.1<span> (</span><span class='info'>Contact Header</span><span>)</span></a>, one of the
   parameters in the contact header is the keepalive_interval.  Both
   sides populate this field with their requested intervals (in
   seconds) between keepalive messages.

</p>
<p>
   The format of a keepalive message is a one byte message type code
   of KEEPALIVE (as described in <a class='info' href='#types:codes'>Table&nbsp;2<span> (</span><span class='info'>TCPCL Header Types</span><span>)</span></a>, with no
   additional data. Both sides SHOULD send a keepalive message
   whenever the negotiated interval has elapsed with no transmission
   of any message (keepalive or other).

</p>
<p>
   If no message (keepalive or other) has been received for at least
   twice the keepalive interval, then either party may terminate the
   session by transmitting a one byte message type code of SHUTDOWN
   (as described in <a class='info' href='#types:codes'>Table&nbsp;2<span> (</span><span class='info'>TCPCL Header Types</span><span>)</span></a>) and closing the TCP
   connection.

</p>
<p>
   Note: The keepalive interval should not be chosen too short as TCP
   retransmissions may occur in case of packet loss.  Those will have
   to be triggered by a timeout (TCP RTO) which is dependent on the
   measured RTT for the TCP connection so that keepalive message may
   experience noticeable latency.

</p>
<a name="sec:termination"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6"></a><h3>6.&nbsp;
Connection Termination</h3>

<p>
   This section describes the procedures for ending a TCPCL connection.

</p>
<a name="sec:shutdown"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.1"></a><h3>6.1.&nbsp;
Shutdown Message</h3>

<p>
   To cleanly shut down a connection, a SHUTDOWN message MUST be
   transmitted by either the initiator or the acceptor at any point
   following complete transmission of any other message. In case
   acknowledgments have been negotiated, it is advisable to
   acknowledge all received data segments first and then shut down the
   connection.

</p><br /><hr class="insert" />
<a name="fig:shutdown_message"></a>

<p>
      The format of the shutdown message is as follows:
   
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
                        1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 3 3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |  0x3  |0|0|R|D| reason (opt)  | reconnection delay (opt)      |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;6: Format of bundle shutdown messages&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>
   It is possible for a node to convey additional information
   regarding the reason for connection termination.  To do so, the
   node MUST set the 'R' bit in the message header flags, and transmit
   a one-byte reason code immediately following the message
   header. The specified values of the reason code are:

</p><br /><hr class="insert" />
<a name="shutdown:reason"></a>
<table class="full" align="center" border="0" cellpadding="2" cellspacing="2">
<col align="center" width="5%"><col align="left" width="30%"><col align="left" width="65%">
<tr><th align="center">Code</th><th align="left">Meaning</th><th align="left">Comment</th></tr>
<tr>
<td align="center">0x00</td>
<td align="left">Idle timeout</td>
<td align="left">The connection is being closed due to idleness.</td>
</tr>
<tr>
<td align="center">&nbsp;</td>
<td align="left">&nbsp;</td>
<td align="left">&nbsp;</td>
</tr>
<tr>
<td align="center">0x01</td>
<td align="left">Version mismatch</td>
<td align="left">The node cannot conform to the specified TCPCL protocol
      version.</td>
</tr>
<tr>
<td align="center">&nbsp;</td>
<td align="left">&nbsp;</td>
<td align="left">&nbsp;</td>
</tr>
<tr>
<td align="center">0x02</td>
<td align="left">Busy</td>
<td align="left">The node is too busy to handle the current connection.</td>
</tr>
</table>
<br clear="all" />
<table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Table 3: Shutdown Reason Codes&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>
   It is also possible to convey a requested reconnection delay to
   indicate how long the other node must wait before attempting
   connection re-establishment. To do so, the node sets the 'D' bit in
   the message header flags, then transmits an SDNV specifying the
   requested delay, in seconds, following the message header (and
   optionally the shutdown reason code).  The value 0 SHALL be
   interpreted as an infinite delay, i.e. that the connecting node
   MUST NOT re-establish the connection.  In contrast, if the node
   does not wish to request a delay, it SHOULD omit the delay field
   (and set the 'D' bit to zero).  Note that in the figure above, a
   two octet SDNV is shown for convenience of the presentation.

</p>
<p>
   A connection shutdown MAY occur immediately after TCP connection
   establishment or reception of a contact header (and prior to any
   further data exchange).  This may, for example, be used to notify a
   the initiator that the node is currently not capable of or willing
   to communicate.  However, a node MUST always send the contact
   header to its peer first.

</p>
<p>
   If either node terminates a connection prematurely in this manner,
   it SHOULD send a SHUTDOWN message and MUST indicate a reason code
   unless the incoming connection did not include the magic string.
   If a node does not want its peer to re-open the connection
   immediately, it SHOULD set the 'D' bit in the flags and include a
   reconnection delay to indicate when the peer is allowed to attempt
   another connection setup.

</p>
<p>
   If a connection is to be terminated before another protocol message
   has completed, then the node MUST NOT transmit the SHUTDOWN message
   but still SHOULD close the TCP connection.  In particular, if the
   connection is to be closed (for whatever reason) while a node is in
   the process of transmitting a bundle data segment, receiving node
   is still expecting segment data and might erroneously interpret the
   SHUTDOWN message to be part of the data segment.

</p>
<a name="sec:idle"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.2"></a><h3>6.2.&nbsp;
Idle Connection Shutdown</h3>

<p>
   The protocol includes a provision for clean shutdown of idle TCP
   connections. Determining the length of time to wait before closing
   idle connections, if they are to be closed at all, is an
   implementation and configuration matter.

</p>
<p>
   If there is a configured time to close idle links, then if no
   bundle data (other than keepalive messages) has been received for
   at least that amount of time, then either node MAY terminate the
   connection by transmitting a SHUTDOWN message indicating the reason
   code of 'idle timeout' (as described above).  After receiving a
   SHUTDOWN message in response, both sides may close the TCP
   connection.

</p>
<a name="anchor6"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7"></a><h3>7.&nbsp;
Requirements notation</h3>

<p>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL
      NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and
      "OPTIONAL" in this document are to be interpreted as described
      in <a class='info' href='#RFC2119'>[RFC2119]<span> (</span><span class='info'>Bradner, S., &ldquo;Key words for use in RFCs to Indicate Requirement Levels,&rdquo; March&nbsp;1997.</span><span>)</span></a>.
</p>
<a name="anchor7"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.8"></a><h3>8.&nbsp;
Security Considerations</h3>

<p>
   One security consideration for this protocol relates to the fact
   that nodes present their endpoint identifier as part of the
   connection header exchange. It would be possible for a node to
   fake this value and present the identity of a singleton endpoint
   in which the node is not a member, essentially masquerading as
   another DTN node. If this identifier is used without further
   verification as a means to determine which bundles are transmitted
   over the connection, then the node that has falsified its identity
   may be able to obtain bundles that it should not have.

</p>
<p>
   These concerns may be mitigated through the use of
   the <a class='info' href='#refs.dtnsecurity'>Bundle Security
   Protocols<span> (</span><span class='info'>Symington, S., Farrell, S., and H. Weiss, &ldquo;Bundle Security Protocol Specification,&rdquo; April&nbsp;2007.</span><span>)</span></a> [refs.dtnsecurity]. In particular, the Bundle Authentication Header
   defines mechanism for secure exchange of bundles between DTN nodes.
   Thus an implementation could delay trusting the presented endpoint
   identifier until the node can securely validate that its peer is in
   fact the only member of the given singleton endpoint.

</p>
<p>
   Another consideration for this protocol relates to denial of
   service attacks. A node may send a large amount of data over a TCP
   connection, requiring the receiving node to either handle the data,
   attempt to stop the flood of data by sending a REFUSE_BUNDLE
   message, or forcibly terminate the connection. This burden could
   cause denial of service on other, well-behaving connections. There
   is also nothing to prevent a malicious node from continually
   establishing connections and repeatedly trying to send copious
   amounts of bundle data.

</p>
<a name="anchor8"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.9"></a><h3>9.&nbsp;
IANA Considerations</h3>

<p>
   Port number 4556 has been assigned as the default port for the
   TCP convergence layer.

</p>
<a name="rfc.references1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>10.&nbsp;References</h3>
<table width="99%" border="0">
<tr><td class="author-text" valign="top"><a name="RFC2119">[RFC2119]</a></td>
<td class="author-text">Bradner, S., &ldquo;<a href="http://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>,&rdquo; RFC&nbsp;2119, March&nbsp;1997.</td></tr>
<tr><td class="author-text" valign="top"><a name="refs.bundleproto">[refs.bundleproto]</a></td>
<td class="author-text">Scott, K. and S. Burleigh, &ldquo;<a href="http://tools.ietf.org/html/rfc5050">Bundle Protocol Specification</a>,&rdquo; RFC&nbsp;5050, November&nbsp;2007.</td></tr>
<tr><td class="author-text" valign="top"><a name="refs.dtnarch">[refs.dtnarch]</a></td>
<td class="author-text">Cerf et al, V., &ldquo;<a href="http://tools.ietf.org/html/rfc4838">Delay-Tolerant Network Architecture</a>,&rdquo; RFC&nbsp;4838, April&nbsp;2007.</td></tr>
<tr><td class="author-text" valign="top"><a name="refs.dtnimpl">[refs.dtnimpl]</a></td>
<td class="author-text">DTNRG, &ldquo;<a href="http://www.dtnrg.org/Code">Delay Tolerant Networking Reference Implementation</a>.&rdquo;</td></tr>
<tr><td class="author-text" valign="top"><a name="refs.dtnsecurity">[refs.dtnsecurity]</a></td>
<td class="author-text">Symington, S., Farrell, S., and H. Weiss, &ldquo;Bundle Security Protocol Specification,&rdquo; Internet Draft, work in progress&nbsp;draft-irtf-dtnrg-bundle-security-03.txt, April&nbsp;2007.</td></tr>
</table>

<a name="rfc.authors"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>Authors' Addresses</h3>
<table width="99%" border="0" cellpadding="0" cellspacing="0">
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Michael J. Demmer</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">University of California, Berkeley</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Computer Science Division</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">445 Soda Hall</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Berkeley, CA  94720-1776</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">US</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:demmer@cs.berkeley.edu">demmer@cs.berkeley.edu</a></td></tr>
<tr cellpadding="3"><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Joerg Ott</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Helsinki University of Technology</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Department of Communications and Networking</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">PO Box 3000</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">TKK  02015</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Finland</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:jo@netlab.tkk.fi">jo@netlab.tkk.fi</a></td></tr>
</table>
<a name="rfc.copyright"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>Full Copyright Statement</h3>
<p class='copyright'>
Copyright &copy; The IETF Trust (2008).</p>
<p class='copyright'>
This document is subject to the rights,
licenses and restrictions contained in BCP&nbsp;78,
and except as set forth therein,
the authors retain all their rights.</p>
<p class='copyright'>
This document and the information contained herein are provided
on an &ldquo;AS IS&rdquo; basis and THE CONTRIBUTOR,
THE ORGANIZATION HE/SHE REPRESENTS
OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY, THE IETF TRUST
AND THE INTERNET ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT
THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY
IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR
PURPOSE.</p>
<h3>Intellectual Property</h3>
<p class='copyright'>
The IETF takes no position regarding the validity or scope of any
Intellectual Property Rights or other rights that might be claimed
to pertain to the implementation or use of the technology
described in this document or the extent to which any license
under such rights might or might not be available; nor does it
represent that it has made any independent effort to identify any
such rights.
Information on the procedures with respect to
rights in RFC documents can be found in BCP&nbsp;78 and BCP&nbsp;79.</p>
<p class='copyright'>
Copies of IPR disclosures made to the IETF Secretariat and any
assurances of licenses to be made available,
or the result of an attempt made to obtain a general license or
permission for the use of such proprietary rights by implementers or
users of this specification can be obtained from the IETF on-line IPR
repository at <a href='http://www.ietf.org/ipr'>http://www.ietf.org/ipr</a>.</p>
<p class='copyright'>
The IETF invites any interested party to bring to its attention
any copyrights,
patents or patent applications,
or other
proprietary rights that may cover technology that may be required
to implement this standard.
Please address the information to the IETF at <a href='mailto:ietf-ipr@ietf.org'>ietf-ipr@ietf.org</a>.</p>
</body></html>
