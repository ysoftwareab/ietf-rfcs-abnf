



Internet Draft    Policy-Based Management MIB     Nov 22, 2000


                 Policy Based Management MIB
                draft-ietf-snmpconf-pm-04.txt
                      November 22, 2000


                       Steve Waldbusser
                         Jon Saperia
                       Thippanna Hongal





Status of this Memo

This document is an Internet-Draft and is in full conformance
with all provisions of Section 10 of RFC2026.

Internet-Drafts are working documents of the Internet
Engineering Task Force (IETF), its areas, and its working
groups.  Note that other groups may also distribute working
documents as Internet-Drafts.

Internet-Drafts are draft documents valid for a maximum of six
months and may be updated, replaced, or obsoleted by other
documents at any time.  It is inappropriate to use Internet-
Drafts as reference material or to cite them other than as
"work in progress."

The list of current Internet-Drafts can be accessed at
http://www.ietf.org/ietf/1id-abstracts.txt

The list of Internet-Draft Shadow Directories can be accessed
at http://www.ietf.org/shadow.html.

Copyright Notice

   Copyright (C) The Internet Society (2000).  All Rights Reserved.

1.  Abstract

This memo defines a portion of the Management Information Base
(MIB) for use with network management protocols in TCP/IP-
based internets.  In particular, this MIB defines objects that
enable policy-based configuration management of SNMP





Various Authors      Expires May 22, 2001             [Page 1]





Internet Draft    Policy-Based Management MIB     Nov 22, 2000


infrastructures.

2.  The SNMP Management Framework

   The SNMP Management Framework presently consists of five
   major components:

    o   An overall architecture, described in RFC 2571 [1].

    o   Mechanisms for describing and naming objects and
        events for the purpose of management. The first
        version of this Structure of Management Information
        (SMI) is called SMIv1 and described in STD 16, RFC
        1155 [2], STD 16, RFC 1212 [3] and RFC 1215 [4]. The
        second version, called SMIv2, is described in STD 58,
        RFC 2578 [5], RFC 2579 [6] and RFC 2580 [7].

    o   Message protocols for transferring management
        information. The first version of the SNMP message
        protocol is called SNMPv1 and described in STD 15, RFC
        1157 [8]. A second version of the SNMP message
        protocol, which is not an Internet standards track
        protocol, is called SNMPv2c and described in RFC 1901
        [9] and RFC 1906 [10]. The third version of the
        message protocol is called SNMPv3 and described in RFC
        1906 [10], RFC 2572 [11] and RFC 2574 [12].

    o   Protocol operations for accessing management
        information. The first set of protocol operations and
        associated PDU formats is described in STD 15, RFC
        1157 [8]. A second set of protocol operations and
        associated PDU formats is described in RFC 1905 [13].

    o   A set of fundamental applications described in RFC
        2573 [14] and the view-based access control mechanism
        described in RFC 2575 [15].

   A more detailed introduction to the current SNMP Management
   Framework can be found in RFC 2570 [18].

   Managed objects are accessed via a virtual information
   store, termed the Management Information Base or MIB.
   Objects in the MIB are defined using the mechanisms defined
   in the SMI.






Various Authors      Expires May 22, 2001             [Page 2]





Internet Draft    Policy-Based Management MIB     Nov 22, 2000


   This memo specifies a MIB module that is compliant to the
   SMIv2. A MIB conforming to the SMIv1 can be produced
   through the appropriate translations. The resulting
   translated MIB must be semantically equivalent, except
   where objects or events are omitted because no translation
   is possible (use of Counter64). Some machine readable
   information in SMIv2 will be converted into textual
   descriptions in SMIv1 during the translation process.
   However, this loss of machine readable information is not
   considered to change the semantics of the MIB.








































Various Authors      Expires May 22, 2001             [Page 3]





Internet Draft    Policy-Based Management MIB     Nov 22, 2000


3.  Overview

Large IT organizations have developed management strategies to cope
with the extraordinarily large scale and complexity inherent in
today's networks. In particular, they try to configure the network as
a whole by describing and implementing high-level business policies,
rather than managing device by device, where orders of magnitude more
decisions (and mistakes) may be made.

Following this management practice results in the following benefits:
  - Reduced training needs (fewer details to learn)
  - Reduced documentation costs (fewer details to document)
  - Reduced impact of turnover (less ad-hoc knowledge goes out the door)
  - Greater testability (a greater percentage of fielded
    configurations may be tested in the lab)
  - Higher reliability (combination of factors above)
  - Lower cost of changes (changes can be simpler and operate over a
    wider extent)
  - Lower cost of corporate mergers (less knowledge to transfer; fewer
    policies to integrate)
  - Lower cost of ownership (combination of factors above)

To illustrate the concept of "business policies", some examples are:
  - All routers will run code version 6.2
  - On-site contracters will all have special security restrictions on
    their ports
  - All voice over cable ports in California must provide free local
    calling
  - Apply special forwarding to all ports whose customers have paid
    for premium service.

Each of these policies could represent an action applied to hundreds
of thousands of configuration variables.

In order to automate this practice, customers need software tools that
will implement business policies across their network, as well as
a standard protocol that will ensure that it can be applied to all of
their devices, regardless of the vendor.

This practice is called Policy-Based Network Management. This document
defines standard managed objects for the Simple Network Management
Protocol that are used to distribute policies in a standard form
throughout the network.







Various Authors      Expires May 22, 2001             [Page 4]





Internet Draft    Policy-Based Management MIB     Nov 22, 2000


4.  Policy-Based Management Architecture

Policy-based network management is the practice of applying management
operations globally on all managed objects that share certain
attributes.

Policies always express a notion of:
  if (an object has certain characteristics) then (apply operation to
  that object)

Policies take the following normal form:

  if (policyFilter) then (policyAction)

A policyFilter is program code which results in a boolean
to determine whether or not an object is a member of a set of
objects upon which an action is to be performed.

A policyAction is an operation performed on an object or a set of
objects.

These policies are executed on or near managed devices, where the
objects live (and thus their characteristics may be easily inspected),
and where operations on those objects will be performed.

A management station is responsible for distributing an organization's
policies to all of the managed devices in the infrastructure. The
pmPolicyTable provides managed objects for sending a policy to a
managed device.

In this architecture, the objects that policies act on are called
elements. An element is a group of related MIB variables such as all
the variables for interface #7. This enables policies to be expressed
more efficiently and concisely. Elements can also model circuits,
CPUs, queues, processes, systems, etc.

The execution model for policies on a managed device is:

  foreach element for which policyFilter returns true
      execute policyAction on that element

For example:

  If (interface is fast ethernet)       then (apply full-duplex mode)
  If (interface is access)              then (apply security filters)





Various Authors      Expires May 22, 2001             [Page 5]





Internet Draft    Policy-Based Management MIB     Nov 22, 2000


  If (gold service paid for on circuit) then (apply special queueing)

PolicyFilters have the capability of performing comparison operations
on SNMP variables, logical expressions, and other functions. Many
device characteristics are already defined in MIBs and are
easy to include in policyFilter expressions (ifType == ethernet,
frCircuitCommittedBurst < 128K, etc). However, there are
important characteristics that aren't currently in MIB objects, and
worse, it is not current practice to store this information on managed
devices. Therefore, this document defines MIB objects for this
information. To meet today's needs there are three missing areas:
roles, capabilities and time.

Roles

A role is an administratively specified characteristic of a managed
element (for example, an interface). It is a selector for
policies, to determine the applicability of the policy to
a particular managed element.

Some examples of roles are political, financial, legal,
geographical, or architectural characteristics, typically not directly
derivable from information stored on the managed system. For example,
"paid for premium service" or "is plugged into a UPS" are examples of
roles, whereas the percent utilization of a link would not be.

Some types of information one would put into a role include:

  political - describes the role of a person or group of people, or of
              a service that a group of people use. Examples:
              executive, sales, outside-contracter, customer.
        If (attached user is executive) then (apply higher bandwidth)
        If (attached user is outside-contracter) then (restrict access)

  financial/legal - describes what financial consideration was
                    received. Could also include contractual or legal
                    considerations. Examples:
                    paid, gold, free, trial, demo, lifeline
        If (gold service paid for) then (apply special queueing)

  geographical - describes the location of an element. Examples:
                 California, Headquarters, insecure conduit.
        If (interface leaves the building) then (apply special security)

  architectural - describes the network architects "intent" for an





Various Authors      Expires May 22, 2001             [Page 6]





Internet Draft    Policy-Based Management MIB     Nov 22, 2000


                  element. For example: backup, trunk.
         If (interface is backup) then (set ifAdminStatus = down)

  Roles are human defined strings that can be referenced by policy
  code. Roles may be assigned to elements by the role group in
  this MIB as well as through implementation-dependent means. Multiple
  roles may be assigned to each element. Because policy code can make
  policy decisions based on the value of any MIB object, role strings
  will typically contain information not accessible in MIB objects.

  The roleMatch accessor function allows policy code to make
  decisions based on whether or not an element has a particular role
  assigned to it.

  The role group allows a management station to learn what roles exist
  on a managed system. The management station may choose not to
  download policies that depend on a role that does not exist on any
  elements in the system. The management station can then register for
  notifications of new roles. Upon receipt of a pmNewRoleNotification,
  it may choose to download new policies that make use of that new
  role.

Capabilities

  Some actions are inappropriate for certain elements or are simply
  unsupported because a capability doesn't exist or because it is
  restricted. Policy filters must be able to be defined so that a
  policy can be applied only to elements that have the proper
  capability. The capabilities table provides MIB objects that
  describe the capabilities of the system.

  The capMatch accessor function allows policy code to make
  decisions based on whether or not an element has certain
  capabilities.

  The capabilities group allows a management station to learn what
  capabilities exist on a managed system. The management station may
  choose not to download policies that depend on a capability that
  does not exist on any elements in the system. The management station
  can then register for notifications of new capabilities. Upon
  receipt of a pmNewCapabilityNotification, it may choose to download
  new policies that make use of that new capability.

Time






Various Authors      Expires May 22, 2001             [Page 7]





Internet Draft    Policy-Based Management MIB     Nov 22, 2000


  Managers may wish to define policies that are true for certain
  periods of time. This might mean that a policy is downloaded and is
  dormant for a period of time, becomes active, and then later becomes
  inactive. Sometimes these time periods will be regular (M-F 9-5) and
  sometimes ad-hoc. This MIB provides MIB objects that allow
  policies to be dependent on time.


5.  Policy Based Management Execution Environment

There are several steps performed in order to execute policies
in this environment:

    - Element Discovery
    - Element Filtering
    - Policy Enforcement


5.1.  Element Discovery

An element is a uniquely addressable entity on a managed
device. Examples of elements include interfaces, circuits,
queues, CPUs, and processes. Sometimes various attributes of
an entity will be described through tables in several standard
and proprietary MIBs - as long as the indexing is consistent
between these tables, the entity can be modeled as 1 element.
For example, the ifTable and the dot3Stats table both contain
attributes of interfaces and share the same index (ifIndex),
therefore they can be modeled as one element type.

The Element Type Registration table is used for the manager to
learn what element types are being managed by the system and
to register new types if necessary. An element type is
registered by providing the OID of an SNMP object (i.e.,
without the instance). Each SNMP instance that exists under
that object is a distinct element. The address of the element
is the index part of the discovered OID. This address will be
supplied to policy filters and actions so that this code can
inspect and configure the element.

For each element that is discovered, the policy filter is
called with the element address as an argument to see if the
element is a member of the set that the policy acts upon.

If the agent is discovering elements by polling, it should





Various Authors      Expires May 22, 2001             [Page 8]





Internet Draft    Policy-Based Management MIB     Nov 22, 2000


check for new elements no less frequently than
pmElementTypeRegMaxLatency would dictate. When an element is
first discovered all policyFilters are run immediately and
policyFilters that match will have the associated policyAction
run immediately. Subsequently, the policyFilter will be run
regularly for the element with no more than
pmPolicyFilterMaxLatency milliseconds elapsing between each
invocation.


5.1.1.  Implementation Notes

Note that while the external behavior of this registration
process is defined in terms of the walking of MIB tables,
implementation strategies may differ. For example, commonly-
used element types (like interface) may have purpose-built
element discovery capability built-in and advertised to
managers through an entry in the pmElementTypeRegTable.

Before registering an element type, it is the responsibility
of a manager to inspect the table and see if it is already
registered (by the agent or another manager). Note that
entries that differ only in the last OID (which specifies
which object in an entry) are effectively duplicates and
should be treated as such by the manager.

The system which implements the Policy-Based Management MIB
may not have knowledge of the format of object identifiers in
other MIBs. Therefore it is inappropriate for it to check
these OIDs for errors. It is the responsibility of the
management station to register well-formed object-identifiers.
For example, if an extra sub-identifier is supplied when
registering the ifTable, no elements will be discovered.
Similarly, if a sub-identifier is missing, every element will
be discovered numerous times (once per column) and none of the
element addresses will be well-formed.



5.2.  Element Filtering

The first step in executing a policy is to see which elements
match the policy filter. To evaluate a policy, the policy
filter is called once for each element and runs to completion.
The element address is the only state that is passed to the





Various Authors      Expires May 22, 2001             [Page 9]





Internet Draft    Policy-Based Management MIB     Nov 22, 2000


filter code for each invocation (in particular, except for
state accessible from accessor functions, no state is
remembered from the previous invocation of this element nor
from the previous invocation of the policy filter). If any
syntax or processing error occurs, the filter will terminate
immediately for this element. If the filter returns non-zero,
the corresponding policy action will be executed for this
element.

If an element matches a filter and it had not matched that
filter the last time it was checked (or it was a newly-
discovered element), the associated policyAction will be
executed immediately. If the element had matched the filter at
the last check, it will remain in the set of elements that
will whose policyAction will be run within the
policyFilterActionMaxLatency.


5.2.1.  Implementation Notes

It is an implementation-dependent matter as to how policy
filters are scheduled. Each filter/element combination is
conceptually its own process and can be scheduled sequentially
or one or more could be run simultaneously.

Policy filters have no side-effects. Policy filter
interpreters are encouraged to stop processing a filter as
soon as it's return value is known.



5.3.  Policy Enforcement

For each element that has returned non-zero from the policy
filter, the corresponding policy action is called. The element
address is the only state that is passed to the policy action
for each invocation (in particular, except for state
accessible from accessor functions, no state is remembered
from the policy filter evaluation, nor from the previous
filter/action invocation of this element nor from the previous
invocation of the policy filter or action). If any syntax or
processing error occurs, the action will terminate immediately
for this element.







Various Authors      Expires May 22, 2001            [Page 10]





Internet Draft    Policy-Based Management MIB     Nov 22, 2000


5.3.1.  Implementation Notes

It is an implementation-dependent matter as to how policy
actions are scheduled. Each filter/element combination is
conceptually its own process and can be scheduled sequentially
or one or more could be run simultaneously.












































Various Authors      Expires May 22, 2001            [Page 11]





Internet Draft    Policy-Based Management MIB     Nov 22, 2000


6.  Policy Language

Policy filters and policy actions are expressed with the
policy language.

The policy language is intended to be familiar to programmers
in a variety of languages, including Perl and C. There is no
referenceable standard for the Perl language, so the policy
language is defined as a subset of the C language. A subset
was used to provide for easy development of low-cost
interpreters of the policy language and to take away language
constructs that are peculiar to the C language.  For example,
it is expected that both C and Perl programmers will
understand the constructs allowed in the policy language.

Some examples of the features that have been removed from the
C language are: function definitions, pointer variables,
structures, enums, typedefs, floating point and pre-processor
functions.

This language is formally defined as a subset of ISO C [19],
but only allows those constructs that may be expressed in the
BNF documented here. This is done because while BNF doesn't
fully specify syntactical rules (it allows constructs that are
invalid) and doesn't specify semantic rules, it can
successfully be used to define the subset of ISO C that is
required for conformance to this standard. Unless explicitly
described herein, the meaning of any construct expressed in
the BNF can be found by reference to the ANSI/ISO C standard.

The use of comments and newlines are allowed and encouraged
where they will promote readability of policy code.

Policy code in this language must be expressed in the UTF8
character set.



6.1.  Formal Definition

The policy language follows the syntax and semantics of ISO C
[19], but policy code is limited to that which that can be
expressed in the following EBNF form:

    letter            : Any lower or upper case letter or underscore





Various Authors      Expires May 22, 2001            [Page 12]





Internet Draft    Policy-Based Management MIB     Nov 22, 2000


    char              : Any character

    digit             : '0' | '1' | '2' | '3' | '4' |
                        '5' | '6' | '7' | '8' | '9'

    hexdigit         : digit | 'A' | 'B' | 'C' | 'D' | 'E' | 'F' |
                               'a' | 'b' | 'c' | 'd' | 'e' | 'f'

    decimal           : digit+

    integer-constant  : decimal | ( '0' 'x' hexdigit+ )

    char-constant     : ( ''' char ''' ) |
                        ( ''' '' decimal ''' )

    identifier        : letter ( letter | digit )*

    string-literal    : '"' char* '"'

    -- Expressions

    primary-expression:
          identifier
        | integer-constant
        | char-constant
        | string-literal
        | '(' expression ')'

    postfix-expression:
          primary-expression
        | postfix-expression '(' argument-expression-list? ')'
        | postfix-expression '++'
        | postfix-expression '--'
        | postfix-expression '[' expression ']'

    argument-expression-list:
          assignment-expression
        | argument-expression-list ',' assignment-expression

    unary-expression:
          postfix-expression
        | unary-operator unary-expression

    unary_operator:
        '+', '-', ', '!', '++', '--', '&'





Various Authors      Expires May 22, 2001            [Page 13]





Internet Draft    Policy-Based Management MIB     Nov 22, 2000


    multiplicative-expression:
          unary-expression
        | multiplicative-expression '*' unary-expression
        | multiplicative-expression '/' unary-expression
        | multiplicative-expression '%' unary-expression

    additive-expression:
          multiplicative-expression
        | additive-expression '+' multiplicative-expression
        | additive-expression '-' multiplicative-expression

    shift-expression:
          additive-expression
        | shift-expression '<<' additive-expression
        | shift-expression '>>' additive-expression

    relational-expression:
          shift-expression
        | relational-expression '<' shift-expression
        | relational-expression '>' shift-expression
        | relational-expression '<=' shift-expression
        | relational-expression '>=' shift-expression

    equality-expression:
          relational-expression
        | equality-expression '==' relational-expression
        | equality-expression '!=' relational-expression

    AND-expression:
          equality-expression
        | AND-expression '&' equality-expression

    exclusive-OR-expression:
          AND-expression
        | exclusive-OR-expression '^' AND-expression

    inclusive-OR-expression:
          exclusive-OR-expression
        | inclusive-OR-expression '|' exclusive-OR-expression

    logical-AND-expression:
          inclusive-OR-expression
        | logical-AND-expression '&&' inclusive-OR-expression

    logical-OR-expression:





Various Authors      Expires May 22, 2001            [Page 14]





Internet Draft    Policy-Based Management MIB     Nov 22, 2000


          logical-AND-expression
        | logical-OR-expression '||' logical-AND-expression

    assignment-expression:
          logical-OR-expression
        | unary-expression assignment-operator assignment-expression

    assignment-operator:
          '=' | '*=' | '/=' | '%=' | '+=' | '-=' | '<<=' | '>>='
        | '&=' | '^=' | '|='

    expression:
          assignment-expression
        | expression ',' assignment-expression

    constant-expression:
        logical-OR-expression

    ------------------------------------------------------
    -- Declarations

    declaration:
        type-specifier declarator-list ';'

    declarator-list:
          init-declarator
        | declarator-list ',' init-declarator

    init-declarator:
          identifier
        | identifier '=' assignment-expression

    type-specifier:
          'char' | 'int' | 'long' | 'long' 'long'
        | 'unsigned' | 'unsigned' 'int' | 'unsigned' 'long'
        | 'unsigned' 'long' 'long'
        | 'string'

    ------------------------------------------------------
    -- Statements

    statement:
          if-statement
        | non-if-statement






Various Authors      Expires May 22, 2001            [Page 15]





Internet Draft    Policy-Based Management MIB     Nov 22, 2000


    -- if-else-statement is considered a non-if statement for
    -- purpose of resolving dangling if clauses.
    non-if-statement:
          labeled-statement
        | compound-statement
        | expression-statement
        | if-else-statement
        | iteration-statement
        | jump-statement

    compound-statement:
        '{' statement-list? '}'

    statement-list:
        statement
      | statement-list statement

    expression-statement:
        expression? ';'

    if-statement:
        'if' '(' expression ')' statement

    if-else-statement:
        'if' '(' expression ')' non-if-statement 'else' statement

    iteration-statement:
          'while' '(' expression ')' statement
        | 'for' '(' expression? ';' expression? ';' expression? ')'
              statement

    jump-statement:
          'continue' ';'
        | 'break' ';'
        | 'return' expression? ';'


    ---------------------------------------------
    -- Root production.

    policy-code:
        declaration*
        statement-list?







Various Authors      Expires May 22, 2001            [Page 16]





Internet Draft    Policy-Based Management MIB     Nov 22, 2000


7.  Sizes of variables

While ISO C [19] allows implementation flexibility in choosing
the size of the integer types, implementations of the policy
language must use the following sizes:

  type               bits  range
  ----               ----  -----
  int                32    -2147483648 to 2147483647
  long               32    -2147483648 to 2147483647
  long long          64    -9223372036854775808 to 9223372036854775807
  unsigned           32    0 to 4294967296
  unsigned int       32    0 to 4294967296
  unsigned long      32    0 to 4294967296
  unsigned long long 64    0 to 18446744073709551616


8.  String type

The string type is available for use in policy code as if
declared as a typedef prior to a policy's execution (however,
note that typedef is not provided in the C subset valid for
policy code itself).

A string represents a sequence of characters. The string type
is not a null-terminated string and does not need to be pre-
allocated.  Operations on a string that change its length will
automatically allocate or free memory as necessary. Strings
can contain binary data (including null bytes) as well as
printable data. The length of a string cannot be determined by
inspection of the contents of the string (i.e. no null
termination), but can be determined by calling strlen(). When
a string variable is a parameter to a function, it can be
modified by that function.



8.1.  Infix string operators

The following operators are supported for strings. In the
following list, a and b are variables or expressions of type
string and i is an expression of type int.

  Assign: a = b;






Various Authors      Expires May 22, 2001            [Page 17]





Internet Draft    Policy-Based Management MIB     Nov 22, 2000


        Copies the value of b to a. After the copy a and
        b are equal but do not share storage.

  Concatenate: a + b
  Append: a += b
  Index (with range checking): a[i]
  Test for equality: a == b
  Test for not equal: a != b
  Compare: a < b, a > b, a <= b, or a >= b


9.  Address of `this element'

Policy code needs a convenient way to get the components of
the index for "this element" so that they can perform SNMP
operations on it or on related elements.

Two mechanisms are provided.

1. For all oid input parameters to all SNMP Access Functions (but not
   oid utility functions), the token "$n" ('$' followed by an integer
   between 0 and 99) can be used in place of any decimal
   sub-identifier. This token is expanded by the agent at execution
   time to contain the n'th subid of the index for the current
   element. For example, if the element is interface #7, and the
   objectIdentifier is "1.3.6.1.2.1.2.2.1.3.$1", it will be expanded
   to "1.3.6.1.2.1.2.2.1.3.7".

   If the token specified is beyond the length of the index for the
   current element, processing of the containing filter or action will
   be immediately terminated.

2. An array of strings will be available to the policy code. The n'th
   element of the array contains the ascii decimal string value of the
   n'th subidentifier in the index for "this element". The array is
   called iv. The number of subids in the array is called ic.

   For example, if "this element" is frCircuitDLCI.5.57
                                     (ifIndex = 5, DLCI = 57)
         then ic == 2
              iv[0] == 5
              iv[1] == 57








Various Authors      Expires May 22, 2001            [Page 18]





Internet Draft    Policy-Based Management MIB     Nov 22, 2000


10.  Accessor Functions

Accessor functions are built-in functions available primarily
to provide access to information on the local system or to
more efficiently manipulate this information. A group of
functions is organized into a library, the unit of conformance
for function implementation. In order to claim conformance to
a library, an implementation must implement all functions in a
library to the specifications of the library.

In order for a management station or policy code to understand
if a certain library of functions is implemented, each library
will have a registration OID that it registers in this MIB's
capabilities table. Thus, conformance to a library can be
tested with the capMatch library function (in the base
library) or by inspecting the pmCapabilitiesType objects in
the pmCapabilitiesTable.


11.  Base Accessor Function Library

A standard base library of accessor functions is available to
all systems that implement this specification. This library is
known by the capability OID of:

  pmBaseFunctionLibrary ::= { policyMgt pmConformance pmGroups 2 }

This library contains four types of functions:

  - SNMP Access functions
  - Policy Configuration Access functions
  - Utility functions
  - Library Functions


11.1.  SNMP Access Functions

Two sets of SNMP Access functions are available with different
situations in mind:

  - Convenience SNMP Functions

    In an effort to keep simple things simple, these functions are
    easy to use and promote easy to understand code. These functions
    will suffice for the majority of situations where a single





Various Authors      Expires May 22, 2001            [Page 19]





Internet Draft    Policy-Based Management MIB     Nov 22, 2000


    variable is referenced and the desired error recovery is to simply
    (and immediately) give up (and move to the next policy-element
    combination). In more complex cases, the General SNMP Functions
    can be used at the cost of several times the code complexity.

    The convenience SNMP functions are getint, getvar, exists,
    setint, setvar, setRowStatus, and searchcolumn.

  - General SNMP Functions

    The General SNMP functions allow nearly any legal SNMP Message to
    be generated, including those with multiple varbinds, getNext
    operations, notifications, and messages with explicit addressing
    or security specifications.

    The general SNMP functions are writeVarbind, readVarbind,
    and snmpsend.

Many of the accessor functions use a string encoding of a
value that may be one of many SMI data types as input or
output parameters. The actual type is not encoded in the
value, but rather is specified elsewhere, possibly by nature
of the context in which it is used. The encodings are:

Any Integer value
    (INTEGER, Integer32, Counter32, Counter64, Gauge32, Unsigned32,
    TimeTicks, Counter64):

    Ascii-encoded integer in ascii,
    range: -9223372036854775808 to 9223372036854775807

    Note that getint and setint encode integers as C integer values
    and do not use this character string encoding.

Octet String
    The character string contains the unencoded value of the octet
    string.

Object Identifier
    A decimal ascii encoded object identifier stored in a string.

    subid:     decimal
    oid:       subid | subid '.' oid

    Note that ascii descriptors (e.g. "ifIndex") are never used in





Various Authors      Expires May 22, 2001            [Page 20]





Internet Draft    Policy-Based Management MIB     Nov 22, 2000


    these encodings "over the wire". They are never returned from
    accessor functions nor are they ever accepted by them. NMS user
    interfaces are encouraged to allow humans to view object
    identifiers with ascii descriptors, but they must translate those
    descriptors to dotted-decimal format before sending them in MIB
    objects to policy agents.



11.1.1.  Convenience SNMP Functions


11.1.1.1.  getint()

The getint() function is used to retrieve the value of an SNMP
MIB instance when it is known to be of a 32 bit unsigned
integer type. 32-bit signed integer values may be retrieved
but they may have undefined results if the sign bit is set.

     long getint(string oid)

        Oid is a string containing an ASCII dotted-decimal
        representation of an object identifier
        (e.g. "1.3.6.1.2.1.1.1.0").

        The agent will retrieve the instance in the same SNMP context
        in which the element resides. Note that no actual SNMP PDU
        needs to be generated and parsed when the policy MIB module
        resides on the same system as the managed elements.

        If the queried object identifier value does not exist or is
        not a 32-bit integer-valued object, execution of the
        containing code on the current element will immediately
        terminate and the associated policyAction will not be executed
        on the current element.

        This function returns the value of the integer-valued MIB
        instance.

        It is recommended that NMS user interfaces display and allow
        input of MIB object names by their descriptor values followed
        by the index in dotted-decimal form (e.g., "ifType.7).








Various Authors      Expires May 22, 2001            [Page 21]





Internet Draft    Policy-Based Management MIB     Nov 22, 2000


11.1.1.2.  getvar()

The getvar() function is used to retrieve the value of an SNMP
MIB instance.

     string getvar(string oid, string value)

        Oid is a string containing an ASCII dotted-decimal
        representation of an object identifier
        (e.g. "1.3.6.1.2.1.1.1.0").

        The agent will retrieve the instance in the same SNMP context
        in which the element resides. Note that no actual SNMP PDU
        needs to be generated and parsed when the policy MIB module
        resides on the same system as the managed elements.

        If the queried object identifier value does not exist
        execution of the containing code on the current
        element will immediately terminate and the associated
        policyAction will not be executed on the current element.

        This function returns a string containing the returned value,
        encoded according to the returned type.

        The optional argument value will be filled in with
        the returned value if supplied.

        It is recommended that NMS user interfaces display and allow
        input of MIB object names by their descriptor values followed
        by the index in dotted-decimal form (e.g., "ifType.7).

11.1.1.3.  exists()

The exists() function is used to verify the existence of an
SNMP MIB instance.

     int exists(string oid)

        oid is a string containing an ASCII dotted-decimal
        representation of an object identifier
        (e.g. "1.3.6.1.2.1.1.1.0").

        The agent will retrieve the instance in the same SNMP context
        in which the element resides. Note that no actual SNMP PDU
        needs to be generated and parsed when the policy MIB module





Various Authors      Expires May 22, 2001            [Page 22]





Internet Draft    Policy-Based Management MIB     Nov 22, 2000


        resides on the same system as the managed elements.

        This function returns the value 1 if the SNMP instance exists
        and 0 if it doesn't exist.

        It is recommended that NMS user interfaces display and allow
        input of MIB object names by their descriptor values followed
        by the index in dotted-decimal form (e.g., "ifType.7).

11.1.1.4.  setint()

The setint() function is used to set a MIB instance to a
certain integer value. The setint() function is only valid in
policyActions.  If when executing a policyFilter, the agent
encounters a call to the setint() function, execution of the
policyFilter for the current element will immediately
terminate and the associated policyAction will not be executed
on the current element.

    int setint(string oid, long value)

        oid is a string containing an ASCII dotted-decimal
        representation of an object identifier
        (e.g. "1.3.6.1.2.1.1.1.0").

        The agent will set the variable specified by oid
        to the integer value specified by value.

        The agent will set the instance in the same SNMP context
        in which the element resides. Note that no actual SNMP PDU
        needs to be generated and parsed when the policy MIB module
        resides on the same system as the managed elements.

        If the set encounters any error, 0 is returned. If sucessful,
        1 is returned.

        It is recommended that NMS user interfaces display and allow
        input of MIB object names by their descriptor values followed
        by the index in dotted-decimal form (e.g., "ifType.7).

11.1.1.5.  setvar()

The setvar() function is used to set a MIB instance to a
certain value. The setvar() function is only valid in
policyActions.  If when executing a policyFilter, the agent





Various Authors      Expires May 22, 2001            [Page 23]





Internet Draft    Policy-Based Management MIB     Nov 22, 2000


encounters a call to the setvar() function, execution of the
policyFilter for the current element will immediately
terminate and the associated policyAction will not be executed
on the current element.

    int setvar(string oid, string value, int type)

        oid is a string containing an ASCII dotted-decimal
        representation of an object identifier
        (e.g. "1.3.6.1.2.1.1.1.0").

        value is a string encoded in the format appropriate to the
        type parameter. The agent will set the variable specified by
        oid to the value specified by value.

        type is the type of the value parameter and will be one of the
        DataType Constants.

        The agent will set the instance in the same SNMP context
        in which the element resides. Note that no actual SNMP PDU
        needs to be generated and parsed when the policy MIB module
        resides on the same system as the managed elements.

        If the set encounters any error, 0 is returned. If sucessful,
        1 is returned.

        It is recommended that NMS user interfaces display and allow
        input of MIB object names by their descriptor values followed
        by the index in dotted-decimal form (e.g., "ifType.7).

11.1.1.6.  searchcolumn()

    int searchcolumn(string columnoid, string startoid,
                     string value, int type, string oid)

        searchcolumn performs an SNMP walk on a portion of the MIB
        searching for objects with values equal to the `value'
        parameter.

        columnoid constrains the search to only those variables that
        share the same OID prefix (i.e. are beneath it in the OID
        tree).

        startoid is the OID sent in the first getnext packet. While
        the value has not been found and the returned OID still shares





Various Authors      Expires May 22, 2001            [Page 24]





Internet Draft    Policy-Based Management MIB     Nov 22, 2000


        the same prefix wth columnoid, the returned OID will be sent
        in the next getnext query.

        In the first search of a column, startoid will be set to the
        same value as columnoid. If the caller wishes to learn of more
        than one match, it should call searchcolumn multiple times
        where the startoid value should be set to the value returned
        from the previous invocation (effectively continuing the
        search).

        value is the value to be searched for. When a value is found
        that matches exactly, oid is set to the oid of the matched
        value.

        type describes the type of the value to be matched.

        If the search traverses beyond columnoid without finding a
        match, zero is returned.

        For example:
        To find an ethernet interface
        searchcolumn("ifType", "ifType", "6", Integer);

        This sends a getnext request for ifType and continues to walk
        the tree until a value matching 6 is found or a variable
        returns that is not in the 'ifType' subtree.

        To find the next ethernet interface, assuming interface #3
        was discovered to be the first:
        searchcolumn("ifType", "ifType.3", "6", Integer);


11.1.1.7.  setRowStatus()

    int setRowStatus(string oid, int maxTries)

        setRowStatus is used to automate the process of finding an
        unused row in a read-create table that uses RowStatus.

        oid is a string containing an ASCII dotted-decimal
        representation of an object identifier, with one of
        the subids replaced with a '*' character
        (e.g. "1.3.6.1.3.1.99.1.2.1.9.*"). The oid must reference an
        'instance' of the RowStatus object and the '*' must replace
        any integer index item that may be set to some random value.





Various Authors      Expires May 22, 2001            [Page 25]





Internet Draft    Policy-Based Management MIB     Nov 22, 2000


        setRowStatus will come up with a random number for the
        selected index item and will attempt to create the instance
        with the createAndWait state. If the attempt fails, it will
        retry with a different random index value. It will attempt
        this no more than maxTries times.

        setRowStatus returns the successful integer value for the
        index. If unsuccessful after maxTries or if more than one
        '*' is in oid, -1 will be returned.


11.1.2.  General SNMP Functions

It is desireable for a general SNMP interface have the ability
to perform SNMP operations on multiple variables at once and
for it to allow multiple varbind lists to exist at once. The
readVarbind and writeVarbind functions exist in order to
provide these facilities in a language without pointers,
arrays and memory allocators.

readVarbind and writeVarbind access a data store of variable
length varbindlists. The index of the varbindlist and the
index of the variable within that varbindlist are specified in
every readVarbind and writeVarbind operation. Once a
varbindlist has been fully specified by one or more calls to
writeVarbind, it is passed to snmpsend (by referencing the
varbindlist index) and the number of varbinds to be included
in the operation. When a response is returned, the contents of
the response are in the same varbindlist (i.e. the same
varbindlist index is used) and may be read by one or more
calls to readVarbind.

Varbinds in this data store are created automatically whenever
they are written or read by any writeVarbind, readVarbind, or
snmpsend operation. It is not a runtime error to read a
varbind that has not been previously written, however the
values read will be unpredictable.

For example:
  writeVarbind(0, 0, "sysDescr.0", ...);
  writeVarbind(0, 1, "sysOID.0", ...);
  writeVarbind(0, 2, "ifNumber.0", ...);
  if (snmpsend(0, 3, Get, ...))
      return;
  readVarbind(0, 0, iKnowItsSysDescr, iKnowItsaString, value, &len);





Various Authors      Expires May 22, 2001            [Page 26]





Internet Draft    Policy-Based Management MIB     Nov 22, 2000


  readVarbind(0, 1, ...)
  readVarbind(0, 2, ...)
  ...

or,
  writeVarbind(0, 0, "ifIndex", ...);
  writeVarbind(0, 1, "ifType", ...);
  while(!done){
    if (snmpsend(0, 2, Getnext, ...))
        continue;
    readVarbind(0, 0, oid1, ...);
    readVarbind(0, 1, oid2, ...);
    /* leave OIDs alone, now varbindlist #0 is set up for next step
       in table walk. */
    if (oidncmp(oid1, "ifIndex", oidlen("ifIndex")))
      done = 0;
    ...
  }

To be conformant to this specification, implementations must
support at least 5 varbindlists with at least 32 varbinds per
list.

Implementations may, but are not required to, initialize the
varbind database when a new filter or action begins executing.
A policy filter or action can only depend on the state it has
written into this datastore or retrieves with accessor
functions.


11.1.2.1.  writeVarbind()

    void writeVarbind(int varbindListIndex, int varBindIndex,
                      string oid, int type, string value)

        writeVarbind will store the oid, the value and it's type in
        the specified varbind.

        varbindListIndex is a non-negative integer that identifies the
        varbindList modified by this call.

        varbindIndex is a non-negative integer that identifies the
        varbind within the varbindList modified by this call.

        oid is a string containing an ASCII dotted-decimal





Various Authors      Expires May 22, 2001            [Page 27]





Internet Draft    Policy-Based Management MIB     Nov 22, 2000


        representation of an object identifier
        (e.g. "1.3.6.1.2.1.1.1.0").

        type is the type of the value parameter and should be set to
        one of the values for DataType Constants.

        value is a string encoded in the format appropriate to the
        type parameter.



11.1.2.2.  readVarbind()

    void readVarbind(int varbindListIndex, int varBindIndex,
                     string oid, int *type, string value)

        writeVarbind will retrieve the oid, the value and it's type
        from the specified varbind.

        varbindListIndex is a non-negative integer that identifies the
        varbindList read by this call.

        varbindIndex is a non-negative integer that identifies the
        varbind within the varbindList read by this call.

        The object identifier value of the referenced varbind will be
        copied into the oid parameter, formatted in an ASCII
        dotted-decimal representation (e.g. "1.3.6.1.2.1.1.1.0").

        type is the type of the value parameter and will be set to
        one of the values for DataType Constants.

        value is a string encoded in the format appropriate to the
        type parameter.


11.1.2.3.  snmpsend()

    int snmpsend(int varbindListIndex, int numVarbinds, int opcode)

        snmpsend will perform an SNMP operation using the specified
        varbindlist. Note that no actual SNMP PDU needs to be
        generated and parsed when the policy MIB module
        resides on the same system as the managed elements.






Various Authors      Expires May 22, 2001            [Page 28]





Internet Draft    Policy-Based Management MIB     Nov 22, 2000


        The results of the operation will be placed in the same
        varbindList. If an error occurred, the varbindlist will remain
        unmodified except for the following:

          1) If the response PDU had a nonzero error-index, the
             varbind specified by the error-index will have its type
             field replaced with associated error-status constant.
          2) If the response PDU contained varbinds with exceptions,
             the type field of those varbinds will be replaced with
             the appropriate exception (Nosuchobject,
             NosuchInstance, or Endofmibview).
          3) If the error-status was zero and there were no
             exceptions, the varbindlist will remain unmodified. (some
             examples of situations where this will apply are timeout
             and authentication failure).

        This function returns zero unless an error occurs in which
        case it returns the proper SNMP Error Constant.

        varbindListIndex is a non-negative integer that identifies the
        varbindList used by this operation.

        numVarbinds is a integer greater than zero that specified
        which varbinds in the varbindList will be used in this
        operation. The first N varbinds in the varbindList are used.

        opcode is the type of SNMP operation to perform and must be
        one of the values for SNMP Operation Constants.


11.2.  Constants

The following constants are defined for use in all SNMP Access
Functions. Policy code will be executed in an environment
where the following constants are declared. (Note that these
constant declarations will not be visible in the policyFilter
or policyAction MIB objects.)

While these declarations are expressed here as C 'const's, the
'const' construct itself is not available to be used inside of
policy code.

  -- Datatype Constants

  const int Integer       = 1;





Various Authors      Expires May 22, 2001            [Page 29]





Internet Draft    Policy-Based Management MIB     Nov 22, 2000


  const int String        = 2;
  const int Oid           = 3;
  const int Integer32     = 4;
  const int Ipaddress     = 5;
  const int Counter32     = 6;
  const int Gauge32       = 7;
  const int Unsigned32    = 8;
  const int Timeticks     = 9;
  const int Opaque        = 10;
  const int Counter64     = 11;

  -- SNMP Error Constants

  const int Nosuchobject         = 21;
  const int Nosuchinstance       = 22;
  const int Endofmibview         = 23;
  const int Noerror              = 24;
  const int Toobig               = 25;
  const int Nosuchname           = 26;
  const int Badvalue             = 27;
  const int Readonly             = 28;
  const int Generr               = 29;
  const int Noaccess             = 30;
  const int Wrongtype            = 31;
  const int Wronglength          = 32;
  const int Wrongencoding        = 33;
  const int Wrongvalue           = 34;
  const int Nocreation           = 35;
  const int Inconsistentvalue    = 36;
  const int Resourceunavailable  = 37;
  const int Commitfailed         = 38;
  const int Undofailed           = 39;
  const int Authorizationerror   = 40;
  const int Notwritable          = 41;

  const int Badparameter         = 42;
  const int Toolong              = 43;
  const int Parseerror           = 44;
  const int Authfailure          = 45;
  const int Timeout              = 46;

  -- SNMP Operation Constants

  const int Get                  = 0;
  const int Getnext              = 1;





Various Authors      Expires May 22, 2001            [Page 30]





Internet Draft    Policy-Based Management MIB     Nov 22, 2000


  const int Set                  = 3;
  const int Trap                 = 4;
  const int Inform               = 6;
  const int V2trap               = 7;



11.3.  Policy Configuration Access Functions

Policy Configuration Access Functions provide access to
information specifically related to the execution of policies.


11.3.1.  roleMatch()

The roleMatch() function is used to check to see if the
current element has been assigned a particular role.

    int roleMatch(string roleString)

        Argument roleString is a string. If this
        exactly matches (content and length) any role assigned to the
        current element, the function returns 1. If no roles match,
        the function returns 0.

11.3.2.  capMatch()

The capMatch() function is used to check to see if the current
element has a certain capability.

    int capMatch(string capOid)

        Argument capability is a string containing a
        ASCII dotted-decimal representation of an object identifier
        that describes a capability as would be found in the
        pmCapabilitiesTable.

        If the current element has the capability described by
        capString, this function returns 1, otherwise it returns 0.

11.3.3.  elementName()

The elementName() function is used to determine what the
current element is and can be used to provide information
about the type of element as well as how it is indexed.





Various Authors      Expires May 22, 2001            [Page 31]





Internet Draft    Policy-Based Management MIB     Nov 22, 2000


    string elementName()

        elementName returns a string containing an ASCII
        dotted-decimal representation of an object identifier
        (e.g. 1.3.6.1.2.1.1.1.0). This object identifier identifies an
        instance of a MIB object that is an attribute of this element.
        .fi .sh 3 "setScratchpad()"


11.3.4.  setScratchpad()

    setScratchpad(string varName, int scope, string value)

        Every maxLatency time period, every policy runs once for each
        element. When the setScratchpad function executes, it stores a
        value that can be retrieved even after this policy execution
        code exits. The value of scope controls which policy/element
        combinations can retrieve this varName/value pair. The options
        for scope are:

        Global
            The varName/value combination will be available in the
            filter or action of any policy while executing on any
            element.

        Policy
            The varName/value combination will be available in any
            future execution of the filter or action of the current
            policy (regardless of what element the policy is executing
            on).

        PolicyElement
            The varName/value combination will be available in future
            executions of the filter or action of the current policy
            but only when the policy is executing on the current
            element.


        varName is a string used to identify the value. Subsequent
        retrievals of the same varName in the proper scope will return
        the value stored. Note that the namespace for varName is
        distinct for each scope. varName is case sensitive.

        value is a string containing the value to be stored.






Various Authors      Expires May 22, 2001            [Page 32]





Internet Draft    Policy-Based Management MIB     Nov 22, 2000


11.3.5.  getScratchpad()

    int getScratchpad(string varName, int scope, string value)

        The getScratchpad function allows the retrieval of values that
        were stored previously in this execution context or in
        other execution contexts. The value of scope controls which
        execution contexts can pass a value to this execution context.
        Refer to the definition of setScratchpad to see which values
        of scope can pass a value to which execution contexts.

        varName is a string used to identify the value. Subsequent
        retrievals of the same varName in the proper scope will return
        the value stored. Note that the namespace for varName is
        distinct for each scope. As a result, getScratchpad cannot
        force access to a variable in an inaccessible scope - it can
        only retrieve variables by referencing the proper scope in
        which they were set. varName is case sensitive.

        On successful return, value will be set to the value that was
        previously stored.

        This function returns 1 if a value was previously stored and 0
        otherwise.

Scratchpad Usage Examples

      Policy  Element    Action
      A       ifIndex.1  setScratchpad("foo", Global, "55")
      A       ifIndex.1  getScratchpad("foo", Global, val) == 55
      A       ifIndex.2  getScratchpad("foo", Global, val) == 55
      B       ifIndex.2  getScratchpad("foo", Global, val) == 55
      B       ifIndex.2  setScratchpad("foo", Global, "16")
      A       ifIndex.1  getScratchpad("foo", Global, val) == 16

      Policy  Element    Action
      A       ifIndex.1  setScratchpad("bar", Policy, "75")
      A       ifIndex.1  getScratchpad("bar", Policy, val) == 75
      A       ifIndex.2  getScratchpad("bar", Policy, val) == 75
      B       ifIndex.1  getScratchpad("bar", Policy, val) not found
      B       ifIndex.1  setScratchpad("bar", Policy, "20")
      A       ifIndex.2  getScratchpad("bar", Policy, val) == 75
      B       ifIndex.2  getScratchpad("bar", Policy, val) == 20

      Policy  Element    Action





Various Authors      Expires May 22, 2001            [Page 33]





Internet Draft    Policy-Based Management MIB     Nov 22, 2000


      A       ifIndex.1  setScratchpad("baz", PolicyElement, "43")
      A       ifIndex.1  getScratchpad("baz", PolicyElement, val) == 43
      A       ifIndex.2  getScratchpad("baz", PolicyElement, val) not found
      B       ifIndex.1  getScratchpad("baz", PolicyElement, val) not found
      A       ifIndex.2  setScratchpad("baz", PolicyElement, "54")
      B       ifIndex.1  setScratchpad("baz", PolicyElement, "65")
      A       ifIndex.1  getScratchpad("baz", PolicyElement, val) == 43
      A       ifIndex.2  getScratchpad("baz", PolicyElement, val) == 54
      B       ifIndex.1  getScratchpad("baz", PolicyElement, val) == 65

      Policy  Element    Action
      A       ifIndex.1  setScratchpad("foo", PolicyElement, "11")
      A       ifIndex.1  setScratchpad("foo", Global, "22")
      A       ifIndex.1  getScratchpad("foo", PolicyElement, val) == 11
      A       ifIndex.1  getScratchpad("foo", Global, val) == 22


11.3.6.  Constants

The following constants are defined for use for the scratchpad
functions. Policy code will be executed in an environment
where the following constants are declared. (Note that these
constant declarations will not be visible in the policyFilter
or policyAction MIB objects.)

While these declarations are expressed here as C 'const's, the
'const' construct itself is not available to be used inside of
policy code.

  -- Scratchpad Constants

  const int Global           = 0;
  const int Policy           = 1;
  const int PolicyElement    = 2;


11.4.  Utility Accessor Functions

Utility Accessor Functions are provided to enable more
efficient use of the other accessor functions.










Various Authors      Expires May 22, 2001            [Page 34]





Internet Draft    Policy-Based Management MIB     Nov 22, 2000


11.4.1.  oidlength()

    int oidlen(string oid)

        oidlen returns the number of subidentifiers in oid. oid is a
        string containing an ASCII dotted-decimal
        representation of an object identifier
        (e.g. "1.3.6.1.2.1.1.1.0").


11.4.2.  oidncmp()

    int oidncmp(string oid1, string oid2, int n)

        Arguments oid1 and oid2 are strings containing
        ASCII dotted-decimal representations of object identifiers
        (e.g. "1.3.6.1.2.1.1.1.0").

        Compares the first n subidentifiers of oid1 and oid2 and
        returns -1 if oid1 is less than oid2, 0 if they are equal, and
        1 if oid1 is greater than oid2.


11.4.3.  subid()

    int subid(string oid, int n)

        subid returns the value of the n'th (starting at zero)
        subidentifier of oid. oid is a string containing an ASCII
        dotted-decimal representation of an object identifier
        (e.g. "1.3.6.1.2.1.1.1.0").

        If n specifies a subidentifier beyond the length of oid, a
        value of -1 is returned.


11.4.4.  subidwrite()

    int subidwrite(string oid, int n, int subid)

        subid sets the value of the n'th (starting at zero)
        subidentifier of oid to `subid'. oid is a string containing an
        ASCII dotted-decimal representation of an object identifier
        (e.g. "1.3.6.1.2.1.1.1.0").






Various Authors      Expires May 22, 2001            [Page 35]





Internet Draft    Policy-Based Management MIB     Nov 22, 2000


        If n specifies a subidentifier beyond the length of oid, a
        value of -1 is returned.


11.4.5.  oidsplice()

    string oidsplice(string oid1, int m, string oid2, int n)

        oidsplice replaces n subidentifiers in oid1 with all of the
        subidentifiers from oid2, starting at the m'th subidentifier
        in oid1. The oid length will be extended if necessary. The
        resulting oid is returned.


11.5.  Library Accessor Functions

The following standard library accessor functions are
provided:

  strncmp()
  strncasecmp()
  strncat()
  strlen()
  strncpy()
  atoi()
  random()
  memcmp()
  memmove()
  sprintf()





















Various Authors      Expires May 22, 2001            [Page 36]





Internet Draft    Policy-Based Management MIB     Nov 22, 2000


12.  Definitions

POLICY-MANAGEMENT-MIB DEFINITIONS ::= BEGIN
IMPORTS
    MODULE-IDENTITY, OBJECT-TYPE, NOTIFICATION-TYPE,
    Counter32, Integer32, Gauge32, Unsigned32,
    experimental                                 FROM SNMPv2-SMI
    RowStatus, RowPointer, TEXTUAL-CONVENTION    FROM SNMPv2-TC
    MODULE-COMPLIANCE, OBJECT-GROUP,
    NOTIFICATION-GROUP                           FROM SNMPv2-CONF
    SnmpAdminString                              FROM SNMP-FRAMEWORK-MIB;

--  Policy-Based Management MIB

policyMgt MODULE-IDENTITY
    LAST-UPDATED "200011221500Z"  -- November 22, 2000
    ORGANIZATION "IETF SNMP Configuration Working Group"
    CONTACT-INFO
        "


        Steve Waldbusser

        Phone: +1-650-948-6500
        Fax:   +1-650-745-0671
        Email: waldbusser@nextbeacon.com

        Jon Saperia
        JDS Consulting, Inc.
        174 Chapman St.
        Watertown MA 02472-3063
        USA
        Phone: +1-617-744-1079
        Fax:   +1-617-249-0874
        Email: saperia@jdscons.com

        Thippanna Hongal
        Riverstone Networks, Inc.
        5200 Great America Parkway
        Santa Clara, CA, 95054
        USA

        Phone: +1-408-878-6562
        Fax:   +1-408-878-6501
        Email: hongal@riverstonenet.com"





Various Authors      Expires May 22, 2001            [Page 37]





Internet Draft    Policy-Based Management MIB     Nov 22, 2000


    DESCRIPTION
        "The MIB module for rule-based configuration of SNMP
        infrastructures."

    REVISION "200011221500Z"    -- November 22, 2000
    DESCRIPTION
        "The original version of this MIB, published as RFCXXXX."
    ::= { experimental 107 }

UTF8String ::= TEXTUAL-CONVENTION
    DISPLAY-HINT "255a"
    STATUS       current
    DESCRIPTION
        "An octet string containing information typically in
        human-readable form.

        To facilitate internationalization, this
        information is represented using the ISO/IEC
        IS 10646-1 character set, encoded as an octet
        string using the UTF-8 transformation format
        described in [RFC2279].

        Since additional code points are added by
        amendments to the 10646 standard from time
        to time, implementations must be prepared to
        encounter any code point from 0x00000000 to
        0x7fffffff.  Byte sequences that do not
        correspond to the valid UTF-8 encoding of a
        code point or are outside this range are
        prohibited.

        The use of control codes should be avoided.

        When it is necessary to represent a newline,
        the control code sequence CR LF should be used.

        For code points not directly supported by user
        interface hardware or software, an alternative
        means of entry and display, such as hexadecimal,
        may be provided.

        For information encoded in 7-bit US-ASCII,
        the UTF-8 encoding is identical to the
        US-ASCII encoding.






Various Authors      Expires May 22, 2001            [Page 38]





Internet Draft    Policy-Based Management MIB     Nov 22, 2000


        UTF-8 may require multiple bytes to represent a
        single character / code point; thus the length
        of this object in octets may be different from
        the number of characters encoded.  Similarly,
        size constraints refer to the number of encoded
        octets, not the number of characters represented
        by an encoding.

        Note that when this TC is used for an object that
        is used or envisioned to be used as an index, then
        a SIZE restriction MUST be specified so that the
        number of sub-identifiers for any object instance
        does not exceed the limit of 128, as defined by
        [RFC1905].

        Note that the size of an UTF8String object is
        measured in octets, not characters."
       SYNTAX       OCTET STRING

-- The policy group

pmPolicyTable OBJECT-TYPE
    SYNTAX      SEQUENCE OF PmPolicyEntry
    MAX-ACCESS  not-accessible
    STATUS      current
    DESCRIPTION
        "The policy table. A policy is a pairing of a
        policyFilter and a policyAction which is used to apply the
        action to a selected set of elements."
    ::= { policyMgt 1 }

pmPolicyEntry OBJECT-TYPE
    SYNTAX      PmPolicyEntry
    MAX-ACCESS  not-accessible
    STATUS      current
    DESCRIPTION
        "An entry in the policy table."
    INDEX { pmPolicyIndex }
    ::= { pmPolicyTable 1 }

PmPolicyEntry ::= SEQUENCE {
    pmPolicyIndex                Unsigned32,
    pmPolicyFilter               Unsigned32,
    pmPolicyCalendar             RowPointer,
    pmPolicyAction               Unsigned32,





Various Authors      Expires May 22, 2001            [Page 39]





Internet Draft    Policy-Based Management MIB     Nov 22, 2000


    pmPolicyFilterMaxLatency     Unsigned32,
    pmPolicyActionMaxLatency     Unsigned32,
    pmPolicyPrecedence           Unsigned32,
    pmPolicyGroup                UTF8String,
    pmPolicyDescription          UTF8String,
    pmPolicyMatches              Gauge32,
    pmPolicyAbnormalTerminations Gauge32,
    pmPolicyExecutionErrors      Counter32,
    pmPolicyDebugging            INTEGER,
    pmPolicyStatus               RowStatus
}

pmPolicyIndex OBJECT-TYPE
    SYNTAX      Unsigned32
    MAX-ACCESS  not-accessible
    STATUS      current
    DESCRIPTION
         "A unique index for this policy entry."
    ::= { pmPolicyEntry 1 }

pmPolicyFilter OBJECT-TYPE
    SYNTAX      Unsigned32
    MAX-ACCESS  read-only
    STATUS      current
    DESCRIPTION
         "A pointer to the row or rows in the pmPolicyCodeTable that
         contain the filter code for this policy. When a policy entry
         is created, an unused pmPolicyCodeIndex value will be
         assigned to this object.

         A policy filter is one or more policy language statements
         which results in a boolean value that represents whether or
         not an element is a member of a set of elements upon which an
         action is to be performed.

         Filter evaluation stops immediately when any error
         is detected without executing the policyAction.

         The policyFilter is evaluated for various elements. Any
         element for which the policyFilter returns any nonzero value
         will match the filter and will have the associated

                  policyAction executed on that element."
    ::= { pmPolicyEntry 2 }






Various Authors      Expires May 22, 2001            [Page 40]





Internet Draft    Policy-Based Management MIB     Nov 22, 2000


pmPolicyCalendar OBJECT-TYPE
    SYNTAX      RowPointer
    MAX-ACCESS  read-create
    STATUS      current
    DESCRIPTION
         "A pointer to an entry in the schedTable of the Scheduling
         MIB [20]. This policy is active when specified by the
         associated schedule entry.

         If the value of this object is 0.0, this policy is always
         active."
    ::= { pmPolicyEntry 3 }

pmPolicyAction OBJECT-TYPE
    SYNTAX      Unsigned32
    MAX-ACCESS  read-only
    STATUS      current
    DESCRIPTION
         "A pointer to the row or rows in the pmPolicyCodeTable that
         contain the action code for this policy. When a policy entry
         is created, an unused pmPolicyCodeIndex value will be
         assigned to this object.

         A pmPolicyAction is an operation performed on a set of
         elements.

         Action evaluation stops immediately when any error is
         detected."
    ::= { pmPolicyEntry 4 }

pmPolicyFilterMaxLatency OBJECT-TYPE
    SYNTAX      Unsigned32
    UNITS       "milliseconds"
    MAX-ACCESS  read-create
    STATUS      current
    DESCRIPTION
        "Every element under the control of this agent is
        re-checked periodically to see if it is under control of this
        policy by re-running the filter for this policy.
        This object lets the manager control the maximum amount of
        time that may pass before an element is re-checked.

        In other words, in any given interval of this duration, all
        elements must be re-checked. Note that it is an
        implementation-dependent matter as to how the policy agent





Various Authors      Expires May 22, 2001            [Page 41]





Internet Draft    Policy-Based Management MIB     Nov 22, 2000


        schedules the checking of various elements within this
        interval."
    ::= { pmPolicyEntry 5 }

pmPolicyActionMaxLatency OBJECT-TYPE
    SYNTAX      Unsigned32
    UNITS       "milliseconds"
    MAX-ACCESS  read-create
    STATUS      current
    DESCRIPTION
        "Every element that matches this policy's filter and is
        therefore under control of this policy will have this policy's
        action executed periodically to ensure that the element
        remains in the state dictated by the policy.
        This object lets the manager control the maximum amount of
        time that may pass before an element has the action run on
        it.

        In other words, in any given interval of this duration, all
        elements under control of this policy must have the action run
        on them. Note that it is an implementation-dependent matter as
        to how the policy agent schedules the policy action on various
        elements within this interval."
    ::= { pmPolicyEntry 6 }

pmPolicyPrecedence OBJECT-TYPE
    SYNTAX      Unsigned32 (0..65535)
    MAX-ACCESS  read-create
    STATUS      current
    DESCRIPTION
        "The order in which policies on the local system are
        evaluated. A policy with a higher precedence value will
        be evaluated after a policy with a lower precedence. For
        example, a policy with a precedence value of 999 will be
        evaluated after a policy with a precedence value of 998.
        These values must be unique on the local policy system
        that realizes this module. The value for a particular
        policy should be the same across an administrative
        domain, though that is not mandatory.

        When the local policy system performs the evaluation in the
        pmPolicyFilter for the policy identified by this row it will
        also read the pmTrackingElementToPolicyStatus object for each
        object returned as a result of the policy evaluation.  If that
        object is set to modified(3), then the pmPolicyAction shall





Various Authors      Expires May 22, 2001            [Page 42]





Internet Draft    Policy-Based Management MIB     Nov 22, 2000


        not be taken on that element.

        The value of precedence(4), of pmTrackingElementToPolicyStatus
        is an indication that when an evaluation was performed by
        another policy, the pmTrackingElementToPolicyStatus was found
        to have a value of on(1) and that policy had a higher
        precedence value than the policy that initially set the value
        of the pmTrackingElementToPolicyStatus to on(1). In this
        event, the pmTrackingElementToPolicyPrecedence object shall
        have the value of the pmPolicyIndex for the policy with the
        higher precedence value entered. If the policy identified by
        this row of the pmPolicyTable has a higher precedence value
        than the value found in pmTrackingElementToPolicyPrecedence
        then the pmPolicyAction should be performed on the element and
        the pmTrackingElementToPolicyPrecedence object updated with
        the value of the pmPolicyIndex for this policy. The only
        exception to these rules is when the policy that has the
        higher precedence value in not currently running, i.e., the
        schedule is off."
    ::= { pmPolicyEntry 7 }

pmPolicyGroup OBJECT-TYPE
    SYNTAX      UTF8String (SIZE (0..32))
    MAX-ACCESS  read-create
    STATUS      current
    DESCRIPTION
        "An administratively assigned string that is used to group
        policies. Any combination is legal, the pmPolicyGroup object
        does not constrain precedence. That is precedence is evaluated
        independent of grouping though adminstrators might group
        related policies together for clarity."
    ::= { pmPolicyEntry 8 }

pmPolicyDescription OBJECT-TYPE
    SYNTAX      UTF8String (SIZE (0..255))
    MAX-ACCESS  read-create
    STATUS      current
    DESCRIPTION
         "A description of this rule and its significance, typically
         provided by a human."
    ::= { pmPolicyEntry 9 }

pmPolicyMatches OBJECT-TYPE
    SYNTAX      Gauge32
    UNITS       "elements"





Various Authors      Expires May 22, 2001            [Page 43]





Internet Draft    Policy-Based Management MIB     Nov 22, 2000


    MAX-ACCESS  read-create
    STATUS      current
    DESCRIPTION
         "The number of elements that are currently matched by the
         associated pmPolicyFilter."
    ::= { pmPolicyEntry 10 }

pmPolicyAbnormalTerminations OBJECT-TYPE
    SYNTAX      Gauge32
    UNITS       "elements"
    MAX-ACCESS  read-create
    STATUS      current
    DESCRIPTION
         "The number of elements that have experienced processing
         errors in the policyFilter code."
    ::= { pmPolicyEntry 11 }

pmPolicyExecutionErrors OBJECT-TYPE
    SYNTAX      Counter32
    UNITS       "errors"
    MAX-ACCESS  read-only
    STATUS      current
    DESCRIPTION
         "The number of times execution of this policy has been
         terminated due to run-time errors."
    ::= { pmPolicyEntry 12 }

pmPolicyDebugging OBJECT-TYPE
    SYNTAX      INTEGER {
                    off(0),
                    on(1)
                }
    MAX-ACCESS  read-create
    STATUS      current
    DESCRIPTION
         "The status of debugging for this policy. If this is turned
         on(1), log entries will be created in the pmDebuggingTable
         for each run-time error that is experienced by this policy."
    DEFVAL { off }
    ::= { pmPolicyEntry 13 }

pmPolicyStatus OBJECT-TYPE
    SYNTAX      RowStatus
    MAX-ACCESS  read-create
    STATUS      current





Various Authors      Expires May 22, 2001            [Page 44]





Internet Draft    Policy-Based Management MIB     Nov 22, 2000


    DESCRIPTION
         "The status of this pmPolicyEntry.

         The status may not be set to active if any of the related
         entries in the pmPolicyCode table do not have a status of
         active."
    ::= { pmPolicyEntry 14 }


pmPolicyCodeTable OBJECT-TYPE
    SYNTAX      SEQUENCE OF PmPolicyCodeEntry
    MAX-ACCESS  not-accessible
    STATUS      current
    DESCRIPTION
        "The pmPolicyCodeTable stores the code for policy filters and
        actions."
    ::= { policyMgt 2 }

pmPolicyCodeEntry OBJECT-TYPE
    SYNTAX      PmPolicyCodeEntry
    MAX-ACCESS  not-accessible
    STATUS      current
    DESCRIPTION
        "An entry in the policy code table."
    INDEX { pmPolicyCodeProgramIndex, pmPolicyCodeSegment }
    ::= { pmPolicyCodeTable 1 }

PmPolicyCodeEntry ::= SEQUENCE {
    pmPolicyCodeProgramIndex   Unsigned32,
    pmPolicyCodeSegment        Unsigned32,
    pmPolicyCodeText           UTF8String,
    pmPolicyCodeStatus         RowStatus
}

pmPolicyCodeProgramIndex OBJECT-TYPE
    SYNTAX      Unsigned32
    MAX-ACCESS  not-accessible
    STATUS      current
    DESCRIPTION
         "A unique index for each policy filter or action. The code
         for each such filter or action may be composed of multiple
         entries in this table if the code cannot fit in one entry.
         Values of pmPolicyCodeProgramIndex may not be used unless
         they have previously been assigned in the
         pmPolicyFilterProgramIndex or pmPolicyActionProgramIndex





Various Authors      Expires May 22, 2001            [Page 45]





Internet Draft    Policy-Based Management MIB     Nov 22, 2000


         objects."
    ::= { pmPolicyCodeEntry 1 }

pmPolicyCodeSegment OBJECT-TYPE
    SYNTAX      Unsigned32
    MAX-ACCESS  not-accessible
    STATUS      current
    DESCRIPTION
         "A unique index for each segment of a policy filter or
         action.

         When a policy filter or action spans multiple entries in this
         table, the code of that policy starts from the
         lowest-numbered segment and continues with increasing segment
         values until ending with the highest-numbered segment."
    ::= { pmPolicyCodeEntry 2 }

pmPolicyCodeText OBJECT-TYPE
    SYNTAX      UTF8String (SIZE (1..1024))
    MAX-ACCESS  read-create
    STATUS      current
    DESCRIPTION
         "A segment of policy code (filter or action). Lengthy Policy
         filters or actions may be stored in multiple segments in this
         table that share the same value of pmPolicyCodeProgramIndex.
         When multiple segments are used, it is recommended that each
         segment be as large as practical.

         The code

         Entries in this table are associated with policies by values
         of the pmPolicyFilterProgramIndex and
         pmPolicyActionProgramIndex objects. If the status of the
         related policy is active, then this object may not be
         modified."
    ::= { pmPolicyCodeEntry 3 }

pmPolicyCodeStatus OBJECT-TYPE
    SYNTAX      RowStatus
    MAX-ACCESS  read-create
    STATUS      current
    DESCRIPTION
         "The status of this code entry.

         Entries in this table are associated with policies by values





Various Authors      Expires May 22, 2001            [Page 46]





Internet Draft    Policy-Based Management MIB     Nov 22, 2000


         of the pmPolicyFilterProgramIndex and
         pmPolicyActionProgramIndex objects. If the status of the
         related policy is active, then entries in this table may not
         be created or deleted."
    ::= { pmPolicyCodeEntry 4 }

-- Element Type Registration Table

-- The Element Type Registration table is used for the manager to
-- learn what element types are being managed by the system and to
-- register new types if necessary. An element type is registered by
-- providing the OID of an SNMP object (i.e., without the
-- instance). Each SNMP instance that exists under that object is a
-- distinct element. The address of the element is the index part of
-- the discovered OID. This address will be supplied to policy filters
-- and actions so that this code can inspect and configure the
-- element.
--
-- Before registering an element type, it is the responsibility of a
-- manager to inspect the table and see if it is already registered
-- (by the agent or another manager). Note that entries that differ
-- only in the last OID (which specifies which object in an entry) are
-- effectively duplicates and should be treated as such by the
-- manager.
--
-- Note that agents may automatically configure elements in this
-- table.

pmElementTypeRegTable OBJECT-TYPE
    SYNTAX      SEQUENCE OF PmElementTypeRegEntry
    MAX-ACCESS  not-accessible
    STATUS      current
    DESCRIPTION
        "A registration table for element types managed by this
        system."
    ::= { policyMgt 3 }

pmElementTypeRegEntry OBJECT-TYPE
    SYNTAX      PmElementTypeRegEntry
    MAX-ACCESS  not-accessible
    STATUS      current
    DESCRIPTION
        "A registration of an element type."
    INDEX       { pmElementTypeRegIndex }
    ::= { pmElementTypeRegTable 1 }





Various Authors      Expires May 22, 2001            [Page 47]





Internet Draft    Policy-Based Management MIB     Nov 22, 2000


PmElementTypeRegEntry ::= SEQUENCE {
    pmElementTypeRegIndex         Unsigned32,
    pmElementTypeRegOIDPrefix     OBJECT IDENTIFIER,
    pmElementTypeRegMaxLatency    Unsigned32,
    pmElementTypeRegName          UTF8String,
    pmElementTypeRegRowStatus     RowStatus
}

pmElementTypeRegIndex OBJECT-TYPE
    SYNTAX      Unsigned32
    MAX-ACCESS  not-accessible
    STATUS      current
    DESCRIPTION
        "A unique index for this entry."
    ::= { pmElementTypeRegEntry 1 }

pmElementTypeRegOIDPrefix OBJECT-TYPE
    SYNTAX      OBJECT IDENTIFIER
    MAX-ACCESS  read-create
    STATUS      current
    DESCRIPTION
        "An OBJECT IDENTIFIER subtree under which all instances of
        this element type may be found.

        This OBJECT IDENTIFIER should be specified up to, but not
        including, any index objects. The agent will discover all
        instances in the system that are members of the specified
        subtree. It will then execute policy filters (and potentially
        policy actions) for each instance discovered.

        Each invocation of the policy filter will be supplied with a
        parameter. This is derived by taking the last N
        sub-identifiers from the discovered instance, where N is:

           X = number of sub-identifiers in pmElementTypeRegOIDPrefix
           Y = number of sub-identifiers in discovered instance

           N = Y - X
        "
    ::= { pmElementTypeRegEntry 2 }

pmElementTypeRegMaxLatency OBJECT-TYPE
    SYNTAX      Unsigned32
    UNITS       "milliseconds"
    MAX-ACCESS  read-create





Various Authors      Expires May 22, 2001            [Page 48]





Internet Draft    Policy-Based Management MIB     Nov 22, 2000


    STATUS      current
    DESCRIPTION
        "The PM agent is responsible for discovering new elements of
        types that are registered. This object lets the manager
        control the maximum amount of time that may pass between the
        time an element is created and when it is discovered.

        In other words, in any given interval of this duration, all
        new elements must be discovered. Note that it is an
        implementation-dependent matter as to how the policy agent
        schedules the checking of various elements within this
        interval."
    ::= { pmElementTypeRegEntry 3 }

pmElementTypeRegName OBJECT-TYPE
    SYNTAX      UTF8String (SIZE (0..32))
    MAX-ACCESS  read-create
    STATUS      current
    DESCRIPTION
        "A descriptive label for this registered type."
    ::= { pmElementTypeRegEntry 4 }

pmElementTypeRegRowStatus OBJECT-TYPE
    SYNTAX      RowStatus
    MAX-ACCESS  read-create
    STATUS      current
    DESCRIPTION
        "The status of this registration entry."
    ::= { pmElementTypeRegEntry 5 }

-- Role Tables

-- The Role tables associate role strings to elements. It is the
-- responsibility of the agent to keep track of any re-indexing of the
-- underlying SNMP elements and to continue to associate role strings
-- with the element with which they were initially configured.
--
-- The agent must store role string associations in nonvolatile
-- storage.
--
-- The Role String table is visible through 2 SNMP tables. The
-- pmRoleESTable is a read-create table that organizes role strings
-- sorted by element. This table is used to create and modify role
-- strings and their associations.
-- The pmRoleSETable is a read-only table that organizes role strings





Various Authors      Expires May 22, 2001            [Page 49]





Internet Draft    Policy-Based Management MIB     Nov 22, 2000


-- sorted by string. This table is read-only.

pmRoleESTable OBJECT-TYPE
    SYNTAX      SEQUENCE OF PmRoleESEntry
    MAX-ACCESS  not-accessible
    STATUS      current
    DESCRIPTION
         "The role string table with element as the major index."
    ::= { policyMgt 4 }

pmRoleESEntry OBJECT-TYPE
    SYNTAX      PmRoleESEntry
    MAX-ACCESS  not-accessible
    STATUS      current
    DESCRIPTION
         "A role string entry associates a role string with an
         individual element."
    INDEX       { pmRoleESElement, pmRoleESString }
    ::= { pmRoleESTable 1 }

PmRoleESEntry ::= SEQUENCE {
    pmRoleESElement        RowPointer,
    pmRoleESString         UTF8String,
    pmRoleESStatus         RowStatus
}

pmRoleESElement OBJECT-TYPE
    SYNTAX      RowPointer
    MAX-ACCESS  not-accessible
    STATUS      current
    DESCRIPTION
         "The element to which this role string is associated.

         If the agent assigns new indexes in the MIB table to
         represent the same underlying element (re-indexing), the
         agent will modify this value to contain the new index for the
         underlying element."
    ::= { pmRoleESEntry 1 }

pmRoleESString OBJECT-TYPE
    SYNTAX      UTF8String (SIZE (0..64))
    MAX-ACCESS  read-create
    STATUS      current
    DESCRIPTION
         "The role string that is associated with an element through





Various Authors      Expires May 22, 2001            [Page 50]





Internet Draft    Policy-Based Management MIB     Nov 22, 2000


         this table.

         A role string is an administratively specified characteristic
         of a managed element (for example, an interface). It is a
         selector for policy rules, to determine the applicability of
         the rule to a particular managed element."
    ::= { pmRoleESEntry 2 }

pmRoleESStatus OBJECT-TYPE
    SYNTAX      RowStatus
    MAX-ACCESS  read-create
    STATUS      current
    DESCRIPTION
         "The status of this role string."
    ::= { pmRoleESEntry 3 }

pmRoleSETable OBJECT-TYPE
    SYNTAX      SEQUENCE OF PmRoleSEEntry
    MAX-ACCESS  not-accessible
    STATUS      current
    DESCRIPTION
         "A read-only version of the role string table with
         roleString as the major index. The purpose of this
         table is to make it easy to retrieve all elements that
         share a common string."
    ::= { policyMgt 5 }

pmRoleSEEntry OBJECT-TYPE
    SYNTAX      PmRoleSEEntry
    MAX-ACCESS  not-accessible
    STATUS      current
    DESCRIPTION
         "A role string entry associates a role string with an
         individual element."
    INDEX       { pmRoleSEString, pmRoleSEElement }
    ::= { pmRoleSETable 1 }

PmRoleSEEntry ::= SEQUENCE {
    pmRoleSEString         UTF8String,
    pmRoleSEElement        RowPointer
}

pmRoleSEString OBJECT-TYPE
    SYNTAX      UTF8String (SIZE (0..64))
    MAX-ACCESS  not-accessible





Various Authors      Expires May 22, 2001            [Page 51]





Internet Draft    Policy-Based Management MIB     Nov 22, 2000


    STATUS      current
    DESCRIPTION
         "The role string that is associated with an element through
         this table.

         A role string is an administratively specified characteristic
         of a managed element (for example, an interface). It is a
         selector for policy rules, to determine the applicability of
         the rule to a particular managed element."
    ::= { pmRoleSEEntry 1 }

pmRoleSEElement OBJECT-TYPE
    SYNTAX      RowPointer
    MAX-ACCESS  read-only
    STATUS      current
    DESCRIPTION
         "The element to which this role string is associated.

         If the agent assigns new indexes in the MIB table to
         represent the same underlying element (re-indexing), the
         agent will modify this value to contain the new index for the
         underlying element."
    ::= { pmRoleSEEntry 2 }

-- Capabilities table

-- Note that with this table it is not necessary to list all OIDs that
-- a mechanism specific MIB Module supports, just the base OID if
-- the implementation is a fully compliant one. If the implementation
-- is not, then additional rows will exist in the table that list
-- the limitations or enhancements.

pmCapabilitiesTable OBJECT-TYPE
    SYNTAX      SEQUENCE OF PmCapabilitiesEntry
    MAX-ACCESS  not-accessible
    STATUS      current
    DESCRIPTION
         "The pmCapabilitiesTable contains a description of
         the inherent capabilities of the system."
    ::= { policyMgt 6 }

pmCapabilitiesEntry OBJECT-TYPE
    SYNTAX      PmCapabilitiesEntry
    MAX-ACCESS  not-accessible
    STATUS      current





Various Authors      Expires May 22, 2001            [Page 52]





Internet Draft    Policy-Based Management MIB     Nov 22, 2000


    DESCRIPTION
         "The description of a capability or limitation of a
         capability of the system. An entry will exist for each
         domain and mechanism specific ability the system has. In
         the case of a domain specific capability with no mechanism
         specific parameters, the pmCapabilitiesSubType and all other
         columns may be null. Entries will exist that contain
         values for the pmCapabilitiesRestrictOID,
         pmCapabilitiesRestrictType, pmCapabilitiesRestrictValue
         and pmCapabilitiesRestrictString objects only when
         an implementation is reporting a mechanism specific
         restriction. Multiple entries are possible when more
         than one restriction for a type or subtype are needed."
    INDEX       { pmCapabilitiesIndex }
    ::= { pmCapabilitiesTable 1 }

PmCapabilitiesEntry ::= SEQUENCE {
    pmCapabilitiesIndex              Unsigned32,
    pmCapabilitiesType               OBJECT IDENTIFIER,
    pmCapabilitiesSubType            OBJECT IDENTIFIER,
    pmCapabilitiesModificationOID    OBJECT IDENTIFIER,
    pmCapabilitiesModificationType   INTEGER,
    pmCapabilitiesModificationValue  Integer32,
    pmCapabilitiesModificationString OCTET STRING
}

pmCapabilitiesIndex OBJECT-TYPE
    SYNTAX      Unsigned32
    MAX-ACCESS  not-accessible
    STATUS      current
    DESCRIPTION
         "A unique index for this entry."
    ::= { pmCapabilitiesEntry 1 }

pmCapabilitiesType OBJECT-TYPE
    SYNTAX      OBJECT IDENTIFIER
    MAX-ACCESS  read-only
    STATUS      current
    DESCRIPTION
         "The type of the capability represented by this entry.
         The IANA will publish the list of identifiers that are valid
         values for this object."
    ::= { pmCapabilitiesEntry 2 }

pmCapabilitiesSubType OBJECT-TYPE





Various Authors      Expires May 22, 2001            [Page 53]





Internet Draft    Policy-Based Management MIB     Nov 22, 2000


    SYNTAX      OBJECT IDENTIFIER
    MAX-ACCESS  read-only
    STATUS      current
    DESCRIPTION
         "The sub type of capability is a pointer to a mechanism specific
          set of capabilities supporting a base technology. In the case of
          DIFFSERV, the OID value here would be the base OID of the
          Differentiated Services Policy MIB Module."
    ::= { pmCapabilitiesEntry 3 }

pmCapabilitiesModificationOID OBJECT-TYPE
    SYNTAX      OBJECT IDENTIFIER
    MAX-ACCESS  read-only
    STATUS      current
    DESCRIPTION
         "The OID of the object that is either not supported, supported
         with one or more limitations, or expanded by an implementation
         specific module. If this columnar object is other than null then
         there must be at least an entry in pmCapabilitiesModificationType.
         Note that this need not be a leaf node or scalar object. If
         an entire table is not supported, this value can be the base OID
         for the table."
    ::= { pmCapabilitiesEntry 4 }

pmCapabilitiesModificationType OBJECT-TYPE
    SYNTAX      INTEGER {
                    unsupported(0),
                    restricted(1),
                    additional(2),
                    addvalue(3),
                    maxlimit(4),
                    minlimit(5)
                }
    MAX-ACCESS  read-only
    STATUS      current
    DESCRIPTION
         "An unsupported value indicates that the OID in
          pmCapabilitiesModificationOID is not supported on
          this system. A value of 1 indicates that the OID
          is supported but with restricted values
          These constraints are described in the
          pmCapabilitiesModificationValue and
          pmCapabilitiesModificationString objects. A value of
          2 indicates a vendor specific extension to a standard.
          The OID of the new object is pmCapabilitiesModificationOID.





Various Authors      Expires May 22, 2001            [Page 54]





Internet Draft    Policy-Based Management MIB     Nov 22, 2000


          For some implementations, additional functions may be
          provided. addvalue indicates that this row of the table
          describes an additional value that the object can take.
          The specific value is in the pmCapabilitiesModificationValue.
          The values of 4 and 5 indicate restrictions or the removal
          of restrictions for the object identified."
    ::= { pmCapabilitiesEntry 5 }

pmCapabilitiesModificationValue OBJECT-TYPE
    SYNTAX      Integer32 (0..2147483647)
    MAX-ACCESS  read-only
    STATUS      current
    DESCRIPTION
         "If the value of pmCapabilitiesModificationType is 0, this
          object will be null since 0 indicates no support for the
          object at all. A value of 1 in the
          pmCapabilitiesModificationType will be further modified by a
          single integer value in this object that corresponds to
          enumerated integer values that are not supported by the
          system for the object that is identified in this row. This
          value can also represent the limit values in the
          pmCapabilitiesModificationType object."
    ::= { pmCapabilitiesEntry 6 }

pmCapabilitiesModificationString OBJECT-TYPE
    SYNTAX      OCTET STRING
    MAX-ACCESS  read-only
    STATUS      current
    DESCRIPTION
         "Any additional details or description or parameters needed."
    ::= { pmCapabilitiesEntry 7 }

-- Policy Tracking

pmTrackingPolicyToElementTable OBJECT-TYPE
    SYNTAX      SEQUENCE OF PmTrackingPolicyToElementEntry
    MAX-ACCESS  not-accessible
    STATUS      current
    DESCRIPTION
         "The pmTrackingPolicyToElementTable describes what elements
         are under control of a policy. This table is indexed in
         order to optimize retrieval of the entire status for a given
         policy."
    ::= { policyMgt 7 }






Various Authors      Expires May 22, 2001            [Page 55]





Internet Draft    Policy-Based Management MIB     Nov 22, 2000


pmTrackingPolicyToElementEntry OBJECT-TYPE
    SYNTAX      PmTrackingPolicyToElementEntry
    MAX-ACCESS  not-accessible
    STATUS      current
    DESCRIPTION
         "An entry in the pmTrackingPolicyToElementTable.  The
         pmPolicyIndex in the index specifies the policy tracked by
         this entry."
    INDEX       { pmPolicyIndex, pmTrackingPolicyToElementElement }
    ::= { pmTrackingPolicyToElementTable 1 }

PmTrackingPolicyToElementEntry ::= SEQUENCE {
    pmTrackingPolicyToElementElement          RowPointer,
    pmTrackingPolicyToElementStatus           INTEGER
}

pmTrackingPolicyToElementElement OBJECT-TYPE
    SYNTAX      RowPointer
    MAX-ACCESS  not-accessible
    STATUS      current
    DESCRIPTION
         "The element this policy is configuring."
    ::= { pmTrackingPolicyToElementEntry 1 }

pmTrackingPolicyToElementStatus OBJECT-TYPE
    SYNTAX      INTEGER {
                    off(0),
                    on(1)
                }
    MAX-ACCESS  read-only
    STATUS      current
    DESCRIPTION
         "The status of this policy-element relationship. This value
         will be 1 if the associated policyFilter returned 1 for this
         element and if the calendar for the policy is active.

         Entries will only exist in this table if their status is
         on(1). Thus, on(1) is the only value of this object that can
         be retrieved. This object exists so that it can serve as the
         'payload' in the varbind instead of the
         pmTrackingPolicyToElementElement object which is much longer
         and is already in the index (it would otherwise be
         duplicated)."
    ::= { pmTrackingPolicyToElementEntry 2 }






Various Authors      Expires May 22, 2001            [Page 56]





Internet Draft    Policy-Based Management MIB     Nov 22, 2000


-- Element to Policy Table

pmTrackingElementToPolicyTable OBJECT-TYPE
    SYNTAX      SEQUENCE OF PmTrackingElementToPolicyEntry
    MAX-ACCESS  not-accessible
    STATUS      current
    DESCRIPTION
         "The pmTrackingElementToPolicyTable describes what policies
         are controlling an element. This table is indexed in
         order to optimize retrieval of the status of all policies
         active for a given element."
    ::= { policyMgt 8 }

pmTrackingElementToPolicyEntry OBJECT-TYPE
    SYNTAX      PmTrackingElementToPolicyEntry
    MAX-ACCESS  not-accessible
    STATUS      current
    DESCRIPTION
         "An entry in the pmTrackingElementToPolicyTable. The
         pmPolicyIndex in the index specifies the policy tracked by
         this entry."
    INDEX       { pmTrackingElementToPolicyElement, pmPolicyIndex }
    ::= { pmTrackingElementToPolicyTable 1 }

PmTrackingElementToPolicyEntry ::= SEQUENCE {
    pmTrackingElementToPolicyElement          RowPointer,
    pmTrackingElementToPolicyStatus           INTEGER
}

pmTrackingElementToPolicyElement OBJECT-TYPE
    SYNTAX      RowPointer
    MAX-ACCESS  not-accessible
    STATUS      current
    DESCRIPTION
         "The element this policy is configuring."
    ::= { pmTrackingElementToPolicyEntry 1 }

pmTrackingElementToPolicyStatus OBJECT-TYPE
    SYNTAX      INTEGER {
                    off(0),
                    on(1),
                    forceOff(2)
                }
    MAX-ACCESS  read-write
    STATUS      current





Various Authors      Expires May 22, 2001            [Page 57]





Internet Draft    Policy-Based Management MIB     Nov 22, 2000


    DESCRIPTION
         "The status of this policy-element relationship. This value
         will be 1 if the associated policyFilter returned 1 for this
         element and if the calendar for the policy is active.

         Entries will not exist in this table if their status would be
         off(0).

         A policy can be forcibly disabled on a particular element
         by setting this value to forceOff(2). The agent should then
         act as if the policyFilter failed for this element. The
         forceOff(2) state will persist (even across reboots) until
         this value is set to on(1) by a management request. Even if
         the policyFilter later fails for this element, this value
         will stay in the forceOff(2) state."
    ::= { pmTrackingElementToPolicyEntry 2 }

-- Policy Debugging Table

-- Policies that have debugging turned on will generate a log entry in
-- the policy debugging table for every runtine error that occurs in
-- either the filter or action code.

pmDebuggingTable OBJECT-TYPE
    SYNTAX      SEQUENCE OF PmDebuggingEntry
    MAX-ACCESS  not-accessible
    STATUS      current
    DESCRIPTION
         "The pmDebuggingTable logs debugging messages when
         policies experience runtime errors."
    ::= { policyMgt 9 }

pmDebuggingEntry OBJECT-TYPE
    SYNTAX      PmDebuggingEntry
    MAX-ACCESS  not-accessible
    STATUS      current
    DESCRIPTION
         "An entry in the pmDebuggingTable. The pmPolicyIndex in the
         index specifies the policy that encountered the error that
         led to this log entry."
    INDEX       { pmPolicyIndex, pmDebuggingElement,
                  pmDebuggingLogIndex }
    ::= { pmDebuggingTable 1 }

PmDebuggingEntry ::= SEQUENCE {





Various Authors      Expires May 22, 2001            [Page 58]





Internet Draft    Policy-Based Management MIB     Nov 22, 2000


    pmDebuggingElement          RowPointer,
    pmDebuggingLogIndex         Unsigned32,
    pmDebuggingMessage          UTF8String
}

pmDebuggingElement OBJECT-TYPE
    SYNTAX      RowPointer
    MAX-ACCESS  read-only
    STATUS      current
    DESCRIPTION
         "The element the policy was executing on when it encountered
         the error that led to this log entry."
    ::= { pmDebuggingEntry 1 }

pmDebuggingLogIndex OBJECT-TYPE
    SYNTAX      Unsigned32
    MAX-ACCESS  read-only
    STATUS      current
    DESCRIPTION
         "A unique index for this log entry amongst other log entries
         for this policy/element combination."
    ::= { pmDebuggingEntry 2 }

pmDebuggingMessage OBJECT-TYPE
    SYNTAX      UTF8String (SIZE (0..128))
    MAX-ACCESS  read-only
    STATUS      current
    DESCRIPTION
         "An error message generated by the policy execution environment."
    ::= { pmDebuggingEntry 3 }

-- Notification Registration Table

-- A management station may choose not to download policies to a
-- system that depend on roles or capabilities that don't exist on any
-- elements in the system. However, the management station must be able
-- to quickly learn if new roles or capabilities are added to the
-- system so that it can immediately download the policies that make
-- use of that new role or capability. This table allows a management
-- station to register itself so that it will receive
-- pmNewRoleNotifications and pmNewCapabilityNotifications whenever a
-- role or capability first appears on the system.
--
-- pmNewRoleNotifications and pmNewCapabilityNotifications are sent in
-- Inform PDU's so they are automatically retransmitted if they are





Various Authors      Expires May 22, 2001            [Page 59]





Internet Draft    Policy-Based Management MIB     Nov 22, 2000


-- not acknowledged.
--
-- The procedure to guarantee accurate knowledge of roles and
-- capabilities is as follows:
--
--   Step 1: The NMS registers itself in the pmNotificationRegTable
--           Whenever it receives a notification, it adds the new role
--           or capability to its internal database for that system.
--           Followed immediately by:
--   Step 2: The NMS downloads the roles and capabilities from the
--           system from the pmRoleESTable (or pmRoleSETable) and the
--           pmCapabilitiesTable, adding this information to its
--           internal database.
--           Followed immediately by:
--   Step 3: The NMS downloads policies to the system, potentially
--           skipping policies that depend on roles or capabilities
--           that haven't been inserted into the internal database.
--           Followed immediately by:
--   Step 4: Whenever a notification indicates a new role or
--           capability that requires new policies to be downloaded,
--           it will immediately download such policies. The NMS will
--           continue this step indefinitely.

pmNotificationRegTable OBJECT-TYPE
    SYNTAX      SEQUENCE OF PmNotificationRegEntry
    MAX-ACCESS  not-accessible
    STATUS      current
    DESCRIPTION
        "A manager that wishes to receive notifications about new
        roles or capabilities on an agent places an entry in the
        notification registration table. pmNewRoleNotifications and
        pmNewCapabilityNotifications will then be sent to the target
        specified in the associated snmpTargetAddr entry. These
        notifications will be sent until the entry is removed from
        this table."
    ::= { policyMgt 10 }

pmNotificationRegEntry OBJECT-TYPE
    SYNTAX      PmNotificationRegEntry
    MAX-ACCESS  not-accessible
    STATUS      current
    DESCRIPTION
        "An entry in the pmNotificationRegTable."
    INDEX { pmNotificationRegIndex }
    ::= { pmNotificationRegTable 1 }





Various Authors      Expires May 22, 2001            [Page 60]





Internet Draft    Policy-Based Management MIB     Nov 22, 2000


PmNotificationRegEntry ::= SEQUENCE {
    pmNotificationRegIndex                Unsigned32,
    pmNotificationRegSnmpTargetAddrName   SnmpAdminString,
    pmNotificationRegStatus               RowStatus
}

pmNotificationRegIndex OBJECT-TYPE
    SYNTAX      Unsigned32
    MAX-ACCESS  not-accessible
    STATUS      current
    DESCRIPTION
         "A unique index for this entry."
    ::= { pmNotificationRegEntry 1 }

pmNotificationRegSnmpTargetAddrName OBJECT-TYPE
    SYNTAX      SnmpAdminString
    MAX-ACCESS  read-create
    STATUS      current
    DESCRIPTION
         "The snmpTargetAddrName of an associated
         snmpTargetAddrEntry. When the following conditions are true,
         pmNewRoleNotifications and pmNewCapabilityNotifications
         should be sent to the specified target:

           1) The pmNotificationRegEntry is active
           2) The associated snmpTargetAddr entry is fully
              configured and active.
           3) The associated snmpTargetParams entry is fully
              configured and active."
    ::= { pmNotificationRegEntry 2 }

pmNotificationRegStatus OBJECT-TYPE
    SYNTAX      RowStatus
    MAX-ACCESS  read-create
    STATUS      current
    DESCRIPTION
         "The status of this entry."
    ::= { pmNotificationRegEntry 3 }

-- Notifications

pmNotifications OBJECT IDENTIFIER ::= { policyMgt 11 }

pmNewRoleNotification NOTIFICATION-TYPE
    OBJECTS     { pmRoleESString }





Various Authors      Expires May 22, 2001            [Page 61]





Internet Draft    Policy-Based Management MIB     Nov 22, 2000


    STATUS      current
    DESCRIPTION
        "The pmNewRoleNotification is sent when an agent is configured with
        its first instance of a previously unused role string (not
        every time a new element is given a particular role).

        An instance of the pmRoleESString object is sent containing
        the new roleString. In the event that two or more elements are
        given the same role simultaneously, it is an
        implementation-dependent matter as to which pmRoleESString
        instance will be included in the notification."
    ::= { pmNotifications 1 }

pmNewCapabilityNotification NOTIFICATION-TYPE
    OBJECTS     { pmCapabilitiesType }
    STATUS      current
    DESCRIPTION
        "The pmNewCapabilityNotification is sent when an agent
        gains a new capability that did not previously exist in any
        element on the system (not every time an element gains a
        particular role).

        An instance of the pmCapabilitiesType object is sent containing
        the identity of the new capability. In the event that two or
        more elements gain the same role simultaneously, it is an
        implementation-dependent matter as to which pmCapabilitiesType
        instance will be included in the notification."
    ::= { pmNotifications 2 }

-- Compliance Statements

    pmConformance   OBJECT IDENTIFIER ::= { policyMgt 20 }
    pmCompliances   OBJECT IDENTIFIER ::= { pmConformance 1 }
    pmGroups        OBJECT IDENTIFIER ::= { pmConformance 2 }

pmCompliance MODULE-COMPLIANCE
    STATUS  current
    DESCRIPTION
        "Describes the requirements for conformance to
        the Policy-Based Management MIB"
    MODULE  -- this module
        MANDATORY-GROUPS { pmPolicyManagementGroup,
                           pmNotificationGroup }
    ::= { pmCompliances 1 }






Various Authors      Expires May 22, 2001            [Page 62]





Internet Draft    Policy-Based Management MIB     Nov 22, 2000


pmPolicyManagementGroup OBJECT-GROUP
    OBJECTS { pmPolicyFilter, pmPolicyCalendar, pmPolicyAction,
              pmPolicyFilterMaxLatency, pmPolicyActionMaxLatency,
              pmPolicyPrecedence, pmPolicyGroup,
              pmPolicyDescription, pmPolicyMatches,
              pmPolicyAbnormalTerminations,
              pmPolicyExecutionErrors, pmPolicyDebugging,
              pmPolicyStatus,
              pmPolicyCodeText, pmPolicyCodeStatus,
              pmElementTypeRegOIDPrefix, pmElementTypeRegMaxLatency,
              pmElementTypeRegName, pmElementTypeRegRowStatus,
              pmRoleESString, pmRoleESStatus, pmRoleSEElement,
              pmCapabilitiesType, pmCapabilitiesSubType,
              pmCapabilitiesModificationOID,
              pmCapabilitiesModificationType,
              pmCapabilitiesModificationValue,
              pmCapabilitiesModificationString,
              pmTrackingPolicyToElementStatus,
              pmTrackingElementToPolicyStatus,
              pmDebuggingElement, pmDebuggingLogIndex,
              pmDebuggingMessage,
              pmNotificationRegSnmpTargetAddrName,
              pmNotificationRegStatus }
    STATUS  current
    DESCRIPTION
        "Objects that allow for the creation and management of
        configuration policies."
    ::=  { pmGroups 1 }

pmNotificationGroup NOTIFICATION-GROUP
    NOTIFICATIONS { pmNewRoleNotification,
                    pmNewCapabilityNotification }
    STATUS        current
    DESCRIPTION
        "Notifications sent by an Policy MIB agent."
    ::= { pmGroups 2 }

pmBaseFunctionLibrary OBJECT IDENTIFIER ::= { pmGroups 2 }

END










Various Authors      Expires May 22, 2001            [Page 63]





Internet Draft    Policy-Based Management MIB     Nov 22, 2000


13.  Security Considerations

There are a number of management objects defined in this MIB
that have a MAX-ACCESS clause of read-write and/or read-
create.  Such objects may be considered sensitive or
vulnerable in some network environments.  The support for SET
operations in a non-secure environment without proper
protection can have a negative effect on network operations.

SNMPv1 by itself is not a secure environment.  Even if the
network itself is secure (for example by using IPSec), even
then, there is no control as to who on the secure network is
allowed to access and GET/SET (read/change/create/delete) the
objects in this MIB.

It is recommended that the implementors consider the security
features as provided by the SNMPv3 framework.  Specifically,
the use of the User-based Security Model RFC 2574 [12] and the
View-based Access Control Model RFC 2575 [15] is recommended.

It is then a customer/user responsibility to ensure that the
SNMP entity giving access to an instance of this MIB, is
properly configured to give access to the objects only to
those principals (users) that have legitimate rights to indeed
GET or SET (change/create/delete) them.

























Various Authors      Expires May 22, 2001            [Page 64]





Internet Draft    Policy-Based Management MIB     Nov 22, 2000


14.  References

[1]  Harrington, D., Presuhn, R., and B. Wijnen, "An
     Architecture for Describing SNMP Management Frameworks",
     RFC 2571, April 1999.

[2]  Rose, M., and K. McCloghrie, "Structure and
     Identification of Management Information for TCP/IP-based
     Internets", STD 16, RFC 1155, May 1990.

[3]  Rose, M., and K. McCloghrie, "Concise MIB Definitions",
     STD 16, RFC 1212, March 1991.

[4]  Rose, M., "A Convention for Defining Traps for use with
     the SNMP", RFC 1215, March 1991.

[5]  McCloghrie, K., Perkins, D., Schoenwaelder, J., Case, J.,
     Rose, M., and S. Waldbusser, "Structure of Management
     Information Version 2 (SMIv2)", STD 58, RFC 2578, April
     1999.

[6]  McCloghrie, K., Perkins, D., Schoenwaelder, J., Case, J.,
     Rose, M., and S. Waldbusser, "Textual Conventions for
     SMIv2", STD 58, RFC 2579, April 1999.

[7]  McCloghrie, K., Perkins, D., Schoenwaelder, J., Case, J.,
     Rose, M., and S. Waldbusser, "Conformance Statements for
     SMIv2", STD 58, RFC 2580, April 1999.

[8]  Case, J., Fedor, M., Schoffstall, M., and J. Davin,
     "Simple Network Management Protocol", STD 15, RFC 1157,
     May 1990.

[9]  Case, J., McCloghrie, K., Rose, M., and S. Waldbusser,
     "Introduction to Community-based SNMPv2", RFC 1901,
     January 1996.

[10] Case, J., McCloghrie, K., Rose, M., and S. Waldbusser,
     "Transport Mappings for Version 2 of the Simple Network
     Management Protocol (SNMPv2)", RFC 1906, January 1996.

[11] Case, J., Harrington D., Presuhn R., and B. Wijnen,
     "Message Processing and Dispatching for the Simple
     Network Management Protocol (SNMP)", RFC 2572, April
     1999.





Various Authors      Expires May 22, 2001            [Page 65]





Internet Draft    Policy-Based Management MIB     Nov 22, 2000


[12] Blumenthal, U., and B. Wijnen, "User-based Security Model
     (USM) for version 3 of the Simple Network Management
     Protocol (SNMPv3)", RFC 2574, April 1999.

[13] Case, J., McCloghrie, K., Rose, M., and S. Waldbusser,
     "Protocol Operations for Version 2 of the Simple Network
     Management Protocol (SNMPv2)", RFC 1905, January 1996.

[14] Levi, D., Meyer, P., and B. Stewart, "SNMPv3
     Applications", RFC 2573, April 1999.

[15] Wijnen, B., Presuhn, R., and K. McCloghrie, "View-based
     Access Control Model (VACM) for the Simple Network
     Management Protocol (SNMP)", RFC 2575, April 1999.

[16] McCloghrie, K. and M. Rose, Editors, "Management
     Information Base for Network Management of TCP/IP-based
     internets: MIB-II", STD 17, RFC 1213, Hughes LAN Systems,
     Performance Systems International, March 1991.

[17] McCloghrie, K. and F. Kastenholz, "The Interfaces Group
     MIB using SMIv2", RFC 2233, Cisco Systems, FTP Software,
     November 1997.

[18] Case, J., Mundy, R., Partain, D., and B. Stewart,
     "Introduction to Version 3 of the Internet-standard
     Network Management Framework", RFC 2570, April 1999.

[19] International Standards Organization, "C Language
     Specification", X3J11

[20] Levi, D. and J. Schoenwaelder, "Definitions of Managed
     Objects for Scheduling Management Operations", RFC 2591,
     May 1999.

15.  Intellectual Property

The IETF takes no position regarding the validity or scope of
any intellectual property or other rights that might be
claimed to  pertain to the implementation or use of the
technology described in this document or the extent to which
any license under such rights might or might not be available;
neither does it represent that it has made any effort to
identify any such rights.  Information on the IETF's
procedures with respect to rights in standards-track and





Various Authors      Expires May 22, 2001            [Page 66]





Internet Draft    Policy-Based Management MIB     Nov 22, 2000


standards-related documentation can be found in BCP-11.
Copies of claims of rights made available for publication and
any assurances of licenses to be made available, or the result
of an attempt made to obtain a general license or permission
for the use of such proprietary rights by implementors or
users of this specification can be obtained from the IETF
Secretariat.

The IETF invites any interested party to bring to its
attention any copyrights, patents or patent applications, or
other proprietary rights which may cover technology that may
be required to practice this standard.  Please address the
information to the IETF Executive Director.


16.  Full Copyright Statement

Copyright (C) The Internet Society (2000). All Rights Reserved.

This document and translations of it may be copied and
furnished to others, and derivative works that comment on or
otherwise explain it or assist in its implementation may be
prepared, copied, published and distributed, in whole or in
part, without restriction of any kind, provided that the above
copyright notice and this paragraph are included on all such
copies and derivative works.  However, this document itself
may not be modified in any way, such as by removing the
copyright notice or references to the Internet Society or
other Internet organizations, except as needed for the
purpose of developing Internet standards in which case the
procedures for copyrights defined in the Internet Standards
process must be followed, or as required to translate it into
languages other than English.

The limited permissions granted above are perpetual and will
not be revoked by the Internet Society or its successors or
assigns.

This document and the information contained herein is provided
on an "AS IS" basis and THE INTERNET SOCIETY AND THE INTERNET
ENGINEERING TASK FORCE DISCLAIMS ALL WARRANTIES, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE
USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR
ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A
PARTICULAR PURPOSE.





Various Authors      Expires May 22, 2001            [Page 67]





Internet Draft    Policy-Based Management MIB     Nov 22, 2000


Table of Contents


1 Abstract ..............................................    1
2 The SNMP Management Framework .........................    2
3 Overview ..............................................    4
4 Policy-Based Management Architecture ..................    5
5 Policy Based Management Execution Environment .........    8
5.1 Element Discovery ...................................    8
5.1.1 Implementation Notes ..............................    9
5.2 Element Filtering ...................................    9
5.2.1 Implementation Notes ..............................   10
5.3 Policy Enforcement ..................................   10
5.3.1 Implementation Notes ..............................   11
6 Policy Language .......................................   12
6.1 Formal Definition ...................................   12
7 Sizes of variables ....................................   17
8 String type ...........................................   17
8.1 Infix string operators ..............................   17
9 Address of `this element' .............................   18
10 Accessor Functions ...................................   19
11 Base Accessor Function Library .......................   19
11.1 SNMP Access Functions ..............................   19
11.1.1 Convenience SNMP Functions .......................   21
11.1.1.1 getint() .......................................   21
11.1.1.2 getvar() .......................................   22
11.1.1.3 exists() .......................................   22
11.1.1.4 setint() .......................................   23
11.1.1.5 setvar() .......................................   23
11.1.1.6 searchcolumn() .................................   24
11.1.1.7 setRowStatus() .................................   25
11.1.2 General SNMP Functions ...........................   26
11.1.2.1 writeVarbind() .................................   27
11.1.2.2 readVarbind() ..................................   28
11.1.2.3 snmpsend() .....................................   28
11.2 Constants ..........................................   29
11.3 Policy Configuration Access Functions ..............   31
11.3.1 roleMatch() ......................................   31
11.3.2 capMatch() .......................................   31
11.3.3 elementName() ....................................   31
11.3.4 setScratchpad() ..................................   32
11.3.5 getScratchpad() ..................................   33
11.3.6 Constants ........................................   34
11.4 Utility Accessor Functions .........................   34
11.4.1 oidlength() ......................................   35





Various Authors      Expires May 22, 2001            [Page 68]





Internet Draft    Policy-Based Management MIB     Nov 22, 2000


11.4.2 oidncmp() ........................................   35
11.4.3 subid() ..........................................   35
11.4.4 subidwrite() .....................................   35
11.4.5 oidsplice() ......................................   36
11.5 Library Accessor Functions .........................   36
12 Definitions ..........................................   37
13 Security Considerations ..............................   64
14 References ...........................................   65
15 Intellectual Property ................................   66
16 Full Copyright Statement .............................   67








































Various Authors      Expires May 22, 2001            [Page 69]

