<!DOCTYPE html>
<html lang="en" class="Internet-Draft">
<head>
<meta charset="utf-8">
<meta content="Common,Latin" name="scripts">
<meta content="initial-scale=1.0" name="viewport">
<title>More Accurate ECN Feedback in TCP</title>
<meta content="Bob Briscoe" name="author">
<meta content="Mirja KÃ¼hlewind" name="author">
<meta content="Richard Scheffenegger" name="author">
<meta content="
       Explicit Congestion Notification (ECN) is a mechanism where network
      nodes can mark IP packets instead of dropping them to indicate incipient
      congestion to the end-points. Receivers with an ECN-capable transport
      protocol feed back this information to the sender. ECN was originally
      specified for TCP in such a way that only one feedback signal can be
      transmitted per Round-Trip Time (RTT). Recent new TCP mechanisms like
      Congestion Exposure (ConEx), Data Center TCP (DCTCP) or Low Latency Low
      Loss Scalable Throughput (L4S) need more accurate ECN feedback
      information whenever more than one marking is received in one RTT. This
      document updates the original ECN specification to specify a scheme to
      provide more than one feedback signal per RTT in the TCP header. Given
      TCP header space is scarce, it allocates a reserved header bit
      previously assigned to the ECN-Nonce. It also overloads the two existing
      ECN flags in the TCP header. The resulting extra space is exploited to
      feed back the IP-ECN field received during the 3-way handshake as well.
      Supplementary feedback information can optionally be provided in a new
      TCP option, which is never used on the TCP SYN. The document also
      specifies the treatment of this updated TCP wire protocol by
      middleboxes, updating BCP 69 with respect to ACK filtering. 
    " name="description">
<meta content="xml2rfc 3.12.3" name="generator">
<meta content="Congestion Control and Management" name="keyword">
<meta content="Congestion Notification" name="keyword">
<meta content="Feedback" name="keyword">
<meta content="Reliable" name="keyword">
<meta content="Ordered" name="keyword">
<meta content="Protocol" name="keyword">
<meta content="ECN" name="keyword">
<meta content="draft-ietf-tcpm-accurate-ecn-17" name="ietf.draft">
<!-- Generator version information:
  xml2rfc 3.12.3
    Python 3.6.12
    appdirs 1.4.4
    ConfigArgParse 1.5.3
    google-i18n-address 2.5.0
    html5lib 1.1
    intervaltree 3.1.0
    Jinja2 2.11.3
    kitchen 1.2.6
    lxml 4.8.0
    MarkupSafe 2.0.1
    pycountry 22.1.10
    pyflakes 2.4.0
    PyYAML 6.0
    requests 2.27.1
    setuptools 59.6.0
    six 1.16.0
    WeasyPrint 52.5
-->
<link href="/tmp/draft-ietf-tcpm-accurate-ecn-17-mk_1eig2.xml" rel="alternate" type="application/rfc+xml">
<link href="#copyright" rel="license">
<style type="text/css">/*

  NOTE: Changes at the bottom of this file overrides some earlier settings.

  Once the style has stabilized and has been adopted as an official RFC style,
  this can be consolidated so that style settings occur only in one place, but
  for now the contents of this file consists first of the initial CSS work as
  provided to the RFC Formatter (xml2rfc) work, followed by itemized and
  commented changes found necssary during the development of the v3
  formatters.

*/

/* fonts */
@import url('https://fonts.googleapis.com/css?family=Noto+Sans'); /* Sans-serif */
@import url('https://fonts.googleapis.com/css?family=Noto+Serif'); /* Serif (print) */
@import url('https://fonts.googleapis.com/css?family=Roboto+Mono'); /* Monospace */

@viewport {
  zoom: 1.0;
  width: extend-to-zoom;
}
@-ms-viewport {
  width: extend-to-zoom;
  zoom: 1.0;
}
/* general and mobile first */
html {
}
body {
  max-width: 90%;
  margin: 1.5em auto;
  color: #222;
  background-color: #fff;
  font-size: 14px;
  font-family: 'Noto Sans', Arial, Helvetica, sans-serif;
  line-height: 1.6;
  scroll-behavior: smooth;
}
.ears {
  display: none;
}

/* headings */
#title, h1, h2, h3, h4, h5, h6 {
  margin: 1em 0 0.5em;
  font-weight: bold;
  line-height: 1.3;
}
#title {
  clear: both;
  border-bottom: 1px solid #ddd;
  margin: 0 0 0.5em 0;
  padding: 1em 0 0.5em;
}
.author {
  padding-bottom: 4px;
}
h1 {
  font-size: 26px;
  margin: 1em 0;
}
h2 {
  font-size: 22px;
  margin-top: -20px;  /* provide offset for in-page anchors */
  padding-top: 33px;
}
h3 {
  font-size: 18px;
  margin-top: -36px;  /* provide offset for in-page anchors */
  padding-top: 42px;
}
h4 {
  font-size: 16px;
  margin-top: -36px;  /* provide offset for in-page anchors */
  padding-top: 42px;
}
h5, h6 {
  font-size: 14px;
}
#n-copyright-notice {
  border-bottom: 1px solid #ddd;
  padding-bottom: 1em;
  margin-bottom: 1em;
}
/* general structure */
p {
  padding: 0;
  margin: 0 0 1em 0;
  text-align: left;
}
div, span {
  position: relative;
}
div {
  margin: 0;
}
.alignRight.art-text {
  background-color: #f9f9f9;
  border: 1px solid #eee;
  border-radius: 3px;
  padding: 1em 1em 0;
  margin-bottom: 1.5em;
}
.alignRight.art-text pre {
  padding: 0;
}
.alignRight {
  margin: 1em 0;
}
.alignRight > *:first-child {
  border: none;
  margin: 0;
  float: right;
  clear: both;
}
.alignRight > *:nth-child(2) {
  clear: both;
  display: block;
  border: none;
}
svg {
  display: block;
}
.alignCenter.art-text {
  background-color: #f9f9f9;
  border: 1px solid #eee;
  border-radius: 3px;
  padding: 1em 1em 0;
  margin-bottom: 1.5em;
}
.alignCenter.art-text pre {
  padding: 0;
}
.alignCenter {
  margin: 1em 0;
}
.alignCenter > *:first-child {
  border: none;
  /* this isn't optimal, but it's an existence proof.  PrinceXML doesn't
     support flexbox yet.
  */
  display: table;
  margin: 0 auto;
}

/* lists */
ol, ul {
  padding: 0;
  margin: 0 0 1em 2em;
}
ol ol, ul ul, ol ul, ul ol {
  margin-left: 1em;
}
li {
  margin: 0 0 0.25em 0;
}
.ulCompact li {
  margin: 0;
}
ul.empty, .ulEmpty {
  list-style-type: none;
}
ul.empty li, .ulEmpty li {
  margin-top: 0.5em;
}
ul.ulBare, li.ulBare {
  margin-left: 0em !important;
}
ul.compact, .ulCompact,
ol.compact, .olCompact {
  line-height: 100%;
  margin: 0 0 0 2em;
}

/* definition lists */
dl {
}
dl > dt {
  float: left;
  margin-right: 1em;
}
/* 
dl.nohang > dt {
  float: none;
}
*/
dl > dd {
  margin-bottom: .8em;
  min-height: 1.3em;
}
dl.compact > dd, .dlCompact > dd {
  margin-bottom: 0em;
}
dl > dd > dl {
  margin-top: 0.5em;
  margin-bottom: 0em;
}

/* links */
a {
  text-decoration: none;
}
a[href] {
  color: #22e; /* Arlen: WCAG 2019 */
}
a[href]:hover {
  background-color: #f2f2f2;
}
figcaption a[href],
a[href].selfRef {
  color: #222;
}
/* XXX probably not this:
a.selfRef:hover {
  background-color: transparent;
  cursor: default;
} */

/* Figures */
tt, code, pre, code {
  background-color: #f9f9f9;
  font-family: 'Roboto Mono', monospace;
}
pre {
  border: 1px solid #eee;
  margin: 0;
  padding: 1em;
}
img {
  max-width: 100%;
}
figure {
  margin: 0;
}
figure blockquote {
  margin: 0.8em 0.4em 0.4em;
}
figcaption {
  font-style: italic;
  margin: 0 0 1em 0;
}
@media screen {
  pre {
    overflow-x: auto;
    max-width: 100%;
    max-width: calc(100% - 22px);
  }
}

/* aside, blockquote */
aside, blockquote {
  margin-left: 0;
  padding: 1.2em 2em;
}
blockquote {
  background-color: #f9f9f9;
  color: #111; /* Arlen: WCAG 2019 */
  border: 1px solid #ddd;
  border-radius: 3px;
  margin: 1em 0;
}
cite {
  display: block;
  text-align: right;
  font-style: italic;
}

/* tables */
table {
  width: 100%;
  margin: 0 0 1em;
  border-collapse: collapse;
  border: 1px solid #eee;
}
th, td {
  text-align: left;
  vertical-align: top;
  padding: 0.5em 0.75em;
}
th {
  text-align: left;
  background-color: #e9e9e9;
}
tr:nth-child(2n+1) > td {
  background-color: #f5f5f5;
}
table caption {
  font-style: italic;
  margin: 0;
  padding: 0;
  text-align: left;
}
table p {
  /* XXX to avoid bottom margin on table row signifiers. If paragraphs should
     be allowed within tables more generally, it would be far better to select on a class. */
  margin: 0;
}

/* pilcrow */
a.pilcrow {
  color: #666; /* Arlen: AHDJ 2019 */
  text-decoration: none;
  visibility: hidden;
  user-select: none;
  -ms-user-select: none;
  -o-user-select:none;
  -moz-user-select: none;
  -khtml-user-select: none;
  -webkit-user-select: none;
  -webkit-touch-callout: none;
}
@media screen {
  aside:hover > a.pilcrow,
  p:hover > a.pilcrow,
  blockquote:hover > a.pilcrow,
  div:hover > a.pilcrow,
  li:hover > a.pilcrow,
  pre:hover > a.pilcrow {
    visibility: visible;
  }
  a.pilcrow:hover {
    background-color: transparent;
  }
}

/* misc */
hr {
  border: 0;
  border-top: 1px solid #eee;
}
.bcp14 {
  font-variant: small-caps;
}

.role {
  font-variant: all-small-caps;
}

/* info block */
#identifiers {
  margin: 0;
  font-size: 0.9em;
}
#identifiers dt {
  width: 3em;
  clear: left;
}
#identifiers dd {
  float: left;
  margin-bottom: 0;
}
/* Fix PDF info block run off issue */
@media print {
  #identifiers dd {
    float: none;
  }
}
#identifiers .authors .author {
  display: inline-block;
  margin-right: 1.5em;
}
#identifiers .authors .org {
  font-style: italic;
}

/* The prepared/rendered info at the very bottom of the page */
.docInfo {
  color: #666; /* Arlen: WCAG 2019 */
  font-size: 0.9em;
  font-style: italic;
  margin-top: 2em;
}
.docInfo .prepared {
  float: left;
}
.docInfo .prepared {
  float: right;
}

/* table of contents */
#toc  {
  padding: 0.75em 0 2em 0;
  margin-bottom: 1em;
}
nav.toc ul {
  margin: 0 0.5em 0 0;
  padding: 0;
  list-style: none;
}
nav.toc li {
  line-height: 1.3em;
  margin: 0.75em 0;
  padding-left: 1.2em;
  text-indent: -1.2em;
}
/* references */
.references dt {
  text-align: right;
  font-weight: bold;
  min-width: 7em;
}
.references dd {
  margin-left: 8em;
  overflow: auto;
}

.refInstance {
  margin-bottom: 1.25em;
}

.references .ascii {
  margin-bottom: 0.25em;
}

/* index */
.index ul {
  margin: 0 0 0 1em;
  padding: 0;
  list-style: none;
}
.index ul ul {
  margin: 0;
}
.index li {
  margin: 0;
  text-indent: -2em;
  padding-left: 2em;
  padding-bottom: 5px;
}
.indexIndex {
  margin: 0.5em 0 1em;
}
.index a {
  font-weight: 700;
}
/* make the index two-column on all but the smallest screens */
@media (min-width: 600px) {
  .index ul {
    -moz-column-count: 2;
    -moz-column-gap: 20px;
  }
  .index ul ul {
    -moz-column-count: 1;
    -moz-column-gap: 0;
  }
}

/* authors */
address.vcard {
  font-style: normal;
  margin: 1em 0;
}

address.vcard .nameRole {
  font-weight: 700;
  margin-left: 0;
}
address.vcard .label {
  font-family: "Noto Sans",Arial,Helvetica,sans-serif;
  margin: 0.5em 0;
}
address.vcard .type {
  display: none;
}
.alternative-contact {
  margin: 1.5em 0 1em;
}
hr.addr {
  border-top: 1px dashed;
  margin: 0;
  color: #ddd;
  max-width: calc(100% - 16px);
}

/* temporary notes */
.rfcEditorRemove::before {
  position: absolute;
  top: 0.2em;
  right: 0.2em;
  padding: 0.2em;
  content: "The RFC Editor will remove this note";
  color: #9e2a00; /* Arlen: WCAG 2019 */
  background-color: #ffd; /* Arlen: WCAG 2019 */
}
.rfcEditorRemove {
  position: relative;
  padding-top: 1.8em;
  background-color: #ffd; /* Arlen: WCAG 2019 */
  border-radius: 3px;
}
.cref {
  background-color: #ffd; /* Arlen: WCAG 2019 */
  padding: 2px 4px;
}
.crefSource {
  font-style: italic;
}
/* alternative layout for smaller screens */
@media screen and (max-width: 1023px) {
  body {
    padding-top: 2em;
  }
  #title {
    padding: 1em 0;
  }
  h1 {
    font-size: 24px;
  }
  h2 {
    font-size: 20px;
    margin-top: -18px;  /* provide offset for in-page anchors */
    padding-top: 38px;
  }
  #identifiers dd {
    max-width: 60%;
  }
  #toc {
    position: fixed;
    z-index: 2;
    top: 0;
    right: 0;
    padding: 0;
    margin: 0;
    background-color: inherit;
    border-bottom: 1px solid #ccc;
  }
  #toc h2 {
    margin: -1px 0 0 0;
    padding: 4px 0 4px 6px;
    padding-right: 1em;
    min-width: 190px;
    font-size: 1.1em;
    text-align: right;
    background-color: #444;
    color: white;
    cursor: pointer;
  }
  #toc h2::before { /* css hamburger */
    float: right;
    position: relative;
    width: 1em;
    height: 1px;
    left: -164px;
    margin: 6px 0 0 0;
    background: white none repeat scroll 0 0;
    box-shadow: 0 4px 0 0 white, 0 8px 0 0 white;
    content: "";
  }
  #toc nav {
    display: none;
    padding: 0.5em 1em 1em;
    overflow: auto;
    height: calc(100vh - 48px);
    border-left: 1px solid #ddd;
  }
}

/* alternative layout for wide screens */
@media screen and (min-width: 1024px) {
  body {
    max-width: 724px;
    margin: 42px auto;
    padding-left: 1.5em;
    padding-right: 29em;
  }
  #toc {
    position: fixed;
    top: 42px;
    right: 42px;
    width: 25%;
    margin: 0;
    padding: 0 1em;
    z-index: 1;
  }
  #toc h2 {
    border-top: none;
    border-bottom: 1px solid #ddd;
    font-size: 1em;
    font-weight: normal;
    margin: 0;
    padding: 0.25em 1em 1em 0;
  }
  #toc nav {
    display: block;
    height: calc(90vh - 84px);
    bottom: 0;
    padding: 0.5em 0 0;
    overflow: auto;
  }
  img { /* future proofing */
    max-width: 100%;
    height: auto;
  }
}

/* pagination */
@media print {
  body {

    width: 100%;
  }
  p {
    orphans: 3;
    widows: 3;
  }
  #n-copyright-notice {
    border-bottom: none;
  }
  #toc, #n-introduction {
    page-break-before: always;
  }
  #toc {
    border-top: none;
    padding-top: 0;
  }
  figure, pre {
    page-break-inside: avoid;
  }
  figure {
    overflow: scroll;
  }
  h1, h2, h3, h4, h5, h6 {
    page-break-after: avoid;
  }
  h2+*, h3+*, h4+*, h5+*, h6+* {
    page-break-before: avoid;
  }
  pre {
    white-space: pre-wrap;
    word-wrap: break-word;
    font-size: 10pt;
  }
  table {
    border: 1px solid #ddd;
  }
  td {
    border-top: 1px solid #ddd;
  }
}

/* This is commented out here, as the string-set: doesn't
   pass W3C validation currently */
/*
.ears thead .left {
  string-set: ears-top-left content();
}

.ears thead .center {
  string-set: ears-top-center content();
}

.ears thead .right {
  string-set: ears-top-right content();
}

.ears tfoot .left {
  string-set: ears-bottom-left content();
}

.ears tfoot .center {
  string-set: ears-bottom-center content();
}

.ears tfoot .right {
  string-set: ears-bottom-right content();
}
*/

@page :first {
  padding-top: 0;
  @top-left {
    content: normal;
    border: none;
  }
  @top-center {
    content: normal;
    border: none;
  }
  @top-right {
    content: normal;
    border: none;
  }
}

@page {
  size: A4;
  margin-bottom: 45mm;
  padding-top: 20px;
  /* The follwing is commented out here, but set appropriately by in code, as
     the content depends on the document */
  /*
  @top-left {
    content: 'Internet-Draft';
    vertical-align: bottom;
    border-bottom: solid 1px #ccc;
  }
  @top-left {
    content: string(ears-top-left);
    vertical-align: bottom;
    border-bottom: solid 1px #ccc;
  }
  @top-center {
    content: string(ears-top-center);
    vertical-align: bottom;
    border-bottom: solid 1px #ccc;
  }
  @top-right {
    content: string(ears-top-right);
    vertical-align: bottom;
    border-bottom: solid 1px #ccc;
  }
  @bottom-left {
    content: string(ears-bottom-left);
    vertical-align: top;
    border-top: solid 1px #ccc;
  }
  @bottom-center {
    content: string(ears-bottom-center);
    vertical-align: top;
    border-top: solid 1px #ccc;
  }
  @bottom-right {
      content: '[Page ' counter(page) ']';
      vertical-align: top;
      border-top: solid 1px #ccc;
  }
  */

}

/* Changes introduced to fix issues found during implementation */
/* Make sure links are clickable even if overlapped by following H* */
a {
  z-index: 2;
}
/* Separate body from document info even without intervening H1 */
section {
  clear: both;
}


/* Top align author divs, to avoid names without organization dropping level with org names */
.author {
  vertical-align: top;
}

/* Leave room in document info to show Internet-Draft on one line */
#identifiers dt {
  width: 8em;
}

/* Don't waste quite as much whitespace between label and value in doc info */
#identifiers dd {
  margin-left: 1em;
}

/* Give floating toc a background color (needed when it's a div inside section */
#toc {
  background-color: white;
}

/* Make the collapsed ToC header render white on gray also when it's a link */
@media screen and (max-width: 1023px) {
  #toc h2 a,
  #toc h2 a:link,
  #toc h2 a:focus,
  #toc h2 a:hover,
  #toc a.toplink,
  #toc a.toplink:hover {
    color: white;
    background-color: #444;
    text-decoration: none;
  }
}

/* Give the bottom of the ToC some whitespace */
@media screen and (min-width: 1024px) {
  #toc {
    padding: 0 0 1em 1em;
  }
}

/* Style section numbers with more space between number and title */
.section-number {
  padding-right: 0.5em;
}

/* prevent monospace from becoming overly large */
tt, code, pre, code {
  font-size: 95%;
}

/* Fix the height/width aspect for ascii art*/
pre.sourcecode,
.art-text pre {
  line-height: 1.12;
}


/* Add styling for a link in the ToC that points to the top of the document */
a.toplink {
  float: right;
  margin-right: 0.5em;
}

/* Fix the dl styling to match the RFC 7992 attributes */
dl > dt,
dl.dlParallel > dt {
  float: left;
  margin-right: 1em;
}
dl.dlNewline > dt {
  float: none;
}

/* Provide styling for table cell text alignment */
table td.text-left,
table th.text-left {
  text-align: left;
}
table td.text-center,
table th.text-center {
  text-align: center;
}
table td.text-right,
table th.text-right {
  text-align: right;
}

/* Make the alternative author contact informatio look less like just another
   author, and group it closer with the primary author contact information */
.alternative-contact {
  margin: 0.5em 0 0.25em 0;
}
address .non-ascii {
  margin: 0 0 0 2em;
}

/* With it being possible to set tables with alignment
  left, center, and right, { width: 100%; } does not make sense */
table {
  width: auto;
}

/* Avoid reference text that sits in a block with very wide left margin,
   because of a long floating dt label.*/
.references dd {
  overflow: visible;
}

/* Control caption placement */
caption {
  caption-side: bottom;
}

/* Limit the width of the author address vcard, so names in right-to-left
   script don't end up on the other side of the page. */

address.vcard {
  max-width: 30em;
  margin-right: auto;
}

/* For address alignment dependent on LTR or RTL scripts */
address div.left {
  text-align: left;
}
address div.right {
  text-align: right;
}

/* Provide table alignment support.  We can't use the alignX classes above
   since they do unwanted things with caption and other styling. */
table.right {
 margin-left: auto;
 margin-right: 0;
}
table.center {
 margin-left: auto;
 margin-right: auto;
}
table.left {
 margin-left: 0;
 margin-right: auto;
}

/* Give the table caption label the same styling as the figcaption */
caption a[href] {
  color: #222;
}

@media print {
  .toplink {
    display: none;
  }

  /* avoid overwriting the top border line with the ToC header */
  #toc {
    padding-top: 1px;
  }

  /* Avoid page breaks inside dl and author address entries */
  .vcard {
    page-break-inside: avoid;
  }

}
/* Tweak the bcp14 keyword presentation */
.bcp14 {
  font-variant: small-caps;
  font-weight: bold;
  font-size: 0.9em;
}
/* Tweak the invisible space above H* in order not to overlay links in text above */
 h2 {
  margin-top: -18px;  /* provide offset for in-page anchors */
  padding-top: 31px;
 }
 h3 {
  margin-top: -18px;  /* provide offset for in-page anchors */
  padding-top: 24px;
 }
 h4 {
  margin-top: -18px;  /* provide offset for in-page anchors */
  padding-top: 24px;
 }
/* Float artwork pilcrow to the right */
@media screen {
  .artwork a.pilcrow {
    display: block;
    line-height: 0.7;
    margin-top: 0.15em;
  }
}
/* Make pilcrows on dd visible */
@media screen {
  dd:hover > a.pilcrow {
    visibility: visible;
  }
}
/* Make the placement of figcaption match that of a table's caption
   by removing the figure's added bottom margin */
.alignLeft.art-text,
.alignCenter.art-text,
.alignRight.art-text {
   margin-bottom: 0;
}
.alignLeft,
.alignCenter,
.alignRight {
  margin: 1em 0 0 0;
}
/* In print, the pilcrow won't show on hover, so prevent it from taking up space,
   possibly even requiring a new line */
@media print {
  a.pilcrow {
    display: none;
  }
}
/* Styling for the external metadata */
div#external-metadata {
  background-color: #eee;
  padding: 0.5em;
  margin-bottom: 0.5em;
  display: none;
}
div#internal-metadata {
  padding: 0.5em;                       /* to match the external-metadata padding */
}
/* Styling for title RFC Number */
h1#rfcnum {
  clear: both;
  margin: 0 0 -1em;
  padding: 1em 0 0 0;
}
/* Make .olPercent look the same as <ol><li> */
dl.olPercent > dd {
  margin-bottom: 0.25em;
  min-height: initial;
}
/* Give aside some styling to set it apart */
aside {
  border-left: 1px solid #ddd;
  margin: 1em 0 1em 2em;
  padding: 0.2em 2em;
}
aside > dl,
aside > ol,
aside > ul,
aside > table,
aside > p {
  margin-bottom: 0.5em;
}
/* Additional page break settings */
@media print {
  figcaption, table caption {
    page-break-before: avoid;
  }
}
/* Font size adjustments for print */
@media print {
  body  { font-size: 10pt;      line-height: normal; max-width: 96%; }
  h1    { font-size: 1.72em;    padding-top: 1.5em; } /* 1*1.2*1.2*1.2 */
  h2    { font-size: 1.44em;    padding-top: 1.5em; } /* 1*1.2*1.2 */
  h3    { font-size: 1.2em;     padding-top: 1.5em; } /* 1*1.2 */
  h4    { font-size: 1em;       padding-top: 1.5em; }
  h5, h6 { font-size: 1em;      margin: initial; padding: 0.5em 0 0.3em; }
}
/* Sourcecode margin in print, when there's no pilcrow */
@media print {
  .artwork,
  .sourcecode {
    margin-bottom: 1em;
  }
}
/* Avoid narrow tables forcing too narrow table captions, which may render badly */
table {
  min-width: 20em;
}
/* ol type a */
ol.type-a { list-style-type: lower-alpha; }
ol.type-A { list-style-type: upper-alpha; }
ol.type-i { list-style-type: lower-roman; }
ol.type-I { list-style-type: lower-roman; }
/* Apply the print table and row borders in general, on request from the RPC,
and increase the contrast between border and odd row background sligthtly */
table {
  border: 1px solid #ddd;
}
td {
  border-top: 1px solid #ddd;
}
tr:nth-child(2n+1) > td {
  background-color: #f8f8f8;
}
/* Use style rules to govern display of the TOC. */
@media screen and (max-width: 1023px) {
  #toc nav { display: none; }
  #toc.active nav { display: block; }
}
/* Add support for keepWithNext */
.keepWithNext {
  break-after: avoid-page;
  break-after: avoid-page;
}
/* Add support for keepWithPrevious */
.keepWithPrevious {
  break-before: avoid-page;
}
/* Change the approach to avoiding breaks inside artwork etc. */
figure, pre, table, .artwork, .sourcecode  {
  break-before: auto;
  break-after: auto;
}
/* Avoid breaks between <dt> and <dd> */
dl {
  break-before: auto;
  break-inside: auto;
}
dt {
  break-before: auto;
  break-after: avoid-page;
}
dd {
  break-before: avoid-page;
  break-after: auto;
  orphans: 3;
  widows: 3
}
span.break, dd.break {
  margin-bottom: 0;
  min-height: 0;
  break-before: auto;
  break-inside: auto;
  break-after: auto;
}
/* Undo break-before ToC */
@media print {
  #toc {
    break-before: auto;
  }
}
/* Text in compact lists should not get extra bottim margin space,
   since that would makes the list not compact */
ul.compact p, .ulCompact p,
ol.compact p, .olCompact p {
 margin: 0;
}
/* But the list as a whole needs the extra space at the end */
section ul.compact,
section .ulCompact,
section ol.compact,
section .olCompact {
  margin-bottom: 1em;                    /* same as p not within ul.compact etc. */
}
/* The tt and code background above interferes with for instance table cell
   backgrounds.  Changed to something a bit more selective. */
tt, code {
  background-color: transparent;
}
p tt, p code, li tt, li code {
  background-color: #f8f8f8;
}
/* Tweak the pre margin -- 0px doesn't come out well */
pre {
   margin-top: 0.5px;
}
/* Tweak the comact list text */
ul.compact, .ulCompact,
ol.compact, .olCompact,
dl.compact, .dlCompact {
  line-height: normal;
}
/* Don't add top margin for nested lists */
li > ul, li > ol, li > dl,
dd > ul, dd > ol, dd > dl,
dl > dd > dl {
  margin-top: initial;
}
/* Elements that should not be rendered on the same line as a <dt> */
/* This should match the element list in writer.text.TextWriter.render_dl() */
dd > div.artwork:first-child,
dd > aside:first-child,
dd > figure:first-child,
dd > ol:first-child,
dd > div:first-child > pre.sourcecode,
dd > table:first-child,
dd > ul:first-child {
  clear: left;
}
/* fix for weird browser behaviour when <dd/> is empty */
dt+dd:empty::before{
  content: "\00a0";
}
/* Make paragraph spacing inside <li> smaller than in body text, to fit better within the list */
li > p {
  margin-bottom: 0.5em
}
/* Don't let p margin spill out from inside list items */
li > p:last-of-type {
  margin-bottom: 0;
}
</style>
<link href="rfc-local.css" rel="stylesheet" type="text/css">
<script type="application/javascript">async function addMetadata(){try{const e=document.styleSheets[0].cssRules;for(let t=0;t<e.length;t++)if(/#identifiers/.exec(e[t].selectorText)){const a=e[t].cssText.replace("#identifiers","#external-updates");document.styleSheets[0].insertRule(a,document.styleSheets[0].cssRules.length)}}catch(e){console.log(e)}const e=document.getElementById("external-metadata");if(e)try{var t,a="",o=function(e){const t=document.getElementsByTagName("meta");for(let a=0;a<t.length;a++)if(t[a].getAttribute("name")===e)return t[a].getAttribute("content");return""}("rfc.number");if(o){t="https://www.rfc-editor.org/rfc/rfc"+o+".json";try{const e=await fetch(t);a=await e.json()}catch(e){t=document.URL.indexOf("html")>=0?document.URL.replace(/html$/,"json"):document.URL+".json";const o=await fetch(t);a=await o.json()}}if(!a)return;e.style.display="block";const s="",d="https://datatracker.ietf.org/doc",n="https://datatracker.ietf.org/ipr/search",c="https://www.rfc-editor.org/info",l=a.doc_id.toLowerCase(),i=a.doc_id.slice(0,3).toLowerCase(),f=a.doc_id.slice(3).replace(/^0+/,""),u={status:"Status",obsoletes:"Obsoletes",obsoleted_by:"Obsoleted By",updates:"Updates",updated_by:"Updated By",see_also:"See Also",errata_url:"Errata"};let h="<dl style='overflow:hidden' id='external-updates'>";["status","obsoletes","obsoleted_by","updates","updated_by","see_also","errata_url"].forEach(e=>{if("status"==e){a[e]=a[e].toLowerCase();var t=a[e].split(" "),o=t.length,w="",p=1;for(let e=0;e<o;e++)p<o?w=w+r(t[e])+" ":w+=r(t[e]),p++;a[e]=w}else if("obsoletes"==e||"obsoleted_by"==e||"updates"==e||"updated_by"==e){var g,m="",b=1;g=a[e].length;for(let t=0;t<g;t++)a[e][t]&&(a[e][t]=String(a[e][t]).toLowerCase(),m=b<g?m+"<a href='"+s+"/rfc/".concat(a[e][t])+"'>"+a[e][t].slice(3)+"</a>, ":m+"<a href='"+s+"/rfc/".concat(a[e][t])+"'>"+a[e][t].slice(3)+"</a>",b++);a[e]=m}else if("see_also"==e){var y,L="",C=1;y=a[e].length;for(let t=0;t<y;t++)if(a[e][t]){a[e][t]=String(a[e][t]);var _=a[e][t].slice(0,3),v=a[e][t].slice(3).replace(/^0+/,"");L=C<y?"RFC"!=_?L+"<a href='"+s+"/info/"+_.toLowerCase().concat(v.toLowerCase())+"'>"+_+" "+v+"</a>, ":L+"<a href='"+s+"/info/"+_.toLowerCase().concat(v.toLowerCase())+"'>"+v+"</a>, ":"RFC"!=_?L+"<a href='"+s+"/info/"+_.toLowerCase().concat(v.toLowerCase())+"'>"+_+" "+v+"</a>":L+"<a href='"+s+"/info/"+_.toLowerCase().concat(v.toLowerCase())+"'>"+v+"</a>",C++}a[e]=L}else if("errata_url"==e){var R="";R=a[e]?R+"<a href='"+a[e]+"'>Errata exist</a> | <a href='"+d+"/"+l+"'>Datatracker</a>| <a href='"+n+"/?"+i+"="+f+"&submit="+i+"'>IPR</a> | <a href='"+c+"/"+l+"'>Info page</a>":"<a href='"+d+"/"+l+"'>Datatracker</a> | <a href='"+n+"/?"+i+"="+f+"&submit="+i+"'>IPR</a> | <a href='"+c+"/"+l+"'>Info page</a>",a[e]=R}""!=a[e]?"Errata"==u[e]?h+=`<dt>More info:</dt><dd>${a[e]}</dd>`:h+=`<dt>${u[e]}:</dt><dd>${a[e]}</dd>`:"Errata"==u[e]&&(h+=`<dt>More info:</dt><dd>${a[e]}</dd>`)}),h+="</dl>",e.innerHTML=h}catch(e){console.log(e)}else console.log("Could not locate metadata <div> element");function r(e){return e.charAt(0).toUpperCase()+e.slice(1)}}window.removeEventListener("load",addMetadata),window.addEventListener("load",addMetadata);</script>
</head>
<body>
<script src="metadata.min.js"></script>
<table class="ears">
<thead><tr>
<td class="left">Internet-Draft</td>
<td class="center">Accurate TCP-ECN Feedback</td>
<td class="right">March 2022</td>
</tr></thead>
<tfoot><tr>
<td class="left">Briscoe, et al.</td>
<td class="center">Expires 8 September 2022</td>
<td class="right">[Page]</td>
</tr></tfoot>
</table>
<div id="external-metadata" class="document-information"></div>
<div id="internal-metadata" class="document-information">
<dl id="identifiers">
<dt class="label-workgroup">Workgroup:</dt>
<dd class="workgroup">TCP Maintenance &amp; Minor Extensions (tcpm)</dd>
<dt class="label-internet-draft">Internet-Draft:</dt>
<dd class="internet-draft">draft-ietf-tcpm-accurate-ecn-17</dd>
<dt class="label-updates">Updates:</dt>
<dd class="updates">
<a href="https://www.rfc-editor.org/rfc/rfc3168" class="eref">3168</a>, <a href="https://www.rfc-editor.org/rfc/rfc3449" class="eref">3449</a> (if approved)</dd>
<dt class="label-published">Published:</dt>
<dd class="published">
<time datetime="2022-03-07" class="published">7 March 2022</time>
    </dd>
<dt class="label-intended-status">Intended Status:</dt>
<dd class="intended-status">Standards Track</dd>
<dt class="label-expires">Expires:</dt>
<dd class="expires"><time datetime="2022-09-08">8 September 2022</time></dd>
<dt class="label-authors">Authors:</dt>
<dd class="authors">
<div class="author">
      <div class="author-name">B. Briscoe</div>
<div class="org">Independent</div>
</div>
<div class="author">
      <div class="author-name">M. KÃ¼hlewind</div>
<div class="org">Ericsson</div>
</div>
<div class="author">
      <div class="author-name">R. Scheffenegger</div>
<div class="org">NetApp</div>
</div>
</dd>
</dl>
</div>
<h1 id="title">More Accurate ECN Feedback in TCP</h1>
<section id="section-abstract">
      <h2 id="abstract"><a href="#abstract" class="selfRef">Abstract</a></h2>
<p id="section-abstract-1">Explicit Congestion Notification (ECN) is a mechanism where network
      nodes can mark IP packets instead of dropping them to indicate incipient
      congestion to the end-points. Receivers with an ECN-capable transport
      protocol feed back this information to the sender. ECN was originally
      specified for TCP in such a way that only one feedback signal can be
      transmitted per Round-Trip Time (RTT). Recent new TCP mechanisms like
      Congestion Exposure (ConEx), Data Center TCP (DCTCP) or Low Latency Low
      Loss Scalable Throughput (L4S) need more accurate ECN feedback
      information whenever more than one marking is received in one RTT. This
      document updates the original ECN specification to specify a scheme to
      provide more than one feedback signal per RTT in the TCP header. Given
      TCP header space is scarce, it allocates a reserved header bit
      previously assigned to the ECN-Nonce. It also overloads the two existing
      ECN flags in the TCP header. The resulting extra space is exploited to
      feed back the IP-ECN field received during the 3-way handshake as well.
      Supplementary feedback information can optionally be provided in a new
      TCP option, which is never used on the TCP SYN. The document also
      specifies the treatment of this updated TCP wire protocol by
      middleboxes, updating BCP 69 with respect to ACK filtering.<a href="#section-abstract-1" class="pilcrow">Â¶</a></p>
</section>
<div id="status-of-memo">
<section id="section-boilerplate.1">
        <h2 id="name-status-of-this-memo-16">
<a href="#name-status-of-this-memo-16" class="section-name selfRef">Status of This Memo</a>
        </h2>
<p id="section-boilerplate.1-1">
        This Internet-Draft is submitted in full conformance with the
        provisions of BCP 78 and BCP 79.<a href="#section-boilerplate.1-1" class="pilcrow">Â¶</a></p>
<p id="section-boilerplate.1-2">
        Internet-Drafts are working documents of the Internet Engineering Task
        Force (IETF). Note that other groups may also distribute working
        documents as Internet-Drafts. The list of current Internet-Drafts is
        at <span><a href="https://datatracker.ietf.org/drafts/current/">https://datatracker.ietf.org/drafts/current/</a></span>.<a href="#section-boilerplate.1-2" class="pilcrow">Â¶</a></p>
<p id="section-boilerplate.1-3">
        Internet-Drafts are draft documents valid for a maximum of six months
        and may be updated, replaced, or obsoleted by other documents at any
        time. It is inappropriate to use Internet-Drafts as reference
        material or to cite them other than as "work in progress."<a href="#section-boilerplate.1-3" class="pilcrow">Â¶</a></p>
<p id="section-boilerplate.1-4">
        This Internet-Draft will expire on 8 September 2022.<a href="#section-boilerplate.1-4" class="pilcrow">Â¶</a></p>
</section>
</div>
<div id="copyright">
<section id="section-boilerplate.2">
        <h2 id="name-copyright-notice-16">
<a href="#name-copyright-notice-16" class="section-name selfRef">Copyright Notice</a>
        </h2>
<p id="section-boilerplate.2-1">
            Copyright (c) 2022 IETF Trust and the persons identified as the
            document authors. All rights reserved.<a href="#section-boilerplate.2-1" class="pilcrow">Â¶</a></p>
<p id="section-boilerplate.2-2">
            This document is subject to BCP 78 and the IETF Trust's Legal
            Provisions Relating to IETF Documents
            (<span><a href="https://trustee.ietf.org/license-info">https://trustee.ietf.org/license-info</a></span>) in effect on the date of
            publication of this document. Please review these documents
            carefully, as they describe your rights and restrictions with
            respect to this document. Code Components extracted from this
            document must include Revised BSD License text as described in
            Section 4.e of the Trust Legal Provisions and are provided without
            warranty as described in the Revised BSD License.<a href="#section-boilerplate.2-2" class="pilcrow">Â¶</a></p>
</section>
</div>
<div id="toc">
<section id="section-toc.1">
        <a href="#" onclick="scroll(0,0)" class="toplink">â²</a><h2 id="name-table-of-contents-16">
<a href="#name-table-of-contents-16" class="section-name selfRef">Table of Contents</a>
        </h2>
<nav class="toc"><ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.1">
            <p id="section-toc.1-1.1.1"><a href="#section-1" class="xref">1</a>.Â Â <a href="#name-introduction-15" class="xref">Introduction</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.1.2.1">
                <p id="section-toc.1-1.1.2.1.1" class="keepWithNext"><a href="#section-1.1" class="xref">1.1</a>.Â Â <a href="#name-document-roadmap" class="xref">Document Roadmap</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.1.2.2">
                <p id="section-toc.1-1.1.2.2.1" class="keepWithNext"><a href="#section-1.2" class="xref">1.2</a>.Â Â <a href="#name-goals" class="xref">Goals</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.1.2.3">
                <p id="section-toc.1-1.1.2.3.1" class="keepWithNext"><a href="#section-1.3" class="xref">1.3</a>.Â Â <a href="#name-terminology-12" class="xref">Terminology</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.1.2.4">
                <p id="section-toc.1-1.1.2.4.1"><a href="#section-1.4" class="xref">1.4</a>.Â Â <a href="#name-recap-of-existing-ecn-feedb" class="xref">Recap of Existing ECN feedback in IP/TCP</a></p>
</li>
            </ul>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.2">
            <p id="section-toc.1-1.2.1"><a href="#section-2" class="xref">2</a>.Â Â <a href="#name-accecn-protocol-overview-an" class="xref">AccECN Protocol Overview and Rationale</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.2.2.1">
                <p id="section-toc.1-1.2.2.1.1"><a href="#section-2.1" class="xref">2.1</a>.Â Â <a href="#name-capability-negotiation" class="xref">Capability Negotiation</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.2.2.2">
                <p id="section-toc.1-1.2.2.2.1"><a href="#section-2.2" class="xref">2.2</a>.Â Â <a href="#name-feedback-mechanism" class="xref">Feedback Mechanism</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.2.2.3">
                <p id="section-toc.1-1.2.2.3.1"><a href="#section-2.3" class="xref">2.3</a>.Â Â <a href="#name-delayed-acks-and-resilience" class="xref">Delayed ACKs and Resilience Against ACK Loss</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.2.2.4">
                <p id="section-toc.1-1.2.2.4.1"><a href="#section-2.4" class="xref">2.4</a>.Â Â <a href="#name-feedback-metrics" class="xref">Feedback Metrics</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.2.2.5">
                <p id="section-toc.1-1.2.2.5.1"><a href="#section-2.5" class="xref">2.5</a>.Â Â <a href="#name-generic-dumb-reflector" class="xref">Generic (Dumb) Reflector</a></p>
</li>
            </ul>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.3">
            <p id="section-toc.1-1.3.1"><a href="#section-3" class="xref">3</a>.Â Â <a href="#name-accecn-protocol-specificati" class="xref">AccECN Protocol Specification</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.3.2.1">
                <p id="section-toc.1-1.3.2.1.1"><a href="#section-3.1" class="xref">3.1</a>.Â Â <a href="#name-negotiating-to-use-accecn" class="xref">Negotiating to use AccECN</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.3.2.1.2.1">
                    <p id="section-toc.1-1.3.2.1.2.1.1"><a href="#section-3.1.1" class="xref">3.1.1</a>.Â Â <a href="#name-negotiation-during-the-tcp-" class="xref">Negotiation during the TCP handshake</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.3.2.1.2.2">
                    <p id="section-toc.1-1.3.2.1.2.2.1"><a href="#section-3.1.2" class="xref">3.1.2</a>.Â Â <a href="#name-backward-compatibility" class="xref">Backward Compatibility</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.3.2.1.2.3">
                    <p id="section-toc.1-1.3.2.1.2.3.1"><a href="#section-3.1.3" class="xref">3.1.3</a>.Â Â <a href="#name-forward-compatibility" class="xref">Forward Compatibility</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.3.2.1.2.4">
                    <p id="section-toc.1-1.3.2.1.2.4.1"><a href="#section-3.1.4" class="xref">3.1.4</a>.Â Â <a href="#name-retransmission-of-the-syn" class="xref">Retransmission of the SYN</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.3.2.1.2.5">
                    <p id="section-toc.1-1.3.2.1.2.5.1"><a href="#section-3.1.5" class="xref">3.1.5</a>.Â Â <a href="#name-implications-of-accecn-mode" class="xref">Implications of AccECN Mode</a></p>
</li>
                </ul>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.3.2.2">
                <p id="section-toc.1-1.3.2.2.1"><a href="#section-3.2" class="xref">3.2</a>.Â Â <a href="#name-accecn-feedback" class="xref">AccECN Feedback</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.3.2.2.2.1">
                    <p id="section-toc.1-1.3.2.2.2.1.1"><a href="#section-3.2.1" class="xref">3.2.1</a>.Â Â <a href="#name-initialization-of-feedback-" class="xref">Initialization of Feedback Counters</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.3.2.2.2.2">
                    <p id="section-toc.1-1.3.2.2.2.2.1"><a href="#section-3.2.2" class="xref">3.2.2</a>.Â Â <a href="#name-the-ace-field" class="xref">The ACE Field</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.3.2.2.2.2.2.1">
                        <p id="section-toc.1-1.3.2.2.2.2.2.1.1"><a href="#section-3.2.2.1" class="xref">3.2.2.1</a>.Â Â <a href="#name-ace-field-on-the-ack-of-the" class="xref">ACE Field on the ACK of the SYN/ACK</a></p>
</li>
                      <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.3.2.2.2.2.2.2">
                        <p id="section-toc.1-1.3.2.2.2.2.2.2.1"><a href="#section-3.2.2.2" class="xref">3.2.2.2</a>.Â Â <a href="#name-encoding-and-decoding-feedb" class="xref">Encoding and Decoding Feedback in the ACE Field</a></p>
</li>
                      <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.3.2.2.2.2.2.3">
                        <p id="section-toc.1-1.3.2.2.2.2.2.3.1"><a href="#section-3.2.2.3" class="xref">3.2.2.3</a>.Â Â <a href="#name-testing-for-mangling-of-the" class="xref">Testing for Mangling of the IP/ECN Field</a></p>
</li>
                      <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.3.2.2.2.2.2.4">
                        <p id="section-toc.1-1.3.2.2.2.2.2.4.1"><a href="#section-3.2.2.4" class="xref">3.2.2.4</a>.Â Â <a href="#name-testing-for-zeroing-of-the-" class="xref">Testing for Zeroing of the ACE Field</a></p>
</li>
                      <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.3.2.2.2.2.2.5">
                        <p id="section-toc.1-1.3.2.2.2.2.2.5.1"><a href="#section-3.2.2.5" class="xref">3.2.2.5</a>.Â Â <a href="#name-safety-against-ambiguity-of" class="xref">Safety against Ambiguity of the ACE Field</a></p>
</li>
                    </ul>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.3.2.2.2.3">
                    <p id="section-toc.1-1.3.2.2.2.3.1"><a href="#section-3.2.3" class="xref">3.2.3</a>.Â Â <a href="#name-the-accecn-option" class="xref">The AccECN Option</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.3.2.2.2.3.2.1">
                        <p id="section-toc.1-1.3.2.2.2.3.2.1.1"><a href="#section-3.2.3.1" class="xref">3.2.3.1</a>.Â Â <a href="#name-encoding-and-decoding-feedba" class="xref">Encoding and Decoding Feedback in the AccECN Option Fields</a></p>
</li>
                      <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.3.2.2.2.3.2.2">
                        <p id="section-toc.1-1.3.2.2.2.3.2.2.1"><a href="#section-3.2.3.2" class="xref">3.2.3.2</a>.Â Â <a href="#name-path-traversal-of-the-accec" class="xref">Path Traversal of the AccECN Option</a></p>
</li>
                      <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.3.2.2.2.3.2.3">
                        <p id="section-toc.1-1.3.2.2.2.3.2.3.1"><a href="#section-3.2.3.3" class="xref">3.2.3.3</a>.Â Â <a href="#name-usage-of-the-accecn-tcp-opt" class="xref">Usage of the AccECN TCP Option</a></p>
</li>
                    </ul>
</li>
                </ul>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.3.2.3">
                <p id="section-toc.1-1.3.2.3.1"><a href="#section-3.3" class="xref">3.3</a>.Â Â <a href="#name-accecn-compliance-requireme" class="xref">AccECN Compliance Requirements for TCP Proxies, Offload Engines and other Middleboxes</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.3.2.3.2.1">
                    <p id="section-toc.1-1.3.2.3.2.1.1"><a href="#section-3.3.1" class="xref">3.3.1</a>.Â Â <a href="#name-requirements-for-tcp-proxie" class="xref">Requirements for TCP Proxies</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.3.2.3.2.2">
                    <p id="section-toc.1-1.3.2.3.2.2.1"><a href="#section-3.3.2" class="xref">3.3.2</a>.Â Â <a href="#name-requirements-for-transparen" class="xref">Requirements for Transparent Middleboxes and TCP Normalizers</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.3.2.3.2.3">
                    <p id="section-toc.1-1.3.2.3.2.3.1"><a href="#section-3.3.3" class="xref">3.3.3</a>.Â Â <a href="#name-requirements-for-tcp-ack-fi" class="xref">Requirements for TCP ACK Filtering</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.3.2.3.2.4">
                    <p id="section-toc.1-1.3.2.3.2.4.1"><a href="#section-3.3.4" class="xref">3.3.4</a>.Â Â <a href="#name-requirements-for-tcp-segmen" class="xref">Requirements for TCP Segmentation Offload</a></p>
</li>
                </ul>
</li>
            </ul>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4">
            <p id="section-toc.1-1.4.1"><a href="#section-4" class="xref">4</a>.Â Â <a href="#name-updates-to-rfc-3168" class="xref">Updates to RFC 3168</a></p>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.5">
            <p id="section-toc.1-1.5.1"><a href="#section-5" class="xref">5</a>.Â Â <a href="#name-interaction-with-tcp-varian" class="xref">Interaction with TCP Variants</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.5.2.1">
                <p id="section-toc.1-1.5.2.1.1"><a href="#section-5.1" class="xref">5.1</a>.Â Â <a href="#name-compatibility-with-syn-cook" class="xref">Compatibility with SYN Cookies</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.5.2.2">
                <p id="section-toc.1-1.5.2.2.1"><a href="#section-5.2" class="xref">5.2</a>.Â Â <a href="#name-compatibility-with-tcp-expe" class="xref">Compatibility with TCP Experiments and Common TCP Options</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.5.2.3">
                <p id="section-toc.1-1.5.2.3.1"><a href="#section-5.3" class="xref">5.3</a>.Â Â <a href="#name-compatibility-with-feedback" class="xref">Compatibility with Feedback Integrity Mechanisms</a></p>
</li>
            </ul>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.6">
            <p id="section-toc.1-1.6.1"><a href="#section-6" class="xref">6</a>.Â Â <a href="#name-protocol-properties" class="xref">Protocol Properties</a></p>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.7">
            <p id="section-toc.1-1.7.1"><a href="#section-7" class="xref">7</a>.Â Â <a href="#name-iana-considerations-16" class="xref">IANA Considerations</a></p>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.8">
            <p id="section-toc.1-1.8.1"><a href="#section-8" class="xref">8</a>.Â Â <a href="#name-security-considerations-16" class="xref">Security Considerations</a></p>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.9">
            <p id="section-toc.1-1.9.1"><a href="#section-9" class="xref">9</a>.Â Â <a href="#name-acknowledgements-5" class="xref">Acknowledgements</a></p>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.10">
            <p id="section-toc.1-1.10.1"><a href="#section-10" class="xref">10</a>.Â <a href="#name-comments-solicited" class="xref">Comments Solicited</a></p>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.11">
            <p id="section-toc.1-1.11.1"><a href="#section-11" class="xref">11</a>.Â <a href="#name-references-13" class="xref">References</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.11.2.1">
                <p id="section-toc.1-1.11.2.1.1"><a href="#section-11.1" class="xref">11.1</a>.Â Â <a href="#name-normative-references-15" class="xref">Normative References</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.11.2.2">
                <p id="section-toc.1-1.11.2.2.1"><a href="#section-11.2" class="xref">11.2</a>.Â Â <a href="#name-informative-references-14" class="xref">Informative References</a></p>
</li>
            </ul>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.12">
            <p id="section-toc.1-1.12.1"><a href="#appendix-A" class="xref">Appendix A</a>.Â Â <a href="#name-example-algorithms" class="xref">Example Algorithms</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.12.2.1">
                <p id="section-toc.1-1.12.2.1.1"><a href="#appendix-A.1" class="xref">A.1</a>.Â Â <a href="#name-example-algorithm-to-encode" class="xref">Example Algorithm to Encode/Decode the AccECN Option</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.12.2.2">
                <p id="section-toc.1-1.12.2.2.1"><a href="#appendix-A.2" class="xref">A.2</a>.Â Â <a href="#name-example-algorithm-for-safet" class="xref">Example Algorithm for Safety Against Long Sequences of ACK Loss</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.12.2.2.2.1">
                    <p id="section-toc.1-1.12.2.2.2.1.1"><a href="#appendix-A.2.1" class="xref">A.2.1</a>.Â Â <a href="#name-safety-algorithm-without-th" class="xref">Safety Algorithm without the AccECN Option</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.12.2.2.2.2">
                    <p id="section-toc.1-1.12.2.2.2.2.1"><a href="#appendix-A.2.2" class="xref">A.2.2</a>.Â Â <a href="#name-safety-algorithm-with-the-a" class="xref">Safety Algorithm with the AccECN Option</a></p>
</li>
                </ul>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.12.2.3">
                <p id="section-toc.1-1.12.2.3.1"><a href="#appendix-A.3" class="xref">A.3</a>.Â Â <a href="#name-example-algorithm-to-estima" class="xref">Example Algorithm to Estimate Marked Bytes from Marked Packets</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.12.2.4">
                <p id="section-toc.1-1.12.2.4.1"><a href="#appendix-A.4" class="xref">A.4</a>.Â Â <a href="#name-example-algorithm-to-count-" class="xref">Example Algorithm to Count Not-ECT Bytes</a></p>
</li>
            </ul>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.13">
            <p id="section-toc.1-1.13.1"><a href="#appendix-B" class="xref">Appendix B</a>.Â Â <a href="#name-rationale-for-usage-of-tcp-" class="xref">Rationale for Usage of TCP Header Flags</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.13.2.1">
                <p id="section-toc.1-1.13.2.1.1"><a href="#appendix-B.1" class="xref">B.1</a>.Â Â <a href="#name-three-tcp-header-flags-in-t" class="xref">Three TCP Header Flags in the SYN-SYN/ACK Handshake</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.13.2.2">
                <p id="section-toc.1-1.13.2.2.1"><a href="#appendix-B.2" class="xref">B.2</a>.Â Â <a href="#name-four-codepoints-in-the-syn-" class="xref">Four Codepoints in the SYN/ACK</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.13.2.3">
                <p id="section-toc.1-1.13.2.3.1"><a href="#appendix-B.3" class="xref">B.3</a>.Â Â <a href="#name-space-for-future-evolution" class="xref">Space for Future Evolution</a></p>
</li>
            </ul>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.14">
            <p id="section-toc.1-1.14.1"><a href="#appendix-C" class="xref"></a><a href="#name-authors-addresses-14" class="xref">Authors' Addresses</a></p>
</li>
        </ul>
</nav>
</section>
</div>
<div id="accecn_Introduction">
<section id="section-1">
      <h2 id="name-introduction-15">
<a href="#section-1" class="section-number selfRef">1. </a><a href="#name-introduction-15" class="section-name selfRef">Introduction</a>
      </h2>
<p id="section-1-1">Explicit Congestion Notification (ECN) <span>[<a href="#RFC3168" class="xref">RFC3168</a>]</span> is a
      mechanism where network nodes can mark IP packets instead of dropping
      them to indicate incipient congestion to the end-points. Receivers with
      an ECN-capable transport protocol feed back this information to the
      sender. In RFC 3168, ECN was specified for TCP in such a way that only
      one feedback signal could be transmitted per Round-Trip Time (RTT).
      Recently, proposed mechanisms like Congestion Exposure (ConEx <span>[<a href="#RFC7713" class="xref">RFC7713</a>]</span>), DCTCP <span>[<a href="#RFC8257" class="xref">RFC8257</a>]</span> or L4S <span>[<a href="#I-D.ietf-tsvwg-l4s-arch" class="xref">I-D.ietf-tsvwg-l4s-arch</a>]</span> need to know when more than one
      marking is received in one RTT which is information that cannot be
      provided by the feedback scheme as specified in <span>[<a href="#RFC3168" class="xref">RFC3168</a>]</span>. This document specifies an update to the ECN
      feedback scheme of RFC 3168 that provides more accurate information and
      could be used by these and potentially other future TCP extensions. A
      fuller treatment of the motivation for this specification is given in
      the associated requirements document <span>[<a href="#RFC7560" class="xref">RFC7560</a>]</span>.<a href="#section-1-1" class="pilcrow">Â¶</a></p>
<p id="section-1-2">This documents specifies a standards track scheme for ECN feedback in
      the TCP header to provide more than one feedback signal per RTT. It will
      be called the more accurate ECN feedback scheme, or AccECN for short.
      This document updates RFC 3168 with respect to negotiation and use of
      the feedback scheme for TCP. All aspects of RFC 3168 other than the TCP
      feedback scheme, in particular the definition of ECN at the IP layer,
      remain unchanged by this specification. <a href="#accecn_3168_updates" class="xref">Section 4</a> gives a more detailed specification of
      exactly which aspects of RFC 3168 this document updates.<a href="#section-1-2" class="pilcrow">Â¶</a></p>
<p id="section-1-3">AccECN is intended to be a complete replacement for classic TCP/ECN
      feedback, not a fork in the design of TCP. AccECN feedback complements
      TCP's loss feedback and it can coexist alongside 'classic' <span>[<a href="#RFC3168" class="xref">RFC3168</a>]</span> TCP/ECN feedback. So its applicability is intended to
      include all public and private IP networks (and even any non-IP networks
      over which TCP is used today), whether or not any nodes on the path
      support ECN, of whatever flavour. This document uses the term Classic
      ECN when it needs to distinguish the RFC 3168 ECN TCP feedback scheme
      from the AccECN TCP feedback scheme.<a href="#section-1-3" class="pilcrow">Â¶</a></p>
<p id="section-1-4">AccECN feedback overloads the two existing ECN flags in the TCP
      header and allocates the currently reserved flag (previously called NS)
      in the TCP header, to be used as one three-bit counter field indicating
      the number of congestion experienced marked packets. Given the new
      definitions of these three bits, both ends have to support the new wire
      protocol before it can be used. Therefore during the TCP handshake the
      two ends use these three bits in the TCP header to negotiate the most
      advanced feedback protocol that they can both support, in a way that is
      backward compatible with <span>[<a href="#RFC3168" class="xref">RFC3168</a>]</span>.<a href="#section-1-4" class="pilcrow">Â¶</a></p>
<p id="section-1-5">AccECN is solely a change to the TCP wire protocol; it covers the
      negotiation and signaling of more accurate ECN feedback from a TCP Data
      Receiver to a Data Sender. It is completely independent of how TCP might
      respond to congestion feedback, which is out of scope, but ultimately
      the motivation for accurate ECN feedback. Like Classic ECN feedback,
      AccECN can be used by standard Reno congestion control <span>[<a href="#RFC5681" class="xref">RFC5681</a>]</span> to respond to the existence of at least one
      congestion notification within a round trip. Or, unlike Reno, AccECN can
      be used to respond to the extent of congestion notification over a round
      trip, as for example DCTCP does in controlled environments <span>[<a href="#RFC8257" class="xref">RFC8257</a>]</span>. For congestion response, this specification refers
      to RFC 3168, or ECN experiments such as those referred to in <span>[<a href="#RFC8311" class="xref">RFC8311</a>]</span>, namely: a TCP-based Low Latency Low Loss Scalable
      (L4S) congestion control <span>[<a href="#I-D.ietf-tsvwg-l4s-arch" class="xref">I-D.ietf-tsvwg-l4s-arch</a>]</span>; or
      Alternative Backoff with ECN (ABE) <span>[<a href="#RFC8511" class="xref">RFC8511</a>]</span>.<a href="#section-1-5" class="pilcrow">Â¶</a></p>
<p id="section-1-6">It is recommended that the AccECN protocol is implemented alongside
      SACK <span>[<a href="#RFC2018" class="xref">RFC2018</a>]</span> and the experimental ECN++ protocol <span>[<a href="#I-D.ietf-tcpm-generalized-ecn" class="xref">I-D.ietf-tcpm-generalized-ecn</a>]</span>, which allows the ECN
      capability to be used on TCP control packets. Therefore, this
      specification does not discuss implementing AccECN alongside <span>[<a href="#RFC5562" class="xref">RFC5562</a>]</span>, which was an earlier experimental protocol with
      narrower scope than ECN++.<a href="#section-1-6" class="pilcrow">Â¶</a></p>
<section id="section-1.1">
        <h3 id="name-document-roadmap">
<a href="#section-1.1" class="section-number selfRef">1.1. </a><a href="#name-document-roadmap" class="section-name selfRef">Document Roadmap</a>
        </h3>
<p id="section-1.1-1">The following introductory section outlines the goals of AccECN
        (<a href="#accecn_Goals" class="xref">Section 1.2</a>). Then terminology is defined (<a href="#accecn_Terminology" class="xref">Section 1.3</a>) and a recap of existing prerequisite
        technology is given (<a href="#accecn_Recap" class="xref">Section 1.4</a>).<a href="#section-1.1-1" class="pilcrow">Â¶</a></p>
<p id="section-1.1-2"><a href="#accecn_Overview" class="xref">Section 2</a> gives an informative overview of
        the AccECN protocol. Then <a href="#accecn_Spec" class="xref">Section 3</a> gives the
        normative protocol specification, and <a href="#accecn_3168_updates" class="xref">Section 4</a> clarifies which aspects of RFC 3168 are
        updated by this specification. <a href="#accecn_Interact_Variants" class="xref">Section 5</a> assesses the interaction of AccECN
        with commonly used variants of TCP, whether standardized or not. <a href="#accecn_Properties" class="xref">Section 6</a> summarizes the features and properties of
        AccECN.<a href="#section-1.1-2" class="pilcrow">Â¶</a></p>
<p id="section-1.1-3"><a href="#accecn_IANA_Considerations" class="xref">Section 7</a> summarizes the protocol
        fields and numbers that IANA will need to assign and <a href="#accecn_Security_Considerations" class="xref">Section 8</a> points to the aspects of the
        protocol that will be of interest to the security community.<a href="#section-1.1-3" class="pilcrow">Â¶</a></p>
<p id="section-1.1-4"><a href="#accecn_Algo_Examples" class="xref">Appendix A</a> gives pseudocode examples for
        the various algorithms that AccECN uses and <a href="#accecn_flags_rationale" class="xref">Appendix B</a> explains why AccECN uses flags in
        the main TCP header and quantifies the space left for future use.<a href="#section-1.1-4" class="pilcrow">Â¶</a></p>
</section>
<div id="accecn_Goals">
<section id="section-1.2">
        <h3 id="name-goals">
<a href="#section-1.2" class="section-number selfRef">1.2. </a><a href="#name-goals" class="section-name selfRef">Goals</a>
        </h3>
<p id="section-1.2-1"><span>[<a href="#RFC7560" class="xref">RFC7560</a>]</span> enumerates requirements that a candidate
        feedback scheme will need to satisfy, under the headings: resilience,
        timeliness, integrity, accuracy (including ordering and lack of bias),
        complexity, overhead and compatibility (both backward and forward). It
        recognizes that a perfect scheme that fully satisfies all the
        requirements is unlikely and trade-offs between requirements are
        likely. <a href="#accecn_Properties" class="xref">Section 6</a> presents the properties of
        AccECN against these requirements and discusses the trade-offs
        made.<a href="#section-1.2-1" class="pilcrow">Â¶</a></p>
<p id="section-1.2-2">The requirements document recognizes that a protocol as ubiquitous
        as TCP needs to be able to serve as-yet-unspecified requirements.
        Therefore an AccECN receiver aims to act as a generic (dumb) reflector
        of congestion information so that in future new sender behaviours can
        be deployed unilaterally.<a href="#section-1.2-2" class="pilcrow">Â¶</a></p>
</section>
</div>
<div id="accecn_Terminology">
<section id="section-1.3">
        <h3 id="name-terminology-12">
<a href="#section-1.3" class="section-number selfRef">1.3. </a><a href="#name-terminology-12" class="section-name selfRef">Terminology</a>
        </h3>
<span class="break"></span><dl class="dlParallel" id="section-1.3-1">
          <dt id="section-1.3-1.1">AccECN:</dt>
          <dd style="margin-left: 1.5em" id="section-1.3-1.2">The more accurate ECN feedback scheme will
            be called AccECN for short.<a href="#section-1.3-1.2" class="pilcrow">Â¶</a>
</dd>
          <dd class="break"></dd>
<dt id="section-1.3-1.3">Classic ECN:</dt>
          <dd style="margin-left: 1.5em" id="section-1.3-1.4">the ECN protocol specified in <span>[<a href="#RFC3168" class="xref">RFC3168</a>]</span>.<a href="#section-1.3-1.4" class="pilcrow">Â¶</a>
</dd>
          <dd class="break"></dd>
<dt id="section-1.3-1.5">Classic ECN feedback:</dt>
          <dd style="margin-left: 1.5em" id="section-1.3-1.6">the feedback aspect of the ECN
            protocol specified in <span>[<a href="#RFC3168" class="xref">RFC3168</a>]</span>, including
            generation, encoding, transmission and decoding of feedback, but
            not the Data Sender's subsequent response to that feedback.<a href="#section-1.3-1.6" class="pilcrow">Â¶</a>
</dd>
          <dd class="break"></dd>
<dt id="section-1.3-1.7">ACK:</dt>
          <dd style="margin-left: 1.5em" id="section-1.3-1.8">A TCP acknowledgement, with or without a data
            payload (ACK=1).<a href="#section-1.3-1.8" class="pilcrow">Â¶</a>
</dd>
          <dd class="break"></dd>
<dt id="section-1.3-1.9">Pure ACK:</dt>
          <dd style="margin-left: 1.5em" id="section-1.3-1.10">A TCP acknowledgement without a data
            payload.<a href="#section-1.3-1.10" class="pilcrow">Â¶</a>
</dd>
          <dd class="break"></dd>
<dt id="section-1.3-1.11">Acceptable packet / segment:</dt>
          <dd style="margin-left: 1.5em" id="section-1.3-1.12">A packet or segment
            that passes the acceptability tests in <span>[<a href="#RFC0793" class="xref">RFC0793</a>]</span>
            and <span>[<a href="#RFC5961" class="xref">RFC5961</a>]</span>.<a href="#section-1.3-1.12" class="pilcrow">Â¶</a>
</dd>
          <dd class="break"></dd><dt id="section-1.3-1.13">TCP client:</dt>
          <dd style="margin-left: 1.5em" id="section-1.3-1.14">The TCP stack that originates a
            connection.<a href="#section-1.3-1.14" class="pilcrow">Â¶</a>
</dd>
          <dd class="break"></dd>
<dt id="section-1.3-1.15">TCP server:</dt>
          <dd style="margin-left: 1.5em" id="section-1.3-1.16">The TCP stack that responds to a
            connection request.<a href="#section-1.3-1.16" class="pilcrow">Â¶</a>
</dd>
          <dd class="break"></dd>
<dt id="section-1.3-1.17">Data Receiver:</dt>
          <dd style="margin-left: 1.5em" id="section-1.3-1.18">The endpoint of a TCP half-connection
            that receives data and sends AccECN feedback.<a href="#section-1.3-1.18" class="pilcrow">Â¶</a>
</dd>
          <dd class="break"></dd>
<dt id="section-1.3-1.19">Data Sender:</dt>
          <dd style="margin-left: 1.5em" id="section-1.3-1.20">The endpoint of a TCP half-connection
            that sends data and receives AccECN feedback.<a href="#section-1.3-1.20" class="pilcrow">Â¶</a>
</dd>
          <dd class="break"></dd></dl>
<p id="section-1.3-2">The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
        "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
        document are to be interpreted as described in BCP 14 <span>[<a href="#RFC2119" class="xref">RFC2119</a>]</span> <span>[<a href="#RFC8174" class="xref">RFC8174</a>]</span> when, and only when, they
        appear in all capitals, as shown here.<a href="#section-1.3-2" class="pilcrow">Â¶</a></p>
</section>
</div>
<div id="accecn_Recap">
<section id="section-1.4">
        <h3 id="name-recap-of-existing-ecn-feedb">
<a href="#section-1.4" class="section-number selfRef">1.4. </a><a href="#name-recap-of-existing-ecn-feedb" class="section-name selfRef">Recap of Existing ECN feedback in IP/TCP</a>
        </h3>
<p id="section-1.4-1">ECN <span>[<a href="#RFC3168" class="xref">RFC3168</a>]</span> uses two bits in the IP header. Once
        ECN has been negotiated with the receiver at the transport layer, an
        ECN sender can set two possible codepoints (ECT(0) or ECT(1)) in the
        IP header to indicate an ECN-capable transport (ECT).  If both ECN bits are
        zero, the packet is considered to have been sent by a Not-ECN-capable
        Transport (Not-ECT). When a network node experiences congestion, it
        will occasionally either drop or mark a packet, with the choice
        depending on the packet's ECN codepoint. If the codepoint is Not-ECT,
        only drop is appropriate. If the codepoint is ECT(0) or ECT(1), the
        node can mark the packet by setting both ECN bits, which is termed
        'Congestion Experienced' (CE), or loosely a 'congestion mark'. <a href="#accecn_Tab_ECN" class="xref">Table 1</a> summarises these codepoints.<a href="#section-1.4-1" class="pilcrow">Â¶</a></p>
<span id="name-the-ecn-field-in-the-ip-hea"></span><div id="accecn_Tab_ECN">
<table class="center" id="table-1">
          <caption>
<a href="#table-1" class="selfRef">Table 1</a>:
<a href="#name-the-ecn-field-in-the-ip-hea" class="selfRef">The ECN Field in the IP Header</a>
          </caption>
<thead>
            <tr>
              <th class="text-left" rowspan="1" colspan="1">IP-ECN codepoint</th>
              <th class="text-left" rowspan="1" colspan="1">Codepoint name</th>
              <th class="text-left" rowspan="1" colspan="1">Description</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">0b00</td>
              <td class="text-left" rowspan="1" colspan="1">Not-ECT</td>
              <td class="text-left" rowspan="1" colspan="1">NotÂ ECN-CapableÂ Transport</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">0b01</td>
              <td class="text-left" rowspan="1" colspan="1">ECT(1)</td>
              <td class="text-left" rowspan="1" colspan="1">ECN-CapableÂ Transport (1)</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">0b10</td>
              <td class="text-left" rowspan="1" colspan="1">ECT(0)</td>
              <td class="text-left" rowspan="1" colspan="1">ECN-CapableÂ Transport (0)</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">0b11</td>
              <td class="text-left" rowspan="1" colspan="1">CE</td>
              <td class="text-left" rowspan="1" colspan="1">CongestionÂ Experienced</td>
            </tr>
          </tbody>
        </table>
</div>
<p id="section-1.4-3">In the TCP header the first two bits in byte 14 are defined as
        flags for the use of ECN (CWR and ECE in <a href="#accecn_Fig_TCPHdr" class="xref">Figure 1</a> <span>[<a href="#RFC3168" class="xref">RFC3168</a>]</span>). A TCP client
        indicates it supports ECN by setting ECE=CWR=1 in the SYN, and an
        ECN-enabled server confirms ECN support by setting ECE=1 and CWR=0 in
        the SYN/ACK. On reception of a CE-marked packet at the IP layer, the
        Data Receiver starts to set the Echo Congestion Experienced (ECE) flag
        continuously in the TCP header of ACKs, which ensures the signal is
        received reliably even if ACKs are lost. The TCP sender confirms that
        it has received at least one ECE signal by responding with the
        congestion window reduced (CWR) flag, which allows the TCP receiver to
        stop repeating the ECN-Echo flag. This always leads to a full RTT of
        ACKs with ECE set. Thus any additional CE markings arriving within
        this RTT cannot be fed back.<a href="#section-1.4-3" class="pilcrow">Â¶</a></p>
<p id="section-1.4-4">The last bit in byte 13 of the TCP header was defined as the Nonce
        Sum (NS) for the ECN Nonce <span>[<a href="#RFC3540" class="xref">RFC3540</a>]</span>. In the absence of
        widespread deployment RFC 3540 has been reclassified as historic <span>[<a href="#RFC8311" class="xref">RFC8311</a>]</span> and the respective flag has been marked as
        "reserved", making this TCP flag available for use by the AccECN
        experiment instead.<a href="#section-1.4-4" class="pilcrow">Â¶</a></p>
<span id="name-the-post-ecn-nonce-definiti"></span><div id="accecn_Fig_TCPHdr">
<figure id="figure-1">
          <div class="alignCenter art-text artwork" id="section-1.4-5.1">
<pre>
  0   1   2   3   4   5   6   7   8   9  10  11  12  13  14  15
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
|               |           | N | C | E | U | A | P | R | S | F |
| Header Length | Reserved  | S | W | C | R | C | S | S | Y | I |
|               |           |   | R | E | G | K | H | T | N | N |
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
</pre>
</div>
<figcaption><a href="#figure-1" class="selfRef">Figure 1</a>:
<a href="#name-the-post-ecn-nonce-definiti" class="selfRef">The (post-ECN Nonce) definition of the TCP header flags</a>
          </figcaption></figure>
</div>
</section>
</div>
</section>
</div>
<div id="accecn_Overview">
<section id="section-2">
      <h2 id="name-accecn-protocol-overview-an">
<a href="#section-2" class="section-number selfRef">2. </a><a href="#name-accecn-protocol-overview-an" class="section-name selfRef">AccECN Protocol Overview and Rationale</a>
      </h2>
<p id="section-2-1">This section provides an informative overview of the AccECN protocol
      that will be normatively specified in <a href="#accecn_Spec" class="xref">Section 3</a><a href="#section-2-1" class="pilcrow">Â¶</a></p>
<p id="section-2-2">Like the original TCP approach, the Data Receiver of each TCP
      half-connection sends AccECN feedback to the Data Sender on TCP
      acknowledgements, reusing data packets of the other half-connection
      whenever possible.<a href="#section-2-2" class="pilcrow">Â¶</a></p>
<p id="section-2-3">The AccECN protocol has had to be designed in two parts:<a href="#section-2-3" class="pilcrow">Â¶</a></p>
<ul class="normal">
<li class="normal" id="section-2-4.1">an essential part that re-uses ECN TCP header bits for the Data
          Receiver to feed back the number of packets arriving with CE in the
          IP-ECN field. This provides more accuracy than classic ECN feedback,
          but limited resilience against ACK loss;<a href="#section-2-4.1" class="pilcrow">Â¶</a>
</li>
        <li class="normal" id="section-2-4.2">a supplementary part using a new AccECN TCP Option that provides
          additional feedback on the number of bytes that arrive marked with
          each of the three ECN codepoints in the IP-ECN field (not just CE
          marks). This provides greater resilience against ACK loss than the
          essential feedback, but it is more likely to suffer from middlebox
          interference.<a href="#section-2-4.2" class="pilcrow">Â¶</a>
</li>
      </ul>
<p id="section-2-5">The two part design was necessary, given limitations on the
      space available for TCP options and given the possibility that certain
      incorrectly designed middleboxes prevent TCP using any new options.<a href="#section-2-5" class="pilcrow">Â¶</a></p>
<p id="section-2-6">The essential part overloads the previous definition of the three
      flags in the TCP header that had been assigned for use by ECN. This
      design choice deliberately replaces the classic ECN feedback protocol,
      rather than leaving classic ECN feedback intact and adding more accurate
      feedback separately because:<a href="#section-2-6" class="pilcrow">Â¶</a></p>
<ul class="normal">
<li class="normal" id="section-2-7.1">this efficiently reuses scarce TCP header space, given TCP option
          space is approaching saturation;<a href="#section-2-7.1" class="pilcrow">Â¶</a>
</li>
        <li class="normal" id="section-2-7.2">a single upgrade path for the TCP protocol is preferable to a
          fork in the design;<a href="#section-2-7.2" class="pilcrow">Â¶</a>
</li>
        <li class="normal" id="section-2-7.3">otherwise classic and accurate ECN feedback could give
          conflicting feedback on the same segment, which could open up new
          security concerns and make implementations unnecessarily
          complex;<a href="#section-2-7.3" class="pilcrow">Â¶</a>
</li>
        <li class="normal" id="section-2-7.4">middleboxes are more likely to faithfully forward the TCP ECN
          flags than newly defined areas of the TCP header.<a href="#section-2-7.4" class="pilcrow">Â¶</a>
</li>
      </ul>
<p id="section-2-8">AccECN is designed to work even if the supplementary part is removed
      or zeroed out, as long as the essential part gets through.<a href="#section-2-8" class="pilcrow">Â¶</a></p>
<section id="section-2.1">
        <h3 id="name-capability-negotiation">
<a href="#section-2.1" class="section-number selfRef">2.1. </a><a href="#name-capability-negotiation" class="section-name selfRef">Capability Negotiation</a>
        </h3>
<p id="section-2.1-1">AccECN is a change to the wire protocol of the main TCP header,
        therefore it can only be used if both endpoints have been upgraded to
        understand it. The TCP client signals support for AccECN on the
        initial SYN of a connection and the TCP server signals whether it
        supports AccECN on the SYN/ACK. The TCP flags on the SYN that the
        client uses to signal AccECN support have been carefully chosen so
        that a TCP server will interpret them as a request to support the most
        recent variant of ECN feedback that it supports. Then the client falls
        back to the same variant of ECN feedback.<a href="#section-2.1-1" class="pilcrow">Â¶</a></p>
<p id="section-2.1-2">An AccECN TCP client does not send the new AccECN Option on the SYN
        as SYN option space is limited. The TCP server sends the AccECN Option
        on the SYN/ACK and the client sends it on the first ACK to test
        whether the network path forwards the option correctly.<a href="#section-2.1-2" class="pilcrow">Â¶</a></p>
</section>
<section id="section-2.2">
        <h3 id="name-feedback-mechanism">
<a href="#section-2.2" class="section-number selfRef">2.2. </a><a href="#name-feedback-mechanism" class="section-name selfRef">Feedback Mechanism</a>
        </h3>
<p id="section-2.2-1">A Data Receiver maintains four counters initialized at the start of
        the half-connection. Three count the number of arriving payload bytes
        respectively marked CE, ECT(1) and ECT(0) in the IP-ECN field. The
        fourth counts the number of packets arriving marked with a CE
        codepoint (including control packets without payload if they are
        CE-marked).<a href="#section-2.2-1" class="pilcrow">Â¶</a></p>
<p id="section-2.2-2">The Data Sender maintains four equivalent counters for the half
        connection, and the AccECN protocol is designed to ensure they will
        match the values in the Data Receiver's counters, albeit after a
        little delay.<a href="#section-2.2-2" class="pilcrow">Â¶</a></p>
<p id="section-2.2-3">Each ACK carries the three least significant bits (LSBs) of the
        packet-based CE counter using the ECN bits in the TCP header, now
        renamed the Accurate ECN (ACE) field (see <a href="#accecn_Fig_ACE_ACK" class="xref">Figure 3</a> later). The 24 LSBs of each byte counter
        are carried in the AccECN Option.<a href="#section-2.2-3" class="pilcrow">Â¶</a></p>
</section>
<section id="section-2.3">
        <h3 id="name-delayed-acks-and-resilience">
<a href="#section-2.3" class="section-number selfRef">2.3. </a><a href="#name-delayed-acks-and-resilience" class="section-name selfRef">Delayed ACKs and Resilience Against ACK Loss</a>
        </h3>
<p id="section-2.3-1">With both the ACE and the AccECN Option mechanisms, the Data
        Receiver continually repeats the current LSBs of each of its
        respective counters. There is no need to acknowledge these continually
        repeated counters, so the congestion window reduced (CWR) mechanism is
        no longer used. Even if some ACKs are lost, the Data Sender should be
        able to infer how much to increment its own counters, even if the
        protocol field has wrapped.<a href="#section-2.3-1" class="pilcrow">Â¶</a></p>
<p id="section-2.3-2">The 3-bit ACE field can wrap fairly frequently. Therefore, even if
        it appears to have incremented by one (say), the field might have
        actually cycled completely then incremented by one. The Data Receiver
        is not allowed to delay sending an ACK to such an extent that the ACE
        field would cycle. However cycling is still a possibility at the Data
        Sender because a whole sequence of ACKs carrying intervening values of
        the field might all be lost or delayed in transit.<a href="#section-2.3-2" class="pilcrow">Â¶</a></p>
<p id="section-2.3-3">The fields in the AccECN Option are larger, but they will increment
        in larger steps because they count bytes not packets. Nonetheless,
        their size has been chosen such that a whole cycle of the field would
        never occur between ACKs unless there had been an infeasibly long
        sequence of ACK losses. Therefore, as long as the AccECN Option is
        available, it can be treated as a dependable feedback channel.<a href="#section-2.3-3" class="pilcrow">Â¶</a></p>
<p id="section-2.3-4">If the AccECN Option is not available, e.g.Â it is being
        stripped by a middlebox, the AccECN protocol will only feed back
        information on CE markings (using the ACE field). Although not ideal,
        this will be sufficient, because it is envisaged that neither ECT(0)
        nor ECT(1) will ever indicate more severe congestion than CE, even
        though future uses for ECT(0) or ECT(1) are still unclear <span>[<a href="#RFC8311" class="xref">RFC8311</a>]</span>. Because the 3-bit ACE field is so small, when it
        is the only field available, the Data Sender has to interpret it
        assuming the most likely wrap, but with a degree of conservatism.<a href="#section-2.3-4" class="pilcrow">Â¶</a></p>
<p id="section-2.3-5">Certain specified events trigger the Data Receiver to include an
        AccECN Option on an ACK. The rules are designed to ensure that the
        order in which different markings arrive at the receiver is
        communicated to the sender (as long as options are reaching the sender
        and as long as there is no ACK loss). Implementations are encouraged
        to send an AccECN Option more frequently, but this is left up to the
        implementer.<a href="#section-2.3-5" class="pilcrow">Â¶</a></p>
</section>
<section id="section-2.4">
        <h3 id="name-feedback-metrics">
<a href="#section-2.4" class="section-number selfRef">2.4. </a><a href="#name-feedback-metrics" class="section-name selfRef">Feedback Metrics</a>
        </h3>
<p id="section-2.4-1">The CE packet counter in the ACE field and the CE byte counter in
        the AccECN Option both provide feedback on received CE-marks. The CE
        packet counter includes control packets that do not have payload data,
        while the CE byte counter solely includes marked payload bytes. If
        both are present, the byte counter in the option will provide the more
        accurate information needed for modern congestion control and policing
        schemes, such as L4S, DCTCP or ConEx. If the option is stripped, a
        simple algorithm to estimate the number of marked bytes from the ACE
        field is given in <a href="#accecn_Algo_ACE_Bytes" class="xref">Appendix A.3</a>.<a href="#section-2.4-1" class="pilcrow">Â¶</a></p>
<p id="section-2.4-2">Feedback in bytes is recommended in order to protect against the
        receiver using attacks similar to 'ACK-Division' to artificially
        inflate the congestion window, which is why <span>[<a href="#RFC5681" class="xref">RFC5681</a>]</span>
        now recommends that TCP counts acknowledged bytes not packets.<a href="#section-2.4-2" class="pilcrow">Â¶</a></p>
</section>
<div id="accecn_demb_reflector">
<section id="section-2.5">
        <h3 id="name-generic-dumb-reflector">
<a href="#section-2.5" class="section-number selfRef">2.5. </a><a href="#name-generic-dumb-reflector" class="section-name selfRef">Generic (Dumb) Reflector</a>
        </h3>
<p id="section-2.5-1">The ACE field provides feedback about CE markings in the IP-ECN
        field of both data and control packets. According to <span>[<a href="#RFC3168" class="xref">RFC3168</a>]</span> the Data Sender is meant to set the IP-ECN field of
        control packets to Not-ECT. However, mechanisms in certain private
        networks (e.g.Â data centres) set control packets to be ECN
        capable because they are precisely the packets that performance
        depends on most.<a href="#section-2.5-1" class="pilcrow">Â¶</a></p>
<p id="section-2.5-2">For this reason, AccECN is designed to be a generic reflector of
        whatever ECN markings it sees, whether or not they are compliant with
        a current standard. Then as standards evolve, Data Senders can upgrade
        unilaterally without any need for receivers to upgrade too. It is also
        useful to be able to rely on generic reflection behaviour when senders
        need to test for unexpected interference with markings (for instance
        <a href="#accecn_sec_ecn-mangling" class="xref">Section 3.2.2.3</a>, <a href="#accecn_sec_ACE_init_invalid" class="xref">Section 3.2.2.4</a> and <a href="#accecn_Mbox_Interference" class="xref">Section 3.2.3.2</a> of the present document and para 2
        of Section 20.2 of <span>[<a href="#RFC3168" class="xref">RFC3168</a>]</span>).<a href="#section-2.5-2" class="pilcrow">Â¶</a></p>
<p id="section-2.5-3">The initial SYN is the most critical control packet, so AccECN
        provides feedback on its IP-ECN field. Although RFC 3168 prohibits an
        ECN-capable SYN, providing feedback of ECN marking on the SYN supports
        future scenarios in which SYNs might be ECN-enabled (without
        prejudging whether they ought to be). For instance, <span>[<a href="#RFC8311" class="xref">RFC8311</a>]</span> updates this aspect of RFC 3168 to allow
        experimentation with ECN-capable TCP control packets.<a href="#section-2.5-3" class="pilcrow">Â¶</a></p>
<p id="section-2.5-4">Even if the TCP client (or server) has set the SYN (or SYN/ACK) to
        not-ECT in compliance with RFC 3168, feedback on the state of the
        IP-ECN field when it arrives at the receiver could still be useful,
        because middleboxes have been known to overwrite the IP-ECN field as
        if it is still part of the old Type of Service (ToS) field <span>[<a href="#Mandalari18" class="xref">Mandalari18</a>]</span>. If a TCP client has set the SYN to Not-ECT,
        but receives feedback that the IP-ECN field on the SYN arrived with a
        different codepoint, it can detect such middlebox interference and
        send Not-ECT for the rest of the connection. Previously, if a TCP
        server received ECT or CE on a SYN, it could not know whether it was
        invalid (or valid) because only the TCP client knew whether it
        originally marked the SYN as Not-ECT (or ECT). Therefore, prior to
        AccECN, the server's only safe course of action was to disable ECN for
        the connection. Instead, the AccECN protocol allows the server to feed
        back the received ECN field to the client, which then has all the
        information to decide whether the connection has to fall-back from
        supporting ECN (or not).<a href="#section-2.5-4" class="pilcrow">Â¶</a></p>
</section>
</div>
</section>
</div>
<div id="accecn_Spec">
<section id="section-3">
      <h2 id="name-accecn-protocol-specificati">
<a href="#section-3" class="section-number selfRef">3. </a><a href="#name-accecn-protocol-specificati" class="section-name selfRef">AccECN Protocol Specification</a>
      </h2>
<div id="accecn_Negotiation">
<section id="section-3.1">
        <h3 id="name-negotiating-to-use-accecn">
<a href="#section-3.1" class="section-number selfRef">3.1. </a><a href="#name-negotiating-to-use-accecn" class="section-name selfRef">Negotiating to use AccECN</a>
        </h3>
<p id="section-3.1-1"></p>
<div id="accecn_Negotiation_3WHS">
<section id="section-3.1.1">
          <h4 id="name-negotiation-during-the-tcp-">
<a href="#section-3.1.1" class="section-number selfRef">3.1.1. </a><a href="#name-negotiation-during-the-tcp-" class="section-name selfRef">Negotiation during the TCP handshake</a>
          </h4>
<p id="section-3.1.1-1">Given the ECN Nonce <span>[<a href="#RFC3540" class="xref">RFC3540</a>]</span> has been
          reclassified as historic <span>[<a href="#RFC8311" class="xref">RFC8311</a>]</span>, the present
          specification re-allocates the TCP flag at bit 7 of the TCP header,
          which was previously called NS (Nonce Sum), as the AE (Accurate ECN)
          flag (see IANA Considerations in <a href="#accecn_IANA_Considerations" class="xref">Section 7</a>) as shown below.<a href="#section-3.1.1-1" class="pilcrow">Â¶</a></p>
<span id="name-the-post-accecn-definition-"></span><div id="accecn_Fig_TCPHdr_AE">
<figure id="figure-2">
            <div class="alignCenter art-text artwork" id="section-3.1.1-2.1">
<pre>
  0   1   2   3   4   5   6   7   8   9  10  11  12  13  14  15
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
|               |           | A | C | E | U | A | P | R | S | F |
| Header Length | Reserved  | E | W | C | R | C | S | S | Y | I |
|               |           |   | R | E | G | K | H | T | N | N |
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
</pre>
</div>
<figcaption><a href="#figure-2" class="selfRef">Figure 2</a>:
<a href="#name-the-post-accecn-definition-" class="selfRef">The (post-AccECN) definition of the TCP header flags                  during the TCP handshake</a>
            </figcaption></figure>
</div>
<p id="section-3.1.1-3">During the TCP handshake at the start of a connection, to request
          more accurate ECN feedback the TCP client (host A) MUST set the TCP
          flags AE=1, CWR=1 and ECE=1 in the initial SYN segment.<a href="#section-3.1.1-3" class="pilcrow">Â¶</a></p>
<p id="section-3.1.1-4">If a TCP server (B) that is AccECN-enabled receives a SYN with
          the above three flags set, it MUST set both its half connections
          into AccECN mode. Then it MUST set the AE, CWR and ECE TCP flags on
          the SYN/ACK to the combination in the top block of <a href="#accecn_Tab_Negotiation" class="xref">Table 2</a> that feeds back the IP-ECN field
          that arrived on the SYN. This applies whether or not the server
          itself supports setting the IP-ECN field on a SYN or SYN/ACK (see
          <a href="#accecn_demb_reflector" class="xref">Section 2.5</a> for rationale).<a href="#section-3.1.1-4" class="pilcrow">Â¶</a></p>
<p id="section-3.1.1-5">When the TCP server returns any of the 4 combinations in the top
          block of <a href="#accecn_Tab_Negotiation" class="xref">Table 2</a>, it confirms that
          it supports AccECN. The TCP server MUST NOT set one of these 4
          combination of flags on the SYN/ACK unless the preceding SYN
          requested support for AccECN as above.<a href="#section-3.1.1-5" class="pilcrow">Â¶</a></p>
<p id="section-3.1.1-6"></p>
<p id="section-3.1.1-7">Once a TCP client (A) has sent the above SYN to declare that it
          supports AccECN, and once it has received the above SYN/ACK segment
          that confirms that the TCP server supports AccECN, the TCP client
          MUST set both its half connections into AccECN mode.<a href="#section-3.1.1-7" class="pilcrow">Â¶</a></p>
<p id="section-3.1.1-8">Once in AccECN mode, a TCP client or server has the rights and
          obligations to participate in the ECN protocol defined in <a href="#accecn_implications_accecn_mode" class="xref">Section 3.1.5</a>.<a href="#section-3.1.1-8" class="pilcrow">Â¶</a></p>
<p id="section-3.1.1-9">The procedure for the client to follow if a SYN/ACK does not
          arrive before its retransmission timer expires is given in <a href="#accecn_sec_SYN_rexmt" class="xref">Section 3.1.4</a>.<a href="#section-3.1.1-9" class="pilcrow">Â¶</a></p>
</section>
</div>
<div id="accecn_sec_backward_compat">
<section id="section-3.1.2">
          <h4 id="name-backward-compatibility">
<a href="#section-3.1.2" class="section-number selfRef">3.1.2. </a><a href="#name-backward-compatibility" class="section-name selfRef">Backward Compatibility</a>
          </h4>
<p id="section-3.1.2-1">The three flags set to 1 to indicate AccECN support on the SYN
          have been carefully chosen to enable natural fall-back to prior
          stages in the evolution of ECN, as above. <a href="#accecn_Tab_Negotiation" class="xref">Table 2</a> tabulates all the negotiation
          possibilities for ECN-related capabilities that involve at least one
          AccECN-capable host. The entries in the first two columns have been
          abbreviated, as follows:<a href="#section-3.1.2-1" class="pilcrow">Â¶</a></p>
<span class="break"></span><dl class="dlParallel" id="section-3.1.2-2">
            <dt id="section-3.1.2-2.1">AccECN:</dt>
            <dd style="margin-left: 2.0em" id="section-3.1.2-2.2">More Accurate ECN Feedback (the present
              specification)<a href="#section-3.1.2-2.2" class="pilcrow">Â¶</a>
</dd>
            <dd class="break"></dd>
<dt id="section-3.1.2-2.3">Nonce:</dt>
            <dd style="margin-left: 2.0em" id="section-3.1.2-2.4">ECN Nonce feedback <span>[<a href="#RFC3540" class="xref">RFC3540</a>]</span><a href="#section-3.1.2-2.4" class="pilcrow">Â¶</a>
</dd>
            <dd class="break"></dd>
<dt id="section-3.1.2-2.5">ECN:</dt>
            <dd style="margin-left: 2.0em" id="section-3.1.2-2.6">'Classic' ECN feedback <span>[<a href="#RFC3168" class="xref">RFC3168</a>]</span><a href="#section-3.1.2-2.6" class="pilcrow">Â¶</a>
</dd>
            <dd class="break"></dd>
<dt id="section-3.1.2-2.7">No ECN:</dt>
            <dd style="margin-left: 2.0em" id="section-3.1.2-2.8">Not-ECN-capable. Implicit congestion
              notification using packet drop.<a href="#section-3.1.2-2.8" class="pilcrow">Â¶</a>
</dd>
          <dd class="break"></dd>
</dl>
<span id="name-ecn-capability-negotiation-"></span><div id="accecn_Tab_Negotiation">
<table class="center" id="table-2">
            <caption>
<a href="#table-2" class="selfRef">Table 2</a>:
<a href="#name-ecn-capability-negotiation-" class="selfRef">ECN capability negotiation between Client (A) and Server (B)</a>
            </caption>
<thead>
              <tr>
                <th class="text-left" rowspan="1" colspan="1">A</th>
                <th class="text-left" rowspan="1" colspan="1">B</th>
                <th class="text-center" rowspan="1" colspan="1">SYN A-&gt;B</th>
                <th class="text-center" rowspan="1" colspan="1">SYN/ACK B-&gt;A</th>
                <th class="text-left" rowspan="1" colspan="1">Feedback Mode</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td class="text-left" rowspan="1" colspan="1"></td>
                <td class="text-left" rowspan="1" colspan="1"></td>
                <td class="text-center" rowspan="1" colspan="1">AEÂ CWRÂ ECE</td>
                <td class="text-center" rowspan="1" colspan="1">AEÂ CWRÂ ECE</td>
                <td class="text-left" rowspan="1" colspan="1"></td>
              </tr>
              <tr>
                <td class="text-left" rowspan="1" colspan="1">AccECN</td>
                <td class="text-left" rowspan="1" colspan="1">AccECN</td>
                <td class="text-center" rowspan="1" colspan="1">1 Â  1 Â  1</td>
                <td class="text-center" rowspan="1" colspan="1">0 Â  1 Â  0</td>
                <td class="text-left" rowspan="1" colspan="1">AccECN(no ECT on SYN)</td>
              </tr>
              <tr>
                <td class="text-left" rowspan="1" colspan="1">AccECN</td>
                <td class="text-left" rowspan="1" colspan="1">AccECN</td>
                <td class="text-center" rowspan="1" colspan="1">1 Â  1 Â  1</td>
                <td class="text-center" rowspan="1" colspan="1">0 Â  1 Â  1</td>
                <td class="text-left" rowspan="1" colspan="1">AccECN (ECT1 on SYN)</td>
              </tr>
              <tr>
                <td class="text-left" rowspan="1" colspan="1">AccECN</td>
                <td class="text-left" rowspan="1" colspan="1">AccECN</td>
                <td class="text-center" rowspan="1" colspan="1">1 Â  1 Â  1</td>
                <td class="text-center" rowspan="1" colspan="1">1 Â  0 Â  0</td>
                <td class="text-left" rowspan="1" colspan="1">AccECN (ECT0 on SYN)</td>
              </tr>
              <tr>
                <td class="text-left" rowspan="1" colspan="1">AccECN</td>
                <td class="text-left" rowspan="1" colspan="1">AccECN</td>
                <td class="text-center" rowspan="1" colspan="1">1 Â  1 Â  1</td>
                <td class="text-center" rowspan="1" colspan="1">1 Â  1 Â  0</td>
                <td class="text-left" rowspan="1" colspan="1">AccECN (CE on SYN)</td>
              </tr>
              <tr>
                <td class="text-left" rowspan="1" colspan="1"></td>
                <td class="text-left" rowspan="1" colspan="1"></td>
                <td class="text-center" rowspan="1" colspan="1"></td>
                <td class="text-center" rowspan="1" colspan="1"></td>
                <td class="text-left" rowspan="1" colspan="1"></td>
              </tr>
              <tr>
                <td class="text-left" rowspan="1" colspan="1">AccECN</td>
                <td class="text-left" rowspan="1" colspan="1">Nonce</td>
                <td class="text-center" rowspan="1" colspan="1">1 Â  1 Â  1</td>
                <td class="text-center" rowspan="1" colspan="1">1 Â  0 Â  1</td>
                <td class="text-left" rowspan="1" colspan="1">(Reserved)</td>
              </tr>
              <tr>
                <td class="text-left" rowspan="1" colspan="1">AccECN</td>
                <td class="text-left" rowspan="1" colspan="1">ECN</td>
                <td class="text-center" rowspan="1" colspan="1">1 Â  1 Â  1</td>
                <td class="text-center" rowspan="1" colspan="1">0 Â  0 Â  1</td>
                <td class="text-left" rowspan="1" colspan="1">classic ECN</td>
              </tr>
              <tr>
                <td class="text-left" rowspan="1" colspan="1">AccECN</td>
                <td class="text-left" rowspan="1" colspan="1">No ECN</td>
                <td class="text-center" rowspan="1" colspan="1">1 Â  1 Â  1</td>
                <td class="text-center" rowspan="1" colspan="1">0 Â  0 Â  0</td>
                <td class="text-left" rowspan="1" colspan="1">Not ECN</td>
              </tr>
              <tr>
                <td class="text-left" rowspan="1" colspan="1"></td>
                <td class="text-left" rowspan="1" colspan="1"></td>
                <td class="text-center" rowspan="1" colspan="1"></td>
                <td class="text-center" rowspan="1" colspan="1"></td>
                <td class="text-left" rowspan="1" colspan="1"></td>
              </tr>
              <tr>
                <td class="text-left" rowspan="1" colspan="1">Nonce</td>
                <td class="text-left" rowspan="1" colspan="1">AccECN</td>
                <td class="text-center" rowspan="1" colspan="1">0 Â  1 Â  1</td>
                <td class="text-center" rowspan="1" colspan="1">0 Â  0 Â  1</td>
                <td class="text-left" rowspan="1" colspan="1">classic ECN</td>
              </tr>
              <tr>
                <td class="text-left" rowspan="1" colspan="1">ECN</td>
                <td class="text-left" rowspan="1" colspan="1">AccECN</td>
                <td class="text-center" rowspan="1" colspan="1">0 Â  1 Â  1</td>
                <td class="text-center" rowspan="1" colspan="1">0 Â  0 Â  1</td>
                <td class="text-left" rowspan="1" colspan="1">classic ECN</td>
              </tr>
              <tr>
                <td class="text-left" rowspan="1" colspan="1">No ECN</td>
                <td class="text-left" rowspan="1" colspan="1">AccECN</td>
                <td class="text-center" rowspan="1" colspan="1">0 Â  0 Â  0</td>
                <td class="text-center" rowspan="1" colspan="1">0 Â  0 Â  0</td>
                <td class="text-left" rowspan="1" colspan="1">Not ECN</td>
              </tr>
              <tr>
                <td class="text-left" rowspan="1" colspan="1"></td>
                <td class="text-left" rowspan="1" colspan="1"></td>
                <td class="text-center" rowspan="1" colspan="1"></td>
                <td class="text-center" rowspan="1" colspan="1"></td>
                <td class="text-left" rowspan="1" colspan="1"></td>
              </tr>
              <tr>
                <td class="text-left" rowspan="1" colspan="1">AccECN</td>
                <td class="text-left" rowspan="1" colspan="1">Broken</td>
                <td class="text-center" rowspan="1" colspan="1">1 Â  1 Â  1</td>
                <td class="text-center" rowspan="1" colspan="1">1 Â  1 Â  1</td>
                <td class="text-left" rowspan="1" colspan="1">Not ECN</td>
              </tr>
            </tbody>
          </table>
</div>
<p id="section-3.1.2-4"><a href="#accecn_Tab_Negotiation" class="xref">Table 2</a> is divided into blocks
          each separated by an empty row.<a href="#section-3.1.2-4" class="pilcrow">Â¶</a></p>
<ol start="1" type="1" class="normal type-1" id="section-3.1.2-5">
<li id="section-3.1.2-5.1">The top block shows the case already described in <a href="#accecn_Negotiation" class="xref">Section 3.1</a> where both endpoints support
              AccECN and how the TCP server (B) indicates congestion
              feedback.<a href="#section-3.1.2-5.1" class="pilcrow">Â¶</a>
</li>
            <li id="section-3.1.2-5.2">
              <p id="section-3.1.2-5.2.1">The second block shows the cases where the TCP client (A)
              supports AccECN but the TCP server (B) supports some earlier
              variant of TCP feedback, indicated in its SYN/ACK. Therefore, as
              soon as an AccECN-capable TCP client (A) receives the SYN/ACK
              shown it MUST set both its half connections into the feedback
              mode shown in the rightmost column. If it has set itself into
              classic ECN feedback mode it MUST then comply with <span>[<a href="#RFC3168" class="xref">RFC3168</a>]</span>.<a href="#section-3.1.2-5.2.1" class="pilcrow">Â¶</a></p>
<p id="section-3.1.2-5.2.2">The server response
              called 'Nonce' in the table is now historic. For an AccECN
              implementation, there is no need to recognize or support ECN
              Nonce feedback <span>[<a href="#RFC3540" class="xref">RFC3540</a>]</span>, which has been
              reclassified as historic <span>[<a href="#RFC8311" class="xref">RFC8311</a>]</span>. AccECN is
              compatible with alternative ECN feedback integrity approaches
              (see <a href="#accecn_Integrity" class="xref">Section 5.3</a>).<a href="#section-3.1.2-5.2.2" class="pilcrow">Â¶</a></p>
</li>
            <li id="section-3.1.2-5.3">
              <p id="section-3.1.2-5.3.1">The third block shows the cases where the TCP server (B)
              supports AccECN but the TCP client (A) supports some earlier
              variant of TCP feedback, indicated in its SYN.<a href="#section-3.1.2-5.3.1" class="pilcrow">Â¶</a></p>
<p id="section-3.1.2-5.3.2">When an AccECN-enabled TCP server (B) receives a
              SYN with AE,CWR,ECE = 0,1,1 it MUST do one of the
              following:<a href="#section-3.1.2-5.3.2" class="pilcrow">Â¶</a></p>
<ul class="normal">
<li class="normal" id="section-3.1.2-5.3.3.1">set both its half connections into the classic ECN
                  feedback mode and return a SYN/ACK with AE, CWR, ECE = 0,0,1
                  as shown. Then it MUST comply with <span>[<a href="#RFC3168" class="xref">RFC3168</a>]</span>.<a href="#section-3.1.2-5.3.3.1" class="pilcrow">Â¶</a>
</li>
                <li class="normal" id="section-3.1.2-5.3.3.2">set both its half-connections into No ECN mode and return
                  a SYN/ACK with AE,CWR,ECE = 0,0,0, then continue with ECN
                  disabled. This latter case is unlikely to be desirable, but
                  it is allowed as a possibility, e.g.Â for minimal TCP
                  implementations.<a href="#section-3.1.2-5.3.3.2" class="pilcrow">Â¶</a>
</li>
              </ul>
<p id="section-3.1.2-5.3.4">When an AccECN-enabled TCP server (B) receives a SYN
              with AE,CWR,ECE = 0,0,0 it MUST set both its half connections
              into the Not ECN feedback mode, return a SYN/ACK with AE,CWR,ECE
              = 0,0,0 as shown and continue with ECN disabled.<a href="#section-3.1.2-5.3.4" class="pilcrow">Â¶</a></p>
</li>
            <li id="section-3.1.2-5.4">The fourth block displays a combination labelled `Broken'.
              Some older TCP server implementations incorrectly set the
              reserved flags in the SYN/ACK by reflecting those in the SYN.
              Such broken TCP servers (B) cannot support ECN, so as soon as an
              AccECN-capable TCP client (A) receives such a broken SYN/ACK it
              MUST fall back to Not ECN mode for both its half connections and
              continue with ECN disabled.<a href="#section-3.1.2-5.4" class="pilcrow">Â¶</a>
</li>
          </ol>
<p id="section-3.1.2-6">The following additional rules do not fit the structure of the
          table, but they complement it:<a href="#section-3.1.2-6" class="pilcrow">Â¶</a></p>
<span class="break"></span><dl class="dlParallel" id="section-3.1.2-7">
            <dt id="section-3.1.2-7.1">Simultaneous Open:</dt>
            <dd style="margin-left: 1.5em" id="section-3.1.2-7.2">An originating AccECN Host (A),
              having sent a SYN with AE=1, CWR=1 and ECE=1, might receive
              another SYN from host B. Host A MUST then enter the same
              feedback mode as it would have entered had it been a responding
              host and received the same SYN. Then host A MUST send the same
              SYN/ACK as it would have sent had it been a responding host.<a href="#section-3.1.2-7.2" class="pilcrow">Â¶</a>
</dd>
            <dd class="break"></dd>
<dt id="section-3.1.2-7.3">In-window SYN during TIME-WAIT:</dt>
            <dd style="margin-left: 1.5em" id="section-3.1.2-7.4">Many TCP
              implementations create a new TCP connection if they receive an
              in-window SYN packet during TIME-WAIT state. When a TCP host
              enters TIME-WAIT or CLOSED state, it should ignore any previous
              state about the negotiation of AccECN for that connection and
              renegotiate the feedback mode according to <a href="#accecn_Tab_Negotiation" class="xref">Table 2</a>.<a href="#section-3.1.2-7.4" class="pilcrow">Â¶</a>
</dd>
          <dd class="break"></dd>
</dl>
</section>
</div>
<div id="accecn_sec_forward_compat">
<section id="section-3.1.3">
          <h4 id="name-forward-compatibility">
<a href="#section-3.1.3" class="section-number selfRef">3.1.3. </a><a href="#name-forward-compatibility" class="section-name selfRef">Forward Compatibility</a>
          </h4>
<p id="section-3.1.3-1">If a TCP server that implements AccECN receives a SYN with the
          three TCP header flags (AE, CWR and ECE) set to any combination
          other than 000, 011 or 111, it MUST negotiate the use of AccECN as
          if they had been set to 111. This ensures that future uses of the
          other combinations on a SYN can rely on consistent behaviour from
          the installed base of AccECN servers.<a href="#section-3.1.3-1" class="pilcrow">Â¶</a></p>
<p id="section-3.1.3-2">For the avoidance of doubt, the behaviour described in the
          present specification applies whether or not the three remaining
          reserved TCP header flags are zero.<a href="#section-3.1.3-2" class="pilcrow">Â¶</a></p>
</section>
</div>
<div id="accecn_sec_SYN_rexmt">
<section id="section-3.1.4">
          <h4 id="name-retransmission-of-the-syn">
<a href="#section-3.1.4" class="section-number selfRef">3.1.4. </a><a href="#name-retransmission-of-the-syn" class="section-name selfRef">Retransmission of the SYN</a>
          </h4>
<p id="section-3.1.4-1">If the sender of an AccECN SYN times out before receiving the
          SYN/ACK, the sender SHOULD attempt to negotiate the use of AccECN at
          least one more time by continuing to set all three TCP ECN flags on
          the first retransmitted SYN (using the usual retransmission
          time-outs). If this first retransmission also fails to be
          acknowledged, the sender SHOULD send subsequent retransmissions of
          the SYN with the three TCP-ECN flags cleared (AE=CWR=ECE=0). A
          retransmitted SYN MUST use the same ISN as the original SYN.<a href="#section-3.1.4-1" class="pilcrow">Â¶</a></p>
<p id="section-3.1.4-2">Retrying once before fall-back adds delay in the case where a
          middlebox drops an AccECN (or ECN) SYN deliberately. However,
          current measurements imply that a drop is less likely to be due to
          middlebox interference than other intermittent causes of loss,
          e.g.Â congestion, wireless interference, etc.<a href="#section-3.1.4-2" class="pilcrow">Â¶</a></p>
<p id="section-3.1.4-3">Implementers MAY use other fall-back strategies if they are found
          to be more effective (e.g.Â attempting to negotiate AccECN on
          the SYN only once or more than twice (most appropriate during high
          levels of congestion). However, other fall-back strategies will need
          to follow all the rules in <a href="#accecn_implications_accecn_mode" class="xref">Section 3.1.5</a>, which concern behaviour
          when SYNs or SYN/ACKs negotiating different types of feedback have
          been sent within the same connection.<a href="#section-3.1.4-3" class="pilcrow">Â¶</a></p>
<p id="section-3.1.4-4">Further it may make sense to also remove any other new or
          experimental fields or options on the SYN in case a middlebox might
          be blocking them, although the required behaviour will depend on the
          specification of the other option(s) and any attempt to co-ordinate
          fall-back between different modules of the stack.<a href="#section-3.1.4-4" class="pilcrow">Â¶</a></p>
<p id="section-3.1.4-5">Whichever fall-back strategy is used, the TCP initiator SHOULD
          cache failed connection attempts. If it does, it SHOULD NOT give up
          attempting to negotiate AccECN on the SYN of subsequent connection
          attempts until it is clear that the blockage is persistently and
          specifically due to AccECN. The cache should be arranged to expire
          so that the initiator will infrequently attempt to check whether the
          problem has been resolved.<a href="#section-3.1.4-5" class="pilcrow">Â¶</a></p>
<p id="section-3.1.4-6">The fall-back procedure if the TCP server receives no ACK to
          acknowledge a SYN/ACK that tried to negotiate AccECN is specified in
          <a href="#accecn_Mbox_Interference" class="xref">Section 3.2.3.2</a>.<a href="#section-3.1.4-6" class="pilcrow">Â¶</a></p>
</section>
</div>
<div id="accecn_implications_accecn_mode">
<section id="section-3.1.5">
          <h4 id="name-implications-of-accecn-mode">
<a href="#section-3.1.5" class="section-number selfRef">3.1.5. </a><a href="#name-implications-of-accecn-mode" class="section-name selfRef">Implications of AccECN Mode</a>
          </h4>
<p id="section-3.1.5-1"><a href="#accecn_Negotiation_3WHS" class="xref">Section 3.1.1</a> describes the only ways
          that a host can enter AccECN mode, whether as a client or as a
          server.<a href="#section-3.1.5-1" class="pilcrow">Â¶</a></p>
<p id="section-3.1.5-2">As a Data Sender, a host in AccECN mode has the rights and
          obligations concerning the use of ECN defined below, which build on
          those in <span>[<a href="#RFC3168" class="xref">RFC3168</a>]</span> as updated by <span>[<a href="#RFC8311" class="xref">RFC8311</a>]</span>:<a href="#section-3.1.5-2" class="pilcrow">Â¶</a></p>
<ul class="normal">
<li class="normal" id="section-3.1.5-3.1">
              <p id="section-3.1.5-3.1.1">Using ECT:<a href="#section-3.1.5-3.1.1" class="pilcrow">Â¶</a></p>
<ul class="normal">
<li class="normal" id="section-3.1.5-3.1.2.1">It can set an ECT codepoint in the IP header of packets
                  to indicate to the network that the transport is capable and
                  willing to participate in ECN for this packet.<a href="#section-3.1.5-3.1.2.1" class="pilcrow">Â¶</a>
</li>
                <li class="normal" id="section-3.1.5-3.1.2.2">It does not have to set ECT on any packet (for instance
                  if it has reason to believe such a packet would be
                  blocked).<a href="#section-3.1.5-3.1.2.2" class="pilcrow">Â¶</a>
</li>
              </ul>
</li>
            <li class="normal" id="section-3.1.5-3.2">
              <p id="section-3.1.5-3.2.1">Switching feedback negotiation (e.g.Â fall-back):<a href="#section-3.1.5-3.2.1" class="pilcrow">Â¶</a></p>
<ul class="normal">
<li class="normal" id="section-3.1.5-3.2.2.1">It SHOULD NOT set ECT on any packet if it has received at
                  least one valid SYN or Acceptable SYN/ACK with AE=CWR=ECE=0.
                  A "valid SYN" has the same port numbers and the same ISN as
                  the SYN that caused the server to enter AccECN mode.<a href="#section-3.1.5-3.2.2.1" class="pilcrow">Â¶</a>
</li>
                <li class="normal" id="section-3.1.5-3.2.2.2">It MUST NOT send an ECN-setup SYN <span>[<a href="#RFC3168" class="xref">RFC3168</a>]</span> within the same connection as it has sent
                  a SYN requesting AccECN feedback.<a href="#section-3.1.5-3.2.2.2" class="pilcrow">Â¶</a>
</li>
                <li class="normal" id="section-3.1.5-3.2.2.3">It MUST NOT send an ECN-setup SYN/ACK <span>[<a href="#RFC3168" class="xref">RFC3168</a>]</span> within the same connection as it has sent
                  a SYN/ACK agreeing to use AccECN feedback.<a href="#section-3.1.5-3.2.2.3" class="pilcrow">Â¶</a>
</li>
              </ul>
<p id="section-3.1.5-3.2.3">The above rules are necessary because, if one peer were
              to negotiate the feedback mode in two different types of
              handshake, it would not be possible for the other peer to know
              for certain which handshake packet(s) the other end had
              eventually received or in which order it received them. So, in
              the absence of these rules, the two peers could end up using
              different feedback modes without knowing it.<a href="#section-3.1.5-3.2.3" class="pilcrow">Â¶</a></p>
</li>
            <li class="normal" id="section-3.1.5-3.3">
              <p id="section-3.1.5-3.3.1">Congestion response:<a href="#section-3.1.5-3.3.1" class="pilcrow">Â¶</a></p>
<ul class="normal">
<li class="normal" id="section-3.1.5-3.3.2.1">It is still obliged to respond appropriately to AccECN
                  feedback that indicates there were ECN marks on packets it
                  had previously sent, as defined in Section 6.1 of <span>[<a href="#RFC3168" class="xref">RFC3168</a>]</span> and updated by Sections 2.1 and 4.1 of
                  <span>[<a href="#RFC8311" class="xref">RFC8311</a>]</span>.<a href="#section-3.1.5-3.3.2.1" class="pilcrow">Â¶</a>
</li>
                <li class="normal" id="section-3.1.5-3.3.2.2">The commitment to respond appropriately to incoming
                  indications of congestion remains even if it sends a SYN
                  packet with AE=CWR=ECE=0, in a later transmission within the
                  same TCP connection.<a href="#section-3.1.5-3.3.2.2" class="pilcrow">Â¶</a>
</li>
                <li class="normal" id="section-3.1.5-3.3.2.3">Unlike an RFC 3168 data sender, it MUST NOT set CWR to
                  indicate it has received and responded to indications of
                  congestion (for the avoidance of doubt, this does not
                  preclude it from setting the bits of the ACE counter field,
                  which includes an overloaded use of the same bit).<a href="#section-3.1.5-3.3.2.3" class="pilcrow">Â¶</a>
</li>
              </ul>
</li>
          </ul>
<p id="section-3.1.5-4">As a Data Receiver:<a href="#section-3.1.5-4" class="pilcrow">Â¶</a></p>
<ul class="normal">
<li class="normal" id="section-3.1.5-5.1">a host in AccECN mode MUST feed back the information in the
              IP-ECN field of incoming packets using Accurate ECN feedback, as
              specified in <a href="#accecn_feedback" class="xref">Section 3.2</a> below.<a href="#section-3.1.5-5.1" class="pilcrow">Â¶</a>
</li>
            <li class="normal" id="section-3.1.5-5.2">if it receives an ECN-setup SYN or ECN-setup SYN/ACK <span>[<a href="#RFC3168" class="xref">RFC3168</a>]</span> during the same connection as it receives a
              SYN requesting AccECN feedback or a SYN/ACK agreeing to use
              AccECN feedback, it MUST reset the connection with a RST
              packet.<a href="#section-3.1.5-5.2" class="pilcrow">Â¶</a>
</li>
            <li class="normal" id="section-3.1.5-5.3">If for any reason it is not willing to provide ECN feedback
              on a particular TCP connection, to indicate this unwillingness
              it SHOULD clear the AE, CWR and ECE flags in all SYN and/or
              SYN/ACK packets that it sends.<a href="#section-3.1.5-5.3" class="pilcrow">Â¶</a>
</li>
            <li class="normal" id="section-3.1.5-5.4">it MUST NOT use reception of packets with ECT set in the
              IP-ECN field as an implicit signal that the peer is ECN-capable.
              Reason: ECT at the IP layer does not explicitly confirm the peer
              has the correct ECN feedback logic, as the packets could have
              been mangled at the IP layer.<a href="#section-3.1.5-5.4" class="pilcrow">Â¶</a>
</li>
          </ul>
</section>
</div>
</section>
</div>
<div id="accecn_feedback">
<section id="section-3.2">
        <h3 id="name-accecn-feedback">
<a href="#section-3.2" class="section-number selfRef">3.2. </a><a href="#name-accecn-feedback" class="section-name selfRef">AccECN Feedback</a>
        </h3>
<p id="section-3.2-1">Each Data Receiver of each half connection maintains four counters,
        r.cep, r.ceb, r.e0b and r.e1b:<a href="#section-3.2-1" class="pilcrow">Â¶</a></p>
<ul class="normal">
<li class="normal" id="section-3.2-2.1">The Data Receiver MUST increment the CE packet counter (r.cep),
            for every Acceptable packet that it receives with the CE code
            point in the IP ECN field, including CE marked control packets but
            excluding CE on SYN packets (SYN=1; ACK=0).<a href="#section-3.2-2.1" class="pilcrow">Â¶</a>
</li>
          <li class="normal" id="section-3.2-2.2">A Data Receiver that supports sending of the AccECN TCP Option
            MUST increment the r.ceb, r.e0b or r.e1b byte counters by the
            number of TCP payload octets in Acceptable packets marked
            respectively with the CE, ECT(0) and ECT(1) codepoint in their
            IP-ECN field, including any payload octets on control packets, but
            not including any payload octets on SYN packets (SYN=1;
            ACK=0).<a href="#section-3.2-2.2" class="pilcrow">Â¶</a>
</li>
        </ul>
<p id="section-3.2-3">Each Data Sender of each half connection maintains four counters,
        s.cep, s.ceb, s.e0b and s.e1b intended to track the equivalent
        counters at the Data Receiver.<a href="#section-3.2-3" class="pilcrow">Â¶</a></p>
<p id="section-3.2-4">A Data Receiver feeds back the CE packet counter using the Accurate
        ECN (ACE) field, as explained in <a href="#accecn_ACE" class="xref">Section 3.2.2</a>. And it
        optionally feeds back all the byte counters using the AccECN TCP
        Option, as specified in <a href="#accecn_option" class="xref">Section 3.2.3</a>.<a href="#section-3.2-4" class="pilcrow">Â¶</a></p>
<p id="section-3.2-5">Whenever a host feeds back the value of any counter, it MUST report
        the most recent value, no matter whether it is in a pure ACK, an ACK
        with new payload data or a retransmission. Therefore the feedback
        carried on a retransmitted packet is unlikely to be the same as the
        feedback on the original packet.<a href="#section-3.2-5" class="pilcrow">Â¶</a></p>
<div id="accecn_init_counters">
<section id="section-3.2.1">
          <h4 id="name-initialization-of-feedback-">
<a href="#section-3.2.1" class="section-number selfRef">3.2.1. </a><a href="#name-initialization-of-feedback-" class="section-name selfRef">Initialization of Feedback Counters</a>
          </h4>
<p id="section-3.2.1-1">When a host first enters AccECN mode, in its role as a Data
          Receiver it initializes its counters to r.cep = 5, r.e0b = r.e1b = 1
          and r.ceb = 0,<a href="#section-3.2.1-1" class="pilcrow">Â¶</a></p>
<p id="section-3.2.1-2">Non-zero initial values are used to support a stateless handshake
          (see <a href="#accecn_Interaction_SYN_Cookies" class="xref">Section 5.1</a>) and to be
          distinct from cases where the fields are incorrectly zeroed
          (e.g.Â by middleboxes - see <a href="#accecn_sec_zero_option" class="xref">Section 3.2.3.2.4</a>).<a href="#section-3.2.1-2" class="pilcrow">Â¶</a></p>
<p id="section-3.2.1-3">When a host enters AccECN mode, in its role as a Data Sender it
          initializes its counters to s.cep = 5, s.e0b = s.e1b = 1 and s.ceb =
          0.<a href="#section-3.2.1-3" class="pilcrow">Â¶</a></p>
</section>
</div>
<div id="accecn_ACE">
<section id="section-3.2.2">
          <h4 id="name-the-ace-field">
<a href="#section-3.2.2" class="section-number selfRef">3.2.2. </a><a href="#name-the-ace-field" class="section-name selfRef">The ACE Field</a>
          </h4>
<p id="section-3.2.2-1">After AccECN has been negotiated on the SYN and SYN/ACK, both
          hosts overload the three TCP flags (AE, CWR and ECE) in the main TCP
          header as one 3-bit field. Then the field is given a new name, ACE,
          as shown in <a href="#accecn_Fig_ACE_ACK" class="xref">Figure 3</a>.<a href="#section-3.2.2-1" class="pilcrow">Â¶</a></p>
<span id="name-definition-of-the-ace-field"></span><div id="accecn_Fig_ACE_ACK">
<figure id="figure-3">
            <div class="alignCenter art-text artwork" id="section-3.2.2-2.1">
<pre>
  0   1   2   3   4   5   6   7   8   9  10  11  12  13  14  15
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
|               |           |           | U | A | P | R | S | F |
| Header Length | Reserved  |    ACE    | R | C | S | S | Y | I |
|               |           |           | G | K | H | T | N | N |
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
</pre>
</div>
<figcaption><a href="#figure-3" class="selfRef">Figure 3</a>:
<a href="#name-definition-of-the-ace-field" class="selfRef">Definition of  the ACE field within bytes 13 and 14 of the TCP Header (when AccECN has been negotiated and SYN=0).</a>
            </figcaption></figure>
</div>
<p id="section-3.2.2-3">The original definition of these three flags in the TCP header,
          including the addition of support for the ECN Nonce, is shown for
          comparison in <a href="#accecn_Fig_TCPHdr" class="xref">Figure 1</a>. This specification
          does not rename these three TCP flags to ACE unconditionally; it
          merely overloads them with another name and definition once an
          AccECN connection has been established.<a href="#section-3.2.2-3" class="pilcrow">Â¶</a></p>
<p id="section-3.2.2-4">With one exception (<a href="#accecn_ACE_3rdACK" class="xref">Section 3.2.2.1</a>), a host
          with both of its half-connections in AccECN mode MUST interpret the
          AE, CWR and ECE flags as the 3-bit ACE counter on a segment with the
          SYN flag cleared (SYN=0). On such a packet, a Data Receiver MUST
          encode the three least significant bits of its r.cep counter into
          the ACE field that it feeds back to the Data Sender. A host MUST NOT
          interpret the 3 flags as a 3-bit ACE field on any segment with SYN=1
          (whether ACK is 0 or 1), or if AccECN negotiation is incomplete or
          has not succeeded.<a href="#section-3.2.2-4" class="pilcrow">Â¶</a></p>
<p id="section-3.2.2-5">Both parts of each of these conditions are equally important. For
          instance, even if AccECN negotiation has been successful, the ACE
          field is not defined on any segments with SYN=1 (e.g.Â a
          retransmission of an unacknowledged SYN/ACK, or when both ends send
          SYN/ACKs after AccECN support has been successfully negotiated
          during a simultaneous open).<a href="#section-3.2.2-5" class="pilcrow">Â¶</a></p>
<div id="accecn_ACE_3rdACK">
<section id="section-3.2.2.1">
            <h5 id="name-ace-field-on-the-ack-of-the">
<a href="#section-3.2.2.1" class="section-number selfRef">3.2.2.1. </a><a href="#name-ace-field-on-the-ack-of-the" class="section-name selfRef">ACE Field on the ACK of the SYN/ACK</a>
            </h5>
<p id="section-3.2.2.1-1">A TCP client (A) in AccECN mode MUST feed back which of the 4
            possible values of the IP-ECN field was on the SYN/ACK by writing
            it into the ACE field of a pure ACK with no SACK blocks using the
            binary encoding in <a href="#accecn_Tab_SYN-ACK_fb2" class="xref">Table 3</a> (which
            is the same as that used on the SYN/ACK in <a href="#accecn_Tab_Negotiation" class="xref">Table 2</a>). This shall be called the
            handshake encoding of the ACE field, and it is the only exception
            to the rule that the ACE field carries the 3 least significant
            bits of the r.cep counter on packets with SYN=0.<a href="#section-3.2.2.1-1" class="pilcrow">Â¶</a></p>
<p id="section-3.2.2.1-2">Normally, a TCP client acknowledges a SYN/ACK with an ACK that
            satisfies the above conditions anyway (SYN=0, no data, no SACK
            blocks). If an AccECN TCP client intends to acknowledge the
            SYN/ACK with a packet that does not satisfy these conditions
            (e.g.Â it has data to include on the ACK), it SHOULD first
            send a pure ACK that does satisfy these conditions (see <a href="#accecn_Interaction_Other" class="xref">Section 5.2</a>), so that it can feed back
            which of the four values of the IP-ECN field arrived on the
            SYN/ACK. A valid exception to this "SHOULD" would be where the
            implementation will only be used in an environment where mangling
            of the ECN field is unlikely.<a href="#section-3.2.2.1-2" class="pilcrow">Â¶</a></p>
<span id="name-the-encoding-of-the-ace-fie"></span><div id="accecn_Tab_SYN-ACK_fb2">
<table class="center" id="table-3">
              <caption>
<a href="#table-3" class="selfRef">Table 3</a>:
<a href="#name-the-encoding-of-the-ace-fie" class="selfRef">The encoding of the ACE field in the ACK of the SYN-ACK to reflect the SYN-ACK's IP-ECN field</a>
              </caption>
<thead>
                <tr>
                  <th class="text-left" rowspan="1" colspan="1">IP-ECN codepoint on SYN/ACK</th>
                  <th class="text-left" rowspan="1" colspan="1">ACE on pure ACK of SYN/ACK</th>
                  <th class="text-left" rowspan="1" colspan="1">r.cep of client in AccECN mode</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td class="text-left" rowspan="1" colspan="1">Not-ECT</td>
                  <td class="text-left" rowspan="1" colspan="1">0b010</td>
                  <td class="text-left" rowspan="1" colspan="1">5</td>
                </tr>
                <tr>
                  <td class="text-left" rowspan="1" colspan="1">ECT(1)</td>
                  <td class="text-left" rowspan="1" colspan="1">0b011</td>
                  <td class="text-left" rowspan="1" colspan="1">5</td>
                </tr>
                <tr>
                  <td class="text-left" rowspan="1" colspan="1">ECT(0)</td>
                  <td class="text-left" rowspan="1" colspan="1">0b100</td>
                  <td class="text-left" rowspan="1" colspan="1">5</td>
                </tr>
                <tr>
                  <td class="text-left" rowspan="1" colspan="1">CE</td>
                  <td class="text-left" rowspan="1" colspan="1">0b110</td>
                  <td class="text-left" rowspan="1" colspan="1">6</td>
                </tr>
              </tbody>
            </table>
</div>
<p id="section-3.2.2.1-4">When an AccECN server in SYN-RCVD state receives a pure ACK
            with SYN=0 and no SACK blocks, instead of treating the ACE field
            as a counter, it MUST infer the meaning of each possible value of
            the ACE field from <a href="#accecn_Tab_SYN-ACK_fb" class="xref">Table 4</a>, which
            also shows the value that an AccECN server MUST set s.cep to as a
            result.<a href="#section-3.2.2.1-4" class="pilcrow">Â¶</a></p>
<p id="section-3.2.2.1-5">Given this encoding of the ACE field on the ACK of a SYN/ACK is
            exceptional, an AccECN server using large receive offload (LRO)
            might prefer to disable LRO until such an ACK has transitioned it
            out of SYN-RCVD state.<a href="#section-3.2.2.1-5" class="pilcrow">Â¶</a></p>
<span id="name-meaning-of-the-ace-field-on"></span><div id="accecn_Tab_SYN-ACK_fb">
<table class="center" id="table-4">
              <caption>
<a href="#table-4" class="selfRef">Table 4</a>:
<a href="#name-meaning-of-the-ace-field-on" class="selfRef">Meaning of the ACE field on the ACK of the SYN/ACK</a>
              </caption>
<thead>
                <tr>
                  <th class="text-left" rowspan="1" colspan="1">ACE on ACK of SYN/ACK</th>
                  <th class="text-left" rowspan="1" colspan="1">IP-ECN codepoint on SYN/ACK inferred by server</th>
                  <th class="text-left" rowspan="1" colspan="1">s.cep of server in AccECN mode</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td class="text-left" rowspan="1" colspan="1">0b000</td>
                  <td class="text-left" rowspan="1" colspan="1">{Notes 1, 3}</td>
                  <td class="text-left" rowspan="1" colspan="1">Disable ECN</td>
                </tr>
                <tr>
                  <td class="text-left" rowspan="1" colspan="1">0b001</td>
                  <td class="text-left" rowspan="1" colspan="1">{Notes 2, 3}</td>
                  <td class="text-left" rowspan="1" colspan="1">5</td>
                </tr>
                <tr>
                  <td class="text-left" rowspan="1" colspan="1">0b010</td>
                  <td class="text-left" rowspan="1" colspan="1">Not-ECT</td>
                  <td class="text-left" rowspan="1" colspan="1">5</td>
                </tr>
                <tr>
                  <td class="text-left" rowspan="1" colspan="1">0b011</td>
                  <td class="text-left" rowspan="1" colspan="1">ECT(1)</td>
                  <td class="text-left" rowspan="1" colspan="1">5</td>
                </tr>
                <tr>
                  <td class="text-left" rowspan="1" colspan="1">0b100</td>
                  <td class="text-left" rowspan="1" colspan="1">ECT(0)</td>
                  <td class="text-left" rowspan="1" colspan="1">5</td>
                </tr>
                <tr>
                  <td class="text-left" rowspan="1" colspan="1">0b101</td>
                  <td class="text-left" rowspan="1" colspan="1">Currently Unused {Note 2}</td>
                  <td class="text-left" rowspan="1" colspan="1">5</td>
                </tr>
                <tr>
                  <td class="text-left" rowspan="1" colspan="1">0b110</td>
                  <td class="text-left" rowspan="1" colspan="1">CE</td>
                  <td class="text-left" rowspan="1" colspan="1">6</td>
                </tr>
                <tr>
                  <td class="text-left" rowspan="1" colspan="1">0b111</td>
                  <td class="text-left" rowspan="1" colspan="1">Currently Unused {Note 2}</td>
                  <td class="text-left" rowspan="1" colspan="1">5</td>
                </tr>
              </tbody>
            </table>
</div>
<p id="section-3.2.2.1-7">{Note 1}: If the server is in AccECN mode, the value of zero
            raises suspicion of zeroing of the ACE field on the path (see
            <a href="#accecn_sec_ACE_init_invalid" class="xref">Section 3.2.2.4</a>).<a href="#section-3.2.2.1-7" class="pilcrow">Â¶</a></p>
<p id="section-3.2.2.1-8">{Note 2}: If the server is in AccECN mode, these values are
            Currently Unused but the AccECN server's behaviour is still
            defined for forward compatibility. Then the designer of a future
            protocol can know for certain what AccECN servers will do with
            these codepoints.<a href="#section-3.2.2.1-8" class="pilcrow">Â¶</a></p>
<p id="section-3.2.2.1-9">{Note 3}: In the case where a server that implements AccECN is
            also using a stateless handshake (termed a SYN cookie) it will not
            remember whether it entered AccECN mode. The values 0b000 or 0b001
            will remind it that it did not enter AccECN mode, because AccECN
            does not use them (see <a href="#accecn_Interaction_SYN_Cookies" class="xref">Section 5.1</a> for details). If a
            stateless server that implements AccECN receives either of these
            two values in the ACK, its action is implementation-dependent and
            outside the scope of this spec, It will certainly not take the
            action in the third column because, after it receives either of
            these values, it is not in AccECN mode. I.e., it will not disable
            ECN (at least not just because ACE is 0b000) and it will not set
            s.cep.<a href="#section-3.2.2.1-9" class="pilcrow">Â¶</a></p>
</section>
</div>
<div id="accecn_sec_ACE_feedback">
<section id="section-3.2.2.2">
            <h5 id="name-encoding-and-decoding-feedb">
<a href="#section-3.2.2.2" class="section-number selfRef">3.2.2.2. </a><a href="#name-encoding-and-decoding-feedb" class="section-name selfRef">Encoding and Decoding Feedback in the ACE Field</a>
            </h5>
<p id="section-3.2.2.2-1">Whenever the Data Receiver sends an ACK with SYN=0 (with or
            without data), unless the handshake encoding in <a href="#accecn_ACE_3rdACK" class="xref">Section 3.2.2.1</a> applies, the Data Receiver MUST
            encode the least significant 3 bits of its r.cep counter into the
            ACE field (see <a href="#accecn_Algo_ACE_Wrap" class="xref">Appendix A.2</a>).<a href="#section-3.2.2.2-1" class="pilcrow">Â¶</a></p>
<p id="section-3.2.2.2-2">Whenever the Data Sender receives an ACK with SYN=0 (with or
            without data), it first checks whether it has already been
            superseded by another ACK in which case it ignores the ECN
            feedback. If the ACK has not been superseded, and if the special
            handshake encoding in <a href="#accecn_ACE_3rdACK" class="xref">Section 3.2.2.1</a> does not
            apply, the Data Sender decodes the ACE field as follows (see <a href="#accecn_Algo_ACE_Wrap" class="xref">Appendix A.2</a> for examples).<a href="#section-3.2.2.2-2" class="pilcrow">Â¶</a></p>
<ul class="normal">
<li class="normal" id="section-3.2.2.2-3.1">It takes the least significant 3 bits of its local s.cep
                counter and subtracts them from the incoming ACE counter to
                work out the minimum positive increment it could apply to
                s.cep (assuming the ACE field only wrapped at most once).<a href="#section-3.2.2.2-3.1" class="pilcrow">Â¶</a>
</li>
              <li class="normal" id="section-3.2.2.2-3.2">It then follows the safety procedures in <a href="#accecn_ACE_Safety_S" class="xref">Section 3.2.2.5.2</a> to calculate or estimate how
                many packets the ACK could have acknowledged under the
                prevailing conditions to determine whether the ACE field might
                have wrapped more than once.<a href="#section-3.2.2.2-3.2" class="pilcrow">Â¶</a>
</li>
            </ul>
<p id="section-3.2.2.2-4">The encode/decode procedures during the three-way handshake are
            exceptions to the general rules given so far, so they are spelled
            out step by step below for clarity:<a href="#section-3.2.2.2-4" class="pilcrow">Â¶</a></p>
<ul class="normal">
<li class="normal" id="section-3.2.2.2-5.1">
                <p id="section-3.2.2.2-5.1.1">If a TCP server in AccECN mode receives a CE mark in the
                IP-ECN field of a SYN (SYN=1, ACK=0), it MUST NOT increment
                r.cep (it remains at its initial value of 5).<a href="#section-3.2.2.2-5.1.1" class="pilcrow">Â¶</a></p>
<p id="section-3.2.2.2-5.1.2">Reason: It would be redundant for the server
                to include CE-marked SYNs in its r.cep counter, because it
                already reliably delivers feedback of any CE marking using the
                encoding in <a href="#accecn_Tab_Negotiation" class="xref">Table 2</a> in the
                SYN/ACK. This also ensures that, when the server starts using
                the ACE field, it has not unnecessarily consumed more than one
                initial value, given they can be used to negotiate variants of
                the AccECN protocol (see <a href="#accecn_space_evolution" class="xref">Appendix B.3</a>).<a href="#section-3.2.2.2-5.1.2" class="pilcrow">Â¶</a></p>
</li>
              <li class="normal" id="section-3.2.2.2-5.2">If a TCP client in AccECN mode receives CE feedback in the
                TCP flags of a SYN/ACK, it MUST NOT increment s.cep (it
                remains at its initial value of 5), so that it stays in step
                with r.cep on the server. Nonetheless, the TCP client still
                triggers the congestion control actions necessary to respond
                to the CE feedback.<a href="#section-3.2.2.2-5.2" class="pilcrow">Â¶</a>
</li>
              <li class="normal" id="section-3.2.2.2-5.3">
                <p id="section-3.2.2.2-5.3.1">If a TCP client in AccECN mode receives a CE mark in the
                IP-ECN field of a SYN/ACK, it MUST increment r.cep, but no
                more than once no matter how many CE-marked SYN/ACKs it
                receives (i.e.Â incremented from 5 to 6, but no further).<a href="#section-3.2.2.2-5.3.1" class="pilcrow">Â¶</a></p>
<p id="section-3.2.2.2-5.3.2">Reason: Incrementing r.cep ensures the
                client will eventually deliver any CE marking to the server
                reliably when it starts using the ACE field. Even though the
                client also feeds back any CE marking on the ACK of the
                SYN/ACK using the encoding in <a href="#accecn_Tab_SYN-ACK_fb2" class="xref">Table 3</a>, this ACK is not delivered
                reliably, so it can be considered as a timely notification
                that is redundant but unreliable. The client does not
                increment r.cep more than once, because the server can only
                increment s.cep once (see next bullet). Also, this limits the
                unnecessarily consumed initial values of the ACE field to
                two.<a href="#section-3.2.2.2-5.3.2" class="pilcrow">Â¶</a></p>
</li>
              <li class="normal" id="section-3.2.2.2-5.4">
                <p id="section-3.2.2.2-5.4.1">If a TCP server in AccECN mode and in SYN-RCVD state
                receives CE feedback in the TCP flags of a pure ACK with no
                SACK blocks, it MUST increment s.cep (from 5 to 6). The TCP
                server then triggers the congestion control actions necessary
                to respond to the CE feedback.<a href="#section-3.2.2.2-5.4.1" class="pilcrow">Â¶</a></p>
<p id="section-3.2.2.2-5.4.2">Reasoning: The TCP server can only increment
                s.cep once, because the first ACK it receives will cause it to
                transition out of SYN-RCVD state. The server's congestion
                response would be no different even if it could receive
                feedback of more than one CE-marked SYN/ACK.<a href="#section-3.2.2.2-5.4.2" class="pilcrow">Â¶</a></p>
<p id="section-3.2.2.2-5.4.3">Once the TCP server transitions to ESTABLISHED
                state, it might later receive other pure ACK(s) with the
                handshake encoding in the ACE field. A server MAY implement a
                test for such a case, but it is not required. Therefore, once
                in the ESTABLISHED state, it will be sufficient for the server
                to consider the ACE field to be encoded as the normal ACE
                counter on all packets with SYN=0.<a href="#section-3.2.2.2-5.4.3" class="pilcrow">Â¶</a></p>
<p id="section-3.2.2.2-5.4.4">Reasoning: Such ACKs will be quite unusual,
                e.g.Â a SYN/ACK (or ACK of the SYN/ACK) that is delayed
                for longer than the server's retransmission timeout; or packet
                duplication by the network. And the impact of any error in the
                feedback on such ACKs will only be temporary.<a href="#section-3.2.2.2-5.4.4" class="pilcrow">Â¶</a></p>
</li>
            </ul>
</section>
</div>
<div id="accecn_sec_ecn-mangling">
<section id="section-3.2.2.3">
            <h5 id="name-testing-for-mangling-of-the">
<a href="#section-3.2.2.3" class="section-number selfRef">3.2.2.3. </a><a href="#name-testing-for-mangling-of-the" class="section-name selfRef">Testing for Mangling of the IP/ECN Field</a>
            </h5>
<p id="section-3.2.2.3-1">The value of the ACE field on the SYN/ACK indicates the value
            of the IP/ECN field when the SYN arrived at the server. The client
            can compare this with how it originally set the IP/ECN field on
            the SYN. If this comparison implies an unsafe transition (see
            below) of the IP/ECN field, for the remainder of the connection
            the client MUST NOT send ECN-capable packets, but it MUST continue
            to feed back any ECN markings on arriving packets.<a href="#section-3.2.2.3-1" class="pilcrow">Â¶</a></p>
<p id="section-3.2.2.3-2">The value of the ACE field on the last ACK of the 3WHS
            indicates the value of the IP/ECN field when the SYN/ACK arrived
            at the client. The server can compare this with how it originally
            set the IP/ECN field on the SYN/ACK. If this comparison implies an
            unsafe transition of the IP/ECN field, for the remainder of the
            connection the server MUST NOT send ECN-capable packets, but it
            MUST continue to feed back any ECN markings on arriving
            packets.<a href="#section-3.2.2.3-2" class="pilcrow">Â¶</a></p>
<p id="section-3.2.2.3-3">The ACK of the SYN/ACK is not reliably delivered (nonetheless,
            the count of CE marks is still eventually delivered reliably). If
            this ACK does not arrive, the server can continue to send
            ECN-capable packets without having tested for mangling of the
            IP/ECN field on the SYN/ACK.<a href="#section-3.2.2.3-3" class="pilcrow">Â¶</a></p>
<p id="section-3.2.2.3-4">Invalid transitions of the IP/ECN field are defined in <span>[<a href="#RFC3168" class="xref">RFC3168</a>]</span> and repeated here for convenience:<a href="#section-3.2.2.3-4" class="pilcrow">Â¶</a></p>
<ul class="normal">
<li class="normal" id="section-3.2.2.3-5.1">the not-ECT codepoint changes;<a href="#section-3.2.2.3-5.1" class="pilcrow">Â¶</a>
</li>
              <li class="normal" id="section-3.2.2.3-5.2">either ECT codepoint transitions to not-ECT;<a href="#section-3.2.2.3-5.2" class="pilcrow">Â¶</a>
</li>
              <li class="normal" id="section-3.2.2.3-5.3">the CE codepoint changes.<a href="#section-3.2.2.3-5.3" class="pilcrow">Â¶</a>
</li>
            </ul>
<p id="section-3.2.2.3-6">RFC 3168 says that a router that changes ECT to not-ECT is
            invalid but safe. However, from a host's viewpoint, this
            transition is unsafe because it could be the result of two
            transitions at different routers on the path: ECT to CE (safe)
            then CE to not-ECT (unsafe). This scenario could well happen where
            an ECN-enabled home router congests its upstream mobile broadband
            bottleneck link, then the ingress to the mobile network clears the
            ECN field <span>[<a href="#Mandalari18" class="xref">Mandalari18</a>]</span>.<a href="#section-3.2.2.3-6" class="pilcrow">Â¶</a></p>
<p id="section-3.2.2.3-7">Once a Data Sender has entered AccECN mode it SHOULD check
            whether it is receiving continuous CE marking. Specifying exactly
            how to do this is beyond the scope of the present specification,
            but the sender might check whether the feedback for every packet
            it sends for the first three or four rounds indicates CE-marking.
            If continuous CE-marking is detected, for the remainder of the
            connection the Data Sender SHOULD NOT send ECN-capable packets and
            consequently it SHOULD NOT respond to any ECN feedback. The phrase
            'MUST NOT' has been avoided to allow the sender to test whether it
            can resume sending ECN-capable packets. Throughout, it MUST remain
            in the AccECN feedback mode and it MUST continue to feed back any
            ECN markings on arriving packets (in its role as Data
            Receiver).<a href="#section-3.2.2.3-7" class="pilcrow">Â¶</a></p>
<p id="section-3.2.2.3-8">All the fall-back behaviours in this section are necessary in
            case mangling of the IP/ECN field is asymmetric, which is
            currently common over some mobile networks <span>[<a href="#Mandalari18" class="xref">Mandalari18</a>]</span>. Then one end might see no unsafe
            transition and continue sending ECN-capable packets, while the
            other end sees an unsafe transition and stops sending ECN-capable
            packets.<a href="#section-3.2.2.3-8" class="pilcrow">Â¶</a></p>
</section>
</div>
<div id="accecn_sec_ACE_init_invalid">
<section id="section-3.2.2.4">
            <h5 id="name-testing-for-zeroing-of-the-">
<a href="#section-3.2.2.4" class="section-number selfRef">3.2.2.4. </a><a href="#name-testing-for-zeroing-of-the-" class="section-name selfRef">Testing for Zeroing of the ACE Field</a>
            </h5>
<p id="section-3.2.2.4-1"><a href="#accecn_ACE" class="xref">Section 3.2.2</a> required the Data Receiver to
            initialize the r.cep counter to a non-zero value. Therefore, in
            either direction the initial value of the ACE counter ought to be
            non-zero.<a href="#section-3.2.2.4-1" class="pilcrow">Â¶</a></p>
<p id="section-3.2.2.4-2">If AccECN has been successfully negotiated, the Data Sender
            SHOULD check the value of the ACE counter in the first packet
            (with or without data) that arrives with SYN=0. If the value of
            this ACE field is zero (0b000), the Data Sender disables sending
            ECN-capable packets for the remainder of the half-connection by
            setting the IP/ECN field in all subsequent packets to Not-ECT.<a href="#section-3.2.2.4-2" class="pilcrow">Â¶</a></p>
<p id="section-3.2.2.4-3">Usually, the server checks the ACK of the SYN/ACK from the
            client, while the client checks the first data segment from the
            server. However, if reordering occurs, "the first packet ... that
            arrives" will not necessarily be the same as the first packet in
            sequence order. The test has been specified loosely like this to
            simplify implementation, and because it would not have been any
            more precise to have specified the first packet in sequence order,
            which would not necessarily be the first ACE counter that the Data
            Receiver fed back anyway, given it might have been a
            retransmission.<a href="#section-3.2.2.4-3" class="pilcrow">Â¶</a></p>
<p id="section-3.2.2.4-4">The possibility of re-ordering means that there is a small
            chance that the ACE field on the first packet to arrive is
            genuinely zero (without middlebox interference). This would cause
            a host to unnecessarily disable ECN for a half connection.
            Therefore, in environments where there is no evidence of the ACE
            field being zeroed, implementations can skip this test.<a href="#section-3.2.2.4-4" class="pilcrow">Â¶</a></p>
<p id="section-3.2.2.4-5">Note that the Data Sender MUST NOT test whether the arriving
            counter in the initial ACE field has been initialized to a
            specific valid value - the above check solely tests whether the
            ACE fields have been incorrectly zeroed. This allows hosts to use
            different initial values as an additional signalling channel in
            future.<a href="#section-3.2.2.4-5" class="pilcrow">Â¶</a></p>
</section>
</div>
<div id="accecn_ACE_Safety">
<section id="section-3.2.2.5">
            <h5 id="name-safety-against-ambiguity-of">
<a href="#section-3.2.2.5" class="section-number selfRef">3.2.2.5. </a><a href="#name-safety-against-ambiguity-of" class="section-name selfRef">Safety against Ambiguity of the ACE Field</a>
            </h5>
<p id="section-3.2.2.5-1">If too many CE-marked segments are acknowledged at once, or if
            a long run of ACKs is lost or thinned out, the 3-bit counter in
            the ACE field might have cycled between two ACKs arriving at the
            Data Sender. The following safety procedures minimize this
            ambiguity.<a href="#section-3.2.2.5-1" class="pilcrow">Â¶</a></p>
<div id="accecn_ACE_Safety_R">
<section id="section-3.2.2.5.1">
              <h6 id="name-data-receiver-safety-proced">
<a href="#section-3.2.2.5.1" class="section-number selfRef">3.2.2.5.1. </a><a href="#name-data-receiver-safety-proced" class="section-name selfRef">Data Receiver Safety Procedures</a>
              </h6>
<p id="section-3.2.2.5.1-1">The following rules define when a Data Receiver in AccECN
              mode emits an ACK:<a href="#section-3.2.2.5.1-1" class="pilcrow">Â¶</a></p>
<span class="break"></span><dl class="dlParallel" id="section-3.2.2.5.1-2">
                <dt id="section-3.2.2.5.1-2.1">Change-Triggered ACKs:</dt>
                <dd style="margin-left: 1.5em" id="section-3.2.2.5.1-2.2">
                  <p id="section-3.2.2.5.1-2.2.1">An AccECN Data Receiver
                  SHOULD emit an ACK whenever a data packet marked CE arrives
                  after the previous packet was not CE.<a href="#section-3.2.2.5.1-2.2.1" class="pilcrow">Â¶</a></p>
<p id="section-3.2.2.5.1-2.2.2">Even though this rule is stated as a
                  "SHOULD", it is important for a transition to trigger an ACK
                  if at all possible, The only valid exception to this rule is
                  given below these bullets.<a href="#section-3.2.2.5.1-2.2.2" class="pilcrow">Â¶</a></p>
<p id="section-3.2.2.5.1-2.2.3">For the
                  avoidance of doubt, this rule is deliberately worded to
                  apply solely when <em>data</em> packets
                  arrive, but the comparison with the previous packet includes
                  any packet, not just data packets.<a href="#section-3.2.2.5.1-2.2.3" class="pilcrow">Â¶</a></p>
</dd>
                <dd class="break"></dd>
<dt id="section-3.2.2.5.1-2.3">Increment-Triggered ACKs:</dt>
                <dd style="margin-left: 1.5em" id="section-3.2.2.5.1-2.4">An AccECN Data
                  Receiver MUST emit an ACK if 'n' CE marks have arrived since
                  the previous ACK. If there is newly delivered data to
                  acknowledge, 'n' SHOULD be 2. If there is no newly delivered
                  data to acknowledge, 'n' SHOULD be 3 and MUST be no less
                  than 3. In either case, 'n' MUST be no greater than 7.<a href="#section-3.2.2.5.1-2.4" class="pilcrow">Â¶</a>
</dd>
              <dd class="break"></dd>
</dl>
<p id="section-3.2.2.5.1-3">The above rules for when to send an ACK are designed to
              be complemented by those in <a href="#accecn_option_usage" class="xref">Section 3.2.3.3</a>, which concern whether the AccECN
              TCP Option ought to be included on ACKs.<a href="#section-3.2.2.5.1-3" class="pilcrow">Â¶</a></p>
<p id="section-3.2.2.5.1-4">If the arrivals of a number of data packets are all processed
              as one event, e.g.Â using large receive offload (LRO) or
              generic receive offload (GRO), both the above rules SHOULD be
              interpreted as requiring multiple ACKs to be emitted
              back-to-back (for each transition and for each repetition by 'n'
              CE marks). If this is problematic for high performance, either
              rule can be interpreted as requiring just a single ACK at the
              end of the whole receive event.<a href="#section-3.2.2.5.1-4" class="pilcrow">Â¶</a></p>
<p id="section-3.2.2.5.1-5">Even if a number of data packets do not arrive as one event,
              the 'Change-Triggered ACKs' rule could sometimes cause the ACK
              rate to be problematic for high performance (although high
              performance protocols such as DCTCP already successfully use
              change-triggered ACKs). The rationale for change-triggered ACKs
              is so that the Data Sender can rely on them to detect queue
              growth as soon as possible, particularly at the start of a flow.
              The approach can lead to some additional ACKs but it feeds back
              the timing and the order in which ECN marks are received with
              minimal additional complexity. If CE marks are infrequent, as is
              the case for most AQMs at the time of writing, or there are
              multiple marks in a row, the additional load will be low.
              However, marking patterns with numerous non-contiguous CE marks
              could increase the load significantly. One possible compromise
              would be for the receiver to heuristically detect whether the
              sender is in slow-start, then to implement change-triggered ACKs
              while the sender is in slow-start, and offload otherwise.<a href="#section-3.2.2.5.1-5" class="pilcrow">Â¶</a></p>
<p id="section-3.2.2.5.1-6">With ECN-capable pure ACKs <span>[<a href="#I-D.ietf-tcpm-generalized-ecn" class="xref">I-D.ietf-tcpm-generalized-ecn</a>]</span>, the
              'Increment-Triggered ACKs' rule could cause ECN-marked pure ACKs
              to trigger further ACKs. Although TCP normally only ACKs newly
              delivered data, in this case the ACKs of ACKs would feed back
              new congestion state. The minimum of 3 for 'n' in this case
              ensures that, even if there is pathological congestion in both
              directions, any resulting ping-pong of ACKs will be rapidly
              damped.<a href="#section-3.2.2.5.1-6" class="pilcrow">Â¶</a></p>
<p id="section-3.2.2.5.1-7">These ACKs of ACKs could be misidentified as duplicate ACKs
              in certain circumstances described below. Therefore, a host in
              AccECN mode that is sending ECN-capable pure ACKs SHOULD add one
              of the following additional checks when it tests whether an
              incoming pure ACK is a duplicate:<a href="#section-3.2.2.5.1-7" class="pilcrow">Â¶</a></p>
<ul class="normal">
<li class="normal" id="section-3.2.2.5.1-8.1">If SACK has been negotatiated for the connection, but
                  there is no SACK option on the incoming pure ACK, it is not
                  a duplicate;<a href="#section-3.2.2.5.1-8.1" class="pilcrow">Â¶</a>
</li>
                <li class="normal" id="section-3.2.2.5.1-8.2">If timestamps are in use, and the incoming pure ACK
                  echoes a timestamp older than the oldest unacknowledged
                  data, it is not a duplicate.<a href="#section-3.2.2.5.1-8.2" class="pilcrow">Â¶</a>
</li>
              </ul>
<p id="section-3.2.2.5.1-9">In the unlikely event that neither SACK nor timestamps
              are in use, or if the implementation has opted not to include
              either of the above two checks, it SHOULD NOT send ECN-capable
              pure ACKs. If it does, it could lead to false detection of
              duplicate ACKs, causing spurious retransmission(s) with a
              resulting unnecessary reduction in congestion window; but only
              in certain circumstances. Specifically, if TCP peer A has been
              sending data, then receiving, then within one round trip it
              starts sending again, and the ECN-capable pure ACKs it sent in
              the previous round encounter heavy enough congestion to trigger
              peer B to invoke the above 'n'-CE-mark rule. Also note that
              falsely considering these ACKs as duplicates would incorrectly
              imply that data left the network.<a href="#section-3.2.2.5.1-9" class="pilcrow">Â¶</a></p>
</section>
</div>
<div id="accecn_ACE_Safety_S">
<section id="section-3.2.2.5.2">
              <h6 id="name-data-sender-safety-procedur">
<a href="#section-3.2.2.5.2" class="section-number selfRef">3.2.2.5.2. </a><a href="#name-data-sender-safety-procedur" class="section-name selfRef">Data Sender Safety Procedures</a>
              </h6>
<p id="section-3.2.2.5.2-1">If the Data Sender has not received AccECN TCP Options to
              give it more dependable information, and it detects that the ACE
              field could have cycled, it SHOULD deem whether it cycled by
              taking the safest likely case under the prevailing conditions.
              It can detect if the counter could have cycled by using the jump
              in the acknowledgement number since the last ACK to calculate or
              estimate how many segments could have been acknowledged. An
              example algorithm to implement this policy is given in <a href="#accecn_Algo_ACE_Wrap" class="xref">Appendix A.2</a>. An implementer MAY develop an
              alternative algorithm as long as it satisfies these
              requirements.<a href="#section-3.2.2.5.2-1" class="pilcrow">Â¶</a></p>
<p id="section-3.2.2.5.2-2">If missing acknowledgement numbers arrive later (reordering)
              and prove that the counter did not cycle, the Data Sender MAY
              attempt to neutralize the effect of any action it took based on
              a conservative assumption that it later found to be
              incorrect.<a href="#section-3.2.2.5.2-2" class="pilcrow">Â¶</a></p>
<p id="section-3.2.2.5.2-3">The Data Sender can estimate how many packets (of any
              marking) an ACK acknowledges. If the ACE counter on an ACK seems
              to imply that the minimum number of newly CE-marked packets is
              greater that the number of newly acknowledged packets, the Data
              Sender SHOULD believe the ACE counter, unless it can be sure
              that it is counting all control packets correctly.<a href="#section-3.2.2.5.2-3" class="pilcrow">Â¶</a></p>
</section>
</div>
</section>
</div>
</section>
</div>
<div id="accecn_option">
<section id="section-3.2.3">
          <h4 id="name-the-accecn-option">
<a href="#section-3.2.3" class="section-number selfRef">3.2.3. </a><a href="#name-the-accecn-option" class="section-name selfRef">The AccECN Option</a>
          </h4>
<p id="section-3.2.3-1">The AccECN Option is defined as shown in <a href="#accecn_Fig_TCPopt" class="xref">Figure 4</a>. The initial 'E' of each field name
          stands for 'Echo'.<a href="#section-3.2.3-1" class="pilcrow">Â¶</a></p>
<span id="name-the-accecn-tcp-option"></span><div id="accecn_Fig_TCPopt">
<figure id="figure-4">
            <div class="alignLeft art-text artwork" id="section-3.2.3-2.1">
<pre> 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|  Kind = TBD0  |  Length = 11  |          EE0B field           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
| EE0B (cont'd) |           ECEB field                          |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                  EE1B field                   |             Order 0
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|  Kind = TBD1  |  Length = 11  |          EE1B field           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
| EE1B (cont'd) |           ECEB field                          |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                  EE0B field                   |             Order 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre>
</div>
<figcaption><a href="#figure-4" class="selfRef">Figure 4</a>:
<a href="#name-the-accecn-tcp-option" class="selfRef">The AccECN TCP Option</a>
            </figcaption></figure>
</div>
<p id="section-3.2.3-3"><a href="#accecn_Fig_TCPopt" class="xref">Figure 4</a> shows two option field orders;
          order 0 and order 1. They both consists of three 24-bit fields.
          Order 0 provides the 24 least significant bits of the r.e0b, r.ceb
          and r.e1b counters, respectively. Order 1 provides the same fields,
          but in the opposite order. On each packet, the Data Receiver can use
          whichever order is more efficient.<a href="#section-3.2.3-3" class="pilcrow">Â¶</a></p>
<p id="section-3.2.3-4">When a Data Receiver sends an AccECN Option, it MUST set the Kind
          field to TBD0 if using Order 0, or to TBD1 if using Order 1. These
          two new TCP Option Kinds are registered in <a href="#accecn_IANA_Considerations" class="xref">Section 7</a> and called respectively
          AccECN0 and AccECN1.<a href="#section-3.2.3-4" class="pilcrow">Â¶</a></p>
<p id="section-3.2.3-5">Note that there is no field to feed back Not-ECT bytes.
          Nonetheless an algorithm for the Data Sender to calculate the number
          of payload bytes received as Not-ECT is given in <a href="#accecn_Algo_Not-ECT" class="xref">Appendix A.4</a>.<a href="#section-3.2.3-5" class="pilcrow">Â¶</a></p>
<p id="section-3.2.3-6">Whenever a Data Receiver sends an AccECN Option, the rules in
          <a href="#accecn_option_usage" class="xref">Section 3.2.3.3</a> allow it to omit unchanged
          fields from the tail of the option, to help cope with option space
          limitations, as long as it preserves the order of the remaining
          fields and includes any field that has changed. The length field
          MUST indicate which fields are present as follows:<a href="#section-3.2.3-6" class="pilcrow">Â¶</a></p>
<span id="name-fields-included-in-accecn-t"></span><table class="center" id="table-5">
            <caption>
<a href="#table-5" class="selfRef">Table 5</a>:
<a href="#name-fields-included-in-accecn-t" class="selfRef">Fields included in AccECN TCP Options of each length and type</a>
            </caption>
<thead>
              <tr>
                <th class="text-left" rowspan="1" colspan="1">Length</th>
                <th class="text-left" rowspan="1" colspan="1">Type 0</th>
                <th class="text-left" rowspan="1" colspan="1">Type 1</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td class="text-left" rowspan="1" colspan="1">11</td>
                <td class="text-left" rowspan="1" colspan="1">EE0B, ECEB, EE1B</td>
                <td class="text-left" rowspan="1" colspan="1">EE1B, ECEB, EE0B</td>
              </tr>
              <tr>
                <td class="text-left" rowspan="1" colspan="1">8</td>
                <td class="text-left" rowspan="1" colspan="1">EE0B, ECEB</td>
                <td class="text-left" rowspan="1" colspan="1">EE1B, ECEB</td>
              </tr>
              <tr>
                <td class="text-left" rowspan="1" colspan="1">5</td>
                <td class="text-left" rowspan="1" colspan="1">EE0B</td>
                <td class="text-left" rowspan="1" colspan="1">EE1B</td>
              </tr>
              <tr>
                <td class="text-left" rowspan="1" colspan="1">2</td>
                <td class="text-left" rowspan="1" colspan="1">(empty)</td>
                <td class="text-left" rowspan="1" colspan="1">(empty)</td>
              </tr>
            </tbody>
          </table>
<p id="section-3.2.3-8">The empty option of Length=2 is provided to allow for a case
          where an AccECN Option has to be sent (e.g.Â on the SYN/ACK to
          test the path), but there is very limited space for the option.<a href="#section-3.2.3-8" class="pilcrow">Â¶</a></p>
<p id="section-3.2.3-9">All implementations of a Data Sender that read any AccECN Option
          MUST be able to read in AccECN Options of any of the above lengths.
          For forward compatibility, if the AccECN Option is of any other
          length, implementations MUST use those whole 3-octet fields that fit
          within the length and ignore the remainder of the option, treating
          it as padding.<a href="#section-3.2.3-9" class="pilcrow">Â¶</a></p>
<p id="section-3.2.3-10">The AccECN Option has to be optional to implement, because both
          sender and receiver have to be able to cope without the option
          anyway - in cases where it does not traverse a network path. It is
          RECOMMENDED to implement both sending and receiving of the AccECN
          Option. If sending of the AccECN Option is implemented, the
          fall-backs described in this document will need to be implemented as
          well (unless solely for a controlled environment where path
          traversal is not considered a problem). Even if a developer does not
          implement sending of the AccECN Option, it is RECOMMENDED that they
          still implement logic to receive and understand any AccECN Options
          sent by remote peers.<a href="#section-3.2.3-10" class="pilcrow">Â¶</a></p>
<p id="section-3.2.3-11">If a Data Receiver intends to send the AccECN Option at any time
          during the rest of the connection it is strongly recommended to also
          test path traversal of the AccECN Option as specified in <a href="#accecn_Mbox_Interference" class="xref">Section 3.2.3.2</a>.<a href="#section-3.2.3-11" class="pilcrow">Â¶</a></p>
<section id="section-3.2.3.1">
            <h5 id="name-encoding-and-decoding-feedba">
<a href="#section-3.2.3.1" class="section-number selfRef">3.2.3.1. </a><a href="#name-encoding-and-decoding-feedba" class="section-name selfRef">Encoding and Decoding Feedback in the AccECN Option Fields</a>
            </h5>
<p id="section-3.2.3.1-1">Whenever the Data Receiver includes any of the counter fields
            (ECEB, EE0B, EE1B) in an AccECN Option, it MUST encode the 24
            least significant bits of the current value of the associated
            counter into the field (respectively r.ceb, r.e0b, r.e1b).<a href="#section-3.2.3.1-1" class="pilcrow">Â¶</a></p>
<p id="section-3.2.3.1-2">Whenever the Data Sender receives ACK carrying an AccECN
            Option, it first checks whether the ACK has already been
            superseded by another ACK in which case it ignores the ECN
            feedback. If the ACK has not been superseded, the Data Sender
            normally decodes the fields in the AccECN Option as follows. For
            each field, it takes the least significant 24 bits of its
            associated local counter (s.ceb, s.e0b or s.e1b) and subtracts
            them from the counter in the associated field of the incoming
            AccECN Option (respectively ECEB, EE0B, EE1B), to work out the
            minimum positive increment it could apply to s.ceb, s.e0b or s.e1b
            (assuming the field in the option only wrapped at most once).<a href="#section-3.2.3.1-2" class="pilcrow">Â¶</a></p>
<p id="section-3.2.3.1-3"><a href="#accecn_Algo_Option_Coding" class="xref">Appendix A.1</a> gives an example
            algorithm for the Data Receiver to encode its byte counters into
            the AccECN Option, and for the Data Sender to decode the AccECN
            Option fields into its byte counters.<a href="#section-3.2.3.1-3" class="pilcrow">Â¶</a></p>
<p id="section-3.2.3.1-4">Note that, as specified in <a href="#accecn_feedback" class="xref">Section 3.2</a>,
            any data on the SYN (SYN=1, ACK=0) is not included in any of the
            byte counters held locally for each ECN marking nor in the AccECN
            Option on the wire.<a href="#section-3.2.3.1-4" class="pilcrow">Â¶</a></p>
</section>
<div id="accecn_Mbox_Interference">
<section id="section-3.2.3.2">
            <h5 id="name-path-traversal-of-the-accec">
<a href="#section-3.2.3.2" class="section-number selfRef">3.2.3.2. </a><a href="#name-path-traversal-of-the-accec" class="section-name selfRef">Path Traversal of the AccECN Option</a>
            </h5>
<p id="section-3.2.3.2-1"></p>
<div id="accecn_AccECN_Option_3WHS">
<section id="section-3.2.3.2.1">
              <h6 id="name-testing-the-accecn-option-d">
<a href="#section-3.2.3.2.1" class="section-number selfRef">3.2.3.2.1. </a><a href="#name-testing-the-accecn-option-d" class="section-name selfRef">Testing the AccECN Option during the Handshake</a>
              </h6>
<p id="section-3.2.3.2.1-1">The TCP client MUST NOT include the AccECN TCP Option on the
              SYN. If there is somehow an AccECN Option on a SYN, it MUST be
              ignored when forwarded or received. (A fall-back strategy for
              the loss of the SYN, possibly due to middlebox interference, is
              specified in <a href="#accecn_sec_SYN_rexmt" class="xref">Section 3.1.4</a>.)<a href="#section-3.2.3.2.1-1" class="pilcrow">Â¶</a></p>
<p id="section-3.2.3.2.1-2">A TCP server that confirms its support for AccECN (in
              response to an AccECN SYN from the client as described in <a href="#accecn_Negotiation" class="xref">Section 3.1</a>) SHOULD include an AccECN TCP
              Option on the SYN/ACK.<a href="#section-3.2.3.2.1-2" class="pilcrow">Â¶</a></p>
<p id="section-3.2.3.2.1-3">A TCP client that has successfully negotiated AccECN SHOULD
              include an AccECN Option in the first ACK at the end of the
              3WHS. However, this first ACK is not delivered reliably, so the
              TCP client SHOULD also include an AccECN Option on the first
              data segment it sends (if it ever sends one).<a href="#section-3.2.3.2.1-3" class="pilcrow">Â¶</a></p>
<p id="section-3.2.3.2.1-4">A host MAY omit the AccECN Option in any of the above three
              cases due to insufficient option space or if it has cached
              knowledge that the packet would be likely to be blocked on the
              path to the other host if it included an AccECN Option.<a href="#section-3.2.3.2.1-4" class="pilcrow">Â¶</a></p>
</section>
</div>
<div id="accecn_AccECN_Option_Loss">
<section id="section-3.2.3.2.2">
              <h6 id="name-testing-for-loss-of-packets">
<a href="#section-3.2.3.2.2" class="section-number selfRef">3.2.3.2.2. </a><a href="#name-testing-for-loss-of-packets" class="section-name selfRef">Testing for Loss of Packets Carrying the AccECN Option</a>
              </h6>
<p id="section-3.2.3.2.2-1">If
              after the normal TCP timeout the TCP server has not received an
              ACK to acknowledge its SYN/ACK, the SYN/ACK might just have been
              lost, e.g.Â due to congestion, or a middlebox might be
              blocking the AccECN Option. To expedite connection setup, the
              TCP server SHOULD retransmit the SYN/ACK repeating the same AE,
              CWR and ECE TCP flags as on the original SYN/ACK but with no
              AccECN Option. If this retransmission times out, to expedite
              connection setup, the TCP server SHOULD disable AccECN and ECN
              for this connection by retransmitting the SYN/ACK with
              AE=CWR=ECE=0 and no AccECN Option.<a href="#section-3.2.3.2.2-1" class="pilcrow">Â¶</a></p>
<p id="section-3.2.3.2.2-2">Implementers MAY use other fall-back strategies if they are
              found to be more effective (e.g.Â retrying the AccECN Option
              for a second time before fall-back - most appropriate during
              high levels of congestion). However, other fall-back strategies
              will need to follow all the rules in <a href="#accecn_implications_accecn_mode" class="xref">Section 3.1.5</a>, which concern
              behaviour when SYNs or SYN/ACKs negotiating different types of
              feedback have been sent within the same connection.<a href="#section-3.2.3.2.2-2" class="pilcrow">Â¶</a></p>
<p id="section-3.2.3.2.2-3">If the TCP client detects that the first data segment it sent
              with the AccECN Option was lost, it SHOULD fall back to no
              AccECN Option on the retransmission. Again, implementers MAY use
              other fall-back strategies such as attempting to retransmit a
              second segment with the AccECN Option before fall-back, and/or
              caching whether the AccECN Option is blocked for subsequent
              connections. <span>[<a href="#RFC9040" class="xref">RFC9040</a>]</span> further discusses caching
              of TCP parameters and status information.<a href="#section-3.2.3.2.2-3" class="pilcrow">Â¶</a></p>
<p id="section-3.2.3.2.2-4">If a host falls back to not sending the AccECN Option, it
              will continue to process any incoming AccECN Options as
              normal.<a href="#section-3.2.3.2.2-4" class="pilcrow">Â¶</a></p>
<p id="section-3.2.3.2.2-5">Either host MAY include the AccECN Option in a subsequent
              segment to retest whether the AccECN Option can traverse the
              path.<a href="#section-3.2.3.2.2-5" class="pilcrow">Â¶</a></p>
<p id="section-3.2.3.2.2-6">If the TCP server receives a second SYN with a request for
              AccECN support, it should resend the SYN/ACK, again confirming
              its support for AccECN, but this time without the AccECN Option.
              This approach rules out any interference by middleboxes that may
              drop packets with unknown options, even though it is more likely
              that the SYN/ACK would have been lost due to congestion. The TCP
              server MAY try to send another packet with the AccECN Option at
              a later point during the connection but should monitor if that
              packet got lost as well, in which case it SHOULD disable the
              sending of the AccECN Option for this half-connection.<a href="#section-3.2.3.2.2-6" class="pilcrow">Â¶</a></p>
<p id="section-3.2.3.2.2-7">Similarly, an AccECN end-point MAY separately memorize which
              data packets carried an AccECN Option and disable the sending of
              AccECN Options if the loss probability of those packets is
              significantly higher than that of all other data packets in the
              same connection.<a href="#section-3.2.3.2.2-7" class="pilcrow">Â¶</a></p>
</section>
</div>
<section id="section-3.2.3.2.3">
              <h6 id="name-testing-for-absence-of-the-">
<a href="#section-3.2.3.2.3" class="section-number selfRef">3.2.3.2.3. </a><a href="#name-testing-for-absence-of-the-" class="section-name selfRef">Testing for Absence of the AccECN Option</a>
              </h6>
<p id="section-3.2.3.2.3-1">If the TCP client has successfully negotiated AccECN but does
              not receive an AccECN Option on the SYN/ACK (e.g.Â because
              is has been stripped by a middlebox or not sent by the server),
              the client switches into a mode that assumes that the AccECN
              Option is not available for this half connection.<a href="#section-3.2.3.2.3-1" class="pilcrow">Â¶</a></p>
<p id="section-3.2.3.2.3-2">Similarly, if the TCP server has successfully negotiated
              AccECN but does not receive an AccECN Option on the first
              segment that acknowledges sequence space at least covering the
              ISN, it switches into a mode that assumes that the AccECN Option
              is not available for this half connection.<a href="#section-3.2.3.2.3-2" class="pilcrow">Â¶</a></p>
<p id="section-3.2.3.2.3-3">While a host is in this mode that assumes incoming AccECN
              Options are not available, it MUST adopt the conservative
              interpretation of the ACE field discussed in <a href="#accecn_ACE_Safety" class="xref">Section 3.2.2.5</a>. However, it cannot make any
              assumption about support of outgoing AccECN Options on the other
              half connection, so it SHOULD continue to send the AccECN Option
              itself (unless it has established that sending the AccECN Option
              is causing packets to be blocked as in <a href="#accecn_AccECN_Option_Loss" class="xref">Section 3.2.3.2.2</a>).<a href="#section-3.2.3.2.3-3" class="pilcrow">Â¶</a></p>
<p id="section-3.2.3.2.3-4">If a host is in the mode that assumes incoming AccECN Options
              are not available, but it receives an AccECN Option at any later
              point during the connection, this clearly indicates that the
              AccECN Option is not blocked on the respective path, and the
              AccECN endpoint MAY switch out of the mode that assumes the
              AccECN Option is not available for this half connection.<a href="#section-3.2.3.2.3-4" class="pilcrow">Â¶</a></p>
</section>
<div id="accecn_sec_zero_option">
<section id="section-3.2.3.2.4">
              <h6 id="name-test-for-zeroing-of-the-acc">
<a href="#section-3.2.3.2.4" class="section-number selfRef">3.2.3.2.4. </a><a href="#name-test-for-zeroing-of-the-acc" class="section-name selfRef">Test for Zeroing of the AccECN Option</a>
              </h6>
<p id="section-3.2.3.2.4-1">For a related test for invalid initialization of the ACE
              field, see <a href="#accecn_sec_ACE_init_invalid" class="xref">Section 3.2.2.4</a><a href="#section-3.2.3.2.4-1" class="pilcrow">Â¶</a></p>
<p id="section-3.2.3.2.4-2"><a href="#accecn_init_counters" class="xref">Section 3.2.1</a> required the Data
              Receiver to initialize the r.e0b and r.e1b counters to a
              non-zero value. Therefore, in either direction the initial value
              of the EE0B field or EE1B field in the AccECN Option (if one
              exists) ought to be non-zero. If AccECN has been
              negotiated:<a href="#section-3.2.3.2.4-2" class="pilcrow">Â¶</a></p>
<ul class="normal">
<li class="normal" id="section-3.2.3.2.4-3.1">the TCP server MAY check that the initial value of the
                  EE0B field or the EE1B field is non-zero in the first
                  segment that acknowledges sequence space that at least
                  covers the ISN plus 1. If it runs a test and either initial
                  value is zero, the server will switch into a mode that
                  ignores the AccECN Option for this half connection.<a href="#section-3.2.3.2.4-3.1" class="pilcrow">Â¶</a>
</li>
                <li class="normal" id="section-3.2.3.2.4-3.2">the TCP client MAY check the initial value of the EE0B
                  field or the EE1B field is non-zero on the SYN/ACK. If it
                  runs a test and either initial value is zero, the client
                  will switch into a mode that ignores the AccECN Option for
                  this half connection.<a href="#section-3.2.3.2.4-3.2" class="pilcrow">Â¶</a>
</li>
              </ul>
<p id="section-3.2.3.2.4-4">While a host is in the mode that ignores the AccECN Option it
              MUST adopt the conservative interpretation of the ACE field
              discussed in <a href="#accecn_ACE_Safety" class="xref">Section 3.2.2.5</a>.<a href="#section-3.2.3.2.4-4" class="pilcrow">Â¶</a></p>
<p id="section-3.2.3.2.4-5">Note that the Data Sender MUST NOT test whether the arriving
              byte counters in the initial AccECN Option have been initialized
              to specific valid values - the above checks solely test whether
              these fields have been incorrectly zeroed. This allows hosts to
              use different initial values as an additional signalling channel
              in future. Also note that the initial value of either field
              might be greater than its expected initial value, because the
              counters might already have been incremented. Nonetheless, the
              initial values of the counters have been chosen so that they
              cannot wrap to zero on these initial segments.<a href="#section-3.2.3.2.4-5" class="pilcrow">Â¶</a></p>
</section>
</div>
<section id="section-3.2.3.2.5">
              <h6 id="name-consistency-between-accecn-">
<a href="#section-3.2.3.2.5" class="section-number selfRef">3.2.3.2.5. </a><a href="#name-consistency-between-accecn-" class="section-name selfRef">Consistency between AccECN Feedback Fields</a>
              </h6>
<p id="section-3.2.3.2.5-1">When the AccECN Option is available it ought to provide more
              unambiguous feedback. However, it supplements but does not
              replace the ACE field. An endpoint using AccECN feedback MUST
              always reconcile the information provided in the ACE field with
              that in any AccECN Option, so that the state of the ACE-related
              packet counter can be relied on if future feedback does not
              carry the AccECN Option.<a href="#section-3.2.3.2.5-1" class="pilcrow">Â¶</a></p>
<p id="section-3.2.3.2.5-2">If the AccECN option is present, the s.cep counter might
              increase more than expected from the increase of the s.ceb
              counter (e.g.Â due to a CE-marked control packet). The
              sender's response to such a situation is out of scope, and needs
              to be dealt with in a specification that uses ECN-capable
              control packets. Theoretically, this situation could also occur
              if a middlebox mangled the AccECN Option but not the ACE field.
              However, the Data Sender has to assume that the integrity of the
              AccECN Option is sound, based on the above test of the
              well-known initial values and optionally other integrity tests
              (<a href="#accecn_Integrity" class="xref">Section 5.3</a>).<a href="#section-3.2.3.2.5-2" class="pilcrow">Â¶</a></p>
<p id="section-3.2.3.2.5-3">If either end-point detects that the s.ceb counter has
              increased but the s.cep has not (and by testing ACK coverage it
              is certain how much the ACE field has wrapped), and if there is
              no explanation other than an invalid protocol transition due to
              some form of feedback mangling, the Data Sender MUST disable
              sending ECN-capable packets for the remainder of the
              half-connection by setting the IP/ECN field in all subsequent
              packets to Not-ECT.<a href="#section-3.2.3.2.5-3" class="pilcrow">Â¶</a></p>
</section>
</section>
</div>
<div id="accecn_option_usage">
<section id="section-3.2.3.3">
            <h5 id="name-usage-of-the-accecn-tcp-opt">
<a href="#section-3.2.3.3" class="section-number selfRef">3.2.3.3. </a><a href="#name-usage-of-the-accecn-tcp-opt" class="section-name selfRef">Usage of the AccECN TCP Option</a>
            </h5>
<p id="section-3.2.3.3-1">If a Data Receiver in AccECN mode intends to use the AccECN TCP
            Option to provide feedback, the rules below determine when it
            includes an AccECN TCP Option, and which fields to include, given
            other options might be competing for limited option space:<a href="#section-3.2.3.3-1" class="pilcrow">Â¶</a></p>
<span class="break"></span><dl class="dlParallel" id="section-3.2.3.3-2">
              <dt id="section-3.2.3.3-2.1">Importance of Congestion Control:</dt>
              <dd style="margin-left: 1.5em" id="section-3.2.3.3-2.2">
                <p id="section-3.2.3.3-2.2.1">AccECN is for
                congestion control, which SHOULD generally be considered
                important relative to other TCP options.<a href="#section-3.2.3.3-2.2.1" class="pilcrow">Â¶</a></p>
<p id="section-3.2.3.3-2.2.2">If SACK has been negotiated, and the smallest
                recommended AccECN Option would leave insufficient space for
                two SACK blocks on a particular ACK, the Data Receiver MUST
                give precedence to the SACK option (total 18 octets), because
                loss feedback is more critical.<a href="#section-3.2.3.3-2.2.2" class="pilcrow">Â¶</a></p>
</dd>
              <dd class="break"></dd>
<dt id="section-3.2.3.3-2.3">Recommended Simple Scheme:</dt>
              <dd style="margin-left: 1.5em" id="section-3.2.3.3-2.4">
                <p id="section-3.2.3.3-2.4.1">The Data Receiver
                SHOULD include an AccECN TCP Option on every scheduled ACK if
                any byte counter has incremented since the last ACK. Whenever
                possible, it SHOULD include a field for every byte counter
                that has changed at some time during the connection (see
                examples later).<a href="#section-3.2.3.3-2.4.1" class="pilcrow">Â¶</a></p>
<p id="section-3.2.3.3-2.4.2">A scheduled ACK means
                an ACK that the Data Receiver would send by its regular
                delayed ACK rules. Recall that <a href="#accecn_Terminology" class="xref">Section 1.3</a> defines an 'ACK' as either with
                data payload or without. But the above rule is worded so that,
                in the common case when most of the data is from a server to a
                client, the server only includes an AccECN TCP Option while it
                is acknowledging data from the client.<a href="#section-3.2.3.3-2.4.2" class="pilcrow">Â¶</a></p>
</dd>
            <dd class="break"></dd>
</dl>
<p id="section-3.2.3.3-3">When available TCP option space is limited on particular
            packets, the recommended scheme will need to include compromises.
            To guide the implementer the rules below are ranked in order of
            importance, but the final decision has to be
            implementation-dependent, because tradeoffs will alter as new TCP
            options are defined and new use-cases arise.<a href="#section-3.2.3.3-3" class="pilcrow">Â¶</a></p>
<span class="break"></span><dl class="dlParallel" id="section-3.2.3.3-4">
              <dt id="section-3.2.3.3-4.1">Necessary Option Length:</dt>
              <dd style="margin-left: 1.5em" id="section-3.2.3.3-4.2">The Data Receiver MUST
                only include an AccECN TCP Option on a packet if it includes
                all the counter(s) that have incremented since the previous
                AccECN Option. It MUST only truncate unchanged fields from the
                right-hand tail of the option to preserve the order of the
                remaining fields (see <a href="#accecn_option" class="xref">Section 3.2.3</a>);<a href="#section-3.2.3.3-4.2" class="pilcrow">Â¶</a>
</dd>
              <dd class="break"></dd>
<dt id="section-3.2.3.3-4.3">Change-Triggered AccECN TCP Options:</dt>
              <dd style="margin-left: 1.5em" id="section-3.2.3.3-4.4">
                <p id="section-3.2.3.3-4.4.1">If an
                arriving packet increments a different byte counter to that
                incremented by the previous packet, the Data Receiver SHOULD
                feed it back in an AccECN Option on the next scheduled ACK.<a href="#section-3.2.3.3-4.4.1" class="pilcrow">Â¶</a></p>
<p id="section-3.2.3.3-4.4.2">For the avoidance of doubt, this rule
                does not concern the arrival of control packets with no
                payload, because they cannot alter any byte counters.<a href="#section-3.2.3.3-4.4.2" class="pilcrow">Â¶</a></p>
</dd>
              <dd class="break"></dd>
<dt id="section-3.2.3.3-4.5">Continual Repetition:</dt>
              <dd style="margin-left: 1.5em" id="section-3.2.3.3-4.6">
                <p id="section-3.2.3.3-4.6.1">Otherwise, if arriving
                packets continue to increment the same byte counter:<a href="#section-3.2.3.3-4.6.1" class="pilcrow">Â¶</a></p>
<ul class="normal">
<li class="normal" id="section-3.2.3.3-4.6.2.1">the Data Receiver SHOULD include a counter that has
                    continued to increment on the next scheduled ACK following
                    a change-triggered AccECN TCP Option;<a href="#section-3.2.3.3-4.6.2.1" class="pilcrow">Â¶</a>
</li>
                  <li class="normal" id="section-3.2.3.3-4.6.2.2">while the same counter continues to increment, it
                    SHOULD include the counter every n ACKs as consistently as
                    possible, where n can be chosen by the implementer;<a href="#section-3.2.3.3-4.6.2.2" class="pilcrow">Â¶</a>
</li>
                  <li class="normal" id="section-3.2.3.3-4.6.2.3">It SHOULD always include an AccECN Option if the r.ceb
                    counter is incrementing and it MAY include an AccECN
                    Option if r.ec0b or r.ec1b is incrementing<a href="#section-3.2.3.3-4.6.2.3" class="pilcrow">Â¶</a>
</li>
                  <li class="normal" id="section-3.2.3.3-4.6.2.4">It SHOULD, include each counter at least once for every
                    2^22 bytes incremented to prevent overflow during
                    continual repetition.<a href="#section-3.2.3.3-4.6.2.4" class="pilcrow">Â¶</a>
</li>
                </ul>
</dd>
            <dd class="break"></dd>
</dl>
<p id="section-3.2.3.3-5">The above rules complement those in <a href="#accecn_ACE_Safety" class="xref">Section 3.2.2.5</a>, which determine when to generate an
            ACK irrespective of whether an AccECN TCP Option is to be
            included.<a href="#section-3.2.3.3-5" class="pilcrow">Â¶</a></p>
<p id="section-3.2.3.3-6">The recommended scheme is intended as a simple way to ensure
            that all the relevant byte counters will be carried on any ACK
            that reaches the Data Sender, no matter how many pure ACKs are
            filtered or coalesced along the network path, and without
            consuming the space available for payload data with counter
            field(s) that have never changed.<a href="#section-3.2.3.3-6" class="pilcrow">Â¶</a></p>
<p id="section-3.2.3.3-7">As an example of the recommended scheme, if ECT(0) is the only
            codepoint that has ever arrived in the IP-ECN field, the Data
            Receiver will feed back an AccECN0 TCP Option with only the EE0B
            field on every packet. However, as soon as even one CE-marked
            packet arrives, on every packet that acknowledges new data it will
            start to include an option with two fields, EE0B and ECEB. As a
            second example, if the first packet to arrive happens to be
            CE-marked, the Data Receiver will have to arbitrarily choose
            whether to precede the ECEB field with an EE0B field or an EE1B
            field. If it chooses, say, EEB0 but it turns out never to receive
            ECT(0), it can start sending EE1B and ECEB instead - it does not
            have to include the EE0B field if the r.e0b counter has never
            changed during the connection.<a href="#section-3.2.3.3-7" class="pilcrow">Â¶</a></p>
<p id="section-3.2.3.3-8">With the recommended scheme, if the data sending direction
            switches during a connection, there can be cases where the AccECN
            TCP Option that is meant to feed back the counter values at the
            end of a volley in one direction never reaches the other peer, due
            to packet loss. ACE feedback ought to be sufficient to fill this
            gap, given accurate feedback becomes moot after data transmission
            has paused.<a href="#section-3.2.3.3-8" class="pilcrow">Â¶</a></p>
<p id="section-3.2.3.3-9"><a href="#accecn_Algo_ACE_Bytes" class="xref">Appendix A.3</a> gives an example
            algorithm to estimate the number of marked bytes from the ACE
            field alone, if the AccECN Option is not available.<a href="#section-3.2.3.3-9" class="pilcrow">Â¶</a></p>
<p id="section-3.2.3.3-10">If a host has determined that segments with the AccECN Option
            always seem to be discarded somewhere along the path, it is no
            longer obliged to follow any of the rules in this section.<a href="#section-3.2.3.3-10" class="pilcrow">Â¶</a></p>
</section>
</div>
</section>
</div>
</section>
</div>
<div id="accecn_Mbox_Operation">
<section id="section-3.3">
        <h3 id="name-accecn-compliance-requireme">
<a href="#section-3.3" class="section-number selfRef">3.3. </a><a href="#name-accecn-compliance-requireme" class="section-name selfRef">AccECN Compliance Requirements for TCP Proxies, Offload Engines and other Middleboxes</a>
        </h3>
<p id="section-3.3-1"></p>
<section id="section-3.3.1">
          <h4 id="name-requirements-for-tcp-proxie">
<a href="#section-3.3.1" class="section-number selfRef">3.3.1. </a><a href="#name-requirements-for-tcp-proxie" class="section-name selfRef">Requirements for TCP Proxies</a>
          </h4>
<p id="section-3.3.1-1">A large class of middleboxes split TCP connections. Such a
          middlebox would be compliant with the AccECN protocol if the TCP
          implementation on each side complied with the present AccECN
          specification and each side negotiated AccECN independently of the
          other side.<a href="#section-3.3.1-1" class="pilcrow">Â¶</a></p>
</section>
<div id="accecn_middlebox_transparent_normalizers">
<section id="section-3.3.2">
          <h4 id="name-requirements-for-transparen">
<a href="#section-3.3.2" class="section-number selfRef">3.3.2. </a><a href="#name-requirements-for-transparen" class="section-name selfRef">Requirements for Transparent Middleboxes and TCP Normalizers</a>
          </h4>
<p id="section-3.3.2-1">Another large class of middleboxes intervenes to some degree at
          the transport layer, but attempts to be transparent (invisible) to
          the end-to-end connection. A subset of this class of middleboxes
          attempts to `normalize' the TCP wire protocol by checking that all
          values in header fields comply with a rather narrow interpretation
          of the TCP specifications that is also not always up to date.<a href="#section-3.3.2-1" class="pilcrow">Â¶</a></p>
<p id="section-3.3.2-2">A middlebox that is not normalizing the TCP protocol and does not
          itself act as a back-to-back pair of TCP endpoints (i.e.Â a
          middlebox that intends to be transparent or invisible at the
          transport layer) ought to forward the AccECN TCP Option unaltered,
          whether or not the length value matches one of those specified in
          <a href="#accecn_option" class="xref">Section 3.2.3</a>, and whether or not the initial
          values of the byte-counter fields match those in <a href="#accecn_init_counters" class="xref">Section 3.2.1</a>. This is because blocking apparently
          invalid values prevents the standardized set of values being
          extended in future (given outdated normalizers would block updated
          hosts from using the extended AccECN standard).<a href="#section-3.3.2-2" class="pilcrow">Â¶</a></p>
<p id="section-3.3.2-3">A TCP normalizer is likely to block or alter an AccECN TCP Option
          if the length value or the initial values of its byte-counter fields
          do not match one of those specified in <a href="#accecn_option" class="xref">Section 3.2.3</a> or <a href="#accecn_init_counters" class="xref">Section 3.2.1</a>.
          However, to comply with the present AccECN specification, a
          middlebox MUST NOT change the ACE field; or those fields of the
          AccECN Option that are currently specified in <a href="#accecn_option" class="xref">Section 3.2.3</a>; or any AccECN field covered by integrity
          protection (e.g.Â <span>[<a href="#RFC5925" class="xref">RFC5925</a>]</span>).<a href="#section-3.3.2-3" class="pilcrow">Â¶</a></p>
</section>
</div>
<section id="section-3.3.3">
          <h4 id="name-requirements-for-tcp-ack-fi">
<a href="#section-3.3.3" class="section-number selfRef">3.3.3. </a><a href="#name-requirements-for-tcp-ack-fi" class="section-name selfRef">Requirements for TCP ACK Filtering</a>
          </h4>
<p id="section-3.3.3-1">A node that implements ACK filtering (aka.Â thinning or
          coalescing) SHOULD determine if an ACK is part of a connection using
          AccECN and SHOULD then preserve the correct operation of AccECN
          feedback. The following notes might help with each part of this
          requirement:<a href="#section-3.3.3-1" class="pilcrow">Â¶</a></p>
<ul class="normal">
<li class="normal" id="section-3.3.3-2.1">To determine whether a pure TCP ACK is part of an AccECN
              connection without resorting to connection tracking and per-flow
              state, a useful heuristic would be to check for a non-zero ECN
              field at the IP layer (because the ECN++ experiment only allows
              TCP pure ACKs to be ECN-capable if AccECN has been negotiated
              <span>[<a href="#I-D.ietf-tcpm-generalized-ecn" class="xref">I-D.ietf-tcpm-generalized-ecn</a>]</span>). This heuristic
              is simple and stateless. However, it might omit some AccECN
              ACKs, because it is only recommended but not obligatory to use
              ECN++ with AccECN - only deployment experience will tell. Also,
              TCP ACKs might be ECN-capable owing to some scheme other than
              AccECN, e.g.Â <span>[<a href="#RFC5690" class="xref">RFC5690</a>]</span> or some future
              standards action. Again, only deployment experience will
              tell.<a href="#section-3.3.3-2.1" class="pilcrow">Â¶</a>
</li>
            <li class="normal" id="section-3.3.3-2.2">The main concern with preserving correct AccECN operation
              involves leaving enough ACKs for the data sender to work out
              whether the 3-bit ACE field has wrapped. ACE field wrap is of
              less concern if packets also carry the AccECN TCP Option.<a href="#section-3.3.3-2.2" class="pilcrow">Â¶</a>
</li>
          </ul>
<p id="section-3.3.3-3">Note that the present specification of AccECN in TCP does not
          presume to rely on any of the above ACK filtering behaviour in the
          network (hence the use of 'SHOULD' rather than 'MUST' above),
          because it has to be robust against pre-existing network nodes that
          do not distinguish AccECN ACKs, and robust against ACK loss during
          overload more generally.<a href="#section-3.3.3-3" class="pilcrow">Â¶</a></p>
<p id="section-3.3.3-4">Section 5.2.1 of BCPÂ 69 <span>[<a href="#RFC3449" class="xref">RFC3449</a>]</span> gives best
          current practice on pure TCP ACK filtering. It gives no advice on
          ACKs carrying ECN feedback, other than that filtering ought to
          preserve the correct operation of ECN feedback, because at the time
          it said that "SACK and ECN remain areas of ongoing research". This
          section updates that best current practice for a TCP connection that
          supports AccECN feedback.<a href="#section-3.3.3-4" class="pilcrow">Â¶</a></p>
</section>
<section id="section-3.3.4">
          <h4 id="name-requirements-for-tcp-segmen">
<a href="#section-3.3.4" class="section-number selfRef">3.3.4. </a><a href="#name-requirements-for-tcp-segmen" class="section-name selfRef">Requirements for TCP Segmentation Offload</a>
          </h4>
<p id="section-3.3.4-1">Hardware to offload certain TCP processing represents another
          large class of middleboxes (even though it is often a function of a
          host's network interface and rarely in its own 'box').<a href="#section-3.3.4-1" class="pilcrow">Â¶</a></p>
<p id="section-3.3.4-2">The ACE field changes with every received CE marking, so today's
          receive offloading could lead to many interrupts in high congestion
          situations. Although that would be useful (because congestion
          information is received sooner), it could also significantly
          increase processor load, particularly in scenarios such as DCTCP or
          L4S where the marking rate is generally higher.<a href="#section-3.3.4-2" class="pilcrow">Â¶</a></p>
<p id="section-3.3.4-3">Current offload hardware ejects a segment from the coalescing
          process whenever the TCP ECN flags change. Thus Classic ECN causes
          offload to be inefficient. In data centres it has been fortunate for
          this offload hardware that DCTCP-style feedback changes less often
          when there are long sequences of CE marks, which is more common with
          a step marking threshold (but less likely the more short flows are
          in the mix). The ACE counter approach has been designed so that
          coalescing can continue over arbitrary patterns of marking and only
          needs to stop when the counter wraps. Nonetheless, until the
          particular offload hardware in use implements this more efficient
          approach, it is likely to be more efficient for AccECN connections
          to implement this counter-style logic using software segmentation
          offload.<a href="#section-3.3.4-3" class="pilcrow">Â¶</a></p>
<p id="section-3.3.4-4">ECN encodes a varying signal in the ACK stream, so it is
          inevitable that offload hardware will ultimately need to handle any
          form of ECN feedback exceptionally. The ACE field has been designed
          as a counter so that it is straightforward for offload hardware to
          pass on the highest counter, and to push a segment from its cache
          before the counter wraps. The purpose of working towards
          standardized TCP ECN feedback is to reduce the risk for hardware
          developers, who would otherwise have to guess which scheme is likely
          to become dominant.<a href="#section-3.3.4-4" class="pilcrow">Â¶</a></p>
<p id="section-3.3.4-5">The above process has been designed to enable a continuing
          incremental deployment path - to more highly dynamic congestion
          control. Once offload hardware supports AccECN, it will be able to
          coalesce efficiently for any sequence of marks, instead of relying
          for efficiency on the long marking sequences from step marking. In
          the next stage, marking can evolve from a step to a ramp function.
          That in turn will allow host congestion control algorithms to
          respond faster to dynamics, while being backwards compatible with
          existing host algorithms.<a href="#section-3.3.4-5" class="pilcrow">Â¶</a></p>
</section>
</section>
</div>
</section>
</div>
<div id="accecn_3168_updates">
<section id="section-4">
      <h2 id="name-updates-to-rfc-3168">
<a href="#section-4" class="section-number selfRef">4. </a><a href="#name-updates-to-rfc-3168" class="section-name selfRef">Updates to RFC 3168</a>
      </h2>
<p id="section-4-1">Normative statements in the following sections of RFC3168 are updated
      by the present AccECN specification:<a href="#section-4-1" class="pilcrow">Â¶</a></p>
<ul class="normal">
<li class="normal" id="section-4-2.1">The whole of "6.1.1 TCP Initialization" of <span>[<a href="#RFC3168" class="xref">RFC3168</a>]</span> is updated by <a href="#accecn_Negotiation" class="xref">Section 3.1</a>
          of the present specification.<a href="#section-4-2.1" class="pilcrow">Â¶</a>
</li>
        <li class="normal" id="section-4-2.2">
          <p id="section-4-2.2.1">In "6.1.2. The TCP Sender" of <span>[<a href="#RFC3168" class="xref">RFC3168</a>]</span>, all
          mentions of a congestion response to an ECN-Echo (ECE) ACK packet
          are updated by <a href="#accecn_feedback" class="xref">Section 3.2</a> of the present
          specification to mean an increment to the sender's count of
          CE-marked packets, s.cep. And the requirements to set the CWR flag
          no longer apply, as specified in <a href="#accecn_implications_accecn_mode" class="xref">Section 3.1.5</a> of the present
          specification. Otherwise, the remaining requirements in "6.1.2. The
          TCP Sender" still stand.<a href="#section-4-2.2.1" class="pilcrow">Â¶</a></p>
<p id="section-4-2.2.2">It will be noted
          that RFC 8311 already updates, or potentially updates, a number of
          the requirements in "6.1.2. The TCP Sender". Section 6.1.2 of RFC
          3168 extended standard TCP congestion control <span>[<a href="#RFC5681" class="xref">RFC5681</a>]</span> to cover ECN marking as well as packet drop.
          Whereas, RFC 8311 enables experimentation with alternative responses
          to ECN marking, if specified for instance by an experimental RFC on
          the IETF document stream. RFC 8311 also strengthened the statement
          that "ECT(0) SHOULD be used" to a "MUST" (see <span>[<a href="#RFC8311" class="xref">RFC8311</a>]</span> for the details).<a href="#section-4-2.2.2" class="pilcrow">Â¶</a></p>
</li>
        <li class="normal" id="section-4-2.3">The whole of "6.1.3. The TCP Receiver" of <span>[<a href="#RFC3168" class="xref">RFC3168</a>]</span> is updated by <a href="#accecn_feedback" class="xref">Section 3.2</a> of
          the present specification, with the exception of the last paragraph
          (about congestion response to drop and ECN in the same round trip),
          which still stands. Incidentally, this last paragraph is in the
          wrong section, because it relates to TCP sender behaviour.<a href="#section-4-2.3" class="pilcrow">Â¶</a>
</li>
        <li class="normal" id="section-4-2.4">
          <p id="section-4-2.4.1">The following text within "6.1.5. Retransmitted TCP packets":<a href="#section-4-2.4.1" class="pilcrow">Â¶</a></p>
<ul class="normal ulEmpty">
<li class="normal ulEmpty" id="section-4-2.4.2.1">"the TCP data receiver SHOULD ignore the ECN field on
              arriving data packets that are outside of the receiver's current
              window."<a href="#section-4-2.4.2.1" class="pilcrow">Â¶</a>
</li>
          </ul>
<p id="section-4-2.4.3"> is updated by more stringent acceptability tests for any
          packet (not just data packets) in the present specification.
          Specifically, in the normative specification of AccECN (<a href="#accecn_Spec" class="xref">Section 3</a>) only 'Acceptable' packets contribute to the
          ECN counters at the AccECN receiver and <a href="#accecn_Terminology" class="xref">Section 1.3</a> defines an Acceptable packet as one
          that passes the acceptability tests in both <span>[<a href="#RFC0793" class="xref">RFC0793</a>]</span>
          and <span>[<a href="#RFC5961" class="xref">RFC5961</a>]</span>.<a href="#section-4-2.4.3" class="pilcrow">Â¶</a></p>
</li>
        <li class="normal" id="section-4-2.5">Sections 5.2, 6.1.1, 6.1.4, 6.1.5 and 6.1.6 of <span>[<a href="#RFC3168" class="xref">RFC3168</a>]</span> prohibit use of ECN on TCP control packets and
          retransmissions. The present specification does not update that
          aspect of RFC 3168, but it does say what feedback an AccECN Data
          Receiver should provide if it receives an ECN-capable control packet
          or retransmission. This ensures AccECN is forward compatible with
          any future scheme that allows ECN on these packets, as provided for
          in section 4.3 of <span>[<a href="#RFC8311" class="xref">RFC8311</a>]</span> and as proposed in <span>[<a href="#I-D.ietf-tcpm-generalized-ecn" class="xref">I-D.ietf-tcpm-generalized-ecn</a>]</span>.<a href="#section-4-2.5" class="pilcrow">Â¶</a>
</li>
      </ul>
</section>
</div>
<div id="accecn_Interact_Variants">
<section id="section-5">
      <h2 id="name-interaction-with-tcp-varian">
<a href="#section-5" class="section-number selfRef">5. </a><a href="#name-interaction-with-tcp-varian" class="section-name selfRef">Interaction with TCP Variants</a>
      </h2>
<p id="section-5-1">This section is informative, not normative.<a href="#section-5-1" class="pilcrow">Â¶</a></p>
<div id="accecn_Interaction_SYN_Cookies">
<section id="section-5.1">
        <h3 id="name-compatibility-with-syn-cook">
<a href="#section-5.1" class="section-number selfRef">5.1. </a><a href="#name-compatibility-with-syn-cook" class="section-name selfRef">Compatibility with SYN Cookies</a>
        </h3>
<p id="section-5.1-1">A TCP server can use SYN Cookies (see Appendix A of <span>[<a href="#RFC4987" class="xref">RFC4987</a>]</span>) to protect itself from SYN flooding attacks. It
        places minimal commonly used connection state in the SYN/ACK, and
        deliberately does not hold any state while waiting for the subsequent
        ACK (e.g.Â it closes the thread). Therefore it cannot record the
        fact that it entered AccECN mode for both half-connections. Indeed, it
        cannot even remember whether it negotiated the use of classic ECN
        <span>[<a href="#RFC3168" class="xref">RFC3168</a>]</span>.<a href="#section-5.1-1" class="pilcrow">Â¶</a></p>
<p id="section-5.1-2">Nonetheless, such a server can determine that it negotiated AccECN
        as follows. If a TCP server using SYN Cookies supports AccECN and if
        it receives a pure ACK that acknowledges an ISN that is a valid SYN
        cookie, and if the ACK contains an ACE field with the value 0b010 to
        0b111 (decimal 2 to 7), it can assume that:<a href="#section-5.1-2" class="pilcrow">Â¶</a></p>
<ul class="normal">
<li class="normal" id="section-5.1-3.1">the TCP client must have requested AccECN support on the
            SYN<a href="#section-5.1-3.1" class="pilcrow">Â¶</a>
</li>
          <li class="normal" id="section-5.1-3.2">it (the server) must have confirmed that it supported
            AccECN<a href="#section-5.1-3.2" class="pilcrow">Â¶</a>
</li>
        </ul>
<p id="section-5.1-4">Therefore the server can switch itself into AccECN mode, and
        continue as if it had never forgotten that it switched itself into
        AccECN mode earlier.<a href="#section-5.1-4" class="pilcrow">Â¶</a></p>
<p id="section-5.1-5">If the pure ACK that acknowledges a SYN cookie contains an ACE
        field with the value 0b000 or 0b001, these values indicate that the
        client did not request support for AccECN and therefore the server
        does not enter AccECN mode for this connection. Further, 0b001 on the
        ACK implies that the server sent an ECN-capable SYN/ACK, which was
        marked CE in the network, and the non-AccECN client fed this back by
        setting ECE on the ACK of the SYN/ACK.<a href="#section-5.1-5" class="pilcrow">Â¶</a></p>
</section>
</div>
<div id="accecn_Interaction_Other">
<section id="section-5.2">
        <h3 id="name-compatibility-with-tcp-expe">
<a href="#section-5.2" class="section-number selfRef">5.2. </a><a href="#name-compatibility-with-tcp-expe" class="section-name selfRef">Compatibility with TCP Experiments and Common TCP Options</a>
        </h3>
<p id="section-5.2-1">AccECN is compatible (at least on paper) with the most commonly
        used TCP options: MSS, time-stamp, window scaling, SACK and TCP-AO. It
        is also compatible with the recent promising experimental TCP options
        TCP Fast Open (TFO <span>[<a href="#RFC7413" class="xref">RFC7413</a>]</span>) and Multipath TCP (MPTCP
        <span>[<a href="#RFC6824" class="xref">RFC6824</a>]</span>). AccECN is friendly to all these protocols,
        because space for TCP options is particularly scarce on the SYN, where
        AccECN consumes zero additional header space.<a href="#section-5.2-1" class="pilcrow">Â¶</a></p>
<p id="section-5.2-2">When option space is under pressure from other options, <a href="#accecn_option_usage" class="xref">Section 3.2.3.3</a> provides guidance on how important it
        is to send an AccECN Option relative to other options, and which
        fields are more important to include.<a href="#section-5.2-2" class="pilcrow">Â¶</a></p>
<p id="section-5.2-3">Implementers of TFO need to take careful note of the recommendation
        in <a href="#accecn_ACE_3rdACK" class="xref">Section 3.2.2.1</a>. That section recommends that,
        if the client has successfully negotiated AccECN, when acknowledging
        the SYN/ACK, even if it has data to send, it sends a pure ACK
        immediately before the data. Then it can reflect the IP-ECN field of
        the SYN/ACK on this pure ACK, which allows the server to detect ECN
        mangling. Note that, as specified in <a href="#accecn_feedback" class="xref">Section 3.2</a>,
        any data on the SYN (SYN=1, ACK=0) is not included in any of the byte
        counters held locally for each ECN marking, nor in the AccECN Option
        on the wire.<a href="#section-5.2-3" class="pilcrow">Â¶</a></p>
</section>
</div>
<div id="accecn_Integrity">
<section id="section-5.3">
        <h3 id="name-compatibility-with-feedback">
<a href="#section-5.3" class="section-number selfRef">5.3. </a><a href="#name-compatibility-with-feedback" class="section-name selfRef">Compatibility with Feedback Integrity Mechanisms</a>
        </h3>
<p id="section-5.3-1">Three alternative mechanisms are available to assure the integrity
        of ECN and/or loss signals. AccECN is compatible with any of these
        approaches:<a href="#section-5.3-1" class="pilcrow">Â¶</a></p>
<ul class="normal">
<li class="normal" id="section-5.3-2.1">The Data Sender can test the integrity of the receiver's ECN
            (or loss) feedback by occasionally setting the IP-ECN field to a
            value normally only set by the network (and/or deliberately
            leaving a sequence number gap). Then it can test whether the Data
            Receiver's feedback faithfully reports what it expects (similar to
            para 2 of Section 20.2 of <span>[<a href="#RFC3168" class="xref">RFC3168</a>]</span>). Unlike the
            ECN Nonce <span>[<a href="#RFC3540" class="xref">RFC3540</a>]</span>, this approach does not waste
            the ECT(1) codepoint in the IP header, it does not require
            standardization and it does not rely on misbehaving receivers
            volunteering to reveal feedback information that allows them to be
            detected. However, setting the CE mark by the sender might conceal
            actual congestion feedback from the network and should therefore
            only be done sparingly.<a href="#section-5.3-2.1" class="pilcrow">Â¶</a>
</li>
          <li class="normal" id="section-5.3-2.2">
            <p id="section-5.3-2.2.1">Networks generate congestion signals when they are becoming
            congested, so networks are more likely than Data Senders to be
            concerned about the integrity of the receiver's feedback of these
            signals. A network can enforce a congestion response to its ECN
            markings (or packet losses) using congestion exposure (ConEx)
            audit <span>[<a href="#RFC7713" class="xref">RFC7713</a>]</span>. Whether the receiver or a
            downstream network is suppressing congestion feedback or the
            sender is unresponsive to the feedback, or both, ConEx audit can
            neutralize any advantage that any of these three parties would
            otherwise gain.<a href="#section-5.3-2.2.1" class="pilcrow">Â¶</a></p>
<p id="section-5.3-2.2.2">ConEx is an experimental
            change to the Data Sender that would be most useful when combined
            with AccECN. Without AccECN, the ConEx behaviour of a Data Sender
            would have to be more conservative than would be necessary if it
            had the accurate feedback of AccECN.<a href="#section-5.3-2.2.2" class="pilcrow">Â¶</a></p>
</li>
          <li class="normal" id="section-5.3-2.3">The standards track TCP authentication option (TCP-AO <span>[<a href="#RFC5925" class="xref">RFC5925</a>]</span>) can be used to detect any tampering with
            AccECN feedback between the Data Receiver and the Data Sender
            (whether malicious or accidental). The AccECN fields are immutable
            end-to-end, so they are amenable to TCP-AO protection, which
            covers TCP options by default. However, TCP-AO is often too
            brittle to use on many end-to-end paths, where middleboxes can
            make verification fail in their attempts to improve performance or
            security, e.g.Â by resegmentation or shifting the sequence
            space.<a href="#section-5.3-2.3" class="pilcrow">Â¶</a>
</li>
        </ul>
<p id="section-5.3-3">Originally the ECN Nonce <span>[<a href="#RFC3540" class="xref">RFC3540</a>]</span> was
        proposed to ensure integrity of congestion feedback. With minor
        changes AccECN could be optimized for the possibility that the ECT(1)
        codepoint might be used as an ECN Nonce. However, given RFC 3540 has
        been reclassified as historic, the AccECN design has been generalized
        so that it ought to be able to support other possible uses of the
        ECT(1) codepoint, such as a lower severity or a more instant
        congestion signal than CE.<a href="#section-5.3-3" class="pilcrow">Â¶</a></p>
</section>
</div>
</section>
</div>
<div id="accecn_Properties">
<section id="section-6">
      <h2 id="name-protocol-properties">
<a href="#section-6" class="section-number selfRef">6. </a><a href="#name-protocol-properties" class="section-name selfRef">Protocol Properties</a>
      </h2>
<p id="section-6-1">This section is informative not normative. It describes how well the
      protocol satisfies the agreed requirements for a more accurate ECN
      feedback protocol <span>[<a href="#RFC7560" class="xref">RFC7560</a>]</span>.<a href="#section-6-1" class="pilcrow">Â¶</a></p>
<span class="break"></span><dl class="dlParallel" id="section-6-2">
        <dt id="section-6-2.1">Accuracy:</dt>
        <dd style="margin-left: 1.5em" id="section-6-2.2">From each ACK, the Data Sender can infer the
          number of new CE marked segments since the previous ACK. This
          provides better accuracy on CE feedback than classic ECN. In
          addition if the AccECN Option is present (not blocked by the network
          path) the number of bytes marked with CE, ECT(1) and ECT(0) are
          provided.<a href="#section-6-2.2" class="pilcrow">Â¶</a>
</dd>
        <dd class="break"></dd><dt id="section-6-2.3">Overhead:</dt>
        <dd style="margin-left: 1.5em" id="section-6-2.4">The AccECN scheme is divided into two parts.
          The essential part reuses the 3 flags already assigned to ECN in the
          IP header. The supplementary part adds an additional TCP option
          consuming up to 11 bytes. However, no TCP option is consumed in the
          SYN.<a href="#section-6-2.4" class="pilcrow">Â¶</a>
</dd>
        <dd class="break"></dd>
<dt id="section-6-2.5">Ordering:</dt>
        <dd style="margin-left: 1.5em" id="section-6-2.6">The order in which marks arrive at the Data
          Receiver is preserved in AccECN feedback, because the Data Receiver
          is expected to send an ACK immediately whenever a different mark
          arrives.<a href="#section-6-2.6" class="pilcrow">Â¶</a>
</dd>
        <dd class="break"></dd><dt id="section-6-2.7">Timeliness:</dt>
        <dd style="margin-left: 1.5em" id="section-6-2.8">While the same ECN markings are arriving
          continually at the Data Receiver, it can defer ACKs as TCP does
          normally, but it will immediately send an ACK as soon as a different
          ECN marking arrives.<a href="#section-6-2.8" class="pilcrow">Â¶</a>
</dd>
        <dd class="break"></dd>
<dt id="section-6-2.9">Timeliness vs Overhead:</dt>
        <dd style="margin-left: 1.5em" id="section-6-2.10">Change-Triggered ACKs are
          intended to enable latency-sensitive uses of ECN feedback by
          capturing the timing of transitions but not wasting resources while
          the state of the signalling system is stable. Within the constraints
          of the change-triggered ACK rules, the receiver can control how
          frequently it sends the AccECN TCP Option and therefore to some
          extent it can control the overhead induced by AccECN.<a href="#section-6-2.10" class="pilcrow">Â¶</a>
</dd>
        <dd class="break"></dd><dt id="section-6-2.11">Resilience:</dt>
        <dd style="margin-left: 1.5em" id="section-6-2.12">All information is provided based on
          counters. Therefore if ACKs are lost, the counters on the first ACK
          following the losses allows the Data Sender to immediately recover
          the number of the ECN markings that it missed. And if data or ACKs
          are reordered, stale congestion information can be identified and
          ignored.<a href="#section-6-2.12" class="pilcrow">Â¶</a>
</dd>
        <dd class="break"></dd>
<dt id="section-6-2.13">Resilience against Bias:</dt>
        <dd style="margin-left: 1.5em" id="section-6-2.14">Because feedback is based on
          repetition of counters, random losses do not remove any information,
          they only delay it. Therefore, even though some ACKs are
          change-triggered, random losses will not alter the proportions of
          the different ECN markings in the feedback.<a href="#section-6-2.14" class="pilcrow">Â¶</a>
</dd>
        <dd class="break"></dd>
<dt id="section-6-2.15">Resilience vs Overhead:</dt>
        <dd style="margin-left: 1.5em" id="section-6-2.16">If space is limited in some
          segments (e.g.Â because more options are needed on some
          segments, such as the SACK option after loss), the Data Receiver can
          send AccECN Options less frequently or truncate fields that have not
          changed, usually down to as little as 5 bytes. However, it has to
          send a full-sized AccECN Option at least three times per RTT, which
          the Data Sender can rely on as a regular beacon or checkpoint.<a href="#section-6-2.16" class="pilcrow">Â¶</a>
</dd>
        <dd class="break"></dd>
<dt id="section-6-2.17">Resilience vs Timeliness and Ordering:</dt>
        <dd style="margin-left: 1.5em" id="section-6-2.18">Ordering
          information and the timing of transitions cannot be communicated in
          three cases: i) during ACK loss; ii) if something on the path strips
          the AccECN Option; or iii) if the Data Receiver is unable to support
          Change-Triggered ACKs. Following ACK reordering, the Data Sender can
          reconstruct the order in which feedback was sent, but not until all
          the missing feedback has arrived.<a href="#section-6-2.18" class="pilcrow">Â¶</a>
</dd>
        <dd class="break"></dd><dt id="section-6-2.19">Complexity:</dt>
        <dd style="margin-left: 1.5em" id="section-6-2.20">An AccECN implementation solely involves
          simple counter increments, some modulo arithmetic to communicate the
          least significant bits and allow for wrap, and some heuristics for
          safety against fields cycling due to prolonged periods of ACK loss.
          Each host needs to maintain eight additional counters. The hosts
          have to apply some additional tests to detect tampering by
          middleboxes, but in general the protocol is simple to understand,
          simple to implement and requires few cycles per packet to
          execute.<a href="#section-6-2.20" class="pilcrow">Â¶</a>
</dd>
        <dd class="break"></dd>
<dt id="section-6-2.21">Integrity:</dt>
        <dd style="margin-left: 1.5em" id="section-6-2.22">AccECN is compatible with at least three
          approaches that can assure the integrity of ECN feedback. If the
          AccECN Option is stripped the resolution of the feedback is
          degraded, but the integrity of this degraded feedback can still be
          assured.<a href="#section-6-2.22" class="pilcrow">Â¶</a>
</dd>
        <dd class="break"></dd>
<dt id="section-6-2.23">Backward Compatibility:</dt>
        <dd style="margin-left: 1.5em" id="section-6-2.24">If only one endpoint supports
          the AccECN scheme, it will fall-back to the most advanced ECN
          feedback scheme supported by the other end.<a href="#section-6-2.24" class="pilcrow">Â¶</a>
</dd>
        <dd class="break"></dd><dt id="section-6-2.25">Backward Compatibility:</dt>
        <dd style="margin-left: 1.5em" id="section-6-2.26">If the AccECN Option is
          stripped by a middlebox, AccECN still provides basic congestion
          feedback in the ACE field. Further, AccECN can be used to detect
          mangling of the IP ECN field; mangling of the TCP ECN flags;
          blocking of ECT-marked segments; and blocking of segments carrying
          the AccECN Option. It can detect these conditions during TCP's 3WHS
          so that it can fall back to operation without ECN and/or operation
          without the AccECN Option.<a href="#section-6-2.26" class="pilcrow">Â¶</a>
</dd>
        <dd class="break"></dd><dt id="section-6-2.27">Forward Compatibility:</dt>
        <dd style="margin-left: 1.5em" id="section-6-2.28">The behaviour of endpoints and
          middleboxes is carefully defined for all reserved or currently
          unused codepoints in the scheme. Then, the designers of security
          devices can understand which currently unused values might appear in
          future. So, even if they choose to treat such values as anomalous
          while they are not widely used, any blocking will at least be under
          policy control not hard-coded. Then, if previously unused values
          start to appear on the Internet (or in standards), such policies
          could be quickly reversed.<a href="#section-6-2.28" class="pilcrow">Â¶</a>
</dd>
      <dd class="break"></dd>
</dl>
</section>
</div>
<div id="accecn_IANA_Considerations">
<section id="section-7">
      <h2 id="name-iana-considerations-16">
<a href="#section-7" class="section-number selfRef">7. </a><a href="#name-iana-considerations-16" class="section-name selfRef">IANA Considerations</a>
      </h2>
<p id="section-7-1">This document reassigns bit 7 of the TCP header flags to the AccECN
      protocol. This bit was previously called the Nonce Sum (NS) flag <span>[<a href="#RFC3540" class="xref">RFC3540</a>]</span>, but RFC 3540 has been reclassified as historic <span>[<a href="#RFC8311" class="xref">RFC8311</a>]</span>. The flag will now be defined as:<a href="#section-7-1" class="pilcrow">Â¶</a></p>
<span id="name-tcp-header-flag-reassignmen"></span><table class="center" id="table-6">
        <caption>
<a href="#table-6" class="selfRef">Table 6</a>:
<a href="#name-tcp-header-flag-reassignmen" class="selfRef">TCP header flag reassignment</a>
        </caption>
<thead>
          <tr>
            <th class="text-left" rowspan="1" colspan="1">Bit</th>
            <th class="text-left" rowspan="1" colspan="1">Name</th>
            <th class="text-left" rowspan="1" colspan="1">Reference</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td class="text-left" rowspan="1" colspan="1">7</td>
            <td class="text-left" rowspan="1" colspan="1">AE (Accurate ECN)</td>
            <td class="text-left" rowspan="1" colspan="1">RFC XXXX</td>
          </tr>
        </tbody>
      </table>
<p id="section-7-3">[TO BE REMOVED: IANA is requested to update the existing entry in the
      Transmission Control Protocol (TCP) Header Flags registration
      (https://www.iana.org/assignments/tcp-header-flags/tcp-header-flags.xhtml#tcp-header-flags-1)
      for Bit 7 to "AE (Accurate ECN), previously used as NS (Nonce Sum) by
      [RFC3540], which is now Historic [RFC8311]" and change the reference to
      this RFC-to-be instead of RFC8311.]<a href="#section-7-3" class="pilcrow">Â¶</a></p>
<p id="section-7-4">This document also defines two new TCP options for AccECN, assigned
      values of TBD0 and TBD1 (decimal) from the TCP option space. These
      values are defined as:<a href="#section-7-4" class="pilcrow">Â¶</a></p>
<span id="name-new-tcp-option-assignments"></span><table class="center" id="table-7">
        <caption>
<a href="#table-7" class="selfRef">Table 7</a>:
<a href="#name-new-tcp-option-assignments" class="selfRef">New TCP Option assignments</a>
        </caption>
<thead>
          <tr>
            <th class="text-left" rowspan="1" colspan="1">Kind</th>
            <th class="text-left" rowspan="1" colspan="1">Length</th>
            <th class="text-left" rowspan="1" colspan="1">Meaning</th>
            <th class="text-left" rowspan="1" colspan="1">Reference</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td class="text-left" rowspan="1" colspan="1">TBD0</td>
            <td class="text-left" rowspan="1" colspan="1">N</td>
            <td class="text-left" rowspan="1" colspan="1">Accurate ECN Order 0 (AccECN0)</td>
            <td class="text-left" rowspan="1" colspan="1">RFC XXXX</td>
          </tr>
          <tr>
            <td class="text-left" rowspan="1" colspan="1">TBD1</td>
            <td class="text-left" rowspan="1" colspan="1">N</td>
            <td class="text-left" rowspan="1" colspan="1">Accurate ECN Order 1 (AccECN1)</td>
            <td class="text-left" rowspan="1" colspan="1">RFC XXXX</td>
          </tr>
        </tbody>
      </table>
<p id="section-7-6">[TO BE REMOVED: This registration should take place at the following
      location:
      http://www.iana.org/assignments/tcp-parameters/tcp-parameters.xhtml#tcp-parameters-1
      ]<a href="#section-7-6" class="pilcrow">Â¶</a></p>
<p id="section-7-7">Early implementations using experimental option 254 per <span>[<a href="#RFC6994" class="xref">RFC6994</a>]</span> with the single magic number 0xACCE (16 bits), as
      allocated in the IANA "TCP Experimental Option Experiment Identifiers
      (TCP ExIDs)" registry, SHOULD migrate to use these new option kinds
      (TBD0 &amp; TBD1).<a href="#section-7-7" class="pilcrow">Â¶</a></p>
<p id="section-7-8">[TO BE REMOVED: The description of the 0xACCE value in the TCP ExIDs
      registry should be changed to "AccECN (current and new implementations
      SHOULD use option kinds TBD0 and TBD1)" at the following location:
      https://www.iana.org/assignments/tcp-parameters/tcp-parameters.xhtml#tcp-exids
      ]<a href="#section-7-8" class="pilcrow">Â¶</a></p>
</section>
</div>
<div id="accecn_Security_Considerations">
<section id="section-8">
      <h2 id="name-security-considerations-16">
<a href="#section-8" class="section-number selfRef">8. </a><a href="#name-security-considerations-16" class="section-name selfRef">Security Considerations</a>
      </h2>
<p id="section-8-1">If ever the supplementary part of AccECN based on the new AccECN TCP
      Option is unusable (due for example to middlebox interference) the
      essential part of AccECN's congestion feedback offers only limited
      resilience to long runs of ACK loss (see <a href="#accecn_ACE_Safety" class="xref">Section 3.2.2.5</a>). These problems are unlikely to be due to
      malicious intervention (because if an attacker could strip a TCP option
      or discard a long run of ACKs it could wreak other arbitrary havoc).
      However, it would be of concern if AccECN's resilience could be
      indirectly compromised during a flooding attack. AccECN is still
      considered safe though, because if the option is not present, the AccECN
      Data Sender is then required to switch to more conservative assumptions
      about wrap of congestion indication counters (see <a href="#accecn_ACE_Safety" class="xref">Section 3.2.2.5</a> and <a href="#accecn_Algo_ACE_Wrap" class="xref">Appendix A.2</a>).<a href="#section-8-1" class="pilcrow">Â¶</a></p>
<p id="section-8-2"><a href="#accecn_Interaction_SYN_Cookies" class="xref">Section 5.1</a> describes how a TCP
      server can negotiate AccECN and use the SYN cookie method for mitigating
      SYN flooding attacks.<a href="#section-8-2" class="pilcrow">Â¶</a></p>
<p id="section-8-3">There is concern that ECN feedback could be altered or suppressed,
      particularly because a misbehaving Data Receiver could increase its own
      throughput at the expense of others. AccECN is compatible with the three
      schemes known to assure the integrity of ECN feedback (see <a href="#accecn_Integrity" class="xref">Section 5.3</a> for details). If the AccECN Option is
      stripped by an incorrectly implemented middlebox, the resolution of the
      feedback will be degraded, but the integrity of this degraded
      information can still be assured. Assuring that Data Senders respond
      appropriately to ECN feedback is possible, but the scope of the present
      document is confined to the feedback protocol, and excludes the response
      to this feedback.<a href="#section-8-3" class="pilcrow">Â¶</a></p>
<p id="section-8-4">In <a href="#accecn_option" class="xref">Section 3.2.3</a> a Data Sender is allowed to ignore
      an unrecognized TCP AccECN Option length and read as many whole 3-octet
      fields from it as possible up to a maximum of 3, treating the remainder
      as padding. This opens up a potential covert channel of up to 29B (40 -
      (2+3*3))B. However, it is really an overt channel (not hidden) and it is
      no different to the use of unknown TCP options with unknown option
      lengths in general. Therefore, where this is of concern, it can already
      be adequately mitigated by regular TCP normalizer technology (see <a href="#accecn_middlebox_transparent_normalizers" class="xref">Section 3.3.2</a>).<a href="#section-8-4" class="pilcrow">Â¶</a></p>
<p id="section-8-5">The AccECN protocol is not believed to introduce any new privacy
      concerns, because it merely counts and feeds back signals at the
      transport layer that had already been visible at the IP layer. A covert
      channel can be used to compromise privacy. However, as explained above,
      undefined TCP options in general open up such channels and common
      techniques are available to close them off.<a href="#section-8-5" class="pilcrow">Â¶</a></p>
<p id="section-8-6">There is a potential concern that a Data Receiver could deliberately
      omit the AccECN Option pretending that it had been stripped by a
      middlebox. No known way can yet be contrived for a receiver to take
      advantage of this behaviour, which seems to always degrade its own
      performance. However, the concern is mentioned here for
      completeness.<a href="#section-8-6" class="pilcrow">Â¶</a></p>
</section>
</div>
<div id="accecn_Acknowledgements">
<section id="section-9">
      <h2 id="name-acknowledgements-5">
<a href="#section-9" class="section-number selfRef">9. </a><a href="#name-acknowledgements-5" class="section-name selfRef">Acknowledgements</a>
      </h2>
<p id="section-9-1">We want to thank Koen De Schepper, Praveen Balasubramanian, Michael
      Welzl, Gorry Fairhurst, David Black, Spencer Dawkins, Michael Scharf,
      Michael Tuexen, Yuchung Cheng, Kenjiro Cho, Olivier Tilmans, Ilpo
      Jaervinen, Neal Cardwell, Yoshifumi Nishida, Martin Duke and
      Jonathan Morton for their input and discussion. The idea of using the
      three ECN-related TCP flags as one field for more accurate TCP-ECN
      feedback was first introduced in the re-ECN protocol that was the
      ancestor of ConEx.<a href="#section-9-1" class="pilcrow">Â¶</a></p>
<p id="section-9-2">Bob Briscoe was part-funded by the Comcast Innovation Fund, the
      European Community under its Seventh Framework Programme through the
      Reducing Internet Transport Latency (RITE) project (ICT-317700) and
      through the Trilogy 2 project (ICT-317756), and the Research Council of
      Norway through the TimeIn project. The views expressed here are solely
      those of the authors.<a href="#section-9-2" class="pilcrow">Â¶</a></p>
<p id="section-9-3">Mirja Kuehlewind was partly supported by the European Commission
      under Horizon 2020 grant agreement no. 688421 Measurement and
      Architecture for a Middleboxed Internet (MAMI), and by the Swiss State
      Secretariat for Education, Research, and Innovation under contract no.
      15.0268. This support does not imply endorsement.<a href="#section-9-3" class="pilcrow">Â¶</a></p>
</section>
</div>
<div id="accecn_Comments_Solicited">
<section id="section-10">
      <h2 id="name-comments-solicited">
<a href="#section-10" class="section-number selfRef">10. </a><a href="#name-comments-solicited" class="section-name selfRef">Comments Solicited</a>
      </h2>
<p id="section-10-1">Comments and questions are encouraged and very welcome. They can be
      addressed to the IETF TCP maintenance and minor modifications working
      group mailing list &lt;tcpm@ietf.org&gt;, and/or to the authors.<a href="#section-10-1" class="pilcrow">Â¶</a></p>
</section>
</div>
<section id="section-11">
      <h2 id="name-references-13">
<a href="#section-11" class="section-number selfRef">11. </a><a href="#name-references-13" class="section-name selfRef">References</a>
      </h2>
<section id="section-11.1">
        <h3 id="name-normative-references-15">
<a href="#section-11.1" class="section-number selfRef">11.1. </a><a href="#name-normative-references-15" class="section-name selfRef">Normative References</a>
        </h3>
<dl class="references">
<dt id="RFC0793">[RFC0793]</dt>
        <dd>
<span class="refAuthor">Postel, J.</span>, <span class="refTitle">"Transmission Control Protocol"</span>, <span class="seriesInfo">STD 7</span>, <span class="seriesInfo">RFC 793</span>, <span class="seriesInfo">DOI 10.17487/RFC0793</span>, <time datetime="1981-09" class="refDate">September 1981</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc793">https://www.rfc-editor.org/info/rfc793</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC2119">[RFC2119]</dt>
        <dd>
<span class="refAuthor">Bradner, S.</span>, <span class="refTitle">"Key words for use in RFCs to Indicate Requirement Levels"</span>, <span class="seriesInfo">BCP 14</span>, <span class="seriesInfo">RFC 2119</span>, <span class="seriesInfo">DOI 10.17487/RFC2119</span>, <time datetime="1997-03" class="refDate">March 1997</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc2119">https://www.rfc-editor.org/info/rfc2119</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC3168">[RFC3168]</dt>
        <dd>
<span class="refAuthor">Ramakrishnan, K.</span>, <span class="refAuthor">Floyd, S.</span>, and <span class="refAuthor">D. Black</span>, <span class="refTitle">"The Addition of Explicit Congestion Notification (ECN) to IP"</span>, <span class="seriesInfo">RFC 3168</span>, <span class="seriesInfo">DOI 10.17487/RFC3168</span>, <time datetime="2001-09" class="refDate">September 2001</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc3168">https://www.rfc-editor.org/info/rfc3168</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC5681">[RFC5681]</dt>
        <dd>
<span class="refAuthor">Allman, M.</span>, <span class="refAuthor">Paxson, V.</span>, and <span class="refAuthor">E. Blanton</span>, <span class="refTitle">"TCP Congestion Control"</span>, <span class="seriesInfo">RFC 5681</span>, <span class="seriesInfo">DOI 10.17487/RFC5681</span>, <time datetime="2009-09" class="refDate">September 2009</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc5681">https://www.rfc-editor.org/info/rfc5681</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC8174">[RFC8174]</dt>
      <dd>
<span class="refAuthor">Leiba, B.</span>, <span class="refTitle">"Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words"</span>, <span class="seriesInfo">BCP 14</span>, <span class="seriesInfo">RFC 8174</span>, <span class="seriesInfo">DOI 10.17487/RFC8174</span>, <time datetime="2017-05" class="refDate">May 2017</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc8174">https://www.rfc-editor.org/info/rfc8174</a>&gt;</span>. </dd>
<dd class="break"></dd>
</dl>
</section>
<section id="section-11.2">
        <h3 id="name-informative-references-14">
<a href="#section-11.2" class="section-number selfRef">11.2. </a><a href="#name-informative-references-14" class="section-name selfRef">Informative References</a>
        </h3>
<dl class="references">
<dt id="I-D.ietf-tcpm-generalized-ecn">[I-D.ietf-tcpm-generalized-ecn]</dt>
        <dd>
<span class="refAuthor">Bagnulo, M.</span> and <span class="refAuthor">B. Briscoe</span>, <span class="refTitle">"ECN++: Adding Explicit Congestion Notification (ECN) to TCP Control Packets"</span>, <span class="refContent">Work in Progress</span>, <span class="seriesInfo">Internet-Draft, draft-ietf-tcpm-generalized-ecn-09</span>, <time datetime="2022-01-31" class="refDate">31 January 2022</time>, <span>&lt;<a href="https://datatracker.ietf.org/doc/html/draft-ietf-tcpm-generalized-ecn-09">https://datatracker.ietf.org/doc/html/draft-ietf-tcpm-generalized-ecn-09</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="I-D.ietf-tsvwg-l4s-arch">[I-D.ietf-tsvwg-l4s-arch]</dt>
        <dd>
<span class="refAuthor">Briscoe, B.</span>, <span class="refAuthor">Schepper, K. D.</span>, <span class="refAuthor">Bagnulo, M.</span>, and <span class="refAuthor">G. White</span>, <span class="refTitle">"Low Latency, Low Loss, Scalable Throughput (L4S) Internet Service: Architecture"</span>, <span class="refContent">Work in Progress</span>, <span class="seriesInfo">Internet-Draft, draft-ietf-tsvwg-l4s-arch-16</span>, <time datetime="2022-02-01" class="refDate">1 February 2022</time>, <span>&lt;<a href="https://datatracker.ietf.org/doc/html/draft-ietf-tsvwg-l4s-arch-16">https://datatracker.ietf.org/doc/html/draft-ietf-tsvwg-l4s-arch-16</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="Mandalari18">[Mandalari18]</dt>
        <dd>
<span class="refAuthor">Mandalari, A.</span>, <span class="refAuthor">Lutu, A.</span>, <span class="refAuthor">Briscoe, B.</span>, <span class="refAuthor">Bagnulo, M.</span>, and <span class="refAuthor">Ã. Alay</span>, <span class="refTitle">"Measuring ECN++: Good News for ++, Bad News for ECN over Mobile"</span>, <span class="seriesInfo">IEEE Communications Magazine </span>, <time datetime="2018-03" class="refDate">March 2018</time>, <span>&lt;<a href="http://www.it.uc3m.es/amandala/ecn++/ecn_commag_2018.html">http://www.it.uc3m.es/amandala/ecn++/ecn_commag_2018.html</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC2018">[RFC2018]</dt>
        <dd>
<span class="refAuthor">Mathis, M.</span>, <span class="refAuthor">Mahdavi, J.</span>, <span class="refAuthor">Floyd, S.</span>, and <span class="refAuthor">A. Romanow</span>, <span class="refTitle">"TCP Selective Acknowledgment Options"</span>, <span class="seriesInfo">RFC 2018</span>, <span class="seriesInfo">DOI 10.17487/RFC2018</span>, <time datetime="1996-10" class="refDate">October 1996</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc2018">https://www.rfc-editor.org/info/rfc2018</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC3449">[RFC3449]</dt>
        <dd>
<span class="refAuthor">Balakrishnan, H.</span>, <span class="refAuthor">Padmanabhan, V.</span>, <span class="refAuthor">Fairhurst, G.</span>, and <span class="refAuthor">M. Sooriyabandara</span>, <span class="refTitle">"TCP Performance Implications of Network Path Asymmetry"</span>, <span class="seriesInfo">BCP 69</span>, <span class="seriesInfo">RFC 3449</span>, <span class="seriesInfo">DOI 10.17487/RFC3449</span>, <time datetime="2002-12" class="refDate">December 2002</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc3449">https://www.rfc-editor.org/info/rfc3449</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC3540">[RFC3540]</dt>
        <dd>
<span class="refAuthor">Spring, N.</span>, <span class="refAuthor">Wetherall, D.</span>, and <span class="refAuthor">D. Ely</span>, <span class="refTitle">"Robust Explicit Congestion Notification (ECN) Signaling with Nonces"</span>, <span class="seriesInfo">RFC 3540</span>, <span class="seriesInfo">DOI 10.17487/RFC3540</span>, <time datetime="2003-06" class="refDate">June 2003</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc3540">https://www.rfc-editor.org/info/rfc3540</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC4987">[RFC4987]</dt>
        <dd>
<span class="refAuthor">Eddy, W.</span>, <span class="refTitle">"TCP SYN Flooding Attacks and Common Mitigations"</span>, <span class="seriesInfo">RFC 4987</span>, <span class="seriesInfo">DOI 10.17487/RFC4987</span>, <time datetime="2007-08" class="refDate">August 2007</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc4987">https://www.rfc-editor.org/info/rfc4987</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC5562">[RFC5562]</dt>
        <dd>
<span class="refAuthor">Kuzmanovic, A.</span>, <span class="refAuthor">Mondal, A.</span>, <span class="refAuthor">Floyd, S.</span>, and <span class="refAuthor">K. Ramakrishnan</span>, <span class="refTitle">"Adding Explicit Congestion Notification (ECN) Capability to TCP's SYN/ACK Packets"</span>, <span class="seriesInfo">RFC 5562</span>, <span class="seriesInfo">DOI 10.17487/RFC5562</span>, <time datetime="2009-06" class="refDate">June 2009</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc5562">https://www.rfc-editor.org/info/rfc5562</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC5690">[RFC5690]</dt>
        <dd>
<span class="refAuthor">Floyd, S.</span>, <span class="refAuthor">Arcia, A.</span>, <span class="refAuthor">Ros, D.</span>, and <span class="refAuthor">J. Iyengar</span>, <span class="refTitle">"Adding Acknowledgement Congestion Control to TCP"</span>, <span class="seriesInfo">RFC 5690</span>, <span class="seriesInfo">DOI 10.17487/RFC5690</span>, <time datetime="2010-02" class="refDate">February 2010</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc5690">https://www.rfc-editor.org/info/rfc5690</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC5925">[RFC5925]</dt>
        <dd>
<span class="refAuthor">Touch, J.</span>, <span class="refAuthor">Mankin, A.</span>, and <span class="refAuthor">R. Bonica</span>, <span class="refTitle">"The TCP Authentication Option"</span>, <span class="seriesInfo">RFC 5925</span>, <span class="seriesInfo">DOI 10.17487/RFC5925</span>, <time datetime="2010-06" class="refDate">June 2010</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc5925">https://www.rfc-editor.org/info/rfc5925</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC5961">[RFC5961]</dt>
        <dd>
<span class="refAuthor">Ramaiah, A.</span>, <span class="refAuthor">Stewart, R.</span>, and <span class="refAuthor">M. Dalal</span>, <span class="refTitle">"Improving TCP's Robustness to Blind In-Window Attacks"</span>, <span class="seriesInfo">RFC 5961</span>, <span class="seriesInfo">DOI 10.17487/RFC5961</span>, <time datetime="2010-08" class="refDate">August 2010</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc5961">https://www.rfc-editor.org/info/rfc5961</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC6824">[RFC6824]</dt>
        <dd>
<span class="refAuthor">Ford, A.</span>, <span class="refAuthor">Raiciu, C.</span>, <span class="refAuthor">Handley, M.</span>, and <span class="refAuthor">O. Bonaventure</span>, <span class="refTitle">"TCP Extensions for Multipath Operation with Multiple Addresses"</span>, <span class="seriesInfo">RFC 6824</span>, <span class="seriesInfo">DOI 10.17487/RFC6824</span>, <time datetime="2013-01" class="refDate">January 2013</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc6824">https://www.rfc-editor.org/info/rfc6824</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC6994">[RFC6994]</dt>
        <dd>
<span class="refAuthor">Touch, J.</span>, <span class="refTitle">"Shared Use of Experimental TCP Options"</span>, <span class="seriesInfo">RFC 6994</span>, <span class="seriesInfo">DOI 10.17487/RFC6994</span>, <time datetime="2013-08" class="refDate">August 2013</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc6994">https://www.rfc-editor.org/info/rfc6994</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC7413">[RFC7413]</dt>
        <dd>
<span class="refAuthor">Cheng, Y.</span>, <span class="refAuthor">Chu, J.</span>, <span class="refAuthor">Radhakrishnan, S.</span>, and <span class="refAuthor">A. Jain</span>, <span class="refTitle">"TCP Fast Open"</span>, <span class="seriesInfo">RFC 7413</span>, <span class="seriesInfo">DOI 10.17487/RFC7413</span>, <time datetime="2014-12" class="refDate">December 2014</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc7413">https://www.rfc-editor.org/info/rfc7413</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC7560">[RFC7560]</dt>
        <dd>
<span class="refAuthor">Kuehlewind, M., Ed.</span>, <span class="refAuthor">Scheffenegger, R.</span>, and <span class="refAuthor">B. Briscoe</span>, <span class="refTitle">"Problem Statement and Requirements for Increased Accuracy in Explicit Congestion Notification (ECN) Feedback"</span>, <span class="seriesInfo">RFC 7560</span>, <span class="seriesInfo">DOI 10.17487/RFC7560</span>, <time datetime="2015-08" class="refDate">August 2015</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc7560">https://www.rfc-editor.org/info/rfc7560</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC7713">[RFC7713]</dt>
        <dd>
<span class="refAuthor">Mathis, M.</span> and <span class="refAuthor">B. Briscoe</span>, <span class="refTitle">"Congestion Exposure (ConEx) Concepts, Abstract Mechanism, and Requirements"</span>, <span class="seriesInfo">RFC 7713</span>, <span class="seriesInfo">DOI 10.17487/RFC7713</span>, <time datetime="2015-12" class="refDate">December 2015</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc7713">https://www.rfc-editor.org/info/rfc7713</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC8257">[RFC8257]</dt>
        <dd>
<span class="refAuthor">Bensley, S.</span>, <span class="refAuthor">Thaler, D.</span>, <span class="refAuthor">Balasubramanian, P.</span>, <span class="refAuthor">Eggert, L.</span>, and <span class="refAuthor">G. Judd</span>, <span class="refTitle">"Data Center TCP (DCTCP): TCP Congestion Control for Data Centers"</span>, <span class="seriesInfo">RFC 8257</span>, <span class="seriesInfo">DOI 10.17487/RFC8257</span>, <time datetime="2017-10" class="refDate">October 2017</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc8257">https://www.rfc-editor.org/info/rfc8257</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC8311">[RFC8311]</dt>
        <dd>
<span class="refAuthor">Black, D.</span>, <span class="refTitle">"Relaxing Restrictions on Explicit Congestion Notification (ECN) Experimentation"</span>, <span class="seriesInfo">RFC 8311</span>, <span class="seriesInfo">DOI 10.17487/RFC8311</span>, <time datetime="2018-01" class="refDate">January 2018</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc8311">https://www.rfc-editor.org/info/rfc8311</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC8511">[RFC8511]</dt>
        <dd>
<span class="refAuthor">Khademi, N.</span>, <span class="refAuthor">Welzl, M.</span>, <span class="refAuthor">Armitage, G.</span>, and <span class="refAuthor">G. Fairhurst</span>, <span class="refTitle">"TCP Alternative Backoff with ECN (ABE)"</span>, <span class="seriesInfo">RFC 8511</span>, <span class="seriesInfo">DOI 10.17487/RFC8511</span>, <time datetime="2018-12" class="refDate">December 2018</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc8511">https://www.rfc-editor.org/info/rfc8511</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC9040">[RFC9040]</dt>
      <dd>
<span class="refAuthor">Touch, J.</span>, <span class="refAuthor">Welzl, M.</span>, and <span class="refAuthor">S. Islam</span>, <span class="refTitle">"TCP Control Block Interdependence"</span>, <span class="seriesInfo">RFC 9040</span>, <span class="seriesInfo">DOI 10.17487/RFC9040</span>, <time datetime="2021-07" class="refDate">July 2021</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc9040">https://www.rfc-editor.org/info/rfc9040</a>&gt;</span>. </dd>
<dd class="break"></dd>
</dl>
</section>
</section>
<div id="accecn_Algo_Examples">
<section id="appendix-A">
      <h2 id="name-example-algorithms">
<a href="#appendix-A" class="section-number selfRef">Appendix A. </a><a href="#name-example-algorithms" class="section-name selfRef">Example Algorithms</a>
      </h2>
<p id="appendix-A-1">This appendix is informative, not normative. It gives example
      algorithms that would satisfy the normative requirements of the AccECN
      protocol. However, implementers are free to choose other ways to
      implement the requirements.<a href="#appendix-A-1" class="pilcrow">Â¶</a></p>
<div id="accecn_Algo_Option_Coding">
<section id="appendix-A.1">
        <h3 id="name-example-algorithm-to-encode">
<a href="#appendix-A.1" class="section-number selfRef">A.1. </a><a href="#name-example-algorithm-to-encode" class="section-name selfRef">Example Algorithm to Encode/Decode the AccECN Option</a>
        </h3>
<p id="appendix-A.1-1">The
        example algorithms below show how a Data Receiver in AccECN mode could
        encode its CE byte counter r.ceb into the ECEB field within the AccECN
        TCP Option, and how a Data Sender in AccECN mode could decode the ECEB
        field into its byte counter s.ceb. The other counters for bytes marked
        ECT(0) and ECT(1) in the AccECN Option would be similarly encoded and
        decoded.<a href="#appendix-A.1-1" class="pilcrow">Â¶</a></p>
<p id="appendix-A.1-2">It is assumed that each local byte counter is an unsigned integer
        greater than 24b (probably 32b), and that the following constant has
        been assigned:<a href="#appendix-A.1-2" class="pilcrow">Â¶</a></p>
<ul class="normal ulEmpty">
<li class="normal ulEmpty" id="appendix-A.1-3.1">DIVOPT = 2^24<a href="#appendix-A.1-3.1" class="pilcrow">Â¶</a>
</li>
        </ul>
<p id="appendix-A.1-4">Every time a CE marked data segment arrives, the Data Receiver
        increments its local value of r.ceb by the size of the TCP Data.
        Whenever it sends an ACK with the AccECN Option, the value it writes
        into the ECEB field is<a href="#appendix-A.1-4" class="pilcrow">Â¶</a></p>
<ul class="normal ulEmpty">
<li class="normal ulEmpty" id="appendix-A.1-5.1">ECEB = r.ceb % DIVOPT<a href="#appendix-A.1-5.1" class="pilcrow">Â¶</a>
</li>
        </ul>
<p id="appendix-A.1-6">where '%' is the remainder operator.<a href="#appendix-A.1-6" class="pilcrow">Â¶</a></p>
<p id="appendix-A.1-7">On the arrival of an AccECN Option, the Data Sender first makes
        sure the ACK has not been superseded in order to avoid winding the
        s.ceb counter backwards. It uses the TCP acknowledgement number and
        any SACK options to calculate newlyAckedB, the amount of new data that
        the ACK acknowledges in bytes (newlyAckedB can be zero but not
        negative). If newlyAckedB is zero, either the ACK has been superseded
        or CE-marked packet(s) without data could have arrived. To break the
        tie for the latter case, the Data Sender could use timestamps (if
        present) to work out newlyAckedT, the amount of new time that the ACK
        acknowledges. If the Data Sender determines that the ACK has been
        superseded it ignores the AccECN Option. Otherwise, the Data Sender
        calculates the minimum non-negative difference d.ceb between the ECEB
        field and its local s.ceb counter, using modulo arithmetic as
        follows:<a href="#appendix-A.1-7" class="pilcrow">Â¶</a></p>
<div class="alignLeft art-text artwork" id="appendix-A.1-8">
<pre>   if ((newlyAckedB &gt; 0) || (newlyAckedT &gt; 0)) {
       d.ceb = (ECEB + DIVOPT - (s.ceb % DIVOPT)) % DIVOPT
       s.ceb += d.ceb
   }
</pre><a href="#appendix-A.1-8" class="pilcrow">Â¶</a>
</div>
<p id="appendix-A.1-9">For example, if s.ceb is 33,554,433 and ECEB is 1461 (both
        decimal), then<a href="#appendix-A.1-9" class="pilcrow">Â¶</a></p>
<div class="alignLeft art-text artwork" id="appendix-A.1-10">
<pre>   s.ceb % DIVOPT = 1
         d.ceb = (1461 + 2^24 - 1) % 2^24
               = 1460
         s.ceb = 33,554,433 + 1460
               = 33,555,893
</pre><a href="#appendix-A.1-10" class="pilcrow">Â¶</a>
</div>
<p id="appendix-A.1-11">In practice an implementation might use heuristics to guess the
        feedback in missing ACKs, then when it subsequently receives feedback
        it might find that it needs to correct its earlier heuristics as part
        of the decoding process. The above decoding process does not include
        any such heuristics.<a href="#appendix-A.1-11" class="pilcrow">Â¶</a></p>
</section>
</div>
<div id="accecn_Algo_ACE_Wrap">
<section id="appendix-A.2">
        <h3 id="name-example-algorithm-for-safet">
<a href="#appendix-A.2" class="section-number selfRef">A.2. </a><a href="#name-example-algorithm-for-safet" class="section-name selfRef">Example Algorithm for Safety Against Long Sequences of ACK Loss</a>
        </h3>
<p id="appendix-A.2-1">The example algorithms below show how a Data Receiver in AccECN
        mode could encode its CE packet counter r.cep into the ACE field, and
        how the Data Sender in AccECN mode could decode the ACE field into its
        s.cep counter. The Data Sender's algorithm includes code to
        heuristically detect a long enough unbroken string of ACK losses that
        could have concealed a cycle of the congestion counter in the ACE
        field of the next ACK to arrive.<a href="#appendix-A.2-1" class="pilcrow">Â¶</a></p>
<p id="appendix-A.2-2">Two variants of the algorithm are given: i) a more conservative
        variant for a Data Sender to use if it detects that the AccECN Option
        is not available (see <a href="#accecn_ACE_Safety" class="xref">Section 3.2.2.5</a> and <a href="#accecn_Mbox_Interference" class="xref">Section 3.2.3.2</a>); and ii) a less conservative
        variant that is feasible when complementary information is available
        from the AccECN Option.<a href="#appendix-A.2-2" class="pilcrow">Â¶</a></p>
<section id="appendix-A.2.1">
          <h4 id="name-safety-algorithm-without-th">
<a href="#appendix-A.2.1" class="section-number selfRef">A.2.1. </a><a href="#name-safety-algorithm-without-th" class="section-name selfRef">Safety Algorithm without the AccECN Option</a>
          </h4>
<p id="appendix-A.2.1-1">It is assumed that each local packet counter is a sufficiently
          sized unsigned integer (probably 32b) and that the following
          constant has been assigned:<a href="#appendix-A.2.1-1" class="pilcrow">Â¶</a></p>
<ul class="normal ulEmpty">
<li class="normal ulEmpty" id="appendix-A.2.1-2.1">DIVACE = 2^3<a href="#appendix-A.2.1-2.1" class="pilcrow">Â¶</a>
</li>
          </ul>
<p id="appendix-A.2.1-3">Every time an Acceptable CE marked packet arrives (<a href="#accecn_sec_ACE_feedback" class="xref">Section 3.2.2.2</a>), the Data Receiver increments
          its local value of r.cep by 1. It repeats the same value of ACE in
          every subsequent ACK until the next CE marking arrives, where<a href="#appendix-A.2.1-3" class="pilcrow">Â¶</a></p>
<ul class="normal ulEmpty">
<li class="normal ulEmpty" id="appendix-A.2.1-4.1">ACE = r.cep % DIVACE.<a href="#appendix-A.2.1-4.1" class="pilcrow">Â¶</a>
</li>
          </ul>
<p id="appendix-A.2.1-5">If the Data Sender received an earlier value of the counter that
          had been delayed due to ACK reordering, it might incorrectly
          calculate that the ACE field had wrapped. Therefore, on the arrival
          of every ACK, the Data Sender ensures the ACK has not been
          superseded using the TCP acknowledgement number, any SACK options
          and timestamps (if available) to calculate newlyAckedB, as in <a href="#accecn_Algo_Option_Coding" class="xref">Appendix A.1</a>. If the ACK has not been
          superseded, the Data Sender calculates the minimum difference d.cep
          between the ACE field and its local s.cep counter, using modulo
          arithmetic as follows:<a href="#appendix-A.2.1-5" class="pilcrow">Â¶</a></p>
<div class="alignLeft art-text artwork" id="appendix-A.2.1-6">
<pre>   if ((newlyAckedB &gt; 0) || (newlyAckedT &gt; 0))
       d.cep = (ACE + DIVACE - (s.cep % DIVACE)) % DIVACE
</pre><a href="#appendix-A.2.1-6" class="pilcrow">Â¶</a>
</div>
<p id="appendix-A.2.1-7"><a href="#accecn_ACE_Safety" class="xref">Section 3.2.2.5</a> expects the Data Sender to
          assume that the ACE field cycled if it is the safest likely case
          under prevailing conditions. The 3-bit ACE field in an arriving ACK
          could have cycled and become ambiguous to the Data Sender if a
          sequence of ACKs goes missing that covers a stream of data long
          enough to contain 8 or more CE marks. We use the word `missing'
          rather than `lost', because some or all the missing ACKs might
          arrive eventually, but out of order. Even if some of the missing
          ACKs were piggy-backed on data (i.e.Â not pure ACKs)
          retransmissions will not repair the lost AccECN information, because
          AccECN requires retransmissions to carry the latest AccECN counters,
          not the original ones.<a href="#appendix-A.2.1-7" class="pilcrow">Â¶</a></p>
<p id="appendix-A.2.1-8">The phrase `under prevailing conditions' allows for
          implementation-dependent interpretation. A Data Sender might take
          account of the prevailing size of data segments and the prevailing
          CE marking rate just before the sequence of missing ACKs. However,
          we shall start with the simplest algorithm, which assumes segments
          are all full-sized and ultra-conservatively it assumes that ECN
          marking was 100% on the forward path when ACKs on the reverse path
          started to all be dropped. Specifically, if newlyAckedB is the
          amount of data that an ACK acknowledges since the previous ACK, then
          the Data Sender could assume that this acknowledges newlyAckedPkt
          full-sized segments, where newlyAckedPkt = newlyAckedB/MSS. Then it
          could assume that the ACE field incremented by<a href="#appendix-A.2.1-8" class="pilcrow">Â¶</a></p>
<div class="alignLeft art-text artwork" id="appendix-A.2.1-9">
<pre>    dSafer.cep = newlyAckedPkt - ((newlyAckedPkt - d.cep) % DIVACE),</pre><a href="#appendix-A.2.1-9" class="pilcrow">Â¶</a>
</div>
<p id="appendix-A.2.1-10">For example, imagine an ACK acknowledges newlyAckedPkt=9 more
          full-size segments than any previous ACK, and that ACE increments by
          a minimum of 2 CE marks (d.cep=2). The above formula works out that
          it would still be safe to assume 2 CE marks (because 9 - ((9-2) % 8)
          = 2). However, if ACE increases by a minimum of 2 but acknowledges
          10 full-sized segments, then it would be necessary to assume that
          there could have been 10 CE marks (because 10 - ((10-2) % 8) =
          10).<a href="#appendix-A.2.1-10" class="pilcrow">Â¶</a></p>
<p id="appendix-A.2.1-11">Note that checks would need to be added to the above pseudocode
          for (d.cep &gt; newlyAckedPkt), which could occur if newlyAckedPkt
          had been wrongly estimated using an inappropriate packet size.<a href="#appendix-A.2.1-11" class="pilcrow">Â¶</a></p>
<p id="appendix-A.2.1-12">ACKs that acknowledge a large stretch of packets might be common
          in data centres to achieve a high packet rate or might be due to ACK
          thinning by a middlebox. In these cases, cycling of the ACE field
          would often appear to have been possible, so the above algorithm
          would be over-conservative, leading to a false high marking rate and
          poor performance. Therefore it would be reasonable to only use
          dSafer.cep rather than d.cep if the moving average of newlyAckedPkt
          was well below 8.<a href="#appendix-A.2.1-12" class="pilcrow">Â¶</a></p>
<p id="appendix-A.2.1-13">Implementers could build in more heuristics to estimate
          prevailing average segment size and prevailing ECN marking. For
          instance, newlyAckedPkt in the above formula could be replaced with
          newlyAckedPktHeur = newlyAckedPkt*p*MSS/s, where s is the prevailing
          segment size and p is the prevailing ECN marking probability.
          However, ultimately, if TCP's ECN feedback becomes inaccurate it
          still has loss detection to fall back on. Therefore, it would seem
          safe to implement a simple algorithm, rather than a perfect one.<a href="#appendix-A.2.1-13" class="pilcrow">Â¶</a></p>
<p id="appendix-A.2.1-14">The simple algorithm for dSafer.cep above requires no monitoring
          of prevailing conditions and it would still be safe if, for example,
          segments were on average at least 5% of full-sized as long as ECN
          marking was 5% or less. Assuming it was used, the Data Sender would
          increment its packet counter as follows:<a href="#appendix-A.2.1-14" class="pilcrow">Â¶</a></p>
<ul class="normal ulEmpty">
<li class="normal ulEmpty" id="appendix-A.2.1-15.1">s.cep += dSafer.cep<a href="#appendix-A.2.1-15.1" class="pilcrow">Â¶</a>
</li>
          </ul>
<p id="appendix-A.2.1-16">If missing acknowledgement numbers arrive later (due to
          reordering), <a href="#accecn_ACE_Safety" class="xref">Section 3.2.2.5</a> says "the Data
          Sender MAY attempt to neutralize the effect of any action it took
          based on a conservative assumption that it later found to be
          incorrect". To do this, the Data Sender would have to store the
          values of all the relevant variables whenever it made assumptions,
          so that it could re-evaluate them later. Given this could become
          complex and it is not required, we do not attempt to provide an
          example of how to do this.<a href="#appendix-A.2.1-16" class="pilcrow">Â¶</a></p>
</section>
<section id="appendix-A.2.2">
          <h4 id="name-safety-algorithm-with-the-a">
<a href="#appendix-A.2.2" class="section-number selfRef">A.2.2. </a><a href="#name-safety-algorithm-with-the-a" class="section-name selfRef">Safety Algorithm with the AccECN Option</a>
          </h4>
<p id="appendix-A.2.2-1">When the AccECN Option is available on the ACKs before and after
          the possible sequence of ACK losses, if the Data Sender only needs
          CE-marked bytes, it will have sufficient information in the AccECN
          Option without needing to process the ACE field. If for some reason
          it needs CE-marked packets, if dSafer.cep is different from d.cep,
          it can determine whether d.cep is likely to be a safe enough
          estimate by checking whether the average marked segment size (s =
          d.ceb/d.cep) is less than the MSS (where d.ceb is the amount of
          newly CE-marked bytes - see <a href="#accecn_Algo_Option_Coding" class="xref">Appendix A.1</a>). Specifically, it could use
          the following algorithm:<a href="#appendix-A.2.2-1" class="pilcrow">Â¶</a></p>
<div class="alignLeft art-text artwork" id="appendix-A.2.2-2">
<pre>   SAFETY_FACTOR = 2
   if (dSafer.cep &gt; d.cep) {
       if (d.ceb &lt;= MSS * d.cep) {  % Same as (s &lt;= MSS), but no DBZ
          sSafer = d.ceb/dSafer.cep
          if (sSafer &lt; MSS/SAFETY_FACTOR)
              dSafer.cep = d.cep    % d.cep is a safe enough estimate
       } % else
           % No need for else; dSafer.cep is already correct,
           % because d.cep must have been too small
   }
</pre><a href="#appendix-A.2.2-2" class="pilcrow">Â¶</a>
</div>
<p id="appendix-A.2.2-3">The chart below shows when the above algorithm will consider
          d.cep can replace dSafer.cep as a safe enough estimate of the number
          of CE-marked packets:<a href="#appendix-A.2.2-3" class="pilcrow">Â¶</a></p>
<div class="alignLeft art-text artwork" id="appendix-A.2.2-4">
<pre>                 ^
           sSafer|
                 |
              MSS+
                 |
                 |         dSafer.cep
                 |                  is
MSS/SAFETY_FACTOR+--------------+    safest
                 |              |
                 | d.cep is safe|
                 |    enough    |
                 +--------------------&gt;
                               MSS     s

</pre><a href="#appendix-A.2.2-4" class="pilcrow">Â¶</a>
</div>
<p id="appendix-A.2.2-5">The following examples give the reasoning behind the algorithm,
          assuming MSS=1460 [B]:<a href="#appendix-A.2.2-5" class="pilcrow">Â¶</a></p>
<ul class="normal">
<li class="normal" id="appendix-A.2.2-6.1">
              <p id="appendix-A.2.2-6.1.1">if d.cep=0, dSafer.cep=8 and d.ceb=1460, then s=infinity and
              sSafer=182.5.<a href="#appendix-A.2.2-6.1.1" class="pilcrow">Â¶</a></p>
<p id="appendix-A.2.2-6.1.2">Therefore even though the
              average size of 8 data segments is unlikely to have been as
              small as MSS/8, d.cep cannot have been correct, because it would
              imply an average segment size greater than the MSS.<a href="#appendix-A.2.2-6.1.2" class="pilcrow">Â¶</a></p>
</li>
            <li class="normal" id="appendix-A.2.2-6.2">
              <p id="appendix-A.2.2-6.2.1">if d.cep=2, dSafer.cep=10 and d.ceb=1460, then s=730 and
              sSafer=146.<a href="#appendix-A.2.2-6.2.1" class="pilcrow">Â¶</a></p>
<p id="appendix-A.2.2-6.2.2">Therefore d.cep is safe
              enough, because the average size of 10 data segments is unlikely
              to have been as small as MSS/10.<a href="#appendix-A.2.2-6.2.2" class="pilcrow">Â¶</a></p>
</li>
            <li class="normal" id="appendix-A.2.2-6.3">
              <p id="appendix-A.2.2-6.3.1">if d.cep=7, dSafer.cep=15 and d.ceb=10200, then s=1457 and
              sSafer=680.<a href="#appendix-A.2.2-6.3.1" class="pilcrow">Â¶</a></p>
<p id="appendix-A.2.2-6.3.2">Therefore d.cep is safe
              enough, because the average data segment size is more likely to
              have been just less than one MSS, rather than below MSS/2.<a href="#appendix-A.2.2-6.3.2" class="pilcrow">Â¶</a></p>
</li>
          </ul>
<p id="appendix-A.2.2-7">If pure ACKs were allowed to be ECN-capable, missing ACKs would
          be far less likely. However, because <span>[<a href="#RFC3168" class="xref">RFC3168</a>]</span>
          currently precludes this, the above algorithm assumes that pure ACKs
          are not ECN-capable.<a href="#appendix-A.2.2-7" class="pilcrow">Â¶</a></p>
</section>
</section>
</div>
<div id="accecn_Algo_ACE_Bytes">
<section id="appendix-A.3">
        <h3 id="name-example-algorithm-to-estima">
<a href="#appendix-A.3" class="section-number selfRef">A.3. </a><a href="#name-example-algorithm-to-estima" class="section-name selfRef">Example Algorithm to Estimate Marked Bytes from Marked Packets</a>
        </h3>
<p id="appendix-A.3-1">If the AccECN Option is not available, the Data Sender can only
        decode CE-marking from the ACE field in packets. Every time an ACK
        arrives, to convert this into an estimate of CE-marked bytes, it needs
        an average of the segment size, s_ave. Then it can add or subtract
        s_ave from the value of d.ceb as the value of d.cep increments or
        decrements. Some possible ways to calculate s_ave are outlined below.
        The precise details will depend on why an estimate of marked bytes is
        needed.<a href="#appendix-A.3-1" class="pilcrow">Â¶</a></p>
<p id="appendix-A.3-2">The implementation could keep a record of the byte numbers of all
        the boundaries between packets in flight (including control packets),
        and recalculate s_ave on every ACK. However it would be simpler to
        merely maintain a counter packets_in_flight for the number of packets
        in flight (including control packets), which is reset once per RTT.
        Either way, it would estimate s_ave as:<a href="#appendix-A.3-2" class="pilcrow">Â¶</a></p>
<ul class="normal ulEmpty">
<li class="normal ulEmpty" id="appendix-A.3-3.1">s_ave ~= flightsize / packets_in_flight,<a href="#appendix-A.3-3.1" class="pilcrow">Â¶</a>
</li>
        </ul>
<p id="appendix-A.3-4">where flightsize is the variable that TCP already maintains
        for the number of bytes in flight. To avoid floating point arithmetic,
        it could right-bit-shift by lg(packets_in_flight), where lg() means
        log base 2.<a href="#appendix-A.3-4" class="pilcrow">Â¶</a></p>
<p id="appendix-A.3-5">An alternative would be to maintain an exponentially weighted
        moving average (EWMA) of the segment size:<a href="#appendix-A.3-5" class="pilcrow">Â¶</a></p>
<ul class="normal ulEmpty">
<li class="normal ulEmpty" id="appendix-A.3-6.1">s_ave = a * s + (1-a) * s_ave,<a href="#appendix-A.3-6.1" class="pilcrow">Â¶</a>
</li>
        </ul>
<p id="appendix-A.3-7">where a is the decay constant for the EWMA. However, then it
        is necessary to choose a good value for this constant, which ought to
        depend on the number of packets in flight. Also the decay constant
        needs to be power of two to avoid floating point arithmetic.<a href="#appendix-A.3-7" class="pilcrow">Â¶</a></p>
</section>
</div>
<div id="accecn_Algo_Not-ECT">
<section id="appendix-A.4">
        <h3 id="name-example-algorithm-to-count-">
<a href="#appendix-A.4" class="section-number selfRef">A.4. </a><a href="#name-example-algorithm-to-count-" class="section-name selfRef">Example Algorithm to Count Not-ECT Bytes</a>
        </h3>
<p id="appendix-A.4-1">A Data Sender in AccECN mode can infer the amount of TCP payload
        data arriving at the receiver marked Not-ECT from the difference
        between the amount of newly ACKed data and the sum of the bytes with
        the other three markings, d.ceb, d.e0b and d.e1b.<a href="#appendix-A.4-1" class="pilcrow">Â¶</a></p>
<p id="appendix-A.4-2">For this approach to be precise, it has to be assumed that spurious
        (unnecessary) retransmissions do not lead to double counting. This
        assumption is currently correct, given that RFC 3168 requires that the
        Data Sender marks retransmitted segments as Not-ECT. However, the
        converse is not true; necessary retransmissions will result in
        under-counting.<a href="#appendix-A.4-2" class="pilcrow">Â¶</a></p>
<p id="appendix-A.4-3">However, such precision is unlikely to be necessary. The only known
        use of a count of Not-ECT marked bytes is to test whether equipment on
        the path is clearing the ECN field (perhaps due to an out-dated
        attempt to clear, or bleach, what used to be the ToS field). To detect
        bleaching it will be sufficient to detect whether nearly all bytes
        arrive marked as Not-ECT. Therefore there should be no need to keep
        track of the details of retransmissions.<a href="#appendix-A.4-3" class="pilcrow">Â¶</a></p>
</section>
</div>
</section>
</div>
<div id="accecn_flags_rationale">
<section id="appendix-B">
      <h2 id="name-rationale-for-usage-of-tcp-">
<a href="#appendix-B" class="section-number selfRef">Appendix B. </a><a href="#name-rationale-for-usage-of-tcp-" class="section-name selfRef">Rationale for Usage of TCP Header Flags</a>
      </h2>
<section id="appendix-B.1">
        <h3 id="name-three-tcp-header-flags-in-t">
<a href="#appendix-B.1" class="section-number selfRef">B.1. </a><a href="#name-three-tcp-header-flags-in-t" class="section-name selfRef">Three TCP Header Flags in the SYN-SYN/ACK Handshake</a>
        </h3>
<p id="appendix-B.1-1">AccECN uses a rather unorthodox approach to negotiate the highest
        version TCP ECN feedback scheme that both ends support, as justified
        below. It follows from the original TCP ECN capability negotiation
        <span>[<a href="#RFC3168" class="xref">RFC3168</a>]</span>, in which the client set the 2 least
        significant of the original reserved flags in the TCP header, and fell
        back to no ECN support if the server responded with the 2 flags
        cleared, which had previously been the default.<a href="#appendix-B.1-1" class="pilcrow">Â¶</a></p>
<p id="appendix-B.1-2">ECN originally used header flags rather than a TCP option because
        it was considered more efficient to use a header flag for 1 bit of
        feedback per ACK, and this bit could be overloaded to indicate support
        for ECN during the handshake. During the development of ECN, 1 bit
        crept up to 2, in order to deliver the feedback reliably and to work
        round some broken hosts that reflected the reserved flags during the
        handshake.<a href="#appendix-B.1-2" class="pilcrow">Â¶</a></p>
<p id="appendix-B.1-3">In order to be backward compatible with RFC 3168, AccECN continues
        this approach, using the 3rd least significant TCP header flag that
        had previously been allocated for the ECN nonce (now historic). Then,
        whatever form of server an AccECN client encounters, the connection
        can fall back to the highest version of feedback protocol that both
        ends support, as explained in <a href="#accecn_Negotiation" class="xref">Section 3.1</a>.<a href="#appendix-B.1-3" class="pilcrow">Â¶</a></p>
<p id="appendix-B.1-4">If AccECN had used the more orthodox approach of a TCP option, it
        would still have had to set the two ECN flags in the main TCP header,
        in order to be able to fall back to Classic RFC 3168 ECN, or to
        disable ECN support, without another round of negotiation. Then AccECN
        would also have had to handle all the different ways that servers
        currently respond to settings of the ECN flags in the main TCP header,
        including all the conflicting cases where a server might have said it
        supported one approach in the flags and another approach in the new
        TCP option. And AccECN would have had to deal with all the additional
        possibilities where a middlebox might have mangled the ECN flags, or
        removed the TCP option. Thus, usage of the 3rd reserved TCP header
        flag simplified the protocol.<a href="#appendix-B.1-4" class="pilcrow">Â¶</a></p>
<p id="appendix-B.1-5">The third flag was used in a way that could be distinguished from
        the ECN nonce, in case any nonce deployment was encountered. Previous
        usage of this flag for the ECN nonce was integrated into the original
        ECN negotiation. This further justified the 3rd flag's use for AccECN,
        because a non-ECN usage of this flag would have had to use it as a
        separate single bit, rather than in combination with the other 2 ECN
        flags.<a href="#appendix-B.1-5" class="pilcrow">Â¶</a></p>
<p id="appendix-B.1-6">Indeed, having overloaded the original uses of these three flags
        for its handshake, AccECN overloads all three bits again as a 3-bit
        counter.<a href="#appendix-B.1-6" class="pilcrow">Â¶</a></p>
</section>
<section id="appendix-B.2">
        <h3 id="name-four-codepoints-in-the-syn-">
<a href="#appendix-B.2" class="section-number selfRef">B.2. </a><a href="#name-four-codepoints-in-the-syn-" class="section-name selfRef">Four Codepoints in the SYN/ACK</a>
        </h3>
<p id="appendix-B.2-1">Of the 8 possible codepoints that the 3 TCP header flags can
        indicate on the SYN/ACK, 4 already indicated earlier (or broken)
        versions of ECN support. In the early design of AccECN, an AccECN
        server could use only 2 of the 4 remaining codepoints. They both
        indicated AccECN support, but one fed back that the SYN had arrived
        marked as CE. Even though ECN support on a SYN is not yet on the
        standards track, the idea is for either end to act as a dumb
        reflector, so that future capabilities can be unilaterally deployed
        without requiring 2-ended deployment (justified in <a href="#accecn_demb_reflector" class="xref">Section 2.5</a>).<a href="#appendix-B.2-1" class="pilcrow">Â¶</a></p>
<p id="appendix-B.2-2">During traversal testing it was discovered that the ECN field in
        the SYN was mangled on a non-negligible proportion of paths. Therefore
        it was necessary to allow the SYN/ACK to feed all four IP/ECN
        codepoints that the SYN could arrive with back to the client. Without
        this, the client could not know whether to disable ECN for the
        connection due to mangling of the IP/ECN field (also explained in
        <a href="#accecn_demb_reflector" class="xref">Section 2.5</a>). This development consumed the
        remaining 2 codepoints on the SYN/ACK that had been reserved for
        future use by AccECN in earlier versions.<a href="#appendix-B.2-2" class="pilcrow">Â¶</a></p>
</section>
<div id="accecn_space_evolution">
<section id="appendix-B.3">
        <h3 id="name-space-for-future-evolution">
<a href="#appendix-B.3" class="section-number selfRef">B.3. </a><a href="#name-space-for-future-evolution" class="section-name selfRef">Space for Future Evolution</a>
        </h3>
<p id="appendix-B.3-1">Despite availability of usable TCP header space being extremely
        scarce, the AccECN protocol has taken all possible steps to ensure
        that there is space to negotiate possible future variants of the
        protocol, either if a variant of AccECN is required, or if a
        completely different ECN feedback approach is needed:<a href="#appendix-B.3-1" class="pilcrow">Â¶</a></p>
<span class="break"></span><dl class="dlParallel" id="appendix-B.3-2">
          <dt id="appendix-B.3-2.1">Future AccECN variants:</dt>
          <dd style="margin-left: 1.5em" id="appendix-B.3-2.2">
            <p id="appendix-B.3-2.2.1">When the AccECN capability
            is negotiated during TCP's 3WHS, the rows in <a href="#accecn_Tab_Negotiation" class="xref">Table 2</a> tagged as 'Nonce' and 'Broken'
            in the column for the capability of node B are unused by any
            current protocol in the RFC series. These could be used by TCP
            servers in future to indicate a variant of the AccECN protocol. In
            recent measurement studies in which the response of large numbers
            of servers to an AccECN SYN has been tested, e.g.Â <span>[<a href="#Mandalari18" class="xref">Mandalari18</a>]</span>, a very small number of SYN/ACKs arrive
            with the pattern tagged as 'Nonce', and a small but more
            significant number arrive with the pattern tagged as 'Broken'. The
            'Nonce' pattern could be a sign that a few servers have
            implemented the ECN Nonce <span>[<a href="#RFC3540" class="xref">RFC3540</a>]</span>, which has now
            been reclassified as historic <span>[<a href="#RFC8311" class="xref">RFC8311</a>]</span>, or it
            could be the random result of some unknown middlebox behaviour.
            The greater prevalence of the 'Broken' pattern suggests that some
            instances still exist of the broken code that reflects the
            reserved flags on the SYN.<a href="#appendix-B.3-2.2.1" class="pilcrow">Â¶</a></p>
<p id="appendix-B.3-2.2.2">The requirement
            not to reject unexpected initial values of the ACE counter (in the
            main TCP header) in the last para of <a href="#accecn_sec_ACE_init_invalid" class="xref">Section 3.2.2.4</a> ensures that 3 unused
            codepoints on the ACK of the SYN/ACK, 6 unused values on the first
            SYN=0 data packet from the client and 7 unused values on the first
            SYN=0 data packet from the server could be used to declare future
            variants of the AccECN protocol. The word 'declare' is used rather
            than 'negotiate' because, at this late stage in the 3WHS, it would
            be too late for a negotiation between the endpoints to be
            completed. A similar requirement not to reject unexpected initial
            values in the TCP option (<a href="#accecn_sec_zero_option" class="xref">Section 3.2.3.2.4</a>)
            is for the same purpose. If traversal of the TCP option were
            reliable, this would have enabled a far wider range of future
            variation of the whole AccECN protocol. Nonetheless, it could be
            used to reliably negotiate a wide range of variation in the
            semantics of the AccECN Option.<a href="#appendix-B.3-2.2.2" class="pilcrow">Â¶</a></p>
</dd>
          <dd class="break"></dd>
<dt id="appendix-B.3-2.3">Future non-AccECN variants:</dt>
          <dd style="margin-left: 1.5em" id="appendix-B.3-2.4">
            <p id="appendix-B.3-2.4.1">Five codepoints out of
            the 8 possible in the 3 TCP header flags used by AccECN are unused
            on the initial SYN (in the order AE,CWR,ECE): 001, 010, 100, 101,
            110. <a href="#accecn_sec_forward_compat" class="xref">Section 3.1.3</a> ensures that the
            installed base of AccECN servers will all assume these are
            equivalent to AccECN negotiation with 111 on the SYN. These
            codepoints would not allow fall-back to Classic ECN support for a
            server that did not understand them, but this approach ensures
            they are available in future, perhaps for uses other than ECN
            alongside the AccECN scheme. All possible combinations of SYN/ACK
            could be used in response except either 000 or reflection of the
            same values sent on the SYN.<a href="#appendix-B.3-2.4.1" class="pilcrow">Â¶</a></p>
<p id="appendix-B.3-2.4.2">Of course,
            other ways could be resorted to in order to extend AccECN or ECN
            in future, although their traversal properties are likely to be
            inferior. They include a new TCP option; using the remaining
            reserved flags in the main TCP header (preferably extending the
            3-bit combinations used by AccECN to 4-bit combinations, rather
            than burning one bit for just one state); a non-zero urgent
            pointer in combination with the URG flag cleared; or some other
            unexpected combination of fields yet to be invented.<a href="#appendix-B.3-2.4.2" class="pilcrow">Â¶</a></p>
</dd>
        <dd class="break"></dd>
</dl>
</section>
</div>
</section>
</div>
<div id="authors-addresses">
<section id="appendix-C">
      <h2 id="name-authors-addresses-14">
<a href="#name-authors-addresses-14" class="section-name selfRef">Authors' Addresses</a>
      </h2>
<address class="vcard">
        <div dir="auto" class="left"><span class="fn nameRole">Bob Briscoe</span></div>
<div dir="auto" class="left"><span class="org">Independent</span></div>
<div dir="auto" class="left"><span class="country-name">United Kingdom</span></div>
<div class="email">
<span>Email:</span>
<a href="mailto:ietf@bobbriscoe.net" class="email">ietf@bobbriscoe.net</a>
</div>
<div class="url">
<span>URI:</span>
<a href="http://bobbriscoe.net/" class="url">http://bobbriscoe.net/</a>
</div>
</address>
<address class="vcard">
        <div dir="auto" class="left"><span class="fn nameRole">Mirja KÃ¼hlewind</span></div>
<div dir="auto" class="left"><span class="org">Ericsson</span></div>
<div dir="auto" class="left"><span class="country-name">Germany</span></div>
<div class="email">
<span>Email:</span>
<a href="mailto:ietf@kuehlewind.net" class="email">ietf@kuehlewind.net</a>
</div>
</address>
<address class="vcard">
        <div dir="auto" class="left"><span class="fn nameRole">Richard Scheffenegger</span></div>
<div dir="auto" class="left"><span class="org">NetApp</span></div>
<div dir="auto" class="left"><span class="locality">Vienna</span></div>
<div dir="auto" class="left"><span class="country-name">Austria</span></div>
<div class="email">
<span>Email:</span>
<a href="mailto:Richard.Scheffenegger@netapp.com" class="email">Richard.Scheffenegger@netapp.com</a>
</div>
</address>
</section>
</div>
<script>const toc = document.getElementById("toc");
toc.querySelector("h2").addEventListener("click", e => {
  toc.classList.toggle("active");
});
toc.querySelector("nav").addEventListener("click", e => {
  toc.classList.remove("active");
});
</script>
</body>
</html>
