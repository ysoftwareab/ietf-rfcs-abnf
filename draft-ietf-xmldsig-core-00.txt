XML Digital Signatures Working Group               J. Reagle,
INTERNET-DRAFT                                     W3C/MIT
draft-ietf-xmldsig-core-00.txt                       D. Solo,
Expires April 14, 1999                             Citigroup

                         XML-Signature Core Syntax
                                      
Copyright Notice

   Copyright (c) 1999 The Internet Society & W3C (MIT, INRIA, Keio), All
   Rights Reserved.
   
IETF Status of this Memo
 
   This document is an Internet-Draft and is in full conformance with all
   provisions of Section 10 of RFC2026.
   
   Internet-Drafts are working documents of the Internet Engineering Task
   Force (IETF), its areas, and its working groups. Note that other
   groups may also distribute working documents as Internet-Drafts.
   
   Internet-Drafts are draft documents valid for a maximum of six months
   and may be updated, replaced, or obsoleted by other documents at any
   time. It is inappropriate to use Internet- Drafts as reference
   material or to cite them other than as "work in progress."
   
   The list of current Internet-Drafts can be accessed at
   http://www.ietf.org/ietf/1id-abstracts.txt
   
   The list of Internet-Draft Shadow Directories can be accessed at
   http://www.ietf.org/shadow.html.
   
W3C Status of this document

   This document is a production of the joint IETF/W3C XML Signature
   Working Group.
   
   http://www.w3.org/Signature
   
   The comparable html draft of this version may be found at
   
   http://www.w3.org/TR/1999/xmldsig-core-19991020
   
   The latest version of this draft series may be found at:
   
   http://www.w3.org/TR/xmldsig-core

   This is the first (and rough) public draft of this specification. This
   draft covers most of the topics the final specification will cover,
   however parts of the text and syntax within this specification are
   subject to change (and may be incorrect or inconsistent.)
   
   Please send comments to the editors and cc: the list
   <w3c-ietf-xmldsig@w3.org>. Publication as a Working Draft does not
   imply endorsement by the W3C membership or IESG. This is a draft


Reagle, Solo							[Page 1]


Internet Draft		XML-Signature Core Syntax	October 1999


   document and may be updated, replaced or obsoleted by other documents
   at any time. It is inappropriate to cite W3C Drafts as other than
   "work in progress." A list of current W3C working drafts can be found
   at http://www.w3.org/TR
   
   Patent disclosures relevant to this specification may be found on the
   WG's patent disclosure page.
   
Abstract

   This document specifies the core signature syntax  and processing
   rules of a XML signature application.
   
Table of Contents

     1. Introduction
          1.1 Editorial Conventions
          1.2 Design Philosophy
          1.3 Overview
          1.4 The Signature Element
          1.5 The SignedInfo Element
          1.6 The ObjectReference Element
          1.7 The Manifest and Package Elements
     2. Signature Structure
     3. SignatureValue
     4. SignedInfo
          4.1 CanonicalizationAlgorithm
          4.2 SignatureAlgorithm
          4.3 ObjectReference
          4.3.1 Location
          4.3.2 Type
          4.3.3 Transformations
          4.3.4 DigestAlgorithm
          4.3.5 digestvalue
     5. Object
     6. KeyInfo
     7. Algorithms
          7.1 Algorithm Identifiers and Requirements
          7.2 Message Digests
          7.3 Message Authentication Codes
          7.4 Signature Algorithms
          7.5 Canonicalization Algorithms
          7.6 Transformation Algorithms
          7.7 Algorithm References
     8. Processing rules
          8.1 Generation
          8.2 Signature Validation
     9. DTD
     10. Example syntax
     11. Open Issues
     12. Security Considerations
     13. References
     14. Acknowledgements

Reagle, Solo							[Page 2]


Internet Draft		XML-Signature Core Syntax	October 1999


     15. Other Useful Types
       
1 Introduction

   This document describes the proposed syntax and processing rules for
   the XML Digital Signature specification. This specification provides a
   mechanism for applying digital signatures to XML documents and other
   Internet resources.
   
   The structure allows for both embedded and detached signatures. An
   embedded signature can include the signature within the signed object
   or embed the signed object within the signature. A detached signature
   allows the signature to be independent of the object. The processing
   structure allows for switching between embedded and detached
   signatures without invalidating the signature.
   
   In addition to the basic signature document type, this document also
   defines other useful types including a methods of referencing multiple
   resources and key management and algorithm definitions.
   
  1.1 Editorial Conventions
  
   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
   document are to be interpreted as described in [RFC2119].
   
   The XML namespace [XML-namespace] URI that MUST be used by
   experimental implementations of this dated specification is:
   
   xmlns="http://www.w3.org/1999/10/signature-core"
   
   While applications MUST support XML-namespaces, the use of our "dsig"
   XML namespace prefix and defaulting/scoping conventions are OPTIONAL
   -- we use these facilities so as to provide compact and readable
   examples.
   
   The URI in the namespace declaration above is also used as a prefix
   for URIs which identify resources, algorithms, or semantics under
   control of this specification. We use MIME types to identify
   algorithithms, resources, or their characteristics under the control
   of IANA. Otherwise we define a URN Namespace Identifiers [RFC2141] for
   other organizations, for example: urn:ietf-org:hmac-sha1
   
   This document includes the following abbreviations for long words.
   (The acronyms are generated by wrapping the word_length-2 in the first
   and last letter):
     * c14n: canonicalization
     * i18n: internationalization
       
   Finally, this document includes a list of open issues which are still
   being addressed by the working group.
   
   Readers unfamiliar with DTD syntax may wish to refer to Ron Bourret's

Reagle, Solo							[Page 3]


Internet Draft		XML-Signature Core Syntax	October 1999


   "Declaring Elements and Attributes in an XML DTD."
   
  1.2 Design Philosophy
  
   The design philosophy and requirements of this specification are
   addressed in the XML-Signature Requirements document
   [XML-Signature-RD].
   
  1.3 Overview
  
   This section provides a general top down overview of XML digital
   signature syntax and processing.  The formal specification is provided
   in later sections. General familiarity with digital signature concepts
   and XML syntax is assumed.
   
  1.3.1 The Signature Element
  
   XML digital signatures are very flexible and may be used to apply
   signatures to any type of resource.  The object(s) being signed may be
   included within the signature, outside the signature in the same
   document, or completely outside of the document.
   
   XML digital signatures are represented by the Signature element which
   has the following structure:
   
   <Signature>
     (SignedInfo)
     (SignatureValue)
     (KeyInfo)?
     (Object)*
   </Signature>
   
   The required SignedInfo element is the information which is actually
   signed.  SignedInfo includes a digest calculated over each of the data
   objects being signed. The core signature verification includes the
   verification of these digests. The algorithms used in calculating the
   SignatureValue are also included in the signed information. The
   signature can not cover itself so the SignatureValue element is
   outside SignedInfo.
   
   KeyInfo indicates what key was used to create the signature. It is
   optional because in some applications the key is implied by the
   circumstances. A wide variety of KeyInfo forms are available including
   certificates, key names, key agreement algorithms and information,
   etc. The keying information is outside of the signed information so
   that it need not be signed. KeyInfo might contain auxiliary
   information it is not desired to reveal to all signature verifiers. If
   KeyInfo were signed, it would be necessary to pass all of it to all
   verifiers. On the other hand, if it is desired to bind the keying
   information in to the signature, its digest and a pointer to it can
   easily be included in the signed information.
   
   Object is an optional element for carrying the signed data. A

Reagle, Solo							[Page 4]


Internet Draft		XML-Signature Core Syntax	October 1999


   signature can be applied to a mix of external and embedded objects.
   The data can be optionally typed and/or encoded. While Object elements
   can appear inside a signature as show above, they can also appear
   outside of the Signature element in the same document or in other
   documents.
   
   While there is no explicit provision for "signature attributes", they
   can be included as a type of Object and thus can easily be secured or
   not as appropriate.
   
  1.3.2 The SignedInfo Element
  
   The SignedInfo element has the structure indicated below.
   
   <Signature>
     <SignedInfo>
       (CanonicalizationAlgorithm)
       (SignatureAlgorithm)
       (ObjectReference)+
     </SignedInfo>
     (SignatureValue)
     (KeyInfo)?
     (Object)*
   </Signature>
   
   The CanonicalizationAlgorithm is the algorithm which is used to
   canonicalize the SignedInfo element before it is digested as part of
   the signature operation.
   
   The SignatureAlgorithm is the algorithm used to convert the
   canonicalized SignedInfo into the SignatureValue. It is a combination
   of a digest algorithm and a key dependent algorithm such as RSA-SHA1
   or HMAC-SHA1. The algorithm names are signed to resist attacks based
   on substituting a weaker algorithm.
   
   To promote interoperability, there are mandatory to implement
   canonicalization and signature algorithms. Additional standard
   algorithms are specified as Recommended or Optional and user defined
   algorithms are permitted.
   
   The ObjectReference elements specify the things secured by the
   signature. As specified in more detail below, they point to the thing,
   specify any transformations, specify the digest algorithm, and include
   the digest value itself. It is the signing of this digest value and
   its verification as part of the signature verification that secures
   the thing pointed to.
   
   The indirect reference to secured things via the ObjectReference means
   that it is possible to change a Signature from one where the data in
   enclosed as an Object within the Signature to one where the Object
   appears elsewhere or to move a secure item between locations outside a
   Signature without invalidating the signature provided the secured data
   can still be located from the same ObjectReference.

Reagle, Solo							[Page 5]


Internet Draft		XML-Signature Core Syntax	October 1999


   
  1.3.3 The ObjectReference Element
  
   The ObjectReference element has the structure indicated below.
   
   ...
   <SignedInfo>
      (CanonicalizationAlgorithm)?
      (SignatureAlgorithm)
      <ObjectReference>
        (Location)?
        (Type)?
        (Transformations)?
        (DigestAlgorithm)
        (DigestValue)
      </ObjectReference>+
   </SignedInfo>
   ...
   
   The Location says where the secured thing is.
   
   The optional Type element provides information about the content of
   the thing at Location. In particular, it can indicate that the thing
   consists of signature attributes or is a Manifest or Package (see
   below).
   
   Transformations is an optional ordered list of processing steps that
   are applied to the thing at Location before it is digested. These
   transformations can include any number of canonicalizations, encoding
   and decoding including compression and inflation, and XPath based
   transforms. XPath transforms permit parts of an XML thing to be
   omitted. For example, if a thing being secured encloses the signature
   itself, such a transform must be used to exclude the signature from
   the data covered. If no Transformations element is present, the data
   pointed at by Location is digested directly.
   
   To promote interoperability, there are mandatory to implement
   canonicalization and coding algorithms. Additional standard
   canonicalization, coding, and XPath based transform algorithms are
   specified as Recommended or Optional and user defined transformation
   algorithms are permitted.
   
   DigestAlgorithm is the algorithm which, when applied to the thing at
   Location after Transformations is applied results in DigestValue. The
   signing of the DigestValue is what secures the thing pointed to.
   
  1.3.4 The Manifest and Package Elements
  
   There are cases where it is efficient to have one signature covering
   many items.  One approach is to include multiple object references
   within SignedInfo.  Since the core verification behavior of this
   specification includes verifying the digests of objects referenced
   within SignedInfo, some applications may need an alternative approach

Reagle, Solo							[Page 6]


Internet Draft		XML-Signature Core Syntax	October 1999


   which allows pushing the validation decision to the application.  This
   allows more complex processing to be defined on an application
   specific basis; for example, it may be sufficient if the signature's
   validity for n out of m of the items can be verified or there may be a
   large number of items that it is desired to sign with multiple
   signature algorithms and / or keys where listing all of the item
   within the SignedInfo element of each Signature is too bulky.
   
   To answer these requirements, additional objects have been defined
   which may be referenced by SignedInfo.  The Manifest element is
   provided which similarly contains a collection of references and
   objects (like SignedInfo), but leaves it entirely up to the
   application which digest or digests it will verify. Multiple
   signatures over the possibly large number of items in a Manifest need
   only point to the manifest from one ObjectReference in each
   signature's SignedInfo.
   
   The structure of Manifest, which reuses the ObjectReference and Object
   elements described above, is as follows:
   
   <Manifest>
     (ObjectReference)+
     (Object)*
   </Manifest>
   
   A Package is syntactically identical to a Manifest but asserts the
   equivalence of each of its ObjectReference elements.
   
 2.0 Signature Structure

   The general structure of an XML signature includes the following
   elements:
     * SignedInfo is the actual data over which the signature is
       calculated. It contains control information (algorithm
       identifiers, pre-processing transformations) and digest(s) over
       the object(s) being signed.
     * SignatureValue contains the actual value of the digital signature.
     * KeyInfo is an optional element which enables the recipient(s) to
       obtain the key(s) needed to validate the signature.
     * Object is an optional element wherein applications may place
       (embed) the content being signed.
       
   <!ELEMENT Signature (SignedInfo, SignatureValue, KeyInfo?, Object*)>
   <!ATTLIST SignedInfo
             Id     ID       #IMPLIED>
   
   A simple example follows:
   
   <Signature xmlns="http://www.w3.org/1999/10/signature-core">
     <SignedInfo>
       <CanonicalizationAlgorithm name="null"/>
       <SignatureAlgorithm name="dsig:dsaWithSHA-1"/>
       <ObjectReference>

Reagle, Solo							[Page 7]


Internet Draft		XML-Signature Core Syntax	October 1999


         <Location HREF="http://www.ietf.org"/>
         <Type>text/html; charset="us-ascii"</Type>
         <DigestAlgorithm name="urn:nist-gov:sha1"/>
         <DigestValue
   encoding="urn:ietf-org:base64">a23bcd43</DigestValue>
       </ObjectReference>
     </SignedInfo>
     <SignatureValue
   encoding="urn:ietf-org:base64">dd2323dd</SignatureValue>
     <KeyInfo>
        <keyname>Solo</keyname>
     </KeyInfo>
   </Signature>
   
   Note: this example will be revised to ensure hash/signature validate.
   
  3.0 SignatureValue

   The SignatureValue element contains the actual value of the digital
   signature. The ability to define a SignatureAlgorithm and
   SignatureValue pair which includes multiple distinct signatures is
   explicitly permitted (e.g. "rsawithsha-1 and ecdsawithsha-1").
   
   <!ELEMENT SignatureValue CDATA)>
   <!-- base64 encoded signature value -->
   <!ATTLIST SignatureValue
             encoding    CDATA     "urn:ietf-org:base64">
   
  4.0 SignedInfo

   The structure of SignedInfo includes a canonicalization algorithm, a
   signature algorithm, and one or more references to objects. The
   SignedInfo element may contain an optional ID attribute that will
   allow it to be referenced by other signatures and objects.
   
   <!ELEMENT SignedInfo(CanonicalizationAlgorithm, SignatureAlgorithm,
   ObjectReference+ )>
   <!ATTLIST SignedInfo
             Id     ID       #IMPLIED>
   
   SignedInfo does not include explicit signature attributes. If an
   application needs to associate attributes (such as signing time,
   signing device, etc.) with the signature, it may add an additional
   Object that includes that data and reference that Object via an
   ObjectReference.
   
 4.1 CanonicalizationAlgorithm
  
   CanonicalizationAlgorithm is a mandatory element which specifies the
   canonicalization algorithm applied to the SignedInfo element prior to
   performing signature calculations. This element uses the general
   structure here for algorithms in which an URI is included as an
   attribute naming the algorithm and optional contents of the element

Reagle, Solo							[Page 8]


Internet Draft		XML-Signature Core Syntax	October 1999


   contain any parameter, value, or other information defined by the
   algorithm name. Possible options may include a null algorithm (no
   changes), a minimal algorithm (CRLF and charset normalization), or
   more extensive operations such as [XML-C14N].  An expected default for
   this value will be defined once the specification of XML aware
   canonicalization algorithms are finalized.
   
   <!ELEMENT CanonicalizationAlgorithm ANY>
   <!ATTLIST CanonicalizationAlgorithm
             name    CDATA >
        <!-- Where CDATA conforms to the
             productions specified by [URI] -->
   
   Note: the ANY for this and all other Algorithm elements may be replace
   once a decision is reached on how to represent parameters.
   
  4.2 SignatureAlgorithm
  
   SignatureAlgorithm is a required element which specifies the algorithm
   used for signature generation and validation. This algorithm ID
   identifies all cryptographic functions involved in the signature
   operation (e.g. hashing, public key algorithms, MACs, etc.). This
   element uses the general structure here for algorithms in which a URI
   is included as an attribute naming the algorithm and optional contents
   of the element contain any parameter, value, or other information
   defined by the algorithm name. While there is a single identifier,
   that identifier may specify a format containing multiple distinct
   signature values.
   
   <!ELEMENT SignatureAlgorithm ANY>
   <!ATTLIST SignatureAlgorithm
             name    CDATA    #REQUIRED >
        <!-- Where CDATA conforms to the
             productions specified by [URI] -->
   
  4.3 ObjectReference
  
   ObjectReference  is an element that may occur one or more times. It
   includes a pointer to the object being signed, the type of the object,
   a list of transformations to be applied prior to digesting, a digest
   algorithm and digest value. Note, it is the content yielded after the
   URI is dereferenced, decoded, and transformed that the digest
   algorithm is applied to.
   
   <!ELEMENT ObjectReference (Location?, Type?, Transformations?,
   DigestAlgorithm, DigestValue) >
   
  4.3.1 Location
  
   Location identifies where to find the Object using a URI. As the terms
   are defined in RFC2396 [URI], some URIs are used in conjunction with a
   fragment identifier by use of a separating hash (#), but the URI does
   not include the fragment identifier. Location only permits a URI, and

Reagle, Solo							[Page 9]


Internet Draft		XML-Signature Core Syntax	October 1999


   fragment identification is covered under Transformations.  If this
   element is omitted, then the receiving application is expected to be
   able to determine the object to which the signature applies (for
   example, this approach might be used in associated a signature with a
   lightweight protocol data unit).  The location may be omitted only if
   there is a single object reference.  If there are multiple object
   references, they each must contain an explicit location.
   
   <!ELEMENT Location CDATA>
   <!-- The content conforms to the productions specified by [URI] -->
   
   If the URI indicates an XML document, the document is assumed to be
   unparsed prior to the application of Transformations. If there are no
   Transformations, then the indicated resource is passed to the digest
   algorithm unmodified.
   
  4.3.2 Type
  
   Type is an optional element which contains information about the type
   of object being signed (e.g. manifest, package, document, SignedInfo,
   PDF file). This may be represented as a name (e.g. MIME type), or
   URI.  The type element is intended to be advisory for an application
   to assist in processing objects.  While the type element in
   ObjectReference should match the type attribute, if present, in
   object; such a check is not required.
   
   <!ELEMENT Type CDATA >
       <!--  where PCDATA conforms to the productions specified for the
             content of a Content-Type MIME header [RFC 2045] or is
             a namespace qualified element name or conforms to the
             productions specified by [URI] -->
   
   Type is an optional element which contains information about the type
   of object being signed (e.g. manifest, package, document, SignedInfo,
   PDF file). This may be represented as a name (e.g. MIME type), or URI.
   For example:
   
   <Type>text/plain; charset="us-ascii"</Type>
   <Type>http://www.w3.org/1999/10/signature-core/manifest</Type>
   <Type>urn:ietf-org:hmac-sha1</Type>
   
  4.3.3 Transformations
  
   Transformations is an optional element that contains one or more
   operations to be performed on the Object prior to signature
   calculation. Examples of Transformations include encoding,
   canonicalization, XPointer, XSLT, filtering, encoding, etc. (These
   operations are applied to the reference object as contrasted with
   those specified in the signature which are applied to signedinfo.)
   Transformations are applied in the order they appear, from left to
   right.  In additiona, more than one instance of a particular
   transformation may appear (e.g. encode, canonicalize, encode).  No
   transformations are applied other than those explicitly identified

Reagle, Solo							[Page 10]


Internet Draft		XML-Signature Core Syntax	October 1999


   (i.e., there are no default transformations).
   
   Each element within Transformations uses the general structure here
   for algorithms in which a URI is included as a value specifying the
   algorithm and optional contents of the element contain any parameter,
   value, or other information defined by the algorithm name.
   
   Note that when transformations are applied the signer is not signing
   the native (original) document but the resulting (transformed)
   document. Where transformation processes are well known and widely
   implemented an application might include native content and specify
   transformations by reference. Otherwise, an application may perform
   transformations on the content itself and use the resulting content
   within the signature.
   
   <!ELEMENT Transformations (Generic | CanonicalizationAlgorithm |
   Encoding
             | XSLT Stylesheet | XPointer)*) >
   
   <!ELEMENT Generic ANY >
   <!ATTLIST Generic
             name    CDATA    #REQUIRED >
   
   <!-- While not necessary because of the Generic, we
   define a few specific transformation types.
   
   <!ELEMENT Encoding ANY >
   <!ATTLIST Encoding
             name    CDATA    #REQUIRED >
   
   <!ELEMENT CanonicalizationAlgorithm ANY >
   <!ATTLIST CanonicalizationAlgorithm
             name    CDATA    #REQUIRED >
   
   <!ELEMENT XSLT ANY >
   <!ATTLIST XSLT
             name    CDATA    #REQUIRED >
   
   <!ELEMENT Stylesheet ANY >
   <!ATTLIST Stylesheet
             name    CDATA    #REQUIRED >
   
   <!ELEMENT XPointer ANY >
   <!ATTLIST XPointer
             name    CDATA    #REQUIRED >
   
        <!-- Where CDATA conforms to the
             productions specified by [URI] -->
   
  4.3.4 DigestAlgorithm
  
   DigestAlgorithm is a required element which identifies the digest
   algorithm to be applied to the signed object. This element uses the

Reagle, Solo							[Page 11]


Internet Draft		XML-Signature Core Syntax	October 1999


   general structure here for algorithms in which a URI is included as an
   attribute naming the algorithm and optional contents of the element
   contain any parameter, value, or other information defined by the
   algorithm name.
   
   <!ELEMENT DigestAlgorithm ANY>
   <!ATTLIST DigestAlgorithm
              name     CDATA   #REQUIRED >
        <!-- Where CDATA conforms to the
             productions specified by [URI] -->
   
  4.3.5 digestvalue
  
   digestvalue is an element which contains the base64 encoded value of
   the digest.
   
   <!ELEMENT DigestValue CDATA>
   <!ATTLIST DigestValue
             encoding    CDATA     "urn:ietf-org:base64">
   
5.0 Object

   Object is an optional element which may occur one or more times. When
   present this element may contain any item and specifies the encoding.
   The digest is calculated over the entire Object element including
   start and end tags.  If the application wishes to exclude the <object>
   tags from the digest calculation, then a transformation must be used.
   Exclusion of the object tags may be desired for cases where the
   signature is intended to survive a change between embedded and
   detached objects.
   
   <!ELEMENT Object ANY>
   <!ATTLIST Object
             Id    CDATA    #IMPLIED
             Type  CDATA    #IMPLIED
             Encoding       CDATA   #IMPLIED >
        <!-- Where type and encoding CDATA conforms to the
             productions specified by [URI] -->
   
   The Object's ID is referenced from the ObjectReference in SignedInfo.
   This element is used for embedded signatures where the object being
   signed is to be included in the signature document. The Object element
   may include optional type, ID, and encoding attributes.
   
6.0 KeyInfo

   KeyInfo may contain keys, names, certificates and other public key
   management information (such as inband key distribution or agreement
   data or use any other method.) This specification defines a few simple
   types but  applications may place (embed) their own key identification
   and exchange semantics within this element through the XML-namespace
   facility. [XML-namespace]
   

Reagle, Solo							[Page 12]


Internet Draft		XML-Signature Core Syntax	October 1999


   <!ELEMENT KeyInfo  (#PCDATA | (KeyName | KeyValue |
             SubjectName | RetrievalMethod | x509Data |
             PGPData | MgmtData)* )>
   
   KeyInfo is an optional element which enables the recipient(s) to
   obtain the key(s) needed to validate the signature. If omitted, the
   recipient is expected to be able to identify the key based on
   application context information. This element contains one or more
   KeyInfo data elements providing information for the recipient(s).
   Applications may define and use any mechanism they choose through
   inclusion of elements from a different namespace.
     * KeyName contains an identifier for the key which may be useful to
       the recipient. This may be a name, index, etc.
     * KeyValue contains the actual key(s) used to validate the
       signature. If the key is sent in protected form, the MgmtData
       element should be used. Specific types must be defined for each
       algorithm type (see algorithms).
     * SubjectName contains one or more names for the sender. Forms to be
       supported include a simple name string, encoded DN, email address,
       etc.
     * RetrievalMethod is a URI which may be used to obtain key and/or
       certificate information. The URI should contain the complete
       string for retrieving the key needed for this message (rather than
       a generic URI).
     * X509Data contains an identifier of the key/cert used for
       validation (either an issuerserial value, a subject name, or a
       subjectkeyID) and an optional collection of certificates and
       revocation/status information which may be used by the recipient.
       issuerserial contains the encoded issuer name (RFCxxxx) along with
       the serial number.
     * PGPData data associated with a PGP key.
     * MgmtData contains in-band key distribution or agreement data.
       Examples may include DH key exchange, RSA key encryption etc.
       
   <!ELEMENT KeyName (#PCDATA)>
   <!ELEMENT KeyValue (#PCDATA)>
   <!ELEMENT SubjectName (#PCDATA)>
   <!ELEMENT RetrievalMethod (#PCDATA)>
   <!ELEMENT X509Data (#PCDATA)>
   <!ELEMENT MgmtData (#PCDATA)>
   
   Note:  This section is preliminary.  A more detailed version will be
   included in a subsequent version of this specification.
   
7.0 Algorithms

   This sections identifies algorithms used with the XML digital
   signature standard. Entries contain the identifier to be used in
   signature documents, a reference to the formal specification, and
   definitions, where applicable, for the representation of keys and the
   results of cryptographic operations.
   
  7.1 Algorithm Identifiers and Requirements

Reagle, Solo							[Page 13]


Internet Draft		XML-Signature Core Syntax	October 1999


  
   The specification defines a set of algorithms, their URIs, and
   requirements for implementation. Requirements are specified over
   implementation, not over requirements for signature use. Furthermore,
   the mechanism is extensible, alternative algorithms may be used by
   signature applications.
   
   Algorithm Type Algorithm Requirements Algorithm URI URN Derivation
   Digest
     SHA1 REQUIRED urn:nist-gov:sha1 IOTP
   Encoding
     Base64 REQUIRED urn:ietf-org:base64 suggested
   MAC
     HMAC-SHA1 REQUIRED urn:ietf-org:hmac-sha1 extrapolated from IOTP
   Signature
     DSAwithSHA1 (DSS) REQUIRED urn:nist-gov:dsa IOTP
     RSAwithSHA1 RECOMMENDED urn:rsasdi-com:rsa-sha1 extrapolated from
   IOTP
     ECDSA OPTIONAL urn:nist-gov:ecdsa extrapolated from IOTP
   Canonicalization
     :null REQUIRED http://www.w3.org/1999/10/signature-core/null
   suggested W3C
     minimal REQUIRED http://www.w3.org/1999/10/signature-core/minimal
   suggested W3C
     XML-Canonicalization RECOMMENDED
   http://www.w3.org/1999/07/WD-xml-c14n-19990729 W3C
   Transformation
     XSLT RECOMMENDED http://www.w3.org/TR/1999/PR-xslt-19991008 W3C
     XPath RECOMMENDED http://www.w3.org/TR/1999/PR-xpath-19991008 W3C
     XPointer RECOMMENDED http://www.w3.org/1999/07/WD-xptr-19990709 W3C
   
  7.2 Message Digests
  
    7.2.1 SHA-1
    
   The SHA-1 algorithm identifier is urn:nist-gov:sha1. The SHA-1
   algorithm takes no parameters. An example of an SHA-1 DigestAlg
   element is
   
   <DigestAlgorithm name="urn:nist-gov:sha1"/>
   
   An SHA-1 digest is a 160-bit string. The content of the DigestValue
   element shall be the base64 encoding of this bit string viewed as an
   20-octet octet stream. Example: the DigestValue element for the
   message digest
   
   A9993E36 4706816A BA3E2571 7850C26C 9CD0D89D
   
   from Appendix A of the SHA-1 standard would be
   
   <DigestValue>qZk+NkcGgWq6PiVxeFDCbJzQ2J0=</DigestValue>
   
  7.3 Message Authentication Codes

Reagle, Solo							[Page 14]


Internet Draft		XML-Signature Core Syntax	October 1999


  
    7.3.1 HMAC
    
   The HMAC algorithm identifiers are urn:ietf-org:hmac-sha1 and
   urn:ietf-org:hmac-md5. The HMAC algorithm takes the truncation length
   in bits as a parameter (parameter identifier
   urn:ietf-org:hmac-outputlength).   An example of an HMAC SignatureAlg
   element:
   
   <SignatureAlgorithm name="urn:ietf-org:hmac-sha1">
     <Parameter type="urn:ietf-org:hmac-outputlength">
        128
     </Parameter>
   </SignatureAlg>
   
   The output of the HMAC algorithm is ultimately the output (possibly
   truncated) of the chosen digest algorithm. This value shall be base64
   encoded in the same straightforward fashion as the output of the
   digest algorithms. Example: the SignatureValue element for the
   HMAC-MD5 digest
   
   9294727A 3638BB1C 13F48EF8 158BFC9D
   
   from the test vectors in RFC 2104 would be
   
   <SignatureValue>kpRyejY4uxwT9I74FYv8nQ==</SignatureValue>
   
  7.4 Signature Algorithms
  
    7.4.1 DSA
    
   The DSA algorithm identifier is urn:nist-gov:dsa. The DSA algorithm
   takes no parameters. An example of a DSA SignatureAlg element is
   
   <SignatureAlgorithm name="urn:nist-gov:dsa"/>
   
   The output of the DSA algorithm consists of a pair of integers usually
   referred by the pair (r, s). The signature value shall consist of the
   base64 encoding of the concatenation of two octet-streams that
   respectively result from the octet-encoding of the values r and s.
   Integer to octet-stream conversion shall be done according to the
   I2OSP operation defined in the PKCS #1 specification with a k
   parameter equal to 20. Example: the SignatureValue element for a DSA
   signature (r, s) with values specified in hexadecimal
   
   r = 8BAC1AB6 6410435C B7181F95 B16AB97C 92B341C0
   s = 41E2345F 1F56DF24 58F426D1 55B4BA2D B6DCD8C8
   
   from the example in Appendix 5 of the DSS standard would be
   
   <SignatureValue>i6watmQQQ1y3GB+VsWq5fJKzQcBB4jRfH1bfJFj0JtFVtLotttzYyA
   ==</SignatureValue>
   

Reagle, Solo							[Page 15]


Internet Draft		XML-Signature Core Syntax	October 1999


    7.4.2 RSA
    
   The expression "RSA algorithm" as used in this document refers to the
   RSASSA-PKCS1-v1_5 algorithm described in RFC 2437.
   
   The RSA algorithm identifiers are urn:rsasdi-com:rsa-sha1 and
   urn:rsasdi-com:rsa-md5. The RSA algorithm takes no parameters. An
   example of an RSA SignatureAlg element is
   
   <SignatureAlgorithm name="urn:rsasdi-com:rsa-sha1"/>
   
   The output of the RSA algorithm is an octet string. The SignatureValue
   content for an RSA signature shall be the base64 encoding of this
   octet string. Example: <insert example here>
   
    7.4.3 ECDSA
    
   The expression ECDSA as used in this document refers to the signature
   algorithms specified in ANSI X9.62.  Additional details are to be
   provided.
   
  7.5 Canonicalization Algorithms
  
    7.5.1 Null Canonicalization
    
   The algorithm identifier for the null canonicalization is
   http://www.w3.org/1999/10/signature-core/null.  An example of a null
   canonicalization CanonicalizationAlgorithm element is
   
   <CanonicalizationAlgorithm
   name="http://www.w3.org/1999/10/signature-core/null"/>
   
   The null canonicalization produces a message byte-for-byte identical
   with the original resource. No character set, line ending, or white
   space normalization is done.
   
   This algorithm is appropriate for applications where the resource to
   be signed is not XML, or where the XML document will be exactly
   preserved. For many applications, one of the other canonicalization
   algorithms will be more appropriate.
   
    7.5.2 Minimal Canonicalization
    
   The algorithm identifier for the minimal canonicalization is
   http://www.w3.org/1999/10/signature-core/minimal. An example of a
   minimal canonicalization CanonicalizationAlg element is
   
   <CanonicalizationAlgorithm
   name="http://www.w3.org/1999/10/signature-core/minimal"/>
   
   The minimal canonicalization algorithm:
     * converts the character encoding to UTF-8, removing the encoding
       pseudo-attribute

Reagle, Solo							[Page 16]


Internet Draft		XML-Signature Core Syntax	October 1999


     * normalizes line endings
       
   This algorithm is only applicable to XML resources.
   
    7.5.3 Canonical XML
    
   The algorithm identifier for XML canonicalization is
   http://www.w3.org/1999/07/WD-xml-c14n-19990729. An example of an XML
   canonicalization CanonicalizationAlg element is
   
   <CanonicalizationAlgorithm
   name="http://www.w3.org/1999/07/WD-xml-c14n-19990729"/>
   
   See the Canonical XML specification.
   
  7.6 Transformation Algorithms
  
   Application developers are strongly encouraged to support all
   transformations listed in this section as RECOMMENDED unless the
   application environment has severe resource constraints that would
   make such support impractical. The working group goal is to maximize
   application interoperability on XML signatures, and the working group
   expects ubiquitous availability of software to support these
   transformations that can be incorporated into applications without
   extensive development.
   
    7.6.1 Canonicalization
    
   The Algorithm value for canonicalization are defined above.
   
   The Transformation element content MUST include a Canonicalization
   element, which specifies the canonicalization algorithm that will be
   applied to the input of the Transformation element.
   
    7.6.2 Base-64 Decoding
    
   The Algorithm value for the base 64 decoding transformation is
   urn:ietf-org:base64.
   
   The base-64 decoding algorithm identifier is urn:ietf-org:base64.
   
   The base-64 Transformation element has no content. The input (from the
   Location or from the previous Transformation) is base-64 decoded. This
   transformation is useful if an application needs to sign the raw data
   associated with base-64 encoded content of an element.
   
    7.6.3 XPath Filtering
    
   The Algorithm value for the XPath filtering transformation is
   "http://www.w3.org/TR/1999/PR-xpath-19991008"
   
   The Transformation element content MUST conform to the XML Path
   Language (XPath) syntax.

Reagle, Solo							[Page 17]


Internet Draft		XML-Signature Core Syntax	October 1999


   
   XPath assumes that an XML processor has processed the input resource.
   So, for example, entity reference expansion, normalization of
   linefeeds and attribute values are normalized, and CDATA section
   replacement are expected. As well, XPath joins all consecutive
   characters into a single text node.
   
   The input resource MUST be a well-formed XML document. The result of
   applying the XPath to the input resource MUST be a node-set (as
   defined in XPath). The output of this transformation is a new XML
   document with the following characteristics:
    1. The output document has the XML declaration of the input resource
       (see rule 23 XMLDecl in XML specification). If the encoding is
       UTF-16, the output document has the same byte order mark as the
       input resource.
    2. The output document contains the nodes in the node-set identified
       by the XPath, and excludes the nodes of the input resource that
       are not not in the node-set identified by the XPath.
    3. The nodes in the output document appear in the document order (as
       defined in XPath) of the input resource.
    4. The output document has all of the input resource's entity
       references expanded, except that characters corresponding to
       illegal XML are reencoded as character references (XML rule 66)
       except the ampersand and less than symbol, which are encoded using
       &amp; and &lt;, respectively.
    5. Attribute values are normalized in accordance with the rules for a
       validating XML processor (even if the implementation did not use a
       validating XML processor to parse the input resource).
       
   It is RECOMMENDED that the XPath be constructed such that the result
   of this operation is a well-formed XML document. This should be the
   case if root element of the input resource is included by the XPath
   (even if a number of its descendant elements and attributes are
   omitted by the XPath).
   
    7.6.4 XPointer Filtering
    
   The Algorithm value for the XPointer filtering transformation is
   "http://www.w3.org/1999/07/WD-xptr-19990709".
   
   The Transformation element content MUST conform to the XML Pointer
   Language (XPointer) syntax.
   
   The processing rules for XPointer filtering are identical to those for
   XPath filtering (stated above), except that the additional
   functionality offered by XPointer can be utilized in constructing the
   output node-set.
   
   The XPointer filter is particularly important if the input resource is
   processed by a validating XML processor since the XPointer barename
   shortcut could then be used to implement the well-known fragment
   identification by ID attribute.
   

Reagle, Solo							[Page 18]


Internet Draft		XML-Signature Core Syntax	October 1999


   NOTE: In application environments with severe resource limitations,
   applications MAY constrain XPointer support to barename processing and
   also to determination of the ID attribute by means other than a
   validating XML processor. In fact, the use of an XML processor for
   barename resolution is OPTIONAL. However, the output expectations of
   this transformation MUST be supported by the application.
   
    7.6.5 XSLT Transformation
    
   The Algorithm value for the XSLT transformation is
   "http://www.w3.org/TR/1999/PR-xslt-19991008"
   
   The Transformation element content MUST conform to the XSL
   Transformations (XSLT) language syntax.
   
   The processing rules for the XSLT transformation are stated in the
   XSLT specification.
   
    7.6.6 Java Transformation
    
   The Algorithm value for the Java transformation is urn:ECMA-org:java.
   
   Details to be determined.
   
   Although the Algorithm attribute of a Transformation can take
   application-specific values, having a Java transformation seems to be
   the most reasonable way to allow application-specific transformations
   that can be processed outside of the application domain.
   
  7.7. Algorithm References
  
   Base64
          RFC 2045. Multipurpose Internet Mail Extensions (MIME) Part
          One: Format of Internet Message Bodies. N. Freed & N.
          Borenstein. DRAFT STANDARD.
          http://www.ietf.org/rfc/rfc2045.txt
          
   DSS
          FIPS PUB 186-1. Digital Signature Standard (DSS). U.S.
          Department of Commerce/National Institute of Standards and
          Technology.
          http://www.ietf.org/rfc/rfc2104.txt
          
   HMAC
          RFC 2104. HMAC: Keyed-Hashing for Message Authentication. H.
          Krawczyk, M. Bellare, R. Canetti. INFORMATIONAL.
          
   MD5
          RFC 1321. The MD5 Message-Digest Algorithm. R. Rivest.
          INFORMATIONAL.
          http://www.ietf.org/rfc/rfc1321.
          
   RSA

Reagle, Solo							[Page 19]


Internet Draft		XML-Signature Core Syntax	October 1999


          RFC 2437. PKCS #1: RSA Cryptography Specifications Version 2.0.
          B. Kaliski, J. Staddon. INFORMATIONAL.
          http://www.ietf.org/rfc/rfc2432.txt
          
   SHA-1
          FIPS PUB 180-1. Secure Hash Standard. U.S. Department of
          Commerce/National Institute of Standards and Technology.
          http://csrc.nist.gov/fips/fip180-1.pdf
          
   URNs
          RFC 2141. URN Syntax. R. Moats. PROPOSED STANDARD.
          ftp://ftp.isi.edu/in-notes/rfc2141.txt
          RFC 2611. URN Namespace Definition Mechanisms. L. Daigle, D.
          van Gulik, R. Iannella, P. Falstrom. BEST CURRENT PRACTICE.
          ftp://ftp.isi.edu/in-notes/rfc2611.txt
          
   XML-Canonicalization
          Canonical XML. W3C Working Draft
          http://www.w3.org/1999/07/WD-xml-c14n-19990729
          
   XPath
          XML Path Language (XPath)Version 1.0. W3C Proposed
          Recommendation
          http://www.w3.org/TR/1999/PR-xpath-19991008
          
   XPointer
          XML Pointer Language (XPointer). W3C Working Draft.
          http://www.w3.org/1999/07/WD-xptr-19990709
          
   XSL
          Extensible Stylesheet Language (XSL) W3C Working Draft
          http://www.w3.org/TR/1999/WD-xsl-19990421
          
   XSLT
          XSL Transformations (XSLT) Version 1.0. W3C Proposed
          Recommendation
          http://www.w3.org/TR/1999/PR-xslt-19991008
          
8.0 Processing rules

   These sections describe the operations to be performed as part of
   signature generation and validation. The description is of a logical
   behavior and does not specify an order of execution, nor specify
   discrete steps.
   
  8.1 Generation
  
    1. apply Transformations determined by application to each object
       being signed.
    2. calculate digest over each transformed object (including start and
       end tags)
    3. create ObjectReference element(s) including location of object,
       digest, digest algorithm, and transformation elements, if

Reagle, Solo							[Page 20]


Internet Draft		XML-Signature Core Syntax	October 1999


       required.
    4. create SignedInfo element with SignatureAlgorithm,
       CanonicalizationAlgorithm, and ObjectReference(s).
    5. canonicalize and calculate signature over SignedInfo based on
       algorithms in step d.
    6. construct signature document with SignedInfo, Object (s) (if
       desired, encoding may be different than that used for signing),
       KeyInfo (if required), and SignatureValue.
       
  8.2 Signature Validation
  
    1. locate object and apply Transformations  to the specified resource
       based on each ObjectReference(s) in the SignedInfo element.  Each
       transformation is applied in order from left to right to the
       object with the output of each transformation being the input to
       the next.
    2. calculate digest over each transformed signed object(s) (including
       start and end tags) based on the algorithm in ObjectReference(s).
    3. compare value against DigestValue in SignedInfo for each reference
       (if any mismatch, validation fails).
    4. canonicalize the SignedInfo element based on the
       CanonicalizationAlgorithm in SignedInfo.
    5. obtain the validation keying info from KeyInfo or externally.
    6. validate the SignatureValue based on the SignatureAlgorithm in the
       SignedInfo element, the key obtained in step e, and the results of
       step d. - Digest calculation is performed over the SignedInfo
       element including start and end tags.
       
   Any processing beyond cryptographic validation (e.g. certificate
   validation, applicability decisions, time related processing) is
   outside the scope of this specification.
   
9 DTD

   [TBD: Combined DTD]
   
10.0 Example syntax

   <Signature xmlns="http://www.w3.org/1999/10/signature-core">
     <SignedInfo Id="5">
       <CanonicalizationAlgorithm name="null"/>
       <SignatureAlgorithm name="urn:nist-gov:dsa"/>
       <ObjectReference>
         <Location HREF="..."/>
           <!-- pointer to external signedobject   -->
         <Type>text/plain; charset="us-ascii"</Type>
         <Transformations>
            <CanonicalizationAlgorithm
   name="http://www.w3.org/1999/10/signature-core/null">
            <Encoding name="urn:ietf-org:base64"/>
         </Transformations>
         <DigestAlgorithm Algorithm="urn:nist-gov:sha1"/>
         <DigestValue>a23bcd43"</DigestValue>

Reagle, Solo							[Page 21]


Internet Draft		XML-Signature Core Syntax	October 1999


       </ObjectReference>
       <ObjectReference>
         <Location HREF="#timestamp"/> <!-- points to Object below -->
         <Type
   type="http://www.w3.org/1999/10/signature-core/signatureattributes"/>
         <Transformations>
            <CanonicalizationAlgorithm name="http://..."/>
         </Transformations>
         <DigestAlgorithm Algorithm="urn:nist-gov:sha1"/>
         <DigestValue>a53uud43"</DigestValue>
       </ObjectReference>
     </SignedInfo>
     <SignatureValue
   encoding="urn:ietf-org:base64">dd2323dd</SignatureValue>
     <Object id="timestamp"
   
   type="http://www.w3.org/1999/10/signature-core/signatureattributes " >
       <timestamp about="#5" xmlsn="http://www.ietf.org/rfc/1234">
         <date>19990908</date>
         <time>14:34:34:34</time>
       </timestamp>
     </Object>
     <KeyInfo>
        <keyname>Solo</keyname>
     </keyinfo>
   </Signature>
   
11.0 Open Issues

    1. Additional review is required on use of the dsig namespace; other
       use of namespaces; specification of types; etc.
    2. Need to review Default CanonicalizationAlgorithm algorithms for
       SignedInfo and for objects. Other defaults. Mandatory to implement
       cryptographic algorithms.
    3. Much more detail for KeyInfo types.
    4. How to represent optional parameters for all algorithms.
       Candidate choices include (EMPTY | Parameter+) where Parameter has
       a name attribute and is of type ANY; or allowing multiple elements
       such as <keySize>128</keySize>.
    5. Make sure we are consistent with respect to types, algorithm IDs,
       URIs, etc.
    6. The signature data structures specified in this document are not
       yet associated with a data model.
       
12.0 Security Considerations

   The XML digital signature standard provides a very flexible
   mechanism.  In designing a system to make use of it, due consideration
   should be given to the threat model being defended against and to the
   factors covered in the subsections below.
   
    Only What is Signed is Secure
    

Reagle, Solo							[Page 22]


Internet Draft		XML-Signature Core Syntax	October 1999


   The flexible Transformations mechanism, including canonicalization and
   explicit filtering and extraction, permit securing only a subset of
   data in an object. This is good for many applications where a limited
   portion of an object must change after the signature or different
   signatures secure different parts or the application modifies aspects
   of the object that are not significant and can be omitted from
   signature coverage or the like.   Keep in mind that whenever this is
   done, those aspects that are not signed can be arbitrarily modified
   and the signature will still validate.
   
    Only What is "Seen" Should be Signed
    
   If signing is intended to convey the judgment or consent of an
   automated mechanism or person concerning some information, then it is
   normally necessary to secure as exactly as possible the information
   that was presented to that mechanism or person.  Note that this can be
   accomplished by literally signing what was presented, for example the
   screen images shown a user.  However, this may result in data which it
   is difficult for subsequent software to manipulate.  It can be
   effective instead to secure the full data along with whatever filters,
   style sheets, or the like were used to control the part of the
   information that was presented.
   
    Check the Security Model
    
   This standard specifies public key signatures and secret key keyed
   hash authentication codes.  These have substantially different
   security models. Furthermore, it permits user specified additions
   which may have other models.
   
   With public key signatures, any number of parties can hold the public
   key and verify signatures while only the parties with the secret key
   can create signatures.  The number of holders of the secret key should
   be minimized and preferably be one.  Confidence by verifiers in the
   public key they are using and its binding to the entity or
   capabilities represented by the corresponding secret key is an
   important issue, usually addressed by certificate or on line authority
   systems.
   
   Keyed hash authentication codes, based on secret keys, are typically
   much more efficient in terms of the computational effort required but
   have the characteristic that all verifiers need to have possession of
   the same key as the signer.  Thus any verifier can forge signatures.
   
   This standard permits user provided signature algorithms and keying
   information designators.  Such user provided algorithms may have
   further different security models.  For example, methods involving
   biometrics usually depend on a "key" which is a physical
   characteristic of the user and thus can not be changed the way public
   or secret keys can be and may have other security model differences.
   
    Algorithms, Key Lengths, Etc.
    

Reagle, Solo							[Page 23]


Internet Draft		XML-Signature Core Syntax	October 1999


   The strength of a particular signature depends on all links in the
   security chain.  This includes the signature and digest algorithms
   used, the strength of the key generation [RFC 1750] and the size of
   the key, the security of key and certificate authentication and
   distribution mechanisms, protection of all cryptographic processing
   from hostile observation and tampering, etc.  The security of an
   overall system would also depend on the security and integrity of its
   operating procedures, its personnel, and on the administrative
   enforcement of those procedures.  The factors listed in this
   paragraph, while critical to the overall security of a system, are
   mostly beyond the scope of this document.
   
13.0 References
  
   Other references can be found in section7.7 .
   
   DOMHASH
          Internet Draft. Digest Values for DOM (DOMHASH)
          http://search.ietf.org/internet-drafts/draft-hiroshi-dom-hash-0
          1.txt .
          
   RDF
          RDF Schema
          http://www.w3.org/TR/1999/PR-rdf-schema-19990303
          RDF Model and Syntax
          http://www.w3.org/TR/1999/REC-rdf-syntax-19990222
          
   [RFC2119]
          RFC2119 -- Key words for use in RFCs to Indicate Requirement
          Levels.
          http://www.ietf.org/rfc/rfc2119.txt
          
   URI
          Uniform Resource Identifiers (URI): Generic Syntax
          http://www.ietf.org/rfc/rfc2396.txt
          
   XLink
          XML Linking Language
          http://www.w3.org/1999/07/WD-xlink-19990726
          
   XML
          Extensible Markup Language (XML) Recommendation.
          http://www.w3.org/TR/1998/REC-xml-19980210
          
   XML-namespace
          Namespaces in XML
          http://www.w3.org/TR/1999/REC-xml-names-19990114
          
   XML-schema
          XML Schema Part 1: Structures
          http://www.w3.org/1999/05/06-xmlschema-1/
          XML Schema Part 2: Datatypes
          http://www.w3.org/1999/05/06-xmlschema-2/

Reagle, Solo							[Page 24]


Internet Draft		XML-Signature Core Syntax	October 1999


          
   XML-Signature-RD
          XML-Signature Requirements
          http://www.w3.org/1999/08/WD-xmldsig-requirements-990820
          
   WebData
          Web Architecture: Describing and Exchanging Data.
          http://www.w3.org/1999/04/WebData
          
14.0 Acknowledgements

     * Milton Anderson, FSTC
     * Mark Bartel, JetForm Corporation
     * John Boyer, UWI.com
     * Richard Brown, Globeset
     * Donald Eastlake 3rd, IBM
     * Barb Fox, Microsoft
     * Phillip Hallam-Baker, VeriSign Inc
     * Joseph Reagle, W3C
     * Ed Simon , Entrust Technologies Inc.
     * Chris Smithies, PenOp
     * David Solo, Citigroup
     * Winchel Todd Vincent III, GSU
     * Greg Whitehead, Signio Inc.
       
15.0 Other Useful Types

   We define the following types for use in identifying XML resources
   that include Signture semantics.
   
   http://www.w3.org/1999/10/signature-core/signatureattributes
          designates that the referenced resource is a statement about
          the referring signature.
          
   http://www.w3.org/1999/10/signature-core/manifest
          designates that the referenced resource is a collection of
          other resources.
          
   http://www.w3.org/1999/10/signature-core/package
          designates that the referenced resources is a collection of
          other resources and the creator of that collection asserts that
          the specified resources, when transformed as specified, yield
          the same exact content.










Reagle, Solo							[Page 25]

