flag = 0x60 - 2 bytes in this block were guessed correctly, 5 and 6.
     Reconstructed data is:    0 1 2 3 4 5 6 7
        File:                  A A A A A
        Guess table:                     A A
flag = 0x60 - 2 bytes in this block were guessed correctly, 5 and 6.
     Reconstructed data is:    0 1 2 3 4 5 6 7
        File:                  A A A A A
        Guess table:                     A A
flag = 0x6f - 6 bytes in this block were guessed correctly, 0-3, 5 and 6.
     Reconstructed data is:    0 1 2 3 4 5 6 7
        File:                          A
        Guess table:           A A A A   A A
flag = 0x6f - 6 bytes in this block were guessed correctly, 0-3, 5 and 6.
     Reconstructed data is:    0 1 2 3 4 5 6 7
        File:                          A
        Guess table:           A A A A   A A
flag = 0x41 - 2 bytes in this block were guessed correctly, 0 and 6.
     Reconstructed data is:    0 1 2 3 4 5 6 7
        File:                    B A B A B
        Guess table:           A           A
flag = 0x60 - 2 bytes in this block were guessed correctly, 5 and 6.
     Reconstructed data is:    0 1 2 3 4 5 6 7
        File:                  B A B A B
        Guess table:                     A B
flag = 0x60 - 2 bytes in this block were guessed correctly, 5 and 6
     Reconstructed data is:    0 1 2 3 4 5 6 7
        File:                  x x x x x
        Guess table:                     x x

   And now, on to the source - note that it has been modified to work
   with a split block. If your data stream can't be split within a block
   (e.g., compressing packets), then the code dealing with "final", and
   the memcpy are not required.  You can detect this situation (or
   errors, for that matter) by observing that the flag byte indicates
   that more data is required from the compressed data stream, but you
   are out of data (len in decompress is <= 0). It *is* ok if len == 0,
   and flags indicate guess table usage.

   #include <stdio.h>
   #ifdef __STDC__
   #include <stdlib.h>
   #endif
   #include <string.h>
   /*
    * pred.c -- Test program for Dave Rand's rendition of the
    * predictor algorithm
    * Updated by: iand@labtam.labtam.oz.au (Ian Donaldson)
    * Updated by: Carsten Bormann <cabo@cs.tu-berlin.de>
    * Original  : Dave Rand <dlr@bungi.com>/<dave_rand@novell.com>
    */

   /* The following hash code is the heart of the algorithm:
    * It builds a sliding hash sum of the previous 3-and-a-bit
    * characters which will be used to index the guess table.
    * A better hash function would result in additional compression,
    * at the expense of time.
    */
   #define HASH(x) Hash = (Hash << 4) ^ (x)

   static unsigned short int Hash;
   static unsigned char GuessTable[65536];

   static int
   compress(source, dest, len)
   unsigned char *source, *dest;
   int len;
   {
       int i, bitmask;
       unsigned char *flagdest, flags, *orgdest;

orgdest = dest;
flagdest = dest++; flags = 0; /* All guess wrong initially */
orgdest = dest;
flags = *source++;
flags = *source++;
len2 = compress((unsigned char *)bufp,
len1 = 0;
len3 = len1;
len2 = decompress((unsigned char *)bufp,
len2 = decompress((unsigned char *)bufp,
dflag = 1;
