Network Working Group                                      M. Wildgrube
Internet Draft
Document: draft-wildgrube-sdxf-04.txt                         June 2000
Category: Informational
Expiration Date: December 2000


                 Structured Data Exchange Format (SDXF)


Status of this Memo

   This document is an Internet-Draft and is in full conformance with
      all provisions of Section 10 of RFC2026 [1].

   Internet-Drafts are working documents of the Internet Engineering
   Task Force (IETF), its areas, and its working groups. Note that
   other groups may also distribute working documents as Internet-
   Drafts. Internet-Drafts are draft documents valid for a maximum of
   six months and may be updated, replaced, or obsoleted by other
   documents at any time. It is inappropriate to use Internet- Drafts
   as reference material or to cite them other than as "work in
   progress."
   The list of current Internet-Drafts can be accessed at
   http://www.ietf.org/ietf/1id-abstracts.txt
   The list of Internet-Draft Shadow Directories can be accessed at
   http://www.ietf.org/shadow.html.




Abstract

   This specification describes an all-purpose interchange format for
   use as a file format or for net-working.
   Data is organized in chunks which can be ordered in hierarchical
   structures.
   This format is self-describing and cpu-independent.

Difference to the previous draft
   - Formatting this text in the correct RFC-style













Wildgrube                   Informational                     [Page 1]


                Structured Data Exchange Format (SDXF)       June 2000

Table of Contents

   1. Introduction
   2. Description of SDXF data format.
   3. Introduction to the SDXF functions
   3.1 General remarks
   3.2 Writing a SDXF buffer
   3.3 Reading a SDXF buffer
   3.4 Example
   4. Platform independence
   5. Compression
   6. Encryption
   7. Arrays
   8. Description of the SDXF functions
   8.1 Introduction
   8.2 Basic definitions
   8.3 Definitions for C++
   8.4 Common Definitions:
   8.5 Special functions
   9. Security Considerations
   10. Remarks
   11. Author's Address



1. Introduction

   The purpose of the Structured Data eXchange Format (SDXF) is to
   permit the interchange of an arbitrary structured data block with
   different kinds of data (numerical, text, bitstrings).
   This data format is not limited to any application, the demand for
   this format is that it is usable as a text format for word-
   processing, as a picture format, a sound format, for remote
   procedure calls with complex parameters, suitable for document
   formats, for interchanging business data, etc.

   SDXF is self-describing, every program can unpack every SDXF-data
   without knowing the meaning of the individual data elements.

   Together with the description of the data format a set of functions
   will be introduced. With the help of these functions one can create
   and access the data elements of SDXF.
   The idea is that a programmer should only use these functions
   instead of maintaining the structure by himself on the level of bits
   and bytes.
   (In the speech of object-oriented programming these functions are
   methods of an object which works as a handle for a given SDXF data
   block.)

   SDXF is not limited on a specific platform, along with a correct




Wildgrube                   Informational                     [Page 2]


                Structured Data Exchange Format (SDXF)       June 2000

   preparation of the SDXF functions the SDXF data can be interchanged
   (via network or data carrier) across the boundaries of different
   architectures (specified by the character code like ASCII, ANSI or
   EBCDIC and the byte order for binary data)

   SDXF is also prepared to compress and encrypt parts or the whole
   block of SDXF data.


2. Description of SDXF data format.

   2.1 First we introduce the term "chunk". A chunk is a data structure
   with a fixed set of components. A chunk may be "elementary" or
   "structured". The latter one contains itself one or more other
   chunks.

   2.2 A chunk consists of a header and the data body (content):

   +----------+-----+-------+-----------------------------------+
   | Name     | Pos.| Length| Description                       |
   +----------+-----+-------+-----------------------------------+
   | chunk-ID |  1  |   2   | ID of the chunk (unsigned short)  |
   | flags    |  3  |   1   | type and properties of this chunk |
   | length   |  4  |   3   | length  of the following data     |
   | content  |  7  |   *)  | net data or a list of of chunks   |
   +----------+-----+-------+-----------------------------------+
   (* as stated in "length". total length of chunk is length+6
   The chunk ID is a non-zero positive number.

   or more visually:

   +----+----+----+----+----+----+----+----+----+-...
   | chunkID | fl | length       |  content
   +----+----+----+----+----+----+----+----+----+-...

   or in ASN.1 syntax:

   chunk  ::=  SEQUENCE
   {
     chunkID INTEGER (1..65535),
     flags   BIT STRING,
     length  OCTET STRING SIZE 3, -- or: INTEGER (0..16777215)
     content OCTET STRING
   }

   2.3 Structured chunk.

   A structured chunk is marked as such by the flag byte (see 2.6).
   Opposed to an elementary chunk his content consists of a list of
   chunks (elementary or structured):




Wildgrube                   Informational                     [Page 3]


                Structured Data Exchange Format (SDXF)       June 2000

   visually in a shorter form:



   +----+-+---+-------+-------+-------+-----+-------+
   | id |f|len| chunk | chunk | chunk | ... | chunk |
   +----+-+---+-------+-------+-------+-----+-------+

   With the help of this concept you can reproduce every
   hierarchically structured data into a SDXF chunk.


   2.4 Some Remarks about the internal representation of the chunk's
   elements:

   Binary values are always in high-order-first (big endian) format,
   like the binary values in the IP header (network format). A
   length of 300 is stored as

   +----+----+----+----+----+----+----+----+----+--
   |         |    | 00   01   2C |  content
   +----+----+----+----+----+----+----+----+----+--
   in hexadecimal notation.

   This is also applicable to the chunk-ID.

   2.5 Character values in the content portion are also an object of
   adaptation: see chapter 4.

   2.6 Meaning of the flag-bits:
   Let us represent the flag byte in this manner:

      +-+-+-+-+-+-+-+-+
      |0|1|2|3|4|5|6|7|
      +-+-+-+-+-+-+-+-+
       | | | | | | | |
       | | | | | | | +-- reserved
       | | | | | | +---- array
       | | | | | +------ short chunk
       | | | | +-------- encrypted chunk
       | | | +---------- compressed chunk
       | | |
       +-+-+------------ data type (0..7)

   data types:

   0 -- pending structure (chunk is inconsistent)
   1 -- structure
   2 -- bit string
   3 -- numeric
   4 -- character



Wildgrube                   Informational                     [Page 4]


                Structured Data Exchange Format (SDXF)       June 2000

   5 -- float (ANSI/IEEE 754-1985)
   6 -- reserved
   7 -- reserved

   (The data type zero is explained in 10.1)

   2.7 A short chunk has no data body. The 3 byte Length field is used
   as data bytes instead. This is used in order to save space when
   there are many small chunks.

   2.8 Compressed and encrypted chunks are explained in chapter 5
   and 6.

   2.9 Arrays are explained in chapter 7.

   2.10 Not all combinations of bits are allowed or reasonable:

   - the flags 'array' and 'short' are mutually exclusive.
   - 'short' is not applicable for data type 'structure' and 'float'.
   - 'array' is not applicable for data type 'structure'.


3. Introduction to the SDXF functions

3.1 General remarks

   The functionality of the SDXF concept is not bounded to any
   programming language, but of course the functions themselves must be
   coded in a particular language. I discuss these functions in C and
   C++, because in the meanwhile these languages are available on
   almost all platforms.

   All these functions for reading and writing SDXF chunks uses only
   one parameter, a parameter structure.
   As member functions of the C++ class this parameter structure is
   part of the class.

   An exact description of the interface is given in chapter 8.

3.2 Writing a SDXF buffer

   To write SDXF chunks, there are following functions:

   init    -- initialize the parameter structure
   create  -- create a new chunk
   leave   -- "close" a structured chunk

3.3 Reading a SDXF buffer

   To read SDXF chunks, there are following functions:




Wildgrube                   Informational                     [Page 5]


                Structured Data Exchange Format (SDXF)       June 2000

   init    -- initialize the parameter structure
   enter   -- "go into" a structured chunk
   next    -- "go to" the next chunk inside a structured chunk
   extract -- extract the content of an elementary chunk into
              your data area
   leave   -- "go out" off a structured chunk

3.4 Example:

   3.4.1 Writing:
   (For demonstration we use a reduced (outlined) C++ Form of these
   functions with polymorph definitions:

   void create (short chunkID); // opens a new structure,
   void create (short chunkID, char *string);
        // creates a new chunk with dataType character, etc.)
   The sequence:

   SDXF x(new); // create the SDXF class "x" for a new chunk
                // includes the "init"
   x.create (3301);   // opens a new structure
   x.create (3302, "first chunk");
   x.create (3303, "second chunk");
   x.create (3304);   // opens a new structure
   x.create (3305, "chunk in a structure");
   x.create (3306, "next chunk in a structure");
   x.leave ();        // closes the inner structure
   x.create (3307, "third chunk");
   x.leave ();        // closes the outer structure

   creates a chunk which we can show graphically like:

   3301
     |
     +--- 3302 = "first chunk"
     |
     +--- 3303 = "second chunk"
     |
     +--- 3304
     |      |
     |      +--- 3305 = "chunk in a structure"
     |      |
     |      +--- 3306 = "next chunk in a structure"
     |
     +--- 3307 = "last chunk"
   3.4.2 Reading

   A typically access to a structured SDXF chunk is a selection
   inside a loop:





Wildgrube                   Informational                     [Page 6]


                Structured Data Exchange Format (SDXF)       June 2000

   SDXF x(old); // defines a SDXF class "x" for an old chunk
   x.enter ();

   while (x.rc == 0)
   // 0 == ok, rc will set by the SDXF functions
   {
     switch (x.chunkID)
     {
       case 3302:
         x.extract (data1, maxLength);
                   // extr. 1st chunk into data1
         break;

       case 3303:
         x.extract (data2, maxLength);
                   // extr. 2nd chunk into data2
         break;

       case 3304:  // we know this is a structure
         x.enter ();

         while (x.rc == 0) // inner loop
         {
           switch (x.chunkID)
           {
             case 3305:
               x.extract (data3, maxLength);
                         // extr. the chunk inside struct.
               break;
             case 3306:
               x.extract (data4, maxLength);
                         // extr. 2nd chunk inside struct.
               break;
           }

           x.next (); // returns x.rc = 1 at end of structure
         } // end-while
         break;

       case 3307:
         x.extract (data5, maxLength);
                   // extract last chunk into data
         break;

       default:
         // ignore unknown chunks !!!

     } // end-switch

     x.next (); // returns x.rc = 1 at end of structure
   } // end-while



Wildgrube                   Informational                     [Page 7]


                Structured Data Exchange Format (SDXF)       June 2000

4. Platform independence

   The very most of the computer platforms today have a 8-Bits-in-a-
   Byte architecture, which enables data exchange between these
   platforms.
   But there are two significant points in which platforms may be
   different:

   a) The representation of binary numerical (the short and long int).

   b) The representation of characters (ASCII/ANSI vs. EBCDIC)

   Point (a) is the phenomenon of "byte swapping": How is a short int
   value 259 = 0x0103 = X'0103' be stored on address 4402?

   the two flavours are:

   4402 4403
   01   03    the big-endian, and
   03   01    the little-endian.

   Point (b) is represented by a table of the assignment of the 256
   possible values of a Byte to printable or control characters.
   (in ASCII the letter "A" is assigned to value (or position) 0x41 =
   65, in EBCDIC it is 0xC1 = 193)

   The solution of the problems which results out of it is to normalize
   the data:

   We fix:

   (a) The internal representation of binary numerals are 2-complements
   in big-endian order.

   (b) The internal representation of characters is ISO 8859-1 (also
   known as Latin 1).

   The fixing of point (b) should be regarded as a first strike. In
   some environment 8859-1 seems not to be the best choice, in a greek
   or russian environment 8859-5 or 8859-7 are appropriate.

   Nevertheless, in a specific group (or world) of applications, that
   is to say all the applications which wants to interchange data with
   a defined protocol (via networking or diskette or something else),
   this internal character table must be unique.

   So a possibility to define a translation table (and his inversion)
   should be given.

   Important: You construct a SDXF chunk not for a specific addressee,
   but you adapt your data into a normalized format (or network



Wildgrube                   Informational                     [Page 8]


                Structured Data Exchange Format (SDXF)       June 2000

   format).

   This adaption is not done by the programmer, it will be done by the
   create and extract function. An administrator has take care of
   defining the correct translation tables.


5. Compression

   As stated in 2.6 there is a flag bit which declares that the
   following data (elementary or structured) are compressed. This data
   is not further interpretable until it is decompressed. Compression
   is transparently done by the SDXF functions: "create" does the
   compression for elementary chunks, "leave" for structured chunks,
   "extract" does the decompression for elementary chunks, "enter" for
   structured chunks.

   Transparently means that the programmer has only to tell the SDXF
   functions that he want compress the following chunk(s).

   For choosing between different compression methods and for
   controlling the decompressed (original) length, there is an
   additional definition:

   After the chunk header for a compressed chunk, a compression header
   is following:

   +-----------------------+---------------+---------------->
   |      chunk header     | compr. header | compressed data
   +---+---+---+---+---+---+---+---+---+---+---------------->
   |chunkID|flg|   length  |md | orglength |
   +---+---+---+---+---+---+---+---+---+---+---------------->

   -- 'md' is the "compression method": Two methods are reserved:

    01 for a simple (fast but not very effective) "Run Length 1" or
   "Byte Run 1" algorithm. (More then two consecutive identical
   characters are replaced by the number of these characters and the
   character itself.)

    02 for the wonderful "deflate" algorithm which comes from the
   "zip"-people.
   The authors are:
   Jean-loup Gailly (deflate routine),
   Mark Adler (inflate routine).

   Mark and Jean-loup can be reached by e-mail at zlib@gzip.org .
   The deflate format is described by RFC 1951.
   For more information: www.cdrom.com/pub/infozip/zlib/

   -- 'orglength' is the original (decompressed) length of the data.



Wildgrube                   Informational                     [Page 9]


                Structured Data Exchange Format (SDXF)       June 2000

6. Encryption

   As stated in 2.6 there is a flag bit which declares that the
   following data (elementary or structured) is encrypted. This data is
   not interpretable until it is decrypted. En/Decryption is
   transparently done by the SDXF functions, "create" does the
   encryption for elementary chunks, "leave" for structured chunks,
   "extract" does the decryption for elementary chunks, "enter" for
   structured chunks. (Yes it sounds very similar to chapter 5.)

   More then one encryption method for a given range of applications is
   not very reasonable. We specify that the length of the data will not
   be changed by encryption. So a special encryption header (similar as
   the compression header) is not necessary.

   Even the en/decryption is done transparently, an encryption key
   (password) must be given to the SDXF functions.

   Encryption is done after translating character data into, decryption
   is done before translation from the internal ("network-") format.

   If both, encryption and compression are applied on the same chunk,
   compression is done first - compression on good encrypted data (same
   strings appears as different after encryption) tends to zero
   compression rates.


7. Arrays

   An array is a sequence of chunks with the chunk-ID, length and data
   type.

   At first a hint: in principle a special definition in SDXF for such
   array is not really necessary:

   It is not forbidden that there are more than one chunk with equal
   chunk-ID within the same structured chunk.

   Therefore with a sequence of SDX_next / SDX_extract calls one can
   fill the destination array step by step.

   If there are many occurences of chunks with the same chunk-ID (and a
   comparative small length), the overhead of the chunk-packages may be
   significant.

   Therefore the array flag is introduced.
   An array chunk has only one chunk header for the complete sequence
   of elementary chunks.
   After the chunk header for an array chunk, an array header is
   following:




Wildgrube                   Informational                    [Page 10]


                Structured Data Exchange Format (SDXF)       June 2000

   This is a short integer (big endian!) which contains the number of
   the array elements (CT) . Every element has a fixed length (EL), so
   the chunklength (CL) is CL = EL * CT + 2.

   The data elements follows immediately after the array header.

   The complete array will be constructed by SDX_create, the complete
   array will be read by SDX_extract.

   The parameter fields (see 8.2.1) 'dataLength' and 'count' are used
   for the SDXF functions 'extract' and 'create':

   Field 'dataLength' is the common length of the array elements,
   'count' is the actual dimension of the array for 'create' (input).

   For the 'extract' function 'count' acts both as an input and output
   parameter:

   input:  the maximum dimension
   output: the actual array dimension.

   (If output count is greater than input count, the 'data cutted'
   warning will be responded and the destination array is filled up to
   the maximum dimension.)



8. Description of the SDXF functions

8.1 Introduction

   Following the principles of Object Oriented Programming, not only
   the description of the data is necessary, but also the functions
   which manipulate data - the "methods".

   For the programmer knowing the methods is more important than
   knowing the data structure, the methods has to know the exact
   specifications of the data and guarantees the consistence of the
   data while creating them.

   A SDXF object is an instance of a parameter structure which acts as
   a programming interface. Especially it points to an actual SDXF data
   chunk, and, while processing on this data, there is a pointer to the
   actual inner chunk which will be the focus for the next operation.

   The benefit of an exact interface description is the same as using
   for example the standard C library functions: By using standard
   interfaces your code remains platform independent.






Wildgrube                   Informational                    [Page 11]


                Structured Data Exchange Format (SDXF)       June 2000

8.2 Basic definitions

   8.2.1 The SDXF Parameter structure

   All SDXF access functions need only one parameter, a pointer to the
   SDXF parameter structure:

   First 3 prerequisite definitions:

   typedef short int      ChunkID;
   typedef unsigned char  Byte;

   typedef struct Chunk
   {
     ChunkID    chunkID;
     Byte       flags;
     char       length [3];
     Byte       data;
   } Chunk;

   And now the parameter structure:

   typedef struct
   {
     ChunkID  chunkID;       // name (ID) of Chunk
     Byte    *container;     // pointer to the whole Chunk
     long     bufferSize;    // size of container
     Chunk   *currChunk;     // pointer to actual Chunk
     long     dataLength;    // length of data in Chunk
     long     maxLength;     // max. length of Chunk for SDX_extract
     long     remainingSize; // rem. size in cont. after SDX_create
     long     value;         // for data type numeric / init option
     double   fvalue;        // for data type float
     char    *function;      // name of the executed SDX function
     Byte    *data;          // pointer to Data
     Byte    *cryptkey;      // pointer to Crypt Key
     short    count;         // (max.) number of elements in an array
     short    dataType;      // Chunk data type / init open type
     short    ec;            // extended return-code
     short    rc;            // return-code
     short    level;         // level of hierarchy
     char     filler;        // filler char for SDX_extract
     Byte     encrypt;       // Indication if data to encrypt (0 / 1)
     Byte     compression;   // compression method
                             //   (00=none, 01=RL1, 02=zip/deflate)
   } SDX_obj, *SDX_handle;

   Only the "public" fields of the parameter structure is described,
   which acts as input and output for the SDXF functions.
   A given implementation may add some "private" fields to this
   structure.



Wildgrube                   Informational                    [Page 12]


                Structured Data Exchange Format (SDXF)       June 2000

   8.2.2 Basic Functions

   All these functions works with a SDX_handle as the only formal
   parameter.
   Every function returns as output ec and rc as a report of success.
   For the values for ec, rc and dataType see chap. 8.4.


   8.2.2.1 SDX_init : Initialize the parameter structure.
     input : container, dataType,
             bufferSize (for dataType = SDX_NEW only)
     output: currChunk, dataLength (for dataType = SDX_OLD only),
             ec, rc,
             the other fields of the parameter structure will be
             initialized.

   8.2.2.2 SDX_enter : Enter a structured chunk.
     You can access the first chunk inside this structured chunk.
     input : none
     output: currChunk, chunkID, dataLength, level, dataType,
             ec, rc


   8.2.2.3 SDX_leave : Leave the actual entered structured chunk.
     input : none
     output: currChunk, chunkID, dataLength, level, dataType,
             ec, rc

   8.2.2.4 SDX_next : Go to the next chunk inside a structured
           chunk.
     input : none
     output: currChunk, chunkID, dataLength, dataType, count,
             ec, rc

     At the end of a structured chunk SDX_next returns rc =
     SDX_RC_failed and ec = SDX_EC_eoc (end of chunk)
     The actual structured chunk is SDX_leave'd automatically.

   8.2.2.5 SDX_extract : Extract data of the actual chunk.
     (If actual chunk is structured, only a copy is done,
     elsewhere the data is converted to host format.)
     input / output depends on the dataType:

     if dataType is structured, binary or char:
     input : data, maxLength, count, filler
     output: dataLength, count, ec, rc

     if dataType is numeric (float resp.):
     input : none
     output: value (fvalue resp.), ec, rc




Wildgrube                   Informational                    [Page 13]


                Structured Data Exchange Format (SDXF)       June 2000

   8.2.2.6 SDX_select : Go to the (next) chunk with a given
     chunkID.
     input : chunkID
     output: currChunk, dataLength, dataType, ec, rc

   8.2.2.8 SDX_create : Creating a new chunk (at the end of
     the actual structured chunk).
     input : chunkID, dataLength, data, (f)value, dataType,
             compression, encrypt, count
     update: remainingSize, level
     output: currChunk, dataLength, ec, rc

   8.2.2.9 SDX_append : Append a complete chunk at the end of
     the actual structured chunk.
     input : data, maxLength, currChunk
     output: chunkID, chunkLength, maxLength, level, dataType,
             ec, rc


8.3 Definitions for C++

   This is the specification of the SDXF class in C++:
   (Byte is defined as "unsigned char" for bitstrings, opposed to
   "signed char" for character strings)

   class C_SDXF
   {
     public:

    // constructors and destructor:
     C_SDXF  ();                          // dummy
     C_SDXF  (Byte *cont);                // old container
     C_SDXF  (Byte *cont, long size);     // new container
     C_SDXF  (long size);                 // new container
     ~C_SDXF ();

    // methods:

     void init  (void);                   // old container
     void init  (Byte *cont);             // old container
     void init  (Byte *cont, long size);  // new container
     void init  (long size);              // new container

     void enter   (void);
     void leave   (void);
     void next    (void);
     long extract (Byte *data, long length);    // chars, bits
     long extract (void);                       // numeric data
     void create  (ChunkID);                    // structured
     void create  (ChunkID, long value);        // numeric
     void create  (ChunkID, double fvalue);     // float



Wildgrube                   Informational                    [Page 14]


                Structured Data Exchange Format (SDXF)       June 2000

     void create  (ChunkID, Byte *data, long length);// binary
     void create  (ChunkID, char *data);             // chars
     void set_compression (Byte compression_method);
     void set_encryption  (Byte *encryption_key);

    // interface:

     ChunkID  id;        // see 7.4.1
     short    dataType;  // see 7.4.2
     long     length;    // length of data or chunk

     long     value;
     double   fvalue;
     short    rc;  // the raw return code       see 7.4.3
     short    ec;  // the extended return code  see 7.4.4

     protected:
    // implementation dependent

   };


8.4 Common Definitions:

   8.4.1 Definition of ChunkID:

   typedef short ChunkID;

   8.4.1 Values for dataType:

   SDX_DT_inconsistent     = 0
   SDX_DT_structured       = 1
   SDX_DT_binary           = 2
   SDX_DT_numeric          = 3
   SDX_DT_char             = 4
   SDX_DT_float            = 5

     data types for SDX_init:
   SDX_OLD                 = 1
   SDX_NEW                 = 2

   8.4.3 Values for rc:

   SDX_RC_ok               = 0
   SDX_RC_failed           = 1
   SDX_RC_warning          = 1
   SDX_RC_illegalOperation = 2
   SDX_RC_dataError        = 3
   SDX_RC_parameterError   = 4
   SDX_RC_programError     = 5
   SDX_RC_noMemory         = 6

Wildgrube                   Informational                    [Page 15]


                Structured Data Exchange Format (SDXF)       June 2000

   8.4.4 Values for ec:

   SDX_EC_ok              =  0
   SDX_EC_eoi             =  1
   SDX_EC_notFound        =  2
   SDX_EC_dataCutted      =  3
   SDX_EC_overflow        =  4
   SDX_EC_wrongInitType   =  5
   SDX_EC_comprerr        =  6
   SDX_EC_forbidden       =  7
   SDX_EC_unknown         =  8
   SDX_EC_levelOvflw      =  9
   SDX_EC_paramMissing    = 10
   SDX_EC_magicError      = 11
   SDX_EC_not_consistent  = 12
   SDX_EC_wrongDataType   = 13
   SDX_EC_noMemory        = 14
   SDX_EC_error           = 99

8.5 Special functions

   Besides the basic definitions there is a global function
   (SDX_getOptions) which returns a pointer to a global table of
   options.

   With the help of these options you can adapt the behaviour of SDXF.
   Especially you can define an alternative pair of translation tables
   or an alternative function which reads these tables from an external
   resource (p.e. from disk)

   In this table of options there is also a pointer to the function
   which is used for encryption / decryption: You can install your own
   encryption algorithm by setting this pointer.

   The options pointer is received by:

   SDX_TOptions  opt = SDX_getOptions ();

   With:

   typedef struct
   {
    Byte            *toHost;        // Trans tab net -> host
    Byte            *toNet;         // Trans tab host -> net
    int              maxlevel;      // highest possible level
    int              translation;   // translation net <-> host
                                    // is in effect=1 or not=0
    TEncryptProc    *encryptProc;   // altern. encryption routine
    TGetTablesProc  *getTablesProc; // altern. routine defining
                                    // translation Tables
   }  SDX_TOptions;



Wildgrube                   Informational                    [Page 16]


                Structured Data Exchange Format (SDXF)       June 2000

   typedef int TEncryptProc
     ( Byte *buffer,
       long len,      // len: length of buffer
       char *passw,   // Password
       int modif );   // = 0 (Modifier for special applications
     // returns success: 1 = ok, 0 = error

   typedef int TGetTablesProc (Byte **toNet, Byte **toHost);
     // toNet, toHost: pointer to output params. Both params
     // points to translation tables of 256 Bytes.
     // returns success: 1 = ok, 0 = error.


9. Security Considerations

   Any corruption of data in the chunk headers denounce the
   complete SDXF structure.

   Any corruption of data in a encrypted or compressed SDXF structure
   makes this chunk unusable. An integrity check after decryption or
   decompression is done by the "enter" function.

   While using TCP/IP (more precisely: IP) as a transmission medium we
   can trust on his CRC check on the transport layer.


10. Final remarks

   10.1 A consistent construction of a SDXF structure is done if every
   "create" to a structured chunk is closed by a paired "leave".
   While a structured chunk is under construction, his data type is set
   to zero.

   10.2 While creating an elementary chunk a platform dependent
   transformation to a platform independent format of the data is
   performed - at the end of construction the content of the buffer is
   ready to transport to another site, without any further translation.

   10.3 As you see no data definition in your programming language is
   needed for to construct a specific SDXF structure. The data is
   created dynamically by function calls.

   10.4 With SDXF as a base you can define protocols for client /
   server applications. With following two rules these protocols may be
   extended in downward compatibility manner:

   Rule 1: Ignore unknown chunkIDs.

   Rule 2: The sequence of chunks should not be significant.





Wildgrube                   Informational                    [Page 17]


                Structured Data Exchange Format (SDXF)       June 2000

11. Author's Address

   Max Wildgrube
   Schlossstrasse 120
   60486 Frankfurt
   Germany

   EMail: max@wildgrube.com                                                    














































Wildgrube                   Informational                    [Page 18]

