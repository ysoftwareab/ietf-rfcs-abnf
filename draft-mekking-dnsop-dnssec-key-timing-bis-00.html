<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" 
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html lang="en" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head profile="http://www.w3.org/2006/03/hcard%20http://dublincore.org/documents/2008/08/04/dc-html/">
  <meta http-equiv="Content-Type" content="text/html; charset=us-ascii" />

  <title>DNSSEC Key Timing Considerations Follow-Up </title>

  <style type="text/css" title="Xml2Rfc (sans serif)">
  /*<![CDATA[*/
	  a {
	  text-decoration: none;
	  }
	  a.smpl {
	  color: black;
	  }
	  a:hover {
	  text-decoration: underline;
	  }
	  a:active {
	  text-decoration: underline;
	  }
	  address {
	  margin-top: 1em;
	  margin-left: 2em;
	  font-style: normal;
	  }
	  body {
	  color: black;
	  font-family: verdana, helvetica, arial, sans-serif;
	  font-size: 10pt;
	  
	  }
	  cite {
	  font-style: normal;
	  }
	  dd {
	  margin-right: 2em;
	  }
	  dl {
	  margin-left: 2em;
	  }
	
	  ul.empty {
	  list-style-type: none;
	  }
	  ul.empty li {
	  margin-top: .5em;
	  }
	  dl p {
	  margin-left: 0em;
	  }
	  dt {
	  margin-top: .5em;
	  }
	  h1 {
	  font-size: 14pt;
	  line-height: 21pt;
	  page-break-after: avoid;
	  }
	  h1.np {
	  page-break-before: always;
	  }
	  h1 a {
	  color: #333333;
	  }
	  h2 {
	  font-size: 12pt;
	  line-height: 15pt;
	  page-break-after: avoid;
	  }
	  h3, h4, h5, h6 {
	  font-size: 10pt;
	  page-break-after: avoid;
	  }
	  h2 a, h3 a, h4 a, h5 a, h6 a {
	  color: black;
	  }
	  img {
	  margin-left: 3em;
	  }
	  li {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  ol {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  ol p {
	  margin-left: 0em;
	  }
	  p {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  pre {
	  margin-left: 3em;
	  background-color: lightyellow;
	  padding: .25em;
	  }
	  pre.text2 {
	  border-style: dotted;
	  border-width: 1px;
	  background-color: #f0f0f0;
	  width: 69em;
	  }
	  pre.inline {
	  background-color: white;
	  padding: 0em;
	  }
	  pre.text {
	  border-style: dotted;
	  border-width: 1px;
	  background-color: #f8f8f8;
	  width: 69em;
	  }
	  pre.drawing {
	  border-style: solid;
	  border-width: 1px;
	  background-color: #f8f8f8;
	  padding: 2em;
	  }
	  table {
	  margin-left: 2em;
	  }
	  table.tt {
	  vertical-align: top;
	  }
	  table.full {
	  border-style: outset;
	  border-width: 1px;
	  }
	  table.headers {
	  border-style: outset;
	  border-width: 1px;
	  }
	  table.tt td {
	  vertical-align: top;
	  }
	  table.full td {
	  border-style: inset;
	  border-width: 1px;
	  }
	  table.tt th {
	  vertical-align: top;
	  }
	  table.full th {
	  border-style: inset;
	  border-width: 1px;
	  }
	  table.headers th {
	  border-style: none none inset none;
	  border-width: 1px;
	  }
	  table.left {
	  margin-right: auto;
	  }
	  table.right {
	  margin-left: auto;
	  }
	  table.center {
	  margin-left: auto;
	  margin-right: auto;
	  }
	  caption {
	  caption-side: bottom;
	  font-weight: bold;
	  font-size: 9pt;
	  margin-top: .5em;
	  }
	
	  table.header {
	  border-spacing: 1px;
	  width: 95%;
	  font-size: 10pt;
	  color: white;
	  }
	  td.top {
	  vertical-align: top;
	  }
	  td.topnowrap {
	  vertical-align: top;
	  white-space: nowrap; 
	  }
	  table.header td {
	  background-color: gray;
	  width: 50%;
	  }
	  table.header a {
	  color: white;
	  }
	  td.reference {
	  vertical-align: top;
	  white-space: nowrap;
	  padding-right: 1em;
	  }
	  thead {
	  display:table-header-group;
	  }
	  ul.toc, ul.toc ul {
	  list-style: none;
	  margin-left: 1.5em;
	  margin-right: 0em;
	  padding-left: 0em;
	  }
	  ul.toc li {
	  line-height: 150%;
	  font-weight: bold;
	  font-size: 10pt;
	  margin-left: 0em;
	  margin-right: 0em;
	  }
	  ul.toc li li {
	  line-height: normal;
	  font-weight: normal;
	  font-size: 9pt;
	  margin-left: 0em;
	  margin-right: 0em;
	  }
	  li.excluded {
	  font-size: 0pt;
	  }
	  ul p {
	  margin-left: 0em;
	  }
	
	  .comment {
	  background-color: yellow;
	  }
	  .center {
	  text-align: center;
	  }
	  .error {
	  color: red;
	  font-style: italic;
	  font-weight: bold;
	  }
	  .figure {
	  font-weight: bold;
	  text-align: center;
	  font-size: 9pt;
	  }
	  .filename {
	  color: #333333;
	  font-weight: bold;
	  font-size: 12pt;
	  line-height: 21pt;
	  text-align: center;
	  }
	  .fn {
	  font-weight: bold;
	  }
	  .hidden {
	  display: none;
	  }
	  .left {
	  text-align: left;
	  }
	  .right {
	  text-align: right;
	  }
	  .title {
	  color: #990000;
	  font-size: 18pt;
	  line-height: 18pt;
	  font-weight: bold;
	  text-align: center;
	  margin-top: 36pt;
	  }
	  .vcardline {
	  display: block;
	  }
	  .warning {
	  font-size: 14pt;
	  background-color: yellow;
	  }
	
	
	  @media print {
	  .noprint {
		display: none;
	  }
	
	  a {
		color: black;
		text-decoration: none;
	  }
	
	  table.header {
		width: 90%;
	  }
	
	  td.header {
		width: 50%;
		color: black;
		background-color: white;
		vertical-align: top;
		font-size: 12pt;
	  }
	
	  ul.toc a::after {
		content: leader('.') target-counter(attr(href), page);
	  }
	
	  ul.ind li li a {
		content: target-counter(attr(href), page);
	  }
	
	  .print2col {
		column-count: 2;
		-moz-column-count: 2;
		column-fill: auto;
	  }
	  }
	
	  @page {
	  @top-left {
		   content: "Internet-Draft"; 
	  } 
	  @top-right {
		   content: "December 2010"; 
	  } 
	  @top-center {
		   content: "Abbreviated Title";3
	  } 
	  @bottom-left {
		   content: "Doe"; 
	  } 
	  @bottom-center {
		   content: "Expires June 2011"; 
	  } 
	  @bottom-right {
		   content: "[Page " counter(page) "]"; 
	  } 
	  }
	
	  @page:first { 
		@top-left {
		  content: normal;
		}
		@top-right {
		  content: normal;
		}
		@top-center {
		  content: normal;
		}
	  }
  /*]]>*/
  </style>

  <link href="#rfc.toc" rel="Contents">
<link href="#rfc.section.1" rel="Chapter" title="1 Introduction">
<link href="#rfc.section.1.1" rel="Chapter" title="1.1 Key Rollover Considerations">
<link href="#rfc.section.1.1.1" rel="Chapter" title="1.1.1 Key Goals">
<link href="#rfc.section.1.2" rel="Chapter" title="1.2 Terminology">
<link href="#rfc.section.2" rel="Chapter" title="2 Key Definitions">
<link href="#rfc.section.2.1" rel="Chapter" title="2.1 Key Types">
<link href="#rfc.section.2.2" rel="Chapter" title="2.2 Key States Unraveled">
<link href="#rfc.section.2.3" rel="Chapter" title="2.3 Delay Timings">
<link href="#rfc.section.3" rel="Chapter" title="3 Key Rollovers">
<link href="#rfc.section.3.1" rel="Chapter" title="3.1 ZSK Rollovers">
<link href="#rfc.section.3.1.1" rel="Chapter" title="3.1.1 Double-Signature">
<link href="#rfc.section.3.1.2" rel="Chapter" title="3.1.2 Pre-Publication">
<link href="#rfc.section.3.1.3" rel="Chapter" title="3.1.3 Double-RRSIG">
<link href="#rfc.section.3.2" rel="Chapter" title="3.2 KSK Rollovers">
<link href="#rfc.section.3.2.1" rel="Chapter" title="3.2.1 Double-RRset">
<link href="#rfc.section.3.2.2" rel="Chapter" title="3.2.2 Double-Signature">
<link href="#rfc.section.3.2.3" rel="Chapter" title="3.2.3 Double-DS">
<link href="#rfc.section.3.2.4" rel="Chapter" title="3.2.4 Interaction with Configured Trust Anchors">
<link href="#rfc.section.3.2.4.1" rel="Chapter" title="3.2.4.1 Adding a KSK">
<link href="#rfc.section.3.2.4.2" rel="Chapter" title="3.2.4.2 Removing a KSK">
<link href="#rfc.section.3.3" rel="Chapter" title="3.3 Rollovers in a Single Type Signing Scheme">
<link href="#rfc.section.3.3.1" rel="Chapter" title="3.3.1 Double-RRset">
<link href="#rfc.section.3.3.2" rel="Chapter" title="3.3.2 Double-Signature">
<link href="#rfc.section.3.3.3" rel="Chapter" title="3.3.3 Pre-Publication">
<link href="#rfc.section.3.3.4" rel="Chapter" title="3.3.4 Double-DS">
<link href="#rfc.section.3.4" rel="Chapter" title="3.4 Stand-by Keys">
<link href="#rfc.section.4" rel="Chapter" title="4 Policy rollover">
<link href="#rfc.section.4.1" rel="Chapter" title="4.1 Enabling DNSSEC">
<link href="#rfc.section.4.2" rel="Chapter" title="4.2 Disabling DNSSEC">
<link href="#rfc.section.4.3" rel="Chapter" title="4.3 Algorithm Rollover">
<link href="#rfc.section.4.4" rel="Chapter" title="4.4 KSK-ZSK Split or Single Type Signing Scheme">
<link href="#rfc.section.5" rel="Chapter" title="5 IANA Considerations">
<link href="#rfc.section.6" rel="Chapter" title="6 Security Considerations">
<link href="#rfc.section.7" rel="Chapter" title="7 Acknowledgements">
<link href="#rfc.section.8" rel="Chapter" title="8 Changes with key-timing draft">
<link href="#rfc.references" rel="Chapter" title="9 References">
<link href="#rfc.references.1" rel="Chapter" title="9.1 Informative References">
<link href="#rfc.references.2" rel="Chapter" title="9.2 Normative References">
<link href="#rfc.authors" rel="Chapter">


  <meta name="generator" content=
  "http://greenbytes.de/tech/webdav/rfc2629.xslt, Revision 1.539, 2011-01-02 17:13:00, XSLT vendor: SAXON 6.5.5 from Michael Kay http://saxon.sf.net/" />
  <link rel="schema.dct" href="http://purl.org/dc/terms/" />
  <meta name="dct.creator" content="Doe, J." />
  <meta name="dct.identifier" content="urn:ietf:id:draft-sample-input-00" />
  <meta name="dct.issued" scheme="ISO8601" content="2010-12" />
  
  <meta name="dct.abstract" content="This document describes issues surrounding the timing of events in enforcing key policy within DNSSEC.  It presents timelines for various key rollovers and changes into the policy with respect to the key signing scheme.  It explicitly identifies the relationships between the various parameters affecting the process.  " />
  <meta name="description" content="This document describes issues surrounding the timing of events in enforcing key policy within DNSSEC.  It presents timelines for various key rollovers and changes into the policy with respect to the key signing scheme.  It explicitly identifies the relationships between the various parameters affecting the process.  " />
  <meta name="keywords" content="DNS, DNSSEC, key, rollover" />

</head>

<body>

  <table class="header">
    <tbody>
    
    	<tr>
<td class="left">Domain Name System Operations</td>
<td class="right">W.M. Mekking</td>
</tr>
<tr>
<td class="left">Internet-Draft</td>
<td class="right">NLnet Labs</td>
</tr>
<tr>
<td class="left">Intended status: Standards Track</td>
<td class="right">February 25, 2011</td>
</tr>
<tr>
<td class="left">Expires: August 29, 2011</td>
<td class="right"></td>
</tr>

    	
    </tbody>
  </table>

  <p class="title">DNSSEC Key Timing Considerations Follow-Up <br />
  <span class="filename">draft-mekking-dnsop-dnssec-key-timing-bis-00</span></p>
  
  <h1 id="rfc.abstract"><a href="#rfc.abstract">Abstract</a></h1>
<p>This document describes issues surrounding the timing of events in enforcing key policy within DNSSEC.  It presents timelines for various key rollovers and changes into the policy with respect to the key signing scheme.  It explicitly identifies the relationships between the various parameters affecting the process.  </p>
<h1 id="rfc.status"><a href="#rfc.status">Status of this Memo</a></h1>
<p>This Internet-Draft is submitted in full conformance with the provisions of BCP 78 and BCP 79.</p>
<p>Internet-Drafts are working documents of the Internet Engineering Task Force (IETF).  Note that other groups may also distribute working documents as Internet-Drafts.  The list of current Internet- Drafts is at http://datatracker.ietf.org/drafts/current/.</p>
<p>Internet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other documents at any time.  It is inappropriate to use Internet-Drafts as reference material or to cite them other than as "work in progress."</p>
<p>This Internet-Draft will expire on August 29, 2011.</p>
<h1 id="rfc.copyrightnotice"><a href="#rfc.copyrightnotice">Copyright Notice</a></h1>
<p>Copyright (c) 2011 IETF Trust and the persons identified as the document authors.  All rights reserved.</p>
<p>This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document.  Please review these documents carefully, as they describe your rights and restrictions with respect to this document.  Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.</p>

  
  <hr class="noprint" />
  <h1 class="np" id="rfc.toc"><a href="#rfc.toc">Table of Contents</a></h1>
  <ul class="toc">

  	<li>1.   <a href="#rfc.section.1">Introduction</a>
</li>
<li>1.1.   <a href="#rfc.section.1.1">Key Rollover Considerations</a>
</li>
<li>1.1.1.   <a href="#rfc.section.1.1.1">Key Goals</a>
</li>
<li>1.2.   <a href="#rfc.section.1.2">Terminology</a>
</li>
<li>2.   <a href="#rfc.section.2">Key Definitions</a>
</li>
<li>2.1.   <a href="#rfc.section.2.1">Key Types</a>
</li>
<li>2.2.   <a href="#rfc.section.2.2">Key States Unraveled</a>
</li>
<li>2.3.   <a href="#rfc.section.2.3">Delay Timings</a>
</li>
<li>3.   <a href="#rfc.section.3">Key Rollovers</a>
</li>
<li>3.1.   <a href="#rfc.section.3.1">ZSK Rollovers</a>
</li>
<li>3.1.1.   <a href="#rfc.section.3.1.1">Double-Signature</a>
</li>
<li>3.1.2.   <a href="#rfc.section.3.1.2">Pre-Publication</a>
</li>
<li>3.1.3.   <a href="#rfc.section.3.1.3">Double-RRSIG</a>
</li>
<li>3.2.   <a href="#rfc.section.3.2">KSK Rollovers</a>
</li>
<li>3.2.1.   <a href="#rfc.section.3.2.1">Double-RRset</a>
</li>
<li>3.2.2.   <a href="#rfc.section.3.2.2">Double-Signature</a>
</li>
<li>3.2.3.   <a href="#rfc.section.3.2.3">Double-DS</a>
</li>
<li>3.2.4.   <a href="#rfc.section.3.2.4">Interaction with Configured Trust Anchors</a>
</li>
<li>3.2.4.1.   <a href="#rfc.section.3.2.4.1">Adding a KSK</a>
</li>
<li>3.2.4.2.   <a href="#rfc.section.3.2.4.2">Removing a KSK</a>
</li>
<li>3.3.   <a href="#rfc.section.3.3">Rollovers in a Single Type Signing Scheme</a>
</li>
<li>3.3.1.   <a href="#rfc.section.3.3.1">Double-RRset</a>
</li>
<li>3.3.2.   <a href="#rfc.section.3.3.2">Double-Signature</a>
</li>
<li>3.3.3.   <a href="#rfc.section.3.3.3">Pre-Publication</a>
</li>
<li>3.3.4.   <a href="#rfc.section.3.3.4">Double-DS</a>
</li>
<li>3.4.   <a href="#rfc.section.3.4">Stand-by Keys</a>
</li>
<li>4.   <a href="#rfc.section.4">Policy rollover</a>
</li>
<li>4.1.   <a href="#rfc.section.4.1">Enabling DNSSEC</a>
</li>
<li>4.2.   <a href="#rfc.section.4.2">Disabling DNSSEC</a>
</li>
<li>4.3.   <a href="#rfc.section.4.3">Algorithm Rollover</a>
</li>
<li>4.4.   <a href="#rfc.section.4.4">KSK-ZSK Split or Single Type Signing Scheme</a>
</li>
<li>5.   <a href="#rfc.section.5">IANA Considerations</a>
</li>
<li>6.   <a href="#rfc.section.6">Security Considerations</a>
</li>
<li>7.   <a href="#rfc.section.7">Acknowledgements</a>
</li>
<li>8.   <a href="#rfc.section.8">Changes with key-timing draft</a>
</li>
<li>9.   <a href="#rfc.references">References</a>
</li>
<li>9.1.   <a href="#rfc.references.1">Informative References</a>
</li>
<li>9.2.   <a href="#rfc.references.2">Normative References</a>
</li>
<li><a href="#rfc.authors">Author's Address</a>
</li>


  </ul>

  <h1 id="rfc.section.1">
<a href="#rfc.section.1">1.</a> <a href="#intro" id="intro">Introduction</a>
</h1>
<p id="rfc.section.1.p.1">A zone is managed according to a given security policy.  Such a policy may enforce DNSSEC keys to be used and for how long.  When enforcing a lifetime on DNSSEC keys, key rollovers must to take place.  In addition, changes in the policy may trigger certain key rollover events.  Key rollovers are time critical, multiple steps processes.  This document describes issues surrounding the timing of events in the rolling of DNSSEC keys.  </p>
<p id="rfc.section.1.p.2">[MM: Editorarial comments are indicated by square brackets and editor initials] </p>
<h1 id="rfc.section.1.1">
<a href="#rfc.section.1.1">1.1.</a> <a href="#considerations" id="considerations">Key Rollover Considerations</a>
</h1>
<p id="rfc.section.1.1.p.1">A key is used with a purpose: An operational decision has been made to secure the zone with DNSSEC.  That decision leads to a key being created, published in the zone and used for signing.  Policy may enforce a lifetime on keys.  As a result, current active keys need to be replaced with new keys.  The new key becomes active, while the current key is retired.  The keys need to be introcuded into and removed from the zone at the appropriate times.  Considerations that must be taken into account are: </p>
<p></p>

<ul>
<li>Speed: A rollover should occur as fast and simple as possible.  However, DNSSEC records are not only held at the authoritative nameserver, they are also cached at client resolvers.  The data on these systems can be interlinked, meaning a validating may try to validate a signature retrieved from a cache with a key obtained separately.  The rollover process needs to happen in such a way that at all times through the rollover the information is consistent.  </li>
<li>Size of the zone and the DNS response: A rollover can be speed up by introducing the DNSSEC records prematurely.  However, adding arbitrary signatures increases the size of your zone and DNS responses significantly.  To keep the sizes of the zone and responses as small as possible, you might want to consider to introduce the DNSSEC records only when they are required, For the same reason, dead keys and signatures must be removed periodically.  </li>
<li>Size of the DNSKEY RRset and the priming response: You can choose to keep the size of the DNSKEY RRset to a minimum, to make priming responses smaller in size.  The larger the packet, the more resolvers may have problems retrieving the response.  Other responses may have more signatures, since the initial size is relatively small.  The DNSKEY RRset is usually already quite large and should not grow too much anymore.  </li>
<li>Interactions with the Parent: A KSK sometimes needs its corresponding DS record to be published at the parent zone, while its predecessor needs to remove its DS record from the parent zone.  Such a request requires additional operational work and can be a sufficient delay.  Ideally, the interactions with the parent is kept to a minimum.  </li>
</ul>

<p> </p>
<h1 id="rfc.section.1.1.1">
<a href="#rfc.section.1.1.1">1.1.1.</a> <a href="#goals" id="goals">Key Goals</a>
</h1>
<p id="rfc.section.1.1.1.p.1">We have identified three different goals for a key: </p>
<p></p>

<ul>
<li>Activate key: Make validating resolvers use the key's associated information to perform authentication.</li>
<li>Remove key: Make validating resolvers forget about the key's associated information.</li>
<li>Stand-by key: Pre-publish information for this key to speed up a future (unscheduled) rollover.</li>
</ul>

<p> </p>
<p id="rfc.section.1.1.1.p.3">Each key rollover and change in key signing scheme can now be described by one or more goals that are put on a key.  </p>
<h1 id="rfc.section.1.2">
<a href="#rfc.section.1.2">1.2.</a> <a href="#terminology" id="terminology">Terminology</a>
</h1>
<p id="rfc.section.1.2.p.1">The terminology used in this document is as defined in <a href="#RFC4033">[RFC4033]</a> and <a href="#RFC5011">[RFC5011]</a>.  </p>
<h1 id="rfc.section.2">
<a href="#rfc.section.2">2.</a> <a href="#definitions" id="definitions">Key Definitions</a>
</h1>
<h1 id="rfc.section.2.1">
<a href="#rfc.section.2.1">2.1.</a> <a href="#types" id="types">Key Types</a>
</h1>
<p id="rfc.section.2.1.p.1">Keys can be used to authenticate information within the zone.  Such keys are said to be ZSKs.  In addition, keys can be used to authenticate the DNSKEY RRset in the zone.  These keys are said to be KSKs.  Keys can be marked to be ZSK and KSK at the same time, for example in a Single Type Signing Scheme (STSS).  </p>
<p id="rfc.section.2.1.p.2">Despite that ZSK and KSK only describe the usage of a key, the terms are often used for identifiying a key.  Thus when we talk about a ZSK, we actually mean that the key is used as ZSK.  In the same spirt, a KSK is a key that is used as KSK.  </p>
<p id="rfc.section.2.1.p.3">DNSSEC recognises the classification of keys with its SEP bit set and not set.  Usually if a key is used as KSK, the SEP bit is set.  However, <a href="#dnssec-bis">draft-ietf-dnsext-dnssec-bis-updates</a> <cite title="NONE">[dnssec-bis]</cite> says that a SEP bit setting has no effect on how a DNSKEY may be used.  Policy determines whether the bit should be set, depending on the key's usage.  </p>
<h1 id="rfc.section.2.2">
<a href="#rfc.section.2.2">2.2.</a> <a href="#unraveled" id="unraveled">Key States Unraveled</a>
</h1>
<p id="rfc.section.2.2.p.1">We use unraveled key states to seperately represent the key and its associated information.  There can be up to three pieces of key associated information: the public key (in DNSKEY format), its created signatures (the RRSIG records) and the secured delegation (the corresponding DS record).  The state of the piece of information is defined by 'RRtype State'.  </p>
<p id="rfc.section.2.2.p.2">Key conditions are essentially what are called key states in <a href="#key-timing">draft-ietf-dnsop-dnssec-key-timing</a> <cite title="NONE">[key-timing]</cite>.  A key can have multiple conditions at the same time.  </p>
<p id="rfc.section.2.2.p.3">A piece of information may exist in up to two places: it can be present in the corresponding zone and it may live in resolver caches.  This is true for every piece of associated information.  Therefore, all of the three pieces of information follow the same state diagram: </p>
<p id="rfc.section.2.2.p.4">Generated --&gt; Introduced --&gt; Propagated --&gt; Withdrawn --&gt; Dead.  </p>
<p></p>

<dl>
<dt>Generated: </dt>
<dd style="margin-left: 8">The information has been generated, but is not available in the zone.  In this state, no resolvers are able to fetch this information. <br> - The key condition is said to be Generated, if no information has passed the Introduced state yet.  </dd>
<dt>Introduced: </dt>
<dd style="margin-left: 8">The information is introduced and, as a result, may be available in the zone.  In this state, there may be resolvers that fetch this information. <br> - The key condition is said to be Published if it has its DNSKEY state in Introduced. <br> - The key condition is said to be Active if it has its RRSIG state in Introduced (for ZSKs). <br> - The key condition is said to be Submitted, or ActiveDS, if it has its DS state in Introduced (for KSKs).  </dd>
<dt>Propagated: </dt>
<dd style="margin-left: 8">The information is available in the zone and enough time has passed to have it propagated into all resolver caches.  As a result, all resolvers fetch this information from cache of from the authoritative name server. <br> - The key condition is said to be Known if it has its DNSKEY state in Propagated. <br> - The key condition is said to be Safe if it has its RRSIG state in Propagated (for ZSKs). <br> - The key condition is said to be SafeDS if it has its DS state in Propagated (for KSKs).  </dd>
<dt>Withdrawn: </dt>
<dd style="margin-left: 8">The information is being withdrawn from the zone, but may still be available in the zone.  In this state, the information can still live in resolver caches. <br> - The key condition is said to be Removed if it has its DNSKEY state in Withdrawn. <br> - The key condition is said to be Retired if it has its RRSIG state in Withdrawn (for ZSKs). <br> - The key condition is said to be RetiredDS if it has its DS state in Withdrawn (for KSKs).  </dd>
<dt>Dead: </dt>
<dd style="margin-left: 8">The information is not available in the zone anymore and enough time has passed to have it expire from all resolver caches. <br> - The key condition is said to be Forgotten if it has its DNSKEY state in Dead. <br> - The key condition is said to be Expired if it has its RRSIG state in Dead (for ZSKs). <br> - The key condition is said to be ExpiredDS if it has its DS state in Dead (for KSKs).  </dd>
</dl>

<p> </p>
<p id="rfc.section.2.2.p.6">A key state can now be represented as the triplet (DNSKEY State, RRSIG State, DS State).  For example: </p>
<p id="rfc.section.2.2.p.7">S(Kc) = (DNSKEY Propagated, RRSIG Introduced, DS Generated) </p>
<p id="rfc.section.2.2.p.8">tells us that key Kc is published in the zone and all the resolvers that have a copy of the DNSKEY RRset, have one that includes Kc.  In other words, Kc is said to be Known.  In addition, the key is Active as it is being used for signing RRsets: RRSIG records made with Kc have been introduced in the zone.  However, there may still be some resolver caches that are unaware of these signatures.  Finally, the corresponding DS record is said to be Generated and has thus not yet been submitted to the parent.  </p>
<p id="rfc.section.2.2.p.9">For convenience, we can represent a ZSK as a tuple (DNSKEY State, RRSIG State), because the DS record is only used with KSKs.  And we can represent a KSK as a tuple (DNSKEY State, DS State), because the RRSIG state only refers to ZSKs.  The RRSIG record over the DNSKEY RRset should be published at the same time when the corresponding DNSKEY record is published.  Therefore, both records will propagate and expire at the same time from resolver caches.  </p>
<h1 id="rfc.section.2.3">
<a href="#rfc.section.2.3">2.3.</a> <a href="#timings" id="timings">Delay Timings</a>
</h1>
<p id="rfc.section.2.3.p.1">For every change we make in the zone, we have to take into account several delays.  </p>
<p></p>

<dl>
<dt>Software Delay (Dsfw): </dt>
<dd style="margin-left: 8">The time it takes for the software to introduce the new information in the zone.  This delay can vary alot depending on the information that needs to be introduced.  One can imagine that the software needs more time to sign a complete zone than when it pre-publishes a DNSKEY record.  [MM: Dsfw maps to Dsgn from the key-timing draft] </dd>
<dt>Propagation Delay (Dprp): </dt>
<dd style="margin-left: 8">The time it takes for any change introduced at the master to replicate to all slave servers.  </dd>
<dt>TTL Delay (Dttl): </dt>
<dd style="margin-left: 8">The time it takes to expire the previous information from the resolver caches.  This delay depends on what RRsets need to expire from the caches.  If not explicitly mentioned otherwise, Dttl is considered the maximum TTL of the information that needs to expire from caches.  Otherwise, Dttl(RRtype) shows which specific RRsets need to expire.  [MM: TTL terminology in key-timing draft: TTLds, TTLkey, TTLkeyC, TTLsoa, TTLsoaC, TTLsoaP, TTLsig)] </dd>
<dt>Registration Delay to the Parent (Dreg): </dt>
<dd style="margin-left: 8">The time it takes to get the DS record to be placed into the parent zone, after it is submitted.  </dd>
<dt>Propagation Delay of the Parent (DprpP): </dt>
<dd style="margin-left: 8">The time it takes for any change introduced at the parent master to replicate to all parent slave servers.  </dd>
</dl>

<p> </p>
<p id="rfc.section.2.3.p.3">Despite these delays may vary for the different rollover methods, we can identify the propagation delay to the caches as: </p>
<p id="rfc.section.2.3.p.4">DcacheZ = Dsfw + Dprp + Dttl <br> DcacheK = Dsfw + Dprp + Dttl(DNSKEY) <br> DcacheP = Dreg + DprpP + Dttl(DS) </p>
<p id="rfc.section.2.3.p.5">where DcacheZ is the propagation delay to the caches for information published in our zone, DcacheK is the propagation delay to the caches for our DNSKEY RRset and DcacheP is the propagation delay for information published in our parent zone.  </p>
<h1 id="rfc.section.3">
<a href="#rfc.section.3">3.</a> <a href="#rollovers" id="rollovers">Key Rollovers</a>
</h1>
<p id="rfc.section.3.p.1">There are many different key rollover methods. In <a href="#considerations">Section 1.1</a>, we have seen that there are several properties to prefer one method over the other.  Though there are many different type of key rollovers, all methods share the same goal.  There is a current key (Kc) that needs to become Forgotten-Retired and a successor key (Ks) that needs to become Known-Safe.  </p>
<h1 id="rfc.section.3.1">
<a href="#rfc.section.3.1">3.1.</a> <a href="#zsk-rollovers" id="zsk-rollovers">ZSK Rollovers</a>
</h1>
<p id="rfc.section.3.1.p.1">The two most common rollover methods for ZSKs are Double-Signature and Pre-Publication.  Both are described in <a href="#RFC4641">RFC4641</a> <cite title="NONE">[RFC4641]</cite>.  <a href="#key-timing">draft-ietf-dnsop-dnssec-key-timing</a> <cite title="NONE">[key-timing]</cite> also introduces ZSK Double-RRSIG rollover.  Double-Signature is the fastest way to rollover a ZSK.  Pre-Publication minimizes the number of signatures over the RRsets in the zone and responses.  Double-RRSIG keeps the size of the DNSKEY RRset to a minimum.  </p>
<h1 id="rfc.section.3.1.1">
<a href="#rfc.section.3.1.1">3.1.1.</a> Double-Signature</h1>
<p id="rfc.section.3.1.1.p.1">This involves introducing the new key into the zone and using it to create additional RRSIG records; the old key and existing RRSIG records are retained.  During the period in which the zone is being signed, client resolvers are always able to validate RRSIGs: any combination of old and new DNSKEY RRset and RRSIG allows at least one signature to be validated.  </p>
<p id="rfc.section.3.1.1.p.2">Once the signing process is complete and enough time has elapsed to allow all old information to expire from caches, the old key and signatures can be removed from the zone.  As before, during this period any combination of DNSKEY RRset and RRSIG will allow validation of at least one signature.  </p>
<p id="rfc.section.3.1.1.p.3">Double-Signature is the fastest way to rollover to a new key, since all new information is published right away.  The drawback of this method is a noticeable increase in the size of the DNSSEC data, affecting both the overall size of the zone and the size of the responses.  </p>
<p id="rfc.section.3.1.1.p.4">Only when Ks is said to be Known, e.g. the DNSKEY record of Ks is known to all validating resolvers, we can remove the signatures made with Kc.  And only when we can ensure that all validators only use the information of Ks for authentication, we can remove the DNSKEY record for Kc.  In other words, Ks needs to be Known and Safe, before we can remove Kc.  Thus, we first have to introduce all new information into the zone.  Once all has been propagated, we can withdraw all information of Kc from the zone.  </p>
<div id="#rfc.figure.1"></div>
<p>The timeline diagram is shown below:</p>
<pre>
        |1|  |2|     |3|  |4|     |5|
Kc       |    |       |    |       |
- RRSIG  |----|-------|----|DcacheZ|
- DNSKEY |----|-------|----|DcacheK|
         |    |       |    |       |
                           Trem    Tfor
                           Tret    Texp

Ks       |    |       |    |       |
- RRSIG  |    |DcacheZ|----|-------|---
- DNSKEY |    |DcacheK|----|-------|---
         |    |       |    |       |
         Tgen Tpub    Tkno
              Tact    Tsaf
    </pre>
<p>Figure: ZSK Double-Signature Rollover.</p>
<p id="rfc.section.3.1.1.p.5">Event 1: Key Ks is generated at the generate time (Tgen).  </p>
<p id="rfc.section.3.1.1.p.6">S(Ks) = (DNSKEY Generated, RRSIG Generated) <br> C(Ks) = Generated </p>
<p id="rfc.section.3.1.1.p.7">Event 2: Key Ks is added to the DNSKEY RRset and is immediately used to sign the zone; existing signatures in the zone are not removed.  This is Ks' publish time (Tpub) and Ks is said to be Published.  It is also Ks' active time (Tact), the time when Ks is said to be Active.  Because the Double-Signature rollover is in place, we now temporarily have two active keys.  </p>
<p id="rfc.section.3.1.1.p.8">Tpub(Ks) &gt;= Tgen(Ks), Tact(Ks) == Tpub(Ks) </p>
<p id="rfc.section.3.1.1.p.9">S(Ks) = (DNSKEY Introduced, RRSIG Introduced) <br> C(ks) = Published Active </p>
<p id="rfc.section.3.1.1.p.10">Event 3: The information for Ks must be published long enough to ensure that the information have reached all validating resolvers that may have RRsets from this zone cached.  At the point in time that the DNSKEY RRset including Ks has been propagated and Ks is said to be Known (Tkno).  At the point in time that the other RRsets including a signature of Ks have been propagated (Tsaf), Ks is said to be Safe.  </p>
<p id="rfc.section.3.1.1.p.11">Tkno(Ks) &gt;= Tpub(Ks) + DcacheK <br> Tsaf(Ks) &gt;= Tact(Ks) + DcacheZ <br> </p>
<p id="rfc.section.3.1.1.p.12">S(Ks) = (DNSKEY Propagated, RRSIG Propagated) <br> C(ks) = Known Safe </p>
<p id="rfc.section.3.1.1.p.13">Note that we could already retire Kc, i.e. stop signing with Kc, after DcacheK.  It does not matter if not all signatures of Ks have been Propagated, since the resolver can validate RRsets with both Kc and Ks.  If the validator fetches a RRset from the cache, it uses the DNSKEY of Kc for validation.  Otherwise, it can use the DNSKEY of Ks.  </p>
<p id="rfc.section.3.1.1.p.14">Event 4: Once we have a successor key that is said to be Propagated, we can retire Kc.  This is Kc' retire time (Tret) and Kc is said to be Retired.  And once we have a successor key that is said to be Safe, we can remove Kc.  Therefore, it is also Kc' removal time (Trem), the time that Kc is said to be Removed.  </p>
<p id="rfc.section.3.1.1.p.15">Tret(Kc) &gt;= Tkno(Ks) <br> Trem(Kc) &gt;= MAX(Tsaf(Ks), TsafDS(Ks)) </p>
<p id="rfc.section.3.1.1.p.16">S(Kc) = (DNSKEY Withdrawn, RRSIG Withdrawn) <br> C(kc) = Removed Retired </p>
<p id="rfc.section.3.1.1.p.17">Event 5: From the perspective of the authoritative server, the rollover is complete.  After some delay, Kc and its signatures have expired from the caches.  This delay is the maximum of DcacheZ, DcacheK.  This is Tfor, the time that the key is said to be Forgotten and Texp, the time that the key is said to be Expired.  </p>
<p id="rfc.section.3.1.1.p.18">Tfor(Kc) &gt;= Trem(Kc) + DcacheK <br> Texp(Kc) &gt;= Tret(Kc) + DcacheZ </p>
<p id="rfc.section.3.1.1.p.19">S(Kc) = (DNSKEY Dead, RRSIG Dead) <br> C(Kc) = Forgotten Expired </p>
<h1 id="rfc.section.3.1.2">
<a href="#rfc.section.3.1.2">3.1.2.</a> Pre-Publication</h1>
<p id="rfc.section.3.1.2.p.1">With Pre-Publication, the new key is introduced into the DNSKEY RRset, leaving the existing keys and signatures in place.  This state of affairs remains in place for long enough to ensure that any DNSKEY RRsets cached in client validating resolvers contain both keys.  At that point signatures created with the old key can be replaced by those created with the new key, and the old signatures can be removed.  During the re-signing process it doesn't matter which key an RRSIG record retrieved by a client was created with; clients with a cached copy of the DNSKEY RRset will have a copy containing both the old and new keys.  </p>
<p id="rfc.section.3.1.2.p.2">Once the zone contains only signatures created with the new key, there is an interval during which RRSIG records created with the old key expire from client caches.  After this, there will be no signatures anywhere that were created using the old key, and it can can be removed from the DNSKEY RRset.  </p>
<p id="rfc.section.3.1.2.p.3">Pre-Publication is more complex than Double-Signature - introduce the new key, approximately one TTL later sign the records, and approximately one TTL after that remove the old key.  It also takes more time than the Double-Signature method.  The delay is because we don't want to publish signatures of both keys at the same time.  As an advantage, the amount of DNSSEC data is kept to a minimum which reduces the impact on performance.  </p>
<div id="#rfc.figure.2"></div>
<p>The timeline diagram looks like this:</p>
<pre>
        |1|  |2|     |3|  |4|     |5|  |6|     |7|
Kc       |    |       |    |       |    |       |
- RRSIG  |----|-------|----|DcacheZ|    |       |
- DNSKEY |----|-------|----|-------|----|DcacheK|
         |    |       |    |       |    |       |
                           Tret    Texp Trem    Tfor

Ks       |    |       |    |       |    |       |
- RRSIG  |    |       |    |DcacheZ|----|-------|---
- DNSKEY |    |DcacheK|----|-------|----|-------|---
         |    |       |    |       |    |       |
         Tgen Tpub    Tkno Tact    Tsaf
    </pre>
<p>Figure: ZSK Pre-Publication Rollover.</p>
<p id="rfc.section.3.1.2.p.4">Event 1: Key Ks is generated at the generate time (Tgen).  </p>
<p id="rfc.section.3.1.2.p.5">S(Ks) = (DNSKEY Generated, RRSIG Generated) <br> C(Ks) = Generated </p>
<p id="rfc.section.3.1.2.p.6">Event 2: The DNSKEY record of Ks is put into the zone, i.e. it is added to the DNSKEY RRset which is then re-signed with the current KSK.  The time at which this occurs is Ks' publication time (Tpub), and the key is now said to be Published.  Note that the key is not yet used to sign records.  </p>
<p id="rfc.section.3.1.2.p.7">Tpub(Ks) &gt;= Tgen(Ks) </p>
<p id="rfc.section.3.1.2.p.8">S(Ks) = (DNSKEY Introduced, RRSIG Generated) <br> C(Ks) = Published </p>
<p id="rfc.section.3.1.2.p.9">Event 3: Before Ks can be used, the DNSKEY record for Ks must be published for long enough (DcacheK) to guarantee that any resolver that has a copy of the DNSKEY RRset also includes this key.  In other words, that any prior cached information about the DNSKEY RRset has expired.  After this delay, the key is said to be Known and could be used to sign records.  The time at which this event occurs is Tkno, which is given by: </p>
<p id="rfc.section.3.1.2.p.10">Tkno(Ks) &gt;= Tpub(Ks) + DcacheK </p>
<p id="rfc.section.3.1.2.p.11">S(Ks) = (DNSKEY Propagated, RRSIG Generated) <br> C(Ks) = Known </p>
<p id="rfc.section.3.1.2.p.12">Event 4: At some point in time, the decision is made to actually start signing the zone using the successor key.  This will be when the current key has been in use for an interval equal to the ZSK lifetime.  This point in time is Ks' active time (Tact), the time that Ks is said to be Active.  It is also Kc' retire time (Tret), the time that Kc is said to be Retired.  </p>
<p id="rfc.section.3.1.2.p.13">Tact(Ks) &gt;= Tkno(Ks), Tret(Kc) == Tact(Ks) </p>
<p id="rfc.section.3.1.2.p.14">S(Kc) = (DNSKEY Propagated, RRSIG Withdrawn) <br> C(Kc) = Known Retired <br> S(Ks) = (DNSKEY Propagated, RRSIG Introduced) <br> C(Ks) = Known Active <br> </p>
<p id="rfc.section.3.1.2.p.15">Event 5: Kc needs to be retained in the zone whilst any RRSIG records created by the retired key are still published in the zone or held in resolver caches.  In other words, Kc should be retained in the zone until all RRSIG records created by Ks have been propagated.  This time is Ks' safe time (Tsaf), the time that Ks is considered to be Safe.  Consequently, at the same time Kc is considered to be Expired.  </p>
<p id="rfc.section.3.1.2.p.16">Tsaf(Ks) &gt;= Tact(Ks) + DcacheZ </p>
<p id="rfc.section.3.1.2.p.17">S(Kc) = (DNSKEY Propagated, RRSIG Dead) <br> C(Kc) = Known Expired <br> S(Ks) = (DNSKEY Propagated, RRSIG Propagated) <br> C(Ks) = Known Safe </p>
<p id="rfc.section.3.1.2.p.18">Event 6: When all new signatures have been propagated, Kc can be removed from the zone and the DNSKEY RRset re-signed with the current KSK.  This time is Kc' removal time (Trem), the time that Kc is considered to be Removed.  </p>
<p id="rfc.section.3.1.2.p.19">Trem(Kc) &gt;= Tsaf(Ks) </p>
<p id="rfc.section.3.1.2.p.20">S(Kc) = (DNSKEY Withdrawn, RRSIG Dead) <br> C(Kc) = Removed Expired </p>
<p id="rfc.section.3.1.2.p.21">Event 7: From the perspective of the authoritative server, the rollover is complete.  After some delay, The DNSKEY record for Kc has expired from the caches.  This is Tfor, and the key is said to be Forgotten.  </p>
<p id="rfc.section.3.1.2.p.22">Tfor(Kc) &gt;= Trem(Kc) + DcacheK </p>
<p id="rfc.section.3.1.2.p.23">S(Kc) = (DNSKEY Dead, RRSIG Dead) <br> C(Kc) = Forgotten Expired </p>
<h1 id="rfc.section.3.1.3">
<a href="#rfc.section.3.1.3">3.1.3.</a> Double-RRSIG</h1>
<p id="rfc.section.3.1.3.p.1">This involves introducing the new signatures first, while existing signatures are being retained.  This state of affairs remains in place for long enough to ensure that all RRsets cached in client validating resolvers contain two signatures.  The DNSKEY RR can now be switched.  For the period of time before the predecessor key has been expired from all caches, it does not matter if the validator uses the cached key or the successor key that is in the zone.  Both corresponding signatures can be retrieved from the cache or from the name server.  </p>
<p id="rfc.section.3.1.3.p.2">Once the signing process is complete and enough time has elapsed to allow all old information to expire from caches, the old signatures can be removed from the zone.  As before, during this period any combination of DNSKEY RRset and RRSIG will allow validation of at least one signature.  </p>
<p id="rfc.section.3.1.3.p.3">Double-RRSIG is also more complex than Double-Signature - first introducing the signatures, then switch the key and finally remove the olds signatures.  It also takes more time than the Double-Signature method.  The delay is because we cannot publish the public data of both keys at the same time.  As an advantage, the DNSKEY RRset is kept to a minimum which reduces the impact on priming performance.  </p>
<div id="#rfc.figure.3"></div>
<p>The timeline diagram is shown below:</p>
<pre>
        |1|  |2|     |3|  |4|     |5|  |6|     |7|
Kc       |    |       |    |       |    |       |
- RRSIG  |----|-------|----|DcacheK|    |       |
- DNSKEY |----|-------|----|-------|----|DcacheZ|
         |    |       |    |       |    |       |
                           Trem    Tfor Tret    Texp

Ks       |    |       |    |       |    |       |
- RRSIG  |    |DcacheZ|----|-------|----|-------|---
- DNSKEY |    |       |    |DcacheK|----|-------|---
         |    |       |    |       |    |       |
         Tgen Tact    Tsaf Tpub    Tkno
    </pre>
<p>Figure: ZSK Double-RRSIG Rollover.</p>
<p id="rfc.section.3.1.3.p.4">Event 1: Key Ks is generated at the generate time (Tgen).  </p>
<p id="rfc.section.3.1.3.p.5">S(Ks) = (DNSKEY Generated, RRSIG Generated) <br> C(Ks) = Generated </p>
<p id="rfc.section.3.1.3.p.6">Event 2: The zone is signed with Ks but existing signatures are retained.  The DNSKEY RR for Ks remains unpublished.  The time at which this occurs is Ks' active time (Tact), and the key is now said to be Active.  </p>
<p id="rfc.section.3.1.3.p.7">Tact(Ks) &gt;= Tgen(Ks) </p>
<p id="rfc.section.3.1.3.p.8">S(Ks) = (DNSKEY Generated, RRSIG Introduced) <br> C(Ks) = Active </p>
<p id="rfc.section.3.1.3.p.9">Event 3: Before we can switch the DNSKEY from Kc to Ks, the signatures of Ks must be published for long enough (DcacheZ) to guarantee that any resolver that has a copy of any RRset, also has both signatures.  In other words, that any cached information is double signed.  After this delay, the key is said to be Safe.  The time at which this event occurs is Tsaf, which is given by: </p>
<p id="rfc.section.3.1.3.p.10">Tsaf(Ks) &gt;= Tact(Ks) + DcacheZ </p>
<p id="rfc.section.3.1.3.p.11">S(Ks) = (DNSKEY Generated, RRSIG Propagated) <br> C(Ks) = Safe </p>
<p id="rfc.section.3.1.3.p.12">Event 4: At some point in time, the decision is made to publish Ks.  This point in time is Ks' publish time (Tpub), the time that Ks is said to be Published.  At the same time, the DNSKEY RR for Kc is removed from the zone, and Kc is said to be Removed.  </p>
<p id="rfc.section.3.1.3.p.13">Tpub(Ks) &gt;= Tsaf(Ks), Trem(Kc) == Tpub(Ks) </p>
<p id="rfc.section.3.1.3.p.14">S(Kc) = (DNSKEY Removed, RRSIG Propagated) <br> C(Kc) = Removed Safe <br> S(Ks) = (DNSKEY Introduced, RRSIG Propagated) <br> C(Ks) = Published Safe <br> </p>
<p id="rfc.section.3.1.3.p.15">Event 5: The signatures of Kc need to be retained in the zone until the DNSKEY RR has expired from all resolver caches.  When this happens, Ks is said to be Known (Tkno) and Kc is said to be Forgotten (Tfor).  </p>
<p id="rfc.section.3.1.3.p.16">Tfor(Kc) &gt;= Trem(Kc) + DcacheK <br> Tkno(Ks) &gt;= Tpub(Ks) + DcacheK </p>
<p id="rfc.section.3.1.3.p.17">S(Kc) = (DNSKEY Dead, RRSIG Propagated) <br> C(Kc) = Forgotten Safe <br> S(Ks) = (DNSKEY Propagated, RRSIG Propagated) <br> C(Ks) = Known Safe </p>
<p id="rfc.section.3.1.3.p.18">Event 6: The signatures of Kc can be removed when the DNSKEY RR for Ks has been propagated.  This time is Kc' retire time (Tret), the time that Kc is considered to be Retired.  </p>
<p id="rfc.section.3.1.3.p.19">Tret(Kc) &gt;= Tsaf(Ks) </p>
<p id="rfc.section.3.1.3.p.20">S(Kc) = (DNSKEY Dead, RRSIG Withdrawn) <br> C(Kc) = Forgotten Retired </p>
<p id="rfc.section.3.1.3.p.21">Event 7: From the perspective of the authoritative server, the rollover is complete.  After some delay, all signatures of Kc have expired from the caches.  This is Texp, and the key is said to be Expired.  </p>
<p id="rfc.section.3.1.3.p.22">Texp(Kc) &gt;= Tret(Kc) + DcacheZ </p>
<p id="rfc.section.3.1.3.p.23">S(Kc) = (DNSKEY Dead, RRSIG Dead) <br> C(Kc) = Forgotten Expired </p>
<h1 id="rfc.section.3.2">
<a href="#rfc.section.3.2">3.2.</a> <a href="#ksk-rollovers" id="ksk-rollovers">KSK Rollovers</a>
</h1>
<p id="rfc.section.3.2.p.1">The most common rollover method for KSKs is Double-Signature, described in <a href="#RFC4641">RFC4641</a> <cite title="NONE">[RFC4641]</cite>.  Two more methods are identified in <a href="#key-timing">draft-ietf-dnsop-dnssec-key-timing</a> <cite title="NONE">[key-timing]</cite>: Double-DS and Double-RRset.  Double-RRset is the fastest way to rollover a KSK, while Double-Signature minimizes the number of required interactions to the parent, and Double-DS keeps your DNSKEY RRset as small as possible.  </p>
<p id="rfc.section.3.2.p.2">Note that with these type of rollovers, we do not have to worry whether the information within the zone is authentic.  We assume that there exists one or more ZSKs in the DNSKEY RRset that takes care of this during the rollover.  </p>
<h1 id="rfc.section.3.2.1">
<a href="#rfc.section.3.2.1">3.2.1.</a> Double-RRset</h1>
<p id="rfc.section.3.2.1.p.1">With Double-RRset, the new KSK is added to the DNSKEY RRset which is then signed with both the old and new key, and the new DS record added to the parent zone.  After waiting a suitable interval for the old DS and DNSKEY RRsets to expire from validating resolver caches, the old DNSKEY and DS record are removed.  </p>
<p id="rfc.section.3.2.1.p.2">Only when Ks is said to be Known, e.g. the DNSKEY record of Ks is known to all validating resolvers, we can remove the DS record of Kc.  And only when can ensure that all validators can use the DS record for Ks to build the secure chain of trust, we can remove the DNSKEY record of Kc.  In other words, Ks needs to be Known and SafeDS.  Thus, we first have to introduce all new information into the zone.  Once all has been propagated, we can withdraw all information of Kc from the zone.  </p>
<div id="#rfc.figure.4"></div>
<p>The timeline diagram looks like this:</p>
<pre>
        |1|  |2|     |3|   |4|     |5|
Kc       |    |       |     |       |
- DNSKEY |----|-------|-----|DcacheK|
- DS     |----|-------|-----|DcacheP|
         |    |       |     |       |
                            Trem    Tfor
                            TretDS  TexpDS

Ks       |    |       |     |       |
- DNSKEY |    |DcacheK|-----|-------|---
- DS     |    |DcacheP|-----|-------|---
         |    |       |     |       |
         Tgen Tpub    Tkno 
              TactDS  TsafDS
    </pre>
<p>Figure: KSK Double-RRset Rollover.</p>
<p id="rfc.section.3.2.1.p.3">Event 1: Ks is generated at time Tgen.  </p>
<p id="rfc.section.3.2.1.p.4">S(Ks) = (DNSKEY Generated, DS Generated) <br> C(Ks) = Generated </p>
<p id="rfc.section.3.2.1.p.5">Event 2: Ks is introduced into the zone; it is added to the DNSKEY RRset, which is then signed by all currently active KSKs (including Kc and Ks).  In addition, the DS record is submitted to the parent.  This is Ks' publish time (Tpub), the time that Ks is said to be Published.  It is also Ks' submit time (TactDS), the time that the DS record for Ks is Submitted (ActiveDS).  </p>
<p id="rfc.section.3.2.1.p.6">Tpub(ks) &gt;= Tgen(Ks), TactDS(Ks) == Tpub(Ks) </p>
<p id="rfc.section.3.2.1.p.7">S(Ks) = (DNSKEY Introduced, DS Introduced) <br> C(ks) = Published ActiveDS </p>
<p id="rfc.section.3.2.1.p.8">After the registration delay, the DS is published in the parent.  </p>
<p id="rfc.section.3.2.1.p.9">Event 3: The information for Ks must be published long enough to ensure that the information have reached all validating resolvers that may have the DNSKEY or DS RRset from this zone cached.  At the point in time that the DNSKEY RRset including Ks has been propagated (Tkno), Ks is said to be Known.  At the point in time that the DS RRset of Ks has been propagated (Tsaf), Ks is said to be SafeDS.  </p>
<p id="rfc.section.3.2.1.p.10">Tkno(Ks) &gt;= Tpub(Ks) + DcacheK, TsafDS(Ks) &gt;= TactDS(Ks) + DcacheP </p>
<p id="rfc.section.3.2.1.p.11">S(Ks) = (DNSKEY Propagated, DS Propagated) <br> C(Ks) = Known SafeDS </p>
<p id="rfc.section.3.2.1.p.12">Note that we could already send the request to the parent to withdraw the DS record of Kc after DcacheK.  It does not matter if the DS record for Ks has not yet been propagated, since the resolver can authenticate the DNSKEY RRset with both Kc and Ks.  If the validator fetches a DS RRset from the cache, it uses Kc.  Otherwise, it can use Ks.  </p>
<p id="rfc.section.3.2.1.p.13">Event 4: Once we have a successor key that is said to be Known, we can withdraw the DS record for Kc.  This is Kc' retire time (Tret), the time that Kc is said to be RetiredDS.  If Ks is also said to be SafeDS, we no longer need to retain Kc in the zone.  It is also Kc' removal time (Trem), the time that Kc is said to be Removed.  </p>
<p id="rfc.section.3.2.1.p.14">TretDS(Kc) &gt;= Tkno(ks) <br> Trem(Kc) &gt;= MAX(TsafDS(Ks), Tkno(Ks)) </p>
<p id="rfc.section.3.2.1.p.15">S(Kc) = (DNSKEY Withdrawn, DS Withdrawn) <br> C(Kc) = Removed RetiredDS </p>
<p id="rfc.section.3.2.1.p.16">Event 5: From the perspective of the authoritative server, the rollover is complete.  After some delay, Kc and its DS have also expired from the caches.  </p>
<p id="rfc.section.3.2.1.p.17">Tfor(Kc) &gt;= Trem(Kc) + DcachK <br> TexpDS(Kc) &gt;= TretDS(Kc) + DcacheP </p>
<p id="rfc.section.3.2.1.p.18">S(Kc) = (DNSKEY Dead, DS Dead) <br> C(Kc) = Forgotten Expired </p>
<h1 id="rfc.section.3.2.2">
<a href="#rfc.section.3.2.2">3.2.2.</a> Double-Signature</h1>
<p id="rfc.section.3.2.2.p.1">With Double-Signature, the new KSK is added to the DNSKEY RRset which is then signed with both the old and new key.  After waiting for the old RRset to expire from caches, the DS record in the parent zone is changed.  After waiting a further interval for this change to be reflected in caches, the old key is removed from the RRset.  </p>
<p id="rfc.section.3.2.2.p.2">If you want to minimize the number of interactions to the parent, this rollover method is preferred over the Double-RRset method.  As a consequence, you have to wait with submitting the DS record of Ks, until it is safe to withdraw the DS record of Kc.  </p>
<div id="#rfc.figure.5"></div>
<p>The timing diagram for such a rollover is:</p>
<pre>
        |1|  |2|     |3|   |4|     |5|    |6|     |7|
Kc       |    |       |     |       |      |       |
- DNSKEY |----|-------|-----|-------|------|DcacheK|
- DS     |----|-------|-----|DcacheP|      |       |
         |    |       |     |       |      |       |
                            TretDS  TexpDS Trem    Tfor

Ks       |    |       |     |       |      |       |
- DNSKEY |    |DcacheK|-----|-------|------|-------|---
- DS     |    |       |     |DcacheP|------|-------|---
         |    |       |     |       |      |       |
         Tgen Tpub    Tkno  TactDS  TsafDS
    </pre>
<p>Figure: KSK Double-Signature Rollover.</p>
<p id="rfc.section.3.2.2.p.3">Event 1: Ks is generated at time Tgen.  </p>
<p id="rfc.section.3.2.2.p.4">S(Ks) = (DNSKEY Generated, DS Generated) <br> C(Ks) = Generated </p>
<p id="rfc.section.3.2.2.p.5">Event 2: Ks is introduced into the zone; it is added to the DNSKEY RRset, which is then signed by Ks and all currently actice KSKs (including Kc).  This is the publication time (Tpub), the time that Ks is said to be Published.  </p>
<p id="rfc.section.3.2.2.p.6">Tpub(Ks) &gt;= Tgen(Ks) </p>
<p id="rfc.section.3.2.2.p.7">S(Ks) = (DNSKEY Introduced, DS Generated) <br> C(Ks) = Published </p>
<p id="rfc.section.3.2.2.p.8">Event 3: Before we can submit the corresponding DS, the DNSKEY record for Ks must be published for long enough (DcacheK) to guarantee that any resolver that has a copy of the DNSKEY RRset also includes this key.  In other words, that any prior cached information about the DNSKEY RRset has expired.  This time is Tkno and Ks is said to be Known.  </p>
<p id="rfc.section.3.2.2.p.9">Tkno(Ks) &gt;= Tpub(Ks) + DcacheK </p>
<p id="rfc.section.3.2.2.p.10">S(Ks) = (DNSKEY Propagated, DS Generated) <br> C(Ks) = Known </p>
<p id="rfc.section.3.2.2.p.11">Event 4: At some later time, the DS RR corresponding to Ks is submitted to the parent zone for publication.  In addition, the request has been made to remove the DS RR corresponding to Kc from the parent zone.  This time is Ks' submit time (TactDS), the time that Ks is considered to be Submitted.  It is also Kc' retire time (TretDS), the time that Kc is considered to be RetiredDS.  </p>
<p id="rfc.section.3.2.2.p.12">TactDS(Ks) &gt;= Tkno(Ks) <br> TretDS(kc) == TactDS(Kc) </p>
<p id="rfc.section.3.2.2.p.13">S(Kc) = (DNSKEY Propagated, DS Withdrawn) <br> C(Ks) = Known RetiredDS <br> S(Ks) = (DNSKEY Propagated, DS Introduced) <br> C(Ks) = Known ActiveDS </p>
<p id="rfc.section.3.2.2.p.14">After the registration delay, the DS is published in the parent.  </p>
<p id="rfc.section.3.2.2.p.15">Event 5: At some time later, all validating resolvers that have the DS RRset cached will have a a copy that includes the new DS record.  This is Ks' safe time (TsafDS), the time that the new KSK is said to be SafeDS. Consequently, Kc is said to be ExpiredDS (TexpDS).  </p>
<p id="rfc.section.3.2.2.p.16">TsafDS(Ks) &gt;= TactDS(Ks) + DcacheP <br> TexpDS(Kc) &gt;= TretDS(Kc) + DcacheP </p>
<p id="rfc.section.3.2.2.p.17">S(Kc) = (DNSKEY Propagated, DS Dead)  <br> C(kc) = Known ExpiredDS <br> S(Ks) = (DNSKEY Propagated, DS Propagated)  <br> C(Ks) = Known SafeDS </p>
<p id="rfc.section.3.2.2.p.18">Event 6: When the new DS record has been propagated, the DNSKEY record of Kc can be removed from the zone.  This is Kc' removal time (Trem), the time that Kc is said to be Removed.  </p>
<p id="rfc.section.3.2.2.p.19">Trem(Kc) &gt;= TsafDS(Ks) </p>
<p id="rfc.section.3.2.2.p.20">S(Kc) = (DNSKEY Withdrawn, DS Dead) <br> C(Kc) = Removed ExpiredDS </p>
<p id="rfc.section.3.2.2.p.21">Event 7: From the perspective of the authoritative server, the rollover is complete.  After some delay, The DNSKEY record for Kc has also expired from the caches.  </p>
<p id="rfc.section.3.2.2.p.22">Tfor(Kc) &gt;= Trem(Kc) + DcacheK </p>
<p id="rfc.section.3.2.2.p.23">S(Kc) = (DNSKEY Dead, DS Dead) <br> C(Kc) = Forgotten ExpiredDS </p>
<h1 id="rfc.section.3.2.3">
<a href="#rfc.section.3.2.3">3.2.3.</a> Double-DS</h1>
<p id="rfc.section.3.2.3.p.1">In this case, first the new DS record is published.  After waiting for this change to propagate into the caches of all validating resolvers, the KSK is changed.  After waiting another interval, during which the old DNSKEY RRset expires from caches, the old DS record is removed.  </p>
<p id="rfc.section.3.2.3.p.2">If you want to keep the size of the DNSKEY RRset to a minimum, this rollover method is preferred over Double-RRset.  It does require the additional administrative overhead of two interactions with the parent to roll a KSK.  </p>
<div id="#rfc.figure.6"></div>
<p>The timeline diagram looks like this:</p>
<pre>
        |1|  |2|     |3|     |4|     |5|   |6|     |7|
Kc       |    |       |       |       |     |       |
- DNSKEY |----|-------|-------|DcacheK|     |       |
- DS     |----|-------|-------|-------|-----|DcacheP|
         |    |       |       |       |     |       |
                              Trem    Tfor  TretDS  TexpDS

Ks       |    |       |       |       |     |       |
- DNSKEY |    |       |       |DcacheK|-----|-------|---
- DS     |    |DcacheP|-------|-------|-----|-------|---
         |    |       |       |       |     |       |
         Tgen TactDS  TsafDS  Tpub    Tkno
    </pre>
<p>Figure: KSK Double-DS Rollover.</p>
<p id="rfc.section.3.2.3.p.3">Event 1: Ks is generated at time Tgen.  </p>
<p id="rfc.section.3.2.3.p.4">S(Ks) = (DNSKEY Generated, DS Generated) <br> C(Ks) = Generated </p>
<p id="rfc.section.3.2.3.p.5">Event 2: Before we introduce the new key Ks into the zone, we are going to submit the new DS.  We can do that, because there exists a valid chain of trust for the same algorithm (Kc).  This time is Ks' submit time (TactDS), the time that the DS record for Ks was submitted and is said to be ActiveDS.  </p>
<p id="rfc.section.3.2.3.p.6">TactDS(Ks) &gt;= Tgen(Ks) </p>
<p id="rfc.section.3.2.3.p.7">S(Ks) = (DNSKEY Generated, DS Introduced) <br> C(Kc) = ActiveDS </p>
<p id="rfc.section.3.2.3.p.8">After some delay, the DS becomes available in the parent zone.  </p>
<p id="rfc.section.3.2.3.p.9">Event 3: Some time later, the new DS RRset has been propagated.  This is Ks' safe time (TsafDS), the time that Ks is said to be SafeDS.  </p>
<p id="rfc.section.3.2.3.p.10">TsafDS(Ks) &gt;= TactDS(Ks) + DcacheP </p>
<p id="rfc.section.3.2.3.p.11">S(Ks) = (DNSKEY Generated, DS Propagated) <br> C(Ks) = SafeDS </p>
<p id="rfc.section.3.2.3.p.12">Event 4: Because there are now two trust anchors a resolver can use, we can switch the KSK in the DNSKEY RRset.  We stop signing with Kc and sign the DNSKEY RRset with Ks.  This time is Ks' publish time (Tpub), the time that Ks is said to be Published.  It is also Kc' removal time (Trem), the time that Kc is said to be Removed.  </p>
<p id="rfc.section.3.2.3.p.13">Tpub(Ks) &gt;= TsafDS(Ks) <br> Trem(Kc) == Tpub(Ks) </p>
<p id="rfc.section.3.2.3.p.14">S(Kc) = (DNSKEY Withdrawn, DS Propagated) <br> C(Kc) = Removed SafeDS <br> S(Ks) = (DNSKEY Introduced, DS Propagated) <br> C(Ks) = Published SafeDS </p>
<p id="rfc.section.3.2.3.p.15">Event 5: We have to wait before Kc has been expired from the caches, before we can withdraw the DS record of Kc.  When the DNSKEY RRset that includes Kc has been expired, Kc is said to be forgotten and Ks is said to be Known.  This happens at Ks' known time, given by: </p>
<p id="rfc.section.3.2.3.p.16">Tkno(Ks) &gt;= Tpub(Ks) + DcacheK <br> Tfor(Kc) == Tkno(Ks) </p>
<p id="rfc.section.3.2.3.p.17">S(Kc) = (DNSKEY Dead, DS Propagated) <br> C(Kc) = Forgotten SafeDS <br> S(Ks) = (DNSKEY Propagated, DS Propagated) <br> C(Ks) = Known SafeDS </p>
<p id="rfc.section.3.2.3.p.18">Event 6: Now that we have a key Ks that is said to be Propagated and SafeDS,  we are ready to withdraw the DS for Kc.  We call this Kc' retire time (TretDS), the time that we don't need a secure delegation for Kc anymore.  </p>
<p id="rfc.section.3.2.3.p.19">TretDS(Kc) &gt;= Tkno(Ks) </p>
<p id="rfc.section.3.2.3.p.20">S(Kc) = (DNSKEY Dead, DS Withdrawn) <br> C(Kc) = Forgotten RetiredDS </p>
<p id="rfc.section.3.2.3.p.21">Event 7: From the perspective of the authoritative server, the rollover is complete.  After some delay, The DS record for Kc has expired from the caches.  This is Texp, given by: </p>
<p id="rfc.section.3.2.3.p.22">Texp(Kc) &gt;= Tret(Kc) + DcacheP </p>
<p id="rfc.section.3.2.3.p.23">S(Kc) = (DNSKEY Dead, DS Dead) <br> C(Kc) = Forgotten ExpiredDS </p>
<h1 id="rfc.section.3.2.4">
<a href="#rfc.section.3.2.4">3.2.4.</a> Interaction with Configured Trust Anchors</h1>
<p id="rfc.section.3.2.4.p.1">Zone managers may want to take into account the possibility that some validating resolvers may have their KSK configured as a trust anchor directly, as described in <a href="#RFC5011">[RFC5011]</a>.  This influences the value of DcacheK, the time to guarantee that any resolver that has a copy of the newest DNSKEY RRset.  </p>
<h1 id="rfc.section.3.2.4.1">
<a href="#rfc.section.3.2.4.1">3.2.4.1.</a> Adding a KSK</h1>
<p id="rfc.section.3.2.4.1.p.1">When the new key is introduced, the delay DcacheK between Tpub and Tkno is also subject to the condition: </p>
<p id="rfc.section.3.2.4.1.p.2">DcacheK' = MAX(DcacheK, 2 * (queryInterval + x * retryTime) + c) </p>
<p id="rfc.section.3.2.4.1.p.3">The right hand side of this expression is two times the Active Refresh time defined in section 2.3 in <a href="#RFC5011">[RFC5011]</a>.  This ensures that the successor key is at least seen twice by 5011-enabled validators.  The parameter x is the maximum number of retries that is taken as a safety margin, in case an Active Refresh fails.  The parameter c is a constant that can be taken as an additional safety margin.  </p>
<p id="rfc.section.3.2.4.1.p.4">Most probably, this delays the time when a key is said to be Known.  </p>
<h1 id="rfc.section.3.2.4.2">
<a href="#rfc.section.3.2.4.2">3.2.4.2.</a> Removing a KSK</h1>
<p id="rfc.section.3.2.4.2.p.1">When the current key is ready to be removed from the zone, it is instead said to be Revoked.  The REVOKE bit is said and the key is published for DcacheK' time: </p>
<p id="rfc.section.3.2.4.2.p.2">DcacheK' = MAX(DcacheK, (queryInterval + x * retryTime) + c) </p>
<p id="rfc.section.3.2.4.2.p.3">The right hand side of this expression is the Active Refresh time defined in section 2.3 in <a href="#RFC5011">RFC5011</a> <cite title="NONE">[RFC5011]</cite>.  This ensures that the revoked key is at least seen once by 5011-enabled validators.  </p>
<p id="rfc.section.3.2.4.2.p.4">After that delay, we can guarantee that every 5011-enabled resolver has seen the revoked key and it may be removed from the zone.  Another DcacheK delay, the key has fully expired from all the resolver caches.  </p>
<h1 id="rfc.section.3.3">
<a href="#rfc.section.3.3">3.3.</a> <a href="#stss-rollovers" id="stss-rollovers">Rollovers in a Single Type Signing Scheme</a>
</h1>
<p id="rfc.section.3.3.p.1">In situations where you use a Single Type Signing Scheme, you can combine one of the ZSK rollover methods with one of the KSK rollover methods.  However, not all combinations are possible.  The KSK Double-DS rollover is only suitable for combining with the ZSK Double-RRSIG rollover, because both keep the DNSKEY RRset to a minimum size.  The other ZSK rollovers require a period where both the current key and its successor are being served at the same time.  </p>
<p id="rfc.section.3.3.p.2">The KSK Double-RRset method is suitable with both the other ZSK rollover methods, but does not gain any advantages when combined with the ZSK Pre-Publication method.  Therefore, we can leave that combination out.  The KSK Double-Signature method is suitable with both the ZSK Double-Signature and the ZSK Pre-Publication method.  </p>
<p id="rfc.section.3.3.p.3">To conclude, we can identify four different rollover methods for the Single Type Signing Scheme.  </p>
<h1 id="rfc.section.3.3.1">
<a href="#rfc.section.3.3.1">3.3.1.</a> Double-RRset</h1>
<p id="rfc.section.3.3.1.p.1">This is a combination of the ZSK Double-Signature rollover and the KSK Double-RRset rollover.  The new KSK is added to the DNSKEY RRset, and all RRsets are then signed with both the old and new key, and the new DS record added to the parent zone.  After waiting a suitable interval for the old DS and all zone RRsets to expire from validating resolver caches, the old DNSKEY and DS record are removed.  </p>
<p id="rfc.section.3.3.1.p.2">Double-RRset is the fastest way to replace keys in a Single Type Signing Scheme.  However, it does have a lot of disadvantages of - it requires two signatures and two keys during the period of the rollover, as well as two interactions with the parent.  </p>
<div id="#rfc.figure.7"></div>
<p>The timeline diagram looks like this:</p>
<pre>
        |1|  |2|     |3|   |4|     |5|
Kc       |    |       |     |       |
- RRSIG  |----|-------|-----|DcacheZ|
- DNSKEY |----|-------|-----|DcacheK|
- DS     |----|-------|-----|DcacheP|
         |    |       |     |       |
                            Trem    Tfor
                            Tret    Texp
                            TretDS  TexpDS

Ks       |    |       |     |       |
- RRSIG  |    |DcacheZ|-----|-------|---
- DNSKEY |    |DcacheK|-----|-------|---
- DS     |    |DcacheP|-----|-------|---
         |    |       |     |       |
         Tgen Tpub    Tkno 
              Tact    Tsaf
              TactDS  TsafDS
    </pre>
<p>Figure: STSS Double-RRset Rollover.</p>
<p id="rfc.section.3.3.1.p.3">The rollover method is almost the same as that of the KSK Double-RRset rollover, except we now have to take DcacheZ into account.  </p>
<h1 id="rfc.section.3.3.2">
<a href="#rfc.section.3.3.2">3.3.2.</a> Double-Signature</h1>
<p id="rfc.section.3.3.2.p.1">This is a combination of the ZSK Double-Signature rollover and the KSK Double-Signature rollover.  The new key is added to the DNSKEY RRset and all RRsets are then signed with both the old and new key.  After waiting for the old RRsets to expire from caches, the DS record in the parent zone is changed.  After waiting a further interval for this change to be reflected in caches, the old key is removed from the DNSKEY RRset, and all RRsets are signed with the new key only.  </p>
<p id="rfc.section.3.3.2.p.2">This rollover minimizes the number of interactions with the parent zone.  However, for the period of the rollover all RRsets are still signed with two keys, so increasing the size of the zone and the size of the response.  </p>
<div id="#rfc.figure.8"></div>
<p>The timing diagram for such a rollover is:</p>
<pre>
        |1|  |2|     |3|   |4|     |5|    |6|     |7|
Kc       |    |       |     |       |      |       |
- RRSIG  |----|-------|-----|-------|------|DcacheZ|
- DNSKEY |----|-------|-----|-------|------|DcacheK|
- DS     |----|-------|-----|DcacheP|      |       |
         |    |       |     |       |      |       |
                            TretDS  TexpDS Trem    Tfor
                                           Tret    Texp

Ks       |    |       |     |       |      |       |
- RRSIG  |    |DcacheZ|-----|-------|------|-------|---
- DNSKEY |    |DcacheK|-----|-------|------|-------|---
- DS     |    |       |     |DcacheP|------|-------|---
         |    |       |     |       |      |       |
         Tgen Tpub    Tkno  TactDS  TsafDS
              Tact    Tsaf
    </pre>
<p>Figure: STSS Double-Signature Rollover.</p>
<p id="rfc.section.3.3.2.p.3">The rollover diagram is almost the same as that of the KSK Double-Signature rollover, except we now have to take DcacheZ into account.  </p>
<h1 id="rfc.section.3.3.3">
<a href="#rfc.section.3.3.3">3.3.3.</a> Pre-Publication</h1>
<p id="rfc.section.3.3.3.p.1">This is a combination of the ZSK Pre-Publication rollover and the KSK Double-Signature rollover and requires only one interaction with the parent.  In addition, your non-DNSKEY RRsets require only one signature during the rollover.  If speed is not an issue, this rollover method is considered to be the best practice in a Single Type Signing Scheme environment.  </p>
<p id="rfc.section.3.3.3.p.2">The new key is added to the DNSKEY RRset and the DNSKEY RRset is then signed with both the old and new key.  Other RRsets will only be signed with the old key.  Only after the DS has been switched, the signatures of other RRsets are replaced with that of the new key.  After waiting a further interval for this change to be reflected in caches, the old key is removed from the RRset, and is signed with the new key only.  </p>
<div id="#rfc.figure.9"></div>
<p>The timeline diagram looks like this:</p>
<pre>
        |1|  |2|     |3|   |4|     |5|     |6|     |7|  |8|     |9|
Kc       |    |       |     |       |       |       |    |       |
- RRSIG  |----|-------|-----|-------|-------|DcacheZ|    |       |
- DNSKEY |----|-------|-----|-------|-------|-------|----|DcacheK|
- DS     |----|-------|-----|DcacheP|       |       |    |       |
         |    |       |     |       |       |       |    |       |
                            TretDS  TexpDS  Tret    Texp Trem    Tfor

Ks       |    |       |     |       |       |       |    |       |
- RRSIG  |    |       |     |       |       |DcacheZ|----|-------|
- DNSKEY |    |DcacheK|-----|-------|-------|-------|----|-------|
- DS     |    |       |     |DcacheP|-------|-------|----|-------|
         |    |       |     |       |       |       |    |       |
         Tgen Tpub    Tkno  TactDS  TsafDS  Tact    Tsaf
    </pre>
<p>Figure: STSS Pre-Publication Rollover.</p>
<p id="rfc.section.3.3.3.p.3">Event 1: Key Ks is generated at the generate time (Tgen).  </p>
<p id="rfc.section.3.3.3.p.4">S(Ks) = (DNSKEY Generated, RRSIG Generated, DS Generated) <br> C(Ks) = Generated </p>
<p id="rfc.section.3.3.3.p.5">Event 2: The DNSKEY record of Ks is put into the zone, i.e. it is added to the DNSKEY RRset which is then re-signed with the Ks and all other current KSKs (including Kc).  The time at which this occurs is Ks' publication time (Tpub), and the key is now said to be Published.  Note that the key is not yet used to sign other RRsets.  </p>
<p id="rfc.section.3.3.3.p.6">Tpub(Ks) &gt;= Tgen(Ks) </p>
<p id="rfc.section.3.3.3.p.7">S(Ks) = (DNSKEY Introduced, RRSIG Generated, DS Generated) <br> C(Ks) = Published </p>
<p id="rfc.section.3.3.3.p.8">Event 3: Before we can switch the DS, the DNSKEY record for Ks must be published for long enough (DcacheK) to guarantee that any resolver that has a copy of the DNSKEY RRset also includes this key.  After this delay, the key is said to be Known and the DS record may be submitted.  The time at which this event occurs is Ks' known time (Tkno), which is given by: </p>
<p id="rfc.section.3.3.3.p.9">Tkno(Ks) &gt;= Tpub(Ks) + DcacheK </p>
<p id="rfc.section.3.3.3.p.10">S(Ks) = (DNSKEY Propagated, RRSIG Generated, DS Generated) <br> C(ks) = Known </p>
<p id="rfc.section.3.3.3.p.11">Event 4: The time that the DS record of Ks is submitted is at Ks' submit time (TactDS).  Ks is said to be ActiveDS.  At the same time, the DS record of Kc is withdrawn (TretDS) and Kc is said to be RetiredDS.  </p>
<p id="rfc.section.3.3.3.p.12">TactDS(Ks) &gt;= Tkno(Ks) TretDS(Kc) == TactDS(Ks) </p>
<p id="rfc.section.3.3.3.p.13">S(Kc) = (DNSKEY Propagated, RRSIG Propagated, DS Withdrawn) <br> C(Kc) = Known Safe RetiredDS <br> S(Ks) = (DNSKEY Propagated, RRSIG Generated, DS Introduced) <br> C(Ks) = Known ActiveDS </p>
<p id="rfc.section.3.3.3.p.14">Some time later, the new DS RRset is published at the parent.  </p>
<p id="rfc.section.3.3.3.p.15">Event 5: Some time later, we can guarantee that all validating resolvers use the DS RRset that includes a copy of the DS record of DS.  At this time, Ks' safe time (TsafDS), Ks is said to be SafeDS.  But we still use Kc as ZSK.  </p>
<p id="rfc.section.3.3.3.p.16">TsafDS(Ks) &gt;= TactDS(Ks) + DcacheP <br> TexpDS(Kc) &gt;= TretDS(Kc) + DcacheP </p>
<p id="rfc.section.3.3.3.p.17">S(Kc) = (DNSKEY Propagated, RRSIG Propagated, DS Dead) <br> C(kc) = Known Safe ExpiredDS <br> S(Ks) = (DNSKEY Propagated, RRSIG Generated, DS Propagated) <br> C(Ks) = Known SafeDS </p>
<p id="rfc.section.3.3.3.p.18">Event 6: At some point in time, the decision is made to actually start signing the zone using the successor key.  This will be when the current key has been in use for an interval equal to the ZSK lifetime.  This point in time is Ks' active time (Tact), the time that Ks is said to be Active.  It is also Kc' retire time (Tret), the time that Kc is said to be Retired.  </p>
<p id="rfc.section.3.3.3.p.19">Tact(Ks) &gt;= TsafDS(Ks) <br> Tret(Kc) == Tact(Ks) </p>
<p id="rfc.section.3.3.3.p.20">S(Kc) = (DNSKEY Propagated, RRSIG Withdrawn, DS Dead)) <br> C(Kc) = Known Retired ExpiredDS <br> S(Ks) = (DNSKEY Propagated, RRSIG Introduced, DS Propagated)) <br> C(Ks) = Known Active SafeDS </p>
<p id="rfc.section.3.3.3.p.21">Event 7: Kc needs to be retained in the zone whilst any RRSIG records created by the retired key are still published in the zone or held in resolver caches.  In other words, Kc should be retained in the zone until all RRSIG records created by Ks have been propagated.  This time is Ks' safe time (Tsaf), the time that Ks is considered to be Safe, and Kc' expiration time (Texp), the time that Kc is considered to be Expired.  </p>
<p id="rfc.section.3.3.3.p.22">Tsaf(Ks) &gt;= Tact(Ks) + DcacheZ <br> Texp(Kc) == Tsaf(Ks) </p>
<p id="rfc.section.3.3.3.p.23">S(Kc) = (DNSKEY Propagated, RRSIG Dead, DS Dead) <br> C(Kc) = Known Expired ExpiredDS <br> S(Ks) = (DNSKEY Propagated, RRSIG Propagated, DS Propagated) <br> C(Ks) = Known Safe SafeDS </p>
<p id="rfc.section.3.3.3.p.24">Event 8: When all new signatures have been propagated, Kc can be removed from the zone and the DNSKEY RRset re-signed with the current KSK.  This time is Kc' removal time (Trem), the time that Kc is considered to be Removed.  </p>
<p id="rfc.section.3.3.3.p.25">Trem(Kc) &gt;= Tsaf(Ks) </p>
<p id="rfc.section.3.3.3.p.26">S(Kc) = (DNSKEY Withdrawn, RRSIG Dead, DS Dead) <br> C(Kc) = Removed Expired ExpiredDS </p>
<p id="rfc.section.3.3.3.p.27">Event 9: From the perspective of the authoritative server, the rollover is complete.  After some delay, The DNSKEY record for Kc has expired from the caches.  This is Tfor, the time that the key is said to be Forgotten.  </p>
<p id="rfc.section.3.3.3.p.28">Tfor(Kc) &gt;= Trem(Kc) + DcacheK </p>
<p id="rfc.section.3.3.3.p.29">S(Kc) = (DNSKEY Dead, RRSIG Dead, DS Dead) <br> C(Kc) = Forgotten Expired ExpiredDS </p>
<h1 id="rfc.section.3.3.4">
<a href="#rfc.section.3.3.4">3.3.4.</a> Double-DS</h1>
<p id="rfc.section.3.3.4.p.1">This is a combination of the ZSK Double-RRSIG rollover and the KSK Double-DS rollover.  This keeps your DNSKEY RRset to a minimum size, but at the cost of double signatures in your zone and double DS at the parent.  </p>
<p id="rfc.section.3.3.4.p.2">The new signatures are added to the zone and the new DS is submitted.  Once all signatures and the DS record have been propagated, the DNSKEY is switched.  After waiting a further interval for this switch to be reflected in caches, the old signatures are removed and the old DS is withdrawn from the parent zone.  </p>
<div id="#rfc.figure.10"></div>
<p>The timeline diagram looks like this:</p>
<pre>
        |1|  |2|     |3|   |4|     |5|     |6|     |7|  |8|     |9|
Kc       |    |       |     |       |       |       |    |       |
- RRSIG  |----|-------|-----|-------|-------|DcacheZ|    |       |
- DNSKEY |----|-------|-----|-------|-------|-------|----|DcacheK|
- DS     |----|-------|-----|DcacheP|       |       |    |       |
         |    |       |     |       |       |       |    |       |
                            TretDS  TexpDS  Tret    Texp Trem    Tfor

Ks       |    |       |     |       |       |       |    |       |
- RRSIG  |    |       |     |       |       |DcacheZ|----|-------|
- DNSKEY |    |DcacheK|-----|-------|-------|-------|----|-------|
- DS     |    |       |     |DcacheP|-------|-------|----|-------|
         |    |       |     |       |       |       |    |       |
         Tgen Tpub    Tkno  TactDS  TsafDS  Tact    Tsaf
    </pre>
<p>Figure: STSS Double-DS Rollover.</p>
<p id="rfc.section.3.3.4.p.3">Event 1: Key Ks is generated at the generate time (Tgen).  </p>
<p id="rfc.section.3.3.4.p.4">S(Ks) = (DNSKEY Generated, RRSIG Generated, DS Generated) <br> C(Ks) = Generated </p>
<p id="rfc.section.3.3.4.p.5">Event 2: Before we introduce the new key Ks into the zone, we are going to add the new signatures and submit the new DS.  This time is Ks' active time (Tact), the time that Ks is said to be Active.  It is also Ks' submit time (TactDS), the time that the DS record for Ks was submitted and is said to be ActiveDS.  </p>
<p id="rfc.section.3.3.4.p.6">Tact(Ks) &gt;= Tgen(Ks) <br> TactDS(Ks) &gt;= Tgen(Ks) </p>
<p id="rfc.section.3.3.4.p.7">S(Ks) = (DNSKEY Generated, RRSIG Introduced, DS Introduced) <br> C(Kc) = Active ActiveDS </p>
<p id="rfc.section.3.3.4.p.8">After some delay, the DS becomes available in the parent zone.  </p>
<p id="rfc.section.3.3.4.p.9">Event 3: Some time later, the new signatures and the new DS RRset have been propagated.  This is Ks' safe time (Tsaf, TsafDS), the time that Ks is said to be Safe and SafeDS.  </p>
<p id="rfc.section.3.3.4.p.10">Tsaf(Ks) &gt;= Tact(Ks) + DcacheZ <br> TsafDS(Ks) &gt;= TactDS(Ks) + DcacheP </p>
<p id="rfc.section.3.3.4.p.11">S(Ks) = (DNSKEY Generated, RRSIG Propagated, DS Propagated) <br> C(Ks) = Safe SafeDS </p>
<p id="rfc.section.3.3.4.p.12">Event 4: Because there are now two trust anchors a resolver can use, we can switch the KSK in the DNSKEY RRset.  This time is Ks' publish time (Tpub), the time that Ks is said to be Published.  It is also Kc' removal time (Trem), the time that Kc is removed from the zone.  </p>
<p id="rfc.section.3.3.4.p.13">Tpub(Ks) &gt;= MAX(TsafDS(Ks), Tsaf(Ks)) <br> Trem(Kc) == Tpub(Ks) </p>
<p id="rfc.section.3.3.4.p.14">S(Kc) = (DNSKEY Withdrawn, RRSIG Propagated, DS Propagated) <br> C(Kc) = Removed Safe SafeDS <br> S(Ks) = (DNSKEY Introduced, RRSIG Propagated, DS Propagated) <br> C(Ks) = Published Safe SafeDS </p>
<p id="rfc.section.3.3.4.p.15">Event 5: We have to wait before the signatures of Kc and its corresponding DS record have been expired from the caches, before we can withdraw the DNSKEY record of Kc.  When the DNSKEY RRset that includes Kc has been expired, Ks is said to be Known and Kc is said to be Removed.  This happens at Ks' known time, given by: </p>
<p id="rfc.section.3.3.4.p.16">Tkno(Ks) &gt;= Tpub(Ks) + DcacheK, Trem(Kc) == Tkno(Ks) </p>
<p id="rfc.section.3.3.4.p.17">S(Kc) = (DNSKEY Dead, RRSIG Propagated, DS Propagated) <br> C(Kc) = Forgotten Safe SafeDS <br> S(Ks) = (DNSKEY Propagated, RRSIG Propagated, DS Propagated) <br> C(Ks) = Known Safe SafeDS </p>
<p id="rfc.section.3.3.4.p.18">Event 6: Now that we have a key Ks that is said to be Propagated and SafeDS,  we are ready to withdraw the signatures and DS for Kc.  We call this Kc' retire time (Tret, TretDS), the time Kc is said to be Retired and RetiredDS.  </p>
<p id="rfc.section.3.3.4.p.19">Tret(Kc) &gt;= Tkno(Ks) <br> TretDS(Kc) &gt;= Tkno(Ks) </p>
<p id="rfc.section.3.3.4.p.20">S(Kc) = (DNSKEY Dead, RRSIG Withdrawn, DS Withdrawn) <br> C(Kc) = Forgotten Retired RetiredDS </p>
<p id="rfc.section.3.3.4.p.21">Event 7: From the perspective of the authoritative server, the rollover is complete.  After some delay, The signatures of Kc and its corresponding DS record have expired from the caches.  </p>
<p id="rfc.section.3.3.4.p.22">Texp(Kc) &gt;= Tret(Kc) + DcacheZ <br> TexpDS(Kc) &gt;= TretDS(Kc) + DcacheP </p>
<p id="rfc.section.3.3.4.p.23">S(Kc) = (DNSKEY Dead, RRSIG Dead, DS Dead) <br> C(Kc) = Forgotten Expired ExpiredDS </p>
<h1 id="rfc.section.3.4">
<a href="#rfc.section.3.4">3.4.</a> <a href="#standby" id="standby">Stand-by Keys</a>
</h1>
<p id="rfc.section.3.4.p.1">Although keys will usually be rolled according to some regular schedule, there may be occasions when an emergency rollover is required, e.g. if the active key is suspected of being compromised.  The aim of the emergency rollover is to allow the zone to be re-signed with a new key as soon as possible.  As a key must be ready to sign the zone, having at least one additional key (a stand-by key) in this state at all times will minimise delay.  </p>
<p id="rfc.section.3.4.p.2">In the case of a ZSK, a stand-by key only makes sense with the Pre-Publication method, since with the Double-Signature and Double-RRSIG methods, the stand-by key would be used for signing.  The goal is to make the stand-by key Known.  This goal is reached at Tkno, step 3 in the Pre-Publication method timeline diagram.  </p>
<p id="rfc.section.3.4.p.3">A successor key must always be published soon enough so that the key lifetime of the predecessor key does not exceed.  That means that the successor ZSK Ks must at latest be published DcacheK delay before the lifetime of the predecessor ZSK kc has reached: </p>
<p id="rfc.section.3.4.p.4">Tpub(Ks) &lt;= Tact(Kc) + Lzsk - DcacheK </p>
<p id="rfc.section.3.4.p.5">Here, Lzsk is the lifetime of ZSKs according to policy.  </p>
<p id="rfc.section.3.4.p.6">In the case of a KSK, a stand-by key only makes sense with the Double-DS method, since in the other cases, the key would be needed to sign the DNSKEY RRset.  The goal is to get the stand-by key in the SafeDS condition.  This goal is reached at TsafDS, step 3 in the Double-DS method timeline diagram.  </p>
<p id="rfc.section.3.4.p.7">The DS record for the successor KSK Ks should be propagated to the caches before the key lifetime of the predecessor KSK Kc exceeds: </p>
<p id="rfc.section.3.4.p.8">TactDS(Ks) &lt;= Tact(Kc) + Lksk - DcacheP </p>
<p id="rfc.section.3.4.p.9">Here, Lksk is the lifetime of KSKs according to policy.  </p>
<p id="rfc.section.3.4.p.10">Because a stand-by KSK only makes sense with the Double-DS method, stand-by keys in a STSS is not applicable.  This is because the Double-DS method is not easy integratable with one of the ZSK rollover methods.  </p>
<h1 id="rfc.section.4">
<a href="#rfc.section.4">4.</a> <a href="#policy" id="policy">Policy rollover</a>
</h1>
<p id="rfc.section.4.p.1">Besides your scheduled and unscheduled key rollovers, changes in policy may occur.  The initial transition is enabling DNSSEC. The counterpart, disabling DNSSEC, is also possible.  Two other policy changes we have encountered are are algorithm rollover and changing signing schemes.  </p>
<h1 id="rfc.section.4.1">
<a href="#rfc.section.4.1">4.1.</a> <a href="#enabling" id="enabling">Enabling DNSSEC</a>
</h1>
<p id="rfc.section.4.1.p.1">When a zone makes the transition from going insecure to secure, the initial set of keys safely need to be introduced into the zone.  The goals of this event is to make a ZSK (Kz) and a KSK (Kk) both Known and Safe.  </p>
<p id="rfc.section.4.1.p.2">One must take into account that resolver caches may hold unsigned RRsets.  Therefore, validating resolvers should not know about the initial DNSKEY RRset before all unsigned RRsets have been expired from the caches.  This means that the zone must be fully signed, before the DS associated with the initial KSK is published.  Only if you are afraid that a key scraper fetches your DNSKEY RRset too soon, you should wait with publishing your DNSKEY RRset until enough time has elapsed for all unsigned RRsets to expire from all resolver caches.  The ZSK and KSK can be the same key, for example in a Single Type Signing Scheme.  </p>
<div id="#rfc.figure.11"></div>
<p></p>

<p>The timeline diagram is shown below:</p>
<pre>
        |1|  |2|     |3|    |4|     |5|
Kz       |    |       |      |       |
- RRSIG  |    |DcacheZ|------|-------|---
- DNSKEY |    |DcacheK|------|-------|---
         |    |       |      |       |
         Tgen Tpub    Tkno
              Tact    Tsaf

Kk       |    |       |      |       |
- DNSKEY |    |DcacheK|------|-------|---
- DS     |    |       |      |DcacheP|---
         |    |       |      |       |
         Tgen Tpub    Tkno   TactDS  TsafDS
  </pre>
<p>Figure: Enabling DNSSEC.</p>
<p id="rfc.section.4.1.p.4">Event 1: Kk and Kz are generated.  We call this Tgen, the time that the keys were Generated (note that Tgen for Kk could be different that Tgen for Kz).  </p>
<p id="rfc.section.4.1.p.5">S(Kk) = (DNSKEY Generated, DS Generated) <br> C(Kk) = Generated <br> S(Kz) = (DNSKEY Generated, RRSIG Generated) <br> C(Kk) = Generated </p>
<p id="rfc.section.4.1.p.6">Event 2: The keys are put into the zone and are immediately used for signing.  Because there exists no pointer to the fact that our zone is DNSSEC enabled, the DNSKEY and RRSIG records may be introduced at the same time.  This is the publish time (Tpub), the time that the keys are Published.  It is also Kz' active time (Tact), the time that Kz is said to be Active.  </p>
<p id="rfc.section.4.1.p.7">Tpub(Kk) &gt;= Tgen(Kk) <br> Tpub(Kz) &gt;= Tgen(Kz) <br> Tact(Kz) == Tpub(Kz) </p>
<p id="rfc.section.4.1.p.8">S(Kk) = (DNSKEY Introduced, DS Generated) <br> C(Kk) = Published <br> S(Kz) = (DNSKEY Introduced, RRSIG Introduced) <br> C(Kz) = Published Active </p>
<p id="rfc.section.4.1.p.9">Event 3: Before we can submit the DS record, Kz must be considered Known and Safe.  Once that has happened, we are done for the ZSK.  This time is Kz' known time (Tkno).  </p>
<p id="rfc.section.4.1.p.10">Tkno(Kk) &gt;= Tpub(Kk) + DcacheP <br> Tkno(Kk) == Tkno(Kz) <br> Tsaf(Kz) &gt;= Tact(Kz) + DcacheZ </p>
<p id="rfc.section.4.1.p.11">S(Kk) = (DNSKEY Propagated, DS Generated) <br> C(Kk) = Known <br> S(Kz) = (DNSKEY Propagated, RRSIG Propagated) <br> C(Kz) = Known Safe </p>
<p id="rfc.section.4.1.p.12">Because this is the first DNSKEY for this zone, the Dttl for the DNSKEY RRset is Ingc, the negative cache interval from the zone's SOA record, calculated according to <a href="#RFC2308">RFC2308</a> <cite title="NONE">[RFC2308]</cite> as the minimum of the TTL of the SOA record itself and the MINIMUM field in the record's parameters: </p>
<p id="rfc.section.4.1.p.13">Ingc = min(TTL(SOA), MINIMUM) </p>
<p id="rfc.section.4.1.p.14">Event 4: Once we are sure of the fact that the DNSKEY RRset and all RRSIG records have reached the caches, we may submit the DS to the parent.  We call this TactDS, the time that the DS has been submitted to the parent.  </p>
<p id="rfc.section.4.1.p.15">TactDS(Kk) &gt;= Tkno(Kk) </p>
<p id="rfc.section.4.1.p.16">S(Kk) = (DNSKEY Propagated, DS Introduced) <br> C(Kk) = Known ActiveDS </p>
<p id="rfc.section.4.1.p.17">Event 5: Some time later, the DS has been published in the parent zone.  Some more time later, all resolvers that have a copy of the DS RRset have one that includes the DS record of Kk.  </p>
<p id="rfc.section.4.1.p.18">TsafDS(Kk) &gt;= TactDS(Kk) + DcacheP </p>
<p id="rfc.section.4.1.p.19">S(Kk) = (DNSKEY Propagated, DS Propagated) <br> C(Kk) = Known SafeDS </p>
<p id="rfc.section.4.1.p.20">Because this is the first DS for this zone, the Dttl for the DS RRset is Ingc, for the same reason as in step 3 for the DNSKEY RRset.  </p>
<h1 id="rfc.section.4.2">
<a href="#rfc.section.4.2">4.2.</a> <a href="#disabling" id="disabling">Disabling DNSSEC</a>
</h1>
<p id="rfc.section.4.2.p.1">When a zone decides for whatever reason to go back to the Insecure status, the set of keys safely need to be removed from the zone.  We assume that there is a KSK (Kk) and a ZSK (Kz) that are Known and Safe.  The goals of this event is to make Kk and Kz both Forgotten and Expired.  </p>
<div id="#rfc.figure.12"></div>
<p></p>

<p>The timeline diagram is shown below:</p>
<pre>
        |0|  |1|     |3|    |4|     |5|
Kz       |    |       |      |       |
- RRSIG  |----|-------|------|DcacheZ|
- DNSKEY |----|-------|------|DcacheK|
         |    |       |      |       |
                             Trem    Tfor
                             Tret    Texp

Kk       |    |       |      |       |
- DNSKEY |----|-------|------|DcacheK|
- DS     |----|DcacheP|      |       |
         |    |       |      |       |
              TretDS  TexpDS Trem    Tfor

  </pre>
<p>Figure: Disabling DNSSEC.</p>
<p id="rfc.section.4.2.p.3">Event 1: The DS record of Kk needs to be withdrawn.  This time is Kk' retire time (TretDS), the time that Kk is said to be RetiredDS.  </p>
<p id="rfc.section.4.2.p.4">S(Kk) = (DNSKEY Propagated, DS Withdrawn) <br> C(Kk) = Known RetiredDS <br> </p>
<p id="rfc.section.4.2.p.5">Event 2: We have to wait until the DS record of Kk has expired from all resolver caches.  This time is Kk' expire time (TexpDS), the time that Kk is said to be ExpiredDS.  </p>
<p id="rfc.section.4.2.p.6">TexpDS(Kk) &gt;= TretDS(Kk) + DcacheP </p>
<p id="rfc.section.4.2.p.7">S(Kk) = (DNSKEY Propagated, DS Dead) <br> C(Kk) = Known ExpiredDS <br> </p>
<p id="rfc.section.4.2.p.8">Event 3: Now that we can guarantee that no secure chain of trust to Kk exist anymore, we can retire the ZSK and withdraw both keys.  This time is Trem, the time that the keys are removed from the zone.  </p>
<p id="rfc.section.4.2.p.9">Trem(Kk) &gt;= TexpDS(Kk) <br> Trem(Kz) == Trem(Kk) <br> Tret(Kz) == Trem(kz) </p>
<p id="rfc.section.4.2.p.10">S(Kk) = (DNSKEY Withdrawn, DS Dead) <br> C(Kk) = Removed ExpiredDS <br> S(Kz) = (DNSKEY Withdrawn, RRSIG Withdrawn) <br> C(Kz) = Removed Retired </p>
<p id="rfc.section.4.2.p.11">Event 4: After some delay, all information about the keys have expired from the caches.  </p>
<p id="rfc.section.4.2.p.12">Tfor(Kk) &gt;= Trem(Kk) + DcacheK <br> Tfor(Kz) == Tfor(Kk) <br> Texp(Kz) &gt;= Tret(Kz) + DcacheZ </p>
<p id="rfc.section.4.2.p.13">S(Kk) = (DNSKEY Dead, DS Dead) <br> C(Kk) = Forgotten ExpiredDS <br> S(Kz) = (DNSKEY Dead, RRSIG Dead) <br> C(Kz) = Forgotten Expired </p>
<h1 id="rfc.section.4.3">
<a href="#rfc.section.4.3">4.3.</a> <a href="#algo-rollover" id="algo-rollover">Algorithm Rollover</a>
</h1>
<p id="rfc.section.4.3.p.1">When changing algorithms, you can either add, remove or replace an algorithm.  Adding and removing an algorithm follow the same timings as enabling and disabling DNSSEC.  Replacing an algorithm can be done with a STSS Double-Signature rollover or a KSK and ZSK Double-Signature Rollover at the same time.  [MM: This needs more text, but I am awaiting the discussion about algorithm rollover and how to interpret section 2.2 of RFC 4035] </p>
<h1 id="rfc.section.4.4">
<a href="#rfc.section.4.4">4.4.</a> <a href="#split-rollover" id="split-rollover">KSK-ZSK Split or Single Type Signing Scheme</a>
</h1>
<p id="rfc.section.4.4.p.1">When changing signing schemes, you should follow the timelines of the most restricting signing scheme.  The STSS signing scheme makes some rollover combinations unsuitable, thus it can be considered the most restricted signing scheme.  In the case of moving to a KSK-ZSK Split, Ks is used as the successor key in the STSS rollover methods, and it now reflects both the successor ZSK and KSK.  In the case of moving away from a KSK-ZSK Split, Kc is used as the predecessor key in the STSS rollover methods, and it now reflects both the predecessor ZSK and KSK.  [MM: This could perhaps also use more explanation.] </p>
<h1 id="rfc.section.5">
<a href="#rfc.section.5">5.</a> <a href="#iana" id="iana">IANA Considerations</a>
</h1>
<p id="rfc.section.5.p.1">This memo includes no request to IANA.  </p>
<h1 id="rfc.section.6">
<a href="#rfc.section.6">6.</a> <a href="#security" id="security">Security Considerations</a>
</h1>
<p id="rfc.section.6.p.1">This document does not introduce any new security issues beyond those already discussed in <a href="#RFC4033">RFC4033</a> <cite title="NONE">[RFC4033]</cite>, <a href="#RFC4034">RFC4034</a> <cite title="NONE">[RFC4034]</cite>. <a href="#RFC4035">RFC4035</a> <cite title="NONE">[RFC4035]</cite> and <a href="#RFC5011">RFC5011</a> <cite title="NONE">[RFC5011]</cite>.  </p>
<h1 id="rfc.section.7">
<a href="#rfc.section.7">7.</a> <a href="#acknnowledgements" id="acknnowledgements">Acknowledgements</a>
</h1>
<p id="rfc.section.7.p.1">Special acknowledgments and gratitude go out to Stephen Morris, Johan Ihren and John Dickinson, the authors of <a href="#key-timing">the key-timing draft</a> <cite title="NONE">[key-timing]</cite>. Significant parts of the text is taken from that document.  Especially <a href="#zsk-rollovers">Section 3.1</a> and <a href="#ksk-rollovers">Section 3.2</a> are largely copied and adjusted to the new introduced terminology from this document.  </p>
<p id="rfc.section.7.p.2">I also want to acknowledge Yuri Schaeffer, who brought to my attention the idea of key goals (<a href="#goals">Section 1.1.1</a>) and whose discussions helped to shape this document.  </p>
<h1 id="rfc.section.8">
<a href="#rfc.section.8">8.</a> Changes with key-timing draft</h1>
<p id="rfc.section.8.p.1">This document builds further on <a href="#key-timing">draft-ietf-dnsop-dnssec-key-timing</a> <cite title="NONE">[key-timing]</cite>.  The most important changes with respect to that document are: </p>
<p id="rfc.section.8.p.2">- Introduced the concept of Rollover Considerations (Speed vs Size vs Interactions), that causes the existence of different key rollover scenarios.  </p>
<p id="rfc.section.8.p.3">- Introduced the concept of Key Goals.  </p>
<p id="rfc.section.8.p.4">- Key States are unraveled to represent the status of each piece of information seperately.  Provides more flexibility. Used for combining rollover methods in a Single Type Singing Scheme.  </p>
<p id="rfc.section.8.p.5">- What were Key States in the key-timing draft, are now called Key Conditions.  A key can have more than one condition.  </p>
<p id="rfc.section.8.p.6">- Four new Key Conditions are introduced: Known, Safe, Forgotten and Expired, to represent whether information about the key exist in resolver caches.  The key conditions Ready and Dead are deprecated.  </p>
<p id="rfc.section.8.p.7">- Timelines for STSS Rollovers.  </p>
<p id="rfc.section.8.p.8">- Timelines for enabling and disabling DNSSEC.  </p>
<p id="rfc.section.8.p.9">- Text about policy rollover, such as algorithm rollover and changing signing schemes.  </p>
<h1 id="rfc.references">
<a href="#rfc.references">9.</a> References</h1>
<h1 id="rfc.references.1">
<a href="#rfc.references.1">9.1.</a> Informative References</h1>
<table><tbody><tr>
<td class="reference"><b id="RFC4641">[RFC4641]</b></td>
<td class="top">
<a>Kolkman, O.</a> and <a>R. Gieben</a>, "<a href="http://tools.ietf.org/html/rfc4641">DNSSEC Operational Practices</a>", RFC 4641, September 2006.</td>
</tr></tbody></table>
<h1 id="rfc.references.2">
<a href="#rfc.references.2">9.2.</a> Normative References</h1>
<table><tbody>
<tr>
<td class="reference"><b id="RFC2308">[RFC2308]</b></td>
<td class="top">
<a href="mailto:Mark.Andrews@cmis.csiro.au" title="CSIRO - Mathematical and Information Sciences">Andrews, M.</a>, "<a href="http://tools.ietf.org/html/rfc2308">Negative Caching of DNS Queries (DNS NCACHE)</a>", RFC 2308, March 1998.</td>
</tr>
<tr>
<td class="reference"><b id="RFC4033">[RFC4033]</b></td>
<td class="top">
<a>Arends, R.</a>, <a>Austein, R.</a>, <a>Larson, M.</a>, <a>Massey, D.</a> and <a>S. Rose</a>, "<a href="http://tools.ietf.org/html/rfc4033">DNS Security Introduction and Requirements</a>", RFC 4033, March 2005.</td>
</tr>
<tr>
<td class="reference"><b id="RFC4034">[RFC4034]</b></td>
<td class="top">
<a>Arends, R.</a>, <a>Austein, R.</a>, <a>Larson, M.</a>, <a>Massey, D.</a> and <a>S. Rose</a>, "<a href="http://tools.ietf.org/html/rfc4034">Resource Records for the DNS Security Extensions</a>", RFC 4034, March 2005.</td>
</tr>
<tr>
<td class="reference"><b id="RFC4035">[RFC4035]</b></td>
<td class="top">
<a>Arends, R.</a>, <a>Austein, R.</a>, <a>Larson, M.</a>, <a>Massey, D.</a> and <a>S. Rose</a>, "<a href="http://tools.ietf.org/html/rfc4035">Protocol Modifications for the DNS Security Extensions</a>", RFC 4035, March 2005.</td>
</tr>
<tr>
<td class="reference"><b id="RFC5011">[RFC5011]</b></td>
<td class="top">
<a>StJohns, M.</a>, "<a href="http://tools.ietf.org/html/rfc5011">Automated Updates of DNS Security (DNSSEC) Trust Anchors</a>", RFC 5011, September 2007.</td>
</tr>
<tr>
<td class="reference"><b id="key-timing">[key-timing]</b></td>
<td class="top">
<a>Morris, S.</a>, <a>Ihren, J.</a> and <a>J. Dickinson</a>, "<a>DNSSEC Key Timing Considerations</a>", July 2010.</td>
</tr>
<tr>
<td class="reference"><b id="dnssec-bis">[dnssec-bis]</b></td>
<td class="top">
<a>Weiler, S.</a> and <a>D. Blacka</a>, "<a>Clarifications and Implementation Notes for DNSSECbis</a>", November 2010.</td>
</tr>
</tbody></table>
<h1 id="rfc.authors"><a href="#rfc.authors">Author's Address</a></h1>
<div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Matthijs Mekking</span> 
	  <span class="n hidden">
		<span class="family-name">Mekking</span>
	  </span>
	</span>
	<span class="org vcardline">NLnet Labs </span>
	<span class="adr">
	  <span>Science Park 140</span>

	  <span class="vcardline">
		<span class="locality">Amsterdam</span>,  
		<span class="region"></span>
		<span class="code">1098 XG</span>
	  </span>
	  <span class="country-name vcardline">The Netherlands</span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:matthijs@nlnetlabs.nl%20">matthijs@nlnetlabs.nl </a></span>

  </address>
</div>

</body>
</html>