K = MD4(UNICODE(password))

T = 0 in the generation of sequence number for the MIC token
T = 0 in the generation of sequence number for the WRAP token
T = 0 in the generation of encrypted data for the WRAPPED token

K = the Key
T = the message type, encoded as a little-endian four-byte integer

Ksign = HMAC(K, "signaturekey")  //includes zero octet at end
tmp = MD5(concat(T, data))
CHKSUM = HMAC(Ksign, tmp)

T = the message type, encoded as a little-endian four-byte integer.

           OCTET L40[14] = "fortybits";

      The header field on the encrypted data in KDC messages is:

           typedef struct _RC4_MDx_HEADER {
               OCTET Checksum[16];
               OCTET Confounder[8];
           } RC4_MDx_HEADER, *PRC4_MDx_HEADER;


           ENCRYPT (K, export, T, data)
           {
               struct EDATA {
                   struct HEADER {
                           OCTET Checksum[16];
                           OCTET Confounder[8];
                   } Header;
                   OCTET Data[0];
               } edata;

               if (export){
                   *((DWORD *)(L40+10)) = T;
K1 = HMAC(K, L40); // where the length of L40 in
                                      // octets is 14
K1 = HMAC(K, &T); // where the length of T in octets
                                     // is 4
K3 = HMAC (K1, edata.Checksum);

K3 = HMAC (K1, edata.Checksum);
checksum = HMAC (K2, concat(edata.Confounder, edata.Data));
               if (checksum != edata.Checksum)
                   printf("CHECKSUM ERROR  !!!!!!\n");
Kseq = HMAC(Kss, "fortybits", (int32)0);
                                        // len includes terminating null
Kcrypt = HMAC(Klocal, "fortybits", (int32)0);
                                       // len includes terminating null
Kseq = HMAC(Kss, "fortybits", (int32)0);
                                       // len includes terminating null
Kseq = HMAC(Kss, "fortybits", (int32)0);
                                        // len includes terminating null
Kcrypt = HMAC(Klocal, "fortybits", (int32)0);
                                       // len includes terminating null
Kseq = HMAC(Kss, "fortybits", (int32)0);
                                       // len includes terminating null
Ksign = HMAC(Kss, "signaturekey");
                                     // length includes terminating null

Sgn_Cksum = MD5((int32)15, Token.Header, data);

Sgn_Cksum = HMAC(Ksign, Sgn_Cksum);
Kseq = HMAC(Kss, "fortybits", (int32)0); Expand
Kseq = HMAC(Kss, "fortybits", (int32)0);
                                        // len includes terminating null
Kseq = HMAC(Kss, "fortybits", (int32)0);
                                        // len includes terminating null
Kseq = HMAC(Kss, (int32)0);
Kseq = HMAC(Kseq, Token.SGN_CKSUM);

Ksign = HMAC(Kss, "signaturekey");

                    // Generate checksum of message - Expand
Sgn_Cksum = MD5((int32)13, Token.Header,
                Token.Confounder);








Sgn_Cksum = MD5((int32)15, Token.Header,
                Token.Confounder);


Sgn_Cksum = MD5((int32)13, Token.Header,
                Token.Confounder);


Kcrypt = HMAC(Klocal, "fortybits", (int32)0);
                                       // len includes terminating null
Kcrypt = HMAC(Klocal, (int32)0);
Kcrypt = HMAC(Kcrypt, (int32)seq_num);







Kcrypt = HMAC(Kcrypt, (int32)seq);



Kcrypt = HMAC(Kcrypt, (int32)seq_num);

tmp=concat(Token.Confounder,data);

tmp=concat(Token.Confounder,data);

Sgn_Cksum = HMAC(Ksign, Sgn_Cksum);
Kseq = HMAC(Kss, "fortybits", (int32)0);
                                       // len includes terminating null
Kseq = HMAC(Kss, (int32)0);
Kseq = HMAC(Kseq, Token.SGN_CKSUM);

