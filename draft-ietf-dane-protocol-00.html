<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="en"><head><title>Using Secure DNS to Associate Certificates with Domain Names For TLS</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="description" content="Using Secure DNS to Associate Certificates with Domain Names For TLS">
<meta name="generator" content="xml2rfc v1.35 (http://xml.resource.org/)">
<meta name="viewport" content="width=600;" />
<style type='text/css'><!--
        body {
                font-family: verdana, charcoal, helvetica, arial, sans-serif;
                font-size: 85%;
		max-width: 60em; 
		color: #000; background-color: #FFF;
                margin: 2em;
        }
        h1, h2, h3, h4, h5, h6 {
                font-family: helvetica, monaco, "MS Sans Serif", arial, sans-serif;
                font-weight: bold; font-style: normal;
        }
        h1 { color: #900; background-color: transparent; text-align: right; }
        h3 { color: #333; background-color: transparent; }

        td.RFCbug {
                font-size: x-small; text-decoration: none;
                width: 30px; height: 30px; padding-top: 2px;
                text-align: justify; vertical-align: middle;
                background-color: #000;
        }
        td.RFCbug span.RFC {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: bold; color: #666;
        }
        td.RFCbug span.hotText {
                font-family: charcoal, monaco, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: normal; text-align: center; color: #FFF;
        }

        table.TOCbug { width: 30px; height: 15px; }
        td.TOCbug {
                text-align: center; width: 30px; height: 15px;
                color: #FFF; background-color: #900;
        }
        td.TOCbug a {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, sans-serif;
                font-weight: bold; font-size: x-small; text-decoration: none;
                color: #FFF; background-color: transparent;
        }

        td.header {
                font-family: arial, helvetica, sans-serif; font-size: x-small;
                vertical-align: top; width: 33%;
                color: #FFF; background-color: #666;
        }
        td.author { font-weight: bold; font-size: x-small; margin-left: 4em; }
        td.author-text { font-size: x-small; }

        /* info code from SantaKlauss at http://www.madaboutstyle.com/tooltip2.html */
        a.info {
                /* This is the key. */
                position: relative;
                z-index: 24;
                text-decoration: none;
        }
        a.info:hover {
                z-index: 25;
                color: #FFF; background-color: #900;
        }
        a.info span { display: none; }
        a.info:hover span.info {
                /* The span will display just on :hover state. */
                display: block;
                position: absolute;
                font-size: smaller;
                top: 2em; left: -5em; width: 15em;
                padding: 2px; border: 1px solid #333;
                color: #900; background-color: #EEE;
                text-align: left;
        }

        a { font-weight: bold; }
        a:link    { color: #900; background-color: transparent; }
        a:visited { color: #633; background-color: transparent; }
        a:active  { color: #633; background-color: transparent; }

        p { margin-left: 2em; margin-right: 2em; }
        p.copyright { font-size: x-small; }
        p.toc { font-size: 85%;
		max-width: 60em; 
		font-weight: bold; margin-left: 3em; }
        table.toc { margin: 0 0 0 3em; padding: 0; border: 0; vertical-align: text-top; }
        td.toc { font-size: 85%;
		max-width: 60em; 
		font-weight: bold; vertical-align: text-top; }

        ol.text { margin-left: 2em; margin-right: 2em; }
        ul.text { margin-left: 2em; margin-right: 2em; }
        li      { margin-left: 3em; }

        /* RFC-2629 <spanx>s and <artwork>s. */
        em     { font-style: italic; }
        strong { font-weight: bold; }
        dfn    { font-weight: bold; font-style: normal; }
        cite   { font-weight: normal; font-style: normal; }
        tt     { color: #036; }
        tt, pre, pre dfn, pre em, pre cite, pre span {
                font-family: "Courier New", Courier, monospace; font-size: small;
        }
        pre {
                text-align: left; padding: 4px;
                color: #000; background-color: #CCC;
        }
        pre dfn  { color: #900; }
        pre em   { color: #66F; background-color: #FFC; font-weight: normal; }
        pre .key { color: #33C; font-weight: bold; }
        pre .id  { color: #900; }
        pre .str { color: #000; background-color: #CFF; }
        pre .val { color: #066; }
        pre .rep { color: #909; }
        pre .oth { color: #000; background-color: #FCF; }
        pre .err { background-color: #FCC; }

        /* RFC-2629 <texttable>s. */
        table.all, table.full, table.headers, table.none {
                font-size: 85%;
		max-width: 60em; 
		text-align: center; border-width: 2px;
                vertical-align: top; border-collapse: collapse;
        }
        table.all, table.full { border-style: solid; border-color: black; }
        table.headers, table.none { border-style: none; }
        th {
                font-weight: bold; border-color: black;
                border-width: 2px 2px 3px 2px;
        }
        table.all th, table.full th { border-style: solid; }
        table.headers th { border-style: none none solid none; }
        table.none th { border-style: none; }
        table.all td {
                border-style: solid; border-color: #333;
                border-width: 1px 2px;
        }
        table.full td, table.headers td, table.none td { border-style: none; }

        hr { height: 1px; }
        hr.insert {
                width: 80%; border-style: none; border-width: 0;
                color: #CCC; background-color: #CCC;
        }
--></style>
</head>
<body>
<table summary="layout" width="66%" border="0" cellpadding="0" cellspacing="0"><tr><td><table summary="layout" width="100%" border="0" cellpadding="2" cellspacing="1">
<tr><td class="header">Network Working Group</td><td class="header">P. Hoffman</td></tr>
<tr><td class="header">Internet-Draft</td><td class="header">VPN Consortium</td></tr>
<tr><td class="header">Intended status: Standards Track</td><td class="header">J. Schlyter</td></tr>
<tr><td class="header">Expires: June 16, 2011</td><td class="header">Kirei AB</td></tr>
<tr><td class="header">&nbsp;</td><td class="header">December 13, 2010</td></tr>
</table></td></tr></table>
<h1><br />Using Secure DNS to Associate Certificates with Domain Names For TLS<br />draft-ietf-dane-protocol-00</h1>

<h3>Abstract</h3>

<p>TLS and DTLS use certificates for authenticating the server. Users want
their applications to verify that the certificate provided by the TLS server
is in fact associated with the domain name they expect. Instead of trusting a
certification authority to have made this association correctly, the user
might instead trust the authoritative DNS server for the domain name to make
that association. This document describes how to use secure DNS to associate
the TLS server's certificate with the the intended domain name.
</p>
<h3>Status of this Memo</h3>
<p>
This Internet-Draft is submitted  in full
conformance with the provisions of BCP&nbsp;78 and BCP&nbsp;79.</p>
<p>
Internet-Drafts are working documents of the Internet Engineering
Task Force (IETF).  Note that other groups may also distribute
working documents as Internet-Drafts.  The list of current
Internet-Drafts is at http://datatracker.ietf.org/drafts/current/.</p>
<p>
Internet-Drafts are draft documents valid for a maximum of six months
and may be updated, replaced, or obsoleted by other documents at any time.
It is inappropriate to use Internet-Drafts as reference material or to cite
them other than as &ldquo;work in progress.&rdquo;</p>
<p>
This Internet-Draft will expire on June 16, 2011.</p>

<h3>Copyright Notice</h3>
<p>
Copyright (c) 2010 IETF Trust and the persons identified as the
document authors.  All rights reserved.</p>
<p>
This document is subject to BCP 78 and the IETF Trust's Legal
Provisions Relating to IETF Documents
(http://trustee.ietf.org/license-info) in effect on the date of
publication of this document.  Please review these documents
carefully, as they describe your rights and restrictions with respect
to this document. Code Components extracted from this document must
include Simplified BSD License text as described in Section 4.e of
the Trust Legal Provisions and are provided without warranty as
described in the Simplified BSD License.</p>

<a name="anchor1"></a><br /><hr />
<a name="rfc.section.1"></a><h3>1.&nbsp;
Introduction</h3>

<p>The first response from the server in TLS may contain a certificate. In
order for the TLS client to authenticate that it is talking to the expected
TLS server, the client must validate that this certificate is associated with
the domain name used by the client to get to the server. Currently, the client
must extract the domain name from the certificate, must trust a trust anchor
upon which the server's certificate is rooted, and must successfully validate
the certificate.
</p>
<p>Some people want a different way to authenticate the association of the
server's certificate with the intended domain name without trusting the CA.
Given that the DNS administrator for a domain name is authorized to give
identifying information about the zone, it makes sense to allow that
administrator to also make an authoritative binding between the domain name
and a certificate that might be used by a host at that domain name. The
easiest way to do this is to use the DNS.
</p>
<p>This document applies to both TLS <a class='info' href='#RFC5246'>[RFC5246]<span> (</span><span class='info'>Dierks, T. and E. Rescorla, &ldquo;The Transport Layer Security (TLS) Protocol Version 1.2,&rdquo; August&nbsp;2008.</span><span>)</span></a> and DTLS <a class='info' href='#4347bis'>[4347bis]<span> (</span><span class='info'>Rescorla, E. and N. Modadugu, &ldquo;Datagram Transport Layer Security version 1.2,&rdquo; July&nbsp;2010.</span><span>)</span></a>. In order to make the document more readable, it mostly
only talks about "TLS", but in all cases, it means "TLS or DTLS". This
document only relates to securely associating certificates for TLS and DTLS
with host names; other security protocols are handled in other documents. For
example, keys for IPsec are covered in <a class='info' href='#RFC4025'>[RFC4025]<span> (</span><span class='info'>Richardson, M., &ldquo;A Method for Storing IPsec Keying Material in DNS,&rdquo; March&nbsp;2005.</span><span>)</span></a> and keys for
SSH are covered in <a class='info' href='#RFC4255'>[RFC4255]<span> (</span><span class='info'>Schlyter, J. and W. Griffin, &ldquo;Using DNS to Securely Publish Secure Shell (SSH) Key Fingerprints,&rdquo; January&nbsp;2006.</span><span>)</span></a>.
</p>
<a name="anchor2"></a><br /><hr />
<a name="rfc.section.1.1"></a><h3>1.1.&nbsp;
Certificate Associations</h3>

<p>In this document, a certificate association is based on a cryptographic
hash of a certificate (sometimes called a "fingerprint") or on the certificate
itself. For a fingerprint, a hash is taken of the certificate, and that hash
is the certificate association; the type of hash function used can be chosen
by the DNS administrator. When using the certificate itself in the certificate
association, the entire certificate in the normal format is used. This
document also only applies to PKIX <a class='info' href='#RFC5280'>[RFC5280]<span> (</span><span class='info'>Cooper, D., Santesson, S., Farrell, S., Boeyen, S., Housley, R., and W. Polk, &ldquo;Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile,&rdquo; May&nbsp;2008.</span><span>)</span></a> certificates.
</p>
<p>Certificate associations are made between a certificate or the hash of a
certificate and a domain name. Server software that is running TLS that is
found at that domain name would use a certificate that has a certificate
association given in the DNS, as described in this document. A DNS query can
return multiple certificate associations, such as in the case of different
server software on a single host using different certificates (even if they
are normally accessed with different host names), or in the case that a server
is changing from one certificate to another.
</p>
<a name="anchor3"></a><br /><hr />
<a name="rfc.section.1.2"></a><h3>1.2.&nbsp;
Securing Certificate Associations</h3>

<p>This document defines a secure method to associate the certificate that is
obtained from the TLS server with a domain name using DNS protected by DNSSEC.
Because the certificate association was retrieved based on a DNS query, the
domain name in the query is by definition associated with the certificate.
</p>
<p>DNSSEC, which is defined in RFCs 4033, 4034, and 4035 (<a class='info' href='#RFC4033'>[RFC4033]<span> (</span><span class='info'>Arends, R., Austein, R., Larson, M., Massey, D., and S. Rose, &ldquo;DNS Security Introduction and Requirements,&rdquo; March&nbsp;2005.</span><span>)</span></a>, <a class='info' href='#RFC4034'>[RFC4034]<span> (</span><span class='info'>Arends, R., Austein, R., Larson, M., Massey, D., and S. Rose, &ldquo;Resource Records for the DNS Security Extensions,&rdquo; March&nbsp;2005.</span><span>)</span></a>, and <a class='info' href='#RFC4035'>[RFC4035]<span> (</span><span class='info'>Arends, R., Austein, R., Larson, M., Massey, D., and S. Rose, &ldquo;Protocol Modifications for the DNS Security Extensions,&rdquo; March&nbsp;2005.</span><span>)</span></a>),
uses cryptographic keys and digital signatures to provide authentication of
DNS data. Information retrieved from the DNS and that is validated using
DNSSEC is thereby proved to be the authoritative data. The DNSSEC signature
MUST be validated on all responses in order to assure the proof of origin of
the data.
</p>
<p>This document only relates to securely getting the DNS information for the
certificate association using DNSSEC; other secure DNS mechanisms are out of
scope.
</p>
<a name="anchor4"></a><br /><hr />
<a name="rfc.section.1.3"></a><h3>1.3.&nbsp;
Terminology</h3>

<p>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
"SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document
are to be interpreted as described in RFC 2119 <a class='info' href='#RFC2119'>[RFC2119]<span> (</span><span class='info'>Bradner, S., &ldquo;Key words for use in RFCs to Indicate Requirement Levels,&rdquo; March&nbsp;1997.</span><span>)</span></a>.
</p>
<p>A note on terminology: Some people have said that this protocol is a form
of "certificate exclusion". This is true, but in a very unusual sense. That
is, a DNS reply that contains two of the certificate types defined here
inherently excludes every other possible certificate in the universe other
than those found with a pre-image attack against one of those two. The
certificate type defined here is better thought of as "enumeration" of a small
number of certificate associations, not "exclusion" of a near-infinite number
of other certificates.
</p>
<p>Some of the terminology in this -00 draft may not match with the
terminology used in RFC 5280. This will be fixed in future versions of this
draft, with help from the PKIX community.
</p>
<a name="anchor5"></a><br /><hr />
<a name="rfc.section.2"></a><h3>2.&nbsp;
Getting TLS Certificate Associations from the DNS</h3>

<p>This document defines a new DNS resource record type, "TLSA". A query on a
domain name for the TLSA RR can return one or more records of the type TLSA.
The TLSA RRType is TBD.
</p>
<p>The format of the data in the resource record is a binary record with three
values, which MUST be in the order defined here:
</p>
<p></p>
<ul class="text">
<li>A one-octet value, called "certificate type", specifying the provided
association that will be used to match the target certificate. The types
defined are:


<blockquote class="text">
<p>1 -- Hash of an end-entity certificate
</p>
<p>2 -- Full end-entity certificate
</p>
<p>3 -- Hash of an certification authority's certificate
</p>
<p>4 -- Full certification authority's certificate
</p>
</blockquote>
</li>
<li>A one-octet value, called "hash type", specifying the type of hash
algorithm used for the certificate association. This value has the same values
as those of the TLS hash, as defined in the IANA registry titled "TLS
HashAlgorithm Registry"
(&lt;http://www.iana.org/assignments/tls-parameters&gt;). For example, the
value for the SHA-1 hash function is "2". When no hashing is used (that is, in
the certificate types where the full certificate is given), the hash type is
0. Using the same hash algorithm as is used in the signature in the
certificate will make it more likely that the TLS client will understand this
TLSA data.
</li>
<li>A variable-length set of bytes containing the certificate or the hash of
the associated certificate (that is, the certificate or the hash of the
certificate itself, not of the TLS ASN.1Cert object).
</li>
</ul>

<p>An example of a hash for a single certificate: 
</p>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
   www.example.com. IN TLSA 1 2 AgHne3GdTpxjwLCgMzvgpBiOSQthjg==
</pre></div><p>

</p>
<a name="anchor6"></a><br /><hr />
<a name="rfc.section.2.1"></a><h3>2.1.&nbsp;
Making Certificate Associations</h3>

<p>The TLS client determines whether or not the certificate offered by the TLS
server matches the certificate association in the TLSA resource record. If the
certificate from the TLS server matches, the TLS client accepts the
certificate association. Each certificate type has a different method for
determining matching.
</p>
<p>For types 1 and 3, the hash used in the comparison is the hash type from
the TLSA data.
</p>
<p>Types 1 (hash of an end-entity certificate) and 2 (full end-entity
certificate) are matched against the first certificate offered by the TLS
server. For type 1, the certificate association is valid if the hash of the
first certificate offered by the TLS server matches the value from the
resource record. For type 2, the certificate association is valid if the
certificate in the TLSA data matches to the first certificate offered by
TLS.
</p>
<p>Type 3 (hash of certification authority's certificate) can be used in one
of two ways. If the hash of any certificate past the first in the certificate
bundle from TLS matches the value from the TLSA data, and the chain in the
certificate bundle is valid up to that certificate, then the certificate
association is valid. Alternately, if the first certificate offered chains to
a trust anchor, and the hash of that trust anchor matches the value from the
TLSA data, then the certificate association is valid.
</p>
<p>Type 4 (full certification authority's certificate) is used in chaining
from the end-entity given in TLS. The certificate association is valid if the
first certificate in the certificate bundle can be validly chained to the
certificate from the TLSA data.
</p>
<a name="anchor7"></a><br /><hr />
<a name="rfc.section.3"></a><h3>3.&nbsp;
Use of TLS Certificate Associations in TLS</h3>

<p>In order to use one or more TLS certificate associations described in this
document obtained from the DNS, an application MUST assure that the
certificates were obtained using DNS protected by DNSSEC.
</p>
<p>If a certificate association contains a hash type that is not understood by
the TLS client, that certificate association MUST be marked as unusable.
</p>
<p>An application that requests TLS certificate associations using the method
described in this document obtains zero or more usable certificate
associations. If the application receives zero usable certificate
associations, it processes TLS in the normal fashion.
</p>
<p>If a match between one of the certificate association(s) and the server's
end entity certificate in TLS is found, the TLS client continues the TLS
handshake. If a match between the certificate association(s) and the server's
end entity certificate in TLS is not found, the TLS client MUST abort the
handshake with an "access_denied" error.
</p>
<a name="anchor8"></a><br /><hr />
<a name="rfc.section.3.1"></a><h3>3.1.&nbsp;
Certificate Validation by TLS Clients When Using Certificate
Associations</h3>

<p>TLS client policy is deliberately not prescribed by this specification. A
client MAY choose to trust a DNSSEC-secured certificate association, depending
on its local policy.
</p>
<p>[[ The preceding paragraph is probably wrong in the sense that it means
that we now hove no conformance requirements. There is probably no reason to
even use this protocol unless you are going to fully trust the results. The
one exception that has been discussed is that you might want to use the TLSA
data as a "second positive opinion", such as in a GUI or in logging. Both of
those seem fairly useless in the case of DNS resolution. Thus, the above
paragraph may be changed by the WG in a future version of this draft. ]]
</p>
<a name="anchor9"></a><br /><hr />
<a name="rfc.section.3.1.1"></a><h3>3.1.1.&nbsp;
Use of Self-Signed Certificates</h3>

<p>One expected use case for this protocol is that some TLS servers will begin
to use self-signed certificates in association with certificate associations.
A TLS client that is using this protocol needs to treat self-signed
certificates as special, and thus SHOULD NOT attempt certificate validation on
them. (An exception to this rule would be clients that keep self-signed end
entity certificates in its trust anchor store.) 
</p>
<a name="anchor10"></a><br /><hr />
<a name="rfc.section.3.1.2"></a><h3>3.1.2.&nbsp;
Ignorning Host Names in Certificates</h3>

<p>All data in a self-signed certificate other than the key itself can be
ignored as untrusted unless a client validates the self-signed certificate to
a trust anchor that is identical to the certificate. That means that the host
name given in the self-signed certificate is meaningless, and that the only
way to associate the public key in the certificate with the domain name is
through the certificate association made in the DNS.
</p>
<p>If a TLS client fully trusts the association between a domain name and the
certificate that was provided by the DNS, then that client MUST ignore the
domain name that is given in the certificate. That is, the certificate might
contain a domain name that is different than the one that was used to get the
TLSA data, but if the client is trusting the TLSA data, it doesn't matter what
domain name is used in the certificate. An expected use case for this protocol
is to allow someone who controls the private key on a certificate to use that
certificate for multiple TLS servers. These servers might be on a single
computer that has many domain names (such as a computer that is both a web
host and a mail host, and is known by both "www.example.com" and
"smtp.example.com"), or they might be on different computers (such as multiple
computers that all respond IP addresses reachable as "www.example.com").
</p>
<a name="anchor11"></a><br /><hr />
<a name="rfc.section.3.1.3"></a><h3>3.1.3.&nbsp;
Use of Local Trust Anchors</h3>

<p>Another expected use case for this protocol is that some TLS servers will
use certificates that chain to a trust anchor that might not be one that is
trusted by the TLS client, such as a local certification authority (CA) that
is administered by the organization that runs the TLS server; this is a likely
use for certificate types 3 and 4. Because of this, a TLS client that is using
this protocol that performs certificate validation on server certificates MAY
have a method to communicate with the user that differentiates between
validation failures that occur on certificates that have had secure
certificate associations and those that have not. If it does not have such a
method of communication, the failure to validate SHOULD cause the same error
as for any other certificate validation.
</p>
<a name="anchor12"></a><br /><hr />
<a name="rfc.section.3.1.4"></a><h3>3.1.4.&nbsp;
Use of Additional Certificate Data</h3>

<p>Some TLS clients extract data from the certificate other than the key to
show to the user; for example, most modern web browsers have the ability to
show an extended validation (EV) name that is embedded in a certificate.
Because this data comes from a trusted third party and not the TLS server
itself, TLS clients that extract additional information from TLS server
certificates MUST validate those certificates in the normal fashion.
</p>
<a name="anchor13"></a><br /><hr />
<a name="rfc.section.4"></a><h3>4.&nbsp;
IANA Considerations</h3>

<p>This document uses a new DNS RRType, TLSA, whose value is TBD. A separate
request for the RRType will be submitted to the expert reviewer, and future
versions of this document will have that value instead of TBD.
</p>
<a name="anchor14"></a><br /><hr />
<a name="rfc.section.5"></a><h3>5.&nbsp;
Security Considerations</h3>

<p>The security of the protocols described in this document relies on the
security of DNSSEC as used by the client requesting A and TLSA records.
</p>
<p>A DNS administrator who goes rogue and changes both the A and TLSA records
for a domain name can cause the user to go to an unauthorized server that will
appear authorized, unless the client performs certificate validation and
rejects the certificate.
</p>
<p>The values in the TLSA data will be normally entered in the DNS through the
same system used to enter A/AAAA records, and other DNS information for the
host name. If the authentication for changes to the host information is weak,
an attacker can easily change any of this information. Given that the TLSA
data is not easily human-readable, an attacker might change those records and
A/AAAA records and not have the change be noticed if changes to a zone are
only monitored visually.
</p>
<p>If the authentication mechanism for adding or changing TLSA data in a zone
is weaker than the authentication mechanism for changing the A/AAAA records,
an man-in-the-middle who can redirect traffic to their site may be able to
impersonate the attacked host in TLS if they can use the weaker authentication
mechanism. A better design for authenticating DNS would be to have the same
level of authentication used for all DNS additions and changes for a
particular host.
</p>
<a name="anchor15"></a><br /><hr />
<a name="rfc.section.6"></a><h3>6.&nbsp;
Acknowledgements</h3>

<p>Many of the ideas in this document have been discussed over many years.
More recently, the ideas have been discussed by the authors and others in a
more focused fashion. In particular, some of the ideas here originated with
Paul Vixie, Dan Kaminsky, Jeff Hodges, Phill Hallam-Baker, Simon Josefsson,
Warren Kumari, Adam Langley, Ilari Liusvaara, and Ondrej Sury.
</p>
<a name="rfc.references"></a><br /><hr />
<a name="rfc.section.7"></a><h3>7.&nbsp;
References</h3>

<a name="rfc.references1"></a><br /><hr />
<h3>7.1.&nbsp;Normative References</h3>
<table width="99%" border="0">
<tr><td class="author-text" valign="top"><a name="4347bis">[4347bis]</a></td>
<td class="author-text">Rescorla, E. and N. Modadugu, &ldquo;<a href="http://www.ietf.org/internet-drafts/draft-ietf-tls-rfc4347-bis.txt">Datagram Transport Layer Security version 1.2</a>,&rdquo; draft-ietf-tls-rfc4347-bis (work in progress), July&nbsp;2010.</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC2119">[RFC2119]</a></td>
<td class="author-text"><a href="mailto:sob@harvard.edu">Bradner, S.</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>,&rdquo; BCP&nbsp;14, RFC&nbsp;2119, March&nbsp;1997 (<a href="http://www.rfc-editor.org/rfc/rfc2119.txt">TXT</a>, <a href="http://xml.resource.org/public/rfc/html/rfc2119.html">HTML</a>, <a href="http://xml.resource.org/public/rfc/xml/rfc2119.xml">XML</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4033">[RFC4033]</a></td>
<td class="author-text">Arends, R., Austein, R., Larson, M., Massey, D., and S. Rose, &ldquo;<a href="http://tools.ietf.org/html/rfc4033">DNS Security Introduction and Requirements</a>,&rdquo; RFC&nbsp;4033, March&nbsp;2005 (<a href="http://www.rfc-editor.org/rfc/rfc4033.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4034">[RFC4034]</a></td>
<td class="author-text">Arends, R., Austein, R., Larson, M., Massey, D., and S. Rose, &ldquo;<a href="http://tools.ietf.org/html/rfc4034">Resource Records for the DNS Security Extensions</a>,&rdquo; RFC&nbsp;4034, March&nbsp;2005 (<a href="http://www.rfc-editor.org/rfc/rfc4034.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4035">[RFC4035]</a></td>
<td class="author-text">Arends, R., Austein, R., Larson, M., Massey, D., and S. Rose, &ldquo;<a href="http://tools.ietf.org/html/rfc4035">Protocol Modifications for the DNS Security Extensions</a>,&rdquo; RFC&nbsp;4035, March&nbsp;2005 (<a href="http://www.rfc-editor.org/rfc/rfc4035.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC5246">[RFC5246]</a></td>
<td class="author-text">Dierks, T. and E. Rescorla, &ldquo;<a href="http://tools.ietf.org/html/rfc5246">The Transport Layer Security (TLS) Protocol Version 1.2</a>,&rdquo; RFC&nbsp;5246, August&nbsp;2008 (<a href="http://www.rfc-editor.org/rfc/rfc5246.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC5280">[RFC5280]</a></td>
<td class="author-text">Cooper, D., Santesson, S., Farrell, S., Boeyen, S., Housley, R., and W. Polk, &ldquo;<a href="http://tools.ietf.org/html/rfc5280">Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile</a>,&rdquo; RFC&nbsp;5280, May&nbsp;2008 (<a href="http://www.rfc-editor.org/rfc/rfc5280.txt">TXT</a>).</td></tr>
</table>

<a name="rfc.references2"></a><br /><hr />
<h3>7.2.&nbsp;Informative References</h3>
<table width="99%" border="0">
<tr><td class="author-text" valign="top"><a name="RFC4025">[RFC4025]</a></td>
<td class="author-text">Richardson, M., &ldquo;<a href="http://tools.ietf.org/html/rfc4025">A Method for Storing IPsec Keying Material in DNS</a>,&rdquo; RFC&nbsp;4025, March&nbsp;2005 (<a href="http://www.rfc-editor.org/rfc/rfc4025.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4255">[RFC4255]</a></td>
<td class="author-text">Schlyter, J. and W. Griffin, &ldquo;<a href="http://tools.ietf.org/html/rfc4255">Using DNS to Securely Publish Secure Shell (SSH) Key Fingerprints</a>,&rdquo; RFC&nbsp;4255, January&nbsp;2006 (<a href="http://www.rfc-editor.org/rfc/rfc4255.txt">TXT</a>).</td></tr>
</table>

<a name="rfc.authors"></a><br /><hr />
<h3>Authors' Addresses</h3>
<table width="99%" border="0" cellpadding="0" cellspacing="0">
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Paul Hoffman</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">VPN Consortium</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:paul.hoffman@vpnc.org">paul.hoffman@vpnc.org</a></td></tr>
<tr cellpadding="3"><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Jakob Schlyter</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Kirei AB</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:jakob@kirei.se">jakob@kirei.se</a></td></tr>
</table>
</body></html>
