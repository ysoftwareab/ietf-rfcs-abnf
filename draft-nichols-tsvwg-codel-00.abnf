interval = MS2TIME(100); // Sliding-minimum window (100ms) u_int
maxpacket = 512; // Maximum packet size in bytes
   			  // (should use interface MTU)
   
dropping_ = 0;
count_ = (count_ > 2 && now - drop_next_ < 16*interval_)?
   		    count_ - 2 : 1;
drop_next_ = control_law(now);
       } return (r.p);
first_above_time_ = 0; return r;
       }
   
       // To span a large range of bandwidths, CoDel runs two //
       different AQMs in parallel. One is sojourn-time-based // and
       takes effect when the time to send an MTU-sized // packet is less
       than target.  The 1st term of the "if" // below does this.  The
       other is backlog-based and takes // effect when the time to send
       an MTU-sized packet is >= // target. The goal here is to keep the
       output link // utilization high by never allowing the queue to
       get // smaller than the amount that arrives in a typical //
       interarrival time (MTU-sized packets arriving spaced // by the
       amount of time it takes to send such a packet on // the
       bottleneck). The 2nd term of the "if" does this.  time_t
sojourn_time = now - r.p->tstamp; if (sojourn_time_ < target_ ||
first_above_time_ = 0;
       } else {
first_above_time_ = now + interval_;
