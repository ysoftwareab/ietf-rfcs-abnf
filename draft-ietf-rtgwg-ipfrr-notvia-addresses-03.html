<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="en"><head><title>IP Fast Reroute Using Not-via Addresses</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="description" content="IP Fast Reroute Using Not-via Addresses">
<meta name="generator" content="xml2rfc v1.35 (http://xml.resource.org/)">
<meta name="viewport" content="width=600;" />
<style type='text/css'><!--
        body {
                font-family: verdana, charcoal, helvetica, arial, sans-serif;
                font-size: 85%;
		max-width: 40em; 
		color: #000; background-color: #FFF;
                margin: 2em;
        }
        h1, h2, h3, h4, h5, h6 {
                font-family: helvetica, monaco, "MS Sans Serif", arial, sans-serif;
                font-weight: bold; font-style: normal;
        }
        h1 { color: #900; background-color: transparent; text-align: right; }
        h3 { color: #333; background-color: transparent; }

        td.RFCbug {
                font-size: x-small; text-decoration: none;
                width: 30px; height: 30px; padding-top: 2px;
                text-align: justify; vertical-align: middle;
                background-color: #000;
        }
        td.RFCbug span.RFC {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: bold; color: #666;
        }
        td.RFCbug span.hotText {
                font-family: charcoal, monaco, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: normal; text-align: center; color: #FFF;
        }

        table.TOCbug { width: 30px; height: 15px; }
        td.TOCbug {
                text-align: center; width: 30px; height: 15px;
                color: #FFF; background-color: #900;
        }
        td.TOCbug a {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, sans-serif;
                font-weight: bold; font-size: x-small; text-decoration: none;
                color: #FFF; background-color: transparent;
        }

        td.header {
                font-family: arial, helvetica, sans-serif; font-size: x-small;
                vertical-align: top; width: 33%;
                color: #FFF; background-color: #666;
        }
        td.author { font-weight: bold; font-size: x-small; margin-left: 4em; }
        td.author-text { font-size: x-small; }

        /* info code from SantaKlauss at http://www.madaboutstyle.com/tooltip2.html */
        a.info {
                /* This is the key. */
                position: relative;
                z-index: 24;
                text-decoration: none;
        }
        a.info:hover {
                z-index: 25;
                color: #FFF; background-color: #900;
        }
        a.info span { display: none; }
        a.info:hover span.info {
                /* The span will display just on :hover state. */
                display: block;
                position: absolute;
                font-size: smaller;
                top: 2em; left: -5em; width: 15em;
                padding: 2px; border: 1px solid #333;
                color: #900; background-color: #EEE;
                text-align: left;
        }

        a { font-weight: bold; }
        a:link    { color: #900; background-color: transparent; }
        a:visited { color: #633; background-color: transparent; }
        a:active  { color: #633; background-color: transparent; }

        p { margin-left: 2em; margin-right: 2em; }
        p.copyright { font-size: x-small; }
        p.toc { font-size: 85%;
		max-width: 40em; 
		font-weight: bold; margin-left: 3em; }
        table.toc { margin: 0 0 0 3em; padding: 0; border: 0; vertical-align: text-top; }
        td.toc { font-size: 85%;
		max-width: 40em; 
		font-weight: bold; vertical-align: text-top; }

        ol.text { margin-left: 2em; margin-right: 2em; }
        ul.text { margin-left: 2em; margin-right: 2em; }
        li      { margin-left: 3em; }

        /* RFC-2629 <spanx>s and <artwork>s. */
        em     { font-style: italic; }
        strong { font-weight: bold; }
        dfn    { font-weight: bold; font-style: normal; }
        cite   { font-weight: normal; font-style: normal; }
        tt     { color: #036; }
        tt, pre, pre dfn, pre em, pre cite, pre span {
                font-family: "Courier New", Courier, monospace; font-size: small;
        }
        pre {
                text-align: left; padding: 4px;
                color: #000; background-color: #CCC;
        }
        pre dfn  { color: #900; }
        pre em   { color: #66F; background-color: #FFC; font-weight: normal; }
        pre .key { color: #33C; font-weight: bold; }
        pre .id  { color: #900; }
        pre .str { color: #000; background-color: #CFF; }
        pre .val { color: #066; }
        pre .rep { color: #909; }
        pre .oth { color: #000; background-color: #FCF; }
        pre .err { background-color: #FCC; }

        /* RFC-2629 <texttable>s. */
        table.all, table.full, table.headers, table.none {
                font-size: 85%;
		max-width: 40em; 
		text-align: center; border-width: 2px;
                vertical-align: top; border-collapse: collapse;
        }
        table.all, table.full { border-style: solid; border-color: black; }
        table.headers, table.none { border-style: none; }
        th {
                font-weight: bold; border-color: black;
                border-width: 2px 2px 3px 2px;
        }
        table.all th, table.full th { border-style: solid; }
        table.headers th { border-style: none none solid none; }
        table.none th { border-style: none; }
        table.all td {
                border-style: solid; border-color: #333;
                border-width: 1px 2px;
        }
        table.full td, table.headers td, table.none td { border-style: none; }

        hr { height: 1px; }
        hr.insert {
                width: 80%; border-style: none; border-width: 0;
                color: #CCC; background-color: #CCC;
        }
--></style>
</head>
<body>
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<table summary="layout" width="66%" border="0" cellpadding="0" cellspacing="0"><tr><td><table summary="layout" width="100%" border="0" cellpadding="2" cellspacing="1">
<tr><td class="header">Network Working Group</td><td class="header">M. Shand</td></tr>
<tr><td class="header">Internet-Draft</td><td class="header">S. Bryant</td></tr>
<tr><td class="header">Intended status: Standards Track</td><td class="header">S. Previdi</td></tr>
<tr><td class="header">Expires: May 3, 2009</td><td class="header">Cisco Systems</td></tr>
<tr><td class="header">&nbsp;</td><td class="header">October 30, 2008</td></tr>
</table></td></tr></table>
<h1><br />IP Fast Reroute Using Not-via Addresses<br />draft-ietf-rtgwg-ipfrr-notvia-addresses-03</h1>

<h3>Status of this Memo</h3>
<p>
By submitting this Internet-Draft,
each author represents that any applicable patent or other IPR claims of which
he or she is aware have been or will be disclosed,
and any of which he or she becomes aware will be disclosed,
in accordance with Section&nbsp;6 of BCP&nbsp;79.</p>
<p>
Internet-Drafts are working documents of the Internet Engineering
Task Force (IETF), its areas, and its working groups.
Note that other groups may also distribute working documents as
Internet-Drafts.</p>
<p>
Internet-Drafts are draft documents valid for a maximum of six months
and may be updated, replaced, or obsoleted by other documents at any time.
It is inappropriate to use Internet-Drafts as reference material or to cite
them other than as &ldquo;work in progress.&rdquo;</p>
<p>
The list of current Internet-Drafts can be accessed at
<a href='http://www.ietf.org/ietf/1id-abstracts.txt'>http://www.ietf.org/ietf/1id-abstracts.txt</a>.</p>
<p>
The list of Internet-Draft Shadow Directories can be accessed at
<a href='http://www.ietf.org/shadow.html'>http://www.ietf.org/shadow.html</a>.</p>
<p>
This Internet-Draft will expire on May 3, 2009.</p>

<h3>Abstract</h3>

<p>This draft describes a mechanism that provides fast reroute in an IP
      network through encapsulation to "not-via" addresses. A single level of
      encapsulation is used. The mechanism protects unicast, multicast and LDP
      traffic against link, router and shared risk group failure, regardless
      of network topology and metrics.
</p><a name="toc"></a><br /><hr />
<h3>Table of Contents</h3>
<p class="toc">
<a href="#anchor1">1.</a>&nbsp;
Conventions used in this document<br />
<a href="#anchor2">2.</a>&nbsp;
Introduction<br />
<a href="#anchor3">3.</a>&nbsp;
Overview of Not-via Repairs<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor4">3.1.</a>&nbsp;
Use of Equal Cost Multi-Path<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor5">3.2.</a>&nbsp;
Use of LFA repairs<br />
<a href="#anchor6">4.</a>&nbsp;
Not-via Repair Path Computation <br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor7">4.1.</a>&nbsp;
Computing not-via repairs in routing vector protocols<br />
<a href="#anchor8">5.</a>&nbsp;
Operation of Repairs<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor9">5.1.</a>&nbsp;
Node Failure<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor10">5.2.</a>&nbsp;
Link Failure<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor11">5.3.</a>&nbsp;
Multi-homed Prefixes<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor12">5.4.</a>&nbsp;
Installation of Repair Paths <br />
<a href="#anchor13">6.</a>&nbsp;
Compound Failures<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor14">6.1.</a>&nbsp;
Shared Risk Link Groups<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor15">6.1.1.</a>&nbsp;
Use of LFAs with SRLGs <br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor16">6.2.</a>&nbsp;
Local Area Networks<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor17">6.2.1.</a>&nbsp;
Simple LAN Repair<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor18">6.2.2.</a>&nbsp;
LAN Component Repair<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor19">6.2.3.</a>&nbsp;
LAN Repair Using Diagnostics <br />
<a href="#anchor20">7.</a>&nbsp;
Multiple Simultaneous Failures <br />
<a href="#anchor21">8.</a>&nbsp;
Optimizing not-via computations using LFAs<br />
<a href="#anchor22">9.</a>&nbsp;
Multicast<br />
<a href="#anchor23">10.</a>&nbsp;
Fast Reroute in an MPLS LDP Network.  <br />
<a href="#anchor24">11.</a>&nbsp;
Encapsulation<br />
<a href="#anchor25">12.</a>&nbsp;
Routing Extensions<br />
<a href="#anchor26">13.</a>&nbsp;
Incremental Deployment<br />
<a href="#anchor27">14.</a>&nbsp;
IANA Considerations<br />
<a href="#anchor28">15.</a>&nbsp;
Security Considerations<br />
<a href="#anchor29">16.</a>&nbsp;
Acknowledgements<br />
<a href="#rfc.references1">17.</a>&nbsp;
References<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#rfc.references1">17.1.</a>&nbsp;
Normative References<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#rfc.references2">17.2.</a>&nbsp;
Informative References<br />
<a href="#rfc.authors">&#167;</a>&nbsp;
Authors' Addresses<br />
<a href="#rfc.copyright">&#167;</a>&nbsp;
Intellectual Property and Copyright Statements<br />
</p>
<br clear="all" />

<a name="anchor1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1"></a><h3>1.&nbsp;
Conventions used in this document</h3>

<p>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
      "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
      document are to be interpreted as described in RFC 2119 <a class='info' href='#RFC2119'>[RFC2119]<span> (</span><span class='info'>Bradner, S., &ldquo;Key words for use in RFCs to Indicate Requirement Levels,&rdquo; March&nbsp;1997.</span><span>)</span></a>.
</p>
<p>
</p>
<a name="anchor2"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2"></a><h3>2.&nbsp;
Introduction</h3>

<p>
</p>
<p>When a link or a router fails, only the neighbors of the failure are
      initially aware that the failure has occurred. In a network operating IP
      fast reroute <a class='info' href='#I-D.ietf-rtgwg-ipfrr-framework'>[I&#8209;D.ietf&#8209;rtgwg&#8209;ipfrr&#8209;framework]<span> (</span><span class='info'>Shand, M. and S. Bryant, &ldquo;IP Fast Reroute Framework,&rdquo; October&nbsp;2009.</span><span>)</span></a>, the
      routers that are the neighbors of the failure repair the failure. These
      repairing routers have to steer packets to their destinations despite
      the fact that most other routers in the network are unaware of the
      nature and location of the failure.
</p>
<p>A common limitation in most IPFRR mechanisms is an inability to
      indicate the identity of the failure and to explicitly steer the
      repaired packet round the failure. The extent to which this limitation
      affects the repair coverage is topology dependent. The mechanism
      proposed here is to encapsulate the packet to an address that explicitly
      identifies the network component that the repair must avoid. This
      produces a repair mechanism, which, provided the network is not
      partitioned by the failure, will always achieve a repair.
</p>
<a name="anchor3"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3"></a><h3>3.&nbsp;
Overview of Not-via Repairs</h3>

<p>
</p>
<p>When a link or a router fails, only the neighbors of the failure are
      initially aware that the failure has occurred. In a network operating IP
      fast reroute <a class='info' href='#I-D.ietf-rtgwg-ipfrr-framework'>[I&#8209;D.ietf&#8209;rtgwg&#8209;ipfrr&#8209;framework]<span> (</span><span class='info'>Shand, M. and S. Bryant, &ldquo;IP Fast Reroute Framework,&rdquo; October&nbsp;2009.</span><span>)</span></a>, the
      routers that are the neighbors of the failure repair the failure. These
      repairing routers have to steer packets to their destinations despite
      the fact that most other routers in the network are unaware of the
      nature and location of the failure.
</p>
<p>A common limitation in most IPFRR mechanisms is an inability to
      indicate the identity of the failure and to explicitly steer the
      repaired packet round the failure. The extent to which this limitation
      affects the repair coverage is topology dependent. The mechanism
      proposed here is to encapsulate the packet to an address that explicitly
      identifies the network component that the repair must avoid. This
      produces a repair mechanism, which, provided the network is not
      partitioned by the failure, will always achieve a repair.
</p>
<p>
</p><br /><hr class="insert" />
<a name="fig-repair"></a>

<p>
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>              A
              |                Bp is the address to use to get
              |                  a packet to B not-via P
              |
   S----------P----------B. . . . . . . . . .D
    \         |        Bp^
     \        |          |
      \       |          |
       \      C          |
        \                |
         ----------------+
           Repair to Bp
</pre></div>
<p>
</p><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;1: Not-via repair of router failure&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>
</p>
<p>
</p>
<p>Assume that S has a packet for some destination D that it would
      normally send via P and B, and that S suspects that P has failed. S
      encapsulates the packet to Bp. The path from S to Bp is the shortest
      path from S to B not going via P. If the network contains a path from S
      to B that does not transit router P, i.e. the network is not partitioned
      by the failure of P, then the packet will be successfully delivered to
      B. When the packet addressed to Bp arrives at B, B removes the
      encapsulation and forwards the repaired packet towards its final
      destination.
</p>
<p>Note that if the path from B to the final destination includes one or
      more nodes that are included in the repair path, a packet may back track
      after the encapsulation is removed. However, because the decapsulating
      router is always closer to the packet destination than the encapsulating
      router, the packet will not loop.
</p>
<p>For complete protection, all of P's neighbors will require a not-via
      address that allows traffic to be directed to them without traversing P.
      This is shown in <a class='info' href='#fig-notvia-P'>Figure&nbsp;2<span> (</span><span class='info'>The set of Not-via P Addresses  </span><span>)</span></a>.
</p><br /><hr class="insert" />
<a name="fig-notvia-P"></a>

<p>
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>              A
              |Ap
              |
    Sp      Pa|Pb
   S----------P----------B
            Ps|Pc      Bp
              |
            Cp|
              C
</pre></div>
<p>
</p><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;2: The set of Not-via P Addresses  &nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>
</p>
<a name="anchor4"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.1"></a><h3>3.1.&nbsp;
Use of Equal Cost Multi-Path</h3>

<p>
</p>
<p>A router can use an equal cost multi-path (ECMP) repair in place of
        a not-via repair.
</p>
<p>A router computing a not-via repair path MAY subject the repair to
        ECMP.
</p>
<a name="anchor5"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.2"></a><h3>3.2.&nbsp;
Use of LFA repairs</h3>

<p>
</p>
<p>The not-via approach provides complete repair coverage and
        therefore may be used as the sole repair mechanism. There are,
        however, advantages in using not-via in combination with loop free
        alternates (LFA) and or downstream paths as documented in <a class='info' href='#RFC5286'>[RFC5286]<span> (</span><span class='info'>Atlas, A. and A. Zinin, &ldquo;Basic Specification for IP Fast Reroute: Loop-Free Alternates,&rdquo; September&nbsp;2008.</span><span>)</span></a>.
</p>
<p>LFAs are computed on a per destination basis and in general, only a
        subset of the destinations requiring repair will have a suitable LFA
        repair. In this case, those destinations which are repairable by LFAs
        are so repaired and the remainder of the destinations are repaired
        using the not-via encapsulation. This has the advantage of reducing
        the volume of traffic that requires encapsulation. On the other hand,
        the path taken by an LFA repair may be less optimal than that of the
        equivalent not-via repair for traffic destined to nodes close to the
        far end of the failure, but may be more optimal for some other
        traffic. The description in this document assumes that LFAs will be
        used where available, but the distribution of repairs between the two
        mechanisms is a local implementation choice.
</p>
<a name="anchor6"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4"></a><h3>4.&nbsp;
Not-via Repair Path Computation </h3>

<p>
</p>
<p>The not-via repair mechanism requires that all routers on the path
      from S to B (<a class='info' href='#fig-repair'>Figure&nbsp;1<span> (</span><span class='info'>Not-via repair of router failure</span><span>)</span></a>) have a route to Bp. They
      can calculate this by failing node P, running an SPF, and finding the
      shortest route to B.
</p>
<p>A router has no simple way of knowing whether it is on the shortest
      path for any particular repair. It is therefore necessary for every
      router to calculate the path it would use in the event of any possible
      router failure. Each router therefore "fails" every router in the
      network, one at a time, and calculates its own best route to each of the
      neighbors of that router. In other words, with reference to <a class='info' href='#fig-repair'>Figure&nbsp;1<span> (</span><span class='info'>Not-via repair of router failure</span><span>)</span></a>, some router X will consider each router in
      turn to be P, fail P, and then calculate its own route to each of the
      not-via P addresses advertised by the neighbors of P. i.e. X calculates
      its route to Sp, Ap, Bp, and Cp, in each case, not via P.
</p>
<p>To calculate the repair paths a router has to calculate n-1 SPFs
      where n is the number of routers in the network. This is expensive to
      compute. However, the problem is amenable to a solution in which each
      router (X) proceeds as follows. X first calculates the base topology
      with all routers functional and determines its normal path to all
      not-via addresses. This can be performed as part of the normal SPF
      computation. For each router P in the topology, X then performs the
      following actions:-
</p>
<p></p>
<ol class="text">
<li>Removes router P from the topology.
</li>
<li>Performs an incremental SPF <a class='info' href='#ISPF'>[ISPF]<span> (</span><span class='info'>McQuillan, J., Richer, I., and E. Rosen, &ldquo;ARPANET Routing Algorithm Improvements&quot;,&rdquo; 1978.</span><span>)</span></a> on the
          modified topology. The iSPF process involves detaching the sub-tree
          affected by the removal of router P, and then re-attaching the
          detached nodes. However, it is not necessary to run the iSPF to
          completion. It is sufficient to run the iSPF up to the point where
          all of the nodes advertising not-via P addresses have been
          re-attached to the SPT, and then terminate it.
</li>
<li>Reverts to the base topology.
</li>
</ol><p>This algorithm is significantly less expensive than a set of
      full SPFs. Thus, although a router has to calculate the repair paths for
      n-1 failures, the computational effort is much less than n-1 SPFs.
</p>
<p>Experiments on a selection of real world network topologies with
      between 40 and 400 nodes suggest that the worst-case computational
      complexity using the above optimizations is equivalent to performing
      between 5 and 13 full SPFs. Further optimizations are described in
      section 6.
</p>
<a name="anchor7"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.1"></a><h3>4.1.&nbsp;
Computing not-via repairs in routing vector protocols</h3>

<p>
</p>
<p>While this document focuses on link state routing protocols, it is
        equally possible to compute not-via repairs in distance vector (e.g.
        RIP) or path vector (e.g. BGP) routing protocols. This can be achieved
        with very little protocol modification by advertising the not-via
        address in the normal way, but ensuring that the information about a
        not-via address Ps is not propagated through the node S. In the case
        of link protection this simply means that the advertisement from P to
        S is suppressed, with the result that S and all other nodes compute a
        route to Ps which doesn't traverse S, as required.
</p>
<p>In the case of node protection, where P is the protected node, and
        N is some neighbor, the advertisement of Np must be suppressed not
        only across the link N-&gt;P, but also across any link to P. The
        simplest way of achieving this is for P itself to perform the
        suppression of any address of the form Xp.
</p>
<a name="anchor8"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5"></a><h3>5.&nbsp;
Operation of Repairs</h3>

<p>This section explains the basic operation of the not-via repair of
      node and link failure.
</p>
<a name="anchor9"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.1"></a><h3>5.1.&nbsp;
Node Failure</h3>

<p>
</p>
<p>When router P fails (<a class='info' href='#fig-notvia-P'>Figure&nbsp;2<span> (</span><span class='info'>The set of Not-via P Addresses  </span><span>)</span></a>) S
        encapsulates any packet that it would send to B via P to Bp, and then
        sends the encapsulated packet on the shortest path to Bp. S follows
        the same procedure for routers A and C in <a class='info' href='#fig-notvia-P'>Figure&nbsp;2<span> (</span><span class='info'>The set of Not-via P Addresses  </span><span>)</span></a>. The packet is decapsulated at the
        repair target (A, B or C) and then forwarded normally to its
        destination. The repair target can be determined as part of the normal
        SPF by recording the "next-next-hop" for each destination in addition
        to the normal next-hop.
</p>
<p>Notice that with this technique only one level of encapsulation is
        needed, and that it is possible to repair ANY failure regardless of
        link metrics and any asymmetry that may be present in the network. The
        only exception to this is where the failure was a single point of
        failure that partitioned the network, in which case ANY repair is
        clearly impossible.
</p>
<a name="anchor10"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.2"></a><h3>5.2.&nbsp;
Link Failure</h3>

<p>
</p>
<p>The normal mode of operation of the network would be to assume
        router failure. However, where some destinations are only reachable
        through the failed router, it is desirable that an attempt be made to
        repair to those destinations by assuming that only a link failure has
        occurred.
</p>
<p>To perform a link repair, S encapsulates to Ps (i.e. it instructs
        the network to deliver the packet to P not-via S). All of the
        neighbors of S will have calculated a path to Ps in case S itself had
        failed. S could therefore give the packet to any of its neighbors
        (except, of course, P). However, S should preferably send the
        encapsulated packet on the shortest available path to P. This path is
        calculated by running an SPF with the link SP failed. Note that this
        may again be an incremental calculation, which can terminate when
        address Ps has been reattached.
</p>
<p>It is necessary to consider the behavior of IPFRR solutions when a
        link repair is attempted in the presence of node failure. In its
        simplest form the not-via IPFRR solution prevents the formation of
        loops forming as a result of mutual repair, by never providing a
        repair path for a not-via address. Referring to <a class='info' href='#fig-notvia-P'>Figure&nbsp;2<span> (</span><span class='info'>The set of Not-via P Addresses  </span><span>)</span></a>, if A was the neighbor of P that was on
        the link repair path from S to P, and P itself had failed, the
        repaired packet from S would arrive at A encapsulated to Ps. A would
        have detected that the AP link had failed and would normally attempt
        to repair the packet. However, no repair path is provided for any
        not-via address, and so A would be forced to drop the packet, thus
        preventing the formation of loop.
</p>
<p>
</p>
<a name="anchor11"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.3"></a><h3>5.3.&nbsp;
Multi-homed Prefixes</h3>

<p>
</p>
<p>A multi-homed Prefix (MHP) is a prefix that is reachable via more
        than one router in the network. Some of these may be repairable using
        LFAs as described in <a class='info' href='#RFC5286'>[RFC5286]<span> (</span><span class='info'>Atlas, A. and A. Zinin, &ldquo;Basic Specification for IP Fast Reroute: Loop-Free Alternates,&rdquo; September&nbsp;2008.</span><span>)</span></a>. Only those
        without such a repair need be considered here.
</p>
<p>When IPFRR router S (<a class='info' href='#fig-MHP'>Figure&nbsp;3<span> (</span><span class='info'>Multi-homed Prefixes</span><span>)</span></a>) discovers that
        P has failed, it needs to send packets addressed to the MHP X, which
        is normally reachable through P, to an alternate router, which is
        still able to reach X.
</p><br /><hr class="insert" />
<a name="fig-MHP"></a>

<p>
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>   X                          X                          X
   |                          |                          |
   |                          |                          |
   |                Sp        |Pb                        |
   Z...............S----------P----------B...............Y
                            Ps|Pc      Bp
                              |
                            Cp|
                              C</pre></div>
<p>
</p><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;3: Multi-homed Prefixes&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>
</p>
<p>S should choose the closest router that can reach X during the
        failure as the alternate router. S determines which router to use as
        the alternate while running the SPF with P failed. This is
        accomplished by the normal process of re-attaching a leaf node to the
        core topology (this is sometimes known as a "partial SPF").
</p>
<p>First, consider the case where the shortest alternate path to X is
        via Z. S can reach Z without using the failed router P. However, S
        cannot just send the packet towards Z, because the other routers in
        the network will not be aware of the failure of P, and may loop the
        packet back to S. S therefore encapsulates the packet to Z (using a
        normal address for Z). When Z receives the encapsulated packet it
        removes the encapsulation and forwards the packet to X.
</p>
<p>Now consider the case where the shortest alternate path to X is via
        Y, which S reaches via P and B. To reach Y, S must first repair the
        packet to B using the normal not-via repair mechanism. To do this S
        encapsulates the packet for X to Bp. When B receives the packet it
        removes the encapsulation and discovers that the packet is intended
        for MHP X. The situation now reverts to the previous case, in which
        the shortest alternate path does not require traversal of the failure.
        B therefore follows the algorithm above and encapsulates the packet to
        Y (using a normal address for Y). Y removes the encapsulation and
        forwards the packet to X.
</p>
<p>It may be that the cost of reaching X using local delivery from the
        alternate router (i.e. Z or Y) is greater than the cost of reaching X
        via P. Under those circumstances, the alternate router would normally
        forward to X via P, which would cause the IPFRR repair to loop. To
        prevent the repair from looping the alternate router must locally
        deliver a packet received via a repair encapsulation. This may be
        specified by using a special address with the above semantics. Note
        that only one such address is required per node. Notice that using the
        not-via approach, only one level of encapsulation was needed to repair
        MHPs to the alternate router.
</p>
<a name="anchor12"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.4"></a><h3>5.4.&nbsp;
Installation of Repair Paths </h3>

<p>
</p>
<p>The following algorithm is used by node S (<a class='info' href='#fig-MHP'>Figure&nbsp;3<span> (</span><span class='info'>Multi-homed Prefixes</span><span>)</span></a>) to pre- calculate and install repair paths
        in the FIB, ready for immediate use in the event of a failure. It is
        assumed that the not-via repair paths have already been calculated as
        described above.
</p>
<p>For each neighbor P, consider all destinations which are reachable
        via P in the current topology:-
</p>
<p></p>
<ol class="text">
<li>For all destinations with an ECMP or LFA repair (as described
            in <a class='info' href='#RFC5286'>[RFC5286]<span> (</span><span class='info'>Atlas, A. and A. Zinin, &ldquo;Basic Specification for IP Fast Reroute: Loop-Free Alternates,&rdquo; September&nbsp;2008.</span><span>)</span></a>) install that repair.
</li>
<li>For each destination (DR) that remains, identify in the current
            topology the next-next-hop (H) (i.e. the neighbor of P that P will
            use to send the packet to DR). This can be determined during the
            normal SPF run by recording the additional information. If S has a
            path to the not-via address Hp (H not via P), install a not-via
            repair to Hp for the destination DR.
</li>
<li>Identify all remaining destinations (M) which can still be
            reached when node P fails. These will be multi-homed prefixes that
            are not repairable by LFA, for which the normal attachment node is
            P, or a router for which P is a single point of failure, and have
            an alternative attachment point that is reachable after P has
            failed. One way of determining these destinations would be to run
            an SPF rooted at S with node P removed, but an implementation may
            record alternative attachment points during the normal SPF run. In
            either case, the next best point of attachment can also be
            determined for use in step (4) below.
</li>
<li>For each multi-homed prefix (M) identified in step (3):-
<blockquote class="text"><dl>
<dt>A.</dt>
<dd>Identify the new attachment node (as shown in <a class='info' href='#fig-MHP'>Figure&nbsp;3<span> (</span><span class='info'>Multi-homed Prefixes</span><span>)</span></a>). This may be:-
<blockquote class="text"><dl>
<dt>a.</dt>
<dd>Y, where the next hop towards Y is P, or
</dd>
<dt>b.</dt>
<dd>Z, where the next hop towards Z is not P.
</dd>
</dl></blockquote>If the attachment node is Z, install the repair for M
                as a tunnel to Z' (where Z' is the address of Z that is used
                to force local forwarding).
</dd>
<dt>B.</dt>
<dd>For the subset of prefixes (M) that remain (having
                attachment point Y), install the repair path previously
                installed for destination Y.
</dd>
</dl></blockquote>For each destination (DS) that remains, install a not-via
            repair to Ps (P not via S). Note, these are destinations for which
            node P is a single point of failure, and can only be repaired by
            assuming that the apparent failure of node P was simply a failure
            of the S-P link. Note that, if available, a downstream path to P
            may be used for such a repair. This cannot generate a persistent
            loop in the event of the failure of node P, but if one neighbor of
            P uses a not-via repair and another uses a downstream path, it is
            possible for a packet sent on the downstream path to be returned
            to the sending node inside a not-via encapsulation. Since packets
            destined to not-via addresses are not repaired, the packet will be
            dropped after executing a single turn loop.
</li>
</ol>

<a name="anchor13"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6"></a><h3>6.&nbsp;
Compound Failures</h3>

<p>The following types of failures involve more tha one component.
</p>
<a name="anchor14"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.1"></a><h3>6.1.&nbsp;
Shared Risk Link Groups</h3>

<p>
</p>
<p>A Shared Risk Link Group (SRLG) is a set of links whose failure can
        be caused by a single action such as a conduit cut or line card
        failure. When repairing the failure of a link that is a member of an
        SRLG, it must be assumed that all the other links that are also
        members of the SRLG have also failed. Consequently, any repair path
        must be computed to avoid not just the adjacent link, but also all the
        links which are members of the same SRLG.
</p>
<p>In <a class='info' href='#fig-SRLG1'>Figure&nbsp;4<span> (</span><span class='info'>Shared Risk Link Group  </span><span>)</span></a> below, the links S-P and A-B
        are both members of SRLG "a". The semantics of the not-via address Ps
        changes from simply "P not-via the link S-P" to be "P not-via the link
        S-P or any other link with which S-P shares an SRLG" In <a class='info' href='#fig-SRLG1'>Figure&nbsp;4<span> (</span><span class='info'>Shared Risk Link Group  </span><span>)</span></a> this is the links that are members of SRLG
        "a". I.e. links S-P and A-B. Since the information about SRLG
        membership of all links is available in the Link State Database, all
        nodes computing routes to the not-via address Ps can infer these
        semantics, and perform the computation by failing all the links in the
        SRLG when running the iSPF.
</p>
<p>Note that it is not necessary for S to consider repairs to any
        other nodes attached to members of the SRLG (such as B). It is
        sufficient for S to repair to the other end of the adjacent link (P in
        this case).
</p><br /><hr class="insert" />
<a name="fig-SRLG1"></a>

<p>
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>                a   Ps
           S----------P---------D
           |          |
           |    a     |
           A----------B
           |          |
           |          |
           C----------E</pre></div>
<p>
</p><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;4: Shared Risk Link Group  &nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>In some cases, it may be that the links comprising the SRLG occur
        in series on the path from S to the destination D, as shown in <a class='info' href='#fig-SRLG2'>Figure&nbsp;5<span> (</span><span class='info'>Shared Risk Link Group members in series</span><span>)</span></a>. In this case, multiple consecutive repairs
        may be necessary. S will first repair to Ps, then P will repair to Dp.
        In both cases, because the links concerned are members of SRLG "a" the
        paths are computed to avoid all members of SRLG "a".
</p><br /><hr class="insert" />
<a name="fig-SRLG2"></a>

<p>
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>                a   Ps    a   Dp
           S----------P---------D
           |          |         |
           |    a     |         |
           A----------B         |
           |          |         |
           |          |         |
           C----------E---------F</pre></div>
<p>
</p><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;5: Shared Risk Link Group members in series&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>
</p>
<p>While the use of multiple repairs in series introduces some
        additional overhead, these semantics avoid the potential combinatorial
        explosion of not-via addresses that could otherwise occur.
</p>
<p>Note that although multiple repairs are used, only a single level
        of encapsulation is required. This is because the first repair packet
        is de-capsulated before the packet is re-encapsulated using the not-
        via address corresponding to the far side of the next link which is a
        member of the same SRLG. In some cases the de-capsulation and re-
        encapsulation takes place (at least notionally) at a single node,
        while in other cases, these functions may be performed by different
        nodes. This scenario is illustrated in <a class='info' href='#fig-SRLG3'>Figure&nbsp;6<span> (</span><span class='info'>Shared Risk Link Group members in series </span><span>)</span></a> below.
</p><br /><hr class="insert" />
<a name="fig-SRLG3"></a>

<p>
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>                a   Ps              a  Dg
           S----------P---------G--------D
           |          |         |        |
           |    a     |         |        |
           A----------B         |        |
           |          |         |        |
           |          |         |        |
           C----------E---------F--------H
</pre></div>
<p>
</p><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;6: Shared Risk Link Group members in series &nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>
</p>
<p>In this case, S first encapsulates to Ps, and node P decapsulates
        the packet and forwards it "native" to G using its normal FIB entry
        for destination D. G then repairs the packet to Dg.
</p>
<p>It can be shown that such multiple repairs can never form a loop
        because each repair causes the packet to move closer to its
        destination.
</p>
<p>It is often the case that a single link may be a member of multiple
        SRLGs, and those SRLG may not be isomorphic. This is illustrated in
        <a class='info' href='#fig-SRLG4'>Figure&nbsp;7<span> (</span><span class='info'>Multiple Shared Risk Link Groups </span><span>)</span></a> below.
</p><br /><hr class="insert" />
<a name="fig-SRLG4"></a>

<p>
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>                ab  Ps              a  Dg
           S----------P---------G--------D
           |          |         |        |
           |    a     |         |        |
           A----------B         |        |
           |          |         |        |
           |    b     |         |   b    |
           C----------E---------F--------H
           |          |
           |          |
           J----------K</pre></div>
<p>
</p><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;7: Multiple Shared Risk Link Groups &nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>The link SP is a member of SRLGs "a" and "b". When a failure of the
        link SP is detected, it must be assumed that BOTH SRLGs have failed.
        Therefore the not-via path to Ps must be computed by failing all links
        which are members of SRLG "a" or SRLG "b". I.e. the semantics of Ps is
        now "P not-via any links which are members of any of the SRLGs of
        which link SP is a member". This is illustrated in <a class='info' href='#fig-SRLG5'>Figure&nbsp;8<span> (</span><span class='info'>Topology used for repair computation for link S-P</span><span>)</span></a> below.
</p><br /><hr class="insert" />
<a name="fig-SRLG5"></a>

<p>
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>                ab  Ps              a  Dg
           S----/-----P---------G---/----D
           |          |         |        |
           |    a     |         |        |
           A----/-----B         |        |
           |          |         |        |
           |    b     |         |   b    |
           C----/-----E---------F---/----H
           |          |
           |          |
           J----------K</pre></div>
<p>
</p><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;8: Topology used for repair computation for link S-P&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>In this case, the repair path to Ps will be S-A-C-J-K-E-B-P. It may
        appear that there is no path to D because GD is a member of SRLG "a"
        and FH is a member of SRLG "b". This is true if BOTH SRLGs "a" and "b"
        have in fact failed. But that would be an instance of multiple
        uncorrelated failures which are out of scope for this design. In
        practice it is likely that there is only a single failure, i.e. either
        SRLG "a" or SRLG "b" has failed, but not both. These two possibilities
        are indistinguishable from the point of view of the repairing router S
        and so it must repair on the assumption that both are unavailable.
        However, each link repair is considered independently. The repair to
        Ps delivers the packet to P which then forwards the packet to G. When
        the packet arrives at G, if SRLG "a" has failed it will be repaired
        around the path G-F-H-D. This is illustrated in <a class='info' href='#fig-SRLG6'>Figure&nbsp;9<span> (</span><span class='info'>Topology used for repair computation for link G-D  </span><span>)</span></a> below. If, on the other hand, SRLG "b" has
        failed, link GD will still be available. In this case the packet will
        be delivered as normal across the link GD.
</p><br /><hr class="insert" />
<a name="fig-SRLG6"></a>

<p>
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>                ab  Ps              a  Dg
           S----/-----P---------G---/----D
           |          |         |        |
           |    a     |         |        |
           A----/-----B         |        |
           |          |         |        |
           |    b     |         |   b    |
           C----------E---------F--------H
           |          |
           |          |
           J----------K</pre></div>
<p>
</p><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;9: Topology used for repair computation for link G-D  &nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>
</p>
<p>A repair strategy that assumes the worst-case failure for each link
        can often result in longer repair paths than necessary. In cases where
        only a single link fails, rather than the full SRLG, this strategy may
        occasionally fail to identify a repair even though a viable repair
        path exists in the network. The use of sub-optimal repair paths is an
        inevitable consequence of this compromise approach. The failure to
        identify any repair is a serious deficiency, but is a rare occurrence
        in a robustly designed network. This problem can be addressed
        by:-</p>
<ol class="text">
<li>Reporting that the link in question is irreparable, so that the
            network designer can take appropriate action.
</li>
<li>Modifying the design of the network to avoid this
            possibility.
</li>
<li>Using some form of SRLG diagnostic (for example, by running BFD
            over alternate repair paths) to determine which SRLG member(s) has
            actually failed and using this information to select an
            appropriate pre-computed repair path. However, aside from the
            complexity of performing the diagnostics, this requires multiple
            not-via addresses per interface, which has poor scaling
            properties.
</li>
</ol>

<a name="anchor15"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.1.1"></a><h3>6.1.1.&nbsp;
Use of LFAs with SRLGs </h3>

<p>Section 4.1 above describes the repair of links which are members
          of one or more SRLGs. LFAs can be used for the repair of such links
          provided that any other link with which S-P shares an SRLG is
          avoided when computing the LFA. This is described for the simple
          case of "local-SRLGs" in <a class='info' href='#RFC5286'>[RFC5286]<span> (</span><span class='info'>Atlas, A. and A. Zinin, &ldquo;Basic Specification for IP Fast Reroute: Loop-Free Alternates,&rdquo; September&nbsp;2008.</span><span>)</span></a>.
</p>
<p>
</p>
<a name="anchor16"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.2"></a><h3>6.2.&nbsp;
Local Area Networks</h3>

<p>LANs are a special type of SRLG and are solved using the SRLG
        mechanisms outlined above. With all SRLGs there is a trade-off between
        the sophistication of the fault detection and the size of the SRLG.
        Protecting against link failure of the LAN link(s) is relatively
        straightforward, but as with all fast reroute mechanisms, the problem
        becomes more complex when it is desired to protect against the
        possibility of failure of the nodes attached to the LAN as well as the
        LAN itself.
</p><br /><hr class="insert" />
<a name="fig-LAN1"></a>

<p>
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>                        +--------------Q------C
                        |
                        |
                        |
      A--------S-------(N)-------------P------B
                        |
                        |
                        |
                        +--------------R------D</pre></div>
<p>
</p><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;10: Local Area Networks &nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>
</p>
<p>Consider the LAN shown in <a class='info' href='#fig-LAN1'>Figure&nbsp;10<span> (</span><span class='info'>Local Area Networks </span><span>)</span></a>. For
        connectivity purposes, we consider that the LAN is represented by the
        pseudonode (N). To provide IPFRR protection, S must run a connectivity
        check to each of its protected LAN adjacencies P, Q, and R, using, for
        example BFD <a class='info' href='#I-D.ietf-bfd-base'>[I&#8209;D.ietf&#8209;bfd&#8209;base]<span> (</span><span class='info'>Katz, D. and D. Ward, &ldquo;Bidirectional Forwarding Detection,&rdquo; January&nbsp;2010.</span><span>)</span></a>.
</p>
<p>When S discovers that it has lost connectivity to P, it is unsure
        whether the failure is:
</p>
<p></p>
<ul class="text">
<li>its own interface to the LAN,
</li>
<li>the LAN itself,
</li>
<li>the LAN interface of P,
</li>
<li>the node P.
</li>
</ul>

<a name="anchor17"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.2.1"></a><h3>6.2.1.&nbsp;
Simple LAN Repair</h3>

<p>A simple approach to LAN repair is to consider the LAN and all of
          its connected routers as a single SRLG. Thus, the address P not via
          the LAN (Pl) would require P to be reached not-via any router
          connected to the LAN. This is shown in <a class='info' href='#fig-LAN2'>Figure&nbsp;11<span> (</span><span class='info'>Local Area Networks - LAN SRLG</span><span>)</span></a>.
</p><br /><hr class="insert" />
<a name="fig-LAN2"></a>

<p>
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>                                    Ql       Cl
                        +-------------Q--------C
                        |              Qc
                        |
       As       Sl      |           Pl       Bl
      A--------S-------(N)------------P--------B
             Sa         |              Pb
                        |
                        |           Rl       Dl
                        +-------------R--------D
                                       Rd
</pre></div>
<p>
</p><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;11: Local Area Networks - LAN SRLG&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>
</p>
<p>In this case, when S detected that P had failed it would send
          traffic reached via P and B to B not-via the LAN or any router
          attached to the LAN (i.e. to Bl). Any destination only reachable
          through P would be addressed to P not-via the LAN or any router
          attached to the LAN (except of course P).
</p>
<p>Whilst this approach is simple, it assumes that a large portion
          of the network adjacent to the failure has also failed. This will
          result in the use of sub-optimal repair paths and in some cases the
          inability to identify a viable repair.
</p>
<p>
</p>
<a name="anchor18"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.2.2"></a><h3>6.2.2.&nbsp;
LAN Component Repair</h3>

<p>
</p>
<p>In this approach, possible failures are considered at a finer
          granularity, but without the use of diagnostics to identify the
          specific component that has failed. Because S is unable to diagnose
          the failure it must repair traffic sent through P and B, to B not-
          via P,N (i.e. not via P and not via N), on the conservative
          assumption that both the entire LAN and P have failed. Destinations
          for which P is a single point of failure must as usual be sent to P
          using an address that avoids the interface by which P is reached
          from S, i.e. to P not-via N. Similarly for routers Q and R.
</p>
<p>Notice that each router that is connected to a LAN must, as
          usual, advertise one not-via address for each neighbor. In addition,
          each router on the LAN must advertise an extra address not via the
          pseudonode (N).
</p>
<p>Notice also that each neighbor of a router connected to a LAN
          must advertise two not-via addresses, the usual one not via the
          neighbor and an additional one, not via either the neighbor or the
          pseudonode. The required set of LAN address assignments is shown in
          <a class='info' href='#fig-LAN3'>Figure&nbsp;12<span> (</span><span class='info'>Local Area Networks</span><span>)</span></a> below. Each router on the LAN, and
          each of its neighbors, is advertising exactly one address more than
          it would otherwise have advertised if this degree of connectivity
          had been achieved using point-to-point links.
</p><br /><hr class="insert" />
<a name="fig-LAN3"></a>

<p>
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>                                  Qs Qp Qc    Cqn
                        +--------------Q---------C
                        |         Qr Qn        Cq
                        |
       Asn   Sa Sp Sq   |         Ps Pq Pb    Bpn
      A--------S-------(N)-------------P---------B
       As       Sr Sn   |         Pr Pn        Bp
                        |
                        |         Rs Rp Pd    Drn
                        +--------------R---------D
                                  Rq Rn        Dr</pre></div>
<p>
</p><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;12: Local Area Networks&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<a name="anchor19"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.2.3"></a><h3>6.2.3.&nbsp;
LAN Repair Using Diagnostics </h3>

<p>A more specific LAN repair can be undertaken by using
          diagnostics. In order to explicitly diagnose the failed network
          component, S correlates the connectivity reports from P and one or
          more of the other routers on the LAN, in this case, Q and R. If it
          lost connectivity to P alone, it could deduce that the LAN was still
          functioning and that the fault lay with either P, or the interface
          connecting P to the LAN. It would then repair to B not via P (and P
          not-via N for destinations for which P is a single point of failure)
          in the usual way. If S lost connectivity to more than one router on
          the LAN, it could conclude that the fault lay only with the LAN, and
          could repair to P, Q and R not-via N, again in the usual way.
</p>
<p>
</p>
<a name="anchor20"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7"></a><h3>7.&nbsp;
Multiple Simultaneous Failures </h3>

<p>
</p>
<p>The failure of a node or an SRLG can result in multiple correlated
      failures, which may be repaired using the mechanisms described in this
      design. This design will not correctly repair a set of unanticipated
      multiple failures. Such failures are out of scope of this design and are
      for further study.
</p>
<p>It is important that the routers in the network are able to
      discriminate between these two classes of failure, and take appropriate
      action.
</p>
<a name="anchor21"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.8"></a><h3>8.&nbsp;
Optimizing not-via computations using LFAs</h3>

<p>
</p>
<p>If repairing node S has an LFA to the repair endpoint it is not
      necessary for any router to perform the incremental SPF with the link SP
      removed in order to compute the route to the not-via address Ps. This is
      because the correct routes will already have been computed as a result
      of the SPF on the base topology. Node S can signal this condition to all
      other routers by including a bit in its LSP or LSA associated with each
      LFA protected link. Routers computing not-via routes can then omit the
      running of the iSPF for links with this bit set.
</p>
<p>When running the iSPF for a particular link AB, the calculating
      router first checks whether the link AB is present in the existing SPT.
      If the link is not present in the SPT, no further work is required. This
      check is a normal part of the iSPF computation.
</p>
<p>If the link is present in the SPT, this optimization introduces a
      further check to determine whether the link is marked as protected by an
      LFA in the direction in which the link appears in the SPT. If so the
      iSPF need not be performed. For example, if the link appears in the SPT
      in the direction A-&gt;B and A has indicated that the link AB is
      protected by an LFA no further action is required for this link.
</p>
<p>If the receipt of this information is delayed, the correct operation
      of the protocol is not compromised provided that the necessity to
      perform a not-via computation is re-evaluated whenever new information
      arrives.
</p>
<p>This optimization is not particularly beneficial to nodes close to
      the repair since, as has been observed above, the computation for nodes
      on the LFA path is trivial. However, for nodes upstream of the link SP
      for which S-P is in the path to P, there is a significant reduction in
      the computation required.
</p>
<a name="anchor22"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.9"></a><h3>9.&nbsp;
Multicast</h3>

<p>
</p>
<p>Multicast traffic can be repaired in a similar way to unicast. The
      multicast forwarder is able to use the not-via address to which the
      multicast packet was addressed as an indication of the expected receive
      interface and hence to correctly run the required RPF check.
</p>
<p>In some cases, all the destinations, including the repair endpoint,
      are repairable by an LFA. In this case, all unicast traffic may be
      repaired without encapsulation. Multicast traffic still requires
      encapsulation, but for the nodes on the LFA repair path the computation
      of the not-via forwarding entry is unnecessary since, by definition,
      their normal path to the repair endpoint is not via the failure.
</p>
<p>A more complete description of multicast operation will be provided
      in a future version of this draft.
</p>
<p>
</p>
<a name="anchor23"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.10"></a><h3>10.&nbsp;
Fast Reroute in an MPLS LDP Network.  </h3>

<p>
</p>
<p>Not-via addresses are IP addresses and LDP <a class='info' href='#RFC5036'>[RFC5036]<span> (</span><span class='info'>Andersson, L., Minei, I., and B. Thomas, &ldquo;LDP Specification,&rdquo; October&nbsp;2007.</span><span>)</span></a> will distribute labels for them in the usual
      way. The not-via repair mechanism may therefore be used to provide fast
      re-route in an MPLS network by first pushing the label which the repair
      endpoint uses to forward the packet, and then pushing the label
      corresponding to the not-via address needed to effect the repair.
      Referring once again to <a class='info' href='#fig-repair'>Figure&nbsp;1<span> (</span><span class='info'>Not-via repair of router failure</span><span>)</span></a>, if S has a
      packet destined for D that it must reach via P and B, S first pushes B's
      label for D. S then pushes the label that its next hop to Bp needs to
      reach Bp.
</p>
<p>Note that in an MPLS LDP network it is necessary for S to have the
      repair endpoint's label for the destination. When S is effecting a link
      repair it already has this. In the case of a node repair, S either needs
      to set up a directed LDP session with each of its neighbor's neighbors,
      or it needs to use the next-next hop label distribution mechanism
      proposed in <a class='info' href='#I-D.shen-mpls-ldp-nnhop-label'>[I&#8209;D.shen&#8209;mpls&#8209;ldp&#8209;nnhop&#8209;label]<span> (</span><span class='info'>Shen, N., &ldquo;Discovering LDP Next-Nexthop Labels,&rdquo; May&nbsp;2005.</span><span>)</span></a>.
</p>
<a name="anchor24"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.11"></a><h3>11.&nbsp;
Encapsulation</h3>

<p>Any IETF specified IP in IP encapsulation may be used to carry a
      not-via repair. IP in IP <a class='info' href='#RFC2003'>[RFC2003]<span> (</span><span class='info'>Perkins, C., &ldquo;IP Encapsulation within IP,&rdquo; October&nbsp;1996.</span><span>)</span></a>, GRE <a class='info' href='#RFC1701'>[RFC1701]<span> (</span><span class='info'>Hanks, S., Li, T., Farinacci, D., and P. Traina, &ldquo;Generic Routing Encapsulation (GRE),&rdquo; October&nbsp;1994.</span><span>)</span></a> and L2TPv3 <a class='info' href='#RFC3931'>[RFC3931]<span> (</span><span class='info'>Lau, J., Townsley, M., and I. Goyret, &ldquo;Layer Two Tunneling Protocol - Version 3 (L2TPv3),&rdquo; March&nbsp;2005.</span><span>)</span></a>, all
      have the necessary and sufficient properties. The requirement is that
      both the encapsulating router and the router to which the encapsulated
      packet is addressed have a common ability to process the chosen
      encapsulation type. When an MPLS LDP network is being protected, the
      encapsulation would normally be an additional MPLS label. In an MPLS
      enabled IP network an MPLS label may be used in place of an IP in IP
      encapsulation in the case above.
</p>
<a name="anchor25"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.12"></a><h3>12.&nbsp;
Routing Extensions</h3>

<p>
</p>
<p>IPFRR requires IGP extensions. Each IPFRR router that is directly
      connected to a protected network component must advertise a not-via
      address for that component. This must be advertised in such a way that
      the association between the protected component (link, router or SRLG)
      and the not-via address can be determined by the other routers in the
      network.
</p>
<p>It is necessary that not-via capable routers advertise in the IGP
      that they will calculate not-via routes.
</p>
<p>It is necessary for routers to advertise the type of encapsulation
      that they support (MPLS, GRE, L2TPv3 etc). However, the deployment of
      mixed IP encapsulation types within a network is discouraged.
</p>
<a name="anchor26"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.13"></a><h3>13.&nbsp;
Incremental Deployment</h3>

<p>Incremental deployment is supported by excluding routers that are not
      calculating not-via routes (as indicated by their capability information
      flooded with their link state information) from the base topology used
      for the computation of repair paths. In that way repairs may be steered
      around islands of routers that are not IPFRR capable. Routers that are
      protecting a network component need to have the capability to
      encapsulate and de-capsulate packets. However, routers that are on the
      repair path only need to be capable of calculating not-via paths and
      including the not-via addresses in their FIB i.e. these routers do not
      need any changes to their forwarding mechanism.
</p>
<a name="anchor27"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.14"></a><h3>14.&nbsp;
IANA Considerations</h3>

<p>There are no IANA considerations that arise from this draft.
</p>
<a name="anchor28"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.15"></a><h3>15.&nbsp;
Security Considerations</h3>

<p>The repair endpoints present vulnerability in that they might be used
      as a method of disguising the delivery of a packet to a point in the
      network. The primary method of protection should be through the use of a
      private address space for the not-via addresses. These addresses MUST
      NOT be advertised outside the area, and SHOULD be filtered at the
      network entry points. In addition, a mechanism might be developed that
      allowed the use of the mild security available through the use of a key
      <a class='info' href='#RFC1701'>[RFC1701]<span> (</span><span class='info'>Hanks, S., Li, T., Farinacci, D., and P. Traina, &ldquo;Generic Routing Encapsulation (GRE),&rdquo; October&nbsp;1994.</span><span>)</span></a> <a class='info' href='#RFC3931'>[RFC3931]<span> (</span><span class='info'>Lau, J., Townsley, M., and I. Goyret, &ldquo;Layer Two Tunneling Protocol - Version 3 (L2TPv3),&rdquo; March&nbsp;2005.</span><span>)</span></a>. With the
      deployment of such mechanisms, the repair endpoints would not increase
      the security risk beyond that of existing IP tunnel mechanisms. An
      attacker may attempt to overload a router by addressing an excessive
      traffic load to the de-capsulation endpoint. Typically, routers take a
      50% performance penalty in decapsulating a packet. The attacker could
      not be certain that the router would be impacted, and the extremely high
      volume of traffic needed, would easily be detected as an anomaly. If an
      attacker were able to influence the availability of a link, they could
      cause the network to invoke the not-via repair mechanism. A network
      protected by not-via IPFRR is less vulnerable to such an attack than a
      network that undertook a full convergence in response to a link up/down
      event.
</p>
<p>
</p>
<a name="anchor29"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.16"></a><h3>16.&nbsp;
Acknowledgements</h3>

<p>The authors would like to acknowledge contributions made by Alia
      Atlas and John Harper.
</p>
<a name="rfc.references"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.17"></a><h3>17.&nbsp;
References</h3>

<a name="rfc.references1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>17.1.&nbsp;Normative References</h3>
<table width="99%" border="0">
<tr><td class="author-text" valign="top"><a name="RFC2119">[RFC2119]</a></td>
<td class="author-text"><a href="mailto:sob@harvard.edu">Bradner, S.</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>,&rdquo; BCP&nbsp;14, RFC&nbsp;2119, March&nbsp;1997 (<a href="http://www.rfc-editor.org/rfc/rfc2119.txt">TXT</a>, <a href="http://xml.resource.org/public/rfc/html/rfc2119.html">HTML</a>, <a href="http://xml.resource.org/public/rfc/xml/rfc2119.xml">XML</a>).</td></tr>
</table>

<a name="rfc.references2"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>17.2.&nbsp;Informative References</h3>
<table width="99%" border="0">
<tr><td class="author-text" valign="top"><a name="I-D.ietf-bfd-base">[I-D.ietf-bfd-base]</a></td>
<td class="author-text">Katz, D. and D. Ward, &ldquo;<a href="http://www.ietf.org/internet-drafts/draft-ietf-bfd-base-11.txt">Bidirectional Forwarding Detection</a>,&rdquo; draft-ietf-bfd-base-11 (work in progress), January&nbsp;2010 (<a href="http://www.ietf.org/internet-drafts/draft-ietf-bfd-base-11.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="I-D.ietf-rtgwg-ipfrr-framework">[I-D.ietf-rtgwg-ipfrr-framework]</a></td>
<td class="author-text">Shand, M. and S. Bryant, &ldquo;<a href="http://www.ietf.org/internet-drafts/draft-ietf-rtgwg-ipfrr-framework-13.txt">IP Fast Reroute Framework</a>,&rdquo; draft-ietf-rtgwg-ipfrr-framework-13 (work in progress), October&nbsp;2009 (<a href="http://www.ietf.org/internet-drafts/draft-ietf-rtgwg-ipfrr-framework-13.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="I-D.shen-mpls-ldp-nnhop-label">[I-D.shen-mpls-ldp-nnhop-label]</a></td>
<td class="author-text">Shen, N., &ldquo;<a href="http://www.ietf.org/internet-drafts/draft-shen-mpls-ldp-nnhop-label-02.txt">Discovering LDP Next-Nexthop Labels</a>,&rdquo; draft-shen-mpls-ldp-nnhop-label-02 (work in progress), May&nbsp;2005 (<a href="http://www.ietf.org/internet-drafts/draft-shen-mpls-ldp-nnhop-label-02.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="ISPF">[ISPF]</a></td>
<td class="author-text">McQuillan, J., Richer, I., and E. Rosen, &ldquo;ARPANET Routing Algorithm Improvements",&rdquo; BBN Technical Report&nbsp;3803, 1978.</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC1701">[RFC1701]</a></td>
<td class="author-text"><a href="mailto:stan@netsmiths.com">Hanks, S.</a>, <a href="mailto:tli@cisco.com">Li, T.</a>, <a href="mailto:dino@cisco.com">Farinacci, D.</a>, and <a href="mailto:pst@cisco.com">P. Traina</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc1701">Generic Routing Encapsulation (GRE)</a>,&rdquo; RFC&nbsp;1701, October&nbsp;1994 (<a href="http://www.rfc-editor.org/rfc/rfc1701.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC2003">[RFC2003]</a></td>
<td class="author-text"><a href="mailto:perk@watson.ibm.com">Perkins, C.</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc2003">IP Encapsulation within IP</a>,&rdquo; RFC&nbsp;2003, October&nbsp;1996 (<a href="http://www.rfc-editor.org/rfc/rfc2003.txt">TXT</a>, <a href="http://xml.resource.org/public/rfc/html/rfc2003.html">HTML</a>, <a href="http://xml.resource.org/public/rfc/xml/rfc2003.xml">XML</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC3931">[RFC3931]</a></td>
<td class="author-text">Lau, J., Townsley, M., and I. Goyret, &ldquo;<a href="http://tools.ietf.org/html/rfc3931">Layer Two Tunneling Protocol - Version 3 (L2TPv3)</a>,&rdquo; RFC&nbsp;3931, March&nbsp;2005 (<a href="http://www.rfc-editor.org/rfc/rfc3931.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC5036">[RFC5036]</a></td>
<td class="author-text">Andersson, L., Minei, I., and B. Thomas, &ldquo;<a href="http://tools.ietf.org/html/rfc5036">LDP Specification</a>,&rdquo; RFC&nbsp;5036, October&nbsp;2007 (<a href="http://www.rfc-editor.org/rfc/rfc5036.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC5286">[RFC5286]</a></td>
<td class="author-text">Atlas, A. and A. Zinin, &ldquo;<a href="http://tools.ietf.org/html/rfc5286">Basic Specification for IP Fast Reroute: Loop-Free Alternates</a>,&rdquo; RFC&nbsp;5286, September&nbsp;2008 (<a href="http://www.rfc-editor.org/rfc/rfc5286.txt">TXT</a>).</td></tr>
</table>

<a name="rfc.authors"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>Authors' Addresses</h3>
<table width="99%" border="0" cellpadding="0" cellspacing="0">
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Mike Shand</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Cisco Systems</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">250, Longwater Avenue.</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Reading, Berks  RG2 6GB</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">UK</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:mshand@cisco.com">mshand@cisco.com</a></td></tr>
<tr cellpadding="3"><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Stewart Bryant</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Cisco Systems</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">250, Longwater Avenue.</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Reading, Berks  RG2 6GB</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">UK</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:stbryant@cisco.com">stbryant@cisco.com</a></td></tr>
<tr cellpadding="3"><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Stefano Previdi</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Cisco Systems</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Via Del Serafico, 200</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">00142 Rome,   </td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Italy</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:sprevidi@cisco.com">sprevidi@cisco.com</a></td></tr>
</table>
<a name="rfc.copyright"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>Full Copyright Statement</h3>
<p class='copyright'>
Copyright &copy; The IETF Trust (2008).</p>
<p class='copyright'>
This document is subject to the rights,
licenses and restrictions contained in BCP&nbsp;78,
and except as set forth therein,
the authors retain all their rights.</p>
<p class='copyright'>
This document and the information contained herein are provided
on an &ldquo;AS IS&rdquo; basis and THE CONTRIBUTOR,
THE ORGANIZATION HE/SHE REPRESENTS
OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY, THE IETF TRUST
AND THE INTERNET ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT
THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY
IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR
PURPOSE.</p>
<h3>Intellectual Property</h3>
<p class='copyright'>
The IETF takes no position regarding the validity or scope of any
Intellectual Property Rights or other rights that might be claimed
to pertain to the implementation or use of the technology
described in this document or the extent to which any license
under such rights might or might not be available; nor does it
represent that it has made any independent effort to identify any
such rights.
Information on the procedures with respect to
rights in RFC documents can be found in BCP&nbsp;78 and BCP&nbsp;79.</p>
<p class='copyright'>
Copies of IPR disclosures made to the IETF Secretariat and any
assurances of licenses to be made available,
or the result of an attempt made to obtain a general license or
permission for the use of such proprietary rights by implementers or
users of this specification can be obtained from the IETF on-line IPR
repository at <a href='http://www.ietf.org/ipr'>http://www.ietf.org/ipr</a>.</p>
<p class='copyright'>
The IETF invites any interested party to bring to its attention
any copyrights,
patents or patent applications,
or other
proprietary rights that may cover technology that may be required
to implement this standard.
Please address the information to the IETF at <a href='mailto:ietf-ipr@ietf.org'>ietf-ipr@ietf.org</a>.</p>
</body></html>
