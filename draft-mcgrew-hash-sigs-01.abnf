X = 128*b0 + 64*b1 + 32*b2 + 16*b3 + 8*b4 + 4*b5 + 2*b6 + b7
X = 64*d0 + 16*d1 + 4*d2 + d3
X = 16*q0 + q1
e = 2^w - 1
sum = 0
sum = sum + (2^w - 1) - coef(S, i, w)
V = ( H(message) || C(H(message)) )
a = coef(V, i, w)
V = ( H(message) || C(H(message)) )
a = (2^w - 1) - coef(V, i, w)
ldwm_reserved = 0,
ldwm_sha256_m20_w1  = 1,
ldwm_sha256_m20_w2  = 2,
ldwm_sha256_m20_w4  = 3,
ldwm_sha256_m20_w8  = 4
level = 0
v = leaf
step = 0
position = n % k
v = hash_final()
n = floor(n/k)
step = step + (k-1)
mts_reserved      = 0,
mts_sha256_k2_h20 = 1,
mts_sha256_k4_h10 = 2,
mts_sha256_k8_h7  = 3,
mts_sha256_k16_h5 = 4
c = C(H(message)) (see Section 3.7).  To attempt a forgery, an
a = coef(h, j, w), and

b = coef(c, k, w), and

u = ceil(8*n/w)
v = ceil(floor(lg(u)) / w) + 1
p = u + v
ls = (number of bits in sum) - (v * w)

