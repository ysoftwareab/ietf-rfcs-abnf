<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="en"><head><title>IKEv2 Mediation Extension</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="description" content="IKEv2 Mediation Extension">
<meta name="generator" content="xml2rfc v1.35 (http://xml.resource.org/)">
<meta name="viewport" content="width=600;" />
<style type='text/css'><!--
        body {
                font-family: verdana, charcoal, helvetica, arial, sans-serif;
                font-size: 85%;
		max-width: 40em; 
		color: #000; background-color: #FFF;
                margin: 2em;
        }
        h1, h2, h3, h4, h5, h6 {
                font-family: helvetica, monaco, "MS Sans Serif", arial, sans-serif;
                font-weight: bold; font-style: normal;
        }
        h1 { color: #900; background-color: transparent; text-align: right; }
        h3 { color: #333; background-color: transparent; }

        td.RFCbug {
                font-size: x-small; text-decoration: none;
                width: 30px; height: 30px; padding-top: 2px;
                text-align: justify; vertical-align: middle;
                background-color: #000;
        }
        td.RFCbug span.RFC {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: bold; color: #666;
        }
        td.RFCbug span.hotText {
                font-family: charcoal, monaco, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: normal; text-align: center; color: #FFF;
        }

        table.TOCbug { width: 30px; height: 15px; }
        td.TOCbug {
                text-align: center; width: 30px; height: 15px;
                color: #FFF; background-color: #900;
        }
        td.TOCbug a {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, sans-serif;
                font-weight: bold; font-size: x-small; text-decoration: none;
                color: #FFF; background-color: transparent;
        }

        td.header {
                font-family: arial, helvetica, sans-serif; font-size: x-small;
                vertical-align: top; width: 33%;
                color: #FFF; background-color: #666;
        }
        td.author { font-weight: bold; font-size: x-small; margin-left: 4em; }
        td.author-text { font-size: x-small; }

        /* info code from SantaKlauss at http://www.madaboutstyle.com/tooltip2.html */
        a.info {
                /* This is the key. */
                position: relative;
                z-index: 24;
                text-decoration: none;
        }
        a.info:hover {
                z-index: 25;
                color: #FFF; background-color: #900;
        }
        a.info span { display: none; }
        a.info:hover span.info {
                /* The span will display just on :hover state. */
                display: block;
                position: absolute;
                font-size: smaller;
                top: 2em; left: -5em; width: 15em;
                padding: 2px; border: 1px solid #333;
                color: #900; background-color: #EEE;
                text-align: left;
        }

        a { font-weight: bold; }
        a:link    { color: #900; background-color: transparent; }
        a:visited { color: #633; background-color: transparent; }
        a:active  { color: #633; background-color: transparent; }

        p { margin-left: 2em; margin-right: 2em; }
        p.copyright { font-size: x-small; }
        p.toc { font-size: 85%;
		max-width: 40em; 
		font-weight: bold; margin-left: 3em; }
        table.toc { margin: 0 0 0 3em; padding: 0; border: 0; vertical-align: text-top; }
        td.toc { font-size: 85%;
		max-width: 40em; 
		font-weight: bold; vertical-align: text-top; }

        ol.text { margin-left: 2em; margin-right: 2em; }
        ul.text { margin-left: 2em; margin-right: 2em; }
        li      { margin-left: 3em; }

        /* RFC-2629 <spanx>s and <artwork>s. */
        em     { font-style: italic; }
        strong { font-weight: bold; }
        dfn    { font-weight: bold; font-style: normal; }
        cite   { font-weight: normal; font-style: normal; }
        tt     { color: #036; }
        tt, pre, pre dfn, pre em, pre cite, pre span {
                font-family: "Courier New", Courier, monospace; font-size: small;
        }
        pre {
                text-align: left; padding: 4px;
                color: #000; background-color: #CCC;
        }
        pre dfn  { color: #900; }
        pre em   { color: #66F; background-color: #FFC; font-weight: normal; }
        pre .key { color: #33C; font-weight: bold; }
        pre .id  { color: #900; }
        pre .str { color: #000; background-color: #CFF; }
        pre .val { color: #066; }
        pre .rep { color: #909; }
        pre .oth { color: #000; background-color: #FCF; }
        pre .err { background-color: #FCC; }

        /* RFC-2629 <texttable>s. */
        table.all, table.full, table.headers, table.none {
                font-size: 85%;
		max-width: 40em; 
		text-align: center; border-width: 2px;
                vertical-align: top; border-collapse: collapse;
        }
        table.all, table.full { border-style: solid; border-color: black; }
        table.headers, table.none { border-style: none; }
        th {
                font-weight: bold; border-color: black;
                border-width: 2px 2px 3px 2px;
        }
        table.all th, table.full th { border-style: solid; }
        table.headers th { border-style: none none solid none; }
        table.none th { border-style: none; }
        table.all td {
                border-style: solid; border-color: #333;
                border-width: 1px 2px;
        }
        table.full td, table.headers td, table.none td { border-style: none; }

        hr { height: 1px; }
        hr.insert {
                width: 80%; border-style: none; border-width: 0;
                color: #CCC; background-color: #CCC;
        }
--></style>
</head>
<body>
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<table summary="layout" width="66%" border="0" cellpadding="0" cellspacing="0"><tr><td><table summary="layout" width="100%" border="0" cellpadding="2" cellspacing="1">
<tr><td class="header">Network Working Group</td><td class="header">T. Brunner</td></tr>
<tr><td class="header">Internet-Draft</td><td class="header">University of Applied Sciences,</td></tr>
<tr><td class="header">Intended status: Experimental</td><td class="header">Rapperswil</td></tr>
<tr><td class="header">Expires: October 18, 2008</td><td class="header">April 16, 2008</td></tr>
</table></td></tr></table>
<h1><br />IKEv2 Mediation Extension<br />draft-brunner-ikev2-mediation-00</h1>

<h3>Status of This Memo</h3>
<p>
By submitting this Internet-Draft,
each author represents that any applicable patent or other IPR claims of which
he or she is aware have been or will be disclosed,
and any of which he or she becomes aware will be disclosed,
in accordance with Section&nbsp;6 of BCP&nbsp;79.</p>
<p>
Internet-Drafts are working documents of the Internet Engineering
Task Force (IETF), its areas, and its working groups.
Note that other groups may also distribute working documents as
Internet-Drafts.</p>
<p>
Internet-Drafts are draft documents valid for a maximum of six months
and may be updated, replaced, or obsoleted by other documents at any time.
It is inappropriate to use Internet-Drafts as reference material or to cite
them other than as &ldquo;work in progress.&rdquo;</p>
<p>
The list of current Internet-Drafts can be accessed at
<a href='http://www.ietf.org/ietf/1id-abstracts.txt'>http://www.ietf.org/ietf/1id-abstracts.txt</a>.</p>
<p>
The list of Internet-Draft Shadow Directories can be accessed at
<a href='http://www.ietf.org/shadow.html'>http://www.ietf.org/shadow.html</a>.</p>
<p>
This Internet-Draft will expire on October 18, 2008.</p>

<h3>Abstract</h3>

<p>This document describes the IKEv2 Mediation Extension (IKE-ME), a
      connectivity extension to the Internet Key Exchange IKEv2.
      IKE-ME allows two peers, each behind one or more Network Address
      Translators (NATs) or firewalls to establish a direct and secure
      connection without the need to configure any of the intermediate
      network devices. To establish this direct connection, a process
      similar to Interactive  Connectivity Establishment (ICE) is used.
      
</p><a name="toc"></a><br /><hr />
<h3>Table of Contents</h3>
<p class="toc">
<a href="#anchor1">1.</a>&nbsp;
Introduction<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor2">1.1.</a>&nbsp;
Terminology and Notation<br />
<a href="#anchor3">2.</a>&nbsp;
Protocol Overview<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor4">2.1.</a>&nbsp;
Basic Operation<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor5">2.2.</a>&nbsp;
Example Protocol Exchanges<br />
<a href="#sec-mediation">3.</a>&nbsp;
Mediation Connection<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor6">3.1.</a>&nbsp;
Initial IKE Exchanges<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor7">3.2.</a>&nbsp;
CREATE_CHILD_SA Exchange<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec-obtaining">3.3.</a>&nbsp;
Obtaining Endpoints<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor8">3.3.1.</a>&nbsp;
Host Endpoints<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor9">3.3.2.</a>&nbsp;
Server Reflexive and Relayed Endpoints<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor10">3.3.2.1.</a>&nbsp;
Considerations Concerning TURN<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec-optainms">3.3.2.2.</a>&nbsp;
Obtaining Server Reflexive Endpoints from Mediation Servers<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor12">3.3.3.</a>&nbsp;
Peer Reflexive Endpoints<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor13">3.3.4.</a>&nbsp;
The Base of Local Endpoints<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor14">3.3.5.</a>&nbsp;
Prioritizing Endpoints<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec-formula">3.3.5.1.</a>&nbsp;
Recommended Formula<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec-guidelines">3.3.6.</a>&nbsp;
Guidelines for Choosing Type and IP Address Preferences<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor15">3.3.7.</a>&nbsp;
Eliminating Redundant Endpoints<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor16">3.4.</a>&nbsp;
Initiating a Connection<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec-me_connect">3.4.1.</a>&nbsp;
ME_CONNECT Exchange<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor17">3.4.2.</a>&nbsp;
Receiving a ME_CONNECT Request<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor18">3.4.3.</a>&nbsp;
Receiving a ME_CONNECT Response<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor19">3.4.4.</a>&nbsp;
Timeout for the Overall Transaction<br />
<a href="#sec-building-pairs">4.</a>&nbsp;
Building Endpoint Pairs<br />
<a href="#sec-conncheck">5.</a>&nbsp;
Connectivity Checks<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor20">5.1.</a>&nbsp;
Forming Connectivity Checks<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec-connectauth">5.1.1.</a>&nbsp;
ME_CONNECTAUTH<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor21">5.2.</a>&nbsp;
Responding to Connectivity Checks<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor22">5.3.</a>&nbsp;
Processing Connectivity Checks<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor23">5.3.1.</a>&nbsp;
Failure Cases<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor24">5.3.2.</a>&nbsp;
Success Cases<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor25">5.3.3.</a>&nbsp;
Stopping the Checks and Selecting the Endpoints<br />
<a href="#anchor26">6.</a>&nbsp;
Mediated Connection<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor27">6.1.</a>&nbsp;
Initiating the Mediated Connection<br />
<a href="#sec-payloads">7.</a>&nbsp;
Payload Formats<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec-idp">7.1.</a>&nbsp;
Identification Payload - Peer Identity<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor28">7.2.</a>&nbsp;
Notify Messages - Error Types<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor29">7.2.1.</a>&nbsp;
ME_CONNECT_FAILED Notify Payload<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor30">7.3.</a>&nbsp;
Notify Messages - Status Types<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor31">7.3.1.</a>&nbsp;
ME_MEDIATION Notify Payload<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor32">7.3.2.</a>&nbsp;
ME_ENDPOINT Notify Payloads<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor33">7.3.3.</a>&nbsp;
ME_CALLBACK Notify Payload<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor34">7.3.4.</a>&nbsp;
ME_CONNECTID Notify Payload<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor35">7.3.5.</a>&nbsp;
ME_CONNECTKEY Notify Payload<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor36">7.3.6.</a>&nbsp;
ME_CONNECTAUTH Notify Payload<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor37">7.3.7.</a>&nbsp;
ME_RESPONSE Notify Payload<br />
<a href="#sec-security">8.</a>&nbsp;
Security Considerations<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor38">8.1.</a>&nbsp;
Trusting the Mediation Servers<br />
<a href="#anchor39">9.</a>&nbsp;
IANA Considerations<br />
<a href="#sec-iab">10.</a>&nbsp;
IAB Considerations<br />
<a href="#anchor40">11.</a>&nbsp;
Acknowledgements<br />
<a href="#rfc.references1">12.</a>&nbsp;
References<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#rfc.references1">12.1.</a>&nbsp;
Normative References<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#rfc.references2">12.2.</a>&nbsp;
Informative References<br />
<a href="#anchor43">Appendix&nbsp;A.</a>&nbsp;
Open Issues<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor44">A.1.</a>&nbsp;
Is the second ME_CONNECTKEY required?<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor45">A.2.</a>&nbsp;
Different NAT, Same Subnet<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor46">A.3.</a>&nbsp;
Relaying Provided by the Mediation Server<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor47">A.4.</a>&nbsp;
Compatibility/Synergy with MOBIKE<br />
<a href="#anchor48">Appendix&nbsp;B.</a>&nbsp;
Design Decisions<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor49">B.1.</a>&nbsp;
Two exchanges between mediation server and second peer<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec-meresponse-req">B.2.</a>&nbsp;
Why the ME_RESPONSE Notify payload is needed<br />
<a href="#anchor50">Appendix&nbsp;C.</a>&nbsp;
Changelog<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor51">C.1.</a>&nbsp;
Changes from -.3 to -00<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor52">C.2.</a>&nbsp;
Changes from -.2 to -.3<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor53">C.3.</a>&nbsp;
Changes from -.1 to -.2<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor54">C.4.</a>&nbsp;
Changes from -.0 to -.1<br />
</p>
<br clear="all" />

<a name="anchor1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1"></a><h3>1.&nbsp;
Introduction</h3>

<p>IKEv2 <a class='info' href='#RFC4306'>[RFC4306]<span> (</span><span class='info'>Kaufman, C., &ldquo;Internet Key Exchange (IKEv2) Protocol,&rdquo; December&nbsp;2005.</span><span>)</span></a> inherently supports the traversal of
    Network Address Translators (NATs) by doing automatic NAT discovery
    during the IPsec connection setup. If a NAT situation is detected, IKE
    floats to UDP source and destination ports 4500 and after a CHILD_SA has
    been successfully established, ESP packets encapsulated in UDP
    datagrams <a class='info' href='#RFC3948'>[RFC3948]<span> (</span><span class='info'>Huttunen, A., Swander, B., Volpe, V., DiBurro, L., and M. Stenberg, &ldquo;UDP Encapsulation of IPsec ESP Packets,&rdquo; January&nbsp;2005.</span><span>)</span></a> will share the same floated ports.
    While both IPsec and IKEv2 are peer-to-peer protocols by their nature,
    NATs and firewalls often restrict these protocols to a unidirectional
    mode where only the peer on the inside is able to actively set up a
    connection. If both peers are hidden by NATs or firewalls, the IKEv2
    protocol usually fails to establish IPsec connectivity.
    
</p>
<p>In the area of multimedia communications  the Interactive Connectivity
    Establishment protocol <a class='info' href='#I-D.ietf-mmusic-ice'>[I&#8209;D.ietf&#8209;mmusic&#8209;ice]<span> (</span><span class='info'>Rosenberg, J., &ldquo;Interactive Connectivity Establishment (ICE): A Protocol for Network Address Translator (NAT) Traversal for Offer/Answer Protocols,&rdquo; October&nbsp;2007.</span><span>)</span></a> has been
    developed to solve the NAT and firewall problems mentioned above.
    Unfortunately the proposed solution is rather closely bound to the Session
    Initiation Protocol (SIP) and Session Description Protocol (SDP), and
    generally tends to solve problems specific to voice and/or video media
    streams.
    
</p>
<p>The IKEv2 Mediation Extension (IKE-ME) adapts the connectivity
    establishment methods known from ICE to the IPsec domain, allowing
    secure IP connections to be established in environments with multiple
    NATs or firewalls.
</p>
<p>The IKEv2 Mediation Extension protocol uses a mediation server to locate
    other peers and allows them to exchange their communication endpoints.
    It implements an ICE-like mechanism with a minimum impact on the standard
    IKEv2 protocol. IKEv2 exchanges are used for communication between peers and
    the mediation server to simplify implementation in existing IKEv2 products.
    
</p>
<a name="anchor2"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1.1"></a><h3>1.1.&nbsp;
Terminology and Notation</h3>

<p>The following terms are used throughout this document:
    </p>
<blockquote class="text">
<p>Peer
        </p>
<blockquote class="text">
<p>A peer is an IKEv2 host that supports the
          protocol defined in this document and wants to establish a direct
          connection with another peer.
</p>
</blockquote>

<p>Mediation Server
        </p>
<blockquote class="text">
<p>A server is an IKEv2 host that helps peers to
          establish a direct connection between them. The server has to be
          reachable by all peers involved in the mediation scheme.
          
</p>
</blockquote>

<p>Transport Address
        </p>
<blockquote class="text">
<p>A transport address is the combination of an IP
          address, a transport protocol (limited to UDP in this specification),
          and a port number.
</p>
</blockquote>

<p>Endpoint
        </p>
<blockquote class="text">
<p>An endpoint is a transport address that is
          obtained in order to be used in a direct connection. In addition to a
          plain transport address it has a type, a priority, and a base. The
          term endpoint may also be used to simply indicate the end of a
          connection. The actual meaning should be clear from the context.
          
</p>
</blockquote>

<p>Host Endpoint
        </p>
<blockquote class="text">
<p>An endpoint directly obtained from a local
          interface.
</p>
</blockquote>

<p>Server Reflexive Endpoint
        </p>
<blockquote class="text">
<p>Server reflexive endpoints are endpoints
          allocated on a NAT and are learned by a method such as Session
          Traversal Utilities for NAT (STUN).
</p>
</blockquote>

<p>Relayed Endpoint
        </p>
<blockquote class="text">
<p>Relayed endpoints are like remote host endpoints.
          Traversal Using Relays around NAT (TURN) is a possible source for
          relayed endpoints.
</p>
</blockquote>

<p>Peer Reflexive Endpoint
        </p>
<blockquote class="text">
<p>Peer reflexive endpoints are learned during
          connectivity checks. See <a class='info' href='#sec-conncheck'>Section&nbsp;5<span> (</span><span class='info'>Connectivity Checks</span><span>)</span></a> for how this
          is done.
</p>
</blockquote>

<p>Base
        </p>
<blockquote class="text">
<p>The base of an endpoint is the transport address
          from which messages are actually sent. For instance, a peer cannot
          send messages directly from a server reflexive endpoint which it got
          allocated on a NAT, but only from the host endpoint from which it
          obtained the server reflexive endpoint. See
          <a class='info' href='#sec-obtaining'>Section&nbsp;3.3<span> (</span><span class='info'>Obtaining Endpoints</span><span>)</span></a> for details.
</p>
</blockquote>

</blockquote>

<p>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
      "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
      document are to be interpreted as described in <a class='info' href='#RFC2119'>[RFC2119]<span> (</span><span class='info'>Bradner, S., &ldquo;Key words for use in RFCs to Indicate Requirement Levels,&rdquo; March&nbsp;1997.</span><span>)</span></a>.
      
</p>
<a name="anchor3"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2"></a><h3>2.&nbsp;
Protocol Overview</h3>

<a name="anchor4"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2.1"></a><h3>2.1.&nbsp;
Basic Operation</h3>

<p>In order to establish a direct connection between them, two peers need to
      connect to a mediation server first. The mediation server is required to
      forward the endpoints on which a peer is potentially reachable by another
      peer. <a class='info' href='#fig-situation'>Figure&nbsp;1<span> (</span><span class='info'>Overview</span><span>)</span></a> provides a general overview of the
      most common situation. Peer 1 and Peer 2 want to establish a secure direct
      connection between them. Since both are behind a NAT they cannot reach
      one another directly - they most likely don't even know where to try.
      This is where the mediation server comes into play. It helps to locate
      other peers and to exchange endpoints over which a peer may be reachable.

      <br /><hr class="insert" />
<a name="fig-situation"></a>
</p>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>

                          +-------------+
                          |  Mediation  |
                          |   Server    |
                          +--+-------+--+
                             |       |
        Mediation Connection |       | Mediation Connection
             +---------------+       +---------------+
             |                                       |
             + +-----------------------------------+ +
             |/         Mediated Connection         \|
       +-----+-----+                           +-----+-----+
       |   NAT 1   |                           |   NAT 2   |
       +-----+-----+                           +-----+-----+
             |                                       |
       +-----+-----+     Secure Connection     +-----------+
       |  Peer 1   |===========================|  Peer 2   |
       +-----------+                           +-----------+

</pre></div><p>
<table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;1: Overview&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

      
</p>
<p>Each peer registers itself with the mediation server in order to announce
      its online presence. It does so by setting up an IKE_SA including special
      mediation payloads. No CHILD_SA is established between a peer and the
      mediation server because there is no need to exchange any encrypted IP
      payloads.
</p>
<p>Before a peer can connect to other peers it has to collect a number of
      endpoints on which it is potentially reachable by other hosts. To obtain
      endpoints an arbitrary method can be used. For instance, STUN might be
      used to learn server reflexive endpoints and TURN could be used to obtain
      a relayed endpoint. A client may also request a server reflexive endpoint
      from the mediation server. By connecting to the mediation server, the peer
      automatically gets transport addresses allocated on the intermediate NATs.
      The transport address on the NAT nearest to the mediation server is the
      source from which the mediation server receives the messages from the
      peer. This transport address can be requested from the mediation server
      and provides a server reflexive endpoint.
</p>
<p>If a peer requests a connection to another peer that is already
      registered, the mediation server acts as a relay to allow the peers to
      exchange their endpoints.
      
</p>
<p>Each peer then performs connectivity checks on all available endpoint
      pairs constructed by combining its own with the received endpoints.
      
</p>
<p>After all path combinations have been probed and the best suited endpoint
      pair has been elected, the initiating peer then goes on to set up an
      IKE_SA using the standard IKEv2 protocol and including at least one
      request for a CHILD_SA.
      
</p>
<p>The protocol is designed to establish connectivity between peers in
      any network topology. As local endpoints are included in the checks, peers
      in the same (private) network can establish a connection directly.
      Depending on the NAT implementation, the used hole punching mechanism
      may not work. If both NAT are too restrictive, a relayed endpoint may
      be used to establish an IKE_SA between the peers.
      
</p>
<a name="anchor5"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2.2"></a><h3>2.2.&nbsp;
Example Protocol Exchanges</h3>

<p>This section illustrates some example protocol exchanges. The notation is
      based on <a class='info' href='#RFC4306'>[RFC4306]<span> (</span><span class='info'>Kaufman, C., &ldquo;Internet Key Exchange (IKEv2) Protocol,&rdquo; December&nbsp;2005.</span><span>)</span></a>, Section 1.2. In addition, the
      source/destination IP addresses and ports are shown for each packet: here
      IP_P1, IP_P2, and IP_MS represent IP addresses used by the two peers and
      the mediation server, respectively. Referring to
      <a class='info' href='#fig-situation'>Figure&nbsp;1<span> (</span><span class='info'>Overview</span><span>)</span></a>, the two peers are each located behind a
      NAT. Thus, the modifications on outgoing packets, as performed by the
      NATs, are also shown. At this, IP_N1 and IP_N2 denote the public addresses
      of the NATs.
</p>
<p>In a first step, Peer 1 connects to the mediation server starting with an
      IKE_SA_INIT exchange.
      </p>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>

       Initiator                          Responder
      -----------                        -----------

1) IP_P1:500 -&gt; IP_MS:500
    \--&gt; IP_N1:1201 -&gt; IP_MS:500
   HDR, SAi1, KEi, Ni,
        N(ME_MEDIATION),
        N(NAT_DETECTION_SOURCE_IP),
        N(NAT_DETECTION_DESTINATION_IP)   --&gt;

                                 IP_MS:500 -&gt; IP_N1:1201
                           &lt;--   HDR, SAr1, KEr, Nr,
                                      N(ME_MEDIATION),
                                      N(NAT_DETECTION_SOURCE_IP),
                                      N(NAT_DETECTION_DESTINATION_IP)
                                      [,CERTREQ]

</pre></div><p>

      The IKEv2 NAT_DETECTION_SOURCE_IP and NAT_DETECTION_DESTINATION_IP Notify
      payloads are used to detect if there is any NAT between the peer and the
      mediation server. The new ME_MEDIATION Notify payload announces the
      request for a mediation connection. As mentioned above, we assume that
      both peers are behind a NAT. Therefore Peer 1 floats to UDP port 4500
      before continuing with a modified IKE_AUTH exchange that does not contain
      a CHILD_SA proposal.
      </p>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>

2) IP_P1:4500 -&gt; IP_MS:4500
    \--&gt; IP_N1:1202 -&gt; IP_MS:4500
   HDR, SK { IDi, [CERT,] [CERTREQ,]
             [IDr,] AUTH, N(ME_ENDPOINT) }   --&gt;

                                 IP_MS:4500 -&gt; IP_N1:1202
                           &lt;--   HDR, SK { IDr, [CERT,] AUTH,
                                           N(ME_ENDPOINT) }

</pre></div><p>

      The peer uses the new ME_ENDPOINT Notify payload to request a server
      reflexive endpoint from the mediation server. After this exchange Peer 1
      is connected to the mediation server and thus available for mediation with
      any other peer, as well as eligible to request a mediated connection
      itself. Peer 2 connects to the mediation server using the same procedure.
      </p>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>

3) IP_P2:500 -&gt; IP_MS:500
    \--&gt; IP_N2:1024 -&gt; IP_MS:500
   HDR, SAi1, KEi, Ni,
        N(ME_MEDIATION),
        N(NAT_DETECTION_SOURCE_IP),
        N(NAT_DETECTION_DESTINATION_IP)   --&gt;

                                 IP_MS:500 -&gt; IP_N2:1024
                           &lt;--   HDR, SAr1, KEr, Nr,
                                      N(ME_MEDIATION),
                                      N(NAT_DETECTION_SOURCE_IP),
                                      N(NAT_DETECTION_DESTINATION_IP)
                                      [,CERTREQ]

4) IP_P2:4500 -&gt; IP_MS:4500
    \--&gt; IP_N2:1025 -&gt; IP_MS:4500
   HDR, SK { IDi, [CERT,] [CERTREQ,]
             [IDr,] AUTH, N(ME_ENDPOINT) }   --&gt;

                                 IP_MS:4500 -&gt; IP_N2:1025
                           &lt;--   HDR, SK { IDr, [CERT,] AUTH,
                                           N(ME_ENDPOINT) }

</pre></div><p>

      A direct connection is initiated by Peer 1 with the transmission of a
      ME_CONNECT request to the mediation server. Peers are identified by the
      ID with which they authenticate against the mediation server. So, this
      request includes the ID of the other peer, denoted IDp2, and several
      endpoints on which Peer 1 is potentially reachable by the other peer. Also
      included are a randomly generated ID and a randomly generated key that are
      mainly used for the ensuing connectivity checks.
      </p>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>

5) IP_P1:4500 -&gt; IP_MS:4500
    \--&gt; IP_N1:1202 -&gt; IP_MS:4500
   HDR, SK { IDp2, N(ME_CONNECTID), N(ME_CONNECTKEY),
             N(ME_ENDPOINT), N(ME_ENDPOINT) }   --&gt;

                                 IP_MS:4500 -&gt; IP_N1:1202
                            &lt;--  HDR, SK {}

</pre></div><p>

      The mediation server relays this ME_CONNECT request to the other peer,
      but replaces the IDp payload with the ID of Peer 1.
      </p>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>

   IP_MS:4500 -&gt; IP_N2:1025
   HDR, SK { IDp1, N(ME_CONNECTID), N(ME_CONNECTKEY),
             N(ME_ENDPOINT), N(ME_ENDPOINT) }   --&gt;

                                 IP_P2:4500 -&gt; IP_MS:4500
                                  \--&gt; IP_N2:1025 -&gt; IP_MS:4500
                           &lt;--   HDR, SK {}

</pre></div><p>

      Peer 2 answers with a ME_CONNECT exchange of its own, including the
      initiating peer's ID, the connect ID, as well as its own randomly
      generated key and obtained endpoints. To mark the exchange as a response
      a ME_RESPONSE Notify payload is included. The mediation server extracts
      this information and forwards it back to Peer 1, again, exchanging the IDp
      accordingly.
      </p>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>

6) IP_P2:4500 -&gt; IP_MS:4500
    \--&gt; IP_N2:1025 -&gt; IP_MS:4500
   HDR, SK { IDp1, N(ME_RESPONSE), N(ME_CONNECTID),
             N(ME_CONNECTKEY), N(ME_ENDPOINT),
             N(ME_ENDPOINT) }   --&gt;

                                IP_MS:4500 -&gt; IP_N2:1025
                          &lt;--   HDR, SK {}

   IP_MS:4500 -&gt; IP_N1:1202
   HDR, SK { IDp2, N(ME_RESPONSE), N(ME_CONNECTID),
             N(ME_CONNECTKEY), N(ME_ENDPOINT),
             N(ME_ENDPOINT) }   --&gt;

                                 IP_P1:4500 -&gt; IP_MS:4500
                                  \--&gt; IP_N1:1202 -&gt; IP_MS:4500
                           &lt;--   HDR, SK {}

</pre></div><p>

      Both peers now pair their own endpoints with those received from the other
      end and proceed with connectivity checks. Connectivity checks are done
      using unprotected INFORMATIONAL exchanges that include the connect ID, an
      ME_ENDPOINT payload, and a ME_CONNECTAUTH Notify payload, which contains a
      MAC to authenticate the sender of the check. In this example we assume
      that both NATs perform endpoint independent mapping and filtering.
      </p>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>

7) IP_P1:4500 -&gt; IP_P2:4500
   HDR, N(ME_CONNECTID), N(ME_ENDPOINT),
        N(ME_CONNECTAUTH) --&gt;      !!  NOT REACHABLE

   IP_P1:4500 -&gt; IP_N2:1025
   \--&gt; IP_N1:1202 -&gt; IP_N2:1025
   HDR, N(ME_CONNECTID), N(ME_ENDPOINT),
        N(ME_CONNECTAUTH) --&gt;

                                 IP_P2:4500 -&gt; IP_N1:1202
                                 \--&gt; IP_N2:1025 -&gt; IP_N1:1202
                           &lt;--   HDR

</pre></div><p>

      Peer 2 does the same in the opposite direction. If at least one
      connectivity check is successful, the initiating peer proceeds with a
      normal IKE_SA_INIT request using the endpoints from the successful check.
      
</p>
<a name="sec-mediation"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3"></a><h3>3.&nbsp;
Mediation Connection</h3>

<p>This section describes the protocol between peers and the mediation server.
    
</p>
<a name="anchor6"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.1"></a><h3>3.1.&nbsp;
Initial IKE Exchanges</h3>

<p>To establish a mediation connection with a mediation server an
      implementation MUST include a ME_MEDIATION notification in the
      IKE_SA_INIT exchange. The initiator MUST stop the initiation if the
      responder does not include a ME_MEDIATION notification in its response.
      
</p>
<p>The format of the ME_MEDIATION notification is described in
      <a class='info' href='#sec-payloads'>Section&nbsp;7<span> (</span><span class='info'>Payload Formats</span><span>)</span></a>.
</p>
<p>If the transport address used to communicate with the mediation server
      is also to be used as Host endpoint (see <a class='info' href='#sec-optainms'>Section&nbsp;3.3.2.2<span> (</span><span class='info'>Obtaining Server Reflexive Endpoints from Mediation Servers</span><span>)</span></a>),
      the peer MUST now float to port 4500 even if no NAT is detected between
      the peer and the mediation server. Because connectivity checks are sent
      with non-ESP marker in front of the IKE header it would be confusing for
      implementations to receive such packets on port 500.
</p>
<p>As no CHILD_SAs are established on mediation connections, the
      IKE_AUTH exchange differs from <a class='info' href='#RFC4306'>[RFC4306]<span> (</span><span class='info'>Kaufman, C., &ldquo;Internet Key Exchange (IKEv2) Protocol,&rdquo; December&nbsp;2005.</span><span>)</span></a>. The payloads
      SAi2 and TSi, and SAr2 and TSr MUST be omitted from request and response,
      respectively. If any of these payloads are found included in the request,
      an implementation MUST respond with a NO_ADDITIONAL_SAS notification
      without any other payloads, and then delete the IKE_SA. All other payloads
      of the IKE_AUTH exchange remain as defined in <a class='info' href='#RFC4306'>[RFC4306]<span> (</span><span class='info'>Kaufman, C., &ldquo;Internet Key Exchange (IKEv2) Protocol,&rdquo; December&nbsp;2005.</span><span>)</span></a>.
      
</p>
<p>A peer MUST NOT have more than one connection to a specific mediation
      server at the same time. Thus, a mediation server MUST delete an existing
      IKE_SA with a peer upon receipt of a valid IKE_AUTH request of the same
      peer.
</p>
<p>An implementation that supports MOBIKE <a class='info' href='#RFC4555'>[RFC4555]<span> (</span><span class='info'>Eronen, P., &ldquo;IKEv2 Mobility and Multihoming Protocol (MOBIKE),&rdquo; June&nbsp;2006.</span><span>)</span></a>
      SHALL include the MOBIKE_SUPPORTED notification in the IKE_AUTH exchange.
      
</p>
<p>Optionally, a peer MAY obtain a server reflexive endpoint from the
      mediation server, as described in <a class='info' href='#sec-optainms'>Section&nbsp;3.3.2.2<span> (</span><span class='info'>Obtaining Server Reflexive Endpoints from Mediation Servers</span><span>)</span></a>.
</p>
<a name="anchor7"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.2"></a><h3>3.2.&nbsp;
CREATE_CHILD_SA Exchange</h3>

<p>The absence of CHILD_SAs on mediation connections also affects the
      allowed usages of the CREATE_CHILD_SA exchange. Exchanges of this type
      SHALL only be used to rekey the IKE_SA. An implementation MUST respond to
      CREATE_CHILD_SA requests that demand the creation of a CHILD_SA with a
      NO_ADDITIONAL_SAS notification, without any other payloads.
      
</p>
<a name="sec-obtaining"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.3"></a><h3>3.3.&nbsp;
Obtaining Endpoints</h3>

<p>A peer obtains endpoints before requesting a mediated connection or
      before responding to such a request. There are four types of endpoints
      defined in this document - host, peer reflexive, server reflexive, and
      relayed endpoints. Since every peer decides on its own which endpoints
      it wants to share with other peers, the methods to obtain these endpoints
      can vary widely.
</p>
<a name="anchor8"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.3.1"></a><h3>3.3.1.&nbsp;
Host Endpoints</h3>

<p>Host endpoints are obtained by binding ports to an IP address on a
        peer's host. A peer could use the same endpoint it uses to communicate
        with the mediation server, but it could also use a different port. If a
        peer is multihomed, it SHOULD obtain endpoints for every available IP
        address.
</p>
<a name="anchor9"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.3.2"></a><h3>3.3.2.&nbsp;
Server Reflexive and Relayed Endpoints</h3>

<p>Server reflexive and relayed endpoints can be obtained from various
        sources. One possibility is to use STUN
        (<a class='info' href='#I-D.ietf-behave-rfc3489bis'>[I&#8209;D.ietf&#8209;behave&#8209;rfc3489bis]<span> (</span><span class='info'>Rosenberg, J., Mahy, R., Matthews, P., and D. Wing, &ldquo;Session Traversal Utilities for (NAT) (STUN),&rdquo; February&nbsp;2008.</span><span>)</span></a>) and its Binding Discovery
        and Relay Usages (<a class='info' href='#I-D.ietf-behave-turn'>[I&#8209;D.ietf&#8209;behave&#8209;turn]<span> (</span><span class='info'>Rosenberg, J., Mahy, R., and P. Matthews, &ldquo;Traversal Using Relays around NAT (TURN): Relay Extensions to Session  Traversal Utilities for NAT (STUN),&rdquo; February&nbsp;2008.</span><span>)</span></a>).
        This specification does not restrict implementations on the methods used
        to obtain such endpoints. But a peer SHOULD obtain server reflexive and
        MAY obtain relayed endpoints for each host endpoint, to increase the
        probability of a successful connection.
</p>
<p>Use of relays is expensive, and when using this protocol, relays will
        only be utilized when both peers are behind NATs that perform address
        and port dependent mapping. Consequently, some deployments might
        consider this use case marginal and decide not to use relays.
</p>
<a name="anchor10"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.3.2.1"></a><h3>3.3.2.1.&nbsp;
Considerations Concerning TURN</h3>

<p>An implementation that opts for STUN's Relay Usage
          (<a class='info' href='#I-D.ietf-behave-turn'>[I&#8209;D.ietf&#8209;behave&#8209;turn]<span> (</span><span class='info'>Rosenberg, J., Mahy, R., and P. Matthews, &ldquo;Traversal Using Relays around NAT (TURN): Relay Extensions to Session  Traversal Utilities for NAT (STUN),&rdquo; February&nbsp;2008.</span><span>)</span></a>) as source for relayed
          endpoints has to consider several implications that result from that
          decision. For instance, as long as no active destination is set for
          such an endpoint, any IKE or ESP traffic that will be transferred
          through that endpoint will be encapsulated in Data Indication
          messages. Aside from the overhead of this additional layer of
          encapsulation, this also means that the implementation has to be able
          to process such traffic. This may be significantly easier for IKE
          traffic, since IKE traffic is often processed in user space, whereas
          ESP traffic is usually handled in kernel space, where the introduction
          of an additional layer of encapsulation might be more difficult to
          implement. Therefore, it is RECOMMENDED that an owner of such a
          relayed endpoint sets an active destination as soon as it becomes
          apparent that the endpoint is being used to establish the mediated
          connection. Thus, it depends on the selected pair and the associated
          endpoints. If the initiator owns the relayed endpoint of the selected
          endpoint pair, it sets the active destination to the remote endpoint
          of that pair, just before sending the IKE_SA_INIT request to initiate
          the mediated connection. Because the responder does not know which
          pair finally gets selected by the initiator, it waits until it gets
          the IKE_SA_INIT request and just before sending the IKE_SA_INIT
          response sets the active destination to the endpoint provided in the
          REMOTE-ADDRESS attribute of the Data Indication message. In the
          extremely rare case of the selected pair consisting of two relayed
          endpoints, the procedure is the same, with both peers taking
          appropriate measures. This could happen, for instance, if both peers
          are behind a NAT and neither did provide server reflexive endpoints.
          
</p>
<a name="sec-optainms"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.3.2.2"></a><h3>3.3.2.2.&nbsp;
Obtaining Server Reflexive Endpoints from Mediation Servers</h3>

<p>A peer MAY obtain a server reflexive endpoint from the mediation
          server. To do so, it includes a ME_ENDPOINT Notify payload either in
          the IKE_AUTH request or at a later stage in a separate INFORMATIONAL
          exchange.
</p>
<p>The priority, family, and port fields of this payload are set to
          zero, the address field is zero length, and the type field is set to
          SERVER_REFLEXIVE. Upon receiving such a payload, the mediation server
          includes in its answer a ME_ENDPOINT notification of the same type
          filling in the family, address and port of the endpoint it received
          the request from.
</p>
<p>The mediation server MUST ignore the ME_ENDPOINT Notify payload if
          the type is not SERVER_REFLEXIVE <a class='info' href='#comment.anchor11'>[anchor11]<span> (</span><span class='info'>this allows later revisions of this specification to define a relay usage</span><span>)</span></a><a name='anchor11'></a>.
</p>
<p>If MOBIKE <a class='info' href='#RFC4555'>[RFC4555]<span> (</span><span class='info'>Eronen, P., &ldquo;IKEv2 Mobility and Multihoming Protocol (MOBIKE),&rdquo; June&nbsp;2006.</span><span>)</span></a> is in use on the mediation
          connection, detection of changes in NAT mappings SHOULD be activated
          (as specified in <a class='info' href='#RFC4555'>[RFC4555]<span> (</span><span class='info'>Eronen, P., &ldquo;IKEv2 Mobility and Multihoming Protocol (MOBIKE),&rdquo; June&nbsp;2006.</span><span>)</span></a>, Section 3.8). A peer that
          previously obtained a server reflexive endpoint from the mediation
          server SHOULD refresh that endpoint, whenever MOBIKE indicates that
          the NAT mapping has changed.
</p>
<a name="anchor12"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.3.3"></a><h3>3.3.3.&nbsp;
Peer Reflexive Endpoints</h3>

<p>Peer reflexive endpoints are different from the previous endpoint
        types. Endpoints of this type are never obtained before a connection
        attempt, but dynamically learned during the connectivity checks. The
        process of how and when these endpoints MAY be learned is explained in
        <a class='info' href='#sec-conncheck'>Section&nbsp;5<span> (</span><span class='info'>Connectivity Checks</span><span>)</span></a>.
</p>
<a name="anchor13"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.3.4"></a><h3>3.3.4.&nbsp;
The Base of Local Endpoints</h3>

<p>All local endpoints have a Base. This is the transport address used to
        send the actual messages for an endpoint. Since it is not possible to
        send messages directly from a server reflexive endpoint, the base of
        such an endpoint is the host endpoint from which the server reflexive
        endpoint was obtained. If the peer is not behind a NAT, the base of a
        server reflexive endpoint will equal that endpoint, which is then
        redundant and will be eliminated. The base of host endpoints is the
        endpoint itself. The same is true for relayed endpoints, since these are
        like remote host endpoints. Peer reflexive endpoints also have a base;
        it is the base of the local endpoint of the pair from whose connectivity
        check the peer reflexive endpoint was learned.
</p>
<a name="anchor14"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.3.5"></a><h3>3.3.5.&nbsp;
Prioritizing Endpoints</h3>

<p>Each obtained endpoint is assigned a unique priority that MUST be a
        positive integer between 0 and 2**32 - 1. A peer SHOULD compute this
        priority using the formula in <a class='info' href='#sec-formula'>Section&nbsp;3.3.5.1<span> (</span><span class='info'>Recommended Formula</span><span>)</span></a> and choose
        its parameters using the guidelines in <a class='info' href='#sec-guidelines'>Section&nbsp;3.3.6<span> (</span><span class='info'>Guidelines for Choosing Type and IP Address Preferences</span><span>)</span></a>.
        Using a different formula will most likely break the coordination in the
        connectivity checks, causing the protocol to take longer to converge.
        
</p>
<a name="sec-formula"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.3.5.1"></a><h3>3.3.5.1.&nbsp;
Recommended Formula</h3>

<p>The priority is based on a preference for each type of endpoint
          (host, peer reflexive, server reflexive and relayed) and a preference
          for each of a peer's local IP addresses, in case it is multihomed.
          These two preferences are combined to compute the priority for an
          endpoint using the following formula (which is derived from the
          formula defined in <a class='info' href='#I-D.ietf-mmusic-ice'>[I&#8209;D.ietf&#8209;mmusic&#8209;ice]<span> (</span><span class='info'>Rosenberg, J., &ldquo;Interactive Connectivity Establishment (ICE): A Protocol for Network Address Translator (NAT) Traversal for Offer/Answer Protocols,&rdquo; October&nbsp;2007.</span><span>)</span></a>,
          Section 4.1.2):
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>

   priority = (2**16)*(type preference) +
              IP address preference

</pre></div>
<p>The type preference MUST be an integer from 0 to 255 inclusive and
          represents the preference for the type of the endpoint. 255 is the
          highest preference, and 0 is the lowest. Setting the value to 0 means
          that endpoints of this type will only be used as a last resort. The
          type preference MUST be identical for all endpoints of the same type
          and MUST be different for endpoints of different types. The type
          preference for peer reflexive endpoints MUST be higher than that of
          server reflexive endpoints. This is because it is easier for an
          attacker to foist a bad server reflexive endpoint on a peer, than it
          is to do the same with peer reflexive endpoints.
</p>
<p>The IP address preference MUST be an integer from 0 to 65535
          inclusive. It represents a preference for the particular IP address
          from which the endpoint was obtained in case a peer is multihomed.
          65535 represents the highest preference and 0 the lowest. When there
          is only a single IP address, this value SHOULD be set to 65535. If a
          peer is dual-stacked the IP address preference SHOULD be equal to the
          precedence value for IP addresses as described in
          <a class='info' href='#RFC3484'>[RFC3484]<span> (</span><span class='info'>Draves, R., &ldquo;Default Address Selection for Internet Protocol version 6 (IPv6),&rdquo; February&nbsp;2003.</span><span>)</span></a>.
</p>
<a name="sec-guidelines"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.3.6"></a><h3>3.3.6.&nbsp;
Guidelines for Choosing Type and IP Address Preferences</h3>

<p>The RECOMMENDED values for the type preference are 255 for host
        endpoints, 128 for peer reflexive endpoints, 64 for server reflexive
        endpoints, and 0 for relayed endpoints.
</p>
<p>One criteria for the selection of the IP address preference values is
        IP address family. This protocol works with both IPv4 and IPv6. It also
        allows dual-stack hosts to prefer connections over IPv6, but to fall
        back to IPv4. Other criteria MAY be established as a matter of local
        optimization.
        
</p>
<a name="anchor15"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.3.7"></a><h3>3.3.7.&nbsp;
Eliminating Redundant Endpoints</h3>

<p>After obtaining the endpoints, the peer eliminates redundant ones. An
        endpoint is redundant if its transport address equals that of another
        endpoint and its base equals the base of that other endpoint. Two
        endpoints that share the same transport address but have different bases
        are not considered redundant. The peer SHOULD eliminate the redundant
        candidate with the lower priority.
</p>
<a name="anchor16"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.4"></a><h3>3.4.&nbsp;
Initiating a Connection</h3>

<p>To initiate a direct connection with another peer and to exchange
      endpoints, a new exchange type (ME_CONNECT) is defined. The communication
      between initiating peer and responding peer passes through the mediation
      server and therefore consists of multiple exchanges. Request and
      response between the peers are each composed of two distinct exchanges
      between the mediation server and the peers. This results in the following
      message flow:
      <br /><hr class="insert" />
<a name="fig-me_connect_flow"></a>
</p>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>

      Peer 1                Mediation Server                Peer 2
     --------              ------------------              --------
/     ME_CONNECT request -&gt;
Re-                   &lt;- ME_CONNECT response
quest                       ME_CONNECT request -&gt;
\                                           &lt;- ME_CONNECT response

/                                           &lt;- ME_CONNECT request
Re-                         ME_CONNECT response -&gt;
sponse                &lt;- ME_CONNECT request
\     ME_CONNECT response -&gt;

</pre></div><p>
<table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;2: ME_CONNECT Exchanges&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

      
</p>
<a name="sec-me_connect"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.4.1"></a><h3>3.4.1.&nbsp;
ME_CONNECT Exchange</h3>

<p>The first payload included in a ME_CONNECT request is an IDp payload
        containing the ID of the other peer. All other payloads are
        notifications.
</p>
<p>The first two notifications are ME_CONNECTID and ME_CONNECTKEY.
        ME_CONNECTID contains a randomly chosen value that is used to identify
        the current connection setup. This identifier is provided by the
        initiator and is sent back by the other peer in the reply in order to be
        able to distinguish concurrent ME_CONNECT exchanges initiated by both
        sides. Each peer also provides a randomly chosen key contained in a
        ME_CONNECTKEY Notify payload that is used to authenticate the
        connectivity checks.
</p>
<p>If the requested peer is currently not online, that is, not connected
        to the mediation server, the mediation server MUST include a
        ME_CONNECT_FAILED error notification in its response. To prevent an
        initiator from constantly having to poll the other peer's online status,
        it MAY include a ME_CALLBACK notification in its request. This
        instructs the mediation server to notify the initiator as soon as the
        requested peer gets online.
</p>
<p>To transmit the previously obtained endpoints, notification payloads of
        type ME_ENDPOINT are used. A ME_CONNECT request MUST include at
        least one such payload. Mediation servers MUST reply with a
        ME_CONNECT_FAILED if a request contains no endpoints.
</p>
<p><a class='info' href='#fig-me_connect-init'>Figure&nbsp;3<span> (</span><span class='info'>ME_CONNECT Exchange: Initiation</span><span>)</span></a> shows a schematic overview of the
      ME_CONNECT exchange that is used to initiate a connection.
      <a class='info' href='#fig-me_connect-failure'>Figure&nbsp;4<span> (</span><span class='info'>ME_CONNECT Exchange: Failure</span><span>)</span></a> shows the exchange used to
      indicate a failure.
      <br /><hr class="insert" />
<a name="fig-me_connect-init"></a>
</p>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>

      Initiator                                  Responder
     -----------                                -----------

     HDR, SK { IDp, [N(ME_RESPONSE)], N(ME_CONNECTID),
               N(ME_CONNECTKEY), [N(ME_CALLBACK)],
               N(ME_ENDPOINT)+ }   --&gt;

                     &lt;--   HDR, SK { [N(ME_CONNECT_FAILED)] }

</pre></div><p>
<table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;3: ME_CONNECT Exchange: Initiation&nbsp;</b></font><br /></td></tr></table><hr class="insert" />


      <br /><hr class="insert" />
<a name="fig-me_connect-failure"></a>
</p>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>

      Initiator                                  Responder
     -----------                                -----------

     HDR, SK { IDp, N(ME_CONNECT_FAILED) }   --&gt;

                                           &lt;--   HDR, SK {}

</pre></div><p>
<table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;4: ME_CONNECT Exchange: Failure&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

      
</p>
<p>On every ME_CONNECT request the mediation server checks whether the
        requested peer is connected to it. If this is the case, the mediation
        server forwards the data included in the request to the requested peer
        by initiating another ME_CONNECT exchange, thereby replacing the IDp
        payload with the ID of the initiator. If the requested peer is not
        available the mediation server responds immediately with a
        ME_CONNECT_FAILED notification. If the initiator included a
        ME_CALLBACK notification in its request, the mediation server registers
        the requested ID. Once the requested peer connects, the mediation
        server notifies all waiting peers by initiating a ME_CONNECT exchange
        containing the peer ID of the requested peer and a ME_CALLBACK Notify
        payload, as shown in <a class='info' href='#fig-me_connect-callback'>Figure&nbsp;5<span> (</span><span class='info'>ME_CONNECT Exchange: Callback</span><span>)</span></a>.
        Afterwards, the mediation server removes the ID from the list of
        requested peers.
      <br /><hr class="insert" />
<a name="fig-me_connect-callback"></a>
</p>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>

      Initiator                                  Responder
     -----------                                -----------

     HDR, SK { IDp, N(ME_CALLBACK) }   --&gt;

                                           &lt;--   HDR, SK {}

</pre></div><p>
<table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;5: ME_CONNECT Exchange: Callback&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

      
</p>
<a name="anchor17"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.4.2"></a><h3>3.4.2.&nbsp;
Receiving a ME_CONNECT Request</h3>

<p>Upon receipt of a ME_CONNECT request from the mediation server, a peer
        has to obtain endpoints itself. Actually the peer could have done that
        earlier, even before connecting to the mediation server, keeping the
        endpoints alive while waiting for incoming requests. The peer then
        assembles a ME_CONNECT request which contains its own endpoints, the ID
        of the other peer, and a randomly generated value for the ME_CONNECTKEY
        payload.
        It also includes the ME_CONNECTID payload from the request and
        a ME_RESPONSE Notify payload to mark this exchange as a response. This
        message is then sent to the mediation server which should confirm it
        with an empty response. If the response contains a ME_CONNECT_FAILED
        notification, the other peer is not connected to the mediation server
        anymore. In this case the peer stops handling the request, otherwise, it
        proceeds with connectivity checks, as described beginning with <a class='info' href='#sec-building-pairs'>Section&nbsp;4<span> (</span><span class='info'>Building Endpoint Pairs</span><span>)</span></a>.
</p>
<p>In case a peer is unable to handle the request for a mediated
        connection - this could be due to missing configuration, local policy or
        other failures - it immediately responds with a ME_CONNECT_FAILED in
        the response to the ME_CONNECT request it received from the mediation
        server. If it later faces a condition that prevents it from responding
        to the request, it SHOULD initiate a ME_CONNECT exchange containing
        only an IDp and a ME_CONNECT_FAILED Notify payload. This notification is
        then forwarded to the initiating peer to inform it of this situation.
        
</p>
<a name="anchor18"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.4.3"></a><h3>3.4.3.&nbsp;
Receiving a ME_CONNECT Response</h3>

<p>The initiator eventually gets a ME_CONNECT request from the mediation
        server containing the response from the other peer. It correlates the
        response with the previously sent request using the ID contained in the
        ME_CONNECTID payload. It extracts the endpoints and key provided by the
        responder and proceeds with connectivity checks, as described beginning
        with <a class='info' href='#sec-building-pairs'>Section&nbsp;4<span> (</span><span class='info'>Building Endpoint Pairs</span><span>)</span></a>.
</p>
<a name="anchor19"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.4.4"></a><h3>3.4.4.&nbsp;
Timeout for the Overall Transaction</h3>

<p>Since the whole transaction is split in four separate exchanges (see
        <a class='info' href='#fig-me_connect_flow'>Figure&nbsp;2<span> (</span><span class='info'>ME_CONNECT Exchanges</span><span>)</span></a>) a timeout for the overall
        transaction is required. This timeout allows the initiator to act
        appropriately in case any of the three exchanges, in which it is not
        actively involved, fails. The nature of appropriate means is not defined
        by this specification, a peer might just restart the process, cancel it
        and log a message, or might take more sophisticated measures (like
        contacting an alternative mediation server). The timer controlling this
        timeout SHOULD be started right after the initial ME_CONNECT exchange
        finished successfully.
</p>
<p>Since <a class='info' href='#RFC4306'>[RFC4306]<span> (</span><span class='info'>Kaufman, C., &ldquo;Internet Key Exchange (IKEv2) Protocol,&rdquo; December&nbsp;2005.</span><span>)</span></a> does not exactly specify how
        retransmissions for IKEv2 messages have to be effected and does not
        define the time frame within which dead peers have to be detected, it
        becomes impossible to specify an exact timeout value. Therefore this
        document only specifies that an overall timeout value MUST be
        configurable to allow it to be adapted to specific conditions. As a
        recommendation the timeout value SHOULD approximately amount to at
        least three times the maximum time it takes the initiating peer to
        conclude that the retransmission of an IKEv2 message has finally
        failed.
</p>
<a name="sec-building-pairs"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4"></a><h3>4.&nbsp;
Building Endpoint Pairs</h3>

<p>After receiving endpoints with a ME_CONNECT exchange, a peer builds a list
    of endpoint pairs. This is done by pairing each local endpoint with each
    remote endpoint (endpoints get only paired if they share the same IP address
    family). Then for each pair a priority is computed. The resulting list is
    then sorted in decreasing order of priorities. The formula used to compute
    this priority is as follows (it is basically the same formula as defined in
    <a class='info' href='#I-D.ietf-mmusic-ice'>[I&#8209;D.ietf&#8209;mmusic&#8209;ice]<span> (</span><span class='info'>Rosenberg, J., &ldquo;Interactive Connectivity Establishment (ICE): A Protocol for Network Address Translator (NAT) Traversal for Offer/Answer Protocols,&rdquo; October&nbsp;2007.</span><span>)</span></a>, Section 5.7.2):
    </p>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>

   priority = (2**32) * MIN(pI, pR) +
                    2 * MAX(pI, pR) + (pI &gt; pR ? 1 : 0)

</pre></div><p>

    where pI and pR denote the priorities of the initiator and the responder,
    respectively. MIN and MAX are functions that result in either the minimum
    or the maximum value of their parameters, respectively. The last term of the
    formula evaluates to 1 if pI is greater than pR or to 0 otherwise.
</p>
<p>A peer cannot send messages directly from a reflexive endpoint, but only
    from its base. Since a peer generated pairs with both host endpoints and
    server reflexive endpoints as local endpoints, it's likely that there are
    duplicate entries in the list of pairs. Therefore, the peer MUST prune the
    list. This is done by removing a pair if the base of its local endpoint and
    the remote endpoint are identical to those of a pair higher up on the list.
    
</p>
<p>After sorting and pruning the list, the pairs are numbered serially. This
    number serves as a message ID in connectivity checks. The result is a
    sequentially numbered, ordered list of endpoint pairs, called the checklist.
    
</p>
<p>Each pair in the checklist has a specific state assigned to it that
    changes during the connectivity checks. Initially all pairs are in state
    Waiting. The possible states are as follows:
    </p>
<blockquote class="text">
<p>Waiting: No check has been performed yet for this pair. As soon as it
        becomes the highest priority Waiting pair on the checklist, a check can
        be performed.
</p>
<p>In-Progress: A check has been sent for this pair, but the transaction
        is still in progress.
</p>
<p>Succeeded: A check for this pair produced a successful result.
</p>
<p>Failed: A check for this pair was done and it failed.
</p>
</blockquote><p>
    
</p>
<p>An implementation SHOULD limit the number of endpoints it accepts in a
    ME_CONNECT exchange as well as the number of pairs in a single checklist.
    This specification does not define what the limits are but the limits MUST
    be configurable, so that users can adjust the limits if a specific situation
    demands it. If more endpoints are received than the configured upper limit,
    the implementation SHOULD discard them according to their priority. The same
    procedure is RECOMMENDED for supernumerary pairs.
    
</p>
<a name="sec-conncheck"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5"></a><h3>5.&nbsp;
Connectivity Checks</h3>

<p>Connectivity checks are done using unprotected INFORMATIONAL exchanges.
    The peers process the checklist sequentially and send a request from the
    local endpoint to the remote endpoint of each pair. In addition to the
    checklist each peer maintains a FIFO queue, called the triggered check
    queue, which contains pairs for which checks are to be sent at the next
    available opportunity. A periodically firing timer T controls the generation
    of the checks. Whenever timer T fires, a peer first checks whether there
    are any elements in the triggered check queue. If so, it removes the first
    pair from it and initiates a connectivity check for that pair. Otherwise the
    peer sends a check for the topmost pair in the checklist which is in state
    Waiting. If no such pair exists the peer does nothing in this time slot.
    This process is illustrated in <a class='info' href='#fig-sender'>Figure&nbsp;6<span> (</span><span class='info'>Sending Connectivity Checks</span><span>)</span></a>. Once a check has
    been sent the state of the pair is set to In-Progress.

    <br /><hr class="insert" />
<a name="fig-sender"></a>
</p>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>

         +---------------------+      /---------------\
  /-----&gt;|        idle         |&lt;-----|   send check  |
  |      +---------------------+      \---------------/
  |                 | timer fires             ^
  |                 v                         |
  |     +----------------------+              |
  |     |triggered check queue:| ok           |
  |     |    get first item    |--------------+
  |     +----------------------+              |
  |                 | none                    |
  |                 v                         |
  |      +---------------------+              |
  | none |checklist: get first | ok           |
  \------|pair in state Waiting|--------------/
         +---------------------+

</pre></div><p>
<table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;6: Sending Connectivity Checks&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

    
</p>
<p>There is no RECOMMENDED setting for timer T specified in this document. But
    timer T MUST be configurable so that a user may change the setting to adjust
    to specific environments. There is a second timer called retransmission
    timer R which is started for each connectivity check request after it has
    been initially sent. Whenever timer R fires the request is retransmitted.
    This not done indefinitely, though. After a set number of retransmissions
    the connectivity check times out and the state of the pair is set to Failed.
    As with timer T, this specification does not restrict implementors on how to
    design these retransmissions. However, it is RECOMMENDED that a user may
    be able to configure how often and how long retransmissions are sent in
    order to improve the connectivity in specific situations.
</p>
<a name="anchor20"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.1"></a><h3>5.1.&nbsp;
Forming Connectivity Checks</h3>

<p>Specially crafted unprotected INFORMATIONAL exchanges act as connectivity
      checks. The INFORMATIONAL request is formed as follows. The SPI fields in
      the IKE header are set to zero. The message ID is set to the ID
      of the corresponding entry in the checklist. Three payloads follow the
      header. The first one is a ME_CONNECTID notification containing the value
      provided by the initiator that allows the recipient to locate the correct
      checklist. The next payload is a ME_ENDPOINT Notify payload that has all
      fields but the priority and the type set to zero. The priority field is
      set equal to the priority that would be assigned based on the formula in
      <a class='info' href='#sec-formula'>Section&nbsp;3.3.5.1<span> (</span><span class='info'>Recommended Formula</span><span>)</span></a> to a peer reflexive endpoint. Hence, the
      type field is set to PEER_REFLEXIVE. To authenticate the message a
      ME_CONNECTAUTH notification is built and added, containing an SHA-1 hash
      of several parts of the message and the value of the appropriate
      ME_CONNECTKEY (see <a class='info' href='#sec-connectauth'>Section&nbsp;5.1.1<span> (</span><span class='info'>ME_CONNECTAUTH</span><span>)</span></a> for details).
      Request and response of a connectivity check are always authenticated with
      the same key, that of the responder. Thus a connectivity check from peer
      L to peer R (and its response) is authenticated with the key provided
      by R. Likewise, a connectivity check from R to L (and its response) is
      authenticated with the key provided by L.
</p>
<p>To simplify things, the IKE messages used to do connectivity checks are
      always sent with a non-ESP marker in front of the IKE header, as defined
      in <a class='info' href='#RFC3948'>[RFC3948]<span> (</span><span class='info'>Huttunen, A., Swander, B., Volpe, V., DiBurro, L., and M. Stenberg, &ldquo;UDP Encapsulation of IPsec ESP Packets,&rdquo; January&nbsp;2005.</span><span>)</span></a>, even if the port numbers used are not 4500.
      
</p>
<p><a class='info' href='#fig-conncheck'>Figure&nbsp;7<span> (</span><span class='info'>Connectivity Checks</span><span>)</span></a> provides a schematic diagram of a
      connectivity check.
</p><br /><hr class="insert" />
<a name="fig-conncheck"></a>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>

        Initiator                                  Responder
       -----------                                -----------

       HDR, N(ME_CONNECTID), N(ME_ENDPOINT),
            N(ME_CONNECTAUTH)   --&gt;

                           &lt;--   HDR, N(ME_CONNECTID), N(ME_ENDPOINT)
                                      N(ME_CONNECTAUTH)

</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;7: Connectivity Checks&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<a name="sec-connectauth"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.1.1"></a><h3>5.1.1.&nbsp;
ME_CONNECTAUTH</h3>

<p>The formula used to compute the value of the ME_CONNECTAUTH Notify
        payload is:
      </p>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>

  auth = Hash(MID | ME_CONNECTID | ME_ENDPOINT | ME_CONNECTKEY)

</pre></div><p>

      where MID denotes the message ID in the IKE Header in network byte order
      and | indicates concatenation. Of each included Notify payload only the
      notification data is considered. The hash function used is SHA-1.
      
</p>
<a name="anchor21"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.2"></a><h3>5.2.&nbsp;
Responding to Connectivity Checks</h3>

<p>After receiving a connectivity check request, a peer uses the value of
      the ME_CONNECTID payload to locate the correct checklist and the
      appropriate key. It verifies that the message is genuine, by computing the
      hash as the sender did and comparing the result with the content of the
      ME_CONNECTAUTH Notify payload. If either the checklist is not found or the
      verification fails, the peer MUST ignore the connectivity check request.
      Otherwise, it proceeds as follows. Refer to <a class='info' href='#fig-responder'>Figure&nbsp;8<span> (</span><span class='info'>Responding to Connectivity Checks</span><span>)</span></a>
      for an illustration of this process.

      </p>
<ol class="text">
<li>It checks whether the source address and port of the message are
          already included in the list of remote endpoints. If this is not the
          case, this represents a new peer reflexive endpoint. The priority
          of this endpoint is set to the priority noted in the ME_ENDPOINT
          payload of the request and it is then added to the list of remote
          endpoints.
</li>
<li>A new pair is constructed setting the local endpoint to the one on
          which the request was received, and the remote endpoint to the one
          where the request came from (this may be the peer reflexive endpoint
          just learned). The priority of this pair is computed as usual.
</li>
<li>If this pair is already in the checklist, further processing depends
          on the state of that pair.
          
<ul class="text">
<li>If the pair is in waiting state, a check for it is enqueued into
              the triggered check queue.
</li>
<li>If the state is In-Progress, retransmissions for the pending
              request will be cancelled, but the peer will wait the duration of
              the retransmission timeout for a response. If there is no answer
              the peer MUST schedule a new connectivity check for that pair, by
              enqueuing a check in the triggered check queue. The state of the
              pair is then changed to Waiting.
</li>
<li>If the state of the pair is Failed, it is changed to Waiting and
              the peer MUST enqueue a new connectivity check for that pair in
              the triggered check queue.
</li>
<li>If the state is already Succeeded, nothing is done.
</li>
</ul>
          If the pair had not yet been included in the checklist, it is now
          inserted based on its priority. The ID is set to the number of pairs
          in the checklist plus one. The state is set to Waiting and a
          connectivity check is enqueued in the triggered check queue.
</li>
<li>A response is then sent back. It includes the same ME_CONNECTID as
          the request, the ME_ENDPOINT is filled with the source endpoint from
          which the request was received - for relayed endpoints that are
          obtained using STUN, the source address is included in the
          REMOTE-ADDRESS attribute, if it was encapsulated in a Data Indication
          message, or it is the current active destination for the STUN relay
          session, otherwise - and the ME_CONNECTAUTH is built as in the
          request, using the appropriate key.
</li>
</ol><p>

      <br /><hr class="insert" />
<a name="fig-responder"></a>
</p>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>

                        +-------------------+
                        | request received  |
                        |   and verified    |
                        +-------------------+
                                  |
                                  v
  +---------------+     +-------------------+
  |    add to     |  no | source in list of |
  |remote endoints|&lt;----| remote endpoints? |
  +---------------+     +-------------------+
          |                       | yes
          |                       v
          |              +------------------+
          \-------------&gt;| create pair and  |
                         | compute priority |
                         +------------------+
                                  |
                                  v
  +---------------+      +------------------+
  |  add pair to  |   no | pair is already  |
  |   checklist   |&lt;-----|  in checklist?   |
  +---------------+      +------------------+
          |                       | yes
          |                       v
          |      Waiting /------------------\ Succeeded
          +--------------|    pair state    |--------------\
          |              \------------------/              |
          |                /              \                |
          |        Failed |                | In-Progress   |
          |               v                v               |
          |     +------------+          +------------+     |
          |     |change state|   failed |  wait for  | ok  |
          +-----| to Waiting |&lt;---------|  response  |-----+
          |     +------------+          +------------+     |
          v                                                |
  +---------------+                                        |
  |queue triggered|                                        |
  |     check     |                                        |
  +---------------+                                        |
          |              +------------------+              |
          \-------------&gt;|  send response   |&lt;-------------/
                         +------------------+

</pre></div><p>
<table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;8: Responding to Connectivity Checks&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

      
</p>
<a name="anchor22"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.3"></a><h3>5.3.&nbsp;
Processing Connectivity Checks</h3>

<p>This section describes how responses to connectivity checks are
      processed. On receipt of a connectivity check response a peer correlates
      it to the corresponding pair using, first, the ME_CONNECTID to find the
      correct checklist and then the message ID to identify the pair. It MUST
      verify the authenticity of the check using the key provided by the other
      peer.
</p>
<a name="anchor23"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.3.1"></a><h3>5.3.1.&nbsp;
Failure Cases</h3>

<p>If the peer either cannot find the checklist or cannot find the
        corresponding pair or if the verification of the check fails, it MUST
        ignore the check response.
</p>
<p>Implementations MAY support receipt of ICMP errors for connectivity
        checks. If a connectivity check generates an ICMP error, a peer sets the
        state of the corresponding pair to Failed.
</p>
<p>If a connectivity check times out, the peer also sets the state of the
        corresponding pair to Failed.
</p>
<p>The peer MUST check that the source address and port of the response
        equals the remote endpoint of the pair, and the destination address and
        port of the response equals the base of the local endpoint of the pair.
        If either of these comparisons fails the state of the pair is set to
        Failed.
</p>
<a name="anchor24"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.3.2"></a><h3>5.3.2.&nbsp;
Success Cases</h3>

<p>A connectivity check is considered a success, if the following are
        true:
        </p>
<ul class="text">
<li>The source address and port of the response equal the remote
            endpoint of the pair.
</li>
<li>The destination address and port of the response match the base of
            the local endpoint of the pair.
</li>
</ul>

<p>After verifying that the check is successful, the peer checks the
        mapped endpoint that is returned in the ME_ENDPOINT Notify payload. If
        the endpoint does not match any of the local endpoints that the peer
        knows about, the mapped endpoint represents a new peer reflexive
        endpoint. The base of this endpoint is set equal to the base of the
        local endpoint of the pair the check was sent for. The priority is set
        equal to the value noted in the payload. This endpoint is then added to
        the list of local endpoints and a new pair is built as follows.
</p>
<p>A new pair is constructed whose local endpoint equals the endpoint from
        the ME_ENDPOINT Notify payload as described in the preceding paragraph,
        and whose remote endpoint equals the destination address to which the
        request was sent. This pair is inserted into a second list called valid
        list, since it has been validated by a connectivity check. The valid
        pair may equal the pair that generated the check, may equal a different
        pair in the checklist, or may be a pair not currently in the checklist.
        
</p>
<p>If the pair is not on the checklist, the priority is computed as usual.
        If the local endpoint is peer reflexive, its priority is equal to the
        priority field of the ME_ENDPOINT payload. The priority of the remote
        endpoint is looked up in the list of remote endpoints.
</p>
<p>The state of the pair that generated the check is then set to
        Succeeded.
</p>
<a name="anchor25"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.3.3"></a><h3>5.3.3.&nbsp;
Stopping the Checks and Selecting the Endpoints</h3>

<p>Once one or more connectivity checks have completed successfully, valid
        pairs are generated and added to the valid list. The initiating peer
        lets the checks continue until some stopping criteria is met and then
        selects one pair from the valid list based on an evaluation criteria.
        The criteria for stopping the checks and for evaluating the valid pairs
        is entirely a matter of local optimization.
</p>
<p>The responding peer does not stop the checks for a checklist until it
        receives an IKE_SA_INIT request that includes a ME_CONNECTID Notify
        payload containing the respective connect ID.
</p>
<a name="anchor26"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6"></a><h3>6.&nbsp;
Mediated Connection</h3>

<a name="anchor27"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.1"></a><h3>6.1.&nbsp;
Initiating the Mediated Connection</h3>

<p>After the initiating peer has selected a valid pair, it uses these
      endpoints to initiate an IKE_SA_INIT exchange with the other peer. Like
      the connectivity checks, the IKE traffic on mediated connections is sent
      with the non-ESP Marker prepended to the IKE header, as defined in
      <a class='info' href='#RFC3948'>[RFC3948]<span> (</span><span class='info'>Huttunen, A., Swander, B., Volpe, V., DiBurro, L., and M. Stenberg, &ldquo;UDP Encapsulation of IPsec ESP Packets,&rdquo; January&nbsp;2005.</span><span>)</span></a>. Whether UDP encapsulation of ESP traffic is
      enabled on the mediated connection, is decided as usual, using NAT
      detection as defined in <a class='info' href='#RFC4306'>[RFC4306]<span> (</span><span class='info'>Kaufman, C., &ldquo;Internet Key Exchange (IKEv2) Protocol,&rdquo; December&nbsp;2005.</span><span>)</span></a>, Section 2.23.
</p>
<p>In addition to all the default payloads in the IKE_SA_INIT exchange the
      initiating peer also includes a ME_CONNECTID Notify payload containing the
      appropriate connect ID.
</p>
<a name="sec-payloads"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7"></a><h3>7.&nbsp;
Payload Formats</h3>

<a name="sec-idp"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.1"></a><h3>7.1.&nbsp;
Identification Payload - Peer Identity</h3>

<p>This payload, denoted IDp in this document, is used to exchange the
      identities of mediated peers. It is identical to the Identification
      Payloads defined in <a class='info' href='#RFC4306'>[RFC4306]<span> (</span><span class='info'>Kaufman, C., &ldquo;Internet Key Exchange (IKEv2) Protocol,&rdquo; December&nbsp;2005.</span><span>)</span></a>, Section 3.5.
</p>
<p>The payload type for this Identification Payload (IDp) is
      TBD_BY_IANA.
</p>
<a name="anchor28"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.2"></a><h3>7.2.&nbsp;
Notify Messages - Error Types</h3>

<a name="anchor29"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.2.1"></a><h3>7.2.1.&nbsp;
ME_CONNECT_FAILED Notify Payload</h3>

<p>This notification is used to signal that the attempt to mediate
        a connection with a peer has failed. It is used in the ME_CONNECT
        exchange request or response.
</p>
<p>The Notify Message Type for ME_CONNECT_FAILED is TBD-BY-IANA.
        The Protocol ID and SPI Size fields are set to zero. There is no data
        associated with this Notify type.
</p>
<a name="anchor30"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.3"></a><h3>7.3.&nbsp;
Notify Messages - Status Types</h3>

<a name="anchor31"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.3.1"></a><h3>7.3.1.&nbsp;
ME_MEDIATION Notify Payload</h3>

<p>This notification is included in the IKE_SA_INIT exchange of a
        mediation connection to indicate that both parties support this
        specification and want to establish a mediation connection.
</p>
<p>The Notify Message Type for ME_MEDIATION is TBD-BY-IANA. The Protocol
        ID and SPI Size fields are set to zero. The notification data field MUST
        be left empty (zero-length) when sending, and its contents (if any) MUST
        be ignored when this notification is received. This allows the field to
        be used by future versions of this protocol.
</p>
<a name="anchor32"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.3.2"></a><h3>7.3.2.&nbsp;
ME_ENDPOINT Notify Payloads</h3>

<p>This notification is used to exchange endpoints.
        
</p>
<p>The Notify Message Type for ME_ENDPOINT is TBD-BY-IANA. The Protocol
        ID and SPI Size fields are set to zero. The data associated with these
        Notify types starts with a four-octet long number denoting the
        endpoint's priority, followed by the eight bit long address family, and
        an eight bit long number indicating the type of the endpoint. The data
        further consists of a two-octet port number, which is finally followed
        by either a four-octet IPv4 address or a 16-octet IPv6 address.
        
</p>
<p>The following figure illustrates the format of the notification
        data of the ME_ENDPOINT payload:
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>

                       1                   2                   3
   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  !                           priority                            !
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  !    family     !     type      !              port             !
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  !                       IP address (variable)
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

</pre></div>
<p>The address family can take on the following values:
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>

   Name                              Value
   ------------------------------    -----
   RESERVED                          0
   IPv4                              1
   IPv6                              2

</pre></div>
<p>The following endpoint types are defined:
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>

   Name                              Value
   ------------------------------    -----
   RESERVED                          0
   HOST                              1
   PEER_REFLEXIVE                    2
   SERVER_REFLEXIVE                  3
   RELAYED                           4

</pre></div>
<p>This payload is also used to request endpoints from a mediation server
        and in connectivity checks. Refer to <a class='info' href='#sec-obtaining'>Section&nbsp;3.3<span> (</span><span class='info'>Obtaining Endpoints</span><span>)</span></a> and
        <a class='info' href='#sec-conncheck'>Section&nbsp;5<span> (</span><span class='info'>Connectivity Checks</span><span>)</span></a> for details.
</p>
<a name="anchor33"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.3.3"></a><h3>7.3.3.&nbsp;
ME_CALLBACK Notify Payload</h3>

<p>This notification allows a peer to instruct the mediation server to
        send out a notification once a specific peer connects to it, if it was
        not available when the peer initially sent the ME_CONNECT. The
        mediation server also includes a Notify payload of this type in the
        requested callback.
        
</p>
<p>The Notify Message Type for ME_CONNECTID is TBD-BY-IANA. The Protocol
        ID and SPI Size fields are set to zero. There is no data associated with
        this Notify type.
</p>
<a name="anchor34"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.3.4"></a><h3>7.3.4.&nbsp;
ME_CONNECTID Notify Payload</h3>

<p>This notification is used to exchange an identification number that
        uniquely identifies a direct connection attempt. The initiator provides
        this identifier in the ME_CONNECT exchange. It is then later used in the
        connectivity checks as well as in the IKE_SA_INIT request of the
        mediated connection. The randomly generated identifier MUST have a
        length of 4 to 16 octets.
</p>
<p>The Notify Message Type for ME_CONNECTID is TBD-BY-IANA. The Protocol
        ID and SPI Size fields are set to zero. The data associated with this
        Notify type consists of random data of variable length.
</p>
<a name="anchor35"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.3.5"></a><h3>7.3.5.&nbsp;
ME_CONNECTKEY Notify Payload</h3>

<p>This notification contains a symmetric key used in the MAC that
        authenticates the connectivity checks. The randomly generated key MUST
        be at least 16 octets long, but MAY have a length of up to 32 octets.
        
</p>
<p>The Notify Message Type for ME_CONNECTKEY is TBD-BY-IANA. The Protocol
        ID and SPI Size fields are set to zero. The data associated with this
        Notify type consists of random data of variable length.
</p>
<a name="anchor36"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.3.6"></a><h3>7.3.6.&nbsp;
ME_CONNECTAUTH Notify Payload</h3>

<p>This notification contains the message authentication code (MAC) in a
        connectivity check.
</p>
<p>The Notify Message Type for ME_CONNECTAUTH is TBD-BY-IANA. The Protocol
        ID and SPI Size fields are set to zero. The data associated with this
        Notify type consists of a 20-octet SHA-1 digest.
</p>
<a name="anchor37"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.3.7"></a><h3>7.3.7.&nbsp;
ME_RESPONSE Notify Payload</h3>

<p>This notification is used in ME_CONNECT exchanges to mark an exchange
        as a response. Since ME_CONNECT exchanges usually contain the same
        payloads, this Notify payload is required to distinguish between
        exchanges that serve as requests and exchanges that serve as responses.
        This is particularly important in the case of two peers trying to
        initiate a connection to each other at the same time.
        
</p>
<p>The Notify Message Type for ME_RESPONSE is TBD-BY-IANA. The Protocol
        ID and SPI Size fields are set to zero. There is no data associated with
        this Notify type.
</p>
<a name="sec-security"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.8"></a><h3>8.&nbsp;
Security Considerations</h3>

<a name="anchor38"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.8.1"></a><h3>8.1.&nbsp;
Trusting the Mediation Servers</h3>

<p>The peers must at least partially trust the mediation servers they
      use. Because the information that is passed to other peers is not
      encrypted in an end-to-end fashion the mediation server can observe all
      the exchanged endpoints. This could lead to the unwanted disclosure of
      private IP addresses and address ranges. Of course each peer can
      decide which endpoints it wants to share with other peers and hence with
      the mediation server.
      
</p>
<a name="anchor39"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.9"></a><h3>9.&nbsp;
IANA Considerations</h3>

<p>This document does not create any new namespaces to be maintained by IANA,
    but it requires new values in namespaces that have been defined in the IKEv2
    base specification <a class='info' href='#RFC4306'>[RFC4306]<span> (</span><span class='info'>Kaufman, C., &ldquo;Internet Key Exchange (IKEv2) Protocol,&rdquo; December&nbsp;2005.</span><span>)</span></a>.
</p>
<p>This document defines a new IKEv2 exchange whose value is to be allocated
    from the "IKEv2 Exchange Types" namespace:
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>

   Exchange Type                     Value
   ------------------------------    -----
   ME_CONNECT                        TBD-BY-IANA (38..239)

</pre></div>
<p>These exchange is described in <a class='info' href='#sec-me_connect'>Section&nbsp;3.4.1<span> (</span><span class='info'>ME_CONNECT Exchange</span><span>)</span></a>.
</p>
<p>This document defines one new IKEv2 payload whose value is to be allocated
    from the "IKEv2 Payload Types" namespace:
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>

   Payload Type                      Notation   Value
   ------------------------------    --------   -----
   Identification - Peer             IDp        TBD-BY-IANA (49..127)

</pre></div>
<p>This payload is described in <a class='info' href='#sec-payloads'>Section&nbsp;7<span> (</span><span class='info'>Payload Formats</span><span>)</span></a>.
</p>
<p>This document defines several new IKEv2 notifications whose values are to
    be allocated from the "IKEv2 Notify Message Types" namespace:
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>

   Notify Messages - Error Types     Value
   ------------------------------    -----
   ME_CONNECT_FAILED                 TBD-BY-IANA (42..8191)

   Notify Messages - Status Types    Value
   ------------------------------    -----
   ME_MEDIATION                      TBD-BY-IANA (16406..40959)
   ME_ENDPOINT                       TBD-BY-IANA (16406..40959)
   ME_CALLBACK                       TBD-BY-IANA (16406..40959)
   ME_CONNECTID                      TBD-BY-IANA (16406..40959)
   ME_CONNECTKEY                     TBD-BY-IANA (16406..40959)
   ME_CONNECTAUTH                    TBD-BY-IANA (16406..40959)
   ME_RESPONSE                       TBD-BY-IANA (16406..40959)

</pre></div>
<p>These notification payloads are described in
    <a class='info' href='#sec-payloads'>Section&nbsp;7<span> (</span><span class='info'>Payload Formats</span><span>)</span></a>.
</p>
<a name="sec-iab"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.10"></a><h3>10.&nbsp;
IAB Considerations</h3>

<p>TODO?
</p>
<a name="anchor40"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.11"></a><h3>11.&nbsp;
Acknowledgements</h3>

<p>The author would like to thank Martin Willi for his work on the
    introductory sections, and both him and Andreas Steffen for their comments
    and suggestions. A special thanks goes to Daniel Roethlisberger who worked
    with the author on an early revision of this specification.
</p>
<a name="rfc.references"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.12"></a><h3>12.&nbsp;
References</h3>

<a name="rfc.references1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>12.1.&nbsp;Normative References</h3>
<table width="99%" border="0">
<tr><td class="author-text" valign="top"><a name="RFC2119">[RFC2119]</a></td>
<td class="author-text"><a href="mailto:sob@harvard.edu">Bradner, S.</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>,&rdquo; BCP&nbsp;14, RFC&nbsp;2119, March&nbsp;1997 (<a href="http://www.rfc-editor.org/rfc/rfc2119.txt">TXT</a>, <a href="http://xml.resource.org/public/rfc/html/rfc2119.html">HTML</a>, <a href="http://xml.resource.org/public/rfc/xml/rfc2119.xml">XML</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC3948">[RFC3948]</a></td>
<td class="author-text">Huttunen, A., Swander, B., Volpe, V., DiBurro, L., and M. Stenberg, &ldquo;<a href="http://tools.ietf.org/html/rfc3948">UDP Encapsulation of IPsec ESP Packets</a>,&rdquo; RFC&nbsp;3948, January&nbsp;2005 (<a href="http://www.rfc-editor.org/rfc/rfc3948.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4306">[RFC4306]</a></td>
<td class="author-text">Kaufman, C., &ldquo;<a href="http://tools.ietf.org/html/rfc4306">Internet Key Exchange (IKEv2) Protocol</a>,&rdquo; RFC&nbsp;4306, December&nbsp;2005 (<a href="http://www.rfc-editor.org/rfc/rfc4306.txt">TXT</a>).</td></tr>
</table>

<a name="rfc.references2"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>12.2.&nbsp;Informative References</h3>
<table width="99%" border="0">
<tr><td class="author-text" valign="top"><a name="I-D.ietf-behave-rfc3489bis">[I-D.ietf-behave-rfc3489bis]</a></td>
<td class="author-text">Rosenberg, J., Mahy, R., Matthews, P., and D. Wing, &ldquo;<a href="http://www.ietf.org/internet-drafts/draft-ietf-behave-rfc3489bis-15.txt">Session Traversal Utilities for (NAT) (STUN)</a>,&rdquo; draft-ietf-behave-rfc3489bis-15 (work in progress), February&nbsp;2008 (<a href="http://www.ietf.org/internet-drafts/draft-ietf-behave-rfc3489bis-15.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="I-D.ietf-behave-turn">[I-D.ietf-behave-turn]</a></td>
<td class="author-text">Rosenberg, J., Mahy, R., and P. Matthews, &ldquo;<a href="http://www.ietf.org/internet-drafts/draft-ietf-behave-turn-07.txt">Traversal Using Relays around NAT (TURN): Relay Extensions to Session  Traversal Utilities for NAT (STUN)</a>,&rdquo; draft-ietf-behave-turn-07 (work in progress), February&nbsp;2008 (<a href="http://www.ietf.org/internet-drafts/draft-ietf-behave-turn-07.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="I-D.ietf-mmusic-ice">[I-D.ietf-mmusic-ice]</a></td>
<td class="author-text">Rosenberg, J., &ldquo;<a href="http://www.ietf.org/internet-drafts/draft-ietf-mmusic-ice-19.txt">Interactive Connectivity Establishment (ICE): A Protocol for Network Address Translator (NAT) Traversal for Offer/Answer Protocols</a>,&rdquo; draft-ietf-mmusic-ice-19 (work in progress), October&nbsp;2007 (<a href="http://www.ietf.org/internet-drafts/draft-ietf-mmusic-ice-19.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC3484">[RFC3484]</a></td>
<td class="author-text">Draves, R., &ldquo;<a href="http://tools.ietf.org/html/rfc3484">Default Address Selection for Internet Protocol version 6 (IPv6)</a>,&rdquo; RFC&nbsp;3484, February&nbsp;2003 (<a href="http://www.rfc-editor.org/rfc/rfc3484.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4555">[RFC4555]</a></td>
<td class="author-text">Eronen, P., &ldquo;<a href="http://tools.ietf.org/html/rfc4555">IKEv2 Mobility and Multihoming Protocol (MOBIKE)</a>,&rdquo; RFC&nbsp;4555, June&nbsp;2006 (<a href="http://www.rfc-editor.org/rfc/rfc4555.txt">TXT</a>).</td></tr>
</table>

<a name="rfc.comments"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>Editorial Comments</h3>
<table border="0">
<tr><td class="author-text" valign="top">
<a class="info" href="#anchor11">
anchor11</a><a name="comment.anchor11"></a>:
</td><td class="author-text">
this allows later revisions of this specification to define a relay usage</td></tr>
</table>

<a name="anchor43"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.A"></a><h3>Appendix A.&nbsp;
Open Issues</h3>

<a name="anchor44"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.A.1"></a><h3>A.1.&nbsp;
Is the second ME_CONNECTKEY required?</h3>

<p>The key provided by the responding peer is not really required. It's
        just that the MACs of the connectivity check requests from both
        peers would look the same, if only one key was used. On the other hand
        using just one key, would allow us to drop the ME_RESPONSE Notify
        payload from the ME_CONNECT response. Because the response from the
        other peer would not contain a ME_CONNECTKEY Notify it were clearly
        distinguishable from a ME_CONNECT request (see
        <a class='info' href='#sec-meresponse-req'>Appendix&nbsp;B.2<span> (</span><span class='info'>Why the ME_RESPONSE Notify payload is needed</span><span>)</span></a>).
</p>
<a name="anchor45"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.A.2"></a><h3>A.2.&nbsp;
Different NAT, Same Subnet</h3>

<p>One problem arises when two hosts behind different NATs are attached
        to the same subnet. Is this just a configuration problem that we need
        or need not to document, or is it a main issue that we should provide
        a solution for (Virtual IP?).
</p>
<a name="anchor46"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.A.3"></a><h3>A.3.&nbsp;
Relaying Provided by the Mediation Server</h3>

<p>As we provide the possibility to request a server reflexive endpoint
        from the mediation server, should we also provide relayed endpoints?
</p>
<a name="anchor47"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.A.4"></a><h3>A.4.&nbsp;
Compatibility/Synergy with MOBIKE</h3>

<p>What happens in the following situations:
        Moving behind a NAT. Moving out of a NAT. External IP changes
        (NAT/no NAT). Multihomed host (active link goes down).
        If both peers still are connected to the mediation server, is there
        a possibility to update the endpoints? If a peer notices an address
        change with MOBIKE, should it update the endpoints? Should it send
        updated endpoints to the other peer? If the mediation server notices
        that our endpoint changed, does it send us a notice (other than through
        MOBIKE)?
</p>
<a name="anchor48"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.B"></a><h3>Appendix B.&nbsp;
Design Decisions</h3>

<a name="anchor49"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.B.1"></a><h3>B.1.&nbsp;
Two exchanges between mediation server and second peer</h3>

<p>This document proposes the initiation of a connection to be composed of
        four exchanges: from one peer to the mediation server, from the
        mediation server to the other peer, and vice-versa. The two exchanges
        between the other peer and the mediation server could theoretically be
        combined in one exchange. This would be problematic in situations where
        the second peer first has to obtain endpoints before being able to
        answer the request. As this will take some time, the mediation server
        would most likely have retransmitted the request due to a timeout.
        And, if the peer wants to acquire a server reflexive endpoint from the
        mediation server a window size higher than one is required.
        
</p>
<a name="sec-meresponse-req"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.B.2"></a><h3>B.2.&nbsp;
Why the ME_RESPONSE Notify payload is needed</h3>

<p>It might seem that the ME_RESPONSE is rather superfluous. The
        ME_CONNECTID alone seems to be enough to distinguish requests from
        responses. A peer just has to maintain a list of issued ids and then
        simply compares the ME_CONNECTID of received ME_CONNECT messages with
        the items in this list. If an item matches, the received message is a
        response, otherwise, it is a request. Since the ME_CONNECTID is randomly
        chosen by the initiator, the ids contained in requests from two
        different peers should never match. So, this should even work if two
        peers concurrently initiate a mediation with each other.
</p>
<p>But there is a problem: What happens if a peer looses its state
        (e.g. due to a crash/restart) right after initiating a mediation, but
        immediately reconnects to the mediation server? Now, the ME_CONNECTID
        included in the answer from the other peer to the previously sent
        request is not included in the list of issued ids anymore. The answer
        thus looks exactly like a request for a new mediation. To avoid such a
        misunderstanding, peers have to be able to clearly distinguish requests
        from responses. Therefore, a ME_RESPONSE Notify payload is included in
        mediation responses.
        
</p>
<a name="anchor50"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.C"></a><h3>Appendix C.&nbsp;
Changelog</h3>

<a name="anchor51"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.C.1"></a><h3>C.1.&nbsp;
Changes from -.3 to -00</h3>

<p></p>
<ul class="text">
<li>Lots of clarifications and refinements. Major work on the
          introductory sections.
</li>
</ul>

<a name="anchor52"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.C.2"></a><h3>C.2.&nbsp;
Changes from -.2 to -.3</h3>

<p></p>
<ul class="text">
<li>Refined some details after implementing the protocol.
</li>
</ul>

<a name="anchor53"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.C.3"></a><h3>C.3.&nbsp;
Changes from -.1 to -.2</h3>

<p></p>
<ul class="text">
<li>Complete redesign to an ICE-like solution.
</li>
</ul>

<a name="anchor54"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.C.4"></a><h3>C.4.&nbsp;
Changes from -.0 to -.1</h3>

<p></p>
<ul class="text">
<li>P2P_CONNECT for both sides
</li>
<li>"Endpoint..." terms expanded.
</li>
</ul>

<a name="rfc.authors"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>Author's Address</h3>
<table width="99%" border="0" cellpadding="0" cellspacing="0">
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Tobias Brunner</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">University of Applied Sciences, Rapperswil</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Oberseestrasse 10</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Rapperswil, SG  8640</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Switzerland</td></tr>
<tr><td class="author" align="right">EMail:&nbsp;</td>
<td class="author-text"><a href="mailto:tobias.brunner@hsr.ch">tobias.brunner@hsr.ch</a></td></tr>
<tr><td class="author" align="right">URI:&nbsp;</td>
<td class="author-text"><a href="http://ita.hsr.ch">http://ita.hsr.ch</a></td></tr>
</table>
<a name="rfc.copyright"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>Full Copyright Statement</h3>
<p class='copyright'>
Copyright &copy; The IETF Trust (2008).</p>
<p class='copyright'>
This document is subject to the rights,
licenses and restrictions contained in BCP&nbsp;78
and at <a href='http://www.rfc-editor.org/copyright.html'>http://www.rfc-editor.org/copyright.html</a>, and except as set forth therein,
the authors retain all their rights.</p>
<p class='copyright'>
This document and the information contained herein are provided
on an &ldquo;AS IS&rdquo; basis and THE CONTRIBUTOR,
THE ORGANIZATION HE/SHE REPRESENTS
OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY, THE IETF TRUST
AND THE INTERNET ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT
THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY
IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR
PURPOSE.</p>
<h3>Intellectual Property</h3>
<p class='copyright'>
The IETF takes no position regarding the validity or scope of any
Intellectual Property Rights or other rights that might be claimed
to pertain to the implementation or use of the technology
described in this document or the extent to which any license
under such rights might or might not be available; nor does it
represent that it has made any independent effort to identify any
such rights.
Information on the procedures with respect to
rights in RFC documents can be found in BCP&nbsp;78 and BCP&nbsp;79.</p>
<p class='copyright'>
Copies of IPR disclosures made to the IETF Secretariat and any
assurances of licenses to be made available,
or the result of an attempt made to obtain a general license or
permission for the use of such proprietary rights by implementers or
users of this specification can be obtained from the IETF on-line IPR
repository at <a href='http://www.ietf.org/ipr'>http://www.ietf.org/ipr</a>.</p>
<p class='copyright'>
The IETF invites any interested party to bring to its attention
any copyrights,
patents or patent applications,
or other
proprietary rights that may cover technology that may be required
to implement this standard.
Please address the information to the IETF at <a href='mailto:ietf-ipr@ietf.org'>ietf-ipr@ietf.org</a>.</p>
</body></html>
