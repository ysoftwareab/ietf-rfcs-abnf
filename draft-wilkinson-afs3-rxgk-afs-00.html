<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="en"><head><title>Integrating rxgk with AFS</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="description" content="Integrating rxgk with AFS">
<meta name="generator" content="xml2rfc v1.35 (http://xml.resource.org/)">
<meta name="viewport" content="width=600;" />
<style type='text/css'><!--
        body {
                font-family: verdana, charcoal, helvetica, arial, sans-serif;
                font-size: 85%;
		max-width: 40em; 
		color: #000; background-color: #FFF;
                margin: 2em;
        }
        h1, h2, h3, h4, h5, h6 {
                font-family: helvetica, monaco, "MS Sans Serif", arial, sans-serif;
                font-weight: bold; font-style: normal;
        }
        h1 { color: #900; background-color: transparent; text-align: right; }
        h3 { color: #333; background-color: transparent; }

        td.RFCbug {
                font-size: x-small; text-decoration: none;
                width: 30px; height: 30px; padding-top: 2px;
                text-align: justify; vertical-align: middle;
                background-color: #000;
        }
        td.RFCbug span.RFC {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: bold; color: #666;
        }
        td.RFCbug span.hotText {
                font-family: charcoal, monaco, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: normal; text-align: center; color: #FFF;
        }

        table.TOCbug { width: 30px; height: 15px; }
        td.TOCbug {
                text-align: center; width: 30px; height: 15px;
                color: #FFF; background-color: #900;
        }
        td.TOCbug a {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, sans-serif;
                font-weight: bold; font-size: x-small; text-decoration: none;
                color: #FFF; background-color: transparent;
        }

        td.header {
                font-family: arial, helvetica, sans-serif; font-size: x-small;
                vertical-align: top; width: 33%;
                color: #FFF; background-color: #666;
        }
        td.author { font-weight: bold; font-size: x-small; margin-left: 4em; }
        td.author-text { font-size: x-small; }

        /* info code from SantaKlauss at http://www.madaboutstyle.com/tooltip2.html */
        a.info {
                /* This is the key. */
                position: relative;
                z-index: 24;
                text-decoration: none;
        }
        a.info:hover {
                z-index: 25;
                color: #FFF; background-color: #900;
        }
        a.info span { display: none; }
        a.info:hover span.info {
                /* The span will display just on :hover state. */
                display: block;
                position: absolute;
                font-size: smaller;
                top: 2em; left: -5em; width: 15em;
                padding: 2px; border: 1px solid #333;
                color: #900; background-color: #EEE;
                text-align: left;
        }

        a { font-weight: bold; }
        a:link    { color: #900; background-color: transparent; }
        a:visited { color: #633; background-color: transparent; }
        a:active  { color: #633; background-color: transparent; }

        p { margin-left: 2em; margin-right: 2em; }
        p.copyright { font-size: x-small; }
        p.toc { font-size: 85%;
		max-width: 40em; 
		font-weight: bold; margin-left: 3em; }
        table.toc { margin: 0 0 0 3em; padding: 0; border: 0; vertical-align: text-top; }
        td.toc { font-size: 85%;
		max-width: 40em; 
		font-weight: bold; vertical-align: text-top; }

        ol.text { margin-left: 2em; margin-right: 2em; }
        ul.text { margin-left: 2em; margin-right: 2em; }
        li      { margin-left: 3em; }

        /* RFC-2629 <spanx>s and <artwork>s. */
        em     { font-style: italic; }
        strong { font-weight: bold; }
        dfn    { font-weight: bold; font-style: normal; }
        cite   { font-weight: normal; font-style: normal; }
        tt     { color: #036; }
        tt, pre, pre dfn, pre em, pre cite, pre span {
                font-family: "Courier New", Courier, monospace; font-size: small;
        }
        pre {
                text-align: left; padding: 4px;
                color: #000; background-color: #CCC;
        }
        pre dfn  { color: #900; }
        pre em   { color: #66F; background-color: #FFC; font-weight: normal; }
        pre .key { color: #33C; font-weight: bold; }
        pre .id  { color: #900; }
        pre .str { color: #000; background-color: #CFF; }
        pre .val { color: #066; }
        pre .rep { color: #909; }
        pre .oth { color: #000; background-color: #FCF; }
        pre .err { background-color: #FCC; }

        /* RFC-2629 <texttable>s. */
        table.all, table.full, table.headers, table.none {
                font-size: 85%;
		max-width: 40em; 
		text-align: center; border-width: 2px;
                vertical-align: top; border-collapse: collapse;
        }
        table.all, table.full { border-style: solid; border-color: black; }
        table.headers, table.none { border-style: none; }
        th {
                font-weight: bold; border-color: black;
                border-width: 2px 2px 3px 2px;
        }
        table.all th, table.full th { border-style: solid; }
        table.headers th { border-style: none none solid none; }
        table.none th { border-style: none; }
        table.all td {
                border-style: solid; border-color: #333;
                border-width: 1px 2px;
        }
        table.full td, table.headers td, table.none td { border-style: none; }

        hr { height: 1px; }
        hr.insert {
                width: 80%; border-style: none; border-width: 0;
                color: #CCC; background-color: #CCC;
        }
--></style>
</head>
<body>
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<table summary="layout" width="66%" border="0" cellpadding="0" cellspacing="0"><tr><td><table summary="layout" width="100%" border="0" cellpadding="2" cellspacing="1">
<tr><td class="header">Network Working Group</td><td class="header"> Wilkinson</td></tr>
<tr><td class="header">Internet-Draft</td><td class="header">YFS</td></tr>
<tr><td class="header">Intended status: Informational</td><td class="header">January 12, 2010</td></tr>
<tr><td class="header">Expires: July 16, 2010</td><td class="header">&nbsp;</td></tr>
</table></td></tr></table>
<h1><br />Integrating rxgk with AFS<br />draft-wilkinson-afs3-rxgk-afs-00</h1>

<h3>Abstract</h3>

<p>This document describes how the new GSSAPI based rxgk security class
       for RX is integrated with the AFS application protocol. It describes a
       number of extensions to the basic rxgk protocol, clarifies a number
       of implementation issues, and provides values for the application
       specific elements of rxgk.
    
</p>
<h3>Status of this Memo</h3>
<p>
This Internet-Draft is submitted to IETF in full
conformance with the provisions of BCP&nbsp;78 and BCP&nbsp;79.</p>
<p>
Internet-Drafts are working documents of the Internet Engineering
Task Force (IETF), its areas, and its working groups.
Note that other groups may also distribute working documents as
Internet-Drafts.</p>
<p>
Internet-Drafts are draft documents valid for a maximum of six months
and may be updated, replaced, or obsoleted by other documents at any time.
It is inappropriate to use Internet-Drafts as reference material or to cite
them other than as &ldquo;work in progress.&rdquo;</p>
<p>
The list of current Internet-Drafts can be accessed at
<a href='http://www.ietf.org/ietf/1id-abstracts.txt'>http://www.ietf.org/ietf/1id-abstracts.txt</a>.</p>
<p>
The list of Internet-Draft Shadow Directories can be accessed at
<a href='http://www.ietf.org/shadow.html'>http://www.ietf.org/shadow.html</a>.</p>
<p>
This Internet-Draft will expire on July 16, 2010.</p>

<h3>Copyright Notice</h3>
<p>
Copyright (c) 2010 IETF Trust and the persons identified as the
document authors.  All rights reserved.</p>
<p>
This document is subject to BCP 78 and the IETF Trust's Legal
Provisions Relating to IETF Documents
(http://trustee.ietf.org/license-info) in effect on the date of
publication of this document.  Please review these documents
carefully, as they describe your rights and restrictions with respect
to this document. Code Components extracted from this document must
include Simplified BSD License text as described in Section 4.e of
the Trust Legal Provisions and are provided without warranty as
described in the BSD License.</p>
<a name="toc"></a><br /><hr />
<h3>Table of Contents</h3>
<p class="toc">
<a href="#anchor1">1.</a>&nbsp;
Introduction<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor2">1.1.</a>&nbsp;
Requirements Language<br />
<a href="#anchor3">2.</a>&nbsp;
Security Index<br />
<a href="#anchor4">3.</a>&nbsp;
Key negotiation<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor5">3.1.</a>&nbsp;
The AFSCombineTokens operation<br />
<a href="#anchor6">4.</a>&nbsp;
Tokens<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor7">4.1.</a>&nbsp;
Container<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor8">4.2.</a>&nbsp;
Token Encryption<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor9">4.3.</a>&nbsp;
Token Contents<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor10">4.4.</a>&nbsp;
Time<br />
<a href="#anchor11">5.</a>&nbsp;
Authenticator data<br />
<a href="#anchor12">6.</a>&nbsp;
Client tokens<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor13">6.1.</a>&nbsp;
Keyed clients<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor14">6.2.</a>&nbsp;
Unkeyed clients<br />
<a href="#anchor15">7.</a>&nbsp;
Server to server communication<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor16">7.1.</a>&nbsp;
Ticket printing<br />
<a href="#anchor17">8.</a>&nbsp;
Declaring rxgk support for a fileserver<br />
<a href="#anchor18">9.</a>&nbsp;
Per server keys<br />
<a href="#anchor19">10.</a>&nbsp;
Securing the callback channel<br />
<a href="#IANA">11.</a>&nbsp;
IANA Considerations<br />
<a href="#anchor20">12.</a>&nbsp;
Security Considerations<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor21">12.1.</a>&nbsp;
Downgrade attacks<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor22">12.2.</a>&nbsp;
Per server keys<br />
<a href="#rfc.references1">13.</a>&nbsp;
Normative References<br />
<a href="#anchor24">Appendix&nbsp;A.</a>&nbsp;
Acknowledgements<br />
<a href="#rfc.authors">&#167;</a>&nbsp;
Author's Address<br />
</p>
<br clear="all" />

<a name="anchor1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1"></a><h3>1.&nbsp;
Introduction</h3>

<p><a class='info' href='#I-D.wilkinson-afs3-rxgk'>rxgk<span> (</span><span class='info'>Wilkinson, S., &ldquo;rxgk: GSSAPI based security class for RX,&rdquo; January&nbsp;2010.</span><span>)</span></a> [I&#8209;D.wilkinson&#8209;afs3&#8209;rxgk] is a new 
       <a class='info' href='#RFC2743'>GSSAPI<span> (</span><span class='info'>Linn, J., &ldquo;Generic Security Service Application Program Interface Version 2, Update 1,&rdquo; January&nbsp;2000.</span><span>)</span></a> [RFC2743] based security layer for the RX
       remote procedure call system. The rxgk specification details how it
       may be used with a generic RX application, this document
       provides additional detail specific to integrating rxgk with the AFS
       distributed file system.
    
</p>
<p>AFS differs from the standard rxgk implementation in that it does not
       require GSSAPI negotiation with each server. Instead, a client
       negotiates with a central location (the vlserver), and receives a
       token which can then be used with any server in the cell. 
       This requires that all servers have an identical cell wide 
       pre-shared key for token encryption.
</p>
<p>For more complex cell topologies, servers which do not share the
       cell-wide key are supported by means of an extended CombineTokens
       call. This call takes a server identifier, and will return a token
       encrypted with a key for a specific server. This extended call,
       AFSCombineTokens, also provides support for indicating whether
       a specific server is rxgk capable, allowing cells to securely
       migrate to rxgk from other security mechanisms.
</p>
<p>We also define mechanisms for securing the callback channel which
       is created between fileserver and client.
</p>
<a name="anchor2"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1.1"></a><h3>1.1.&nbsp;
Requirements Language</h3>

<p>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
         "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
         document are to be interpreted as described in <a class='info' href='#RFC2119'>RFC 2119<span> (</span><span class='info'>Bradner, S., &ldquo;Key words for use in RFCs to Indicate Requirement Levels,&rdquo; March&nbsp;1997.</span><span>)</span></a> [RFC2119].
      
</p>
<a name="anchor3"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2"></a><h3>2.&nbsp;
Security Index</h3>

<p>When used within the AFS protocol, rxgk has a securityIndex value of 4
    
</p>
<a name="anchor4"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3"></a><h3>3.&nbsp;
Key negotiation</h3>

<p>An AFS cell wishing to support rxgk MUST run an rxgk key negotiation
       service, as specified in <a class='info' href='#I-D.wilkinson-afs3-rxgk'>[I&#8209;D.wilkinson&#8209;afs3&#8209;rxgk]<span> (</span><span class='info'>Wilkinson, S., &ldquo;rxgk: GSSAPI based security class for RX,&rdquo; January&nbsp;2010.</span><span>)</span></a>, 
       on each of its vlservers. The service MUST listen on the same port as
       the vlserver.
</p>
<p>The GSS identity afs-rxgk@_afs.&lt;cellname&gt;
       is the acceptor identity for this service. Where multiple 
       vlservers exist for a single cell, all of these servers must
       have access to the key material for this identity, which MUST be
       identical across the cell. Clients MAY use the presence of this
       identity as an indicator of rxgk support for a particular cell. Clients
       which wish to support cells using other rx security objects MAY downgrade
       if this identity is not available.
    
</p>
<p>Tokens returned from the GSSNegotiate call MUST only be used with
       database servers. Tokens for fileservers MUST be obtained by
       calling AFSCombineTokens before each server is contacted.
</p>
<a name="anchor5"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.1"></a><h3>3.1.&nbsp;
The AFSCombineTokens operation</h3>

<p>AFS extends the existing CombineTokens operation to provide a more
	 general token manipulation service. This operation takes a user
	 token, an optional cache manager token, and a destination identifier,
	 and returns a token specific to the specified destination.
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
    AFSCombineTokens(IN RXGK_Data *token0&lt;&gt;,
                     IN RXGK_Data *token1&lt;&gt;,
                     IN afsUUID destination,
                     OUT RXGK_Data *new_token&lt;&gt;) = 3;
</pre></div>
<blockquote class="text"><dl>
<dt>token0:</dt>
<dd>An rxgk token obtained using the GSSNegotiate rpc
</dd>
<dt>token1:</dt>
<dd>Either, an rxgk token obtained using the GSSNegotiate rpc, or empty (0 length)
</dd>
<dt>destination:</dt>
<dd>The UUID of the server this token is indented for. Fileserver UUIDs may be obtained from the VLDB in the same call as returns their addresses.
</dd>
<dt>new_token:</dt>
<dd>A new rxgk token, or empty
</dd>
</dl></blockquote>
<p>The AFSCombineTokens call MUST only be performed over an rxgk
	 protected
	 channel, with a security level of 1 (integrity) or more. Servers
         MUST reject all attempts to perform this operation over channels
         that are not protected in this way.
</p>
<p>Clients which are caching the results of RPCs on behalf of
	 multiple users (such as a traditional AFS Cache Manager), SHOULD 
         provide both the user's token (as token0) and a token generated
	 from an identity that is private to the cache manager (as token1).
	 This prevents a user from poisoning the cache for other users.
	 Recommendations on keying cache managers are contained below
</p>
<p>Clients which are working on behalf of a single user can provide
	 an empty token1, but MUST use AFSCombineTokens to obtain a
	 destination specific token for each fileserver they contact.
</p>
<p>If the returned token is 0 length, then the destination does not
	 support rxgk, and the client MAY fall back to using a different
	 authentication mechanism for that server. This is the only situation
	 in which an rxgk capable client operating within an rxgk enabled
	 cell may downgrade its choice of security layer.
</p>
<p>Keys and tokens are combined in the same way as the
	 CombineTokens call, documented in 
	 <a class='info' href='#I-D.wilkinson-afs3-rxgk'>[I&#8209;D.wilkinson&#8209;afs3&#8209;rxgk]<span> (</span><span class='info'>Wilkinson, S., &ldquo;rxgk: GSSAPI based security class for RX,&rdquo; January&nbsp;2010.</span><span>)</span></a>.
</p>
<a name="anchor6"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4"></a><h3>4.&nbsp;
Tokens</h3>

<a name="anchor7"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.1"></a><h3>4.1.&nbsp;
Container</h3>

<p>rxgk tokens for AFS take the form of some key management data,
         followed by an encrypted data blob. The key management data (a
	 version number, followed by an <a class='info' href='#RFC3961'>[RFC3961]<span> (</span><span class='info'>Raeburn, K., &ldquo;Encryption and Checksum Specifications for Kerberos 5,&rdquo; February&nbsp;2005.</span><span>)</span></a> 
	 encryption type) allows the
         recipient to identify which pre-shared key has been used to 
         encrypt the token itself.
      
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
    struct RXGK_TokenContainer {
      afs_int32 kvno;
      afs_int32 enctype;
      opaque    encrypted_token&lt;&gt;;
    }
</pre></div>
<a name="anchor8"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.2"></a><h3>4.2.&nbsp;
Token Encryption</h3>

<p>Token contents are encrypted using a pre-shared key. rxgk supports
	 the use of both a single cell-wide key and the use of per-server
	 keys. The cell-wide key must be installed on all servers which are
	 capable of accepting cell-wide tokens. Cell-wide keys should be for
	 a selected RFC3961 encryption mechanism which is supported by all
	 servers within the cell. Per-server keys should be for an
	 encryption mechanism which is supported by both the destination
	 server, and the negotiation service. The management of per-server
	 keys is discussed in more detail below.
</p>
<p>Key rollover is permitted by means of a key version number. When the
	 key is changed, a different key version number MUST be selected. Servers
	 SHOULD accept tokens using the old key until the lifetime of all
	 existing tokens has elapsed.
</p>
<p>Encryption is performed over the XDR encoded RXGK_Token structure,
         using the RFC3961 encrypt operation, with a key usage value of
	 1036 (RXGK_SERVER_ENC_TICKET)
</p>
<a name="anchor9"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.3"></a><h3>4.3.&nbsp;
Token Contents</h3>

<p>The token itself contains the information expressed by the following
	 XDR:
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
    struct RXGK_Token {
      afs_int32 enctype;
      opaque    K0&lt;&gt;;
      afs_int32 level;
      afs_int64 starttime;
      afs_int32 lifetime;
      afs_int32 bytelife;
      afs_int64 expirationtime;
      struct PrAuthName identities&lt;&gt;;
    }
</pre></div>
<blockquote class="text"><dl>
<dt>enctype:</dt>
<dd>The RFC3961 encryption type of the session key
	  contained within this ticket
</dd>
<dt>K0:</dt>
<dd>The session key (see the rxgk specification for
	  details of how this key is negotiated between client and negotiation
          service).
</dd>
<dt>level:</dt>
<dd>The security level that MUST be used for this
	  connection
</dd>
<dt>starttime:</dt>
<dd>The time, expressed as a 100ns value, since
	  the Unix epoch. Servers MUST reject attempts to
	  start connections with tokens that are not yet valid. 
	
</dd>
<dt>lifetime:</dt>
<dd>The maximum number of seconds that a 
	key derived from K0 may be used for. This is an advisory limit. If 0,
	keys have no time based limit
</dd>
<dt>bytelife:</dt>
<dd>The maximum amount of data (expressed as
	  log 2 byes) that may be transferred using a key derived from K0.
	  This is an advisory limit. If 0, there is no data based limit on
          key usage
</dd>
<dt>expirationtime:</dt>
<dd>The time (expressed as the number of 100ns          since the Unix epoch) beyond which this token may no longer be
          used. Servers MUST
          reject attempts to use connections secured with this token after
	  this time has passed. A time of 0 indicates that this token never
	  expires.
</dd>
<dt>identities:</dt>
<dd>A list of identities represented by this
	token. struct PrAuthName is the identity structure defined in 
	<a class='info' href='#I-D.brashear-afs3-pts-extended-names'>[I&#8209;D.brashear&#8209;afs3&#8209;pts&#8209;extended&#8209;names]<span> (</span><span class='info'>Brashear, D., &ldquo;Authentication Name Mapping extension for AFS-3 Protection Service,&rdquo; April&nbsp;2010.</span><span>)</span></a>
</dd>
</dl></blockquote>
<a name="anchor10"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.4"></a><h3>4.4.&nbsp;
Time</h3>

<p>THIS SECTION WILL BE REMOVED BEFORE PUBLICATION
</p>
<p>This document uses 64bit time values, with a granularity of 100ns - the
       currently proposed mechanism for representing 64 bit time in AFS. This
       proposal has yet to be standardised - it is intended that this 
       document will evolve to match whatever AFS standardises upon.
</p>
<a name="anchor11"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5"></a><h3>5.&nbsp;
Authenticator data</h3>

<p>The appdata opaque within the RXGK_Authenticator contains the XDR
      encoded UUID of the client. The UUID is encoded using the afsUUID
      type.
</p>
<a name="anchor12"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6"></a><h3>6.&nbsp;
Client tokens</h3>

<p>In order to protect users of a multi-user cache manager from each
       other, it must be impossible for an individual user to determine the
       key used to protect operations which affect the cache. This requires
       that the cache manager have key material of its own which can be
       combined with that of the user. This functionality is provided by
       the AFSCombineTokens call specified earlier in this document. However,
       this call requires that a cache manager have access to a token for this
       purpose.
</p>
<a name="anchor13"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.1"></a><h3>6.1.&nbsp;
Keyed clients</h3>

<p>Where a host already has key material for a GSSAPI mechanism
	 supported by rxgk, that material may be used to key the client.
	 The client simply calls the rxgk negotiation service using the
	 relevant material, and obtains a token. The client should frequently
	 renew this token, to avoid combined tokens having unnecessarily
	 close expiration times.
</p>
<p>It is recommended that identities created specifically for use by 
	 a cache manager have the name afs3-callback@&lt;hostname&gt; where 
	 &lt;hostname&gt; is the fully qualified domain name of the cache
	 manager.
</p>
<a name="anchor14"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.2"></a><h3>6.2.&nbsp;
Unkeyed clients</h3>

<p>When a client has no key material, it is possible that an
	 anonymous GSSAPI connection may succeed. Clients MAY attempt to
	 negotiate such a connection by calling GSS_Init_Sec_Context() 
	 with the <a class='info' href='#RFC2743'>anon_req_flag<span> (</span><span class='info'>Linn, J., &ldquo;Generic Security Service Application Program Interface Version 2, Update 1,&rdquo; January&nbsp;2000.</span><span>)</span></a> [RFC2743] and the 
	 default credentials set.
</p>
<a name="anchor15"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7"></a><h3>7.&nbsp;
Server to server communication</h3>

<p>A number of portions of the AFS protocol require that servers
       communicate amongst themselves. To secure this with rxgk we require
       both a mechanism of generating tokens for these servers to use, and
       a definition of which identities are permitted for authorisation
       purposes. 
</p>
<a name="anchor16"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.1"></a><h3>7.1.&nbsp;
Ticket printing</h3>

<p>A server with access to the cell-wide pre-shared key may print its
	 own tokens for server to server access. To do so, it should construct
	 a token with suitable values. The list of identities in such a token
	 MUST be empty. It can then encrypt this token using the pre-shared key,
	 and use it in the same way as a normal rxgk token. The receiving server
	 can identify it is a printed token by the empty identity list.
	 
      
</p>
<a name="anchor17"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.8"></a><h3>8.&nbsp;
Declaring rxgk support for a fileserver</h3>

<p>The AFSCombineTokens call has specific behaviour when a destination
       endpoint does not support rxgk. Implementing this behaviour requires
       that the vlserver be aware of whether a fileserver supports rxgk.
    
</p>
<p>Fileservers currently register with the vlserver using the 
       VL_RegisterAddrs RPC. Fileservers which support rxgk MUST call this
       RPC over a rxgk protected connection. The vlserver should then note
       the rx security layer used in registration, and infer rxgk support
       from that. To prevent downgrade attacks, once a fileserver has
       registered as being rxgk capable, the vlserver MUST NOT remove that
       registration without administrator intervention.
    
</p>
<p>Once a fileserver has been marked as supporting rxgk, VL_RegisterAddrs
       calls for that fileserver MUST only be accepted over an rxgk
       protected link.
    
</p>
<a name="anchor18"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.9"></a><h3>9.&nbsp;
Per server keys</h3>

<p>The provision of servers with their own keys, rather than the cell wide
       master key, requires the ability to maintain a directory of these keys
       on the vlserver, so that the AFSCombineTokens RPC can encrypt the
       outgoing token with the correct key. The manner in which this directory
       is maintained is down to the implementor, who MAY decided to use a
       manual, or out of band key management system
    
</p>
<p>Implementations supporting automatic key management through the AFS3
       protocol MUST provide the following RPC
</p>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
    struct RXGK_ServerKeyDataRequest {
	afs_int32 enctypes&lt;&gt;
	opaque nonce1&lt;&gt;
    };

    struct RXGK_ServerKeyDataResponse {
        afs_int32 enctype;
        afs_int32 kvno;
	opaque nonce2&lt;&gt;
    };

    VL_RegisterAddrsAndKey(
        IN afsUUID *uuidp,
	IN afs_int32 spare1,
	IN bulkaddrs *ipaddr,
	IN afs_int32 secIndex,
	IN opaque *keyDataRequest&lt;&gt;,
	OUT opaque *keyDataResponse&lt;&gt;) = XXX;
</pre></div><p>

</p>
<blockquote class="text"><dl>
<dt>uuidp:</dt>
<dd>As the existing VL_RegisterAddrs RPC
</dd>
<dt>spare1:</dt>
<dd>As the existing VL_RegisterAddrs RPC
</dd>
<dt>ipaddr:</dt>
<dd>As the existing VL_RegisterAddrs RPC
</dd>
<dt>secIndex:</dt>
<dd>The index of the security mechanism for 
	which a key is being set. For rxgk, this value should be '4'
</dd>
<dt>keyDataRequest:</dt>
<dd>An opaque blob of data, specific to
	the security mechanism defined by secIndex. For rxgk it is,
	the xdr encoded representation of RXGK_ServerKeyDataRequest
</dd>
<dt>keyDataResponse:</dt>
<dd>An opaque blob of data, specific to
	the security mechanism defined by secIndex. For rxgk it is
        the xdr encoded representation of RXGK_ServerDataResponse
</dd>
</dl></blockquote>
<p>The client provides, in the RXGK_ServerKeyDataRequest structure, a list
       of the RFC3961 encryption types that it will accept as a server key. It
       also provides a nonce containing 20 random data bytes.
</p>
<p>The server selects an encryption type shared by it and the client, and
       returns that, along with 20 bytes of random data that it has generated,
       in RXGK_ServerKeyDataResponse. If there is no common encryption type,
       then the server must fail the request.
</p>
<p>The server key can then be derived by both client and server using
</p>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
       random-to-key(PRF+(K0, K, nonce1 || nonce2))
</pre></div><p>

</p>
<p>random-to-key is the function specified by the RFC3961 profile of the
       encryption type chosen by the server, and returned in enctype.
</p>
<p>PRF+ is the function of that name specified by 
       <a class='info' href='#RFC4402'>[RFC4402]<span> (</span><span class='info'>Williams, N., &ldquo;A Pseudo-Random Function (PRF) for the Kerberos V Generic Security Service Application Program Interface (GSS-API) Mechanism,&rdquo; February&nbsp;2006.</span><span>)</span></a>
</p>
<p>K0 is the master key of the current rxgk session, as originally 
       determined by the GSSNegotiate call.
</p>
<p>K is the key generation seed length as specified in enctype's RFC3961
       profile
</p>
<a name="anchor19"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.10"></a><h3>10.&nbsp;
Securing the callback channel</h3>

<p>AFS has traditionally had an unprotected callback channel. However,
       extended callbacks requires a mechanism for ensuring that callback
       breaks and, critically, data updates, are protected. This requires
       that there is a strong connection between the key material used
       initially to perform the RPC, and that which is used to protect
       any resulting callback. We achieve this using the cache manager
       token discussed earlier, which is required in order for a client to
       accept secure callbacks
    
</p>
<p>A cache manager may set a key for secure callbacks by issuing
       the following RPC (part of the AFS_ family)
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
    AFS_SetCallbackKey(afs_int32 securityIndex,
		       opaque mech_data&lt;&gt;) = XXX;
</pre></div>
<blockquote class="text"><dl>
<dt>securityIndex:</dt>
<dd>The securityIndex of the mechanism for
         which this key is being set. In the rxgk case, this will be
	 rxgk's security index, as defined earlier.
</dd>
<dt>mech_data:</dt>
<dd>This contains the security object specific
	 data. In rxgk's case this is an XDR encoded RXGK_Token structure.
</dd>
</dl></blockquote>
<p>When used with rxgk, this RPC MUST be performed over an rxgk protected
       link established using solely the cache manager's token. This connection
       MUST have a security level of 2 (encrypted).
</p>
<p>If a fileserver receives a AFS_SetCallbackKey protected with a different
       cache manager identity than the previous call from that client, it MUST
       break all secure callbacks held by that client using the old key before
       this RPC completes.
</p>
<p>Only RPCs issued over an rxgk protected connection should receive rxgk
       protected callbacks
</p>
<p>The fileserver MUST only send rxgk protected callbacks when one of the
       identities performing the RPC establishing that callback matches the
       identity associated with that clients callback channel.
</p>
<a name="IANA"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.11"></a><h3>11.&nbsp;
IANA Considerations</h3>

<p>This memo includes no request to IANA.
</p>
<a name="anchor20"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.12"></a><h3>12.&nbsp;
Security Considerations</h3>

<a name="anchor21"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.12.1"></a><h3>12.1.&nbsp;
Downgrade attacks</h3>

<p>Using the presence of a GSSAPI key to determine a cell's ability to
         perform rxgk is vulnerable to a downgrade attack, as an attacker may
         forge error responses. Cells which no longer support rxkad
         SHOULD remove their afs@REALM and afs/cell@REALM Kerberos keys.
      
</p>
<a name="anchor22"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.12.2"></a><h3>12.2.&nbsp;
Per server keys</h3>

<p>The mechanism for automatically registering per server keys is
	 potentially vulnerable, as it trades a short lived key (the rxgk
	 session key, which protects the key exchange) for a long life one
	 (the server key)
      
</p>
<a name="rfc.references1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>13.&nbsp;Normative References</h3>
<table width="99%" border="0">
<tr><td class="author-text" valign="top"><a name="I-D.brashear-afs3-pts-extended-names">[I-D.brashear-afs3-pts-extended-names]</a></td>
<td class="author-text">Brashear, D., &ldquo;<a href="http://www.ietf.org/internet-drafts/draft-brashear-afs3-pts-extended-names-01.txt">Authentication Name Mapping extension for AFS-3 Protection Service</a>,&rdquo; draft-brashear-afs3-pts-extended-names-01 (work in progress), April&nbsp;2010 (<a href="http://www.ietf.org/internet-drafts/draft-brashear-afs3-pts-extended-names-01.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="I-D.wilkinson-afs3-rxgk">[I-D.wilkinson-afs3-rxgk]</a></td>
<td class="author-text">Wilkinson, S., &ldquo;<a href="http://www.ietf.org/internet-drafts/draft-wilkinson-afs3-rxgk-00.txt">rxgk: GSSAPI based security class for RX</a>,&rdquo; draft-wilkinson-afs3-rxgk-00 (work in progress), January&nbsp;2010 (<a href="http://www.ietf.org/internet-drafts/draft-wilkinson-afs3-rxgk-00.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC2119">[RFC2119]</a></td>
<td class="author-text"><a href="mailto:sob@harvard.edu">Bradner, S.</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>,&rdquo; BCP&nbsp;14, RFC&nbsp;2119, March&nbsp;1997 (<a href="http://www.rfc-editor.org/rfc/rfc2119.txt">TXT</a>, <a href="http://xml.resource.org/public/rfc/html/rfc2119.html">HTML</a>, <a href="http://xml.resource.org/public/rfc/xml/rfc2119.xml">XML</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC2743">[RFC2743]</a></td>
<td class="author-text"><a href="mailto:jlinn@rsasecurity.com">Linn, J.</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc2743">Generic Security Service Application Program Interface Version 2, Update 1</a>,&rdquo; RFC&nbsp;2743, January&nbsp;2000 (<a href="http://www.rfc-editor.org/rfc/rfc2743.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC3961">[RFC3961]</a></td>
<td class="author-text">Raeburn, K., &ldquo;<a href="http://tools.ietf.org/html/rfc3961">Encryption and Checksum Specifications for Kerberos 5</a>,&rdquo; RFC&nbsp;3961, February&nbsp;2005 (<a href="http://www.rfc-editor.org/rfc/rfc3961.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4402">[RFC4402]</a></td>
<td class="author-text">Williams, N., &ldquo;<a href="http://tools.ietf.org/html/rfc4402">A Pseudo-Random Function (PRF) for the Kerberos V Generic Security Service Application Program Interface (GSS-API) Mechanism</a>,&rdquo; RFC&nbsp;4402, February&nbsp;2006 (<a href="http://www.rfc-editor.org/rfc/rfc4402.txt">TXT</a>).</td></tr>
</table>

<a name="anchor24"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.A"></a><h3>Appendix A.&nbsp;
Acknowledgements</h3>

<p>
	RXGK has been the work of many contributors over the years. A partial
	list is contained in the previous document. All errors and omissions
	are, however, mine.
	
</p>
<a name="rfc.authors"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>Author's Address</h3>
<table width="99%" border="0" cellpadding="0" cellspacing="0">
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Simon Wilkinson</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Your File System Inc</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:simon@sxw.org.uk">simon@sxw.org.uk</a></td></tr>
</table>
</body></html>
