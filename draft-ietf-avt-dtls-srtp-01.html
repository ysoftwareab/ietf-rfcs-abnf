<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="en"><head><title>Datagram Transport Layer Security
    (DTLS) Extension to Establish Keys for Secure Real-time Transport Protocol
    (SRTP)</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="description" content="Datagram Transport Layer Security
    (DTLS) Extension to Establish Keys for Secure Real-time Transport Protocol
    (SRTP)">
<meta name="generator" content="xml2rfc v1.35 (http://xml.resource.org/)">
<meta name="viewport" content="width=600;" />
<style type='text/css'><!--
        body {
                font-family: verdana, charcoal, helvetica, arial, sans-serif;
                font-size: 85%;
		max-width: 40em; 
		color: #000; background-color: #FFF;
                margin: 2em;
        }
        h1, h2, h3, h4, h5, h6 {
                font-family: helvetica, monaco, "MS Sans Serif", arial, sans-serif;
                font-weight: bold; font-style: normal;
        }
        h1 { color: #900; background-color: transparent; text-align: right; }
        h3 { color: #333; background-color: transparent; }

        td.RFCbug {
                font-size: x-small; text-decoration: none;
                width: 30px; height: 30px; padding-top: 2px;
                text-align: justify; vertical-align: middle;
                background-color: #000;
        }
        td.RFCbug span.RFC {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: bold; color: #666;
        }
        td.RFCbug span.hotText {
                font-family: charcoal, monaco, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: normal; text-align: center; color: #FFF;
        }

        table.TOCbug { width: 30px; height: 15px; }
        td.TOCbug {
                text-align: center; width: 30px; height: 15px;
                color: #FFF; background-color: #900;
        }
        td.TOCbug a {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, sans-serif;
                font-weight: bold; font-size: x-small; text-decoration: none;
                color: #FFF; background-color: transparent;
        }

        td.header {
                font-family: arial, helvetica, sans-serif; font-size: x-small;
                vertical-align: top; width: 33%;
                color: #FFF; background-color: #666;
        }
        td.author { font-weight: bold; font-size: x-small; margin-left: 4em; }
        td.author-text { font-size: x-small; }

        /* info code from SantaKlauss at http://www.madaboutstyle.com/tooltip2.html */
        a.info {
                /* This is the key. */
                position: relative;
                z-index: 24;
                text-decoration: none;
        }
        a.info:hover {
                z-index: 25;
                color: #FFF; background-color: #900;
        }
        a.info span { display: none; }
        a.info:hover span.info {
                /* The span will display just on :hover state. */
                display: block;
                position: absolute;
                font-size: smaller;
                top: 2em; left: -5em; width: 15em;
                padding: 2px; border: 1px solid #333;
                color: #900; background-color: #EEE;
                text-align: left;
        }

        a { font-weight: bold; }
        a:link    { color: #900; background-color: transparent; }
        a:visited { color: #633; background-color: transparent; }
        a:active  { color: #633; background-color: transparent; }

        p { margin-left: 2em; margin-right: 2em; }
        p.copyright { font-size: x-small; }
        p.toc { font-size: 85%;
		max-width: 40em; 
		font-weight: bold; margin-left: 3em; }
        table.toc { margin: 0 0 0 3em; padding: 0; border: 0; vertical-align: text-top; }
        td.toc { font-size: 85%;
		max-width: 40em; 
		font-weight: bold; vertical-align: text-top; }

        ol.text { margin-left: 2em; margin-right: 2em; }
        ul.text { margin-left: 2em; margin-right: 2em; }
        li      { margin-left: 3em; }

        /* RFC-2629 <spanx>s and <artwork>s. */
        em     { font-style: italic; }
        strong { font-weight: bold; }
        dfn    { font-weight: bold; font-style: normal; }
        cite   { font-weight: normal; font-style: normal; }
        tt     { color: #036; }
        tt, pre, pre dfn, pre em, pre cite, pre span {
                font-family: "Courier New", Courier, monospace; font-size: small;
        }
        pre {
                text-align: left; padding: 4px;
                color: #000; background-color: #CCC;
        }
        pre dfn  { color: #900; }
        pre em   { color: #66F; background-color: #FFC; font-weight: normal; }
        pre .key { color: #33C; font-weight: bold; }
        pre .id  { color: #900; }
        pre .str { color: #000; background-color: #CFF; }
        pre .val { color: #066; }
        pre .rep { color: #909; }
        pre .oth { color: #000; background-color: #FCF; }
        pre .err { background-color: #FCC; }

        /* RFC-2629 <texttable>s. */
        table.all, table.full, table.headers, table.none {
                font-size: 85%;
		max-width: 40em; 
		text-align: center; border-width: 2px;
                vertical-align: top; border-collapse: collapse;
        }
        table.all, table.full { border-style: solid; border-color: black; }
        table.headers, table.none { border-style: none; }
        th {
                font-weight: bold; border-color: black;
                border-width: 2px 2px 3px 2px;
        }
        table.all th, table.full th { border-style: solid; }
        table.headers th { border-style: none none solid none; }
        table.none th { border-style: none; }
        table.all td {
                border-style: solid; border-color: #333;
                border-width: 1px 2px;
        }
        table.full td, table.headers td, table.none td { border-style: none; }

        hr { height: 1px; }
        hr.insert {
                width: 80%; border-style: none; border-width: 0;
                color: #CCC; background-color: #CCC;
        }
--></style>
</head>
<body>
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<table summary="layout" width="66%" border="0" cellpadding="0" cellspacing="0"><tr><td><table summary="layout" width="100%" border="0" cellpadding="2" cellspacing="1">
<tr><td class="header">Network Working Group</td><td class="header">D. McGrew</td></tr>
<tr><td class="header">Internet-Draft</td><td class="header">Cisco Systems</td></tr>
<tr><td class="header">Intended status:  Standards Track</td><td class="header">E. Rescorla</td></tr>
<tr><td class="header">Expires:  May 21, 2008</td><td class="header">Network Resonance</td></tr>
<tr><td class="header">&nbsp;</td><td class="header">November 18, 2007</td></tr>
</table></td></tr></table>
<h1><br />Datagram Transport Layer Security
    (DTLS) Extension to Establish Keys for Secure Real-time Transport Protocol
    (SRTP)<br />draft-ietf-avt-dtls-srtp-01.txt</h1>

<h3>Status of this Memo</h3>
<p>
By submitting this Internet-Draft,
each author represents that any applicable patent or other IPR claims of which
he or she is aware have been or will be disclosed,
and any of which he or she becomes aware will be disclosed,
in accordance with Section&nbsp;6 of BCP&nbsp;79.</p>
<p>
Internet-Drafts are working documents of the Internet Engineering
Task Force (IETF), its areas, and its working groups.
Note that other groups may also distribute working documents as
Internet-Drafts.</p>
<p>
Internet-Drafts are draft documents valid for a maximum of six months
and may be updated, replaced, or obsoleted by other documents at any time.
It is inappropriate to use Internet-Drafts as reference material or to cite
them other than as &ldquo;work in progress.&rdquo;</p>
<p>
The list of current Internet-Drafts can be accessed at
<a href='http://www.ietf.org/ietf/1id-abstracts.txt'>http://www.ietf.org/ietf/1id-abstracts.txt</a>.</p>
<p>
The list of Internet-Draft Shadow Directories can be accessed at
<a href='http://www.ietf.org/shadow.html'>http://www.ietf.org/shadow.html</a>.</p>
<p>
This Internet-Draft will expire on May 21, 2008.</p>

<h3>Abstract</h3>

<p>
     This document describes a Datagram Transport Layer Security (DTLS)
     extension to establish keys for secure RTP (SRTP) and secure RTP
     Control Protocol (SRTCP) flows. DTLS keying happens on the media
     path, independent of any out-of-band signalling channel present.
     
</p><a name="toc"></a><br /><hr />
<h3>Table of Contents</h3>
<p class="toc">
<a href="#anchor1">1.</a>&nbsp;
Introduction<br />
<a href="#sec-conv">2.</a>&nbsp;
Conventions Used In This Document<br />
<a href="#sec-overview">3.</a>&nbsp;
Overview of DTLS-SRTP Operation<br />
<a href="#sec-extension">4.</a>&nbsp;
DTLS Extensions for SRTP Key Establishment<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor2">4.1.</a>&nbsp;
The use_srtp Extension<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor3">4.1.1.</a>&nbsp;
use_srtp Extension Definition<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section.propro">4.1.2.</a>&nbsp;
SRTP Protection Profiles<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor4">4.1.3.</a>&nbsp;
srtp_mki value<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#keyDeriv">4.2.</a>&nbsp;
Key Derivation<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor5">4.3.</a>&nbsp;
Key Scope<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor6">4.4.</a>&nbsp;
Key Usage Limitations<br />
<a href="#sec-data-prot">5.</a>&nbsp;
Use of RTP and RTCP over a DTLS-SRTP Channel<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor7">5.1.</a>&nbsp;
Data Protection<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section.transmit">5.1.1.</a>&nbsp;
Transmission<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor8">5.1.2.</a>&nbsp;
Reception<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section.rehandshake">5.2.</a>&nbsp;
Rehandshake and Re-key<br />
<a href="#sec-multiparty">6.</a>&nbsp;
Multi-party RTP Sessions<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor9">6.1.</a>&nbsp;
SIP Forking<br />
<a href="#section.sec">7.</a>&nbsp;
Security Considerations<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor10">7.1.</a>&nbsp;
Security of Negotiation<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor11">7.2.</a>&nbsp;
Framing Confusion<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor12">7.3.</a>&nbsp;
Sequence Number Interactions<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor13">7.3.1.</a>&nbsp;
Alerts<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor14">7.3.2.</a>&nbsp;
Renegotiation<br />
<a href="#section.iana">8.</a>&nbsp;
IANA Considerations<br />
<a href="#anchor15">9.</a>&nbsp;
Acknowledgments<br />
<a href="#rfc.references1">10.</a>&nbsp;
References<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#rfc.references1">10.1.</a>&nbsp;
Normative References<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#rfc.references2">10.2.</a>&nbsp;
Informational References<br />
<a href="#appendix">Appendix&nbsp;A.</a>&nbsp;
Performance of Multiple DTLS Handshakes<br />
<a href="#rfc.authors">&#167;</a>&nbsp;
Authors' Addresses<br />
<a href="#rfc.copyright">&#167;</a>&nbsp;
Intellectual Property and Copyright Statements<br />
</p>
<br clear="all" />

<a name="anchor1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1"></a><h3>1.&nbsp;
Introduction</h3>

<p>The Secure RTP profile (SRTP) [6] can provide confidentiality,
     message authentication, and replay protection to RTP data and
     RTP Control (RTCP) traffic. SRTP does not provide key management
     functionality, but instead depends on external key management to
     exchange secret master keys, and to negotiate the algorithms and
     parameters for use with those keys.
</p>
<p>Datagram Transport Layer Security (DTLS) <a class='info' href='#RFC4347'>[5]<span> (</span><span class='info'>Rescorla, E. and N. Modadugu, &ldquo;Datagram Transport Layer Security,&rdquo; April&nbsp;2006.</span><span>)</span></a> is a channel security protocol that offers
      integrated key management, parameter negotiation, and secure data
      transfer. Because DTLS's data transfer protocol is generic, it is less
      highly optimized for use with RTP than is SRTP, which has been
      specifically tuned for that purpose.
</p>
<p>This document describes DTLS-SRTP, an SRTP extension for DTLS which
      combine the performance and encryption flexibility benefits of SRTP with
      the flexibility and convenience of DTLS's integrated key and association
      management. DTLS-SRTP can be viewed in two equivalent ways: as a new key
      management method for SRTP, and a new RTP-specific data format for
      DTLS.
</p>
<p>The key points of DTLS-SRTP are that: </p>
<ul class="text">
<li>application data is protected using SRTP,
</li>
<li>the DTLS handshake is used to establish keying material,
          algorithms, and parameters for SRTP,
</li>
<li>a DTLS extension used to negotiate SRTP algorithms, and
</li>
<li>other DTLS record layer content types are protected using the
          ordinary DTLS record format.
</li>
</ul><p> 
</p>
<p>The remainder of this memo is structured as follows. <a class='info' href='#sec-conv'>Section&nbsp;2<span> (</span><span class='info'>Conventions Used In This Document</span><span>)</span></a>
     describes conventions used to indicate normative requirements.
     <a class='info' href='#sec-overview'>Section&nbsp;3<span> (</span><span class='info'>Overview of DTLS-SRTP Operation</span><span>)</span></a>
     provides an overview of DTLS-SRTP operation. 
     <a class='info' href='#sec-extension'>Section&nbsp;4<span> (</span><span class='info'>DTLS Extensions for SRTP Key Establishment</span><span>)</span></a>
     specifies the DTLS extensions, while 
     <a class='info' href='#sec-data-prot'>Section&nbsp;5<span> (</span><span class='info'>Use of RTP and RTCP over a DTLS-SRTP Channel</span><span>)</span></a> discusses how
     RTP and RTCP are transported over a DTLS-SRTP channel.
     <a class='info' href='#sec-multiparty'>Section&nbsp;6<span> (</span><span class='info'>Multi-party RTP Sessions</span><span>)</span></a>
     describes use with multi-party sessions. 
     <a class='info' href='#section.sec'>Section&nbsp;7<span> (</span><span class='info'>Security Considerations</span><span>)</span></a> and <a class='info' href='#section.iana'>Section&nbsp;8<span> (</span><span class='info'>IANA Considerations</span><span>)</span></a>
     describe Security and IANA considerations.
     
</p>
<a name="sec-conv"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2"></a><h3>2.&nbsp;
Conventions Used In This Document</h3>

<p>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
      "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
      document are to be interpreted as described in <a class='info' href='#RFC2119'>[1]<span> (</span><span class='info'>Bradner, S., &ldquo;Key words for use in RFCs to Indicate Requirement Levels,&rdquo; March&nbsp;1997.</span><span>)</span></a>.
</p>
<a name="sec-overview"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3"></a><h3>3.&nbsp;
Overview of DTLS-SRTP Operation</h3>

<p>
        DTLS-SRTP is defined for point-to-point media sessions, in
        which there are exactly two participants.  Each DTLS-SRTP
        session contains a single DTLS association (called a
        "connection" in TLS jargon), and an SRTP context.  
        A single DTLS-SRTP session only protects data 
        carried over a single UDP source and destination port pair.
        
</p>
<p>
	The general pattern of DTLS-SRTP is as follows. For each
	RTP or RTCP flow the peers do a DTLS handshake on the same source
	and destination port pair to establish a DTLS association.
	The keying material from that handshake is fed into the
	SRTP stack. Once that association is established, RTP packets
	are protected (becoming SRTP) using that keying material.
</p>
<p>
     RTP and RTCP traffic is usually sent on two separate UDP ports.
     When symmetric RTP <a class='info' href='#RFC4961'>[9]<span> (</span><span class='info'>Wing, D., &ldquo;Symmetric RTP / RTP Control Protocol (RTCP),&rdquo; July&nbsp;2007.</span><span>)</span></a> is used, two bidirectional DTLS-SRTP
     sessions are needed, one for the RTP port, one for the RTCP port.
     When RTP flows are not symmetric, four unidirectional DTLS-SRTP
     sessions are needed (for inbound and outbound RTP, and inbound
     and outbound RTCP).
     
</p>
<p>
          Symmetric RTP <a class='info' href='#RFC4961'>[9]<span> (</span><span class='info'>Wing, D., &ldquo;Symmetric RTP / RTP Control Protocol (RTCP),&rdquo; July&nbsp;2007.</span><span>)</span></a> is the case in which there are two RTP
          sessions that have their source and destination ports
          and addresses reversed, in a manner similar to the way
          that a TCP connection uses its ports.  Each participant
          has an inbound RTP session and an outbound RTP session.
          When symmetric RTP is used, a single DTLS-SRTP session
          can protect both of the RTP sessions.  
         
</p>
<p>
     RTP and RTCP traffic MAY be multiplexed on a single UDP port [7].
     In this case, both RTP and RTCP packets may be sent over the same
     DTLS-SRTP session, halving the number of DTLS-SRTP sessions needed.
     It is RECOMMENDED that symmetric RTP is used, with RTP and RTCP
     multiplexed on a single UDP port; this requires only a single
     DTLS-SRTP session.
        
</p>
<p> Between a single pair of participants, there may be
          multiple media sessions.  There MUST be a separate DTLS-SRTP
          session for each distinct pair of source and destination
          ports used by a media session (though the sessions can
	  share a single DTLS session and hence amortize the initial
	  public key handshake!).
</p>
<p>A DTLS-SRTP session MAY be indicated by an external signaling
        protocol like SIP. When the signaling exchange is integrity-protected
        (e.g when SIP Identity protection via digital signatures is used),
        DTLS-SRTP can leverage this integrity guarantee to provide complete
        security of the media stream. A description of how to indicate
        DTLS-SRTP sessions in SIP and SDP, and how to authenticate the
        endpoints using fingerprints can be found in <a class='info' href='#I-D.fischl-mmusic-sdp-dtls'>[12]<span> (</span><span class='info'>Fischl, J. and H. Tschofenig, &ldquo;Session Description Protocol (SDP) Indicators for Datagram Transport Layer  Security (DTLS),&rdquo; November&nbsp;2007.</span><span>)</span></a> and <a class='info' href='#I-D.fischl-sipping-media-dtls'>[11]<span> (</span><span class='info'>Fischl, J., &ldquo;Datagram Transport Layer Security (DTLS) Protocol for Protection of Media  Traffic Established with the Session Initiation Protocol,&rdquo; July&nbsp;2007.</span><span>)</span></a>.
	
</p>
<p>In a naive implementation, when there are multiple media
        sessions, there is a new DTLS session establishment (complete
        with public key cryptography) for each media channel. For
        example, a videophone may be sending both an audio stream and
        a video stream, each of which would use a separate DTLS
        session establishment exchange, which would proceed in
        parallel. As an optimization, the DTLS-SRTP implementation
        SHOULD use the following strategy: a single DTLS connection is
        established, and all other DTLS sessions wait until that
        connection is established before proceeding with their session
        establishment exchanges. This strategy allows the later
        sessions to use the DTLS session re-start, which allows the
        amortization of the expensive public key cryptography
        operations over multiple DTLS session establishment
        instances.
</p>
<p>The SRTP keys used to protect packets originated by the client are
        distinct from the SRTP keys used to protect packets originated by the
        server. All of the RTP sources originating on the client use the same
        SRTP keys, and similarly, all of the RTP sources originating on the
        server over the same channel use the same SRTP keys. The SRTP
        implementation MUST ensure that all of the SSRC values for all of the
        RTP sources originating from the same device are distinct, in order to
        avoid the "two-time pad" problem (as described in Section 9.1 of RFC
        3711).
</p>
<a name="sec-extension"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4"></a><h3>4.&nbsp;
DTLS Extensions for SRTP Key Establishment</h3>

<a name="anchor2"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.1"></a><h3>4.1.&nbsp;
The use_srtp Extension</h3>

<p>In order to negotiate the use of SRTP data protection, clients 
        include an extension of type "use_srtp" in the DTLS extended client hello. 
        This extension MUST only be used when the data being transported is
        RTP and RTCP <a class='info' href='#RFC3550'>[3]<span> (</span><span class='info'>Schulzrinne, H., Casner, S., Frederick, R., and V. Jacobson, &ldquo;RTP: A Transport Protocol for Real-Time Applications,&rdquo; July&nbsp;2003.</span><span>)</span></a>.
        The "extension_data" field of this extension contains the list of
        acceptable SRTP protection profiles, as indicated below.
</p>
<p>Servers that receive an extended hello containing a "use_srtp"
        extension can agree to use SRTP by including an extension of type
        "use_srtp", with the chosen protection profile in the extended server
        hello. This process is shown below.
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
      Client                                               Server

      ClientHello + use_srtp       --------&gt;
                                           ServerHello + use_srtp
                                                     Certificate*
                                               ServerKeyExchange*
                                              CertificateRequest*
                                   &lt;--------      ServerHelloDone
      Certificate*
      ClientKeyExchange
      CertificateVerify*
      [ChangeCipherSpec]
      Finished                     --------&gt;
                                               [ChangeCipherSpec]
                                   &lt;--------             Finished
      SRTP packets                 &lt;-------&gt;      SRTP packets
</pre></div>
<p>Note that '*' indicates messages which are not always
	sent in DTLS. The CertificateRequest, client Certificate,
	and CertificateVerify will be sent in DTLS-SRTP.
</p>
<p>
         Once the "use_srtp" extension is negotiated, the RTP or RTCP
         application data is protected solely using SRTP. Application
         data is never sent in DTLS record-layer "application_data"
         packets. Rather, complete RTP or RTCP packets are passed to
         the DTLS stack which passes them to the SRTP stack which
         protects them appropriately. Note that if RTP/RTCP
         multiplexing <a class='info' href='#I-D.ietf-avt-rtp-and-rtcp-mux'>[10]<span> (</span><span class='info'>Perkins, C. and M. Westerlund, &ldquo;Multiplexing RTP Data and Control Packets on a Single Port,&rdquo; August&nbsp;2007.</span><span>)</span></a>
         is in use, this means that RTP and RTCP packets may both be
         passed to the DTLS stack. Because the DTLS layer
	 does not process the packets, it does need to distinguish
	 them. The SRTP stack can use the procedures of 
	 <a class='info' href='#I-D.ietf-avt-rtp-and-rtcp-mux'>[10]<span> (</span><span class='info'>Perkins, C. and M. Westerlund, &ldquo;Multiplexing RTP Data and Control Packets on a Single Port,&rdquo; August&nbsp;2007.</span><span>)</span></a> to
	 distinguish RTP from RTCP. 
	 
</p>
<p>
	 When the "use_srtp" extension is in
         effect, implementations MUST NOT place more than one "record"
         per datagram. (This is only meaningful from the perspective of
         DTLS because SRTP is inherently oriented towards one payload
         per packet, but is stated purely for clarification.)
</p>
<p>Records of type other than "application_data" MUST
         use ordinary DTLS framing.
</p>
<a name="anchor3"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.1.1"></a><h3>4.1.1.&nbsp;
use_srtp Extension Definition</h3>

<p>The client MUST fill the extension_data field of the "use_srtp"
          extension with an UseSRTPData value (see <a class='info' href='#section.iana'>Section&nbsp;8<span> (</span><span class='info'>IANA Considerations</span><span>)</span></a>  for the registration):
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
   uint8 SRTPProtectionProfile[2];

   struct {
      SRTPProtectionProfiles SRTPProtectionProfiles;
      uint8 srtp_mki&lt;0..255&gt;;
   } UseSRTPData;

   SRTPProtectionProfile SRTPProtectionProfiles&lt;2^16-1&gt;;
</pre></div>
<p>The SRTPProtectionProfiles list indicates the SRTP protection
          profiles that the client is willing to support, listed in descending
          order of preference. The srtp_mki value contains the SRTP
          MasterKeyIdentifier (MKI) value (if any) which the client will use
          for his SRTP messages. If this field is of zero length,
	  then no MKI will be used.
</p>
<p>If the server is willing to accept the use_srtp extension, it
          MUST respond with its own "use_srtp" extension in the
          ExtendedServerHello. The extension_data field MUST contain a
          UseSRTPData value with a single SRTPProtectionProfile value which
          the server has chosen for use with this connection. The server MUST
          NOT select a value which the client has not offered. If there is no
          shared profile, the server SHOULD not return the use_srtp extension
          at which point the connection falls back to the negotiated DTLS
          cipher suite. If that is not acceptable the server SHOULD return an
          appropriate DTLS alert.
</p>
<a name="section.propro"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.1.2"></a><h3>4.1.2.&nbsp;
SRTP Protection Profiles</h3>

<p>A DTLS-SRTP SRTP Protection Profile defines the parameters and
          options that are in effect for the SRTP processing. This document
          defines the following SRTP protection profiles.
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
   SRTPProtectionProfile SRTP_AES128_CM_SHA1_80 = {0x00, 0x01};
   SRTPProtectionProfile SRTP_AES128_CM_SHA1_32 = {0x00, 0x02};
   SRTPProtectionProfile SRTP_AES256_CM_SHA1_80 = {0x00, 0x03};
   SRTPProtectionProfile SRTP_AES256_CM_SHA1_32 = {0x00, 0x04};
   SRTPProtectionProfile SRTP_NULL_SHA1_80      = {0x00, 0x05};
   SRTPProtectionProfile SRTP_NULL_SHA1_32      = {0x00, 0x06};
</pre></div>
<p>The following list indicates the SRTP transform
          parameters for each protection profile. The parameters
          cipher_key_length, cipher_salt_length, auth_key_length, and
          auth_tag_length express the number of bits in the values to
          which they refer. The maximum_lifetime parameter indicates
          the maximum number of packets that can be protected with
          each single set of keys when the parameter profile is in
          use.  All of these parameters apply to both RTP and RTCP,
          unless the RTCP parameters are separately specified.
	  
</p>
<p>
	    All of the crypto algorithms in these profiles are from
	    <a class='info' href='#RFC3711'>[7]<span> (</span><span class='info'>Baugher, M., McGrew, D., Naslund, M., Carrara, E., and K. Norrman, &ldquo;The Secure Real-time Transport Protocol (SRTP),&rdquo; March&nbsp;2004.</span><span>)</span></a>, except for the AES256_CM cipher,
	    which is specified in
	    <a class='info' href='#I-D.mcgrew-srtp-big-aes'>[14]<span> (</span><span class='info'>McGrew, D., &ldquo;The use of AES-192 and AES-256 in Secure RTP,&rdquo; March&nbsp;2009.</span><span>)</span></a>.
	    
</p>
<p></p>
<blockquote class="text"><dl>
<dt>SRTP_AES128_CM_HMAC_SHA1_80</dt>
<dd>
<blockquote class="text"><dl>
<dt></dt>
<dd>cipher: AES_128_CM
</dd>
<dt></dt>
<dd>cipher_key_length: 128
</dd>
<dt></dt>
<dd>cipher_salt_length: 112
</dd>
<dt></dt>
<dd>maximum_lifetime: 2^31
</dd>
<dt></dt>
<dd>auth_function: HMAC-SHA1
</dd>
<dt></dt>
<dd>auth_key_length: 160
</dd>
<dt></dt>
<dd>auth_tag_length: 80
</dd>
</dl></blockquote>
</dd>
<dt>SRTP_AES128_CM_HMAC_SHA1_32</dt>
<dd>
		
<blockquote class="text"><dl>
<dt></dt>
<dd>cipher: AES_128_CM
</dd>
<dt></dt>
<dd>cipher_key_length: 128
</dd>
<dt></dt>
<dd>cipher_salt_length: 112
</dd>
<dt></dt>
<dd>maximum_lifetime: 2^31
</dd>
<dt></dt>
<dd>auth_function: HMAC-SHA1
</dd>
<dt></dt>
<dd>auth_key_length: 160
</dd>
<dt></dt>
<dd>auth_tag_length: 32
</dd>
<dt></dt>
<dd>RTCP auth_tag_length: 80
</dd>
</dl></blockquote>
</dd>
<dt>SRTP_AES256_CM_HMAC_SHA1_80</dt>
<dd>
<blockquote class="text"><dl>
<dt></dt>
<dd>cipher: AES_128_CM
</dd>
<dt></dt>
<dd>cipher_key_length: 128
</dd>
<dt></dt>
<dd>cipher_salt_length: 112
</dd>
<dt></dt>
<dd>maximum_lifetime: 2^31
</dd>
<dt></dt>
<dd>auth_function: HMAC-SHA1
</dd>
<dt></dt>
<dd>auth_key_length: 160
</dd>
<dt></dt>
<dd>auth_tag_length: 80
</dd>
</dl></blockquote>
</dd>
<dt>SRTP_AES256_CM_HMAC_SHA1_32</dt>
<dd>
		
<blockquote class="text"><dl>
<dt></dt>
<dd>cipher: AES_128_CM
</dd>
<dt></dt>
<dd>cipher_key_length: 128
</dd>
<dt></dt>
<dd>cipher_salt_length: 112
</dd>
<dt></dt>
<dd>maximum_lifetime: 2^31
</dd>
<dt></dt>
<dd>auth_function: HMAC-SHA1
</dd>
<dt></dt>
<dd>auth_key_length: 160
</dd>
<dt></dt>
<dd>auth_tag_length: 32
</dd>
<dt></dt>
<dd>RTCP auth_tag_length: 80
</dd>
</dl></blockquote>
</dd>
<dt>SRTP_NULL_HMAC_SHA1_80</dt>
<dd>
<blockquote class="text"><dl>
<dt></dt>
<dd>cipher: NULL
</dd>
<dt></dt>
<dd>cipher_key_length: 0
</dd>
<dt></dt>
<dd>cipher_salt_length: 0
</dd>
<dt></dt>
<dd>maximum_lifetime: 2^31
</dd>
<dt></dt>
<dd>auth_function: HMAC-SHA1
</dd>
<dt></dt>
<dd>auth_key_length: 160
</dd>
<dt></dt>
<dd>auth_tag_length: 80
</dd>
</dl></blockquote>
</dd>
<dt>SRTP_NULL_HMAC_SHA1_32</dt>
<dd>
		
<blockquote class="text"><dl>
<dt></dt>
<dd>cipher: NULL
</dd>
<dt></dt>
<dd>cipher_key_length: 0
</dd>
<dt></dt>
<dd>cipher_salt_length: 0
</dd>
<dt></dt>
<dd>maximum_lifetime: 2^31
</dd>
<dt></dt>
<dd>auth_function: HMAC-SHA1
</dd>
<dt></dt>
<dd>auth_key_length: 160
</dd>
<dt></dt>
<dd>auth_tag_length: 32
</dd>
<dt></dt>
<dd>RTCP auth_tag_length: 80
</dd>
</dl></blockquote>
</dd>
</dl></blockquote><p> 
	    
</p>
<p>
	    With all of these SRTP Parameter profiles, the following
          SRTP options are in effect:
	  
</p>
<p></p>
<ul class="text">
<li>The TLS Key Derivation Function (KDF) is used to generate
              keys to feed into the SRTP KDF.
</li>
<li>The Key Derivation Rate (KDR) is equal to zero. Thus, keys
              are not re-derived based on the SRTP sequence number.
</li>
<li>For all other parameters, the default values are used.
</li>
</ul>

<p> All SRTP parameters that are not determined by the SRTP
          Protection Profile MAY be established via the signaling system. In
          particular, the relative order of Forward Error Correction and SRTP
          processing, and a suggested SRTP replay window size SHOULD be
          established in this manner. An example of how these parameters can
          be defined for SDP by is contained in <a class='info' href='#RFC4568'>[8]<span> (</span><span class='info'>Andreasen, F., Baugher, M., and D. Wing, &ldquo;Session Description Protocol (SDP) Security Descriptions for Media Streams,&rdquo; July&nbsp;2006.</span><span>)</span></a>. If they are not otherwise signalled,
	  they take on their default values from <a class='info' href='#RFC3711'>[7]<span> (</span><span class='info'>Baugher, M., McGrew, D., Naslund, M., Carrara, E., and K. Norrman, &ldquo;The Secure Real-time Transport Protocol (SRTP),&rdquo; March&nbsp;2004.</span><span>)</span></a>.
</p>
<p>
	    Applications using DTLS-SRTP SHOULD coordinate the SRTP
	    Protection Profiles between the DTLS-SRTP session that
	    protects an RTP flow and the DTLS-SRTP session that
	    protects the associated RTCP flow (in those case in which
	    the RTP and RTCP are not multiplexed over a common port).
	    In particular, identical ciphers SHOULD be used.
	    
</p>
<p>New SRTPProtectionProfile values must be defined by RFC 2434
          Standards Action. See  <a class='info' href='#section.iana'>Section&nbsp;8<span> (</span><span class='info'>IANA Considerations</span><span>)</span></a>
          for IANA Considerations.
</p>
<a name="anchor4"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.1.3"></a><h3>4.1.3.&nbsp;
srtp_mki value</h3>

<p>The srtp_mki value MAY be used to indicate the capability and
          desire to use the SRTP Master Key Indicator (MKI) field in the SRTP
          and SRTCP packets. The MKI field indicates to an SRTP receiver which
          key was used to protect the packet that contains that field. The
          srtp_mki field contains the value of the SRTP MKI which is
          associated with the SRTP master keys derived from this handshake.
          Each SRTP session MUST have exactly one master key that is used to
          protect packets at any given time. The client MUST choose the MKI
          value so that it is distinct from the last MKI value that was used,
          and it SHOULD make these values unique.
</p>
<p>Upon receipt of a "use_srtp" extension containing a "srtp_mki"
          field, the server MUST either (assuming it accepts the extension at
          all):
</p>
<p></p>
<ol class="text">
<li>include a matching "srtp_mki" value in its "use_srtp"
              extension to indicate that it will make use of the MKI, or
</li>
<li>return an empty "srtp_mki" value to indicate that it cannot
              make use of the MKI.
</li>
</ol>

<p>If the client detects a nonzero-length MKI in the server's
          response that is different than the one the client offered MUST
          abort the handshake and SHOULD send an invalid_parameter alert. If
          the client and server agree on an MKI, all SRTP packets protected
          under the new security parameters MUST contain that MKI.
</p>
<a name="keyDeriv"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.2"></a><h3>4.2.&nbsp;
Key Derivation</h3>

<p>When SRTP mode is in effect, different keys are used for ordinary
        DTLS record protection and SRTP packet protection. These keys are
        generated using a TLS extractor <a class='info' href='#I-D.rescorla-tls-extractor'>[15]<span> (</span><span class='info'>Rescorla, E., &ldquo;Keying Material Extractors for Transport Layer Security (TLS),&rdquo; November&nbsp;2007.</span><span>)</span></a> to generate 
	2 * (SRTPSecurityParams.master_key_len + SRTPSecurityParams.master_salt_len) bytes of data, which are assigned as shown below.
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
client_write_SRTP_master_key[SRTPSecurityParams.master_key_len];
server_write_SRTP_master_key[SRTPSecurityParams.master_key_len];
client_write_SRTP_master_salt[SRTPSecurityParams.master_salt_len];
server_write_SRTP_master_salt[SRTPSecurityParams.master_salt_len];
</pre></div>
<p>The extractor label for this usage is "dtls_srtp".
	
</p>
<p>The four keying material values
	are provided as inputs to the SRTP key
        derivation mechanism, as shown in <a class='info' href='#KeyFig'>Figure&nbsp;1<span> (</span><span class='info'>The derivation of the SRTP keys.</span><span>)</span></a> and
        detailed below. By default, the mechanism defined in Section 4.3 of
        <a class='info' href='#RFC3711'>[7]<span> (</span><span class='info'>Baugher, M., McGrew, D., Naslund, M., Carrara, E., and K. Norrman, &ldquo;The Secure Real-time Transport Protocol (SRTP),&rdquo; March&nbsp;2004.</span><span>)</span></a> is used, unless another key derivation
        mechanism is specified as part of an SRTP Protection Profile.
</p>
<p>The client_write_SRTP_master_key and client_write_SRTP_master_salt
        are provided to one invocation of the SRTP key derivation function, to
        generate the SRTP keys used to encrypt and authenticate packets sent
        by the client. The server MUST only use these keys to decrypt and to
        check the authenticity of inbound packets.
</p>
<p>The server_write_SRTP_master_key and server_write_SRTP_master_salt
        are provided to one invocation of the SRTP key derivation function, to
        generate the SRTP keys used to encrypt and authenticate packets sent
        by the server. The client MUST only use these keys to decrypt and to
        check the authenticity of inbound packets.
</p><br /><hr class="insert" />
<a name="KeyFig"></a>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
    +------- TLS master secret
    |
    v    +-&gt; client_write_MAC_secret
+-----+  |
| TLS |--+-&gt; server_write_MAC_secret
| KDF |  |
+-----+  +-&gt; client_write_key
         |
         +-&gt; server_write_key
         |                                       +------+   SRTP
         +-&gt; client_write_SRTP_master_key  -----&gt;| SRTP |-&gt; client
         |                                  +---&gt;|  KDF |   write
         +-&gt; server_write_SRTP_master_key --|-+  +------+   keys
         |                                  | |
         +-&gt; client_write_SRTP_master_salt -+ |  +------+   SRTP
         |                                    +-&gt;| SRTP |-&gt; server
         +-&gt; server_write_SRTP_master_salt -----&gt;|  KDF |   write
                                                 +------+   keys
</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;1: The derivation of the SRTP keys.&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>
	  When both RTCP and RTP use the same source and destination
	  ports, then both the SRTP and SRTCP keys are need.
	  Otherwise, there are two DTLS-SRTP sessions, one of which
	  protects the RTP packets and one of which protects the RTCP
	  packets; each DTLS-SRTP session protects the part of an SRTP
	  session that passes over a single source/destination
	  transport address pair, as shown in
	  <a class='info' href='#SessionFig'>Figure&nbsp;2<span> (</span><span class='info'>A DTLS-SRTP session protecting RTP (1) and another one protecting RTCP (2), showing the transport addresses and keys used.</span><span>)</span></a>.  When a DTLS-SRTP session is
	  protecting RTP, the SRTCP keys derived from the DTLS
	  handshake are not needed and are discarded.  When a
	  DTLS-SRTP session is protecting RTCP, the SRTP keys derived
	  from the DTLS handshake are not needed and are discarded.
	  
</p><br /><hr class="insert" />
<a name="SessionFig"></a>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
   Client            Server
  (Sender)         (Receiver)
(1)   &lt;----- DTLS ------&gt;    src/dst = a/b and b/a
      ------ SRTP ------&gt;    src/dst = a/b, uses client write keys

(2)   &lt;----- DTLS ------&gt;    src/dst = c/d and d/c
      ------ SRTCP -----&gt;    src/dst = c/d, uses client write keys
      &lt;----- SRTCP ------    src/dst = d/c, uses server write keys
</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;2: A DTLS-SRTP session protecting RTP (1) and another one protecting RTCP (2), showing the transport addresses and keys used.&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>
</p>
<a name="anchor5"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.3"></a><h3>4.3.&nbsp;
Key Scope</h3>

<p>Because of the possibility of packet reordering, DTLS-SRTP
        implementations SHOULD store multiple SRTP keys sets during a re-key
        in order to avoid the need for receivers to drop packets for which
        they lack a key.
</p>
<a name="anchor6"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.4"></a><h3>4.4.&nbsp;
Key Usage Limitations</h3>

<p>The maximum_lifetime parameter in the SRTP protection
        profile indicates the maximum number of packets that can be
        protected with each single encryption and authentication
        key. (Note that, since RTP and RTCP are protected with
        independent keys, those protocols are counted separately for
        the purposes of determining when a key has reached the end of
        its lifetime.) Each profile defines its own limit. When this
        limit is reached, a new DTLS session SHOULD be used to
        establish replacement keys, and SRTP implementations MUST NOT
        use the existing keys for the processing of either outbound or
        inbound traffic.
</p>
<a name="sec-data-prot"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5"></a><h3>5.&nbsp;
Use of RTP and RTCP over a DTLS-SRTP Channel</h3>

<a name="anchor7"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.1"></a><h3>5.1.&nbsp;
Data Protection</h3>

<p>Once the DTLS handshake has completed the peers can send RTP or
        RTCP over the newly created channel. We describe the transmission
        process first followed by the reception process.
</p>
<p>Within each RTP session, SRTP processing MUST NOT take place before
        the DTLS handshake completes.
</p>
<a name="section.transmit"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.1.1"></a><h3>5.1.1.&nbsp;
Transmission</h3>

<p>DTLS and TLS define a number of record content types. In ordinary
          TLS/DTLS, all data is protected using the same record encoding and
          mechanisms. When the mechanism described in this document is in
          effect, this is modified so that data of type "application_data"
          (used to transport data traffic) is encrypted using SRTP rather than
          the standard TLS record encoding.
</p>
<p>When a user of DTLS wishes to send an RTP packet in SRTP mode it
          delivers it to the DTLS implementation as a single write of type
          "application_data". The DTLS implementation then invokes the
          processing described in RFC 3711 Sections 3 and 4. The resulting
          SRTP packet is then sent directly on the wire as a single datagram
          with no DTLS framing. This provides an encapsulation of the data
          that conforms to and interoperates with SRTP. Note that the RTP
          sequence number rather than the DTLS sequence number is used for
          these packets.
</p>
<a name="anchor8"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.1.2"></a><h3>5.1.2.&nbsp;
Reception</h3>

<p>When DTLS-SRTP is used to protect an RTP session, the RTP
          receiver needs to demultiplex packets that are arriving on the RTP
          port. Arriving packets may be of types RTP, DTLS, or STUN<a class='info' href='#I-D.ietf-behave-rfc3489bis'>[13]<span> (</span><span class='info'>Rosenberg, J., Mahy, R., Matthews, P., and D. Wing, &ldquo;Session Traversal Utilities for (NAT) (STUN),&rdquo; July&nbsp;2008.</span><span>)</span></a>. The type of a packet
          can be determined by looking at its first byte.
</p>
<p>The process for demultiplexing a packet is as
          follows. The receiver looks at the first byte of the
          packet. If the value of this byte is 0 or 1, then the packet
          is STUN. If the value is in between 128 and 191 (inclusive),
          then the packet is RTP (or RTCP, if both RTCP and RTP are
          being multiplexed over the same destination port). If the
          value is between 20 and 63 (inclusive), the packet is
          DTLS. This processes is summarized
          in <a class='info' href='#demuxFig'>Figure&nbsp;3<span> (</span><span class='info'>The DTLS-SRTP receiver's packet demultiplexing     algorithm.  Here the field B denotes the leading byte of the packet.</span><span>)</span></a>.
</p><br /><hr class="insert" />
<a name="demuxFig"></a>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
                +----------------+
                | 127 &lt; B &lt; 192 -+--&gt; forward to RTP
                |                |
    packet --&gt;  |  19 &lt; B &lt; 64  -+--&gt; forward to DTLS
                |                |
                |       B &lt; 2   -+--&gt; forward to STUN
                +----------------+
</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;3: The DTLS-SRTP receiver's packet demultiplexing     algorithm.  Here the field B denotes the leading byte of the packet.&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<a name="section.rehandshake"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.2"></a><h3>5.2.&nbsp;
Rehandshake and Re-key</h3>

<p>Rekeying in DTLS is accomplished by performing a new handshake over
        the existing DTLS channel. This handshake can be performed in parallel
        with data transport, so no interruption of the data flow is required.
        Once the handshake is finished, the newly derived set of keys is used
        to protect all outbound packets, both DTLS and SRTP.
</p>
<p>Because of packet reordering, packets protected by the previous set
        of keys can appear on the wire after the handshake has completed. To
        compensate for this fact, receivers SHOULD maintain both sets of keys
        for some time in order to be able to decrypt and verify older packets.
        The keys should be maintained for the duration of the maximum segment
        lifetime (MSL).
</p>
<p>If an MKI is used, then the receiver should use the
        corresponding set of keys to process an incoming
        packet. Otherwise, when a packet arrives after the handshake
        completed, a receiver SHOULD use the newly derived set of keys
        to process that packet unless there is an MKI (If the packet
        was protected with the older set of keys, this fact will
        become apparent to the receiver as an authentication failure
        will occur.)  
	If the authentication check on the packet fails and no MKI is being
	used, then the receiver MAY
        process the packet with the older set of keys. If that authentication
        check indicates that the packet is valid, the packet should be
        accepted; otherwise, the packet MUST be discarded and rejected.
</p>
<p>Receivers MAY use the SRTP packet sequence number to aid in the
        selection of keys. After a packet has been received and authenticated
        with the new key set, any packets with sequence numbers that are
        greater will also have been protected with the new key set.
</p>
<a name="sec-multiparty"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6"></a><h3>6.&nbsp;
Multi-party RTP Sessions</h3>

<p>Since DTLS is a point-to-point protocol, DTLS-SRTP is intended only
      to protect RTP flow in which there are exactly two participants.
      This does not preclude its use with RTP mixers. For example, a
      conference bridge may use DTLS-SRTP to secure the communication to and
      from each of the participants in a conference. However, because
      each flow between an endpoint and a mixer has its own key,
      the mixer has to decrypt and then reencrypt the traffic for each
      recipient.
</p>
<p>A future specification
      may describe methods for sharing a single key between multiple
      DTLS-SRTP associations which would allow conferencing systems
      to avoid the decrypt/reencrypt stage. However, any system in
      which the media is modified (e.g., for level balancing or
      transcoding) will generally need to be performed on the plaintext
      and will certainly break the authentication tag and therefore
      will require a decrypt/reencrypt stage.
</p>
<a name="anchor9"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.1"></a><h3>6.1.&nbsp;
SIP Forking</h3>

<p>When SIP parallel forking occurs while establishing an RTP flow
        a situation may arise in which two or more sources are sending RTP
        packets to a single RTP destination transport address. When this
        situation arises and DTLS-SRTP is in use, the receiver MUST use the
        source transport IP address and port of each packet to distinguish
        between the senders, and treat the flow of packets from each distinct
        source transport address as a distinct DTLS-SRTP session for the
        purposes of the DTLS association.
</p>
<p>When SIP forking occurs, the following method can be used to 
	correlate each answer to the corresponding DTLS-SRTP session. 
	If the answers have different certificates then fingerprints
	in the answers can be used to correlate the SIP dialogs
	with the associated DTLS session. Note that two forks
	with the same certificate cannot be distinguished at the
	DTLS level, but this problem is a generic problem with 
	SIP forking and should be solved at a higher level.
	
</p>
<a name="section.sec"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7"></a><h3>7.&nbsp;
Security Considerations</h3>

<p>The use of multiple data protection framings negotiated in the same
      handshake creates some complexities, which are discussed here.
</p>
<a name="anchor10"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.1"></a><h3>7.1.&nbsp;
Security of Negotiation</h3>

<p>One concern here is that attackers might be able to implement a
        bid-down attack forcing the peers to use ordinary DTLS rather than
        SRTP. However, because the negotiation of this extension is performed
        in the DTLS handshake, it is protected by the Finished messages.
        Therefore, any bid-down attack is automatically detected, which
        reduces this to a denial of service attack - which any attacker who
        can control the channel can always mount.
</p>
<a name="anchor11"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.2"></a><h3>7.2.&nbsp;
Framing Confusion</h3>

<p>Because two different framing formats are used, there is concern
        that an attacker could convince the receiver to treat an SRTP-framed
        RTP packet as a DTLS record (e.g., a handshake message) or vice versa.
        This attack is prevented by using different keys for MAC verification
        for each type of data. Therefore, this type of attack reduces to being
        able to forge a packet with a valid MAC, which violates a basic
        security invariant of both DTLS and SRTP.
</p>
<p>As an additional defense against injection into the DTLS handshake
        channel, the DTLS record type is included in the MAC. Therefore, an
        SRTP record would be treated as an unknown type and ignored. (See
        Section 6 of <a class='info' href='#RFC4346'>[4]<span> (</span><span class='info'>Dierks, T. and E. Rescorla, &ldquo;The Transport Layer Security (TLS) Protocol Version 1.1,&rdquo; April&nbsp;2006.</span><span>)</span></a>).
</p>
<a name="anchor12"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.3"></a><h3>7.3.&nbsp;
Sequence Number Interactions</h3>

<p>As described in  <a class='info' href='#section.transmit'>Section&nbsp;5.1.1<span> (</span><span class='info'>Transmission</span><span>)</span></a>,
        the SRTP and DTLS sequence number spaces are distinct. This means that
        it is not possible to unambiguously order a given DTLS control record
        with respect to an SRTP packet. In general, this is relevant in two
        situations: alerts and rehandshake.
</p>
<a name="anchor13"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.3.1"></a><h3>7.3.1.&nbsp;
Alerts</h3>

<p>Because DTLS handshake and change_cipher_spec messages share the
          same sequence number space as alerts, they can be ordered correctly.
          Because DTLS alerts are inherently unreliable and SHOULD NOT be
          generated as a response to data packets, reliable sequencing between
          SRTP packets and DTLS alerts is not an important feature. However,
          implementations which wish to use DTLS alerts to signal problems
          with the SRTP encoding SHOULD simply act on alerts as soon as they
          are received and assume that they refer to the temporally contiguous
          stream. Such implementations MUST check for alert retransmission and
          discard retransmitted alerts to avoid overreacting to replay
          attacks.
</p>
<a name="anchor14"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.3.2"></a><h3>7.3.2.&nbsp;
Renegotiation</h3>

<p>Because the rehandshake transition algorithm specified in Section
          <a class='info' href='#section.rehandshake'>Section&nbsp;5.2<span> (</span><span class='info'>Rehandshake and Re-key</span><span>)</span></a> requires trying multiple
          sets of keys if no MKI is used, it slightly weakens the authentication. For instance,
          if an n-bit MAC is used and k different sets of keys are present,
          then the MAC is weakened by log_2(k) bits to n - log_2(k). In
          practice, since the number of keys used will be very small and the
          MACs in use are typically strong (the default for SRTP is 80 bits)
          the decrease in security involved here is minimal.
</p>
<p>Another concern here is that this algorithm slightly increases
          the work factor on the receiver because it needs to attempt multiple
          validations. However, again, the number of potential keys will be
          very small (and the attacker cannot force it to be larger) and this
          technique is already used for rollover counter management, so the
          authors do not consider this to be a serious flaw.
</p>
<a name="section.iana"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.8"></a><h3>8.&nbsp;
IANA Considerations</h3>

<p>This document a new extension for DTLS, in accordance with <a class='info' href='#RFC4366'>[6]<span> (</span><span class='info'>Blake-Wilson, S., Nystrom, M., Hopwood, D., Mikkelsen, J., and T. Wright, &ldquo;Transport Layer Security (TLS) Extensions,&rdquo; April&nbsp;2006.</span><span>)</span></a>:
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>     enum { use_srtp (??) } ExtensionType;
</pre></div>
<p>[[ NOTE: This value needs to be assigned by IANA ]]
</p>
<p>This extension MUST only be used with DTLS, and not with TLS.
</p>
<p> <a class='info' href='#section.propro'>Section&nbsp;4.1.2<span> (</span><span class='info'>SRTP Protection Profiles</span><span>)</span></a> requires that all
      SRTPProtectionProfile values be defined by RFC 2434 Standards Action.
      IANA SHOULD create a DTLS SRTPProtectionProfile registry initially
      populated with values from  <a class='info' href='#section.propro'>Section&nbsp;4.1.2<span> (</span><span class='info'>SRTP Protection Profiles</span><span>)</span></a>
      of this document. Future values MUST be allocated via Standards Action
      as described in <a class='info' href='#RFC2434'>[2]<span> (</span><span class='info'>Narten, T. and H. Alvestrand, &ldquo;Guidelines for Writing an IANA Considerations Section in RFCs,&rdquo; October&nbsp;1998.</span><span>)</span></a>
</p>
<a name="anchor15"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.9"></a><h3>9.&nbsp;
Acknowledgments</h3>

<p>Special thanks to Flemming Andreasen, Francois Audet,
      Jason Fischl, Cullen
      Jennings, Colin Perkins, and Dan Wing, 
      for input, discussions, and guidance.
</p>
<a name="rfc.references"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.10"></a><h3>10.&nbsp;
References</h3>

<a name="rfc.references1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>10.1.&nbsp;Normative References</h3>
<table width="99%" border="0">
<tr><td class="author-text" valign="top"><a name="RFC2119">[1]</a></td>
<td class="author-text"><a href="mailto:sob@harvard.edu">Bradner, S.</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>,&rdquo; BCP&nbsp;14, RFC&nbsp;2119, March&nbsp;1997 (<a href="http://www.rfc-editor.org/rfc/rfc2119.txt">TXT</a>, <a href="http://xml.resource.org/public/rfc/html/rfc2119.html">HTML</a>, <a href="http://xml.resource.org/public/rfc/xml/rfc2119.xml">XML</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC2434">[2]</a></td>
<td class="author-text"><a href="mailto:narten@raleigh.ibm.com">Narten, T.</a> and <a href="mailto:Harald@Alvestrand.no">H. Alvestrand</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc2434">Guidelines for Writing an IANA Considerations Section in RFCs</a>,&rdquo; BCP&nbsp;26, RFC&nbsp;2434, October&nbsp;1998 (<a href="http://www.rfc-editor.org/rfc/rfc2434.txt">TXT</a>, <a href="http://xml.resource.org/public/rfc/html/rfc2434.html">HTML</a>, <a href="http://xml.resource.org/public/rfc/xml/rfc2434.xml">XML</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC3550">[3]</a></td>
<td class="author-text">Schulzrinne, H., Casner, S., Frederick, R., and V. Jacobson, &ldquo;<a href="http://tools.ietf.org/html/rfc3550">RTP: A Transport Protocol for Real-Time Applications</a>,&rdquo; STD&nbsp;64, RFC&nbsp;3550, July&nbsp;2003 (<a href="http://www.rfc-editor.org/rfc/rfc3550.txt">TXT</a>, <a href="http://www.rfc-editor.org/rfc/rfc3550.ps">PS</a>, <a href="http://www.rfc-editor.org/rfc/rfc3550.pdf">PDF</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4346">[4]</a></td>
<td class="author-text">Dierks, T. and E. Rescorla, &ldquo;<a href="http://tools.ietf.org/html/rfc4346">The Transport Layer Security (TLS) Protocol Version 1.1</a>,&rdquo; RFC&nbsp;4346, April&nbsp;2006 (<a href="http://www.rfc-editor.org/rfc/rfc4346.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4347">[5]</a></td>
<td class="author-text">Rescorla, E. and N. Modadugu, &ldquo;<a href="http://tools.ietf.org/html/rfc4347">Datagram Transport Layer Security</a>,&rdquo; RFC&nbsp;4347, April&nbsp;2006 (<a href="http://www.rfc-editor.org/rfc/rfc4347.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4366">[6]</a></td>
<td class="author-text">Blake-Wilson, S., Nystrom, M., Hopwood, D., Mikkelsen, J., and T. Wright, &ldquo;<a href="http://tools.ietf.org/html/rfc4366">Transport Layer Security (TLS) Extensions</a>,&rdquo; RFC&nbsp;4366, April&nbsp;2006 (<a href="http://www.rfc-editor.org/rfc/rfc4366.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC3711">[7]</a></td>
<td class="author-text">Baugher, M., McGrew, D., Naslund, M., Carrara, E., and K. Norrman, &ldquo;<a href="http://tools.ietf.org/html/rfc3711">The Secure Real-time Transport Protocol (SRTP)</a>,&rdquo; RFC&nbsp;3711, March&nbsp;2004 (<a href="http://www.rfc-editor.org/rfc/rfc3711.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4568">[8]</a></td>
<td class="author-text">Andreasen, F., Baugher, M., and D. Wing, &ldquo;<a href="http://tools.ietf.org/html/rfc4568">Session Description Protocol (SDP) Security Descriptions for Media Streams</a>,&rdquo; RFC&nbsp;4568, July&nbsp;2006 (<a href="http://www.rfc-editor.org/rfc/rfc4568.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4961">[9]</a></td>
<td class="author-text">Wing, D., &ldquo;<a href="http://tools.ietf.org/html/rfc4961">Symmetric RTP / RTP Control Protocol (RTCP)</a>,&rdquo; BCP&nbsp;131, RFC&nbsp;4961, July&nbsp;2007 (<a href="http://www.rfc-editor.org/rfc/rfc4961.txt">TXT</a>).</td></tr>
</table>

<a name="rfc.references2"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>10.2.&nbsp;Informational References</h3>
<table width="99%" border="0">
<tr><td class="author-text" valign="top"><a name="I-D.ietf-avt-rtp-and-rtcp-mux">[10]</a></td>
<td class="author-text">Perkins, C. and M. Westerlund, &ldquo;<a href="http://www.ietf.org/internet-drafts/draft-ietf-avt-rtp-and-rtcp-mux-07.txt">Multiplexing RTP Data and Control Packets on a Single Port</a>,&rdquo; draft-ietf-avt-rtp-and-rtcp-mux-07 (work in progress), August&nbsp;2007 (<a href="http://www.ietf.org/internet-drafts/draft-ietf-avt-rtp-and-rtcp-mux-07.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="I-D.fischl-sipping-media-dtls">[11]</a></td>
<td class="author-text">Fischl, J., &ldquo;<a href="http://www.ietf.org/internet-drafts/draft-fischl-sipping-media-dtls-03.txt">Datagram Transport Layer Security (DTLS) Protocol for Protection of Media  Traffic Established with the Session Initiation Protocol</a>,&rdquo; draft-fischl-sipping-media-dtls-03 (work in progress), July&nbsp;2007 (<a href="http://www.ietf.org/internet-drafts/draft-fischl-sipping-media-dtls-03.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="I-D.fischl-mmusic-sdp-dtls">[12]</a></td>
<td class="author-text">Fischl, J. and H. Tschofenig, &ldquo;<a href="http://www.ietf.org/internet-drafts/draft-fischl-mmusic-sdp-dtls-04.txt">Session Description Protocol (SDP) Indicators for Datagram Transport Layer  Security (DTLS)</a>,&rdquo; draft-fischl-mmusic-sdp-dtls-04 (work in progress), November&nbsp;2007 (<a href="http://www.ietf.org/internet-drafts/draft-fischl-mmusic-sdp-dtls-04.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="I-D.ietf-behave-rfc3489bis">[13]</a></td>
<td class="author-text">Rosenberg, J., Mahy, R., Matthews, P., and D. Wing, &ldquo;<a href="http://www.ietf.org/internet-drafts/draft-ietf-behave-rfc3489bis-18.txt">Session Traversal Utilities for (NAT) (STUN)</a>,&rdquo; draft-ietf-behave-rfc3489bis-18 (work in progress), July&nbsp;2008 (<a href="http://www.ietf.org/internet-drafts/draft-ietf-behave-rfc3489bis-18.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="I-D.mcgrew-srtp-big-aes">[14]</a></td>
<td class="author-text">McGrew, D., &ldquo;<a href="http://www.ietf.org/internet-drafts/draft-mcgrew-srtp-big-aes-01.txt">The use of AES-192 and AES-256 in Secure RTP</a>,&rdquo; draft-mcgrew-srtp-big-aes-01 (work in progress), March&nbsp;2009 (<a href="http://www.ietf.org/internet-drafts/draft-mcgrew-srtp-big-aes-01.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="I-D.rescorla-tls-extractor">[15]</a></td>
<td class="author-text">Rescorla, E., &ldquo;<a href="http://www.ietf.org/internet-drafts/draft-rescorla-tls-extractor-01.txt">Keying Material Extractors for Transport Layer Security (TLS)</a>,&rdquo; draft-rescorla-tls-extractor-01 (work in progress), November&nbsp;2007 (<a href="http://www.ietf.org/internet-drafts/draft-rescorla-tls-extractor-01.txt">TXT</a>).</td></tr>
</table>

<a name="appendix"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.A"></a><h3>Appendix A.&nbsp;
Performance of Multiple DTLS Handshakes</h3>

<p>Standard practice for security protocols such as TLS, DTLS, and SSH
      which do inline key management is to create a separate security
      association for each underlying network channel (TCP connection, UDP
      host/port quartet, etc.). This has dual advantages of simplicity and
      independence of the security contexts for each channel.
</p>
<p>Three concerns have been raised about the overhead of this strategy
      in the context of RTP security. The first concern is the additional
      performance overhead of doing a separate public key operation for each
      channel. The conventional procedure here (used in TLS and DTLS) is to
      establish a master context which can then be used to derive fresh
      traffic keys for new associations. In TLS/DTLS this is called "session
      resumption" and can be transparently negotiated between the peers.
      
</p>
<p>The second concern is network bandwidth overhead for the
      establishment of subsequent connections and for rehandshake (for
      rekeying) for existing connections. In particular, there is a concern
      that the channels will have very narrow capacity requirements allocated
      entirely to media which will be overflowed by the rehandshake.
      Measurements of the size of the rehandshake (with resumption) in TLS
      indicate that it is about 300-400 bytes if a full selection of cipher
      suites is offered. (the size of a full handshake is approximately 1-2k
      larger because of the certificate and keying material exchange).
</p>
<p>The third concern is the additional round-trips associated with
      establishing the 2nd, 3rd, ... channels. In TLS/DTLS these can all be
      done in parallel but in order to take advantage of session resumption
      they should be done after the first channel is established. For two
      channels this provides a ladder diagram something like this
      (parenthetical #s are media channel #s)
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
Alice                                   Bob
-------------------------------------------
                   &lt;-       ClientHello (1)
ServerHello (1)    -&gt;
Certificate (1)
ServerHelloDone (1)
                   &lt;- ClientKeyExchange (1)
                       ChangeCipherSpec (1)
                               Finished (1)
ChangeCipherSpec (1)-&gt;
Finished         (1)-&gt;
                                             &lt;--- Channel 1 ready

                   &lt;-       ClientHello (2)
ServerHello (2)    -&gt;
ChangeCipherSpec(2)-&gt;
Finished(2)        -&gt;
                   &lt;-  ChangeCipherSpec (2)
                               Finished (2)
                                             &lt;--- Channel 2 ready
</pre></div>
<p>So, there is an additional 1 RTT after Channel 1 is ready before
      Channel 2 is ready. If the peers are potentially willing to forego
      resumption they can interlace the handshakes, like so:
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
Alice                                   Bob
-------------------------------------------
                   &lt;-       ClientHello (1)
ServerHello (1)    -&gt;
Certificate (1)
ServerHelloDone (1)
                   &lt;- ClientKeyExchange (1)
                       ChangeCipherSpec (1)
                               Finished (1)
                   &lt;-       ClientHello (2)
ChangeCipherSpec (1)-&gt;
Finished         (1)-&gt;
                                             &lt;--- Channel 1 ready
ServerHello (2)    -&gt;
ChangeCipherSpec(2)-&gt;
Finished(2)        -&gt;
                   &lt;-  ChangeCipherSpec (2)
                               Finished (2)
                                             &lt;--- Channel 2 ready
</pre></div>
<p>In this case the channels are ready contemporaneously, but if a
      message in handshake (1) is lost then handshake (2) requires either a
      full rehandshake or that Alice be clever and queue the resumption
      attempt until the first handshake completes. Note that just dropping the
      packet works as well since Bob will retransmit.
</p>
<a name="rfc.authors"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>Authors' Addresses</h3>
<table width="99%" border="0" cellpadding="0" cellspacing="0">
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">David McGrew</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Cisco Systems</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">510 McCarthy Blvd.</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Milpitas, CA  95305</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">USA</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:mcgrew@cisco.com">mcgrew@cisco.com</a></td></tr>
<tr cellpadding="3"><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Eric Rescorla</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Network Resonance</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">2064 Edgewood Drive</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Palo Alto, CA  94303</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">USA</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:ekr@networkresonance.com">ekr@networkresonance.com</a></td></tr>
</table>
<a name="rfc.copyright"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>Full Copyright Statement</h3>
<p class='copyright'>
Copyright &copy; The IETF Trust (2007).</p>
<p class='copyright'>
This document is subject to the rights,
licenses and restrictions contained in BCP&nbsp;78,
and except as set forth therein,
the authors retain all their rights.</p>
<p class='copyright'>
This document and the information contained herein are provided
on an &ldquo;AS IS&rdquo; basis and THE CONTRIBUTOR,
THE ORGANIZATION HE/SHE REPRESENTS
OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY, THE IETF TRUST
AND THE INTERNET ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT
THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY
IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR
PURPOSE.</p>
<h3>Intellectual Property</h3>
<p class='copyright'>
The IETF takes no position regarding the validity or scope of any
Intellectual Property Rights or other rights that might be claimed
to pertain to the implementation or use of the technology
described in this document or the extent to which any license
under such rights might or might not be available; nor does it
represent that it has made any independent effort to identify any
such rights.
Information on the procedures with respect to
rights in RFC documents can be found in BCP&nbsp;78 and BCP&nbsp;79.</p>
<p class='copyright'>
Copies of IPR disclosures made to the IETF Secretariat and any
assurances of licenses to be made available,
or the result of an attempt made to obtain a general license or
permission for the use of such proprietary rights by implementers or
users of this specification can be obtained from the IETF on-line IPR
repository at <a href='http://www.ietf.org/ipr'>http://www.ietf.org/ipr</a>.</p>
<p class='copyright'>
The IETF invites any interested party to bring to its attention
any copyrights,
patents or patent applications,
or other
proprietary rights that may cover technology that may be required
to implement this standard.
Please address the information to the IETF at <a href='mailto:ietf-ipr@ietf.org'>ietf-ipr@ietf.org</a>.</p>
</body></html>
