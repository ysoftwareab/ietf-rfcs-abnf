needSuccess = true, needAll = true:  doAll [doUntilFailure]
          All contained transactions must succeed.  If any failure
          occurs, the entire set of transactions in the transactions-
          data-list must be rolled back.  This mode is most similar to
          the previous SNMP SET-PDU.

needSuccess = false, needAll = true: tryAll
          With this combination set, the command responder must try to
          achieve all the transactions, however if any transaction fails
          it is not required to roll back the rest of the transactions.
          The failed transactions themselves, however, must individually
          properly revert to the previous state.  This mode allows a
          bunch of independent transactions to be specified in one
          management operation.  It is roughly equivalent to a bunch of
          individual and independent SNMP SET-PDU operations.

needSuccess = true, needAll = false:  doAtLeastOne
          [doUntilSuccess]
          In this case, at least one must succeed for the transaction as
          a whole to succeed.  More importantly, if any one transaction
          component does succeed, processing MUST be stopped and the
          transaction as a whole is considered successful.  Another way
          to put it: at most one successful component is executed and
          never more than one.  This mode is useful for specifying, for
          example, a transaction with one or more "fall-back"
          transactions in case one fails.

needSuccess = false, needAll = false:  tryAtLeastOne
          In this case, at least one must succeed for the transaction as
          a whole to succeed.  More importantly, if any one transaction
          component does succeed, processing MUST be stopped.  The
          different between this combination of bits and the previous is
          that this transaction itself always succeeds, even if all the
          sub-transactions fail.  It is impossible for a transaction of
          this type to be considered a failure in itself.

element-number = 3 }

match-data = {
which = 1,   -- ifIndex
what  = 5    -- 5th
element-value = "interface 5" },
element-value = 6 }
element-number = 2,
element-number = 3,
multiple-subelement = {
element-specifier = ifXTable,
element-list = {
                                        6, 10
sub-criteria = {
                                    {
match-type = 0,  -- equals
match-data = {
which = 3,    -- ifType
what  = 6     -- ethernetCsmacd
match-type = 12,
match-data = {
which = 5,    -- ifSpeed
what  = 10000000
element-value = 12 },
element-value = "interface 12" },
element-value = 6 }
element-value = {
                  { which-element = 6,
element-value = 12345 },
element-value = 12345 },
element-number = 2,
element-number = 3,
multiple-subelement = {
element-specifier = ifXTable,
element-list = {
                                        6, 10
sub-criteria = {
                                    {
match-type = 0,  -- equals
match-data = {
which = 3,    -- ifType
what  = 6     -- ethernetCsmacd
match-type = 12,
match-data = {
which = 5,     -- ifSpeed
what  = 10000000
element-value = 5 },
element-value = "interface 5" },
element-value = 6 }
element-value = {
                  { which-element = 6,
element-value = 23456 },
element-value = 23456 },
match-data = {
which = 3,     -- ifType
what  = 20     -- basicISDN
element-value = {
                  { which-element = 1,     -- ifIndex
element-value = 12 },  -- #12
element-value = 1 },   -- up
element-value = 1 }    -- up
