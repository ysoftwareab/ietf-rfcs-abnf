

Internet Engineering Task Force       Audio-Video Transport WG
INTERNET-DRAFT                          T.Turletti, C. Huitema
                                                         INRIA
                                                  September 94
                                             Expires: March 95

                        Packetization
                             of
                     H.261 video streams



                      September 9, 1994

             Thierry Turletti, Christian Huitema
                            INRIA

              Christian.Huitema@sophia.inria.fr
               Thierry.Turletti@sophia.inria.fr


             <draft-ietf-avt-video-packet-03.txt>



1.  Status of this Memo

This document is an Internet draft. Internet drafts are
working documents of the Internet Engineering Task Force
(IETF), its Areas, and its Working Groups. Note that other
groups may also distribute working documents as Internet
Drafts).

Internet Drafts are draft documents valid for a maximum of six
months. Internet Drafts may be updated, replaced, or obsoleted
by other documents at any time. It is not appropriate to use
Internet Drafts as reference material or to cite them other
than as a "working draft" or "work in progress".

Please check the I-D abstract listing contained in each
Internet Draft directory to learn the current status of this
or any other Internet Draft.

Distribution of this document is unlimited.












INTERNET-DRAFT                    Packetization of H.261


2.  Abstract

This draft describes a packetization scheme of H.261 video
stream.  The scheme proposed can be used to transport such a
video flow over the protocols used by RTP.

This specification is a product  of the Audio-Video Transport
working  group within the Internet  Engineering Task  Force.
Comments  are solicited  and should be addressed to the
working group's mailing list at  rem-conf@es.net and/or the
authors.

3.  Purpose of this document

The CCITT recommendation H.261 [6] specifies the encodings
used by CCITT compliant video-conference codecs. Although
these encodings were originally specified for fixed data rate
ISDN circuits, experimentations [4] have shown that they can
also be used over the internet.

The purpose of this memo is to specify how H.261 video streams
can be carried over the protocols used by RTP [1], such as
UDP, ST-II, etc.


4.  Structure of the packet stream

H.261 codecs produce a bit stream. In fact, H.261 and
companion recommendations specify several levels of encoding:

(1)  Images are first separated in blocks of 8x8 pixels.
     Blocks which have moved are encoded by computing the
     discrete cosine transform (DCT) of their coefficients,
     which are then quantized and Huffman encoded.

(2)  The bits resulting of the Huffman encoding are then
     arranged in 512 bits frames, containing 2 bits of
     synchronization, 492 bits of data and 18 bits of error
     correcting code.

(3)  The 512 bits frames are then interlaced with an audio
     stream and transmitted over px64 kbps circuits according
     to specification H.221.







Turletti, Huitema                                     [Page 2]





INTERNET-DRAFT                    Packetization of H.261


When transmitting over the Internet, we will directly consider
the output of the Huffman encoding. We will not carry the 512
bits frames, as protection against errors can be obtained by
other means. Similarly, we will not attempt to multiplex audio
and video signals in the same packets, as UDP and RTP provide
a much more efficient way to achieve multiplexing.

Directly transmitting the result of the Huffman encoding over
an unreliable stream of UDP datagrams would however have very
poor error resistance characteristics. The H.261 coding is in
fact organized as a sequence of images, or frames, which are
themselves organized as a set of Groups of Blocks (GOB). Each
GOB holds a set of 3 lines of 11 macro blocks (MB). Each MB
carries information on a group of 16x16 pixels: luminance
information is specified for 4 blocks of 8x8 pixels, while
chrominance information is only given by two color difference
components 8x8 "red" and "blue" blocks. These components and
the codes representing their sampled values are as defined in
the CCIR Recommendation 601.

This grouping is used to specify information at each level of
the hierarchy:

-    At the frame level, one specifies information such as the
     delay from the previous frame, the image format, and
     various indicators.

-    At the GOB level, one specifies the GOB number and the
     default quantifier that will be used for the MBs.

-    At the MB level, one specifies which blocks are present
     and which did not change, and optionally a quantifier, as
     well as precisions on the codings such as distance
     vectors.

The result of this structure is that one needs to receive the
information present in the frame header to decode the GOBs, as
well as the information present in the GOB header to decode
the MBs. Without precautions, this would mean that one has to
receive all the packets that carry an image in order to
properly decode its components. In fact, the experience has
shown that:

(1)  It would be unrealistic to carry an image in a single
     packet: video images can sometimes be very large.





Turletti, Huitema                                     [Page 3]





INTERNET-DRAFT                    Packetization of H.261


(2)  GOB information typically fits in a packet. In fact,
     several GOBs can often be grouped in a packet.

Once we have take the decision to correlate GOB
synchronization and packetization, a number of decisions
remain to be taken, due to the following conditions:

(1)  The algorithm should be easy to implement when
     packetizing the output stream of a hardware codec.

(2)  The algorithm should not induce rendition delays -- we
     should not have to wait for a following packet to display
     an image.

(3)  The algorithm should allow for efficient
     resynchronization in case of packet losses.

(4)  It should be easy to depacketize the data stream and
     direct it to an hardware codec's input.

(5)  When the hardware decoder operates at a fixed bit rate,
     one should be able to maintain synchronization, e.g. by
     adding padding bits when the packet arrival rate is
     slower than the bit rate.

(6)  The fragmentation process should break the frame up so
     that packets start on GOB boundaries when possible.

The H.261 Huffman encoding includes a special "GOB start"
pattern, composed of 15 zeroes followed by a single 1, that
cannot be imitated by any other code words. That pattern marks
the separation between two GOBs, and is in fact used as an
indicator that the current GOB is terminated. The encoding
also includes a stuffing pattern, composed of seven zeroes
followed by four ones; that stuffing pattern can only be
entered between the encoding of MBs, or just before the GOB
separator.

The first conclusion of the analysis is that the packets
should contain all the GOB data, including the "GOB start"
pattern that separate the current block from its follower.
Actually, as this pattern is well known, we could as well use
a single bit in the data header to indicate that a GOB-start
pattern must be added at the decoder side.






Turletti, Huitema                                     [Page 4]





INTERNET-DRAFT                    Packetization of H.261


Not encoding the GOB-start pattern has two advantages:

(1)  It reduces the number of bits in the packets, and avoids
     the possibility of splitting packets in the middle of a
     GOB separator.

(2)  It authorizes gateways to hardware decoders to insert the
     stuffing pattern in front of the GOB, in order to meet
     the fixed bit rate requirement.

Another problem posed by the specificities of the H.261
compression is that the GOB data have no particular reason to
fit in an integer number of octets.

5.  Specification of the packetization scheme

The data header will thus contain two three-bits integers,
EBIT and SBIT:

SBIT indicates the number of bits that should be ignored in
     the first (start) data octet.

EBIT indicates the number of bits that should be ignored in
     the last (end) data octet.

Although only the EBIT counter would really be needed for
software coders, the SBIT counter was inserted to ease the
packetization of hardware coders output.  A sample
packetization procedure is found in annex A.

At the receiving sites, the GOB synchronization can be used in
conjunction with the synchronization service of the RTP
protocol. In case of losses, the decoders could become
desynchronized. The "S" bit of the H.261 option field will be
set to indicate that the packet includes the beginning of the
encoding of a GOB. A GOB start code must be prepended to that
packet before decoding. If several GOBs are encoded inside a
same packet, all the GOBs except the first one contain the GOB
start code. The receiver will detect losses by looking at the
RTP sequence numbers. The receiver is recommended to
resequence out of order packets in order to limit the packet
loss effect. Some misordering of packets in the network seems
likely, even when there is no loss, and one would not want to
drop a frame because of that. In case of losses, it will
ignore all packets whose "S" bit is null. Once an S bit packet





Turletti, Huitema                                     [Page 5]





INTERNET-DRAFT                    Packetization of H.261


has been received, it will prepend the GOB start code to that
packet, and resume decoding. The "E" bit of the H.261 header
will be set to indicate that the packet contains the end of a
GOB, so after resequencing, it can safely be decoded without
having decoder state hanging between packets. The "fragment
offset" field (2 bytes) is set to the byte offset of the
current packet into the frame. It is used to estimate how much
memory shall be left for the possible delayed packets. A 2-
bytes length for the "fragment offset" field is enough since
H.261 recommendation specifies a maximal size of 256 kbits for
CIF and 64 kbits for QCIF images.

An example packetization program is given in Appendix A.

5.1.  Usage of RTP

The H.261 information are carried as data within the RTP
protocol. The payload type should specify the corresponding
H.261 type (see companion profile document RFC TBD). The RTP
timestamp encodes the date at which the image was grabbed. The
timestamp consists of the middle 32 bits of a 64-bit NTP
timestamp, as defined in  RFC 1305 [2]. That is, it counts
time since 0 hours UTC, January 1, 1900, with a resolution of
65536 ticks per  second. (UTC is Coordinated Universal Time,
approximately equal to the historical Greenwich Mean Time.)

The very definition of this settings implies that the
beginning of an image shall always be synchronized with a
packet. The RTP sequence number can be used to detect missing
packets. In this case, one shall ignore all incoming packets
until the next synchronization mark is received ("S" bit set
in the H.261 header). The marker "M" bit of the RTP header can
be used as a flag to trigger display the new image on the
screen. This marker has a value of one in the last packet of a
video frame.  The H.261 data will follow the RTP header, as
in:














Turletti, Huitema                                     [Page 6]





INTERNET-DRAFT                    Packetization of H.261


  0                   1                   2                   3
  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 .                                                               .
 .                          RTP header                           .
 .                                                               .
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |                          H.261  header                        |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |                          H.261 stream ...                     .
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

The H.261 options field is defined as following:

  0                   1                   2                   3
  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |S|SBIT |E|EBIT |I|V| MBZ |SIZE |      fragment offset          |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+































Turletti, Huitema                                     [Page 7]





INTERNET-DRAFT                    Packetization of H.261


_________________________________________________________________________
|S (1 bit)                 |   Start of GOB. Set if the packet is a     |
|                          |   start of GOB.                            |
|__________________________|____________________________________________|
|SBIT (3 bits)             |   Start bit position number of bits        |
|                          |   that should be ignored in the first data |
|                          |   octet. SBIT must be null if S is unset.  |
|__________________________|____________________________________________|
|E (1 bit)                 |   End of GOB. Set if the packet is an      |
|                          |   end of GOB.                              |
|__________________________|____________________________________________|
|EBIT (3 bits)             |   End bit position number of bits          |
|                          |   that should be ignored in the last data  |
|                          |   octet. EBIT must be null if E is unset.  |
|__________________________|____________________________________________|
|I (1 bit)                 |   Full Intra Image flag. Set if it is the  |
|                          |   first packet of a full intra image.      |
|__________________________|____________________________________________|
|V (1 bit)                 |   Movement Vector flag. Set if movement    |
|                          |   vectors are encoded. All V               |
|                          |   bits of the same frame must be identical.|
|__________________________|____________________________________________|
|MBZ (3 bits)              |   Must Be Zero.                            |
|__________________________|____________________________________________|
|SIZE (3 bits)             |   Image format:                            |
|                          |   QCIF, CIF or number of CIF in SCIF.      |
|__________________________|____________________________________________|
|fragment offset (16 bits) |   Byte offset of the current packet        |
|                          |   into the frame.                          |
|__________________________|____________________________________________|


The image format (3 bits) is defined as following:

















Turletti, Huitema                                     [Page 8]





INTERNET-DRAFT                    Packetization of H.261


                 ____________________________
                | QCIF               |   000|
                |____________________|______|
                | CIF                |   001|
                |____________________|______|
                | SCIF 0             |      |
                | upper left corner  |   100|
                | CIF in SCIF image  |      |
                |____________________|______|
                | SCIF 1             |      |
                | upper right corner |   101|
                | CIF in SCIF image  |      |
                |____________________|______|
                | SCIF 2             |      |
                | lower left corner  |   110|
                | CIF in SCIF image  |      |
                |____________________|______|
                | SCIF 3             |      |
                | lower right corner |   111|
                | CIF in SCIF image  |      |
                |____________________|______|


With:

-    CIF: Common interchange format for video images with 352
     x 288 pixels.

-    QCIF: Quarter CIF with 176 x 144 pixels.

-    SCIF: Super CIF with 704 x 576 pixels.

5.2.  Usage of RTCP control packets

When sending or receiving H.261 streams through the RTP
protocol, the stations should be ready to:

(1)  process or ignore all generic RTCP control packets.

(2)  send or receive H.261 specific RTCP control packets, to
     request a video refreshment.

This memo describes two H.261 specific RTCP control packets,
"Full Intra Request" and "Negative Acknowledgement".






Turletti, Huitema                                     [Page 9]





INTERNET-DRAFT                    Packetization of H.261


5.2.1.  Controlling the reverse flow

Support of the reverse RTCP control packets by the H.261
sender is optional; in particular, early experiments have
shown that the usage of this feature could have very negative
effects when the number of sites is very large. Thus, reverse
RTCP control packets should be used with caution.  The aim of
these packets is to speed the refreshment of the video when it
is possible. Videoconferencing applications do not require
reliable multicast packet delivery such as whiteboard
applications. Reliable multicast protocols can use similar
NACK RTCP control packets but in this case, the main purpose
is to provide reliable data transfer to the receivers packets
with minimal throughput. A few reliable multicast protocols
use random delays to prevent NACK implosion problem [3]. On
the other hand, it is more efficient in videoconferencing
applications to send NACK control packets as soon as possible,
i.e. as soon as a loss is detected, without adding any random
delays. In this case, multicasting NACKs control packets
generates useless traffic between receivers since only the
coder will use them. But this method is only efficient when
the number of receivers is small. e.g. in IVS [5] reverse RTCP
control packets are used only if there are less than 10
participants in the conference.

A site may distinguish reverse RTCP packets from forward RTCP
packets by their arrival port. Reverse RTCP packets arrive on
the same port that the site uses as a source port for forward
(data) RTP packets.

5.2.2.  Full Intra Request (FIR) RTCP control packet

  0                   1                   2                   3
  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |T=2|P|   MBZ   |  PT=RTCP_FIR  |           length              |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |                              SSRC                             |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

This packet indicates that a receiver requires a full encoded
image in order to either start decoding with an entire image
or to refresh its image and speed the recovery after a burst
of lost packets. The receiver requests the source to force the
next image in full "Intra" coding mode, i.e. without using





Turletti, Huitema                                    [Page 10]





INTERNET-DRAFT                    Packetization of H.261


differential coding. The various fields are defined in the RTP
specification [1]. SSRC is the synchronization source
identifier for the sender of this packet. The value of the
packet type (PT) identifier is the constant RTCP_FIR (192).

5.2.3.  Negative ACKnowledgements (NACK) RTCP packet

Packets lost are detected using the RTP sequence number. After
a packet loss, the receiver will resynchronize on the next
GOB. However, as H.261 uses differential encoding, parts of
the images may remain blurred as long as all corresponding MBs
are not encoded in INTRA mode; i.e. absolute encoding without
relation to previous frame. There are several ways to put it
right.

The fastest way is to request a refreshment. As all GOB
belonging to a given video image carry the same time stamp,
the receiver can determine a list of GOBs which were really
received for that time stamp, and thus identify the "missing
blocks". Requesting a specific reinitialization of these
missing blocks is more efficient than requesting a complete
reinitialization of the image through the "Full Intra Request"
item. When it is impossible to use NACK, e.g. if the number of
receivers is large or if the coder does not handle NACK,
another method consists to periodically force INTRA encoding
each MB. The INTRA refreshment rate can be raised in order to
speed the recovering when the loss rate measured is important.

The format of the NACK RTCP control packet is as follow:

  0                   1                   2                   3
  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |T=2|P|   MBZ   | PT=RTCP_NACK  |           length              |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |                              SSRC                             |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |     FGOBL     |     LGOBL     |           MBZ           |SIZE |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |      timestamp (seconds)      |     timestamp (fraction)      |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

The various fields T, P, PT, length and SSRC are defined in
the RTP specification [1]. The value of the packet type (PT)
identifier is the constant RTCP_NACK (193). SSRC is the





Turletti, Huitema                                    [Page 11]





INTERNET-DRAFT                    Packetization of H.261


synchronization source identifier for the sender of this
packet.

The remaining fields have the following values:

    _____________________________________________________
   | FGOBL     |   First GOB Lost:                      |
   |           |   Identifies the first GOB lost number.|
   |___________|________________________________________|
   | LGOBL     |   Last GOB Lost:                       |
   |           |   Identifies the last GOB lost number. |
   |___________|________________________________________|
   | MBZ       |   Must Be Zero.                        |
   |___________|________________________________________|
   | SIZE      |   Repeat the format indicator of the   |
   |           |   received image, including the number |
   |           |   of the SCIF subimage if present.     |
   |___________|________________________________________|
   | Timestamp |   The RTP timestamp of the             |
   |           |   original image                       |
   |___________|________________________________________|





























Turletti, Huitema                                    [Page 12]





INTERNET-DRAFT                    Packetization of H.261


Acknowledgements

This draft is based on discussion within the AVT working group
chaired by Stephen Casner. Steve McCanne, Stephen Casner, Mark
Handley, Van Jacobson and Henning G.Schulzrinne provided
valuable comments.


References

[1]  Henning Schulzrinne, Stephen Casner, Ron Frederick, Van
     Jacobson, RTP: A Transport Protocol for Real-Time
     Applications, INTERNET-DRAFT, July 18, 1994.

[2]  D.L. Mills, ``Network time protocol (version 3) --
     specification, implementation and analysis,'' Network
     Working Group Request for Comments RFC 1305, University
     of Delaware, Mar. 1992.

[3]  Sridhar Pingali, Don Towsley and James F. Kurose, A
     comparison of sender-initiated and receiver-initiated
     reliable multicast protocols, IEEE GLOBECOM '94.

[4]  Thierry Turletti, H.261 software codec for
     videoconferencing over the Internet INRIA Research Report
     no 1834, January 1993.

[5]  Thierry Turletti, INRIA Videoconferencing tool (IVS),
     available by anonymous ftp from zenon.inria.fr in
     rodeo/ivs/last_version.

[6]  Video codec for audiovisual services at p x 64 kbit/s
     CCITT Recommendation H.261, 1990.

















Turletti, Huitema                                    [Page 13]





INTERNET-DRAFT                    Packetization of H.261


Appendix A

The following code can be used to packetize the output of an
H.261 codec:

#include <stdio.h>

#define BUFFER_MAX 512

int right[] = {
   /* Number of successives zeroes starting at the MSB for
each octet */
   8,7,6,6,5,5,5,5,4,4,4,4,4,4,4,4,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,
   2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
   1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
   1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
   0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
   0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
   0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
   0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};

int left[] = {
   /* Number of successives zeroes starting at the LSB for
each octet */
   8,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,
   5,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,
   6,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,
   5,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,
   7,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,
   5,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,
   6,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,
   5,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0};

h261_sync(F)
   FILE *F;
{
   int  i, ebit, sbit, start_of_group, end_of_group,
         c, nz;
   unsigned char buf[BUFFER_MAX];
   int *left, *right;

   i = 0;
   ebit = 0;
   sbit = 0;
   start_of_group = 1;





Turletti, Huitema                                    [Page 14]





INTERNET-DRAFT                    Packetization of H.261


   nz = 0;
   while (c = getc(F)) {
      buf[i++] = c;
      if (c == 0) {
         nz += 8;
      } else {
         nz += right[c];
         end_of_group = 1;
         if (nz >= 15) {
            if (right[c] == 7) {
               ebit = 0;
               send_message(buf, i - 2, sbit, ebit,
                  end_of_group, start_of_group);
               sbit = 0;
               i = 0;
            } else {
               ebit = 7 - right[c];
               send_message(buf, i - 2, sbit, ebit,
                  end_of_group, start_of_group);
               i = 0;
               buf[i++] = c;
               sbit = right[c] + 1;
            }
            start_of_group = 1;
         } else {
            nz = left[c];
            if (i >= BUFFER_MAX) {
               ebit = 0;
               end_of_group = 0;
               send_message(buf, i - 2, sbit, ebit,
                  end_of_group, start_of_group);
               buf[0] = buf[i - 2];
               buf[1] = buf[i - 1];
               i = 2;
               sbit = 0;
               start_of_group = 0;
            }
         }
      }
   }
}









Turletti, Huitema                                    [Page 15]





INTERNET-DRAFT                    Packetization of H.261


Table of Contents


1 Status of this Memo ...................................    1
2 Abstract ..............................................    2
3 Purpose of this document ..............................    2
4 Structure of the packet stream ........................    2
5 Specification of the packetization scheme .............    5
5.1 Usage of RTP ........................................    6
5.2 Usage of RTCP control packets .......................    9
5.2.1 Controlling the reverse flow ......................   10
5.2.2 Full Intra Request (FIR) RTCP control packet ......   10
5.2.3 Negative ACKnowledgements (NACK) RTCP packet ......   11
 Acknowledgements .......................................   13
 References .............................................   13
 Appendix A .............................................   14


































Turletti, Huitema                                    [Page 16]



