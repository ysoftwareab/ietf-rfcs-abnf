<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="en"><head><title>rxgk: GSSAPI based security class for RX</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="description" content="rxgk: GSSAPI based security class for RX">
<meta name="generator" content="xml2rfc v1.35 (http://xml.resource.org/)">
<meta name="viewport" content="width=600;" />
<style type='text/css'><!--
        body {
                font-family: verdana, charcoal, helvetica, arial, sans-serif;
                font-size: 85%;
		max-width: 40em; 
		color: #000; background-color: #FFF;
                margin: 2em;
        }
        h1, h2, h3, h4, h5, h6 {
                font-family: helvetica, monaco, "MS Sans Serif", arial, sans-serif;
                font-weight: bold; font-style: normal;
        }
        h1 { color: #900; background-color: transparent; text-align: right; }
        h3 { color: #333; background-color: transparent; }

        td.RFCbug {
                font-size: x-small; text-decoration: none;
                width: 30px; height: 30px; padding-top: 2px;
                text-align: justify; vertical-align: middle;
                background-color: #000;
        }
        td.RFCbug span.RFC {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: bold; color: #666;
        }
        td.RFCbug span.hotText {
                font-family: charcoal, monaco, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: normal; text-align: center; color: #FFF;
        }

        table.TOCbug { width: 30px; height: 15px; }
        td.TOCbug {
                text-align: center; width: 30px; height: 15px;
                color: #FFF; background-color: #900;
        }
        td.TOCbug a {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, sans-serif;
                font-weight: bold; font-size: x-small; text-decoration: none;
                color: #FFF; background-color: transparent;
        }

        td.header {
                font-family: arial, helvetica, sans-serif; font-size: x-small;
                vertical-align: top; width: 33%;
                color: #FFF; background-color: #666;
        }
        td.author { font-weight: bold; font-size: x-small; margin-left: 4em; }
        td.author-text { font-size: x-small; }

        /* info code from SantaKlauss at http://www.madaboutstyle.com/tooltip2.html */
        a.info {
                /* This is the key. */
                position: relative;
                z-index: 24;
                text-decoration: none;
        }
        a.info:hover {
                z-index: 25;
                color: #FFF; background-color: #900;
        }
        a.info span { display: none; }
        a.info:hover span.info {
                /* The span will display just on :hover state. */
                display: block;
                position: absolute;
                font-size: smaller;
                top: 2em; left: -5em; width: 15em;
                padding: 2px; border: 1px solid #333;
                color: #900; background-color: #EEE;
                text-align: left;
        }

        a { font-weight: bold; }
        a:link    { color: #900; background-color: transparent; }
        a:visited { color: #633; background-color: transparent; }
        a:active  { color: #633; background-color: transparent; }

        p { margin-left: 2em; margin-right: 2em; }
        p.copyright { font-size: x-small; }
        p.toc { font-size: 85%;
		max-width: 40em; 
		font-weight: bold; margin-left: 3em; }
        table.toc { margin: 0 0 0 3em; padding: 0; border: 0; vertical-align: text-top; }
        td.toc { font-size: 85%;
		max-width: 40em; 
		font-weight: bold; vertical-align: text-top; }

        ol.text { margin-left: 2em; margin-right: 2em; }
        ul.text { margin-left: 2em; margin-right: 2em; }
        li      { margin-left: 3em; }

        /* RFC-2629 <spanx>s and <artwork>s. */
        em     { font-style: italic; }
        strong { font-weight: bold; }
        dfn    { font-weight: bold; font-style: normal; }
        cite   { font-weight: normal; font-style: normal; }
        tt     { color: #036; }
        tt, pre, pre dfn, pre em, pre cite, pre span {
                font-family: "Courier New", Courier, monospace; font-size: small;
        }
        pre {
                text-align: left; padding: 4px;
                color: #000; background-color: #CCC;
        }
        pre dfn  { color: #900; }
        pre em   { color: #66F; background-color: #FFC; font-weight: normal; }
        pre .key { color: #33C; font-weight: bold; }
        pre .id  { color: #900; }
        pre .str { color: #000; background-color: #CFF; }
        pre .val { color: #066; }
        pre .rep { color: #909; }
        pre .oth { color: #000; background-color: #FCF; }
        pre .err { background-color: #FCC; }

        /* RFC-2629 <texttable>s. */
        table.all, table.full, table.headers, table.none {
                font-size: 85%;
		max-width: 40em; 
		text-align: center; border-width: 2px;
                vertical-align: top; border-collapse: collapse;
        }
        table.all, table.full { border-style: solid; border-color: black; }
        table.headers, table.none { border-style: none; }
        th {
                font-weight: bold; border-color: black;
                border-width: 2px 2px 3px 2px;
        }
        table.all th, table.full th { border-style: solid; }
        table.headers th { border-style: none none solid none; }
        table.none th { border-style: none; }
        table.all td {
                border-style: solid; border-color: #333;
                border-width: 1px 2px;
        }
        table.full td, table.headers td, table.none td { border-style: none; }

        hr { height: 1px; }
        hr.insert {
                width: 80%; border-style: none; border-width: 0;
                color: #CCC; background-color: #CCC;
        }
--></style>
</head>
<body>
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<table summary="layout" width="66%" border="0" cellpadding="0" cellspacing="0"><tr><td><table summary="layout" width="100%" border="0" cellpadding="2" cellspacing="1">
<tr><td class="header">Network Working Group</td><td class="header"> Wilkinson</td></tr>
<tr><td class="header">Internet-Draft</td><td class="header">YFS</td></tr>
<tr><td class="header">Intended status: Informational</td><td class="header">January 09, 2010</td></tr>
<tr><td class="header">Expires: July 13, 2010</td><td class="header">&nbsp;</td></tr>
</table></td></tr></table>
<h1><br />rxgk: GSSAPI based security class for RX<br />draft-wilkinson-afs3-rxgk-00</h1>

<h3>Abstract</h3>

<p>rxgk is a security class for the RX RPC protocol. It uses the GSSAPI
       framework to provide authentication, confidentiality and integrity
       protection. This document provides a general description of rxgk. A
       further document will provide details of integration with specific
       RX applications. 
</p>
<h3>Status of this Memo</h3>
<p>
This Internet-Draft is submitted to IETF in full
conformance with the provisions of BCP&nbsp;78 and BCP&nbsp;79.</p>
<p>
Internet-Drafts are working documents of the Internet Engineering
Task Force (IETF), its areas, and its working groups.
Note that other groups may also distribute working documents as
Internet-Drafts.</p>
<p>
Internet-Drafts are draft documents valid for a maximum of six months
and may be updated, replaced, or obsoleted by other documents at any time.
It is inappropriate to use Internet-Drafts as reference material or to cite
them other than as &ldquo;work in progress.&rdquo;</p>
<p>
The list of current Internet-Drafts can be accessed at
<a href='http://www.ietf.org/ietf/1id-abstracts.txt'>http://www.ietf.org/ietf/1id-abstracts.txt</a>.</p>
<p>
The list of Internet-Draft Shadow Directories can be accessed at
<a href='http://www.ietf.org/shadow.html'>http://www.ietf.org/shadow.html</a>.</p>
<p>
This Internet-Draft will expire on July 13, 2010.</p>

<h3>Copyright Notice</h3>
<p>
Copyright (c) 2010 IETF Trust and the persons identified as the
document authors.  All rights reserved.</p>
<p>
This document is subject to BCP 78 and the IETF Trust's Legal
Provisions Relating to IETF Documents
(http://trustee.ietf.org/license-info) in effect on the date of
publication of this document.  Please review these documents
carefully, as they describe your rights and restrictions with respect
to this document. Code Components extracted from this document must
include Simplified BSD License text as described in Section 4.e of
the Trust Legal Provisions and are provided without warranty as
described in the BSD License.</p>
<a name="toc"></a><br /><hr />
<h3>Table of Contents</h3>
<p class="toc">
<a href="#intro">1.</a>&nbsp;
Introduction<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor1">1.1.</a>&nbsp;
Requirements Language<br />
<a href="#enctype">2.</a>&nbsp;
Encryption framework<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#usage">2.1.</a>&nbsp;
Key usage values<br />
<a href="#anchor2">3.</a>&nbsp;
Security Levels<br />
<a href="#tokens">4.</a>&nbsp;
Token Format<br />
<a href="#anchor3">5.</a>&nbsp;
Key negotiation<br />
<a href="#combine">6.</a>&nbsp;
The combine tokens operation<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor4">6.1.</a>&nbsp;
Overview<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor5">6.2.</a>&nbsp;
Key combination algorithm<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor6">6.3.</a>&nbsp;
RPC definition<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor7">6.4.</a>&nbsp;
Server operation<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor8">6.5.</a>&nbsp;
Client operation<br />
<a href="#class">7.</a>&nbsp;
The rxgk security class<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor9">7.1.</a>&nbsp;
Overview<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor10">7.2.</a>&nbsp;
Rekeying<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor11">7.3.</a>&nbsp;
Key derivation<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor12">7.4.</a>&nbsp;
The Challenge<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor13">7.5.</a>&nbsp;
The Response<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor14">7.5.1.</a>&nbsp;
The Authenticator<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor15">7.6.</a>&nbsp;
Checking the Reponse<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor16">7.7.</a>&nbsp;
Packet handling<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor17">7.7.1.</a>&nbsp;
Encryption<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor18">7.7.2.</a>&nbsp;
Integrity protection<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor19">7.7.3.</a>&nbsp;
Authentication only<br />
<a href="#IANA">8.</a>&nbsp;
IANA Considerations<br />
<a href="#security">9.</a>&nbsp;
Security Considerations<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor20">9.1.</a>&nbsp;
Abort Packets<br />
<a href="#rfc.references1">10.</a>&nbsp;
Normative References<br />
<a href="#anchor22">Appendix&nbsp;A.</a>&nbsp;
Acknowledgements<br />
<a href="#rfc.authors">&#167;</a>&nbsp;
Author's Address<br />
</p>
<br clear="all" />

<a name="intro"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1"></a><h3>1.&nbsp;
Introduction</h3>

<p>rxgk is a <a class='info' href='#RFC2743'>GSSAPI<span> (</span><span class='info'>Linn, J., &ldquo;Generic Security Service Application Program Interface Version 2, Update 1,&rdquo; January&nbsp;2000.</span><span>)</span></a> [RFC2743] based security class
     for the rx protocol. It provides
     authentication, confidentiality and integrity protection for rx RPC calls,
     using a security context established using any GSSAPI mechanism with 
     <a class='info' href='#RFC4401'>PRF<span> (</span><span class='info'>Williams, N., &ldquo;A Pseudo-Random Function (PRF) API Extension for the Generic Security Service Application Program Interface (GSS-API),&rdquo; February&nbsp;2006.</span><span>)</span></a> [RFC4401] support.
</p>
<p>Architecturally, rxgk is split into two parts. The rxgk rx security
     class provides strong encryption using previously negotiated ciphers and
     keys. It builds on the Kerberos crypto framework for its encryption 
     requirements, but is authentication mechanism independent - the class
     itself does not require the use of either Kerberos, or GSSAPI. The
     security class simply uses a previously negotiated encryption type, and
     master key. The master key is never directly used, but instead a per
     connection key is derived for each new secure connection that is
     established.
</p>
<p>The second portion of rxgk is a service which permits the negotiation of
     an encryption algorithm, and the establishment of a master key. This is
     done via a separate RPC exchange with a server, prior to the setup of
     any rxgk connections. The exchange establishes an rxgk token, and a
     master key shared between client and server. This exchange is protected
     within a GSSAPI security context.
</p>
<a name="anchor1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1.1"></a><h3>1.1.&nbsp;
Requirements Language</h3>

<p>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
        "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
        document are to be interpreted as described in <a class='info' href='#RFC2119'>RFC 2119<span> (</span><span class='info'>Bradner, S., &ldquo;Key words for use in RFCs to Indicate Requirement Levels,&rdquo; March&nbsp;1997.</span><span>)</span></a> [RFC2119].
</p>
<a name="enctype"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2"></a><h3>2.&nbsp;
Encryption framework</h3>

<p>Bulk data encryption within rxgk is performed using the encryption
      framework defined by <a class='info' href='#RFC3961'>RFC3961<span> (</span><span class='info'>Raeburn, K., &ldquo;Encryption and Checksum Specifications for Kerberos 5,&rdquo; February&nbsp;2005.</span><span>)</span></a> [RFC3961]. Any
      algorithm which is defined using this framework and supported by 
      both client and server may be used.
   
</p>
<a name="usage"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2.1"></a><h3>2.1.&nbsp;
Key usage values</h3>

<p>In order to avoid using the same key for multiple tasks, key 
       derivation is employed. The following key usage values are used by 
       rxgk, their functions are as defined later in this document. 
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
const RXGK_CLIENT_ENC_PACKET		= 1026;
const RXGK_CLIENT_MIC_PACKET		= 1027;
const RXGK_SERVER_ENC_PACKET		= 1028;
const RXGK_SERVER_MIC_PACKET		= 1029;
const RXGK_CLIENT_ENC_RESPONSE		= 1030;
const RXGK_CLIENT_COMBINE_ORIG		= 1032;
const RXGK_SERVER_COMBINE_NEW		= 1034;
const RXGK_SERVER_ENC_TICKET		= 1036;
</pre></div>
<a name="anchor2"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3"></a><h3>3.&nbsp;
Security Levels</h3>

<p>rxgk supports the negotiation of a range of different security levels.
       These, along with the protocol constant that represents them during
       key negotiation, are:
</p>
<blockquote class="text"><dl>
<dt>Authentication only</dt>
<dd> (0) Provides only connection 
	 authentication, without either integrity or confidentiality 
	 protection. This mode of operation provides higher throughput, but
	 is vulnerable to man in the middle attacks. This corresponds
 	 to the traditional 'clear' security level
</dd>
<dt>Integrity</dt>
<dd> (1) Provides integrity protection only. 
	  Data is protected from modification by an attacker, but not against 
	  eavesdropping. This corresponds to the tranditional 'auth' level.
</dd>
<dt>Encryption</dt>
<dd> (2) Provides both integrity and 
	  confidentiality protection, corresponding to 'crypt'
</dd>
<dt>Bind</dt>
<dd> (3) Connection security is provided by channel
	  bindings with another layer. This mode of operation is experimental,
	  and this value is reserved for future expansion.
</dd>
</dl></blockquote>
<a name="tokens"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4"></a><h3>4.&nbsp;
Token Format</h3>

<p>An rxgk token is an opaque identifier which is specific to an particular
     application's implementation of rxgk. The token is completely opaque to
     the client, which just transmits it from server to server. The token must 
     permit the receiving server to identify the corresponding user and session
     key for the incoming connection - whether that be by encrypting the
     information within the token, or making the token a large random
     identifier which keys a lookup hash table on the server.
</p>
<p>The token MUST NOT expose the session key on the wire. It MUST be
     sufficiently random that an attacker cannot predict suitable token values
     by observing other connections. An attacker MUST NOT be able to forge
     tokens which convey a particular session key or identity.
</p>
<a name="anchor3"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5"></a><h3>5.&nbsp;
Key negotiation</h3>

<p>rxgk uses an independent RX RPC service for key negotiation. The 
       location of this service is application dependent. Within a given
       application protocol, a client must be able to locate the key
       negotiation service, and that service must be able to create tokens
       which can be read by the application server. The simplest deployment
       has the service running on every server, on the same transport
       endpoints, but using a separate, dedicated, rx service id.
</p>
<p>The key negotiation RPC is defined by the following XDR
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
    typedef afs_int32 RXGK_Enctypes&lt;&gt;;

    struct RXGK_StartParams {
        RXGK_Enctypes enctypes;
        afs_int32 levels&lt;&gt;;
        afs_int32 lifetime;
        afs_int32 bytelife;
        opaque client_nonce&lt;&gt;;
    };

    struct RXGK_ClientInfo {
        afs_int32 errorcode;
        afs_int32 flags;
        afs_int32 enctype;
        afs_int32 level;
        afs_int32 lifetime;
        afs_int32 bytelife;
        afs_int64 expiration;
        opaque mic&lt;&gt;;
        RXGK_Ticket_Crypt ticket;
        opaque server_nonce&lt;&gt;;
    };

    package RXGK_

    GSSNegotiate(IN RXGK_StartParams *client_start,
                 IN RXGK_Token *input_token_buffer,
                 IN RXGK_Token *opaque_in,
                 OUT RXGK_Token *output_token_buffer,
                 OUT RXGK_Token *opaque_out,
                 OUT afs_uint32 *gss_status,
                 OUT RXGK_Token *rxgk_info) = 1;

</pre></div>
<p>The client populates RXGK_StartParams with lists of its prefered
       options. These should be ordered from best to worst, with the 
       clients favoured option occuring first within the list. The 
       parameters are: 
</p>
<blockquote class="text"><dl>
<dt>enctypes:</dt>
<dd>List of encryption types from the 
	 Kerberos Encryption Type Number registry created in RFC3961 and 
	 maintained by IANA. This list indicates the encryption types that
 	 the client is prepared to support.
</dd>
<dt>levels:</dt>
<dd>List of supported rxgk transport encryption
	 levels.
</dd>
<dt>lifetime:</dt>
<dd>The maximum lifetime of the negotiated key,
	 in seconds.
</dd>
<dt>bytelife:</dt>
<dd>The maximum amount of data that the 
	 negotiated key should encrypt before being discared, expressed as
	 log 2 of the number of bytes. A 
 	 value of 0 indicates that there is no limit on the number of
	 bytes that may be transmitted. The byte lifetime is advisory - a
	 connection that is over its byte lifetime should be permitted to
	 continue, but clients should attempt to establish a new context
 	 at their earliest convenience.
</dd>
<dt>clientnonce:</dt>
<dd>A client generated string of random bytes,
	 to be used as input to the key generation.
</dd>
</dl></blockquote>
<p>The client then calls gss_init_sec_context() to obtain an output token
       to send to the server. The GSS service name is application dependent.
</p>
<p>The client then calls RXGK_GSSNegotiate, as defined above. This takes
       the following parameters
</p>
<blockquote class="text"><dl>
<dt>clientparms</dt>
<dd>The client params structure detailed above.
        This should remain constant across the negotiation
</dd>
<dt>input_token_buffer</dt>
<dd>The token produced by a call to
	gss_init_sec_context
</dd>
<dt>opaque_in</dt>
<dd>An opaque token, which was returned by the 
	server following a previous call to GSSNegotiate in this negotiation. 
	If this is the first call, this should be NULL.
</dd>
<dt>output_token_buffer</dt>
<dd>The token output by the server's call
	to gss_accept_sec_context
</dd>
<dt>opaque_out</dt>
<dd>An opaque token, which the server may use to
	preserve state information between multiple calls in the same context
	negotiate. The client should use this value as opaque_in in its next
	call to GSSNegotiate.
</dd>
<dt>gss_status</dt>
<dd>The major status code output by the server's
	call to gss_accept_sec_context
</dd>
<dt>rxgk_info</dt>
<dd>If gss_status == GSS_S_COMPLETE this contains an
	encrypted block containing the server's response to the client. See
	below.
</dd>
</dl></blockquote>
<p>Upon receiving the server's response, the client checks the 
       contents of gss_status. If this is GSS_S_CONTINUE_NEEDED, the client
       should call gss_init_sec_context again with the token provided by the
       server in output_token_buffer, followed by a further call to 
       GSSNegotiate, including the server's previous opaque_out as this call's
       opaque_in
</p>
<p>This process continues until the either the server, or client,
       encounters an error, or the server returns GSS_S_COMPLETE in gss_status.
       
</p>
<p>Upon completion, rxgk_info contains the XDR representation of a 
       RXGK_ClientInfo structure, encrypted using gss_wrap() with
       confidentiality protection. The client should decrypt this structure
       using gss_unwrap - ClientInfo contains the following server populated
       fields
</p>
<blockquote class="text"><dl>
<dt>errorcode</dt>
<dd>A policy (rather than connection establishment) 
        error code. If non-zero, an error has occured, the resulting key
	negotiation has failed, and the rest of the values in this structure
	are undefined.
</dd>
<dt>flags</dt>
<dd>
</dd>
<dt>enctype</dt>
<dd>The encryption type selected by the server.
	This will be one of the types listed by the client in its StartParams
	structure
</dd>
<dt>level</dt>
<dd>The rxgk security level selected by the server.
</dd>
<dt>lifetime</dt>
<dd>The connection lifetime, in seconds, as determined
	by the server (this must be less than or equal to the lifetime proposed
	by the client)
</dd>
<dt>bytelife</dt>
<dd>The maximum amount of data (in log 2 bytes) that
	may be transfered using this key. This must be less than or equal to
	the bytelife proposed by the client
</dd>
<dt>expiration</dt>
<dd>The time, in seconds since the Unix epoch, at
	which this token expires
</dd>
<dt>mic</dt>
<dd>The result of calling gss_get_mic over the XDR encoded
	representation of the StartParams request received by the server.
</dd>
<dt>token</dt>
<dd>An rxgk token. This is an opaque blob, as detailed
	earlier
</dd>
<dt>server_nonce</dt>
<dd>The nonce used by the server to create the K0
	used within the rxgk token
</dd>
</dl></blockquote>
<p>Upon receiving the server's response, the client must verify that the
        mic contained within it matches the MIC of the XDR representation of
	the StartParams structure it sent to the server (this prevents a man
	in the middle from performing a downgrade attack). It should also 
	verify that the server's selected connection properties match those 
	it proposed.
</p>
<p>The client may then compute K0, by taking the nonce it sent to the
        server (client_nonce), and the one it has just received (server_nonce),
        combining them together, and passsing them to gss_psuedo_random, with
        the GSS_C_PRF_KEY_FULL option
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
	gss_pseudo_random(gssapi_context,
			  GSS_C_PRF_KEY_FULL,
			  client_nonce || server_nonce,
			  K,
			  *K0);
</pre></div>
<p>|| is the concatenation operation
</p>
<p>K, the desired output length, is the key generation seed length as
        specified in the RFC3961 profile of the negotiated enctype
</p>
<a name="combine"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6"></a><h3>6.&nbsp;
The combine tokens operation</h3>

<a name="anchor4"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.1"></a><h3>6.1.&nbsp;
Overview</h3>

<p>A client may elect to combine multiple rxgk tokens in its possession
	 into a single token. This allows an rx connection to be secured using
	 a combination of multiple, individually established identities, which
	 provides additional security for a number of application protocols.
      
</p>
<p>Token combination is performed using the CombineTokens RPC call. The
	 client has two keys - K0 and K1, and two tokens, T0 and T1. It locally
	 combines the two keys using a defined combination alogrithm to produce
	 Kn. It then calls the CombineTokens RPC with T0 and T1, to receive a
	 new token, Tn, which has embeded within it Kn, as computed by the
	 server.
</p>
<a name="anchor5"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.2"></a><h3>6.2.&nbsp;
Key combination algorithm</h3>

<p>Assume that the tokens being combined are T0 and T1, with initial keys
	 K0 and K1. The new initial key for the combined token, Kn is computed
	 using the KRB-FX-CF2 operation, described in section 6.1 of 
	 <a class='info' href='#I-D.ietf-krb-wg-preauth-framework'>draft-ietf-krb-wg-preauth-framework-14<span> (</span><span class='info'>Hartman, S. and L. Zhu, &ldquo;A Generalized Framework for Kerberos Pre-Authentication,&rdquo; October&nbsp;2009.</span><span>)</span></a> [I&#8209;D.ietf&#8209;krb&#8209;wg&#8209;preauth&#8209;framework]. The constants 
	 pepper1 and pepper2 required by this operation are defined as the 
	 ASCII strings "AFS" and "rxgk" respectively.
      
</p>
<a name="anchor6"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.3"></a><h3>6.3.&nbsp;
RPC definition</h3>

<p>The combine keys RPC is defined as
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
    CombineTokens(IN opaque token0,
                  IN opaque token1,
                  OUT opaque new_token) = 2;
</pre></div>
<a name="anchor7"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.4"></a><h3>6.4.&nbsp;
Server operation</h3>

<p>The server receives both token0 and token1 from the RPC call, and 
         decrypts these tokens using its private key. Providing this decryption
	 is successful, it now has copies of the initial key (K0) from both
	 tokens. It then performs the key combination algorithm detailed above
	 to obtain a new key, Kn. The server constructs a new token, where each
	 of the numerical fields are set to the minimum of the values of each
	 of the original tokens, and the list of identities is the union of 
	 those in the original tokens. This new token contains the derived key,
	 Kn. The new token is encrypted with the server's private key, as 
	 normal, and returned to the client.
      
</p>
<a name="anchor8"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.5"></a><h3>6.5.&nbsp;
Client operation</h3>

<p>As detailed within the overview, the client calls the CombineTokens 
         RPC using two tokens, T0 and T1 within its posession. It then receives
 	 a new token, Tn from this call. The client can only make use of Tn to
	 establish an rxgk protected connection if it can derive Kn, which it 
	 can only do if it already knows K0 and K1.
      
</p>
<a name="class"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7"></a><h3>7.&nbsp;
The rxgk security class</h3>

<a name="anchor9"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.1"></a><h3>7.1.&nbsp;
Overview</h3>

<p>When a new connection using rxgk is created by the client, it stores the
        current timestamp (as start_time for the rest of this discussion), and 
      then uses this, along with other connection information, to derive a 
      transport key from the current user's master key.
</p>
<p>This key is then used to protect the first message the client sends
   to the server. The server follows the standard RX security
   establishment protocol, and responds to the client with a challenge.
   rxgk challenges simply contain some versioning information and a
   random nonce selected by the server.
</p>
<p>Upon receiving this challenge, the client uses the transport key to
	 encrypt an authenticator, which contains the server's nonce, and some
	 other connection information. The client sends this authenticator, 
         together with start_time and the current user's rxgk token, back 
	 to the server.
</p>
<p>The server decrypts the rxgk token to determine the master key in use,
         uses this to derive the transport key, which it in turn uses to 
         decrypt the authenticator, and thus validate the connection.
</p>
<a name="anchor10"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.2"></a><h3>7.2.&nbsp;
Rekeying</h3>

<p>As part of connection negotiation, the server and client agree upon
	 a number of advisory lifetimes (both time, and data, based) for
	 connection keys. Each connection has a key number, which starts at
	 0. When a connection exceeds one of its lifetimes, either side may
	 elect to increment the key number. When the other endpoint sees
	 a key number increment, it should reset all of its connection
	 counters. Endpoints should accept packets encrypted with either
	 the current, previous, or next key number, to allow for resends
	 around the rekeying process.
      
</p>
<p>The key version number is contained within the 16 bit spare field
	 of the RX header (used by previous security layers as a checksum
	 field), and expressed as an unsigned value in network byte order.
	 If rekeying would cause this value to wrap, then the endpoint
	 perform the rekey must terminate the connection.
      
</p>
<a name="anchor11"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.3"></a><h3>7.3.&nbsp;
Key derivation</h3>

<p>In order to avoid the sharing of keys between multiple connections,
         each connection has its own transport key, TK, which is derived
	 from the master key, K0. Derivation is performed using the PRF+ 
	 function defined in RFC4402, combined with the random-to-key function
	 of K0's encryption type, as defined in RFC3961. The PRF input data
	 is the concantenation of the rx epoch, connection ID, start_time and
	 key number, all in network byte order. This gives:
     
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
  TK = random-to-key(PRF+(K0, L,
	                  epoch || cid || start_time || key_number))
</pre></div>
<p>L is the key generation seed length as specified in the RFC3961
	 profile
</p>
<p>Note that start_time is selected by the client when it receives the
	 server's challenge, and shared with the server as part of its 
	 response. Thus both sides of the negotiation are guaranteed to use
	 the same value for start_time.
      
</p>
<a name="anchor12"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.4"></a><h3>7.4.&nbsp;
The Challenge</h3>

<p>The rxgk challenge is an XDR encoded structure with the following
         signature:
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
    struct RXGK_Challenge {
        afs_int32 version;
        opaque nonce[20];
    };
</pre></div>
<blockquote class="text"><dl>
<dt>version:</dt>
<dd>The rxgk version number
</dd>
<dt>nonce:</dt>
<dd>20 octets of random data
</dd>
</dl></blockquote>
<p>A client receiving a challenge containing an unknown version number
         MUST reject that challenge.
</p>
<a name="anchor13"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.5"></a><h3>7.5.&nbsp;
The Response</h3>

<p>The rxgk response is an XDR encoded structure, with the following 
       signature:
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
    struct RXGK_Response {
        afs_int32 version;
        afs_int64 start_time;
        opaque token&lt;&gt;
        opaque authenticator&lt;&gt;
    };
</pre></div>
<blockquote class="text"><dl>
<dt>version:</dt>
<dd>the rxgk version number
</dd>
<dt>start_time:</dt>
<dd>the number of seconds since the Unix epoch 
          (1970-1-1 00:00:00Z)
</dd>
<dt>authenticator:</dt>
<dd>the XDR encoded representation of 
          RXGK_Authenticator, encrypted with the transport key, and key usage
          RXGK_CLIENT_ENC_RESPONSE.
</dd>
</dl></blockquote>
<a name="anchor14"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.5.1"></a><h3>7.5.1.&nbsp;
The Authenticator</h3>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
    struct RXGK_Authenticator {
        opaque nonce[20];
	opaque appdata&lt;&gt;
        afs_uint32 epoch;
	afs_uint32 cid;
	afs_int32 maxcalls;
	afs_int32 call_numbers&lt;&gt;;
    };
</pre></div>
<blockquote class="text"><dl>
<dt>nonce:</dt>
<dd>a copy of the nonce from the challenge
</dd>
<dt>appdata:</dt>
<dd>an application specific opaque blob
</dd>
<dt>epoch:</dt>
<dd>the rx connection epoch
</dd>
<dt>cid:</dt>
<dd>the rx connection ID
</dd>
<dt>maxcalls:</dt>
<dd>the highest rx call number in use
</dd>
<dt>call_numbers:</dt>
<dd>the set of current rx call numbers
</dd>
</dl></blockquote>
<a name="anchor15"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.6"></a><h3>7.6.&nbsp;
Checking the Reponse</h3>

<p>To check the validity of an rxgk response, the authenticator should
        be decrypted, the nonce compared with that sent in the challenge, and
        the connection ID and epoch compared with that of the current
        connection. Failure of any of these steps MUST result in the failure
        of the security context.
     
</p>
<a name="anchor16"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.7"></a><h3>7.7.&nbsp;
Packet handling</h3>

<p>The way in which the rxgk security class handles packets depends upon 
	the requested security level. As noted earlier, 3 levels are currently
	defined - authentication only, integrity protection and encryption
</p>
<a name="anchor17"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.7.1"></a><h3>7.7.1.&nbsp;
Encryption</h3>

<p>Using the encryption security level provides both integrity and 
	confidentiality protection.
</p>
<p>The existing payload is prefixed with a psuedo header, to produce 
	the following data for encryption.
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                             epoch                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                              cid                                |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                          call number                            |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                            sequence                             |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                         security index                          |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
| Data ...                                                        |
+-+-+-+-+-+-

</pre></div>
<p>This plaintext is encrypted using an RFC3961 style encrypt() 
	function, with the connection's transport key, using key usage 
        RXGK_CLIENT_ENC_PACKET for messages from client to server, and
        RXGK_SERVER_ENC_PACKET for messages from server to client, and the
        encrypted block transmitted to the peer.
     
</p>
<a name="anchor18"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.7.2"></a><h3>7.7.2.&nbsp;
Integrity protection</h3>

<p>The rxgk_auth security level prepends the packet with the same data
	block as crypt (as detailed above), and then calls the RFC3961 
	get_mic operation over the result, using key usage
	RXGK_CLIENT_MIC_PACKET for messages from client to server, and 
	RXGK_SERVER_MIC_PACKET for messages from server to client.
</p>
<p>The peer is sent the output from the MIC operation, followed by the
        original payload (excluding the additional header which was added for
        the MIC step).
</p>
<p>Upon receiving a protected packet, the receiver should consult the 
        RFC3961 profile for the encryption algorithm in use to determine how
	many bytes of checksum are contained within the packet. Having split
	the data into checksum and payload using this information, the 
	checksum should be verified using the encryption profile's
	verify_mic() operation with the appropriate key derivation.
</p>
<p>Note that the checksum field within the rx packet header itself is not
        used, as it is too small to hold a collision proof checksum value.
</p>
<a name="anchor19"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.7.3"></a><h3>7.7.3.&nbsp;
Authentication only</h3>

<p>When running at the rxgk_clear level, no manipulation of the payload is
        performed by the security class.
</p>
<a name="IANA"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.8"></a><h3>8.&nbsp;
IANA Considerations</h3>

<p>This memo includes no request to IANA.
</p>
<a name="security"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.9"></a><h3>9.&nbsp;
Security Considerations</h3>

<a name="anchor20"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.9.1"></a><h3>9.1.&nbsp;
Abort Packets</h3>

<p>RX Abort packets are not protected by the security layer. Therefore
	  caution should be exercised when relying on their results. In
	  particular, clients MUST NOT use an error from GSSNegotiate or
	  CombineTokens to determine whether to downgrade to another 
	  security class
</p>
<a name="rfc.references1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>10.&nbsp;Normative References</h3>
<table width="99%" border="0">
<tr><td class="author-text" valign="top"><a name="RFC2119">[RFC2119]</a></td>
<td class="author-text"><a href="mailto:sob@harvard.edu">Bradner, S.</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>,&rdquo; BCP&nbsp;14, RFC&nbsp;2119, March&nbsp;1997 (<a href="http://www.rfc-editor.org/rfc/rfc2119.txt">TXT</a>, <a href="http://xml.resource.org/public/rfc/html/rfc2119.html">HTML</a>, <a href="http://xml.resource.org/public/rfc/xml/rfc2119.xml">XML</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC2743">[RFC2743]</a></td>
<td class="author-text"><a href="mailto:jlinn@rsasecurity.com">Linn, J.</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc2743">Generic Security Service Application Program Interface Version 2, Update 1</a>,&rdquo; RFC&nbsp;2743, January&nbsp;2000 (<a href="http://www.rfc-editor.org/rfc/rfc2743.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC3961">[RFC3961]</a></td>
<td class="author-text">Raeburn, K., &ldquo;<a href="http://tools.ietf.org/html/rfc3961">Encryption and Checksum Specifications for Kerberos 5</a>,&rdquo; RFC&nbsp;3961, February&nbsp;2005 (<a href="http://www.rfc-editor.org/rfc/rfc3961.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4401">[RFC4401]</a></td>
<td class="author-text">Williams, N., &ldquo;<a href="http://tools.ietf.org/html/rfc4401">A Pseudo-Random Function (PRF) API Extension for the Generic Security Service Application Program Interface (GSS-API)</a>,&rdquo; RFC&nbsp;4401, February&nbsp;2006 (<a href="http://www.rfc-editor.org/rfc/rfc4401.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="I-D.ietf-krb-wg-preauth-framework">[I-D.ietf-krb-wg-preauth-framework]</a></td>
<td class="author-text">Hartman, S. and L. Zhu, &ldquo;<a href="http://www.ietf.org/internet-drafts/draft-ietf-krb-wg-preauth-framework-15.txt">A Generalized Framework for Kerberos Pre-Authentication</a>,&rdquo; draft-ietf-krb-wg-preauth-framework-15 (work in progress), October&nbsp;2009 (<a href="http://www.ietf.org/internet-drafts/draft-ietf-krb-wg-preauth-framework-15.txt">TXT</a>).</td></tr>
</table>

<a name="anchor22"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.A"></a><h3>Appendix A.&nbsp;
Acknowledgements</h3>

<p>rxgk was originally developed over a number of AFS Hackathons. The
	editor of this document has assembled the protocol description from
	a number of notes taken at these meetings, and from a partial
	implementation in the Arla AFS client.
</p>
<p>Thanks to 
	Derrick Brashear, Jeffrey Hutzelman, Love Hornquist Astrand and 
        Chaskiel Grundman for their original design work, and comments on this
	document, and apologies for any omissions or misconceptions in my 
	archaelogical work.
</p>
<p>Marcus Watts and Jeffrey Altman provided invaluable feedback on an
	earlier version of this document at the 2009 Edinburgh AFS Hackathon.
     
</p>
<a name="rfc.authors"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>Author's Address</h3>
<table width="99%" border="0" cellpadding="0" cellspacing="0">
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Simon Wilkinson</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Your File System Inc</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:simon@sxw.org.uk">simon@sxw.org.uk</a></td></tr>
</table>
</body></html>
