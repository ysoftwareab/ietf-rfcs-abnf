



Network Working Group              Carsten Bormann (ed.), TZI/Uni Bremen
INTERNET-DRAFT
Expires: April 2000
                                          Carsten Burmeister, Matsushita
                                              Christopher Clanton, Nokia
                                          Mikael Degermark, U of Arizona
                                           Hideaki Fukushima, Matsushita
                                                    Hans Hannu, Ericsson
                                             Lars-Erik Jonsson, Ericsson
                                              Rolf Hakenberg, Matsushita
                                                      Tmima Koren, Cisco
                                                         Khiem Le, Nokia
                                                      Zhigang Liu, Nokia
                                              Anton Martensson, Ericsson
                                            Akihiro Miyazaki, Matsushita
                                               Krister Svanbro, Ericsson
                                               Thomas Wiebke, Matsushita
                                                    Haihong Zheng, Nokia

                                                        October 03, 2000
                     RObust Header Compression (ROHC)
                       <draft-ietf-rohc-rtp-03.txt>




Status of this memo

   This document is an Internet-Draft and is in full conformance with
   all provisions of Section 10 of RFC2026.

   Internet-Drafts are working documents of the Internet Engineering
   Task Force (IETF), its areas, and its working groups. Note that other
   groups may also distribute working documents as Internet-Drafts.

   Internet-Drafts are draft documents valid for a maximum of six months
   and may be updated, replaced, or obsoleted by other documents at any
   time. It is inappropriate to use Internet-Drafts as reference
   material or cite them other than as "work in progress".

   The list of current Internet-Drafts can be accessed at
   http://www.ietf.org/ietf/lid-abstracts.txt

   The list of Internet-Draft Shadow Directories can be accessed at
   http://www.ietf.org/shadow.html

   This document is a product of the IETF ROHC WG. Comments should be
   directed to its mailing list, rohc@cdt.luth.se.





Bormann (ed.)                                                   [Page 1]

INTERNET-DRAFT          Robust Header Compression           Oct 03, 2000



Abstract

   Existing header compression schemes do not work well when used over
   links with significant error rates and long round-trip times. For
   many bandwidth limited links where header compression is essential,
   such characteristics are common.

   A highly robust and efficient header compression scheme for
   RTP/UDP/IP and UDP/IP is specified in this document. The scheme can
   adapt to the characteristics of the link over which it is used and
   also to the properties of the packet streams whose headers it
   compresses.


Revision History

   -03: Redo packet formats to allow new ROHC framework. Fill in gaps.
   -02: Major changes after 48th IETF
   -01: Minor editorial changes for 48th IETF
   -00: Document created from ROHC submissions

































Bormann (ed.)                                                   [Page 2]

INTERNET-DRAFT          Robust Header Compression           Oct 03, 2000


Table of contents

   Status of this memo.................................................1
   Abstract............................................................2
   Revision History....................................................2
   Table of contents...................................................3
   0.  ROHC WG internal short-term time plan...........................8
   1.  Introduction....................................................9
   2.  Terminology....................................................11
   3.  Background.....................................................15
   3.1.  Header compression fundamentals..............................15
   3.2.  Existing header compression schemes..........................15
   3.3.  Requirements on a new header compression scheme..............17
   3.4.  Classification of header fields..............................17
   4.  Header compression framework...................................19
   4.1.  Operating assumptions .......................................19
   4.2.  Dynamicity...................................................20
   4.3.  Compression and decompression states.........................21
   4.3.1.  Compressor states..........................................22
   4.3.1.1.  Initialization and Refresh (IR) State....................22
   4.3.1.2.  First Order (FO) State...................................22
   4.3.1.3.  Second Order (SO) State..................................23
   4.3.2.  Decompressor states........................................23
   4.4.  Modes of operation...........................................24
   4.4.1.  Unidirectional mode - U-mode...............................24
   4.4.2.  Bi-directional optimistic mode - O-mode....................25
   4.4.3.  Bi-directional reliable mode - R-mode......................25
   4.5.  Encoding methods.............................................26
   4.5.1.  Least Significant Bits (LSB) encoding .....................26
   4.5.2.  Window-based LSB encoding (W-LSB encoding).................28
   4.5.3 . Scaled RTP Timestamp encoding .............................29
   4.5.4 .  Timer-Based Compression of RTP Timestamp .................30
   4.5.5.  Offset IP-ID encoding......................................33
   4.5.6.  Self-describing variable-length values. ...................34
   4.5.7.  Encoded values across several fields in compressed headers.35
   5.  The protocol...................................................36
   5.1.  Data structures..............................................36
   5.1.1.  Per-channel parameters.....................................36
   5.1.2.  Per-context parameters, profiles...........................36
   5.1.3.  Contexts and context identifiers ..........................36
   5.2.  Packet types.................................................37
   5.2.1.  Packet formats from compressor to decompressor ............37
   5.2.2.  Feedback from decompressor to compressor...................38
   5.2.3.  Parameters needed for mode transition......................40
   5.3.  Operation in unidirectional mode.............................41
   5.3.1.  Compressor states and logic (U-mode).......................41
   5.3.1.1.  State transition logic (U-mode)..........................41
   5.3.1.1.1.  Optimistic approach, upwards transition................41
   5.3.1.1.2.  Timeouts, downward transition..........................42
   5.3.1.1.3.  Need for updates, downward transition..................42
   5.3.1.2.  Compression logic and packets used (U-mode)..............42



Bormann (ed.)                                                   [Page 3]

INTERNET-DRAFT          Robust Header Compression           Oct 03, 2000


   5.3.1.3.  Feedback in unidirectional mode..........................42
   5.3.2.  Decompressor states and logic (U-mode).....................42
   5.3.2.1.  State transition logic (U-mode)..........................43
   5.3.2.2.  Decompression logic (U-mode).............................43
   5.3.2.2.1.  Decide whether decompression is allowed................43
   5.3.2.2.2.  Reconstruct and verify the header......................43
   5.3.2.2.3.  Actions upon CRC failure...............................44
   5.3.2.2.3.1.  Correction of SN wrap-around.........................45
   5.3.2.2.3.2.  Repair of incorrect SN updates.......................45
   5.3.2.2.3.3.  Judge whether bit error or context damage............46
   5.3.2.3.  Feedback in unidirectional mode..........................47
   5.4.  Operation in bi-directional optimistic mode..................48
   5.4.1.  Compressor states and logic (O-mode).......................48
   5.4.1.1.  State transition logic...................................48
   5.4.1.1.1.  Negative acknowledgements (NACKs), downward transition.48
   5.4.1.1.2.  Optional acknowledgements, upwards transition..........48
   5.4.1.2.  Compression logic and packets used.......................49
   5.4.2.  Decompressor states and logic (O-mode).....................49
   5.4.2.1.  Decompression logic, timer-based timestamp decompression.49
   5.4.2.2.  Feedback logic (O-mode)..................................49
   5.5.  Operation in bi-directional reliable mode....................51
   5.5.1.  Compressor states and logic (R-mode).......................51
   5.3.1.1.  State transition logic (R-mode)..........................51
   5.5.2.  Decompressor states and logic (R-mode).....................51
   5.5.2.1.  Decompression logic (R-mode).............................51
   5.5.2.2.  Feedback logic (R-mode)..................................51
   5.6.  Mode transitions.............................................52
   5.6.1.  Compression and decompression during mode transitions......52
   5.6.2.  Transition from Unidirectional to Optimistic mode..........53
   5.6.3.  From Optimistic to Reliable mode...........................54
   5.6.4.  From Unidirectional to Reliable mode.......................54
   5.6.5.  From Reliable to Optimistic mode...........................54
   5.6.6.  Transition to Unidirectional mode..........................56
   5.7.  Packet formats ..............................................57
   5.7.1.  Packet type 0: UO-0, R-0, R-0-CRC .........................61
   5.7.2.  Packet type 1 (R-mode): R-1, R-1-TS, R-1-ID ...............61
   5.7.3.  Packet type 1 (UO-modes): UO-1, UO-1-ID, UO-1-TS ..........63
   5.7.4.  Packet type 2: UOR-2 ......................................64
   5.7.5.  Extension formats .........................................65
   5.7.5.1 RND flags and packet types ................................69
   5.7.5.2 Flags/Fields in context ...................................70
   5.7.6.  Feedback packets and formats ..............................71
   5.7.6.1 Feedback packet type for ROHC RTP..........................71
   5.7.6.2 Feedback formats for ROHC RTP..............................72
   5.7.6.3 RTP Feedback options ......................................74
   5.7.6.4 The CRC option ............................................74
   5.7.6.5 The REJECT option .........................................74
   5.7.6.6 The SN option .............................................75
   5.7.6.7 The CLOCK option ..........................................75
   5.7.6.8 The JITTER option .........................................75
   5.7.6.9 The LOSS option ...........................................76



Bormann (ed.)                                                   [Page 4]

INTERNET-DRAFT          Robust Header Compression           Oct 03, 2000


   5.7.6.10 Unknown option types .....................................76
   5.7.6.11 RTP feedback example .....................................77
   5.7.7  IR and IR-DYN packets.......................................77
   5.7.7.2. Basic structure of the IR-DYN packet......................79
   5.7.7.3.  Initialization of IPv6 Header [IPv6].....................80
   5.7.7.4. Initialization of IPv4 Header [IPv4, section 3.1].........81
   5.7.7.5. Initialization of UDP Header [RFC-768]....................82
   5.7.7.6. Initialization of RTP Header [RTP]........................82
   5.7.7.7.  Minimal Encapsulation header [RFC-2004, section 3.1].....83
   5.8 List-Based Compression.........................................84
   5.8.1.  CSRC compression...........................................84
   5.8.1.1.  Transformation Classification for CSRC List..............84
   5.8.1.2.  Encoding Schemes.........................................85
   5.8.1.3. Format of compressed CSRC list............................85
   5.8.1.3.1 Insertion Only Scheme....................................85
   5.8.1.3.1.1 R-mode.................................................85
   5.8.1.3.1.2 UO-modes...............................................86
   5.8.1.3.2 Removal Only Scheme......................................87
   5.8.1.3.2.1 R-mode.................................................87
   5.8.1.3.2.2 UO-mode................................................87
   5.8.1.3.3 Generic Scheme...........................................88
   5.8.1.3.3.1 R-mode.................................................88
   5.8.1.3.3.2 UO-mode................................................89
   5.8.2.  Header Compression for IPv6 Extension Headers..............89
   5.8.2.1. Terminology...............................................90
   5.8.2.2. Transformation Classification and Encoding Schemes........90
   5.8.2.2.1 Transformation Classification............................90
   5.8.2.2.2 Encoding Schemes.........................................91
   5.8.2.2.3 Special Handling.........................................91
   5.8.2.2.3.1 Special Handling of AH.................................91
   5.8.2.2.3.2 Encapsulating Security Payload Header..................92
   5.8.2.2.3.3 Special Handling of Next Header Field..................92
   5.8.2.3. Packet Format.............................................94
   5.8.2.3.1. Format in extension "11" header.........................94
   5.8.2.3.2 Format of compressed IPv6 extension header...............95
   5.8.2.3.2.1 Insertion Only Scheme..................................95
   5.8.2.3.2.1.1 R-mode...............................................95
   5.8.2.3.2.2 Removal Only Scheme....................................96
   5.8.2.3.2.2.1 R-mode...............................................96
   5.8.2.3.2.3 Content Change Only Scheme.............................97
   5.8.2.3.2.3.1 R-mode...............................................97
   5.8.2.3.2.3.2 UO-mode..............................................98
   5.8.2.3.2.4 Uncompressed Scheme (common to R-mode and UO-modes)....98
   5.9.  Header compression CRCs, coverage and polynomials............99
   5.9.1.  IR & IR-DYN packet CRCs....................................99
   5.9.2.  CRCs in compressed packets.................................99
   5.10. ROHC UDP _ non-RTP UDP/IP compression (Profile 1)...........100
   5.10.1 Initialization.............................................100
   5.10.2 States and Modes...........................................101
   5.10.3 Packet types...............................................101
   5.10.4 Extensions.................................................101



Bormann (ed.)                                                   [Page 5]

INTERNET-DRAFT          Robust Header Compression           Oct 03, 2000


   5.10.5 IP-ID......................................................102
   5.10.6. Feedback..................................................102
   6.  Implementation issues.........................................104
   6.1.  Reverse decompression.......................................104
   6.2.  RTCP........................................................105
   6.3.  Implementation parameters and signals.......................105
   6.3.1.  ROHC implementation parameters at compressor:.............106
   6.3.2.  ROHC implementation parameters at decompressor:...........106
   6.5.  Handling of resource limitations at the decompressor........107
   7.  Further work..................................................108
   7.3.  Tunneling...................................................108
   7.3.1.  Header Compression for IPv4 Tunneling Header..............108
   7.3.1.1.  Mobile IPv4 Tunneling Header Fields Type................108
   7.3.1.2.  Compression of Tunneling Headers in MIPv4...............109
   7.3.1.2.1.  IP in IP Encapsulation in IPv4........................109
   7.3.1.2.2.  Minimum Encapsulation in IPv4.........................109
   7.3.1.2.3.  Generic Routing Encapsulation in IPv4.................109
   8.  Section 8 has been removed....................................110
   9.  Security considerations.......................................110
   10.  Acknowledgements.............................................110
   11.  Intellectual property considerations.........................112
   12.  References...................................................113
   13.  Authors' addresses...........................................114
   Appendix A.  Detailed classification of header fields.............115
   A.1.  General classification......................................115
   A.1.1.  IPv6 header fields........................................116
   A.1.2.  IPv4 header fields........................................117
   A.1.3.  UDP header fields.........................................119
   A.1.4.  RTP header fields.........................................120
   A.1.5.  Summary for IP/UDP/RTP....................................121
   A.2.  Analysis of change patterns of header fields................121
   A.2.1.  IPv4 Identification.......................................123
   A.2.2.  IP Traffic-Class / Type-Of-Service........................124
   A.2.3.  IP Hop-Limit / Time-To-Live...............................125
   A.2.4.  UDP Checksum..............................................125
   A.2.5.  RTP CSRC Counter..........................................125
   A.2.6.  RTP Marker................................................125
   A.2.7.  RTP Payload Type..........................................125
   A.2.8.  RTP Sequence Number.......................................125
   A.2.9.  RTP Timestamp.............................................125
   A.2.10.  RTP Contributing Sources (CSRC)..........................126
   A.3.  Header compression strategies...............................126
   A.3.1.  Do not send at all........................................126
   A.3.2.  Transmit only initially...................................127
   A.3.3.  Transmit initially, but be prepared to update.............127
   A.3.4.  Be prepared to update or send as-is frequently............127
   A.3.5.  Guarantee continuous robustness...........................127
   A.3.6.  Transmit as-is in all packets.............................128
   A.3.7.  Establish and be prepared to update delta.................128
   Appendix E - Encoding Examples....................................129
   E.1.  Basic VLE...................................................129



Bormann (ed.)                                                   [Page 6]

INTERNET-DRAFT          Robust Header Compression           Oct 03, 2000


   E.2.  Timer-Based VLE.............................................130



   (Editor's note: The TOC has not necessarily been updated.)

















































Bormann (ed.)                                                   [Page 7]

INTERNET-DRAFT          Robust Header Compression           Oct 03, 2000


0.  ROHC WG internal short-term time plan

   This document captures the state of the ROHC RTP specification as on
   October 03, 2000.  For information, the ROHC WG internal short-term
   time plan that led to this document is as follows:

       18 September    ROHC-02 completed

               Draft review and discussion

               Complementary contributions created

       29 September    Cutoff for draft review and discussion

       02 October      ROHC-03 completed (this document)

       04 October      Judge whether draft ready for last call

   As of Oct 04, the WG chairs believe this draft is not yet ready for
   last call on Oct 04. At least the following points are identified as
   to be completed:

                          Complete section 5.5.
                          Merge section 5.8 and 7.3.
                          Align terminology in informational Appendix E.

   Time plan for continued work is as follows.

       10 October      ROHC-04 Completed.

       13 October      Cutoff for draft review and discussion

       16 October      ROHC-05 Completed

   WG Last call at completion of ROHC-05 on October 16.



















Bormann (ed.)                                                   [Page 8]

INTERNET-DRAFT          Robust Header Compression           Oct 03, 2000



1.  Introduction

   During the last five years, two communication technologies in
   particular have become commonly used by the general public: cellular
   telephony and the Internet. Cellular telephony has provided its users
   with the revolutionary possibility of always being reachable with
   reasonable service quality no matter where they are. The main service
   provided by the dedicated terminals has been speech. The Internet, on
   the other hand, has from the beginning been designed for multiple
   services and its flexibility for all kinds of usage has been one of
   its strengths. Internet terminals have usually been general-purpose
   and have been attached over fixed connections. The experienced
   quality of some services (such as Internet telephony) has sometimes
   been low.

   Today, IP telephony is gaining momentum thanks to improved technical
   solutions. It seems reasonable to believe that in the years to come,
   IP will become a commonly used way to carry telephony. Some future
   cellular telephony links might also be based on IP and IP telephony.
   Cellular phones may have become more general-purpose, and may have IP
   stacks supporting not only audio and video, but also web browsing,
   email, gaming, etc.

   One of the scenarios we are envisioning might then be the one in
   Figure 1.1, where two mobile terminals are communicating with each
   other. Both are connected to base stations over cellular links, and
   the base stations are connected to each other through a wired (or
   possibly wireless) network. Instead of two mobile terminals, there
   could of course be one mobile and one wired terminal, but the case
   with two cellular links is technically more demanding.


   Mobile            Base                      Base            Mobile
   Terminal          Station                   Station         Terminal


         |  ~   ~   ~  \ /                       \ /  ~   ~   ~   ~  |
         |              |                         |                  |
      +--+              |                         |               +--+
      |  |              |                         |               |  |
      |  |              |                         |               |  |
      +--+              |                         |               +--+
                        |                         |
                        |=========================|

            Cellular              Wired               Cellular
            Link                  Network             Link

        Figure 1.1 : Scenario for IP telephony over cellular links




Bormann (ed.)                                                   [Page 9]

INTERNET-DRAFT          Robust Header Compression           Oct 03, 2000


   It is obvious that the wired network can be IP-based. With the
   cellular links, the situation is less clear. IP could be terminated
   in the fixed network, and special solutions implemented for each
   supported service over the cellular link. However, this would limit
   the flexibility of the services supported. If technically and
   economically feasible, a solution with pure IP all the way from
   terminal to terminal would have certain advantages. However, to make
   this a viable alternative, a number of problems have to be addressed,
   in particular problems regarding bandwidth efficiency.

   For cellular phone systems, it is of vital importance to use the
   scarce radio resources in an efficient way. A sufficient number of
   users per cell is crucial, otherwise deployment costs will be
   prohibitive [CELL]. The quality of the voice service should also be
   as good as in today's cellular systems. It is likely that even with
   support for new services, lower quality of the voice service is
   acceptable only if costs are significantly reduced.

   A problem with IP over cellular links when used for interactive voice
   conversations is the large header overhead. Speech data for IP
   telephony will most likely be carried by RTP [RTP]. A packet will
   then, in addition to link layer framing, have an IP [IPv4] header (20
   octets), a UDP [UDP] header (8 octets), and an RTP header (12 octets)
   for a total of 40 octets. With IPv6 [IPv6], the IP header is 40
   octets for a total of 60 octets. The size of the payload depends on
   the speech coding and frame sizes being used and may be as low as 15-
   20 octets.

   From these numbers, the need for reducing header sizes for efficiency
   reasons is obvious. However, cellular links have characteristics that
   make header compression as defined in [IPHC,CRTP,PPPHC] perform less
   than well. The most important characteristic is the lossy behavior of
   cellular links, where a bit error rate (BER) as high as 1e-3 must be
   accepted to keep the radio resources efficiently utilized [CELL]. In
   severe operating situations, the BER can be as high as 1e-2. The
   other problematic characteristic is the long round-trip time (RTT) of
   the cellular link, which can be as high as 100-200 milliseconds
   [CELL]. An additional problem is that the residual BER is nontrivial,
   i.e., lower layers can sometimes deliver frames containing undetected
   errors. A viable header compression scheme for cellular links must be
   able to handle loss on the link between the compression and
   decompression point as well as loss before the compression point.

   Bandwidth is the most costly resource in cellular links. Processing
   power is very cheap in comparison. Implementation or computational
   simplicity of a header compression scheme is therefore of less
   importance than its compression ratio and robustness.







Bormann (ed.)                                                  [Page 10]

INTERNET-DRAFT          Robust Header Compression           Oct 03, 2000


2.  Terminology

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
   document are to be interpreted as described in RFC 2119.

   BER

    Bit Error Rate. Cellular radio links can have a rather high BER. In
    this document BER is usually given as a probability, but one also
    needs to consider the error distribution as bit errors are not
    independent.

   Cellular links

    Wireless links between mobile terminals and base stations. The BER
    and the RTT are rather high in order to achieve an efficient system
    overall.

   Compression efficiency

    The performance of a header compression scheme can be described
    with three parameters, compression efficiency, robustness and
    compression transparency. The compression efficiency is determined
    by how much the header sizes are reduced by the compression scheme.

   Compression transparency

    The performance of a header compression scheme can be described
    with three parameters, compression efficiency, robustness and
    compression transparency. The compression transparency is a measure
    for how well the scheme ensures that the decompressed headers are
    semantically identical to the original headers. If all decompressed
    headers are semantically identical to the corresponding original
    headers, the transparency is 100 per cent. Compression transparency
    is high when damage propagation is low.

   Context

    The context is the state which the compressor uses to compress a
    header and which the decompressor uses to decompress a header. The
    context basically contains the uncompressed version of the last
    header sent (compressor) or received (decompressor) over the link,
    except for fields in the header that are included "as-is" in
    compressed headers or can be inferred from, e.g., the size of the
    link-level frame. The context can also contain additional
    information describing the packet stream, for example the typical
    inter-packet increase in sequence numbers or timestamps.

   Context damage




Bormann (ed.)                                                  [Page 11]

INTERNET-DRAFT          Robust Header Compression           Oct 03, 2000


    When the context of the decompressor is not consistent with the
    context of the compressor, header decompression may fail to
    reproduce the original header. This situation can occur when the
    context of the decompressor has not been initialized properly or
    when packets have been lost or damaged between compressor and
    decompressor. Packets for which the decompressor detects they
    cannot be decompressed due to inconsistent contexts are said to be
    lost due to context damage.

   Context repair mechanism

    To avoid excessive context damage, a context repair mechanism is
    needed. Context repair mechanisms can be based on explicit requests
    for context updates, periodic updates sent by the compressor, or
    methods for local repair at the decompressor side.

   CRC-DYNAMIC

     Opposite of CRC-STATIC.

   CRC-STATIC

     A CRC over the original header is the primary mechanism of ROHC to
     detect incorrect decompression. In order to decrease computational
     complexity, the fields of the header are conceptually rearranged
     when computing the CRC, such that it is first computed over octets
     which are static (called CRC-STATIC in this document) and then over
     octets whose values are expected to change between packets (CRC-
     DYNAMIC). In this manner, the intermediate result of the CRC
     computation, after it has covered the CRC-STATIC fields, can be
     reused for several packets. The restarted CRC computation only
     covers the CRC-DYNAMIC octets.  See also section 5.9.

   Damage propagation

     Generation of incorrect decompressed headers due to damage to
     previous packet(s).

   Loss propagation

     Failure to decompress headers due to loss of previous frame(s).

   Error detection

     Detection of errors. If error detection is not perfect, there will
     be residual errors.

   Error propagation

     Damage propagation or loss propagation.




Bormann (ed.)                                                  [Page 12]

INTERNET-DRAFT          Robust Header Compression           Oct 03, 2000


   FLR

    Frame Loss Rate, given as a probability that a frame is lost on the
    channel between compressor and decompressor.  (In contrast, frames
    lost due to context damage contribute to the packet loss rate.)

   Frame

     Packet emitted by the compressor/received by the decompressor.
     Note that, in this document, there is no relationship to other
     (e.g. physical layer) frame concepts such as radio frames.

   Header compression profile

    A header compression profile is a specification of how to compress
    the headers of a certain kind of packet stream over a certain kind
    of link. Compression profiles provide the details of the header
    compression framework introduced in this document. The profile
    concept makes use of profile identifiers to separate different
    profiles which are used when setting up the compression scheme. All
    variations and parameters of the header compression scheme that are
    not part of the context state are handled by different profile
    identifiers.

   Packet

     Generally, a unit of transmission and reception (protocol data
     unit).  Specifically, when contrasted to "frame", the packet
     compressed and then decompressed by ROHC.  Also called
     "uncompressed packet".

   Pre-HC links

    Pre-HC links are all links a packet has traversed before the header
    compression point. If we consider a path with cellular links as
    first and last hops, the Pre-HC links for the compressor at the
    last link are the first cellular link plus the wired links in
    between.

   Residual error

     Error introduced during transmission and not detected by lower-
     layer error detection schemes.

   Robustness

    The performance of a header compression scheme can be described
    with three parameters, compression efficiency, robustness and
    compression transparency. A robust scheme tolerates errors on the
    link over which header compression takes place (including both




Bormann (ed.)                                                  [Page 13]

INTERNET-DRAFT          Robust Header Compression           Oct 03, 2000


    frame losses and residual bit errors) without losing additional
    packets, introducing additional errors, or using more bandwidth.

   RTT

    Round-trip time -- The time it takes to send a packet from
    compressor to decompressor and back again from decompressor to
    compressor.

   Simplex link

    A simplex (or unidirectional) link is a point to point link without
    a return channel. Over simplex links, header compression must rely
    on periodic refreshes since feedback from the decompressor can not
    be sent to the compressor.

   Spectrum efficiency

    Radio resources are limited and expensive. Therefore they must be
    used efficiently to make the system economically feasible. In
    cellular systems this is achieved by maximizing the number of users
    served within each cell, while the quality of the provided services
    is kept at an acceptable level. A consequence of efficient spectrum
    use is a high rate of errors (frame loss and residual bit errors),
    even after channel coding with error correction.

   Timestamp stride

    The timestamp stride (TS STRIDE) is the expected increase in the
    timestamp value between two RTP packets with consecutive sequence
    numbers.























Bormann (ed.)                                                  [Page 14]

INTERNET-DRAFT          Robust Header Compression           Oct 03, 2000


3.  Background

   This chapter provides a background to the subject of header
   compression. The fundamental ideas are described together with
   descriptions of existing header compression schemes, their drawbacks
   and requirements and motivation for new header compression solutions.


3.1.  Header compression fundamentals

   The main reason why header compression can be done at all is the fact
   that there is significant redundancy between header fields, both
   within the same packet header but in particular between consecutive
   packets belonging to the same packet stream. By sending static field
   information only initially and utilizing dependencies and
   predictability for other fields, the header size can be significantly
   reduced for most packets.

   In general, header compression methods maintain a context, which is
   essentially the uncompressed version of the last header sent over the
   link, plus some additional information, at both compressor and
   decompressor. Compression and decompression are done relative to the
   context. When compressed headers carry differences from the previous
   header, each compressed header will update the context of the
   decompressor. In this case, when a packet is lost between compressor
   and decompressor, the context of the decompressor will be brought out
   of sync since it is not updated correctly. A header compression
   method must have a way to repair the context, i.e., bring it into
   sync, after such events.


3.2.  Existing header compression schemes

   The original header compression scheme, CTCP [VJHC], was invented by
   Van Jacobson. CTCP compresses the 40 octet IP+TCP header to 4 octets.
   The CTCP compressor detects transport-level retransmissions and sends
   a header that updates the context completely when they occur. This
   repair mechanism does not require any explicit signaling between
   compressor and decompressor.

   A general IP header compression scheme, IP header compression [IPHC],
   improves somewhat on CTCP and can compress arbitrary IP, TCP, and UDP
   headers. When compressing non-TCP headers, IPHC does not use delta
   encoding and is robust. When compressing TCP, the repair mechanism of
   CTCP is augmented with a link-level nacking scheme which speeds up
   the repair. IPHC does not compress RTP headers.

   CRTP [CRTP, IPHC] by Casner and Jacobson is a header compression
   scheme that compresses 40 octets of IPv4/UDP/RTP headers to a minimum
   of 2 octets when no UDP checksum is present. If the UDP checksum is
   present, the minimum CRTP header is 4 octets. CRTP cannot use the



Bormann (ed.)                                                  [Page 15]

INTERNET-DRAFT          Robust Header Compression           Oct 03, 2000


   same repair mechanism as CTCP since UDP/RTP does not retransmit.
   Instead, CRTP uses explicit signaling messages from decompressor to
   compressor, called CONTEXT_STATE messages, to indicate that the
   context is out of sync. The link roundtrip time will thus limit the
   speed of this context repair mechanism.

   On lossy links with long roundtrip times, such as most cellular
   links, CRTP does not perform well. Each lost packet over the link
   causes several subsequent packets to be lost since the context is out
   of sync during at least one link roundtrip time. This behavior is
   documented in [CRTPC]. For voice conversations such long loss events
   will degrade the voice quality. Moreover, bandwidth is wasted by the
   large headers sent by CRTP when updating the context. [CRTPC] found
   that CRTP did not perform well enough for a lossy cellular link. It
   is clear that CRTP alone is not a viable header compression scheme
   for IP telephony over cellular links.

   To avoid losing packets due to the context being out of sync, CRTP
   decompressors can attempt to repair the context locally by using a
   mechanism known as TWICE. Each CRTP packet contains a counter which
   is incremented by one for each packet sent out by the CRTP
   compressor. If the counter increases by more than one, at least one
   packet was lost over the link. The decompressor then attempts to
   repair the context by guessing how the lost packet(s) would have
   updated it. The guess is then verified by decompressing the packet
   and checking the UDP checksum - if it succeeds, the repair is deemed
   successful and the packet can be forwarded or delivered. TWICE has
   got its name from the observation that when the compressed packet
   stream is regular, the correct guess is to apply the update in the
   current packet twice. [CRTPC] found that even with TWICE, CRTP
   doubled the number of lost packets. TWICE improves CRTP performance
   significantly. However, there are several problems with using TWICE:

   1) It becomes mandatory to use the UDP checksum:

      - the minimal compressed header size increases by 100% to 4
        octets.

      - most speech codecs developed for cellular links tolerate errors
        in the encoded data. Such codecs will not want to enable the UDP
        checksum, since they do want damaged packets to be delivered.

      - errors in the payload will make the UDP checksum fail when the
        guess is correct (and might make it succeed when it is wrong).

   2) Loss in an RTP stream that occurs before the compression point
      will make updates in CRTP headers less regular. Simple-minded
      versions of TWICE will then perform badly. More sophisticated
      versions would need more repair attempts to succeed.





Bormann (ed.)                                                  [Page 16]

INTERNET-DRAFT          Robust Header Compression           Oct 03, 2000




3.3.  Requirements on a new header compression scheme

   The major problem with CRTP is that it is not sufficiently robust
   against packets being damaged between compressor and decompressor. A
   viable header compression scheme must be less fragile. This increased
   robustness must be obtained without increasing the compressed header
   size; a larger header would make IP telephony over cellular links
   economically unattractive.

   A major cause of the bad performance of CRTP over cellular links is
   the long link roundtrip time, during which many packets are lost when
   the context is out of sync. This problem can be attacked directly by
   finding ways to reduce the link roundtrip time. Future generations of
   cellular technologies may indeed achieve lower link roundtrip times.
   However, these will probably always be rather high [CELL]. The
   benefits in terms of lower loss and smaller bandwidth demands if the
   context can be repaired locally will be present even if the link
   roundtrip time is decreased. A reliable way to detect a successful
   context repair is then needed.

   One might argue that a better way to solve the problem is to improve
   the cellular link so that packet loss is less likely to occur. Such
   modifications do not appear to come for free, however. If links were
   made (almost) error free, the system might not be able to support a
   sufficiently large number of users per cell and might thus be
   economically infeasible [CELL].

   One might also argue that the speech codecs should be able to deal
   with the kind of packet loss induced by CRTP, in particular since the
   speech codecs probably must be able to deal with packet loss anyway
   if the RTP stream crosses the Internet. While the latter is true, the
   kind of loss induced by CRTP is difficult to deal with. It is usually
   not possible to completely hide a loss event where well over 100 ms
   worth of sound is completely lost. If such loss occurs frequently at
   both ends of the end-to-end path, the speech quality will suffer.

   A detailed description of the requirements specified for ROHC may be
   found in [REQ].


3.4.  Classification of header fields

   As mentioned earlier, header compression is possible due to the fact
   that there is much redundancy between header field values within
   packets, but especially between consecutive packets. To utilize these
   properties for header compression, it is important to understand the
   change patterns of the various header fields.





Bormann (ed.)                                                  [Page 17]

INTERNET-DRAFT          Robust Header Compression           Oct 03, 2000


   All header fields have been classified in detail in appendix A. The
   fields are first classified on a high level and then some of them are
   studied more in detail. Finally, the appendix concludes with
   recommendations about how the various fields should be handled by
   header compression algorithms. The main conclusion that can be drawn
   is that most of the header fields can easily be compressed away since
   they never or seldom change. Only 5 fields, with a combined size of
   about 10 octets, need more sophisticated mechanisms. Those fields
   are:

    - IPv4 Identification (16 bits)   - IP-ID
    - UDP Checksum (16 bits)
    - RTP Marker (1 bit)              - M-bit
    - RTP Sequence Number (16 bits)   - SN
    - RTP Timestamp (32 bits)         - TS

   The analysis in Appendix A reveals that the values of the TS and IP-
   ID fields can usually be predicted from the RTP Sequence Number,
   which increments by one for each packet emitted by an RTP source. M-
   bit is also usually the same, but needs to be communicated explicitly
   occasionally. The UDP checksum should not be predicted and is sent
   as-is when enabled.

   The way ROHC RTP compression operates, then, is to first establish
   functions from SN to the other fields, and then reliably communicate
   the SN. Whenever a function from SN to another field changes, i.e.,
   the existing function gives a result which is different from the
   field in the header to be compressed, additional information is sent
   to update the parameters of that function.

























Bormann (ed.)                                                  [Page 18]

INTERNET-DRAFT          Robust Header Compression           Oct 03, 2000



4.  Header compression framework


4.1.  Operating assumptions

   The cellular links which are a primary target for ROHC have a number
   of characteristics that are briefly described here. ROHC requires
   functionality from lower layers which is outlined here and more
   thoroughly described in the lower layer guidelines document [LLG].

   Channels

     ROHC header-compressed packets flow on channels. Unlike many fixed
     links, some cellular radio links can have several channels
     connecting the same pair of nodes. Each channel can have different
     characteristics in terms of error rate, bandwidth, etc.

   Context identifiers

     On some channels, the ability to transport multiple packet streams
     is required.  It can also be feasible to have channels dedicated to
     individual packet streams. Therefore, ROHC uses a distinct context
     identifier space per channel and can eliminate context identifiers
     completely in channels where only a single packet stream is
     compressed.

   Packet type indication

     Packet type indication is done in the header compression scheme
     itself. Unless the link already has a way of indicating packet
     types which can be used, such as PPP, this provides smaller
     compressed headers, overall. It may also be less difficult to
     allocate a single packet type, rather than many, in order to run
     ROHC over links such as PPP.

   Reordering

     The channel between compressor and decompressor is not assumed to
     reorder packets, i.e., the decompressor receives packets in the
     same order as the compressor sends them.  (Reordering before the
     compression point, however, is dealt with, i.e., there is no
     assumption that the compressor will only receive packets in
     sequence.)

   Packet length


     ROHC is designed under the assumption that lower layers indicate
     the length of a compressed packet. ROHC packets do not contain
     length information for the payload.



Bormann (ed.)                                                  [Page 19]

INTERNET-DRAFT          Robust Header Compression           Oct 03, 2000



   Framing

     The link layer must provide framing, which makes it possible to
     distinguish frame boundaries and individual frames.

   Error detection/protection

     The ROHC scheme has been designed to cope with residual errors in
     the headers delivered to the decompressor. CRCs and sanity checks
     are used to prevent or reduce damage propagation. However, it is
     RECOMMENDED that lower layers deploy error detection for ROHC
     headers and do not deliver ROHC headers with high residual error
     rates.

     Without giving a hard limit on the residual error rate acceptable
     to ROHC, it is noted that for a residual bit error rate of at most
     1E-5, the ROHC scheme has been designed not to increase the number
     of damaged headers, i.e., the number of damaged headers due to
     damage propagation is designed to be less than the number of
     damaged headers caught by the ROHC error detection scheme.

   Negotiation

     In addition to the packet handling mechanisms above, the link layer
     MUST provide a way to negotiate header compression parameters.
     (For unidirectional links, this negotiation may be performed out-
     of-band or even a-priori.)


4.2.  Dynamicity

   The ROHC protocol achieves its compression gain by establishing state
   at both ends of the link, i.e., at the compressor and at the
   decompressor. Different parts of the state are established at
   different times and with different frequency; hence, it can be said
   some state is more dynamic that other state.

   Some state is established at the time a channel is established; ROHC
   assumes the existence of an out-of-band negotiation protocol (such as
   PPP), or pre-defined channel state (most useful for uni-directional
   links). In both cases, we speak of "negotiated channel state".  ROHC
   does not assume that this state can change dynamically during the
   channel lifetime (and does not explicitly support such changes,
   although some changes may be innocuous from a protocol point of
   view).  An example of negotiated channel state is the maximum size of
   packet headers that can be compressed (MAX_HEADER).

   Other state is associated with the individual packet streams in the
   channel; this state is said to be part of the context.  Using context
   identifiers (CIDs), multiple packet streams with different contexts



Bormann (ed.)                                                  [Page 20]

INTERNET-DRAFT          Robust Header Compression           Oct 03, 2000


   can share a channel.  The highest context identifier to be used is
   one of the members of the negotiated channel state, as well as the
   selection of one of two ways to indicate the CID in the compressed
   header.

   It is up to the compressor to decide which packets to associate with
   a context (or, equivalently, which packets constitute a single
   stream); however, ROHC is efficient only when all packets of a stream
   share certain properties, such as having the same values for fields
   that are described as "static" in this document (e.g., the IP
   addresses, port numbers, and RTP parameters such as the payload
   type). The efficiency of ROHC RTP also depends on the compressor
   seeing most RTP sequence numbers.

   Streams need not share all characteristics important for compression.
   ROHC has a notion of compression profiles: a compression profile
   denotes a pre-defined set of such characteristics.  To provide for
   extensibility, the negotiated channel state includes the set of
   profiles acceptable to the decompressor. The context state includes
   the profile currently in use for the context.

   Other elements of the context state may include:  The current value
   of all header fields (from this one can deduce whether an IPv4 header
   is present in the header chain, and whether UDP checksums are
   enabled), as well as additional compression context that is not part
   of an uncompressed header: e.g., TS STRIDE, IP-ID characteristics (in
   network byte order? random?), a number of old reference headers, and
   the compressor/decompressor state machines (see next section).


4.3.  Compression and decompression states

   Header compression with ROHC can be characterized as an interaction
   between two state machines, one compressor machine and one
   decompressor machine, each instantiated once per context. The
   compressor and the decompressor have three states each, which in many
   ways are related to each other even if the meaning of the states are
   slightly different for the two parties. Both machines start in the
   lowest compression state and transits gradually to higher states.
   Transitions need not be synchronized between the two machines. In
   normal operation it is only the compressor that temporarily transits
   back to lower states.

   Subsequent sections present an overview of the state machines and
   their corresponding states respectively, starting with the
   compressor.








Bormann (ed.)                                                  [Page 21]

INTERNET-DRAFT          Robust Header Compression           Oct 03, 2000


4.3.1.  Compressor states

   For ROHC compression, the three compressor states are the
   Initialization and Refresh (IR), First Order (FO), and Second Order
   (SO) states. The compressor starts in the lowest compression state
   (IR) and transits gradually to higher compression states. The
   compressor will always operate in the highest possible compression
   state, under the constraint that the compressor is sufficiently
   confident that the decompressor has the information necessary to
   decompress a header compressed according to that state.

    +----------+                +----------+                +----------+
    | IR State |   <-------->   | FO State |   <-------->   | SO State |
    +----------+                +----------+                +----------+

   Decisions about transitions between the various compression states
   are taken by the compressor based on:

      - variations in packet headers.
      - positive feedback from decompressor (Acknowledgements - ACKs)
      - negative feedback from decompressor (Negative ACKs - NACKs)
      - periodic timeouts (when no feedback is used)

   How transitions are performed is explained in detail in chapter 5 for
   each mode of operation.


4.3.1.1.  Initialization and Refresh (IR) State

   The purpose of the IR state is to initialize the static parts of the
   context at the decompressor or to recover after failure. In this
   state, the compressor sends complete header information. This
   includes all static and non-static fields in uncompressed form plus
   some additional information. Refreshes may also be performed on non-
   static information only.

   The compressor stays in IR state until it is rather confident that
   the decompressor has received the static information correctly.


4.3.1.2.  First Order (FO) State

   The purpose of the FO state is to efficiently communicate
   irregularities in the packet stream. When operating in this state,
   the compressor rarely sends complete information and the information
   sent is usually compressed at least partially. The difference between
   IR and FO should therefore be clear.

   The compressor enters this state after the IR state and when the
   headers of the packet stream does not conform to their previous
   pattern. It stays in FO state until it is confident that the



Bormann (ed.)                                                  [Page 22]

INTERNET-DRAFT          Robust Header Compression           Oct 03, 2000


   decompressor has acquired all the parameters of the new pattern.
   Changes in fields that are always irregular are communicated in all
   packets and is therefore part of what is a uniform pattern.

   Since packets sent in the FO state usually carry context updating
   information, successful transmission of this information may be of
   vital importance for successful decompression of subsequent packets.
   The decompression process is sensitive to loss of, or damage to, such
   packets.


4.3.1.3.  Second Order (SO) State

   This is the state where compression is optimal. The compressor enters
   SO state when the header to be compressed is completely predictable
   given the SN, and the compressor is sufficiently confident that the
   decompressor has acquired all parameters of the functions from SN to
   other fields. Packets sent in SO state are almost independent of each
   other and error sensitivity is therefore low. However, successful
   decompression of packets sent in SO state requires that the
   information sent in preceding FO state operations has been
   successfully received by the decompressor.

   The compressor leaves this state and goes back to the FO state when
   the header no longer conforms to the uniform pattern and can not be
   independently compressed based on previous context information.


4.3.2.  Decompressor states

   The decompressor starts in its lowest compression state, "No Context"
   and gradually transits to higher states. The decompressor state
   machine normally never leaves the "Full Context" state when it once
   has started to work in that state.

    +--------------+         +----------------+         +--------------+
    |  No Context  |  <--->  | Static Context |  <--->  | Full Context |
    +--------------+         +----------------+         +--------------+

   When initially working in the "No Context" state, the decompressor
   has never successfully decompressed any packet. When a packet once
   has been decompressed correctly (upon reception of an initialization
   packet with static and dynamic information, for example), the
   decompressor can transit all the way to "Full Context" state, and
   only upon repeated failures will it transit back to lower states.
   However, when that happens it first transits back to "Static Context"
   state. There, reception of any packet sent in FO state is normally
   sufficient to enable transition to "Full Context" state again. Only
   when decompression of several packets sent in FO state fails in
   "Static Context" state will the decompressor go all the way back to
   the "No Context" state.



Bormann (ed.)                                                  [Page 23]

INTERNET-DRAFT          Robust Header Compression           Oct 03, 2000



   When state transitions are performed is explained in detail in
   chapter 5.


4.4.  Modes of operation.

   The ROHC scheme has three modes of operation, called Unidirectional,
   Bi-directional Optimistic, and Bi-directional Reliable mode.

   It is important to understand the difference between states, as
   described in previous chapter, and modes. These abstractions are
   orthogonal to each other. The state abstraction is the same for all
   modes of operation, while the mode controls the logic of state
   transitions and what actions to perform in each state.

                          +----------------------+
                          |  Unidirectional Mode |
                          |   +--+  +--+  +--+   |
                          |   |IR|  |FO|  |SO|   |
                          |   +--+  +--+  +--+   |
                          +----------------------+
                            ^                  ^
                           /                    \
                          /                      \
                         v                        v
     +----------------------+                  +----------------------+
     |   Optimistic Mode    |                  |    Reliable Mode     |
     |   +--+  +--+  +--+   |                  |   +--+  +--+  +--+   |
     |   |IR|  |FO|  |SO|   | <--------------> |   |IR|  |FO|  |SO|   |
     |   +--+  +--+  +--+   |                  |   +--+  +--+  +--+   |
     +----------------------+                  +----------------------+

   The optimal mode to operate in depends on the characteristics of the
   environment of the compression protocol, such as feedback abilities,
   error probabilities and distributions, header size variation effects,
   etc. All ROHC implementations MUST implement and support all three
   modes of operation. The three modes are briefly described in the
   following subsections.

   Detailed descriptions of the three modes of operation regarding
   compression and decompression logic are given in chapter 5. The mode
   transition mechanisms are also described in chapter 5.


4.4.1.  Unidirectional mode - U-mode

   When in the unidirectional mode of operation, packets are sent in one
   direction only; from compressor to decompressor. This mode therefore
   makes ROHC usable over links where a return path from decompressor to
   compressor is not available or is undesirable.



Bormann (ed.)                                                  [Page 24]

INTERNET-DRAFT          Robust Header Compression           Oct 03, 2000



   In U-mode, transitions between compressor states are performed based
   only on periodic timeouts and irregularities in the header field
   change patterns in the compressed packet stream. Due to the periodic
   refreshes and the lack of feedback for initiation of error recovery,
   compression in the unidirectional mode will be less efficient and
   have a slightly higher probability for loss propagation compared to
   any of the bi-directional modes.

   Compression with ROHC MUST start in the unidirectional mode.
   Transition to any of the bi-directional modes can be performed as
   soon as a packet has reached the decompressor and it has replied with
   a feedback packet indicating that a mode transition is desired (see
   chapter 5).


4.4.2.  Bi-directional optimistic mode - O-mode

   The bi-directional optimistic mode is similar to the unidirectional
   mode. The difference is that a feedback channel is used to send error
   recovery requests and (optionally) acknowledgments of significant
   context updates from decompressor to compressor (not for sequence
   number updates only). Periodic refreshes are not used in the bi-
   directional optimistic mode.

   O-mode is designed for good compression efficiency and sparse usage
   of the return channel while maintaining reasonable robustness. Loss
   of compressor-decompressor synchronization and introduction of loss
   propagation is rare even under high probabilistic error rates, but
   can occur with longer consecutive loss events. When loss propagation
   does occur, the amount is limited by the CRC check and NACKing scheme
   used. Nevertheless, this mode is not completely robust against loss
   propagation.


4.4.3.  Bi-directional reliable mode - R-mode

   The bi-directional reliable mode differs in many ways from the
   previous two. The most important differences are a more intensive
   usage of the feedback channel and a stricter logic at both the
   compressor and the decompressor that prevents loss of context
   synchronization between compressor and decompressor except for very
   high residual bit error rates. Feedback is sent to acknowledge all
   context updates, including updates of the sequence number field.
   However, not every packet updates the context in reliable mode.

   The chief advantage of R-mode is almost complete robustness against
   packet loss between compressor and decompressor. Loss propagation can
   never occur due to header compression when operating in this mode.
   For reasonably well-behaving links, the price is slightly higher
   overhead in some cases and additional feedback traffic.



Bormann (ed.)                                                  [Page 25]

INTERNET-DRAFT          Robust Header Compression           Oct 03, 2000



4.5.  Encoding methods

   This chapter describes the encoding methods that are used for
   different header fields. How the methods are applied to each field
   (e.g., values of associated parameters) is specified in section 5.7.


4.5.1. Least Significant Bits (LSB) encoding

   Least Significant Bits (LSB) encoding is used for header fields whose
   values are usually subject to small changes. With LSB encoding, the k
   least significant bits of the field value are transmitted instead of
   the original field value, where k is a positive integer. After
   receiving k bits, the decompressor derives the original value using a
   previously received value as reference (v_ref).

   The scheme is guaranteed to be correct if the compressor and the
   decompressor agree on an interpretation interval

     1) in which the original value resides, and
     2) in which the original value is the only value that has the exact
        same k least significant bits as those transmitted.

   The interpretation interval can be described as a function f(v_ref,
   k). Let

      f(v_ref, k) = [v_ref - p, v_ref + (2^k - 1) - p]

   where p is an integer.


      <------- interpretation interval (size is 2^k) ------->
      |-------------+---------------------------------------|
   v_ref - p        v_ref                        v_ref + (2^k-1) - p


   The function f has the following property: for any value k, k least
   significant bits will uniquely identify a value in f(v_ref, k).

   The parameter p is introduced so that the interpretation interval can
   be shifted with respect to v_ref. Choosing a good value for p will
   yield more efficient encoding for fields with certain
   characteristics. Examples of appropriate values of p are

   a) for field values that are expected to always increase, p can be
      set to _1. The interpretation interval becomes
      [v_ref + 1, v_ref + 2^k].

   b) for field values that stay the same or increase, p can be set to
      0. The interpretation interval becomes [v_ref, v_ref + 2^k - 1].



Bormann (ed.)                                                  [Page 26]

INTERNET-DRAFT          Robust Header Compression           Oct 03, 2000


   c) for field values that are expected to have small deviations around
      a constant value, p can be set to 2^(k-1)-1. The interpretation
      interval becomes [v_ref _ 2^(k-1) + 1, v_ref + 2^(k-1)].

   d) for field values that are expected to have small negative changes
      and larger positive changes, such as the RTP TS for video, or RTP
      SN when there is misordering, p can be set to 2^(k-2). The
      interval becomes [v_ref _ 2^(k-2) + 1, v_ref + 3 * 2^(k-2)], i.e.,
      3/4 of the interval is used for positive changes.

   The following is a simplified procedure for LSB compression and
   decompression, it is modified for robustness and damage propagation
   protection in the next subsection:

     1) The compressor (decompressor) always uses v_ref_c (v_ref_d), the
        last value that has been compressed (decompressed), as v_ref;

     2) When compressing a value v, the compressor finds the minimal
        value of k such that v falls into the interval f(v_ref_c, k).
        Call this function k = g(v_ref_c, v).

        When only a few distinct values of k are possible, for example
        due to limitations imposed by packet formats (see section 5.7),
        the compressor will instead pick the smallest k of those
        possible such that v is in the interval f(v_ref_c, k).

     3) When receiving m LSBs, the decompressor uses the interpretation
        interval f(v_ref_d, m), called interval d. It picks as the
        decompressed value the one in interval_d whose LSBs match the
        received m bits.

   The scheme is complicated by two factors: packet loss between the
   compressor and decompressor, and transmission errors undetected by
   the lower layer. In the former case, the compressor and decompressor
   will lose the synchronization of v_ref, and thus also of the
   interpretation interval. If v is still covered by the
   intersection(interval_c, interval_d), decompression will be correct.
   Otherwise, incorrect decompression will happen. The next section will
   address this issue further.

   In the case of undetected transmission errors, the corrupted LSBs
   will give an incorrectly decompressed value that will later be used
   as v_ref_d, which in turn is likely to lead to damage propagation.
   This problem is addressed by using a secure reference, i.e., a
   reference value whose correctness is verified by a protecting CRC.
   Consequently, the procedure 1) above is modified as follows:

    1) a) the compressor always uses as v_ref_c the last value that has
          been compressed and sent with a protecting CRC.
       b) the decompressor always uses as v_ref_d the last correct
          value, as verified by a succeeding CRC.



Bormann (ed.)                                                  [Page 27]

INTERNET-DRAFT          Robust Header Compression           Oct 03, 2000



   Note that in U/O mode, 1) b) is modified so that if decompression of
   the SN fails using the last verified SN reference, another
   decompression attempt is made using the last but one verified SN
   reference. This procedure dampens damage propagation when a small CRC
   fails to detect a damaged value.


4.5.2.  Window-based LSB encoding (W-LSB encoding)

   This section describes how to modify the simplified algorithm in
   4.5.1 to achieve robustness.

   The compressor may not be able to determine the exact value of
   v_ref_d that will be used by the decompressor for a particular value
   v, since some candidates for v_ref_d may have been lost or damaged.
   However, by using feedback or by making reasonable assumptions the
   compressor can limit the candidate set. The compressor then
   calculates k such that no matter which v_ref_d in the candidate set
   the decompressor uses, v is covered by the resulting interval_d.

   Since the decompressor always uses the last received value where the
   CRC succeeded as the reference, the compressor maintains a sliding
   window (VSW) containing the candidates for v_ref_d. VSW is initially
   empty. The following operations are performed on VSW by the
   compressor:

     1) After sending a value v (compressed or uncompressed) protected
        by a CRC, the compressor adds v to the VSW;
     2) For each value v being compressed, the compressor chooses k =
        max(g(v, v_min), g(v, v_max)), where v_min and v_max are the
        minimal and maximal values in VSW, and g is the function defined
        in the previous section;
     3) When the compressor has sufficient confidence that a certain
        value v will not be used as a reference by the decompressor, the
        window is advanced by removing v and all values older than v.
        The confidence may be obtained by various means. In R mode an
        ACK from the decompressor implies that values older than the
        ACKed one can be removed from VSW. In U/O mode there is always a
        CRC to verify correct decompression, and a VSW with a limited
        maximum width is used. The window width is an implementation
        dependent optimization parameter.

   Note that the decompressor follows the procedure described in the
   previous section, except that in R mode it MUST ACK each value
   received with a CRC (see also section 5.5).








Bormann (ed.)                                                  [Page 28]

INTERNET-DRAFT          Robust Header Compression           Oct 03, 2000


4.5.3. Scaled RTP Timestamp encoding

   The RTP Timestamp (TS) will usually not increase by an arbitrary
   number from packet to packet. Instead, the increase is normally an
   integral multiple of some unit (TS_STRIDE). For example, in the case
   of audio, the sample rate is normally 8Khz and one voice frame may
   cover 20 ms. Furthermore, each voice frame is usually carried in one
   RTP packet. In this case, the RTP increment is always n * 160 (= 8000
   * 0.02), for some integer n. Note that silence periods has no impact
   on this as the sample clock at the source normally keeps running
   without changing either frame rate or frame boundaries.

   For the case of video, there is usually a TS_STRIDE as well when we
   consider the video frame level. The sample rate for most video codecs
   is 90Khz. If the video frame rate is fixed, say to 30 frames/second,
   the TS will increase by n * 3000 (= n * 90000 / 30) between video
   frames. Note that a video frame is often divided into several RTP
   packets to achieve robustness against packet loss. In this case
   several RTP packets will carry the same TS.

   When using scaled RTP Timestamp encoding, the TS is downscaled by a
   factor of TS_STRIDE before compression. This saves

       floor(log2(TS_STRIDE))

   bits for each compressed TS. The following equality holds between TS
   and TS SCALED:

       TS = TS SCALED * TS STRIDE + TS OFFSET

   TS STRIDE is explicitly, and TS OFFSET implicitly, communicated to
   the decompressor. The following algorithm is used:

     1. Initialization: The compressor sends to the decompressor the
        value of TS_STRIDE (e.g., via in-band signaling, see packet
        format section) and the absolute value of one or several TS. The
        latter are used by the decompressor to initialize TS_OFFSET to
        (absolute value) modulo TS_STRIDE. Note that TS OFFSET is the
        same regardless of which absolute value is used, as long as the
        unscaled TS value does not wrap around, see 4) below.

     2. Compression: After initialization, the compressor no longer
        compresses the original TS values. Instead, it compresses the
        down-scaled values: TS_SCALED = TS / TS_STRIDE. The compression
        method could be either W-LSB encoding or the timer-based
        encoding described in the next section.

     3. Decompression: When receiving the compressed value of TS_SCALED,
        the decompressor first derives the value of the original
        TS_SCALED. The original RTP TS is then calculated as TS =
        TS_SCALED * TS_STRIDE + TS_OFFSET.



Bormann (ed.)                                                  [Page 29]

INTERNET-DRAFT          Robust Header Compression           Oct 03, 2000



     4. Wrap around: Wrap around of the unscaled 32-bit TS will
        invalidate the current value of TS_OFFSET used in the equation
        above. For example, let's assume TS_STRIDE = 160 = 0xA0 and the
        current TS = 0xFFFFFFF0. TS_OFFSET is then 0x50 = 80. Then if
        the next RTP TS = 0x00000130 (i.e., the increment is 160 * 2 =
        320), the new TS_OFFSET should be 0x00000130 modulo 0xA0 = 0x90
        = 144. The compressor is not required to re-initialize TS OFFSET
        at wrap around. Instead, the decompressor MUST detect wrap
        around of the unscaled TS (which is trivial) and update
        TS_OFFSET to

           TS OFFSET = (Wrapped around unscaled TS) modulo TS STRIDE

   This scaling method can be applied to many frame-based codecs.
   However, the value of TS_STRIDE might change during a session, for
   example due to adaptation strategies. If that happens, the unscaled
   TS is compressed until re-initialization of the new TS_STRIDE and
   TS_OFFSET is completed.


4.5.4.  Timer-Based Compression of RTP Timestamp

   The RTP timestamp [RFC 1889] is defined to identify the number of the
   first sample used to generate the payload. When RTP packets carry
   payloads corresponding to a fixed sampling interval, the sampling is
   done at a constant rate, and packets are generated in lock-step with
   sampling, the timestamp will closely follow a linear pattern as a
   function of the time of day. This is the case for conversational
   media, such as interactive speech. The linear ratio is determined by
   the source sample rate. The linear pattern can be complicated by
   packetization (e.g., in the case of video where a video frame usually
   corresponds to several RTP packets) or frame re-arrangement (e.g.,
   MPEG B-frames are sent out-of-order by some video codecs).

   With a fixed sample rate of 8kHz, 20 ms in time domain is equivalent
   to an increment of 160 in the unscaled TS domain, and to an increment
   of 1 in the scaled TS domain with TS_STRIDE=160.

   As a consequence, the (scaled) TS of headers coming to the
   decompressor will follow a linear pattern as a function of time of
   day, with some deviation due to the delay jitter between the source
   and the decompressor. In normal operation, i.e., no crashes or
   failures, the delay jitter will be bounded to meet the requirements
   of conversational real-time traffic.  Hence, by using a local clock
   the decompressor can obtain an approximation of the (scaled) TS in
   the header to be decompressed by considering its arrival time. The
   approximation can then be refined with the k LSBs of the (scaled) TS
   carried in the header. The required value of k to ensure correct
   decompression is a function of the jitter between the source and
   decompressor.



Bormann (ed.)                                                  [Page 30]

INTERNET-DRAFT          Robust Header Compression           Oct 03, 2000



   If the compressor knows the potential jitter introduced between
   compressor and decompressor, it can determine k by using a local
   clock to estimate jitter in packet arrival times, or alternatively it
   can use a fixed k and discard packets arriving too much out of time.

   The advantages of this scheme include:

   a) The size of the compressed TS is constant and small. In
      particular, it does NOT depend on the length of silence intervals.
      This is in contrast to other TS compression techniques, which at
      the beginning of a talk-spurt requires sending a number of bits
      dependent on the duration of the preceding silence interval.

   b) No synchronization is required between the clock local to the
      compressor and the clock local to the decompressor.

   Note that although this scheme can be made to work using both scaled
   and unscaled TS, in practice it is always combined with scaled TS
   encoding because of the less demanding requirement on the clock
   resolution, e.g., 20 ms instead of 1/8 ms. Therefore, the algorithm
   described below assumes that the clock-based encoding scheme operates
   on the scaled TS. The case of unscaled TS would be similar, with
   changes to scale factors.

   Compressor: its major task is to determine the value of k. Its
   sliding window, TSW, now contains not only potential reference values
   for the TS, but also their times of arrival at the compressor.

     1) The compressor maintains a sliding window TSW = {(T_j, a_j),
        for each header j that can be used as a reference}, where T_j is
        the scaled TS for header j, and a_j is the arrival time of
        header j. The TSW fills the same purpose as the VSW of section
        4.5.2.

     2) When a new header n arrives with T_n as the scaled TS, the
        compressor notes the arrival time a_n. It then calculates

        Max_Jitter_BC =

            max {|(T_n - T_j) - ((a_n - a_j) / TIME_STRIDE)|,
                 for all headers j in TSW},

        where TIME_STRIDE is the time interval equivalent to one
        TS_STRIDE, e.g., 20 ms. Max_Jitter_BC is the maximum observed
        jitter before the compressor, in units of TS_STRIDE, for the
        headers in TSW.

     3) k is calculated as: k = ceiling(log2(2 * J + 1), where J =
        Max_Jitter_BC + Max_Jitter_CD + 2.




Bormann (ed.)                                                  [Page 31]

INTERNET-DRAFT          Robust Header Compression           Oct 03, 2000


        Max_Jitter_CD is the upper bound of jitter expected on the
        communication channel between compressor and decompressor (CD-
        CC). It depends only on the characteristics of CD-CC.

        The factor 2 accounts for the quantization error introduced by
        the clocks at the compressor and decompressor, which can be +/-
        1.

        Note that the calculation of k follows the compression algorithm
        described in section 4.5.1, with p = 2^(k-1) - 1.

     4) TSW is subject to the same window operations as in section
        4.5.2, 1) and 3), except that the values added and removed are
        paired with their arrival times.

   Decompressor:

     1) The decompressor uses as its reference header the last correctly
        (as verified by CRC) decompressed header. It maintains the pair
        (T_ref, a_ref), where T_ref is the scaled TS of the reference
        header, and a_ref is the arrival time of the reference header.

     2) When receiving a compressed header n at time a_n, the
        approximation of the original scaled TS is calculated as:

            T_approx = T_ref + (a_n - a_ref) / TIME_STRIDE.

     3) The approximation is then refined by the k least significant
        bits carried in header n, following the decompression algorithm
        of section 4.5.1, with p = 2^(k-1) - 1.

   Note: the algorithm does not assume any particular pattern in the
   packets arriving to the compressor, i.e., it tolerates reordering
   before the compressor and non-increasing RTP timestamp behavior.

   Note: Integer arithmetic is used in all equations above. If
   TIME_STRIDE is not equal to an integral number of clock ticks, time
   must be normalized such that TIME_STRIDE is an integral number of
   clock ticks. For example, if a clock tick is 20 ms and TIME STRIDE is
   30 ms, (a_n _ a_ref) in 2) can be multiplied by 3 and TIME_STRIDE can
   have the value 2.

   Note: the clock resolution of compressor or decompressor can be worse
   than TIME_STRIDE, in which case the difference, i.e., actual
   resolution _ TIME_STRIDE, is treated as additional jitter in the
   calculation of k.

   Note: the clock resolution of the decompressor may be communicated to
   the compressor using the CLOCK feedback option.





Bormann (ed.)                                                  [Page 32]

INTERNET-DRAFT          Robust Header Compression           Oct 03, 2000


   Note: the decompressor may observe the jitter and report this to the
   compressor using the JITTER feedback option. The compressor may use
   this information to refine its estimate of Max_Jitter_CD.

4.5.5.  Offset IP-ID encoding

   As all IPv4 packets have an IP Identifier to allow for fragmentation,
   ROHC provides for transparent compression of this ID.  There is no
   explicit support in ROHC for the IPv6 fragmentation header, so there
   is never a need to discuss IP IDs outside the context of IPv4.

   This section assumes (initially) that the IPv4 stack at the source
   host assigns IP-ID to the value of a 2-byte counter which is
   increased by one after each assignment to an outgoing packet.
   Therefore, the IP-ID field of a particular IPv4 packet flow will
   increment by 1 from packet to packet except when the source has
   emitted intermediate packets not belonging to that flow.

   For such IPv4 stacks, the RTP SN will increase by 1 for each packet
   emitted and the IP-ID will increase by at least the same amount.
   Thus, it is more efficient to compress the offset, i.e., (IP-ID - RTP
   SN), instead of IP-ID itself.

   The following text describes how to compress/decompress the sequence
   of offsets using W-LSB encoding/decoding, with p = 0 (see section
   4.5.1).

   Compressor:

     The compressor uses W-LSB encoding to compress a sequence of
     offsets

        Offset_i = ID_i _ SN_i,

     where ID_i and SN_i are the values of the IP-ID and RTP SN of
     header i. The sliding window contains such offsets and not the
     values of header fields, but the rules for adding and deleting
     offsets from the window otherwise follow section 4.5.2.

   Decompressor:

     The reference header is the last correctly (as verified by CRC)
     decompressed header.

     When receiving a compressed packet m, the decompressor calculates
     Offset_ref = ID_ref - SN_ref, where ID_ref and SN_ref are the
     values of IP-ID and RTP SN in the reference header, respectively.
     Then W-LSB decoding is used to decompress Offset_m, using the
     received LSBs in packet m and Offset_ref. Note that m may contain
     zero LSBs for Offset_m, in which case Offset_m = Offset_ref.




Bormann (ed.)                                                  [Page 33]

INTERNET-DRAFT          Robust Header Compression           Oct 03, 2000


     Finally, the IP-ID for packet m is regenerated as

       IP-ID for m = decompressed SN of packet m + Offset_m


   Network byte order:

   Some IPv4 stacks do use a counter to generate IP ID values as
   described, but do not transmit the contents of this counter in
   network byte order, but instead send the two octets reversed. In this
   case, the compressor can compress the IP-ID field after swapping the
   bytes. Consequently, the decompressor also swaps the bytes of the IP-
   ID after decompression to regenerate the original IP-ID. This
   requires that the compressor and the decompressor synchronize on the
   byte order of the IP-ID field using the NBO or NBO2 flag (see section
   5.7.)

   Random IP Identifier:

   Some IPv4 stacks generate the IP Identifier values using a pseudo-
   random number generator. While this may provide some security
   benefits, it makes it pointless to attempt compressing the field.
   Therefore, the compressor should detect such random behavior of the
   field. After detection and synchronization with the decompressor
   using the RND or RND2 flag, the field is sent as-is in its entirety
   as additional octets after the compressed header.


4.5.6.  Self-describing variable-length values.

   The values of TS STRIDE and a few other compression parameters can
   vary widely. TS STRIDE can be 160 for voice and 90 000 for 1 f/s
   video. To optimize the transfer of such values, a variable number of
   octets is used to encode them. The first few bits of the encoded
   value determines its length.

   1 octet: first bit is zero. 7 bits transferred. Up to 127 decimal.
               Encoded octets in hexadecimal: 00 to 7F

   2 octets: first bits 10. 14 bits. Up to 16 383 decimal.
               Encoded octets in hexadecimal: 80 00 to BF FF

   3 octets: first bits 110. 21 bits. Up to 2 097 151 decimal.
               Encoded octets in hexadecimal: C0 00 00 to DF FF FF

   4 octets: first bits 111. 29 bits. Up to 536 870 911 decimal.
               Encoded octets in hexadecimal: E0 00 00 00 to FF FF FF FF







Bormann (ed.)                                                  [Page 34]

INTERNET-DRAFT          Robust Header Compression           Oct 03, 2000



4.5.7.  Encoded values across several fields in compressed headers.

   When a compressed header has an extension, pieces of an encoded value
   can be present in more than one field. When an encoded value is split
   over several fields in this manner, the more significant bits of the
   value are closer to the beginning of the header. If the number of
   bits available in compressed header fields exceeds the number of bits
   of the value, the most significant field is padded with zeroes in its
   most significant bits.

   For example, an unscaled TS value can be transferred using an UOR-2
   header (see section 5.7) with an extension of type 3. The Tsc bit of
   the extension is then unset and the variable length TS field of the
   extension is 4 octets (see section 4.5.6). The UOR-2 TS field will
   contain the most significant three bits of the unscaled TS, and the
   4-octet TS field in the extension contains the remaining 29 bits.





































Bormann (ed.)                                                  [Page 35]

INTERNET-DRAFT          Robust Header Compression           Oct 03, 2000


5.  The protocol


5.1.  Data structures

   The ROHC protocol is based on a number of parameters that form part
   of the negotiated channel state and the per-context state.  This
   section describes some of this state in an abstract way.
   Implementations can use a different structure and representation of
   this state.  In particular, negotiation protocols that set up per-
   channel state need to establish the information that constitutes the
   negotiated channel state, but not necessarily have to exchange it in
   the form it is described here.

5.1.1.  Per-channel parameters

   MAX_CID: non-negative integer; highest context ID number to be used
   by the compressor (note that this parameter is not coupled to, but in
   effect further constrained by, LARGE_CIDS).

   LARGE_CIDS: Boolean; if false, the short CID representation (0 bytes
   or 1 prefix byte, covering CID 0 to 15) is used, if true, the
   embedded CID representation (1 or 2 embedded CID bytes covering CID 0
   to 16383) is used.

   PROFILES: Set of non-negative integers, indicating which profiles are
   supported by the decompressor.

   FEEDBACK_FOR: Optional reference to a channel in the reverse
   direction.  If set, this indicates which channel any feedback sent on
   this channel refers to (see 5.7.6.1).

5.1.2.  Per-context parameters, profiles

   Per-context parameters are established in the I/R headers (see
   section 5.7).  Note that the profile parameter influences the
   semantics of the packet type identifiers and packet types of the
   profile used for a specific context.  This document describes
   profiles 0 and 1; further profiles may be defined when ROHC is
   extended in the future.

   Profile 0 is for RTP/UDP/IP compression.

   Profile 1 is for UDP/IP compression, i.e., compression of the first
       12 octets of the UDP payload is not attempted. See section 5.10.

5.1.3.  Contexts and context identifiers

   Associated with each compressed flow is a context, which is the state
   compressor and decompressor maintains in order to correctly compress
   or decompress the headers of the flow. Contexts are identified by a



Bormann (ed.)                                                  [Page 36]

INTERNET-DRAFT          Robust Header Compression           Oct 03, 2000


   context identifier, CID, which is sent along with compressed headers
   and feedback information.

   The CID space is distinct for each channel, i.e., CID 3 over channel
   A and CID 3 over channel B do not refer to the same context, even if
   the endpoints of A and B are the same nodes.  In particular, CIDs for
   any pairs of forward and reverse channels are not related (forward
   and reverse channels need not even have the same size CID space).

   Context information is conceptually kept in a table. The context
   table is indexed using the CID which is sent along with compressed
   headers and feedback information. The CID space can be negotiated to
   be either small, which means that CIDs can take the values 0 through
   15, or large, which means that CIDs take values between 0 and 2^14-1
   = 16383. Whether the CID space is large or small is negotiated no
   later than when a channel is established.

   A small CID is either CID 0, which is represented using zero bits, or
   CID 1 to 15, which are represented using a packet type plus four
   bits.  A large CID is represented using the encoding scheme of
   section 4.5.6., limited to two octets.


5.2.  Packet types

   A ROHC RTP packet always starts with a packet type. The packet type
   indicates the format of the (first part of) the packet. Packet types
   allow distinguishing compressed packets from feedback packets, and
   also allows compressed ROHC RTP packets to carry piggybacked feedback
   information.

   The format of a compressed packets can depend on the mode. Therefore
   a naming scheme of the form

       <modes format is used in>-<packet type number>-<some property>

   is used to uniquely identify the format when necessary. E.g, UOR-2,
   R-1. For exact formats of the packet types, see section 5.7.

5.2.1.  Packet formats from compressor to decompressor

   Three packet types are used to identify compressed headers, and two
   for initialization/refresh. Context identifiers of the appropriate
   length is sent along with these headers. Exact header formats are
   found in section 5.7.

   Packet type zero: R-0, R-0-CRC, UO-0.

     This, the minimal, packet type is used when parameters of all SN-
     functions are known by the decompressor, and the header to be




Bormann (ed.)                                                  [Page 37]

INTERNET-DRAFT          Robust Header Compression           Oct 03, 2000


     compressed adheres to those functions. Thus, only the W-LSB encoded
     RTP SN needs to be communicated.

     R-mode:  Only if a CRC is present (packet type R-0-CRC) may the
     header be used as a reference for subsequent decompression.

     U-mode and O-mode: A small CRC is present in the UO-0 packet.

   Packet type 1: R-1, R-1-ID, R-1-TS, UO-1, UO-1-ID, UO-1-TS.

     This packet type is used when the number of bits needed for the SN
     exceeds those available in packet type zero, or when the parameters
     of the SN-functions for RTP TS or IP-ID change.

     R-mode: R-1-* packets are not used as references for subsequent
     decompression. Values for other fields than the RTP TS or IP-ID can
     be communicated using an extension, but they do not update the
     context.

     U-mode and O-mode: Only the values of RTP SN, RTP TS and IP-ID can
     be used as references for future compression. Non-updating values
     can be provided for other fields using an extension (UO-1-ID).

   Packet type 2: UOR-2, UOR-2-ID, UOR-2-TS

     This packet type can be used to change the parameters of any SN-
     function, except for those for most static fields. Headers of
     packets transferred using packet type 2 can be used as references
     for subsequent decompression.

   Packet type 5: IR

     This packet type communicates the static part of the context, i.e.,
     the value of the constant SN-functions. It can optionally also
     communicate the dynamic part of the context, i.e., the parameters
     of the non-constant SN-functions.

   Packet type 6: IR-DYN

     This packet type communicates the dynamic part of the context,
     i.e., the parameters of non-constant SN-functions.


5.2.2.  Feedback from decompressor to compressor

   Feedback carry information from decompressor to compressor. The
   following principal kinds of feedback is supported. In addition to
   these, feedback can carry options which provide the compressor with
   various information.

   ACK         : Acknowledges successful decompression of a packet,



Bormann (ed.)                                                  [Page 38]

INTERNET-DRAFT          Robust Header Compression           Oct 03, 2000


                 which means that the context is up to date with a
                 high probability.

   NACK        : Indicates that the dynamic context of the
                 decompressor is out of sync.

   STATIC-NACK : Indicates that the static context of the decompressor
                 is not valid or has not been established.

   It is anticipated that feedback to the compressor can be realized in
   many ways, depending on the properties of the particular lower layer.
   The exact details of how feedback is realized is specified in a "ROHC
   over X" document, for each lower layer X in question. As examples,
   feedback might be realized using

   1) lower-layer specific mechanisms, or

   2) a dedicated feedback-only channel, realized for example by the
      lower layer providing a way to indicate that a packet is a
      feedback packet, or

   3) a dedicated feedback-only channel, where the timing of the
      feedback provides information about which compressed packet caused
      the feedback, or

   4) interleaving of feedback packets among normal compressed packets
      going in the same direction as the feedback (lower layers do not
      indicate feedback), or

   5) piggybacking of feedback information in compressed packets going
      in the same direction as the feedback (this technique may reduce
      the per-feedback overhead).

   Alternatives 1-3 do not place any particular requirements on the ROHC
   packet type scheme. Alternatives 4 and 5 do, however. The ROHC RTP
   packet types have been designed to allow alternatives 4 and 5, who
   may be used for example over PPP.

        A) The ROHC RTP profile provides a feedback packet type. The
           packet type is able to carry variable-length feedback
           information.

        B) The feedback information sent in a particular channel is
           passed to, and interpreted by, the compressor associated with
           feedback on that channel. Thus, the feedback information must
           contain CID information if the associated compressor can use
           more than one context. How a compressor is associated with
           feedback on a particular channel needs to be defined in a
           "ROHC over X" document.





Bormann (ed.)                                                  [Page 39]

INTERNET-DRAFT          Robust Header Compression           Oct 03, 2000


        C) The ROHC feedback information format is octet-aligned, i.e.,
           starts at an octet boundary, to allow using the format over a
           dedicated feedback channel, 2).

        D) To allow piggybacking, 5), it is possible to explicitly
           provide the length of the feedback information. This allows
           the decompressor to pass piggybacked feedback information to
           the associated compressor without understanding its format.
           The explicit length decouples the decompressor from the
           compressor in the sense that the decompressor can process the
           compressed header immediately without waiting for the
           compressor to hand it back after parsing the feedback
           information.


5.2.3.  Parameters needed for mode transition

   The packet type UOR-2 is common for all modes. It can carry an
   extension with a mode parameter which can take the values U  =
   Unidirectional, O = Bi-directional Optimistic, and R= Bi-directional
   Reliable.

   Feedback of types ACK, NACK, and STATIC-NACK carry sequence numbers
   and feedback packets can also carry a mode parameter indicating the
   desired compression mode: U, O, or R.

   As a shorthand, the notation PACKET(mode) is used to indicate which
   mode value a packet carries. For example, an ACK with mode parameter
   R is written ACK(R), and an UOR-2 with mode parameter O is written
   UOR-2(O).
























Bormann (ed.)                                                  [Page 40]

INTERNET-DRAFT          Robust Header Compression           Oct 03, 2000


5.3.  Operation in unidirectional mode

5.3.1.  Compressor states and logic (U-mode)

   Below is the state machine for the compressor in unidirectional mode.
   Details of the transitions between states and compression logic are
   given subsequent to the figure.

                            Optimistic approach
      +------>------>------>------>------>------>------>------>------+
      |                                                              |
      |        Optimistic approach         Optimistic approach       |
      |      +------>------>------+      +------>------>------+      |
      |      |                    |      |                    |      |
      |      |                    v      |                    v      v
    +----------+                +----------+                +----------+
    | IR State |                | FO State |                | SO State |
    +----------+                +----------+                +----------+
      ^      ^                    |      ^                    |      |
      |      |      Timeout       |      |  Timeout / Update  |      |
      |      +------<------<------+      +------<------<------+      |
      |                                                              |
      |                           Timeout                            |
      +------<------<------<------<------<------<------<------<------+


5.3.1.1.  State transition logic (U-mode)

   The transition logic for compression states in unidirectional mode is
   based on three principles; the optimistic approach principle,
   timeouts, and the need for updates.


5.3.1.1.1.  Optimistic approach, upwards transition

   Transition to higher compression state in unidirectional mode is
   carried out according to the optimistic approach principle. This
   means that the compressor transits to a higher compression state when
   it is rather confident that the decompressor has received enough
   information to correctly decompress packets sent according to the
   higher compression state.

   When the compressor is in IR state, it will stay there until it
   assumes that the decompressor has correctly received the static
   context information. For transition from FO to SO state, the
   compressor should be confident that the decompressor has all
   parameters needed to decompress according to a fixed pattern.

   The compressor normally gets its confidence about decompressor status
   by sending several packets with the same information according to the
   lower compression state. If the decompressor receives any of these



Bormann (ed.)                                                  [Page 41]

INTERNET-DRAFT          Robust Header Compression           Oct 03, 2000


   packets, it will be in sync with the compressor. The number of
   consecutive packets to send for confidence is not defined in this
   document.


5.3.1.1.2.  Timeouts, downward transition

   By using the optimistic approach described above, there will always
   be a possibility for failure since the decompressor may not have
   received sufficient information for correct decompression. Therefore,
   the compressor MUST periodically transit to lower compression states.
   Periodic transition to IR state SHOULD be carried out less often than
   transition to FO state. Two different timeouts SHOULD therefore be
   used for these transitions. For an example of how to implement
   periodic refreshes, see [IPHC] chapter 3.3.1-3.3.2.


5.3.1.1.3.  Need for updates, downward transition

   In addition to the downward state transitions carried out due to
   periodic timeouts, the compressor must also immediately transit back
   to FO state when the header to be compressed does not confirm to the
   established pattern.


5.3.1.2.  Compression logic and packets used (U-mode)

   The compressor chooses the smallest possible packet format that can
   communicate the desired changes, and has the required bits for W-LSB
   encoded values. Sliding windows used in W-LSB encoding have a fixed
   width, not defined in this document.


5.3.1.3.  Feedback in unidirectional mode

   The unidirectional mode of operation is designed to operate over
   links where a feedback channel is not available. If a feedback
   channel is available, however, the decompressor MAY send an
   acknowledgment of successful decompression with the mode parameter
   set to U (send an ACK(U)). When the compressor receives such a
   message, it MAY disable (or increase the interval between) periodic
   IR refreshes.


5.3.2.  Decompressor states and logic (U-mode)

   Below is the state machine for the decompressor in unidirectional
   mode. Details of the transitions between states and decompression
   logic are given subsequent to the figure.

                                  Success



Bormann (ed.)                                                  [Page 42]

INTERNET-DRAFT          Robust Header Compression           Oct 03, 2000


                 +-->------>------>------>------>------>--+
                 |                                        |
     No Static   |            No Dynamic        Success   |    Success
      +-->--+    |             +-->--+      +--->----->---+    +-->--+
      |     |    |             |     |      |             |    |     |
      |     v    |             |     v      |             v    |     v
    +--------------+         +----------------+         +--------------+
    |  No Context  |         | Static Context |         | Full Context |
    +--------------+         +----------------+         +--------------+
       ^                         |        ^                         |
       |    Repeated failure     |        |    Repeated failure     |
       +-----<------<------<-----+        +-----<------<------<-----+


5.3.2.1.  State transition logic (U-mode)

   The state transition logic of the decompressor is much simpler than
   for the compressor side. It is also common for all the three modes of
   operation. Successful decompression will always move the decompressor
   to the Full Context state. Repeated failed decompression will force
   the decompressor to transit downwards to a lower state. The
   decompressor does not attempt to decompress headers at all in the No
   Context and Static Context states unless sufficient information is
   included in the packet itself.


5.3.2.2.  Decompression logic (U-mode)

   Decompression in unidirectional mode is carried out following three
   steps which are described in subsequent sections.


5.3.2.2.1.  Decide whether decompression is allowed

   In Full Context state, decompression may be attempted regardless of
   what kind of packet is received. However, for the other states
   decompression is not always allowed. In the No Context state, only IR
   packets, which carry the static information fields may be
   decompressed. Further, when in the Static Context state, only packets
   carrying a strong CRC can be decompressed (i.e., IR, IR-DYN, or UOR-2
   packets). If decompression may not be performed the packet is
   discarded, unless the optional delayed decompression mechanism is
   used, see section 6.1.


5.3.2.2.2.  Reconstruct and verify the header

   When reconstructing the header, the decompressor takes the header
   information already stored in the context, and updates it with the
   information received in current header.




Bormann (ed.)                                                  [Page 43]

INTERNET-DRAFT          Robust Header Compression           Oct 03, 2000


   The sequence number is reconstructing by replacing the sequence
   number LSBs in the context with those received in the header. The
   resulting value is then verified to be within the expected
   interpretation interval based on previously decompressed value v_ref,
   see chapter 4.5.1. If not within this interval, an interpretation
   adjustment should be applied by adding or subtracting Nxinterval_size
   to/from the reconstructed value. If the interpretation is adjusted,
   the old value MUST be stored together with a flag telling that this
   happened. First when the next packet has been correctly decompressed,
   this flag can be reset and the old value discarded.

   If RTP Timestamp and IP Identification fields are not included in the
   received header, they are supposed to be calculated based on the
   sequence number. The IP Identifier is usually increasing with the
   same delta as the sequence number and the timestamp with the same
   delta times a fixed value. See chapters 4.5.3 and 4.5.5 for details
   about how these fields are encoded in compressed headers.

   When working in unidirectional mode, all decompressed headers carry a
   CRC which MUST be used to verify decompression.


5.3.2.2.3.  Actions upon CRC failure

   A mismatch in the 3-bit CRC can be caused by one or more of:

     1. residual bit errors in the current header,

     2. a damaged context due to residual bit errors in previous
        headers, or

     3. loss of many consecutive packets which causes the 4-bit SN LSB
        to wrap around without the compressor noticing this (which is,
        in essence, another kind of context damage).

   The 3-bit CRC present in some header formats will reliably detect
   context damage eventually, since the probability of undetected
   context damage decreases exponentially with each new header
   processed.  However, residual bit errors in the current header are
   only detected with good probability, not reliably.

   When a CRC mismatch is caused by residual bit errors in the current
   header (case 1 above), the decompressor should stay in its current
   state to avoid unnecessary loss of subsequent packets. On the other
   hand, when the mismatch is caused by a damaged context, the
   decompressor can attempt to repair the context but if that fails, it
   must move to a lower state to avoid delivering incorrect headers.
   When the mismatch is caused by long loss, the decompressor might
   attempt additional decompression attempts.





Bormann (ed.)                                                  [Page 44]

INTERNET-DRAFT          Robust Header Compression           Oct 03, 2000


   In the following sections the various actions to take in case of CRC
   failure are described in detail. If these mechanisms fail in finding
   the reason for the CRC mismatch, additional decompression attempts
   SHOULD NOT be performed.

5.3.2.2.3.1.  Correction of SN wrap-around

   If many consecutive packets are lost there will be a risk of sequence
   number LSB wrap around. The decompressor might be able to detect this
   situation and avoiding context damage by using a local clock. The
   following algorithm can be used:

     a.The decompressor notes the arrival time, a(i), of each incoming
       packet i. Arrival times of packets where decompression fails are
       discarded.

     b.When decompression fails, the decompressor computes INTERVAL =
       a(i) - a(i-1), i.e., the time elapsed between the arrival of the
       previous correctly decompressed packet and the current packet.

     c.If wrap-around has occurred, INTERVAL will correspond to at
       least 16 inter-packet times. Based on an estimate of the packet
       inter-arrival time, obtained for example using a moving average
       of arrival times, TS STRIDE, or TS TIME, the decompressor judges
       if INTERVAL can correspond to 16 or more inter-packet times.

     d.If INTERVAL is judged to be at least 16 packet inter-arrival
       times, the decompressor adds 16 to the SN of the context and
       attempts to decompress the packet using the new context.

     e.If this decompression succeeds, the decompressor updates the
       context but SHOULD NOT deliver the packet to upper layers. The
       following packet is also decompressed and updates the context if
       its CRC succeeds, but SHOULD be discarded. If decompression of
       the third packet using the new context also succeeds, the
       context repair is deemed successful and this and subsequent
       decompressed packets are delivered to the upper layers.

     f.If any of the three decompression attempts in d. and e. fails,
       the decompressor discards the packets and moves to the Static
       Context state.

   Using this mechanism, the decompressor may be able to repair the
   context after excessive loss, at the expense of discarding two
   packets.


5.3.2.2.3.2.  Repair of incorrect SN updates

   The CRC can fail to detect residual errors in the compressed header
   because of its limited length, i.e., the incorrectly decompressed



Bormann (ed.)                                                  [Page 45]

INTERNET-DRAFT          Robust Header Compression           Oct 03, 2000


   packet can happen to have the same CRC as the original uncompressed
   packet, causing the incorrectly decompressed packet to be accepted
   and the context being updated. This can lead to an erroneous
   reference SN being used in W-LSB decoding, as the reference SN is
   updated for each successfully decompressed header of certain types.

   If this happens, the decompressor will detect the incorrect
   decompression of the following packet with high probability, but it
   does not know the reason for the failure. The following mechanism
   allows the decompressor to judge if the context was updated
   incorrectly by an earlier packet.

   1) The decompressor maintains two decompressed SN: the last one
      (ref 0) and the one before that (ref -1).

   2) When receiving a compressed SN:

      SN curr = decompressed SN using ref 0 as reference value
      decompress the rest of the header using SN curr
      IF (the header passes the CRC test)
        ref -1 = ref 0
        ref 0 = SN curr
   3) ELSE
        SN curr = decompressed SN using ref -1 as reference value
        decompress rest of header using SN curr
        IF (header passes the CRC test)
          ref0 = SN curr;  // note ref-1 unchanged
   4)   ELSE
          // one of two error situations:
          // 1) bit error in current header,
          // 2) decompression context corrupted. Use 5.3.2.2.4 to
          // distinguish, (e.g., assume context corrupted
          // only after k out of n errors)

   The purpose of this algorithm is to repair the context. If the header
   generated in 3) passes the CRC test, two more headers MUST also be
   successfully decompressed before the repair is deemed successful. Of
   the three successful headers, the first two SHOULD be discarded and
   only the third delivered to upper layers. If decompression of any of
   the three headers fail, the decompressor MUST discard that header and
   the previously generated headers, and move to the Static Context
   state.


5.3.2.2.3.3.  Judge whether bit error or context damage

   When the CRC check fails, the first step should be to check whether a
   SN wrap-around has occurred, as described in 5.3.2.2.3.1. If that
   attempt fails, repair of a possible incorrect SN update should be
   carried out, as described in previous section.




Bormann (ed.)                                                  [Page 46]

INTERNET-DRAFT          Robust Header Compression           Oct 03, 2000


   However, if both these attempts fail there are two possible reasons
   for the CRC failure either bit errors that have not been detected by
   the link layer or an unrecoverable context damage. It is impossible
   to know which of these is the cause for failure but there are some
   simple rules for how to act when this happens.

   1: For the first CRC failures, assume bit error and simply discard
      the packet. A context request MAY be sent at this time.

   2: When several consecutive decompressed packets have been erroneous,
      context damage SHOULD be assumed and a context request be sent.
      The decompressor MUST also move to Static Context state and
      discard all packets until an update is received.


5.3.2.3.  Feedback in unidirectional mode

   To improve performance for the unidirectional mode over a link that
   does have a feedback channel, the decompressor MAY send an
   acknowledgment when decompression succeeds. Setting the mode
   parameter in the ACK packet to U indicates that the compressor is to
   stay in unidirectional mode.  When receiving an ACK(U), the
   compressor should reduce the frequency of IR packets since the static
   information has been correctly received, but it is not required to
   stop sending IR packets. If IR packets continue to arrive, the
   decompressor MAY repeat the ACK(U), but it SHOULD not repeat the
   ACK(U) continuously.



























Bormann (ed.)                                                  [Page 47]

INTERNET-DRAFT          Robust Header Compression           Oct 03, 2000


5.4.  Operation in bi-directional optimistic mode

5.4.1.  Compressor states and logic (O-mode)

   Below is the state machine for the compressor in bi-directional
   optimistic mode. Details of each state, the transitions between
   states and compression logic are given subsequent to the figure.

                         Optimistic approach / ACK
      +------>------>------>------>------>------>------>------>------+
      |                                                              |
      |      Optimistic appr. / ACK      Optimistic appr. / ACK      |
      |      +------>------>------+      +------>------>------+      |
      |      |                    |      |                    |      |
      |      |                    v      |                    v      v
    +----------+                +----------+                +----------+
    | IR State |                | FO State |                | SO State |
    +----------+                +----------+                +----------+
      ^      ^                    |      ^                    |      |
      |      |    STATIC-NACK     |      |    NACK / Update   |      |
      |      +------<------<------+      +------<------<------+      |
      |                                                              |
      |                         STATIC-NACK                          |
      +------<------<------<------<------<------<------<------<------+


5.4.1.1.  State transition logic

   The transition logic for compression states in bi-directional
   optimistic mode has much in common with the logic of the
   unidirectional mode. The optimistic approach principle and
   transitions because of the need for updates works in the same way as
   described in chapter 5.3.1. However, in optimistic mode there are no
   timeouts. Instead, the optimistic mode makes use of feedback from
   decompressor to compressor both for transitions in the backward
   direction and for improved forward transition.

5.4.1.1.1.  Negative acknowledgements (NACKs), downward transition

   Negative acknowledgements (NACKs), also called context requests,
   replaces the periodic updates needed in unidirectional mode. Upon
   reception of a NACK the compressor transits back to the FO state and
   send context updates to the decompressor. Similarly, reception of a
   STATIC-NACK packet makes the compressor transit back to IR state.

5.4.1.1.2.  Optional acknowledgements, upwards transition

   In addition to the NACKs, also positive feedback (ACKs) MAY be used
   in the bi-directional optimistic mode. Upon reception of an ACK, the
   compressor knows that the decompressor has received the acknowledged
   packet and transition to a higher compression state can be carried



Bormann (ed.)                                                  [Page 48]

INTERNET-DRAFT          Robust Header Compression           Oct 03, 2000


   out without any doubts. Since this functionality is optional, a
   compressor MUST NOT expect to get such ACKs initially. First after
   reception of an acknowledgement for a non-IR packet, the compressor
   can expect to get ACKs also after that.


5.4.1.2.  Compression logic and packets used

   The compression logic is the same for bi-directional optimistic mode
   as for the unidirectional mode (see section 5.3.1.2)


5.4.2.  Decompressor states and logic (O-mode)

   The decompression states and the state transition logic are the same
   as for the unidirectional case (see section 5.3.2). What differs is
   the decompression and feedback logic.


5.4.2.1.  Decompression logic, timer-based timestamp decompression

   In bi-directional mode, timer-based timestamp decompression may be
   used to improve compression efficiency if the RTP timestamp increases
   linearly. The mechanisms used are those described in 4.5.4.


5.4.2.2.  Feedback logic (O-mode)

   The feedback logic defines what feedback to send due to different
   events when operating in the various states. As mentioned above,
   there are three principal kinds of feedback that can be used; ACK,
   NACK and STATIC-NACK. Further, the logic described below will refer
   to three kind of packets that can be received by the decompressor;
   Initiation and Refresh (IR or IR-DYN) packets, type 1 or 2 (UO-1 or
   UOR-2) packets and UO-0 packets. An UO-0 packet carries a packet
   header compressed according to a fixed pattern while type 1 and 2
   packets are used when this patterns is broken.

   Below, rules for which feedback to use when are defined. For the
   optional feedback, it is REQUIRED that if used once, the decompressor
   MUST continue to send optional feedback for the lifetime of the
   packet stream.

   In NC state: - When an IR packet is correctly decompressed, send an
                  ACK with the mode parameter set to O
                - When type 1 or 2 packet, or UO-0 packet is received
                  or decompression of an IR packet has failed, send a
                  STATIC-NACK with the mode parameter set to O

   In SC state: - When an IR packet is correctly decompressed, send an
                  ACK with the mode parameter set to O



Bormann (ed.)                                                  [Page 49]

INTERNET-DRAFT          Robust Header Compression           Oct 03, 2000


                - When a type 1 or 2 packet is correctly decompressed,
                  optionally send an ACK with the mode parameter set to
                  O
                - When an UO-0 packet is received, send a NACK with the
                  mode parameter set to O
                - When decompression of a type 1 or 2, or an IR packet
                  has failed, send a STATIC-NACK with the mode
                  parameter set to O

   In FC state: - When an IR packet is correctly decompressed, send an
                  ACK with the mode parameter set to O
                - When a type 1 or 2 packet is correctly decompressed,
                  optionally send an ACK with the mode parameter set to
                  O
                - When an UO-0 packet is correctly decompressed, no
                  feedback is sent
                - When decompression of any packet has failed, send a
                  NACK with the mode parameter set to O




































Bormann (ed.)                                                  [Page 50]

INTERNET-DRAFT          Robust Header Compression           Oct 03, 2000


5.5.  Operation in bi-directional reliable mode

5.5.1.  Compressor states and logic (R-mode)

   Below is the state machine for the compressor in bi-directional
   reliable mode. Details of each state, the transitions between states
   and compression logic are given subsequent to the figure.

                                    ACK
      +------>------>------>------>------>------>------>------+
      |                                                       |
      |               ACK                         ACK         |   ACK
      |      +------>------>------+      +------>------>------+  +->-+
      |      |                    |      |                    |  |   |
      |      |                    v      |                    v  |   v
    +----------+                +----------+                +----------+
    | IR State |                | FO State |                | SO State |
    +----------+                +----------+                +----------+
      ^      ^                    |      ^                    |      |
      |      |    STATIC-NACK     |      |    NACK / Update   |      |
      |      +------<------<------+      +------<------<------+      |
      |                                                              |
      |                         STATIC-NACK                          |
      +------<------<------<------<------<------<------<------<------+

5.3.1.1.  State transition logic (R-mode)

   The transition logic for compression states in reliable mode is
   similar to the logic of the unidirectional mode, but completely
   relies on ACKs for forward transitions.

5.5.2.  Decompressor states and logic (R-mode)

   The decompression states and the state transition logic are the same
   as for the unidirectional case (see section 5.3.2). What differs is
   the decompression and feedback logic.

5.5.2.1.  Decompression logic (R-mode)

   TBW.

5.5.2.2.  Feedback logic (R-mode)

   The feedback logic for the bi-directional reliable mode is identical
   to the one in optimistic mode (see chapter 5.4.2.2) with two
   important exceptions:

   - All feedback is mandatory, also the feedback defined as optional
     for the optimistic mode.





Bormann (ed.)                                                  [Page 51]

INTERNET-DRAFT          Robust Header Compression           Oct 03, 2000


   - Feedback MUST NOT be sent for packets not updating the context
     (i.e. packets that do not carry a CRC).


5.6.  Mode transitions

   The decision to move from one compression mode to another is taken by
   the decompressor and the possible mode transitions are shown in the
   figure below. Subsequent chapters describe how the transitions are
   performed together with exceptions for the compression and
   decompression functionality during transitions.

                         +-------------------------+
                         | Unidirectional (U) mode |
                         +-------------------------+
                           / ^                 \ ^
                          / /Feedback(U)        \ \Feedback(U)
                         / /                     \ \
                        / /                       \ \
            Feedback(O)/ /              Feedback(R)\ \
                      v /                           v \
      +---------------------+    Feedback(R)    +-------------------+
      | Optimistic (O) mode | ----------------> | Reliable (R) mode |
      |                     | <---------------- |                   |
      +---------------------+    Feedback(O)    +-------------------+


5.6.1.  Compression and decompression during mode transitions

   The following sections assume that compressor and decompressor for
   each context maintains a variable, whose value is the current
   compression mode for that context. The value of the variable controls
   which packet types to use, actions taken, etc, for that context.

   Subsequent chapters define exactly when to change the value of the
   MODE variable. When ROHC transits between compression modes, there
   are several cases where the behavior of compressor or decompressor
   must be restricted during the transition phase. These restrictions
   are defined by exception parameters that specifies which restrictions
   to apply. The transition descriptions in subsequent chapters refer to
   these exception parameters and defines when and to what values they
   are set. All mode related parameters are listed below together with
   their possible values, with explanations and restrictions:

   Parameters for the compressor side:

      - C_MODE
                Possible values for the C_MODE parameter are
                (U)NIDIRECTIONAL, (O)PTIMISTIC and (R)ELIABLE. C MODE
                MUST be initialized to U.




Bormann (ed.)                                                  [Page 52]

INTERNET-DRAFT          Robust Header Compression           Oct 03, 2000


      - C_TRANS
                Possible values for the C_TRANS parameter are (P)ENDING
                and (D)ONE. C TRANS MUST be initialized to D. When C
                TRANS is P, it is REQUIRED that
                1) the compressor only uses packet formats common to
                   all modes,
                2) it does not transit to SO state.
                3) New mode transition requests are ignored.

   Parameters for the decompressor side:

      - D_MODE
                Possible values for the D_MODE parameter are
                (U)NIDIRECTIONAL, (O)PTIMISTIC and (R)ELIABLE. C MODE
                MUST be initialized to U.


      - D_TRANS
                Possible values for the D_TRANS parameter are
                (I)NITIATED, (P)ENDING and (D)ONE. D TRANS MUST be
                initialized to D. A mode transition can be initiated
                only when D TRANS is D. While D TRANS is I, the
                decompressor sends a NACK or ACK for all received
                packets.


5.6.2.  Transition from Unidirectional to Optimistic mode

   As long as there is a feedback channel available, the decompressor
   can at any moment decide to initiate transition from unidirectional
   to bi-directional Optimistic mode. All feedback packets can be used
   with the mode parameter set to O and the decompressor can then
   directly start working in Optimistic mode. The compressor transits
   from unidirectional to optimistic mode as soon as it receives any
   feedback packet with the mode parameter set to O. The transition
   procedure is described below:

               Comnpressor                     Decompressor
              ----------------------------------------------
                    |                               |
                    |        ACK(R)/NACK(R) +-<-<-<-|  D_MODE = O
                    |       +-<-<-<-<-<-<-<-+       |
    C_MODE = O      |-<-<-<-+                       |
                    |                               |

   If the feedback packet is lost, the compressor will continue to work
   in unidirectional mode, but as soon as any feedback packet reaches
   the compressor it will transit to Optimistic mode.






Bormann (ed.)                                                  [Page 53]

INTERNET-DRAFT          Robust Header Compression           Oct 03, 2000



5.6.3.  From Optimistic to Reliable mode

   Transition from Optimistic to Reliable mode is permitted only after
   at least one packet has been correctly decompressed, which means that
   at least the static part of the context is established. An ACK(R) or
   a NACK(R) feedback packet is sent to initiate the mode transition.
   The compressor MUST NOT use packet types 0 or 1 during transition.
   The transition procedure is described below:

               Comnpressor                     Decompressor
              ----------------------------------------------
                    |                               |
                    |        ACK(R)/NACK(R) +-<-<-<-|  D_TRANS = I
                    |       +-<-<-<-<-<-<-<-+       |
    C_TRANS = P     |-<-<-<-+                       |
    C_MODE = R      |                               |
                    |->->->-+   FO(SN0,R)           |
                    |       +->->->->->->->-+       |
                    |->-..                  +->->->-|  D TRANS = P
                    |->-..                          |  D_MODE = R
                    |           ACK(SN0,R)  +-<-<-<-|
                    |       +-<-<-<-<-<-<-<-+       |
    C_TRANS = D     |-<-<-<-+                       |
                    |                               |
                    |->->->-+ SO (Reliable mode)    |
                    |       +->->->->->->->-+       |
                    |                       +->->->-|  D_TRANS = D
                    |                               |

   As long as the decompressor has not received an FO packet with the
   mode transition parameter set to R, it must stay in Optimistic mode.
   The compressor must stay in FO state until it has received an ACK for
   an FO packet sent with the mode transition parameter set to R
   (indicated by the sequence number).


5.6.4.  From Unidirectional to Reliable mode

   Since transition from Unidirectional to Optimistic mode do not
   require any handshakes, it is possible to transit directly from
   Unidirectional to Reliable mode, following the same transition
   procedure in 5.6.3 above.


5.6.5.  From Reliable to Optimistic mode

   Either the ACK(O) or the NACK(O) feedback packet is used to initiate
   the transition from Reliable to Optimistic mode and the compressor
   MUST always run in FO state during transition. The transition
   procedure is described below:



Bormann (ed.)                                                  [Page 54]

INTERNET-DRAFT          Robust Header Compression           Oct 03, 2000



               Comnpressor                     Decompressor
              ----------------------------------------------
                    |                               |
                    |        ACK(O)/NACK(O) +-<-<-<-|  D_TRANS = I
                    |       +-<-<-<-<-<-<-<-+       |
    C_TRANS = P     |-<-<-<-+                       |
    C_MODE = O      |                               |
                    |->->->-+   FO(SN0,O)           |
                    |       +->->->->->->->-+       |
                    |->-..                  +->->->-|  D_MODE = O
                    |->-..                          |
                    |           ACK(SN0,O)  +-<-<-<-|
                    |       +-<-<-<-<-<-<-<-+       |
    C_TRANS = D     |-<-<-<-+                       |
                    |                               |
                    |->->->-+ SO (Optimistic mode)  |
                    |       +->->->->->->->-+       |
                    |                       +->->->-|  D_TRANS = D
                    |                               |

   As long as the decompressor has not received an FO packet with the
   mode transition parameter set to O, it must stay in Reliable mode.
   The compressor must stay in FO state until it has received an ACK for
   a FO packet sent with the mode transition parameter set to O
   (indicated by the sequence number).




























Bormann (ed.)                                                  [Page 55]

INTERNET-DRAFT          Robust Header Compression           Oct 03, 2000


5.6.6.  Transition to Unidirectional mode

   It is possible to force transition back to unidirectional mode if the
   decompressor desires to do so. Independent of which mode it starts
   from, a three way handshake MUST be carried out to ensure correct
   transition on the compressor side. The transition procedure is
   described below:

               Compressor                     Decompressor
              ----------------------------------------------
                    |                               |
                    |        ACK(U)/NACK(U) +-<-<-<-|  D_TRANS = I
                    |       +-<-<-<-<-<-<-<-+       |
    C_TRANS = P     |-<-<-<-+                       |
    C_MODE = U      |                               |
                    |->->->-+   FO(SN0,U)           |
                    |       +->->->->->->->-+       |
                    |->-..                  +->->->-|
                    |->-..                          |
                    |           ACK(SN0,U)  +-<-<-<-|
                    |       +-<-<-<-<-<-<-<-+       |
    C_TRANS = D     |-<-<-<-+                       |
                    |                               |
                    |->->->-+ SO (Uni. mode)        |
                    |       +->->->->->->->-+       |
                    |                       +->->->-|  D_TRANS = D
                    |                               |  D_MODE = U

   The decompressor must continue to send feedback until it knows that
   the compressor is ready with the transition.
























Bormann (ed.)                                                  [Page 56]

INTERNET-DRAFT          Robust Header Compression           Oct 03, 2000



5.7.  Packet formats

   A ROHC RTP packet has the following general format.

    --- --- --- --- --- --- --- ---
   /           Padding             /
    --- --- --- --- --- --- --- ---
   /           Feedback            /
    --- --- --- --- --- --- --- ---
   /            Header             /
    --- --- --- --- --- --- --- ---
   /           Payload             /
    --- --- --- --- --- --- --- ---

   Padding is any number (zero or more) of padding octets.

   Padding Octet

     0   1   2   3   4   5   6   7
   +---+---+---+---+---+---+---+---+
   | 1   1   1   0   0   0   0   0 |
   +---+---+---+---+---+---+---+---+

   (Note that the Padding Octet looks like, and in many implementations
   can be processed as, an Add-CID Octet for CID 0.)

   Either of Feedback or Header must be present. Header is either a
   compressed header or an IR or IR-DYN header. Feedback and Header
   either

   1) do not carry any CID information (indicating CID zero), or

   2) start with one Add-CID Octet (see below), or

   3) contain embedded CID information of length one or two octets.

   Alternatives 1) and 2) apply to compressed headers in channels where
   the CID space is small, and feedback related to such headers.
   Alternative 3 applies only to compressed headers in channels where
   the CID space is large, and feedback related to such headers.

   Add-CID Octet

     0   1   2   3   4   5   6   7
   +---+---+---+---+---+---+---+---+
   | 1   1   1   0 |      CID      |
   +---+---+---+---+---+---+---+---+

      CID:   0x1 through 0xF indicates CIDs 1 through 15.
             (0x0 indicates a padding octet.)



Bormann (ed.)                                                  [Page 57]

INTERNET-DRAFT          Robust Header Compression           Oct 03, 2000




   All remaining types have the following general format:

     0              x-1  x       7
    --- --- --- --- --- --- --- ---
   |         Add-CID octet         | if for CID 1-15 and small CIDs
   +---+--- --- --- ---+--- --- ---+
   | type indication   |   body    | 1 octet (8-x bits of body)
   +---+--- ---+---+---+--- --- ---+
   |                               |
   /    0, 1, or 2 octets of CID   / 1 or 2 octets if large CIDs
   |                               |
   +---+---+---+---+---+---+---+---+
   /             body              /  variable
   +---+---+---+---+---+---+---+---+

   The additional CID octets, if present, are encoded according to
   section 4.5.6. Sections 5.7.1-7 describe the formats more fully.



   Similar fields occur in several formats, therefore it is explained
   here how these fields are used. The following notation is used:

     bits(X) = the number of bits for field X present in the compressed
                   header (including extension).

     field(X) = the value of field X in the compressed header.

     context(X) = the value of field X as established in the context.

     value(X) = field(X) if X is present in the compressed header, else
                context(X).

     hdr(X) = the value of field X in the uncompressed or
              decompressed header.



   The following fields occur in several headers and extensions.

   SN    The compressed RTP sequence number.

     Compressed with W-LSB. The interpretation intervals, see section
     4.5.1, are defined as follows:

           p = -1                  if bits(SN) <= 4
           p = 2^(bits(SN)-2) - 1  if bits(SN) >  4





Bormann (ed.)                                                  [Page 58]

INTERNET-DRAFT          Robust Header Compression           Oct 03, 2000




   IP-ID   A compressed IP-ID field.

     IP-ID fields in compressed base headers carry the compressed IP-ID
     of the innermost IPv4 header whose corresponding RND flag is not 1.

     The rules below assume the IP-ID is for the innermost IP header. If
     it is for an outer IP header, the RND2 and NBO2 flags should be
     used instead of RND and NBO.

     If value(RND)=0, hdr(IP-ID) is compressed using Offset IP-ID
     encoding, see section 4.5.5., using p=0 and default-slope(IP-ID
     offset)=0.

     If value(RND)=1, IP-ID is the uncompressed hdr(IP-ID). IP-ID is
     then passed as additional octets at the end of the compressed
     header, after any Extensions.

     If value(NBO)=1, the octets of hdr(IP-ID) are swapped before
     compression and after decompression. It is pointless but not
     harmful to set both NBO and RND.


   TS    The compressed RTP Timestamp value.

     If value(TIME_STRIDE) > 0, Timer-based compression of RTP
     Timestamp, see section 4.5.4., is used.

     If value(Tsc)=1, Scaled RTP Timestamp encoding is used before
     compression, see section 4.5.3., and default-slope(TS) = 1.

     If value(Tsc)=0, the Timestamp value is compressed as-is, and
     default-slope(TS) = value(TS_STRIDE).


   CRC   CRC over the original, uncompressed, header.

     For 3-bit CRCs, the polynomial of section 5.9.2 is used.
     For 7-bit CRCs, the polynomial of section 5.9.2 is used.
     For 8-bit CRCs, the polynomial of section 5.9.1 is used.


   M   RTP Marker bit.

     Context(M) is initially zero and is never updated. Value(M)=1 only
     when field(M)=1.







Bormann (ed.)                                                  [Page 59]

INTERNET-DRAFT          Robust Header Compression           Oct 03, 2000


   The general format for a compressed header is as follows

     0   1   2   3   4   5   6   7
    --- --- --- --- --- --- --- ---
   |         Add-CID octet         | if for CID 1-15 and small CIDs
   +---+---+---+---+---+---+---+---+
   |   first octet of base header  | (with type indication)
   +---+---+---+---+---+---+---+---+
   |                               |
   /   0, 1, or 2 octets of CID    / 1-2 octets if large CIDs
   |                               |
   +---+---+---+---+---+---+---+---+
   /   remainder of base header    / variable number of bits
   +---+---+---+---+---+---+---+---+
   /     Extension (see 5.7.5)     / extension, if X=1 in base header
    --- --- --- --- --- --- --- ---
   /   IP-ID of inner Ipv4 header  / 2 octets, if value(RND)=1
    --- --- --- --- --- --- --- ---
   /   IP-ID of outer IPv4 header  / 2 octets, if value(RND2)=1
    --- --- --- --- --- --- --- ---
   /         UDP Checksum          / 2 oct, if context(UDP Checksum)!= 0
    --- --- --- --- --- --- --- ---

   In subsequent sections, the position of the large CID is indicated
   using the notation

   +===+===+===+===+===+===+===+===+


   Whether the UDP Checksum field is present or not is controlled by the
   value of the UDP Checksum in the context. If non-zero, the UDP
   checksum is enabled and sent along with each packet. If zero, the UDP
   Checksum is disabled and not sent. Should hdr(UDP checksum) be non-
   zero when context(UDP Checksum) is non-zero, the header cannot be
   compressed. It must be sent uncompressed or the context reinitialized
   using an IR-packet.

   When an IPv4 header is present in the static context, for which the
   corresponding RND flag has not been established to be 1, packet types
   R-1 and UO-1 MUST NOT be used.

   When no IPv4 header is present in the static context, or the RND
   flags for all IPv4 headers in the context have been established to be
   1, packet types R-1-ID, R-1-TS, UO-1-ID, and UO-1-TS MUST NOT be
   used.

   During the transient state when an RND flag is being established,
   packet types R-1-ID, R-1-TS, UO-1-ID, or UO-1-TS, MUST NOT be used.
   This implies that the RND flag(s) of the Extension 3 may have to be
   consulted before the format of a base header carrying an Extension 3
   can be determined.



Bormann (ed.)                                                  [Page 60]

INTERNET-DRAFT          Robust Header Compression           Oct 03, 2000


5.7.1. Packet type 0: UO-0, R-0, R-0-CRC

   Packet type 0 is indicated by the first bit being 0:

   R-0

     0   1   2   3   4   5   6   7
   +---+---+---+---+---+---+---+---+
   | 0 | 0 |          SN           |
   +===+===+===+===+===+===+===+===+

     Updating properties: R-0 packets do not update any part of the
     context.


   R-0-CRC

     0   1   2   3   4   5   6   7
   +---+---+---+---+---+---+---+---+
   | 0 | 1 |            SN         |
   +===+===+===+===+===+===+===+===+
   |SN |            CRC            |
   +---+---+---+---+---+---+---+---+

     Updating properties: R-0-CRC packets updates context(RTP sequence
     number).

     Note: the SN field straddles the CID field.


   UO-0

     0   1   2   3   4   5   6   7
   +---+---+---+---+---+---+---+---+
   | 0 |      SN       |    CRC    |
   +===+===+===+===+===+===+===+===+

     Updating properties: The UO-0 packet updates the current value of
     context(RTP sequence number).


5.7.2. Packet type 1 (R-mode): R-1, R-1-TS, R-1-ID

   Packet type 1 is indicated by the first bits being 10

   R-1

     0   1   2   3   4   5   6   7
   +---+---+---+---+---+---+---+---+
   | 1   0 |          SN           |
   +===+===+===+===+===+===+===+===+



Bormann (ed.)                                                  [Page 61]

INTERNET-DRAFT          Robust Header Compression           Oct 03, 2000


   | M | X |          TS           |
   +---+---+---+---+---+---+---+---+

     Note: R-1 cannot be used if the context contains at least one IPv4
     header with value(RND) = 0.  This disambiguates it from R-1-ID and
     R-1-TS.

   R-1-ID

     0   1   2   3   4   5   6   7
   +---+---+---+---+---+---+---+---+
   | 1   0 |          SN           |
   +===+===+===+===+===+===+===+===+
   | M | X |T=0|       IP-ID       |
   +---+---+---+---+---+---+---+---+

     Note: R-1-ID cannot be used if there is no IPv4 header in the
     context or if value(RND) and value(RND2) are both 1.

   R-1-TS

     0   1   2   3   4   5   6   7
   +---+---+---+---+---+---+---+---+
   | 1   0 |          SN           |
   +===+===+===+===+===+===+===+===+
   | M | X |T=1|        TS         |
   +---+---+---+---+---+---+---+---+

     Note: R-1-TS cannot be used if there is no IPv4 header in the
     context or if value(RND) and value(RND2) are both 1.

     X: X=0 indicates that no Extension is present,
        X=1 indicates that an Extension is present.

     T: T=0 indicates format R-1-ID,
        T=1 indicates format R-1-TS.

     Updating properties: R-1* headers do not update any part of the
     context.















Bormann (ed.)                                                  [Page 62]

INTERNET-DRAFT          Robust Header Compression           Oct 03, 2000


5.7.3. Packet type 1 (UO-modes): UO-1, UO-1-ID, UO-1-TS

   UO-1

     0   1   2   3   4   5   6   7
   +---+---+---+---+---+---+---+---+
   | 1   0 |          TS           |
   +===+===+===+===+===+===+===+===+
   | M |      SN       |    CRC    |
   +---+---+---+---+---+---+---+---+

     Note: UO-1 cannot be used if the context contains at least one IPv4
     header with value(RND) = 0.  This disambiguates it from UO-1-ID and
     UO-1-TS.


   UO-1-ID

     0   1   2   3   4   5   6   7
   +---+---+---+---+---+---+---+---+
   | 1   0 |T=0|       IP-ID       |
   +===+===+===+===+===+===+===+===+
   | X |        SN     |    CRC    |
   +---+---+---+---+---+---+---+---+

     Note: UO-1-ID cannot be used if there is no IPv4 header in the
     context or if value(RND) and value(RND2) are both 1.


   UO-1-TS

     0   1   2   3   4   5   6   7
   +---+---+---+---+---+---+---+---+
   | 1   0 |T=1|        TS         |
   +===+===+===+===+===+===+===+===+
   | M |      SN       |    CRC    |
   +---+---+---+---+---+---+---+---+

     Note: UO-1-TS cannot be used if there is no IPv4 header in the
     context or if value(RND) and value(RND2) are both 1.

     X: X=0 indicates that no Extension is present,
        X=1 indicates that an Extension is present.

     T: T=0 indicates format UO-1-ID, T=1 indicates format UO-1-TS.

     Updating properties: UO-1* packets update context(RTP sequence
     number). UO-1 and UO-1-TS packets update context(RTP Timestamp).
     UO-1-ID packets update context(IP-ID). Values provided in
     Extensions, other than in other SN, TS, or IP-ID fields, do not
     update the context.



Bormann (ed.)                                                  [Page 63]

INTERNET-DRAFT          Robust Header Compression           Oct 03, 2000


5.7.4. Packet type 2: UOR-2

   Packet type 2 is indicated by the first bits being 110

   UOR-2

     0   1   2   3   4   5   6   7
   +---+---+---+---+---+---+---+---+
   | 1   1   0 |        TS         |
   +===+===+===+===+===+===+===+===+
   |TS | M |          SN           |
   +---+---+---+---+---+---+---+---+
   | X |            CRC            |
   +---+---+---+---+---+---+---+---+


   UOR-2-ID

     0   1   2   3   4   5   6   7
   +---+---+---+---+---+---+---+---+
   | 1   1   0 |       IP-ID       |
   +===+===+===+===+===+===+===+===+
   |T=0| M |          SN           |
   +---+---+---+---+---+---+---+---+
   | X |            CRC            |
   +---+---+---+---+---+---+---+---+


   UOR-2-TS

     0   1   2   3   4   5   6   7
   +---+---+---+---+---+---+---+---+
   | 1   1   0 |        TS         |
   +===+===+===+===+===+===+===+===+
   |T=1| M |          SN           |
   +---+---+---+---+---+---+---+---+
   | X |            CRC            |
   +---+---+---+---+---+---+---+---+

     X: X=0 indicates that no Extension is present,
        X=1 indicates that an Extension is present.

     T: T=0 indicates format UOR-2-ID, T=1 indicates format UOR-2-TS.

     Updating properties: All values provided in UOR-2* packets update
     the context, unless explicitly stated otherwise.








Bormann (ed.)                                                  [Page 64]

INTERNET-DRAFT          Robust Header Compression           Oct 03, 2000


5.7.5. Extension formats

   Fields in extensions are concatenated with the corresponding field in
   the base compressed header, if any. Bits in an extension are more
   significant than bits in the base compressed header.

   The TS field is scaled in all extensions, as it is in the base
   header, except optionally when using extension 3 where the Tsc flag
   can indicate that the TS field is not scaled. Value(TS_STRIDE) is
   used as the scale factor when scaling the TS field.

   In the following three extensions, the interpretation of the fields
   depend on whether there is a T-bit in the base compressed header, and
   if so, on the value of that field. When there is no T-bit, +T and -T
   both mean TS. This is the case when  there are no IPv4 headers in the
   static context, and when all IPv4 headers in the static context have
   their corresponding RND flag set (i.e., RND=1).

   If there is a T-bit,

     T = 1   indicates that +T is TS, and
                            -T is IP-ID.

     T = 0   indicates that +T is IP-ID, and
                            -T is TS.


   Extension 0:

     0   1   2   3   4   5   6   7
   +---+---+---+---+---+---+---+---+
   | 0   0 |    SN     |    +T     |
   +---+---+---+---+---+---+---+---+

   Extension 1:

   +---+---+---+---+---+---+---+---+
   | 0   1 |    SN     |    +T     |
   +---+---+---+---+---+---+---+---+
   |              -T               |
   +---+---+---+---+---+---+---+---+

   Extension 2:

   +---+---+---+---+---+---+---+---+
   | 1   0 |    SN     |    +T     |
   +---+---+---+---+---+---+---+---+
   |              +T               |
   +---+---+---+---+---+---+---+---+
   |              -T               |
   +---+---+---+---+---+---+---+---+



Bormann (ed.)                                                  [Page 65]

INTERNET-DRAFT          Robust Header Compression           Oct 03, 2000



   Extension 3 is a more elaborate extension which can give values for
   fields other than SN, TS, and IP-ID. Three optional flag octets
   indicates changes to IP header(s) and RTP header, respectively.

   Extension 3:

      0     1     2     3     4     5     6     7
   +-----+-----+-----+-----+-----+-----+-----+-----+
   |  1     1  |  S  |R-TS | Tsc |  I  | ip  | rtp |            (FLAGS)
   +-----+-----+-----+-----+-----+-----+-----+-----+
   |              Inner IP hdr flags         | ip2 |  if ip=1
    ..... ..... ..... ..... ..... ..... ..... .....
   |              Outer IP hdr flags               |  if ip2=1
    ..... ..... ..... ..... ..... ..... ..... .....
   |                      SN                       |  if S=1
    ..... ..... ..... ..... ..... ..... ..... .....
   /       TS (encoded as in section 4.5.6.)       /  1-4 oct, if R-TS=1
    ..... ..... ..... ..... ..... ..... ..... .....
   |                                               |
   /            Inner IP header fields             /  variable, if ip=1
   |                                               |
    ..... ..... ..... ..... ..... ..... ..... .....
   |                     IP-ID                     |  2 octets if I=1
    ..... ..... ..... ..... ..... ..... ..... .....
   |                                               |
   /            Outer IP header fields             /  variable, if ip2=1
   |                                               |
    ..... ..... ..... ..... ..... ..... ..... .....
   |                                               |
   /          RTP header flags and fields          /  variable, if rtp=1
   |                                               |
    ..... ..... ..... ..... ..... ..... ..... .....

     S, R-TS, I, ip, rtp, ip2: Indicate presence of fields as shown to
     the right of each field above.

     Tsc: Tsc=0 indicates that TS is not scaled.
          Tsc=1 indicates that TS is scaled according to section 4.5.3,
          using value(TS STRIDE).
          Context(Tsc) is always 1. If scaling is not desired, the
          compressor will establish TS_STRIDE = 1

     SN: see beginning of section 5.7.

     TS: Variable number of bits of TS, encoded according to
         section 4.5.6. See beginning of section 5.7.

     IP-ID: see beginning of section 5.7.





Bormann (ed.)                                                  [Page 66]

INTERNET-DRAFT          Robust Header Compression           Oct 03, 2000


   Inner IP header flags

     These correspond to the inner IP header if there are two, and the
     single IP header otherwise.

      0     1     2     3     4     5     6     7
    ..... ..... ..... ..... ..... ..... ..... .....
   | TOS | TTL | DF  | PR  | IPX | NBO | RND | ip2 |  if ip=1
    ..... ..... ..... ..... ..... ..... ..... .....

     TOS, TTL, PR, IPX: Indicates presence of fields as shown to the
        right of the field in question below.

     DF: Don't Fragment bit of IP header.

     NBO: Indicates whether the octets of hdr(IP identifier) of this IP
     header are swapped before compression and after decompression.
     NBO=1 indicates that the octets need not be swapped. NBO=0
     indicates that the octets are to be swapped. See section 4.5.5.

     RND: Indicates whether hdr(IP identifier) is not to be compressed
     but instead sent as-is in compressed headers.

     IP2: Indicates presence of Outer IP header fields. Unless the
     static context contains two IP headers, IP2 is always zero.


   Inner IP header fields

    ..... ..... ..... ..... ..... ..... ..... .....
   |         Type of Service/ Traffic Class        |  if TOS=1
    ..... ..... ..... ..... ..... ..... ..... .....
   |         Time to live/ Hop Limit               |  if TTL=1
    ..... ..... ..... ..... ..... ..... ..... .....
   |         Protocol/ Next Header                 |  if PR=1
    ..... ..... ..... ..... ..... ..... ..... .....
   /         Compressed IP extension hdr(s)        /  variable, if IPX=1
    ..... ..... ..... ..... ..... ..... ..... .....


     Type of Service/Traffic Class: That field in the IP header,
     absolute value.

     Time to live/ Hop Limit: That field in the IP header.

     Protocol/ Next Header: That field in the IP header.

     Compressed IP extension hdr(s): According to section 5.8.2.






Bormann (ed.)                                                  [Page 67]

INTERNET-DRAFT          Robust Header Compression           Oct 03, 2000


   Outer IP header flags

     The fields in this part of the Extension 3 header refers to the
     outermost IP header.

      0     1     2     3     4     5     6     7
    ..... ..... ..... ..... ..... ..... ..... .....
   | TOS2| TTL2| DF2 | PR2 |IPX2 |NBO2 |RND2 |  I2 |  if ip2=1
    ..... ..... ..... ..... ..... ..... ..... .....

     These flags are the same as the Inner IP header flags, but refer to
     the outer IP header instead of the inner IP header. The following
     flag, however, has no counterpart in the Inner IP header flags:

        I2: indicates presence of the IP-ID field.


   Outer IP header fields

    ..... ..... ..... ..... ..... ..... ..... .....
   |         Type of Service/ Traffic Class        |  if TOS2=1
    ..... ..... ..... ..... ..... ..... ..... .....
   |         Time to live/ Hop Limit               |  if TTL2=1
    ..... ..... ..... ..... ..... ..... ..... .....
   |         Protocol/ Next Header                 |  if PR2=1
    ..... ..... ..... ..... ..... ..... ..... .....
   /         compressed IP extension hdr(s)        / variable, if IPX2=1
    ..... ..... ..... ..... ..... ..... ..... .....
   |                     IP-ID                     |  2 octets if I2=1
    ..... ..... ..... ..... ..... ..... ..... .....

     The fields in this part of the Extension 3 are as for the Inner IP
     header fields, but refers to the outer IP header instead of the
     inner IP header. The following field, however, has no counterpart
     among the Inner IP header fields:

        IP-ID: the compressed Identifier field of the outer IP header,
        unless the inner header is an IPv6 header, in which case I2 is
        always zero.















Bormann (ed.)                                                  [Page 68]

INTERNET-DRAFT          Robust Header Compression           Oct 03, 2000


   RTP header flags and fields

      0     1     2     3     4     5     6     7
    ..... ..... ..... ..... ..... ..... ..... .....
   |   Mode    |R-PT |R-P  | R-X |CSRC | TSS | IPT |  if rtp=1
    ..... ..... ..... ..... ..... ..... ..... .....
   |  M  |             RTP PT                      |  if R-PT=1
    ..... ..... ..... ..... ..... ..... ..... .....
   /           Compressed CSRC-list                /  if CSRC=1
    ..... ..... ..... ..... ..... ..... ..... .....
   /                  TS STRIDE                    /  1-4 oct if TSS=1
    ..... ..... ..... ..... ..... ..... ..... ....
   /           TIME STRIDE (milliseconds)          /  1-4 oct if IPT=1
    ..... ..... ..... ..... ..... ..... ..... .....

     Mode: Compression mode. 0 = Reserved,
                             1 = Unidirectional,
                             2 = Bi-directional Optimistic,
                             3 = Bi-directional Reliable.

     R-PT, CSRC, TSS, IPT: Indicate presence of fields as shown to the
        right of each field below.

     R-P: RTP Padding bit, absolute value.

     R-X: RTP eXtension bit, absolute value.

     M: see beginning of section 5.7.

     RTP PT: Absolute value of RTP Payload type field.

     Compressed CSRC-list: see section 5.8.1.

     TS STRIDE: Predicted increment/decrement of the RTP Timestamp
     field, when it changes. Encoded as in section 4.5.6.

     TIME STRIDE: Predicted time interval between changes in RTP
     Timestamp, in milliseconds. Also indication that compressor desires
     to do Timer-based compression of the RTP Timestamp field, see
     section 4.5.4. Encoded as in section 4.5.6.


5.7.5.1   RND flags and packet types

   The values of the RND flag or RND2 flag is changed by sending UOR-2
   packets with an Extension 3 where the flag(s) have the new value. In
   U mode, the UOR-2 with Extension 3 is sent several times in order to
   ensure that the decompressor receives at least one. In O mode and R
   mode, the UOR-2 with Extension 3 is repeated until an  acknowledgment
   for a packet with the new RND flag value(s) is received.




Bormann (ed.)                                                  [Page 69]

INTERNET-DRAFT          Robust Header Compression           Oct 03, 2000


   The decompressor updates the value of its RND and RND2 flags whenever
   it receives an UOR-2 with an Extension 3 carrying values for RND or
   RND2, and the UOR-2 CRC verifies successful decompression.

   When an IPv4 header is present in the static context, for which the
   corresponding RND flag has not been established to be 1, packet types
   R-1 and UO-1 MUST NOT be used.

   When no IPv4 header is present in the static context, or the RND
   flags for all IPv4 headers in the context have been established to be
   1, packet types R-1-ID, R-1-TS, UO-1-ID, and UO-1-TS MUST NOT be
   used.

   During the transient state when an RND flag is being established,
   packet types R-1-ID, R-1-TS, UO-1-ID, or UO-1-TS, MUST NOT be used.
   This implies that the RND flag(s) of the Extension 3 may have to be
   consulted before the exact format of a base header carrying an
   Extension 3 can be determined, i.e., whether a T-bit is present or
   not.


5.7.5.2   Flags/Fields in context

   Some flags and fields in Extension 3 need to be maintained in the
   context of the decompressor. Their values are established using the
   mechanism appropriate to the compression mode, unless otherwise
   indicated in the table below and in referred sections.

   Flag/Field      Initial value   comment
   ---------------------------------------------------------------------
     Mode          Unidirectional  See section 5.x.x

     NBO               1
     RND               0

     NBO2              1
     RND2              0

     TS STRIDE         1
     TIME STRIDE       0
     Tsc               0           Tsc is always 0 in context.
                                   Can be 1 only when an Ext 3
                                   is present.











Bormann (ed.)                                                  [Page 70]

INTERNET-DRAFT          Robust Header Compression           Oct 03, 2000


5.7.6. Feedback packets and formats

   When the roundtrip time between compressor and decompressor is large,
   several packets can be in flight. Therefore, several packets can be
   received by the decompressor after feedback has been sent and before
   the compressor has reacted to feedback.

   When alternatives 4 or 5 are used, the decompressor SHOULD NOT send
   feedback for each successful decompression, unsuccessful
   decompression, or packet received in a rejected packet stream.
   Instead, a compressor SHOULD limit the rate at which feedback is
   sent.


5.7.6.1 Feedback packet type for ROHC RTP

   Feedback has the following format:

     0   1   2   3   4   5   6   7
    --- --- --- --- --- --- --- ---
   |         Add-CID octet         |  if for CID!=0 and small CIDs
   +---+---+---+---+---+---+---+---+
   | 1   1   1   1   1   0 | Code  |
   +---+---+---+---+---+---+---+---+
   |                               |
   /   0-2 octets of CID info      /  1-2 octets if for large CIDs
   |                               |
   +---+---+---+---+---+---+---+---+
   :         Feedback Length       :  if Code=1
   +---+---+---+---+---+---+---+---+
   /           feedback            /  FEEDBACK-1 or FEEDBACK-2
   +---+---+---+---+---+---+---+---+

       Code:   0 indicates FEEDBACK-2 format, no Feedback Length octet
               1 indicates FEEDBACK-2 format, with Feedback Length octet
               2 indicates FEEDBACK-1 format, R-mode (length 1 octet)
               3 indicates FEEDBACK-1 format, O-mode (length 1 octet)

       Feedback Length: indicates size of feedback field

       Feedback: According to section 5.7.6.2

   The CID identifies the context the feedback refers to. The total size
   of the feedback information is determinable as the decompressor must
   be informed about whether the CID space of the associated compressor
   is large or small. The feedback information is passed to the
   associated compressor upon reception.







Bormann (ed.)                                                  [Page 71]

INTERNET-DRAFT          Robust Header Compression           Oct 03, 2000


   Interleaved feedback

   For interleaved feedback, alternative 4) in 5.7.6, Code SHOULD not
   have the value one (1).


   Piggybacked feedback

   For piggybacked feedback, alternative 5) in 5.7.6, Code MUST NOT have
   the value zero (0), as the decompressor must be able to determine the
   size of the piggybacked feedback information without parsing it.


   Dedicated feedback channel

   Alternative 2) in 5.7.6. To achieve an octet-aligned format, the
   packet type indication and the code field is eliminated. Packet types
   are not needed in a dedicated channel. FEEDBACK-1 is always for R-
   mode.

   If the feedback is for large CIDs, the packet will always start with
   a CID.

   If the feedback is for small CIDs, the following procedure can
   determine the format:

        1) If the packet length is one octet, it is a FEEDBACK-1 (for R-
           mode).

        2) Otherwise, if the packet starts with the bits 11, and its
           length is 2 octets, it consists of an Add-CID octet followed
           by FEEDBACK-1.

        3) Otherwise, if the packet starts with the bits 11, and its
           length is larger than 2 octets, it consists of an Add-CID
           octet followed by FEEDBACK-2.

        4) Otherwise, the packet consists of a FEEDBACK-2.



5.7.6.2 Feedback formats for ROHC RTP

   The following is the format for feedback information for ROHC RTP. It
   is to be used when feedback information is piggybacked or interleaved
   (alternatives 4 and 5 in 5.7.6).

   Several feedback formats carry a field labeled SN. The SN field
   contains LSBs of an RTP sequence number. The sequence number to use
   is the sequence number of the header which caused the FEEDBACK packet
   to be sent. If that sequence number cannot be determined, for example



Bormann (ed.)                                                  [Page 72]

INTERNET-DRAFT          Robust Header Compression           Oct 03, 2000


   when decompression fails, the sequence number to use is that of the
   last successfully decompressed header. If no sequence number is
   available, the SN field is zero.


   FEEDBACK-1

     0   1   2   3   4   5   6   7
   +---+---+---+---+---+---+---+---+
   |              SN               |
   +---+---+---+---+---+---+---+---+

     A FEEDBACK-1 is an ACK. In order to send a NACK or a STATIC-NACK,
     FEEDBACK-2 must be used. To indicate Unidirectional mode, FEEDBACK-
     2 must be used.


   FEEDBACK-2

     0   1   2   3   4   5   6   7
   +---+---+---+---+---+---+---+---+
   |Acktype| Mode  |      SN       |
   +---+---+---+---+---+---+---+---+
   |              SN               |
   +---+---+---+---+---+---+---+---+
   /       Feedback options        /
   +---+---+---+---+---+---+---+---+

     Acktype:  0 = ACK
               1 = NACK
               2 = STATIC-NACK
               3 is reserved

     Mode:     0 is reserved
               1 = Unidirectional mode
               2 = Bi-directional Optimistic mode
               3 = Bi-directional Reliable mode

     Feedback options: A variable number of feedback options, see
        section 5.7.6.3. Options may appear in any order.














Bormann (ed.)                                                  [Page 73]

INTERNET-DRAFT          Robust Header Compression           Oct 03, 2000


5.7.6.3  RTP Feedback options

   An RTP Feedback option has variable length and the following general
   format

     0   1   2   3   4   5   6   7
   +---+---+---+---+---+---+---+---+
   |   Opt Type    |   Opt Len     |
   +---+---+---+---+---+---+---+---+
   /          option data          /  Opt Len octets
   +---+---+---+---+---+---+---+---+

   Sections 5.7.6.4-9 describe the currently defined RTP feedback
   options.


5.7.6.4  The CRC option

   The CRC option contains an 8-bit CRC computed over the entire
   feedback packet, including any CID fields, using the polynomial of
   section 5.9.1. For purposes of computing the CRC, the CRC fields of
   all CRC options are zero.

     0   1   2   3   4   5   6   7
   +---+---+---+---+---+---+---+---+
   |  Opt Type = 1 |  Opt Len = 1  |
   +---+---+---+---+---+---+---+---+
   |              CRC              |
   +---+---+---+---+---+---+---+---+

   When receiving a FEEDBACK packet with a CRC option, the compressor
   MUST verify the header by computing the CRC and comparing the result
   with the CRC carried in the CRC option. If the two are not identical,
   all information in the FEEDBACK packet MUST be ignored.


5.7.6.5 The REJECT option

   The REJECT option informs the compressor that the decompressor does
   not have sufficient resources to handle the flow.

     0   1   2   3   4   5   6   7
   +---+---+---+---+---+---+---+---+
   |  Opt Type = 2 |  Opt Len = 0  |
   +---+---+---+---+---+---+---+---+

   When receiving a REJECT option, the compressor stops compressing the
   packet stream, and should refrain from attempting to increase the
   number of compressed packet streams for some time. Any FEEDBACK
   packet carrying a REJECT option MUST also carry a CRC option.




Bormann (ed.)                                                  [Page 74]

INTERNET-DRAFT          Robust Header Compression           Oct 03, 2000


5.7.6.6 The SN option

   The SN option provides 8 additional bits of SN.

     0   1   2   3   4   5   6   7
   +---+---+---+---+---+---+---+---+
   |  Opt Type = 3 |  Opt Len = 1  |
   +---+---+---+---+---+---+---+---+
   |              SN               |
   +---+---+---+---+---+---+---+---+


5.7.6.7 The CLOCK option

   The CLOCK option informs the compressor of the clock resolution of
   the decompressor. This is needed to allow the compressor to estimate
   the jitter introduced by the clock of the decompressor when doing
   Timer-based compression of the RTP timestamp.

     0   1   2   3   4   5   6   7
   +---+---+---+---+---+---+---+---+
   |  Opt Type = 4 |  Opt Len = 1  |
   +---+---+---+---+---+---+---+---+
   |     clock resolution (ms)     |
   +---+---+---+---+---+---+---+---+

   The smallest clock resolution which can be indicated is 1
   millisecond. The value zero has a special meaning: it indicates that
   the decompressor cannot do Timer-based compression of the RTP
   timestamp. Any FEEDBACK packet carrying a CLOCK option SHOULD also
   carry a CRC option.


5.7.6.8  The JITTER option

   The JITTER option allows the decompressor to report the maximum
   jitter it has observed lately, using the following formula which is
   very similar to the formula for Max_Jitter BC in section 4.5.4.

   Let Observation window i contain the decompressor's best
   approximation of the TSW of the compressor (see section 4.5.4) when
   header i is received.

      Max_Jitter i_=

            max {|(T_i _ T_j) _ ((a_i _ a_j) / TIME_STRIDE)|,
                 for all headers j in Observation window i}

      Max Jitter =

            max { Max Jitter i, for a large number of recent headers i }



Bormann (ed.)                                                  [Page 75]

INTERNET-DRAFT          Robust Header Compression           Oct 03, 2000



   This information may be used by the compressor to refine the formula
   for determining k when doing Timer-based compression of the RTP
   Timestamp.

     0   1   2   3   4   5   6   7
   +---+---+---+---+---+---+---+---+
   |  Opt Type = 5 |  Opt Len = 1  |
   +---+---+---+---+---+---+---+---+
   |          Max Jitter           |
   +---+---+---+---+---+---+---+---+

   The decompressor MAY ignore the oldest observed values of Max Jitter
   i. Thus, the reported Max Jitter may decrease. Robustness will be
   reduced if the compressor uses a jitter estimate which is too small.
   Therefore, a FEEDBACK packet carrying a JITTER option SHOULD also
   carry a CRC option. Moreover, the compressor MAY ignore decreasing
   Max Jitter values.


5.7.6.9The LOSS option

   The LOSS option allows the decompressor to report the largest
   observed number of packets lost in sequence. This information MAY be
   used by the compressor to adjust the size of the reference window
   used in U and O mode.

     0   1   2   3   4   5   6   7
   +---+---+---+---+---+---+---+---+
   |  Opt Type = 6 |  Opt Len = 1  |
   +---+---+---+---+---+---+---+---+
   | longest loss event (packets)  |
   +---+---+---+---+---+---+---+---+

   The decompressor MAY choose to ignore the oldest loss events. Thus,
   the value reported may decrease. Since setting the reference window
   too small can reduce robustness, a FEEDBACK packet carrying a LOSS
   option SHOULD also carry a CRC option. The compressor MAY choose to
   ignore decreasing loss values.


5.7.6.10  Unknown option types

   If an option type unknown to the compressor is encountered,
   it must continue parsing the rest of the FEEDBACK packet, which is
   possible since the length of the option is explicit, but MUST
   otherwise ignore the unknown option.







Bormann (ed.)                                                  [Page 76]

INTERNET-DRAFT          Robust Header Compression           Oct 03, 2000


5.7.6.11  RTP feedback example

   Feedback for CID 8 indicating an ACK for SN 17 and Bi-directional
   Reliable mode can have the following format.

     0   1   2   3   4   5   6   7
   +---+---+---+---+---+---+---+---+
   | 1   1   1   0 | 0   1   1   1 |  (Assuming add-on CID format)
   +---+---+---+---+---+---+---+---+
   | 1   1   1   1   1   0 |   0   |  feedback packet type, Code=0
   +---+---+---+---+---+---+---+---+
   | 0   1 | 1   1 |  SN MSB = 0   |  AckType = ACK, Mode = Reliable
   +---+---+---+---+---+---+---+---+
   |          SN LSB=17            |
   +---+---+---+---+---+---+---+---+


   The FEEDBACK-3 format may also be used.

     0   1   2   3   4   5   6   7
   +---+---+---+---+---+---+---+---+
   | 1   1   1   0 | 0   1   1   1 |  (Assuming add-on CID format)
   +---+---+---+---+---+---+---+---+
   | 1   1   1   1   1   0 |   2   |  feedback packet type, Code=2
   +---+---+---+---+---+---+---+---+
   |             SN=17             |
   +---+---+---+---+---+---+---+---+


5.7.7  IR and IR-DYN packets

   The subheaders which are compressible are split into a STATIC part
   and a DYNAMIC part. These parts are defined in sections 5.7.6.3-*.

   The structure of a chain of subheaders is determined by each header
   having a Next Header, or Protocol, field. This field identifies the
   type of the following header. Each Static part below contains that
   field and allows parsing of the Static chain.
















Bormann (ed.)                                                  [Page 77]

INTERNET-DRAFT          Robust Header Compression           Oct 03, 2000


5.7.7.1 Basic structure of the IR packet

   This packet type communicates the static part of the context, i.e.,
   the value of the constant SN-functions. It can optionally also
   communicate the dynamic part of the context, i.e., the parameters of
   non-constant SN-functions. It can also optionally communicate the
   payload of an original packet, if any.

     0   1   2   3   4   5   6   7
    --- --- --- --- --- --- --- ---
   |         Add-CID octet         |  if for CID!=0 for small CIDs
   +---+---+---+---+---+---+---+---+
   | 1   1   1   1   1   1   0 | D |
   +---+---+---+---+---+---+---+---+
   |                               |
   /    0-2 octets of CID info     /  1-2 octets if for large CIDs
   |                               |
   +---+---+---+---+---+---+---+---+
   |            Profile            |  1 octet
   +---+---+---+---+---+---+---+---+
   |              CRC              |  1 octet
   +---+---+---+---+---+---+---+---+
   |                               |
   |         Static chain          |  variable length
   |                               |
   +---+---+---+---+---+---+---+---+
   |                               |
   |         Dynamic chain         |  present if D=1, variable length
   |                               |
    - - - - - - - - - - - - - - - -
   |                               |
   |           Payload             |  variable length
   |                               |
    - - - - - - - - - - - - - - - -

     D:   D=1 indicates that the dynamic chain is present.

     Profile:  Indicates transport/application of this stream.

          CRC: 8-bit CRC, computed according to section 5.9.1.

     Static chain: A chain of static subheader information.

     Dynamic chain: A chain of dynamic subheader information. What
     dynamic information is present is inferred from the Static chain.

     Payload: payload of corresponding original packet, if any. Presence
     inferred from packet size.






Bormann (ed.)                                                  [Page 78]

INTERNET-DRAFT          Robust Header Compression           Oct 03, 2000


5.7.7.2. Basic structure of the IR-DYN packet

   This packet type communicates the dynamic part of the context, i.e.,
   the parameters of non-constant SN-functions.

     0   1   2   3   4   5   6   7
    --- --- --- --- --- --- --- ---
   |         Add-CID octet         |  if for CID!=0 for small CIDs
   +---+---+---+---+---+---+---+---+
   | 1   1   1   1   1   1   1   0 |
   +---+---+---+---+---+---+---+---+
   |                               |
   /     0-2 octets of CID info    /  1-2 octets if for large CIDs
   |                               |
   +---+---+---+---+---+---+---+---+
   |            Profile            |  1 octet
   +---+---+---+---+---+---+---+---+
   |              CRC              |  1 octet
   +---+---+---+---+---+---+---+---+
   |                               |
   /         Dynamic chain         /  variable length
   |                               |
   +---+---+---+---+---+---+---+---+
   |                               |
   /           Payload             /  variable length
   |                               |
    - - - - - - - - - - - - - - - -

     Profile:  Indicates transport/application of this stream.

     CRC: 8-bit checksum covering original header, computed according to
     section 5.9.1.

     Dynamic chain: A chain of dynamic subheader information. What
     dynamic information is present is inferred from the Static chain of
     the context.

     Payload: payload of corresponding original packet, if any.
              (Presence of payload is inferred from length of packet.)


   NOTE: The static and dynamic chains of IR or IR-DYN packets for
   profile 0 MUST end with static and dynamic parts for an RTP header.
   If not, the packet MUST be discarded and the context must not be
   updated.

   NOTE: The static or dynamic chains of IR or IR-DYN packets for
   profile 1 MUST end with static and dynamic parts for a UDP header.
   If not, the packet MUST be discarded and the packet must not be
   updated.




Bormann (ed.)                                                  [Page 79]

INTERNET-DRAFT          Robust Header Compression           Oct 03, 2000


5.7.7.3.  Initialization of IPv6 Header [IPv6]

      Static part:

   +---+---+---+---+---+---+---+---+
   |  Version = 6  |Flow Label(msb)|   1 octet
   +---+---+---+---+---+---+---+---+
   /        Flow Label (lsb)       /   2 octets
   +---+---+---+---+---+---+---+---+
   |         Next Header           |   1 octet
   +---+---+---+---+---+---+---+---+
   |         Hop Limit             |   1 octet
   +---+---+---+---+---+---+---+---+
   /         Source Address        /   16 octets
   +---+---+---+---+---+---+---+---+
   /      Destination Address      /   16 octets
   +---+---+---+---+---+---+---+---+

      Dynamic part:

   +---+---+---+---+---+---+---+---+
   |         Traffic Class         |   1 octet
   +---+---+---+---+---+---+---+---+

      Eliminated:

         Payload Length


   CRC-DYNAMIC: Payload Length field (octets 5-6).

   CRC-STATIC: All other fields (octets 1-4, 7-40).






















Bormann (ed.)                                                  [Page 80]

INTERNET-DRAFT          Robust Header Compression           Oct 03, 2000


5.7.7.4. Initialization of IPv4 Header [IPv4, section 3.1].

      Static part:

        Version, Flags, Time to Live, Protocol, Source Address,
        Destination Address.

        +---+---+---+---+---+---+---+---+
        |  Version = 4  | 0 | DF|   0   |
        +---+---+---+---+---+---+---+---+
        |         Time to Live          |
        +---+---+---+---+---+---+---+---+
        |           Protocol            |
        +---+---+---+---+---+---+---+---+
        /        Source Address         /   4 octets
        +---+---+---+---+---+---+---+---+
        /      Destination Address      /   4 octets
        +---+---+---+---+---+---+---+---+

      Dynamic part:

         Type of Service, Identification

        +---+---+---+---+---+---+---+---+
        |       Type of Service         |
        +---+---+---+---+---+---+---+---+
        /        Identification         /   2 octets
        +---+---+---+---+---+---+---+---+

      Eliminated:

         IHL               (must be 5)
         Total Length      (inferred in decompressed packets)
         MF flag           (More Fragments flag, must be 0)
         Fragment Offset   (must be 0)
         Header Checksum   (inferred in decompressed packets)
         Options, Padding  (must not be present)


     CRC-DYNAMIC: Total Length, Identification, Header Checksum
                    (octets 3-4, 5-6, 11-12).

     CRC-STATIC: All other fields (octets 1-2, 7-10, 13-20).











Bormann (ed.)                                                  [Page 81]

INTERNET-DRAFT          Robust Header Compression           Oct 03, 2000


5.7.7.5. Initialization of UDP Header [RFC-768].

    Static part:

        +---+---+---+---+---+---+---+---+
        /          Source Port          /   2 octets
        +---+---+---+---+---+---+---+---+
        /       Destination Port        /   2 octets
        +---+---+---+---+---+---+---+---+

    Dynamic part:

        +---+---+---+---+---+---+---+---+
        /           Checksum            /   2 octets
        +---+---+---+---+---+---+---+---+

    Eliminated:

         Length

   The Length field of the UDP header MUST match the Length field(s) of
   preceding subheaders, i.e., there must not be any padding after the
   UDP payload that is covered by the IP Length.


   CRC-DYNAMIC: Length field, Checksum (octets 5-8).

   CRC-STATIC: All other fields (octets 1-4).


5.7.7.6. Initialization of RTP Header [RTP].

      Static part:

         P, X, CC, PT, SSRC, CSRC identifiers.

           0   1   2   3   4   5   6   7
         +---+---+---+---+---+---+---+---+
         |  V=2  | P | X |      CC       |
         +---+---+---+---+---+---+---+---+
         | M |            PT             |
         +---+---+---+---+---+---+---+---+
         /             SSRC              /   4 octets
         +---+---+---+---+---+---+---+---+
         :                               :
         :            CSRC ids           :   multiple of 4 octets
         :                               :
         +---+---+---+---+---+---+---+---+






Bormann (ed.)                                                  [Page 82]

INTERNET-DRAFT          Robust Header Compression           Oct 03, 2000


      Dynamic part:

         M, sequence number, timestamp, timestamp delta.

           0   1   2   3   4   5   6   7
         +---+---+---+---+---+---+---+---+
         /      RTP sequence number      /  2 octets
         +---+---+---+---+---+---+---+---+
         |   RTP timestamp (absolute)    |  4 octets
         +---+---+---+---+---+---+---+---+
         | M |      TS-Stride (msb)      |
         +---+---+---+---+---+---+---+---+
         |         TS-Stride (lsb)       |
         +---+---+---+---+---+---+---+---+


      Eliminated:

         Nothing.


      CRC-DYNAMIC: Octet containing M-bit, sequence number field,
                   timestamp (octets 2-8).

      CRC-STATIC: All other fields (octets 1, 9-12, CSRC list).


5.7.7.7.  Minimal Encapsulation header [RFC-2004, section 3.1]

   STATIC Part:

         Entire header.

        0                   1                   2                   3
        0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |   Protocol    |S|  reserved   |        Header Checksum        |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |                 Original Destination Address                  |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       :            (if present) Original Source Address               :
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

      DYNAMIC Part:

         Empty.

      Eliminated:

         Nothing.




Bormann (ed.)                                                  [Page 83]

INTERNET-DRAFT          Robust Header Compression           Oct 03, 2000




   CRC-DYNAMIC: Empty.

   CRC-STATIC: Entire header.


5.8 List-Based Compression

   For CSRC lists in RTP packet, and extension header chains in IP
   headers, the information to be compressed can be described as an
   ordered list, which is largely constant between packets, but to which
   additions and deletions are made occasionally during the life-time of
   the packet stream.  This section describes the compression scheme for
   such information

   [[Editor's note: This section still is under active discussion in the
   mailing list.  A somewhat simplified version has emerged and will be
   integrated in the next revision.]]

5.8.1.  CSRC compression

   The Contributing Source (CSRC) List in a RTP header contains the
   Synchronization Source (SSRC) identifiers of the contributing sources
   for the payload in the current packet.

   A CSRC list contains at most 15 identifiers, due to the 4-bit size of
   CSRC Count (CC) field in RTP header.  Each 32-bit identifier is
   chosen randomly by the original synchronization source so that it is
   globally unique within an RTP session.

   The compression scheme introduced here will utilize the facts
   mentioned above. To maintain transparency, the order of identifiers
   is preserved during compression. In other words, the CSRC list is
   really compressed as a list, not as a set.

5.8.1.1.  Transformation Classification for CSRC List

   A given CSRC list (curr_list) can be classified as belonging to
   one of the following transformation cases when compared with a
   reference CSRC list (ref_list).

     -  Transformation Case A: curr_list can be derived from ref_list
        just by adding some CSRCs; the relative positions of the CSRCs
        common to curr_list and ref_list are the same.

     -  Transformation Case B: curr_list can be derived from ref_list
        just by deleting some CSRCs; the relative positions of the CSRCs
        common to curr_list and ref_list are the same





Bormann (ed.)                                                  [Page 84]

INTERNET-DRAFT          Robust Header Compression           Oct 03, 2000


     -  Transformation Case C: All the other transformation cases that
        are not covered by transformation case A and B.

5.8.1.2.  Encoding Schemes

   To address aforementioned 3 transformation cases, four encoding
   schemes are used. Each scheme addresses one or more
   transformation cases mentioned above. The four encoding schemes
   and the transformation cases they address is listed in
   the following table.

   +----------------------------+--------------------+
   | Encoding Scheme            | Transformaton Case |
   +----------------------------+--------------------+
   | Insertion Only             |         A          |
   +----------------------------+--------------------+
   | Removal Only               |         B          |
   +----------------------------+--------------------+
   | Generic                    |  mixture of A,B,C  |
   +----------------------------+--------------------+
   | Uncompressed               |  mixture of A,B,C  |
   +----------------------------+--------------------+

      - In the insertion only scheme, compared with CSRC list in the
        ref_list, the newly added CSRCs in the curr_list are sent along
        with the positions of the CSRCs in the ref_list, before which
        the new CSRCs will be inserted.

      - In the removal only scheme, the positions of the CSRCs, which
        are in the ref_list, but not in the curr_list, are sent.

      - In the generic scheme, for a given CSRC in the curr_list, it is
        sent compressed only with a position field if the CSRC is also
        in the ref_list, or it is sent uncompressed.

   All the aforementioned 3 schemes generate compressed format of the
   CSRC list. The CSRC list can also be sent in an uncompressed format.

5.8.1.3. Format of compressed CSRC list

   The format of the compressed CSRC list using the four schemes is as
   follows.

5.8.1.3.1 Insertion Only Scheme

5.8.1.3.1.1 R-mode

        2      6 or 14       8 or 16
   +---------+--------+--------------------+
   | ET = 00 | ref_id | insertion bit mask |
   +---------+--------+--------------------+



Bormann (ed.)                                                  [Page 85]

INTERNET-DRAFT          Robust Header Compression           Oct 03, 2000



   +--------+----+--------+
   | CSRC 1 |....| CSRC m |
   +--------+----+--------+

   * ref_id - the LSB of the RTP sequence number of the ref_list

   6 bit: "0" + 5-bit LSB of RTP sequence number
   14 bit: "1" + 13-bit LSB of RTP sequence number

   * insertion bit mask: the bit mask indicating the position of the
     following CSRCs to be inserted into the ref_list in order to
     reconstruct the curr_list.

     The length of insertion bit mask can be 8 bits or 16 bits.

     8 bits:  "0" + 7-bit insertion bit mask
     16 bits: "1" + 15-bit insertion bit mask

     To construct the insertion bit mask and the following inserted
     CSRC list, the following steps are taken.

     ** A list of '0' and an empty inserted CSRC list are generated as
       the starting point. The number of '0's in the '0' list equals the
       number of CSRCs in the ref_list. The i-th '0' in the '0' list
       corresponds to the i-th CSRC in the ref_list.

     ** Comparing the curr_list with the ref_list, if a new CSRC is
       inserted between the i-th item and the (i+1)-th item in the
       ref_list, a '1' is inserted between the i-th '0' and (i+1)-th '0'
       in the original '0' list. The new CSRC should be added to the end
       of inserted CSRC list. This procedure is repeated until all the m
       new CSRCs have been processed. If the length of new insertion bit
       mask is less than 7 bits or 15 bits, additional '0' should be
       added at the end until it reaches 7 bits or 15 bits.

     When the decompressor receives the insertion bit mask, it scans
     from left to right. When a '0' is observed, the decompressor copies
     the corresponding CSRC in the ref_list into the curr_list; when a
     '1' is observed, the decompressor adds the correspondent CSRC into
     the curr_list.

   * CSRC i (i=1..m): the CSRCs to be inserted; assuming that the
   number of CSRC to be inserted is m.

5.8.1.3.1.2 UO-modes

        2       6       8         8          8 or 16
   +---------+------+--------+--------+--------------------+
   | ET = 00 | resv | Gen_id | ref_id | insertion bit mask |
   +---------+------+--------+--------+--------------------+



Bormann (ed.)                                                  [Page 86]

INTERNET-DRAFT          Robust Header Compression           Oct 03, 2000



   +--------+----+--------+
   | CSRC 1 |....| CSRC m |
   +--------+----+--------+

   * resv: reserved

   * Gen_id: is used to identify a set of packets that belongs to the
   same generation

   * ref_id: the Gen_id carried in the ref_list

   * insertion bit mask and CSRC i : the same as defined
   for R-mode

5.8.1.3.2 Removal Only Scheme

5.8.1.3.2.1 R-mode

        2      6 or 14       8 or 16
   +---------+--------+------------------+
   | ET = 01 | ref_id | removal bit mask |
   +---------+--------+------------------+

   * ref_id: the same as defined in section 3.1.1.

   * removal bit mask: the bit mask indicating the CSRC in the
   ref_list to be removed in order to reconstruct the curr_list.
   A '1' in the i-th bit in the removal bit mask means
   that the i-th CSRC in the ref_list is not in the curr_list,
   while a '0' means it is still present in the curr_list.

   The length of insertion bit mask can be 8 bits or 16 bits.

   8 bits:  "0" + 7-bit insertion bit mask
   16 bits: "1" + 15-bit insertion bit mask

   Which format to be used depends on the number of CSRCs
   in the ref_list. If it is less than 8, then 8-bit removal
   bit mask can be used; otherwise the 16-bit format is required.

5.8.1.3.2.2 UO-mode

        2        6      8         8          8 or 16
   +---------+------+--------+--------+------------------+
   | ET = 01 | resv | gen_id | ref_id | removal bit mask |
   +---------+------+--------+--------+------------------+

   * Gen_id, resv and ref_id: the same as defined in section 3.1.2.

   * removal bit mask: the same as defined for R mode



Bormann (ed.)                                                  [Page 87]

INTERNET-DRAFT          Robust Header Compression           Oct 03, 2000



5.8.1.3.3 Generic Scheme

5.8.1.3.3.1 R-mode

        2      6 or 14       4
   +---------+--------+------------+--------------------------+
   | ET = 10 | ref_id | gcount = m | g_CSRC 1 |....| g_CSRC m |
   +---------+--------+------------+--------------------------+

   +:::::::::+
   | padding |
   +:::::::::+

   * ref_id: the same as defined in section 3.1.1.

   * gcount: the number of following g_CSRC field; the length
   is 4 bits.

   * g_CSRC i (i=1..m): corresponds to the i-th CSRC in the
   curr_list. The order of g_CSRC represents the order of
   CSRCs in the curr_list. Two types of g_CSRC is defined.

   ** g_CSRC type 0 is used to compress a CSRC that is in both
   ref_list and curr_list.

   ** g_CSRC type 1 is used to carry a CSRC that is in the
   curr_list but not in the ref_list.

   The format of g_CSRC is defined as follows.

                       1    ceiling(log2(k))
                  +--------+-----+
   g_CSRC type 0: | GC = 0 | pos |
                  +--------+-----+

   - pos: the position of a CSRC in the ref_list; the length
    is ceiling(log2(k)) where k is the number of CSRC in the
    ref_list. Since the value of k is known to both the
    compressor and decompressor, the length of the pos field
    doesn't need to be carried in the compressed list

                       1
                  +--------+------+
   g_CSRC type 1: | GC = 1 | CSRC |
                  +--------+------+

   * padding: padding bits may be required to maintain the byte
   alignment





Bormann (ed.)                                                  [Page 88]

INTERNET-DRAFT          Robust Header Compression           Oct 03, 2000



5.8.1.3.3.2 UO-mode

       8          2        8         4
   +--------+---------+--------+------------+--------------------------+
   | gen_id | ET = 10 | ref_id | gcount = m | g_CSRC 1 |....| g_CSRC m |
   +--------+---------+--------+------------+--------------------------+

   +:::::::::+
   | padding |
   +:::::::::+

   * Gen_id and ref_id: the same as defined in section 3.2.1.2.

   * gcount, g_CSRC and padding: the same as defined for R mode

   3.4 Uncompressed (common to R-mode and UO-modes)

        2        1    1      8          4
   +---------+------+---+::::::::+------------+----------------------+
   | ET = 11 | resv | G | gen_id | ccount = m | CSRC 1 |....| CSRC m |
   +---------+------+---+::::::::+------------+----------------------+

   * resv: reserved

   * G: indicating the presence of gen_id field

   * Gen_id: the same as defined in section 3.1.2.

   - In R-mode, gen_id is not present.

   - During the transition from any mode to U-mode or O-mode, gen_id
   should not be sent. The list without gen_id should not be used
   as a reference to compress and decompress a CSRC list.

   - In UO-modes, gen_id is present if it may be used as a reference
   to compress or decompress the subsequent CSRC list.

   * ccount: the number of CSRCs in the CSRC list

   * CSRC i (i=1..m): the original CSRC list in the curr_list

5.8.2.  Header Compression for IPv6 Extension Headers

   The IPv6 extension headers are encoded as a list of items. Each item
   is one of the extension headers. The length of each extension header
   may vary from each other. When more than one extension header is used
   in the same packet, the order of these extension headers is
   recommended in RFC 2460, but not mandatory. Thus, although it is
   unlikely to happen, the order of the extension headers may vary
   during the same session. In addition, one or more extension header



Bormann (ed.)                                                  [Page 89]

INTERNET-DRAFT          Robust Header Compression           Oct 03, 2000


   may be added or removed during the session and the content of each
   extension header may change. Therefore, the IPv6 extension headers
   are classified as a list of items and the item list compression
   mechanism can be applied.

   The compression of IPv6 extension headers at the list level is
   similar to that of the CSRC entries (section 5.8.1). The compressed
   value of the extension header list is referred to as a compressed
   extension header list. The compression of IPv6 extension headers at
   the item level, i.e., the compression scheme used for each type of
   extension header, is defined in this subsection. The reference
   extension header used to compress a given extension header is the
   extension header in the reference list that has the same type. The
   compressed value of an extension header is referred to as a
   compressed extension header.

5.8.2.1. Terminology

      * extension header list: the list of IPv6 extension headers
      * compressed extension header: the compressed value of an IPv6
        extension header
      * compressed extension header list: the list of compressed
        extension headers
      * reference extension header list: the extension header list
        which is used as the reference to compress an extension header
        list
      * reference extension header: an extension header in the
        reference list that has the same type and is used as the
        reference to compress a given extension header

5.8.2.2. Transformation Classification and Encoding Schemes

5.8.2.2.1 Transformation Classification

   A given extension header list (curr_list) can be
   classified as belonging to one of the following transformation
   cases when compared with a reference extension header list
   (ref_list).

      - Transformation Case A: curr_list can be derived from ref_list
        just by adding (inserting) some extension headers; the relative
        positions of the extension headers common to curr_list and
        ref_list are the same.

      - Transformation Case B: curr_list can be derived from ref_list
        just by deleting some extension headers; the relative positions
        of the extension headers common to curr_list and ref_list are
        the same






Bormann (ed.)                                                  [Page 90]

INTERNET-DRAFT          Robust Header Compression           Oct 03, 2000


      - Transformation Case C: curr_list can be derived from ref_list
        just by modifying the content of some extension headers; the
        relative positions of the extension headers remain the same.

      - Transformation Case D: All the other transformation cases that
        are not covered by transformation case A, B and C.

5.8.2.2.2 Encoding Schemes

   To address aforementioned 4 transformation cases, four encoding
   schemes are used. Each scheme addresses one or more
   transformation cases mentioned above. The four encoding schemes
   and the transformation cases they address is listed in
   the following table.

   +---------------------+----------+--------------------+
   | Encoding Scheme     | ET Value | Transformaton Case |
   +---------------------+----------+--------------------+
   | Insertion Only      |    00    |         A          |
   +---------------------+----------+--------------------+
   | Removal Only        |    01    |         B          |
   +---------------------+----------+--------------------+
   | Content Change Only |    10    |         C          |
   +---------------------+----------+--------------------+
   | Uncompressed        |    11    | mixture of A,B,C,D |
   +---------------------+----------+--------------------+

      * In the insertion only scheme, compared with ref_list, the
        uncompressed value of the newly added extension headers in the
        curr_list are sent along with the positions of the extension
        headers in the ref_list, before which the new extension headers
        will be inserted.

      * In the removal only scheme, the positions of the extension
        headers, which are in the ref_list, but not in the curr_list,
        are sent.

      * In the change only scheme, the positions of the extension
        header whose content is changed as well as its uncompressed or
        compressed value are sent. (Note that in the current stage,
        only uncompressed extension header is used. )

   The aforementioned 3 schemes generate compressed format of
   the extension header list. The curr_list can also be sent
   in an uncompressed format.

5.8.2.2.3 Special Handling

5.8.2.2.3.1 Special Handling of AH





Bormann (ed.)                                                  [Page 91]

INTERNET-DRAFT          Robust Header Compression           Oct 03, 2000


   The sequence number field in the AH contains a monotonically
   increasing counter value for a security association. Therefore, when
   comparing curr_list with ref_list, if the sequence number in AH
   changes and SPI field doesn't change, the AH is not necessary to be
   classified as changed.

   If the sequence number in the AH linearly increases as RTP sequence
   number increases, it doesn't need to be sent. The decompressor
   applies linear extrapolation to reconstruct the sequence number in
   AH.  Otherwise, a compressed sequence number should be included in
   the IPv6 Extension Headers compression element field in PT2 extension
   "11" header.

   The authentication data field in AH changes from packet to packet and
   should be sent in every packet. If the uncompressed AH is sent, the
   authentication data field is sent inside the uncompressed AH;
   otherwise,
   it is sent after the compressed IP/UDP/RTP and IPv6 extension headers
   and before the payload.

5.8.2.2.3.2 Encapsulating Security Payload Header

   If Encapsulating Security Payload Header (ESP) is used, the UDP and
   RTP headers are both encrypted and cannot be compressed. In this
   case, special compressed packet format needs to be defined in ROHC.

   In ESP, the only fields that can be compressed are the SPI and the
   sequence number.

     *  In the case that the SPI field changes, the uncompressed ESP is
        sent.

     *  In the case that no change happens to the SPI field, the ESP is
        not considered as changed.

   The sequence number in ESP has the same behavior as the same field
   in AH. If it linearly increases, it doesn't need to be sent.
   Otherwise, a compressed sequence number should be sent in the IPv6
   Extension Headers compression element field in PT2 extension "11"
   header.

5.8.2.2.3.3 Special Handling of Next Header Field

   The next header field in an extension header changes whenever the
   type of the immediately following header changes, e.g., a new
   extension header is inserted after it, the immediate subsequent
   extension header is removed from the list, or the order of several
   extension headers is changed. Thus, in particular, it may not be
   uncommon that for a given extension header, only the next header
   field changes but the remaining fields don't change. Therefore,
   the next header field in each extension header needs to be treated



Bormann (ed.)                                                  [Page 92]

INTERNET-DRAFT          Robust Header Compression           Oct 03, 2000


   in a special way.

   In the case that only the next header field changes, the extension
   header should be considered as unchanged. The special treatment of
   the change of the next header field is defined as follows.

   * In the case that a subsequent extension header is removed from the
   list, the new value of the next header field can be obtained from the
   reference extension header list. For example, assume that the
   reference extension header list (ref_list) consists of extension
   header A, B and C (ref_ext_hdr A, B, C), and the current extension
   header list (curr_list) only consists of extension headers A and C
   (curr_ext_hdr A, C). The order and value of the next header field
   of these extension headers are as follows.

   ref_list:
   +--------+-----+    +--------+-----+    +--------+-----+
   | type B |     |    | type C |     |    | type D |     |
   +--------+     |    +--------+     |    +--------+     |
   |              |    |              |    |              |
   +--------------+    +--------------+    +--------------+
   ref_ext_hdr A        ref_ext_hdr B       ref_ext_hdr C

   curr_list:
   +--------+-----+    +--------+-----+
   | type C |     |    | type D |     |
   +--------+     |    +--------+     |
   |              |    |              |
   +--------------+    +--------------+
   curr_ext_hdr A      curr_ext_hdr C

   Comparing the curr_ext_hdr A in curr_list and the ref_ext_hdr A
   in ref_list, the value of next header field is changed from
   "type B" to "type C" because of removal of extension header B.
   The new value of the next header field in curr_ext_hdr A, i.e.,
   "type C" doesn't need to be sent to the decompressor, because
   when the decompressor detects (by observing the list level encoding)
   that the immediate following extension header B is removed from
   the list, it retrieves the next header field in ref_ext_hdr B and
   use it to replace the next header field in the curr_ext_hdr A.

   * In the case that a new extension header is inserted after an
   existing extension header, the next header field in the new extension
   header carries the type of itself, instead of the type of extension
   header that follows. For example, assume that the reference extension
   header list (ref_list) consists of extension header A and C
   (ref_ext_hdr A, C), and the current extension header list (curr_list)
   consists of extension header A, B and C (curr_ext_hdr A, B, C). The
   order and the value of the next header field of these extension
   headers are as follows.




Bormann (ed.)                                                  [Page 93]

INTERNET-DRAFT          Robust Header Compression           Oct 03, 2000


   ref_list:
   +--------+-----+    +--------+-----+
   | type C |     |    | type D |     |
   +--------+     |    +--------+     |
   |              |    |              |
   +--------------+    +--------------+
   ref_ext_hdr A        ref_ext_hdr C

   curr_list:
   +--------+-----+    +--------+-----+    +--------+-----+
   | type B |     |    | type C |     |    | type D |     |
   +--------+     |    +--------+     |    +--------+     |
   |              |    |              |    |              |
   +--------------+    +--------------+    +--------------+
   curr_ext_hdr A      curr_ext_hdr B      curr_ext_hdr C

   Comparing the curr_list and the ref_list, the value of the next
   header field in extension header A is changed from "type C" to "type
   B".

   In the compressed extension header list, the uncompressed
   curr_ext_hdr B is carried in the uncompressed data field in c_item
   or u_item depending on the list encoding scheme used.  However,
   instead of carrying the type of the next header (type C)
   in the next header field, the type of curr_ext_hdr B (type B) should
   be carried. When the decompressor detects (by observing the list
   level encoding) that a new extension is inserted after curr_ext_hdr
   A, it will replace the old next header field in ref_ext_hdr A with
   the type of the inserted extension header, i.e., type B, which is
   carried in the next header field in the c_item or u_item for
   extension header B. At the same time, the decompressor also replace
   the next header field in curr_ext_hdr B with the old value of the
   next header field in ref_ext_hdr A, i.e., type C.

5.8.2.3. Packet Format

5.8.2.3.1. Format in extension "11" header

       1      1      1    5
   +------+------+------+-------+
   | ASeq | ESeq | CExt |  resv |
   +------+------+------+-------+

   8 or 32 bits                8 or 32 bits
   +::::::::::::::::::::::::::+:::::::::::::::::::::::::::+
   | compressed AH Seq Number | compressed ESP Seq Number |
   +::::::::::::::::::::::::::+:::::::::::::::::::::::::::+

   variable length
   +:::::::::::::::::::::::::::::::+
   | compressed IPv6 extension hdr |



Bormann (ed.)                                                  [Page 94]

INTERNET-DRAFT          Robust Header Compression           Oct 03, 2000


   +:::::::::::::::::::::::::::::::+

   * ASeq: presence of compressed AH Seq Number
   * ESeq: presence of compressed ESP Seq Number
   * CExt: presence of compressed IPv6 extension hdr

   * compressed AH Seq Number and compressed ESP Seq Number formats:

   "0"  + 7-bit LSB
   "11" + 30-bit LSB

5.8.2.3.2 Format of compressed IPv6 extension header

5.8.2.3.2.1 Insertion Only Scheme

5.8.2.3.2.1.1 R-mode

        2     6 or 14           8
   +---------+--------+--------------------+
   | ET = 00 | ref_id | insertion bit mask |
   +---------+--------+--------------------+

   +----------+----+----------+
   | u_ehdr 1 |....| u_ehdr m |
   +----------+----+----------+

   * ref_id - the LSB of the RTP sequence number of the ref_list

   6 bit: "0" + 5-bit LSB
   14 bit: "1" + 13-bit LSB

   * u_ehdr i (i=1..m) : the uncompressed value of the new
   extension header in the curr_list; m is the number of
   new extension headers to be added.

   * insertion bit mask: the bit mask indicating the position
   of the following u_ehdrs to be inserted into the ref_list in
   order to reconstruct the curr_list.

   The length of insertion bit mask is 8 bits.

   To construct the insertion bit mask and the following inserted
   u_ehdr list, the following steps are taken.
   ** A list of '0' and an empty inserted u_ehdr list are generated
   as the starting point. The number of '0's in the '0' list equals
   the number of extension headers in the ref_list. The i-th
   '0' in the '0' list corresponds to the i-th extension header
   in the ref_list.
   ** Comparing the curr_list with the ref_list, if a new extension
   header is inserted between the i-th item and the (i+1)-th item
   in the ref_list, a '1' is inserted between the i-th '0' and



Bormann (ed.)                                                  [Page 95]

INTERNET-DRAFT          Robust Header Compression           Oct 03, 2000


   (i+1)-th '0' in the original '0' list. The new extension header
   should be added to the end of inserted CSRC list. This procedure
   is repeated until all the m new extension headers have been
   processed. If the length of new insertion bit mask is less
   than 7 bits, additional '0' should be added at the
   end until it reaches 7 bits.

   When the decompressor receives the insertion bit mask, it scans
   from left to right. When a '0' is observed, the decompressor
   copies the corresponding extension header in the ref_list into
   the curr_list; when a '1' is observed, the decompressor adds the
   correspondent u_ehdr into the curr_list.


   3.2.1.2 UO-modes

        2       6        8       8              8
   +---------+------+--------+--------+--------------------+
   | ET = 00 | resv | Gen_id | ref_id | insertion bit mask |
   +---------+------+--------+--------+--------------------+

   +----------+----+----------+
   | u_ehdr 1 |....| u_ehdr m |
   +----------+----+----------+

   * resv: reserved

   * Gen_id: is used to identify a set of packets that belongs to the
   same
   generation

   * ref_id: the Gen_id carried in the ref_list

   * insertion bit mask and u_ehdr i: the same as defined for R-mode

5.8.2.3.2.2 Removal Only Scheme

5.8.2.3.2.2.1 R-mode

        2      6 or 14         8
   +---------+--------+------------------+
   | ET = 01 | ref_id | removal bit mask |
   +---------+--------+------------------+

   * ref_id: the same as defined in section 3.2.1.1.

   * removal bit mask: the bit mask indicating the extension
   header in the ref_list to be removed in order to reconstruct
   the curr_list. A '1' in the i-th bit in the removal bit mask means
   that the i-th extension header in the ref_list is not in the
   curr_list, while a '0' means it is still present in the curr_list.



Bormann (ed.)                                                  [Page 96]

INTERNET-DRAFT          Robust Header Compression           Oct 03, 2000



   The length of insertion bit mask can be 8 bits.

   3.2.2.2 UO-mode

        2        6       8        8            8
   +---------+------+--------+--------+------------------+
   | ET = 01 | resv | gen_id | ref_id | removal bit mask |
   +---------+------+--------+--------+------------------+

   * Gen_id, resv and ref_id: the same as defined in section 3.2.1.2.

   * removal bit mask: the same as defined for R mode

5.8.2.3.2.3 Content Change Only Scheme

5.8.2.3.2.3.1 R-mode

        2     6 or 14           8
   +---------+--------+-----------------+
   | ET = 10 | ref_id | change bit mask |
   +---------+--------+-----------------+

   +-----------+----+-----------+
   | uc_ehdr 1 |....| uc_ehdr m |
   +-----------+----+-----------+

   * ref_id: the same as defined in section 2.3.1.1

   * change bit mask: a bit mask indicating the postion of the
   extension header that is changed. A '1' in the i-th bit in the
   change bit mask means that the i-th extension header in the
   ref_list is not the same as the i-th extension in the curr_list,
   while a '0' means they are the same.

   * uc_ehdr: corresponds to the extension header whose content
   is changed when comparing it with the extension header at
   the same position in the ref_list. Their positions in
   curr_list is indicated in the change bit mask field.

   uc_ehdr:
       1
   +-------+-------------------+
   | C = 0 | uncompressed ehdr |
   +-------+-------------------+

   +-------+-----------------+
   | C = 1 | compressed ehdr |
   +-------+-----------------+

   - uncompressed ehdr: uncompressed extension header



Bormann (ed.)                                                  [Page 97]

INTERNET-DRAFT          Robust Header Compression           Oct 03, 2000


   - compressed ehdr: compressed extension header using the
   extension header at the same position in ref_list as the
   reference. The compression mechanisms for different types
   of extension headers are different from each other and FFS.

5.8.2.3.2.3.2 UO-mode

        2        6       8        8           8
   +---------+------+--------+--------+-----------------+
   | ET = 00 | resv | gen_id | ref_id | change bit mask |
   +---------+------+--------+--------+-----------------+

   +-----------+----+-----------+
   | uc_ehdr 1 |....| uc_ehdr m |
   +-----------+----+-----------+

   * Gen_id, resv, ref_id: the same as defined in section 3.2.1.2.

   * change bit mask and uc_ehdr i: the same as defined for R mode

5.8.2.3.2.4 Uncompressed Scheme (common to R-mode and UO-modes)

        2        5    1     8
   +---------+------+---+::::::::+------------------------------------+
   | ET = 11 | resv | G | Gen_id | uncompressed IPv6 Extension Header |
   +---------+------+---+::::::::+------------------------------------+

   * resv: reserved

   * G: indicating the presence of Gen_id

   * Gen_id: the same as defined in section 3.2.1.2.

   - In R-mode, gen_id is not present.

   - During the transition from any mode to U-mode or O-mode, gen_id
   should not be sent. The list without gen_id should not be used
   as a reference to compress and decompress an extension header
   list.

   - In UO-modes, gen_id is present if it may be used as a reference
   to compress or decompress the subsequent extension header list.












Bormann (ed.)                                                  [Page 98]

INTERNET-DRAFT          Robust Header Compression           Oct 03, 2000


5.9.  Header compression CRCs, coverage and polynomials

   This chapter describes how to calculate the CRCs used in packet
   headers defined in this document.


5.9.1.  IR & IR-DYN packet CRCs

   The CRC in the IR and IR-DYN packet is calculated over the entire IR
   or IR-DYN packet, excluding Payload and including CID. For purposes
   of computing the CRC, the CRC field in the header is set to zero.

   The initial content of the CRC register be preset to all 1's.

   The CRC polynomial to be used is:

     C(x) = 1 + x + x^2 + x^8


5.9.2.  CRCs in compressed packets

   The CRC in compressed headers is calculated over all octets of the
   entire original header, before compression, in the following manner.

   The octets of the header are classified as either CRC-STATIC or CRC-
   DYNAMIC, and the CRC is calculated over:

   1) the concatenated CRC-STATIC octets of the original header, placed
      in the same order as they appear in the original header, followed
      by

   2) the concatenated CRC-DYNAMIC octets of the original header, placed
      in the same order as they appear in the original header.

   The intent is that the state of the CRC computation after 1) will be
   saved. As long as the CRC-STATIC octets do not change, the CRC
   calculation will then only need to process the CRC-DYNAMIC octets.

   For a typical RTP/UDP/IPv4 header, 25 octets are CRC-STATIC and 15
   are CRC-DYNAMIC. For a typical RTP/UDP/IPv6 header, 49 octets are
   CRC-STATIC and 11 are CRC-DYNAMIC. This technique will thus reduce
   the computational complexity of the CRC calculation by roughly 60%
   for RTP/UDP/IPv4 and by roughly 80% for RTP/UDP/IPv6.

   Note: whenever the CRC-STATIC fields change, the new saved CRC state
   after 1) is compared with the old state. If the states are identical,
   the CRC cannot catch the error that the decompressor has not updated
   the static context. The compressor should then require an ACK in O
   mode and send the information for a longer time in U mode. Optimistic
   transition from IR or FO state should not be attempted in this case.




Bormann (ed.)                                                  [Page 99]

INTERNET-DRAFT          Robust Header Compression           Oct 03, 2000


   The initial content of the CRC register is preset to all 1's.

   The polynomial to be used for the 3 bit CRC is:

     C(x) = 1 + x + x^3

   The polynomial to be used for the 7 bit CRC is:

     C(x) = 1 + x + x^2 + x^3 + x^6 + x^7

   The CRC in compressed packets is calculated over the entire original
   header, before compression.


5.10. ROHC UDP _ non-RTP UDP/IP compression (Profile 1)

   UDP/IP headers do not have a sequence number which is as well-behaved
   as the RTP sequence number. Therefore the compressed packet formats
   for RTP are not appropriate, and neither are the feedback formats.

   For UDP/IPv4, there is an IP-ID field which may be echoed in feedback
   information, but when no IPv4 header is present feedback
   identification becomes problematic. A context generation number is
   used for this purpose in profile 1.


5.10.1 Initialization

   The static context for UDP/IP streams can be initialized in either of
   two ways;

   1) By using an IR packet (section 7.7.1), where the profile is one
      (1) and the static chain ends with the static part of an UDP
      packet.

   2) reusing an existing context, where the existing static chain
      contains the static part of a UDP packet, e.g., the context of a
      stream compressed using RTP/UDP/IP (profile 0). This is done with
      an IR-DYN packet (section 7.7.2) with profile = 1, where the
      dynamic chain corresponds to the prefix of the existing static
      chain that ends with the UDP header.

   Method 2) can be used for packet streams where the initial assumption
   was that they were RTP streams, so compression started with profile
   zero, but where it later becomes evident that they are not RTP
   streams.

   The context generation number is re-initialized to zero whenever an
   IR packet is sent or received. It is incremented by one whenever a
   packet which changes the static context is sent or received.




Bormann (ed.)                                                 [Page 100]

INTERNET-DRAFT          Robust Header Compression           Oct 03, 2000



5.10.2 States and Modes

   ROHC UDP uses the same states and modes as ROHC RTP. Mode transitions
   and state logic is the same except when explicitly stated otherwise.


5.10.3 Packet types

   The general format of a ROHC UDP packet is the same as for ROHC RTP
   (see beginning of section 5.7.). Padding and CIDs are the same, as is
   the feedback packet type (5.7.6.1) (but not the feedback), and the IR
   and IR-DYN packets (5.7.7).

   The general format of compressed packets is also the same, but there
   are differences in specific formats and extensions as follows.

   IP-ID and IP-ID2 (in Extension 0) are encoded using W-LSB encoding
   (section 4.5.2) with p = 16.

   UDP-0

     0   1   2   3   4   5   6   7
   +---+---+---+---+---+---+---+---+
   | 0 |            CRC            |
   +===+===+===+===+===+===+===+===+


   UDP-1

     0   1   2   3   4   5   6   7
   +---+---+---+---+---+---+---+---+
   | 1   0 |         IP-ID         |
   +===+===+===+===+===+===+===+===+
   | X |            CRC            |
   +---+---+---+---+---+---+---+---+


5.10.4 Extensions

   Extensions are as in 5.7.5, with the following exceptions:

   Extension 0:

   +---+---+---+---+---+---+---+---+
   | 0 |          IP-ID2           |
   +---+---+---+---+---+---+---+---+

      Provides bits for a second IP Identifier.

   Extension 1:



Bormann (ed.)                                                 [Page 101]

INTERNET-DRAFT          Robust Header Compression           Oct 03, 2000



   Extension 1 is the same as Extension 3 in section 5.7.5, with the
   following exceptions.

   1) The initial flag octet has the following format:

         0     1     2     3     4     5     6     7
      +-----+-----+-----+-----+-----+-----+-----+-----+
      |  1  |      Generation       |  I  | ip  | ip2 |
      +-----+-----+-----+-----+-----+-----+-----+-----+

      Generation: Flags S, R-TS, Tsc, and rtp are eliminated (i.e.,
         always zero). Instead, a context generation identifies the
         changes and allows accurate feedback to be sent. Flag ip2 is
         moved here from the Inner IP hdr flags.

   2) In the position of the old ip2 flag in the Inner IP hdr flags,
      there is a new flag Mod, which indicates whether an octet with the
      following format occurs in the position of the old RTP header
      flags and fields.

      +---+---+---+---+---+---+---+---+
      | 0   0   0   0   0   0 | Mode  |  if Mod=1
      +---+---+---+---+---+---+---+---+

        Mode:  Compression mode. Values as for Mode field in 5.7.5.


5.10.5 IP-ID

   The IP-ID field is the compressed IP Identifier of the innermost IPv4
   header whose RND flag is not set. The IP identifier is compressed
   according to section 4.5.2, using p = 8. The IP-ID2 field in
   extension 0 is the compressed outer IP-ID, if there is one. The RND
   and NBO flags are used as in profile zero, i.e., as described in
   5.7.5.1. (replace UOR-2 with UDP-1, Extension 3 with Extension 1).

5.10.6. Feedback

   The feedback packet type and general format of feedback is the same
   as for profile zero (5.7.6.1.).

   The feedback formats of section 5.7.6.2 are replaced by the
   following:

   FEEDBACK-1

   +---+---+---+---+---+---+---+---+
   |   Generation  |     IP-ID     |
   +---+---+---+---+---+---+---+---+




Bormann (ed.)                                                 [Page 102]

INTERNET-DRAFT          Robust Header Compression           Oct 03, 2000


      Generation: generation of current static context.
      IP-ID: LSBs of innermost IP Identifier of packet which caused
         Feedback to be sent. If there is no IP identifier, zero.

      A FEEDBACK-1 is an ACK.


   FEEDBACK-2

     0   1   2   3   4   5   6   7
   +---+---+---+---+---+---+---+---+
   |Acktype| Mode  |  Generation   |
   +---+---+---+---+---+---+---+---+
   |             IP-ID             |
   +---+---+---+---+---+---+---+---+
   /       Feedback options        /
   +---+---+---+---+---+---+---+---+

     Acktype:  0 = ACK
               1 = NACK
               2 = STATIC-NACK
               3 is reserved

     Mode:     0 is reserved
               1 = Unidirectional mode
               2 = Bi-directional Optimistic mode
               3 = Bi-directional Reliable mode

     Feedback options: A variable number of feedback options, see
        section 5.7.6.3. Options may appear in any order.
























Bormann (ed.)                                                 [Page 103]

INTERNET-DRAFT          Robust Header Compression           Oct 03, 2000


6.  Implementation issues

   This document specifies mechanisms for the protocol, while much of
   the usage of these mechanisms is left to the implementers to decide
   upon. This chapter is aimed to give guidelines, ideas and suggestions
   for implementing the scheme.


6.1.  Reverse decompression

   This chapter describes an OPTIONAL decompressor operation to reduce
   discarded packets due to an invalid context.

   Once a context becomes invalid (e.g., in the case when more
   consecutive packet losses than expected has occurred), subsequent
   compressed packets cannot be decompressed correctly immediately.
   Reverse decompression aims at decompressing such packets later
   instead of discarding them, by storing them until the context has
   been updated and validated and then attempting decompression.

   Let the sequence of stored packets be i, i+1, ..., i+k, where i is
   the first packet and I+k is the packet before the context was
   updated. The decompressor will attempt to recover the stored packets
   in reverse order, i.e., starting with i+k, and working towards i.
   When a stored packet has been reconstructed, its correctness is
   verified using its CRC. Packets not carrying a CRC must not be
   delivered to upper layers. Packets where the CRC succeeds, are
   delivered to upper layers in the original order, i.e., i, ..., i+k.

   Note that this reverse decompression introduces buffering while
   waiting for the context to be validated and thereby introduces
   additional delay. Thus, it should be used only when some amount of
   delay is acceptable. For example, for video packets belonging to the
   same video frame, the delay of packet arrival time does not cause
   presentation time delay. Delay-insensitive streaming applications can
   also be tolerant to such delay. If the decompressor cannot determine
   if the application can tolerate delay, it should not do reverse
   decompression.

   The following illustrates the decompression procedure in some detail:

   1. The decompressor stores compressed packets that cannot be
      decompressed correctly due to an invalid context.

   2. When the decompressor has received a context updating packet and
      the context has been validated, it starts to recover the stored
      packets in reverse order. Decompression is carried out followed
      by the last decompressed packet to its previous packet as if the
      two packets were reordered. After that, the decompressor checks
      the correctness of the reconstructed header using the CRC.




Bormann (ed.)                                                 [Page 104]

INTERNET-DRAFT          Robust Header Compression           Oct 03, 2000


   3. If the CRC indicates successful decompression, the decompressor
      stores the complete packet and attempts to decompress the
      preceeding packet. In this way, the stored packets are recovered
      until no compressed packets are left. For each packet, the
      decompressor checks the correctness of the decompressed headers
      using header compression CRC.

   4. If the CRC indicates an incorrectly decompressed packet, the
      reverse decompression attempt must be terminated and all
      remaining uncompressed packets must be discarded.

   5. Finally, the decompressor forwards all the correctly decompressed
      packets to upper layers in the original order.

6.2.  RTCP

   RTCP is the RTP Control Protocol, [RTP]. RTCP is based on periodic
   transmission of control packets to all participants in a session,
   using the same distribution mechanism as for data packets. Its
   primary function is to provide feedback from the data receivers on
   the quality of the data distribution. The feedback information may be
   used for issues related to congestion control functions, and directly
   useful for control of adaptive encodings.

   In an RTP session there will be two types of packet streams; one with
   the RTP-header and application data, and a second stream with the
   RTCP control information. The difference between the streams at the
   transport level is the UDP port numbers, which is plus one for RTCP.
   The ROHC header compressor implementation has several ways at hand to
   handle the RTCP stream.

     1. One compressor/decompressor entity for both streams and carried
        on the same channel using CIDs to distinguish between them. On
        the RTCP stream, basically only IP/UDP compression will be
        utilized.
     2. Two compressor/decompressor entities, one for RTP and another
        one for RTCP, and the streams carried on their own channel. This
        means that they will not share the same CID number space.

6.3.  Implementation parameters and signals

   A ROHC implementation may have two kinds of parameters; configuration
   parameters that are mandatory and must be negotiated between
   compressor and decompressor peers, and also implementation parameters
   that are optional and when used, mandate how a ROHC implementation is
   to operate.

   Configuration parameters are mandatory and must be negotiated between
   compressor and decompressor, so they have the same values at





Bormann (ed.)                                                 [Page 105]

INTERNET-DRAFT          Robust Header Compression           Oct 03, 2000


   compressor and decompressor. An example of a configuration parameter
   is whether context identification bits (CID) should be used or not.

   Implementation parameters make it possible to mandate how an
   implementation of a ROHC compressor or decompressor should operate.
   Implementation parameters have local significance, are optional to
   use and are thus not necessary to negotiate between compressor and
   decompressor.  Note: this does not preclude that implementation
   parameters may be signaled or negotiated using lower layer
   functionality in order to set the way a ROHC implementation operate.
   Some implementation parameters are valid only at either of compressor
   or decompressor. Implementation parameters may further be divided
   into parameters that describe the way an implementation operates and
   into parameters that trigger a specific event, i.e., signals.

6.3.1.  ROHC implementation parameters at compressor:

   CONTEXT_REFRESH -  signal
   This parameters triggers a complete refresh of the context at the
   decompressor, both static and dynamic part. The compressor MUST, when
   CONTEXT_REFRESH is triggered, fully refresh the context by sending
   IR/DYN headers until it is reasonably confident that the decompressor
   contexts are refreshed. The context refresh MUST be done for all
   contexts at the compressor. This parameter may for instance be used
   to do context relocation at e.g. a cellular handover that result in a
   change of compression point in the radio access network.

   NO_OF_HEADER_SIZES - values:  positive integer value
   This parameter should only be used when HEADER_SIZES_USED is used. In
   that case, this parameter mandates the number of header sizes a ROHC
   implementation can use. With this number is set, the ROHC
   implementation at the compressor MUST NOT use more different header
   sizes than the value of this parameter mandates. The ROHC
   implementation should be able to determine itself which header sizes
   to use. Note: one header size may be used for several header formats.

   HEADER_SIZES_USED - values: list of positive integer values
   This parameter should only be used when NO_OF_HEADER_SIZES is used.
   In that case, this parameter tells which header sizes in bytes that
   may be used by the ROHC implementation. The information about used
   header sizes in this parameter, may then be used to configure lower
   layers.

   For the two parameters above the following MUST apply:
   NO_OF_HEADER_SIZES must be equal to the number of list elements in
   HEADER_SIZES_USED

6.3.2.  ROHC implementation parameters at decompressor:

   MODE - values: [U_mode, O_mode, R_mode]




Bormann (ed.)                                                 [Page 106]

INTERNET-DRAFT          Robust Header Compression           Oct 03, 2000


   This parameter triggers a mode transition using the mechanism
   described in chapter 5 when the parameter changes value, i.e. to
   U_mode (Unidirectional mode), O_mode (bidirectional Optimistic mode)
   or R_mode (bidirectional Reliable mode). The mode transition is made
   from the current mode to the new mode as signaled in the
   implementation parameter. For example, if the current mode is
   bidirectional optimistic mode, MODE should have the value: O_mode. If
   the MODE is changed to R_mode, a mode transition MUST be made from
   bidirectional optimistic mode to bidirectional reliable mode. MODE
   should not only serve as a trigger for mode transitions, but also
   make it visible which mode ROHC operates in.

   TIMER_BASED_TS_COMPRESSION - values: [YES, NO]
   This parameter determines whether timer-based time stamp compression
   as described in chapter X.X should be used or not. It SHOULD be used
   when the parameter has the value YES, and it MUST NOT be used when
   the parameter has the value NO.

   REVERSE_DECOMPRESSION - values: [YES, NO]
   This parameter determines whether reverse decompression as described
   in chapter X.X should be used or not. It MUST be used when the
   parameter has the value YES, and it MUST NOT be used when the
   parameter has the value NO.

6.5.  Handling of resource limitations at the decompressor

   In a point to point link the two nodes can agree on the number of
   compressed sessions they are prepared to support for this link.  It
   may, however, not be possible for the decompressor to accurately
   predict when it will run out of resources.  ROHC allows the
   negotiated number of contexts to be larger than could be accommodated
   in the worst case.  Then, as context resources are consumed, an
   attempt to set up a new context may be rejected by the decompressor,
   using the REJECT option of the feedback payload.

   Upon reception of a REJECT option, the compressor SHOULD wait for a
   while before attempting to compress additional streams destined to
   the rejecting host.
















Bormann (ed.)                                                 [Page 107]

INTERNET-DRAFT          Robust Header Compression           Oct 03, 2000


7.  Further work

   (Editor: This section is _further work_ in particular as it needs to
   be integrated into the rest of the document.  It will go away in the
   next version of this document, -04.)

7.3.  Tunneling

7.3.1.  Header Compression for IPv4 Tunneling Header

      In order to route the packets to the mobile node that is on a
   foreign link, the home agent of the mobile node may encapsulate the
   original packet into an IP header and tunnel the packet to the care-
   of address of the mobile node. In the case of foreign agent care-of
   address in Mobile IPv4, the tunneling header in each tunneled packet
   will be removed by the foreign agent before transferring it to the
   mobile node through the air interface; therefore there is no need for
   compression of tunneling header.  In the case that mobile node uses
   collocated care-of address, the tunneled packet will be sent to
   mobile station through air interface, and compression needs to be
   applied to the tunneling header.

7.3.1.1.  Mobile IPv4 Tunneling Header Fields Type

      The table below summarizes classification of the various fields
   defined in different tunneling headers used in Mobile IPv4. In the
   column of Encapsulation Scheme (Enc. Scheme), three encapsulation
   methods are included - IP in IP Encapsulation (IIE), Minimum
   Encapsulation (ME), Generic Routing Encapsulation (GRE).

   (Editor's note: Harmonize with the way this is described in ROHC
   document)

      +------+------+---------+---------------------------------+
      |Enc.  |Header| Static  |          Non-static             |
      |Scheme|type  |         +-----------+---------------------+
      |      |      |         | Essential |    Non-Essential    |
      +------+------+---------+-----------+---------------------+
      | IIE  |inner |   same as in the table in Appendix A      |
      |      |header|          in ACE Internet Draft            |
      |      +------+-------------------------------------------+
      |      |outer |   same as in the table in Appendix A      |
      |      |header|          in ACE Internet Draft            |
      +------+------+-------------------------------------------+
      | ME   |IP    |   same as in the table in Appendix A      |
      |      |header|          in ACE Internet Draft            |
      |      +------+----------+----------+---------------------+
      |      |Mini. | Protocol |          | S bit               |
      |      |Fw.   |          |          | Header Checksum     |
      |      |header|          |          | Original Dest. Addr.|
      |      |      |          |          | Original Src. Addr. |



Bormann (ed.)                                                 [Page 108]

INTERNET-DRAFT          Robust Header Compression           Oct 03, 2000


      +------+------+----------+----------+---------------------+
      | GRE  |inner |   same as in the table in Appendix A      |
      |      |header|          in ACE Internet Draft            |
      |      +------+-------------------------------------------+
      |      |outer |   same as in the table in Appendix A      |
      |      |header|          in ACE Internet Draft            |
      |      +------+----------+----------+---------------------+
      |      |GRE   | Protocol | Sequence | C, R, K, S, s bits  |
      |      |header| Ver      | number   | Recur               |
      |      |      |          |          | Flags               |
      |      |      |          |          | Checksum            |
      |      |      |          |          | Offset              |
      |      |      |          |          | Key                 |
      |      |      |          |          | Routing             |
      +------+------+----------+----------+---------------------+

7.3.1.2.  Compression of Tunneling Headers in MIPv4

      Three encapsulation schemes have been specified in MIPv4. For
   different encapsulation scheme, the compression methods are different
   from each other.

7.3.1.2.1.  IP in IP Encapsulation in IPv4

      Using IP in IP Encapsulation, the original inner IP header is not
   modified at all and therefore can be compressed as if it is not
   encapsulated. The outer header is compressed at the IP level, while
   the inner header is compressed as defined in ROHC.

7.3.1.2.2.  Minimum Encapsulation in IPv4

      With Minimum Encapsulation, the original IP header is modified and
   the Minimal Forwarding Header is inserted between the modified IP
   header and the original IP payload. The modified IP header plus the
   the UDP/RTP headers is compressed as defined in ROHC.

      The compression scheme for the Minimal Forwarding Header is
   similar to the scheme applied to the IP header. The static and
   changing non- essential fields in the Minimum Forwarding Header are
   sent in the Full Header and Refresh state. When any change happens to
   any non-essential field in the Minimum Forwarding Header, a
   compressed header with a bit mask indicating the change should be
   sent.

7.3.1.2.3.  Generic Routing Encapsulation in IPv4

      With Generic Routing Encapsulation, the original IP packet is
   encapsulated in an outer IP header. A GRE header is inserted between
   the inner header and the outer header. The original IP/UDP/RTP header
   is compressed as if there is no encapsulation. The outer IP header is
   compressed at the IP level.



Bormann (ed.)                                                 [Page 109]

INTERNET-DRAFT          Robust Header Compression           Oct 03, 2000



      The compression scheme for the GRE header is similar to the scheme
   applied to the IP header.  All the static and changing non-essential
   fields in the GRE header are sent in the Full Header and refresh
   state. When any change happens to any non-essential field in the GRE
   header, a compressed header with a bit mask indicating the change
   should be sent. If the sequence number in the GRE header is present,
   the scheme to compress sequence number could be VLE, as defined in
   ACE draft.


8.  Section 8 has been removed.


9.  Security considerations

   Because encryption eliminates the redundancy that header compression
   schemes try to exploit, there is some inducement to forego encryption
   of headers in order to enable operation over low-bandwidth links.
   However, for those cases where encryption of data (and not headers)
   is sufficient, RTP does specify an alternative encryption method in
   which only the RTP payload is encrypted and the headers are left in
   the clear. That would still allow header compression to be applied.

   ROHC compression is transparent with regards to the RTP sequence
   number and RTP timestamp fields, so the values of those fields can be
   trusted by payload encryption schemes.

   A malfunctioning or malicious header compressor could cause the
   header decompressor to reconstitute packets that do not match the
   original packets but still have valid IP, UDP and RTP headers and
   possibly also valid UDP checksums. Such corruption may be detected
   with end-to-end authentication and integrity mechanisms which will
   not be affected by the compression. Moreover, this header compression
   scheme uses an internal checksum for verification of re-constructed
   headers. This reduces the probability of producing decompressed
   headers not matching the original ones without this being noticed.

   Denial-of-service attacks are possible if an intruder can introduce
   (for example) bogus STATIC, DYNAMIC or FEEDBACK packets onto the link
   and thereby cause compression efficiency to be reduced. However, an
   intruder having the ability to inject arbitrary packets at the link
   layer in this manner raises additional security issues that dwarf
   those related to the use of header compression.


10.  Acknowledgements

   When designing this protocol, earlier header compression ideas
   described in [CJHC], [IPHC] and [CRTP] have been important sources of
   knowledge.



Bormann (ed.)                                                 [Page 110]

INTERNET-DRAFT          Robust Header Compression           Oct 03, 2000



   Thanks to Takeshi Yoshimura at NTT DoCoMo for providing the reverse
   decompression section (6.1). Thanks also to Andreas Jonsson (Lulea
   University), who made a great job supporting this work in his study
   of header field change patterns. Thanks also to all others who have
   given comments.
















































Bormann (ed.)                                                 [Page 111]

INTERNET-DRAFT          Robust Header Compression           Oct 03, 2000



11.  Intellectual property considerations

   (Editor's note: this section will go to www.ietf.org/ipr and be
   replaced by the standard reference to that, but for now it is left in
   the draft to simplify working on it.)

   This proposal in is conformity with RFC 2026.

   Telefonaktiebolaget LM Ericsson and its subsidiaries, in accordance
   with corporate policy, will for submissions rightfully made by its
   employees which are adopted or recommended as a standard by the IETF
   offer patent licensing as follows:

   If part(s) of a submission by Ericsson employees is (are) included in
   a standard and Ericsson has patents and/or patent application(s) that
   are essential to implementation of such included part(s) in said
   standard, Ericsson is prepared to grant - on the basis of reciprocity
   (grant-back) - a license on such included part(s) on reasonable, non-
   discriminatory terms and conditions.

   For the avoidance of doubt this general patent licensing undertaking
   applies to this proposal.


   Nokia has filed patent applications that might possibly have
   technical relation to this contribution.


   Matsushita has filed patent applications that might possibly have
   technical relation to this contribution.
   If part(s) of the contribution by Matsushita employee is (are)
   included in a standard and Matsushita has patents and/or patent
   application(s) that are essential to implementation of such included
   part(s) in said standard, Matsushita is prepared to grant - on the
   basis of reciprocity (grantback) - a license on such included part(s)
   on reasonable, non-discriminatory terms and conditions (in according
   with paragraph 10.3.3 of the RFC 2026).


   NTT DoCoMo, Inc. also declares this text may relevant to their
   patent, and offer patent licensing as follows:

   If part(s) of this text provided by NTT DoCoMo employees is (are)
   included in a standard and NTT DoCoMo has patents and/or patent
   application(s) that are essential to implementation of such included
   part(s) in said standard, NTT DoCoMo is prepared to grant - on the
   basis of reciprocity (grant-back) - a license on such included
   part(s) on reasonable, non-discriminatory terms and conditions.





Bormann (ed.)                                                 [Page 112]

INTERNET-DRAFT          Robust Header Compression           Oct 03, 2000


12.  References

   [UDP]    Jon Postel, "User Datagram Protocol", RFC 768, August 1980.

   [IPv4]   Jon Postel, "Internet Protocol", RFC 791, September 1981.

   [IPv6]   Steven Deering, Robert Hinden, "Internet Protocol, Version 6
            (IPv6) Specification", RFC 2460, December 1998.

   [RTP]    Henning Schulzrinne, Stephen Casner, Ron Frederick, Van
            Jacobson, "RTP: A Transport Protocol for Real-Time
            Applications", RFC 1889, January 1996.

   [HDLC]   William Simpson, "PPP in HDLC-like framing", RFC 1662, 1994.

   [VJHC]   Van Jacobson, "Compressing TCP/IP Headers for Low-Speed
            Serial Links", RFC 1144, February 1990.

   [IPHC]   Mikael Degermark, Bjorn Nordgren, Stephen Pink, "IP Header
            Compression", RFC 2507, February 1999.

   [CRTP]   Steven Casner, Van Jacobson, "Compressing IP/UDP/RTP Headers
            for Low-Speed Serial Links", RFC 2508, February 1999.

   [PPPHC]  Mathias Engan, Steven Casner, Carsten Bormann, "IP Header
            Compression over PPP", RFC 2509, February 1999.

   [CRTPC]  Mikael Degermark, Hans Hannu, Lars-Erik Jonsson, Krister
            Svanbro, "CRTP over cellular radio links", Internet Draft
            (work in progress), December 1999.
            <draft-degermark-crtp-cellular-01.txt>

   [REQ]   Mikael Degermark, "Requirements for robust IP/UDP/RTP header
           compression", Internet Draft (work in progress), June 2000.
           <draft-ietf-rohc-rtp-requirements-01.txt>

   [LLG]   Krister Svanbro, "Lower Layer Guidelines for Robust Header
           Compression", Internet Draft (work in progress), May 2000.
           <draft-ietf-rohc-lower-layer-guidelines-00.txt>

   [CELL]   Lars Westberg, Morgan Lindqvist, "Realtime traffic over
            cellular access networks", Internet Draft
           (work in progress), May 2000.
            <draft-westberg-realtime-cellular-02.txt>

   [WCDMA] "Universal Mobile Telecommunications System (UMTS);
           Selection procedures for the choice of radio transmission
           technologies of the UMTS (UMTS 30.03 version 3.1.0)".
           ETSI TR 101 112 V3.0.1, November 1997.





Bormann (ed.)                                                 [Page 113]

INTERNET-DRAFT          Robust Header Compression           Oct 03, 2000



13.  Authors' addresses

   [[Editor's note: Multiple authors at the same address have been
   compressed.  I hope your heads are robust enough for this...]]

   Carsten Bormann               Tel: +49 421 218 7024
   Universitaet Bremen TZI       Fax: +49 421 218 7000
   Postfach 330440               EMail: cabo@tzi.org
   D-28334 Bremen, GERMANY

   Carsten Burmeister            Tel.  +49-6103-766-263
   Rolf Hakenberg                Tel.  +49-6103-766-162
   Thomas Wiebke                 Tel.  +49-6103-766-161
   Panasonic European Laboratories GmbH   Fax.  +49-6103-766-166
   Monzastr. 4c                  Email: burmeister@panasonic.de
   63225 Langen, Germany         Email: hakenberg@panasonic.de
                                 Email: wiebke@panasonic.de

   Mikael Degermark              Tel: +1 520 621-3498
   The University of Arizona     Fax: +1 520 621-4642
   Dept of Computer Science      Email: micke@cs.arizona.edu
   P.O. Box 210077
   Tucson, AZ 85721-0077, USA

   Hideaki Fukushima             Email: fukusima@isl.mei.co.jp
   Akihiro Miyazaki              Email: akihiro@isl.mei.co.jp
   Matsushita Electric Industrial Co., Ltd    Tel.  +81-6-6900-9192
   1006, Kadoma, Kadoma City, Osaka, Japan    Fax.  +81-6-6900-9193

   Hans Hannu                    Tel: +46 920 20 21 84
   Lars-Erik Jonsson             Tel: +46 920 20 21 07
   Krister Svanbro               Tel: +46 920 20 20 77
   Box 920                       Fax: +46 920 20 20 99
   Ericsson Erisoft AB           EMail: lars-erik.jonsson@ericsson.com
   SE-971 28 Lulea, Sweden       Email: krister.svanbro@ericsson.com
                                 EMail: hans.hannu@ericsson.com

   Zhigang Liu                   Tel: +1 972 894-5935
   Nokia Research Center         Fax: +1 972 894-4589
   6000 Connection Drive         EMail: zhigang.liu@nokia.com
   Irving, TX 75039, USA

   Anton Martensson              Tel: +46 8 404 3881
   Ericsson Radio Systems AB     Fax: +46 8 757 5550
   SE-164 80 Stockholm, Sweden   Email: anton.martensson@era.ericsson.se








Bormann (ed.)                                                 [Page 114]

INTERNET-DRAFT          Robust Header Compression           Oct 03, 2000


Appendix A.  Detailed classification of header fields

   Header compression is possible due to the fact that most header
   fields do not vary randomly from packet to packet. Many of the fields
   exhibit static behavior or changes in a more or less predictable way.
   When designing a header compression scheme, it is of fundamental
   importance to understand the behavior of the fields in detail.

   In this appendix, all IP, UDP and RTP header fields are classified
   and analyzed in two steps. First, we have a general classification in
   A.1 where the fields are classified based on stable knowledge and
   assumptions. The general classification does not take into account
   the change characteristics of changing fields because those will vary
   more or less depending on the implementation and on the application
   used. A less stable but more detailed analysis considering the change
   characteristics is then done in A.2. Finally, A.3 summarizes this
   appendix with conclusions about how the various header fields should
   be handled by the header compression scheme to optimize compression
   and functionality.

A.1.  General classification

   On a general level, the header fields are separated into 5 classes:

   INFERRED       These fields contain values that can be inferred from
                  other values, for example the size of the frame
                  carrying the packet, and thus does not have to be
                  handled at all by the compression scheme.

   STATIC         These fields are expected to be constant throughout
                  the lifetime of the packet stream. Static information
                  must in some way be communicated once.

   STATIC-DEF     STATIC fields whose values define a packet stream.
                  They are in general handled as STATIC.

   STATIC-KNOWN   These STATIC fields are expected to have well-known
                  values and therefore do not need to be communicated
                  at all.

   CHANGING       These fields are expected to vary in some way, either
                  randomly, within a limited value set or range, or in
                  some other manner.


   In this section, each of the IP, UDP and RTP header fields is
   assigned to one of these classes. For all fields except those
   classified as CHANGING, the motives for the classification are also
   stated. CHANGING fields are in A.2 further examined and classified
   based on their expected change behavior.




Bormann (ed.)                                                 [Page 115]

INTERNET-DRAFT          Robust Header Compression           Oct 03, 2000


A.1.1.  IPv6 header fields

    +---------------------+-------------+----------------+
    | Field               | Size (bits) |    Class       |
    +---------------------+-------------+----------------+
    | Version             |      4      |  STATIC-KNOWN  |
    | Traffic Class       |      8      |    CHANGING    |
    | Flow Label          |     20      |   STATIC-DEF   |
    | Payload Length      |     16      |    INFERRED    |
    | Next Header         |      8      |  STATIC-KNOWN  |
    | Hop Limit           |      8      |    CHANGING    |
    | Source Address      |    128      |   STATIC-DEF   |
    | Destination Address |    128      |   STATIC-DEF   |
    +---------------------+-------------+----------------+


   Version

     The version field states which IP version the packet is based on.
     Packets with different values in this field must be handled by
     different IP stacks. For header compression, different compression
     profiles must also be used. When compressor and decompressor have
     negotiated which profile to use, the IP version is also known to
     both parties. The field is therefore classified as STATIC-KNOWN.


   Flow Label

     This field may be used to identify packets belonging to a specific
     packet stream. If not used, the value should be set to zero.
     Otherwise, all packets belonging to the same stream must have the
     same value in this field, it being one of the fields defining the
     stream. The field is therefore classified as STATIC-DEF.


   Payload Length

     Information about the packet length (and then also payload length)
     is expected to be provided by the link layer. The field is
     therefore classified as INFERRED.


   Next Header

     This field is expected to have the same value in all packets of a
     packet stream. As for the version number, a certain compression
     profile can only handle a specific next header which means that
     this value is known when profile has been negotiated. The field is
     therefore classified as STATIC-KNOWN.





Bormann (ed.)                                                 [Page 116]

INTERNET-DRAFT          Robust Header Compression           Oct 03, 2000


   Source and Destination addresses

     These fields are part of the definition of a stream and must thus
     be constant for all packets in the stream. The fields are therefore
     classified as STATIC-DEF.


   Summarizing the bits corresponding to the classes gives:

    +--------------+--------------+
    | Class        | Size (octets)|
    +--------------+--------------+
    | INFERRED     |       2      |
    | STATIC-DEF   |     34.5     |
    | STATIC-KNOWN |      1.5     |
    | CHANGING     |       2      |
    +--------------+--------------+


A.1.2.  IPv4 header fields

    +---------------------+-------------+----------------+
    | Field               | Size (bits) |     Class      |
    +---------------------+-------------+----------------+
    | Version             |      4      |  STATIC-KNOWN  |
    | Header Length       |      4      |  STATIC-KNOWN  |
    | Type Of Service     |      8      |    CHANGING    |
    | Packet Length       |     16      |    INFERRED    |
    | Identification      |     16      |    CHANGING    |
    | Reserved flag       |      1      |  STATIC-KNOWN  |
    | May Fragment flag   |      1      |     STATIC     |
    | Last Fragment flag  |      1      |  STATIC-KNOWN  |
    | Fragment Offset     |     13      |  STATIC-KNOWN  |
    | Time To Live        |      8      |    CHANGING    |
    | Protocol            |      8      |  STATIC-KNOWN  |
    | Header Checksum     |     16      |    INFERRED    |
    | Source Address      |     32      |   STATIC-DEF   |
    | Destination Address |     32      |   STATIC-DEF   |
    +---------------------+-------------+----------------+


   Version

     The version field states which IP version the packet is based on
     and packets with different values in this field must be handled by
     different IP stacks. For header compression, different compression
     profiles must also be used. When compressor and decompressor has
     negotiated which profile to use, the IP version is also well known
     to both parties. The field is therefore classified as STATIC-KNOWN.





Bormann (ed.)                                                 [Page 117]

INTERNET-DRAFT          Robust Header Compression           Oct 03, 2000


   Header Length

     As long as there are no options present in the IP header, the
     header length is constant and well known. If there are options, the
     fields would be STATIC, but we assume no options. The field is
     therefore classified as STATIC-KNOWN.


   Packet Length

     Information about the packet length is expected to be provided by
     the link layer. The field is therefore classified as INFERRED.


   Flags

     The Reserved flag must be set to zero and is therefore classified
     as STATIC-KNOWN. The May Fragment flag will be constant for all
     packets in a stream and is therefore classified as STATIC. Finally,
     the Last Fragment bit is expected to be zero because fragmentation
     is NOT expected, due to the small packet size expected. The Last
     Fragment bit is therefore classified as STATIC-KNOWN.


   Fragment Offset

     With the assumption that no fragmentation occurs, the fragment
     offset is always zero. The field is therefore classified as STATIC-
     KNOWN.


   Protocol

     This field is expected to have the same value in all packets of a
     packet stream. As for the version number, a certain compression
     profile can only handle a specific next header which means that
     this value is well known when profile has been negotiated. The
     field is therefore classified as STATIC-KNOWN.


   Header Checksum

     The header checksum protects individual hops from processing a
     corrupted header. When almost all IP header information is
     compressed away, there is no need to have this additional checksum;
     instead it can be regenerate at the decompressor side. The field is
     therefore classified as INFERRED.


   Source and Destination addresses




Bormann (ed.)                                                 [Page 118]

INTERNET-DRAFT          Robust Header Compression           Oct 03, 2000


     These fields are part of the definition of a stream and must thus
     be constant for all packets in the stream. The fields are therefore
     classified as STATIC-DEF.


   Summarizing the bits corresponding to the classes gives:

    +--------------+--------------+
    | Class        | Size (octets)|
    +--------------+--------------+
    | INFERRED     |      4       |
    | STATIC       |    1 bit     |
    | STATIC-DEF   |      8       |
    | STATIC-KNOWN |   3 +7 bits  |
    | CHANGING     |      4       |
    +--------------+--------------+


A.1.3.  UDP header fields

    +------------------+-------------+-------------+
    | Field            | Size (bits) |    Class    |
    +------------------+-------------+-------------+
    | Source Port      |     16      | STATIC-DEF  |
    | Destination Port |     16      | STATIC-DEF  |
    | Length           |     16      |  INFERRED   |
    | Checksum         |     16      |  CHANGING   |
    +------------------+-------------+-------------+


   Source and Destination ports

     These fields are part of the definition of a stream and must thus
     be constant for all packets in the stream. The fields are therefore
     classified as STATIC-DEF.


   Length

     This field is redundant and is therefore classified as INFERRED.


   Summarizing the bits corresponding to the classes gives:

    +------------+--------------+
    | Class      | Size (octets)|
    +------------+--------------+
    | INFERRED   |       2      |
    | STATIC-DEF |       4      |
    | CHANGING   |       2      |
    +------------+--------------+



Bormann (ed.)                                                 [Page 119]

INTERNET-DRAFT          Robust Header Compression           Oct 03, 2000




A.1.4.  RTP header fields

    +-----------------+-------------+----------------+
    | Field           | Size (bits) |     Class      |
    +-----------------+-------------+----------------+
    | Version         |      2      |  STATIC-KNOWN  |
    | Padding         |      1      |     STATIC     |
    | Extension       |      1      |     STATIC     |
    | CSRC Counter    |      4      |    CHANGING    |
    | Marker          |      1      |    CHANGING    |
    | Payload Type    |      7      |    CHANGING    |
    | Sequence Number |     16      |    CHANGING    |
    | Timestamp       |     32      |    CHANGING    |
    | SSRC            |     32      |   STATIC-DEF   |
    | CSRC            |   0(-480)   |    CHANGING    |
    +-----------------+-------------+----------------+


   Version

     There exists only one working RTP version and that is version 2.
     The field is therefore classified as STATIC-KNOWN.


   Padding

     The use of this field depends on the application, but when payload
     padding is used it is likely to be present in all packets. The
     field is therefore classified as STATIC.


   Extension

     If RTP extensions is used by the application, it is likely to be an
     extension present in all packets (but use of extensions is very
     uncommon). However, for safety's sake this field is classified as
     STATIC and not STATIC-KNOWN.


   SSRC

     This field is part of the definition of a stream and must thus be
     constant for all packets in the stream. The field is therefore
     classified as STATIC-DEF.








Bormann (ed.)                                                 [Page 120]

INTERNET-DRAFT          Robust Header Compression           Oct 03, 2000




   Summarizing the bits corresponding to the classes gives:

    +--------------+--------------+
    | Class        | Size (octets)|
    +--------------+--------------+
    | STATIC       |    2 bits    |
    | STATIC-DEF   |      4       |
    | STATIC-KNOWN |    2 bits    |
    | CHANGING     |  7.5(-67.5)  |
    +--------------+--------------+


A.1.5.  Summary for IP/UDP/RTP

   If we summarize this for IP/UDP/RTP we get:

    +----------------+--------------+--------------+
    | Class \ IP ver | IPv6 (octets)| IPv4 (octets)|
    +----------------+--------------+--------------+
    | INFERRED       |       4      |       6      |
    | STATIC         |    2 bits    |    3 bits    |
    | STATIC-DEF     |     42.5     |      16      |
    | STATIC-KNOWN   |   1 +6 bits  |   4 +1 bit   |
    | CHANGING       |  11.5(-71.5) |  13.5(-73.5) |
    +----------------+--------------+--------------+
    | Total          |   60(-120)   |   40(-100)   |
    +----------------+--------------+--------------+


A.2.  Analysis of change patterns of header fields

   To design suitable mechanisms for efficient compression of all header
   fields, their change patterns must be analyzed. For this reason, an
   extended classification is done based on the general classification
   in A.1, considering the fields which were labeled CHANGING in that
   classification. Different applications will use the fields in
   different ways, which may affect their behavior. When this is the
   case, typical behavior for conversational audio and video will be
   discussed.

   The CHANGING fields are separated into five different subclasses:

   STATIC                These are fields that were classified as
                         CHANGING on a general basis, but are classified
                         as STATIC here due to certain additional
                         assumptions.

   SEMISTATIC            These fields are STATIC most of the time.
                         However, occasionally the value changes but



Bormann (ed.)                                                 [Page 121]

INTERNET-DRAFT          Robust Header Compression           Oct 03, 2000


                         reverts to its original value after a known
                         number of packets.

   RARELY-CHANGING (RC)  These are fields that change their values
                         occasionally and then keep their new values.

   ALTERNATING           These fields alternate between a small number
                         of different values.

   IRREGULAR             These, finally, are the fields for which no
                         useful change pattern can be identified.

   To further expand the classification possibilities without increasing
   complexity, the classification can be done either according to the
   values of the field and/or according to the values of the deltas for
   the field.

   When the classification is done, other details are also stated
   regarding possible additional knowledge about the field values and/or
   field deltas, according to the classification. For fields classified
   as STATIC or SEMISTATIC, the case could be that the value of the
   field is not only STATIC but also well KNOWN a priori (two states for
   SEMISTATIC fields). For fields with non-irregular change behavior, it
   could be known that changes usually are within a LIMITED range
   compared to the maximal change for the field. For other fields, the
   values are completely UNKNOWN.

   Table A.1 classifies all the CHANGING fields based on their expected
   change patterns, especially for conversational audio and video.



    +------------------------+-------------+-------------+-------------+
    |         Field          | Value/Delta |    Class    |  Knowledge  |
    +========================+=============+=============+=============+
    |             Sequential |    Delta    |    STATIC   |    KNOWN    |
    |             -----------+-------------+-------------+-------------+
    | IPv4 Id:    Seq. jump  |    Delta    |      RC     |   LIMITED   |
    |             -----------+-------------+-------------+-------------+
    |             Random     |    Value    |  IRREGULAR  |   UNKNOWN   |
    +------------------------+-------------+-------------+-------------+
    | IP TOS / Tr. Class     |    Value    |      RC     |   UNKNOWN   |
    +------------------------+-------------+-------------+-------------+
    | IP TTL / Hop Limit     |    Value    | ALTERNATING |   LIMITED   |
    +------------------------+-------------+-------------+-------------+
    |               Disabled |    Value    |    STATIC   |    KNOWN    |
    | UDP Checksum: ---------+-------------+-------------+-------------+
    |               Enabled  |    Value    |  IRREGULAR  |   UNKNOWN   |
    +------------------------+-------------+-------------+-------------+
    |                 No mix |    Value    |    STATIC   |    KNOWN    |
    | RTP CSRC Count: -------+-------------+-------------+-------------+



Bormann (ed.)                                                 [Page 122]

INTERNET-DRAFT          Robust Header Compression           Oct 03, 2000


    |                 Mixed  |    Value    |      RC     |   LIMITED   |
    +------------------------+-------------+-------------+-------------+
    | RTP Marker             |    Value    |  SEMISTATIC | KNOWN/KNOWN |
    +------------------------+-------------+-------------+-------------+
    | RTP Payload Type       |    Value    |      RC     |   UNKNOWN   |
    +------------------------+-------------+-------------+-------------+
    | RTP Sequence Number    |    Delta    |    STATIC   |    KNOWN    |
    +------------------------+-------------+-------------+-------------+
    | RTP Timestamp          |    Delta    |      RC     |   LIMITED   |
    +------------------------+-------------+-------------+-------------+
    |                 No mix |      -      |      -      |      -      |
    | RTP CSRC List:  -------+-------------+-------------+-------------+
    |                 Mixed  |    Value    |      RC     |   UNKNOWN   |
    +------------------------+-------------+-------------+-------------+

           Table A.1 : Classification of CHANGING header fields

   The following subsections discuss the various header fields in
   detail. Note that table A.1 and the discussions below do not consider
   changes caused by loss or reordering before the compression point.


A.2.1.  IPv4 Identification

   The Identification field (IP ID) of the IPv4 header is there to
   identify which fragments constitute a datagram when reassembling
   fragmented datagrams. The IPv4 specification does not specify exactly
   how this field is to be assigned values, only that each packet should
   get an IP ID that is unique for the source-destination pair and
   protocol for the time the datagram (or any of its fragments) could be
   alive in the network. This means that assignment of IP ID values can
   be done in various ways, which we have separated into three classes.

   Sequential

      This assignment policy keeps a separate counter for each outgoing
      packet stream and thus the IP ID value will increment by one for
      each packet in the stream. Therefore, the delta value of the
      field is constant and well known a priori. When RTP is used on
      top of UDP and IP, the IP ID value follows the RTP sequence
      number. This assignment policy is the most desirable for header
      compression purposes but its usage is not as common as it should
      be. The reason is that it can be realized only if UDP and IP are
      implemented together so that UDP, which separates packet streams
      by the port identification, can make IP use separate ID counters
      for each packet stream.

   Sequential jump

      This is the most common assignment policy in today's IP stacks.
      The difference from the sequential method is that only one



Bormann (ed.)                                                 [Page 123]

INTERNET-DRAFT          Robust Header Compression           Oct 03, 2000


      counter is used for all connections. When the sender is running
      more than one packet stream simultaneously, the IP ID can
      increase by more than one. The IP ID values will be much more
      predictable and require less bits to transfer than random values,
      and the packet-to-packet increment (determined by the number of
      active outgoing packet streams and sending frequencies) will
      usually be limited.

   Random

      Some IP stacks assign IP ID values using a pseudo-random number
      generator. There is thus no correlation between the ID values of
      subsequent datagrams. Therefore there is no way to predict the IP
      ID value for the next datagram. For header compression purposes,
      this means that the IP ID field needs to be sent uncompressed
      with each datagram, resulting in two extra octets of header. IP
      stacks in cellular terminals SHOULD NOT use this IP ID assignment
      policy.

   It should be noted that the ID is an IPv4 mechanism and is therefore
   not needed at all in IPv6 profiles. For IPv4 the ID could be handled
   in three different ways. Firstly, we have the inefficient but
   reliable solution where the ID field is sent as-is in all packets,
   increasing the compressed headers with two octets. This is the best
   way to handle the ID field if the sender uses random assignment of
   the ID field. Secondly, there can be solutions with more flexible
   mechanisms requiring less bits for the ID handling as long as
   sequential jump assignment is used. Such solutions will probably
   require even more bits if random assignment is used by the sender.
   Knowledge about the sender's assignment policy could therefore be
   useful when choosing between the two solutions above. Finally, even
   for IPv4, header compression could be designed without any additional
   information for the ID field included in compressed headers. To use
   such schemes, it must be known that the sender makes use of the pure
   sequential assignment policy for the ID field. That might not be
   possible to know, which implies that the applicability of such
   solutions is very uncertain. However, designers of IPv4 stacks for
   cellular terminals SHOULD use the sequential policy.


A.2.2.  IP Traffic-Class / Type-Of-Service

   The Traffic-Class (IPv6) or Type-Of-Service (IPv4) field is expected
   to be constant during the lifetime of a packet stream or to change
   relatively seldom.









Bormann (ed.)                                                 [Page 124]

INTERNET-DRAFT          Robust Header Compression           Oct 03, 2000


A.2.3.  IP Hop-Limit / Time-To-Live

   The Hop-Limit (IPv6) or Time-To-Live (IPv4) field is expected to be
   constant during the lifetime of a packet stream or to alternate
   between a limited number of values due to route changes.


A.2.4.  UDP Checksum

   The UDP checksum is optional. If disabled, its value is constantly
   zero and could be compressed away. If enabled, its value depends on
   the payload, which for compression purposes is equivalent to it
   changing randomly with every packet.


A.2.5.  RTP CSRC Counter

   This is a counter indicating the number of CSRC items present in the
   CSRC list. This number is expected to be almost constant on a packet-
   to-packet basis and change by small amount. As long as no RTP mixer
   is used, the value of this field is zero.

A.2.6.  RTP Marker

   For audio the marker bit should be set only in the first packet of a
   talkspurt while for video it should be set in the last packet of
   every picture. This means that in both cases the RTP marker is
   classified as SEMISTATIC with well-known values for both states.


A.2.7.  RTP Payload Type

   Changes of the RTP payload type within a packet stream are expected
   to be rare. Applications could adapt to congestion by changing
   payload type and/or frame sizes, but that is not expected to happen
   frequently.


A.2.8.  RTP Sequence Number

   The RTP sequence number will be incremented by one for each packet
   sent.


A.2.9.  RTP Timestamp

   In the audio case:

      As long as there are no pauses in the audio stream, the RTP
      timestamp will be incremented by a constant delta, corresponding
      to the number of samples in the speech frame. It will thus mostly



Bormann (ed.)                                                 [Page 125]

INTERNET-DRAFT          Robust Header Compression           Oct 03, 2000


      follow the RTP sequence number. When there has been a silent
      period and a new talkspurt begins, the timestamp will jump in
      proportion to the length of the silent period. However, the
      increment will probably be within a relatively limited range.

   In the video case:

      The timestamp change between two consecutive packets will either
      be zero or increase by a multiple of a fixed value corresponding
      to the picture clock frequency. The timestamp can also decrease
      by a multiple of the fixed value if B-pictures are used. The
      delta interval, expressed as a multiple of the picture clock
      frequency, is in most cases very limited.


A.2.10.  RTP Contributing Sources (CSRC)

   The participants in a session, which are identified by the CSRC
   fields, are expected to be almost the same on a packet-to-packet
   basis with relatively few additions or removals. As long as RTP
   mixers are not used, no CSRC fields are present at all.

A.3.  Header compression strategies

   This section elaborates on what has been done in previous sections.
   Based in the classifications, recommendations are given on how to
   handle the various fields in the header compression process. Seven
   different actions are possible and these are listed together with the
   fields to which each action applies.


A.3.1.  Do not send at all

   The fields that have well known values a priori do not have to be
   sent at all. These are:

   - IP Version
   - IPv6 Payload Length
   - IPv6 Next Header
   - IPv4 Header Length
   - IPv4 Reserved Flag
   - IPv4 Last Fragment Flag
   - IPv4 Fragment Offset
   - IPv4 Protocol
   - UDP Checksum (if disabled)
   - RTP Version








Bormann (ed.)                                                 [Page 126]

INTERNET-DRAFT          Robust Header Compression           Oct 03, 2000


A.3.2.  Transmit only initially

   The fields that are constant throughout the lifetime of the packet
   stream have to be transmitted and correctly delivered to the
   decompressor only once. These are:

   - IP Source Address
   - IP Destination Address
   - IPv6 Flow Label
   - IPv4 May Fragment Flag
   - UDP Source Port
   - UDP Destination Port
   - RTP Padding Flag
   - RTP Extension Flag
   - RTP SSRC


A.3.3.  Transmit initially, but be prepared to update

   The fields that are changing only occasionally must be transmitted
   initially but there must also be a way to update these fields with
   new values if they change. These fields are:

   - IPv6 Traffic Class
   - IPv6 Hop Limit
   - IPv4 Type Of Service (TOS)
   - IPv4 Time To Live (TTL)
   - RTP CSRC Counter
   - RTP Payload Type
   - RTP CSRC List


A.3.4.  Be prepared to update or send as-is frequently

   For fields that normally are either constant or whose values can be
   deduced from some other field but frequently diverge from that
   behavior, there must be an efficient way to update the field value or
   send it as-is in some packets. Those fields are:

   - IPv4 Identification (if not sequentially assigned)
   - RTP Marker
   - RTP Timestamp


A.3.5.  Guarantee continuous robustness

   Fields that behave like a counter with a fixed delta for ALL packets,
   the only requirement on the transmission encoding is that packet
   losses between compressor and decompressor must be tolerable. If more
   than one such field exists, all these can be communicated together.
   Such fields can also be used to interpret the values for fields



Bormann (ed.)                                                 [Page 127]

INTERNET-DRAFT          Robust Header Compression           Oct 03, 2000


   listed in the previous section. Fields that have this counter
   behavior are:

   - IPv4 Identification (if sequentially assigned)
   - RTP Sequence Number


A.3.6.  Transmit as-is in all packets

   Fields that have completely random values for each packet must be
   included as-is in all compressed headers. Those fields are:

   - IPv4 Identification (if randomly assigned)
   - UDP Checksum (if enabled)


A.3.7.  Establish and be prepared to update delta

   Finally, there is a field that is usually increasing by a fixed delta
   and is correlated to another field. For this field it would make
   sense to make that delta part of the context state. The delta must
   then be possible to initiate and update in the same way as the fields
   listed in A.3.3. The field to which this applies is:

   - RTP Timestamp





























Bormann (ed.)                                                 [Page 128]

INTERNET-DRAFT          Robust Header Compression           Oct 03, 2000



Appendix E - Encoding Examples

   [[Editor's note: Need to update this with current terminology.]]

E.1.  Basic VLE

      The examples below illustrate the operation of VLE under various
   scenarios.  The field values used in the examples could correspond to
   any fields that we wish to compress.  The examples illustrate the
   scenario where the compressed field has resolution of one bit.

      Example 1: Normal operation (no packet loss prior to compressor,
   no reodering prior to compressor).

      Suppose packets with header fields 279, 280, 281, 282, and 283
   have been sent, and 279 and 283 are fields of potential reference
   packets.

      The current VLE window is {279, 283}.

      and a packet with field value = 284 is received next, VLE computes
   the following values

      New Value   VMax    VMin             r                   # LSBs
         284      283     279    max[|284-279|,|284-283|]=5       4

      The window is unmodified if we assuming the new packet {284} is
   not a potential reference.  The field is encoded using 4 bits in this
   case, and the actual encoded value is the 4 least significant bits of
   284 (10011100) which = 1100.

      Example 2:  Packet Loss prior to compressor.

      Suppose packets with header fields 279, 280, 281, 282, and 283
   have been sent, and 279 and 283 are fields of potential reference
   packets such that the VSW is again {279, 283}.

      If a packet with field value = 290 is received next, VLE computes
   the following values

      New Value  VMax  VMin             r                # LSBs
        290      283   279   max[|290-283|,|290-279|]=11    5

      So the field is encoded using 5 bits.  Actual encoded value is the
   5 LSBs of 290 (100100010) which = 00010.

      If we assume the new value is a potential reference, the new VSW
   is {279, 283, 290}.

      Example 3:  Packet Misordering prior to compressor.



Bormann (ed.)                                                 [Page 129]

INTERNET-DRAFT          Robust Header Compression           Oct 03, 2000



      Suppose packets with header fields 279, 280, 281, 282, and 283
   have been sent, and 279 and 283 are fields of potential reference
   packets such that the VSW is again {279, 283}.

      If a packet with field value = 278 is received next, VLE computes
   the following values

      New Value     VMax    VMin             r                  # LSBs
        278         283     279   max[|278-283|,|278-279|]=5      4

      So the field is encoded using 4 bits.  Actual encoded value is the
   4 LSBs of 278 (10010110) which = 0110.

      If we assume the new value is a potential reference, the new VSW
   is {283, 290, 278}.

      In any case, the VLE encoded fields must be accompanied by some
   bits in order to identify the different possible encoded field sizes.
   Sizes of this bit field can vary depending on the number of different
   sizes one wishes to allow.  The approach in ACE is to allow only a
   few different sizes for byte-aligned header formats.  Huffman coding
   of the length is used to achieve some additional efficiency, based on
   the expected frequency of needing the different sizes.  1 or 2
   additional bits are actually sent in the ACE compressed header.

      The decompressor behavior in all the example cases is the same- it
   uses as a reference a specific decompressed header field value.  The
   header to use might be indicated by the presence of a checksum in the
   compressed header packet, or by other means.  They must by definition
   be one of the values in the compressor's window.

      For example let's assume that the last correctly decompressed
   packet which qualifies as a reference was the packet with header
   field = 291.  Now suppose the encoded field value of 303 (10001111)
   is received and = 01111.  The two values closest values to 291 which
   have LSBs = 01111 are 271 and 303.  303 is closest, therefore it is
   correctly selected as the uncompressed field value.

E.2.  Timer-Based VLE



      As a an example of operation, consider the case of a voice codec
   (20 ms), such that TS_stride = 160.  Assume T_current and
   p_TS_current are 357 and 351, respectively, and that we have sliding
   window TSW which contains the following values 4 entries:

           j           T_j         p_TS_j

           1            9            7



Bormann (ed.)                                                 [Page 130]

INTERNET-DRAFT          Robust Header Compression           Oct 03, 2000


           2            8            6
           3            7            4
           4            3            1

      j above is the packet number.

      In this case we have

      Network_jitter(1)=|(357-9)-(351-7)|=4 (80 ms Network Jitter)
      Network_jitter(2)=|(357-8)-(351-6)|=4  (80 ms Network Jitter)
      Network_jitter(3)=|(357-7)-(351-4)|=3 (60 ms Network Jitter)
      Network_jitter(4)=|(357-3)-(351-1)|=4  (80 ms Network Jitter)

      So Max_Network_Jitter = 4.

      We assume a maximum CD-CC jitter of 2 (40 ms); the total jitter to
   be handled in this case is then

           J = 4 + 2 + 2 = 8 packets (160 ms)

      and k = 5 bits (since 2 * 5 + 1 < 2^5).  The compressor sends the
   5 LSBs of p_TS_current to the decompressor (351 = 101011111, so the
   encoded TS value = 11111).

      When the decompressor receives this value, it first attempts to
   estimate the timestamp by computing the time difference between the
   last reference established and the current packet

            T_current - T_ref, where T_ref is the value of the wall
   clock time at which the reference headers was received by the
   decompressor


      That value is added to p_TS_ref, the packed RTP TS of the
   reference header, to get the estimate.

      Assume that at the decompressor packet #3 is used as the
   reference:


           - T_current = 359
           - T_ref = 7
           - p_TS_ref = 4

      Note:

      T_current is picked here as any value; the difference between it
   and T_ref represents the length of the silence interval as observed
   at the decompressor.  Then:

           T_current - T_ref = 359 - 7 = 352



Bormann (ed.)                                                 [Page 131]

INTERNET-DRAFT          Robust Header Compression           Oct 03, 2000


           p_TS_current(estimate) = 352 + 4 = 356


      The decompressor searches for the closest value to 356 which has,
   in this case, LSBs = 11111.  The value in this case is 351, the
   original p_TS.


      If instead the compressor were to send the timestamp jump as
   simply the difference in consecutive packed RTP Timestamps, that
   value would be

      p_TS_current - p_TS_ref = 351-4 = 347 = 101011011

      So over twice as many bits would be sent for a silence interval of

           347 (20 ms) = 6.94 seconds

      Due to basic conversational real-time requirements, the cumulative
   jitter in normal operation is expected to be at most only a few times
   T stride for voice.  For this reason, the FO payload formats in
   section 4.3 are optimized (in terms of representing different k-
   length encoded TS values) for the case of k=4 (handles up to 16
   discrepencies in the timestamp).  The remaining formats allow a wide
   range of jitter conditions (outside of just voice) to be handled as
   well.
























   This Internet-Draft expires April 02, 2001.



