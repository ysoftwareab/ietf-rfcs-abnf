alpha_p=0.8.  The inverse of the pre-emphasis is applied at the
fl=sum(f(i),i<k), fh=fl+f(i), and ft=sum(f(i)).
g_a = N / (N + 2*K*(K+1)),

y0 = round_towards_zero( (K-1) * R / sum(abs(R)))

J = -R^T*y / ||y||

J = -g_f * R^T*y + (g_f)^2 * ||y||^2

S=L-R and no longer have unit norm.

imid = bitexact_cos(itheta);

iside = bitexact_cos(16384-itheta);

delta = (N-1)*(log2_frac(iside,6)-log2_frac(imid,6))>>2;

qalloc = log2_frac((1<<qb)+1,4);

mbits = (b-qalloc/2-delta)/2;

CC = gcc
CFLAGS = -c -O2 -g
LIBS = -lm

OBJS = bands.o celt.o cwrs.o entcode.o entdec.o entenc.o kiss_fft.o \
           kiss_fftr.o laplace.o mdct.o modes.o pitch.o psy.o \
           quant_bands.o rangedec.o rangeenc.o rate.o testcelt.o vq.o

rate = atoi(argv[1]);
channels = atoi(argv[2]);
frame_size = atoi(argv[3]);
mode = celt_mode_create(rate, channels, frame_size, NULL);
bytes_per_packet = atoi(argv[4]);
inFile = argv[argc - 2];
fin = fopen(inFile, "rb");
outFile = argv[argc - 1];
fout = fopen(outFile, "wb+");
enc = celt_encoder_create(mode);
dec = celt_decoder_create(mode);

complexity = atoi(argv[5]);
in = (celt_int16_t *) malloc(frame_size * channels *
                                  sizeof(celt_int16_t));
out =
         (celt_int16_t *) malloc(frame_size * channels *
                                 sizeof(celt_int16_t));
len = celt_encode(enc, in, in, data, bytes_per_packet);
skip = 0;
rmsd = sqrt(rmsd / (1.0 * frame_size * channels * count));
N = mode->mdctSize;
C = mode->nbChannels;
st = celt_alloc(sizeof(CELTEncoder));

x = x * CELT_SIG_SCALE;
x = MAX32(x, -32768);
x = MIN32(x, 32767);
n = -1;
n = i;
n = -1;
ratio = 0;
ratio = ((begin[len - 1]) / (1 + begin[n - 16]));
ratio = 0;
ratio = 1000;
N4 = (N - overlap) >> 1;
flag_bits = flaglist[i] & 0xf;
flag_bits = ec_dec_bits(dec, 2);
flag_bits = (flag_bits << 2) | ec_dec_bits(dec, 2);
flag_bits = (flag_bits << 1) | ec_dec_bits(dec, 1);
N = st->block_size;
N4 = (N - st->overlap) >> 1;
transient_time = -1;
transient_shift = 0;
shortBlocks = 0;

gain_1 = 1. / (1 << transient_shift);
shortBlocks = 1;
has_fold = 1;
m = 0;
m = 0;
mdct_weight_shift = 2;
mdct_weight_pos = m;
mdct_weight_shift = 1;
mdct_weight_pos = m;
intra_ener = st->force_intra || (st->delayedIntra
                                   && nbCompressedBytes >
                                   st->mode->nbEBands);
has_pitch = st->pitch_enabled && st->pitch_permitted
      && (st->pitch_available >= MAX_PERIOD) && (!shortBlocks)
      && !intra_ener;
has_fold = 0;
pitch_power = 0;
pitch_power = bandEp[0] + bandEp[1] + bandEp[2];
curr_power = bandE[0] + bandE[1] + bandE[2];
has_pitch = compute_pitch_gain(st->mode, X, P, gains);
has_pitch = 0;
coarse_needed =
      quant_coarse_energy(st->mode, bandLogE, st->oldBandE,
                          nbCompressedBytes * 8 / 3, intra_ener,
                          st->mode->prob, error, &enc);
coarse_needed = ((coarse_needed * 3 - 1) >> 3) + 1;

target = target - 588 + ec_enc_tell(&enc, 4);

target = IMAX(coarse_needed, (target + 64) / 128);
nbCompressedBytes = IMIN(nbCompressedBytes, target);
bits = nbCompressedBytes * 8 - ec_enc_tell(&enc, 0) - 1;
C = CHANNELS(st->mode);
N = st->block_size;
ret =
        celt_encode_float(st, in, in, compressed, nbCompressedBytes);
ret =
        celt_encode_float(st, in, NULL, compressed,
                          nbCompressedBytes);
value = 3072000;
N = mode->mdctSize;
C = CHANNELS(mode);
st = celt_alloc(sizeof(CELTDecoder));

N = st->block_size;
len = N + st->mode->overlap;

pitch_index = MAX_PERIOD - len - pitch_index;
offset = MAX_PERIOD - pitch_index;
N = st->block_size;
N4 = (N - st->overlap) >> 1;

transient_shift = ec_dec_bits(&dec, 2);
transient_time = ec_dec_uint(&dec, N + st->mode->overlap);
mdct_weight_shift = transient_shift;
mdct_weight_pos =
            ec_dec_uint(&dec, st->mode->nbShortMdcts - 1);
transient_shift = 0;
transient_time = 0;
transient_time = -1;
transient_shift = 0;
pitch_index = ec_dec_uint(&dec, MAX_PERIOD - (2 * N - 2 * N4));
pitch_index = 0;
bits = len * 8 - ec_dec_tell(&dec, 0) - 1;
C = CHANNELS(st->mode);
N = st->block_size;
ret = celt_decode_float(st, data, len, out);

res = (Fs + frame_size) / (2 * frame_size);
min_width = MIN_BINS * res;

low = ((bark_freq[lin] / res) + (MIN_BINS - 1)) / MIN_BINS;
high = nBark - lin;
eBands = celt_alloc(sizeof(celt_int16_t) * (*nbEBands + 2));

pBands = celt_alloc(sizeof(celt_int16_t) * (PBANDS + 2));
allocVectors =
      celt_alloc(sizeof(celt_int16_t) *
                 (BITALLOC_SIZE * mode->nbEBands));
edge = mode->eBands[eband + 1] * res;
alloc = band_allocation[i * BARK_BANDS + j];
alloc = alloc * C * mode->mdctSize;
num = alloc * (edge - bark_freq[j]);
den = bark_freq[j + 1] - bark_freq[j];
low = (num + den / 2) / den;
current = 0;
res = (Fs + frame_size) / (2 * frame_size);

mode = celt_alloc(sizeof(CELTMode));
window = (float *) celt_alloc(mode->overlap * sizeof(float));
prevPtr = mode->bits[i];
N = FRAMESIZE(m);
N = FRAMESIZE(m);
i = 0;
N = FRAMESIZE(m);
j = eBands[i];
Sxx = 0;
Sxy = ((Sxy) + (X[j]) * (P[j]));
Sxx = ((Sxx) + (X[j]) * (X[j]));
Sxy = (Sxy);
Sxx = (Sxx);
Sxy = 0;
Sxy = Sxx;
Sxy = (((.99f)) * (Sxy));
a1 = (.70711f);
a2 = dir * (.70711f);
left = (bank[i]);
right = (bank[i + m->nbEBands]);
norm =
           1e-15f + celt_sqrt(1e-15f + ((left) * (left)) +
                              ((right) * (right)));
a1 = ((((left))) / (norm));
a2 = dir * ((((right))) / (norm));
l = X[j * C];
r = X[j * C + 1];
N = eBands[i + 1] - eBands[i];
max_val = ABS16(x[j]);
max_i = j;
floor_ener = (1.) - ((max_val) * (max_val));
floor_ener = MAX32(floor_ener, 1e-15f);

den = MAX32((.02), den);
r = ((((max_val))) / (den));
ratio = ((ratio) + ((r)));
ratio = ((ratio) / (NR));
ratio = (((.5f * (ratio))) + ((.5f * (*average))));
B = shortBlocks ? m->nbShortMdcts : 1;
norm = _norm;

balance = 0;
N = eBands[i + 1] - eBands[i];
BPbits = m->bits;

tell = ec_enc_tell(enc, 4);
remaining_bits = (total_bits << BITRES) - tell - 1;
curr_balance = (m->nbEBands - i);
curr_balance = 3;
curr_balance = balance / curr_balance;
q = bits2pulses(m, BPbits[i], N, pulses[i] + curr_balance);
curr_bits = pulses2bits(BPbits[i], N, q);
curr_bits = pulses2bits(BPbits[i], N, q);
n = (celt_sqrt(eBands[i + 1] - eBands[i]));

enabled = pgains[pband] > (.5);
B = shortBlocks ? m->nbShortMdcts : 1;
norm = _norm;

balance = 0;
BPbits = m->bits;

N = eBands[i + 1] - eBands[i];
tell = ec_enc_tell(enc, 4);
remaining_bits = (total_bits << BITRES) - tell - 1;
curr_balance = (m->nbEBands - i);
curr_balance = 3;
curr_balance = balance / curr_balance;
b = IMIN(remaining_bits + 1, pulses[i] + curr_balance);
b = 0;

q1 = bits2pulses(m, BPbits[i], N, b / 2);
curr_bits = 2 * pulses2bits(BPbits[i], N, q1);
curr_bits = 2 * pulses2bits(BPbits[i], N, q1);
n = (celt_sqrt((eBands[i + 1] - eBands[i])));

enabled = pgains[pband] > (.5);
qb = (b -
               2 * (N - 1) * (40 - log2_frac(N, 4))) / (32 * (N - 1));
qb = (b >> BITRES) - 1;
qb = 0;
qb = 14;

mid = renormalise_vector(X + C * eBands[i], 1.0f, N, C);
side = renormalise_vector(X + C * eBands[i] + 1, 1.0f, N, C);

itheta = floor(.5 + 16384 * 0.63662 * atan2(side, mid));

qalloc = log2_frac((1 << qb) + 1, 4);
itheta = 0;
shift = 14 - qb;
itheta = (itheta + (1 << shift >> 1)) >> shift;
imid = 32767;
iside = 0;
delta = -10000;
imid = 0;
iside = 32767;
delta = 10000;
imid = bitexact_cos(itheta);
iside = bitexact_cos(16384 - itheta);
delta =
               (N - 1) * (log2_frac(iside, 6) -
                          log2_frac(imid, 6)) >> 2;
mbits = (b - qalloc / 2 - delta) / 2;
mbits = b - qalloc;
mbits = 0;
sbits = b - qalloc - mbits;
q1 = bits2pulses(m, BPbits[i], N, mbits);
q2 = bits2pulses(m, BPbits[i], N, sbits);
curr_bits =
             pulses2bits(BPbits[i], N, q1) + pulses2bits(BPbits[i], N,
                                                         q2) + qalloc;
curr_bits =
                 pulses2bits(BPbits[i], N, q1) + pulses2bits(BPbits[i],
                                                             N,
                                                             q2) +
                 qalloc;
curr_bits =
                 pulses2bits(BPbits[i], N, q1) + pulses2bits(BPbits[i],
                                                             N,
                                                             q2) +
                 qalloc;
n = (celt_sqrt((eBands[i + 1] - eBands[i])));

enabled = pgains[pband] > (.5);
mid = (1. / 32768) * imid;
side = (1. / 32768) * iside;
B = shortBlocks ? m->nbShortMdcts : 1;
norm = _norm;

balance = 0;
N = eBands[i + 1] - eBands[i];
BPbits = m->bits;

tell = ec_dec_tell(dec, 4);
remaining_bits = (total_bits << BITRES) - tell - 1;
curr_balance = (m->nbEBands - i);
curr_balance = 3;
curr_balance = balance / curr_balance;
q = bits2pulses(m, BPbits[i], N, pulses[i] + curr_balance);
curr_bits = pulses2bits(BPbits[i], N, q);
curr_bits = pulses2bits(BPbits[i], N, q);
n = (celt_sqrt(eBands[i + 1] - eBands[i]));

enabled = ec_dec_bits(dec, 1);
B = shortBlocks ? m->nbShortMdcts : 1;
norm = _norm;

balance = 0;
BPbits = m->bits;

N = eBands[i + 1] - eBands[i];
tell = ec_dec_tell(dec, 4);
remaining_bits = (total_bits << BITRES) - tell - 1;
curr_balance = (m->nbEBands - i);
curr_balance = 3;
curr_balance = balance / curr_balance;
b = IMIN(remaining_bits + 1, pulses[i] + curr_balance);
b = 0;

q1 = bits2pulses(m, BPbits[i], N, b / 2);
curr_bits = 2 * pulses2bits(BPbits[i], N, q1);
curr_bits = 2 * pulses2bits(BPbits[i], N, q1);
n = (celt_sqrt((eBands[i + 1] - eBands[i])));

enabled = ec_dec_bits(dec, 1);
qb = (b -
               2 * (N - 1) * (40 - log2_frac(N, 4))) / (32 * (N - 1));
qb = (b >> BITRES) - 1;
qb = 14;
qb = 0;
qalloc = log2_frac((1 << qb) + 1, 4);
itheta = 0;
shift = 14 - qb;
itheta = ec_dec_uint(dec, (1 << qb) + 1);
imid = 32767;
iside = 0;
delta = -10000;
imid = 0;
iside = 32767;
delta = 10000;
imid = bitexact_cos(itheta);
iside = bitexact_cos(16384 - itheta);
delta =
               (N - 1) * (log2_frac(iside, 6) -
                          log2_frac(imid, 6)) >> 2;
mbits = (b - qalloc / 2 - delta) / 2;
mbits = b - qalloc;
mbits = 0;
sbits = b - qalloc - mbits;
q1 = bits2pulses(m, BPbits[i], N, mbits);
q2 = bits2pulses(m, BPbits[i], N, sbits);
curr_bits =
             pulses2bits(BPbits[i], N, q1) + pulses2bits(BPbits[i], N,
                                                         q2) + qalloc;
curr_bits =
                 pulses2bits(BPbits[i], N, q1) + pulses2bits(BPbits[i],
                                                             N,
                                                             q2) +
                 qalloc;
curr_bits =
                 pulses2bits(BPbits[i], N, q1) + pulses2bits(BPbits[i],
                                                             N,
                                                             q2) +
                 qalloc;
n = (celt_sqrt((eBands[i + 1] - eBands[i])));

enabled = ec_dec_bits(dec, 1);
mid = (1. / 32768) * imid;
side = (1. / 32768) * iside;

l = EC_ILOG(val);
val =
          (val >> l - 16) + ((val & (1 << l - 16) - 1) +
                             (1 << l - 16) - 1 >> l - 16);
l = l - 1 << frac;
b = (int) (val >> 16);
val = val + b >> b;
val = val * val + 0x7FFF >> 15;
shift = EC_ILOG(_d ^ _d - 1);
inv = INV_TABLE[_d - 1 >> shift];
one = 1 << shift;
mask = one - 1;
g = 0;
bshift = EC_ILOG(_val) - 1 >> 1;
b = 1U << bshift;
t = ((celt_uint32_t) g << 1) + b << bshift;
N=0 or K=0. This allows us to construct a row of one of the tables
volume="IT-32", number=4, pages="568--583", month=Jul, year=1986 } */

j = 1;
ui1 = ((((_ui[j]) + (_ui[j - 1]))) + (_ui0));
j = 1;
ui1 = ((((_ui[j]) - (_ui[j - 1]))) - (_ui0));
len = _k + 2;
k = 2;
s = -(int) _i;
p = ucwrs2(_k + 1U);
s = -(_i >= p);
yj = _k;
p = ucwrs2(_k);
p = ucwrs3(_k + 1U);
s = -(_i >= p);
yj = _k;
p = ucwrs3(_k);
p = ucwrs4(_k + 1);
s = -(_i >= p);
yj = _k;
kl = 0;
kr = _k;
p = ucwrs4(_k);
kl = _k + 1;
kr = _k - 1;
p = ucwrs5(_k + 1);
s = -(_i >= p);
yj = _k;

p = ucwrs5(_k);
kl = _k + 1;
kr = _k - 1;
j = 0;
p = _u[_k + 1];
s = -(_i >= p);
yj = _k;
p = _u[_k];
p = _u[--_k];
i = icwrs1(_y + 1, &k);
i = icwrs2(_y + 1, &k);
i = icwrs3(_y + 1, &k);
i = icwrs4(_y + 1, &k);
i = icwrs1(_y + _n - 1, &k);
j = _n - 2;
worst_bits = 0;
split_bits = _left_bits[i] + _right_bits[k - i];
worst_bits = split_bits;
tmp2 = get_required_bits_pair(_tmp, _bits1, _bits2,
                                    _n2 >> 1, _n2 >> 1, _maxk,
                                    _frac);
tmp2 = get_required_bits_pair(_tmp, _bits1, _bits2,
                                  _n2 >> 1, _n2 + 1 >> 1, _maxk,
                                  _frac);
n2bits = get_required_bits_pair(n1bits, n2bits_buf, _bits,
                                    _n >> 1, _n + 1 >> 1, _maxk,
                                    _frac);
i = icwrs1(_y, &_k);
i = icwrs2(_y, &_k);
i = icwrs3(_y, &_k);
i = icwrs4(_y, &_k);
i = icwrs5(_y, &_k);
i = icwrs(_n, _k, &nc, _y, u);
split = (N + 1) / 2;
split = (N + 1) / 2;
Rpp = 0;
i = 0;
Rpp = ((Rpp) + (P[i]) * (P[i]));
Ryp = 0;
Ryy = 0;
i = 0;
Ryp = ((Ryp) + (y[i]) * (P[i]));
Ryy = ((Ryy) + (y[i]) * (y[i]));
ryp = (Ryp);
ryy = (Ryy);
rpp = (Rpp);
g = ((celt_sqrt(((Ryy) + (ryp) * (ryp)) - ((ryy) * (rpp))) -
        ryp) * (celt_rcp((Ryy))));

i = 0;
N_1 = 512 / N;

sum = 0;
j = 0;
sum = ((sum) + (P[j]) * (P[j]));
Rpp = (sum);

xy = yy = yp = 0;

pulsesLeft = K;

sum = 0;
j = 0;
j = 1;
sum = (1.f);
rcp = (((K - 1) * (celt_rcp(sum))));
j = 0;
yy = ((yy) + (y[j]) * (y[j]));
xy = ((xy) + (X[j]) * (y[j]));
pulsesAtOnce = (pulsesLeft * N_1) >> 9;     /* pulsesLeft/N */
pulsesAtOnce = 1;

magnitude = (pulsesAtOnce);

best_id = 0;
yy = ((yy) + (magnitude) * (magnitude));
j = 0;
s = magnitude;
Rxy = ((((xy) + (s) * (X[j]))));
Ryy = ((((yy) + (s) * (y[j]))));

Rxy = ((Rxy) * (Rxy));
best_den = Ryy;
best_num = Rxy;
best_id = j;
j = best_id;
is = pulsesAtOnce;
s = (is);

xy = xy + ((s) * (X[j]));
yy = yy + ((s) * (y[j]));
yp = yp + ((s) * (P[j]));

yy = ((yy) + (magnitude) * (magnitude));
j = 0;
s = magnitude;
Rxy = (((xy) + (s) * (X[j])));
Ryy = (((yy) + (s) * (y[j])));
Ryp = (((yp) + (s) * (P[j])));

g = celt_psqrt(((Ryp) * (Ryp)) + ((Ryy) * ((1.f) - Rpp))) -
          Ryp;
num = g * (2 * Rxy - g);

best_den = Ryy;
best_num = num;
best_id = j;
j = 0;
E = ((E) + (*xptr) * (*xptr));
rE = celt_sqrt(E);

g = ((value) * (celt_rcp((rE))));
xptr = X;
offset = C*N0/16; offset -= offset % (C*B); if (offset < 0)
offset = 0; //printf ("%d\n", offset); id += offset; } */
pred_gain = 1.0f;
pred_gain =
        celt_div((float) ((1.f) * (N)),
                 (float) (N + 2 * K * (K + 1)));

n2 = lag >> 1;
L2 = len >> 1;
X = _X;

wptr = window;
Y = _Y;
yptr = &y[0];
yptr = &y[c];
Xptr = &X[2];
Yptr = &Y[2];
Xr = Xptr[0];
Xi = Xptr[1];

n = celt_rsqrt(1e-15f + curve[i]);
Xr = ((((n) * (Xr))));
Xi = ((((n) * (Xi))));

lo = 0;
hi = MAX_PULSES - 1;

lo = 127;
hi = 1024;
hi = pulses;
lo = pulses;
hi = 1024;
hi = pulses;
lo = pulses;
hi = mid;
lo = mid;
bits = log2_frac(((((pulses) * (pulses)) >> 1) + 1) >> 1, 4);
bits =
          log2_frac((((((pulses) * (pulses)) +
                       2) * (pulses))) / 3 << 3, 4);
bits = celt_alloc(m->nbEBands * sizeof(celt_int16_t *));
prevN = -1;
error = 1;
prevN = N;
prevPtr = bits[i];
bits = NULL;
lo = 0;
hi = 1 << BITRES;
psum = 0;
hi = mid;
lo = mid;
psum = 0;
left = (total << BITRES) - psum;
perband = left / len;
left = left - len * perband;
N = m->eBands[j + 1] - m->eBands[j];
d = C * N << BITRES;
offset = 50 - log2_frac(N, 4);
offset = bits[j] - offset * N * C;
offset = 0;
len = m->nbEBands;
lo = 0;
hi = m->nbAllocVectors - 1;
hi = mid;
lo = mid;
f = Fs * i * (1 / (2.f * len));
deriv =
        (8.288e-8 * f) / (3.4225e-16 * f * f * f * f + 1) +
        .009694 / (5.476e-7 * f * f + 1) + 1e-4;
mem = psd[0];
mem = psd[i];
mem = psd[len - 1];
mem = psd[i];
N = len >> 1;
N2 = N >> 1;
N = l->n;
N2 = N >> 1;
N4 = N >> 2;
wp1 = window;
wp2 = window + overlap - 1;
re = yp[0];
im = yp[1];
N = l->n;
N2 = N >> 1;
N4 = N >> 2;
re = fp[0];
im = fp[1];
x1 = *fp1--;
x2 = *fp2++;
ret = !!_v;
m = !!(_v & 0xFFFF0000) << 4;
m = !!(_v & 0xFF00) << 3;
m = !!(_v & 0xF0) << 2;
m = !!(_v & 0xC) << 1;
endbyte = _b->ptr - _b->buf;
endbyte = _b->ptr - _b->buf;
endbyte = _b->ptr - _b->buf;
fl = (unsigned) (_fl >> _ftb) & EC_UNIT_MASK;
ft = 1 << _ftb;
fl = (unsigned) _fl & ft - 1;
ftb = EC_ILOG(_ft);
ft = (_ft >> ftb) + 1;
fl = (unsigned) (_fl >> ftb);
endbyte = _b->ptr - _b->buf;
endbyte = _b->ptr - _b->buf;
endbyte = _b->ptr - _b->buf;
end = _b->buf + _b->storage;
t = 0;
s = ec_decode_bin(_this, EC_UNIT_BITS);
t = t << EC_UNIT_BITS | s;
ft = 1U << _ftb;
s = ec_decode_bin(_this, _ftb);
t = t << _ftb | s;
t = 0;
ftb = EC_ILOG(_ft);
ft = (unsigned) (_ft >> ftb) + 1;
s = ec_decode(_this, ft);
t = t << EC_UNIT_BITS | s;
t = t << ftb | ec_dec_bits(_this, ftb);
t = _ft;
s = ec_decode(_this, (unsigned) _ft);
t = t << ftb | s;
year=1979, address="Southampton", month=Jul } @ARTICLE{MNW98,
author="Alistair Moffat and Radford Neal and Ian H. Witten",
title="Arithmetic Coding Revisited", journal="{ACM} Transactions
pages="256--294", month=Jul,
URL="http://www.stanford.edu/class/ee398/handouts/papers/Moffat98Ari\
carry = _c >> EC_SYM_BITS;
sym = EC_SYM_MAX + carry & EC_SYM_MAX;
r = _this->rng / _ft;
r = _this->rng >> bits;
ft = (ec_uint32) 1 << bits;
nbits =
      (ec_byte_bytes(_this->buf) + (_this->rem >= 0) +
       _this->ext) * EC_SYM_BITS;
l = EC_ILOG(_this->rng);
r = _this->rng >> l - 16;
r = r * r >> 15;
b = (int) (r >> 16);
l = l << 1 | b;
end = EC_CODE_TOP;
msk = EC_CODE_TOP - 1;
end = _this->low + msk & ~msk | msk + 1;
end = end << EC_SYM_BITS & EC_CODE_TOP - 1;
month=Jul } @ARTICLE{MNW98, author="Alistair Moffat and Radford
journal="{ACM} Transactions on Information Systems", year=1998,
volume=16, number=3, pages="256--294", month=Jul,
URL="http://www.stanford.edu/class/ee398/handouts/papers/Moffat98Ari\
ret = ec_byte_read1(_this->buf);
ret = 0;
sym = _this->rem << EC_CODE_EXTRA & EC_SYM_MAX;
s = (unsigned) ((_this->dif - 1) / _this->nrm);
ft = (ec_uint32) 1 << bits;
s = (unsigned) ((_this->dif - 1) / _this->nrm);
s = ((_this->nrm) * ((_ft - _fh)));
nbits =
      (ec_byte_bytes(_this->buf) -
       (EC_CODE_BITS + EC_SYM_BITS - 1) / EC_SYM_BITS) * EC_SYM_BITS;
l = EC_ILOG(_this->rng);
r = _this->rng >> l - 16;
r = r * r >> 15;
b = (int) (r >> 16);
l = l << 1 | b;
s = 1;
val = -val;
ft = 32768;
fl = -fs;
tmp_l = fl;
tmp_s = fs;
fs = (fs * (ec_int32) decay) >> 14;
fs = 1;
fs = tmp_s;
fl = tmp_l;
fl = 0;
fl = 0;
ft = 32768;
fh = fs;
fm = ec_decode(dec, ft);
fl = fh;
fs = (fs * (ec_int32) decay) >> 14;
fs = 1;
val = -val;
dist = ((dist) + (d) * (d));
prob = celt_alloc(4 * m->nbEBands * sizeof(int));
coef = 0;
beta = (((.8f)) * (coef));

bits = ec_enc_tell(enc, 0);
c = 0;
x = eBands[i + c * m->nbEBands];

f = x - mean - coef * oldEBands[i + c * m->nbEBands] - prev[c];
qi = (int) floor(.5f + f);

bits_used = ec_enc_tell(enc, 0) - bits;
qi = -1;
q = qi * 1.f;

c = 0;
q2 = (int) floor((error[i + c * m->nbEBands] + .5f) * frac);

q2 = frac - 1;
offset =
           (q2 + .5f) * (1 << (14 - fine_quant[i])) * (1.f / 16384) -
           .5f;

c = 0;
q2 = error[i + c * m->nbEBands] < 0 ? 0 : 1;
offset =
             (q2 -
              .5f) * (1 << (14 - fine_quant[i] - 1)) * (1.f / 16384);

coef = 0;
beta = (((.8f)) * (coef));

bits = ec_dec_tell(dec, 0);
c = 0;
qi = -1;
qi = ec_laplace_decode_start(dec, prob[2 * i],
                                      prob[2 * i + 1]);
q = qi * 1.f;

c = 0;
q2 = ec_dec_bits(dec, fine_quant[i]);

offset =
           (q2 + .5f) * (1 << (14 - fine_quant[i])) * (1.f / 16384) -
           .5f;

c = 0;
q2 = ec_dec_bits(dec, 1);

offset =
             (q2 -
              .5f) * (1 << (14 - fine_quant[i] - 1)) * (1.f / 16384);

id = 0;
id = i;
max_corr = x[i];
id = 0;
id = i;
max_corr = x[i];
tmp = (4096 + ((celt_int32_t) (x) * (x))) >> 13;
tmp = 32767;
x2 = tmp;
x2 = (32767 - x2) + FRAC_MUL16(x2,
                                 (-7651 +
                                  FRAC_MUL16(x2,
                                             (8277 +
                                              FRAC_MUL16(-626,
                                                         x2)))));
x2 = 32766;
integer = (in.i >> 23) - 127;
frac = in.f - 1.5;
frac =
      -0.41446 + frac * (0.96093 +
                         frac * (-0.33981 + frac * 0.15600));
integer = floor(x);
frac = x - integer;
maxval = MAX16(maxval, ABS16(x[i]));
k = celt_ilog2(x) >> 1;
x = (x);
n = x - 32768;
rt = ((C[0]) +
        (((n) *
          (((C[1]) +
            (((n) *
              (((C[2]) +
                (((n) * (((C[3]) + (((n) * ((C[4])))))))))))))))));

rt = (rt);
k = (celt_ilog2(x) >> 1) - 7;
x = (x);
n = x - 32768;
rt = ((C[0]) +
        (((n) *
          (((C[1]) +
            (((n) *
              (((C[2]) +
                (((n) * (((C[3]) + (((n) * ((C[4])))))))))))))))));

rt = (rt);
k = (celt_ilog2(x) >> 1) - 7;
x = (x);
n = x - 32768;
rt = ((C[0]) +
        (((n) *
          (((C[1]) +
            (((n) *
              (((C[2]) +
                (((n) * (((C[3]) + (((n) * ((C[4])))))))))))))))));

rt = (rt);
x2 = ((x) * (x));
x = x & 0x0001ffff;
x = ((((1))) - (x));
i = celt_ilog2(x);
n = (x) - 32768 - 16384;
frac =
      ((C[0]) +
       (((n) *
         (((C[1]) + (((n) * (((C[2]) + (((n) * ((C[3])))))))))))));
K0 = 1 K1 = log(2) K2 = 3-4*log(2) K3 = 3*log(2) - 2 */
integer = (x);
frac = (x - (integer));
frac =
      ((D0) +
       (((frac) *
         (((D1) + (((frac) * (((D2) + (((D3) * (frac))))))))))));
i = celt_ilog2(x);
n = (x) - ((3));
frac =
      ((C[0]) +
       (((n) *
         (((C[1]) +
           (((n) *
             (((C[2]) +
               (((n) * (((C[3]) + (((n) * ((C[4])))))))))))))))));

arg = celt_div(((y)), x);
arg = 32767;
arg = celt_div(((x)), y);
arg = 32767;
Fout = Fout_beg + i * mm;
Fout2 = Fout + m;
tw1 = st->twiddles;
Fout = Fout_beg + i * mm;
Fout2 = Fout + m;
tw1 = st->twiddles;
Fout = Fout_beg + i * mm;
tw3 = tw2 = tw1 = st->twiddles;
Fout = Fout_beg + i * mm;
tw3 = tw2 = tw1 = st->twiddles;
epi3 = st->twiddles[fstride * m];

tw1 = tw2 = st->twiddles;
epi3 = st->twiddles[fstride * m];

tw1 = tw2 = st->twiddles;
ya = twiddles[fstride * m];
yb = twiddles[fstride * 2 * m];

Fout0 = Fout;
Fout1 = Fout0 + m;
Fout2 = Fout0 + 2 * m;
Fout3 = Fout0 + 3 * m;
Fout4 = Fout0 + 4 * m;

tw = st->twiddles;
ya = twiddles[fstride * m];
yb = twiddles[fstride * 2 * m];

Fout0 = Fout;
Fout1 = Fout0 + m;
Fout2 = Fout0 + 2 * m;
Fout3 = Fout0 + 3 * m;
Fout4 = Fout0 + 4 * m;

tw = st->twiddles;
k = u;
k = u;
k = u;
k = u;
Fout = Fout_beg + i * m2;
Fout = Fout_beg + i * m2;
Fout = Fout_beg + i * m2;
Fout = Fout_beg + i * m2;
Fout = Fout_beg + i * m2;
Fout = Fout_beg + i * m2;
p = 2;
p = 3;
p = n;                  /* no more factors, skip to end */
st = (kiss_fft_cfg) KISS_FFT_MALLOC(memneeded);
st = (kiss_fft_cfg) mem;
twiddle_size = nfft / 2 + 1;
memneeded =
         sizeof(struct kiss_fftr_state) + subsize +
         sizeof(kiss_twiddle_cpx) * twiddle_size;

st = (kiss_fftr_cfg) KISS_FFT_MALLOC(memneeded);
st = (kiss_fftr_cfg) mem;
ncfft = st->substate->nfft;

ncfft = st->substate->nfft;

k1 = st->substate->bitrev[k];
k2 = st->substate->bitrev[ncfft - k];
