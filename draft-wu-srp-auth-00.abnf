i = S[n-1] + 256 * S[n-2] + 256^2 * S[n-3] + ... + 256^(n-1) * S[0]

x = SHA(<salt> | SHA(<username> | ":" | <raw password>))
U = <username>              -->
                                    <--    s = <salt from passwd file>

a = random()
A = g^a % N                 -->
v = <stored password verifier>
b = random()
p = <raw password>
x = SHA(s | SHA(u | ":" | p))

S = (B - g^x) ^ (a + u * x) % N    S = (A * v^u) ^ b % N
K = SHA_Interleave(S)              K = SHA_Interleave(S)
        (this function is described
         in the next section)

   The client generates a random number, raises g to that power modulo
   the field prime, and sends the result to the host.  The host
   does the same thing and also adds the public verifier before
   sending it to the client.  Both sides then construct the shared
   session key based on the respective formulae.

   The parameter u is a 32-bit unsigned integer which takes its
   value from the first 32 bits of the SHA1 hash of B, MSB first.

   The client MUST abort authentication if B % N is zero.
 
   The host MUST abort the authentication attempt if A % N is
   zero.  The host MUST send B after receiving A from the client,
   never before.
 
   At this point, the client and server should have a common
   session key that is secure (i.e. not known to an outside party).
   To finish authentication, they must prove to each other that
   their keys are identical.

M = H(H(N) XOR H(g) | H(U) | s | A | B | K)
                                    -->
                                    <--    H(A | M | K)

E = T[0] | T[2] | T[4] | ...
F = T[1] | T[3] | T[5] | ...

G = SHA(E)
H = SHA(F)

result = G[0] | H[0] | G[1] | H[1] | ... | G[19] | H[19]

