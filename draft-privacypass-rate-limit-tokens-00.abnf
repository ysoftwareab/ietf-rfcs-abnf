Sec-Token-Origin = sf-binary

Sec-Token-Client = sf-binary

Sec-Token-Request-Blind = sf-binary
Sec-Token-Limit = sf-integer

nonce = random(32)
context = SHA256(challenge)
token_input = concat(0x0003, nonce, context, key_id)
accept = message/token-response
cache-control = no-cache, no-store
content-type = message/token-request
content-length = <Length of TokenRequest>
sec-token-origin = Anonymous Origin ID
sec-token-client = Client Key
sec-token-request-blind = request_blind

accept = message/token-response
cache-control = no-cache, no-store
content-type = message/token-request
content-length = <Length of TokenRequest>

blind_sig = rsabssa_blind_sign(skP, TokenRequest.blinded_msg)

content-type = message/token-response
content-length = <Length of blind_sig>
sec-token-origin = index_result
set-token-limit = Token limit

authenticator = rsabssa_finalize(pkI, token_input, blind_sig, blind_inv)

   If this succeeds, the Client then constructs a token as described in
   [AUTHSCHEME] as follows:

   struct {
       uint16_t token_type = 0x0003
       uint8_t nonce[32];
       uint8_t context[32];
       uint8_t token_key_id[Nid];
       uint8_t authenticator[Nk]
   } Token;

aad = concat(encode(1, keyID),
                encode(2, kemID),
                encode(2, kdfID),
                encode(2, aeadID),
                encode(2, token_type),
                encode(1, token_key_id),
                encode(Nk, blinded_msg),
                encode(49, request_key),
                encode(32, name_key_id))
ct = context.Seal(aad, pad(origin_name))
encrypted_origin_name = concat(enc, ct)

aad = concat(encode(1, keyID),
                encode(2, kemID),
                encode(2, kdfID),
                encode(2, aeadID),
                encode(2, token_type),
                encode(1, token_key_id),
                encode(Nk, blinded_msg),
                encode(49, request_key),
                encode(32, name_key_id))
sk_blind = ECDSA-KeyGen()
blinded_key = ECDSA-BlindPublicKey(pk_sign, sk_blind)
request_key = ECDSA-SerializePublicKey(blinded_key)
request_blind = ECDSA-SerializePrivatekey(sk_blind)

context = concat(0x0003, // token_type
                    token_key_id,
                    blinded_msg,
                    request_key,
                    name_key_id,
                    encrypted_origin_name)
request_signature = ECDSA-BlindKeySign(sk_sign, sk_blind, context)

blind_key = ECDSA-DeserializePublicKey(request_key)
sk_blind = ECDSA-DeserializePrivatekey(request_blind)
pk_blind = ECDSA-BlindPublicKey(pk_sign, sk_blind)
context = parse(request[..len(request)-96]) // this matches context computed during signing
valid = ECDSA-Verify(blind_key, context, request_signature)
blind_key = ECDSA-DeserializePublicKey(request_key)
context = parse(request[..len(request)-96]) // this matches context computed during signing
valid = ECDSA-Verify(blind_key, context, request_signature)
evaluated_key = ECDSA-BlindPublicKey(request_key, sk_origin)
index_key = ECDSA-SerializePublicKey(evaluated_key)

evaluated_key = ECDSA-DeserializePublicKey(request_key)
unblinded_key = ECDSA-UnblindPublicKey(evaluated_key, sk_blind)

index_result = ECDSA-SerializePublicKey(unblinded_key)
pk_encoded = ECDSA-SerializePublicKey(pk_sign)

anon_issuer_origin_id = HKDF-SHA384(secret=index_result,
salt=pk_encoded,
info="anon_issuer_origin_id")

