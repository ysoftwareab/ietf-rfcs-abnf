<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="en"><head><title>MPTCP Application Interface Considerations</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="description" content="MPTCP Application Interface Considerations">
<meta name="keywords" content="MPTCP, TCP">
<meta name="generator" content="xml2rfc v1.35 (http://xml.resource.org/)">
<meta name="viewport" content="width=600;" />
<style type='text/css'><!--
        body {
                font-family: verdana, charcoal, helvetica, arial, sans-serif;
                font-size: 85%;
		max-width: 60em; 
		color: #000; background-color: #FFF;
                margin: 2em;
        }
        h1, h2, h3, h4, h5, h6 {
                font-family: helvetica, monaco, "MS Sans Serif", arial, sans-serif;
                font-weight: bold; font-style: normal;
        }
        h1 { color: #900; background-color: transparent; text-align: right; }
        h3 { color: #333; background-color: transparent; }

        td.RFCbug {
                font-size: x-small; text-decoration: none;
                width: 30px; height: 30px; padding-top: 2px;
                text-align: justify; vertical-align: middle;
                background-color: #000;
        }
        td.RFCbug span.RFC {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: bold; color: #666;
        }
        td.RFCbug span.hotText {
                font-family: charcoal, monaco, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: normal; text-align: center; color: #FFF;
        }

        table.TOCbug { width: 30px; height: 15px; }
        td.TOCbug {
                text-align: center; width: 30px; height: 15px;
                color: #FFF; background-color: #900;
        }
        td.TOCbug a {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, sans-serif;
                font-weight: bold; font-size: x-small; text-decoration: none;
                color: #FFF; background-color: transparent;
        }

        td.header {
                font-family: arial, helvetica, sans-serif; font-size: x-small;
                vertical-align: top; width: 33%;
                color: #FFF; background-color: #666;
        }
        td.author { font-weight: bold; font-size: x-small; margin-left: 4em; }
        td.author-text { font-size: x-small; }

        /* info code from SantaKlauss at http://www.madaboutstyle.com/tooltip2.html */
        a.info {
                /* This is the key. */
                position: relative;
                z-index: 24;
                text-decoration: none;
        }
        a.info:hover {
                z-index: 25;
                color: #FFF; background-color: #900;
        }
        a.info span { display: none; }
        a.info:hover span.info {
                /* The span will display just on :hover state. */
                display: block;
                position: absolute;
                font-size: smaller;
                top: 2em; left: -5em; width: 15em;
                padding: 2px; border: 1px solid #333;
                color: #900; background-color: #EEE;
                text-align: left;
        }

        a { font-weight: bold; }
        a:link    { color: #900; background-color: transparent; }
        a:visited { color: #633; background-color: transparent; }
        a:active  { color: #633; background-color: transparent; }

        p { margin-left: 2em; margin-right: 2em; }
        p.copyright { font-size: x-small; }
        p.toc { font-size: 85%;
		max-width: 60em; 
		font-weight: bold; margin-left: 3em; }
        table.toc { margin: 0 0 0 3em; padding: 0; border: 0; vertical-align: text-top; }
        td.toc { font-size: 85%;
		max-width: 60em; 
		font-weight: bold; vertical-align: text-top; }

        ol.text { margin-left: 2em; margin-right: 2em; }
        ul.text { margin-left: 2em; margin-right: 2em; }
        li      { margin-left: 3em; }

        /* RFC-2629 <spanx>s and <artwork>s. */
        em     { font-style: italic; }
        strong { font-weight: bold; }
        dfn    { font-weight: bold; font-style: normal; }
        cite   { font-weight: normal; font-style: normal; }
        tt     { color: #036; }
        tt, pre, pre dfn, pre em, pre cite, pre span {
                font-family: "Courier New", Courier, monospace; font-size: small;
        }
        pre {
                text-align: left; padding: 4px;
                color: #000; background-color: #CCC;
        }
        pre dfn  { color: #900; }
        pre em   { color: #66F; background-color: #FFC; font-weight: normal; }
        pre .key { color: #33C; font-weight: bold; }
        pre .id  { color: #900; }
        pre .str { color: #000; background-color: #CFF; }
        pre .val { color: #066; }
        pre .rep { color: #909; }
        pre .oth { color: #000; background-color: #FCF; }
        pre .err { background-color: #FCC; }

        /* RFC-2629 <texttable>s. */
        table.all, table.full, table.headers, table.none {
                font-size: 85%;
		max-width: 60em; 
		text-align: center; border-width: 2px;
                vertical-align: top; border-collapse: collapse;
        }
        table.all, table.full { border-style: solid; border-color: black; }
        table.headers, table.none { border-style: none; }
        th {
                font-weight: bold; border-color: black;
                border-width: 2px 2px 3px 2px;
        }
        table.all th, table.full th { border-style: solid; }
        table.headers th { border-style: none none solid none; }
        table.none th { border-style: none; }
        table.all td {
                border-style: solid; border-color: #333;
                border-width: 1px 2px;
        }
        table.full td, table.headers td, table.none td { border-style: none; }

        hr { height: 1px; }
        hr.insert {
                width: 80%; border-style: none; border-width: 0;
                color: #CCC; background-color: #CCC;
        }
--></style>
</head>
<body>
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<table summary="layout" width="66%" border="0" cellpadding="0" cellspacing="0"><tr><td><table summary="layout" width="100%" border="0" cellpadding="2" cellspacing="1">
<tr><td class="header">Internet Engineering Task Force</td><td class="header">M. Scharf</td></tr>
<tr><td class="header">Internet-Draft</td><td class="header">Alcatel-Lucent Bell Labs</td></tr>
<tr><td class="header">Intended status: Informational</td><td class="header">A. Ford</td></tr>
<tr><td class="header">Expires: April 23, 2011</td><td class="header">Roke Manor Research</td></tr>
<tr><td class="header">&nbsp;</td><td class="header">October 20, 2010</td></tr>
</table></td></tr></table>
<h1><br />MPTCP Application Interface Considerations<br />draft-scharf-mptcp-api-03</h1>

<h3>Abstract</h3>

<p>Multipath TCP (MPTCP) adds the capability of using multiple
      paths to a regular TCP session. Even though it is designed to be
      totally backward compatible to applications, the data transport
      differs compared to regular TCP, and there are several
      additional degrees of freedom that applications may wish to
      exploit. This document summarizes the impact that MPTCP may have
      on applications, such as changes in performance.  Furthermore,
      it discusses compatibility issues of MPTCP in combination with
      non-MPTCP-aware applications. Finally, the document describes a basic
      application interface for MPTCP-aware applications that provides
      access to multipath address information and a level of control
      equivalent to regular TCP.
</p>
<h3>Status of This Memo</h3>
<p>
This Internet-Draft is submitted  in full
conformance with the provisions of BCP&nbsp;78 and BCP&nbsp;79.</p>
<p>
Internet-Drafts are working documents of the Internet Engineering
Task Force (IETF).  Note that other groups may also distribute
working documents as Internet-Drafts.  The list of current
Internet-Drafts is at http://datatracker.ietf.org/drafts/current/.</p>
<p>
Internet-Drafts are draft documents valid for a maximum of six months
and may be updated, replaced, or obsoleted by other documents at any time.
It is inappropriate to use Internet-Drafts as reference material or to cite
them other than as &ldquo;work in progress.&rdquo;</p>
<p>
This Internet-Draft will expire on April 23, 2011.</p>

<h3>Copyright Notice</h3>
<p>
Copyright (c) 2010 IETF Trust and the persons identified as the
document authors.  All rights reserved.</p>
<p>
This document is subject to BCP 78 and the IETF Trust's Legal
Provisions Relating to IETF Documents
(http://trustee.ietf.org/license-info) in effect on the date of
publication of this document.  Please review these documents
carefully, as they describe your rights and restrictions with respect
to this document. Code Components extracted from this document must
include Simplified BSD License text as described in Section 4.e of
the Trust Legal Provisions and are provided without warranty as
described in the Simplified BSD License.</p>
<a name="toc"></a><br /><hr />
<h3>Table of Contents</h3>
<p class="toc">
<a href="#anchor1">1.</a>&nbsp;
Introduction<br />
<a href="#anchor2">2.</a>&nbsp;
Terminology<br />
<a href="#anchor3">3.</a>&nbsp;
Comparison of MPTCP and Regular TCP<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor4">3.1.</a>&nbsp;
Performance Impact<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor5">3.1.1.</a>&nbsp;
Throughput<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor6">3.1.2.</a>&nbsp;
Delay<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor7">3.1.3.</a>&nbsp;
Resilience<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor8">3.2.</a>&nbsp;
Potential Problems<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor9">3.2.1.</a>&nbsp;
Impact of Middleboxes<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor10">3.2.2.</a>&nbsp;
Outdated Implicit Assumptions<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor11">3.2.3.</a>&nbsp;
Security Implications<br />
<a href="#anchor12">4.</a>&nbsp;
Operation of MPTCP with Legacy Applications<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor13">4.1.</a>&nbsp;
Overview of the MPTCP Network Stack<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor14">4.2.</a>&nbsp;
Address Issues<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor15">4.2.1.</a>&nbsp;
Specification of Addresses by Applications<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor16">4.2.2.</a>&nbsp;
Querying of Addresses by Applications<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor17">4.3.</a>&nbsp;
Socket Option Issues<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor18">4.3.1.</a>&nbsp;
General Guideline<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor19">4.3.2.</a>&nbsp;
Disabling of the Nagle Algorithm<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor20">4.3.3.</a>&nbsp;
Buffer Sizing<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor21">4.3.4.</a>&nbsp;
Other Socket Options<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor22">4.4.</a>&nbsp;
Default Enabling of MPTCP<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor23">4.5.</a>&nbsp;
Summary of Advices to Application Developers<br />
<a href="#anchor24">5.</a>&nbsp;
Basic API for MPTCP-aware Applications<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor25">5.1.</a>&nbsp;
Design Considerations<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor26">5.2.</a>&nbsp;
Requirements on the Basic MPTCP API<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor27">5.3.</a>&nbsp;
Sockets Interface Extensions by the Basic MPTCP API<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor28">5.3.1.</a>&nbsp;
Overview<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor29">5.3.2.</a>&nbsp;
Enabling and Disabling of MPTCP<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor30">5.3.3.</a>&nbsp;
Binding MPTCP to Specified Addresses<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor31">5.3.4.</a>&nbsp;
Querying the MPTCP Subflow Addresses<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor32">5.3.5.</a>&nbsp;
Getting a Unique Connection Identifier<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor33">5.4.</a>&nbsp;
Usage Examples<br />
<a href="#anchor34">6.</a>&nbsp;
Other Compatibility Issues<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor35">6.1.</a>&nbsp;
Usage of the SCTP Socket API<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor36">6.2.</a>&nbsp;
Incompatibilities with other Multihoming Solutions<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor37">6.3.</a>&nbsp;
Interactions with DNS<br />
<a href="#anchor38">7.</a>&nbsp;
Security Considerations<br />
<a href="#anchor39">8.</a>&nbsp;
IANA Considerations<br />
<a href="#anchor40">9.</a>&nbsp;
Conclusion<br />
<a href="#anchor41">10.</a>&nbsp;
Acknowledgments<br />
<a href="#rfc.references1">11.</a>&nbsp;
References<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#rfc.references1">11.1.</a>&nbsp;
Normative References<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#rfc.references2">11.2.</a>&nbsp;
Informative References<br />
<a href="#anchor44">Appendix&nbsp;A.</a>&nbsp;
Requirements on a Future Advanced MPTCP API<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor45">A.1.</a>&nbsp;
Design Considerations<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor46">A.2.</a>&nbsp;
MPTCP Usage Scenarios and Application Requirements<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor47">A.3.</a>&nbsp;
Potential Requirements on an Advanced MPTCP API<br />
<a href="#anchor48">Appendix&nbsp;B.</a>&nbsp;
Change History of the Document<br />
</p>
<br clear="all" />

<a name="anchor1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1"></a><h3>1.&nbsp;
Introduction</h3>

<p>Multipath TCP adds the capability of using multiple
      paths to a regular TCP session <a class='info' href='#RFC0793'>[1]<span> (</span><span class='info'>Postel, J., &ldquo;Transmission Control Protocol,&rdquo; September&nbsp;1981.</span><span>)</span></a>. The
      motivations for this extension include increasing throughput,
      overall resource utilisation, and resilience to network failure,
      and these motivations are discussed, along with high-level
      design decisions, as part of the Multipath TCP architecture
      <a class='info' href='#I-D.ietf-mptcp-architecture'>[4]<span> (</span><span class='info'>Ford, A., Raiciu, C., Barre, S., and J. Iyengar, &ldquo;Architectural Guidelines for Multipath TCP Development,&rdquo; June&nbsp;2010.</span><span>)</span></a>. The MPTCP protocol
      <a class='info' href='#I-D.ietf-mptcp-multiaddressed'>[5]<span> (</span><span class='info'>Ford, A., Raiciu, C., and M. Handley, &ldquo;TCP Extensions for Multipath Operation with Multiple Addresses,&rdquo; July&nbsp;2010.</span><span>)</span></a> offers the same
      reliable, in-order, byte-stream transport as TCP, and is
      designed to be backward compatible with both applications and
      the network layer. It requires support inside the network stack
      of both endpoints.
</p>
<p>This document first presents the impacts that MPTCP may have
      on applications, such as performance changes compared to regular
      TCP. Second, it defines the interoperation of MPTCP and 
      applications that are unaware of the multipath transport.  MPTCP
      is designed to be usable without any application changes, but
      some compatibility issues have to be taken into account. Third,
      this memo specifies a basic Application Programming Interface
      (API) for MPTCP-aware applications. The API presented here is an
      extension to the regular TCP API to allow an MPTCP-aware 
      application the equivalent level of control and access to information
      of an MPTCP connection that would be possible with the standard
      TCP API on a regular TCP connection.
</p>
<p>An advanced API for MPTCP is outside the scope of this
      document. Such an advanced API could offer a more fine-grained
      control over multipath transport functions and policies. The
      appendix includes a brief, non-compulsory list of potential
      features of such an advanced API.
</p>
<p>The de facto standard API for TCP/IP applications is the
      "sockets" interface. This document defines experimental
      MPTCP-specific extensions, using additional socket
      options. It is up to the applications, high-level programming
      languages, or libraries to decide whether to use these optional
      extensions. For instance, an application may want to turn on or
      off the MPTCP mechanism for certain data transfers, or limit
      its use to certain interfaces. The syntax and semantics of
      the specification is in line with the Posix standard
      <a class='info' href='#POSIX'>[8]<span> (</span><span class='info'>, &ldquo;IEEE Std. 1003.1-2008 Standard for Information Technology --           Portable Operating System Interface (POSIX). Open Group           Technical Standard: Base Specifications, Issue 7, 2008.,&rdquo; .</span><span>)</span></a> as much as possible.
</p>
<p>There are also various related extensions of the sockets
      interface: <a class='info' href='#I-D.ietf-shim6-multihome-shim-api'>[12]<span> (</span><span class='info'>Komu, M., Bagnulo, M., Slavov, K., and S. Sugimoto, &ldquo;Socket Application Program Interface (API) for Multihoming Shim,&rdquo; February&nbsp;2010.</span><span>)</span></a>
      specifies sockets API extensions for a multihoming shim
      layer. The API enables interactions between applications and the
      multihoming shim layer for advanced locator management and for
      access to information about failure detection and path
      exploration. Experimental extensions to the sockets API are also
      defined for the Host Identity Protocol (HIP)
      <a class='info' href='#I-D.ietf-hip-native-api'>[13]<span> (</span><span class='info'>Komu, M. and T. Henderson, &ldquo;Basic Socket Interface Extensions for Host Identity Protocol (HIP),&rdquo; January&nbsp;2010.</span><span>)</span></a> in order to manage the
      bindings of identifiers and locator. Further related API
      extensions exist for IPv6 <a class='info' href='#RFC3542'>[10]<span> (</span><span class='info'>Stevens, W., Thomas, M., Nordmark, E., and T. Jinmei, &ldquo;Advanced Sockets Application Program Interface (API) for IPv6,&rdquo; May&nbsp;2003.</span><span>)</span></a>, Mobile IP
      <a class='info' href='#RFC4584'>[11]<span> (</span><span class='info'>Chakrabarti, S. and E. Nordmark, &ldquo;Extension to Sockets API for Mobile IPv6,&rdquo; July&nbsp;2006.</span><span>)</span></a>, and SCTP
      <a class='info' href='#I-D.ietf-tsvwg-sctpsocket'>[14]<span> (</span><span class='info'>Stewart, R., Poon, K., Tuexen, M., Yasevich, V., and P. Lei, &ldquo;Sockets API Extensions for Stream Control Transmission Protocol (SCTP),&rdquo; July&nbsp;2010.</span><span>)</span></a>. There can be
      interactions or incompatibilities of these APIs with MPTCP,
      which are discussed later in this document.
</p>
<p>Some network stack implementations, specially on mobile
      devices, have centralized connection managers or other
      higher-level APIs to solve multi-interface issues, as surveyed
      in <a class='info' href='#I-D.ietf-mif-current-practices'>[16]<span> (</span><span class='info'>Wasserman, M. and P. Seite, &ldquo;Current Practices for Multiple Interface Hosts,&rdquo; June&nbsp;2010.</span><span>)</span></a>. Their
      interaction with MPTCP is outside the scope of this note.
</p>
<p>The target readers of this document are application
      developers whose software may benefit
      significantly from MPTCP. This document also provides the
      necessary information for developers of MPTCP to implement the
      API in a TCP/IP network stack.
</p>
<a name="anchor2"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2"></a><h3>2.&nbsp;
Terminology</h3>

<p>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL
      NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and
      "OPTIONAL" in this document are to be interpreted as described
      in <a class='info' href='#RFC2119'>[3]<span> (</span><span class='info'>Bradner, S., &ldquo;Key words for use in RFCs to Indicate Requirement Levels,&rdquo; March&nbsp;1997.</span><span>)</span></a>.
</p>
<p>This document uses the terminology introduced in
      <a class='info' href='#I-D.ietf-mptcp-multiaddressed'>[5]<span> (</span><span class='info'>Ford, A., Raiciu, C., and M. Handley, &ldquo;TCP Extensions for Multipath Operation with Multiple Addresses,&rdquo; July&nbsp;2010.</span><span>)</span></a>.
</p>
<a name="anchor3"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3"></a><h3>3.&nbsp;
Comparison of MPTCP and Regular TCP</h3>

<p>This section discusses the impact that the use of MPTCP will
      have on applications, in comparison to what may be expected from
      the use of regular TCP.
</p>
<a name="anchor4"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.1"></a><h3>3.1.&nbsp;
Performance Impact</h3>

<p>One of the key goals of adding multipath capability to TCP
        is to improve the performance of a transport connection by
        load distribution over separate subflows across potentially
        disjoint paths. Furthermore, it is an explicit goal of MPTCP
        that it should not provide a worse performing connection that
        would have existed through the use of single-path
        TCP. A corresponding congestion control algorithm is described
        in <a class='info' href='#I-D.ietf-mptcp-congestion'>[7]<span> (</span><span class='info'>Raiciu, C., Handley, M., and D. Wischik, &ldquo;Coupled Multipath-Aware Congestion Control,&rdquo; July&nbsp;2010.</span><span>)</span></a>. The
        following sections summarize the performance impact of MPTCP
        as seen by an application.
</p>
<a name="anchor5"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.1.1"></a><h3>3.1.1.&nbsp;
Throughput</h3>

<p>The most obvious performance improvement that will be
          gained with the use of MPTCP is an increase in throughput,
          since MPTCP will pool more than one path (where available)
          between two endpoints. This will provide greater bandwidth
          for an application.  If there are shared bottlenecks between
          the flows, then the congestion control algorithms will
          ensure that load is evenly spread amongst regular and 
          multipath TCP sessions, so that no end user receives
          worse performance than single-path TCP.
</p>
<p>This performance increase additionally means that an MPTCP session could
          achieve throughput that is greater than the capacity of a
          single interface on the device. If any applications make
          assumptions about interfaces due to throughput (or vice
          versa), they must take this into account (although an MPTCP
          implementation must always respect an application's request 
          for a particular interface).
</p>
<p>The transport of MPTCP signaling information results in a
          small overhead. If multiple subflows share a same
          bottleneck, this overhead slightly reduces the capacity that
          is available for data transport. Yet, this potential
          reduction of throughput will be neglectible in many usage
          scenarios, and the protocol contains optimisations in its
          design so that this overhead is minimal.
</p>
<a name="anchor6"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.1.2"></a><h3>3.1.2.&nbsp;
Delay</h3>

<p>If the delays on the constituent subflows of an MPTCP
          connection differ, the jitter perceivable to an application
          may appear higher as the data is spread across the
          subflows. Although MPTCP will ensure in-order delivery to
          the application, the application must be able to cope with
          the data delivery being burstier than may be usual with
          single-path TCP. Since burstiness is commonplace on the
          Internet today, it is unlikely that applications will suffer
          from such an impact on the traffic profile, but application
          authors may wish to consider this in future development.
</p>
<p>In addition, applications that make round trip time (RTT)
          estimates at the application level may have some
          issues. Whilst the average delay calculated will be
          accurate, whether this is useful for an application will
          depend on what it requires this information for. If a new
          application wishes to derive such information, it should
          consider how multiple subflows may affect its measurements,
          and thus how it may wish to respond. In such a case, an 
          application may wish to express its scheduling preferences,
          as described later in this document.
</p>
<a name="anchor7"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.1.3"></a><h3>3.1.3.&nbsp;
Resilience</h3>

<p>The use of multiple subflows simultaneously means that,
          if one should fail, all traffic will move to the remaining
          subflow(s), and additionally any lost packets can be
          retransmitted on these subflows.
</p>
<p>Subflow failure may be caused by issues within the
          network, which an application would be unaware of, or
          interface failure on the node. An application may, under
          certain circumstances, be in a position to be aware of such
          failure (e.g. by radio signal strength, or simply an interface
          enabled flag), and so must not make assumptions of an MPTCP 
          flow's stablity based on this. An MPTCP implementation must never override an
          application's request for a given interface, however, so the
          cases where this issue may be applicable are limited.
</p>
<a name="anchor8"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.2"></a><h3>3.2.&nbsp;
Potential Problems</h3>

<a name="anchor9"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.2.1"></a><h3>3.2.1.&nbsp;
Impact of Middleboxes</h3>

<p>MPTCP has been designed in order to pass through the
          majority of middleboxes. Empirical evidence suggests that
          new TCP options can successfully be used on most paths in
          the Internet. Nevertheless some middleboxes may still refuse
          to pass MPTCP messages due to the presence of TCP options,
          or they may strip TCP options. If this is the case, MPTCP
          should fall back to regular TCP. Although this will not
          create a problem for the application (its communication will
          be set up either way), there may be additional (and indeed,
          user-perceivable) delay while the first handshake fails.
          A detailed discussion of the various fallback mechanisms,
          for failures occurring at different points in the connection,
          is presented in <a class='info' href='#I-D.ietf-mptcp-multiaddressed'>[5]<span> (</span><span class='info'>Ford, A., Raiciu, C., and M. Handley, &ldquo;TCP Extensions for Multipath Operation with Multiple Addresses,&rdquo; July&nbsp;2010.</span><span>)</span></a>.
</p>
<p>There may also be middleboxes that transparently change
          the length of content. If such middleboxes are present,
          MPTCP's reassembly of the byte stream in the receiver is
          difficult.  Still, MPTCP can detect such middleboxes and
          then fall back to regular TCP. An overview of the impact
          of middleboxes is presented in 
          <a class='info' href='#I-D.ietf-mptcp-architecture'>[4]<span> (</span><span class='info'>Ford, A., Raiciu, C., Barre, S., and J. Iyengar, &ldquo;Architectural Guidelines for Multipath TCP Development,&rdquo; June&nbsp;2010.</span><span>)</span></a> and MPTCP's
          mechanisms to work around these are presented and discussed
          in <a class='info' href='#I-D.ietf-mptcp-multiaddressed'>[5]<span> (</span><span class='info'>Ford, A., Raiciu, C., and M. Handley, &ldquo;TCP Extensions for Multipath Operation with Multiple Addresses,&rdquo; July&nbsp;2010.</span><span>)</span></a>.
</p>
<p>MPTCP can also have other unexpected implications. For
          instance, intrusion detection systems could be
          triggered. A full analysis of MPTCP's impact on such
          middleboxes is for further study after deployment
          experiments.
</p>
<a name="anchor10"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.2.2"></a><h3>3.2.2.&nbsp;
Outdated Implicit Assumptions</h3>

<p>In regular TCP, there is a one-to-one mapping of the 
          socket interface to a flow through a network. Since MPTCP can
          make use of multiple flows, applications cannot implicitly 
          rely on this one-to-one mapping any more. Applications that 
          require the transport along a single path can disable the use 
          of MPTCP as described later in this document. Examples include 
          monitoring tools that want to measure the available 
          bandwidth on a path, or routing protocols such as BGP
          that require the use of a specific link.
</p>
<a name="anchor11"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.2.3"></a><h3>3.2.3.&nbsp;
Security Implications</h3>

<p>The support for multiple IP addresses within one MPTCP
         connection can result in additional security vulnerabilities,
         such as possibilities for attackers to hijack
         connections. The protocol design of MPTCP minimizes this
         risk.  An attacker on one of the paths can cause harm, but
         this is hardly an additional security risk compared to
         single-path TCP, which is vulnerable to man-in-the-middle
         attacks, too. A detailed thread analysis of MPTCP is
         published in <a class='info' href='#I-D.ietf-mptcp-threat'>[6]<span> (</span><span class='info'>Bagnulo, M., &ldquo;Threat Analysis for Multi-addressed/Multi-path TCP,&rdquo; October&nbsp;2010.</span><span>)</span></a>.
</p>
<a name="anchor12"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4"></a><h3>4.&nbsp;
Operation of MPTCP with Legacy Applications</h3>

<a name="anchor13"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.1"></a><h3>4.1.&nbsp;
Overview of the MPTCP Network Stack</h3>

<p>MPTCP is an extension of TCP, but it is designed to be
        backward compatible for legacy applications. TCP interacts
        with other parts of the network stack by different
        interfaces. The de facto standard API between TCP and
        applications is the sockets interface. The position of MPTCP
        in the protocol stack can be illustrated in 
        <a class='info' href='#fig_stack'>Figure&nbsp;1<span> (</span><span class='info'>MPTCP protocol stack</span><span>)</span></a>.
</p><br /><hr class="insert" />
<a name="fig_stack"></a>
<div style='display: table; width: 0; margin-left: auto; margin-right: auto'><pre>
     +-------------------------------+
     |           Application         |
     +-------------------------------+
            ^                 |
 ~~~~~~~~~~~|~Socket Interface|~~~~~~~~~~~
            |                 v
    +-------------------------------+
    |             MPTCP             |
    + - - - - - - - + - - - - - - - +
    | Subflow (TCP) | Subflow (TCP) |
    +-------------------------------+
    |       IP      |      IP       |
    +-------------------------------+
</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;1: MPTCP protocol stack&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>In general, MPTCP can affect all interfaces that make 
        assumptions about the coupling of a TCP connection to a single 
        IP address and TCP port pair, to one sockets endpoint, to one 
        network interface, or to a given path through the network.
</p>
<p>This means that there are two classes of applications:

          </p>
<ul class="text">
<li>Legacy applications: These applications are unaware of
            MPTCP and use the existing API towards TCP without any 
            changes. This is the default case.
</li>
<li>MPTCP-aware applications: These applications indicate
            support for an enhance MPTCP interface. This document
            specified a minimum set of API extensions for such
            applications.
</li>
</ul><p>

        In the following, it is discussed to which extent MPTCP
        affects legacy applications using the existing sockets
        API. The existing sockets API implies that applications deal
        with data structures that store, amongst others, the IP
        addresses and TCP port numbers of a TCP connection. A design
        objective of MPTCP is that legacy applications can continue to
        use the established sockets API without any changes. However,
        in MPTCP there is a one-to-many mapping between the socket
        endpoint and the subflows. This has several subtle
        implications for legacy applications using sockets API
        functions.
</p>
<a name="anchor14"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.2"></a><h3>4.2.&nbsp;
Address Issues</h3>

<a name="anchor15"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.2.1"></a><h3>4.2.1.&nbsp;
Specification of Addresses by Applications</h3>

<p>During binding, an application can either select a
          specific address, or bind to INADDR_ANY. Furthermore, on
          some systems other socket options (e.g., SO_BINDTODEVICE)
          can be used to bind to a specific interface. If an
          application uses a specific address or binds to a specific
          interface, then MPTCP MUST respect this and not interfere in
          the application's choices. If an application binds to
          INADDR_ANY, it is assumed that the application does not care
          which addresses to use locally. In this case, a local policy
          MAY allow MPTCP to automatically set up multiple subflows on
          such a connection.
</p>
<p>The basic sockets API of MPTCP-aware applications allows
          to express further preferences in an MPTCP-compatible way
          (e.g. bind to a subset of interfaces only).
</p>
<a name="anchor16"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.2.2"></a><h3>4.2.2.&nbsp;
Querying of Addresses by Applications</h3>

<p>Applications can use the getpeername() or getsockname()
          functions in order to retrieve the IP address of the peer or
          of the local socket. These functions can be used for various
          purposes, including security mechanisms, geo-location, or
          interface checks. The socket API was designed with an
          assumption that a socket is using just one address, and
          since this address is visible to the application, the
          application may assume that the information provided by the
          functions is the same during the lifetime of a
          connection. However, in MPTCP, unlike in TCP, there is a
          one-to-many mapping of a connection to subflows, and
          subflows can be added and removed while the connections
          continues to exist. Therefore, MPTCP cannot expose addresses
          by getpeername() or getsockname() that are both valid and
          constant during the connection's lifetime.
</p>
<p>This problem is addressed as follows: If used by a legacy
          application, the MPTCP stack MUST always return the
          addresses of the first subflow of an MPTCP connection, in
          all circumstances, even if that particular subflow is no
          longer in use.
</p>
<p>As this address may not be valid any more if the first
          subflow is closed, the MPTCP stack MAY close the whole MPTCP
          connection if the first subflow is closed (i.e. fate
          sharing between the initial subflow and the MPTCP connection
          as a whole). Whether to close the whole MPTCP connection by
          default SHOULD be controlled by a local policy. Further
          experiments are needed to investigate its implications.
</p>
<p>The functions getpeername() and getsockname() SHOULD also
          always return the addresses of the first subflow if the
          socket is used by an MPTCP-aware application, in order to be
          consistent with MPTCP-unaware applications, and, e. g., also
          with SCTP. Instead of getpeername() or getsockname(),
          MPTCP-aware applications can use new API calls, documented
          later, in order to retrieve the full list of address pairs
          for the subflows in use.
</p>
<a name="anchor17"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.3"></a><h3>4.3.&nbsp;
Socket Option Issues</h3>

<a name="anchor18"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.3.1"></a><h3>4.3.1.&nbsp;
General Guideline</h3>

<p>The existing sockets API includes options that modify the
          behavior of sockets and their underlying communications
          protocols. Various socket options exist on socket, TCP, and
          IP level. The value of an option can usually be set by the
          setsockopt() system function. The getsockopt() function gets
          information.  In general, the existing sockets interface
          functions cannot configure each MPTCP subflow
          individually. In order to be backward compatible, existing
          APIs therefore SHOULD apply to all subflows within one
          connection, as far as possible.
</p>
<a name="anchor19"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.3.2"></a><h3>4.3.2.&nbsp;
Disabling of the Nagle Algorithm</h3>

<p>One commonly used TCP socket option (TCP_NODELAY)
          disables the Nagle algorithm as described in
          <a class='info' href='#RFC1122'>[2]<span> (</span><span class='info'>Braden, R., &ldquo;Requirements for Internet Hosts - Communication Layers,&rdquo; October&nbsp;1989.</span><span>)</span></a>.  This option is also specified in
          the Posix standard <a class='info' href='#POSIX'>[8]<span> (</span><span class='info'>, &ldquo;IEEE Std. 1003.1-2008 Standard for Information Technology --           Portable Operating System Interface (POSIX). Open Group           Technical Standard: Base Specifications, Issue 7, 2008.,&rdquo; .</span><span>)</span></a>. Applications can
          use this option in combination with MPTCP exactly in the
          same way. It then SHOULD disable the Nagle algorithm for the MPTCP
          connection, i.e., all subflows.
</p>
<p>In addition, the MPTCP protocol instance MAY use a
          different path scheduler algorithm if TCP_NODELAY is
          present. For instance, it could use an algorithm that is
          optimized for latency-sensitive traffic. Specific
          algorithms are outside the scope of this document.
</p>
<a name="anchor20"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.3.3"></a><h3>4.3.3.&nbsp;
Buffer Sizing</h3>

<p>Applications can explicitly configure send and receive
          buffer sizes by the sockets API (SO_SNDBUF,
          SO_RCVBUF). These socket options can also be used in
          combination with MPTCP and then affect the buffer size of
          the MPTCP connection. However, when defining buffer sizes,
          application programmers should take into account that the
          transport over several subflows requires a certain amount of
          buffer for resequencing in the receiver.  MPTCP may also
          require more storage space in the sender, in particular, if
          retransmissions are sent over more than one path. In
          addition, very small send buffers may prevent MPTCP from
          efficiently scheduling data over different
          subflows. Therefore, it does not make sense to use MPTCP in
          combination with small send or receive buffers.
</p>
<p>An MPTCP implementation MAY set a lower bound for send
          and receive buffers and treat a small buffer size request as
          an implicit request not to use MPTCP.
</p>
<a name="anchor21"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.3.4"></a><h3>4.3.4.&nbsp;
Other Socket Options</h3>

<p>Some network stacks also provide other
          implementation-specific socket options or interfaces that
          affect TCP's behavior. If a network stack supports MPTCP, it
          must be ensured that these options do not interfere.
</p>
<a name="anchor22"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.4"></a><h3>4.4.&nbsp;
Default Enabling of MPTCP</h3>

<p>It is up to a local policy at the end system whether a
        network stack should automatically enable MPTCP for sockets
        even if there is no explicit sign of MPTCP awareness of the
        corresponding application. Such a choice may be under the
        control of the user through system preferences.
</p>
<p>The enabling of MPTCP, either by application or by system
        defaults, does not necessarily mean that MPTCP will always
        be used. Both endpoints must support MPTCP, and there must be
        multiple addresses at at least one endpoint, for MPTCP to be
        used. Even if those requirements are met, however, MPTCP may
        not be immediately used on a connection. It may make sense for
        multiple paths to be brought into operation only after a given
        period of time, or if the connection is saturated.
</p>
<a name="anchor23"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.5"></a><h3>4.5.&nbsp;
Summary of Advices to Application Developers</h3>

<p></p>
<ul class="text">
<li>Using the default MPTCP configuration: Like TCP, MPTCP is
          designed to be efficient and robust in the default
          configuration. Application developers should not explicitly
          configure TCP (or MPTCP) features unless this is really
          needed.
</li>
<li>Socker buffet dimensioning: Multipath transport requires
          larger buffers in the receiver for resequencing, as already
          explained. Applications should use reasonably buffer sizes
          (such as the operating system default values) in order to
          fully benefit from MPTCP. A full discussion of buffer sizing
          issues is given in <a class='info' href='#I-D.ietf-mptcp-multiaddressed'>[5]<span> (</span><span class='info'>Ford, A., Raiciu, C., and M. Handley, &ldquo;TCP Extensions for Multipath Operation with Multiple Addresses,&rdquo; July&nbsp;2010.</span><span>)</span></a>.
</li>
<li>Facilitating stack-internal heuristics: The path
          management and data scheduling by MPTCP is realized by
          stack-internal algorithms that may implicitly try to
          self-optimize their behavior according to assumed
          application needs. For instance, an MPTCP implementation may
          use heuristics to determine whether an application requires
          delay-sensitive or bulk data transport, using for instance
          port numbers, the TCP_NODELAY socket options, or the
          application's read/write patterns as input parameters. An
          application developer can facilitate the operation of such
          heuristics by avoiding atypical interface use cases. For
          instance, for long bulk data transfers, it does neither make
          sense to enable the TCP_NODELAY socket option, nor is it
          reasonable to use many small subsequent socket "send()"
          calls with small amounts of data only.
</li>
</ul>

<a name="anchor24"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5"></a><h3>5.&nbsp;
Basic API for MPTCP-aware Applications</h3>

<a name="anchor25"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.1"></a><h3>5.1.&nbsp;
Design Considerations</h3>

<p>While applications can use MPTCP with the unmodified
        sockets API, multipath transport results in many degrees of
        freedom.  MPTCP manages the data transport over different
        subflows automatically. By default, this is transparent to the
        application, but an application could use an additional API to
        interface with the MPTCP layer and to control important
        aspects of the MPTCP implementation's behaviour.
</p>
<p>This document describes a basic MPTCP API. The API uses
        non-mandatory socket options and only includes a minimum set
        of functions that provide an equivalent level of control and
        information as exists for regular TCP. It maintains backward 
        compatibility with legacy applications.
</p>
<p>An advanced MPTCP API is outside the scope of this
        document. The basic API does not allow a sender or a receiver
        to express preferences about the management of paths or the
        scheduling of data, even if this can have a significant
        performance impact and if an MPTCP implementation could
        benefit from additional guidance by applications. A list of
        potential further API extensions is provided in the
        appendix. The specification of such an advanced API is for
        further study and may partly be implementation-specific.
</p>
<p>MPTCP mainly affects the sending of data. Therefore, the
        basic API only affects the sender side of a data transfer. A
        receiver may also have preferences about data transfer
        choices, and it may have performance requirements, too. Yet,
        the signaling of the receiver's needs is outside of the scope
        of this document.
</p>
<p>As this document specifies sockets API extensions, it is
        written so that the syntax and semantics are in line with the
        Posix standard <a class='info' href='#POSIX'>[8]<span> (</span><span class='info'>, &ldquo;IEEE Std. 1003.1-2008 Standard for Information Technology --           Portable Operating System Interface (POSIX). Open Group           Technical Standard: Base Specifications, Issue 7, 2008.,&rdquo; .</span><span>)</span></a> as much as possible.
</p>
<a name="anchor26"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.2"></a><h3>5.2.&nbsp;
Requirements on the Basic MPTCP API</h3>

<p>Because of the importance of the sockets interface there
        are several fundamental design objectives for the basic
        interface between MPTCP and applications:

          </p>
<ul class="text">
<li>Consistency with existing sockets APIs must be
            maintained as far as possible. In order to support the
            large base of applications using the original API, a
            legacy application must be able to continue to use
            standard socket interface functions when run on a system
            supporting MPTCP. Also, MPTCP-aware applications should be
            able to access the socket without any major changes.
</li>
<li>Sockets API extensions must be minimized and independent
            of an implementation.
</li>
<li>The interface should both handle IPv4 and IPv6.
</li>
</ul><p>
        
</p>
<p>The following is a list of the core requirements for the
        basic API:
</p>
<p></p>
<blockquote class="text"><dl>
<dt>REQ1:</dt>
<dd>Turn on/off MPTCP: An application should be able to
          request to turn on or turn off the usage of MPTCP. This
          means that an application should be able to explicitly
          request the use of MPTCP if this is possible. Applications
          should also be able to request not to enable MPTCP and to
          use regular TCP transport instead. This can be implicit in
          many cases, since MPTCP must disabled by the use of binding
          to a specific address. MPTCP may also be enabled if an
          application uses a dedicated multipath address family (such
          as AF_MULTIPATH, <a class='info' href='#I-D.sarolahti-mptcp-af-multipath'>[9]<span> (</span><span class='info'>Sarolahti, P., &ldquo;Multi-address Interface in the Socket API,&rdquo; March&nbsp;2010.</span><span>)</span></a>).
</dd>
<dt>REQ2:</dt>
<dd>An application should be able to restrict MPTCP to
          binding to a given set of addresses.
</dd>
<dt>REQ3:</dt>
<dd>An application should be able obtain information on the
          addresses used by the MPTCP subflows.
</dd>
<dt>REQ4:</dt>
<dd>An application should be able to extract a unique
          identifier for the connection (per endpoint).
</dd>
</dl></blockquote>

<p>The first requirement is the most important one, since some
        applications could benefit a lot from MPTCP, but there are
        also cases in which it hardly makes sense. The existing
        sockets API provides similar mechanisms to enable or disable
        advanced TCP features. The second requirement corresponds to
        the binding of addresses with the bind() socket call, or,
        e.g., explicit device bindings with a SO_BINDTODEVICE
        option. The third requirement ensures that there is an
        equivalent to getpeername() or getsockname() that is able to
        deal with more than one subflow.  Finally, it should be
        possible for the application to retrieve a unique connection
        identifier (local to the endpoint on which it is running) for
        the MPTCP connection. This is equivalent to using the
        (address, port) pair for a connection identifier in single-path
        TCP, which is no longer static in MPTCP.
</p>
<p>An application can continue to use getpeername() or
        getsockname() in addition to the basic MPTCP API. In that
        case, both functions return the corresponding addresses of the
        first subflow, as already explained.
</p>
<a name="anchor27"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.3"></a><h3>5.3.&nbsp;
Sockets Interface Extensions by the Basic MPTCP API</h3>

<a name="anchor28"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.3.1"></a><h3>5.3.1.&nbsp;
Overview</h3>

<p>The basic MPTCP API consist of four new socket options
          that are specific to MPTCP.  All of these socket options are
          defined at TCP level (IPPROTO_TCP).

            </p>
<ul class="text">
<li>TCP_MULTIPATH_ENABLE: Enable/disable MPTCP
</li>
<li>TCP_MULTIPATH_BIND: Bind MPTCP to a set of given local
              addresses
</li>
<li>TCP_MULTIPATH_SUBFLOWS: Get the addresses currently used by
              the MPTCP subflows
</li>
<li>TCP_MULTIPATH_CONNID: Get the local connection identifier
              for this MPTCP connection
</li>
</ul><p>

          Table <a class='info' href='#tab_options'>Table&nbsp;1<span> (</span><span class='info'>Socket options for MPTCP</span><span>)</span></a> shows a list of the
          socket options for the general configuration of MPTCP.  The
          first column gives the name of the option. The second and
          third columns indicate whether the option can be handled by
          the getsockopt() system call and/or by the setsockopt()
          system call. The fourth column lists the type of data
          structure specified along with the socket option.
</p><br /><hr class="insert" />
<a name="tab_options"></a>
<table class="full" align="center" border="0" cellpadding="2" cellspacing="2">
<col align="left"><col align="center"><col align="center"><col align="center">
<tr><th align="left">Option name</th><th align="center">Get</th><th align="center">Set</th><th align="center">Data type</th></tr>
<tr>
<td align="left">TCP_MULTIPATH_ENABLE</td>
<td align="center">o</td>
<td align="center">o</td>
<td align="center">int</td>
</tr>
<tr>
<td align="left">TCP_MULTIPATH_BIND</td>
<td align="center">&nbsp;</td>
<td align="center">o</td>
<td align="center">list of "struct sockaddr"</td>
</tr>
<tr>
<td align="left">TCP_MULTIPATH_SUBFLOWS</td>
<td align="center">o</td>
<td align="center">&nbsp;</td>
<td align="center">list of pairs of "struct sockaddr"</td>
</tr>
<tr>
<td align="left">TCP_MULTIPATH_CONNID</td>
<td align="center">o</td>
<td align="center">&nbsp;</td>
<td align="center">uint32</td>
</tr>
</table>
<br clear="all" />
<table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Table 1: Socket options for MPTCP&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>There are restrictions when these new socket options can be used:

            </p>
<ul class="text">
<li>TCP_MULTIPATH_ENABLE: This option SHOULD only be set
              before the establishment of a TCP connection. Its value
              SHOULD only be read after the establishment of a
              connection.
</li>
<li>TCP_MULTIPATH_BIND: This option MAY be both applied
              before connection setup or during a connection. In the
              latter case, it allows MPTCP to use a new address, if
              there has been a restriction before connection setup.
</li>
<li>TCP_MULTIPATH_SUBFLOWS: This option is read-only and
              SHOULD only be used after connection setup.
</li>
<li>TCP_MULTIPATH_CONNID: This option is read-only and
              SHOULD only be used after connection setup.
</li>
</ul><p>

          
</p>
<a name="anchor29"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.3.2"></a><h3>5.3.2.&nbsp;
Enabling and Disabling of MPTCP</h3>

<p>An application can explicitly indicate multipath
          capability by setting the TCP_MULTIPATH_ENABLE option with a
          value larger than 0. In this case, the MPTCP implementation
          SHOULD try to negitiate MPTCP for that connection. Note that
          multipath transport will not necessarily be enabled, as it
          requires multiple addresses and support in the other
          end-system and potentially also on middleboxes.
</p>
<p>An application can disable MPTCP setting the option with
          a value of 0. In that case, MPTCP MUST NOT be used on that
          connection.
</p>
<p>After connection establishment, an application can get
          the value of the TCP_MULTIPATH_ENABLE option. A value of 0
          then means lack of MPTCP support. Any value equal to or 
          larger than 1 means that MPTCP is supported.
</p>
<p>As alternative to setting a socket option, an application
          can also use a new, separate address family called
          AF_MULTIPATH
          <a class='info' href='#I-D.sarolahti-mptcp-af-multipath'>[9]<span> (</span><span class='info'>Sarolahti, P., &ldquo;Multi-address Interface in the Socket API,&rdquo; March&nbsp;2010.</span><span>)</span></a>.  This
          separate address family can be used to exchange multiple
          addresses between an application and the standard sockets
          API, and additionally acts as an explicit indication that an
          application is MPTCP-aware, i.e., that it can deal with the
          semantic changes of the sockets API, in particular
          concerning getpeername() and getsockname(). The usage of
          AF_MULTIPATH is also more flexible with respect to multipath
          transport, either IPv4 or IPv6, or both in parallel
          <a class='info' href='#I-D.sarolahti-mptcp-af-multipath'>[9]<span> (</span><span class='info'>Sarolahti, P., &ldquo;Multi-address Interface in the Socket API,&rdquo; March&nbsp;2010.</span><span>)</span></a>.
</p>
<a name="anchor30"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.3.3"></a><h3>5.3.3.&nbsp;
Binding MPTCP to Specified Addresses</h3>

<p>An application can set the TCP_MULTIPATH_BIND socket
          option to announce a set of local IP addresses that MPTCP
          may bind to. The parameter of the option is a list of data
          structures of type "sockaddr". A MPTCP implementation must
          iterate over this list since the length of the structures
          may vary and will be deteremined by the address families.
          By extension, this option will also control the list of
          addresses that can be advertised to the peer via MPTCP
          signalling.
</p>
<p>If used during the lifetime of a connection, an application 
          MUST always provide the full list of addresses that MPTCP is 
          allowed to use. If the option is set, MPTCP MUST only establish 
          subflows using one of the addresses in that list as source
          addresses. MPTCP MUST also use the list as the only set of 
          addresses it can signal to its peer. It should be noted that 
          this signal is only a hint, and an MPTCP implementation may 
          only use a subset of the addresses.
</p>
<p>If an address is not present in the new list, MPTCP MUST
          close any corresponding subflows (i.e. those using the local
          address that is no longer present), and signal the removal
          of the address to the peer. If alternative paths are available
          using the supplied address list but MPTCP is not currently 
          using them, an MPTCP implementation SHOULD establish alternative 
          subflows before undertaking the address removal.
</p>
<p>TBD: If it is unreasonable or difficult for an application
          to keep track of addresses to provide full lists for every
          time TCP_MULTIPATH_BIND is set, we could also provide separate
          TCP_MULTIPATH_ADDR_ADD and TCP_MULTIPATH_ADDR_REMOVE options.
          Would this be preferable? (The ADD option would provide the
          same functionality as bind() before connection setup.)
</p>
<a name="anchor31"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.3.4"></a><h3>5.3.4.&nbsp;
Querying the MPTCP Subflow Addresses</h3>

<p>An application can get a list of the addresses used by
          the currently established subflows by means of the
          TCP_MULTIPATH_SUBFLOWS option, which cannot be set. The
          return value is a list of pairs of "sockaddr" data
          structures. In one pair, the first data structure refers to
          the local IP address and the second one to the remote IP
          address used by the subflow. The list MUST only include
          established subflows.
</p>
<p>The length of the data structure depends on the number of
          subflows, and so an application must iterate over the list
          for its length, determining the length of each "sockaddr" data
          structure by its address family.
</p>
<a name="anchor32"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.3.5"></a><h3>5.3.5.&nbsp;
Getting a Unique Connection Identifier</h3>

<p>An application that wants a unique identifier for the 
          connection, analogous to an (address, port) pair in regular
          TCP, can use the TCP_MULTIPATH_CONNID option to get a local
          connection identifier for the MPTCP connection.
</p>
<p>This is a 32-bit number, and SHOULD be the same as the 
          local connection identifier sent in the MPTCP handshake.
</p>
<a name="anchor33"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.4"></a><h3>5.4.&nbsp;
Usage Examples</h3>

<p>TODO: Example C code for the API functions
</p>
<a name="anchor34"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6"></a><h3>6.&nbsp;
Other Compatibility Issues</h3>

<a name="anchor35"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.1"></a><h3>6.1.&nbsp;
Usage of the SCTP Socket API</h3>

<p>For dealing with multi-homing, several socket API
        extensions have been defined for SCTP
        <a class='info' href='#I-D.ietf-tsvwg-sctpsocket'>[14]<span> (</span><span class='info'>Stewart, R., Poon, K., Tuexen, M., Yasevich, V., and P. Lei, &ldquo;Sockets API Extensions for Stream Control Transmission Protocol (SCTP),&rdquo; July&nbsp;2010.</span><span>)</span></a>. As MPTCP realizes
        multipath transport from and to multi-homed endsystems, some
        of these interface function calls are actually applicable to
        MPTCP in a similar way.
</p>
<p>The following functions that are defined for SCTP have similar 
        functionality to the MPTCP API extensions defined earlier:
</p>
<ul class="text">
<li>sctp_bindx()
</li>
<li>sctp_connectx()
</li>
<li>sctp_getladdrs()
</li>
<li>sctp_getpaddrs()
</li>
</ul>
<p>The syntax and semantics of these functions are described in
        <a class='info' href='#I-D.ietf-tsvwg-sctpsocket'>[14]<span> (</span><span class='info'>Stewart, R., Poon, K., Tuexen, M., Yasevich, V., and P. Lei, &ldquo;Sockets API Extensions for Stream Control Transmission Protocol (SCTP),&rdquo; July&nbsp;2010.</span><span>)</span></a>.
</p>
<p>API developers MAY wish to integrate SCTP and MPTCP calls to
        provide a consistent interface to the application.
        Yet, it must be emphasized that the transport
        service provided by MPTCP is different to SCTP, and this is
        why not all SCTP API functions can be mapped directly to
        MPTCP. Furthermore, a network stack implementing MPTCP does
        not necessarily support SCTP and its specific socket interface
        extensions. This is why the basic API of MPTCP defines
        additional socket options only, which are a backward
        compatible extension of TCP's application interface.
</p>
<a name="anchor36"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.2"></a><h3>6.2.&nbsp;
Incompatibilities with other Multihoming Solutions</h3>

<p>The use of MPTCP can interact with various related sockets
        API extensions. The use of a multihoming shim layer conflicts
        with multipath transport such as MPTCP or SCTP
        <a class='info' href='#I-D.ietf-shim6-multihome-shim-api'>[12]<span> (</span><span class='info'>Komu, M., Bagnulo, M., Slavov, K., and S. Sugimoto, &ldquo;Socket Application Program Interface (API) for Multihoming Shim,&rdquo; February&nbsp;2010.</span><span>)</span></a>. Care
        should be taken for the usage not to confuse with the
        overlapping features of other APIs:

          </p>
<ul class="text">
<li>SHIM API
            <a class='info' href='#I-D.ietf-shim6-multihome-shim-api'>[12]<span> (</span><span class='info'>Komu, M., Bagnulo, M., Slavov, K., and S. Sugimoto, &ldquo;Socket Application Program Interface (API) for Multihoming Shim,&rdquo; February&nbsp;2010.</span><span>)</span></a>: This
            API specifies sockets API extensions for the multihoming
            shim layer.
</li>
<li>HIP API <a class='info' href='#I-D.ietf-hip-native-api'>[13]<span> (</span><span class='info'>Komu, M. and T. Henderson, &ldquo;Basic Socket Interface Extensions for Host Identity Protocol (HIP),&rdquo; January&nbsp;2010.</span><span>)</span></a>: The
            Host Identity Protocol (HIP) also results in a new
            API.
</li>
<li>API for Mobile IPv6 <a class='info' href='#RFC4584'>[11]<span> (</span><span class='info'>Chakrabarti, S. and E. Nordmark, &ldquo;Extension to Sockets API for Mobile IPv6,&rdquo; July&nbsp;2006.</span><span>)</span></a>: For Mobile
            IPv6, a significantly extended socket API exists as well.
</li>
</ul><p>

        In order to avoid any conflict, multiaddressed MPTCP SHOULD
        NOT be enabled if a network stack uses SHIM6, HIP, or Mobile
        IPv6.  Furthermore, applications should not try to use both
        the MPTCP API and another multihoming or mobility layer
        API.
</p>
<p>It is possible, however, that some of the MPTCP
        functionality, such as congestion control, could be used in a
        SHIM6 or HIP environment. Such operation is outside the scope
        of this document.
</p>
<a name="anchor37"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.3"></a><h3>6.3.&nbsp;
Interactions with DNS</h3>

<p>In multihomed or multiaddressed environments, there are
        various issues that are not specific to MPTCP, but have to be
        considered, too. These problems are summarized in
        <a class='info' href='#I-D.ietf-mif-problem-statement'>[15]<span> (</span><span class='info'>Blanchet, M. and P. Seite, &ldquo;Multiple Interfaces Problem Statement,&rdquo; May&nbsp;2010.</span><span>)</span></a>.
</p>
<p>Specifically, there can be interactions with DNS. Whilst
        it is expected that an application will iterate over the list
        of addresses returned from a call such as getaddrinfo(), MPTCP
        itself MUST NOT make any assumptions about multiple A or AAAA
        records from the same DNS query referring to the same host, as
        it is very likely that multiple addresses refer to multiple
        servers for load balancing purposes.
</p>
<p>TODO: Elaborate on DNS
</p>
<a name="anchor38"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7"></a><h3>7.&nbsp;
Security Considerations</h3>

<p>Will be added in a later version of this document.
</p>
<a name="anchor39"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.8"></a><h3>8.&nbsp;
IANA Considerations</h3>

<p>No IANA considerations.
</p>
<a name="anchor40"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.9"></a><h3>9.&nbsp;
Conclusion</h3>

<p>This document discusses MPTCP's application implications and
      specifies a basic MPTCP API. For legacy applications, it is
      ensured that the existing sockets API continues to work.
      MPTCP-aware applications can use the basic MPTCP API that
      provides some control over the transport layer equivalent to
      regular TCP. A more fine-granular interaction between
      applications and MPTCP requires an advanced MPTCP API, which is
      not specified in this document.
</p>
<a name="anchor41"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.10"></a><h3>10.&nbsp;
Acknowledgments</h3>

<p>Authors sincerely thank to the following people for their
      helpful comments to the document: Costin Raiciu
</p>
<p>Michael Scharf is supported by the German-Lab project
      (http://www.german-lab.de/) funded by the German Federal
      Ministry of Education and Research (BMBF). Alan Ford is
      supported by Trilogy (http://www.trilogy-project.org/), a
      research project (ICT-216372) partially funded by the European
      Community under its Seventh Framework Program. The views
      expressed here are those of the author(s) only. The European
      Commission is not liable for any use that may be made of the
      information in this document.
</p>
<a name="rfc.references"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.11"></a><h3>11.&nbsp;
References</h3>

<a name="rfc.references1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>11.1.&nbsp;Normative References</h3>
<table width="99%" border="0">
<tr><td class="author-text" valign="top"><a name="RFC0793">[1]</a></td>
<td class="author-text">Postel, J., &ldquo;<a href="http://tools.ietf.org/html/rfc793">Transmission Control Protocol</a>,&rdquo; STD&nbsp;7, RFC&nbsp;793, September&nbsp;1981 (<a href="http://www.rfc-editor.org/rfc/rfc793.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC1122">[2]</a></td>
<td class="author-text"><a href="mailto:Braden@ISI.EDU">Braden, R.</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc1122">Requirements for Internet Hosts - Communication Layers</a>,&rdquo; STD&nbsp;3, RFC&nbsp;1122, October&nbsp;1989 (<a href="http://www.rfc-editor.org/rfc/rfc1122.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC2119">[3]</a></td>
<td class="author-text"><a href="mailto:sob@harvard.edu">Bradner, S.</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>,&rdquo; BCP&nbsp;14, RFC&nbsp;2119, March&nbsp;1997 (<a href="http://www.rfc-editor.org/rfc/rfc2119.txt">TXT</a>, <a href="http://xml.resource.org/public/rfc/html/rfc2119.html">HTML</a>, <a href="http://xml.resource.org/public/rfc/xml/rfc2119.xml">XML</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="I-D.ietf-mptcp-architecture">[4]</a></td>
<td class="author-text">Ford, A., Raiciu, C., Barre, S., and J. Iyengar, &ldquo;<a href="http://www.ietf.org/internet-drafts/draft-ietf-mptcp-architecture-01.txt">Architectural Guidelines for Multipath TCP Development</a>,&rdquo; draft-ietf-mptcp-architecture-01 (work in progress), June&nbsp;2010 (<a href="http://www.ietf.org/internet-drafts/draft-ietf-mptcp-architecture-01.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="I-D.ietf-mptcp-multiaddressed">[5]</a></td>
<td class="author-text">Ford, A., Raiciu, C., and M. Handley, &ldquo;<a href="http://www.ietf.org/internet-drafts/draft-ietf-mptcp-multiaddressed-01.txt">TCP Extensions for Multipath Operation with Multiple Addresses</a>,&rdquo; draft-ietf-mptcp-multiaddressed-01 (work in progress), July&nbsp;2010 (<a href="http://www.ietf.org/internet-drafts/draft-ietf-mptcp-multiaddressed-01.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="I-D.ietf-mptcp-threat">[6]</a></td>
<td class="author-text">Bagnulo, M., &ldquo;<a href="http://www.ietf.org/internet-drafts/draft-ietf-mptcp-threat-03.txt">Threat Analysis for Multi-addressed/Multi-path TCP</a>,&rdquo; draft-ietf-mptcp-threat-03 (work in progress), October&nbsp;2010 (<a href="http://www.ietf.org/internet-drafts/draft-ietf-mptcp-threat-03.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="I-D.ietf-mptcp-congestion">[7]</a></td>
<td class="author-text">Raiciu, C., Handley, M., and D. Wischik, &ldquo;<a href="http://www.ietf.org/internet-drafts/draft-ietf-mptcp-congestion-00.txt">Coupled Multipath-Aware Congestion Control</a>,&rdquo; draft-ietf-mptcp-congestion-00 (work in progress), July&nbsp;2010 (<a href="http://www.ietf.org/internet-drafts/draft-ietf-mptcp-congestion-00.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="POSIX">[8]</a></td>
<td class="author-text">&ldquo;IEEE Std. 1003.1-2008 Standard for Information Technology --
          Portable Operating System Interface (POSIX). Open Group
          Technical Standard: Base Specifications, Issue 7, 2008..&rdquo;</td></tr>
</table>

<a name="rfc.references2"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>11.2.&nbsp;Informative References</h3>
<table width="99%" border="0">
<tr><td class="author-text" valign="top"><a name="I-D.sarolahti-mptcp-af-multipath">[9]</a></td>
<td class="author-text">Sarolahti, P., &ldquo;<a href="http://www.ietf.org/internet-drafts/draft-sarolahti-mptcp-af-multipath-01.txt">Multi-address Interface in the Socket API</a>,&rdquo; draft-sarolahti-mptcp-af-multipath-01 (work in progress), March&nbsp;2010 (<a href="http://www.ietf.org/internet-drafts/draft-sarolahti-mptcp-af-multipath-01.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC3542">[10]</a></td>
<td class="author-text">Stevens, W., Thomas, M., Nordmark, E., and T. Jinmei, &ldquo;<a href="http://tools.ietf.org/html/rfc3542">Advanced Sockets Application Program Interface (API) for IPv6</a>,&rdquo; RFC&nbsp;3542, May&nbsp;2003 (<a href="http://www.rfc-editor.org/rfc/rfc3542.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4584">[11]</a></td>
<td class="author-text">Chakrabarti, S. and E. Nordmark, &ldquo;<a href="http://tools.ietf.org/html/rfc4584">Extension to Sockets API for Mobile IPv6</a>,&rdquo; RFC&nbsp;4584, July&nbsp;2006 (<a href="http://www.rfc-editor.org/rfc/rfc4584.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="I-D.ietf-shim6-multihome-shim-api">[12]</a></td>
<td class="author-text">Komu, M., Bagnulo, M., Slavov, K., and S. Sugimoto, &ldquo;<a href="http://www.ietf.org/internet-drafts/draft-ietf-shim6-multihome-shim-api-13.txt">Socket Application Program Interface (API) for Multihoming Shim</a>,&rdquo; draft-ietf-shim6-multihome-shim-api-13 (work in progress), February&nbsp;2010 (<a href="http://www.ietf.org/internet-drafts/draft-ietf-shim6-multihome-shim-api-13.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="I-D.ietf-hip-native-api">[13]</a></td>
<td class="author-text">Komu, M. and T. Henderson, &ldquo;<a href="http://www.ietf.org/internet-drafts/draft-ietf-hip-native-api-12.txt">Basic Socket Interface Extensions for Host Identity Protocol (HIP)</a>,&rdquo; draft-ietf-hip-native-api-12 (work in progress), January&nbsp;2010 (<a href="http://www.ietf.org/internet-drafts/draft-ietf-hip-native-api-12.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="I-D.ietf-tsvwg-sctpsocket">[14]</a></td>
<td class="author-text">Stewart, R., Poon, K., Tuexen, M., Yasevich, V., and P. Lei, &ldquo;<a href="http://www.ietf.org/internet-drafts/draft-ietf-tsvwg-sctpsocket-23.txt">Sockets API Extensions for Stream Control Transmission Protocol (SCTP)</a>,&rdquo; draft-ietf-tsvwg-sctpsocket-23 (work in progress), July&nbsp;2010 (<a href="http://www.ietf.org/internet-drafts/draft-ietf-tsvwg-sctpsocket-23.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="I-D.ietf-mif-problem-statement">[15]</a></td>
<td class="author-text">Blanchet, M. and P. Seite, &ldquo;<a href="http://www.ietf.org/internet-drafts/draft-ietf-mif-problem-statement-04.txt">Multiple Interfaces Problem Statement</a>,&rdquo; draft-ietf-mif-problem-statement-04 (work in progress), May&nbsp;2010 (<a href="http://www.ietf.org/internet-drafts/draft-ietf-mif-problem-statement-04.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="I-D.ietf-mif-current-practices">[16]</a></td>
<td class="author-text">Wasserman, M. and P. Seite, &ldquo;<a href="http://www.ietf.org/internet-drafts/draft-ietf-mif-current-practices-01.txt">Current Practices for Multiple Interface Hosts</a>,&rdquo; draft-ietf-mif-current-practices-01 (work in progress), June&nbsp;2010 (<a href="http://www.ietf.org/internet-drafts/draft-ietf-mif-current-practices-01.txt">TXT</a>).</td></tr>
</table>

<a name="anchor44"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.A"></a><h3>Appendix A.&nbsp;
Requirements on a Future Advanced MPTCP API</h3>

<a name="anchor45"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.A.1"></a><h3>A.1.&nbsp;
Design Considerations</h3>

<p>Multipath transport results in many degrees of freedom.
        The basic MPTCP API only defines a minimum set of the sockets
        API extensions for the interface between the MPTCP layer and
        applications, which does not offer much control of the MPTCP
        implementation's behaviour. A future, advanced API could
        address further features of MPTCP and provide more
        control.
</p>
<p>Applications that use TCP may have different requirements
        on the transport layer.  While developers have become used to
        the characteristics of regular TCP, new opportunities created
        by MPTCP could allow the service provided to be optimised
        further.  An advanced API could enable MPTCP-aware
        applications to specify preferences and control certain
        aspects of the behavior, in addition to the simple control
        provided by the basic interface. An advanced API could also
        address aspects that are completely out-of-scope of the basic
        API, for example, the question whether a receiving application
        could influence the sending policy.
</p>
<p>Furthermore, an advanced MPTCP API could be part of a new
        overall interface between the network stack and applications
        that addresses other issues as well, such as the split between
        identifiers and locators. An API that does not use IP
        addresses (but, instead e.g. a connectbyname() function) would
        be useful for numerous purposes, independent of MPTCP.
</p>
<p>This appendix documents a list of potential usage scenarios
        and requirements for the advanded API. The specification and
        implementation of a corresponding API is outside the scope
        of this document.
</p>
<a name="anchor46"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.A.2"></a><h3>A.2.&nbsp;
MPTCP Usage Scenarios and Application Requirements</h3>

<p>There are different MPTCP usage scenarios. An application
        that wishes to transmit bulk data will want MPTCP to provide a
        high throughput service immediately, through creating and
        maximising utilisation of all available subflows.  This is the
        default MPTCP use case.
</p>
<p>But at the other extreme, there are applications that are
        highly interactive, but require only a small amount of
        throughput, and these are optimally served by low latency and
        jitter stability.  In such a situation, it would be preferable
        for the traffic to use only the lowest latency subflow
        (assuming it has sufficient capacity), maybe with one or two
        additional subflows for resilience and recovery purposes.  The
        key challenge for such a strategy is that the delay on a path
        may fluctuate significantly and that just always selecting the
        path with the smallest delay might result in instability.
</p>
<p>The choice between bulk data transport and
        latency-sensitive transport affects the scheduler in terms of
        whether traffic should be, by default, sent on one subflow or
        across several ones. Even if the total bandwidth required is
        less than that available on an individual path, it is
        desirable to spread this load to reduce stress on potential
        bottlenecks, and this is why this method should be the default
        for bulk data transport. However, that may not be optimal for
        applications that require latency/jitter stability.
</p>
<p>In the case of the latter option, a further question
        arises: Should additional subflows be used whenever the
        primary subflow is overloaded, or only when the primary path
        fails (hot-standby)? In other words, is latency stability or
        bandwidth more important to the application? This results in
        two different options: Firstly, there is the single path which
        can overflow into an additional subflow; and secondly there is
        single-path with hot-standby, whereby an application may want
        an alternative backup subflow in order to improve resilience.
        In case that data delivery on the first subflow fails, the
        data transport could immediately be continued on the second
        subflow, which is idle otherwise.
</p>
<p>A further, mostly orthogonal question is whether data
        should be duplicated over the different subflows, in
        particular if there is spare capacity. This could improve both
        the timeliness and reliability of data delivery.
</p>
<p>In summary, there are at least three possible performance
        objectives for multipath transport (not necessarily
        disjoint):

          </p>
<ol class="text">
<li>High bandwidth
</li>
<li>Low latency and jitter stability
</li>
<li>High reliability
</li>
</ol><p>

        In an advanced API, applications could provide high-level
        guidance to the MPTCP implementation concerning these
        performance requirements, for instance, which is considered to
        be the most important one. The MPTCP stack would then use
        internal mechanisms to fulfill this abstract indication of a
        desired service, as far as possible. This would both affect
        the assignment of data (including retransmissions) to existing
        subflows (e.g., 'use all in parallel', 'use as overflow', 'hot
        standby', 'duplicate traffic') as well as the decisions when
        to set up additional subflows to which addresses. In both
        cases different policies can exist, which can be expected to
        be implementation-specific.
</p>
<p>Therefore, an advanced API could provide a mechanism how
        applications can specify their high-level requirements in an
        implementation-independent way. One possibility would be to
        select one "application profile" out of a number of choices
        that characterize typical applications. Yet, as applications
        today do not have to inform TCP about their communication
        requirements, it requires further studies whether such an
        approach would be realistic.
</p>
<p>Of course, independent of an advanced API, such
        functionality could also partly be achieved by MPTCP-internal
        heuristics that infer some application preferences e.g. from
        existing socket options, such as TCP_NODELAY. Whether this
        would be reliable, and indeed appropriate, is for further
        study, too.
</p>
<a name="anchor47"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.A.3"></a><h3>A.3.&nbsp;
Potential Requirements on an Advanced MPTCP API</h3>

<p>The following is a list of potential requirements for an
        advanced MPTCP API beyond the features of the basic API. It is
        included here for information only:
</p>
<p></p>
<blockquote class="text"><dl>
<dt>REQ5:</dt>
<dd>An application should be able to establish MPTCP
          connections without using IP addresses as locators.
</dd>
<dt>REQ6:</dt>
<dd>An application should be able obtain usage information
          and statistics about all subflows (e.g., ratio of traffic
          sent via this subflow).
</dd>
<dt>REQ7:</dt>
<dd>An application should be able to request a change in the
          number of subflows in use, thus triggering removal or
          addition of subflows. An even finer control granularity
          would be a request for the establishment of a new subflow to
          a provided destination, or a request for the termination of
          a specified, existing subflow.
</dd>
<dt>REQ8:</dt>
<dd>An application should be able to inform the MPTCP
          implementation about its high-level performance
          requirements, e.g., in form of a profile.
</dd>
<dt>REQ9:</dt>
<dd>An application should be able to control the automatic
          establishment/termination of subflows. This would imply a
          selection among different heuristics of the path manager,
          e.g., 'try as soon as possible', 'wait until there is a
          bunch of data', etc.
</dd>
<dt>REQ10:</dt>
<dd>An application should be able to set preferred subflows
          or subflow usage policies. This would result in a selection
          among different configurations of the multipath
          scheduler.
</dd>
<dt>REQ11:</dt>
<dd>An application should be able to control the level of
          redundancy by telling whether segments should be sent on
          more than one path in parallel.
</dd>
</dl></blockquote>

<p>An advanced API fulfilling these requirements would allow
        application developers to more specifically configure MPTCP.
        It could avoid suboptimal decisions of internal, implicit
        heuristics. However, it is unclear whether all of these
        requirements would have a significant benefit to applications,
        since they are going above and beyond what the existing API to
        regular TCP provides.
</p>
<a name="anchor48"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.B"></a><h3>Appendix B.&nbsp;
Change History of the Document</h3>

<p>Changes compared to version 02:
</p>
<ul class="text">
<li>Definition of the behavior of getpeername() and
        getsockname() when being called by an MPTCP-aware
        application.
</li>
<li>Discussion of the possiblity that an MPTCP implementation 
        could support the SCTP API, as far as it is applicable to MPTCP.
</li>
<li>Various editorial fixes.
</li>
</ul>
<p>Changes compared to version 01:
</p>
<ul class="text">
<li>Second half of the document completely restructured
</li>
<li>Separation between a basic API and an advanced API: The
        focus of the document is the basic API only; all text
        concerning a potential extended API is moved to the
        appendix
</li>
<li>Several clarifications, e. g., concerning buffer sizeing
        and the use of different scheduling strategies triggered by
        TCP_NODELAY
</li>
<li>Additional references
</li>
</ul>
<p>Changes compared to version 00:
</p>
<ul class="text">
<li>Distinction between legacy and MPTCP-aware applications
</li>
<li>Guidance concerning default enabling, reaction to the shutdown of the first subflow, etc.
</li>
<li>Reference to a potential use of AF_MULTIPATH
</li>
<li>Additional references to related work
</li>
</ul>
<a name="rfc.authors"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>Authors' Addresses</h3>
<table width="99%" border="0" cellpadding="0" cellspacing="0">
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Michael Scharf</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Alcatel-Lucent Bell Labs</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Lorenzstrasse 10</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">70435 Stuttgart</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Germany</td></tr>
<tr><td class="author" align="right">EMail:&nbsp;</td>
<td class="author-text"><a href="mailto:michael.scharf@alcatel-lucent.com">michael.scharf@alcatel-lucent.com</a></td></tr>
<tr cellpadding="3"><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Alan Ford</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Roke Manor Research</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Old Salisbury Lane</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Romsey, Hampshire  SO51 0ZN</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">UK</td></tr>
<tr><td class="author" align="right">Phone:&nbsp;</td>
<td class="author-text">+44 1794 833 465</td></tr>
<tr><td class="author" align="right">EMail:&nbsp;</td>
<td class="author-text"><a href="mailto:alan.ford@roke.co.uk">alan.ford@roke.co.uk</a></td></tr>
</table>
</body></html>
