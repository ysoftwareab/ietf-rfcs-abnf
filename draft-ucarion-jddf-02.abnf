schema = {
     form,
     ? definitions: { * tstr => schema },
     ? additionalProperties: bool,
     * non-keyword => *
non-keyword =
     (((((((((tstr .ne "definitions")
       .ne "additionalProperties")
       .ne "ref")
       .ne "type")
       .ne "enum")
       .ne "elements")
       .ne "properties")
       .ne "optionalProperties")
       .ne "values")
       .ne "discriminator"

                   Figure 1: CDDL definition of a schema

form = empty /
     ref /
     type /
     enum /
     elements /
     properties /
     values /
     discriminator

            Figure 4: CDDL definition of the JDDF schema forms

empty = {}

               Figure 5: CDDL definition of the "empty" form

ref = { ref: tstr }

                Figure 7: CDDL definition of the "ref" form

type = { type: "boolean" / num-type / "string" / "timestamp" }
num-type = "float32" / "float64" /
     "int8" / "uint8" / "int16" / "uint16" / "int32" / "uint32"

                Figure 11: CDDL Definition of the Type Form

enum = { enum: [+ tstr] }

               Figure 13: CDDL definition of the "enum" form
elements = { elements: schema }

             Figure 16: CDDL definition of the "elements" form

properties = with-properties / with-optional-properties

with-properties = {
     properties: * tstr => schema,
     ? optionalProperties * tstr => schema
with-optional-properties = {
     ? properties: * tstr => schema,
     optionalProperties: * tstr => schema
values = { values: * tstr => schema }

              Figure 21: CDDL definition of the "values" form
discriminator = { tag: tstr, mapping: * tstr => properties }

          Figure 23: CDDL definition of the "discriminator" form

root = any

root = [* a]

a = [* b]
b = number

root = "PENDING" / "DONE" / "CANCELED"

root = bool

root = number

root = tstr

root = tdate

root = [* number]

root = { a: bool, b: number, ? c: tstr, ? d: tdate }

root = { * tstr => number }

root = { a: "foo", b: number } / { a: "bar", b: tstr }
