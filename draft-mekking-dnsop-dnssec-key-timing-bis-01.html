<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" 
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html lang="en" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head profile="http://www.w3.org/2006/03/hcard%20http://dublincore.org/documents/2008/08/04/dc-html/">
  <meta http-equiv="Content-Type" content="text/html; charset=us-ascii" />

  <title>DNSSEC Key Timing Considerations Follow-Up </title>

  <style type="text/css" title="Xml2Rfc (sans serif)">
  /*<![CDATA[*/
	  a {
	  text-decoration: none;
	  }
	  a.smpl {
	  color: black;
	  }
	  a:hover {
	  text-decoration: underline;
	  }
	  a:active {
	  text-decoration: underline;
	  }
	  address {
	  margin-top: 1em;
	  margin-left: 2em;
	  font-style: normal;
	  }
	  body {
	  color: black;
	  font-family: verdana, helvetica, arial, sans-serif;
	  font-size: 10pt;
	  
	  }
	  cite {
	  font-style: normal;
	  }
	  dd {
	  margin-right: 2em;
	  }
	  dl {
	  margin-left: 2em;
	  }
	
	  ul.empty {
	  list-style-type: none;
	  }
	  ul.empty li {
	  margin-top: .5em;
	  }
	  dl p {
	  margin-left: 0em;
	  }
	  dt {
	  margin-top: .5em;
	  }
	  h1 {
	  font-size: 14pt;
	  line-height: 21pt;
	  page-break-after: avoid;
	  }
	  h1.np {
	  page-break-before: always;
	  }
	  h1 a {
	  color: #333333;
	  }
	  h2 {
	  font-size: 12pt;
	  line-height: 15pt;
	  page-break-after: avoid;
	  }
	  h3, h4, h5, h6 {
	  font-size: 10pt;
	  page-break-after: avoid;
	  }
	  h2 a, h3 a, h4 a, h5 a, h6 a {
	  color: black;
	  }
	  img {
	  margin-left: 3em;
	  }
	  li {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  ol {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  ol p {
	  margin-left: 0em;
	  }
	  p {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  pre {
	  margin-left: 3em;
	  background-color: lightyellow;
	  padding: .25em;
	  }
	  pre.text2 {
	  border-style: dotted;
	  border-width: 1px;
	  background-color: #f0f0f0;
	  width: 69em;
	  }
	  pre.inline {
	  background-color: white;
	  padding: 0em;
	  }
	  pre.text {
	  border-style: dotted;
	  border-width: 1px;
	  background-color: #f8f8f8;
	  width: 69em;
	  }
	  pre.drawing {
	  border-style: solid;
	  border-width: 1px;
	  background-color: #f8f8f8;
	  padding: 2em;
	  }
	  table {
	  margin-left: 2em;
	  }
	  table.tt {
	  vertical-align: top;
	  }
	  table.full {
	  border-style: outset;
	  border-width: 1px;
	  }
	  table.headers {
	  border-style: outset;
	  border-width: 1px;
	  }
	  table.tt td {
	  vertical-align: top;
	  }
	  table.full td {
	  border-style: inset;
	  border-width: 1px;
	  }
	  table.tt th {
	  vertical-align: top;
	  }
	  table.full th {
	  border-style: inset;
	  border-width: 1px;
	  }
	  table.headers th {
	  border-style: none none inset none;
	  border-width: 1px;
	  }
	  table.left {
	  margin-right: auto;
	  }
	  table.right {
	  margin-left: auto;
	  }
	  table.center {
	  margin-left: auto;
	  margin-right: auto;
	  }
	  caption {
	  caption-side: bottom;
	  font-weight: bold;
	  font-size: 9pt;
	  margin-top: .5em;
	  }
	
	  table.header {
	  border-spacing: 1px;
	  width: 95%;
	  font-size: 10pt;
	  color: white;
	  }
	  td.top {
	  vertical-align: top;
	  }
	  td.topnowrap {
	  vertical-align: top;
	  white-space: nowrap; 
	  }
	  table.header td {
	  background-color: gray;
	  width: 50%;
	  }
	  table.header a {
	  color: white;
	  }
	  td.reference {
	  vertical-align: top;
	  white-space: nowrap;
	  padding-right: 1em;
	  }
	  thead {
	  display:table-header-group;
	  }
	  ul.toc, ul.toc ul {
	  list-style: none;
	  margin-left: 1.5em;
	  margin-right: 0em;
	  padding-left: 0em;
	  }
	  ul.toc li {
	  line-height: 150%;
	  font-weight: bold;
	  font-size: 10pt;
	  margin-left: 0em;
	  margin-right: 0em;
	  }
	  ul.toc li li {
	  line-height: normal;
	  font-weight: normal;
	  font-size: 9pt;
	  margin-left: 0em;
	  margin-right: 0em;
	  }
	  li.excluded {
	  font-size: 0pt;
	  }
	  ul p {
	  margin-left: 0em;
	  }
	
	  .comment {
	  background-color: yellow;
	  }
	  .center {
	  text-align: center;
	  }
	  .error {
	  color: red;
	  font-style: italic;
	  font-weight: bold;
	  }
	  .figure {
	  font-weight: bold;
	  text-align: center;
	  font-size: 9pt;
	  }
	  .filename {
	  color: #333333;
	  font-weight: bold;
	  font-size: 12pt;
	  line-height: 21pt;
	  text-align: center;
	  }
	  .fn {
	  font-weight: bold;
	  }
	  .hidden {
	  display: none;
	  }
	  .left {
	  text-align: left;
	  }
	  .right {
	  text-align: right;
	  }
	  .title {
	  color: #990000;
	  font-size: 18pt;
	  line-height: 18pt;
	  font-weight: bold;
	  text-align: center;
	  margin-top: 36pt;
	  }
	  .vcardline {
	  display: block;
	  }
	  .warning {
	  font-size: 14pt;
	  background-color: yellow;
	  }
	
	
	  @media print {
	  .noprint {
		display: none;
	  }
	
	  a {
		color: black;
		text-decoration: none;
	  }
	
	  table.header {
		width: 90%;
	  }
	
	  td.header {
		width: 50%;
		color: black;
		background-color: white;
		vertical-align: top;
		font-size: 12pt;
	  }
	
	  ul.toc a::after {
		content: leader('.') target-counter(attr(href), page);
	  }
	
	  ul.ind li li a {
		content: target-counter(attr(href), page);
	  }
	
	  .print2col {
		column-count: 2;
		-moz-column-count: 2;
		column-fill: auto;
	  }
	  }
	
	  @page {
	  @top-left {
		   content: "Internet-Draft"; 
	  } 
	  @top-right {
		   content: "December 2010"; 
	  } 
	  @top-center {
		   content: "Abbreviated Title";3
	  } 
	  @bottom-left {
		   content: "Doe"; 
	  } 
	  @bottom-center {
		   content: "Expires June 2011"; 
	  } 
	  @bottom-right {
		   content: "[Page " counter(page) "]"; 
	  } 
	  }
	
	  @page:first { 
		@top-left {
		  content: normal;
		}
		@top-right {
		  content: normal;
		}
		@top-center {
		  content: normal;
		}
	  }
  /*]]>*/
  </style>

  <link href="#rfc.toc" rel="Contents">
<link href="#rfc.section.1" rel="Chapter" title="1 Introduction">
<link href="#rfc.section.1.1" rel="Chapter" title="1.1 Key Rollover Considerations">
<link href="#rfc.section.1.2" rel="Chapter" title="1.2 Terminology">
<link href="#rfc.section.2" rel="Chapter" title="2 Key Definitions">
<link href="#rfc.section.2.1" rel="Chapter" title="2.1 Key Types">
<link href="#rfc.section.2.2" rel="Chapter" title="2.2 Key States Unraveled">
<link href="#rfc.section.2.2.1" rel="Chapter" title="2.2.1 Validation Components">
<link href="#rfc.section.2.2.1.1" rel="Chapter" title="2.2.1.1 The Public Key Component">
<link href="#rfc.section.2.2.1.2" rel="Chapter" title="2.2.1.2 The Signature Component">
<link href="#rfc.section.2.2.1.3" rel="Chapter" title="2.2.1.3 The Secure Delegation Component">
<link href="#rfc.section.2.2.2" rel="Chapter" title="2.2.2 Validation Component States">
<link href="#rfc.section.2.3" rel="Chapter" title="2.3 Key Properties">
<link href="#rfc.section.2.4" rel="Chapter" title="2.4 Key Goals">
<link href="#rfc.section.2.5" rel="Chapter" title="2.5 Delay Timings">
<link href="#rfc.section.3" rel="Chapter" title="3 Key Rollovers">
<link href="#rfc.section.3.1" rel="Chapter" title="3.1 Key Rollover Stages">
<link href="#rfc.section.3.2" rel="Chapter" title="3.2 ZSK Rollovers">
<link href="#rfc.section.3.2.1" rel="Chapter" title="3.2.1 Double-Signature">
<link href="#rfc.section.3.2.2" rel="Chapter" title="3.2.2 Pre-Publication">
<link href="#rfc.section.3.2.3" rel="Chapter" title="3.2.3 Double-RRSIG">
<link href="#rfc.section.3.3" rel="Chapter" title="3.3 KSK Rollovers">
<link href="#rfc.section.3.3.1" rel="Chapter" title="3.3.1 Double-RRset">
<link href="#rfc.section.3.3.2" rel="Chapter" title="3.3.2 Double-Signature">
<link href="#rfc.section.3.3.3" rel="Chapter" title="3.3.3 Double-DS">
<link href="#rfc.section.3.3.4" rel="Chapter" title="3.3.4 Interaction with Configured Trust Anchors">
<link href="#rfc.section.3.3.4.1" rel="Chapter" title="3.3.4.1 Adding a KSK">
<link href="#rfc.section.3.3.4.2" rel="Chapter" title="3.3.4.2 Removing a KSK">
<link href="#rfc.section.3.4" rel="Chapter" title="3.4 Rollovers in a Single Type Signing Scheme">
<link href="#rfc.section.3.4.1" rel="Chapter" title="3.4.1 Double-RRset">
<link href="#rfc.section.3.4.2" rel="Chapter" title="3.4.2 Double-Signature">
<link href="#rfc.section.3.4.3" rel="Chapter" title="3.4.3 Pre-Publication">
<link href="#rfc.section.3.4.4" rel="Chapter" title="3.4.4 Double-DS">
<link href="#rfc.section.3.5" rel="Chapter" title="3.5 Stand-by Keys">
<link href="#rfc.section.4" rel="Chapter" title="4 Policy rollover">
<link href="#rfc.section.4.1" rel="Chapter" title="4.1 Enabling DNSSEC">
<link href="#rfc.section.4.2" rel="Chapter" title="4.2 Disabling DNSSEC">
<link href="#rfc.section.4.3" rel="Chapter" title="4.3 Algorithm Rollover">
<link href="#rfc.section.4.4" rel="Chapter" title="4.4 KSK-ZSK Split or Single Type Signing Scheme">
<link href="#rfc.section.5" rel="Chapter" title="5 IANA Considerations">
<link href="#rfc.section.6" rel="Chapter" title="6 Security Considerations">
<link href="#rfc.section.7" rel="Chapter" title="7 Acknowledgements">
<link href="#rfc.section.8" rel="Chapter" title="8 Changelog">
<link href="#rfc.section.8.1" rel="Chapter" title="8.1 Changes with key-timing draft">
<link href="#rfc.section.8.2" rel="Chapter" title="8.2 From -00 to -01">
<link href="#rfc.references" rel="Chapter" title="9 References">
<link href="#rfc.references.1" rel="Chapter" title="9.1 Informative References">
<link href="#rfc.references.2" rel="Chapter" title="9.2 Normative References">
<link href="#rfc.appendix.Appendix%20A" rel="Chapter" title="Appendix A List of Symbols">
<link href="#rfc.authors" rel="Chapter">


  <meta name="generator" content=
  "http://greenbytes.de/tech/webdav/rfc2629.xslt, Revision 1.539, 2011-01-02 17:13:00, XSLT vendor: SAXON 6.5.5 from Michael Kay http://saxon.sf.net/" />
  <link rel="schema.dct" href="http://purl.org/dc/terms/" />
  <meta name="dct.creator" content="Doe, J." />
  <meta name="dct.identifier" content="urn:ietf:id:draft-sample-input-00" />
  <meta name="dct.issued" scheme="ISO8601" content="2010-12" />
  
  <meta name="dct.abstract" content="This document describes issues surrounding the timing of events related to DNSSEC policy.  It presents timelines for various key rollovers and DNSSEC policy changes regarding the key signing scheme.  It explicitly identifies the relationships between the various parameters affecting the rollover process.  " />
  <meta name="description" content="This document describes issues surrounding the timing of events related to DNSSEC policy.  It presents timelines for various key rollovers and DNSSEC policy changes regarding the key signing scheme.  It explicitly identifies the relationships between the various parameters affecting the rollover process.  " />
  <meta name="keywords" content="DNS, DNSSEC, key, rollover" />

</head>

<body>

  <table class="header">
    <tbody>
    
    	<tr>
<td class="left">Domain Name System Operations</td>
<td class="right">W.M. Mekking</td>
</tr>
<tr>
<td class="left">Internet-Draft</td>
<td class="right">NLnet Labs</td>
</tr>
<tr>
<td class="left">Intended status: Standards Track</td>
<td class="right">June 22, 2011</td>
</tr>
<tr>
<td class="left">Expires: December 24, 2011</td>
<td class="right"></td>
</tr>

    	
    </tbody>
  </table>

  <p class="title">DNSSEC Key Timing Considerations Follow-Up <br />
  <span class="filename">draft-mekking-dnsop-dnssec-key-timing-bis-01</span></p>
  
  <h1 id="rfc.abstract"><a href="#rfc.abstract">Abstract</a></h1>
<p>This document describes issues surrounding the timing of events related to DNSSEC policy.  It presents timelines for various key rollovers and DNSSEC policy changes regarding the key signing scheme.  It explicitly identifies the relationships between the various parameters affecting the rollover process.  </p>
<p>This document updates [draft-ietf-dnsop-dnssec-key-timing] [MM: If approved] as it covers timelines for key rollovers in more detail and it covers additional key rollover scenarios, including algorithm rollover and single type key rollovers.  </p>
<h1 id="rfc.status"><a href="#rfc.status">Status of this Memo</a></h1>
<p>This Internet-Draft is submitted in full conformance with the provisions of BCP 78 and BCP 79.</p>
<p>Internet-Drafts are working documents of the Internet Engineering Task Force (IETF).  Note that other groups may also distribute working documents as Internet-Drafts.  The list of current Internet- Drafts is at http://datatracker.ietf.org/drafts/current/.</p>
<p>Internet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other documents at any time.  It is inappropriate to use Internet-Drafts as reference material or to cite them other than as "work in progress."</p>
<p>This Internet-Draft will expire on December 24, 2011.</p>
<h1 id="rfc.copyrightnotice"><a href="#rfc.copyrightnotice">Copyright Notice</a></h1>
<p>Copyright (c) 2011 IETF Trust and the persons identified as the document authors.  All rights reserved.</p>
<p>This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document.  Please review these documents carefully, as they describe your rights and restrictions with respect to this document.  Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.</p>

  
  <hr class="noprint" />
  <h1 class="np" id="rfc.toc"><a href="#rfc.toc">Table of Contents</a></h1>
  <ul class="toc">

  	<li>1.   <a href="#rfc.section.1">Introduction</a>
</li>
<li>1.1.   <a href="#rfc.section.1.1">Key Rollover Considerations</a>
</li>
<li>1.2.   <a href="#rfc.section.1.2">Terminology</a>
</li>
<li>2.   <a href="#rfc.section.2">Key Definitions</a>
</li>
<li>2.1.   <a href="#rfc.section.2.1">Key Types</a>
</li>
<li>2.2.   <a href="#rfc.section.2.2">Key States Unraveled</a>
</li>
<li>2.2.1.   <a href="#rfc.section.2.2.1">Validation Components</a>
</li>
<li>2.2.1.1.   <a href="#rfc.section.2.2.1.1">The Public Key Component</a>
</li>
<li>2.2.1.2.   <a href="#rfc.section.2.2.1.2">The Signature Component</a>
</li>
<li>2.2.1.3.   <a href="#rfc.section.2.2.1.3">The Secure Delegation Component</a>
</li>
<li>2.2.2.   <a href="#rfc.section.2.2.2">Validation Component States</a>
</li>
<li>2.3.   <a href="#rfc.section.2.3">Key Properties</a>
</li>
<li>2.4.   <a href="#rfc.section.2.4">Key Goals</a>
</li>
<li>2.5.   <a href="#rfc.section.2.5">Delay Timings</a>
</li>
<li>3.   <a href="#rfc.section.3">Key Rollovers</a>
</li>
<li>3.1.   <a href="#rfc.section.3.1">Key Rollover Stages</a>
</li>
<li>3.2.   <a href="#rfc.section.3.2">ZSK Rollovers</a>
</li>
<li>3.2.1.   <a href="#rfc.section.3.2.1">Double-Signature</a>
</li>
<li>3.2.2.   <a href="#rfc.section.3.2.2">Pre-Publication</a>
</li>
<li>3.2.3.   <a href="#rfc.section.3.2.3">Double-RRSIG</a>
</li>
<li>3.3.   <a href="#rfc.section.3.3">KSK Rollovers</a>
</li>
<li>3.3.1.   <a href="#rfc.section.3.3.1">Double-RRset</a>
</li>
<li>3.3.2.   <a href="#rfc.section.3.3.2">Double-Signature</a>
</li>
<li>3.3.3.   <a href="#rfc.section.3.3.3">Double-DS</a>
</li>
<li>3.3.4.   <a href="#rfc.section.3.3.4">Interaction with Configured Trust Anchors</a>
</li>
<li>3.3.4.1.   <a href="#rfc.section.3.3.4.1">Adding a KSK</a>
</li>
<li>3.3.4.2.   <a href="#rfc.section.3.3.4.2">Removing a KSK</a>
</li>
<li>3.4.   <a href="#rfc.section.3.4">Rollovers in a Single Type Signing Scheme</a>
</li>
<li>3.4.1.   <a href="#rfc.section.3.4.1">Double-RRset</a>
</li>
<li>3.4.2.   <a href="#rfc.section.3.4.2">Double-Signature</a>
</li>
<li>3.4.3.   <a href="#rfc.section.3.4.3">Pre-Publication</a>
</li>
<li>3.4.4.   <a href="#rfc.section.3.4.4">Double-DS</a>
</li>
<li>3.5.   <a href="#rfc.section.3.5">Stand-by Keys</a>
</li>
<li>4.   <a href="#rfc.section.4">Policy rollover</a>
</li>
<li>4.1.   <a href="#rfc.section.4.1">Enabling DNSSEC</a>
</li>
<li>4.2.   <a href="#rfc.section.4.2">Disabling DNSSEC</a>
</li>
<li>4.3.   <a href="#rfc.section.4.3">Algorithm Rollover</a>
</li>
<li>4.4.   <a href="#rfc.section.4.4">KSK-ZSK Split or Single Type Signing Scheme</a>
</li>
<li>5.   <a href="#rfc.section.5">IANA Considerations</a>
</li>
<li>6.   <a href="#rfc.section.6">Security Considerations</a>
</li>
<li>7.   <a href="#rfc.section.7">Acknowledgements</a>
</li>
<li>8.   <a href="#rfc.section.8">Changelog</a>
</li>
<li>8.1.   <a href="#rfc.section.8.1">Changes with key-timing draft</a>
</li>
<li>8.2.   <a href="#rfc.section.8.2">From -00 to -01</a>
</li>
<li>9.   <a href="#rfc.references">References</a>
</li>
<li>9.1.   <a href="#rfc.references.1">Informative References</a>
</li>
<li>9.2.   <a href="#rfc.references.2">Normative References</a>
</li>
<li>Appendix A.   <a href="#rfc.appendix.Appendix%20A">List of Symbols</a>
</li>
<li><a href="#rfc.authors">Author's Address</a>
</li>


  </ul>

  <h1 id="rfc.section.1">
<a href="#rfc.section.1">1.</a> <a href="#intro" id="intro">Introduction</a>
</h1>
<p id="rfc.section.1.p.1">DNS was not originally designed with security in mind.  The Domain Name System Security Extensions (DNSSEC, <a href="#RFC4033">[RFC4033]</a>, <a href="#RFC4034">[RFC4034]</a>, <a href="#RFC4035">[RFC4035]</a>) add a security layer that provides data origin authentication and data integrity.  A DNS zone that implements DNSSEC must have the ability to replace ("roll") keys.  This will be needed for various reasons such as recovery from a key compromise, replacement of key-signing hardware (if used), or even just to implement a policy that requires periodic rollovers.  </p>
<p id="rfc.section.1.p.2">In addition, a DNS zone may be subject to a given DNSSEC Policy <a href="#dps-framework">[dps-framework]</a>.  Normally, such a policy provides a methodology for key rollover.  A DNS operator may choose to change the DNSSEC Policy for a zone, or switch to a different policy.  Such a change may also trigger a key rollover scenario to occur.  </p>
<p id="rfc.section.1.p.3">Key rollovers are time critical, multiple steps processes.  This document describes issues surrounding the timing of events in the rolling of DNSSEC keys.  </p>
<p id="rfc.section.1.p.4">[MM: Editorarial comments are indicated by square brackets and editor initials] </p>
<h1 id="rfc.section.1.1">
<a href="#rfc.section.1.1">1.1.</a> <a href="#considerations" id="considerations">Key Rollover Considerations</a>
</h1>
<p id="rfc.section.1.1.p.1">A key rollover involves the replacement of active keys with new keys.  In order to avoid the zone being seen as bogus during the transition, there are constraints on the times at which the keys are added to and removed from the zone.  DNSSEC records are not only held at the authoritative name server, they are also cached at client validators.  The data on these systems can be interlinked, meaning a validator may try to validate a signature retrieved from a cache with a key obtained separately.  The rollover process needs to happen in such a way that at all times through the rollover the information is consistent.  </p>
<p id="rfc.section.1.1.p.2">There exist different flavours of key rollovers.  When making a choice which type of rollover to implement, several considerations may be taken into account: </p>
<p></p>

<ul>
<li>Size of the zone and the DNS response: Adding signatures increases the zone size and the size of DNS responses significantly.  To keep the sizes of the zone and responses as small as possible, the DNSSEC records should be introduced only when they are required.  For the same reason, dead keys and signatures must be removed periodically.  </li>
<li>Size of the DNSKEY RRset: Instead of keeping the set of signatures to a minimum, it is also possible to minimize the size of the DNSKEY RRset.  This consideration may be of importance in the case where trust anchor priming is an issue.  </li>
<li>Interactions with the Parent: Where a key being replaced has a corresponding DS record in the parent zone, the rollover involves removing it and introducing the DS record corresponding to the new key.  Such a process requires communication between the child and parent zones and may require additional operational work.  This may lead to a sufficient delay.  In the case where the interaction through the child-parent provisioning chain is unpredictable, it is preferred to keep the number of interactions with the parent to a minimum.  </li>
</ul>

<p> </p>
<h1 id="rfc.section.1.2">
<a href="#rfc.section.1.2">1.2.</a> <a href="#terminology" id="terminology">Terminology</a>
</h1>
<p id="rfc.section.1.2.p.1">The terminology used in this document is as defined in <a href="#RFC4033">[RFC4033]</a>, <a href="#RFC4034">[RFC4034]</a>, <a href="#RFC4035">[RFC4035]</a> and <a href="#RFC5011">[RFC5011]</a>.  This document also introduces new terms in <a href="#definitions">Section 2</a>.  </p>
<h1 id="rfc.section.2">
<a href="#rfc.section.2">2.</a> <a href="#definitions" id="definitions">Key Definitions</a>
</h1>
<h1 id="rfc.section.2.1">
<a href="#rfc.section.2.1">2.1.</a> <a href="#types" id="types">Key Types</a>
</h1>
<p id="rfc.section.2.1.p.1">Keys can be used to authenticate information within the zone.  Such keys are said to be Zone Signing Keys (ZSKs).  In addition, keys can be used to authenticate the DNSKEY RRset in the zone.  These keys are said to be Key Signing Keys (KSKs).  Keys can be marked to be ZSK and KSK at the same time, for example in a Single Type Signing Scheme (STSS).  </p>
<p id="rfc.section.2.1.p.2">Despite that ZSK and KSK only describe the usage of a key, the terms are often used for identifying a key.  Thus, when this document talks about a ZSK it actually means that the key is used as ZSK (but may also be used as KSK).  In the same spirit, a KSK is a key that is used as KSK (but may also be used as ZSK) A key that is used as a KSK is responsible for creating a signature for the DNSKEY RRset.  A key that is used as a ZSK is responsible for creating a signatures for all RRsets, except the DNSKEY RRset.  </p>
<p id="rfc.section.2.1.p.3">DNSSEC recognises the classification of keys with its SEP bit set and not set.  Usually if a key is used as KSK, the SEP bit is set.  However, a SEP bit setting has no effect on how a DNSKEY may be used.  Policy determines whether the bit should be set, depending on the key's usage.  </p>
<h1 id="rfc.section.2.2">
<a href="#rfc.section.2.2">2.2.</a> <a href="#unraveled" id="unraveled">Key States Unraveled</a>
</h1>
<p id="rfc.section.2.2.p.1">In this document, the key states from <a href="#key-timing">draft-ietf-dnsop-dnssec-key-timing</a> <cite title="NONE">[key-timing]</cite> have been unraveled.  Instead of a single state, the state of all information associated with the key is representated separately.  This information comprises up to three items called Validation Components: the public key, its created signatures, and the corresponding secure delegation.  The consequence of this is that a single <a href="#key-timing">[key-timing]</a> key state now comprises a set of multiple Validation Component states.  </p>
<h1 id="rfc.section.2.2.1">
<a href="#rfc.section.2.2.1">2.2.1.</a> <a href="#component" id="component">Validation Components</a>
</h1>
<h1 id="rfc.section.2.2.1.1">
<a href="#rfc.section.2.2.1.1">2.2.1.1.</a> <a href="#dnskey-component" id="dnskey-component">The Public Key Component</a>
</h1>
<p id="rfc.section.2.2.1.1.p.1">The Public Key (DNSKEY) Component represents the state of the public part of the key.  When talking about a KSK, this comprises the DNSKEY record and the RRSIG record for the DNSKEY RRset created with the key, as both the key and signature travel together.  In the case of a ZSK, this comprises just the DNSKEY record.  </p>
<p id="rfc.section.2.2.1.1.p.2">[MM: Is this a safe assumption? Or are there rollover scenarios that benefit to decouple the DNSKEY RR and the RRSIG RR created with the key? For example in STSS environment.] </p>
<h1 id="rfc.section.2.2.1.2">
<a href="#rfc.section.2.2.1.2">2.2.1.2.</a> <a href="#rrsig-component" id="rrsig-component">The Signature Component</a>
</h1>
<p id="rfc.section.2.2.1.2.p.1">The Signature (RRSIG) Component represents the state of the private part of the key.  This comprises the RRSIG records for all RRsets excluding the DNSKEY RRset.  </p>
<h1 id="rfc.section.2.2.1.3">
<a href="#rfc.section.2.2.1.3">2.2.1.3.</a> <a href="#ds-component" id="ds-component">The Secure Delegation Component</a>
</h1>
<p id="rfc.section.2.2.1.3.p.1">The Secure Delegation (DS) Component represents the state of the secure delegation of the key.  This comprises the DS record that corresponds to the Public Key Component.  </p>
<h1 id="rfc.section.2.2.2">
<a href="#rfc.section.2.2.2">2.2.2.</a> <a href="#component-states" id="component-states">Validation Component States</a>
</h1>
<p id="rfc.section.2.2.2.p.1">A Validation Component may exist in up to two places: it can be present in the corresponding zone and it may be known in validator caches.  All Validation Components follow the same state diagram: </p>
<p id="rfc.section.2.2.2.p.2">Generated --&gt; Introduced --&gt; Propagated --&gt; Withdrawn --&gt; Dead.  </p>
<p></p>

<dl>
<dt>Generated: </dt>
<dd style="margin-left: 8">The Validation Component has been generated, but is not available in the zone.  In this state, no validators are able to fetch this Validation Component.  </dd>
<dt>Introduced: </dt>
<dd style="margin-left: 8">The Validation Component is introduced and, as a result, is available in the zone.  If the Validation Component comprises multiple RRs, the introduction may be done incrementally.  As a result, the Validation Component that is said to be Introduced may be only partly available in the zone.  In this state, there may be validators that fetch this Validation Component from the authoritative name server.  However, there may also be validators that have associated information in the cache and don't use the new Validation Component.  </dd>
<dt>Propagated: </dt>
<dd style="margin-left: 8">The Validation Component is available in the zone and enough time has passed to have it propagated into all validator caches.  If the Validation Component comprises multiple RRs, it is said to be Propagated if and only if all RRs have been propagated into all validator caches.  As a result, all validators fetch this Validation Component from cache or from the authoritative name server.  </dd>
<dt>Withdrawn: </dt>
<dd style="margin-left: 8">The Validation Component is being withdrawn from the zone.  If the Validation Component comprises multiple RRs, the withdrawal may be done incrementally.  As a result, the Validation Component that is said to be Withdrawn may still be partly available in the zone.  In this state, the Validation Component can also still live in validator caches.  </dd>
<dt>Dead: </dt>
<dd style="margin-left: 8">The Validation Component is not available in the zone anymore and enough time has passed to have it expire from all validator caches.  </dd>
</dl>

<p> </p>
<p id="rfc.section.2.2.2.p.4">A Key State can now be represented as the tuple (DNSKEY Component State, RRSIG Component State, DS Component State).  For example: </p>
<p id="rfc.section.2.2.2.p.5">S(Kc) = (DNSKEY Propagated, RRSIG Introduced, DS Generated) </p>
<p id="rfc.section.2.2.2.p.6">where S(Kc) is the state of the key (Kc), means that Kc is published in the zone and all the validators that have a copy of the DNSKEY RRset, have one that includes Kc.  In addition, the key is being used for signing RRsets: RRSIG records made with Kc have been introduced in the zone.  However, there may still be some validator caches that are unaware of these signatures.  Finally, the corresponding DS record of Kc is said to be Generated, meaning it has not yet been submitted to the parent.  </p>
<p id="rfc.section.2.2.2.p.7">For convenience, a ZSK can be represented as a tuple (DNSKEY State, RRSIG State), because the DS record is only used with KSKs.  And a KSK can be represented as a tuple (DNSKEY State, DS State), because the RRSIG state only refers to ZSKs.  The RRSIG record over the DNSKEY RRset should be published at the same time when the corresponding DNSKEY record is published.  Therefore, both records will propagate to and expire from validator caches at the same time.  </p>
<h1 id="rfc.section.2.3">
<a href="#rfc.section.2.3">2.3.</a> <a href="#properties" id="properties">Key Properties</a>
</h1>
<p id="rfc.section.2.3.p.1">Key Properties are essentially what are called key states in <a href="#key-timing">[key-timing]</a>.  Key Properties are derived from the Validation Component States.  For example, if the DNSKEY Component of a key is in the Introduced State, the key is said to be Published.  A key can have multiple properties at the same time.  </p>
<p></p>

<dl>
<dt>Generated: </dt>
<dd style="margin-left: 8">A key is said to be Generated, if all Validation Components are in the Generated state.  The key has been created, but has not yet been used for anything.  <br> S(k) = (DNSKEY Generated, RRSIG Generated, DS Generated) </dd>
<dt>Published: </dt>
<dd style="margin-left: 8">A key is said to be Published if the DNSKEY Component is in the Introduced state.  The DNSKEY record is published in the zone, but predecessors DNSKEY RRsets may be held in caches.  <br> S(k) = (DNSKEY Introduced, RRSIG *, DS *) </dd>
<dt>Active: </dt>
<dd style="margin-left: 8">A key is said to be Active if the RRSIG Component is in the Introduced state (for ZSKs).  <br> S(k) = (DNSKEY *, RRSIG Introduced, DS *) </dd>
<dt>ActiveDS: </dt>
<dd style="margin-left: 8">A key is said to be ActiveDS, or Submitted, if the DS Component is in the Introduced state (for KSKs).  <br> S(k) = (DNSKEY *, RRSIG *, DS Introduced) </dd>
<dt>Known: </dt>
<dd style="margin-left: 8">A key is said to be Known if the DNSKEY Component is in the Propagated state.  The new key data has been published for long enough to guarantee that any previous versions of it have expired from caches.  <br> S(k) = (DNSKEY Propagated, RRSIG *, DS *) </dd>
<dt>Safe: </dt>
<dd style="margin-left: 8">A key is said to be Safe if the RRSIG Component is in the Propagated state (for ZSKs).  If a validator knows about the key, it is safe to assume that it may expect a signature created with this key.  <br> S(k) = (DNSKEY *, RRSIG Propagated, DS *) </dd>
<dt>SafeDS: </dt>
<dd style="margin-left: 8">A key is said to be SafeDS if the DS Component is in the Propagated state (for KSKs).  If a validator knows about the key, it is safe to assume that it may expect a corresponding DS record for this key.  <br> S(k) = (DNSKEY *, RRSIG *, DS Propagated) </dd>
<dt>Removed: </dt>
<dd style="margin-left: 8">A key is said to be Removed if the DNSKEY Component is in the Withdrawn state.  The key has been removed from the zone.  <br> S(k) = (DNSKEY Withdrawn, RRSIG *, DS *) </dd>
<dt>Retired: </dt>
<dd style="margin-left: 8">A key is said to be Retired if the RRSIG Component is in the Withdrawn state (for ZSKs).  Signatures are removed, or are incrementally being removed, from the zone.  When a key is said to be Retired, there may still be caches that hold copies of the signatures.  <br> S(k) = (DNSKEY *, RRSIG Withdrawn, DS *) </dd>
<dt>RetiredDS: </dt>
<dd style="margin-left: 8">A key is said to be RetiredDS if the DS Component is in the Withdrawn state (for KSKs).  The request has been made to withdraw the DS record from the parent zone, but it may take some time before the record is actually removed.  When a key is said to be RetiredDS, there may still be caches that hold copies of the DS record.  <br> S(k) = (DNSKEY *, RRSIG *, DS Withdrawn) </dd>
<dt>Forgotten: </dt>
<dd style="margin-left: 8">A key is said to be Forgotten if the DNSKEY Component is in the Dead state.  At this point, no single validator cache should know about this key.  <br> S(k) = (DNSKEY Dead, RRSIG *, DS *) </dd>
<dt>Expired: </dt>
<dd style="margin-left: 8">A key is said to be Expired if the RRSIG Component is in the Dead state (for ZSKs).  At this point, no single validator cache should know about this key's signatures.  <br> S(k) = (DNSKEY *, RRSIG Dead, DS *) </dd>
<dt>ExpiredDS: </dt>
<dd style="margin-left: 8">A key is said to be ExpiredDS if the DS Component is in the Dead state (for KSKs).  At this point, no single validator cache should know about this key's DS record.  <br> S(k) = (DNSKEY *, RRSIG *, DS Dead) </dd>
</dl>

<p> </p>
<p id="rfc.section.2.3.p.3">Throughout the document, the properties of a key Kc is denoted as P(Kc).  For example, </p>
<p id="rfc.section.2.3.p.4">P(Kc) = Known Retired </p>
<p id="rfc.section.2.3.p.5">means that key Kc is considered to be Known, the new key data has been published for long enough to guarantee that any previous versions of it have expired from caches, and it is considered to be Retired, its signatures are being removed from the zone.  </p>
<h1 id="rfc.section.2.4">
<a href="#rfc.section.2.4">2.4.</a> <a href="#goals" id="goals">Key Goals</a>
</h1>
<p id="rfc.section.2.4.p.1">When performing a key rollover, it is usually desired to introduce a ney key into to zone and to remove an existing key from the zone.  This can be called key goals. A key goal is the desire to make a key have certain Key Properties, as described in <a href="#properties">Section 2.3</a>.  During the lifetime of a key, the following goals may be put on a key: </p>
<p></p>

<ul>
<li>Activate key: Make validators use the key's associated information to perform authentication.  The goal is reached if the key is said to be Known and Safe(DS).  </li>
<li>Remove key: Make validators forget about the key's associated information.  The goal is reached if the key is said to be Forgotten and Expired(DS).  </li>
<li>Stand-by key: Pre-publish information for this key to speed up a future (unscheduled) rollover.  In case of a Stand-by ZSK, the goal is reached if the key is said to be Known.  In case of a Stand-by KSK, the goal is reached if the key is said to be SafeDS.  </li>
</ul>

<p> </p>
<p id="rfc.section.2.4.p.3">[MM: Would it be better here to refer to Key Properties or to Unraveled Key States?] </p>
<h1 id="rfc.section.2.5">
<a href="#rfc.section.2.5">2.5.</a> <a href="#timings" id="timings">Delay Timings</a>
</h1>
<p id="rfc.section.2.5.p.1">For every change made in the zone there are time delays that need to be taken into account: </p>
<p></p>

<dl>
<dt>Software Delay (Dsfw): </dt>
<dd style="margin-left: 8">The time it takes for the software to introduce the new information in the zone.  This delay can vary a lot depending on the information that needs to be introduced.  One can imagine that the software needs more time to sign a complete zone than when it pre-publishes a DNSKEY record.  [MM: Dsfw maps to Dsgn from the key-timing draft] </dd>
<dt>Propagation Delay (Dprp): </dt>
<dd style="margin-left: 8">The time it takes for any change introduced at the master to replicate to all slave servers.  </dd>
<dt>TTL Delay (Dttl): </dt>
<dd style="margin-left: 8">The time it takes to expire the previous information from the validator caches.  This delay depends on what RRsets need to expire from the caches.  If not explicitly mentioned otherwise, Dttl is considered the maximum TTL of the information that needs to expire from caches.  Otherwise, Dttl(RRtype) shows which specific RRsets need to expire.  [MM: TTL terminology in key-timing draft: TTLds, TTLkey, TTLkeyC, TTLsoa, TTLsoaC, TTLsoaP, TTLsig)] </dd>
<dt>Registration Delay to the Parent (Dreg): </dt>
<dd style="margin-left: 8">The time it takes to get the DS record to be placed into the parent zone, after it is submitted.  </dd>
<dt>Propagation Delay of the Parent (DprpP): </dt>
<dd style="margin-left: 8">The time it takes for any change introduced at the parent master to replicate to all parent slave servers.  </dd>
</dl>

<p> </p>
<p id="rfc.section.2.5.p.3">Despite the values of these delays may vary for the different rollover methods, the propagation delay to the caches can be defined as: </p>
<p id="rfc.section.2.5.p.4">DcacheZ = Dsfw + Dprp + Dttl <br> DcacheK = Dsfw + Dprp + Dttl(DNSKEY) <br> DcacheP = Dreg + DprpP + Dttl(DS) </p>
<p id="rfc.section.2.5.p.5">where DcacheZ is the propagation delay to the caches for information published in the zone, DcacheK is the propagation delay to the caches for the DNSKEY RRset and DcacheP is the propagation delay for information published in the parent zone.  </p>
<p id="rfc.section.2.5.p.6">[MM: Because some timings are unpredictable, it would make more sense to use triggering events instead of timings] </p>
<h1 id="rfc.section.3">
<a href="#rfc.section.3">3.</a> <a href="#rollovers" id="rollovers">Key Rollovers</a>
</h1>
<p id="rfc.section.3.p.1">There are many different key rollover methods.  <a href="#considerations">Section 1.1</a> lists several considerations to prefer one method over the other.  Though there are many different type of key rollovers, all methods share the same goal.  There is a current key (Kc) that needs to be removed and a successor key (Ks) that needs to become active.  </p>
<h1 id="rfc.section.3.1">
<a href="#rfc.section.3.1">3.1.</a> <a href="#stages" id="stages">Key Rollover Stages</a>
</h1>
<p id="rfc.section.3.1.p.1">Broadly speaking, any key rollover can be thought of as the following sequence of stages: </p>

<dl>
<dt>Generation: </dt>
<dd style="margin-left: 8">In this stage, a new successor key is generated or derived from a key pool.  </dd>
<dt>Preparation: </dt>
<dd style="margin-left: 8">In this stage, one or more Validation Components of the successor key are published in the zone and propagate through the nameserver network and into caches.  </dd>
<dt>Ready: </dt>
<dd style="margin-left: 8">The Ready Stage always follows the Preparation Stage.  The initial Validation Components of the successor key have been published long enough to guarantee that where key validation components for this zone appear in caches, they will include the components for the successor key.  <br> <br> <br> <br> Not all rollovers go through the Preparation and Ready stages.  The stages exist to facilitate rollover methods where a subset of Validation Components is introduced first and the final Validation Components are changed in an atomic manner.  It is possible that a rollover goes through the Preparation and Ready stages multiple times.  </dd>
<dt>Activation: </dt>
<dd style="margin-left: 8">The final Validation Components are added to the zone: The DNSKEY record is published in the zone, if it has not yet been introduced in previous Rollover Stages.  In addition, a key that acts as ZSK is started to be used to sign RRsets, if it has not yet been started to do so in previous Rollover Stages.  A key that acts as a KSK has its corresponding DS record submitted to the parent, if the DS record was not yet submitted in previous Rollover Stages.  <br> <br> During this stage, it is not guaranteed that all RRs can be validated with the successor key information; some may only be able to be validated with with information from the predecessor key.  <br> <br> In some rollover scenario's, the Activation Stage is an atomic operation, where Validation Components of the successor key replace the Validation Components of its predecessor.  </dd>
<dt>Activated: </dt>
<dd style="margin-left: 8">The Activated Stage always follows the Activation Stage.  All the Validation Components of the successor key have been published long enough to guarantee that any cache that holds validation components for a RR in the zone will contain a copy of these components.  </dd>
<dt>Revocation: </dt>
<dd style="margin-left: 8">If the key acts as a KSK, and it is known that the key is used as a <a href="#RFC5011">[RFC5011]</a> trust anchor, the predecessor key must be published for a period with the REVOKE bit set as a way of notifying validators that may have the key configured as a trust anchor, that is is about to be removed from the zone.  </dd>
<dt>Revoked: </dt>
<dd style="margin-left: 8">The Revoked Stage always follows the Revocation Stage.  The revoked predecessor key has been published long enough to guarantee that RFC5011-aware validators have seen the key being revoked.  <br> <br> Note that if the key is not used as an RFC5011 trust anchor, the rollover will not go through the Revocation and Revoked stages.  </dd>
<dt>Withdrawn: </dt>
<dd style="margin-left: 8">At this point, there may still exist old Validation Components that belong to the predecessor key.  Because a successor key has been Activated, it is safe to withdraw all remaining old Validation Components.  </dd>
<dt>Complete: </dt>
<dd style="margin-left: 8">All the Validation Components of the predecessor key have been removed from the zone long enough to guarantee that they have expired from caches.  </dd>
</dl>

<p> </p>
<h1 id="rfc.section.3.2">
<a href="#rfc.section.3.2">3.2.</a> <a href="#zsk-rollovers" id="zsk-rollovers">ZSK Rollovers</a>
</h1>
<p id="rfc.section.3.2.p.1">The two most common rollover methods for ZSKs are Double-Signature and Pre-Publication.  Both are described in <a href="#RFC4641">RFC4641</a> <cite title="NONE">[RFC4641]</cite>.  <a href="#key-timing">[key-timing]</a> also introduces ZSK Double-RRSIG rollover.  Double-Signature is the fastest way to rollover a ZSK.  Pre-Publication minimizes the number of signatures over the RRsets in the zone and DNS responses.  Double-RRSIG keeps the size of the DNSKEY RRset to a minimum.  </p>
<h1 id="rfc.section.3.2.1">
<a href="#rfc.section.3.2.1">3.2.1.</a> Double-Signature</h1>
<p id="rfc.section.3.2.1.p.1">This involves introducing the new key into the zone and using it to create additional RRSIG records; the old key and existing RRSIG records are retained.  During the period in which the zone is being signed, client validators are always able to validate RRSIGs: any combination of old and new DNSKEY RRset and RRSIG allows at least one signature to be validated.  </p>
<p id="rfc.section.3.2.1.p.2">Once the signing process is complete and enough time has elapsed to allow all old information to expire from caches, the old key and signatures can be removed from the zone.  As before, during this period any combination of DNSKEY RRset and RRSIG will allow validation of at least one signature.  </p>
<p id="rfc.section.3.2.1.p.3">Double-Signature is the fastest way to rollover to a new key, since all new information is published right away.  The drawback of this method is a noticeable increase in the size of the DNSSEC data, affecting both the overall size of the zone and the size of the responses.  </p>
<p id="rfc.section.3.2.1.p.4">Only when Ks is said to be Known, e.g. the DNSKEY record of Ks is known to all validators, the signatures made with Kc can be removed.  And only when all validators only use the information of Ks for authentication, the DNSKEY record of Kc can be removed.  In other words, Ks needs to be Known and Safe, before Kc can be removed.  Thus, first all Validation Components of the successor key need to be introduced into the zone.  Once all has been propagated, all information of Kc can be withdrawn from the zone.  </p>
<div id="#rfc.figure.1"></div>
<p>The timeline diagram is shown below:</p>
<pre>
        |1|  |2|     |3|  |4|     |5|
Kc       |    |       |    |       |
- RRSIG  |----|-------|----|DcacheZ|
- DNSKEY |----|-------|----|DcacheK|
         |    |       |    |       |
                           Trem    Tfor
                           Tret    Texp

Ks       |    |       |    |       |
- RRSIG  |    |DcacheZ|----|-------|---
- DNSKEY |    |DcacheK|----|-------|---
         |    |       |    |       |
         Tgen Tpub    Tkno
              Tact    Tsaf
    </pre>
<p>Figure: ZSK Double-Signature Rollover.</p>
<p id="rfc.section.3.2.1.p.5">Generation Stage: Event 1 <br> Key Ks is generated at the generate time (Tgen).  </p>
<p id="rfc.section.3.2.1.p.6">S(Ks) = (DNSKEY Generated, RRSIG Generated) <br> P(Ks) = Generated </p>
<p id="rfc.section.3.2.1.p.7">With the ZSK Double-Signature Rollover, all new Validation Components of the key Ks are going to be added to the zone and are allowed to propagate into the caches of validators.  Thus, there is no need for Preparation and Ready Stages.  </p>
<p id="rfc.section.3.2.1.p.8">Activation Stage: Event 2 <br> Key Ks is added to the DNSKEY RRset and is immediately used to sign the zone; existing signatures in the zone are maintained.  This is Ks's publish time (Tpub) and Ks is said to be Published.  It is also Ks's active time (Tact), the time when Ks is said to be Active.  Because the Double-Signature rollover is in place, there are now temporarily two active keys.  </p>
<p id="rfc.section.3.2.1.p.9">Tpub(Ks) &gt;= Tgen(Ks), Tact(Ks) == Tpub(Ks) </p>
<p id="rfc.section.3.2.1.p.10">S(Ks) = (DNSKEY Introduced, RRSIG Introduced) <br> P(ks) = Published Active </p>
<p id="rfc.section.3.2.1.p.11">Activated Stage: Event 3 <br> The information for Ks must be published long enough to ensure that the information have reached all validators that may have RRsets from this zone cached.  At the point in time that the DNSKEY RRset including Ks has been propagated and Ks is said to be Known (Tkno).  At the point in time that the other RRsets including signatures of Ks have been propagated (Tsaf), Ks is said to be Safe.  </p>
<p id="rfc.section.3.2.1.p.12">Tkno(Ks) &gt;= Tpub(Ks) + DcacheK <br> Tsaf(Ks) &gt;= Tact(Ks) + DcacheZ <br> </p>
<p id="rfc.section.3.2.1.p.13">S(Ks) = (DNSKEY Propagated, RRSIG Propagated) <br> P(ks) = Known Safe </p>
<p id="rfc.section.3.2.1.p.14">Note that once the DNSKEY RRset containing both Kc and Ks has propagated to all caches, Kc can be retired (i.e. no longer used to sign RRsets).  It does not matter if not all signatures of Ks have been Propagated, since the validator can validate RRsets with both Kc and Ks.  If the validator fetches a RRset from the cache, it uses the DNSKEY of Kc for validation.  Otherwise, it can use the DNSKEY of Ks.  </p>
<p id="rfc.section.3.2.1.p.15">Withdrawal Stage: Event 4 <br> When the successor key Ks is said to be Propagated, Kc can be retired.  And once there is a successor key that is said to be Safe, Kc can be removed.  This is Kc's retire time (Tret) and Kc is said to be Retired.  It is also Kc's removal time (Trem), the time that Kc is said to be Removed.  </p>
<p id="rfc.section.3.2.1.p.16">Tret(Kc) &gt;= Tkno(Ks) <br> Trem(Kc) &gt;= MAX(Tsaf(Ks), TsafDS(Ks)) </p>
<p id="rfc.section.3.2.1.p.17">S(Kc) = (DNSKEY Withdrawn, RRSIG Withdrawn) <br> P(kc) = Removed Retired </p>
<p id="rfc.section.3.2.1.p.18">Complete Stage: Event 5 <br> From the perspective of the authoritative server, the rollover is complete.  After some delay, Kc and its signatures have expired from the caches.  This delay is the maximum of DcacheZ, DcacheK.  This is Tfor, the time that the key is said to be Forgotten and Texp, the time that the key is said to be Expired.  </p>
<p id="rfc.section.3.2.1.p.19">Tfor(Kc) &gt;= Trem(Kc) + DcacheK <br> Texp(Kc) &gt;= Tret(Kc) + DcacheZ </p>
<p id="rfc.section.3.2.1.p.20">S(Kc) = (DNSKEY Dead, RRSIG Dead) <br> P(Kc) = Forgotten Expired </p>
<h1 id="rfc.section.3.2.2">
<a href="#rfc.section.3.2.2">3.2.2.</a> Pre-Publication</h1>
<p id="rfc.section.3.2.2.p.1">With Pre-Publication, the new key is introduced into the DNSKEY RRset, leaving the existing keys and signatures in place.  This state of affairs remains in place for long enough to ensure that any DNSKEY RRsets cached in client validators contain both keys.  At that point signatures created with the old key can be replaced by those created with the new key, and the old signatures can be removed.  During the re-signing process it doesn't matter which key an RRSIG record retrieved by a client was created with; clients with a cached copy of the DNSKEY RRset will have a copy containing both the old and new keys.  </p>
<p id="rfc.section.3.2.2.p.2">Once the zone contains only signatures created with the new key, there is an interval during which RRSIG records created with the old key expire from client caches.  After this, there will be no signatures anywhere that were created using the old key, and it can can be removed from the DNSKEY RRset.  </p>
<p id="rfc.section.3.2.2.p.3">Pre-Publication is more complex than Double-Signature - introduce the new key, approximately one TTL later sign the records, and approximately one TTL after that remove the old key.  Although it takes more time than the Double-Signature method, it has the advantage that each RRset is signed with just one key.  As a result, it has the advantage that the amount of DNSSEC data is kept to a minimum, reducing the impact on performance.  </p>
<p id="rfc.section.3.2.2.p.4">As with the ZSK Double-Signature rollover, only when Ks is said to be Known, Kc may be retired.  Signatures may be retired all at once or may be incrementally replaced with signatures of Ks.  However, during the transition all RRsets must either be signed with Kc or be signed with Ks.  If Ks is considered to be Known and Safe, the DNSKEY record of Kc can be removed.  </p>
<div id="#rfc.figure.2"></div>
<p>The timeline diagram looks like this:</p>
<pre>
        |1|  |2|     |3|  |4|     |5|  |6|     |7|
Kc       |    |       |    |       |    |       |
- RRSIG  |----|-------|----|DcacheZ|    |       |
- DNSKEY |----|-------|----|-------|----|DcacheK|
         |    |       |    |       |    |       |
                           Tret    Texp Trem    Tfor

Ks       |    |       |    |       |    |       |
- RRSIG  |    |       |    |DcacheZ|----|-------|---
- DNSKEY |    |DcacheK|----|-------|----|-------|---
         |    |       |    |       |    |       |
         Tgen Tpub    Tkno Tact    Tsaf
    </pre>
<p>Figure: ZSK Pre-Publication Rollover.</p>
<p id="rfc.section.3.2.2.p.5">With the ZSK Pre-Publication rollover, the DNSKEY record of Ks needs to be pre-published before the rollover can go into the Transit Stage.  </p>
<p id="rfc.section.3.2.2.p.6">Generation Stage: Event 1 <br> Key Ks is generated at the generate time (Tgen).  </p>
<p id="rfc.section.3.2.2.p.7">S(Ks) = (DNSKEY Generated, RRSIG Generated) <br> P(Ks) = Generated </p>
<p id="rfc.section.3.2.2.p.8">Preparation Stage: Event 2 <br> The DNSKEY record of Ks is put into the zone, i.e. it is added to the DNSKEY RRset which is then re-signed with the current KSK.  The time at which this occurs is Ks's publication time (Tpub), and the key is now said to be Published.  Note that the key is not yet used to sign records.  </p>
<p id="rfc.section.3.2.2.p.9">Tpub(Ks) &gt;= Tgen(Ks) </p>
<p id="rfc.section.3.2.2.p.10">S(Ks) = (DNSKEY Introduced, RRSIG Generated) <br> P(Ks) = Published </p>
<p id="rfc.section.3.2.2.p.11">Ready Stage: Event 3 <br> Before Ks can be used, the DNSKEY record of Ks must be published for long enough (DcacheK) to guarantee that any validator that has a copy of the DNSKEY RRset in its cache also includes this key.  In other words, that any prior cached information about the DNSKEY RRset has expired.  After this delay, the key is said to be Known and could be used to sign records.  The time at which this event occurs is Tkno, which is given by: </p>
<p id="rfc.section.3.2.2.p.12">Tkno(Ks) &gt;= Tpub(Ks) + DcacheK </p>
<p id="rfc.section.3.2.2.p.13">S(Ks) = (DNSKEY Propagated, RRSIG Generated) <br> P(Ks) = Known </p>
<p id="rfc.section.3.2.2.p.14">At this point, the rollover is in the Ready Stage.  </p>
<p id="rfc.section.3.2.2.p.15">Activation Stage: Event 4 <br> At some point in time, the decision is made to actually start signing the zone using the successor key.  This will be when the current key has been in use for an interval equal to the ZSK lifetime.  This point in time is Ks's active time (Tact), the time that Ks is said to be Active.  It is also Kc's retire time (Tret), the time that Kc is said to be Retired.  </p>
<p id="rfc.section.3.2.2.p.16">Tact(Ks) &gt;= Tkno(Ks), Tret(Kc) == Tact(Ks) </p>
<p id="rfc.section.3.2.2.p.17">S(Kc) = (DNSKEY Propagated, RRSIG Withdrawn) <br> P(Kc) = Known Retired <br> S(Ks) = (DNSKEY Propagated, RRSIG Introduced) <br> P(Ks) = Known Active <br> </p>
<p id="rfc.section.3.2.2.p.18">Activated Stage: Event 5 <br> Kc needs to be retained in the zone whilst any RRSIG records created by the retired key are still published in the zone or held in validator caches.  In other words, Kc should be retained in the zone until all RRSIG records created by Ks have been propagated.  This time is Ks's safe time (Tsaf), the time that Ks is considered to be Safe.  Consequently, at the same time Kc is considered to be Expired.  </p>
<p id="rfc.section.3.2.2.p.19">Tsaf(Ks) &gt;= Tact(Ks) + DcacheZ </p>
<p id="rfc.section.3.2.2.p.20">S(Kc) = (DNSKEY Propagated, RRSIG Dead) <br> P(Kc) = Known Expired <br> S(Ks) = (DNSKEY Propagated, RRSIG Propagated) <br> P(Ks) = Known Safe </p>
<p id="rfc.section.3.2.2.p.21">Withdrawal Stage: Event 6 <br> When all new signatures have been propagated, Kc can be removed from the zone and the DNSKEY RRset re-signed with the current KSK.  This time is Kc's removal time (Trem), the time that Kc is considered to be Removed.  </p>
<p id="rfc.section.3.2.2.p.22">Trem(Kc) &gt;= Tsaf(Ks) </p>
<p id="rfc.section.3.2.2.p.23">S(Kc) = (DNSKEY Withdrawn, RRSIG Dead) <br> P(Kc) = Removed Expired </p>
<p id="rfc.section.3.2.2.p.24">Complete Stage: Event 7 <br> From the perspective of the authoritative server, the rollover is complete.  After some delay, The DNSKEY record of Kc has expired from the caches.  This is Tfor, and the key is said to be Forgotten.  </p>
<p id="rfc.section.3.2.2.p.25">Tfor(Kc) &gt;= Trem(Kc) + DcacheK </p>
<p id="rfc.section.3.2.2.p.26">S(Kc) = (DNSKEY Dead, RRSIG Dead) <br> P(Kc) = Forgotten Expired </p>
<h1 id="rfc.section.3.2.3">
<a href="#rfc.section.3.2.3">3.2.3.</a> Double-RRSIG</h1>
<p id="rfc.section.3.2.3.p.1">[MM: Note it comes down to "signatures, generated with a key, whose public part is not published".] </p>
<p id="rfc.section.3.2.3.p.2">This involves introducing the new signatures first, while existing signatures are being retained.  This state of affairs remains in place for long enough to ensure that all RRsets cached in client validators contain two signatures.  The DNSKEY RR can now be switched.  For the period of time before the predecessor key has been expired from all caches, it does not matter if the validator uses the cached key or the successor key that is in the zone.  Both corresponding signatures can be retrieved from the cache or from the name server.  </p>
<p id="rfc.section.3.2.3.p.3">Once the signing process is complete and enough time has elapsed to allow all old information to expire from caches, the old signatures can be removed from the zone.  As before, during this period any combination of DNSKEY RRset and RRSIG will allow validation of at least one signature.  </p>
<p id="rfc.section.3.2.3.p.4">Double-RRSIG is also more complex than Double-Signature - first introducing the signatures, then switch the key and finally remove the old signatures.  It also takes more time than the Double-Signature method.  The method will be used where it is desired not to publish the public data of both keys at the same time.  As an advantage, the DNSKEY RRset is kept to a minimum which reduces the impact on priming performance.  The disadvantage is that for a period, each RRset returned will be accompanied by two RRSIGs.  </p>
<p id="rfc.section.3.2.3.p.5">When Ks is said to be Safe, the DNSKEY record of Kc may be removed.  At the same time that the DNSKEY record of Kc is removed, the DNSKEY record for Ks must be introduced.  If Ks is considered to be Known and Safe, Kc may be retired.  </p>
<div id="#rfc.figure.3"></div>
<p>The timeline diagram is shown below:</p>
<pre>
        |1|  |2|     |3|  |4|     |5|  |6|     |7|
Kc       |    |       |    |       |    |       |
- RRSIG  |----|-------|----|DcacheK|    |       |
- DNSKEY |----|-------|----|-------|----|DcacheZ|
         |    |       |    |       |    |       |
                           Trem    Tfor Tret    Texp

Ks       |    |       |    |       |    |       |
- RRSIG  |    |DcacheZ|----|-------|----|-------|---
- DNSKEY |    |       |    |DcacheK|----|-------|---
         |    |       |    |       |    |       |
         Tgen Tact    Tsaf Tpub    Tkno
    </pre>
<p>Figure: ZSK Double-RRSIG Rollover.</p>
<p id="rfc.section.3.2.3.p.6">Generation Stage: Event 1 <br> Key Ks is generated at the generate time (Tgen).  </p>
<p id="rfc.section.3.2.3.p.7">S(Ks) = (DNSKEY Generated, RRSIG Generated) <br> P(Ks) = Generated </p>
<p id="rfc.section.3.2.3.p.8">Preparation Stage: Event 2 <br> The zone is signed with Ks but existing signatures are retained.  The DNSKEY RR of Ks remains unpublished.  The time at which this occurs is Ks's active time (Tact), and the key is now said to be Active.  </p>
<p id="rfc.section.3.2.3.p.9">Tact(Ks) &gt;= Tgen(Ks) </p>
<p id="rfc.section.3.2.3.p.10">S(Ks) = (DNSKEY Generated, RRSIG Introduced) <br> P(Ks) = Active </p>
<p id="rfc.section.3.2.3.p.11">Ready Stage: Event 3 <br> Before the DNSKEY from Kc can be switched to Ks, the signatures of Ks must be published for long enough (DcacheZ) to guarantee that any validator that has a copy of any RRset, also has both signatures.  In other words, that any cached information is double signed.  After this delay, the key is said to be Safe.  The time at which this event occurs is Tsaf, which is given by: </p>
<p id="rfc.section.3.2.3.p.12">Tsaf(Ks) &gt;= Tact(Ks) + DcacheZ </p>
<p id="rfc.section.3.2.3.p.13">S(Ks) = (DNSKEY Generated, RRSIG Propagated) <br> P(Ks) = Safe </p>
<p id="rfc.section.3.2.3.p.14">Activation Stage: Event 4 <br> At some point in time, the decision is made to publish Ks.  This point in time is Ks's publish time (Tpub), the time that Ks is said to be Published.  At the same time, the DNSKEY RR of Kc is removed from the zone, and Kc is said to be Removed.  </p>
<p id="rfc.section.3.2.3.p.15">Tpub(Ks) &gt;= Tsaf(Ks), Trem(Kc) == Tpub(Ks) </p>
<p id="rfc.section.3.2.3.p.16">S(Kc) = (DNSKEY Removed, RRSIG Propagated) <br> P(Kc) = Removed Safe <br> S(Ks) = (DNSKEY Introduced, RRSIG Propagated) <br> P(Ks) = Published Safe <br> </p>
<p id="rfc.section.3.2.3.p.17">Activated Stage: Event 5 <br> The signatures of Kc need to be retained in the zone until the DNSKEY RR has expired from all validator caches.  When this happens, Ks is said to be Known (Tkno) and Kc is said to be Forgotten (Tfor).  </p>
<p id="rfc.section.3.2.3.p.18">Tfor(Kc) &gt;= Trem(Kc) + DcacheK <br> Tkno(Ks) &gt;= Tpub(Ks) + DcacheK </p>
<p id="rfc.section.3.2.3.p.19">S(Kc) = (DNSKEY Dead, RRSIG Propagated) <br> P(Kc) = Forgotten Safe <br> S(Ks) = (DNSKEY Propagated, RRSIG Propagated) <br> P(Ks) = Known Safe </p>
<p id="rfc.section.3.2.3.p.20">Withdrawal Stage: Event 6 <br> The signatures of Kc can be removed when the DNSKEY RR of Ks has been propagated.  This time is Kc's retire time (Tret), the time that Kc is considered to be Retired.  </p>
<p id="rfc.section.3.2.3.p.21">Tret(Kc) &gt;= Tsaf(Ks) </p>
<p id="rfc.section.3.2.3.p.22">S(Kc) = (DNSKEY Dead, RRSIG Withdrawn) <br> P(Kc) = Forgotten Retired </p>
<p id="rfc.section.3.2.3.p.23">Complete Stage: Event 7 <br> From the perspective of the authoritative server, the rollover is complete.  After some delay, all signatures of Kc have expired from the caches.  This is Texp, and the key is said to be Expired.  </p>
<p id="rfc.section.3.2.3.p.24">Texp(Kc) &gt;= Tret(Kc) + DcacheZ </p>
<p id="rfc.section.3.2.3.p.25">S(Kc) = (DNSKEY Dead, RRSIG Dead) <br> P(Kc) = Forgotten Expired </p>
<h1 id="rfc.section.3.3">
<a href="#rfc.section.3.3">3.3.</a> <a href="#ksk-rollovers" id="ksk-rollovers">KSK Rollovers</a>
</h1>
<p id="rfc.section.3.3.p.1">The most common rollover method for KSKs is Double-Signature, described in <a href="#RFC4641">RFC4641</a> <cite title="NONE">[RFC4641]</cite>.  Two more methods are identified in <a href="#key-timing">[key-timing]</a>: Double-DS and Double-RRset.  Double-RRset is the fastest way to rollover a KSK, while Double-Signature minimizes the number of required interactions to the parent, and Double-DS keeps the DNSKEY RRset as small as possible.  </p>
<p id="rfc.section.3.3.p.2">Note that with the KSK rollovers, it is out of scope whether the information within the zone is authentic.  It is assumed that there exists one or more ZSKs in the DNSKEY RRset that takes care of this during the rollover.  </p>
<h1 id="rfc.section.3.3.1">
<a href="#rfc.section.3.3.1">3.3.1.</a> Double-RRset</h1>
<p id="rfc.section.3.3.1.p.1">With Double-RRset, the new KSK is added to the DNSKEY RRset which is then signed with both the old and new key, and the new DS record added to the parent zone.  After waiting a suitable interval for the old DS and DNSKEY RRsets to expire from validator caches, the old DNSKEY and DS record are removed.  </p>
<p id="rfc.section.3.3.1.p.2">Only when Ks is said to be Known, e.g. the DNSKEY record of Ks is known to all validators, the DS record of Kc can be removed.  And only when all validators use the DS record of Ks to build the secure chain of trust, the DNSKEY record of Kc can be removed.  In other words, Ks needs to be Known and SafeDS, before Kc can be removed.  Thus, first all new information for Ks need to be introduced into the zone.  Once all has been propagated, all information of Kc can be withdrawn from the zone.  </p>
<div id="#rfc.figure.4"></div>
<p>The timeline diagram looks like this:</p>
<pre>
        |1|  |2|     |3|   |4|     |5|
Kc       |    |       |     |       |
- DNSKEY |----|-------|-----|DcacheK|
- DS     |----|-------|-----|DcacheP|
         |    |       |     |       |
                            Trem    Tfor
                            TretDS  TexpDS

Ks       |    |       |     |       |
- DNSKEY |    |DcacheK|-----|-------|---
- DS     |    |DcacheP|-----|-------|---
         |    |       |     |       |
         Tgen Tpub    Tkno 
              TactDS  TsafDS
    </pre>
<p>Figure: KSK Double-RRset Rollover.</p>
<p id="rfc.section.3.3.1.p.3">Generation Stage: Event 1 <br> Ks is generated at time Tgen.  </p>
<p id="rfc.section.3.3.1.p.4">S(Ks) = (DNSKEY Generated, DS Generated) <br> P(Ks) = Generated </p>
<p id="rfc.section.3.3.1.p.5">With the KSK Double-RRset Rollover, all new Validation Components of the key Ks are going to be added to the zone and are allowed to propagate into the caches of validators.  Thus, there is no need for a Preparation Stage.  </p>
<p id="rfc.section.3.3.1.p.6">Activation Stage: Event 2 <br> Ks is introduced into the zone; it is added to the DNSKEY RRset, which is then signed by all currently active KSKs (including Kc and Ks).  In addition, the DS record is submitted to the parent.  This is Ks's publish time (Tpub), the time that Ks is said to be Published.  It is also Ks's submit time (TactDS), the time that the DS record of Ks is Submitted (ActiveDS).  </p>
<p id="rfc.section.3.3.1.p.7">Tpub(ks) &gt;= Tgen(Ks), TactDS(Ks) == Tpub(Ks) </p>
<p id="rfc.section.3.3.1.p.8">S(Ks) = (DNSKEY Introduced, DS Introduced) <br> P(ks) = Published ActiveDS </p>
<p id="rfc.section.3.3.1.p.9">After the registration delay, the DS is published in the parent.  </p>
<p id="rfc.section.3.3.1.p.10">Activated Stage: Event 3 <br> The information for Ks must be published long enough to ensure that the information have reached all validators that may have the DNSKEY or DS RRset from this zone cached.  At the point in time that the DNSKEY RRset including Ks has been propagated (Tkno), Ks is said to be Known.  At the point in time that the DS RRset of Ks has been propagated (Tsaf), Ks is said to be SafeDS.  </p>
<p id="rfc.section.3.3.1.p.11">Tkno(Ks) &gt;= Tpub(Ks) + DcacheK, TsafDS(Ks) &gt;= TactDS(Ks) + DcacheP </p>
<p id="rfc.section.3.3.1.p.12">S(Ks) = (DNSKEY Propagated, DS Propagated) <br> P(Ks) = Known SafeDS </p>
<p id="rfc.section.3.3.1.p.13">Note that the request to the parent to withdraw the DS record of Kc can already be made after DcacheK.  It does not matter if the DS record for Ks has not yet been propagated, since the validator can authenticate the DNSKEY RRset with both Kc and Ks.  If the validator fetches a DS RRset from the cache, it uses Kc.  Otherwise, it can use Ks.  </p>
<p id="rfc.section.3.3.1.p.14">Withdrawal Stage: Event 4 <br> Once the successor key Ks is said to be Known, the DS record of Kc can be withdrawn.  If Ks is also said to be SafeDS, the DNSKEY record of Kc can be removed from the zone.  This is Kc's retire time (Tret), the time that Kc is said to be RetiredDS.  It is also Kc's removal time (Trem), the time that Kc is said to be Removed.  </p>
<p id="rfc.section.3.3.1.p.15">TretDS(Kc) &gt;= Tkno(ks) <br> Trem(Kc) &gt;= MAX(TsafDS(Ks), Tkno(Ks)) </p>
<p id="rfc.section.3.3.1.p.16">S(Kc) = (DNSKEY Withdrawn, DS Withdrawn) <br> P(Kc) = Removed RetiredDS </p>
<p id="rfc.section.3.3.1.p.17">Complete Stage: Event 5 <br> From the perspective of the authoritative server, the rollover is complete.  After some delay, Kc and its DS have also expired from the caches.  </p>
<p id="rfc.section.3.3.1.p.18">Tfor(Kc) &gt;= Trem(Kc) + DcachK <br> TexpDS(Kc) &gt;= TretDS(Kc) + DcacheP </p>
<p id="rfc.section.3.3.1.p.19">S(Kc) = (DNSKEY Dead, DS Dead) <br> P(Kc) = Forgotten Expired </p>
<h1 id="rfc.section.3.3.2">
<a href="#rfc.section.3.3.2">3.3.2.</a> Double-Signature</h1>
<p id="rfc.section.3.3.2.p.1">With Double-Signature, the new KSK is added to the DNSKEY RRset which is then signed with both the old and new key.  After waiting for the old RRset to expire from caches, the DS record in the parent zone is changed.  After waiting a further interval for this change to be reflected in caches, the old key is removed from the RRset.  </p>
<p id="rfc.section.3.3.2.p.2">If the number of interactions to the parent needs to be minimized, this rollover method is preferred over the Double-RRset method.  As a consequence, the DS record of Ks can be submitted to the parent only if it is safe to withdraw the DS record of Kc.  </p>
<p id="rfc.section.3.3.2.p.3">When Ks is said to be Known, the DS record can be changed When Ks is considered to be Known and SafeDS, the DNSKEY record of Kc can be removed.  </p>
<div id="#rfc.figure.5"></div>
<p>The timing diagram for such a rollover is:</p>
<pre>
        |1|  |2|     |3|   |4|     |5|    |6|     |7|
Kc       |    |       |     |       |      |       |
- DNSKEY |----|-------|-----|-------|------|DcacheK|
- DS     |----|-------|-----|DcacheP|      |       |
         |    |       |     |       |      |       |
                            TretDS  TexpDS Trem    Tfor

Ks       |    |       |     |       |      |       |
- DNSKEY |    |DcacheK|-----|-------|------|-------|---
- DS     |    |       |     |DcacheP|------|-------|---
         |    |       |     |       |      |       |
         Tgen Tpub    Tkno  TactDS  TsafDS
    </pre>
<p>Figure: KSK Double-Signature Rollover.</p>
<p id="rfc.section.3.3.2.p.4">Generation Stage: Event 1 <br> Ks is generated at time Tgen.  </p>
<p id="rfc.section.3.3.2.p.5">S(Ks) = (DNSKEY Generated, DS Generated) <br> P(Ks) = Generated </p>
<p id="rfc.section.3.3.2.p.6">Preparation Stage: Event 2 <br> Ks is introduced into the zone; it is added to the DNSKEY RRset, which is then signed by Ks and all currently active KSKs (including Kc).  This is the publication time (Tpub), the time that Ks is said to be Published.  </p>
<p id="rfc.section.3.3.2.p.7">Tpub(Ks) &gt;= Tgen(Ks) </p>
<p id="rfc.section.3.3.2.p.8">S(Ks) = (DNSKEY Introduced, DS Generated) <br> P(Ks) = Published </p>
<p id="rfc.section.3.3.2.p.9">Ready Stage: Event 3 <br> Before the corresponding DS can be submitted, the DNSKEY record of Ks must be published for long enough (DcacheK) to guarantee that any validator that has a copy of the DNSKEY RRset also includes this key.  In other words, that any prior cached information about the DNSKEY RRset has expired.  This time is Tkno and Ks is said to be Known.  </p>
<p id="rfc.section.3.3.2.p.10">Tkno(Ks) &gt;= Tpub(Ks) + DcacheK </p>
<p id="rfc.section.3.3.2.p.11">S(Ks) = (DNSKEY Propagated, DS Generated) <br> P(Ks) = Known </p>
<p id="rfc.section.3.3.2.p.12">Activation Stage: Event 4 <br> At some later time, the DS RR corresponding to Ks is submitted to the parent zone for publication, with a request that it replaces the DS RR corresponding to Kc.  This time is Ks's submit time (TactDS), the time that Ks is considered to be Submitted.  It is also Kc's retire time (TretDS), the time that Kc is considered to be RetiredDS.  </p>
<p id="rfc.section.3.3.2.p.13">TactDS(Ks) &gt;= Tkno(Ks) <br> TretDS(kc) == TactDS(Kc) </p>
<p id="rfc.section.3.3.2.p.14">S(Kc) = (DNSKEY Propagated, DS Withdrawn) <br> P(Ks) = Known RetiredDS <br> S(Ks) = (DNSKEY Propagated, DS Introduced) <br> P(Ks) = Known ActiveDS </p>
<p id="rfc.section.3.3.2.p.15">After the registration delay, the DS is published in the parent.  </p>
<p id="rfc.section.3.3.2.p.16">Activated Stage: Event 5 <br> At some time later, all validators that have the DS RRset cached will have a a copy that includes the new DS record.  This is Ks's safe time (TsafDS), the time that the new KSK is said to be SafeDS. Consequently, Kc is said to be ExpiredDS (TexpDS).  </p>
<p id="rfc.section.3.3.2.p.17">TsafDS(Ks) &gt;= TactDS(Ks) + DcacheP <br> TexpDS(Kc) &gt;= TretDS(Kc) + DcacheP </p>
<p id="rfc.section.3.3.2.p.18">S(Kc) = (DNSKEY Propagated, DS Dead)  <br> P(kc) = Known ExpiredDS <br> S(Ks) = (DNSKEY Propagated, DS Propagated)  <br> P(Ks) = Known SafeDS </p>
<p id="rfc.section.3.3.2.p.19">Withdrawal Stage: Event 6 <br> When the new DS record has been propagated, the DNSKEY record of Kc can be removed from the zone.  This is Kc's removal time (Trem), the time that Kc is said to be Removed.  </p>
<p id="rfc.section.3.3.2.p.20">Trem(Kc) &gt;= TsafDS(Ks) </p>
<p id="rfc.section.3.3.2.p.21">S(Kc) = (DNSKEY Withdrawn, DS Dead) <br> P(Kc) = Removed ExpiredDS </p>
<p id="rfc.section.3.3.2.p.22">Complete Stage: Event 7 <br> From the perspective of the authoritative server, the rollover is complete.  After some delay, The DNSKEY record of Kc has also expired from the caches.  </p>
<p id="rfc.section.3.3.2.p.23">Tfor(Kc) &gt;= Trem(Kc) + DcacheK </p>
<p id="rfc.section.3.3.2.p.24">S(Kc) = (DNSKEY Dead, DS Dead) <br> P(Kc) = Forgotten ExpiredDS </p>
<h1 id="rfc.section.3.3.3">
<a href="#rfc.section.3.3.3">3.3.3.</a> Double-DS</h1>
<p id="rfc.section.3.3.3.p.1">In this case, first the new DS record is published.  After waiting for this change to propagate into the caches of all validators, the KSK is changed.  After waiting another interval, during which the old DNSKEY RRset expires from caches, the old DS record is removed.  </p>
<p id="rfc.section.3.3.3.p.2">If the size of the DNSKEY RRset needs to be minimized, this rollover method is preferred over Double-RRset.  It does require the additional administrative overhead of two interactions with the parent to roll a KSK.  </p>
<p id="rfc.section.3.3.3.p.3">When Ks is said to be SafeDS, the DNSKEY record of Kc can be removed.  At the same time, the DNSKEY record of Ks can be introduced.  When Ks is considered to be Known and SafeDS, the DS record of Kc can be removed.  </p>
<div id="#rfc.figure.6"></div>
<p>The timeline diagram looks like this:</p>
<pre>
        |1|  |2|     |3|     |4|     |5|   |6|     |7|
Kc       |    |       |       |       |     |       |
- DNSKEY |----|-------|-------|DcacheK|     |       |
- DS     |----|-------|-------|-------|-----|DcacheP|
         |    |       |       |       |     |       |
                              Trem    Tfor  TretDS  TexpDS

Ks       |    |       |       |       |     |       |
- DNSKEY |    |       |       |DcacheK|-----|-------|---
- DS     |    |DcacheP|-------|-------|-----|-------|---
         |    |       |       |       |     |       |
         Tgen TactDS  TsafDS  Tpub    Tkno
    </pre>
<p>Figure: KSK Double-DS Rollover.</p>
<p id="rfc.section.3.3.3.p.4">Generation Stage: Event 1 <br> Ks is generated at time Tgen.  </p>
<p id="rfc.section.3.3.3.p.5">S(Ks) = (DNSKEY Generated, DS Generated) <br> P(Ks) = Generated </p>
<p id="rfc.section.3.3.3.p.6">Preparation Stage: Event 2 <br> Before the new key Ks can be introduced into the zone, the new DS record needs to be submitted.  This is allowed, because there exists a valid chain of trust for the same algorithm (with the current key Kc).  This is Ks's submit time (TactDS), the time that the DS record of Ks was submitted and is said to be ActiveDS.  </p>
<p id="rfc.section.3.3.3.p.7">TactDS(Ks) &gt;= Tgen(Ks) </p>
<p id="rfc.section.3.3.3.p.8">S(Ks) = (DNSKEY Generated, DS Introduced) <br> P(Kc) = ActiveDS </p>
<p id="rfc.section.3.3.3.p.9">After some delay, the DS becomes available in the parent zone.  </p>
<p id="rfc.section.3.3.3.p.10">Ready Stage: Event 3 <br> Some time later, the new DS RRset has been propagated.  This is Ks's safe time (TsafDS), the time that Ks is said to be SafeDS.  </p>
<p id="rfc.section.3.3.3.p.11">TsafDS(Ks) &gt;= TactDS(Ks) + DcacheP </p>
<p id="rfc.section.3.3.3.p.12">S(Ks) = (DNSKEY Generated, DS Propagated) <br> P(Ks) = SafeDS </p>
<p id="rfc.section.3.3.3.p.13">Activation Stage: Event 4 <br> Because there are now two trust anchors a validator can use, the DNSKEY record of Kc can be switched with the DNSKEY record of Ks.  Kc becomes retired and the DNSKEY RRset is only signed with Ks.  This time is Ks's publish time (Tpub), the time that Ks is said to be Published.  It is also Kc's removal time (Trem), the time that Kc is said to be Removed.  </p>
<p id="rfc.section.3.3.3.p.14">Tpub(Ks) &gt;= TsafDS(Ks) <br> Trem(Kc) == Tpub(Ks) </p>
<p id="rfc.section.3.3.3.p.15">S(Kc) = (DNSKEY Withdrawn, DS Propagated) <br> P(Kc) = Removed SafeDS <br> S(Ks) = (DNSKEY Introduced, DS Propagated) <br> P(Ks) = Published SafeDS </p>
<p id="rfc.section.3.3.3.p.16">Activated Stage: Event 5 <br> Before the DS record of Kc can be withdrawn, Kc will have to expire from validator caches.  When the DNSKEY RRset that includes Kc has expired from caches, Kc is said to be Forgotten and Ks is said to be Known.  This happens at Ks's known time, given by: </p>
<p id="rfc.section.3.3.3.p.17">Tkno(Ks) &gt;= Tpub(Ks) + DcacheK <br> Tfor(Kc) == Tkno(Ks) </p>
<p id="rfc.section.3.3.3.p.18">S(Kc) = (DNSKEY Dead, DS Propagated) <br> P(Kc) = Forgotten SafeDS <br> S(Ks) = (DNSKEY Propagated, DS Propagated) <br> P(Ks) = Known SafeDS </p>
<p id="rfc.section.3.3.3.p.19">Withdrawal Stage: Event 6 <br> Now that there is a key Ks that is said to be Propagated and SafeDS, the DS record of Kc can be withdrawn.  This is Kc's retire time (TretDS), the time that there is no need for a secure delegation for Kc anymore.  </p>
<p id="rfc.section.3.3.3.p.20">TretDS(Kc) &gt;= Tkno(Ks) </p>
<p id="rfc.section.3.3.3.p.21">S(Kc) = (DNSKEY Dead, DS Withdrawn) <br> P(Kc) = Forgotten RetiredDS </p>
<p id="rfc.section.3.3.3.p.22">Complete Stage: Event 7 <br> From the perspective of the authoritative server, the rollover is complete.  After some delay, The DS record of Kc has expired from the caches.  This is Texp, given by: </p>
<p id="rfc.section.3.3.3.p.23">Texp(Kc) &gt;= Tret(Kc) + DcacheP </p>
<p id="rfc.section.3.3.3.p.24">S(Kc) = (DNSKEY Dead, DS Dead) <br> P(Kc) = Forgotten ExpiredDS </p>
<h1 id="rfc.section.3.3.4">
<a href="#rfc.section.3.3.4">3.3.4.</a> Interaction with Configured Trust Anchors</h1>
<p id="rfc.section.3.3.4.p.1">Zone managers may want to take into account the possibility that some validators may have their KSK configured as a trust anchor directly, as described in <a href="#RFC5011">RFC5011</a> <cite title="NONE">[RFC5011]</cite>.  This influences the value of DcacheK, the time to guarantee that any validator that has a copy of the newest DNSKEY RRset.  </p>
<h1 id="rfc.section.3.3.4.1">
<a href="#rfc.section.3.3.4.1">3.3.4.1.</a> Adding a KSK</h1>
<p id="rfc.section.3.3.4.1.p.1">When the new key is introduced, the delay DcacheK between Tpub and Tkno is also subject to the property: </p>
<p id="rfc.section.3.3.4.1.p.2">DcacheK' = MAX(DcacheK, 2 * (queryInterval + x * retryTime) + c) </p>
<p id="rfc.section.3.3.4.1.p.3">The right hand side of this expression is two times the Active Refresh time defined in section 2.3 in <a href="#RFC5011">RFC5011</a> <cite title="NONE">[RFC5011]</cite>.  This ensures that the successor key is at least seen twice by RFC5011-aware validators.  The parameter x is the maximum number of retries that is taken as a safety margin, in case an Active Refresh fails.  The parameter c is a constant that can be taken as an additional safety margin.  </p>
<p id="rfc.section.3.3.4.1.p.4">Most probably, this delays the time when a key is said to be Known.  </p>
<h1 id="rfc.section.3.3.4.2">
<a href="#rfc.section.3.3.4.2">3.3.4.2.</a> Removing a KSK</h1>
<p id="rfc.section.3.3.4.2.p.1">When the current key is ready to be removed from the zone, it is instead going to be revoked.  The REVOKE bit is set and the key is published for DcacheK' time: </p>
<p id="rfc.section.3.3.4.2.p.2">DcacheK' = MAX(DcacheK, (queryInterval + x * retryTime) + c) </p>
<p id="rfc.section.3.3.4.2.p.3">The right hand side of this expression is the Active Refresh time defined in section 2.3 in <a href="#RFC5011">RFC5011</a> <cite title="NONE">[RFC5011]</cite>.  This ensures that the revoked key is at least seen once by RFC5011-aware validators.  </p>
<p id="rfc.section.3.3.4.2.p.4">After that delay, every RFC5011-aware validator has seen the revoked key and the DNSKEY record may be removed from the zone.  Another DcacheK delay, the key has fully expired from all the validator caches.  </p>
<h1 id="rfc.section.3.4">
<a href="#rfc.section.3.4">3.4.</a> <a href="#stss-rollovers" id="stss-rollovers">Rollovers in a Single Type Signing Scheme</a>
</h1>
<p id="rfc.section.3.4.p.1">Previous sections described the possible ways to roll keys that have one key type (either ZSK or KSK).  In situations where a Single Type Signing Scheme (STSS) is used, one key is used both as ZSK and KSK.  This key is responsible for authenticating information within the zone, as well as authenticating the DNSKEY RRset.  STSS Rollovers can be constructed by combining a ZSK rollover method with a KSK rollover method.  However, not all combinations are possible.  For example, the ZSK Double-RRSIG rollover is only suitable for combining with the KSK Double-DS rollover, because both keep the DNSKEY RRset to a minimum size.  The other rollovers are ruled out because they require a period where both the DNSKEY record of the current key and its successor are being served at the same time.  </p>
<p id="rfc.section.3.4.p.2">The ZSK Pre-Publication method is suitable for combining with the KSK Double-RRset and KSK Double-Signature rollover methods, but does not gain any advantages when combined with the KSK Double-RRSet.  In both cases the DNSKEY record needs to be post-published, taking a similar amount of time.  However, the KSK Double-RRset requires two interactions with the parent, while the KSK Double-Signature only involves one interaction.  Therefore, the ZSK Pre-Publication rollover combined with the KSK Double-RRset is left out of this document.  </p>
<p id="rfc.section.3.4.p.3">The ZSK Double-Signature method is suitable for combining with both the KSK Double-RRset and the KSK Double-Signature method.  </p>
<p id="rfc.section.3.4.p.4">To conclude, there are four different STSS rollover methods.  </p>
<h1 id="rfc.section.3.4.1">
<a href="#rfc.section.3.4.1">3.4.1.</a> Double-RRset</h1>
<p id="rfc.section.3.4.1.p.1">This is a combination of the ZSK Double-Signature rollover and the KSK Double-RRset rollover.  The new key is added to the DNSKEY RRset, and all RRsets - including the DNSKEY RRset - are then signed with both the old and new key, and the new DS record added to the parent zone.  After waiting a suitable interval for the old DS and all zone RRsets to expire from validator caches, the old DNSKEY and DS record are removed.  </p>
<p id="rfc.section.3.4.1.p.2">Double-RRset is the fastest way to replace keys in a Single Type Signing Scheme.  However, the disadvantages are that it requires two signatures and two keys during the period of the rollover, as well as two interactions with the parent.  </p>
<div id="#rfc.figure.7"></div>
<p>The timeline diagram looks like this:</p>
<pre>
        |1|  |2|     |3|   |4|     |5|
Kc       |    |       |     |       |
- RRSIG  |----|-------|-----|DcacheZ|
- DNSKEY |----|-------|-----|DcacheK|
- DS     |----|-------|-----|DcacheP|
         |    |       |     |       |
                            Trem    Tfor
                            Tret    Texp
                            TretDS  TexpDS

Ks       |    |       |     |       |
- RRSIG  |    |DcacheZ|-----|-------|---
- DNSKEY |    |DcacheK|-----|-------|---
- DS     |    |DcacheP|-----|-------|---
         |    |       |     |       |
         Tgen Tpub    Tkno 
              Tact    Tsaf
              TactDS  TsafDS
    </pre>
<p>Figure: STSS Double-RRset Rollover.</p>
<p id="rfc.section.3.4.1.p.3">The rollover method is almost the same as that of the KSK Double-RRset rollover, except now also DcacheZ has to be taken into account.  </p>
<h1 id="rfc.section.3.4.2">
<a href="#rfc.section.3.4.2">3.4.2.</a> Double-Signature</h1>
<p id="rfc.section.3.4.2.p.1">This is a combination of the ZSK Double-Signature rollover and the KSK Double-Signature rollover.  The new key is added to the DNSKEY RRset and all RRsets are then signed with both the old and new key.  After waiting for the old RRsets to expire from caches, the DS record in the parent zone is changed.  After waiting a further interval for this change to be reflected in caches, the old key is removed from the DNSKEY RRset, and all RRsets are signed with the new key only.  </p>
<p id="rfc.section.3.4.2.p.2">This rollover minimizes the number of interactions with the parent zone.  However, for the period of the rollover all RRsets are still signed with two keys, so increasing the size of the zone and the size of the response.  </p>
<div id="#rfc.figure.8"></div>
<p>The timing diagram for such a rollover is:</p>
<pre>
        |1|  |2|     |3|   |4|     |5|    |6|     |7|
Kc       |    |       |     |       |      |       |
- RRSIG  |----|-------|-----|-------|------|DcacheZ|
- DNSKEY |----|-------|-----|-------|------|DcacheK|
- DS     |----|-------|-----|DcacheP|      |       |
         |    |       |     |       |      |       |
                            TretDS  TexpDS Trem    Tfor
                                           Tret    Texp

Ks       |    |       |     |       |      |       |
- RRSIG  |    |DcacheZ|-----|-------|------|-------|---
- DNSKEY |    |DcacheK|-----|-------|------|-------|---
- DS     |    |       |     |DcacheP|------|-------|---
         |    |       |     |       |      |       |
         Tgen Tpub    Tkno  TactDS  TsafDS
              Tact    Tsaf
    </pre>
<p>Figure: STSS Double-Signature Rollover.</p>
<p id="rfc.section.3.4.2.p.3">The rollover method is almost the same as that of the KSK Double-RRset rollover, except now also DcacheZ has to be taken into account.  </p>
<h1 id="rfc.section.3.4.3">
<a href="#rfc.section.3.4.3">3.4.3.</a> Pre-Publication</h1>
<p id="rfc.section.3.4.3.p.1">This is a combination of the ZSK Pre-Publication rollover and the KSK Double-Signature rollover and requires only one interaction with the parent.  In addition, the non-DNSKEY RRsets require only one signature during the rollover.  If speed is not an issue, this rollover method might be the way to go in a STSS environment, since it optimizes in both size and interactions with the parent.  </p>
<p id="rfc.section.3.4.3.p.2">The new key is added to the DNSKEY RRset and the DNSKEY RRset is then signed with both the old and new key.  Other RRsets will only be signed with the old key.  Only after the DS has been switched, the signatures of other RRsets are replaced with that of the new key.  After waiting a further interval for this change to be reflected in caches, the old key is removed from the RRset, and is signed with the new key only.  </p>
<div id="#rfc.figure.9"></div>
<p>The timeline diagram looks like this:</p>
<pre>
        |1|  |2|     |3|   |4|     |5|     |6|     |7|  |8|     |9|
Kc       |    |       |     |       |       |       |    |       |
- RRSIG  |----|-------|-----|-------|-------|DcacheZ|    |       |
- DNSKEY |----|-------|-----|-------|-------|-------|----|DcacheK|
- DS     |----|-------|-----|DcacheP|       |       |    |       |
         |    |       |     |       |       |       |    |       |
                            TretDS  TexpDS  Tret    Texp Trem    Tfor

Ks       |    |       |     |       |       |       |    |       |
- RRSIG  |    |       |     |       |       |DcacheZ|----|-------|
- DNSKEY |    |DcacheK|-----|-------|-------|-------|----|-------|
- DS     |    |       |     |DcacheP|-------|-------|----|-------|
         |    |       |     |       |       |       |    |       |
         Tgen Tpub    Tkno  TactDS  TsafDS  Tact    Tsaf
    </pre>
<p>Figure: STSS Pre-Publication Rollover.</p>
<p id="rfc.section.3.4.3.p.3">Generation Stage: Event 1 <br> Key Ks is generated at the generate time (Tgen).  </p>
<p id="rfc.section.3.4.3.p.4">S(Ks) = (DNSKEY Generated, RRSIG Generated, DS Generated) <br> P(Ks) = Generated </p>
<p id="rfc.section.3.4.3.p.5">Preparation Stage: Event 2 <br> The DNSKEY record of Ks is put into the zone, i.e. it is added to the DNSKEY RRset which is then re-signed with the Ks and all other current KSKs (including Kc).  The time at which this occurs is Ks's publication time (Tpub), and the key is now said to be Published.  Note that the key is not yet used to sign other RRsets.  </p>
<p id="rfc.section.3.4.3.p.6">Tpub(Ks) &gt;= Tgen(Ks) </p>
<p id="rfc.section.3.4.3.p.7">S(Ks) = (DNSKEY Introduced, RRSIG Generated, DS Generated) <br> P(Ks) = Published </p>
<p id="rfc.section.3.4.3.p.8">Ready Stage: Event 3 <br> Before the DS record may be switched, the DNSKEY record of Ks must be published for long enough (DcacheK) to guarantee that any validator that has a copy of the DNSKEY RRset also includes this key.  After this delay, the key is said to be Known and the DS record may be submitted.  The time at which this event occurs is Ks's known time (Tkno), which is given by: </p>
<p id="rfc.section.3.4.3.p.9">Tkno(Ks) &gt;= Tpub(Ks) + DcacheK </p>
<p id="rfc.section.3.4.3.p.10">S(Ks) = (DNSKEY Propagated, RRSIG Generated, DS Generated) <br> P(ks) = Known </p>
<p id="rfc.section.3.4.3.p.11">Preparation Stage (2): Event 4 <br> At Ks's submit time (TactDS), the DS RR corresponding to Ks is submitted to the parent zone for publication, with a request that it replaces the DS RR corresponding to Kc.  Ks is said to be ActiveDS.  This time is also Kc's retire time (TretDS) and Kc is said to be RetiredDS.  </p>
<p id="rfc.section.3.4.3.p.12">TactDS(Ks) &gt;= Tkno(Ks) TretDS(Kc) == TactDS(Ks) </p>
<p id="rfc.section.3.4.3.p.13">S(Kc) = (DNSKEY Propagated, RRSIG Propagated, DS Withdrawn) <br> P(Kc) = Known Safe RetiredDS <br> S(Ks) = (DNSKEY Propagated, RRSIG Generated, DS Introduced) <br> P(Ks) = Known ActiveDS </p>
<p id="rfc.section.3.4.3.p.14">Some time later, the new DS RRset is published at the parent.  </p>
<p id="rfc.section.3.4.3.p.15">Ready Stage (2): Event 5 <br> Some time later, all validators use the DS RRset that includes a copy of the DS record of Ks.  At this time, Ks's safe time (TsafDS), Ks is said to be SafeDS.  But Kc is still used as the ZSK.  </p>
<p id="rfc.section.3.4.3.p.16">TsafDS(Ks) &gt;= TactDS(Ks) + DcacheP <br> TexpDS(Kc) &gt;= TretDS(Kc) + DcacheP </p>
<p id="rfc.section.3.4.3.p.17">S(Kc) = (DNSKEY Propagated, RRSIG Propagated, DS Dead) <br> P(kc) = Known Safe ExpiredDS <br> S(Ks) = (DNSKEY Propagated, RRSIG Generated, DS Propagated) <br> P(Ks) = Known SafeDS </p>
<p id="rfc.section.3.4.3.p.18">Activation Stage: Event 6 <br> At some point in time, the decision is made to actually start signing the zone using the successor key.  This will be when the current key has been in use for an interval equal to the key lifetime.  This point in time is Ks's active time (Tact), the time that Ks is said to be Active.  It is also Kc's retire time (Tret), the time that Kc is said to be Retired.  </p>
<p id="rfc.section.3.4.3.p.19">Tact(Ks) &gt;= TsafDS(Ks) <br> Tret(Kc) == Tact(Ks) </p>
<p id="rfc.section.3.4.3.p.20">S(Kc) = (DNSKEY Propagated, RRSIG Withdrawn, DS Dead)) <br> P(Kc) = Known Retired ExpiredDS <br> S(Ks) = (DNSKEY Propagated, RRSIG Introduced, DS Propagated)) <br> P(Ks) = Known Active SafeDS </p>
<p id="rfc.section.3.4.3.p.21">Activated Stage: Event 7 <br> Kc needs to be retained in the zone whilst any RRSIG records created by the retired key are still published in the zone or held in validator caches.  In other words, Kc should be retained in the zone until all RRSIG records created by Ks have been propagated.  This time is Ks's safe time (Tsaf), the time that Ks is considered to be Safe, and Kc's expiration time (Texp), the time that Kc is considered to be Expired.  </p>
<p id="rfc.section.3.4.3.p.22">Tsaf(Ks) &gt;= Tact(Ks) + DcacheZ <br> Texp(Kc) == Tsaf(Ks) </p>
<p id="rfc.section.3.4.3.p.23">S(Kc) = (DNSKEY Propagated, RRSIG Dead, DS Dead) <br> P(Kc) = Known Expired ExpiredDS <br> S(Ks) = (DNSKEY Propagated, RRSIG Propagated, DS Propagated) <br> P(Ks) = Known Safe SafeDS </p>
<p id="rfc.section.3.4.3.p.24">Withdrawal Stage: Event 8 <br> When all new signatures have been propagated, Kc can be removed from the zone and the DNSKEY RRset re-signed with the current KSK.  This time is Kc's removal time (Trem), the time that Kc is considered to be Removed.  </p>
<p id="rfc.section.3.4.3.p.25">Trem(Kc) &gt;= Tsaf(Ks) </p>
<p id="rfc.section.3.4.3.p.26">S(Kc) = (DNSKEY Withdrawn, RRSIG Dead, DS Dead) <br> P(Kc) = Removed Expired ExpiredDS </p>
<p id="rfc.section.3.4.3.p.27">Complete Stage: Event 9 <br> From the perspective of the authoritative server, the rollover is complete.  After some delay, The DNSKEY record of Kc has expired from the caches.  This is Tfor, the time that the key is said to be Forgotten.  </p>
<p id="rfc.section.3.4.3.p.28">Tfor(Kc) &gt;= Trem(Kc) + DcacheK </p>
<p id="rfc.section.3.4.3.p.29">S(Kc) = (DNSKEY Dead, RRSIG Dead, DS Dead) <br> P(Kc) = Forgotten Expired ExpiredDS </p>
<h1 id="rfc.section.3.4.4">
<a href="#rfc.section.3.4.4">3.4.4.</a> Double-DS</h1>
<p id="rfc.section.3.4.4.p.1">This is a combination of the ZSK Double-RRSIG rollover and the KSK Double-DS rollover.  This keeps the DNSKEY RRset to a minimum size, but at the cost of double signatures in the zone and the necessity of two interactions with the parent.  </p>
<p id="rfc.section.3.4.4.p.2">The new signatures are added to the zone and the new DS is submitted.  Once all signatures and the DS record have been propagated, the DNSKEY is switched.  After waiting a further interval for this switch to be reflected in caches, the old signatures are removed and the old DS record is withdrawn from the parent zone.  </p>
<div id="#rfc.figure.10"></div>
<p>The timeline diagram looks like this:</p>
<pre>
        |1|  |2|     |3|    |4|     |5|     |6|     |7|
Kc       |    |       |      |       |       |       |
- RRSIG  |----|-------|------|-------|-------|DcacheZ|
- DNSKEY |----|-------|------|DcacheK|       |       |
- DS     |----|-------|------|-------|-------|DcacheP|
         |    |       |      |       |       |       |
                             Trem    Tfor    Tret    Texp
                                             TretDS  TexpDS

Ks       |    |       |      |       |       |       |    
- RRSIG  |    |DcacheZ|------|-------|-------|-------|----
- DNSKEY |    |       |      |DcacheK|-------|-------|----
- DS     |    |DcacheP|------|-------|-------|-------|----
         |    |       |      |       |       |       |    
         Tgen Tact    Tsaf   Tpub    Tkno
              TactDS  TsafDS
    </pre>
<p>Figure: STSS Double-DS Rollover.</p>
<p id="rfc.section.3.4.4.p.3">Generation Stage: Event 1 <br> Key Ks is generated at the generate time (Tgen).  </p>
<p id="rfc.section.3.4.4.p.4">S(Ks) = (DNSKEY Generated, RRSIG Generated, DS Generated) <br> P(Ks) = Generated </p>
<p id="rfc.section.3.4.4.p.5">Preparation Stage: Event 2 <br> Before the new key Ks can be introduced into the zone, the new signatures must be introduced and the new DS record must be submitted.  This time is Ks's active time (Tact), the time that Ks is said to be Active.  It is also Ks's submit time (TactDS), the time that the DS record of Ks was submitted and is said to be ActiveDS.  </p>
<p id="rfc.section.3.4.4.p.6">Tact(Ks) &gt;= Tgen(Ks) <br> TactDS(Ks) &gt;= Tgen(Ks) </p>
<p id="rfc.section.3.4.4.p.7">S(Ks) = (DNSKEY Generated, RRSIG Introduced, DS Introduced) <br> P(Kc) = Active ActiveDS </p>
<p id="rfc.section.3.4.4.p.8">After some delay, the DS becomes available in the parent zone.  </p>
<p id="rfc.section.3.4.4.p.9">Ready Stage: Event 3 <br> Some time later, the new signatures and the new DS RRset have been propagated.  This is Ks's safe time (Tsaf, TsafDS), the time that Ks is said to be Safe and SafeDS.  </p>
<p id="rfc.section.3.4.4.p.10">Tsaf(Ks) &gt;= Tact(Ks) + DcacheZ <br> TsafDS(Ks) &gt;= TactDS(Ks) + DcacheP </p>
<p id="rfc.section.3.4.4.p.11">S(Ks) = (DNSKEY Generated, RRSIG Propagated, DS Propagated) <br> P(Ks) = Safe SafeDS </p>
<p id="rfc.section.3.4.4.p.12">Activation Stage: Event 4 <br> Because there are now two trust anchors a validator can use, the DNSKEY record of Kc can be switched with the DNSKEY record of Ks.  This time is Ks's publish time (Tpub), the time that Ks is said to be Published.  It is also Kc's removal time (Trem), the time that Kc is removed from the zone.  </p>
<p id="rfc.section.3.4.4.p.13">Tpub(Ks) &gt;= MAX(TsafDS(Ks), Tsaf(Ks)) <br> Trem(Kc) == Tpub(Ks) </p>
<p id="rfc.section.3.4.4.p.14">S(Kc) = (DNSKEY Withdrawn, RRSIG Propagated, DS Propagated) <br> P(Kc) = Removed Safe SafeDS <br> S(Ks) = (DNSKEY Introduced, RRSIG Propagated, DS Propagated) <br> P(Ks) = Published Safe SafeDS </p>
<p id="rfc.section.3.4.4.p.15">Activated Stage: Event 5 <br> When the signatures of Kc and its corresponding DS record have expired from the caches, the DNSKEY record of Kc can be withdrawn from the zone.  When the DNSKEY RRset that includes Kc has been expired, Ks is said to be Known and Kc is said to be Removed.  This happens at Ks's known time, given by: </p>
<p id="rfc.section.3.4.4.p.16">Tkno(Ks) &gt;= Tpub(Ks) + DcacheK, Trem(Kc) == Tkno(Ks) </p>
<p id="rfc.section.3.4.4.p.17">S(Kc) = (DNSKEY Dead, RRSIG Propagated, DS Propagated) <br> P(Kc) = Forgotten Safe SafeDS <br> S(Ks) = (DNSKEY Propagated, RRSIG Propagated, DS Propagated) <br> P(Ks) = Known Safe SafeDS </p>
<p id="rfc.section.3.4.4.p.18">Withdrawal Stage: Event 6 <br> Some time later, Ks is said to be Propagated and SafeDS, and the signatures and DS record of Kc may be withdrawn.  This is this Kc's retire time (Tret, TretDS), the time Kc is said to be Retired and RetiredDS.  </p>
<p id="rfc.section.3.4.4.p.19">Tret(Kc) &gt;= Tkno(Ks) <br> TretDS(Kc) &gt;= Tkno(Ks) </p>
<p id="rfc.section.3.4.4.p.20">S(Kc) = (DNSKEY Dead, RRSIG Withdrawn, DS Withdrawn) <br> P(Kc) = Forgotten Retired RetiredDS </p>
<p id="rfc.section.3.4.4.p.21">Complete Stage: Event 7 <br> From the perspective of the authoritative server, the rollover is complete.  After some delay, The signatures of Kc and its corresponding DS record have expired from the caches.  </p>
<p id="rfc.section.3.4.4.p.22">Texp(Kc) &gt;= Tret(Kc) + DcacheZ <br> TexpDS(Kc) &gt;= TretDS(Kc) + DcacheP </p>
<p id="rfc.section.3.4.4.p.23">S(Kc) = (DNSKEY Dead, RRSIG Dead, DS Dead) <br> P(Kc) = Forgotten Expired ExpiredDS </p>
<h1 id="rfc.section.3.5">
<a href="#rfc.section.3.5">3.5.</a> <a href="#standby" id="standby">Stand-by Keys</a>
</h1>
<p id="rfc.section.3.5.p.1">Although keys will usually be rolled according to some regular schedule, there may be occasions where an emergency rollover is required, e.g. if the active key is suspected of being compromised.  The aim of the emergency rollover is to allow the zone to be re-signed with a new key as soon as possible.  As a key must be ready to sign the zone, having at least one additional key (a stand-by key) in this state at all times will minimise delay.  </p>
<p id="rfc.section.3.5.p.2">In the case of a ZSK, a stand-by key only makes sense with the Pre-Publication method, since with the Double-Signature and Double-RRSIG methods, the stand-by key would be used for signing.  The goal is to make the stand-by key Known.  This goal is reached at Tkno, step 3 in the Pre-Publication method timeline diagram.  </p>
<p id="rfc.section.3.5.p.3">A successor key must always be published soon enough so that the key lifetime of the predecessor key does not expire.  As a consequence, a stand-by ZSK Ks must at latest be published DcacheK delay before the lifetime of the predecessor ZSK Kc has reached: </p>
<p id="rfc.section.3.5.p.4">Tpub(Ks) &lt;= Tact(Kc) + Lzsk - DcacheK </p>
<p id="rfc.section.3.5.p.5">Here, Lzsk is the lifetime of ZSKs according to policy.  </p>
<p id="rfc.section.3.5.p.6">In the case of a KSK, a stand-by key only makes sense with the Double-DS method, since in the other cases, the key would be needed to sign the DNSKEY RRset.  The goal is to get the stand-by key in the SafeDS property.  This goal is reached at TsafDS, step 3 in the Double-DS method timeline diagram.  </p>
<p id="rfc.section.3.5.p.7">The DS record for the stand-by KSK Ks should be propagated to the caches before the key lifetime of the predecessor KSK Kc expires: </p>
<p id="rfc.section.3.5.p.8">TactDS(Ks) &lt;= Tact(Kc) + Lksk - DcacheP </p>
<p id="rfc.section.3.5.p.9">Here, Lksk is the lifetime of KSKs according to policy.  </p>
<p id="rfc.section.3.5.p.10">Because a stand-by KSK only makes sense with the Double-DS method, stand-by keys in a STSS is not applicable.  This is because the Double-DS method is not easy integratable with one of the ZSK rollover methods.  </p>
<h1 id="rfc.section.4">
<a href="#rfc.section.4">4.</a> <a href="#policy" id="policy">Policy rollover</a>
</h1>
<p id="rfc.section.4.p.1">Besides (un)scheduled key rollovers, changes in policy may occur.  The initial transition is enabling DNSSEC. The counterpart, disabling DNSSEC, is also possible.  Two other examples of policy changes are are algorithm rollover and changing signing schemes.  </p>
<h1 id="rfc.section.4.1">
<a href="#rfc.section.4.1">4.1.</a> <a href="#enabling" id="enabling">Enabling DNSSEC</a>
</h1>
<p id="rfc.section.4.1.p.1">When a zone makes the transition from going insecure to secure, the initial set of keys safely need to be introduced into the zone.  The goals of this event is to make a ZSK (Kz) and a KSK (Kk) both Known and Safe.  </p>
<p id="rfc.section.4.1.p.2">A zone must be fully signed, before the DS associated with the initial KSK is published.  The ZSK and KSK can be the same key, for example in a Single Type Signing Scheme.  </p>
<div id="#rfc.figure.11"></div>
<p></p>

<p>The timeline diagram is shown below:</p>
<pre>
        |1|  |2|     |3|    |4|     |5|
Kz       |    |       |      |       |
- RRSIG  |    |DcacheZ|------|-------|---
- DNSKEY |    |DcacheK|------|-------|---
         |    |       |      |       |
         Tgen Tpub    Tkno
              Tact    Tsaf

Kk       |    |       |      |       |
- DNSKEY |    |DcacheK|------|-------|---
- DS     |    |       |      |DcacheP|---
         |    |       |      |       |
         Tgen Tpub    Tkno   TactDS  TsafDS
  </pre>
<p>Figure: Enabling DNSSEC.</p>
<p id="rfc.section.4.1.p.4">Generation Stage: Event 1 <br> Kk and Kz are generated.  The time when this happens is Tgen, the time that the keys were Generated (note that Tgen for Kk could be different that Tgen for Kz).  </p>
<p id="rfc.section.4.1.p.5">S(Kk) = (DNSKEY Generated, DS Generated) <br> P(Kk) = Generated <br> S(Kz) = (DNSKEY Generated, RRSIG Generated) <br> P(Kk) = Generated </p>
<p id="rfc.section.4.1.p.6">Preparation Stage: Event 2 <br> The keys are put into the zone and are immediately used for signing.  Because there exists no pointer to the fact that our zone is DNSSEC enabled, the DNSKEY and RRSIG records may be introduced at the same time.  This is the publish time (Tpub), the time that the keys are Published.  It is also Kz' active time (Tact), the time that Kz is said to be Active.  </p>
<p id="rfc.section.4.1.p.7">Tpub(Kk) &gt;= Tgen(Kk) <br> Tpub(Kz) &gt;= Tgen(Kz) <br> Tact(Kz) == Tpub(Kz) </p>
<p id="rfc.section.4.1.p.8">S(Kk) = (DNSKEY Introduced, DS Generated) <br> P(Kk) = Published <br> S(Kz) = (DNSKEY Introduced, RRSIG Introduced) <br> P(Kz) = Published Active </p>
<p id="rfc.section.4.1.p.9">Ready Stage: Event 3 <br> Before the DS record can be committed, Kz must be considered Known and Safe.  This time is Kz' known time (Tkno).  </p>
<p id="rfc.section.4.1.p.10">Tkno(Kk) &gt;= Tpub(Kk) + DcacheP <br> Tkno(Kk) == Tkno(Kz) <br> Tsaf(Kz) &gt;= Tact(Kz) + DcacheZ </p>
<p id="rfc.section.4.1.p.11">S(Kk) = (DNSKEY Propagated, DS Generated) <br> P(Kk) = Known <br> S(Kz) = (DNSKEY Propagated, RRSIG Propagated) <br> P(Kz) = Known Safe </p>
<p id="rfc.section.4.1.p.12">Because this is the first DNSKEY for this zone, the Dttl for the DNSKEY RRset is Ingc, the negative cache interval from the zone's SOA record, calculated according to <a href="#RFC2308">RFC2308</a> <cite title="NONE">[RFC2308]</cite> as the minimum of the TTL of the SOA record itself and the MINIMUM field in the record's parameters: </p>
<p id="rfc.section.4.1.p.13">Ingc = min(TTL(SOA), MINIMUM) </p>
<p id="rfc.section.4.1.p.14">Activation Stage: Event 4 <br> Some time later, the DNSKEY RRset and all RRSIG records have reached the caches, and the DS record can be submitted to the parent.  This is TactDS, the time that the DS has been submitted to the parent.  </p>
<p id="rfc.section.4.1.p.15">TactDS(Kk) &gt;= Tkno(Kk) </p>
<p id="rfc.section.4.1.p.16">S(Kk) = (DNSKEY Propagated, DS Introduced) <br> P(Kk) = Known ActiveDS </p>
<p id="rfc.section.4.1.p.17">Activated Stage: Event 5 <br> Some time later, the DS has been published in the parent zone.  Some more time later, all validators that have a copy of the DS RRset have one that includes the DS record of Kk.  </p>
<p id="rfc.section.4.1.p.18">TsafDS(Kk) &gt;= TactDS(Kk) + DcacheP </p>
<p id="rfc.section.4.1.p.19">S(Kk) = (DNSKEY Propagated, DS Propagated) <br> P(Kk) = Known SafeDS </p>
<p id="rfc.section.4.1.p.20">Because this is the first DS for this zone, the Dttl for the DS RRset is Ingc, for the same reason as in step 3 for the DNSKEY RRset.  </p>
<h1 id="rfc.section.4.2">
<a href="#rfc.section.4.2">4.2.</a> <a href="#disabling" id="disabling">Disabling DNSSEC</a>
</h1>
<p id="rfc.section.4.2.p.1">When a zone decides for whatever reason to go back to the Insecure status, the set of keys safely need to be removed from the zone.  It is assumed that there is a KSK (Kk) and a ZSK (Kz) that are Known and Safe.  The goals of this event are to make Kk and Kz both Forgotten and Expired.  </p>
<div id="#rfc.figure.12"></div>
<p></p>

<p>The timeline diagram is shown below:</p>
<pre>
        |0|  |1|     |3|    |4|     |5|
Kz       |    |       |      |       |
- RRSIG  |----|-------|------|DcacheZ|
- DNSKEY |----|-------|------|DcacheK|
         |    |       |      |       |
                             Trem    Tfor
                             Tret    Texp

Kk       |    |       |      |       |
- DNSKEY |----|-------|------|DcacheK|
- DS     |----|DcacheP|      |       |
         |    |       |      |       |
              TretDS  TexpDS Trem    Tfor

  </pre>
<p>Figure: Disabling DNSSEC.</p>
<p id="rfc.section.4.2.p.3">Activation Stage: Event 1 <br> The DS record of Kk needs to be withdrawn.  This time is Kk' retire time (TretDS), the time that Kk is said to be RetiredDS.  </p>
<p id="rfc.section.4.2.p.4">S(Kk) = (DNSKEY Propagated, DS Withdrawn) <br> P(Kk) = Known RetiredDS <br> </p>
<p id="rfc.section.4.2.p.5">Activated Stage: Event 2 <br> First, the DS record of Kk must expire from all validator caches.  This time is Kk' expire time (TexpDS), the time that Kk is said to be ExpiredDS.  </p>
<p id="rfc.section.4.2.p.6">TexpDS(Kk) &gt;= TretDS(Kk) + DcacheP </p>
<p id="rfc.section.4.2.p.7">S(Kk) = (DNSKEY Propagated, DS Dead) <br> P(Kk) = Known ExpiredDS <br> </p>
<p id="rfc.section.4.2.p.8">Withdrawal Stage: Event 3 <br> When no secure chain of trust to Kk exists anymore, the DNSKEY records of both keys and all RRSIG records can be removed from the zone.  This time is Trem, the time that the keys are removed from the zone.  </p>
<p id="rfc.section.4.2.p.9">Trem(Kk) &gt;= TexpDS(Kk) <br> Trem(Kz) == Trem(Kk) <br> Tret(Kz) == Trem(kz) </p>
<p id="rfc.section.4.2.p.10">S(Kk) = (DNSKEY Withdrawn, DS Dead) <br> P(Kk) = Removed ExpiredDS <br> S(Kz) = (DNSKEY Withdrawn, RRSIG Withdrawn) <br> P(Kz) = Removed Retired </p>
<p id="rfc.section.4.2.p.11">Complete Stage: Event 4 <br> After some delay, all information about the keys have expired from the caches.  </p>
<p id="rfc.section.4.2.p.12">Tfor(Kk) &gt;= Trem(Kk) + DcacheK <br> Tfor(Kz) == Tfor(Kk) <br> Texp(Kz) &gt;= Tret(Kz) + DcacheZ </p>
<p id="rfc.section.4.2.p.13">S(Kk) = (DNSKEY Dead, DS Dead) <br> P(Kk) = Forgotten ExpiredDS <br> S(Kz) = (DNSKEY Dead, RRSIG Dead) <br> P(Kz) = Forgotten Expired </p>
<h1 id="rfc.section.4.3">
<a href="#rfc.section.4.3">4.3.</a> <a href="#algo-rollover" id="algo-rollover">Algorithm Rollover</a>
</h1>
<p id="rfc.section.4.3.p.1">When changing algorithms, it is possible that algorithms are added, removed or replaced.  Adding and removing an algorithm follows the same timings as enabling and disabling DNSSEC.  Replacing an algorithm can be done with a STSS Double-Signature rollover or a KSK and ZSK Double-Signature Rollover at the same time.  [MM: This needs more text, but I am awaiting the discussion about algorithm rollover and how to interpret section 2.2 of RFC 4035] </p>
<h1 id="rfc.section.4.4">
<a href="#rfc.section.4.4">4.4.</a> <a href="#split-rollover" id="split-rollover">KSK-ZSK Split or Single Type Signing Scheme</a>
</h1>
<p id="rfc.section.4.4.p.1">When changing signing schemes, one should follow the timelines of the most restrive signing scheme.  The STSS signing scheme makes some rollover combinations unsuitable, thus it can be considered the most restricted signing scheme.  In the case of moving to a KSK-ZSK Split, Ks is used as the successor key in the STSS rollover methods, and it now reflects both the successor ZSK and KSK.  In the case of moving away from a KSK-ZSK Split, Kc is used as the predecessor key in the STSS rollover methods, and it now reflects both the predecessor ZSK and KSK.  [MM: This could perhaps also use more explanation.] </p>
<h1 id="rfc.section.5">
<a href="#rfc.section.5">5.</a> <a href="#iana" id="iana">IANA Considerations</a>
</h1>
<p id="rfc.section.5.p.1">This memo includes no request to IANA.  </p>
<h1 id="rfc.section.6">
<a href="#rfc.section.6">6.</a> <a href="#security" id="security">Security Considerations</a>
</h1>
<p id="rfc.section.6.p.1">This document does not introduce any new security issues beyond those already discussed in <a href="#RFC4033">RFC4033</a> <cite title="NONE">[RFC4033]</cite>, <a href="#RFC4034">RFC4034</a> <cite title="NONE">[RFC4034]</cite>. <a href="#RFC4035">RFC4035</a> <cite title="NONE">[RFC4035]</cite> and <a href="#RFC5011">RFC5011</a> <cite title="NONE">[RFC5011]</cite>.  </p>
<h1 id="rfc.section.7">
<a href="#rfc.section.7">7.</a> <a href="#acknnowledgements" id="acknnowledgements">Acknowledgements</a>
</h1>
<p id="rfc.section.7.p.1">Special acknowledgments and gratitude go out to Stephen Morris, Johan Ihren and John Dickinson, the authors of <a href="#key-timing">[key-timing]</a>. Significant parts of the text is taken from that document.  Especially <a href="#zsk-rollovers">Section 3.2</a> and <a href="#ksk-rollovers">Section 3.3</a> are largely copied and adjusted to the new introduced terminology from this document.  </p>
<p id="rfc.section.7.p.2">Also, acknowledgements to Yuri Schaeffer, who brought to the attention the idea of key goals (<a href="#goals">Section 2.4</a>) and whose discussions helped to shape this document.  </p>
<h1 id="rfc.section.8">
<a href="#rfc.section.8">8.</a> <a href="#changelog" id="changelog">Changelog</a>
</h1>
<h1 id="rfc.section.8.1">
<a href="#rfc.section.8.1">8.1.</a> Changes with key-timing draft</h1>
<p id="rfc.section.8.1.p.1">This document builds further on <a href="#key-timing">[key-timing]</a>.  The most important changes with respect to that document are: </p>

<ul class="empty">
<li>- Introduced the concept of Rollover Considerations (Speed vs Size vs Interactions), that causes the existence of different key rollover scenarios.</li>
<li>- Introduced the concept of Key Goals.</li>
<li>- Key States are unraveled to represent the status of each piece of information seperately.  Provides more flexibility. Used for combining rollover methods in a Single Type Singing Scheme.</li>
<li>- What were Key States in the key-timing draft, are now called Key Properties.  A key can have more than one property.</li>
<li>- Four new Key Properties are introduced: Known, Safe, Forgotten and Expired, to represent whether information about the key exist in validator caches.  The key properties Ready and Dead are deprecated.</li>
<li>- Timelines for STSS Rollovers.</li>
<li>- Timelines for enabling and disabling DNSSEC.</li>
<li>- Text about policy rollover, such as algorithm rollover and changing signing schemes.</li>
</ul>

<p> </p>
<h1 id="rfc.section.8.2">
<a href="#rfc.section.8.2">8.2.</a> From -00 to -01</h1>
<p></p>

<ul class="empty">
<li>- Initial review Stephen Morris.</li>
<li>- Changed style, removed all first and second person style.</li>
<li>- Key Conditions are now called Key Properties.</li>
<li>- More detailed explanation on Key States Unraveled: Introduced Validation Components and Key Properties, described in different sections.</li>
<li>- Put the correct timeline figure in the section on STSS Double-DS rollover method.</li>
<li>- Review Marc Lampo, Stephen Morris</li>
<li>- Stephen provided text for the section on Key Rollover Stages</li>
</ul>

<p> </p>
<h1 id="rfc.references">
<a href="#rfc.references">9.</a> References</h1>
<h1 id="rfc.references.1">
<a href="#rfc.references.1">9.1.</a> Informative References</h1>
<table><tbody><tr>
<td class="reference"><b id="RFC4641">[RFC4641]</b></td>
<td class="top">
<a>Kolkman, O.</a> and <a>R. Gieben</a>, "<a href="http://tools.ietf.org/html/rfc4641">DNSSEC Operational Practices</a>", RFC 4641, September 2006.</td>
</tr></tbody></table>
<h1 id="rfc.references.2">
<a href="#rfc.references.2">9.2.</a> Normative References</h1>
<table><tbody>
<tr>
<td class="reference"><b id="RFC2308">[RFC2308]</b></td>
<td class="top">
<a href="mailto:Mark.Andrews@cmis.csiro.au" title="CSIRO - Mathematical and Information Sciences">Andrews, M.</a>, "<a href="http://tools.ietf.org/html/rfc2308">Negative Caching of DNS Queries (DNS NCACHE)</a>", RFC 2308, March 1998.</td>
</tr>
<tr>
<td class="reference"><b id="RFC4033">[RFC4033]</b></td>
<td class="top">
<a>Arends, R.</a>, <a>Austein, R.</a>, <a>Larson, M.</a>, <a>Massey, D.</a> and <a>S. Rose</a>, "<a href="http://tools.ietf.org/html/rfc4033">DNS Security Introduction and Requirements</a>", RFC 4033, March 2005.</td>
</tr>
<tr>
<td class="reference"><b id="RFC4034">[RFC4034]</b></td>
<td class="top">
<a>Arends, R.</a>, <a>Austein, R.</a>, <a>Larson, M.</a>, <a>Massey, D.</a> and <a>S. Rose</a>, "<a href="http://tools.ietf.org/html/rfc4034">Resource Records for the DNS Security Extensions</a>", RFC 4034, March 2005.</td>
</tr>
<tr>
<td class="reference"><b id="RFC4035">[RFC4035]</b></td>
<td class="top">
<a>Arends, R.</a>, <a>Austein, R.</a>, <a>Larson, M.</a>, <a>Massey, D.</a> and <a>S. Rose</a>, "<a href="http://tools.ietf.org/html/rfc4035">Protocol Modifications for the DNS Security Extensions</a>", RFC 4035, March 2005.</td>
</tr>
<tr>
<td class="reference"><b id="RFC5011">[RFC5011]</b></td>
<td class="top">
<a>StJohns, M.</a>, "<a href="http://tools.ietf.org/html/rfc5011">Automated Updates of DNS Security (DNSSEC) Trust Anchors</a>", RFC 5011, September 2007.</td>
</tr>
<tr>
<td class="reference"><b id="key-timing">[key-timing]</b></td>
<td class="top">
<a>Morris, S.</a>, <a>Ihren, J.</a> and <a>J. Dickinson</a>, "<a>DNSSEC Key Timing Considerations</a>", March 2011.</td>
</tr>
<tr>
<td class="reference"><b id="dps-framework">[dps-framework]</b></td>
<td class="top">
<a>Ljunggren, F.</a>, <a>Eklund-Lowinder, A-M.</a> and <a>T. Okubo</a>, "<a>DNSSEC Policy &amp; Practice Statement Framework</a>", March 2011.</td>
</tr>
</tbody></table>
<h1 id="rfc.appendix.Appendix A">
<a href="#rfc.appendix.Appendix%20A">Appendix A.</a> <a href="#app-terms" id="app-terms">List of Symbols</a>
</h1>
<p id="rfc.section.Appendix A.p.1">[MM: To do]</p>
<h1 id="rfc.authors"><a href="#rfc.authors">Author's Address</a></h1>
<div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Matthijs Mekking</span> 
	  <span class="n hidden">
		<span class="family-name">Mekking</span>
	  </span>
	</span>
	<span class="org vcardline">NLnet Labs </span>
	<span class="adr">
	  <span>Science Park 140</span>

	  <span class="vcardline">
		<span class="locality">Amsterdam</span>,  
		<span class="region"></span>
		<span class="code">1098 XG</span>
	  </span>
	  <span class="country-name vcardline">The Netherlands</span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:matthijs@nlnetlabs.nl%20">matthijs@nlnetlabs.nl </a></span>

  </address>
</div>

</body>
</html>