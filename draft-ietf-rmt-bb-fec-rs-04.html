<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="en"><head><title>Reed-Solomon Forward Error Correction (FEC) Schemes</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="description" content="Reed-Solomon Forward Error Correction (FEC) Schemes">
<meta name="keywords" content="I-D, Internet-Draft, Forward Error Correction, Reed-Solomon">
<meta name="generator" content="xml2rfc v1.35 (http://xml.resource.org/)">
<meta name="viewport" content="width=600;" />
<style type='text/css'><!--
        body {
                font-family: verdana, charcoal, helvetica, arial, sans-serif;
                font-size: 85%;
		max-width: 40em; 
		color: #000; background-color: #FFF;
                margin: 2em;
        }
        h1, h2, h3, h4, h5, h6 {
                font-family: helvetica, monaco, "MS Sans Serif", arial, sans-serif;
                font-weight: bold; font-style: normal;
        }
        h1 { color: #900; background-color: transparent; text-align: right; }
        h3 { color: #333; background-color: transparent; }

        td.RFCbug {
                font-size: x-small; text-decoration: none;
                width: 30px; height: 30px; padding-top: 2px;
                text-align: justify; vertical-align: middle;
                background-color: #000;
        }
        td.RFCbug span.RFC {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: bold; color: #666;
        }
        td.RFCbug span.hotText {
                font-family: charcoal, monaco, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: normal; text-align: center; color: #FFF;
        }

        table.TOCbug { width: 30px; height: 15px; }
        td.TOCbug {
                text-align: center; width: 30px; height: 15px;
                color: #FFF; background-color: #900;
        }
        td.TOCbug a {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, sans-serif;
                font-weight: bold; font-size: x-small; text-decoration: none;
                color: #FFF; background-color: transparent;
        }

        td.header {
                font-family: arial, helvetica, sans-serif; font-size: x-small;
                vertical-align: top; width: 33%;
                color: #FFF; background-color: #666;
        }
        td.author { font-weight: bold; font-size: x-small; margin-left: 4em; }
        td.author-text { font-size: x-small; }

        /* info code from SantaKlauss at http://www.madaboutstyle.com/tooltip2.html */
        a.info {
                /* This is the key. */
                position: relative;
                z-index: 24;
                text-decoration: none;
        }
        a.info:hover {
                z-index: 25;
                color: #FFF; background-color: #900;
        }
        a.info span { display: none; }
        a.info:hover span.info {
                /* The span will display just on :hover state. */
                display: block;
                position: absolute;
                font-size: smaller;
                top: 2em; left: -5em; width: 15em;
                padding: 2px; border: 1px solid #333;
                color: #900; background-color: #EEE;
                text-align: left;
        }

        a { font-weight: bold; }
        a:link    { color: #900; background-color: transparent; }
        a:visited { color: #633; background-color: transparent; }
        a:active  { color: #633; background-color: transparent; }

        p { margin-left: 2em; margin-right: 2em; }
        p.copyright { font-size: x-small; }
        p.toc { font-size: 85%;
		max-width: 40em; 
		font-weight: bold; margin-left: 3em; }
        table.toc { margin: 0 0 0 3em; padding: 0; border: 0; vertical-align: text-top; }
        td.toc { font-size: 85%;
		max-width: 40em; 
		font-weight: bold; vertical-align: text-top; }

        ol.text { margin-left: 2em; margin-right: 2em; }
        ul.text { margin-left: 2em; margin-right: 2em; }
        li      { margin-left: 3em; }

        /* RFC-2629 <spanx>s and <artwork>s. */
        em     { font-style: italic; }
        strong { font-weight: bold; }
        dfn    { font-weight: bold; font-style: normal; }
        cite   { font-weight: normal; font-style: normal; }
        tt     { color: #036; }
        tt, pre, pre dfn, pre em, pre cite, pre span {
                font-family: "Courier New", Courier, monospace; font-size: small;
        }
        pre {
                text-align: left; padding: 4px;
                color: #000; background-color: #CCC;
        }
        pre dfn  { color: #900; }
        pre em   { color: #66F; background-color: #FFC; font-weight: normal; }
        pre .key { color: #33C; font-weight: bold; }
        pre .id  { color: #900; }
        pre .str { color: #000; background-color: #CFF; }
        pre .val { color: #066; }
        pre .rep { color: #909; }
        pre .oth { color: #000; background-color: #FCF; }
        pre .err { background-color: #FCC; }

        /* RFC-2629 <texttable>s. */
        table.all, table.full, table.headers, table.none {
                font-size: 85%;
		max-width: 40em; 
		text-align: center; border-width: 2px;
                vertical-align: top; border-collapse: collapse;
        }
        table.all, table.full { border-style: solid; border-color: black; }
        table.headers, table.none { border-style: none; }
        th {
                font-weight: bold; border-color: black;
                border-width: 2px 2px 3px 2px;
        }
        table.all th, table.full th { border-style: solid; }
        table.headers th { border-style: none none solid none; }
        table.none th { border-style: none; }
        table.all td {
                border-style: solid; border-color: #333;
                border-width: 1px 2px;
        }
        table.full td, table.headers td, table.none td { border-style: none; }

        hr { height: 1px; }
        hr.insert {
                width: 80%; border-style: none; border-width: 0;
                color: #CCC; background-color: #CCC;
        }
--></style>
</head>
<body>
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<table summary="layout" width="66%" border="0" cellpadding="0" cellspacing="0"><tr><td><table summary="layout" width="100%" border="0" cellpadding="2" cellspacing="1">
<tr><td class="header">Reliable Multicast Transport</td><td class="header">J. Lacan</td></tr>
<tr><td class="header">Internet-Draft</td><td class="header">ISAE</td></tr>
<tr><td class="header">Intended status: Standards Track</td><td class="header">V. Roca</td></tr>
<tr><td class="header">Expires: April 12, 2008</td><td class="header">INRIA</td></tr>
<tr><td class="header">&nbsp;</td><td class="header">J. Peltotalo</td></tr>
<tr><td class="header">&nbsp;</td><td class="header">S. Peltotalo</td></tr>
<tr><td class="header">&nbsp;</td><td class="header">Tampere University of Technology</td></tr>
<tr><td class="header">&nbsp;</td><td class="header">October 10, 2007</td></tr>
</table></td></tr></table>
<h1><br />Reed-Solomon Forward Error Correction (FEC) Schemes<br />draft-ietf-rmt-bb-fec-rs-04.txt</h1>

<h3>Status of this Memo</h3>
<p>
By submitting this Internet-Draft,
each author represents that any applicable patent or other IPR claims of which
he or she is aware have been or will be disclosed,
and any of which he or she becomes aware will be disclosed,
in accordance with Section&nbsp;6 of BCP&nbsp;79.</p>
<p>
Internet-Drafts are working documents of the Internet Engineering
Task Force (IETF), its areas, and its working groups.
Note that other groups may also distribute working documents as
Internet-Drafts.</p>
<p>
Internet-Drafts are draft documents valid for a maximum of six months
and may be updated, replaced, or obsoleted by other documents at any time.
It is inappropriate to use Internet-Drafts as reference material or to cite
them other than as &ldquo;work in progress.&rdquo;</p>
<p>
The list of current Internet-Drafts can be accessed at
<a href='http://www.ietf.org/ietf/1id-abstracts.txt'>http://www.ietf.org/ietf/1id-abstracts.txt</a>.</p>
<p>
The list of Internet-Draft Shadow Directories can be accessed at
<a href='http://www.ietf.org/shadow.html'>http://www.ietf.org/shadow.html</a>.</p>
<p>
This Internet-Draft will expire on April 12, 2008.</p>

<h3>Abstract</h3>

<p>This document describes a Fully-Specified Forward Error Correction (FEC) Scheme for the Reed-Solomon
FEC codes over GF(2^^m), with m in {2..16}, and its application to the reliable delivery of data objects on
the packet erasure channel.

</p>
<p>
This document also describes a Fully-Specified FEC Scheme for the special case of Reed-Solomon
codes over GF(2^^8) when there is no encoding symbol group.

</p>
<p>
Finally, in the context of the Under-Specified Small Block Systematic FEC Scheme (FEC Encoding ID 129),
this document assigns an FEC Instance ID to the special case of Reed-Solomon codes over GF(2^^8).
</p>
<p>Reed-Solomon codes belong to the class of Maximum Distance Separable (MDS) codes, i.e., they enable
a receiver to recover the k source symbols from any set of k received symbols.
The schemes described here are compatible with the implementation from Luigi Rizzo.
</p><a name="toc"></a><br /><hr />
<h3>Table of Contents</h3>
<p class="toc">
<a href="#Introduction">1.</a>&nbsp;
Introduction<br />
<a href="#Terminology">2.</a>&nbsp;
Terminology<br />
<a href="#DefinitionsNotationsandAbbreviations">3.</a>&nbsp;
Definitions Notations and Abbreviations<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#Definitions">3.1.</a>&nbsp;
Definitions<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#Notations">3.2.</a>&nbsp;
Notations<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#Abbreviations">3.3.</a>&nbsp;
Abbreviations<br />
<a href="#anchor1">4.</a>&nbsp;
Formats and Codes with FEC Encoding ID 2<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor2">4.1.</a>&nbsp;
FEC Payload ID<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#FEC_OTI_EncID2">4.2.</a>&nbsp;
FEC Object Transmission Information<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor3">4.2.1.</a>&nbsp;
Mandatory Elements<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#common_elt_EncID2">4.2.2.</a>&nbsp;
Common Elements<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#scheme_specific_elt_EncID2">4.2.3.</a>&nbsp;
Scheme-Specific Elements<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#FEC_OTI_encoding_format_EncID2">4.2.4.</a>&nbsp;
Encoding Format<br />
<a href="#anchor6">5.</a>&nbsp;
Formats and Codes with FEC Encoding ID 5<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor7">5.1.</a>&nbsp;
FEC Payload ID<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#FEC_OTI_EncID5">5.2.</a>&nbsp;
FEC Object Transmission Information<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor8">5.2.1.</a>&nbsp;
Mandatory Elements<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor9">5.2.2.</a>&nbsp;
Common Elements<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#scheme_specific_elt">5.2.3.</a>&nbsp;
Scheme-Specific Elements<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#FEC_OTI_encoding_format">5.2.4.</a>&nbsp;
Encoding Format<br />
<a href="#procedures">6.</a>&nbsp;
Procedures with FEC Encoding IDs 2 and 5<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#max_source_block_length">6.1.</a>&nbsp;
Determining the Maximum Source Block Length (B)<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#n-algorithm">6.2.</a>&nbsp;
Determining the Number of Encoding Symbols of a Block<br />
<a href="#EncID129_InstID0">7.</a>&nbsp;
Small Block Systematic FEC Scheme (FEC Encoding ID 129) and Reed-Solomon Codes over GF(2^^8)<br />
<a href="#Reed-SolomonCodes">8.</a>&nbsp;
Reed-Solomon Codes Specification for the Erasure Channel<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#FiniteField">8.1.</a>&nbsp;
Finite Field<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#Encoding">8.2.</a>&nbsp;
Reed-Solomon Encoding Algorithm<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#EncodingPrinciples">8.2.1.</a>&nbsp;
Encoding Principles<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor12">8.2.2.</a>&nbsp;
Encoding Complexity<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#Decoding">8.3.</a>&nbsp;
Reed-Solomon Decoding Algorithm<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#DecodingPrinciples">8.3.1.</a>&nbsp;
Decoding Principles<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor13">8.3.2.</a>&nbsp;
Decoding Complexity<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#Implementation">8.4.</a>&nbsp;
Implementation for the Packet Erasure Channel<br />
<a href="#SecurityConsiderations">9.</a>&nbsp;
Security Considerations<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor14">9.1.</a>&nbsp;
Problem Statement<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor15">9.2.</a>&nbsp;
Attacks Against the Data Flow<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor16">9.3.</a>&nbsp;
Attacks against the FEC parameters<br />
<a href="#iana-cons">10.</a>&nbsp;
IANA Considerations<br />
<a href="#Acknowledgments">11.</a>&nbsp;
Acknowledgments<br />
<a href="#rfc.references1">12.</a>&nbsp;
References<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#rfc.references1">12.1.</a>&nbsp;
Normative References<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#rfc.references2">12.2.</a>&nbsp;
Informative References<br />
<a href="#rfc.authors">&#167;</a>&nbsp;
Authors' Addresses<br />
<a href="#rfc.copyright">&#167;</a>&nbsp;
Intellectual Property and Copyright Statements<br />
</p>
<br clear="all" />

<a name="Introduction"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1"></a><h3>1.&nbsp;
Introduction</h3>

<p>The use of Forward Error Correction (FEC) codes is a classical solution to improve the reliability
of multicast and broadcast transmissions.
The <a class='info' href='#rfc5052_fecbb'>[2]<span> (</span><span class='info'>Watson, M., Luby, M., and L. Vicisano, &ldquo;Forward Error Correction (FEC) Building Block,&rdquo; August&nbsp;2007.</span><span>)</span></a> document describes a general framework to use FEC
in Content Delivery Protocols (CDP).
The companion document <a class='info' href='#rfc3453'>[4]<span> (</span><span class='info'>Luby, M., Vicisano, L., Gemmell, J., Rizzo, L., Handley, M., and J. Crowcroft, &ldquo;The Use of Forward Error Correction (FEC) in Reliable Multicast,&rdquo; December&nbsp;2002.</span><span>)</span></a> describes some applications of FEC codes for content delivery.
</p>
<p>Recent FEC schemes like <a class='info' href='#draft-ietf-rmt-bb-fec-raptor-object'>[9]<span> (</span><span class='info'>Luby, M., Shokrollahi, A., Watson, M., and T. Stockhammer, &ldquo;Raptor Forward Error Correction Scheme,&rdquo; June&nbsp;2007.</span><span>)</span></a> and
<a class='info' href='#draft-ietf-rmt-bb-fec-ldpc'>[8]<span> (</span><span class='info'>Roca, V., Neumann, C., and D. Furodet, &ldquo;Low Density Parity Check (LDPC) Forward Error Correction,&rdquo; May&nbsp;2007.</span><span>)</span></a> proposed erasure codes based on sparse graphs/matrices.
These codes are efficient in terms of processing but not optimal in terms of correction
capabilities when dealing with "small" objects.
</p>
<p>The FEC scheme described in this document belongs to the class of Maximum Distance Separable codes
that are optimal in terms of erasure correction capability.
In others words, it enables a receiver to recover the k source symbols from any set of exactly k encoding symbols.
Even if the encoding/decoding complexity is larger than that of
<a class='info' href='#draft-ietf-rmt-bb-fec-raptor-object'>[9]<span> (</span><span class='info'>Luby, M., Shokrollahi, A., Watson, M., and T. Stockhammer, &ldquo;Raptor Forward Error Correction Scheme,&rdquo; June&nbsp;2007.</span><span>)</span></a> or <a class='info' href='#draft-ietf-rmt-bb-fec-ldpc'>[8]<span> (</span><span class='info'>Roca, V., Neumann, C., and D. Furodet, &ldquo;Low Density Parity Check (LDPC) Forward Error Correction,&rdquo; May&nbsp;2007.</span><span>)</span></a>,
this family of codes is very useful.
</p>
<p>Many applications dealing with content transmission or content storage already rely on packet-based
Reed-Solomon codes.
In particular, many of them use the Reed-Solomon codec of Luigi Rizzo  <a class='info' href='#RS-codec'>[5]<span> (</span><span class='info'>Rizzo, L., &ldquo;Reed-Solomon FEC codec (revised version of July 2nd, 1998), available at http://info.iet.unipi.it/~luigi/vdm98/vdm980702.tgz and mirrored at http://planete-bcast.inrialpes.fr/,&rdquo; July&nbsp;1998.</span><span>)</span></a>.
The goal of the present document to specify an implementation of Reed-Solomon codes that is compatible
with this codec.
</p>
<p>The present document:
</p>
<ul class="text">
<li> introduces the Fully-Specified FEC Scheme with FEC Encoding ID 2
	that specifies the use of Reed-Solomon codes over GF(2^^m), with m in {2..16},
</li>
<li> introduces the Fully-Specified FEC Scheme with FEC Encoding ID 5 that focuses on the special
	case of Reed-Solomon codes over GF(2^^8) and no encoding symbol group (i.e., exactly one symbol
	per packet), and
</li>
<li> in the context of the Under-Specified Small Block Systematic FEC Scheme (FEC Encoding ID 129)
        <a class='info' href='#draft-ietf-rmt-bb-fec-basic-schemes-revised'>[3]<span> (</span><span class='info'>Watson, M., &ldquo;Basic Forward Error Correction (FEC) Schemes,&rdquo; February&nbsp;2007.</span><span>)</span></a>, assigns the FEC Instance ID 0 to the
	special case of Reed-Solomon codes over GF(2^^8) and no encoding symbol group.
</li>
</ul><p>

</p>
<a name="Terminology"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2"></a><h3>2.&nbsp;
Terminology</h3>

<p>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 <a class='info' href='#rfc2119'>[1]<span> (</span><span class='info'>Bradner, S., &ldquo;Key words for use in RFCs to Indicate Requirement Levels,&rdquo; .</span><span>)</span></a>.
</p>
<a name="DefinitionsNotationsandAbbreviations"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3"></a><h3>3.&nbsp;
Definitions Notations and Abbreviations</h3>

<a name="Definitions"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.1"></a><h3>3.1.&nbsp;
Definitions</h3>

<p>This document uses the same terms and definitions as those specified in  <a class='info' href='#rfc5052_fecbb'>[2]<span> (</span><span class='info'>Watson, M., Luby, M., and L. Vicisano, &ldquo;Forward Error Correction (FEC) Building Block,&rdquo; August&nbsp;2007.</span><span>)</span></a>.
Additionally, it uses the following definitions:

</p>
<blockquote class="text">
<p>Source symbol:		unit of data used during the encoding process.
</p>
<p>Encoding symbol:		unit of data generated by the encoding process.
</p>
<p>Repair symbol:		encoding symbol that is not a source symbol.
</p>
<p>Systematic code:		FEC code in which the source symbols are part
				of the encoding symbols.
</p>
<p>Source block:		a block of k source symbols that are considered
				together for the encoding.
</p>
<p>Encoding Symbol Group:	a group of encoding symbols that are
				sent together within the same packet, and
				whose relationships to the source block can be
				derived from a single Encoding Symbol ID.
</p>
<p>Source Packet:		a data packet containing only source
				symbols.
</p>
<p>Repair Packet:		a data packet containing only repair
				symbols.
</p>
</blockquote><p>

</p>
<a name="Notations"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.2"></a><h3>3.2.&nbsp;
Notations</h3>

<p>This document uses the following notations:
</p>
<blockquote class="text">
<p>L		denotes the object transfer length in bytes.
</p>
<p>k		denotes the number of source symbols in a source block.
</p>
<p>n_r		denotes the number of repair symbols generated for a source block.
</p>
<p>n		denotes the encoding block length, i.e., the number of
		encoding symbols generated for a source block.
		Therefore: n = k + n_r.
</p>
<p>max_n	denotes the maximum number of encoding symbols generated for any
		source block.
</p>
<p>B		denotes the maximum source block length in symbols,
		i.e., the maximum number of source symbols per source block.
</p>
<p>N		denotes the number of source blocks into which the object
		shall be partitioned.
</p>
<p>E		denotes the encoding symbol length in bytes.
</p>
<p>S		denotes the symbol size in units of m-bit elements.
		When m = 8, then S and E are equal.
</p>
<p>m		defines the length of the elements in the finite field, in bits.
		In this document, m belongs to {2..16}.
</p>
<p>q		defines the number of elements in the finite field. We have: q = 2^^m in this specification.
</p>
<p>G		denotes the number of encoding symbols per group, i.e.
		the number of symbols sent in the same packet.
</p>
<p>GM		denotes the Generator Matrix of a Reed-Solomon code.
</p>
<p>rate		denotes the "code rate", i.e., the k/n ratio.
</p>
<p>a^^b		denotes a raised to the power b.
</p>
<p>a^^-1	denotes the inverse of a.
</p>
<p>I_k		denotes the k*k identity matrix.
</p>
</blockquote>

<a name="Abbreviations"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.3"></a><h3>3.3.&nbsp;
Abbreviations</h3>

<p>This document uses the following abbreviations:
</p>
<blockquote class="text">
<p>ESI		stands for Encoding Symbol ID.
</p>
<p>FEC OTI	stands for FEC Object Transmission Information.
</p>
<p>RS		stands for Reed-Solomon.
</p>
<p>MDS		stands for Maximum Distance Separable code.
</p>
<p>GF(q)	denotes a finite field (also known as Galois Field) with q elements.
		We assume that q = 2^^m in this document.
</p>
</blockquote><p>

</p>
<a name="anchor1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4"></a><h3>4.&nbsp;
Formats and Codes with FEC Encoding ID 2</h3>

<p>This section introduces the formats and codes associated to the Fully-Specified FEC Scheme
with FEC Encoding ID 2
that specifies the use of Reed-Solomon codes over GF(2^^m).
</p>
<a name="anchor2"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.1"></a><h3>4.1.&nbsp;
FEC Payload ID</h3>

<p>The FEC Payload ID is composed of the Source Block Number and the Encoding Symbol ID.
   The length of these two fields depends on the parameter m 
   (which is transmitted in the FEC OTI) as follows:
</p>
<p>
</p>
<ul class="text">
<li>The Source Block Number (field of size 32-m bits) identifies from which source block
   of the object the encoding symbol(s) in the payload is(are) generated.
   There is a maximum of 2^^(32-m) blocks per object.
</li>
<li>The Encoding Symbol ID (field of size m bits) identifies which specific encoding
   symbol(s) generated from the source block is(are) carried in the packet payload.
   There is a maximum of 2^^m encoding symbols per block.
   The first k values (0 to k - 1) identify source symbols, the remaining n-k
   values identify repair symbols.
</li>
</ul><p>

</p>
<p>There MUST be exactly one FEC Payload ID per source or repair packet.
In case of an Encoding Symbol Group,
when multiple encoding symbols are sent in the same packet,
the FEC Payload ID refers to the first symbol of the packet.
The other symbols can be deduced from the ESI of the first symbol
by incrementing sequentially the ESI.

</p><br /><hr class="insert" />
<a name="fig_fec_payload_id_for_8"></a>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|     Source Block Number (32-8=24 bits)        | Enc. Symb. ID |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;1: FEC Payload ID encoding format for m = 8 (default)&nbsp;</b></font><br /></td></tr></table><hr class="insert" />
<br /><hr class="insert" />
<a name="fig_fec_payload_id_for_16"></a>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
| Src Block Nb (32-16=16 bits)  |  Enc. Symbol ID (m=16 bits)   |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;2: FEC Payload ID encoding format for m = 16&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>
The format of the FEC Payload ID for m = 8 and m = 16 is illustrated in 
<a class='info' href='#fig_fec_payload_id_for_8'>Figure&nbsp;1<span> (</span><span class='info'>FEC Payload ID encoding format for m = 8 (default)</span><span>)</span></a> and <a class='info' href='#fig_fec_payload_id_for_16'>Figure&nbsp;2<span> (</span><span class='info'>FEC Payload ID encoding format for m = 16</span><span>)</span></a>
respectively.
</p>
<a name="FEC_OTI_EncID2"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.2"></a><h3>4.2.&nbsp;
FEC Object Transmission Information</h3>

<a name="anchor3"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.2.1"></a><h3>4.2.1.&nbsp;
Mandatory Elements</h3>

<p>
</p>
<ul class="text">
<li>FEC Encoding ID:
   the Fully-Specified FEC Scheme described in this section uses FEC Encoding ID 2.
   
</li>
</ul><p>

</p>
<a name="common_elt_EncID2"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.2.2"></a><h3>4.2.2.&nbsp;
Common Elements</h3>

<p> The following elements MUST be defined with the present FEC scheme:
</p>
<p>
</p>
<ul class="text">
<li>Transfer-Length (L): a non-negative integer indicating the length of the
	object in bytes.
	There are some restrictions on the maximum Transfer-Length that
	can be supported:
	
<blockquote class="text">
<p>max_transfer_length = 2^^(32-m) * B * E
</p>
</blockquote>
	For instance, for m = 8, for B = 2^^8 - 1 (because the codec operates on a
	finite field with  2^^8 elements) and if E = 1024 bytes,
	then the maximum transfer length is approximately equal to 2^^42 bytes
	(i.e., 4 Tera Bytes).

	Similarly, for m = 16, for B = 2^^16 - 1 and if E = 1024 bytes,
	then the maximum transfer length is also approximately equal to 2^^42 bytes.

	For larger objects, another FEC scheme, with a larger Source Block Number
	field in the FEC Payload ID, could be defined.
	Another solution consists in fragmenting large objects into smaller
	objects, each of them complying with the above limits.
	
</li>
<li>Encoding-Symbol-Length (E): a non-negative integer indicating the length
	of each encoding symbol in bytes.
</li>
<li>Maximum-Source-Block-Length (B): a non-negative integer indicating the
	maximum number of source symbols in a source block.
</li>
<li>Max-Number-of-Encoding-Symbols (max_n): a non-negative integer
	indicating the maximum number of encoding symbols generated for
	any source block.
</li>
</ul><p>

</p>
<p><a class='info' href='#procedures'>Section&nbsp;6<span> (</span><span class='info'>Procedures with FEC Encoding IDs 2 and 5</span><span>)</span></a> explains how to derive the values
      of each of these elements.
</p>
<a name="scheme_specific_elt_EncID2"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.2.3"></a><h3>4.2.3.&nbsp;
Scheme-Specific Elements</h3>

<p> The following element MUST be defined with the present FEC Scheme.
It contains two distinct pieces of information:
</p>
<p>
</p>
<ul class="text">
<li> G: a non-negative integer indicating the number of encoding symbols
	per group used for the object. The default value is 1, meaning that
	each packet contains exactly one symbol.
	When no G parameter is communicated to the decoder, then this latter
	MUST assume that G = 1.
    
</li>
<li> m:
         The m parameter is the length of the finite field elements, in
         bits. It also characterizes the number of elements in the finite field:
         q = 2^^m elements.
         The default value is m = 8.
         When no finite field size parameter is communicated to the
         decoder, then this latter MUST assume that m = 8.
    
</li>
</ul><p>

</p>
<a name="FEC_OTI_encoding_format_EncID2"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.2.4"></a><h3>4.2.4.&nbsp;
Encoding Format</h3>

<p>This section shows the two possible encoding formats of the above FEC OTI.
    The present document does not specify when one encoding
    format or the other should be used.
</p>
<a name="anchor4"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.2.4.1"></a><h3>4.2.4.1.&nbsp;
Using the General EXT_FTI Format</h3>

<p>
The FEC OTI binary format is the following, when the EXT_FTI mechanism
is used (e.g., within the ALC <a class='info' href='#draft-ietf-rmt-pi-alc-revised'>[10]<span> (</span><span class='info'>Luby, M., Watson, M., and L. Vicisano, &ldquo;Asynchronous Layered Coding (ALC) Protocol Instantiation,&rdquo; February&nbsp;2007.</span><span>)</span></a>
 or NORM <a class='info' href='#draft-ietf-rmt-pi-norm-revised'>[11]<span> (</span><span class='info'>Adamson, B., Bormann, C., Handley, M., and J. Macker, &ldquo;Negative-acknowledgment (NACK)-Oriented Reliable Multicast (NORM) Protocol,&rdquo; March&nbsp;2007.</span><span>)</span></a> protocols).

</p><br /><hr class="insert" />
<a name="fig:EXT_FTI_format_EncID2"></a>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|   HET = 64    |    HEL = 4    |                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+                               +
|                      Transfer-Length (L)                      |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|       m       |       G       |   Encoding Symbol Length (E)  |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|  Max Source Block Length (B)  |  Max Nb Enc. Symbols (max_n)  |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;3: EXT_FTI Header Format&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<a name="anchor5"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.2.4.2"></a><h3>4.2.4.2.&nbsp;
Using the FDT Instance (FLUTE specific)</h3>

<p>When it is desired that the FEC OTI be carried in the FDT (File Delivery Table)
Instance of a FLUTE session <a class='info' href='#draft-ietf-rmt-flute-revised'>[12]<span> (</span><span class='info'>Paila, T., Walsh, R., Luby, M., Lehtonen, R., and V. Roca, &ldquo;FLUTE - File Delivery over Unidirectional Transport,&rdquo; October&nbsp;2007.</span><span>)</span></a>,
the following XML attributes must be described 
for the associated object:
</p>
<ul class="text">
<li>FEC-OTI-FEC-Encoding-ID
</li>
<li>FEC-OTI-Transfer-Length (L)
</li>
<li>FEC-OTI-Encoding-Symbol-Length (E)
</li>
<li>FEC-OTI-Maximum-Source-Block-Length (B)
</li>
<li>FEC-OTI-Max-Number-of-Encoding-Symbols (max_n)
</li>
<li>FEC-OTI-Scheme-Specific-Info
</li>
</ul><p>
The FEC-OTI-Scheme-Specific-Info contains the string resulting from
the Base64 encoding (in the XML Schema xs:base64Binary sense) of the
following value:

</p><br /><hr class="insert" />
<a name="fig_scheme_specific_EncID2"></a>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
 0                   1
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|       m       |       G       |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;4: FEC OTI Scheme Specific Information to be included in the FDT Instance&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>
When no m parameter is to be carried in the FEC OTI, the m field
is set to 0 (which is not a valid seed value).
Otherwise the m field contains a valid value as explained in
<a class='info' href='#scheme_specific_elt_EncID2'>Section&nbsp;4.2.3<span> (</span><span class='info'>Scheme-Specific Elements</span><span>)</span></a>.
Similarly, when no G parameter is to be carried in the FEC OTI, the G field
is set to 0 (which is not a valid seed value).
Otherwise the G field contains a valid value as explained in
<a class='info' href='#scheme_specific_elt_EncID2'>Section&nbsp;4.2.3<span> (</span><span class='info'>Scheme-Specific Elements</span><span>)</span></a>.
When neither m nor G are to be carried in the FEC OTI, then the
sender simply omits the FEC-OTI-Scheme-Specific-Info attribute.

</p>
<p>
After Base64 encoding, the 2 bytes of the FEC OTI Scheme Specific Information
are transformed into a string of 4 printable characters (in the 64-character
alphabet) and added to the FEC-OTI-Scheme-Specific-Info attribute.

</p>
<a name="anchor6"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5"></a><h3>5.&nbsp;
Formats and Codes with FEC Encoding ID 5</h3>

<p>This section introduces the formats and codes associated to the Fully-Specified FEC Scheme
with FEC Encoding ID 5 that focuses on the special case of Reed-Solomon codes over GF(2^^8)
and no encoding symbol group.
</p>
<a name="anchor7"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.1"></a><h3>5.1.&nbsp;
FEC Payload ID</h3>

<p>The FEC Payload ID is composed of the Source Block 
   Number and the Encoding Symbol ID:
</p>
<p>
</p>
<ul class="text">
<li>The Source Block Number (24 bit field) identifies from which source block
   of the object the encoding symbol in the payload is generated.
   There is a maximum of 2^^24 blocks per object.
</li>
<li>The Encoding Symbol ID (8 bit field) identifies which specific encoding
   symbol generated from the source block is carried in the packet payload.
   There is a maximum of 2^^8 encoding symbols per block.
   The first k values (0 to k - 1) identify source symbols, the remaining n-k
   values identify repair symbols.
</li>
</ul><p>

</p>
<p>There MUST be exactly one FEC Payload ID per source or repair packet.
This FEC Payload ID refer to the one and only symbol of the packet.

</p><br /><hr class="insert" />
<a name="fig_fec_payload_id_EncID5"></a>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|        Source Block Number (24 bits)          | Enc. Symb. ID |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;5: FEC Payload ID encoding format with FEC Encoding ID 5&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<a name="FEC_OTI_EncID5"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.2"></a><h3>5.2.&nbsp;
FEC Object Transmission Information</h3>

<a name="anchor8"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.2.1"></a><h3>5.2.1.&nbsp;
Mandatory Elements</h3>

<p>
</p>
<ul class="text">
<li>FEC Encoding ID:
   the Fully-Specified FEC Scheme described in this section uses FEC Encoding ID 5.
   
</li>
</ul><p>

</p>
<a name="anchor9"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.2.2"></a><h3>5.2.2.&nbsp;
Common Elements</h3>

<p> The Common Elements are the same as those specified in
<a class='info' href='#common_elt_EncID2'>Section&nbsp;4.2.2<span> (</span><span class='info'>Common Elements</span><span>)</span></a> when m = 8 and G = 1.
</p>
<a name="scheme_specific_elt"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.2.3"></a><h3>5.2.3.&nbsp;
Scheme-Specific Elements</h3>

<p>No Scheme-Specific elements are defined by this FEC Scheme.
</p>
<a name="FEC_OTI_encoding_format"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.2.4"></a><h3>5.2.4.&nbsp;
Encoding Format</h3>

<p>This section shows the two possible encoding formats of the above FEC OTI.
    The present document does not specify when one encoding
    format or the other should be used.
</p>
<a name="anchor10"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.2.4.1"></a><h3>5.2.4.1.&nbsp;
Using the General EXT_FTI Format</h3>

<p>
The FEC OTI binary format is the following, when the EXT_FTI mechanism
is used (e.g., within the ALC <a class='info' href='#draft-ietf-rmt-pi-alc-revised'>[10]<span> (</span><span class='info'>Luby, M., Watson, M., and L. Vicisano, &ldquo;Asynchronous Layered Coding (ALC) Protocol Instantiation,&rdquo; February&nbsp;2007.</span><span>)</span></a>
 or NORM <a class='info' href='#draft-ietf-rmt-pi-norm-revised'>[11]<span> (</span><span class='info'>Adamson, B., Bormann, C., Handley, M., and J. Macker, &ldquo;Negative-acknowledgment (NACK)-Oriented Reliable Multicast (NORM) Protocol,&rdquo; March&nbsp;2007.</span><span>)</span></a> protocols).

</p><br /><hr class="insert" />
<a name="fig:EXT_FTI_format_EncID5"></a>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|   HET = 64    |    HEL = 3    |                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+                               +
|                      Transfer-Length (L)                      |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|   Encoding Symbol Length (E)  | MaxBlkLen (B) |     max_n     |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;6: EXT_FTI Header Format with FEC Encoding ID 5&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<a name="anchor11"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.2.4.2"></a><h3>5.2.4.2.&nbsp;
Using the FDT Instance (FLUTE specific)</h3>

<p>When it is desired that the FEC OTI be carried in the FDT Instance
of a FLUTE session <a class='info' href='#draft-ietf-rmt-flute-revised'>[12]<span> (</span><span class='info'>Paila, T., Walsh, R., Luby, M., Lehtonen, R., and V. Roca, &ldquo;FLUTE - File Delivery over Unidirectional Transport,&rdquo; October&nbsp;2007.</span><span>)</span></a>,
the following XML attributes must be described 
for the associated object:
</p>
<ul class="text">
<li>FEC-OTI-FEC-Encoding-ID
</li>
<li>FEC-OTI-Transfer-Length (L)
</li>
<li>FEC-OTI-Encoding-Symbol-Length (E)
</li>
<li>FEC-OTI-Maximum-Source-Block-Length (B)
</li>
<li>FEC-OTI-Max-Number-of-Encoding-Symbols (max_n)
</li>
</ul><p>

</p>
<a name="procedures"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6"></a><h3>6.&nbsp;
Procedures with FEC Encoding IDs 2 and 5</h3>

<p>This section defines procedures that are common to FEC Encoding IDs 2
   and 5. In case of FEC Encoding ID 5, m = 8 and G = 1.
   Note that the block partitioning algorithm is defined in <a class='info' href='#rfc5052_fecbb'>[2]<span> (</span><span class='info'>Watson, M., Luby, M., and L. Vicisano, &ldquo;Forward Error Correction (FEC) Building Block,&rdquo; August&nbsp;2007.</span><span>)</span></a>.
</p>
<a name="max_source_block_length"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.1"></a><h3>6.1.&nbsp;
Determining the Maximum Source Block Length (B)</h3>

<p>
The finite field size parameter, m, defines the number of non zero elements in
this field which is equal to: q - 1 = 2^^m - 1.
Note that q - 1 is also the theoretical maximum number of encoding symbols that can
be produced for a source block.
For instance, when m = 8 (default) there is a maximum of 2^^8 - 1 = 255 encoding symbols.

</p>
<p>
Given the target FEC code rate (e.g., provided by the user when
starting a FLUTE sending application), the sender calculates:
      </p>
<blockquote class="text">
<p>max1_B = floor((2^^m - 1) * rate)
</p>
</blockquote><p>
This max1_B value leaves enough room for the sender to produce the
desired number of parity symbols.

</p>
<p>Additionally, a codec MAY impose other limitations on the maximum block size. 
Yet it is not expected that such limits exist when using the default m = 8 value.
This decision MUST be clarified at implementation time, when the target
use case is known. This results in a max2_B limitation.
</p>
<p>
Then, B is given by:
      </p>
<blockquote class="text">
<p>B = min(max1_B, max2_B)
</p>
</blockquote><p>
Note that this calculation is only required at the coder, since the
B parameter is communicated to the decoder through the FEC OTI.

</p>
<a name="n-algorithm"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.2"></a><h3>6.2.&nbsp;
Determining the Number of Encoding Symbols of a Block</h3>

<p>The following algorithm, also called "n-algorithm", explains how to
determine the actual number of encoding symbols for a given block.
</p>
<p> AT A SENDER: 
</p>
<p> Input:
</p>
<blockquote class="text">
<p>B:		Maximum source block length, for any source block.
		<a class='info' href='#max_source_block_length'>Section&nbsp;6.1<span> (</span><span class='info'>Determining the Maximum Source Block Length (B)</span><span>)</span></a> explains how
		to determine its value.
</p>
<p>k:		Current source block length. This parameter is given by the
		block partitioning algorithm.
</p>
<p>rate:	FEC code rate, which is given by the user (e.g., when
		starting a FLUTE sending application).
		It is expressed as a floating point value.
               	
</p>
</blockquote><p>

</p>
<p>
Output:
</p>
<blockquote class="text">
<p>max_n:	Maximum number of encoding symbols generated for any
		source block.
</p>
<p>n:		Number of encoding symbols generated for this source block.
</p>
</blockquote><p>

</p>
<p>
      Algorithm:
      </p>
<blockquote class="text">
<p>max_n = ceil(B / rate);
</p>
<p>if (max_n &gt; 2^^m - 1) then return an error ("invalid code rate");
</p>
<p>n = floor(k * max_n / B);
</p>
</blockquote><p>

</p>
<p>AT A RECEIVER: 
</p>
<p>Input:
</p>
<blockquote class="text">
<p>B:		Extracted from the received FEC OTI.
</p>
<p>max_n:	Extracted from the received FEC OTI.
</p>
<p>k:		Given by the block partitioning algorithm.
</p>
</blockquote><p>

</p>
<p>Output:
</p>
<blockquote class="text">
<p>n
</p>
</blockquote><p>

</p>
<p>
      Algorithm:
      </p>
<blockquote class="text">
<p>n = floor(k * max_n / B);
</p>
</blockquote><p>

</p>
<p>
Note that a Reed-Solomon decoder does not need to know the n value.
Therefore the receiver part of the "n-algorithm" is not necessary from
the Reed-Solomon decoder point of view.
Yet a receiving application using the Reed-Solomon FEC scheme will sometimes
need to know the n value used by the sender, for instance for memory
management optimizations.
To that purpose, the FEC OTI carries all the parameters needed for a
receiver to execute the above algorithm.

</p>
<a name="EncID129_InstID0"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7"></a><h3>7.&nbsp;
Small Block Systematic FEC Scheme (FEC Encoding ID 129) and Reed-Solomon Codes over GF(2^^8)</h3>

<p>In the context of the Under-Specified Small Block Systematic FEC Scheme (FEC Encoding ID 129)
<a class='info' href='#draft-ietf-rmt-bb-fec-basic-schemes-revised'>[3]<span> (</span><span class='info'>Watson, M., &ldquo;Basic Forward Error Correction (FEC) Schemes,&rdquo; February&nbsp;2007.</span><span>)</span></a>, this document assigns the FEC Instance ID 0
to the special case of Reed-Solomon codes over GF(2^^8) and no encoding symbol group.
</p>
<p>The FEC Instance ID 0 uses the Formats and Codes specified in
<a class='info' href='#draft-ietf-rmt-bb-fec-basic-schemes-revised'>[3]<span> (</span><span class='info'>Watson, M., &ldquo;Basic Forward Error Correction (FEC) Schemes,&rdquo; February&nbsp;2007.</span><span>)</span></a>.
</p>
<p>The FEC Scheme with FEC Instance ID 0 MAY use the algorithm defined in Section 9.1. of
<a class='info' href='#rfc5052_fecbb'>[2]<span> (</span><span class='info'>Watson, M., Luby, M., and L. Vicisano, &ldquo;Forward Error Correction (FEC) Building Block,&rdquo; August&nbsp;2007.</span><span>)</span></a> to partition the file into source blocks.
This FEC Scheme MAY also use another algorithm.
For instance the CDP sender may change the length of each source block dynamically, depending on some
external criteria (e.g., to adjust the FEC coding rate to the current loss rate experienced by NORM receivers)
and inform the CDP receivers of the current block length by means of the EXT_FTI mechanism.
This choice is out of the scope of the current document.
</p>
<a name="Reed-SolomonCodes"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.8"></a><h3>8.&nbsp;
Reed-Solomon Codes Specification for the Erasure Channel</h3>

<p>Reed-Solomon (RS) codes are linear block codes.
They also belong to the class of MDS codes.
A [n,k]-RS code encodes a sequence of k source elements defined over a finite field GF(q) into
a sequence of n encoding elements, where n is upper bounded by q - 1.
The implementation described in this document is based on a generator matrix built from a
Vandermonde matrix put into systematic form.
</p>
<p>

<a class='info' href='#FiniteField'>Section&nbsp;8.1<span> (</span><span class='info'>Finite Field</span><span>)</span></a> to <a class='info' href='#Decoding'>Section&nbsp;8.3<span> (</span><span class='info'>Reed-Solomon Decoding Algorithm</span><span>)</span></a> specify the [n,k]-RS codes when applied
to m-bit elements, and <a class='info' href='#Implementation'>Section&nbsp;8.4<span> (</span><span class='info'>Implementation for the Packet Erasure Channel</span><span>)</span></a> the use of [n,k]-RS codes when applied to
symbols composed of several m-bit elements, which is the target of this specification.

</p>
<a name="FiniteField"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.8.1"></a><h3>8.1.&nbsp;
Finite Field</h3>

<p>A finite field GF(q) is defined as a finite set of q elements which has a structure of field. It contains necessarily q = p^^m
elements, where p is a prime number. With packet erasure channels, p is always set to 2. The elements of the field GF(2^^m) can be
represented by polynomials with binary coefficients (i.e., over GF(2)) of degree lower or equal than m-1. The polynomials can be associated to
binary vectors of length m. For example, the vector (11001) represents the polynomial 1 + x + x^^4. This representation is often
called polynomial representation. The addition between two elements is defined as the addition of binary polynomials in GF(2) and
the multiplication is the multiplication modulo a given irreducible polynomial over GF(2) of degree m 
with coefficients in GF(2). Note that all the roots of this  polynomial are in GF(2^^m) but not in GF(2).
</p>
<p>A finite field GF(2^^m) is completely characterized by the irreducible polynomial.
The following polynomials are chosen to represent the field GF(2^^m), for m varying from 2 to 16:
</p>
<blockquote class="text">
<p>m =  2, "111" (1+x+x^^2)
</p>
<p>m =  3, "1101", (1+x+x^^3)
</p>
<p>m =  4, "11001", (1+x+x^^4)
</p>
<p>m =  5, "101001", (1+x^^2+x^^5)
</p>
<p>m =  6, "1100001", (1+x+x^^6)
</p>
<p>m =  7, "10010001", (1+x^^3+x^^7)
</p>
<p>m =  8, "101110001", (1+x^^2+x^^3+x^^4+x^^8)
</p>
<p>m =  9, "1000100001", (1+x^^4+x^^9)
</p>
<p>m = 10, "10010000001", (1+x^^3+x^^10)
</p>
<p>m = 11, "101000000001", (1+x^^2+x^^11)
</p>
<p>m = 12, "1100101000001", (1+x+x^^4+x^^6+x^^12)
</p>
<p>m = 13, "11011000000001", (1+x+x^^3+x^^4+x^^13)
</p>
<p>m = 14, "110000100010001", (1+x+x^^6+x^^10+x^^14)
</p>
<p>m = 15, "1100000000000001", (1+x+x^^15)
</p>
<p>m = 16, "11010000000010001", (1+x+x^^3+x^^12+x^^16)
</p>
</blockquote><p>
In order to facilitate the implementation, these polynomials are also primitive. This means that any element
of GF(2^^m) can be expressed as a power of a given root of this polynomial.
These polynomials are also chosen so that they contain the minimum number of monomials.

</p>
<a name="Encoding"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.8.2"></a><h3>8.2.&nbsp;
Reed-Solomon Encoding Algorithm</h3>

<a name="EncodingPrinciples"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.8.2.1"></a><h3>8.2.1.&nbsp;
Encoding Principles</h3>

<p>Let s = (s_0, ..., s_{k-1}) be a source vector of k elements over GF(2^^m).
Let e = (e_0, ..., e_{n-1}) be the corresponding encoding vector of n elements over GF(2^^m).
Being a linear code, encoding is performed by multiplying the source vector by a generator matrix, GM, of k rows and n columns
over GF(2^^m). Thus:
</p>
<blockquote class="text">
<p>	e = s * GM.
</p>
</blockquote><p>
The definition of the generator matrix completely characterizes the RS code.
</p>
<p>Let us consider that: n = 2^^m - 1 and: 0 &lt; k &le; n.
Let us denote by alpha the root of the primitive polynomial of degree m chosen in the list of <a class='info' href='#FiniteField'>Section&nbsp;8.1<span> (</span><span class='info'>Finite Field</span><span>)</span></a>
for the corresponding value of m.
Let us consider a Vandermonde matrix of k rows and n columns, denoted by V_{k,n}, and built as follows:
the {i, j} entry of V_{k,n} is v_{i,j} = alpha^^(i*j), where 0 &le; i &le; k - 1 and 0 &le; j &le; n - 1.
This matrix generates a MDS code.
However, this MDS code is not systematic, which is a problem for many networking applications.
To obtain a systematic matrix (and code), the simplest solution consists in considering the matrix V_{k,k}
formed by the first k columns of V_{k,n}, then to invert it and to multiply this inverse by V_{k,n}.
Clearly, the product V_{k,k}^^-1 * V_{k,n} contains the identity matrix I_k on its first k columns, meaning
that the first k encoding elements are equal to source elements. Besides the associated code keeps the MDS property.
</p>
<p>Therefore, the generator matrix of the code considered in this document is:
</p>
<blockquote class="text">
<p>	GM = (V_{k,k}^^-1) * V_{k,n}
</p>
</blockquote><p>

</p>
<p>Note that, in practice, the [n,k]-RS code can be shortened to a [n',k]-RS code, where k &le; n' &lt; n,
by considering the sub-matrix formed by the n' first columns of GM.
</p>
<a name="anchor12"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.8.2.2"></a><h3>8.2.2.&nbsp;
Encoding Complexity</h3>

<p>Encoding can be performed by first pre-computing GM and by multiplying the source vector (k
elements) by GM (k rows and n columns).
The complexity of the pre-computation of the generator matrix can be estimated as the complexity of
the multiplication of the inverse of a Vandermonde matrix by n-k vectors (i.e., the last n-k columns of V_{k,n}).
Since the complexity of the inverse of a k*k-Vandermonde matrix by a vector is O(k * log^^2(k)), the
generator matrix can be computed in 0((n-k)* k * log^^2(k)) operations.
When the generator matrix is pre-computed, the encoding needs k operations per repair element
(vector-matrix multiplication).

</p>
<p>Encoding can also be performed by first computing the product s * V_{k,k}^^-1 and then
by multiplying the result with V_{k,n}.
The multiplication by the inverse of a square Vandermonde matrix is known as the interpolation problem and
its complexity is O(k * log^^2 (k)).
The multiplication by a Vandermonde matrix, known as the multipoint evaluation problem, requires
O((n-k) * log(k)) by using Fast Fourier Transform, as explained in <a class='info' href='#GO94'>[7]<span> (</span><span class='info'>Gohberg, I. and V. Olshevsky, &ldquo;Fast algorithms with preprocessing for matrix-vector multiplication problems,&rdquo; .</span><span>)</span></a>.
The total complexity of this encoding algorithm is then O((k/(n-k)) * log^^2(k) + log(k)) operations
per repair element.
</p>
<a name="Decoding"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.8.3"></a><h3>8.3.&nbsp;
Reed-Solomon Decoding Algorithm</h3>

<a name="DecodingPrinciples"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.8.3.1"></a><h3>8.3.1.&nbsp;
Decoding Principles</h3>

<p>The Reed-Solomon decoding algorithm for the erasure channel allows the recovery of the k source elements from any set of k received
elements. It is based on the fundamental property of the generator matrix which is such that any k*k-submatrix is invertible (see <a class='info' href='#MWS77'>[6]<span> (</span><span class='info'>Mac Williams, F. and N. Sloane, &ldquo;The Theory of Error Correcting Codes,&rdquo; .</span><span>)</span></a>).
The first step of the decoding consists in extracting the k*k submatrix of the generator matrix obtained by considering the columns
corresponding to the received elements. Indeed, since any encoding element is obtained by multiplying the source vector by one column of
the generator matrix, the received vector of k encoding elements can be considered as the result of the multiplication of the source
vector by a k*k submatrix of the generator matrix. Since this submatrix is invertible, the second step of the algorithm is to invert
this matrix and to multiply the received vector by the obtained matrix to recover the source vector.
</p>
<a name="anchor13"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.8.3.2"></a><h3>8.3.2.&nbsp;
Decoding Complexity</h3>

<p>The decoding algorithm described previously includes the matrix inversion and the vector-matrix multiplication. With the classical
Gauss-Jordan algorithm, the matrix inversion requires O(k^^3) operations and the vector-matrix multiplication is performed in O(k^^2)
operations.
</p>
<p>This complexity can be improved by considering that the received submatrix of GM is the product between the inverse of a Vandermonde
matrix (V_(k,k)^^-1) and another Vandermonde matrix (denoted by V' which is a submatrix of V_(k,n)). The decoding can be done by
multiplying the received vector by V'^^-1 (interpolation problem with complexity O( k * log^^2(k)) ) then by V_{k,k} (multipoint
evaluation with complexity O(k * log(k))). The global decoding complexity is then O(log^^2(k)) operations per source element.
</p>
<a name="Implementation"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.8.4"></a><h3>8.4.&nbsp;
Implementation for the Packet Erasure Channel</h3>

<p>In a packet erasure channel, each packet (and symbol(s) since packets contain G &ge; 1 symbols)
is either correctly received or erased.
The location of the erased symbols in the sequence of symbols MUST be known.
The following specification describes the use of Reed-Solomon codes for generating redundant symbols
from the k source symbols and for recovering the source symbols from any set of k received symbols.
</p>
<p>The k source symbols of a source block are assumed to be composed of S m-bit elements.
Each m-bit element corresponds to an element of the finite field GF(2^^m) through the polynomial
representation (<a class='info' href='#FiniteField'>Section&nbsp;8.1<span> (</span><span class='info'>Finite Field</span><span>)</span></a>).
If some of the source symbols contain less than S elements, they MUST be virtually padded with zero
elements (it can be the case for the last symbol of the last block of the object).
However, this padding does not need to be actually sent with the data to the receivers.

</p>
<p>The encoding process produces n encoding symbols of size S m-bit elements, of which k are source symbols
(this is a systematic code) and n-k are repair symbols (<a class='info' href='#encodingFigure'>Figure&nbsp;7<span> (</span><span class='info'>Packet encoding scheme</span><span>)</span></a>).
The m-bit elements of the repair symbols are calculated using the corresponding m-bit elements of the source symbol set.
A logical j-th source vector, comprised of the j-th elements from the set of source symbols,
is used to calculate a j-th encoding vector.
This j-th encoding vector then provides the j-th elements for the set encoding symbols calculated for the block.
As a systematic code, the first k encoding symbols are the same as the k source symbols and the last n-k repair
symbols are the result of the Reed-Solomon encoding. 

</p><br /><hr class="insert" />
<a name="encodingFigure"></a>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
       Input:  k source symbols

 0             j                                  S-1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|             |X|                                   | source symbol 0
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|             |X|                                   | source symbol 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
             . . .
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|             |X|                                   | source symbol k-1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

               *

     +--------------------+
     |  generator matrix  |
     |         GM         |
     |       (k x n)      |
     +--------------------+

               |
               V

     Output: n encoding symbols (source + repair)

 0             j                                  S-1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|             |X|                                   | enc. symbol 0
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|             |X|                                   | enc. symbol 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
             . . .
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|             |Y|                                   | enc. symbol n-1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;7: Packet encoding scheme&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>An asset of this scheme is that the loss of some encoding symbols produces the same
erasure pattern for each of the S encoding vectors.
It follows that the matrix inversion must be done only once and will be used by all the
S encoding vectors.
For large S, this matrix inversion cost becomes negligible in front of the S matrix-vector
multiplications.
</p>
<p>Another asset is that the n-k repair symbols can be produced on demand.
For instance, a sender can start by producing a limited number of repair symbols
and later on, depending on the observed erasures on the channel, decide to
produce additional repair symbols, up to the n-k upper limit.
Indeed, to produce the repair symbol e_j, where k &le; j &lt; n, it is sufficient
to multiply the S source vectors with column j of GM.

</p>
<a name="SecurityConsiderations"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.9"></a><h3>9.&nbsp;
Security Considerations</h3>

<a name="anchor14"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.9.1"></a><h3>9.1.&nbsp;
Problem Statement</h3>

<p>
A content delivery system is potentially subject to many attacks:
some of them target the network (e.g., to compromise the routing infrastructure,
by compromising the congestion control component), others target
the Content Delivery Protocol (CDP) (e.g., to compromise its normal behavior),
and finally some attacks target the content itself.
Since this document focuses on a FEC building block independently of any
particular CDP (even if ALC and NORM are two natural candidates), this
section only discusses the additional threats that an arbitrary CDP may be exposed
to when using this building block.

</p>
<p>
More specifically, several kinds of attacks exist:
</p>
<ul class="text">
<li> those that are meant to give access to a confidential content (e.g., in
	  case of a non-free content),
</li>
<li> those that try to corrupt the object being transmitted (e.g., to
	  inject malicious code within an object, or to prevent a receiver
	  from using an object),
</li>
<li> and those that try to compromise the receiver's behavior (e.g., by
	  making the decoding of an object computationally expensive).
</li>
</ul><p>
These attacks can be launched either against the data flow itself (e.g.
by sending forged symbols) or against the FEC parameters that are
sent either in-band (e.g., in an EXT_FTI or FDT Instance) or out-of-band (e.g., in
a session description).

</p>
<a name="anchor15"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.9.2"></a><h3>9.2.&nbsp;
Attacks Against the Data Flow</h3>

<p>
First of all, let us consider the attacks against the data flow.
Access control is typically provided by means of encryption. This encryption
can be done over the whole object (e.g., by the content provider, before the
FEC encoding process), or be done on a packet per packet basis (e.g., when IPSec/ESP
is used <a class='info' href='#RFC4303_esp'>[14]<span> (</span><span class='info'>Kent, S., &ldquo;IP Encapsulating Security Payload (ESP),&rdquo; December&nbsp;2005.</span><span>)</span></a>).
If access control is a concern, it is RECOMMENDED that one of these solutions be used.
Even if we mention these attacks here, they are not related nor facilitated by
the use of FEC.

</p>
<p>
Protection against corruptions (forged packets) is achieved by means of a
content integrity verification/sender authentication scheme.
This service can be provided at the object level, but in that case a receiver
has no way to identify which symbol(s) is(are) corrupted if the object is detected
as corrupted. 
This service can also be provided at the packet level, and after having removed
all forged packets, the object can be recovered if the number of symbols remaining
is sufficient.
Several techniques can provide this source authentication/content integrity
service:
</p>
<ul class="text">
<li> at the object level, the object MAY be digitally signed (with public key
  cryptography) (e.g., using RSASSA-PKCS1-v1_5 <a class='info' href='#RFC3447_pkcs1'>[13]<span> (</span><span class='info'>Jonsson, J. and B. Kaliski, &ldquo;Public-Key Cryptography Standards (PKCS) #1: RSA Cryptography Specifications Version 2.1,&rdquo; February&nbsp;2003.</span><span>)</span></a>).
  This signature enables a receiver to check the object, once this latter has
  been fully decoded. Even if digital signatures are computationally expensive,
  this calculation occurs only once per object, which is usually acceptable;
</li>
<li> at the packet level, each packet can be digitally signed. A major limitation is
  the high computational and transmission overheads that this solution incurs (unless
  ECC is used, but ECC is protected by IPR). To avoid this problem, the signature
  may span a set of symbols in order to amortize the signature calculation, but
  if a single symbol is missing, the integrity of the whole set cannot be checked;
</li>
<li> at the packet level, a Group Message Authentication Code (MAC) <a class='info' href='#rfc2104_hmac'>[15]<span> (</span><span class='info'>, &ldquo;HMAC: Keyed-Hashing for Message Authentication,&rdquo; February&nbsp;1997.</span><span>)</span></a>
  (e.g., using HMAC-SHA-1 with a secret key shared by all the group members, senders and receivers)
  scheme can be used.
  This technique creates a cryptographically secured (thanks to the secret key)
  digest of a packet that is sent along with the packet.
  The Group MAC scheme  does not incur prohibitive processing load nor transmission
  overhead, but it has a major limitation: it only provides a group authentication/integrity
  service since all group members share the same secret group key, which means that each
  member can send a forged packet. It is therefore restricted to situations where
  group members are fully trusted (or in association with another technique as a
  pre-check);
</li>
<li> at the packet level, TESLA <a class='info' href='#rfc4082_tesla_intro'>[16]<span> (</span><span class='info'>, &ldquo;Timed Efficient Stream Loss-Tolerant Authentication (TESLA): 						Multicast Source Authentication Transform Introduction,&rdquo; June&nbsp;2005.</span><span>)</span></a> is a very attractive
  and efficient solution that is robust to losses, provides a true authentication/integrity
  service, and does not incur any prohibitive processing load or transmission overhead.
</li>
</ul><p>

</p>
<p>
It is up to the developer, who knows the security requirements of the
target use-case, to define which solution is the most appropriate.
Nonetheless, it is RECOMMENDED that at least one of these techniques be used.

</p>
<p>
Techniques relying on public key cryptography (digital signatures and TESLA during
the bootstrap process) require that public keys be securely associated to the
entities. This can be achieved by a Public Key Infrastructure (PKI), or by a
PGP Web of Trust, or by pre-distributing the public keys of each group member.
It is up to the developer, who knows the features of the target use-case, to
define which solution to use.

</p>
<p>
Techniques relying on symmetric key cryptography (group MAC) require that a
secret key be shared by all group members. This can be achieved by means of a
group key management protocol, or simply by pre-distributing the secret key
(but this manual solution has many limitations).
Here also, it is up to the developer to define which solution to use, taking
into account the target use-case features.

</p>
<a name="anchor16"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.9.3"></a><h3>9.3.&nbsp;
Attacks against the FEC parameters</h3>

<p>
Let us now consider attacks against the FEC parameters (or FEC OTI).
The FEC OTI can either be sent in-band (i.e., in an EXT_FTI or in an FDT Instance
containing FEC OTI for the object) or out-of-band (e.g., in a session description).
Attacks on these FEC parameters can prevent the decoding of the associated object:
for instance modifying the B parameter will lead to a different block partitioning
at a receiver thereby compromising decoding; or setting the m parameter to 16 instead
of 8 with FEC Encoding ID 2 will increase the processing load while compromising decoding.

</p>
<p>
It is therefore RECOMMENDED that security measures be taken to guarantee the
FEC OTI integrity. To that purpose, the packets carrying the FEC parameters sent in-band
(i.e., in an EXT_FTI header extension or in an FDT Instance) may be protected by one of the
per-packet techniques described above: TESLA, digital signature, or a group MAC.
Alternatively, when FEC OTI is contained in an FDT Instance, this object may
be digitally signed.
Finally, when FEC OTI is sent out-of-band for instance in a session description,
this latter may be protected by a digital signature.

</p>
<p>
The same considerations concerning the key management aspects apply here also.

</p>
<a name="iana-cons"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.10"></a><h3>10.&nbsp;
IANA Considerations</h3>

<p>
Values of FEC Encoding IDs and FEC Instance IDs are subject to IANA registration.
For general guidelines on IANA considerations as they
apply to this document, see <a class='info' href='#rfc5052_fecbb'>[2]<span> (</span><span class='info'>Watson, M., Luby, M., and L. Vicisano, &ldquo;Forward Error Correction (FEC) Building Block,&rdquo; August&nbsp;2007.</span><span>)</span></a>.

</p>
<p>
This document assigns the Fully-Specified FEC Encoding ID 2 
under the "ietf:rmt:fec:encoding" name-space to "Reed-Solomon Codes over GF(2^^m)".

</p>
<p>
This document assigns the Fully-Specified FEC Encoding ID 5 
under the "ietf:rmt:fec:encoding" name-space to "Reed-Solomon Codes over GF(2^^8)".

</p>
<p>
This document assigns the FEC Instance ID 0 scoped by the Under-Specified FEC Encoding ID 129
to "Reed-Solomon Codes over GF(2^^8)".
More specifically, under the "ietf:rmt:fec:encoding:instance" sub-name-space that is scoped
by the "ietf:rmt:fec:encoding" called "Small Block Systematic FEC Codes", this document
assigns FEC Instance ID 0 to "Reed-Solomon Codes over GF(2^^8)".

</p>
<a name="Acknowledgments"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.11"></a><h3>11.&nbsp;
Acknowledgments</h3>

<p>
The authors want to thank Brian Adamson, Igor Slepchin, Stephen Kent, and Francis Dupont for
their valuable comments.
The authors also want to thank Luigi Rizzo for his comments and for the design of
the reference Reed-Solomon codec.
            
</p>
<a name="rfc.references"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.12"></a><h3>12.&nbsp;
References</h3>

<a name="rfc.references1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>12.1.&nbsp;Normative References</h3>
<table width="99%" border="0">
<tr><td class="author-text" valign="top"><a name="rfc2119">[1]</a></td>
<td class="author-text">Bradner, S., &ldquo;<a href="http://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>,&rdquo; RFC&nbsp;2119.</td></tr>
<tr><td class="author-text" valign="top"><a name="rfc5052_fecbb">[2]</a></td>
<td class="author-text">Watson, M., Luby, M., and L. Vicisano, &ldquo;<a href="http://tools.ietf.org/html/rfc5052">Forward Error Correction (FEC) Building Block</a>,&rdquo; RFC&nbsp;5052, August&nbsp;2007.</td></tr>
<tr><td class="author-text" valign="top"><a name="draft-ietf-rmt-bb-fec-basic-schemes-revised">[3]</a></td>
<td class="author-text">Watson, M., &ldquo;Basic Forward Error Correction (FEC) Schemes,&rdquo; &nbsp;draft-ietf-rmt-bb-fec-basic-schemes-revised-03.txt (work in progress), February&nbsp;2007.</td></tr>
</table>

<a name="rfc.references2"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>12.2.&nbsp;Informative References</h3>
<table width="99%" border="0">
<tr><td class="author-text" valign="top"><a name="rfc3453">[4]</a></td>
<td class="author-text">Luby, M., Vicisano, L., Gemmell, J., Rizzo, L., Handley, M., and J. Crowcroft, &ldquo;<a href="http://tools.ietf.org/html/rfc3453">The Use of Forward Error Correction (FEC) in Reliable Multicast</a>,&rdquo; RFC&nbsp;3453, December&nbsp;2002.</td></tr>
<tr><td class="author-text" valign="top"><a name="RS-codec">[5]</a></td>
<td class="author-text">Rizzo, L., &ldquo;Reed-Solomon FEC codec (revised version of July 2nd, 1998), available at
http://info.iet.unipi.it/~luigi/vdm98/vdm980702.tgz and mirrored at http://planete-bcast.inrialpes.fr/,&rdquo; July&nbsp;1998.</td></tr>
<tr><td class="author-text" valign="top"><a name="MWS77">[6]</a></td>
<td class="author-text">Mac Williams, F. and N. Sloane, &ldquo;The Theory of Error Correcting Codes,&rdquo; North Holland,&nbsp;1977.</td></tr>
<tr><td class="author-text" valign="top"><a name="GO94">[7]</a></td>
<td class="author-text">Gohberg, I. and V. Olshevsky, &ldquo;Fast algorithms with preprocessing for matrix-vector multiplication problems,&rdquo; Journal of Complexity,&nbsp;pp. 411-427, vol. 10, 1994.</td></tr>
<tr><td class="author-text" valign="top"><a name="draft-ietf-rmt-bb-fec-ldpc">[8]</a></td>
<td class="author-text">Roca, V., Neumann, C., and D. Furodet, &ldquo;Low Density Parity Check (LDPC) Forward Error Correction,&rdquo; &nbsp;draft-ietf-rmt-bb-fec-ldpc-06.txt (work in progress), May&nbsp;2007.</td></tr>
<tr><td class="author-text" valign="top"><a name="draft-ietf-rmt-bb-fec-raptor-object">[9]</a></td>
<td class="author-text">Luby, M., Shokrollahi, A., Watson, M., and T. Stockhammer, &ldquo;Raptor Forward Error Correction Scheme,&rdquo; &nbsp;draft-ietf-rmt-bb-fec-raptor-object-09 (work in progress), June&nbsp;2007.</td></tr>
<tr><td class="author-text" valign="top"><a name="draft-ietf-rmt-pi-alc-revised">[10]</a></td>
<td class="author-text">Luby, M., Watson, M., and L. Vicisano, &ldquo;Asynchronous Layered Coding (ALC) Protocol Instantiation,&rdquo; &nbsp;draft-ietf-rmt-pi-alc-revised-04.txt (work in progress), February&nbsp;2007.</td></tr>
<tr><td class="author-text" valign="top"><a name="draft-ietf-rmt-pi-norm-revised">[11]</a></td>
<td class="author-text">Adamson, B., Bormann, C., Handley, M., and J. Macker, &ldquo;Negative-acknowledgment (NACK)-Oriented Reliable Multicast (NORM) Protocol,&rdquo; &nbsp;draft-ietf-rmt-pi-norm-revised-05.txt (work in progress), March&nbsp;2007.</td></tr>
<tr><td class="author-text" valign="top"><a name="draft-ietf-rmt-flute-revised">[12]</a></td>
<td class="author-text">Paila, T., Walsh, R., Luby, M., Lehtonen, R., and V. Roca, &ldquo;FLUTE - File Delivery over Unidirectional Transport,&rdquo; &nbsp;draft-ietf-rmt-flute-revised-04.txt (work in progress), October&nbsp;2007.</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC3447_pkcs1">[13]</a></td>
<td class="author-text">Jonsson, J. and B. Kaliski, &ldquo;<a href="http://tools.ietf.org/html/rfc3447">Public-Key Cryptography Standards (PKCS) #1: RSA Cryptography Specifications Version 2.1</a>,&rdquo; RFC&nbsp;3447, February&nbsp;2003 (<a href="ftp://ftp.isi.edu/in-notes/rfc3447.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4303_esp">[14]</a></td>
<td class="author-text">Kent, S., &ldquo;<a href="http://tools.ietf.org/html/rfc4303">IP Encapsulating Security Payload (ESP)</a>,&rdquo; RFC&nbsp;4303, December&nbsp;2005 (<a href="ftp://ftp.isi.edu/in-notes/rfc4303.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="rfc2104_hmac">[15]</a></td>
<td class="author-text">&ldquo;<a href="http://tools.ietf.org/html/rfc2104">HMAC: Keyed-Hashing for Message Authentication</a>,&rdquo; RFC&nbsp;2104, February&nbsp;1997.</td></tr>
<tr><td class="author-text" valign="top"><a name="rfc4082_tesla_intro">[16]</a></td>
<td class="author-text">&ldquo;<a href="http://tools.ietf.org/html/rfc4082">Timed Efficient Stream Loss-Tolerant Authentication (TESLA):
						Multicast Source Authentication Transform Introduction</a>,&rdquo; RFC&nbsp;4082, June&nbsp;2005.</td></tr>
</table>

<a name="rfc.authors"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>Authors' Addresses</h3>
<table width="99%" border="0" cellpadding="0" cellspacing="0">
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Jerome Lacan</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">ISAE</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">1, place Emile Blouin</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Toulouse  31056</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">France</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:jerome.lacan@isae.fr">jerome.lacan@isae.fr</a></td></tr>
<tr><td class="author" align="right">URI:&nbsp;</td>
<td class="author-text"><a href="http://dmi.ensica.fr/auteur.php3?id_auteur=5">http://dmi.ensica.fr/auteur.php3?id_auteur=5</a></td></tr>
<tr cellpadding="3"><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Vincent Roca</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">INRIA</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">655, av. de l'Europe</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Inovallee; Montbonnot</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">ST ISMIER cedex  38334</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">France</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:vincent.roca@inrialpes.fr">vincent.roca@inrialpes.fr</a></td></tr>
<tr><td class="author" align="right">URI:&nbsp;</td>
<td class="author-text"><a href="http://planete.inrialpes.fr/~roca/">http://planete.inrialpes.fr/~roca/</a></td></tr>
<tr cellpadding="3"><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Jani Peltotalo</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Tampere University of Technology</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">P.O. Box 553 (Korkeakoulunkatu 1)</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Tampere  FIN-33101</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Finland</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:jani.peltotalo@tut.fi">jani.peltotalo@tut.fi</a></td></tr>
<tr><td class="author" align="right">URI:&nbsp;</td>
<td class="author-text"><a href="http://atm.tut.fi/mad">http://atm.tut.fi/mad</a></td></tr>
<tr cellpadding="3"><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Sami Peltotalo</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Tampere University of Technology</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">P.O. Box 553 (Korkeakoulunkatu 1)</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Tampere  FIN-33101</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Finland</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:sami.peltotalo@tut.fi">sami.peltotalo@tut.fi</a></td></tr>
<tr><td class="author" align="right">URI:&nbsp;</td>
<td class="author-text"><a href="http://atm.tut.fi/mad">http://atm.tut.fi/mad</a></td></tr>
</table>
<a name="rfc.copyright"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>Full Copyright Statement</h3>
<p class='copyright'>
Copyright &copy; The IETF Trust (2007).</p>
<p class='copyright'>
This document is subject to the rights,
licenses and restrictions contained in BCP&nbsp;78,
and except as set forth therein,
the authors retain all their rights.</p>
<p class='copyright'>
This document and the information contained herein are provided
on an &ldquo;AS IS&rdquo; basis and THE CONTRIBUTOR,
THE ORGANIZATION HE/SHE REPRESENTS
OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY, THE IETF TRUST
AND THE INTERNET ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT
THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY
IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR
PURPOSE.</p>
<h3>Intellectual Property</h3>
<p class='copyright'>
The IETF takes no position regarding the validity or scope of any
Intellectual Property Rights or other rights that might be claimed
to pertain to the implementation or use of the technology
described in this document or the extent to which any license
under such rights might or might not be available; nor does it
represent that it has made any independent effort to identify any
such rights.
Information on the procedures with respect to
rights in RFC documents can be found in BCP&nbsp;78 and BCP&nbsp;79.</p>
<p class='copyright'>
Copies of IPR disclosures made to the IETF Secretariat and any
assurances of licenses to be made available,
or the result of an attempt made to obtain a general license or
permission for the use of such proprietary rights by implementers or
users of this specification can be obtained from the IETF on-line IPR
repository at <a href='http://www.ietf.org/ipr'>http://www.ietf.org/ipr</a>.</p>
<p class='copyright'>
The IETF invites any interested party to bring to its attention
any copyrights,
patents or patent applications,
or other
proprietary rights that may cover technology that may be required
to implement this standard.
Please address the information to the IETF at <a href='mailto:ietf-ipr@ietf.org'>ietf-ipr@ietf.org</a>.</p>
</body></html>
