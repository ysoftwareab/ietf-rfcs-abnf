root-schema = {
     ? definitions: { * tstr => { schema}},
     schema,
schema = (
     ref //
     type //
     enum //
     elements //
     properties //
     values //
     discriminator //
     empty //
shared = (
     ? metadata: { * tstr => any },
     ? nullable: bool,
empty = shared

ref = ( ref: tstr, shared )

type = (
     type: "boolean"
       / "float32"
       / "float64"
       / "int8"
       / "uint8"
       / "int16"
       / "uint16"
       / "int32"
       / "uint32"
       / "string"
       / "timestamp",
     shared,
enum = ( enum: [+ tstr], shared )

elements = ( elements: { schema }, shared )
properties = (with-properties // with-optional-properties)

with-properties = (
     properties: { * tstr => { schema }},
     ? optionalProperties: { * tstr => { schema }},
     ? additionalProperties: bool,
     shared,
with-optional-properties = (
     ? properties: { * tstr => { schema }},
     optionalProperties: { * tstr => { schema }},
     ? additionalProperties: bool,
     shared,
values = ( values: { schema }, shared )

discriminator = (
     discriminator: tstr,

     ; Note well: this rule is defined in terms of the "properties"
     ; CDDL rule, not the "schema" CDDL rule.
     mapping: { * tstr => { properties } }
     shared,
root = any

root = [* a]

a = [* b]
b = number

root = "PENDING" / "DONE" / "CANCELED"

root = bool

root = number

root = tstr

root = tdate

root = [* number]

root = { a: bool, b: number, ? c: tstr, ? d: tdate }

root = { * tstr => number }

root = { a: "foo", b: number } / { a: "bar", b: tstr }

