


Network Working Group                                        M. Nystroem
Internet-Draft                         RSA, The Security Division of EMC
Intended status: Informational                                S. Machani
Expires: December 13, 2007                              Diversinet Corp.
                                                                  M. Pei
                                                          VeriSign, Inc.
                                                              A. Doherty
                                       RSA, The Security Division of EMC
                                                           June 11, 2007


          Dynamic Symmetric Key Provisioning Protocol (DSKPP)
                     draft-doherty-keyprov-dskpp-00

Status of this Memo

   By submitting this Internet-Draft, each author represents that any
   applicable patent or other IPR claims of which he or she is aware
   have been or will be disclosed, and any of which he or she becomes
   aware will be disclosed, in accordance with Section 6 of BCP 79.

   Internet-Drafts are working documents of the Internet Engineering
   Task Force (IETF), its areas, and its working groups.  Note that
   other groups may also distribute working documents as Internet-
   Drafts.

   Internet-Drafts are draft documents valid for a maximum of six months
   and may be updated, replaced, or obsoleted by other documents at any
   time.  It is inappropriate to use Internet-Drafts as reference
   material or to cite them other than as "work in progress."

   The list of current Internet-Drafts can be accessed at
   http://www.ietf.org/ietf/1id-abstracts.txt.

   The list of Internet-Draft Shadow Directories can be accessed at
   http://www.ietf.org/shadow.html.

   This Internet-Draft will expire on December 13, 2007.

Copyright Notice

   Copyright (C) The IETF Trust (2007).









Nystroem, et al.        Expires December 13, 2007               [Page 1]


Internet-Draft                    DSKPP                        June 2007


Abstract

   DSKPP is a client-server protocol for initialization (and
   configuration) of cryptographic tokens.  The protocol requires
   neither private-key capabilities in the cryptographic tokens, nor an
   established public-key infrastructure.  The four-pass variant of the
   protocol ensures that a provisioned (or generated) symmetric key will
   only be available to the server and the cryptographic token itself.
   Two-pass (i.e., one round-trip) and one-pass (i.e., one message)
   variants enable secure and efficient download and installation of a
   symmetric key to a cryptographic token.


Table of Contents

   1.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   6
     1.1.  Scope . . . . . . . . . . . . . . . . . . . . . . . . . .   6
     1.2.  Background  . . . . . . . . . . . . . . . . . . . . . . .   6
     1.3.  Use Cases . . . . . . . . . . . . . . . . . . . . . . . .   7
       1.3.1.   A mobile device user obtains a symmetric key . . . .   7
       1.3.2.   A user acquires multiple symmetric keys of
                different types  . . . . . . . . . . . . . . . . . .   7
       1.3.3.   A key provisioning service imposes a validity
                period policy for provisioning sessions  . . . . . .   7
       1.3.4.   A symmetric key issuer uses a third pary
                provisioning service provider  . . . . . . . . . . .   8
       1.3.5.   A client application uses a pre-shared transport
                key to communicate with the provisioning service
                provider . . . . . . . . . . . . . . . . . . . . . .   8
       1.3.6.   A user renews its symmetric key with the same key
                ID . . . . . . . . . . . . . . . . . . . . . . . . .   8
       1.3.7.   An administrator initiates a symmetric key
                replacement before it can be used  . . . . . . . . .   9
       1.3.8.   A user acquires a symmetric key through SMS  . . . .   9
       1.3.9.   A client acquires a symmetric key over a
                transport protocol that does not ensure data
                confidentiality  . . . . . . . . . . . . . . . . . .   9
       1.3.10.  A client acquires a symmetric key over a
                transport protocol that does not provide
                authentication . . . . . . . . . . . . . . . . . . .  10
     1.4.  Requirements  . . . . . . . . . . . . . . . . . . . . . .  10
       1.4.1.   Mandatory Requirements . . . . . . . . . . . . . . .  10
       1.4.2.   Desirable Requirements . . . . . . . . . . . . . . .  11
     1.5.  Non-Goals . . . . . . . . . . . . . . . . . . . . . . . .  11
     1.6.  Document organization . . . . . . . . . . . . . . . . . .  12
   2.  Acronyms and Notation . . . . . . . . . . . . . . . . . . . .  13
     2.1.  Acronyms  . . . . . . . . . . . . . . . . . . . . . . . .  13
     2.2.  Notation and Terminology  . . . . . . . . . . . . . . . .  13



Nystroem, et al.        Expires December 13, 2007               [Page 2]


Internet-Draft                    DSKPP                        June 2007


     2.3.  XML Namespaces  . . . . . . . . . . . . . . . . . . . . .  14
   3.  DSKPP . . . . . . . . . . . . . . . . . . . . . . . . . . . .  15
     3.1.  Overview  . . . . . . . . . . . . . . . . . . . . . . . .  15
     3.2.  Entities  . . . . . . . . . . . . . . . . . . . . . . . .  15
     3.3.  Principles of Operation . . . . . . . . . . . . . . . . .  15
       3.3.1.   Four-pass DSKPP  . . . . . . . . . . . . . . . . . .  15
       3.3.2.   Two-pass DSKPP . . . . . . . . . . . . . . . . . . .  19
       3.3.3.   One-pass DSKPP . . . . . . . . . . . . . . . . . . .  19
     3.4.  Authentication  . . . . . . . . . . . . . . . . . . . . .  20
       3.4.1.   Client Authentication  . . . . . . . . . . . . . . .  20
       3.4.2.   Server Authentication  . . . . . . . . . . . . . . .  22
     3.5.  Symmetric Key Container Format  . . . . . . . . . . . . .  22
     3.6.  The DSKPP One-Way Pseudorandom Function, DSKPP-PRF  . . .  22
       3.6.1.   Introduction . . . . . . . . . . . . . . . . . . . .  22
       3.6.2.   Declaration  . . . . . . . . . . . . . . . . . . . .  23
     3.7.  Generation of Symmetric Keys for Cryptographic Tokens . .  23
     3.8.  Encryption of Pseudorandom Nonces Sent from the DSKPP
           Client  . . . . . . . . . . . . . . . . . . . . . . . . .  24
     3.9.  MAC calculations  . . . . . . . . . . . . . . . . . . . .  24
       3.9.1.   Four-pass DSKPP  . . . . . . . . . . . . . . . . . .  24
       3.9.2.   Two-pass DSKPP . . . . . . . . . . . . . . . . . . .  25
       3.9.3.   One-pass DSKPP . . . . . . . . . . . . . . . . . . .  26
     3.10. DSKPP Schema Basics . . . . . . . . . . . . . . . . . . .  27
       3.10.1.  Introduction . . . . . . . . . . . . . . . . . . . .  27
       3.10.2.  General XML Schema Requirements  . . . . . . . . . .  28
       3.10.3.  The AbstractRequestType Type . . . . . . . . . . . .  28
       3.10.4.  The AbstractResponseType Type  . . . . . . . . . . .  28
       3.10.5.  The VersionType Type . . . . . . . . . . . . . . . .  29
       3.10.6.  The IdentifierType Type  . . . . . . . . . . . . . .  29
       3.10.7.  The StatusCode Type  . . . . . . . . . . . . . . . .  29
       3.10.8.  The DeviceIdentifierDataType Type  . . . . . . . . .  32
       3.10.9.  The TokenPlatformInfoType and PlatformType Types . .  32
       3.10.10. The NonceType Type . . . . . . . . . . . . . . . . .  33
       3.10.11. The AlgorithmsType Type  . . . . . . . . . . . . . .  33
       3.10.12. The ProtocolVariantsType and the
                TwoPassSupportType Types . . . . . . . . . . . . . .  33
       3.10.13. The SecretContainersFormatTypeType . . . . . . . . .  34
       3.10.14. The AuthenticationDataType Type  . . . . . . . . . .  35
       3.10.15. The PayloadType Type . . . . . . . . . . . . . . . .  37
       3.10.16. The MacType Type . . . . . . . . . . . . . . . . . .  37
       3.10.17. The SecretContainerType Type . . . . . . . . . . . .  38
       3.10.18. The ExtensionsType and the AbstractExtensionType
                Types  . . . . . . . . . . . . . . . . . . . . . . .  38
     3.11. DSKPP Messages  . . . . . . . . . . . . . . . . . . . . .  39
       3.11.1.  Introduction . . . . . . . . . . . . . . . . . . . .  39
       3.11.2.  DSKPP Initialization (OPTIONAL)  . . . . . . . . . .  39
       3.11.3.  The DSKPP Client's Initial PDU (2- and 4-Pass) . . .  41
       3.11.4.  The DSKPP Server's Initial PDU (4-Pass Only) . . . .  44



Nystroem, et al.        Expires December 13, 2007               [Page 3]


Internet-Draft                    DSKPP                        June 2007


       3.11.5.  The DSKPP Client's Second PDU (4-Pass Only)  . . . .  46
       3.11.6.  The DSKPP Server's Final PDU (1-, 2-, and 4-Pass)  .  48
     3.12. Protocol Extensions . . . . . . . . . . . . . . . . . . .  49
       3.12.1.  The ClientInfoType Type  . . . . . . . . . . . . . .  49
       3.12.2.  The ServerInfoType Type  . . . . . . . . . . . . . .  50
       3.12.3.  The KeyInitializationDataType Type . . . . . . . . .  50
   4.  Protocol Bindings . . . . . . . . . . . . . . . . . . . . . .  52
     4.1.  General Requirements  . . . . . . . . . . . . . . . . . .  52
     4.2.  HTTP/1.1 Binding for DSKPP  . . . . . . . . . . . . . . .  52
       4.2.1.   Introduction . . . . . . . . . . . . . . . . . . . .  52
       4.2.2.   Identification of DSKPP Messages . . . . . . . . . .  52
       4.2.3.   HTTP Headers . . . . . . . . . . . . . . . . . . . .  52
       4.2.4.   HTTP Operations  . . . . . . . . . . . . . . . . . .  53
       4.2.5.   HTTP Status Codes  . . . . . . . . . . . . . . . . .  53
       4.2.6.   HTTP Authentication  . . . . . . . . . . . . . . . .  53
       4.2.7.   Initialization of DSKPP  . . . . . . . . . . . . . .  53
       4.2.8.   Example Messages . . . . . . . . . . . . . . . . . .  53
   5.  Security considerations . . . . . . . . . . . . . . . . . . .  55
     5.1.  General . . . . . . . . . . . . . . . . . . . . . . . . .  55
     5.2.  Active Attacks  . . . . . . . . . . . . . . . . . . . . .  55
       5.2.1.   Introduction . . . . . . . . . . . . . . . . . . . .  55
       5.2.2.   Message Modifications  . . . . . . . . . . . . . . .  55
       5.2.3.   Message Deletion . . . . . . . . . . . . . . . . . .  57
       5.2.4.   Message Insertion  . . . . . . . . . . . . . . . . .  57
       5.2.5.   Message Replay . . . . . . . . . . . . . . . . . . .  57
       5.2.6.   Message Reordering . . . . . . . . . . . . . . . . .  58
       5.2.7.   Man-in-the-Middle  . . . . . . . . . . . . . . . . .  58
     5.3.  Passive Attacks . . . . . . . . . . . . . . . . . . . . .  58
     5.4.  Cryptographic Attacks . . . . . . . . . . . . . . . . . .  58
     5.5.  Attacks on the Interaction between DSKPP and User
           Authentication  . . . . . . . . . . . . . . . . . . . . .  59
     5.6.  Additional Considerations Specific to 2- and 1-pass
           DSKPP . . . . . . . . . . . . . . . . . . . . . . . . . .  59
       5.6.1.   Client Contributions to K_TOKEN Entropy  . . . . . .  59
       5.6.2.   Key Confirmation . . . . . . . . . . . . . . . . . .  60
       5.6.3.   Server Authentication  . . . . . . . . . . . . . . .  60
       5.6.4.   Client Authentication  . . . . . . . . . . . . . . .  60
       5.6.5.   Key Protection in the Passphrase Profile . . . . . .  61
   6.  IANA Considerations . . . . . . . . . . . . . . . . . . . . .  62
   7.  Intellectual Property Considerations  . . . . . . . . . . . .  63
   8.  Acknowledgements  . . . . . . . . . . . . . . . . . . . . . .  64
   9.  References  . . . . . . . . . . . . . . . . . . . . . . . . .  65
     9.1.  Normative references  . . . . . . . . . . . . . . . . . .  65
     9.2.  Informative references  . . . . . . . . . . . . . . . . .  65
   Appendix A.  DSKPP Schema . . . . . . . . . . . . . . . . . . . .  67
   Appendix B.  Key Initialization Profiles of DSKPP . . . . . . . .  76
     B.1.  Introduction  . . . . . . . . . . . . . . . . . . . . . .  76
     B.2.  Key Transport Profile . . . . . . . . . . . . . . . . . .  76



Nystroem, et al.        Expires December 13, 2007               [Page 4]


Internet-Draft                    DSKPP                        June 2007


       B.2.1.   Introduction . . . . . . . . . . . . . . . . . . . .  76
       B.2.2.   Identification . . . . . . . . . . . . . . . . . . .  76
       B.2.3.   Payloads . . . . . . . . . . . . . . . . . . . . . .  76
     B.3.  Key wrap profile  . . . . . . . . . . . . . . . . . . . .  77
       B.3.1.   Introduction . . . . . . . . . . . . . . . . . . . .  77
       B.3.2.   Identification . . . . . . . . . . . . . . . . . . .  77
       B.3.3.   Payloads . . . . . . . . . . . . . . . . . . . . . .  77
     B.4.  Passphrase-based key wrap profile . . . . . . . . . . . .  79
       B.4.1.   Introduction . . . . . . . . . . . . . . . . . . . .  79
       B.4.2.   Identification . . . . . . . . . . . . . . . . . . .  79
       B.4.3.   Payloads . . . . . . . . . . . . . . . . . . . . . .  79
   Appendix C.  Example Messages . . . . . . . . . . . . . . . . . .  81
     C.1.  Example Messages in a Four-pass Exchange  . . . . . . . .  81
       C.1.1.   Example of a DSKPP Initialization (Trigger)
                Message  . . . . . . . . . . . . . . . . . . . . . .  81
       C.1.2.   Example of a <ClientHello> Message . . . . . . . . .  82
       C.1.3.   Example of a <ServerHello> Message . . . . . . . . .  83
       C.1.4.   Example of a <ClientNonce> Message . . . . . . . . .  83
       C.1.5.   Example of a <ServerFinished> Message  . . . . . . .  83
     C.2.  Example Messages in a Two- or One-pass Exchange . . . . .  84
       C.2.1.   Example of a <ClientHello> Message Indicating
                Support for Two-pass DSKPP . . . . . . . . . . . . .  84
       C.2.2.   Example of a <ServerFinished> Message Using the
                Key Transport Profile  . . . . . . . . . . . . . . .  86
       C.2.3.   Example of a <ServerFinished> Message Using the
                Key Wrap Profile . . . . . . . . . . . . . . . . . .  88
       C.2.4.   Example of a <ServerFinished> Message using the
                Passphrase-based Key Wrap Profile  . . . . . . . . .  89
   Appendix D.  Integration with PKCS #11  . . . . . . . . . . . . .  92
     D.1.  The 4-pass Variant  . . . . . . . . . . . . . . . . . . .  92
     D.2.  The 2-pass Variant  . . . . . . . . . . . . . . . . . . .  92
     D.3.  The 1-pass Variant  . . . . . . . . . . . . . . . . . . .  95
   Appendix E.  Example of DSKPP-PRF Realizations  . . . . . . . . .  98
     E.1.  Introduction  . . . . . . . . . . . . . . . . . . . . . .  98
     E.2.  DSKPP-PRF-AES . . . . . . . . . . . . . . . . . . . . . .  98
       E.2.1.   Identification . . . . . . . . . . . . . . . . . . .  98
       E.2.2.   Definition . . . . . . . . . . . . . . . . . . . . .  98
       E.2.3.   Example  . . . . . . . . . . . . . . . . . . . . . .  99
     E.3.  DSKPP-PRF-SHA256  . . . . . . . . . . . . . . . . . . . .  99
       E.3.1.   Identification . . . . . . . . . . . . . . . . . . .  99
       E.3.2.   Definition . . . . . . . . . . . . . . . . . . . . . 100
       E.3.3.   Example  . . . . . . . . . . . . . . . . . . . . . . 101
   Authors' Addresses  . . . . . . . . . . . . . . . . . . . . . . . 102
   Intellectual Property and Copyright Statements  . . . . . . . . . 103







Nystroem, et al.        Expires December 13, 2007               [Page 5]


Internet-Draft                    DSKPP                        June 2007


1.  Introduction

1.1.  Scope

   This document describes a client-server protocol for initialization
   (and configuration) of cryptographic tokens.  The protocol requires
   neither private-key capabilities in the cryptographic tokens, nor an
   established public-key infrastructure.  The objectives of this
   protocol are to:

   o     Provide a secure method of initializing cryptographic tokens
         with symmetric keys without exposing generated, secret material
         to any other entities than the server and the cryptographic
         token itself.

   o     Avoid, as much as possible, any impact on existing
         cryptographic token manufacturing processes.

   o     Provide a solution that is easy to administer and scales well.

   The mechanism is intended for general use within computer and
   communications systems employing connected cryptographic tokens (or
   software emulations thereof).

1.2.  Background

   A cryptographic token MAY be a hand-held hardware device, a hardware
   device connected to a personal computer through an electronic
   interface, such as USB, or a software module resident on a personal
   computer, which offers cryptographic functionality that MAY be used
   to authenticate a user towards some service.  Increasingly, these
   tokens work in a connected fashion, enabling their programmatic
   initialization as well as programmatic retrieval of their output
   values.  This document intends to meet the need for an open and
   inter-operable mechanism to programmatically initialize and configure
   symmetric keys to connected cryptographic tokens.

   The target mechanism addressed herein is a symmetric key provisioning
   server.  In an ideal deployment scenario, direct and near real-time
   communication is possible between the provisioning server and the
   cryptographic token.  In such an environment, it is possible for the
   cryptographic token and provisioning server to mutually generate a
   symmetric key as defined in [4]).  This is the strongest approach to
   symmetric key provisioning, as the key is not transported between
   systems, and is therefore not vulnerable to man-in-the-middle (MITM)
   attacks.

   There are, however, several deployment scenarios where direct



Nystroem, et al.        Expires December 13, 2007               [Page 6]


Internet-Draft                    DSKPP                        June 2007


   communication between the symmetric key provisioning server and the
   cryptographic token is not possible, where work-flow constraints
   otherwise would limit real-time communications (e.g. need for
   administrators to authorize processes), or where network latency or
   other design constraints (such as when initialization of tokens using
   existing keys from legacy systems is required) makes mutual key
   generation less suitable.  In these situations, the token is required
   to download and install a symmetric key from the provisioning server
   in a secure and efficient manner.

   This document tries to meet the needs of these scenarios by
   describing variations to DSKPP for the provisioning of symmetric keys
   in two round trips or less.

1.3.  Use Cases

   The applicability of DSKPP is described by the use cases in this
   section.  The next section describes the primary requirements that
   were derived from these use cases.

1.3.1.  A mobile device user obtains a symmetric key

   A user with a mobile device wants to acquire a symmetric key to use
   with a software-based cryptographic token in the device.  The
   symmetric key MAY be pre-generated by a back-end issuance server, or
   generated by the provisioning server during the provisioning process.
   A unique Secret ID is assigned to the symmetric key by the
   provisioning server.  This protocol enables the client device to
   request the symmetric key, authenticate to the provisioning server,
   download the symmetric key over-the-air (OTA), and install it on the
   mobile device.

1.3.2.  A user acquires multiple symmetric keys of different types

   A user wants to provision multiple symmetric keys on a device.  The
   symmetric keys MAY or MAY NOT be of the same type.  The keys MAY be
   used with different algorithms, such as the HMAC-Based One-Time
   Password (HOTP), RSA SecurID, symmetric challenge-response, or
   others.  The protocol MUST provide for a mechanism to uniquely
   identify a specific symmetric key in the device using token
   identification to allow device authentication before provisioning.

1.3.3.  A key provisioning service imposes a validity period policy for
        provisioning sessions

   Once a user initiates a symmetric key request, the key provisioning
   service may require that any subsequent actions to complete the
   provisioning cycle occur within a certain time window.  For example,



Nystroem, et al.        Expires December 13, 2007               [Page 7]


Internet-Draft                    DSKPP                        June 2007


   a provisioning issuer MAY provide an authentication code to a user
   upon the user's initial request for a secret key.  Such an
   authentication code is associated with a validity period; a user MUST
   consume the pick-up code to initialize or download a symmetric key
   within the validity window.

1.3.4.  A symmetric key issuer uses a third pary provisioning service
        provider

   A symmetric key issuer outsources its key provisioning to a third
   party key provisioning server provider.  The issuer is responsible
   for authenticating and granting rights to users to acquire keys while
   it may delegate the actual key generation and provisioning to a third
   party provisioning service.  The issuer may acquire symmetric keys on
   behalf of its users from the provisioning service provider or
   redirect the user to acquire the secrets directly from provisioning
   service provider.  In the latter case, it is often necessary for a
   user to authenticate to the provisioning service provider.

1.3.5.  A client application uses a pre-shared transport key to
        communicate with the provisioning service provider

   A software-based cryptographic token application is loaded onto a
   smart card after the card is issued to a user.  The symmetric key for
   the cryptographic token application will then be provisioned using a
   secure channel mechanism present in many smart card platforms.  This
   allows a direct secure channel to be established between the smart
   card chip and the provisioning server.  For example, the card
   commands (i.e., Application Protocol Data Units, or APDUs) are
   encrypted with a pre-shared transport key and sent directly to the
   smart card chip, allowing secure post-issuance in-the-field
   provisioning.  This secure flow can pass Transport Layer Security
   (TLS) and other transport security boundaries.

   Note that this use case requires DSKPP to be tunneled and the
   provisioning server to know the correct pre-established transport
   key.

1.3.6.  A user renews its symmetric key with the same key ID

   A user wants to renew its symmetric key with the same key ID.  Such a
   need may occur in the case when a user wants to upgrade its
   cryptographic token device or when a key has expired.  When a user
   uses the same cryptographic token to, for example, perform strong
   authentication at multiple Web login sites, keeping the same key ID
   removes the need for the user to register a new key ID at each site.





Nystroem, et al.        Expires December 13, 2007               [Page 8]


Internet-Draft                    DSKPP                        June 2007


1.3.7.  An administrator initiates a symmetric key replacement before it
        can be used

   This use case represents a special case of symmetric key renewal in
   which a local administrator can authenticate the user procedurally
   before initiating DSKPP.  It also allows for keys on physical
   cryptographic tokens to be issued with a restriction that the key
   MUST be replaced with a new key prior to token use.

   Bulk initialization under controlled conditions during manufacture is
   likely to meet the security needs of most applications.  However,
   reliance on a pre-disclosed secret is unacceptable in some
   circumstances.  One circumstance is when cryptographic tokens are
   issued for classified government use or high security applications.
   In such cases, the token issuer requires the ability to remove all
   secret information installed on the token during manufacture and
   replace it with secret keys established under conditions controlled
   by the issuer.  It is, however, in most cases impractical for the
   administrator to apply a physical marking to the token itself, such
   as a serial number.  It is, therefore, necessary for the enrollment
   process to communicate the token serial number to the provisioning
   service.

   Another variation of this use case is that some enterprises may
   prefer to re-provision a new secret to an existing cryptographic
   token if they decide to reuse the token that was with one user and
   for a new user.

   Note that this use case is essentially the same as the last use case
   wherein the same key ID is used for renewal.

1.3.8.  A user acquires a symmetric key through SMS

   A mobile device may support Short Message Service (SMS) but is not
   able to support a data service allowing for HTTP or HTTPS transports.
   In such a case, the user may initiate a symmetric key request from a
   desktop computer and ask the server to send the key to a mobile phone
   through SMS.  The online communication between the desktop computer
   and the server can carry out user authentication.

1.3.9.  A client acquires a symmetric key over a transport protocol that
        does not ensure data confidentiality

   Some devices are not able to support a secure transport channel such
   as TLS to provide data confidentiality.  A user wants to provision a
   symmetric key to such a device.  It is up to DSKPP to ensure data
   confidentiality over non-secure networks.




Nystroem, et al.        Expires December 13, 2007               [Page 9]


Internet-Draft                    DSKPP                        June 2007


1.3.10.  A client acquires a symmetric key over a transport protocol
         that does not provide authentication

   Some devices are not able to use a transport protocol that provides
   server authentication such as TLS.  A user wants to be sure that it
   acquires a symmetric key from an authentic provisioning service
   provider.  It is up to DSKPP to provide proper client and server
   authentication.

1.4.  Requirements

   This section specifies mandatory and desirable protocol requirements.

1.4.1.  Mandatory Requirements

   R1:   The protocol SHOULD support multiple types of keys for
         symmetric key-based authentication methods.

   R2:   The protocol SHOULD support re-generated symmetric keys (by
         separate key issuance service) or locally generated keys in
         real-time (by provisioning server).

   R3:   The protocol SHOULD support mutually generated symmetric keys
         by both client and server.

   R4:   The protocol SHOULD allow devices to host multiple symmetric
         keys; each key MAY be acquired in a separate provisioning
         session.

   R5:   The protocol SHOULD support renewal of a symmetric key with the
         same key ID.

   R6:   The protocol SHOULD allow clients to specify their
         cryptographic and security capabilities to the server and the
         server to indicate the cryptography and algorithm types that it
         will be using.

   R7:   The protocol SHOULD support mutual authentication and
         confidentiality of sensitive provisioning data

   R8:   The protocol SHOULD NOT require a public-key infrastructure and
         the use of client certificates for device authentication or
         symmetric key data protection.  It MUST allow for other
         mechanisms, such as symmetric key-based techniques, to be used.







Nystroem, et al.        Expires December 13, 2007              [Page 10]


Internet-Draft                    DSKPP                        June 2007


   R9:   The protocol SHOULD NOT rely on transport layer security (e.g.,
         SSL/TLS) for core security requirements.  It SHOULD be
         compatible with transport layer security when available.

   R10:  The protocol SHOULD allow for the transport of the symmetric
         key expiration date set by the key issuer.

   R11:  The protocol SHOULD allow the server to use pre-loaded
         symmetric transport keys on a device-by-device basis (i.e.,
         smart card update keys, such as used by Global Platform for
         establishing a secure channel).

   R12:  The protocol SHOULD enable simple user experience for the
         provisioning process.

   R13:  The protocol SHOULD protect against replay attacks.

   R14:  The protocol SHOULD protect against MITM attacks.

1.4.2.  Desirable Requirements

   D1:   The protocol MAY support a device request to acquire multiple
         symmetric keys in the same session.

   D2:   The protocol MAY allow the provisioning server to verify that
         the key has been correctly provisioned to the client.

   D3:   The protocol MAY support a client to notify the server upon
         symmetric key deletion.

1.5.  Non-Goals

   The following is a list of features that are not required of the
   protocol:

   NR1:  Support for client generated symmetric key upload to a
         provisioning server.

   NR2:  Support for other key lifecycle management functions, such as
         key suspension, lock, and activation.  These functions are
         supported in symmetric key-based application, such as the
         authentication system.

   NR3:  Support for asymmetric key pair provisioning.







Nystroem, et al.        Expires December 13, 2007              [Page 11]


Internet-Draft                    DSKPP                        June 2007


1.6.  Document organization

   The organization of this document is as follows:

   o  Section 1 is an introduction.

   o  Section 2 defines acronyms and notation used in this document.

   o  Section 3 defines the protocol mechanism in detail.

   o  Section 4 defines a binding of the protocol to the transport
      layer.

   o  Section 5 discusses security considerations.

   o  Appendix A defines the XML schema for the protocol mechanism.

   o  Appendix B contains key initialization profiles for the 1- and
      2-pass versions of DSKPP defined herein.

   o  Appendix C provides example messages.

   o  Appendix D discusses integration with PKCS #11 [5].

   o  Appendix E provides example realizations of an abstract
      pseudorandom function defined in Section 3.6.

























Nystroem, et al.        Expires December 13, 2007              [Page 12]


Internet-Draft                    DSKPP                        June 2007


2.  Acronyms and Notation

2.1.  Acronyms

   DSKPP     Dynamic Symmetric Key Provisioning Protocol

   HMAC      Hashing for Message Authentication

   HOTP      HMAC-Based One-Time Password

   MAC       Message Authentication Code

   MITM      Man-in-the-Middle

   OTP       One-Time Password

   PDU       Protocol Data Unit

   PRF       Pseudo-Random Function

   PSKC      Portable Symmetric Key Container

   SOAP      Simple Object Access Protocol

   TLS       Transport Layer Security

   XML       Extensible Markup Language

2.2.  Notation and Terminology

   The following notations are used in this document:

   ||        String concatenation

   [x]       Optional element x

   A ^ B     Exclusive-OR operation on strings A and B (where A and B
             are of equal length)

   ID_C      Identifier for DSKPP client

   ID_S      Identifier for DSKPP server

   K         Key used to encrypt R_C (either K_SERVER or K_SHARED)







Nystroem, et al.        Expires December 13, 2007              [Page 13]


Internet-Draft                    DSKPP                        June 2007


   K_AUTH    Secret key used for authentication purposes in 4-pass DSKPP

   K_CLIENT  Public key of the cryptographic token

   K_DERIVED Secret key derived from a passphrase that is known to both
             the cryptographic token or user and the DSKPP server

   K_MAC     Secret key used for key confirmation and authentication
             purposes, generated in DSKPP

   K_SERVER  Public key of the DSKPP server

   K_SHARED  Secret key shared between the cryptographic token and the
             DSKPP server

   K_TOKEN   Secret key used for token computations, generated in DSKPP

   R         Pseudorandom value chosen by the cryptographic token and
             used for MAC computations

   R_C       Pseudorandom value chosen by the cryptographic token

   R_S       Pseudorandom value chosen by the DSKPP server

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
   document are to be interpreted as described in [6].

   The following typographical convention is used in the body of the
   text: <XMLElement>.

2.3.  XML Namespaces

   The target XML namespace for data types defined in this document is
   as follows:

      xmlns:dskpp="urn:ietf:params:xml:ns:keyprov:protocol"

   The protocol also relies on the following namespace for XML types
   defined in [7]:

      xmlns:pskc="urn:ietf:params:xml:ns:keyprov:container"

   It also uses the following namespace for data types defined in [1]:

      xmlns:ds="http://www.w3.org/2000/09/xmldsig#"





Nystroem, et al.        Expires December 13, 2007              [Page 14]


Internet-Draft                    DSKPP                        June 2007


3.  DSKPP

3.1.  Overview

   The DSKPP is a client-server protocol for the secure initialization
   and configuration of cryptographic tokens.  The protocol is meant to
   provide high assurance for both the provisioning server and the
   client (i.e., the cryptographic token) that generated keys have been
   correctly and randomly generated and not exposed to other entities.
   The protocol does not require the existence of a public-key
   infrastructure.

3.2.  Entities

   In principle, the protocol involves a DSKPP client and a DSKPP
   server.

   It is assumed that a desktop/laptop or a wireless device (e.g., a
   mobile phone or a PDA) will host an application communicating with
   the DSKPP server as well as the cryptographic token, and
   collectively, the cryptographic token and the communicating
   application form the DSKPP client.  When there is a need to point out
   if an action is to be performed by the communicating application or
   by the token, the text will make this explicit.

   The manner in which the communicating application will transfer DSKPP
   protocol elements to and from the cryptographic token is transparent
   to the DSKPP server.  One method for this transfer is described in
   [8].

3.3.  Principles of Operation

   To initiate a DSKPP session, a user MAY use a browser to connect to a
   web server (or service) running on some host.  The user MAY then
   identify and OPTIONALLY authenticate herself and possibly indicate
   how the DSKPP client SHALL contact the DSKPP server.  There are also
   other alternatives for DSKPP session initiation, such as the DSKPP
   client being pre-configured to contact a certain DSKPP server, or the
   user being informed out-of-band about the location of the DSKPP
   server.  In any event, once the location of the DSKPP server is
   known, the DSKPP client and the DSKPP server engage in a 4-pass,
   2-pass, or 1-pass protocol, depending upon the deployment scenario.

3.3.1.  Four-pass DSKPP

   The 4-pass protocol flow is suitable for environments wherein there
   is a direct and near real-time communication possible between the
   DSKPP client and DSKPP server.  It is not suitable for environments



Nystroem, et al.        Expires December 13, 2007              [Page 15]


Internet-Draft                    DSKPP                        June 2007


   wherein administrative approval is a required step in the flow, nor
   for provisioning of legacy keys.  The 4-pass protocol flow, shown in
   Figure 1 and expanded in Figure 2, consists of two round-trips
   between the DSKPP client and server.

   +---------------+                            +---------------+
   |               |                            |               |
   |  DSKPP client |                            |  DSKPP server |
   |               |                            |               |
   +---------------+                            +---------------+
           |                                            |
           |        [ <---- DSKPP trigger ----- ]       |
           |                                            |
           |        ------- Client Hello ------->       |
           |                                            |
           |        <------ Server Hello --------       |
           |                                            |
           |        ------- Client Nonce ------->       |
           |                                            |
           |        <----- Server Finished ------       |
           |                                            |
   Figure 1: The 4-pass DSKPP protocol (with OPTIONAL preceding trigger)

   a.    The DSKPP client sends a <ClientHello> message to the DSKPP
         server.  The contents of the message provide information to the
         DSKPP server about the cryptographic token's identity,
         supported DSKPP versions, cryptographic algorithms supported by
         the token and key types that MAY be generated using this
         protocol, and encryption and MAC algorithms supported by the
         cryptographic token for the purposes of this protocol.

   b.    The DSKPP server responds to the DSKPP client with a
         <ServerHello> message, whose content includes a random nonce,
         R_S, along with information about the type of key to generate,
         and the encryption algorithm chosen to protect sensitive data
         sent in the protocol.  In addition, the <ServerHello> message
         provides either information about a shared secret key to use
         for encrypting the cryptographic token's random nonce (see
         below), or its own public key.  The length of the nonce R_S MAY
         depend on the selected key type.

   c.    Based on information contained in the <ServerHello> message,
         the cryptographic token generates a random nonce, R_C, and
         encrypts it using the selected encryption algorithm and with a
         key, K, that is either the DSKPP server's public key, K_SERVER,
         or a shared secret key, K_SHARED, as indicated by the DSKPP
         server.  The length of the nonce R_C MAY depend on the selected
         key type.  The DSKPP client then sends the encrypted random



Nystroem, et al.        Expires December 13, 2007              [Page 16]


Internet-Draft                    DSKPP                        June 2007


         nonce to the DSKPP server in a <ClientNonce> message.  The
         token also calculates a cryptographic key, K_TOKEN, of the
         selected type from the combination of the two random nonces R_S
         and R_C, the encryption key K, and possibly some other data,
         using the DSKPP-PRF function defined herein.

   d.    The DSKPP server decrypts R_C, calculates K_TOKEN from the
         combination of the two random nonces R_S and R_C, the
         encryption key K, and possibly some other data, using the
         DSKPP-PRF function defined herein.  The server then associates
         K_TOKEN with the cryptographic token in a server-side data
         store.  The intent is that the data store later on will be used
         by some service that needs to verify or decrypt data produced
         by the cryptographic token and the key.

   e.    Once the association has been made, the DSKPP server sends a
         confirmation message to the DSKPP client called
         <ServerFinished>.  The confirmation message includes an
         identifier for the generated key and MAY also contain
         additional configuration information, e.g., the identity of the
         DSKPP server.

   f.    Upon receipt of the DSKPP server's confirmation message, the
         cryptographic token associates the provided key identifier with
         the generated key K_TOKEN, and stores the provided
         configuration data, if any.

   Note: Conceptually, although R_C is one pseudorandom string, it MAY
   be viewed as consisting of two components, R_C1 and R_C2, where R_C1
   is generated during the protocol run, and R_C2 can be generated at
   the cryptographic token manufacturing time and stored in the
   cryptographic token.  In that case, the latter string, R_C2, SHOULD
   be unique for each cryptographic token for a given manufacturer.

   The inclusion of the two random nonces R_S and R_C in the key
   generation provides assurance to both sides (the token and the DSKPP
   server) that they have contributed to the key's randomness and that
   the key is unique.  The inclusion of the encryption key K ensures
   that no man-in-the-middle MAY be present, or else the cryptographic
   token will end up with a key different from the one stored by the
   legitimate DSKPP server.

   Note: A man-in-the-middle (in the form of corrupt client software or
   a mistakenly contacted server) MAY present his own public key to the
   token.  This will enable the attacker to learn the client's version
   of K_TOKEN.  However, the attacker is not able to persuade the
   legitimate server to derive the same value for K_TOKEN, since K_TOKEN
   is a function of the public key involved, and the attacker's public



Nystroem, et al.        Expires December 13, 2007              [Page 17]


Internet-Draft                    DSKPP                        June 2007


   key must be different than the correct server's (or else the attacker
   would not be able to decrypt the information received from the
   client).  Therefore, once the attacker is no longer "in the middle,"
   the client and server will detect that they are "out of synch" when
   they try to use their keys.  In the case of encrypting R_C with
   K_SERVER, it is therefore important to verify that K_SERVER really is
   the legitimate server's key.  One way to do this is to independently
   validate a newly generated K_TOKEN against some validation service at
   the server (e.g. by using a connection independent from the one used
   for the key generation).

   +----------------------+    +-------+     +----------------------+
   |    +------------+    |    |       |     |                      |
   |    | Server key |    |    |       |     |                      |
   | +<-|  Public    |------>------------->-------------+---------+ |
   | |  |  Private   |    |    |       |     |          |         | |
   | |  +------------+    |    |       |     |          |         | |
   | |        |           |    |       |     |          |         | |
   | V        V           |    |       |     |          V         V |
   | |   +---------+      |    |       |     |        +---------+ | |
   | |   | Decrypt |<-------<-------------<-----------| Encrypt | | |
   | |   +---------+      |    |       |     |        +---------+ | |
   | |      |  +--------+ |    |       |     |            ^       | |
   | |      |  | Server | |    |       |     |            |       | |
   | |      |  | Random |--->------------->------+  +----------+  | |
   | |      |  +--------+ |    |       |     |   |  | Client   |  | |
   | |      |      |      |    |       |     |   |  | Random   |  | |
   | |      |      |      |    |       |     |   |  +----------+  | |
   | |      |      |      |    |       |     |   |        |       | |
   | |      V      V      |    |       |     |   V        V       | |
   | |   +------------+   |    |       |     | +------------+     | |
   | +-->|  DSKPP PRF |   |    |       |     | |  DSKPP PRF |<----+ |
   |     +------------+   |    |       |     | +------------+       |
   |           |          |    |       |     |       |              |
   |           V          |    |       |     |       V              |
   |       +-------+      |    |       |     |   +-------+          |
   |       |  Key  |      |    |       |     |   |  Key  |          |
   |       +-------+      |    |       |     |   +-------+          |
   |       +-------+      |    |       |     |   +-------+          |
   |       |Key Id |-------->------------->------|Key Id |          |
   |       +-------+      |    |       |     |   +-------+          |
   +----------------------+    +-------+     +----------------------+
         DSKPP Server         DSKPP Client     DSKPP Client (Token)
                               (PC Host)
   Figure 2: Principal data flow for DSKPP key generation - using public
   server key





Nystroem, et al.        Expires December 13, 2007              [Page 18]


Internet-Draft                    DSKPP                        June 2007


3.3.2.  Two-pass DSKPP

   In two-pass DSKPP, the client's initial <ClientHello> message is
   directly followed by a <ServerFinished> message.  There is no
   exchange of the <ServerHello> message or the <ClientNonce> message.
   Essentially, two-pass DSKPP is a transport of key material from the
   DSKPP server to the DSKPP client.  However, as the two-pass variant
   of DSKPP consists of one round trip to the server, the client is
   still able to specify algorithm preferences and supported key types
   in the <ClientHello> message.  Note that the DSKPP "trigger" message
   MAY be used to trigger the client's sending of the <ClientHello>
   message.

   +---------------+                            +---------------+
   |               |                            |               |
   |  DSKPP client |                            |  DSKPP server |
   |               |                            |               |
   +---------------+                            +---------------+
           |                                            |
           |        [ <---- DSKPP trigger ----- ]       |
           |                                            |
           |        ------- Client Hello ------->       |
           |                                            |
           |        <----- Server Finished ------       |
           |                                            |
   Figure 1: The 2-pass DSKPP protocol (with OPTIONAL preceding trigger)

3.3.3.  One-pass DSKPP

   In one-pass DSKPP, the server simply sends a <ServerFinished> message
   to the DSKPP client.  In this case, there is no exchange of the
   <ClientHello>, <ServerHello>, and <ClientNonce> DSKPP messages, and
   hence there is no way for the client to express supported algorithms
   or key types.  Before attempting one-pass DSKPP, the server MUST
   therefore have prior knowledge not only that the client is able and
   willing to accept this variant of DSKPP, but also of algorithms and
   key types supported by the client.














Nystroem, et al.        Expires December 13, 2007              [Page 19]


Internet-Draft                    DSKPP                        June 2007


   +---------------+                            +---------------+
   |               |                            |               |
   |  DSKPP client |                            |  DSKPP server |
   |               |                            |               |
   +---------------+                            +---------------+
           |                                            |
           |        <----- Server Finished ------       |
           |                                            |
   Figure 1: The 1-pass DSKPP protocol

   Outside the specific cases where one-pass DSKPP is desired, clients
   SHOULD be constructed and configured to only accept DSKPP server
   messages in response to client-initiated transactions.

3.4.  Authentication

3.4.1.  Client Authentication

   To ensure that a generated K_TOKEN ends up associated with the
   correct token and user, the DSKPP server MAY couple an initial user
   authentication to the DSKPP execution in several ways, as discussed
   in the following sub-sections.  Whatever the method, the DSKPP server
   MUST ensure that a generated key is associated with the correct
   token, and if applicable, the correct user.  For a further discussion
   of this, and threats related to man-in-the-middle attacks in this
   context, see Section 5.

3.4.1.1.  Device Certificate

   Instead of requiring an Authentication Code for in-band
   authentication, a device certificate could be used, which was
   supplied with the cryptographic token by its issuer.

3.4.1.2.  Device Identifier

   The provisioning server could be pre-configured with a device
   identifier.  The DSKPP server MAY then include this token identifier
   in the DSKPP initialization trigger, and the DSKPP client would
   include it in its message(s) to the DSKPP server for authentication.
   Note that it is also legitimate for a DSKPP client to initiate the
   DSKPP protocol run without having received an initialization message
   from a server, but in this case any provided device identifier SHALL
   NOT be accepted by the DSKPP server unless the server has access to a
   unique key for the identified device and that key will be used in the
   protocol.






Nystroem, et al.        Expires December 13, 2007              [Page 20]


Internet-Draft                    DSKPP                        June 2007


3.4.1.3.  One-time Use Authentication Code

   A token issuer MAY provide a one-time value, called an Authentication
   Code, to the user or device out-of-band and require this value to be
   used by the DSKPP client when contacting the DSKPP server.  The DSKPP
   client includes the authentication data in its request message, and
   the DSKPP server MUST verify the data before continuing with the
   protocol run.  Note: An alternate method for getting the
   Authentication Code to the client, is for the DSKPP server to place
   the value in the <TriggerNonce> element of the DSKPP initialization
   trigger (if triggers are used; see Section 4.2.7) .

   +------------+  Get Authentication Code  +------------+
   |    User    |<------------------------->|   Issuer   |
   +------------+                           +------------+
          |                                        |
          |                                        |
          |                                        |
          V                                        V
   +--------------+                        +--------------+
   | Provisioning |   Authentication Data  | Provisioning |
   |    Client    |----------------------->|    Server    |
   +--------------+                        +--------------+

   Figure 3: User Authentication with One-Time Code

   Considering an Authentication Code as a special form of shared secret
   between a user and a provisioning server, Authentication Data can
   have one of the following forms:

   o  AuthenticationData = Hash (Authentication Code)

      When an Authentication Code is used to initiate the protocol run,
      the Authentication Code MUST be sent to the DSKPP server in a
      secure manner.  If the underlying transport channel is secure, the
      authentication data MAY contain the plaintext format or the hashed
      format of the Authentication Code using a hash function.

   o  AuthenticationData = HMAC (Authentication Code, R_S)

      If the underlying transport is not secure, the client MUST use
      both the server nonce R_S and the Authentication Code to derive
      authentication data.

   o  AuthenticationData = <Signed data with a client certificate>






Nystroem, et al.        Expires December 13, 2007              [Page 21]


Internet-Draft                    DSKPP                        June 2007


      When a certificate is used for authentication, the authentication
      data MAY be client-signed.  Authentication data MAY be omitted if
      client certificate authentication has been provided by the
      transport channel such as TLS.

   When a token issuer delegates symmetric key provisioning to a third
   party provisioning service provider, both client authentication and
   issuer authentication are required by the provisioning server.
   Client authentication to the Issuer MAY be in-band or out-of-band as
   described above.  The issuer acts as a proxy for the provisioning
   server.  The issuer authenticates to the provisioning service
   provider either using a certificate or a pre-established secret key.

3.4.2.  Server Authentication

   A DSKPP server MUST authenticate itself to avoid a false "Commit" of
   a symmetric key that which could cause the cryptographic token to end
   up in an initialized state for which the server does not know the
   stored key.  To do this, the DSKPP server authenticates itself by
   including a MAC in each of its responses to the client.  In 2-pass
   and 1-pass DSKPP, servers authenticate themselves by including a
   second MAC value in the response message.  In addition, a DSKPP
   server can leverage transport layer authentication if it is
   available.

3.5.  Symmetric Key Container Format

   The default symmetric key container format that is used in the
   <ServerFinished> message is based on the Portable Symmetric Key
   Container (PSKC) defined in [7].  Alternative formats MAY include
   PKCS#12 [9] or PKCS#5 XML [10] format.

3.6.  The DSKPP One-Way Pseudorandom Function, DSKPP-PRF

3.6.1.  Introduction

   The general requirements on DSKPP-PRF are the same as on keyed hash
   functions: It SHALL take an arbitrary length input, and be one-way
   and collision-free (for a definition of these terms, see, e.g.,
   [11]).  Further, the DSKPP-PRF function SHALL be capable of
   generating a variable-length output, and its output SHALL be
   unpredictable even if other outputs for the same key are known.

   It is assumed that any realization of DSKPP-PRF takes three input
   parameters: A secret key k, some combination of variable data, and
   the desired length of the output.  The combination of variable data
   can, without loss of generalization, be considered as a salt value
   (see PKCS#5 Version 2.0 [12], Section 4), and this characterization



Nystroem, et al.        Expires December 13, 2007              [Page 22]


Internet-Draft                    DSKPP                        June 2007


   of DSKPP-PRF SHOULD fit all actual PRF algorithms implemented by
   tokens.  From the point of view of this specification, DSKPP-PRF is a
   "black-box" function that, given the inputs, generates a pseudorandom
   value.

   Separate specifications MAY define the implementation of DSKPP-PRF
   for various types of cryptographic tokens.  Appendix E contains two
   example realizations of DSKPP-PRF.

3.6.2.  Declaration

   DSKPP-PRF (k, s, dsLen)

   Input:

   k     secret key in octet string format

   s     octet string of varying length consisting of variable data
         distinguishing the particular string being derived

   dsLen desired length of the output

   Output:

   DS    pseudorandom string, dsLen-octets long

   For the purposes of this document, the secret key k SHALL be 16
   octets long.

3.7.  Generation of Symmetric Keys for Cryptographic Tokens

   In DSKPP, keys are generated using the DSKPP-PRF function, a secret
   random value R_C chosen by the DSKPP client, a random value R_S
   chosen by the DSKPP server, and the key k used to encrypt R_C. The
   input parameter s of DSKPP-PRF is set to the concatenation of the
   (ASCII) string "Key generation", k, and R_S, and the input parameter
   dsLen is set to the desired length of the key, K_TOKEN (the length of
   K_TOKEN is given by the key's type):

   dsLen = (desired length of K_TOKEN)

   K_TOKEN = DSKPP-PRF (R_C, "Key generation" || k || R_S, dsLen)

   When computing K_TOKEN above, the output of DSKPP-PRF MAY be subject
   to an algorithm-dependent transform before being adopted as a key of
   the selected type.  One example of this is the need for parity in DES
   keys.




Nystroem, et al.        Expires December 13, 2007              [Page 23]


Internet-Draft                    DSKPP                        June 2007


3.8.  Encryption of Pseudorandom Nonces Sent from the DSKPP Client

   DSKPP client random nonce(s) are either encrypted with the public key
   provided by the DSKPP server or by a shared secret key.  For example,
   in the case of a public RSA key, an RSA encryption scheme from PKCS
   #1 [13] MAY be used.

   In the case of a shared secret key, to avoid dependence on other
   algorithms, the DSKPP client MAY use the DSKPP-PRF function described
   herein with the shared secret key K_SHARED as input parameter k (in
   this case, K_SHARED SHOULD be used solely for this purpose), the
   concatenation of the (ASCII) string "Encryption" and the server's
   nonce R_S as input parameter s, and dsLen set to the length of R_C:

   dsLen = len(R_C)

   DS = DSKPP-PRF(K_SHARED, "Encryption" || R_S, dsLen)

   This will produce a pseudorandom string DS of length equal to R_C.
   Encryption of R_C MAY then be achieved by XOR-ing DS with R_C:

   Enc-R_C = DS ^ R_C

   The DSKPP server will then perform the reverse operation to extract
   R_C from Enc-R_C.

   Note: It may appear that an attacker, who learns a previous value of
   R_C, may be able to replay the corresponding R_S and, hence, learn a
   new R_C as well.  However, this attack is mitigated by the
   requirement for a server to show knowledge of K_AUTH (see below) in
   order to successfully complete a key re-generation.

3.9.  MAC calculations

3.9.1.  Four-pass DSKPP

3.9.1.1.  Server Authentication: <ServerHello>

   The MAC value SHALL be computed on the (ASCII) string "MAC 1
   computation", the client's nonce R (if sent), and the server's nonce
   R_S using an authentication key K_AUTH that SHOULD be a special
   authentication key used only for this purpose but MAY be the current
   K_TOKEN.

   The MAC value MAY be computed by using the DSKPP-PRF function of
   Section 3.6, in which case the input parameter s SHALL be set to the
   concatenation of the (ASCII) string "MAC 1 computation", R (if sent
   by the client), and R_S, and k SHALL be set to K_AUTH.  The input



Nystroem, et al.        Expires December 13, 2007              [Page 24]


Internet-Draft                    DSKPP                        June 2007


   parameter dsLen SHALL be set to the length of R_S:

   dsLen = len(R_S)

   MAC = DSKPP-PRF (K_AUTH, "MAC 1 computation" || [R ||] R_S, dsLen)

3.9.1.2.  Server Authentication: <ServerFinished>

   The MAC value SHALL be computed on the (ASCII) string "MAC 2
   computation" and R_C using an authentication key K_AUTH.  Again, this
   SHOULD be a special authentication key used only for this purpose,
   but MAY also be an existing K_TOKEN.  (In this case, implementations
   MUST protect against attacks where K_TOKEN is used to pre-compute MAC
   values.)  If no authentication key is present in the token, and no
   K_TOKEN existed before the DSKPP run, K_AUTH SHALL be the newly
   generated K_TOKEN.

   If DSKPP-PRF is used as the MAC algorithm, then the input parameter s
   SHALL be consist of the concatenation of the (ASCII) string "MAC 2
   computation", R_C, the parameter dsLen SHALL be set to the length of
   R_C:

   dsLen = len(R_C)

   MAC = DSKPP-PRF (K_AUTH, "MAC 2 computation" || R_C, dsLen)

3.9.2.  Two-pass DSKPP

3.9.2.1.  Key Confirmation

   In two-pass DSKPP, the client is REQUIRED to include a nonce R in the
   <ClientHello> message.  Further, the server is REQUIRED to include an
   identifier, ID_S, for itself (in the <ServerID> element) in the
   <ServerFinished> message.  The MAC value in the <ServerFinished>
   message SHALL be computed on the (ASCII) string "MAC 1 computation",
   the server identifier ID_S, and R using a MAC key K_MAC.  Again, in
   contrast with the MAC calculation in the four-pass DSKPP, this key
   SHALL be provided together with K_TOKEN to the token, and hence there
   is no need for a K_AUTH for key confirmation purposes.

   If DSKPP-PRF is used as the MAC algorithm, then the input parameter s
   SHALL consist of the concatenation of the (ASCII) string "MAC 1
   computation" and R, and the parameter dsLen SHALL be set to the
   length of R:

   dsLen = len(R)

   MAC = DSKPP-PRF (K_MAC, "MAC 1 computation" || ID_S || R, dsLen)



Nystroem, et al.        Expires December 13, 2007              [Page 25]


Internet-Draft                    DSKPP                        June 2007


3.9.2.2.  Server Authentication

   As discussed in Section 3.4.2, servers need to authenticate
   themselves when attempting to replace an existing K_TOKEN.  In 2-pass
   DSKPP, servers authenticate themselves by including a second MAC
   value in the AuthenticationDataType extension.  The MAC value in the
   AuthenticationDataType extension SHALL be computed on the (ASCII)
   string "MAC 1 computation", the server identifier ID_S, and R, using
   the existing MAC key K_MAC' (the MAC key that existed before this
   protocol run).  The MAC algorithm SHALL be the same as the algorithm
   used for key confirmation purposes.

   If DSKPP-PRF is used as the MAC algorithm, then the input parameter s
   SHALL consist of the concatenation of the (ASCII) string "MAC 1
   computation" ID_S, and R. The parameter dsLen SHALL be set to at
   least 16 (i.e. the length of the MAC SHALL be at least 16 octets):

   dsLen >= 16

   MAC = DSKPP-PRF (K_MAC', "MAC 1 computation" || ID_S || R, dsLen)

3.9.3.  One-pass DSKPP

3.9.3.1.  Key Confirmation

   In one-pass DSKPP, the server is REQUIRED to include an identifier,
   ID_S, for itself (in the <ServerID> element) in the <ServerFinished>
   message.  The MAC value in the <ServerFinished> message SHALL be
   computed on the (ASCII) string "MAC 1 computation", the server
   identifier ID_S, and an unsigned integer value I, using a MAC key
   K_MAC.  The value I MUST be monotonically increasing and guaranteed
   not to be used again by this server towards this token.  It could for
   example be the number of seconds since some point in time with
   sufficient granularity, a counter value, or a combination of the two
   where the counter value is reset for each new time value.  In
   contrast to the MAC calculation in four-pass DSKPP, the MAC key K_MAC
   SHALL be provided together with K_TOKEN to the token, and hence there
   is no need for a K_AUTH for key confirmation purposes.

   Note: The integer I does not necessarily need to be maintained per
   token by the DSKPP server (it is enough if the server can guarantee
   that the same value is never being sent twice to the same token).

   If DSKPP-PRF is used as the MAC algorithm, then the input parameter s
   SHALL consist of the concatenation of the (ASCII) string "MAC 1
   computation", ID_S, and I. The parameter dsLen SHALL be set to at
   least 16 (i.e. the length of the MAC SHALL be at least 16 octets):




Nystroem, et al.        Expires December 13, 2007              [Page 26]


Internet-Draft                    DSKPP                        June 2007


   dsLen >= 16

   MAC = DSKPP-PRF (K_MAC, "MAC 1 computation" || ID_S || I, dsLen)

   The server SHALL provide I to the client in the Nonce attribute of
   the <Mac> element of the <ServerFinished> message using the
   AuthenticationCodeMacType defined in Section 3.10.14.

3.9.3.2.  Server Authentication

   As discussed in Section 3.4.2, servers need to authenticate
   themselves when attempting to replace an existing K_TOKEN.  In 1-pass
   DSKPP, servers authenticate themselves by including a second MAC
   value in the AuthenticationDataType extension.  The MAC value in the
   AuthenticationDataType extension SHALL be computed on the (ASCII)
   string "MAC 1 computation", the server identifier ID_S, and a new
   value I', I' > I, using the existing MAC key K_MAC' (the MAC key that
   existed before this protocol run).  The MAC algorithm SHALL be the
   same as the algorithm used for key confirmation purposes.

   If DSKPP-PRF is used as the MAC algorithm, then the input parameter s
   SHALL consist of the concatenation of the (ASCII) string "MAC 1
   computation" ID_S, and I'.  The parameter dsLen SHALL be set to at
   least 16 (i.e. the length of the MAC SHALL be at least 16 octets):

   dsLen >= 16

   MAC = DSKPP-PRF (K_MAC', "MAC 1 computation" || ID_S || I', dsLen)

   The server SHALL provide I' to the client in the Nonce attribute of
   the <Mac> element of the AuthenticationDataType extension.  If the
   protocol run is successful, the client stores I' as the new value of
   I for this server.

3.10.  DSKPP Schema Basics

3.10.1.  Introduction

   Core parts of the XML schema for DSKPP, found in Appendix A, are
   explained in this section.  Specific protocol message elements are
   defined in Section 3.11.  Examples can be found in Appendix C.

   The XML format for DSKPP messages have been designed to be
   extensible.  However, it is possible that the use of extensions will
   harm interoperability; therefore, any use of extensions SHOULD be
   carefully considered.  For example, if a particular implementation
   relies on the presence of a proprietary extension, then it may not be
   able to interoperate with independent implementations that have no



Nystroem, et al.        Expires December 13, 2007              [Page 27]


Internet-Draft                    DSKPP                        June 2007


   knowledge of this extension.

   XML types defined in this sub-section are not DSKPP messages; rather
   they provide building blocks that are used by DSKPP messages.

3.10.2.  General XML Schema Requirements

   Some DSKPP elements rely on the parties being able to compare
   received values with stored values.  Unless otherwise noted, all
   elements in this document that have the XML Schema "xs:string" type,
   or a type derived from it, MUST be compared using an exact binary
   comparison.  In particular, DSKPP implementations MUST NOT depend on
   case-insensitive string comparisons, normalization or trimming of
   white space, or conversion of locale-specific formats such as
   numbers.

   Implementations that compare values that are represented using
   different character encodings MUST use a comparison method that
   returns the same result as converting both values to the Unicode
   character encoding, Normalization Form C [2], and then performing an
   exact binary comparison.

   No collation or sorting order for attributes or element values is
   defined.  Therefore, DSKPP implementations MUST NOT depend on
   specific sorting orders for values.

3.10.3.  The AbstractRequestType Type

   All DSKPP requests are defined as extensions to the abstract
   AbstractRequestType type.  The elements of the AbstractRequestType,
   therefore, apply to all DSKPP requests.  All DSKPP requests MUST
   contain a Version attribute.  For this version of this specification,
   Version SHALL be set to "1.0".

   <xs:complexType name="AbstractRequestType" abstract="true">
     <xs:attribute name="Version" type="VersionType" use="required"/>
   </xs:complexType>

3.10.4.  The AbstractResponseType Type

   All DSKPP responses are defined as extensions to the abstract
   AbstractResponseType type.  The elements of the AbstractResponseType,
   therefore, apply to all DSKPP responses.  All DSKPP responses contain
   a Version attribute indicating the version that was used.  A Status
   attribute, which indicates whether the preceding request was
   successful or not MUST also be present.  Finally, all responses MAY
   contain a SessionID attribute identifying the particular DSKPP
   session.  The SessionID attribute needs only be present if more than



Nystroem, et al.        Expires December 13, 2007              [Page 28]


Internet-Draft                    DSKPP                        June 2007


   one roundtrip is REQUIRED for a successful protocol run (this is the
   case with the protocol version described herein).

   <xs:complexType name="AbstractResponseType" abstract="true">
     <xs:attribute name="Version" type="VersionType" use="required"/>
     <xs:attribute name="SessionID" type="IdentifierType"/>
     <xs:attribute name="Status" type="StatusCode" use="required"/>
   </xs:complexType>

3.10.5.  The VersionType Type

   The VersionType type is used within DSKPP messages to identify the
   highest version of this protocol supported by the DSKPP client and
   server.

   <xs:simpleType name="VersionType">
     <xs:restriction base="xs:string">
       <xs:pattern value="\d{1,2}\.\d{1,3}"/>
     </xs:restriction>
   </xs:simpleType>

3.10.6.  The IdentifierType Type

   The IdentifierType type is used to identify various DSKPP elements,
   such as sessions, users, and services.  Identifiers MUST NOT be
   longer than 128 octets.

   <xs:simpleType name="IdentifierType">
     <xs:restriction base="xs:string">
       <xs:maxLength value="128"/>
     </xs:restriction>
   </xs:simpleType>

3.10.7.  The StatusCode Type

   The StatusCode type enumerates all possible return codes:















Nystroem, et al.        Expires December 13, 2007              [Page 29]


Internet-Draft                    DSKPP                        June 2007


   <xs:simpleType name="StatusCode">
     <xs:restriction base="xs:string">
       <xs:enumeration value="Continue"/>
       <xs:enumeration value="Success"/>
       <xs:enumeration value="Abort"/>
       <xs:enumeration value="AccessDenied"/>
       <xs:enumeration value="MalformedRequest"/>
       <xs:enumeration value="UnknownRequest"/>
       <xs:enumeration value="UnknownCriticalExtension"/>
       <xs:enumeration value="UnsupportedVersion"/>
       <xs:enumeration value="NoSupportedKeyTypes"/>
       <xs:enumeration value="NoSupportedEncryptionAlgorithms"/>
       <xs:enumeration value="NoSupportedMACAlgorithms"/>
       <xs:enumeration value="NoProtocolVariants"/>
       <xs:enumeration value="NoSupportedSecretContainers"/>
       <xs:enumeration value="AuthenticationDataInvalid"/>
       <xs:enumeration value="InitializationFailed"/>
     </xs:restriction>
   </xs:simpleType>

   Upon transmission or receipt of a message for which the Status
   attribute's value is not "Success" or "Continue", the default
   behavior, unless explicitly stated otherwise below, is that both the
   DSKPP server and the DSKPP client SHALL immediately terminate the
   DSKPP session.  DSKPP servers and DSKPP clients MUST delete any
   secret values generated as a result of failed runs of the DSKPP
   protocol.  Session identifiers MAY be retained from successful or
   failed protocol runs for replay detection purposes, but such retained
   identifiers SHALL not be reused for subsequent runs of the protocol.

   When possible, the DSKPP client SHOULD present an appropriate error
   message to the user.

   These status codes are valid in all DSKPP Response messages unless
   explicitly stated otherwise:

   o  "Continue" indicates that the DSKPP server is ready for a
      subsequent request from the DSKPP client.  It cannot be sent in
      the server's final message.

   o  "Success" indicates successful completion of the DSKPP session.
      It can only be sent in the server's final message.

   o  "Abort" indicates that the DSKPP server rejected the DSKPP
      client's request for unspecified reasons.

   o  "AccessDenied" indicates that the DSKPP client is not authorized
      to contact this DSKPP server.



Nystroem, et al.        Expires December 13, 2007              [Page 30]


Internet-Draft                    DSKPP                        June 2007


   o  "MalformedRequest" indicates that the DSKPP server failed to parse
      the DSKPP client's request.

   o  "UnknownRequest" indicates that the DSKPP client made a request
      that is unknown to the DSKPP server.

   o  "UnknownCriticalExtension" indicates that a critical DSKPP
      extension (see below) used by the DSKPP client was not supported
      or recognized by the DSKPP server.

   o  "UnsupportedVersion" indicates that the DSKPP client used a DSKPP
      protocol version not supported by the DSKPP server.  This error is
      only valid in the DSKPP server's first response message.

   o  "NoSupportedKeyTypes" indicates that the DSKPP client only
      suggested key types that are not supported by the DSKPP server.
      This error is only valid in the DSKPP server's first response
      message.  Note that the error will only occur if the DSKPP server
      does not support any of the DSKPP client's suggested key types.

   o  "NoSupportedEncryptionAlgorithms" indicates that the DSKPP client
      only suggested encryption algorithms that are not supported by the
      DSKPP server.  This error is only valid in the DSKPP server's
      first response message.  Note that the error will only occur if
      the DSKPP server does not support any of the DSKPP client's
      suggested encryption algorithms.

   o  "NoSupportedMACAlgorithms" indicates that the DSKPP client only
      suggested MAC algorithms that are not supported by the DSKPP
      server.  This error is only valid in the DSKPP server's first
      response message.  Note that the error will only occur if the
      DSKPP server does not support any of the DSKPP client's suggested
      MAC algorithms.

   o  "NoProtocolVariants" indicates that the DSKPP client only
      suggested a protocol variant (either 2-pass or 4-pass) that is not
      supported by the DSKPP server.  This error is only valid in the
      DSKPP server's first response message.  Note that the error will
      only occur if the DSKPP server does not support any of the DSKPP
      client's suggested protocol variants.

   o  "NoSupportedSecretContainers" indicates that the DSKPP client only
      suggested secret container formats that are not supported by the
      DSKPP server.  This error is only valid in the DSKPP server's
      first response message.  Note that the error will only occur if
      the DSKPP server does not support any of the DSKPP client's
      suggested secret container formats.




Nystroem, et al.        Expires December 13, 2007              [Page 31]


Internet-Draft                    DSKPP                        June 2007


   o  "AuthenticationDataInvalid" indicates that the DSKPP client
      supplied user or device authentication data that the DSKPP server
      failed to validate.

   o  "InitializationFailed" indicates that the DSKPP server could not
      generate a valid key given the provided data.  When this status
      code is received, the DSKPP client SHOULD try to restart DSKPP, as
      it is possible that a new run will succeed.

3.10.8.  The DeviceIdentifierDataType Type

   The DeviceIdentifierDataType type is used to uniquely identify the
   device that houses the cryptographic token, e.g., a mobile phone.
   The device identifier allows the DSKPP server to find, e.g., a pre-
   shared transport key for 2-pass DSKPP and/or the correct shared
   secret for MAC'ing purposes.  The default DeviceIdentifierDataType is
   defined in [7].

   <xs:complexType name="DeviceIdentifierDataType">
     <xs:choice>
       <xs:element name="DeviceID" type="pskc:DeviceIdType"/>
       <xs:any namespace="##other" processContents="strict"/>
     </xs:choice>
   </xs:complexType>

3.10.9.  The TokenPlatformInfoType and PlatformType Types

   The TokenPlatformInfoType type is used to carry characteristics of
   the intended token platform, and applies in the public-key variant of
   DSKPP in situations when the client potentially needs to select a
   cryptographic token to initialize.

   <xs:simpleType name="PlatformType">
     <xs:restriction base="xs:string">
       <xs:enumeration value="Hardware"/>
       <xs:enumeration value="Software"/>
       <xs:enumeration value="Unspecified"/>
     </xs:restriction>
   </xs:simpleType>

   <xs:complexType name="TokenPlatformInfoType">
     <xs:attribute name="KeyLocation" type="dskpp:PlatformType"/>
     <xs:attribute name="AlgorithmLocation" type="dskpp:PlatformType"/>
   </xs:complexType>







Nystroem, et al.        Expires December 13, 2007              [Page 32]


Internet-Draft                    DSKPP                        June 2007


3.10.10.  The NonceType Type

   The NonceType type is used to carry pseudorandom values in DSKPP
   messages.  A nonce, as the name implies, MUST be used only once.  For
   each DSKPP message that requires a nonce element to be sent, a fresh
   nonce SHALL be generated each time.  Nonce values MUST be at least 16
   octets long.

   <xs:simpleType name="NonceType">
     <xs:restriction base="xs:base64Binary">
       <xs:minLength value="16"/>
     </xs:restriction>
   </xs:simpleType>

3.10.11.  The AlgorithmsType Type

   The AlgorithmsType type is a list of type-value pairs that define
   algorithms supported by a DSKPP client or server.  Algorithms are
   identified through URIs.

   <xs:complexType name="AlgorithmsType">
     <xs:sequence maxOccurs="unbounded">
       <xs:element name="Algorithm" type="AlgorithmType"/>
     </xs:sequence>
   </xs:complexType>

   <xs:simpleType name="AlgorithmType">
     <xs:restriction base="xs:anyURI"/>
   </xs:simpleType>

3.10.12.  The ProtocolVariantsType and the TwoPassSupportType Types

   The ProtocolVariantsType type is OPTIONALLY used by the DSKPP client
   to indicate the number of passes of the DSKPP protocol that it
   supports (see Section 3.3).  The ProtocolVariantsType MAY be used to
   indicate support for 4-pass or 2-pass DSKPP.  Because 1-pass DSKPP
   does include a client request to the server, the ProtocolVariantsType
   type MAY NOT be used to indicate support for 1-pass DSKPP.  If the
   ProtocolVariantsType is not used, then the DSKPP server will proceed
   with ordinary 4-pass DSKPP.  However, it does not support 4-pass
   DSKPP, then the server MUST find a suitable two-pass variant or else
   the protocol run will fail.









Nystroem, et al.        Expires December 13, 2007              [Page 33]


Internet-Draft                    DSKPP                        June 2007


   <xs:complexType name="ProtocolVariantsType">
     <xs:sequence>
       <xs:element name="TwoPass" type="dskpp:TwoPassSupportType"
         minOccurs="0"/>
       <xs:element name="FourPass" minOccurs="0"/>
     </xs:sequence>
   </xs:complexType>

   <xs:complexType name="TwoPassSupportType">
     <xs:sequence maxOccurs="unbounded">
       <xs:element name="SupportedKeyInitializationMethod"
         type="xs:anyURI"/>
       <xs:element name="Payload" minOccurs="0"/>
     </xs:sequence>
   </xs:complexType>

   The TwoPassSupportType type signals client support for the 2-pass
   version of DSKPP, informs the server of supported two-pass variants,
   and provides OPTIONAL payload data to the DSKPP server.  The payload
   is sent in an opportunistic fashion, and MAY be discarded by the
   DSKPP server if the server does not support the two-pass variant the
   payload is associated with.  The elements of this type have the
   following meaning:

   o  <SupportedKeyInitializationMethod>: A two-pass key initialization
      method supported by the DSKPP client.  Multiple supported methods
      MAY be present, in which case they SHALL be listed in order of
      precedence.

   o  <Payload>: An OPTIONAL payload associated with each supported key
      initialization method.

   A DSKPP client that indicates support for two-pass DSKPP MUST also
   include the nonce R in its <ClientHello> message (this will enable
   the client to verify that the DSKPP server it is communicating with
   is alive).

3.10.13.  The SecretContainersFormatTypeType

   The SecretContainersFormatType type is a list of type-value pairs
   that are OPTIONALLY used to define secret container formats supported
   by a DSKPP client or server.  Secret container formats are identified
   through URIs, e.g., the PSKC URI
   "http://www.openauthentication.org/OATH/2006/10/PSKC#SecretContainer"
   (see [7].






Nystroem, et al.        Expires December 13, 2007              [Page 34]


Internet-Draft                    DSKPP                        June 2007


   <xs:complexType name="SecretContainersFormatType">
     <xs:sequence maxOccurs="unbounded">
       <xs:element name="SecretContainerFormat"
         type="dskpp:SecretContainerFormatType"/>
     </xs:sequence>
   </xs:complexType>

   <xs:simpleType name="SecretContainerFormatType">
     <xs:restriction base="xs:anyURI"/>
   </xs:simpleType>

3.10.14.  The AuthenticationDataType Type

   The AuthenticationDataType type is OPTIONALLY used to carry client or
   server authentication values in DSKPP messages (see Section 3.4).
   The element MAY be used as follows:

   a  A DSKPP client MAY include a one-time use AuthenticationCode that
      was given by the token issuer to the user for acquiring a
      symmetric key.  An AuthenticationCode MAY or MAY NOT contain
      alphanumeric characters in addition to numeric digits depending on
      the device type and policy of the token issuer.  For example, if
      the device is a mobile phone, a code that the user enters on the
      keypad would typically be restricted to numeric digits for ease of
      use.  An activation code can be sent to the DSKPP server in
      plaintext form, hashed data form, or keyed hash data form
      depending on the underlying transport protocol.

   b  A DSKPP client MAY include an AuthenticationCertificate that
      contains a certificate issued with the device by the token issuer.

   c  A DSKPP server MAY use the AuthenticationDataType element
      AuthenticationCodeMac to carry a MAC for authenticating itself to
      the client.  For example, when a successful 1- or 2-pass DSKPP
      protocol run will result in an existing key being replaced, then
      the DSKPP server MUST include a MAC proving to the DSKPP client
      that the server knows the value of the key it is about to replace.














Nystroem, et al.        Expires December 13, 2007              [Page 35]


Internet-Draft                    DSKPP                        June 2007


   <xs:complextype name="AuthenticationDataType">
     <xs:sequence>
       <xs:element name="ClientID" type="dskpp:IdentifierType"
         minOccurs="0"/>
       <xs:choice minOccurs="0">
         <xs:element name="AuthenticationCode"
           type="dskpp:AuthenticationCodeType"/>
         <xs:element name="AuthenticationCodeDigest"
           type="dskpp:AuthenticationCodeDigestType"/>
         <xs:element name="AuthenticationCodeMac"
           type="dskpp:AuthenticationCodeMacType"/>
         <xs:element name="AuthenticationCertificate"
           type="ds:KeyInfoType"/>
       </xs:choice>
     </xs:sequence>
   </xs:complexType>

   <xs:simpleType name="AuthenticationCodeType">
     <xs:restriction base="xs:string">
       <xs:maxLength value="20"/>
     </xs:restriction>
   </xs:simpleType>

   <xs:complexType name="AuthenticationCodeDigestType">
     <xs:simpleContent>
       <xs:extension base="xs:base64Binary">
         <xs:attribute name="HashAlgorithm" type="xs:anyURI"
           use="required"/>
       </xs:extension>
     </xs:simpleContent>
   </xs:complexType>

   <xs:complexType name="AuthenticationCodeMacType">
     <xs:sequence>
       <xs:element name="Data" type="xs:base64Binary">
       <xs:element name="Nonce" type="dskpp:NonceType"/>
     </xs:sequence>
     <attribute name="HMACAlgorithm" type="xs:anyURI"
       use="required"/>
     <attribute name="NonceId" type="dskpp:IdentifierType"/>
   </xs:complexType>

   The element of the AuthenticationDataType type have the following
   meaning:

   o  <ClientID>: A requestor's identifier.  The value MAY be a user ID,
      a device ID, or a keyID associated with the requestor's
      authentication value.  When the authentication data is based on a



Nystroem, et al.        Expires December 13, 2007              [Page 36]


Internet-Draft                    DSKPP                        June 2007


      certificate, <ClientID> can be omitted, as the certificate itself
      is typically sufficient to identify the requestor.  Also, if a
      <DSKPPTrigger> message was provided by the server to initiate the
      DSKPP protocol run, <ClientID> can be omitted, as the DeviceID,
      KeyID, and/or nonce provided in the <InitializationTriggerType>
      element ought to be sufficient to identify the requestor.

   o  <AuthenticationCode>: A one-time use value sent in the clear to
      the DSKPP server.

   o  <AuthenticationCodeDigest>: A one-time use value sent in digest
      form to the DSKPP server.

   o  <AuthenticationCodeMac>: An authentication MAC and OPTIONAL
      additional information (e.g., MAC algorithm).  The value could be
      a one-time use value sent as a MAC value to the DSKPP server; or,
      it could be a MAC value sent to the DSKPP client, where the MAC is
      calculated as described in Section 3.9.

   o  <AuthenticationCertificate>: A device certificate sent to the
      DSKPP server.

3.10.15.  The PayloadType Type

   The PayloadType type is used to carry data in a DSKPP client or
   server message.  For this version of the protocol, only one payload
   is defined, the pseudorandom string R_S, for one message, the DSKPP
   <ServerHello>.

   <xs:complexType name="PayloadType">
     <xs:choice>
       <xs:element name="Nonce" type="dskpp:NonceType"/>
       <xs:any namespace="##other" processContents="strict"/>
     </xs:choice>
   </xs:complexType>

3.10.16.  The MacType Type

   The MacType type is used by the DSKPP server to carry a MAC value
   that the DSKPP server uses to authenticate itself to the client.











Nystroem, et al.        Expires December 13, 2007              [Page 37]


Internet-Draft                    DSKPP                        June 2007


   <xs:complexType name="MacType">
     <xs:simpleContent>
       <xs:extension base="xs:base64Binary">
         <xs:attribute name="MacAlgorithm" type="xs:anyURI"/>
       </xs:extension>
     </xs:simpleContent>
   </xs:complexType>

3.10.17.  The SecretContainerType Type

   The SecretContainerType type is used by the DSKPP server in its final
   message to carry symmetric key(s) (in the 2- and 1-pass exchanges)
   and configuration data.  The default element defined for the
   SecretContainerType is contained in the namespace defined in the PSKC
   namespace as SecretContainerType (see [7].

   <xs:complexType name="SecretContainerType">
     <xs:choice>
       <xs:element name="SecretContainer"
         type="pskc:SecretContainerType"/>
       <xs:element name="##other" processContents="strict"/>
     </xs:choice>
   </xs:complexType>

3.10.18.  The ExtensionsType and the AbstractExtensionType Types

   The ExtensionsType type is a list of type-value pairs that define
   OPTIONAL DSKPP features supported by a DSKPP client or server.
   Extensions MAY be sent with any DSKPP message.  Please see the
   description of individual DSKPP messages in Section 3.12 of this
   document for applicable extensions.  All DSKPP extensions are defined
   as extensions to the AbstractExtensionType type.  The elements of the
   AbstractExtensionType, therefore, apply to all DSKPP extensions.
   Unless an extension is marked as Critical, a receiving party need not
   be able to interpret it.  A receiving party is always free to
   disregard any (non-critical) extensions.















Nystroem, et al.        Expires December 13, 2007              [Page 38]


Internet-Draft                    DSKPP                        June 2007


   <xs:complexType name="ExtensionsType">
     <xs:sequence maxOccurs="unbounded">
       <xs:element name="Extension" type="AbstractExtensionType"/>
     </xs:sequence>
   </xs:complexType>

   <xs:complexType name="AbstractExtensionType" abstract="true">
     <xs:attribute name="Critical" type="xs:boolean"/>
   </xs:complexType>

3.11.  DSKPP Messages

3.11.1.  Introduction

   In this section, DSKPP messages, including their parameters, encoding
   and semantics are defined.

3.11.2.  DSKPP Initialization (OPTIONAL)

   The DSKPP server MAY initialize the DSKPP protocol by sending a
   <DSKPPTrigger> message.  This message MAY, e.g., be sent in response
   to a user requesting token initialization in a browsing session.





























Nystroem, et al.        Expires December 13, 2007              [Page 39]


Internet-Draft                    DSKPP                        June 2007


   <xs:complexType name="InitializationTriggerType">
     <xs:sequence>
       <xs:element name="DeviceIdentifierData"
         type="dskpp:DeviceIdentifierDataType" minOccurs="0"/>
       <xs:element name="KeyID" type="xs:base64Binary" minOccurs="0"/>
       <xs:element name="TokenPlatformInfo"
         type="dskpp:TokenPlatformInfoType" minOccurs="0"/>
       <xs:element name="TriggerNonce" type="dskpp:NonceType"/>
       <xs:element name="DSKPP_URL" type="xs:anyURI" minOccurs="0"/>
       <xs:any namespace="##other" processContents="strict"
         minOccurs="0"/>
     </xs:sequence>
   </xs:complexType>

   <xs:element name="DSKPPTrigger" type="DSKPPTriggerType"/>

   <xs:complexType name="DSKPPTriggerType">
     <xs:annotation>
       <xs:documentation xml:lang="en">
         Message used to trigger the device to initiate a
         DSKPP protocol run.
       </xs:documentation>
     </xs:annotation>
     <xs:sequence>
       <xs:choice>
         <xs:element name="InitializationTrigger"
           type="dskpp:InitializationTriggerType"/>
         <xs:any namespace="##other" processContents="strict"/>
       </xs:choice>
     </xs:sequence>
     <xs:attribute name="Version" type="dskpp:VersionType"/>
   </xs:complexType>

   The <DSKPPTrigger> element is intended for the DSKPP client and MAY
   inform the DSKPP client about the identifier for the device that
   houses the cryptographic token to be initialized, and, OPTIONALLY, of
   the identifier for the key on that token.  The latter would apply to
   key renewal.  The trigger always contains a nonce to allow the DSKPP
   server to couple the trigger with a later DSKPP <ClientHello>
   request.  Finally, the trigger MAY contain a URL to use when
   contacting the DSKPP server.  The <xs:any> elements are for future
   extensibility.  Any provided <DeviceIdentifierData> or <KeyID> values
   SHALL be used by the DSKPP client in the subsequent <ClientHello>
   request.  The OPTIONAL <TokenPlatformInfo> element informs the DSKPP
   client about the characteristics of the intended token platform, and
   applies in the public-key variant of DSKPP in situations when the
   client potentially needs to decide which one of several tokens to
   initialize.



Nystroem, et al.        Expires December 13, 2007              [Page 40]


Internet-Draft                    DSKPP                        June 2007


   The Version attribute SHALL be set to "1.0" for this version of
   DSKPP.

3.11.3.  The DSKPP Client's Initial PDU (2- and 4-Pass)

   This message is the initial message sent from the DSKPP client to the
   DSKPP server.












































Nystroem, et al.        Expires December 13, 2007              [Page 41]


Internet-Draft                    DSKPP                        June 2007


   <xs:element name="ClientHello" type="ClientHelloPDU"/>

   <xs:complexType name="ClientHelloPDU">
     <xs:annotation>
       <xs:documentation xml:lang="en">
         Message sent from DSKPP client to DSKPP server to initiate a
         DSKPP session.
       </xs:documentation>
     </xs:annotation>
     <xs:complexContent>
       <xs:extension base="AbstractRequestType">
         <xs:sequence>
           <xs:element name="DeviceIdentifierData"
             type="dskpp:DeviceIdentifierDataType" minOccurs="0"/>
           <xs:element name="KeyID" type="xs:base64Binary"
             minOccurs="0"/>
           <xs:element name="ClientNonce" type="dskpp:NonceType"
             minOccurs="0"/>
           <xs:element name="TriggerNonce" type="dskpp:NonceType"
             minOccurs="0"/>
           <xs:element name="SupportedKeyTypes"
             type="dskpp:AlgorithmsType"/>
           <xs:element name="SupportedEncryptionAlgorithms"
             type="dskpp:AlgorithmsType"/>
           <xs:element name="SupportedMACAlgorithms"
             type="dskpp:AlgorithmsType"/>
           <xs:element name="SupportedProtocolVariants"
             type="dskpp:ProtocolVariantsType" minOccurs="0"/>
           <xs:element name="SupportedSecretContainers"
             type="dskpp:SecretContainersFormatType" minOccurs="0"/>
           <xs:element name="AuthenticationData"
             type="dskpp:AuthenticationDataType" minOccurs="0"/>
           <xs:element name="Extensions" type="dskpp:ExtensionsType"
             minOccurs="0"/>
         </xs:sequence>
       </xs:extension>
     </xs:complexContent>
   </xs:complexType>

   The components of this message have the following meaning:

   o  Version: (attribute inherited from the AbstractRequestType type)
      The highest version of this protocol the client supports.  Only
      version one ("1.0") is currently specified.

   o  <DeviceIdentifierData>: An identifier for the cryptographic token
      as defined in Section 3.4.1 above.  The identifier SHALL only be
      present if such shared secrets exist or if the identifier was



Nystroem, et al.        Expires December 13, 2007              [Page 42]


Internet-Draft                    DSKPP                        June 2007


      provided by the server in a <DSKPPTrigger> element (see
      Section 4.2.7 below).  In the latter case, it MUST have the same
      value as the identifier provided in that element.

   o  <KeyID>: An identifier for the key that will be overwritten if the
      protocol run is successful.  The identifier SHALL only be present
      if the key exists or was provided by the server in a
      <DSKPPTrigger> element (see Section 4.2.7 below).  In the latter
      case, it MUST have the same value as the identifier provided in
      that element.

   o  <ClientNonce>: This is the nonce R, which, when present, SHALL be
      used by the server when calculating MAC values (see below).  It is
      RECOMMENDED that clients include this element whenever the <KeyID>
      element is present.

   o  <TriggerNonce>: This OPTIONAL element SHALL be present if and only
      if the DSKPP run was initialized with a <DSKPPTrigger> message
      (see Section 4.2.7 below), and SHALL, in that case, have the same
      value as the <TriggerNonce> child of that message.  A server using
      nonces in this way MUST verify that the nonce is valid and that
      any device or key identifier values provided in the <DSKPPTrigger>
      message match the corresponding identifier values in the
      <ClientHello> message.

   o  <SupportedKeyTypes>: A sequence of URIs indicating the key types
      for which the token is willing to generate keys through DSKPP.

   o  <SupportedEncryptionAlgorithms>: A sequence of URIs indicating the
      encryption algorithms supported by the cryptographic token for the
      purposes of DSKPP.  The DSKPP client MAY indicate the same
      algorithm both as a supported key type and as an encryption
      algorithm.

   o  <SupportedMACAlgorithms>: A sequence of URIs indicating the MAC
      algorithms supported by the cryptographic token for the purposes
      of DSKPP.  The DSKPP client MAY indicate the same algorithm both
      as an encryption algorithm and as a MAC algorithm (e.g.,
      urn:ietf:params:xml:schema:keyprov:protocol#dskpp-prf-aes defined
      in Appendix E).

   o  <SupportedProtocolVariants>: This OPTIONAL element is used by the
      DSKPP client to indicate support for four-pass or two-pass DSKPP.
      If two-pass support is specified, then <ClientNonce> MUST be set
      to nonce R in the <ClientHello> message unless <TriggerNonce> is
      already present.





Nystroem, et al.        Expires December 13, 2007              [Page 43]


Internet-Draft                    DSKPP                        June 2007


   o  <SupportedSecretContainers>: This OPTIONAL element is a sequence
      of URIs indicating the secret container formats supported by the
      DSKPP client.  If this element is not provided, then the DSKPP
      server SHALL proceed with "http://www.openauthentication.org/OATH/
      2006/10/PSKC#SecretContainer" (see [7].

   o  <AuthenticationData>: This OPTIONAL element contains data that the
      DSKPP client uses to authenticate the user or device to the DSKPP
      server.  The element is set as specified in Section 3.4.1.

   o  <Extensions>: A sequence of extensions.  One extension is defined
      for this message in this version of DSKPP: the ClientInfoType (see
      Section 3.12).

3.11.4.  The DSKPP Server's Initial PDU (4-Pass Only)

   This message is the first message sent from the DSKPP server to the
   DSKPP client (assuming a trigger message has not been sent to
   initiate the protocol, in which case, this message is the second
   message sent from the DSKPP server to the DSKPP client).  It is sent
   upon reception of a <ClientHello> message.






























Nystroem, et al.        Expires December 13, 2007              [Page 44]


Internet-Draft                    DSKPP                        June 2007


   <xs:element name="ServerHello" type="ServerHelloPDU"/>

   <xs:complexType name="ServerHelloPDU">
     <xs:annotation>
       <xs:documentation xml:lang="en">
         Message sent from DSKPP server to DSKPP client
         in response to a received ClientHello PDU.
       </xs:documentation>
     </xs:annotation>
     <xs:complexContent>
       <xs:extension base="AbstractResponseType">
         <xs:sequence minOccurs="0">
           <xs:element name="KeyType"
             type="dskpp:AlgorithmType"/>
           <xs:element name="EncryptionAlgorithm"
             type="dskpp:AlgorithmType"/>
           <xs:element name="MacAlgorithm"
             type="dskpp:AlgorithmType"/>
           <xs:element name="EncryptionKey"
             type="ds:KeyInfoType"/>
           <xs:element name="SecretContainerFormat"
             type="dskpp:SecretContainerFormatType"/>
           <xs:element name="Payload"
             type="dskpp:PayloadType"/>
           <xs:element name="Extensions"
             type="dskpp:ExtensionsType" minOccurs="0"/>
           <xs:element name="Mac" type="dskpp:MacType"
             minOccurs="0"/>
         </xs:sequence>
       </xs:extension>
     </xs:complexContent>
   </xs:complexType>

   The components of this message have the following meaning:

   o  Version: (attribute inherited from the AbstractResponseType type)
      The version selected by the DSKPP server.  MAY be lower than the
      version indicated by the DSKPP client, in which case, local policy
      at the client SHALL determine whether or not to continue the
      session.

   o  SessionID: (attribute inherited from the AbstractResponseType
      type) An identifier for this session.

   o  Status: (attribute inherited from the AbstractResponseType type)
      Return code for the <ClientHello>.  If Status is not "Continue",
      only the Status and Version attributes will be present; otherwise,
      all the other element MUST be present as well.



Nystroem, et al.        Expires December 13, 2007              [Page 45]


Internet-Draft                    DSKPP                        June 2007


   o  <KeyType>: The type of the key to be generated.

   o  <EncryptionAlgorithm>: The encryption algorithm to use when
      protecting R_C.

   o  <MacAlgorithm>: The MAC algorithm to be used by the DSKPP server.

   o  <EncryptionKey>: Information about the key to use when encrypting
      R_C. It will either be the server's public key (the <ds:KeyValue>
      alternative of ds:KeyInfoType) or an identifier for a shared
      secret key (the <ds:KeyName> alternative of ds:KeyInfoType).

   o  <SecretContainerFormat>: The secret container format type to be
      used by the DSKPP server.  The default setting relies on the
      SecretContainerType element defined in
      "urn:ietf:params:xml:schema:keyprov:container" [7].

   o  <Payload>: The actual payload.  For this version of the protocol,
      only one payload is defined: the pseudorandom string R_S.

   o  <Extensions>: A list of server extensions.  Two extensions are
      defined for this message in this version of DSKPP: the
      ClientInfoType and the ServerInfoType (see Section 3.12).

   o  <Mac>: The MAC MUST be present if the DSKPP run will result in the
      replacement of an existing symmetric key with a new one (i.e., if
      the <KeyID> element was present in the <ClientHello message).  In
      this case, the DSKPP server MUST prove to the cryptographic token
      that it is authorized to replace it.  The MAC value SHALL be
      computed as defined in Section 3.9.1.1.

      The DSKPP client MUST verify the MAC if the successful execution
      of the protocol will result in the replacement of an existing
      symmetric key with a newly generated one.  The DSKPP client MUST
      terminate the DSKPP session if the MAC does not verify, and MUST
      delete any nonces, keys, and/or secrets associated with the failed
      run of the DSKPP protocol.

      The MacType's MacAlgorithm attribute SHALL, when present, identify
      the negotiated MAC algorithm.

3.11.5.  The DSKPP Client's Second PDU (4-Pass Only)

   This message contains the nonce chosen by the cryptographic token,
   R_C, encrypted by the specified encryption key and encryption
   algorithm.





Nystroem, et al.        Expires December 13, 2007              [Page 46]


Internet-Draft                    DSKPP                        June 2007


   <xs:element name="ClientNonce" type="ClientNoncePDU"/>

   <xs:complexType name="ClientNoncePDU">
     <xs:annotation>
       <xs:documentation xml:lang="en">
         Second message sent from DSKPP client to
         DSKPP server in a DSKPP session.
       </xs:documentation>
     </xs:annotation>
     <xs:complexContent>
       <xs:extension base="AbstractRequestType">
         <xs:sequence>
           <xs:element name="EncryptedNonce"
             type="xs:base64Binary"/>
           <xs:element name="AuthenticationData"
             type="dskpp:AuthenticationDataType" minOccurs="0"/>
           <xs:element name="Extensions"
             type="dskpp:ExtensionsType" minOccurs="0"/>
         </xs:sequence>
         <xs:attribute name="SessionID" type="dskpp:IdentifierType"
           use="required"/>
       </xs:extension>
     </xs:complexContent>
   </xs:complexType>

   The components of this message have the following meaning:

   o  Version: (inherited from the AbstractRequestType type) SHALL be
      the same version as in the <ServerHello> message.

   o  <SessionID>: SHALL have the same value as the SessionID attribute
      in the received <ServerHello> message.

   o  <EncryptedNonce>: The nonce generated and encrypted by the token.
      The encryption SHALL be made using the selected encryption
      algorithm and identified key, and as specified in Section 3.6.

   o  <AuthenticationData>: The authentication data value, which MAY
      OPTIONALLY be the same as provided in the <ClientHello>, SHALL be
      set as specified in Section 3.4.1.

   o  <Extensions>: A list of extensions.  Two extensions are defined
      for this message in this version of DSKPP: the ClientInfoType and
      the ServerInfoType (see Section 3.12).







Nystroem, et al.        Expires December 13, 2007              [Page 47]


Internet-Draft                    DSKPP                        June 2007


3.11.6.  The DSKPP Server's Final PDU (1-, 2-, and 4-Pass)

   This message is the last message of the DSKPP protocol run.  In a
   4-pass exchange, the DSKPP server sends this message in response to a
   <ClientNonce> message, whereas in a 2-pass exchange, the DSKPP server
   sends this message in response to a <ClientHello> message.  In a
   1-pass exchange, the DSKPP server sends only this message to the
   client.

   <xs:element name="ServerFinished" type="ServerFinishedPDU"/>

   <xs:complexType name="ServerFinishedPDU">
     <xs:annotation>
       <xs:documentation xml:lang="en">
         Final message sent from DSKPP server to
         DSKPP client in a DSKPP session.
       </xs:documentation>
     </xs:annotation>
     <xs:complexContent>
       <xs:extension base="AbstractResponseType">
         <xs:sequence minOccurs="0">
           <xs:element name="SecretContainer"
             type="dskpp:SecretContainerType"/>
           <xs:element name="Extensions"
             type="dskpp:ExtensionsType" minOccurs="0"/>
           <xs:element name="Mac"
             type="dskpp:MacType"/>
         </xs:sequence>
       </xs:extension>
     </xs:complexContent>
   </xs:complexType>

   The components of this message have the following meaning:

   o  Version: (inherited from the AbstractResponseType type) The DSKPP
      version used in this session.

   o  SessionID: (inherited from the AbstractResponseType type) The
      previously established identifier for this session.

   o  Status: (inherited from the AbstractResponseType type) Return code
      for the <ServerFinished> message.  If Status is not "Success",
      only the Status, SessionID, and Version attributes will be present
      (the presence of the SessionID attribute is dependent on the type
      of reported error); otherwise, all the other elements MUST be
      present as well.  In this latter case, the <ServerFinished>
      message can be seen as a "Commit" message, instructing the
      cryptographic token to store the generated key and associate the



Nystroem, et al.        Expires December 13, 2007              [Page 48]


Internet-Draft                    DSKPP                        June 2007


      given key identifier with this key.

   o  <SecretContainer>: The secret container containing symmetric key
      values (in the case of a 2- or 1-pass exchange) and configuration
      data.  The default container format is based on the
      SecretContainerType type from PSKC, as defined in [7].

   o  <Extensions>: A list of extensions chosen by the DSKPP server.
      For this message, this version of DSKPP defines one extension, the
      ClientInfoType (see Section 3.12).

   o  <Mac>: To avoid a false "Commit" message causing the token to end
      up in an initialized state for which the server does not know the
      stored key, <ServerFinished> messages MUST always be authenticated
      with a MAC.  The MAC SHALL be made using the already established
      MAC algorithm.  The MAC value SHALL be computed as specified in
      Section 3.9.1.2.

      When receiving a <ServerFinished> message with Status="Success"
      for which the MAC verifies, the DSKPP client SHALL associate the
      generated key K_TOKEN with the provided key identifier and store
      this data permanently.  After this operation, it SHALL not be
      possible to overwrite the key unless knowledge of an authorizing
      key is proven through a MAC on a later <ServerHello> (and
      <ServerFinished>) message.

      The DSKPP client MUST verify the MAC.  The DSKPP client MUST
      terminate the DSKPP session if the MAC does not verify, and MUST,
      in this case, also delete any nonces, keys, and/or secrets
      associated with the failed run of the DSKPP protocol.

      The MacType's MacAlgorithm attribute SHALL, when present, identify
      the negotiated MAC algorithm.

3.12.  Protocol Extensions

3.12.1.  The ClientInfoType Type

   When present in a <ClientHello> or a <ClientNonce> message, the
   OPTIONAL ClientInfoType extension contains DSKPP client-specific
   information.  DSKPP servers MUST support this extension.  DSKPP
   servers MUST NOT attempt to interpret the data it carries and, if
   received, MUST include it unmodified in the current protocol run's
   next server response.  Servers need not retain the ClientInfoType's
   data after that response has been generated.






Nystroem, et al.        Expires December 13, 2007              [Page 49]


Internet-Draft                    DSKPP                        June 2007


   <xs:complexType name="ClientInfoType">
     <xs:complexContent>
       <xs:extension base="AbstractExtensionType">
         <xs:sequence>
           <xs:element name="Data"
             type="xs:base64Binary"/>
         </xs:sequence>
       </xs:extension>
     </xs:complexContent>
   </xs:complexType>

3.12.2.  The ServerInfoType Type

   When present, the OPTIONAL ServerInfoType extension contains DSKPP
   server-specific information.  This extension is only valid in
   <ServerHello> messages for which Status = "Continue".  DSKPP clients
   MUST support this extension.  DSKPP clients MUST NOT attempt to
   interpret the data it carries and, if received, MUST include it
   unmodified in the current protocol run's next client request (i.e.,
   the <ClientNonce> message).  DSKPP clients need not retain the
   ServerInfoType's data after that request has been generated.  This
   extension MAY be used, e.g., for state management in the DSKPP
   server.

   <xs:complexType name="ServerInfoType">
     <xs:complexContent>
       <xs:extension base="AbstractExtensionType">
         <xs:sequence>
           <xs:element name="Data"
             type="xs:base64Binary"/>
         </xs:sequence>
       </xs:extension>
     </xs:complexContent>
   </xs:complexType>

3.12.3.  The KeyInitializationDataType Type

   This extension is used for 2- and 1-pass DSKPP exchange; it carries
   an identifier for the selected key initialization method as well as
   key initialization method-dependent payload data.

   Servers MAY include this extension in a <ServerFinished> message that
   is being sent in response to a received <ClientHello> message if and
   only if that <ClientHello> message selected TwoPassSupport as the
   ProtocolVariantType and the client indicated support for the selected
   key initialization method.  Servers MUST include this extension in a
   <ServerFinished> message that is sent as part of a 1-pass DSKPP.




Nystroem, et al.        Expires December 13, 2007              [Page 50]


Internet-Draft                    DSKPP                        June 2007


   <xs:complexType name="KeyInitializationDataType">
     <xs:annotation>
       <xs:documentation xml:lang="en">
         This extension is only valid in ServerFinished PDUs. It
         contains key initialization data and its presence results in a
         two-pass (or one-pass, if no ClientHello was sent) DSKPP
         exchange.
       </xs:documentation>
     </xs:annotation>
     <xs:complexContent>
       <xs:extension base="dskpp:AbstractExtensionType">
         <xs:sequence>
           <xs:element name="KeyInitializationMethod" type="xs:anyURI"/>
           <xs:element name="Payload"/>
         </xs:sequence>
       </xs:extension>
     </xs:complexContent>
   </xs:complexType>

   The elements of this type have the following meaning:

   o  <KeyInitializationMethod>: A two-pass key initialization method
      supported by the DSKPP client.

   o  <Payload>: A payload associated with the key initialization
      method.  Since the syntax is a shorthand for <xs:element
      name="Payload" type="xs:anyType"/>, any well-formed payloads can
      be carried in this element.























Nystroem, et al.        Expires December 13, 2007              [Page 51]


Internet-Draft                    DSKPP                        June 2007


4.  Protocol Bindings

4.1.  General Requirements

   DSKPP assumes a reliable transport.

4.2.  HTTP/1.1 Binding for DSKPP

4.2.1.  Introduction

   This section presents a binding of the previous messages to HTTP/1.1
   [14].  Note that the HTTP client normally will be different from the
   DSKPP client, i.e., the HTTP client will only exist to "proxy" DSKPP
   messages from the DSKPP client to the DSKPP server.  Likewise, on the
   HTTP server side, the DSKPP server MAY receive DSKPP PDUs from a
   "front-end" HTTP server.

4.2.2.  Identification of DSKPP Messages

   The MIME-type for all DSKPP messages SHALL be

   application/vnd.ietf.keyprov.dskpp+xml

4.2.3.  HTTP Headers

   HTTP proxies MUST NOT cache responses carrying DSKPP messages.  For
   this reason, the following holds:

   o  When using HTTP/1.1, requesters SHOULD:

      *  Include a Cache-Control header field set to "no-cache, no-
         store".

      *  Include a Pragma header field set to "no-cache".

   o  When using HTTP/1.1, responders SHOULD:

      *  Include a Cache-Control header field set to "no-cache, no-must-
         revalidate, private".

      *  Include a Pragma header field set to "no-cache".

      *  NOT include a Validator, such as a Last-Modified or ETag
         header.

   There are no other restrictions on HTTP headers, besides the
   requirement to set the Content-Type header value to application/
   vnd.ietf.keyprov.dskpp+xml.



Nystroem, et al.        Expires December 13, 2007              [Page 52]


Internet-Draft                    DSKPP                        June 2007


4.2.4.  HTTP Operations

   Persistent connections as defined in HTTP/1.1 are assumed but not
   required.  DSKPP requests are mapped to HTTP POST operations.  DSKPP
   responses are mapped to HTTP responses.

4.2.5.  HTTP Status Codes

   A DSKPP HTTP responder that refuses to perform a message exchange
   with a DSKPP HTTP requester SHOULD return a 403 (Forbidden) response.
   In this case, the content of the HTTP body is not significant.  In
   the case of an HTTP error while processing a DSKPP request, the HTTP
   server MUST return a 500 (Internal Server Error) response.  This type
   of error SHOULD be returned for HTTP-related errors detected before
   control is passed to the DSKPP processor, or when the DSKPP processor
   reports an internal error (for example, the DSKPP XML namespace is
   incorrect, or the DSKPP schema cannot be located).  If the type of a
   DSKPP request cannot be determined, the DSKPP responder MUST return a
   400 (Bad request) response.

   In these cases (i.e., when the HTTP response code is 4xx or 5xx), the
   content of the HTTP body is not significant.

   Redirection status codes (3xx) apply as usual.

   Whenever the HTTP POST is successfully invoked, the DSKPP HTTP
   responder MUST use the 200 status code and provide a suitable DSKPP
   message (possibly with DSKPP error information included) in the HTTP
   body.

4.2.6.  HTTP Authentication

   No support for HTTP/1.1 authentication is assumed.

4.2.7.  Initialization of DSKPP

   The DSKPP server MAY initialize the DSKPP protocol by sending an HTTP
   response with Content-Type set to application/
   vnd.ietf.keyprov.dskpp+xml and response code set to 200 (OK).  This
   message MAY, e.g., be sent in response to a user requesting token
   initialization in a browsing session.  The initialization message MAY
   carry data in its body.  If this is the case, the data SHALL be a
   valid instance of a <DSKPPTrigger> element.

4.2.8.  Example Messages






Nystroem, et al.        Expires December 13, 2007              [Page 53]


Internet-Draft                    DSKPP                        June 2007


   a.  Initialization from DSKPP server:

       HTTP/1.1 200 OK

       Cache-Control: no-store
       Content-Type: application/vnd.ietf.keyprov.dskpp+xml
       Content-Length: <some value>

       DSKPP initialization data in XML form...

   b.  Initial request from DSKPP client:

       POST http://example.com/cgi-bin/DSKPP-server HTTP/1.1
       Cache-Control: no-store
       Pragma: no-cache
       Host: example.com
       Content-Type: application/vnd.ietf.keyprov.dskpp+xml
       Content-Length: <some value>

       DSKPP data in XML form (supported version, supported
       algorithms...)

   c.  Initial response from DSKPP server:

       HTTP/1.1 200 OK

       Cache-Control: no-store
       Content-Type: application/vnd.ietf.keyprov.dskpp+xml
       Content-Length: <some value>

       DSKPP data in XML form (server random nonce, server public key,
       ...)



















Nystroem, et al.        Expires December 13, 2007              [Page 54]


Internet-Draft                    DSKPP                        June 2007


5.  Security considerations

5.1.  General

   DSKPP is designed to protect generated key material from exposure.
   No other entities than the DSKPP server and the cryptographic token
   will have access to a generated K_TOKEN if the cryptographic
   algorithms used are of sufficient strength and, on the DSKPP client
   side, generation and encryption of R_C and generation of K_TOKEN take
   place as specified and in the token.  This applies even if malicious
   software is present in the DSKPP client.  However, as discussed in
   the following, DSKPP does not protect against certain other threats
   resulting from man-in-the-middle attacks and other forms of attacks.
   DSKPP SHOULD, therefore, be run over a transport providing privacy
   and integrity, such as HTTP over Transport Layer Security (TLS) with
   a suitable ciphersuite, when such threats are a concern.  Note that
   TLS ciphersuites with anonymous key exchanges are not suitable in
   those situations.

5.2.  Active Attacks

5.2.1.  Introduction

   An active attacker MAY attempt to modify, delete, insert, replay, or
   reorder messages for a variety of purposes including service denial
   and compromise of generated key material.  Section 5.2.2 through
   Section 5.2.7.

5.2.2.  Message Modifications

   Modifications to a <DSKPPPTrigger> message will either cause denial-
   of-service (modifications of any of the identifiers or the nonce) or
   the DSKPP client to contact the wrong DSKPP server.  The latter is in
   effect a man-in-the-middle attack and is discussed further in
   Section 5.2.7.

   An attacker may modify a <ClientHello> message.  This means that the
   attacker could indicate a different key or device than the one
   intended by the DSKPP client, and could also suggest other
   cryptographic algorithms than the ones preferred by the DSKPP client,
   e.g., cryptographically weaker ones.  The attacker could also suggest
   earlier versions of the DSKPP protocol, in case these versions have
   been shown to have vulnerabilities.  These modifications could lead
   to an attacker succeeding in initializing or modifying another token
   than the one intended (i.e., the server assigning the generated key
   to the wrong token), or gaining access to a generated key through the
   use of weak cryptographic algorithms or protocol versions.  DSKPP
   implementations MAY protect against the latter by having strict



Nystroem, et al.        Expires December 13, 2007              [Page 55]


Internet-Draft                    DSKPP                        June 2007


   policies about what versions and algorithms they support and accept.
   The former threat (assignment of a generated key to the wrong token)
   is not possible when the shared-key variant of DSKPP is employed
   (assuming existing shared keys are unique per token), but is possible
   in the public-key variant.  Therefore, DSKPP servers MUST NOT accept
   unilaterally provided device identifiers in the public-key variant.
   This is also indicated in the protocol description.  In the shared-
   key variant, however, an attacker may be able to provide the wrong
   identifier (possibly also leading to the incorrect user being
   associated with the generated key) if the attacker has real-time
   access to the token with the identified key.  In other words, the
   generated key is associated with the correct token but the token is
   associated with the incorrect user.  See further Section 5.5 for a
   discussion of this threat and possible countermeasures.

   An attacker may also modify a <ServerHello> message.  This means that
   the attacker could indicate different key types, algorithms, or
   protocol versions than the legitimate server would, e.g.,
   cryptographically weaker ones.  The attacker could also provide a
   different nonce than the one sent by the legitimate server.  Clients
   will protect against the former through strict adherence to policies
   regarding permissible algorithms and protocol versions.  The latter
   (wrong nonce) will not constitute a security problem, as a generated
   key will not match the key generated on the legitimate server.  Also,
   whenever the DSKPP run would result in the replacement of an existing
   key, the <Mac> element protects against modifications of R_S.

   Modifications of <ClientNonce> messages are also possible.  If an
   attacker modifies the SessionID attribute, then, in effect, a switch
   to another session will occur at the server, assuming the new
   SessionID is valid at that time on the server.  It still will not
   allow the attacker to learn a generated K_TOKEN since R_C has been
   wrapped for the legitimate server.  Modifications of the
   <EncryptedNonce> element, e.g., replacing it with a value for which
   the attacker knows an underlying R'C, will not result in the client
   changing its pre-DSKPP state, since the server will be unable to
   provide a valid MAC in its final message to the client.  The server
   MAY, however, end up storing K'TOKEN rather than K_TOKEN.  If the
   token has been associated with a particular user, then this could
   constitute a security problem.  For a further discussion about this
   threat, and a possible countermeasure, see Section 5.5 below.  Note
   that use of Secure Socket Layer (SSL) or TLS does not protect against
   this attack if the attacker has access to the DSKPP client (e.g.,
   through malicious software, "trojans").

   Finally, attackers may also modify the <ServerFinished> message.
   Replacing the <Mac> element will only result in denial-of-service.
   Replacement of any other element may cause the DSKPP client to



Nystroem, et al.        Expires December 13, 2007              [Page 56]


Internet-Draft                    DSKPP                        June 2007


   associate, e.g., the wrong service with the generated key.  DSKPP
   SHOULD be run over a transport providing privacy and integrity when
   this is a concern.

5.2.3.  Message Deletion

   Message deletion will not cause any other harm than denial-of-
   service, since a token SHALL NOT change its state (i.e., "commit" to
   a generated key) until it receives the final message from the DSKPP
   server and successfully has processed that message, including
   validation of its MAC.  A deleted <ServerFinished> message will not
   cause the server to end up in an inconsistent state vis-a-vis the
   token if the server implements the suggestions in Section 5.5.

5.2.4.  Message Insertion

   An active attacker may initiate a DSKPP run at any time, and suggest
   any device identifier.  DSKPP server implementations MAY receive some
   protection against inadvertently initializing a token or
   inadvertently replacing an existing key or assigning a key to a token
   by initializing the DSKPP run by use of the <DSKPPTrigger>.  The
   <TriggerNonce> element allows the server to associate a DSKPP
   protocol run with, e.g., an earlier user-authenticated session.  The
   security of this method, therefore, depends on the ability to protect
   the <TriggerNonce> element in the DSKPP initialization message.  If
   an eavesdropper is able to capture this message, he may race the
   legitimate user for a key initialization.  DSKPP over a transport
   providing privacy and integrity, coupled with the recommendations in
   Section 5.5, is RECOMMENDED when this is a concern.

   Insertion of other messages into an existing protocol run is seen as
   equivalent to modification of legitimately sent messages.

5.2.5.  Message Replay

   During 4-pass DSKPP, attempts to replay a previously recorded DSKPP
   message will be detected, as the use of nonces ensures that both
   parties are live.  For example, a DSKPP client knows that a server it
   is communicating with is "live" since the server MUST create a MAC on
   information sent by the client.

   The same is true for 2-pass DSKPP thanks to the requirement that the
   client sends R in the <ClientHello> message and that the server
   includes R in the MAC computation.

   In 1-pass DSKPP clients (tokens) that record the latest I used by a
   particular server (as identified by ID_S) will be able to detect
   replays.



Nystroem, et al.        Expires December 13, 2007              [Page 57]


Internet-Draft                    DSKPP                        June 2007


5.2.6.  Message Reordering

   An attacker may attempt to re-order 4-pass DSKPP messages but this
   will be detected, as each message is of a unique type.  Note: Message
   re-ordering attacks cannot occur in 2- and 1-pass DSKPP since each
   party sends at most one message each.

5.2.7.  Man-in-the-Middle

   In addition to other active attacks, an attacker posing as a man in
   the middle may be able to provide his own public key to the DSKPP
   client.  This threat and countermeasures to it are discussed in
   Section 3.3.  An attacker posing as a man-in-the-middle may also be
   acting as a proxy and, hence, may not interfere with DSKPP runs but
   still learn valuable information; see Section 5.3.

5.3.  Passive Attacks

   Passive attackers may eavesdrop on DSKPP runs to learn information
   that later on may be used to impersonate users, mount active attacks,
   etc.

   If DSKPP is not run over a transport providing privacy, a passive
   attacker may learn:

   o  What tokens a particular user is in possession of;

   o  The identifiers of keys on those tokens and other attributes
      pertaining to those keys, e.g., the lifetime of the keys; and

   o  DSKPP versions and cryptographic algorithms supported by a
      particular DSKPP client or server.

   Whenever the above is a concer, DSKPP SHOULD be run over a transport
   providing privacy.  If man-in-the-middle attacks for the purposes
   described above are a concern, the transport SHOULD also offer
   server-side authentication.

5.4.  Cryptographic Attacks

   An attacker with unlimited access to an initialized token may use the
   token as an "oracle" to pre-compute values that later on may be used
   to impersonate the DSKPP server.  Section 3.8 and Section 3.11
   contain discussions of this threat and steps RECOMMENDED to protect
   against it.






Nystroem, et al.        Expires December 13, 2007              [Page 58]


Internet-Draft                    DSKPP                        June 2007


5.5.  Attacks on the Interaction between DSKPP and User Authentication

   If keys generated in DSKPP will be associated with a particular user
   at the DSKPP server (or a server trusted by, and communicating with
   the DSKPP server), then in order to protect against threats where an
   attacker replaces a client-provided encrypted R_C with his own R'C
   (regardless of whether the public-key variant or the shared-secret
   variant of DSKPP is employed to encrypt the client nonce), the server
   SHOULD not commit to associate a generated K_TOKEN with the given
   token (user) until the user simultaneously has proven both possession
   of a token containing K_TOKEN and some out-of-band provided
   authenticating information (e.g., a temporary password).  For
   example, if the token is a one-time password token, the user could be
   required to authenticate with both a one-time password generated by
   the token and an out-of-band provided temporary PIN in order to have
   the server "commit" to the generated token value for the given user.
   Preferably, the user SHOULD perform this operation from another host
   than the one used to initialize the token, in order to minimize the
   risk of malicious software on the client interfering with the
   process.

   Note: This scenario, wherein the attacker replaces a client-provided
   R_C with his own R'C, does not apply to 2- and 1-pass DSKPP as the
   client does not provide any entropy to K_TOKEN.  The attack as such
   (and its countermeasures) still applies to 2- and 1-pass DSKPP,
   however, as it essentially is a man-in-the-middle attack.

   Another threat arises when an attacker is able to trick a user to
   authenticate to the attacker rather than to the legitimate service
   before the DSKPP protocol run.  If successful, the attacker will then
   be able to impersonate the user towards the legitimate service, and
   subsequently receive a valid DSKPP trigger.  If the public-key
   variant of DSKPP is used, this may result in the attacker being able
   to (after a successful DSKPP protocol run) impersonate the user.
   Ordinary precautions MUST, therefore, be in place to ensure that
   users authenticate only to legitimate services.

5.6.  Additional Considerations Specific to 2- and 1-pass DSKPP

5.6.1.  Client Contributions to K_TOKEN Entropy

   In 4-pass DSKPP, both the client and the server provide randomizing
   material to K_TOKEN , in a manner that allows both parties to verify
   that they did contribute to the resulting key.  In the 1- and 2-pass
   DSKPP versions defined herein, only the server contributes to the
   entropy of K_TOKEN.  This means that a broken or compromised
   (pseudo-)random number generator in the server may cause more damage
   than it would in the 4-pass variant.  Server implementations SHOULD



Nystroem, et al.        Expires December 13, 2007              [Page 59]


Internet-Draft                    DSKPP                        June 2007


   therefore take extreme care to ensure that this situation does not
   occur.

5.6.2.  Key Confirmation

   4-pass DSKPP servers provide key confirmation through the MAC on R_C
   in the <ServerFinished> message.  In the 1- and 2-pass DSKPP variants
   described herein, key confirmation is provided by the MAC including I
   (in the 1-pass case) or R (2-pass case), using K_MAC.

5.6.3.  Server Authentication

   DSKPP servers MUST authenticate themselves whenever a successful
   DSKPP 1- or 2-pass protocol run would result in an existing K_TOKEN
   being replaced by a K_TOKEN', or else a denial-of-service attack
   where an unauthorized DSKPP server replaces a K_TOKEN with another
   key would be possible.  In 1- and 2-pass DSKPP, servers authenticate
   by including the AuthenticationDataType extension containing a MAC as
   described in Section 3.9 above.

5.6.4.  Client Authentication

   A DSKPP server MUST authenticate a client to ensure that K_TOKEN is
   delivered to the intended device.  The following measures SHOULD be
   considered:

   o  When a device certificate is used for client authentication, the
      DSKPP server SHOULD follow standard certificate verification
      processes to ensure that it is a trusted device.

   o  When an Authentication Code is used for client authentication, a
      password dictionary attack on the authentication data is possible.
      When a secure channel, e.g., SSL or TLS, is established between a
      DSKPP client and server, an attacker could successfully brute-
      force guess an Authentication Code, allowing him to illegitimately
      receive K_TOKEN.

   o  The length the of the Authentication Code when used over a non-
      secure channel SHOULD be longer than what is used over a secure
      channel.  When a device, e.g., some mobile phones with small
      screens, cannot handle a long Authentication Code in a user-
      friendly manner, DSKPP SHOULD rely on a secure channel for
      communication.

   o  In the case that a non-secure channel has to be used, the
      Authentication Code SHOULD be sent to the server MAC's with a
      DSKPP server's nonce value.  The Authentication Code and nonce
      value MUST be strong enough to prevent offline brute-force



Nystroem, et al.        Expires December 13, 2007              [Page 60]


Internet-Draft                    DSKPP                        June 2007


      recovery of the Authentication Code from the HMAC data.  Because
      the nonce value is almost public across a non-secure channel, the
      key strength is dependent on the Authentication Code.

5.6.5.  Key Protection in the Passphrase Profile

   The passphrase-based key wrap profile uses the PBKDF2 function from
   [12] to generate an encryption key from a passphrase and salt string.
   The derived key, K_DERIVED is used by the server to encrypt K_TOKEN
   and by the token to decrypt the newly delivered K_TOKEN.  It is
   important to note that passphrase-based encryption is generally
   limited in the security that it provides despite the use of salt and
   iteration count in PBKDF2 to increase the complexity of attack.
   Implementations SHOULD therefore take additional measures to
   strengthen the security of the passphrase-based key wrap profile.
   The following measures SHOULD be considered where applicable:

   o  The passphrase SHOULD be selected well, and usage guidelines such
      as the ones in [15] SHOULD be taken into account.

   o  A different passphrase SHOULD be used for every key initialization
      wherever possible (the use of a global passphrase for a batch of
      tokens SHOULD be avoided, for example).  One way to achieve this
      is to use randomly-generated passphrases.

   o  The passphrase SHOULD be protected well if stored on the server
      and/or on the token and SHOULD be delivered to the token's user
      using secure methods.

   o  User pre-authentication SHOULD be implemented to ensure that
      K_TOKEN is not delivered to a rogue recipient.

   o  The iteration count in PBKDF2 SHOULD be high to impose more work
      for an attacker using brute-force methods (see [12] for
      recommendations).  However, it MUST be noted that the higher the
      count, the more work is required on the legitimate token to
      decrypt the newly delivered K_TOKEN.  Servers MAY use relatively
      low iteration counts to accommodate tokens with limited processing
      power such as some PDA and cell phones when other security
      measures are implemented and the security of the passphrase-based
      key wrap method is not weakened.

   o  Transport level security (e.g.  TLS) SHOULD be used where possible
      to protect a 2-pass or 1-pass protocol run.  Transport level
      security provides a second layer of protection for the newly
      generated K_TOKEN.





Nystroem, et al.        Expires December 13, 2007              [Page 61]


Internet-Draft                    DSKPP                        June 2007


6.  IANA Considerations

   This document calls for registration of new URNs within the IETF sub-
   namespace per RFC3553 [16].  The following URNs are RECOMMENDED:

   o  DSKPP XML schema: "urn:ietf:params:xml:schema:keyprov:protocol"

   o  DSKPP XML namespace: "urn:ietf:params:xml:ns:keyprov:protocol"











































Nystroem, et al.        Expires December 13, 2007              [Page 62]


Internet-Draft                    DSKPP                        June 2007


7.  Intellectual Property Considerations

   RSA and RSA Security are registered trademarks or trademarks of RSA
   Security Inc. in the United States and/or other countries.  The names
   of other products and services mentioned may be the trademarks of
   their respective owners.













































Nystroem, et al.        Expires December 13, 2007              [Page 63]


Internet-Draft                    DSKPP                        June 2007


8.  Acknowledgements

   Thanks to all the members of OATH [17] and participants of OTPS
   workshops for their review and comments related to this document.















































Nystroem, et al.        Expires December 13, 2007              [Page 64]


Internet-Draft                    DSKPP                        June 2007


9.  References

9.1.  Normative references

   [1]   W3C, "XML Signature Syntax and Processing", W3C Recommendation,
         February 2002,
         <http://www.w3.org/TR/2002/REC-xmldsig-core-20020212/>.

   [2]   Davis, M. and M. Duerst, "Unicode Normalization Forms",
         March 2001,
         <http://www.unicode.org/unicode/reports/tr15/tr15-21.html>.

   [3]   W3C, "XML Encryption Syntax and Processing",
         W3C Recommendation, December 2002,
         <http://www.w3.org/TR/2002/REC-xmldsig-core-20020212/>.

9.2.  Informative references

   [4]   RSA, The Security Division of EMC, "Cryptographic Token Key
         Initialization Protocol (CT-KIP)", November 2006,
         <http://www.ietf.org/rfc/rfc4758.txt>.

   [5]   RSA Laboratories, "Cryptographic Token Interface Standard",
         PKCS #11 Version 2.20, June 2004,
         <http://www.rsasecurity.com/rsalabs/pkcs/>.

   [6]   "Key words for use in RFCs to Indicate Requirement Levels",
         BCP 14, RFC 2119, March 1997,
         <http://www.ietf.org/rfc/rfc2119.txt>.

   [7]   "Portable Symmetric Key Container", 2005, <http://www.ietf.org/
         internet-drafts/
         draft-pei-keyprov-dynamic-symkey-prov-protocol-00.txt>.

   [8]   RSA Laboratories, "PKCS #11 Mechanisms for the Cryptographic
         Token Key Initialization Protocol", PKCS #11 Version 2.20
         Amd.2, December 2005,
         <http://www.rsasecurity.com/rsalabs/pkcs/>.

   [9]   "Personal Information Exchange Syntax Standard", PKCS #12
         Version 1.0, 2005,
         <ftp://ftp.rsasecurity.com/pub/pkcs/pkcs-12/pkcs-12v1.pdf>.

   [10]  RSA Laboratories, "XML Schema for PKCS #5 Version 2.0", PKCS #5
         Version 2.0 Amd.1 (FINAL DRAFT), October 2006,
         <http://www.rsasecurity.com/rsalabs/pkcs/>.

   [11]  RSA Laboratories, "Frequently Asked Questions About Today's



Nystroem, et al.        Expires December 13, 2007              [Page 65]


Internet-Draft                    DSKPP                        June 2007


         Cryptography",  Version 4.1, 2000.

   [12]  RSA Laboratories, "Password-Based Cryptography Standard",
         PKCS #5 Version 2.0, March 1999,
         <http://www.rsasecurity.com/rsalabs/pkcs/>.

   [13]  RSA Laboratories, "RSA Cryptography Standard", PKCS #1 Version
         2.1, June 2002, <http://www.rsasecurity.com/rsalabs/pkcs/>.

   [14]  Fielding, R., Gettys, J., Mogul, J., Frystyk, H., Masinter, L.,
         Leach, P., and T. Berners-Lee, "Hypertext Transfer Protocol --
         HTTP/1.1", RFC 2616, June 1999,
         <http://www.ietf.org/rfc/rfc2616.txt>.

   [15]  National Institute of Standards and Technology, "Password
         Usage", FIPS 112, May 1985,
         <http://www.itl.nist.gov/fipspubs/fip112.htm>.

   [16]  Mealling, M., Masinter, L., Hardie, T., and G. Klyne, "An IETF
         URN Sub-namespace for Registered Protocol Parameters",
         RFC 3553, BCP 73, June 2003.

   [17]  "Initiative for Open AuTHentication", 2005,
         <http://www.openauthentication.org>.

   [18]  National Institute of Standards and Technology, "Specification
         for the Advanced Encryption Standard (AES)", FIPS 197,
         November 2001,
         <http://csrc.nist.gov/publications/fips/fips197/fips-197.pdf>.

   [19]  Krawzcyk, H., Bellare, M., and R. Canetti, "HMAC: Keyed-Hashing
         for Message Authentication", RFC 2104, February 1997.

   [20]  Iwata, T. and K. Kurosawa, "OMAC: One-Key CBC MAC. In Fast
         Software Encryption", FSE 2003, Springer-Verlag , 2003,
         <http://crypt.cis.ibaraki.ac.jp/omac/docs/omac.pdf>.

   [21]  National Institute of Standards and Technology, "Secure Hash
         Standard", FIPS 180-2, February 2004, <http://csrc.nist.gov/
         publications/fips/fips180-2/fips180-2withchangenotice.pdf>.











Nystroem, et al.        Expires December 13, 2007              [Page 66]


Internet-Draft                    DSKPP                        June 2007


Appendix A.  DSKPP Schema

 <?xml version="1.0" encoding="UTF-8"?>

 <xs:schema
   targetNamespace="urn:ietf:params:xml:ns:keyprov:protocol"
   xmlns:dskpp="urn:ietf:params:xml:ns:keyprov:protocol"
   xmlns:pskc="urn:ietf:params:xml:ns:keyprov:protocol"
   xmlns:xs="http://www.w3.org/2001/XMLSchema"
   xmlns:ds="http://www.w3.org/2000/09/xmldsig#">

   <xs:import namespace="http://www.w3.org/2000/09/xmldsig#"
     schemaLocation="http://www.w3.org/TR/2002/
     REC-xmldsig-core-20020212/xmldsig-core-schema.xsd"/>

   <!-- Basic types -->
   <xs:complexType name="AbstractRequestType" abstract="true">
     <xs:attribute name="Version" type="VersionType" use="required"/>
   </xs:complexType>

   <xs:complexType name="AbstractResponseType" abstract="true">
     <xs:attribute name="Version" type="VersionType" use="required"/>
     <xs:attribute name="SessionID" type="IdentifierType"/>
     <xs:attribute name="Status" type="StatusCode" use="required"/>
   </xs:complexType>

   <xs:simpleType name="VersionType">
     <xs:restriction base="xs:string">
       <xs:pattern value="\d{1,2}\.\d{1,3}"/>
     </xs:restriction>
   </xs:simpleType>

   <xs:simpleType name="IdentifierType">
     <xs:restriction base="xs:string">
       <xs:maxLength value="128"/>
     </xs:restriction>
   </xs:simpleType>

   <xs:simpleType name="StatusCode">
     <xs:restriction base="xs:string">
       <xs:enumeration value="Continue"/>
       <xs:enumeration value="Success"/>
       <xs:enumeration value="Abort"/>
       <xs:enumeration value="AccessDenied"/>
       <xs:enumeration value="MalformedRequest"/>
       <xs:enumeration value="UnknownRequest"/>
       <xs:enumeration value="UnknownCriticalExtension"/>
       <xs:enumeration value="UnsupportedVersion"/>



Nystroem, et al.        Expires December 13, 2007              [Page 67]


Internet-Draft                    DSKPP                        June 2007


       <xs:enumeration value="NoSupportedKeyTypes"/>
       <xs:enumeration value="NoSupportedEncryptionAlgorithms"/>
       <xs:enumeration value="NoSupportedMACAlgorithms"/>
       <xs:enumeration value="NoProtocolVariants"/>
       <xs:enumeration value="NoSupportedSecretContainers"/>
       <xs:enumeration value="AuthenticationDataInvalid"/>
       <xs:enumeration value="InitializationFailed"/>
     </xs:restriction>
   </xs:simpleType>

   <xs:complexType name="DeviceIdentifierDataType">
     <xs:choice>
       <xs:element name="DeviceID" type="pskc:DeviceIdType"/>
       <xs:any namespace="##other" processContents="strict"/>
     </xs:choice>
   </xs:complexType>

   <xs:simpleType name="PlatformType">
     <xs:restriction base="xs:string">
       <xs:enumeration value="Hardware"/>
       <xs:enumeration value="Software"/>
       <xs:enumeration value="Unspecified"/>
     </xs:restriction>
   </xs:simpleType>

   <xs:complexType name="TokenPlatformInfoType">
     <xs:attribute name="KeyLocation" type="dskpp:PlatformType"/>
     <xs:attribute name="AlgorithmLocation" type="dskpp:PlatformType"/>
   </xs:complexType>

   <xs:simpleType name="NonceType">
     <xs:restriction base="xs:base64Binary">
       <xs:minLength value="16"/>
     </xs:restriction>
   </xs:simpleType>

   <xs:complexType name="AlgorithmsType">
     <xs:sequence maxOccurs="unbounded">
       <xs:element name="Algorithm" type="AlgorithmType"/>
     </xs:sequence>
   </xs:complexType>

   <xs:simpleType name="AlgorithmType">
     <xs:restriction base="xs:anyURI"/>
   </xs:simpleType>

   <xs:complexType name="ProtocolVariantsType">
     <xs:sequence>



Nystroem, et al.        Expires December 13, 2007              [Page 68]


Internet-Draft                    DSKPP                        June 2007


       <xs:element name="TwoPass" type="dskpp:TwoPassSupportType"
         minOccurs="0"/>
       <xs:element name="FourPass" minOccurs="0"/>
     </xs:sequence>
   </xs:complexType>

   <xs:complexType name="TwoPassSupportType">
     <xs:sequence maxOccurs="unbounded">
       <xs:element name="SupportedKeyInitializationMethod"
         type="xs:anyURI"/>
       <xs:element name="Payload" minOccurs="0"/>
     </xs:sequence>
   </xs:complexType>

   <xs:complexType name="SecretContainersFormatType">
     <xs:sequence maxOccurs="unbounded">
       <xs:element name="SecretContainerFormat"
         type="dskpp:SecretContainerFormatType"/>
     </xs:sequence>
   </xs:complexType>

   <xs:simpleType name="SecretContainerFormatType">
     <xs:restriction base="xs:anyURI"/>
   </xs:simpleType>

   <xs:complextype name="AuthenticationDataType">
     <xs:sequence>
       <xs:element name="ClientID" type="dskpp:IdentifierType"
         minOccurs="0"/>
       <xs:choice minOccurs="0">
         <xs:element name="AuthenticationCode"
           type="dskpp:AuthenticationCodeType"/>
         <xs:element name="AuthenticationCodeDigest"
           type="dskpp:AuthenticationCodeDigestType"/>
         <xs:element name="AuthenticationCodeMac"
           type="dskpp:AuthenticationCodeMacType"/>
         <xs:element name="AuthenticationCertificate"
           type="ds:KeyInfoType"/>
       </xs:choice>
     </xs:sequence>
   </xs:complexType>

   <xs:simpleType name="AuthenticationCodeType">
     <xs:restriction base="xs:string">
       <xs:maxLength value="20"/>
     </xs:restriction>
   </xs:simpleType>




Nystroem, et al.        Expires December 13, 2007              [Page 69]


Internet-Draft                    DSKPP                        June 2007


   <xs:complexType name="AuthenticationCodeDigestType">
     <xs:simpleContent>
       <xs:extension base="xs:base64Binary">
         <xs:attribute name="HashAlgorithm" type="xs:anyURI"
           use="required"/>
       </xs:extension>
     </xs:simpleContent>
   </xs:complexType>

   <xs:complexType name="AuthenticationCodeMacType">
     <xs:sequence>
       <xs:element name="Data" type="xs:base64Binary">
       <xs:element name="Nonce" type="dskpp:NonceType"/>
     </xs:sequence>
     <attribute name="HMACAlgorithm" type="xs:anyURI"
       use="required"/>
     <attribute name="NonceId" type="dskpp:IdentifierType"/>
   </xs:complexType>

   <xs:complexType name="PayloadType">
     <xs:choice>
       <xs:element name="Nonce" type="dskpp:NonceType"/>
       <xs:any namespace="##other" processContents="strict"/>
     </xs:choice>
   </xs:complexType>

   <xs:complexType name="MacType">
     <xs:simpleContent>
       <xs:extension base="xs:base64Binary">
         <xs:attribute name="MacAlgorithm" type="xs:anyURI"/>
       </xs:extension>
     </xs:simpleContent>
   </xs:complexType>

   <xs:complexType name="SecretContainerType">
     <xs:choice>
       <xs:element name="SecretContainer"
         type="pskc:SecretContainerType"/>
       <xs:element name="##other" processContents="strict"/>
     </xs:choice>
   </xs:complexType>

   <xs:complexType name="InitializationTriggerType">
     <xs:sequence>
       <xs:element name="DeviceIdentifierData"
         type="dskpp:DeviceIdentifierDataType" minOccurs="0"/>
       <xs:element name="KeyID" type="xs:base64Binary" minOccurs="0"/>
       <xs:element name="TokenPlatformInfo"



Nystroem, et al.        Expires December 13, 2007              [Page 70]


Internet-Draft                    DSKPP                        June 2007


         type="dskpp:TokenPlatformInfoType" minOccurs="0"/>
       <xs:element name="TriggerNonce" type="dskpp:NonceType"/>
       <xs:element name="DSKPP_URL" type="xs:anyURI" minOccurs="0"/>
       <xs:any namespace="##other" processContents="strict"
         minOccurs="0"/>
     </xs:sequence>
   </xs:complexType>

   <!-- Extension types -->
   <xs:complexType name="ExtensionsType">
     <xs:sequence maxOccurs="unbounded">
       <xs:element name="Extension" type="AbstractExtensionType"/>
     </xs:sequence>
   </xs:complexType>

   <xs:complexType name="AbstractExtensionType" abstract="true">
     <xs:attribute name="Critical" type="xs:boolean"/>
   </xs:complexType>

   <xs:complexType name="ClientInfoType">
     <xs:complexContent>
       <xs:extension base="AbstractExtensionType">
         <xs:sequence>
           <xs:element name="Data"
             type="xs:base64Binary"/>
         </xs:sequence>
       </xs:extension>
     </xs:complexContent>
   </xs:complexType>

   <xs:complexType name="ServerInfoType">
     <xs:complexContent>
       <xs:extension base="AbstractExtensionType">
         <xs:sequence>
           <xs:element name="Data"
             type="xs:base64Binary"/>
         </xs:sequence>
       </xs:extension>
     </xs:complexContent>
   </xs:complexType>

   <xs:complexType name="KeyInitializationDataType">
     <xs:annotation>
       <xs:documentation xml:lang="en">
         This extension is only valid in ServerFinished PDUs. It
         contains key initialization data and its presence results in a
         two-pass (or one-pass, if no ClientHello was sent) DSKPP
         exchange.



Nystroem, et al.        Expires December 13, 2007              [Page 71]


Internet-Draft                    DSKPP                        June 2007


       </xs:documentation>
     </xs:annotation>
     <xs:complexContent>
       <xs:extension base="dskpp:AbstractExtensionType">
         <xs:sequence>
           <xs:element name="KeyInitializationMethod" type="xs:anyURI"/>
           <xs:element name="Payload"/>
         </xs:sequence>
       </xs:extension>
     </xs:complexContent>
   </xs:complexType>

   <!-- DSKPP PDUs -->

   <!-- DSKPP trigger -->
   <xs:element name="DSKPPTrigger" type="DSKPPTriggerType"/>

   <xs:complexType name="DSKPPTriggerType">
     <xs:annotation>
       <xs:documentation xml:lang="en">
         Message used to trigger the device to initiate a
         DSKPP protocol run.
       </xs:documentation>
     </xs:annotation>
     <xs:sequence>
       <xs:choice>
         <xs:element name="InitializationTrigger"
           type="dskpp:InitializationTriggerType"/>
         <xs:any namespace="##other" processContents="strict"/>
       </xs:choice>
     </xs:sequence>
     <xs:attribute name="Version" type="dskpp:VersionType"/>
   </xs:complexType>

   <!-- ClientHello PDU -->
   <xs:element name="ClientHello" type="ClientHelloPDU"/>

   <xs:complexType name="ClientHelloPDU">
     <xs:annotation>
       <xs:documentation xml:lang="en">
         Message sent from DSKPP client to DSKPP server to initiate a
         DSKPP session.
       </xs:documentation>
     </xs:annotation>
     <xs:complexContent>
       <xs:extension base="AbstractRequestType">
         <xs:sequence>
           <xs:element name="DeviceIdentifierData"



Nystroem, et al.        Expires December 13, 2007              [Page 72]


Internet-Draft                    DSKPP                        June 2007


             type="dskpp:DeviceIdentifierDataType" minOccurs="0"/>
           <xs:element name="KeyID" type="xs:base64Binary"
             minOccurs="0"/>
           <xs:element name="ClientNonce" type="dskpp:NonceType"
             minOccurs="0"/>
           <xs:element name="TriggerNonce" type="dskpp:NonceType"
             minOccurs="0"/>
           <xs:element name="SupportedKeyTypes"
             type="dskpp:AlgorithmsType"/>
           <xs:element name="SupportedEncryptionAlgorithms"
             type="dskpp:AlgorithmsType"/>
           <xs:element name="SupportedMACAlgorithms"
             type="dskpp:AlgorithmsType"/>
           <xs:element name="SupportedProtocolVariants"
             type="dskpp:ProtocolVariantsType" minOccurs="0"/>
           <xs:element name="SupportedSecretContainers"
             type="dskpp:SecretContainersFormatType" minOccurs="0"/>
           <xs:element name="AuthenticationData"
             type="dskpp:AuthenticationDataType" minOccurs="0"/>
           <xs:element name="Extensions" type="dskpp:ExtensionsType"
             minOccurs="0"/>
         </xs:sequence>
       </xs:extension>
     </xs:complexContent>
   </xs:complexType>

   <!-- ServerHello PDU -->
   <xs:element name="ServerHello" type="ServerHelloPDU"/>

   <xs:complexType name="ServerHelloPDU">
     <xs:annotation>
       <xs:documentation xml:lang="en">
         Message sent from DSKPP server to DSKPP client
         in response to a received ClientHello PDU.
       </xs:documentation>
     </xs:annotation>
     <xs:complexContent>
       <xs:extension base="AbstractResponseType">
         <xs:sequence minOccurs="0">
           <xs:element name="KeyType"
             type="dskpp:AlgorithmType"/>
           <xs:element name="EncryptionAlgorithm"
             type="dskpp:AlgorithmType"/>
           <xs:element name="MacAlgorithm"
             type="dskpp:AlgorithmType"/>
           <xs:element name="EncryptionKey"
             type="ds:KeyInfoType"/>
           <xs:element name="SecretContainerFormat"



Nystroem, et al.        Expires December 13, 2007              [Page 73]


Internet-Draft                    DSKPP                        June 2007


             type="dskpp:SecretContainerFormatType"/>
           <xs:element name="Payload"
             type="dskpp:PayloadType"/>
           <xs:element name="Extensions"
             type="dskpp:ExtensionsType" minOccurs="0"/>
           <xs:element name="Mac" type="dskpp:MacType"
             minOccurs="0"/>
         </xs:sequence>
       </xs:extension>
     </xs:complexContent>
   </xs:complexType>

   <!-- ClientNonce PDU -->
   <xs:element name="ClientNonce" type="ClientNoncePDU"/>

   <xs:complexType name="ClientNoncePDU">
     <xs:annotation>
       <xs:documentation xml:lang="en">
         Second message sent from DSKPP client to
         DSKPP server in a DSKPP session.
       </xs:documentation>
     </xs:annotation>
     <xs:complexContent>
       <xs:extension base="AbstractRequestType">
         <xs:sequence>
           <xs:element name="EncryptedNonce"
             type="xs:base64Binary"/>
           <xs:element name="AuthenticationData"
             type="dskpp:AuthenticationDataType" minOccurs="0"/>
           <xs:element name="Extensions"
             type="dskpp:ExtensionsType" minOccurs="0"/>
         </xs:sequence>
         <xs:attribute name="SessionID" type="dskpp:IdentifierType"
           use="required"/>
       </xs:extension>
     </xs:complexContent>
   </xs:complexType>

   <!-- ServerFinished PDU -->
   <xs:element name="ServerFinished" type="ServerFinishedPDU"/>

   <xs:complexType name="ServerFinishedPDU">
     <xs:annotation>
       <xs:documentation xml:lang="en">
         Final message sent from DSKPP server to
         DSKPP client in a DSKPP session.
       </xs:documentation>
     </xs:annotation>



Nystroem, et al.        Expires December 13, 2007              [Page 74]


Internet-Draft                    DSKPP                        June 2007


     <xs:complexContent>
       <xs:extension base="AbstractResponseType">
         <xs:sequence minOccurs="0">
           <xs:element name="SecretContainer"
             type="dskpp:SecretContainerType"/>
           <xs:element name="Extensions"
             type="dskpp:ExtensionsType" minOccurs="0"/>
           <xs:element name="Mac"
             type="dskpp:MacType"/>
         </xs:sequence>
       </xs:extension>
     </xs:complexContent>
   </xs:complexType>

 </xs:schema>




































Nystroem, et al.        Expires December 13, 2007              [Page 75]


Internet-Draft                    DSKPP                        June 2007


Appendix B.  Key Initialization Profiles of DSKPP

B.1.  Introduction

   This appendix introduces three profiles of DSKPP for key
   initialization.  They MAY all be used for two- as well as one-pass
   initialization of cryptographic tokens.  Further profiles MAY be
   defined by external entities or through the IETF process.

B.2.  Key Transport Profile

B.2.1.  Introduction

   This profile initializes the cryptographic token with a symmetric
   key, K_TOKEN, through key transport and key derivation.  The key
   transport is carried out using a public key, K_CLIENT, whose private
   key part resides in the token as the transport key.  A key K from
   which two keys, K_TOKEN and K_MAC are derived SHALL be transported.

B.2.2.  Identification

   This profile SHALL be identified with the following URN:

   urn:ietf:params:xml:schema:keyprov:protocol#transport

B.2.3.  Payloads

   In the two-pass version of DSKPP, the client SHALL send a payload
   associated with this key initialization method.  The payload SHALL be
   of type ds:KeyInfoType ([1]), and only those choices of the ds:
   KeyInfoType that identify a public key are allowed.  The ds:
   X509Certificate option of the ds:X509Data alternative is RECOMMENDED
   when the public key corresponding to the private key on the
   cryptographic token has been certified.

   The server payload associated with this key initialization method
   SHALL be of type xenc:EncryptedKeyType ([3]), and only those
   encryption methods utilizing a public key that are supported by the
   DSKPP client (as indicated in the <SupportedEncryptionAlgorithms>
   element of the <ClientHello> message in the case of 2-pass DSKPP, or
   as otherwise known in the case of 1-pass DSKPP) are allowed as values
   for the <xenc:EncryptionMethod> element.  Further, in the case of
   2-pass DSKPP, the <ds:KeyInfo> element SHALL contain the same value
   (i.e. identify the same public key) as the <Payload> of the
   corresponding supported key initialization method in the
   <ClientHello> message that triggered the response.  The
   <CarriedKeyName> element MAY be present, but SHALL, when present,
   contain the same value as the <KeyID> element of the <ServerFinished>



Nystroem, et al.        Expires December 13, 2007              [Page 76]


Internet-Draft                    DSKPP                        June 2007


   message.  The Type attribute of the xenc:EncryptedKeyType SHALL be
   present and SHALL identify the type of the wrapped token key.  The
   type SHALL be one of the types supported by the DSKPP client (as
   reported in the <SupportedKeyTypes> of the preceding <ClientHello>
   message in the case of 2-pass DSKPP, or as otherwise known in the
   case of 1-pass DSKPP).  The transported key SHALL consist of two
   parts of equal length.  The first half constitutes K_MAC and the
   second half constitutes K_TOKEN.  The length of K_TOKEN (and hence
   also the length of K_MAC) is determined by the type of K_TOKEN.

   DSKPP servers and tokens supporting this profile MUST support the
   http://www.w3.org/2001/04/xmlenc#rsa-1_5 key-wrapping mechanism
   defined in [3].

   When this profile is used, the MacAlgorithm attribute of the <Mac>
   element of the <ServerFinished> message MUST be present and MUST
   identify the selected MAC algorithm.  The selected MAC algorithm MUST
   be one of the MAC algorithms supported by the DSKPP client (as
   indicated in the <SupportedMACAlgorithms> element of the
   <ClientHello> message in the case of 2-pass DSKPP, or as otherwise
   known in the case of 1-pass DSKPP).  The MAC SHALL be calculated as
   described in Section 3.9

   In addition, DSKPP servers MUST include the AuthenticationDataType
   element (see further Section 3.9) in their <ServerFinished> messages
   whenever a successful protocol run will result in an existing K_TOKEN
   being replaced.

B.3.  Key wrap profile

B.3.1.  Introduction

   This profile initializes the cryptographic token with a symmetric
   key, K_TOKEN, through key wrap and key derivation.  The key wrap
   SHALL be carried out using a (symmetric) key-wrapping key, K_SHARED,
   known in advance by both the token and the DSKPP server.  A key K
   from which two keys, K_TOKEN and K_MAC are derived SHALL be wrapped.

B.3.2.  Identification

   This profile SHALL be identified with the following URI:

   urn:ietf:params:xml:schema:keyprov:protocol#wrap

B.3.3.  Payloads

   In the 2-pass version of DSKPP, the client SHALL send a payload
   associated with this key initialization method.  The payload SHALL be



Nystroem, et al.        Expires December 13, 2007              [Page 77]


Internet-Draft                    DSKPP                        June 2007


   of type ds:KeyInfoType ([1]), and only those choices of the ds:
   KeyInfoType that identify a symmetric key are allowed.  The ds:
   KeyName alternative is RECOMMENDED.

   The server payload associated with this key initialization method
   SHALL be of type xenc:EncryptedKeyType ([3]), and only those
   encryption methods utilizing a symmetric key that are supported by
   the DSKPP client (as indicated in the <SupportedEncryptionAlgorithms>
   element of the <ClientHello> message in the case of 2-pass DSKPP, or
   as otherwise known in the case of 1-pass DSKPP) are allowed as values
   for the <xenc:EncryptionMethod> element.  Further, in the case of
   2-pass DSKPP, the <ds:KeyInfo> element SHALL contain the same value
   (i.e. identify the same symmetric key) as the <Payload> of the
   corresponding supported key initialization method in the
   <ClientHello> message that triggered the response.  The
   <CarriedKeyName> element MAY be present, and SHALL, when present,
   contain the same value as the <KeyID> element of the <ServerFinished>
   message.  The Type attribute of the xenc:EncryptedKeyType SHALL be
   present and SHALL identify the type of the wrapped token key.  The
   type SHALL be one of the types supported by the DSKPP client (as
   reported in the <SupportedKeyTypes> of the preceding <ClientHello>
   message in the case of 2-pass DSKPP, or as otherwise known in the
   case of 1-pass DSKPP).  The wrapped key SHALL consist of two parts of
   equal length.  The first half constitutes K_MAC and the second half
   constitutes K_TOKEN.  The length of K_TOKEN (and hence also the
   length of K_MAC) is determined by the type of K_TOKEN.

   DSKP servers and tokens supporting this profile MUST support the
   http://www.w3.org/2001/04/xmlenc#kw-aes128 key-wrapping mechanism
   defined in [3].

   When this profile is used, the MacAlgorithm attribute of the <Mac>
   element of the <ServerFinished> message MUST be present and MUST
   identify the selected MAC algorithm.  The selected MAC algorithm MUST
   be one of the MAC algorithms supported by the DSKPP client (as
   indicated in the <SupportedMACAlgorithms> element of the
   <ClientHello> message in the case of 2-pass DSKPP, or as otherwise
   known in the case of 1-pass DSKPP).  The MAC SHALL be calculated as
   described in Section 3.9

   In addition, DSKPP servers MUST include the AuthenticationDataType
   element (see further Section 3.9) in their <ServerFinished> messages
   whenever a successful protocol run will result in an existing K_TOKEN
   being replaced.







Nystroem, et al.        Expires December 13, 2007              [Page 78]


Internet-Draft                    DSKPP                        June 2007


B.4.  Passphrase-based key wrap profile

B.4.1.  Introduction

   This profile is a variation of the key wrap profile.  It initializes
   the cryptographic token with a symmetric key, K_TOKEN, through key
   wrap and key derivation, using a passphrase-derived key-wrapping key,
   K_DERIVED.  The passphrase is known in advance by both the token user
   and the DSKPP server.  To preserve the property of not exposing
   K_TOKEN to any other entity than the DSKPP server and the token
   itself, the method SHOULD be employed only when the token contains
   facilities (e.g. a keypad) for direct entry of the passphrase.  A key
   K from which two keys, K_TOKEN and K_MAC are derived SHALL be
   wrapped.

B.4.2.  Identification

   This profile SHALL be identified with the following URI:

   urn:ietf:params:xml:schema:keyprov:protocol#passphrase-wrap

B.4.3.  Payloads

   In the 2-pass version of DSKPP, the client SHALL send a payload
   associated with this key initialization method.  The payload SHALL be
   of type ds:KeyInfoType ([1]).  The ds:KeyName option SHALL be used
   and the key name SHALL identify the passphrase that will be used by
   the server to generate the key-wrapping key.  As an example, the
   identifier could be a user identifier or a registration identifier
   issued by the server to the user during a session preceding the DSKPP
   protocol run.

   The server payload associated with this key initialization method
   SHALL be of type xenc:EncryptedKeyType ([3]), and only those
   encryption methods utilizing a passphrase to derive the key-wrapping
   key that are supported by the DSKPP client (as indicated in the
   <SupportedEncryptionAlgorithms> element of the <ClientHello> message
   in the case of 2-pass DSKPP, or as otherwise known in the case of
   1-pass DSKPP) are allowed as values for the <xenc:EncryptionMethod>
   element.  Further, in the case of 2-pass DSKPP, the <ds:KeyInfo>
   element SHALL contain the same value (i.e. identify the same
   passphrase) as the <Payload> of the corresponding supported key
   initialization method in the <ClientHello> message that triggered the
   response.  The <CarriedKeyName> element MAY be present, and SHALL,
   when present, contain the same value as the <KeyID> element of the
   <ServerFinished> message.  The Type attribute of the xenc:
   EncryptedKeyType SHALL be present and SHALL identify the type of the
   wrapped token key.  The type SHALL be one of the types supported by



Nystroem, et al.        Expires December 13, 2007              [Page 79]


Internet-Draft                    DSKPP                        June 2007


   the DSKPP client (as reported in the <SupportedKeyTypes> of the
   preceding <ClientHello> message in the case of 2-pass DSKPP, or as
   otherwise known in the case of 1-pass DSKPP).  The wrapped key SHALL
   consist of two parts of equal length.  The first half constitutes
   K_MAC and the second half constitutes K_TOKEN.  The length of K_TOKEN
   (and hence also the length of K_MAC) is determined by the type of
   K_TOKEN.

   DSKPP servers and tokens supporting this profile MUST support the
   PBES2 password based encryption scheme defined in [12] (and
   identified as
   http://www.rsasecurity.com/rsalabs/pkcs/schemas/pkcs-5#pbes2 in
   [10]), the PBKDF2 passphrase-based key derivation function also
   defined in [12] (and identified as
   http://www.rsasecurity.com/rsalabs/pkcs/schemas/pkcs-5#pbkdf2 in
   [10]), and the http://www.w3.org/2001/04/xmlenc#kw-aes128 key-
   wrapping mechanism defined in [3].

   When this profile is used, the MacAlgorithm attribute of the <Mac>
   element of the <ServerFinished> message MUST be present and MUST
   identify the selected MAC algorithm.  The selected MAC algorithm MUST
   be one of the MAC algorithms supported by the DSKPP client (as
   indicated in the <SupportedMACAlgorithms> element of the
   <ClientHello> message in the case of 2-pass DSKPP, or as otherwise
   known in the case of 1-pass DSKPP).  The MAC SHALL be calculated as
   described in Section 3.9

   In addition, DSKPP servers MUST include the AuthenticationDataType
   element (see further Section 3.9) in their <ServerFinished> messages
   whenever a successful protocol run will result in an existing K_TOKEN
   being replaced.




















Nystroem, et al.        Expires December 13, 2007              [Page 80]


Internet-Draft                    DSKPP                        June 2007


Appendix C.  Example Messages

   All examples are syntactically correct.  MAC and cipher values are
   fictitious however.

C.1.  Example Messages in a Four-pass Exchange

   The examples below illustrate a complete four-pass DSKPP exchange.

C.1.1.  Example of a DSKPP Initialization (Trigger) Message

   <?xml version="1.0" encoding="UTF-8"?>
   <dskpp:DSKPPTrigger Version="1.0"
     xmlns:dskpp="urn:ietf:params:xml:schema:keyprov:protocol"
     xmlns:pskc="urn:ietf:params:xml:ns:keyprov:container"
     xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="urn:ietf:params:xml:schema:keyprov:protocol">
     <InitializationTrigger>
       <DeviceIdentifierData>
         <pskc:DeviceID>
           <Manufacturer>ManufacturerABC</Manufacturer>
           <SerialNo>XL0000000001234</SerialNo>
           <Model>U2</Model>
         </DeviceID>
       </DeviceIdentifierData>
       <TriggerNonce>112dsdfwf312asder394jw==</TriggerNonce>
     </InitializationTrigger>
   </dskpp:DSKPPTrigger>























Nystroem, et al.        Expires December 13, 2007              [Page 81]


Internet-Draft                    DSKPP                        June 2007


C.1.2.  Example of a <ClientHello> Message

   <?xml version="1.0" encoding="UTF-8"?>
   <dskpp:ClientHello Version="1.0"
     xmlns:dskpp="urn:ietf:params:xml:schema:keyprov:protocol"
     xmlns:pskc="urn:ietf:params:xml:ns:keyprov:container"
     xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="urn:ietf:params:xml:schema:keyprov:protocol"
     xmlns:ds="http://www.w3.org/2000/09/xmldsig#">
     <DeviceIdentifierData>
       <pskc:DeviceID>
         <Manufacturer>ManufacturerABC</Manufacturer>
         <SerialNo>XL0000000001234</SerialNo>
         <Model>U2</Model>
       </DeviceID>
     </DeviceIdentifierData>
     <TriggerNonce>112dsdfwf312asder394jw==</TriggerNonce>
     <SupportedKeyTypes>
       <Algorithm>http://www.rsa.com/rsalabs/otps/schemas/2005/09/
         otps-wst#SecurID-AES</Algorithm>
       <Algorithm>http://www.openauthentication.org/OATH/2006/10/PSKC#
         HOTP</Algorithm>
     </SupportedKeyTypes>
     <SupportedEncryptionAlgorithms>
       <Algorithm>http://www.w3.org/2001/05/xmlenc#rsa_1_5</Algorithm>
       <Algorithm>urn:ietf:params:xml:schema:keyprov:protocol#
         dskpp-prf-aes</Algorithm>
     </SupportedMACAlgorithms>
       <Algorithm>urn:ietf:params:xml:schema:keyprov:protocol#
         dskpp-prf-aes</Algorithm>
     </SupportedMACAlgorithms>
     <SupportedProtocolVariants>FourPass</SupportedProtocolVariants>
     <SupportedSecretContainers>
       <SecretContainerFormat>
         urn:ietf:params:xml:schema:keyprov:container
       </SecretContainerFormat>
     </SupportedSecretContainers>
     <AuthenticationData>
       <AuthenticationCode>1erd354657689102abcd</AuthenticationCode>
     </AuthenticationData>
   </dskpp:ClientHello>










Nystroem, et al.        Expires December 13, 2007              [Page 82]


Internet-Draft                    DSKPP                        June 2007


C.1.3.  Example of a <ServerHello> Message

   <?xml version="1.0" encoding="UTF-8"?>
   <dskpp:ServerHello Version="1.0" SessionID="4114" Status="Success"
     xmlns:dskpp="urn:ietf:params:xml:schema:keyprov:protocol"
     xmlns:pskc="urn:ietf:params:xml:ns:keyprov:container"
     xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="urn:ietf:params:xml:schema:keyprov:protocol"
     xmlns:ds="http://www.w3.org/2000/09/xmldsig#">
     <KeyType>
       http://www.rsa.com/rsalabs/otps/schemas/2005/09/otps-wst#
         SecurID-AES
     </KeyType>
     <EncryptionAlgorithm>
       urn:ietf:params:xml:schema:keyprov:protocol#dskpp-prf-aes
     </EncryptionAlgorithm>
     <MacAlgorithm>
       urn:ietf:params:xml:schema:keyprov:protocol#dskpp-prf-aes
     </MacAlgorithm>
     <EncryptionKey>
       <ds:KeyName>KEY-1</ds:KeyName>
     </EncryptionKey>
     <SecretContainerFormat>
       urn:ietf:params:xml:schema:keyprov:container
     </SecretContainerFormat>
     <Payload>
       <Nonce>qw2ewasde312asder394jw==</Nonce>
     </Payload>
   </dskpp:ServerHello>

C.1.4.  Example of a <ClientNonce> Message

   <?xml version="1.0" encoding="UTF-8"?>
   <dskpp:ClientNonce Version="1.0" SessionID="4114"
     xmlns:dskpp="urn:ietf:params:xml:schema:keyprov:protocol"
     xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="urn:ietf:params:xml:schema:keyprov:protocol"
     xmlns:ds="http://www.w3.org/2000/09/xmldsig#">
     <EncryptedNonce>VXENc+Um/9/NvmYKiHDLaErK0gk=</EncryptedNonce>
     <AuthenticationData>
       <AuthenticationCode>1erd354657689102abcd</AuthenticationCode>
     </AuthenticationData>
   </dskpp:ClientNonce>

C.1.5.  Example of a <ServerFinished> Message






Nystroem, et al.        Expires December 13, 2007              [Page 83]


Internet-Draft                    DSKPP                        June 2007


   <?xml version="1.0" encoding="UTF-8"?>
   <dskpp:ServerFinished Version="1.0" SessionID="4114" Status="Success"
     xmlns:dskpp="urn:ietf:params:xml:schema:keyprov:protocol"
     xmlns:pskc="urn:ietf:params:xml:ns:keyprov:container"
     xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="urn:ietf:params:xml:schema:keyprov:protocol">
     <pskc:SecretContainer version="1.0">
       <Device>
         <Secret SecretAlgorithm="other" SecretAlgorithm-ext="SecurID"
           SecretId="XL0000000001234">
           <Issuer>CredentialIssuer</Issuer>
           <Usage otp="true">
             <ResponseFormat format="DECIMAL" length="6"/>
           </Usage>
           <FriendlyName>MyFirstToken</FriendlyName>
           <Data Name="TIME">
             <Value>Time</Value>
           </Data>
           <Expiry>10/30/2009</Expiry>
         </Secret>
       </Device>
     </pskc:SecretContainer>
     <Mac>miidfasde312asder394jw==</Mac>
   </dskpp:ServerFinished>

C.2.  Example Messages in a Two- or One-pass Exchange

   The examples illustrate a complete two-pass DSKPP exchange.  The
   server messages MAY also constitute the only messages in a one-pass
   DSKPP exchange.

C.2.1.  Example of a <ClientHello> Message Indicating Support for Two-
        pass DSKPP

   The client indicates support both for the two-pass key transport
   variant as well as the two-pass key wrap variant.

   <?xml version="1.0" encoding="UTF-8"?>
   <dskpp:ClientHello Version="1.0"
     xmlns:dskpp="urn:ietf:params:xml:schema:keyprov:protocol"
     xmlns:pskc="urn:ietf:params:xml:ns:keyprov:container"
     xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="urn:ietf:params:xml:schema:keyprov:protocol"
     xmlns:ds="http://www.w3.org/2000/09/xmldsig#"
     xmlns:pkcs-5=
     "http://www.rsasecurity.com/rsalabs/pkcs/schemas/pkcs-5v2-0#">
     <DeviceIdentifierData>
       <pskc:DeviceID>



Nystroem, et al.        Expires December 13, 2007              [Page 84]


Internet-Draft                    DSKPP                        June 2007


         <Manufacturer>ManufacturerABC</Manufacturer>
         <SerialNo>XL0000000001234</SerialNo>
         <Model>U2</Model>
       </DeviceID>
     </DeviceIdentifierData>
     <SupportedKeyTypes>
       <Algorithm>
         http://www.rsa.com/rsalabs/otps/schemas/2005/09/otps-wst#
           SecurID-AES
       </Algorithm>
       <Algorithm>
         http://www.openauthentication.org/OATH/2006/10/PSKC#HOTP
       </Algorithm>
     </SupportedKeyTypes>
     <SupportedEncryptionAlgorithms>
       <Algorithm>
         http://www.w3.org/2001/05/xmlenc#rsa_1_5
       </Algorithm>
       <Algorithm>
         http://www.w3.org/2001/04/xmlenc#kw-aes128
       </Algorithm>
       <Algorithm>
         http://www.rsasecurity.com/rsalabs/pkcs/schemas/pkcs-5#
           pbes2
       </Algorithm>
       <Algorithm>
         urn:ietf:params:xml:schema:keyprov:protocol#dskpp-prf-aes
       </Algorithm>
     </SupportedMACAlgorithms>
       <Algorithm>urn:ietf:params:xml:schema:keyprov:protocol#
         dskpp-prf-aes</Algorithm>
     </SupportedMACAlgorithms>
     <SupportedProtocolVariants>
       <Variant>
         <TwoPass>
           <SupportedKeyInitializationMethod>
             urn:ietf:params:xml:schema:keyprov:protocol#wrap
           </SupportedKeyInitializationMethod>
           <Payload xsi:type="ds:KeyInfoType">
             <ds:KeyName>Key_001</ds:KeyName>
           </Payload>
           <SupportedKeyInitializationMethod>
             urn:ietf:params:xml:schema:keyprov:protocol#transport
           </SupportedKeyInitializationMethod>
           <Payload xsi:type="ds:KeyInfoType">
             <ds:X509Data>
               <ds:X509Certificate>miib</ds:X509Certificate>
             </ds:X509Data>



Nystroem, et al.        Expires December 13, 2007              [Page 85]


Internet-Draft                    DSKPP                        June 2007


           </Payload>
         </TwoPass>
       </Variant>
     </SupportedProtocolVariants
     <SupportedSecretContainers>
       <SecretContainerFormat>
         urn:ietf:params:xml:schema:keyprov:container
       </SecretContainerFormat>
     </SupportedSecretContainers>
     <AuthenticationData>
       <AuthenticationCode>1erd354657689102abcd</AuthenticationCode>
     </AuthenticationData>
   </dskpp:ClientHello>

C.2.2.  Example of a <ServerFinished> Message Using the Key Transport
        Profile

   In this example, the server responds to the previous request using
   the key transport profile.
































Nystroem, et al.        Expires December 13, 2007              [Page 86]


Internet-Draft                    DSKPP                        June 2007


   <?xml version="1.0" encoding="UTF-8"?>
   <dskpp:ServerFinished Version="1.0" SessionID="4114" Status="Success"
     xmlns:dskpp="urn:ietf:params:xml:schema:keyprov:protocol"
     xmlns:pskc="urn:ietf:params:xml:ns:keyprov:container"
     xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="urn:ietf:params:xml:schema:keyprov:protocol"
     xmlns:ds="http://www.w3.org/2000/09/xmldsig#"
     xmlns:xenc="http://www.w3.org/2001/04/xmlenc#">
     <pskc:SecretContainer version="1.0">
       <EncryptionMethod
         algorithm="http://www.w3.org/2001/05/xmlenc#rsa_1_5">
         <EncKeyLabel>43212093<
         <ds:KeyInfo>
           <ds:X509Data>
             <ds:X509Certificate>miib</ds:X509Certificate>
           </ds:X509Data>
         </ds:KeyInfo>
       </EncryptionMethod>
       <Device>
         <Secret SecretAlgorithm="HOTP" SecretId="SDU312345678">
           <Issuer>CredentialIssuer</Issuer>
           <Usage otp="true">
             <ResponseFormat format="DECIMAL" length="6"/>
           </Usage>
           <FriendlyName>MyFirstToken</FriendlyName>
           <Data Name="SECRET">
             <Value>
               <xenc:CipherData>
               7JHUyp3azOkqJENSsh6b2vxXzwGBYypzJxEr+ikQAa229KV/BgZhGA==
               </xenc:CipherData>
             </Value>
           </Data>
           <Data Name="COUNTER">
             <Value>1</Value>
           </Data>
           <Expiry>10/30/2009</Expiry>
         </Secret>
       </Device>
     </pskc:SecretContainer>
     <Mac MacAlgorithm=
       "urn:ietf:params:xml:schema:keyprov:protocol#dskpp-prf-aes">
       miidfasde312asder394jw==
     </Mac>
   </dskpp:ServerFinished>







Nystroem, et al.        Expires December 13, 2007              [Page 87]


Internet-Draft                    DSKPP                        June 2007


C.2.3.  Example of a <ServerFinished> Message Using the Key Wrap Profile

   In this example, the server responds to the previous request using
   the key wrap profile.















































Nystroem, et al.        Expires December 13, 2007              [Page 88]


Internet-Draft                    DSKPP                        June 2007


  <?xml version="1.0" encoding="UTF-8"?>
  <dskpp:ServerFinished Version="1.0" SessionID="4114" Status="Success"
    xmlns:dskpp="urn:ietf:params:xml:schema:keyprov:protocol"
    xmlns:pskc="urn:ietf:params:xml:ns:keyprov:container"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
      xsi:schemaLocation="urn:ietf:params:xml:schema:keyprov:protocol"
    xmlns:ds="http://www.w3.org/2000/09/xmldsig#"
    xmlns:xenc="http://www.w3.org/2001/04/xmlenc#">
    <pskc:SecretContainer version="1.0">
      <EncryptionMethod
        algorithm="http://www.w3.org/2001/05/xmlenc#kw-aes128">
        <EncKeyLabel>43212093</EncKeyLabel>
        <ds:KeyInfo>
          <ds:KeyName>Key-001</ds:KeyName>
        </ds:KeyInfo>
      </EncryptionMethod>
      <Device>
        <Secret SecretAlgorithm="HOTP" SecretId="SDU312345678">
          <Issuer>CredentialIssuer</Issuer>
          <Usage otp="true">
            <ResponseFormat format="DECIMAL" length="6"/>
          </Usage>
          <FriendlyName>MyFirstToken</FriendlyName>
          <Data Name="SECRET">
            <Value>
              <xenc:CipherData>
                7JHUyp3azOkqJENSsh6b2vxXzwGBYypzJxEr+ikQAa229KV/BgZhGA==
              </xenc:CipherData>
            </Value>
          </Data>
          <Data Name="COUNTER">
            <Value>1</Value>
          </Data>
          <Expiry>10/30/2009</Expiry>
        </Secret>
      </Device>
    </pskc:SecretContainer>
    <Mac MacAlgorithm=
      "urn:ietf:params:xml:schema:keyprov:protocol#dskpp-prf-aes">
      miidfasde312asder394jw==
    </Mac>
  </dskpp:ServerFinished>

C.2.4.  Example of a <ServerFinished> Message using the Passphrase-based
        Key Wrap Profile

   In this example, the server responds to the previous request using
   the passphrase-based key wrap profile.



Nystroem, et al.        Expires December 13, 2007              [Page 89]


Internet-Draft                    DSKPP                        June 2007


 <?xml version="1.0" encoding="UTF-8"?>
 <dskpp:ServerFinished Version="1.0" SessionID="4114" Status="Success"
   xmlns:dskpp="urn:ietf:params:xml:schema:keyprov:protocol"
   xmlns:pskc="urn:ietf:params:xml:ns:keyprov:container"
   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
     xsi:schemaLocation="urn:ietf:params:xml:schema:keyprov:protocol"
   xmlns:ds="http://www.w3.org/2000/09/xmldsig#"
   xmlns:xenc=http://www.w3.org/2001/04/xmlenc#
   xmlns:pkcs-5=
   "http://www.rsasecurity.com/rsalabs/pkcs/schemas/pkcs-5v2-0#">
   <pskc:SecretContainer version="1.0">
     <EncryptionMethod algorithm=
         "http://www.rsasecurity.com/rsalabs/pkcs/schemas/pkcs-5#pbes2">
       <pkcs-5:PBES2-params>
         <KeyDerivationFunc Algorithm=
           "http://www.rsasecurity.com/rsalabs/pkcs/schemas/pkcs-5#
           pbkdf2">
           <pkcs-5:PBKDF2-params>
             <Salt>
               <Specified>32113435</Specified>
             </Salt>
             <IterationCount>1024</IterationCount>
             <KeyLength>128</KeyLength>
             <PRF/>
           </pkcs-5:PBKDF2-params>
         </KeyDerivationFunc>
         <EncryptionScheme Algorithm=
           "http://www.w3.org/2001/04/xmlenc#kw-aes128-cbc">
         </EncryptionScheme
       </pkcs-5:PBES2-params>
       <EncKeyLabel>43212093</EncKeyLabel>
       <ds:KeyInfo>
         <ds:KeyName>Passphrase1</ds:KeyName>
       </ds:KeyInfo>
     </EncryptionMethod>
     <Device>
       <Secret SecretAlgorithm="HOTP" SecretId="SDU312345678">
         <Issuer>CredentialIssuer</Issuer>
         <Usage otp="true">
           <ResponseFormat format="DECIMAL" length="6"/>
         </Usage>
         <FriendlyName>MyFirstToken</FriendlyName>
         <Data Name="SECRET">
           <Value>
             <xenc:CipherData>
               7JHUyp3azOkqJENSsh6b2vxXzwGBYypzJxEr+ikQAa229KV/BgZhGA==
             </xenc:CipherData>
           </Value>



Nystroem, et al.        Expires December 13, 2007              [Page 90]


Internet-Draft                    DSKPP                        June 2007


         </Data>
         <Data Name="COUNTER">
           <Value>1</Value>
         </Data>
         <Expiry>10/30/2009</Expiry>
       </Secret>
     </Device>
   </pskc:SecretContainer>
   <Mac MacAlgorithm=
     "urn:ietf:params:xml:schema:keyprov:protocol#dskpp-prf-aes">
     miidfasde312asder394jw==
   </Mac>
 </dskpp:ServerFinished>






































Nystroem, et al.        Expires December 13, 2007              [Page 91]


Internet-Draft                    DSKPP                        June 2007


Appendix D.  Integration with PKCS #11

   A DSKPP client that needs to communicate with a conncected
   cryptographic token to perform a DSKPP exchange MAY use PKCS #11
   [5]as a programming interface.

D.1.  The 4-pass Variant

   When performing 4-pass DSKPP with a cryptographic token using the
   PKCS #11 programming interface, the procedure described in [8],
   Appendix B, is RECOMMENDED.

D.2.  The 2-pass Variant

   A suggested procedure to perform 2-pass DSKPP with a cryptographic
   token through the PKCS #11 interface using the mechanisms defined in
   [8] is as follows:

   a.  On the client side,

       1.  The client selects a suitable slot and token (e.g. through
           use of the <DeviceIdentifier> or the <PlatformInfo> element
           of the DSKPP trigger message).

       2.  A nonce R is generated, e.g. by calling C_SeedRandom and
           C_GenerateRandom.

       3.  The client sends its first message to the server, including
           the nonce R.

   b.  On the server side,

       1.  A generic key K = K_TOKEN | K _MAC (where '|' denotes
           concatenation) is generated, e.g. by calling C_GenerateKey
           (using key type CKK_GENERIC_SECRET).  The template for K
           SHALL allow it to be exported (but only in wrapped form, i.e.
           CKA_SENSITIVE SHALL be set to CK_TRUE and CKA_EXTRACTABLE
           SHALL also be set to CK_TRUE), and also to be used for
           further key derivation.  From K, a token key K_TOKEN of
           suitable type is derived by calling C_DeriveKey using the
           PKCS #11 mechanism CKM_EXTRACT_KEY_FROM_KEY and setting the
           CK_EXTRACT_PARAMS to the first bit of the generic secret key
           (i.e. set to 0).  Likewise, a MAC key K_MAC is derived from K
           by calling C_DeriveKey using the CKM_EXTRACT_KEY_FROM_KEY
           mechanism, this time setting CK_EXTRACT_PARAMS to the length
           of K (in bits) divided by two.





Nystroem, et al.        Expires December 13, 2007              [Page 92]


Internet-Draft                    DSKPP                        June 2007


       2.  The server wraps K with either the token's public key
           K_CLIENT, the shared secret key K_SHARED, or the derived
           shared secret key K_DERIVED by using C_WrapKey.  If use of
           the DSKPP key wrap algorithm has been negotiated then the
           CKM_KIP_WRAP mechanism SHALL be used to wrap K. When calling
           C_WrapKey, the hKey handle in the CK_KIP_PARAMS structure
           SHALL be set to NULL_PTR.  The pSeed parameter in the
           CK_KIP_PARAMS structure SHALL point to the nonce R provided
           by the DSKPP client, and the ulSeedLen parameter SHALL
           indicate the length of R. The hWrappingKey parameter in the
           call to C_WrapKey SHALL be set to refer to the wrapping key.

       3.  Next, the server needs to calculate a MAC using K_MAC.  If
           use of the DSKPP MAC algorithm has been negotiated, then the
           MAC is calculated by calling C_SignInit with the CKM_KIP_MAC
           mechanism followed by a call to C_Sign.  In the call to
           C_SignInit, K_MAC SHALL be the signature key, the hKey
           parameter in the CK_KIP_PARAMS structure SHALL be set to
           NULL_PTR, the pSeed parameter of the CT_KIP_PARAMS structure
           SHALL be set to NULL_PTR, and the ulSeedLen parameter SHALL
           be set to zero.  In the call to C_Sign, the pData parameter
           SHALL be set to the concatenation of the string ID_S and the
           nonce R, and the ulDataLen parameter SHALL be set to the
           length of the concatenated string.  The desired length of the
           MAC SHALL be specified through the pulSignatureLen parameter
           and SHALL be set to the length of R.

       4.  If the server also needs to authenticate its message (due to
           an existing K_TOKEN being replaced), the server SHALL
           calculate a second MAC.  Again, if use of the DSKPP MAC
           algorithm has been negotiated, then the MAC is calculated by
           calling C_SignInit with the CKM_KIP_MAC mechanism followed by
           a call to C_Sign.  In this call to C_SignInit, the K_MAC
           existing before this DSKPP protocol run SHALL be the
           signature key, the hKey parameter in the CK_KIP_PARAMS
           structure SHALL be set to NULL, the pSeed parameter of the
           CT_KIP_PARAMS structure SHALL be set to NULL_PTR, and the
           ulSeeidLen parameter SHALL be set to zero.  In the call to
           C_Sign, the pData parameter SHALL be set to the concatenation
           of the string ID_S and the nonce R, and the ulDataLen
           parameter SHALL be set to the length of concatenated string.
           The desired length of the MAC SHALL be specified through the
           pulSignatureLen parameter and SHALL be set to the length of
           R.







Nystroem, et al.        Expires December 13, 2007              [Page 93]


Internet-Draft                    DSKPP                        June 2007


       5.  The server sends its message to the client, including the
           wrapped key K, the MAC and possibly also the authenticating
           MAC.

   c.  On the client side,

       1.  The client calls C_UnwrapKey to receive a handle to K. After
           this, the client calls C_DeriveKey twice: Once to derive
           K_TOKEN and once to derive K_MAC.  The client SHALL use the
           same mechanism (CKM_EXTRACT_KEY_FROM_KEY) and the same
           mechanism parameters as used by the server above.  When
           calling C_UnwrapKey and C_DeriveKey, the pTemplate parameter
           SHALL be used to set additional key attributes in accordance
           with local policy and as negotiated and expressed in the
           protocol.  In particular, the value of the <KeyID> element in
           the server's response message MAY be used as CKA_ID for
           K_TOKEN.  The key K SHALL be destroyed after deriving K_TOKEN
           and K_MAC.

       2.  The MAC is verified in a reciprocal fashion as it was
           generated by the server.  If use of the CKM_KIP_MAC mechanism
           has been negotiated, then in the call to C_VerifyInit, the
           hKey parameter in the CK_KIP_PARAMS structure SHALL be set to
           NULL_PTR, the pSeed parameter SHALL be set to NULL_PTR, and
           ulSeedLen SHALL be set to 0.  The hKey parameter of
           C_VerifyInit SHALL refer to K_MAC.  In the call to C_Verify,
           pData SHALL be set to the concatenation of the string ID_S
           and the nonce R, and the ulDataLen parameter SHALL be set to
           the length of the concatenated string, pSignature to the MAC
           value received from the server, and ulSignatureLen to the
           length of the MAC.  If the MAC does not verify the protocol
           session ends with a failure.  The token SHALL be constructed
           to not "commit" to the new K_TOKEN or the new K_MAC unless
           the MAC verifies.

       3.  If an authenticating MAC was received (REQUIRED if the new
           K_TOKEN will replace an existing key on the token), then it
           is verified in a similar vein but using the K_MAC associated
           with this server and existing before the protocol run.
           Again, if the MAC does not verify the protocol session ends
           with a failure, and the token MUST be constructed no to
           "commit" to the new K_TOKEN or the new K_MAC unless the MAC
           verifies.








Nystroem, et al.        Expires December 13, 2007              [Page 94]


Internet-Draft                    DSKPP                        June 2007


D.3.  The 1-pass Variant

   A suggested procedure to perform 1-pass DSKPP with a cryptographic
   token through the PKCS #11 interface using the mechanisms defined in
   [8] is as follows:

   a.  On the server side,

       1.  A generic key K = K_TOKEN | K _MAC (where '|' denotes
           concatenation) is generated, e.g. by calling C_GenerateKey
           (using key type CKK_GENERIC_SECRET).  The template for K
           SHALL allow it to be exported (but only in wrapped form, i.e.
           CKA_SENSITIVE SHALL be set to CK_TRUE and CKA_EXTRACTABLE
           SHALL also be set to CK_TRUE), and also to be used for
           further key derivation.  From K, a token key K_TOKEN of
           suitable type is derived by calling C_DeriveKey using the
           PKCS #11 mechanism CKM_EXTRACT_KEY_FROM_KEY and setting the
           CK_EXTRACT_PARAMS to the first bit of the generic secret key
           (i.e. set to 0).  Likewise, a MAC key K_MAC is derived from K
           by calling C_DeriveKey using the CKM_EXTRACT_KEY_FROM_KEY
           mechanism, this time setting CK_EXTRACT_PARAMS to the length
           of K (in bits) divided by two.

       2.  The server wraps K with either the token's public key,
           K_CLIENT, the shared secret key, K_SHARED, or the derived
           shared secret key, K_DERIVED by using C_WrapKey.  If use of
           the DSKPP key wrap algorithm has been negotiated, then the
           CKM_KIP_WRAP mechanism SHALL be used to wrap K. When calling
           C_WrapKey, the hKey handle in the CK_KIP_PARAMS structure
           SHALL be set to NULL_PTR.  The pSeed parameter in the
           CK_KIP_PARAMS structure SHALL point to the octet-string
           representation of an integer I whose value SHALL be
           incremented before each protocol run, and the ulSeedLen
           parameter SHALL indicate the length of the octet-string
           representation of I. The hWrappingKey parameter in the call
           to C_WrapKey SHALL be set to refer to the wrapping key.

           Note: The integer-to-octet string conversion SHALL be made
           using the I2OSP primitive from [13].  There SHALL be no
           leading zeros.

       3.  For the server's message to the client, if use of the DSKPP
           MAC algorithm has been negotiated, then the MAC is calculated
           by calling C_SignInit with the CKM_KIP_MAC mechanism followed
           by a call to C_Sign.  In the call to C_SignInit, K_MAC SHALL
           be the signature key, the hKey parameter in the CK_KIP_PARAMS
           structure SHALL be set to NULL_PTR, the pSeed parameter of
           the CT_KIP_PARAMS structure SHALL be set to NULL_PTR, and the



Nystroem, et al.        Expires December 13, 2007              [Page 95]


Internet-Draft                    DSKPP                        June 2007


           ulSeedLen parameter SHALL be set to zero.  In the call to
           C_Sign, the pData parameter SHALL be set to the concatenation
           of the string ID_S and the octet-string representation of the
           integer I, and the ulDataLen parameter SHALL be set to the
           length of concatenated string.  The desired length of the MAC
           SHALL be specified through the pulSignatureLen parameter as
           usual, and SHALL be equal to, or greater than, sixteen (16).

       4.  If the server also needs to authenticate its message (due to
           an existing K_TOKEN being replaced), the server calculates a
           second MAC.  If the DSKPP MAC mechanism is used, the server
           does this by calling C_SignInit with the CKM_KIP_MAC
           mechanism followed by a call to C_Sign.  In the call to
           C_SignInit, the K_MAC existing on the token before this
           protocol run SHALL be the signature key, the hKey parameter
           in the CK_KIP_PARAMS structure SHALL be set to NULL_PTR, the
           pSeed parameter of the CT_KIP_PARAMS structure SHALL be set
           to NULL_PTR, and the ulSeedLen parameter SHALL be set to
           zero.  In the call to C_Sign, the pData parameter SHALL be
           set to the concatenation of the string ID_S and the octet-
           string representation of the integer I+1 (i.e.  I SHALL be
           incremented before each use), and the ulDataLen parameter
           SHALL be set to the length of the concatenated string.  The
           desired length of the MAC SHALL be specified through the
           pulSignatureLen parameter as usual, and SHALL be equal to, or
           greater than, sixteen (16).

       5.  The server sends its message to the client, including the MAC
           and possibly also the authenticating MAC.

   b.  On the client side,

       1.  The client calls C_UnwrapKey to receive a handle to K. After
           this, the client calls C_DeriveKey twice: Once to derive
           K_TOKEN and once to derive K_MAC.  The client SHALL use the
           same mechanism (CKM_EXTRACT_KEY_FROM_KEY) and the same
           mechanism parameters as used by the server above.  When
           calling C_UnwrapKey and C_DeriveKey, the pTemplate parameter
           SHALL be used to set additional key attributes in accordance
           with local policy and as negotiated and expressed in the
           protocol.  In particular, the value of the <KeyID> element in
           the server's response message MAY be used as CKA_ID for
           K_TOKEN.  The key K SHALL be destroyed after deriving K_TOKEN
           and K_MAC.







Nystroem, et al.        Expires December 13, 2007              [Page 96]


Internet-Draft                    DSKPP                        June 2007


       2.  The MAC is verified in a reciprocal fashion as it was
           generated by the server.  If use of the CKM_KIP_MAC mechanism
           has been negotiated, then in the call to C_VerifyInit, the
           hKey parameter in the CK_KIP_PARAMS structure SHALL be set to
           NULL_PTR, the pSeed parameter SHALL be set to NULL_PTR, and
           ulSeedLen SHALL be set to 0.  The hKey parameter of
           C_VerifyInit SHALL refer to K_MAC.  In the call to C_Verify,
           pData SHALL be set to the concatenation of the string ID_S
           and the octet-string representation of the provided value for
           I, and the ulDataLen parameter SHALL be set to the length of
           the concatenated string, pSignature to the MAC value received
           from the server, and ulSignatureLen to the length of the MAC.
           If the MAC does not verify or if the provided value of I is
           not larger than any stored value I' for the identified server
           ID_S the protocol session ends with a failure.  The token
           SHALL be constructed to not "commit" to the new K_TOKEN or
           the new K_MAC unless the MAC verifies.  If the verification
           succeeds, the token SHALL store the provided value of I as a
           new I' for ID_S.

       3.  If an authenticating MAC was received (REQUIRED if K_TOKEN
           will replace an existing key on the token), it is verified in
           a similar vein but using the K_MAC existing before the
           protocol run.  Again, if the MAC does not verify the protocol
           session ends with a failure, and the token MUST be
           constructed no to "commit" to the new K_TOKEN or the new
           K_MAC unless the MAC verifies.
























Nystroem, et al.        Expires December 13, 2007              [Page 97]


Internet-Draft                    DSKPP                        June 2007


Appendix E.  Example of DSKPP-PRF Realizations

E.1.  Introduction

   This example appendix defines DSKPP-PRF in terms of AES [18] and HMAC
   [19].

E.2.  DSKPP-PRF-AES

E.2.1.  Identification

   For tokens supporting this realization of DSKPP-PRF, the following
   URI MAY be used to identify this algorithm in DSKPP:

   urn:ietf:params:xml:schema:keyprov:protocol#dskpp-prf-aes

   When this URI is used to identify the encryption algorithm to use,
   the method for encryption of R_C values described in Section 3.8
   SHALL be used.

E.2.2.  Definition

   DSKPP-PRF-AES (k, s, dsLen)

   Input:

   k         Encryption keyto use

   s         Octet string consisting of randomizing material.  The
             length of the string s is sLen.

   dsLen     Desired length of the output

   Output:

   DS        A pseudorandom string, dsLen-octets long

   Steps:

   1.  Let bLen be the output block size of AES in octets:

       bLen = (AES output block length in octets)
       (normally, bLen = 16)

   2.  If dsLen > (2**32 - 1) * bLen, output "derived data too long" and
       stop





Nystroem, et al.        Expires December 13, 2007              [Page 98]


Internet-Draft                    DSKPP                        June 2007


   3.  Let n be the number of bLen-octet blocks in the output data,
       rounding up, and let j be the number of octets in the last block:

       n = ROUND( dsLen / bLen)
       j = dsLen - (n - 1) * bLen

   4.  For each block of the pseudorandom string DS, apply the function
       F defined below to the key k, the string s and the block index to
       compute the block:

       B1 = F (k, s, 1) ,
       B2 = F (k, s, 2) ,
       ...
       Bn = F (k, s, n)

   The function F is defined in terms of the OMAC1 construction from
   [20], using AES as the block cipher:

   F (k, s, i) = OMAC1-AES (k, INT (i) || s)

   where INT (i) is a four-octet encoding of the integer i, most
   significant octet first, and the output length of OMAC1 is set to
   bLen.

   Concatenate the blocks and extract the first dsLen octets to product
   the desired data string DS:

   DS = B1 || B2 || ... || Bn<0..j-1>

   Output the derived data DS.

E.2.3.  Example

   If we assume that dsLen = 16, then:

   n = 16 / 16 = 1

   j = 16 - (1 - 1) * 16 = 16

   DS = B1 = F (k, s, 1) = OMAC1-AES (k, INT (1) || s)

E.3.  DSKPP-PRF-SHA256

E.3.1.  Identification

   For tokens supporting this realization of DSKPP-PRF, the following
   URI MAY be used to identify this algorithm in DSKPP:




Nystroem, et al.        Expires December 13, 2007              [Page 99]


Internet-Draft                    DSKPP                        June 2007


   urn:ietf:params:xml:schema:keyprov:protocol#dskpp-prf-sha256

   When this URI is used to identify the encryption algorithm to use,
   the method for encryption of R_C values described in Section 3.8
   SHALL be used.

E.3.2.  Definition

   DSKPP-PRF-SHA256 (k, s, dsLen)

   Input:

   k         Encryption key to use

   s         Octet string consisting of randomizing material.  The
             length of the string s is sLen.

   dsLen     Desired length of the output

   Output:

   DS        A pseudorandom string, dsLen-octets long

   Steps:

   1.  Let bLen be the output size of SHA-256 in octets of [21] (no
       truncation is done on the HMAC output):

       bLen = 32
       (normally, bLen = 16)

   2.  If dsLen > (2**32 - 1) * bLen, output "derived data too long" and
       stop

   3.  Let n be the number of bLen-octet blocks in the output data,
       rounding up, and let j be the number of octets in the last block:

       n = ROUND( dsLen / bLen)
       j = dsLen - (n - 1) * bLen

   4.  For each block of the pseudorandom string DS, apply the function
       F defined below to the key k, the string s and the block index to
       compute the block:

       B1 = F (k, s, 1) ,
       B2 = F (k, s, 2) ,
       ...
       Bn = F (k, s, n)



Nystroem, et al.        Expires December 13, 2007             [Page 100]


Internet-Draft                    DSKPP                        June 2007


   The function F is defined in terms of the HMAC construction from
   [19], using SHA-256 as the digest algorithm:

   F (k, s, i) = HMAC-SHA256 (k, INT (i) || s)

   where INT (i) is a four-octet encoding of the integer i, most
   significant octet first, and the output length of HMAC is set to
   bLen.

   Concatenate the blocks and extract the first dsLen octets to product
   the desired data string DS:

   DS = B1 || B2 || ... || Bn<0..j-1>

   Output the derived data DS.

E.3.3.  Example

   If we assume that sLen = 256 (two 128-octet long values) and dsLen =
   16, then:

   n = ROUND ( 16 / 32 ) = 1

   j = 16 - (1 - 1) * 32 = 16

   B1 = F (k, s, 1) = HMAC-SHA256 (k, INT (1) || s)

   DS = B1<0 ... 15>

   That is, the result will be the first 16 octets of the HMAC output.





















Nystroem, et al.        Expires December 13, 2007             [Page 101]


Internet-Draft                    DSKPP                        June 2007


Authors' Addresses

   Magnus Nystroem
   RSA, The Security Division of EMC

   Email: magnus@rsa.com


   Salah Machani
   Diversinet Corp.

   Email: smachani@diversinet.com


   Mingliang Pei
   VeriSign, Inc.

   Email: mpei@verisign.com


   Andrea Doherty
   RSA, The Security Division of EMC

   Email: adoherty@rsa.com



























Nystroem, et al.        Expires December 13, 2007             [Page 102]


Internet-Draft                    DSKPP                        June 2007


Full Copyright Statement

   Copyright (C) The IETF Trust (2007).

   This document is subject to the rights, licenses and restrictions
   contained in BCP 78, and except as set forth therein, the authors
   retain all their rights.

   This document and the information contained herein are provided on an
   "AS IS" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS
   OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY, THE IETF TRUST AND
   THE INTERNET ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS
   OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF
   THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED
   WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.


Intellectual Property

   The IETF takes no position regarding the validity or scope of any
   Intellectual Property Rights or other rights that might be claimed to
   pertain to the implementation or use of the technology described in
   this document or the extent to which any license under such rights
   might or might not be available; nor does it represent that it has
   made any independent effort to identify any such rights.  Information
   on the procedures with respect to rights in RFC documents can be
   found in BCP 78 and BCP 79.

   Copies of IPR disclosures made to the IETF Secretariat and any
   assurances of licenses to be made available, or the result of an
   attempt made to obtain a general license or permission for the use of
   such proprietary rights by implementers or users of this
   specification can be obtained from the IETF on-line IPR repository at
   http://www.ietf.org/ipr.

   The IETF invites any interested party to bring to its attention any
   copyrights, patents or patent applications, or other proprietary
   rights that may cover technology that may be required to implement
   this standard.  Please address the information to the IETF at
   ietf-ipr@ietf.org.


Acknowledgment

   Funding for the RFC Editor function is provided by the IETF
   Administrative Support Activity (IASA).





Nystroem, et al.        Expires December 13, 2007             [Page 103]




