<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="en"><head><title>Dynamic Symmetric Key Provisioning Protocol
    (DSKPP)</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="description" content="Dynamic Symmetric Key Provisioning Protocol
    (DSKPP)">
<meta name="generator" content="xml2rfc v1.35 (http://xml.resource.org/)">
<meta name="viewport" content="width=600;" />
<style type='text/css'><!--
        body {
                font-family: verdana, charcoal, helvetica, arial, sans-serif;
                font-size: 85%;
		max-width: 40em; 
		color: #000; background-color: #FFF;
                margin: 2em;
        }
        h1, h2, h3, h4, h5, h6 {
                font-family: helvetica, monaco, "MS Sans Serif", arial, sans-serif;
                font-weight: bold; font-style: normal;
        }
        h1 { color: #900; background-color: transparent; text-align: right; }
        h3 { color: #333; background-color: transparent; }

        td.RFCbug {
                font-size: x-small; text-decoration: none;
                width: 30px; height: 30px; padding-top: 2px;
                text-align: justify; vertical-align: middle;
                background-color: #000;
        }
        td.RFCbug span.RFC {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: bold; color: #666;
        }
        td.RFCbug span.hotText {
                font-family: charcoal, monaco, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: normal; text-align: center; color: #FFF;
        }

        table.TOCbug { width: 30px; height: 15px; }
        td.TOCbug {
                text-align: center; width: 30px; height: 15px;
                color: #FFF; background-color: #900;
        }
        td.TOCbug a {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, sans-serif;
                font-weight: bold; font-size: x-small; text-decoration: none;
                color: #FFF; background-color: transparent;
        }

        td.header {
                font-family: arial, helvetica, sans-serif; font-size: x-small;
                vertical-align: top; width: 33%;
                color: #FFF; background-color: #666;
        }
        td.author { font-weight: bold; font-size: x-small; margin-left: 4em; }
        td.author-text { font-size: x-small; }

        /* info code from SantaKlauss at http://www.madaboutstyle.com/tooltip2.html */
        a.info {
                /* This is the key. */
                position: relative;
                z-index: 24;
                text-decoration: none;
        }
        a.info:hover {
                z-index: 25;
                color: #FFF; background-color: #900;
        }
        a.info span { display: none; }
        a.info:hover span.info {
                /* The span will display just on :hover state. */
                display: block;
                position: absolute;
                font-size: smaller;
                top: 2em; left: -5em; width: 15em;
                padding: 2px; border: 1px solid #333;
                color: #900; background-color: #EEE;
                text-align: left;
        }

        a { font-weight: bold; }
        a:link    { color: #900; background-color: transparent; }
        a:visited { color: #633; background-color: transparent; }
        a:active  { color: #633; background-color: transparent; }

        p { margin-left: 2em; margin-right: 2em; }
        p.copyright { font-size: x-small; }
        p.toc { font-size: 85%;
		max-width: 40em; 
		font-weight: bold; margin-left: 3em; }
        table.toc { margin: 0 0 0 3em; padding: 0; border: 0; vertical-align: text-top; }
        td.toc { font-size: 85%;
		max-width: 40em; 
		font-weight: bold; vertical-align: text-top; }

        ol.text { margin-left: 2em; margin-right: 2em; }
        ul.text { margin-left: 2em; margin-right: 2em; }
        li      { margin-left: 3em; }

        /* RFC-2629 <spanx>s and <artwork>s. */
        em     { font-style: italic; }
        strong { font-weight: bold; }
        dfn    { font-weight: bold; font-style: normal; }
        cite   { font-weight: normal; font-style: normal; }
        tt     { color: #036; }
        tt, pre, pre dfn, pre em, pre cite, pre span {
                font-family: "Courier New", Courier, monospace; font-size: small;
        }
        pre {
                text-align: left; padding: 4px;
                color: #000; background-color: #CCC;
        }
        pre dfn  { color: #900; }
        pre em   { color: #66F; background-color: #FFC; font-weight: normal; }
        pre .key { color: #33C; font-weight: bold; }
        pre .id  { color: #900; }
        pre .str { color: #000; background-color: #CFF; }
        pre .val { color: #066; }
        pre .rep { color: #909; }
        pre .oth { color: #000; background-color: #FCF; }
        pre .err { background-color: #FCC; }

        /* RFC-2629 <texttable>s. */
        table.all, table.full, table.headers, table.none {
                font-size: 85%;
		max-width: 40em; 
		text-align: center; border-width: 2px;
                vertical-align: top; border-collapse: collapse;
        }
        table.all, table.full { border-style: solid; border-color: black; }
        table.headers, table.none { border-style: none; }
        th {
                font-weight: bold; border-color: black;
                border-width: 2px 2px 3px 2px;
        }
        table.all th, table.full th { border-style: solid; }
        table.headers th { border-style: none none solid none; }
        table.none th { border-style: none; }
        table.all td {
                border-style: solid; border-color: #333;
                border-width: 1px 2px;
        }
        table.full td, table.headers td, table.none td { border-style: none; }

        hr { height: 1px; }
        hr.insert {
                width: 80%; border-style: none; border-width: 0;
                color: #CCC; background-color: #CCC;
        }
--></style>
</head>
<body>
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<table summary="layout" width="66%" border="0" cellpadding="0" cellspacing="0"><tr><td><table summary="layout" width="100%" border="0" cellpadding="2" cellspacing="1">
<tr><td class="header">KEYPROV Working Group</td><td class="header">A. Doherty</td></tr>
<tr><td class="header">Internet-Draft</td><td class="header">RSA, The Security Division of EMC</td></tr>
<tr><td class="header">Intended status: Standards Track</td><td class="header">M. Pei</td></tr>
<tr><td class="header">Expires: January 29, 2010</td><td class="header">Verisign, Inc.</td></tr>
<tr><td class="header">&nbsp;</td><td class="header">S. Machani</td></tr>
<tr><td class="header">&nbsp;</td><td class="header">Diversinet Corp.</td></tr>
<tr><td class="header">&nbsp;</td><td class="header">M. Nystrom</td></tr>
<tr><td class="header">&nbsp;</td><td class="header">RSA, The Security Division of EMC</td></tr>
<tr><td class="header">&nbsp;</td><td class="header">July 28, 2009</td></tr>
</table></td></tr></table>
<h1><br />Dynamic Symmetric Key Provisioning Protocol
    (DSKPP)<br />draft-ietf-keyprov-dskpp-08.txt</h1>

<h3>Status of this Memo</h3>
<p>
This Internet-Draft is submitted to IETF in full
conformance with the provisions of BCP&nbsp;78 and BCP&nbsp;79.</p>
<p>
Internet-Drafts are working documents of the Internet Engineering
Task Force (IETF), its areas, and its working groups.
Note that other groups may also distribute working documents as
Internet-Drafts.</p>
<p>
Internet-Drafts are draft documents valid for a maximum of six months
and may be updated, replaced, or obsoleted by other documents at any time.
It is inappropriate to use Internet-Drafts as reference material or to cite
them other than as &ldquo;work in progress.&rdquo;</p>
<p>
The list of current Internet-Drafts can be accessed at
<a href='http://www.ietf.org/ietf/1id-abstracts.txt'>http://www.ietf.org/ietf/1id-abstracts.txt</a>.</p>
<p>
The list of Internet-Draft Shadow Directories can be accessed at
<a href='http://www.ietf.org/shadow.html'>http://www.ietf.org/shadow.html</a>.</p>
<p>
This Internet-Draft will expire on January 29, 2010.</p>

<h3>Copyright Notice</h3>
<p>
Copyright (c) 2009 IETF Trust and the persons identified as the
document authors.  All rights reserved.</p>
<p>
This document is subject to BCP 78 and the IETF Trust's Legal
Provisions Relating to IETF Documents in effect on the date of
publication of this document (http://trustee.ietf.org/license-info).
Please review these documents carefully, as they describe your
rights and restrictions with respect to this document.</p>

<h3>Abstract</h3>

<p>DSKPP is a client-server protocol for initialization (and
      configuration) of symmetric keys to locally and remotely accessible
      cryptographic modules. The protocol can be run with or without
      private-key capabilities in the cryptographic modules, and with or
      without an established public-key infrastructure.
</p>
<p>Two variations of the protocol support multiple usage scenarios. With
      the four-pass variant, keys are mutually generated by the provisioning
      server and cryptographic module; provisioned keys are not transferred
      over-the-wire or over-the-air. The two-pass variant enables secure and
      efficient download and installation of pre-generated symmetric keys to a
      cryptographic module.
</p>
<p>This document builds on information contained in <a class='info' href='#RFC4758'>[RFC4758]<span> (</span><span class='info'>RSA, The Security Division of EMC, &ldquo;Cryptographic Token Key Initialization Protocol           (CT-KIP),&rdquo; November&nbsp;2006.</span><span>)</span></a>, adding specific enhancements in response to
      implementation experience and liaison requests.
</p><a name="toc"></a><br /><hr />
<h3>Table of Contents</h3>
<p class="toc">
<a href="#anchor1">1.</a>&nbsp;
Introduction<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor2">1.1.</a>&nbsp;
Key Words<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor3">1.2.</a>&nbsp;
Versions<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor4">1.3.</a>&nbsp;
Namespace Identifiers<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor5">1.3.1.</a>&nbsp;
Defined Identifiers<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor6">1.3.2.</a>&nbsp;
Identifiers Defined in Related Specifications<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor7">1.3.3.</a>&nbsp;
Referenced Identifiers<br />
<a href="#terms">2.</a>&nbsp;
Terminology<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#Subsection-Definitions">2.1.</a>&nbsp;
Definitions<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor8">2.2.</a>&nbsp;
Notation<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor9">2.3.</a>&nbsp;
Abbreviations<br />
<a href="#anchor10">3.</a>&nbsp;
DSKPP Overview<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor11">3.1.</a>&nbsp;
Protocol Entities<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#Subsection-BasicExchange">3.2.</a>&nbsp;
Basic DSKPP Exchange<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#Subsection-UserAuth">3.2.1.</a>&nbsp;
User Authentication<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor12">3.2.2.</a>&nbsp;
Protocol Initiated by the DSKPP Client<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor13">3.2.3.</a>&nbsp;
Protocol Triggered by the DSKPP Server<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor14">3.2.4.</a>&nbsp;
Variants<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor17">3.3.</a>&nbsp;
Status Codes<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor18">3.4.</a>&nbsp;
Basic Constructs<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#Subsection-AD">3.4.1.</a>&nbsp;
User Authentication Data, AD<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#DSKPP-PRF">3.4.2.</a>&nbsp;
The DSKPP One-Way Pseudorandom Function, DSKPP-PRF<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#Subsection-MsgHashAlg">3.4.3.</a>&nbsp;
The DSKPP Message Hash Algorithm<br />
<a href="#Subsection-FourPassUsage">4.</a>&nbsp;
Four-Pass Protocol Usage<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor20">4.1.</a>&nbsp;
The Key Agreement Mechanism<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#Subsection-FourPassDataFlow">4.1.1.</a>&nbsp;
Data Flow<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#Subsection-4PassKeyGen">4.1.2.</a>&nbsp;
Computation<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#Subsection-4PassFlow">4.2.</a>&nbsp;
Message Flow<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#Subsection-Trigger">4.2.1.</a>&nbsp;
KeyProvTrigger<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor21">4.2.2.</a>&nbsp;
KeyProvClientHello<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#Subsection-ServerHello">4.2.3.</a>&nbsp;
KeyProvServerHello<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#Subsection-Enc">4.2.4.</a>&nbsp;
KeyProvClientNonce<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor22">4.2.5.</a>&nbsp;
KeyProvServerFinished<br />
<a href="#Subsecton-TwoPass">5.</a>&nbsp;
Two-Pass Protocol Usage<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor23">5.1.</a>&nbsp;
Key Protection Methods<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor24">5.1.1.</a>&nbsp;
Key Transport<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor25">5.1.2.</a>&nbsp;
Key Wrap<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor26">5.1.3.</a>&nbsp;
Passphrase-Based Key Wrap<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#Subsection-2PassFlow">5.2.</a>&nbsp;
Message Flow<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor27">5.2.1.</a>&nbsp;
KeyProvTrigger<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor28">5.2.2.</a>&nbsp;
KeyProvClientHello<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor29">5.2.3.</a>&nbsp;
KeyProvServerFinished<br />
<a href="#Section-ProtocolExts">6.</a>&nbsp;
Protocol Extensions<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor30">6.1.</a>&nbsp;
The ClientInfoType Extension<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor31">6.2.</a>&nbsp;
The ServerInfoType Extension<br />
<a href="#Section-Bindings">7.</a>&nbsp;
Protocol Bindings<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor32">7.1.</a>&nbsp;
General Requirements<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor33">7.2.</a>&nbsp;
HTTP/1.1 Binding for DSKPP<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#Subsection-Identification">7.2.1.</a>&nbsp;
Identification of DSKPP Messages<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor34">7.2.2.</a>&nbsp;
HTTP Headers<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor35">7.2.3.</a>&nbsp;
HTTP Operations<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor36">7.2.4.</a>&nbsp;
HTTP Status Codes<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor37">7.2.5.</a>&nbsp;
HTTP Authentication<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#Section-InitDSKPP">7.2.6.</a>&nbsp;
Initialization of DSKPP<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor38">7.2.7.</a>&nbsp;
Example Messages<br />
<a href="#Section-Schema">8.</a>&nbsp;
DSKPP XML Schema<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor39">8.1.</a>&nbsp;
General Processing Requirements<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor40">8.2.</a>&nbsp;
Schema<br />
<a href="#anchor41">9.</a>&nbsp;
Conformance Requirements<br />
<a href="#Section-Security">10.</a>&nbsp;
Security Considerations<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor42">10.1.</a>&nbsp;
General<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor43">10.2.</a>&nbsp;
Active Attacks<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor44">10.2.1.</a>&nbsp;
Introduction<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#Subsection-Messages">10.2.2.</a>&nbsp;
Message Modifications<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor45">10.2.3.</a>&nbsp;
Message Deletion<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor46">10.2.4.</a>&nbsp;
Message Insertion<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor47">10.2.5.</a>&nbsp;
Message Replay<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor48">10.2.6.</a>&nbsp;
Message Reordering<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#Subsection-MITM">10.2.7.</a>&nbsp;
Man-in-the-Middle<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#Subsection-Passive">10.3.</a>&nbsp;
Passive Attacks<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor49">10.4.</a>&nbsp;
Cryptographic Attacks<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#Subsection-Interactions">10.5.</a>&nbsp;
Attacks on the Interaction between DSKPP and User Authentication<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor50">10.6.</a>&nbsp;
Miscellaneous Considerations<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor51">10.6.1.</a>&nbsp;
Client Contributions to K_TOKEN Entropy<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor52">10.6.2.</a>&nbsp;
Key Confirmation<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#Subsection-ServerAuth">10.6.3.</a>&nbsp;
Server Authentication<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor53">10.6.4.</a>&nbsp;
User Authentication<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor54">10.6.5.</a>&nbsp;
Key Protection in Two-Pass DSKPP<br />
<a href="#anchor55">11.</a>&nbsp;
Internationalization Considerations<br />
<a href="#anchor56">12.</a>&nbsp;
IANA Considerations<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor57">12.1.</a>&nbsp;
URN Sub-Namespace Registration<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor58">12.2.</a>&nbsp;
XML Schema Registration<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor59">12.3.</a>&nbsp;
MIME Media Type Registration<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor60">12.4.</a>&nbsp;
Status Code Registry<br />
<a href="#Section-IPR">13.</a>&nbsp;
Intellectual Property Considerations<br />
<a href="#anchor61">14.</a>&nbsp;
Contributors<br />
<a href="#Section-Acknowledgements">15.</a>&nbsp;
Acknowledgements<br />
<a href="#rfc.references1">16.</a>&nbsp;
References<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#rfc.references1">16.1.</a>&nbsp;
Normative references<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#rfc.references2">16.2.</a>&nbsp;
Informative references<br />
<a href="#Section-Usage-Scenarios">Appendix&nbsp;A.</a>&nbsp;
Usage Scenarios<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#UC1">A.1.</a>&nbsp;
Single Key Request<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor64">A.2.</a>&nbsp;
Multiple Key Requests<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor65">A.3.</a>&nbsp;
User Authentication<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor66">A.4.</a>&nbsp;
Provisioning Time-Out Policy<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor67">A.5.</a>&nbsp;
Key Renewal<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor68">A.6.</a>&nbsp;
Pre-Loaded Key Replacement<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor69">A.7.</a>&nbsp;
Pre-Shared Manufacturing Key<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor70">A.8.</a>&nbsp;
End-to-End Protection of Key Material<br />
<a href="#Section-Examples">Appendix&nbsp;B.</a>&nbsp;
Examples<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor71">B.1.</a>&nbsp;
Trigger Message<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor72">B.2.</a>&nbsp;
Four-Pass Protocol<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor73">B.2.1.</a>&nbsp;
&lt;KeyProvClientHello&gt; Without a Preceding Trigger<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor74">B.2.2.</a>&nbsp;
&lt;KeyProvClientHello&gt; Assuming a Preceding Trigger<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor75">B.2.3.</a>&nbsp;
&lt;KeyProvServerHello&gt; Without a Preceding Trigger<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor76">B.2.4.</a>&nbsp;
&lt;KeyProvServerHello&gt; Assuming Key Renewal<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor77">B.2.5.</a>&nbsp;
&lt;KeyProvClientNonce&gt; Using Default Encryption<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor78">B.2.6.</a>&nbsp;
&lt;KeyProvServerFinished&gt; Using Default Encryption<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor79">B.3.</a>&nbsp;
Two-Pass Protocol<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#Example-TwoPass-1">B.3.1.</a>&nbsp;
Example Using the Key Transport Method<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor80">B.3.2.</a>&nbsp;
Example Using the Key Wrap Method<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor81">B.3.3.</a>&nbsp;
Example Using the Passphrase-Based Key Wrap Method<br />
<a href="#Section-Integration">Appendix&nbsp;C.</a>&nbsp;
Integration with PKCS #11<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor82">C.1.</a>&nbsp;
The 4-pass Variant<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor83">C.2.</a>&nbsp;
The 2-pass Variant<br />
<a href="#Section-PRFRealizations">Appendix&nbsp;D.</a>&nbsp;
Example of DSKPP-PRF Realizations<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor84">D.1.</a>&nbsp;
Introduction<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor85">D.2.</a>&nbsp;
DSKPP-PRF-AES<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor86">D.2.1.</a>&nbsp;
Identification<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor87">D.2.2.</a>&nbsp;
Definition<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor88">D.2.3.</a>&nbsp;
Example<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor89">D.3.</a>&nbsp;
DSKPP-PRF-SHA256<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor90">D.3.1.</a>&nbsp;
Identification<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor91">D.3.2.</a>&nbsp;
Definition<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor92">D.3.3.</a>&nbsp;
Example<br />
<a href="#rfc.authors">&#167;</a>&nbsp;
Authors' Addresses<br />
</p>
<br clear="all" />

<a name="anchor1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1"></a><h3>1.&nbsp;
Introduction</h3>

<p>Symmetric key based cryptographic systems (e.g., those providing
      authentication mechanisms such as one-time passwords and
      challenge-response) offer performance and operational advantages over
      public key schemes. Such use requires a mechanism for provisioning of
      symmetric keys providing equivalent functionality to mechanisms such as
      CMP <a class='info' href='#RFC4210'>[RFC4210]<span> (</span><span class='info'>Adams, C., Farrell, S., Kause, T., and T. Mononen, &ldquo;Internet X.509 Public Key Infrastructure Certificate           Management Protocol (CMP),&rdquo; September&nbsp;2005.</span><span>)</span></a> and CMMC <a class='info' href='#RFC5272'>[RFC5272]<span> (</span><span class='info'>Schaad, J. and M. Myers, &ldquo;Certificate Management over CMS (CMC),&rdquo; June&nbsp;2008.</span><span>)</span></a> in a Public Key Infrastructure.
</p>
<p>Traditionally, cryptographic modules have been provisioned with keys
      during device manufacturing, and the keys have been imported to the
      cryptographic server using, e.g., a CD-ROM disc shipped with the
      devices. Some vendors also have proprietary provisioning protocols,
      which often have not been publicly documented (CT-KIP is one exception
      <a class='info' href='#RFC4758'>[RFC4758]<span> (</span><span class='info'>RSA, The Security Division of EMC, &ldquo;Cryptographic Token Key Initialization Protocol           (CT-KIP),&rdquo; November&nbsp;2006.</span><span>)</span></a>).
</p>
<p>This document describes the Dynamic Symmetric Key Provisioning
      Protocol (DSKPP), a client-server protocol for provisioning symmetric
      keys between a cryptographic module (corresponding to DSKPP client) and
      a key provisioning server (corresponding to DSKPP server).
</p>
<p>DSKPP provides an open and interoperable mechanism for initializing
      and configuring symmetric keys to cryptographic modules that are
      accessible over the Internet. The description is based on the
      information contained in <a class='info' href='#RFC4758'>[RFC4758]<span> (</span><span class='info'>RSA, The Security Division of EMC, &ldquo;Cryptographic Token Key Initialization Protocol           (CT-KIP),&rdquo; November&nbsp;2006.</span><span>)</span></a>, and contains
      specific enhancements, such as User Authentication and support for the
      <a class='info' href='#PSKC'>[PSKC]<span> (</span><span class='info'>, &ldquo;Portable Symmetric Key Container,&rdquo; 2008.</span><span>)</span></a> format for transmission of keying
      material.
</p>
<p>DSKPP has two principal protocol variants. The four-pass protocol
      variant permits a symmetric key to be established that includes
      randomness contributed by both the client and the server. The two-pass
      protocol requires only one round trip instead of two and permits a
      server specified key to be established.
</p>
<a name="anchor2"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1.1"></a><h3>1.1.&nbsp;
Key Words</h3>

<p>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
        "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
        document are to be interpreted as described in <a class='info' href='#RFC2119'>[RFC2119]<span> (</span><span class='info'>, &ldquo;Key words for use in RFCs to Indicate Requirement           Levels,&rdquo; March&nbsp;1997.</span><span>)</span></a>.
</p>
<a name="anchor3"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1.2"></a><h3>1.2.&nbsp;
Versions</h3>

<p>There is a provision made in the syntax for an explicit version
        number. Only version "1.0" is currently specified.
</p>
<a name="anchor4"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1.3"></a><h3>1.3.&nbsp;
Namespace Identifiers</h3>

<p>This document uses Uniform Resource Identifiers <a class='info' href='#RFC2396'>[RFC2396]<span> (</span><span class='info'>Berners-Lee, T., Fielding, R., and L. Masinter, &ldquo;Uniform Resource Identifiers (URI): Generic Syntax,&rdquo; August&nbsp;1998.</span><span>)</span></a> to identify resources, algorithms, and
        semantics.
</p>
<a name="anchor5"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1.3.1"></a><h3>1.3.1.&nbsp;
Defined Identifiers</h3>

<p>The XML namespace <a class='info' href='#XMLNS'>[XMLNS]<span> (</span><span class='info'>W3C, &ldquo;Namespaces in XML,&rdquo; January&nbsp;1999.</span><span>)</span></a> URI for Version
          1.0 of DSKPP protocol is:
</p>
<p>xmlns:dskpp="urn:ietf:params:xml:ns:keyprov:dskpp"
</p>
<p>References to qualified elements in the DSKPP schema defined
          herein use the prefix "dskpp".
</p>
<a name="anchor6"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1.3.2"></a><h3>1.3.2.&nbsp;
Identifiers Defined in Related Specifications</h3>

<p>This document relies on qualified elements already defined in the
          Portable Symmetric Key Container <a class='info' href='#PSKC'>[PSKC]<span> (</span><span class='info'>, &ldquo;Portable Symmetric Key Container,&rdquo; 2008.</span><span>)</span></a>
          namespace, which is represented by the prefix "pskc" and declared
          as:
</p>
<p>xmlns:pskc="urn:ietf:params:xml:ns:keyprov:pskc"
</p>
<a name="anchor7"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1.3.3"></a><h3>1.3.3.&nbsp;
Referenced Identifiers</h3>

<p>Finally, the DSKPP syntax presented in this document relies on
          algorithm identifiers defined in the XML Signature <a class='info' href='#XMLDSIG'>[XMLDSIG]<span> (</span><span class='info'>W3C, &ldquo;XML Signature Syntax and Processing,&rdquo; February&nbsp;2002.</span><span>)</span></a> namespace:
</p>
<p>xmlns:ds="http://www.w3.org/2000/09/xmldsig#"
</p>
<p>References to algorithm identifiers in the XML Signature
          namespace are represented by the prefix "ds".
</p>
<a name="terms"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2"></a><h3>2.&nbsp;
Terminology</h3>

<a name="Subsection-Definitions"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2.1"></a><h3>2.1.&nbsp;
Definitions</h3>

<p>The definitions provided below are defined as used in this
        document. The same terms may be defined differently in other
        documents.
</p>
<p></p>
<blockquote class="text"><dl>
<dt>Authentication Code (AC):</dt>
<dd>User Authentication Code
            comprised of a string of numeric characters known to the device
            and the server and containing a client identifier and a password.
            This ClientID/password combination is used only once, and then
            discarded.<br />

</dd>
<dt>Authentication Data (AD):</dt>
<dd>User Authentication Data
            that is derived from the Authentication Code (AC)<br />

</dd>
<dt>Client ID:</dt>
<dd>An identifier that the DSKPP Server uses
            to locate the real user name or account identifier on the server.
            It can be a short random identifier that is unrelated to any real
            usernames.<br />

</dd>
<dt>Cryptographic Module:</dt>
<dd>A component of an application,
            which enables symmetric key cryptographic functionality<br />

</dd>
<dt>Device:</dt>
<dd>A physical piece of hardware, or a software
            framework, that hosts symmetric key cryptographic modules<br />

</dd>
<dt>Device ID (DeviceID):</dt>
<dd>A unique identifier for the
            device that houses the cryptographic module, e.g., a mobile
            phone<br />

</dd>
<dt>DSKPP Client:</dt>
<dd>Manages communication between the
            symmetric key cryptographic module and the DSKPP server<br />

</dd>
<dt>DSKPP Server:</dt>
<dd>The symmetric key provisioning server
            that participates in the DSKPP protocol run<br />

</dd>
<dt>DSKPP Server ID (ServerID):</dt>
<dd>The unique identifier of
            a DSKPP server<br />

</dd>
<dt>Key Agreement:</dt>
<dd>A key establishment protocol whereby
            two or more parties can agree on a key in such a way that both
            influence the outcome<br />

</dd>
<dt>Key Confirmation:</dt>
<dd>The assurance of the rightful
            participants in a key-establishment protocol that the intended
            recipient of the shared key actually possesses the shared
            key<br />

</dd>
<dt>Key Issuer:</dt>
<dd>An organization that issues symmetric
            keys to end-users<br />

</dd>
<dt>Key Package (KP):</dt>
<dd>An object that encapsulates a
            symmetric key and its configuration data<br />

</dd>
<dt>Key ID (KeyID):</dt>
<dd>A unique identifier for the
            symmetric key<br />

</dd>
<dt>Key Protection Method (KPM):</dt>
<dd>The key transport
            method used during two-pass DSKPP<br />

</dd>
<dt>Key Protection Method List (KPML):</dt>
<dd>The list of key
            protection methods supported by a cryptographic module<br />

</dd>
<dt>Key Provisioning Server:</dt>
<dd>A lifecycle management
            system that provides a key issuer with the ability to provision
            keys to cryptographic modules hosted on end-users' devices<br />

</dd>
<dt>Key Transport:</dt>
<dd>A key establishment procedure whereby
            the DSKPP server selects and encrypts the keying material and then
            sends the material to the DSKPP client <a class='info' href='#NIST-SP800-57'>[NIST&#8209;SP800&#8209;57]<span> (</span><span class='info'>National Institute of Standards and             Technology, &ldquo;Recommendation for Key Management - Part I: General           (Revised),&rdquo; March&nbsp;2007.</span><span>)</span></a><br />

</dd>
<dt>Key Transport Key:</dt>
<dd>The private key that resides on
            the cryptographic module. This key is paired with the DSKPP
            client's public key, which the DSKPP server uses to encrypt keying
            material during key transport <a class='info' href='#NIST-SP800-57'>[NIST&#8209;SP800&#8209;57]<span> (</span><span class='info'>National Institute of Standards and             Technology, &ldquo;Recommendation for Key Management - Part I: General           (Revised),&rdquo; March&nbsp;2007.</span><span>)</span></a><br />

</dd>
<dt>Key Type:</dt>
<dd>The type of symmetric key cryptographic
            methods for which the key will be used (e.g., OATH HOTP or RSA
            SecurID authentication, AES encryption, etc.)<br />

</dd>
<dt>Key Wrapping:</dt>
<dd>A method of encrypting keys for key
            transport <a class='info' href='#NIST-SP800-57'>[NIST&#8209;SP800&#8209;57]<span> (</span><span class='info'>National Institute of Standards and             Technology, &ldquo;Recommendation for Key Management - Part I: General           (Revised),&rdquo; March&nbsp;2007.</span><span>)</span></a><br />

</dd>
<dt>Key Wrapping Key:</dt>
<dd>A symmetric key encrypting key
            used for key wrapping <a class='info' href='#NIST-SP800-57'>[NIST&#8209;SP800&#8209;57]<span> (</span><span class='info'>National Institute of Standards and             Technology, &ldquo;Recommendation for Key Management - Part I: General           (Revised),&rdquo; March&nbsp;2007.</span><span>)</span></a><br />

</dd>
<dt>Keying Material:</dt>
<dd>The data necessary (e.g., keys and
            key configuration data) necessary to establish and maintain
            cryptographic keying relationships <a class='info' href='#NIST-SP800-57'>[NIST&#8209;SP800&#8209;57]<span> (</span><span class='info'>National Institute of Standards and             Technology, &ldquo;Recommendation for Key Management - Part I: General           (Revised),&rdquo; March&nbsp;2007.</span><span>)</span></a><br />

</dd>
<dt>Manufacturer's Key</dt>
<dd>A unique master key pre-issued to
            a hardware device, e.g., a smart card, during the manufacturing
            process. If present, this key may be used by a cryptographic
            module to derive secret keys<br />

</dd>
<dt>Protocol Run:</dt>
<dd>Complete execution of the DSKPP that
            involves one exchange (2-pass) or two exchanges (4-pass)<br />

</dd>
<dt>Security Attribute List (SAL):</dt>
<dd>A payload that
            contains the DSKPP version, DSKPP variant (four- or two-pass), key
            package formats, key types, and cryptographic algorithms that the
            cryptographic module is capable of supporting<br />

</dd>
<dt>Security Context (SC):</dt>
<dd>A payload that contains the
            DSKPP version, DSKPP variant (four- or two-pass), key package
            format, key type, and cryptographic algorithms relevant to the
            current protocol run<br />

</dd>
</dl></blockquote>

<a name="anchor8"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2.2"></a><h3>2.2.&nbsp;
Notation</h3>

<p></p>
<blockquote class="text"><dl>
<dt>||</dt>
<dd>String concatenation
</dd>
<dt>[x]</dt>
<dd>Optional element x
</dd>
<dt>A ^ B</dt>
<dd>Exclusive-OR operation on strings A and B
            (where A and B are of equal length)
</dd>
<dt>&lt;XMLElement&gt;</dt>
<dd>A typographical convention used
            in the body of the text
</dd>
<dt>DSKPP-PRF(k,s,dsLen)</dt>
<dd>A keyed pseudo-random
            function
</dd>
<dt>E(k,m)</dt>
<dd>Encryption of m with the key k
</dd>
<dt>K</dt>
<dd>Key used to encrypt R_C (either K_SERVER or
            K_SHARED), or in MAC or DSKPP_PRF computations
</dd>
<dt>K_AC</dt>
<dd>Secret key that is derived from the
            Authentication Code and used for user authentication
            purposes
</dd>
<dt>K_MAC</dt>
<dd>Secret key derived during a DSKPP exchange for
            use with key confirmation
</dd>
<dt>K_MAC'</dt>
<dd>A second secret key used for server
            authentication
</dd>
<dt>K_PROV</dt>
<dd>A provisioning master key from which two keys
            are derived: K_TOKEN and K_MAC
</dd>
<dt>K_SERVER</dt>
<dd>Public key of the DSKPP server; used for
            encrypting R_C in the four-pass protocol variant
</dd>
<dt>K_SHARED</dt>
<dd>Secret key that is pre-shared between the
            DSKPP client and the DSKPP server; used for encrypting R_C in the
            four-pass protocol variant
</dd>
<dt>K_TOKEN</dt>
<dd>Secret key that is established in a
            cryptographic module using DSKPP
</dd>
<dt>R</dt>
<dd>Pseudorandom value chosen by the DSKPP client and
            used for MAC computations
</dd>
<dt>R_C</dt>
<dd>Pseudorandom value chosen by the DSKPP client
            and used as input to the generation of K_TOKEN
</dd>
<dt>R_S</dt>
<dd>Pseudorandom value chosen by the DSKPP server
            and used as input to the generation of K_TOKEN
</dd>
<dt>URL_S</dt>
<dd>DSKPP server address, as a URL
</dd>
</dl></blockquote>

<a name="anchor9"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2.3"></a><h3>2.3.&nbsp;
Abbreviations</h3>

<p></p>
<blockquote class="text"><dl>
<dt>AC</dt>
<dd>Authentication Code
</dd>
<dt>AD</dt>
<dd>Authentication Data
</dd>
<dt>DSKPP</dt>
<dd>Dynamic Symmetric Key Provisioning
            Protocol
</dd>
<dt>HTTP</dt>
<dd>Hypertext Transfer Protocol
</dd>
<dt>KP</dt>
<dd>Key Package
</dd>
<dt>KPM</dt>
<dd>Key Protection Method
</dd>
<dt>KPML</dt>
<dd>Key Protection Method List
</dd>
<dt>MAC</dt>
<dd>Message Authentication Code
</dd>
<dt>PC</dt>
<dd>Personal Computer
</dd>
<dt>PDU</dt>
<dd>Protocol Data Unit
</dd>
<dt>PKCS</dt>
<dd>Public-Key Cryptography Standards
</dd>
<dt>PRF</dt>
<dd>Pseudo-Random Function
</dd>
<dt>PSKC</dt>
<dd>Portable Symmetric Key Container
</dd>
<dt>SAL</dt>
<dd>Security Attribute List (see <a class='info' href='#Subsection-Definitions'>Section&nbsp;2.1<span> (</span><span class='info'>Definitions</span><span>)</span></a>)
</dd>
<dt>SC</dt>
<dd>Security Context (see <a class='info' href='#Subsection-Definitions'>Section&nbsp;2.1<span> (</span><span class='info'>Definitions</span><span>)</span></a>)
</dd>
<dt>TLS</dt>
<dd>Transport Layer Security
</dd>
<dt>URL</dt>
<dd>Uniform Resource Locator
</dd>
<dt>USB</dt>
<dd>Universal Serial Bus
</dd>
<dt>XML</dt>
<dd>eXtensible Markup Language
</dd>
</dl></blockquote>

<a name="anchor10"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3"></a><h3>3.&nbsp;
DSKPP Overview</h3>

<p>The following sub-sections provide a high-level view of protocol
      internals and how they interact with external provisioning applications.
      Usage scenarios are provided in <a class='info' href='#Section-Usage-Scenarios'>Appendix&nbsp;A<span> (</span><span class='info'>Usage Scenarios</span><span>)</span></a>.
</p>
<a name="anchor11"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.1"></a><h3>3.1.&nbsp;
Protocol Entities</h3>

<p>A DSKPP provisioning transaction has three entities:
</p>
<p></p>
<blockquote class="text"><dl>
<dt>Server: </dt>
<dd>The DSKPP provisioning server.<br />

</dd>
<dt>Cryptographic Module:</dt>
<dd>The cryptographic module to
            which the symmetric keys are to be provisioned, e.g., an
            authentication token.<br />

</dd>
<dt>Client:</dt>
<dd>The DSKPP client which manages communication
            between the cryptographic module and the key provisioning
            server.
</dd>
</dl></blockquote>

<p>The principal syntax is XML and it is layered on a transport
        mechanism such as HTTP. While it is highly desirable for the entire
        communication between the DSKPP client and server to be protected by
        means of a transport providing confidentiality and integrity
        protection such as HTTP over Transport Layer Security (TLS), such
        protection is not sufficient to protect the exchange of the symmetric
        key data between the server and the cryptographic module and the DSKPP
        protocol is designed to permit implementations that satisfy this
        requirement.
</p>
<p>The server only communicates to the client. As far as the server is
        concerned, the client and cryptographic module may be considered to be
        a single entity.
</p>
<p>From a client-side security perspective, however, the client and
        the cryptographic module are separate logical entities and may in some
        implementations be separate physical entities as well.
</p>
<p>It is assumed that a device will host an application layered above
        the cryptographic module, and this application will manage
        communication between the DSKPP client and cryptographic module. The
        manner in which the communicating application will transfer DSKPP
        protocol elements to and from the cryptographic module is transparent
        to the DSKPP server. One method for this transfer is described in
        <a class='info' href='#CT-KIP-P11'>[CT&#8209;KIP&#8209;P11]<span> (</span><span class='info'>RSA Laboratories, &ldquo;PKCS #11 Mechanisms for the Cryptographic Token Key           Initialization Protocol,&rdquo; December&nbsp;2005.</span><span>)</span></a>.
</p>
<a name="Subsection-BasicExchange"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.2"></a><h3>3.2.&nbsp;
Basic DSKPP Exchange</h3>

<a name="Subsection-UserAuth"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.2.1"></a><h3>3.2.1.&nbsp;
User Authentication</h3>

<p>In a DSKPP message flow, the user has obtained a new hardware or
          software device embedded with a cryptographic module. The goal of
          DSKPP is to provision the same symmetric key and related information
          to the cryptographic module and the key management server, and
          associate the key with the correct user name (or other account
          identifier) on the server. To do this, the DSKPP Server MUST
          authenticate the user to be sure he is authorized for the new
          key.
</p>
<p>User authentication occurs within the protocol itself after<em></em> the DSKPP client initiates the first message.
          In this case, the DSKPP client MUST have access to the DSKPP Server
          URL.
</p>
<p>Alternatively, a DSKPP web service or other form of web
          application can authenticate a user before<em></em> the first message is exchanged. In this case, the DSKPP
          server MUST trigger the DSKPP client to initiate the first message
          in the protocol transaction.
</p>
<a name="anchor12"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.2.2"></a><h3>3.2.2.&nbsp;
Protocol Initiated by the DSKPP Client</h3>

<p>In the following example, the DSKPP client first initiates DSKPP,
          and then the user is authenticated using a Client ID and
          Authentication Code.
</p><br /><hr class="insert" />
<a name="BasicExchangeAC"></a>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre> Crypto       DSKPP                          DSKPP    Key Provisioning
 Module       Client                         Server        Server
  |             |                              |             |
  |             |                              |     +---------------+
  |             |                              |     |Server creates |
  |             |                              |     |and stores     |
  |             |                              |     |Client ID and  |
  |             |                              |     |Auth. Code and |
  |             |                              |     |delivers them  |
  |             |                              |     |to user out-of-|
  |             |                              |     |band.          |
  |             |                              |     +---------------+
  |             |                              |             |
  |  +----------------------+                  |             |
  |  |User enters Client ID,|                  |             |
  |  |Auth. Code, and URL   |                  |             |
  |  +----------------------+                  |             |
  |             |                              |             |
  |             |&lt;-- 1. TLS handshake with ---&gt;|             |
  |             |        server auth.          |             |
  |             |                              |             |
  |             | 2. &lt;KeyProvClientHello&gt; ----&gt;|     User --&gt;|
  |             |                              |     Auth.   |
  |             |&lt;-- [3. &lt;KeyProvServerHello&gt;] |             |
  |             |                              |             |
  |             | [4. &lt;KeyProvClientNonce&gt;] --&gt;|             |
  |             |                              |             |
  |             |&lt;- 5. &lt;KeyProvServerFinished&gt; |             |
  |             |                              |             |
  |             |                              |             |
  |&lt;-- Key      |                              |      Key --&gt;|
  |    Package  |                              |   Package   |
</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;1: Basic DSKPP Exchange&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>Before DSKPP begins:</p>
<ul class="text">
<li>The Authentication Code is generated by the DSKPP Server, and
              delivered to the user via an out-of-band trustworthy channel
              (e.g., a paper slip delivered by IT department staff).
</li>
<li>The user typically enters the Client ID and Authentication
              Code manually, possibly on a device with only numeric keypad.
              Thus, they are often short numeric values (for example, 8
              decimal digits). However, the DSKPP Server is free to generate
              them in any way it wishes.
</li>
<li>The DSKPP client needs the URL of the DSKPP server (which is
              not user-specific or secret, and may be pre-configured somehow),
              and a set of trust anchors for verifying the server
              certificate.
</li>
<li>There must be an account for the user that has an identifier
              and long-term user name (or other account identifier) to which
              the token will be associated. The DSKPP server will use the
              Client ID to find the corresponding Authentication Code for user
              authentication.
</li>
</ul>

<p>In Step 1, the client establishes a TLS connection, and
          authenticates the server (that is, validates the certificate, and
          compares the host name in the URL with the certificate).
</p>
<p>Next, the DSKPP Client and DSKPP Server exchange DSKPP messages
          (which are sent over HTTPS). In these messages:</p>
<ul class="text">
<li>The client and server negotiate which cryptographic
              algorithms they want to use; which algorithms are supported for
              protecting DSKPP messages, and other DSKPP protocol details.
</li>
<li>The client sends the Client ID to the server, and proves that
              it knows the corresponding Authentication Code.
</li>
<li>The client and server agree on a secret key (token key or
              K_TOKEN); depending on the negotiated protocol variant, this is
              either a fresh key derived during the DSKPP protocol run (called
              "four-pass variant", since it involves four DSKPP messages), or
              it is generated by (or pre-exists on) the server and transported
              to the client (called "two-pass variant" in the rest of this
              document, since it involves two DSKPP messages).
</li>
<li>The server sends a "key package" to the client. The package
              only includes the key itself in the case of the "two-pass
              variant"; with either variant, the key package contains
              attributes that influence how the provisioned key will be later
              used by the cryptographic module and cryptographic server. The
              exact contents depend on the cryptographic algorithm (e.g., for
              a one-time password algorithm that supports variable-length OTP
              values, the length of the OTP value would be one attribute in
              the key package).
</li>
</ul>

<p>After the protocol run has been successfully completed, the
          cryptographic modules stores the contents of the key package.
          Likewise, the DSKPP provisioning server stores the contents of the
          key package with the cryptographic server, and associates these with
          the correct user name. The user can now use the their device to
          perform symmetric-key based operations.
</p>
<p>The exact division of work between the cryptographic module and
          the DSKPP client -- and key Provisioning server and DSKPP server --
          are not specified in this document. The figure above shows one
          possible case, but this is intended for illustrative purposes
          only.
</p>
<a name="anchor13"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.2.3"></a><h3>3.2.3.&nbsp;
Protocol Triggered by the DSKPP Server</h3>

<p>In the first message flow (previous section), the Client ID and
          Authentication Code were delivered to the client by some out-of-band
          means (such as paper sent to the user).
</p><br /><hr class="insert" />
<a name="BasicExchangeWBA"></a>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
Web           DSKPP                          DSKPP            Web
Browser       Client                         Server          Server
  |              |                              |               |
  |&lt;-------- HTTPS browsing + some kind of user auth. ---------&gt;|
  |              |                              |               |
  | some HTTP request -----------------------------------------&gt;|
  |              |                              |
  |              |                              |&lt;-------------&gt;|
  |              |                              |               |
  |&lt;----------------------- HTTP response with &lt;KeyProvTrigger&gt; |
  |              |                              |               |
  | Trigger ----&gt;|                              |               |
  |              |                              |               |
  |              |&lt;-- 1. TLS handshake with ---&gt;|               |
  |              |        server auth.          |               |
  |              |                              |               |
  |              |     ... continues...         |               |
</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;2: DSKPP Exchange with Web-Based Authentication&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>In the second message flow, the user first authenticates to a web
          server (for example, IT department's "self-service" Intranet page),
          using an ordinary web browser and some existing credentials.
</p>
<p>The user then requests (by clicking a link or submitting a form)
          provisioning of a new key to the cryptographic module. The web
          server will reply with a &lt;KeyProvTrigger&gt; message that
          contains the Client ID, Authentication Code, and URL of the DSKPP
          server. This information is also needed by the DSKPP server; how the
          web server and DSKPP server interact is beyond the scope of this
          document.
</p>
<p>The &lt;KeyProvTrigger&gt; message is sent in a HTTP response,
          and it is marked with MIME type
          "application/vnd.ietf.keyprov.dskpp+xml". It is assumed the web
          browser has been configured to recognize this MIME type; the browser
          will start the DSKPP client, and provides it with the
          &lt;KeyProvTrigger&gt; message.
</p>
<p>The DSKPP client then contacts the DSKPP server, and uses the
          Client ID and Authentication Code (from the &lt;KeyProvTrigger&gt;
          messsage) the same way as in the first message flow.
</p>
<a name="anchor14"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.2.4"></a><h3>3.2.4.&nbsp;
Variants</h3>

<p>As noted in the previous section, once the protocol has started,
          the client and server MAY engage in either a two-pass or four-pass
          message exchange. The four-pass and two-pass protocols are
          appropriate in different deployment scenarios. The biggest
          differentiator between the two is that the two-pass protocol
          supports transport of an existing key to a cryptographic module,
          while the four-pass involves key generation on-the-fly via key
          agreement. In either case, both protocol variants support algorithm
          agility through negotiation of encryption mechanisms and key types
          at the beginning of each protocol run.
</p>
<a name="anchor15"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.2.4.1"></a><h3>3.2.4.1.&nbsp;
Criteria for Using the Four-Pass Variant</h3>

<p>The four-pass protocol is needed under one or more of the
            following conditions:</p>
<ul class="text">
<li>Policy requires that both parties engaged in the protocol
                jointly contribute entropy to the key. Enforcing this policy
                mitigates the risk of exposing a key during the provisioning
                process as the key is generated through mutual agreement
                without being transferred over-the-air or over-the-wire. It
                also mitigates risk of exposure after the key is provisioned,
                as the key will not be vulnerable to a single point of attack
                in the system.
</li>
<li>A cryptographic module does not have private-key
                capabilities.
</li>
<li>The cryptographic module is hosted by a device that was
                neither pre-issued with a manufacturer's key or other form of
                pre-shared key (as might be the case with a smart card or SIM
                card) nor has a keypad that can be used for entering a
                passphrase (such as present on a mobile phone).
</li>
</ul>

<a name="anchor16"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.2.4.2"></a><h3>3.2.4.2.&nbsp;
Criteria for Using the Two-Pass Variant</h3>

<p>The two-pass protocol is needed under one or more of the
            following conditions:</p>
<ul class="text">
<li>Pre-existing (i.e., legacy) keys must be provisioned via
                transport to the cryptographic module.
</li>
<li>The cryptographic module is hosted on a device that was
                pre-issued with a manufacturer's key (such as may exist on a
                smart card), or other form of pre-shared key (such as may
                exist on a SIM-card), and is capable of performing private-key
                operations.
</li>
<li>The cryptographic module is hosted by a device that has a
                built-in keypad with which a user may enter a passphrase,
                useful for deriving a key wrapping key for distribution of
                keying material.
</li>
</ul>

<a name="anchor17"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.3"></a><h3>3.3.&nbsp;
Status Codes</h3>

<p>Upon transmission or receipt of a message for which the Status
        attribute's value is not "Success" or "Continue", the default
        behavior, unless explicitly stated otherwise below, is that both the
        DSKPP server and the DSKPP client MUST immediately terminate the DSKPP
        protocol run. DSKPP servers and DSKPP clients MUST delete any secret
        values generated as a result of failed runs of the DSKPP protocol.
        Session identifiers MAY be retained from successful or failed protocol
        runs for replay detection purposes, but such retained identifiers MUST
        NOT be reused for subsequent runs of the protocol.
</p>
<p>When possible, the DSKPP client SHOULD present an appropriate error
        message to the user.
</p>
<p>These status codes are valid in all DSKPP Response messages unless
        explicitly stated otherwise:<br />
<br />
</p>
<blockquote class="text"><dl>
<dt>Continue:</dt>
<dd>The DSKPP server is ready for a subsequent
            request from the DSKPP client. It cannot be sent in the server's
            final message<br />

</dd>
<dt>Success:</dt>
<dd>Successful completion of the DSKPP session.
            It can only be sent in the server's final message<br />

</dd>
<dt>Abort:</dt>
<dd>The DSKPP server rejected the DSKPP client's
            request for unspecified reasons<br />

</dd>
<dt>AccessDenied:</dt>
<dd>The DSKPP client is not authorized to
            contact this DSKPP server<br />

</dd>
<dt>MalformedRequest:</dt>
<dd>The DSKPP server failed to parse
            the DSKPP client's request<br />

</dd>
<dt>UnknownRequest:</dt>
<dd>The DSKPP client made a request that
            is unknown to the DSKPP server<br />

</dd>
<dt>UnknownCriticalExtension:</dt>
<dd>In order to assure that
            all implementations of DSKPP can interoperate, the DSKPP server:A
            critical DSKPP extension (see below) used by the DSKPP client was
            not supported or recognized by the DSKPP server<br />

</dd>
<dt>UnsupportedVersion:</dt>
<dd>The DSKPP client used a DSKPP
            protocol version not supported by the DSKPP server. This error is
            only valid in the DSKPP server's first response message<br />

</dd>
<dt>NoSupportedKeyTypes:</dt>
<dd>"NoSupportedKeyTypes" indicates
            that the DSKPP client only suggested key types that are not
            supported by the DSKPP server. This error is only valid in the
            DSKPP server's first response message<br />

</dd>
<dt>NoSupportedEncryptionAlgorithms:</dt>
<dd>The DSKPP client
            only suggested encryption algorithms that are not supported by the
            DSKPP server. This error is only valid in the DSKPP server's first
            response message<br />

</dd>
<dt>NoSupportedMacAlgorithms:</dt>
<dd>The DSKPP client only
            suggested MAC algorithms that are not supported by the DSKPP
            server. This error is only valid in the DSKPP server's first
            response message<br />

</dd>
<dt>NoProtocolVariants:</dt>
<dd>The DSKPP client only suggested
            a protocol variant (either 2-pass or 4-pass) that is not supported
            by the DSKPP server. This error is only valid in the DSKPP
            server's first response message<br />

</dd>
<dt>NoSupportedKeyPackages:</dt>
<dd>The DSKPP client only
            suggested key package formats that are not supported by the DSKPP
            server. This error is only valid in the DSKPP server's first
            response message<br />

</dd>
<dt>AuthenticationDataMissing:</dt>
<dd>The DSKPP client didn't
            provide authentication data that the DSKPP server required<br />

</dd>
<dt>AuthenticationDataInvalid:</dt>
<dd>The DSKPP client supplied
            user authentication data that the DSKPP server failed to
            validate<br />

</dd>
<dt>InitializationFailed:</dt>
<dd>The DSKPP server could not
            generate a valid key given the provided data. When this status
            code is received, the DSKPP client SHOULD try to restart DSKPP, as
            it is possible that a new run will succeed<br />

</dd>
<dt>ProvisioningPeriodExpired:</dt>
<dd>The provisioning period
            set by the DSKPP server has expired. When the status code is
            received, the DSKPP client SHOULD report the reason for key
            initialization failure to the user and the user MUST register with
            the DSKPP server to initialize a new key<br />

</dd>
</dl></blockquote>

<a name="anchor18"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.4"></a><h3>3.4.&nbsp;
Basic Constructs</h3>

<p>The following calculations are used in both DSKPP protocol
        variants.
</p>
<a name="Subsection-AD"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.4.1"></a><h3>3.4.1.&nbsp;
User Authentication Data, AD</h3>

<p>User authentication data (AD) is derived from a Client ID and
          Authentication Code that the user enters before the first DSKPP
          message is sent.
</p>
<p>Note: The user will typically enter the Client ID and
          Authentication Code manually, possibly on a device with only numeric
          keypad. Thus, they are often short numeric values (for example, 8
          decimal digits). However, the DSKPP Server is free to generate them
          in any way it wishes.
</p>
<a name="anchor19"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.4.1.1"></a><h3>3.4.1.1.&nbsp;
Authentication Code Format</h3>

<p>AC is encoded in Type-Length-Value (TLV) format. The format
            consists of a minimum of two TLVs and a variable number of
            additional TLVs, depending on implementation.
</p>
<p>The TLV fields are defined as follows:
</p>
<p></p>
<blockquote class="text"><dl>
<dt>Type (1 byte)</dt>
<dd>The integer value identifying the
                type of information contained in the value field.<br />

</dd>
<dt>Length (1 byte)</dt>
<dd>The length, in hexadecimal, of
                the value field to follow.<br />

</dd>
<dt>Value (variable length)</dt>
<dd>A variable-length
                hexadecimal value containing the instance-specific information
                for this TLV.
</dd>
</dl></blockquote>

<p>A 1 byte type field identifies the specific TLV, and a 1 byte
            length, in hexadecimal, indicates the length of the value field
            contained in the TLV. A TLV MUST start on a 4 byte boundary. Pad
            bytes MUST be placed at the end of the previous TLV in order to
            align the next TLV. These pad bytes are not counted in the length
            field of the TLV.
</p>
<p>The following table summarizes the TLVs defined in this
            document. Optional TLVs are allowed for vendor-specific extensions
            with the constraint that the high bit MUST be set to indicate a
            vendor-specific type. Other TLVs are left for later revisions of
            this protocol.
</p>
<p>
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>+------+------------+-------------------------------------------+
| Type | TLV Name   | Conformance | Example Usage               |
+------+------------+-------------------------------------------+
|  1   | Client ID  | Mandatory   | { "AC00000A" }              |
+------+------------+-------------+-----------------------------+
|  2   | Password   | Mandatory   | { "3582" }                  |
+------+------------+-------------+-----------------------------+
|  3   | Checksum   | Optional    | { 0x5F8D }                  |
+------+------------+-------------+-----------------------------+</pre></div>
<p>
</p>
<p>The Client ID is a mandatory TLV that represents the
            requester's identifier of maximum length 128. The value is
            represented as an ASCII string that identifies the key request.
            The clientID MUST be HEX encoded. For example, suppose clientID is
            set to "AC00000A", the hexadecimal equivalent is
            0x4143303030303041, resulting in a TLV of {0x1, 0x8,
            0x4143303030303041}.
</p>
<p>The Password is a mandatory TLV the contains a one-time use
            shared secret known by the user and the Provisioning Server. The
            password value is unique and SHOULD be a random string to make AC
            more difficult to guess. The string MUST be UTF-8 encoded in
            accordance with <a class='info' href='#RFC3629'>[RFC3629]<span> (</span><span class='info'>, &ldquo;UTF-8, a transformation format of ISO10646,&rdquo; November&nbsp;2003.</span><span>)</span></a>. For example,
            suppose password is set to "3582", then the TLV would be {0x2,
            0x4, UTF-8("3582")}.
</p>
<p>The Checksum is an OPTIONAL TLV, which is generated by the
            issuing server and sent to the user as part of the AC. If the TLV
            is provided, the checksum value MUST be computed using the CRC16
            algorithm <a class='info' href='#ISO3309'>[ISO3309]<span> (</span><span class='info'>, &ldquo;ISO Information Processing Systems - Data Communication -           High-Level Data Link Control Procedure - Frame Structure,&rdquo; October&nbsp;1984.</span><span>)</span></a>. When the user enters the
            AC, the typed password is verified with the checksum to ensure it
            is correctly entered by the user. For example, suppose the
            Password is set to "3582", then the CRC16 calculation would
            generate a checksum of 0x5F8D, resulting in TLV {0x3, 0x2,
            0x5F8D}.
</p>
<a name="Subsection-ADMAC"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.4.1.2"></a><h3>3.4.1.2.&nbsp;
User Authentication Data Calculation</h3>

<p>The Authentication Data consists of a Client ID (extracted from
            the AC) and a value, which is derived from AC as follows (refer to
            <a class='info' href='#DSKPP-PRF'>Section&nbsp;3.4.2<span> (</span><span class='info'>The DSKPP One-Way Pseudorandom Function, DSKPP-PRF</span><span>)</span></a> for a description of DSKPP-PRF in
            general and <a class='info' href='#Section-PRFRealizations'>Appendix&nbsp;D<span> (</span><span class='info'>Example of DSKPP-PRF Realizations</span><span>)</span></a> for a
            description of DSKPP-PRF-AES):
</p>
<p>MAC = DSKPP-PRF(K_AC, AC-&gt;clientID||URL_S||R_C||[R_S],
            16)
</p>
<p>In four-pass DSKPP, the cryptographic module uses R_C, R_S, and
            URL_S to calculate the MAC, where URL_S is the URL the DSKPP
            client uses when contacting the DSKPP server. In two-pass DSKPP,
            the cryptographic module does not have access to R_S, therefore
            only R_C is used in combination with URL_S to produce the MAC. In
            either case, K_AC MUST be derived from AC-&gt;password as follows
            <a class='info' href='#PKCS-5'>[PKCS&#8209;5]<span> (</span><span class='info'>RSA Laboratories, &ldquo;Password-Based Cryptography Standard,&rdquo; March&nbsp;1999.</span><span>)</span></a>:
</p>
<p>K_AC = PBKDF2(AC-&gt;password, R_C || K, iter_count, 16)
</p>
<p>One of the following values for K MUST be used:<br />
<br />
</p>
<blockquote class="text"><dl>
<dt>a.</dt>
<dd>In four-pass: 
<ul class="text">
<li>The public key of the DSKPP server (K_SERVER), or (in
                    the pre-shared key variant) the pre-shared key between the
                    client and the server (K_SHARED)<br />
<br />

</li>
</ul>
</dd>
<dt>b.</dt>
<dd>In two-pass:
<ul class="text">
<li>The public key of the DSKPP client, or the public key
                    of the device when a device certificate is available
</li>
<li>The pre-shared key between the client and the server
                    (K_SHARED)
</li>
<li>A passphrase-derived key
</li>
</ul>
</dd>
</dl></blockquote><br />
<br />
<p>The iteration count, iter_count,
            MUST be set to at least 100,000 except for case (b) and (c),
            above, in which case it MUST be set to 1.
</p>
<a name="DSKPP-PRF"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.4.2"></a><h3>3.4.2.&nbsp;
The DSKPP One-Way Pseudorandom Function, DSKPP-PRF</h3>

<p>Regardless of the protocol variant employed, there is a
          requirement for a cryptographic primitive that provides a
          deterministic transformation of a secret key k and a varying length
          octet string s to a bit string of specified length dsLen.
</p>
<p>This primitive must meet the same requirements as for a keyed
          hash function: It MUST take an arbitrary length input, and generate
          an output that is one-way and collision-free (for a definition of
          these terms, see, e.g., <a class='info' href='#FAQ'>[FAQ]<span> (</span><span class='info'>RSA Laboratories, &ldquo;Frequently Asked Questions About Today's Cryptography,&rdquo; 2000.</span><span>)</span></a>). Further, its
          output MUST be unpredictable even if other outputs for the same key
          are known.
</p>
<p>From the point of view of this specification, DSKPP-PRF is a
          "black-box" function that, given the inputs, generates a
          pseudorandom value and MAY be realized by any appropriate and
          competent cryptographic technique. <a class='info' href='#Section-PRFRealizations'>Appendix&nbsp;D<span> (</span><span class='info'>Example of DSKPP-PRF Realizations</span><span>)</span></a> contains two example
          realizations of DSKPP-PRF.
</p>
<p>DSKPP-PRF(k, s, dsLen)
</p>
<p>Input:
</p>
<p></p>
<blockquote class="text"><dl>
<dt>k</dt>
<dd>secret key in octet string format
</dd>
<dt>s</dt>
<dd>octet string of varying length consisting of
              variable data distinguishing the particular string being
              derived
</dd>
<dt>dsLen</dt>
<dd>desired length of the output
</dd>
</dl></blockquote>

<p>Output:
</p>
<p></p>
<blockquote class="text"><dl>
<dt>DS</dt>
<dd>pseudorandom string, dsLen-octets long
</dd>
</dl></blockquote>

<p>For the purposes of this document, the secret key k MUST be at
          least 16 octets long.
</p>
<a name="Subsection-MsgHashAlg"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.4.3"></a><h3>3.4.3.&nbsp;
The DSKPP Message Hash Algorithm</h3>

<p>When sending its last message in a protocol run, the DSKPP server
          generates a MAC that is used by the client for key confirmation.
          Computation of the MAC MUST include a hash of all DSKPP messages
          sent by the client and server during the transaction. To compute a
          message hash for the MAC given a sequence of DSKPP messages msg_1,
          ..., msg_n, the following operations MUST be carried out:<br />
<br />
</p>
<blockquote class="text"><dl>
<dt>a.</dt>
<dd>The sequence of messages contains all DSKPP Request and
              Response messages up to but not including this message.
</dd>
<dt>b.</dt>
<dd>Re-transmitted messages are removed from the sequence of
              messages.Note: The resulting sequence
              of messages MUST be an alternating sequence of DSKPP Request and
              DSKPP Response messages<br />

</dd>
<dt>c.</dt>
<dd>The contents of each message is concatenated together.
</dd>
<dt>d.</dt>
<dd>The resultant string is hashed using SHA-256 in accordance
              with <a class='info' href='#FIPS180-SHA'>[FIPS180&#8209;SHA]<span> (</span><span class='info'>National Institute of Standards and             Technology, &ldquo;Secure Hash Standard,&rdquo; February&nbsp;2004.</span><span>)</span></a>.
</dd>
</dl></blockquote>

<a name="Subsection-FourPassUsage"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4"></a><h3>4.&nbsp;
Four-Pass Protocol Usage</h3>

<p>This section describes the methods and message flow that comprise the
      four-pass protocol variant. Four-pass DSKPP depends on a client-server
      key agreement mechanism.
</p>
<a name="anchor20"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.1"></a><h3>4.1.&nbsp;
The Key Agreement Mechanism</h3>

<p>With 4-pass DSKPP, the symmetric key that is the target of
        provisioning, is generated on-the-fly without being transferred
        between the DSKPP client and DSKPP server. The data flow and
        computation are described below.
</p>
<a name="Subsection-FourPassDataFlow"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.1.1"></a><h3>4.1.1.&nbsp;
Data Flow</h3>

<p>A sample data flow showing key generation during the 4-pass
          protocol is shown in <a class='info' href='#keygen'>Figure&nbsp;3<span> (</span><span class='info'>Principal data flow for DSKPP key generation             - using public server key</span><span>)</span></a>.
</p><br /><hr class="insert" />
<a name="keygen"></a>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>+----------------------+                  +----------------------+
|    +------------+    |                  |                      |
|    | Server key |    |                  |                      |
| +&lt;-|  Public    |------&gt;-------------&gt;-------------+---------+ |
| |  |  Private   |    |                  |          |         | |
| |  +------------+    |                  |          |         | |
| |        |           |                  |          |         | |
| V        V           |                  |          V         V |
| |   +---------+      |                  |        +---------+ | |
| |   | Decrypt |&lt;-------&lt;-------------&lt;-----------| Encrypt | | |
| |   +---------+      |                  |        +---------+ | |
| |      |  +--------+ |                  |            ^       | |
| |      |  | Server | |                  |            |       | |
| |      |  | Random |---&gt;-------------&gt;------+  +----------+  | |
| |      |  +--------+ |                  |   |  | Client   |  | |
| |      |      |      |                  |   |  | Random   |  | |
| |      |      |      |                  |   |  +----------+  | |
| |      |      |      |                  |   |        |       | |
| |      V      V      |                  |   V        V       | |
| |   +------------+   |                  | +------------+     | |
| +--&gt;|  DSKPP PRF |   |                  | |  DSKPP PRF |&lt;----+ |
|     +------------+   |                  | +------------+       |
|           |          |                  |       |              |
|           V          |                  |       V              |
|       +-------+      |                  |   +-------+          |
|       |  Key  |      |                  |   |  Key  |          |
|       +-------+      |                  |   +-------+          |
|       +-------+      |                  |   +-------+          |
|       |Key Id |--------&gt;-------------&gt;------|Key Id |          |
|       +-------+      |                  |   +-------+          |
+----------------------+                  +----------------------+
      DSKPP Server                              DSKPP Client
</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;3: Principal data flow for DSKPP key generation             - using public server key&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>The inclusion of the two random nonces (R_S and R_C) in the key
          generation provides assurance to both sides (the cryptographic
          module and the DSKPP server) that they have contributed to the key's
          randomness and that the key is unique. The inclusion of the
          encryption key (K) ensures that no man-in-the-middle may be present,
          or else the cryptographic module will end up with a key different
          from the one stored by the legitimate DSKPP server.
</p>
<p>Conceptually, although R_C is one pseudorandom string, it may be
          viewed as consisting of two components, R_C1 and R_C2, where R_C1 is
          generated during the protocol run, and R_C2 can be pre-generated and
          loaded on the cryptographic module before the device is issued to
          the user. In that case, the latter string, R_C2, SHOULD be unique
          for each cryptographic module.
</p>
<p>A man-in-the-middle (in the form of corrupt client software or a
          mistakenly contacted server) may present his own public key to the
          cryptographic module. This will enable the attacker to learn the
          client's version of K_TOKEN. However, the attacker is not able to
          persuade the legitimate server to derive the same value for K_TOKEN,
          since K_TOKEN is a function of the public key involved, and the
          attacker's public key must be different than the correct server's
          (or else the attacker would not be able to decrypt the information
          received from the client). Therefore, once the attacker is no longer
          "in the middle," the client and server will detect that they are
          "out of sync" when they try to use their keys. In the case of
          encrypting R_C with K_SERVER, it is therefore important to verify
          that K_SERVER really is the legitimate server's key. One way to do
          this is to independently validate a newly generated K_TOKEN against
          some validation service at the server (e.g. using a connection
          independent from the one used for the key generation).
</p>
<a name="Subsection-4PassKeyGen"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.1.2"></a><h3>4.1.2.&nbsp;
Computation</h3>

<p>In DSKPP, the client and server both generate K_TOKEN and K_MAC
          by deriving them from a provisioning key (K_PROV) using the
          DSKPP-PRF function (refer to <a class='info' href='#DSKPP-PRF'>Section&nbsp;3.4.2<span> (</span><span class='info'>The DSKPP One-Way Pseudorandom Function, DSKPP-PRF</span><span>)</span></a>) as
          follows:
</p>
<p>K_PROV = DSKPP-PRF(k,s,dsLen), where<br />
<br />
</p>
<blockquote class="text">
<p>k = R_C (i.e., the secret random value chosen by the DSKPP
              client)<br />
<br />

</p>
<p>s = "Key generation" || K || R_S (where K is the key used to
              encrypt R_C and R_S is the random value chosen by the DSKPP
              server)<br />
<br />

</p>
<p>dsLen = (desired length of K_PROV whose first half
              constitutes K_MAC and second half constitutes K_TOKEN)
</p>
</blockquote>

<p>Then K_TOKEN and K_MAC are derived from K_PROV, where<br />
<br />
</p>
<blockquote class="text">
<p>K_PROV = K_MAC || K_TOKEN
</p>
</blockquote>

<p>When computing K_PROV, the derived keys, K_MAC and K_TOKEN, MAY
          be subject to an algorithm-dependent transform before being adopted
          as a key of the selected type. One example of this is the need for
          parity in DES keys.
</p>
<a name="Subsection-4PassFlow"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.2"></a><h3>4.2.&nbsp;
Message Flow</h3>

<p>The four-pass protocol flow consists of two message exchanges:</p>
<blockquote class="text"><dl>
<dt>1:</dt>
<dd>Pass 1 = &lt;KeyProvClientHello&gt;, Pass 2 =
            &lt;KeyProvServerHello&gt;
</dd>
<dt>2:</dt>
<dd>Pass 3 = &lt;KeyProvClientNonce&gt;, Pass 4 =
            &lt;KeyProvServerFinished&gt;
</dd>
</dl></blockquote>

<p>The first pair of messages negotiate cryptographic algorithms and
        exchange nonces. The second pair of messages establishes a symmetric
        key using mutually authenticated key agreement.
</p>
<p>The purpose and content of each message are described below. XML
        format and examples are in <a class='info' href='#Section-Schema'>Section&nbsp;8<span> (</span><span class='info'>DSKPP XML Schema</span><span>)</span></a> and
        <a class='info' href='#Section-Examples'>Appendix&nbsp;B<span> (</span><span class='info'>Examples</span><span>)</span></a>.
</p>
<a name="Subsection-Trigger"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.2.1"></a><h3>4.2.1.&nbsp;
KeyProvTrigger</h3>

<p>
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>        DSKPP Client                         DSKPP Server
        ------------                         ------------
                             [&lt;---]       AD, [DeviceID],
                                         [KeyID], [URL_S]</pre></div>
<p>
</p>
<p>When this message is sent:</p>
<blockquote class="text">
<p>The "trigger" message is optional. The DSKPP server sends
              this message after the following out-of-band steps are
              performed:</p>
<blockquote class="text"><dl>
<dt>1.</dt>
<dd>A user directed their browser to a key provisioning web
                  application and signs in (i.e., authenticates)
</dd>
<dt>2.</dt>
<dd>The user requests a key
</dd>
<dt>3.</dt>
<dd>The web application processes the request and returns an
                  authentication code to the user, e.g., in the form of an
                  email message
</dd>
<dt>4.</dt>
<dd>The web application retrieves the authentication code
                  from the user (possibly by asking the user to enter it using
                  a web form, or alternatively by the user selecting a URL in
                  which the authentication code is embedded)
</dd>
<dt>5.</dt>
<dd>The web application derives authentication data (AD) from
                  the authentication code as described in <a class='info' href='#Subsection-AD'>Section&nbsp;3.4.1<span> (</span><span class='info'>User Authentication Data, AD</span><span>)</span></a>
</dd>
<dt>6.</dt>
<dd>The web application passes AD, and possibly a DeviceID
                  (identifies a particular device to which the key MUST be
                  provisioned) and/or KeyID (identifies a key that will be
                  replaced) to the DSKPP server
</dd>
</dl></blockquote>

</blockquote>

<p>Purpose of this message:</p>
<blockquote class="text">
<p>To start a DSKPP session: The DSKPP server uses this message
              to trigger a client-side application to send the first DSKPP
              message.<br />
<br />

</p>
<p>To provide a way for the key provisioning system to get the
              DSKPP server URL to the DSKPP client.<br />
<br />
So
              the key provisioning system can point the DSKPP client to a
              particular cryptographic module that was pre-configured in the
              DSKPP provisioning server.<br />
<br />
In the case
              of key renewal, to identify the key to be replaced.
</p>
</blockquote>

<p>What is contained in this message:</p>
<blockquote class="text">
<p>AD MUST be provided to allow the DSKPP server to authenticate
              the user before completing the protocol run.<br />
<br />
A DeviceID MAY be included to allow a key
              provisioning application to bind the provisioned key to a
              specific device.<br />
<br />
A KeyID MAY be included
              to allow the key provisioning application to identify a key to
              be replaced, e.g., in the case of key renewal.<br />
<br />
The Server URL MAY be included to allow the key
              provisioning application to inform the DSKPP client of which
              server to contact
</p>
</blockquote>

<a name="anchor21"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.2.2"></a><h3>4.2.2.&nbsp;
KeyProvClientHello</h3>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
        DSKPP Client                         DSKPP Server
        ------------                         ------------
        SAL, [AD],
        [DeviceID], [KeyID]     ---&gt;</pre></div>
<p>
</p>
<p>When this message is sent:</p>
<blockquote class="text">
<p>When a DSKPP client first connects to a DSKPP server, it is
              required to send the &lt;KeyProvClientHello&gt; as its first
              message. The client can also send a &lt;KeyProvClientHello&gt;
              in response to a &lt;KeyProvTrigger&gt;.
</p>
</blockquote>

<p>What is contained in this message:</p>
<blockquote class="text">
<p>The Security Attribute List (SAL) included with
              &lt;KeyProvClientHello&gt; contains the combinations of DSKPP
              versions, variants, key package formats, key types, and
              cryptographic algorithms that the DSKPP client supports in order
              of the client's preference (favorite choice first). <br />
<br />
If &lt;KeyProvClientHello&gt; was preceded by a
              &lt;KeyProvTrigger&gt;, then this message MUST also include the
              Authentication (AD), DeviceID, and/or KeyID that was provided
              with the trigger. <br />
<br />
If
              &lt;KeyProvClientHello&gt; was not preceded by a
              &lt;KeyProvTrigger&gt;, then this message MAY contain a device
              ID that was pre-shared with the DSKPP server, and a key ID
              associated with a key previously provisioned by the DSKPP
              provisioning server.
</p>
</blockquote>

<p>Application note:</p>
<blockquote class="text">
<p>If this message is preceded by trigger message
              &lt;KeyProvTrigger&gt;, then the application will already have
              AD available (see <a class='info' href='#Subsection-Trigger'>Section&nbsp;4.2.1<span> (</span><span class='info'>KeyProvTrigger</span><span>)</span></a>).
              However, if this message was not preceded by
              &lt;KeyProvTrigger&gt;, then the application MUST retrieve the
              user authentication code, possibly by prompting the user to
              manually enter their authentication code, e.g., on a device with
              only a numeric keypad.<br />
<br />

</p>
<p>The application MUST also derive Authentication Data (AD)
              from the authentication code, as described in <a class='info' href='#Subsection-AD'>Section&nbsp;3.4.1<span> (</span><span class='info'>User Authentication Data, AD</span><span>)</span></a>, and save it for use in its next
              message, &lt;KeyProvClientNonce&gt;.
</p>
</blockquote>

<p>How the DSKPP server uses this message:</p>
<blockquote class="text">
<p>The DSKPP server will look for an acceptable combination of
              DSKPP version, variant (in this case, four-pass), key package
              format, key type, and cryptographic algorithms. If the DSKPP
              Client's SAL does not match the capabilities of the DSKPP
              Server, or does not comply with key provisioning policy, then
              the DSKPP Server will set the Status attribute to something
              other than "Continue". Otherwise, Status will be set to
              "Continue".<br />
<br />

</p>
<p>If included in &lt;KeyProvClientHello&gt;, the DSKPP server
              will validate the Authentication Data (AD), DeviceID, and KeyID.
              The DSKPP server MUST NOT accept the DeviceID unless the server
              sent the DeviceID in a preceding trigger message. Note that it
              is also legitimate for a DSKPP client to initiate the DSKPP
              protocol run without having received a &lt;KeyProvTrigger&gt;
              message from a server, but in this case any provided DeviceID
              MUST NOT be accepted by the DSKPP server unless the server has
              access to a unique key for the identified device and that key
              will be used in the protocol.
</p>
</blockquote>

<a name="Subsection-ServerHello"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.2.3"></a><h3>4.2.3.&nbsp;
KeyProvServerHello</h3>

<p>
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>        DSKPP Client                         DSKPP Server
        ------------                         ------------
                              &lt;---    SC, R_S, [K], [MAC]</pre></div>
<p>
</p>
<p>When this message is sent:</p>
<blockquote class="text">
<p>The DSKPP server will send this message in response to a
              &lt;KeyProvClientHello&gt; message after it looks for an
              acceptable combination of DSKPP version, variant (in this case,
              four-pass), key package format, key type, and set of
              cryptographic algorithms. If it could not find an acceptable
              combination, then it will still send the message, but with a
              failure status.
</p>
</blockquote>

<p>Purpose of this message:</p>
<blockquote class="text">
<p>With this message, the context for the protocol run is set.
              Furthermore, the DSKPP server uses this message to transmit a
              random nonce, which is required for each side to agree upon the
              same symmetric key (K_TOKEN).
</p>
</blockquote>

<p>What is contained in this message:</p>
<blockquote class="text">
<p>A status attribute equivalent to the server's return code to
              &lt;KeyProvClientHello&gt;. If the server found an acceptable
              set of attributes from the client's SAL, then it sets status to
              Continue and returns an SC, which specifies the DSKPP version
              and variant (in this case, four-pass), key type, cryptographic
              algorithms, and key package format that the DSKPP Client MUST
              use for the remainder of the protocol run.<br />
<br />

</p>
<p>A random nonce (R_S) for use in generating a symmetric key
              through key agreement; the length of R_S may depend on the
              selected key type. <br />
<br />

</p>
<p>A key (K) for the DSKPP Client to use for encrypting the
              client nonce included with &lt;KeyProvClientNonce&gt;. K
              represents the server's public key (K_SERVER) or a pre-shared
              secret key (K_SHARED).<br />
<br />
A MAC MUST be
              present if a key is being renewed so that the DSKPP client can
              confirm that the replacement key came from a trusted server.
              This MAC MUST be computed using DSKPP-PRF (see <a class='info' href='#DSKPP-PRF'>Section&nbsp;3.4.2<span> (</span><span class='info'>The DSKPP One-Way Pseudorandom Function, DSKPP-PRF</span><span>)</span></a>), where the input parameter k MUST be
              set to the existing MAC key K_MAC' (i.e., the value of the MAC
              key that existed before this protocol run; the implementation
              MAY specify K_MAC' to be the value of the K_TOKEN that is being
              replaced, or a version of K_MAC from the previous protocol run),
              and input parameter dsLen MUST be set to the length of R_S.
</p>
</blockquote>

<p>How the DSKPP client uses this message:</p>
<blockquote class="text">
<p>When the Status attribute is not set to "Continue", this
              indicates failure and the DSKPP client MUST abort the
              protocol.<br />
<br />

</p>
<p>If successful execution of the protocol will result in the
              replacement of an existing key with a newly generated one, the
              DSKPP client MUST verify the MAC provided in
              &lt;KeyProvServerHello&gt;. The DSKPP client MUST terminate the
              DSKPP session if the MAC does not verify, and MUST delete any
              nonces, keys, and/or secrets associated with the failed
              run.<br />
<br />

</p>
<p>If Status is set to "Continue" the cryptographic module
              generates a random nonce (R_C) using the cryptographic algorithm
              specified in SC. The length of the nonce R_C will depend on the
              selected key type.<br />
<br />

</p>
<p>Encrypt R_C using K and the encryption algorithm included in
              SC.
</p>
</blockquote>

<p>The method the DSKPP client MUST use to encrypt R_C:</p>
<blockquote class="text">
<p>If K is equivalent to K_SERVER (i.e., the public key of the
              DSKPP server), then an RSA encryption scheme from PKCS #1 <a class='info' href='#PKCS-1'>[PKCS&#8209;1]<span> (</span><span class='info'>RSA Laboratories, &ldquo;RSA Cryptography Standard,&rdquo; June&nbsp;2002.</span><span>)</span></a> MAY be used. If K is equivalent to
              K_SERVER, then the cryptographic module SHOULD verify the
              server's certificate before using it to encrypt R_C in
              accordance with <a class='info' href='#RFC5280'>[RFC5280]<span> (</span><span class='info'>Cooper, D., Santesson, S., Farrell, S., Boeyen, S., Housley, R., and W. Polk, &ldquo;Internet X.509 Public Key Infrastructure Certificate and           Certificate Revocation List (CRL) Profile,&rdquo; May&nbsp;2008.</span><span>)</span></a>.<br />
<br />
If K is equivalent to K_SHARED, the DSKPP
              client MAY use the DSKPP-PRF function to avoid dependence on
              other algorithms. In this case, the client uses K_SHARED as
              input parameter k (K_SHARED SHOULD be used solely for this
              purpose) as follows:<br />
<br />
dsLen = len(R_C),
              where "len" is the length of R_C<br />
DS =
              DSKPP-PRF(K_SHARED, "Encryption" || R_S, dsLen)<br />
<br />
This will produce a pseudorandom string DS of
              length equal to R_C. Encryption of R_C MAY then be achieved by
              XOR-ing DS with R_C:<br />
<br />
E(DS, R_C) = DS ^
              R_C<br />
<br />
The DSKPP server will then perform
              the reverse operation to extract R_C from E(DS, R_C).
</p>
</blockquote>

<a name="Subsection-Enc"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.2.4"></a><h3>4.2.4.&nbsp;
KeyProvClientNonce</h3>

<p>
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>        DSKPP Client                         DSKPP Server
        ------------                         ------------
        E(K,R_C), AD          ---&gt;</pre></div>
<p>
</p>
<p>When this message is sent:</p>
<blockquote class="text">
<p>The DSKPP client will send this message immediately following
              a &lt;KeyProvServerHello&gt; message whose status was set to
              "Continue".
</p>
</blockquote>

<p>Purpose of this message:</p>
<blockquote class="text">
<p>With this message the DSKPP client transmits user
              authentication data (AD) and a random nonce encrypted with the
              DSKPP server's key (K). The client's random nonce is required
              for each side to agree upon the same symmetric key
              (K_TOKEN).
</p>
</blockquote>

<p>What is contained in this message:</p>
<blockquote class="text">
<p>Authentication Data (AD) that was derived from an
              authentication code entered by the user before
              &lt;KeyProvClientHello&gt; was sent (refer to <a class='info' href='#Subsection-BasicExchange'>Section&nbsp;3.2<span> (</span><span class='info'>Basic DSKPP Exchange</span><span>)</span></a>).<br />
<br />

</p>
<p>The DSKPP client's random nonce (R_C), which was encrypted as
              described in <a class='info' href='#Subsection-ServerHello'>Section&nbsp;4.2.3<span> (</span><span class='info'>KeyProvServerHello</span><span>)</span></a>.
</p>
</blockquote>

<p>How the DSKPP server uses this message:</p>
<blockquote class="text">
<p>The DSKPP server MUST use AD to authenticate the user. If
              authentication fails, then the DSKPP server MUST set the return
              code to a failure status. <br />
<br />
If user
              authentication passes, the DSKPP server decrypts R_C using its
              key (K). The decryption method is based on whether K that was
              transmitted to the client in &lt;KeyProvServerHello&gt; was
              equal to the server's public key (K_SERVER) or a pre-shared key
              (K_SHARED) (refer to <a class='info' href='#Subsection-ServerHello'>Section&nbsp;4.2.3<span> (</span><span class='info'>KeyProvServerHello</span><span>)</span></a> for a description of how
              the DSKPP client encrypts R_C).<br />
<br />

</p>
<p>After extracting R_C, the DSKPP server computes K_TOKEN using
              a combination of the two random nonces R_S and R_C and its
              encryption key, K, as described in <a class='info' href='#Subsection-4PassKeyGen'>Section&nbsp;4.1.2<span> (</span><span class='info'>Computation</span><span>)</span></a>. The particular
              realization of DSKPP-PRF (e.g., those defined in <a class='info' href='#Section-PRFRealizations'>Appendix&nbsp;D<span> (</span><span class='info'>Example of DSKPP-PRF Realizations</span><span>)</span></a> depends on the MAC
              algorithm contained in the &lt;KeyProvServerHello&gt; message.
              The DSKPP server then generates a key package that contains key
              usage attributes such as expiry date and length. The key package
              MUST NOT include K_TOKEN since in the four-pass variant K_TOKEN
              is never transmitted between the DSKPP server and client. The
              server stores K_TOKEN and the key package with the user's
              account on the cryptographic server.
</p>
<p><br />
Finally, the server generates a key
              confirmation MAC that the client will use to avoid a false
              "Commit" message that would cause the cryptographic module to
              end up in state in which the server does not recognize the
              stored key.
</p>
</blockquote>

<p>The MAC used for key confirmation MUST be calculated as follows:
          </p>
<blockquote class="text">
<p>msg_hash = SHA-256(msg_1, ..., msg_n)<br />
<br />

</p>
<p>dsLen = len(msg_hash)<br />
<br />

</p>
<p>MAC = DSKPP-PRF (K_MAC, "MAC 2 computation" || msg_hash,
              dsLen)<br />
<br />

</p>
<p>where<br />
<br />
</p>
<blockquote class="text"><dl>
<dt>MAC</dt>
<dd>The DSKPP Pseudo-Random Function defined
                  in <a class='info' href='#DSKPP-PRF'>Section&nbsp;3.4.2<span> (</span><span class='info'>The DSKPP One-Way Pseudorandom Function, DSKPP-PRF</span><span>)</span></a> is used to compute the
                  MAC. The particular realization of DSKPP-PRF (e.g., those
                  defined in <a class='info' href='#Section-PRFRealizations'>Appendix&nbsp;D<span> (</span><span class='info'>Example of DSKPP-PRF Realizations</span><span>)</span></a>
                  depends on the MAC algorithm contained in the
                  &lt;KeyProvServerHello&gt; message. The MAC MUST be computed
                  using the existing MAC key (K_MAC), and a string that is
                  formed by concatenating the (ASCII) string "MAC 2
                  computation" and a msg_hash<br />

</dd>
<dt>K_MAC</dt>
<dd>The key derived from K_PROV, as
                  described in <a class='info' href='#Subsection-4PassKeyGen'>Section&nbsp;4.1.2<span> (</span><span class='info'>Computation</span><span>)</span></a>.<br />

</dd>
<dt>msg_hash</dt>
<dd>The message hash (defined in <a class='info' href='#Subsection-MsgHashAlg'>Section&nbsp;3.4.3<span> (</span><span class='info'>The DSKPP Message Hash Algorithm</span><span>)</span></a>) of messages msg_1,
                  ..., msg_n.
</dd>
</dl></blockquote>

</blockquote>

<a name="anchor22"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.2.5"></a><h3>4.2.5.&nbsp;
KeyProvServerFinished</h3>

<p>
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>        DSKPP Client                         DSKPP Server
        ------------                         ------------
                               &lt;---               KP, MAC</pre></div>
<p>
</p>
<p>When this message is sent:</p>
<blockquote class="text">
<p>The DSKPP server will send this message after authenticating
              the user and, if authentication passed, generating K_TOKEN and a
              key package, and associating them with the user's account on the
              cryptographic server.
</p>
</blockquote>

<p>Purpose of this message:</p>
<blockquote class="text">
<p>With this message the DSKPP server confirms generation of the
              key (K_TOKEN), and transmits the associated identifier and
              application-specific attributes, but not the key itself, in a
              key package to the client for protocol completion.
</p>
</blockquote>

<p>What is contained in this message:</p>
<blockquote class="text">
<p>A status attribute equivalent to the server's return code to
              &lt;KeyProvClientNonce&gt;. If user authentication passed, and
              the server successfully computed K_TOKEN, generated a key
              package, and associated them with the user's account on the
              cryptographic server, then it sets Status to Continue.<br />
<br />

</p>
<p>If status is Continue, then this message acts as a "commit"
              message, instructing the cryptographic module to store the
              generated key (K_TOKEN) and associate the given key identifier
              with this key. As such, a key package (KP) MUST be included in
              this message, which holds an identifier for the generated key
              (but not the key itself) and additional configuration, e.g., the
              identity of the DSKPP server, key usage attributes, etc. The
              default symmetric key package format MUST be based on the
              Portable Symmetric Key Container (PSKC) defined in <a class='info' href='#PSKC'>[PSKC]<span> (</span><span class='info'>, &ldquo;Portable Symmetric Key Container,&rdquo; 2008.</span><span>)</span></a>. Alternative formats MAY include <a class='info' href='#SKPC-ASN.1'>[SKPC&#8209;ASN.1]<span> (</span><span class='info'>, &ldquo;Symmetric Key Package Content Type,&rdquo; 2007.</span><span>)</span></a>, PKCS#12 <a class='info' href='#PKCS-12'>[PKCS&#8209;12]<span> (</span><span class='info'>, &ldquo;Personal Information Exchange Syntax Standard,&rdquo; 2005.</span><span>)</span></a>, or PKCS#5 XML <a class='info' href='#PKCS-5-XML'>[PKCS&#8209;5&#8209;XML]<span> (</span><span class='info'>RSA Laboratories, &ldquo;XML Schema for PKCS #5 Version 2.0,&rdquo; October&nbsp;2006.</span><span>)</span></a> format. <br />
<br />
With KP, the server includes a key confirmation
              MAC that the client uses to avoid a false "Commit". The MAC
              algorithm is the same DSKPP-PRF that was sent in the
              &lt;KeyProvServerHello&gt; message.
</p>
</blockquote>

<p>How the DSKPP client uses this message:</p>
<blockquote class="text">
<p>When the Status attribute is not set to "Continue", this
              indicates failure and the DSKPP client MUST abort the
              protocol.<br />
<br />

</p>
<p>After receiving a &lt;KeyProvServerFinished&gt; message with
              Status = "Success", the DSKPP client MUST verify the key
              confirmation MAC that was transmitted with this message. The
              DSKPP client MUST terminate the DSKPP session if the MAC does
              not verify, and MUST, in this case, also delete any nonces,
              keys, and/or secrets associated with the failed run of the
              protocol. <br />
<br />

</p>
<p>If &lt;KeyProvServerFinished&gt; has Status = "Success" and
              the MAC was verified, then the DSKPP client MUST calculate
              K_TOKEN from the combination of the two random nonces R_S and
              R_C and the server's encryption key, K, as described in <a class='info' href='#Subsection-4PassKeyGen'>Section&nbsp;4.1.2<span> (</span><span class='info'>Computation</span><span>)</span></a>. The DSKPP-PRF is the
              same one used for MAC computation. The DSKPP client associates
              the key package contained in &lt;KeyProvServerFinished&gt; with
              the generated key, K_TOKEN, and stores this data permanently on
              the cryptographic module. <br />
<br />

</p>
<p>After this operation, it MUST NOT be possible to overwrite
              the key unless knowledge of an authorizing key is proven through
              a MAC on a later &lt;KeyProvServerHello&gt; (and
              &lt;KeyProvServerFinished&gt;) message.
</p>
</blockquote>

<a name="Subsecton-TwoPass"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5"></a><h3>5.&nbsp;
Two-Pass Protocol Usage</h3>

<p>This section describes the methods and message flow that comprise the
      two-pass protocol variant. Two-pass DSKPP is essentially a transport of
      keying material from the DSKPP server to the DSKPP client. The DSKPP
      server transmits keying material in a key package formatted in
      accordance with <a class='info' href='#PSKC'>[PSKC]<span> (</span><span class='info'>, &ldquo;Portable Symmetric Key Container,&rdquo; 2008.</span><span>)</span></a>, <a class='info' href='#SKPC-ASN.1'>[SKPC&#8209;ASN.1]<span> (</span><span class='info'>, &ldquo;Symmetric Key Package Content Type,&rdquo; 2007.</span><span>)</span></a>, PKCS#12 <a class='info' href='#PKCS-12'>[PKCS&#8209;12]<span> (</span><span class='info'>, &ldquo;Personal Information Exchange Syntax Standard,&rdquo; 2005.</span><span>)</span></a>, or
      PKCS#5 XML <a class='info' href='#PKCS-5-XML'>[PKCS&#8209;5&#8209;XML]<span> (</span><span class='info'>RSA Laboratories, &ldquo;XML Schema for PKCS #5 Version 2.0,&rdquo; October&nbsp;2006.</span><span>)</span></a>.
</p>
<p>The keying material includes a provisioning master key, K_PROV, from
      which the DSKPP client derives two keys: the symmetric key to be
      established in the cryptographic module, K_TOKEN, and a key, K_MAC, used
      for server authentication and key confirmation. The keying material also
      includes key usage attributes, such as expiry date and length.
</p>
<p>The DSKPP server encrypts K_PROV to ensure that it is not exposed to
      any other entity than the DSKPP server and the cryptographic module
      itself. The DSKPP server uses any of three key protection methods to
      encrypt K_PROV: Key Transport, Key Wrap, and Passphrase-Based Key Wrap
      Key Protection Methods.
</p>
<p>While the DSKPP client and server may negotiate the key protection
      method to use, the actual key protection is carried out in the
      KeyPackage. For example, the default KeyPackage format
      urn:ietf:params:xml:ns:keyprov:pskc#KeyContainer from <a class='info' href='#PSKC'>[PSKC]<span> (</span><span class='info'>, &ldquo;Portable Symmetric Key Container,&rdquo; 2008.</span><span>)</span></a> specifies how a key should be protected, including
      the three key protection methods described here.
</p>
<a name="anchor23"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.1"></a><h3>5.1.&nbsp;
Key Protection Methods</h3>

<p>This section introduces three key protection methods for the
        two-pass variant. Additional methods MAY be defined by external
        entities or through the IETF process.
</p>
<a name="anchor24"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.1.1"></a><h3>5.1.1.&nbsp;
Key Transport</h3>

<p>Purpose of this method:</p>
<blockquote class="text">
<p>This method is intended for PKI-capable devices. The DSKPP
              server encrypts keying material and transports it to the DSKPP
              client. The server encrypts the keying material using the public
              key of the DSKPP client, whose private key part resides in the
              cryptographic module. The DSKPP client decrypts the keying
              material and uses it to derive the symmetric key, K_TOKEN.
</p>
</blockquote>

<p>This method is identified with the following URN: </p>
<blockquote class="text">
<p>urn:ietf:params:xml:schema:keyprov:dskpp#transport
</p>
</blockquote>

<p>The DSKPP server and client MUST support the following
          mechanism:</p>
<blockquote class="text">
<p>http://www.w3.org/2001/04/xmlenc#rsa-1_5 encryption mechanism
              defined in <a class='info' href='#XMLENC'>[XMLENC]<span> (</span><span class='info'>W3C, &ldquo;XML Encryption Syntax and Processing,&rdquo; December&nbsp;2002.</span><span>)</span></a>.
</p>
</blockquote>

<a name="anchor25"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.1.2"></a><h3>5.1.2.&nbsp;
Key Wrap</h3>

<p>Purpose of this method:</p>
<blockquote class="text">
<p>This method is ideal for pre-keyed devices, e.g., SIM cards.
              The DSKPP server encrypts keying material using a pre-shared key
              wrapping key and transports it to the DSKPP client. The DSKPP
              client decrypts the keying material, and uses it to derive the
              symmetric key, K_TOKEN.
</p>
</blockquote>

<p>This method is identified with the following URN: </p>
<blockquote class="text">
<p>urn:ietf:params:xml:schema:keyprov:dskpp#wrap
</p>
</blockquote>

<p>The DSKPP server and client MUST support one of the following key
          wrapping mechanisms:</p>
<blockquote class="text">
<p>KW-AES128 without padding; refer to
              http://www.w3.org/2001/04/xmlenc#kw-aes128 in <a class='info' href='#XMLENC'>[XMLENC]<span> (</span><span class='info'>W3C, &ldquo;XML Encryption Syntax and Processing,&rdquo; December&nbsp;2002.</span><span>)</span></a><br />
<br />

</p>
<p>KW-AES128 with padding; refer to
              http://www.w3.org/2001/04/xmlenc#kw-aes128 in <a class='info' href='#XMLENC'>[XMLENC]<span> (</span><span class='info'>W3C, &ldquo;XML Encryption Syntax and Processing,&rdquo; December&nbsp;2002.</span><span>)</span></a> and <a class='info' href='#AESKWPAD'>[AESKWPAD]<span> (</span><span class='info'>Housley, R. and M. Dworkin, &ldquo;Advanced Encryption Standard (AES) Key Wrap with Padding           Algorithm,&rdquo; March&nbsp;2009.</span><span>)</span></a>
              <br />
<br />

</p>
<p>AES-CBC-128; refer to <a class='info' href='#FIPS197-AES'>[FIPS197&#8209;AES]<span> (</span><span class='info'>National Institute of Standards and             Technology, &ldquo;Specification for the Advanced Encryption Standard           (AES),&rdquo; November&nbsp;2001.</span><span>)</span></a>
</p>
</blockquote>

<a name="anchor26"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.1.3"></a><h3>5.1.3.&nbsp;
Passphrase-Based Key Wrap</h3>

<p>Purpose of this method:</p>
<blockquote class="text">
<p>This method is a variation of the Key Wrap Method that is
              applicable to constrained devices with keypads, e.g., mobile
              phones. The DSKPP server encrypts keying material using a
              wrapping key derived from a user-provided passphrase, and
              transports the encrypted material to the DSKPP client. The DSKPP
              client decrypts the keying material, and uses it to derive the
              symmetric key, K_TOKEN. <br />
<br />

</p>
<p>To preserve the property of not exposing K_TOKEN to any other
              entity than the DSKPP server and the cryptographic module
              itself, the method SHOULD be employed only when the device
              contains facilities (e.g. a keypad) for direct entry of the
              passphrase.
</p>
</blockquote>

<p>This method is identified with the following URN: </p>
<blockquote class="text">
<p>urn:ietf:params:xml:schema:keyprov:dskpp#passphrase-wrap
</p>
</blockquote>

<p>The DSKPP server and client MUST support the following:</p>
<blockquote class="text">
<p></p>
<ul class="text">
<li>The PBES2 password-based encryption scheme defined in
                  <a class='info' href='#PKCS-5'>[PKCS&#8209;5]<span> (</span><span class='info'>RSA Laboratories, &ldquo;Password-Based Cryptography Standard,&rdquo; March&nbsp;1999.</span><span>)</span></a> (and identified as
                  http://www.rsasecurity.com/rsalabs/pkcs/schemas/pkcs-5#pbes2
                  in <a class='info' href='#PKCS-5-XML'>[PKCS&#8209;5&#8209;XML]<span> (</span><span class='info'>RSA Laboratories, &ldquo;XML Schema for PKCS #5 Version 2.0,&rdquo; October&nbsp;2006.</span><span>)</span></a>)<br />
<br />

</li>
<li>The PBKDF2 passphrase-based key derivation function also
                  defined in <a class='info' href='#PKCS-5'>[PKCS&#8209;5]<span> (</span><span class='info'>RSA Laboratories, &ldquo;Password-Based Cryptography Standard,&rdquo; March&nbsp;1999.</span><span>)</span></a> (and identified as
                  http://www.rsasecurity.com/rsalabs/pkcs/schemas/pkcs-5#pbkdf2
                  in <a class='info' href='#PKCS-5-XML'>[PKCS&#8209;5&#8209;XML]<span> (</span><span class='info'>RSA Laboratories, &ldquo;XML Schema for PKCS #5 Version 2.0,&rdquo; October&nbsp;2006.</span><span>)</span></a>)<br />
<br />

</li>
<li>One of the following key wrapping mechanisms:
<blockquote class="text"><dl>
<dt>a.</dt>
<dd>KW-AES128 without padding; refer to
                      http://www.w3.org/2001/04/xmlenc#kw-aes128 in <a class='info' href='#XMLENC'>[XMLENC]<span> (</span><span class='info'>W3C, &ldquo;XML Encryption Syntax and Processing,&rdquo; December&nbsp;2002.</span><span>)</span></a>
</dd>
<dt>b.</dt>
<dd>KW-AES128 with padding; refer to
                      http://www.w3.org/2001/04/xmlenc#kw-aes128 in <a class='info' href='#XMLENC'>[XMLENC]<span> (</span><span class='info'>W3C, &ldquo;XML Encryption Syntax and Processing,&rdquo; December&nbsp;2002.</span><span>)</span></a> and <a class='info' href='#AESKWPAD'>[AESKWPAD]<span> (</span><span class='info'>Housley, R. and M. Dworkin, &ldquo;Advanced Encryption Standard (AES) Key Wrap with Padding           Algorithm,&rdquo; March&nbsp;2009.</span><span>)</span></a>
</dd>
<dt>c.</dt>
<dd>AES-CBC-128; refer to <a class='info' href='#FIPS197-AES'>[FIPS197&#8209;AES]<span> (</span><span class='info'>National Institute of Standards and             Technology, &ldquo;Specification for the Advanced Encryption Standard           (AES),&rdquo; November&nbsp;2001.</span><span>)</span></a>
</dd>
</dl></blockquote>
</li>
</ul>

</blockquote>

<a name="Subsection-2PassFlow"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.2"></a><h3>5.2.&nbsp;
Message Flow</h3>

<p>The two-pass protocol flow consists of one exchange:</p>
<blockquote class="text"><dl>
<dt>1:</dt>
<dd>Pass 1 = &lt;KeyProvClientHello&gt;, Pass 2 =
            &lt;KeyProvServerFinished&gt;
</dd>
</dl></blockquote>

<p>Although there is no exchange of the &lt;ServerHello&gt; message or
        the &lt;ClientNonce&gt; message, the DSKPP client is still able to
        specify algorithm preferences and supported key types in the
        &lt;KeyProvClientHello&gt; message.
</p>
<p>The purpose and content of each message are described below. XML
        format and examples are in <a class='info' href='#Section-Schema'>Section&nbsp;8<span> (</span><span class='info'>DSKPP XML Schema</span><span>)</span></a> and
        <a class='info' href='#Section-Examples'>Appendix&nbsp;B<span> (</span><span class='info'>Examples</span><span>)</span></a>.
</p>
<a name="anchor27"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.2.1"></a><h3>5.2.1.&nbsp;
KeyProvTrigger</h3>

<p>The trigger message is used in exactly the same way for the
          two-pass variant as for the four-pass variant; refer to <a class='info' href='#Subsection-Trigger'>Section&nbsp;4.2.1<span> (</span><span class='info'>KeyProvTrigger</span><span>)</span></a>.
</p>
<a name="anchor28"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.2.2"></a><h3>5.2.2.&nbsp;
KeyProvClientHello</h3>

<p>
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>        DSKPP Client                         DSKPP Server
        ------------                         ------------
        SAL, AD, R_C,
        [DeviceID], [KeyID],
        KPML                   ---&gt;</pre></div>
<p>When this message is sent:</p>
<blockquote class="text">
<p>When a DSKPP client first connects to a DSKPP server, it is
              required to send the &lt;KeyProvClientHello&gt; as its first
              message. The client can also send &lt;KeyProvClientHello&gt; in
              response to a &lt;KeyProvTrigger&gt; message.
</p>
</blockquote>

<p>Purpose of this message:</p>
<blockquote class="text">
<p>With this message, the DSKPP client specifies its algorithm
              preferences and supported key types as well as which DSKPP
              versions, protocol variants (in this case "two-pass"), key
              package formats, and key protection methods that it supports.
              Furthermore, the DSKPP client facilitates user authentication by
              transmitting the authentication data (AD) that was provided by
              the user before the first DSKPP message was sent.
</p>
</blockquote>

<p>Application note:</p>
<blockquote class="text">
<p>This message MUST send user authentication data (AD) to the
              DSKPP server. If this message is preceded by trigger message
              &lt;KeyProvTrigger&gt;, then the application will already have
              AD available (see <a class='info' href='#Subsection-Trigger'>Section&nbsp;4.2.1<span> (</span><span class='info'>KeyProvTrigger</span><span>)</span></a>).
              However, if this message was not preceded by
              &lt;KeyProvTrigger&gt;, then the application MUST retrieve the
              user authentication code, possibly by prompting the user to
              manually enter their authentication code, e.g., on a device with
              only a numeric keypad.
</p>
<p>The application MUST also derive Authentication Data (AD)
              from the authentication code, as described in <a class='info' href='#Subsection-AD'>Section&nbsp;3.4.1<span> (</span><span class='info'>User Authentication Data, AD</span><span>)</span></a>, and save it for use in its next
              message, &lt;KeyProvClientNonce&gt;.
</p>
</blockquote>

<p>What is contained in this message:</p>
<blockquote class="text">
<p>The Security Attribute List (SAL) included with
              &lt;KeyProvClientHello&gt; contains the combinations of DSKPP
              versions, variants, key package formats, key types, and
              cryptographic algorithms that the DSKPP client supports in order
              of the client's preference (favorite choice first). <br />
<br />
Authentication Data (AD) that was either
              included with &lt;KeyProvTrigger&gt;, or generated as described
              in the "Application Note" above.<br />
<br />
The
              DSKPP client's random nonce (R_C), which is used to compute
              provisioning key (K_PROV). By inserting R_C into the DSKPP
              session, the DSKPP client is able to ensure the DSKPP server is
              live before committing the key. <br />
<br />
If
              &lt;KeyProvClientHello&gt; was preceded by a
              &lt;KeyProvTrigger&gt;, then this message MUST also include the
              DeviceID and/or KeyID that was provided with the trigger.
              Otherwise, if a trigger message did not precede
              &lt;KeyProvClientHello&gt;, then this message MAY include a
              device ID that was pre-shared with the DSKPP server, and MAY
              contain a key ID associated with a key previously provisioned by
              the DSKPP provisioning server.
</p>
<p><br />
The list of key protection methods
              (KPML) that the DSKPP client supports. Each item in the list MAY
              include an encryption key "payload" for the DSKPP server to use
              to protect keying material that it sends back to the client. The
              payload MUST be of type &lt;ds:KeyInfoType&gt; (<a class='info' href='#XMLDSIG'>[XMLDSIG]<span> (</span><span class='info'>W3C, &ldquo;XML Signature Syntax and Processing,&rdquo; February&nbsp;2002.</span><span>)</span></a>). For each key protection method, the
              allowable choices for &lt;ds:KeyInfoType&gt; are:<br />
<br />
</p>
<ul class="text">
<li>Key Transport<br />
Only those choices
                  of &lt;ds:KeyInfoType&gt; that identify a public key (i.e.,
                  &lt;ds:KeyName&gt;, &lt;ds:KeyValue&gt;,
                  &lt;ds:X509Data&gt;, or &lt;ds:PGPData&gt;). The
                  &lt;ds:X509Certificate&gt; option of the &lt;ds:X509Data&gt;
                  alternative is RECOMMENDED when the public key corresponding
                  to the private key on the cryptographic module has been
                  certified.<br />
<br />

</li>
<li>Key Wrap<br />
Only those choices of
                  &lt;ds:KeyInfoType&gt; that identify a symmetric key (i.e.,
                  &lt;ds:KeyName&gt; and &lt;ds:KeyValue&gt;). The
                  &lt;ds:KeyName&gt; alternative is RECOMMENDED.<br />
<br />

</li>
<li>Passphrase-Based Key Wrap<br />
The
                  &lt;ds:KeyName&gt; option MUST be used and the key name MUST
                  identify the passphrase that will be used by the server to
                  generate the key wrapping key. The identifier and passphrase
                  components of &lt;ds:KeyName&gt; MUST be set to the Client
                  ID and authentication code components of AD (same AD as
                  contained in this message).
</li>
</ul>

</blockquote>

<p>How the DSKPP server uses this message:</p>
<blockquote class="text">
<p>The DSKPP server will look for an acceptable combination of
              DSKPP version, variant (in this case, two-pass), key package
              format, key type, and cryptographic algorithms. If the DSKPP
              Client's SAL does not match the capabilities of the DSKPP
              Server, or does not comply with key provisioning policy, then
              the DSKPP Server will set the Status attribute to something
              other than "Continue". Otherwise, Status will be set to
              "Continue".<br />
<br />

</p>
<p>The DSKPP server will validate the DeviceID and KeyID if
              included in &lt;KeyProvClientHello&gt;. The DSKPP server MUST
              NOT accept the DeviceID unless the server sent the DeviceID in a
              preceding trigger message. Note that it is also legitimate for a
              DSKPP client to initiate the DSKPP protocol run without having
              received a &lt;KeyProvTrigger&gt; message from a server, but in
              this case any provided DeviceID MUST NOT be accepted by the
              DSKPP server unless the server has access to a unique key for
              the identified device and that key will be used in the
              protocol.<br />
<br />
The DSKPP server MUST use AD
              to authenticate the user. If authentication fails, then the
              DSKPP server MUST set the return code to a failure status, and
              MUST, in this case, also delete any nonces, keys, and/or secrets
              associated with the failed run of the protocol.<br />
<br />
If user authentication passes, the DSKPP server
              generates a key K_PROV, which MUST consist of two parts of equal
              length, where the first half constitutes K_MAC and the second
              half constitutes K_TOKEN, i.e.,<br />
<br />
</p>
<blockquote class="text">
<p>K_PROV = K_MAC || K_TOKEN<br />
<br />

</p>
</blockquote>

<p>The length of K_TOKEN (and hence also the length of K_MAC) is
              determined by the type of K_TOKEN, which MUST be one of the key
              types supported by the DSKPP client. <br />
<br />
Once K_PROV is computed, the DSKPP server
              selects one of the key protection methods from the DSKPP
              client's KPML, and uses that method and corresponding payload to
              encrypt K_PROV.
</p>
<p>The DSKPP server generates a key package to transport the key
              encryption method information and the encrypted provisioning key
              (K_PROV). The encrypted data format is subject to the choice
              supported by the selected key package. The key package MUST
              specify and use the selected key protection method and the key
              information that was received in
              &lt;KeyProvClientHello&gt;.<br />
<br />

</p>
<p>The key package also includes key usage attributes such as
              expiry date and length. The server stores the key package and
              K_TOKEN with a user account on the cryptographic server.<br />
<br />

</p>
<p>The server generates two MAC's, one for key confirmation and
              another for server authentication) that the client will use to
              avoid a false "Commit" message that would cause the
              cryptographic module to end up in state in which the server does
              not recognize the stored key.
</p>
</blockquote>

<p>The method the DSKPP server MUST use to calculate the key
          confirmation MAC:</p>
<blockquote class="text">
<p>msg_hash = SHA-256(msg_1, ..., msg_n)<br />
<br />

</p>
<p>dsLen = len(msg_hash)<br />
<br />

</p>
<p>MAC = DSKPP-PRF (K_MAC, "MAC 1 computation" || msg_hash ||
              ServerID, dsLen)<br />
<br />

</p>
<p>where
</p>
<p></p>
<blockquote class="text"><dl>
<dt>MAC</dt>
<dd>The MAC MUST be calculated using the
                  already established MAC algorithm and MUST be computed on
                  the (ASCII) string "MAC 1 computation", msg_hash, and
                  ServerID using the existing the MAC key K_MAC.<br />

</dd>
<dt>K_MAC</dt>
<dd>The key, along with K_TOKEN, that is
                  derived from K_PROV which the DSKPP server MUST provide to
                  the cryptographic module.<br />

</dd>
<dt>msg_hash</dt>
<dd>The message hash, defined in <a class='info' href='#Subsection-MsgHashAlg'>Section&nbsp;3.4.3<span> (</span><span class='info'>The DSKPP Message Hash Algorithm</span><span>)</span></a>, of messages msg_1,
                  ..., msg_n.<br />

</dd>
<dt>ServerID</dt>
<dd>The identifier that the DSKPP server
                  MUST include in the &lt;KeyPackage&gt; element of
                  &lt;KeyProvServerFinished&gt;.<br />

</dd>
</dl></blockquote>

<p>If DSKPP-PRF (defined in <a class='info' href='#DSKPP-PRF'>Section&nbsp;3.4.2<span> (</span><span class='info'>The DSKPP One-Way Pseudorandom Function, DSKPP-PRF</span><span>)</span></a>) is
              used as the MAC algorithm, then the input parameter s MUST
              consist of the concatenation of the (ASCII) string "MAC 1
              computation", msg_hash, and ServerID, and the parameter dsLen
              MUST be set to the length of msg_hash.
</p>
</blockquote>

<p>The method the DSKPP server MUST use to calculate the server
          authentication MAC:</p>
<blockquote class="text">
<p>The MAC MUST be computed on the (ASCII) string "MAC 2
              computation", the server identifier ServerID, and R, using a
              pre-existing MAC key K_MAC' (the MAC key that existed before
              this protocol run). Note that the implementation may specify
              K_MAC' to be the value of the K_TOKEN that is being replaced, or
              a version of K_MAC from the previous protocol run.<br />
<br />

</p>
<p>If DSKPP-PRF is used as the MAC algorithm, then the input
              parameter s MUST consist of the concatenation of the (ASCII)
              string "MAC 2 computation" ServerID, and R. The parameter dsLen
              MUST be set to at least 16 (i.e. the length of the MAC MUST be
              at least 16 octets):<br />
<br />

</p>
<p>dsLen &gt;= 16<br />
<br />

</p>
<p>MAC = DSKPP-PRF (K_MAC', "MAC 2 computation" || ServerID ||
              R, dsLen)<br />
<br />

</p>
<p>The MAC algorithm MUST be the same as the algorithm used by
              the DSKPP server to calculate the key confirmation MAC.
</p>
</blockquote>

<a name="anchor29"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.2.3"></a><h3>5.2.3.&nbsp;
KeyProvServerFinished</h3>

<p>
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>       DSKPP Client                         DSKPP Server
        ------------                         ------------
                               &lt;---           KP, MAC, AD
</pre></div>
<p>
</p>
<p>When this message is sent:</p>
<blockquote class="text">
<p>The DSKPP server will send this message after authenticating
              the user and, if authentication passed, generating K_TOKEN and a
              key package, and associating them with the user's account on the
              cryptographic server.
</p>
</blockquote>

<p>Purpose of this message:</p>
<blockquote class="text">
<p>With this message the DSKPP server transports a key package
              containing the encrypted provisioning key (K_PROV) and key usage
              attributes.
</p>
</blockquote>

<p>What is contained in this message:</p>
<blockquote class="text">
<p>A status attribute equivalent to the server's return code to
              &lt;KeyProvClientHello&gt;. If the server found an acceptable
              set of attributes from the client's SAL, then it sets status to
              Continue.<br />
<br />
The confirmation message MUST
              include the Key Package (KP) that holds the DSKPP Server's ID,
              key ID,key type, encrypted provisioning key (K_PROV), encryption
              method, and additional configuration information. The default
              symmetric key package format is based on the Portable Symmetric
              Key Container (PSKC) defined in <a class='info' href='#PSKC'>[PSKC]<span> (</span><span class='info'>, &ldquo;Portable Symmetric Key Container,&rdquo; 2008.</span><span>)</span></a>.
              Alternative formats MAY include <a class='info' href='#SKPC-ASN.1'>[SKPC&#8209;ASN.1]<span> (</span><span class='info'>, &ldquo;Symmetric Key Package Content Type,&rdquo; 2007.</span><span>)</span></a>, PKCS#12 <a class='info' href='#PKCS-12'>[PKCS&#8209;12]<span> (</span><span class='info'>, &ldquo;Personal Information Exchange Syntax Standard,&rdquo; 2005.</span><span>)</span></a>, or PKCS#5 XML <a class='info' href='#PKCS-5-XML'>[PKCS&#8209;5&#8209;XML]<span> (</span><span class='info'>RSA Laboratories, &ldquo;XML Schema for PKCS #5 Version 2.0,&rdquo; October&nbsp;2006.</span><span>)</span></a>. <br />
<br />
Finally,
              this message MUST include a MAC that the DSKPP client will use
              for key confirmation. It MUST also include a server
              authentication MAC (AD). These MACs are calculated as described
              in the previous section.
</p>
</blockquote>

<p>How the DSKPP client uses this message:</p>
<blockquote class="text">
<p>After receiving a &lt;KeyProvServerFinished&gt; message with
              Status = "Success", the DSKPP client MUST verify both MACs (MAC
              and AD). The DSKPP client MUST terminate the DSKPP protocol run
              if either MAC does not verify, and MUST, in this case, also
              delete any nonces, keys, and/or secrets associated with the
              failed run of the protocol. <br />
<br />
If
              &lt;KeyProvServerFinished&gt; has Status = "Success" and the
              MACs were verified, then the DSKPP client MUST extract K_PROV
              from the provided key package, and derive K_TOKEN. Finally, the
              DSKPP client initializes the cryptographic module with K_TOKEN
              and the corresponding key usage attributes. After this
              operation, it MUST NOT be possible to overwrite the key unless
              knowledge of an authorizing key is proven through a MAC on a
              later &lt;KeyProvServerFinished&gt; message.
</p>
</blockquote>

<a name="Section-ProtocolExts"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6"></a><h3>6.&nbsp;
Protocol Extensions</h3>

<p>DSKPP has been designed to be extensible. However, it is possible
      that the use of extensions will harm interoperability; therefore, any
      use of extensions SHOULD be carefully considered. For example, if a
      particular implementation relies on the presence of a proprietary
      extension, then it may not be able to interoperate with independent
      implementations that have no knowledge of this extension.
</p>
<a name="anchor30"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.1"></a><h3>6.1.&nbsp;
The ClientInfoType Extension</h3>

<p>The ClientInfoType extension MAY contain any client-specific data
        required of an application. This extension MAY be present in a
        &lt;KeyProvClientHello&gt; or &lt;KeyProvClientNonce&gt; message.
        DSKPP servers MUST support this extension. DSKPP servers MUST NOT
        attempt to interpret the data it carries and, if received, MUST
        include it unmodified in the current protocol run's next server
        response. DSKPP servers need not retain the ClientInfoType data.
</p>
<a name="anchor31"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.2"></a><h3>6.2.&nbsp;
The ServerInfoType Extension</h3>

<p>The ServerInfoType extension MAY contain any server-specific data
        required of an application, e.g., state information. This extension is
        only valid in &lt;KeyProvServerHello&gt; messages for which the Status
        attribute is set to "Continue". DSKPP clients MUST support this
        extension. DSKPP clients MUST NOT attempt to interpret the data it
        carries and, if received, MUST include it unmodified in the current
        protocol run's next client request (i.e., the
        &lt;KeyProvClientNonce&gt; message). DSKPP clients need not retain the
        ServerInfoType data.
</p>
<a name="Section-Bindings"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7"></a><h3>7.&nbsp;
Protocol Bindings</h3>

<a name="anchor32"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.1"></a><h3>7.1.&nbsp;
General Requirements</h3>

<p>DSKPP assumes a reliable transport.
</p>
<a name="anchor33"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.2"></a><h3>7.2.&nbsp;
HTTP/1.1 Binding for DSKPP</h3>

<p>This section presents a binding of the previous messages to
        HTTP/1.1 <a class='info' href='#RFC2616'>[RFC2616]<span> (</span><span class='info'>Fielding, R., Gettys, J., Mogul, J., Frystyk, H., Masinter, L., Leach, P., and T. Berners-Lee, &ldquo;Hypertext Transfer Protocol -- HTTP/1.1,&rdquo; June&nbsp;1999.</span><span>)</span></a>. Note that the HTTP client
        will normally be different from the DSKPP client (i.e., the HTTP
        client will "proxy" DSKPP messages from the DSKPP client to the DSKPP
        server). Likewise, on the HTTP server side, the DSKPP server MAY
        receive DSKPP message from a "front-end" HTTP server. The DSKPP server
        will be identified by a specific URL, which may be pre-configured, or
        provided to the client during initialization.
</p>
<a name="Subsection-Identification"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.2.1"></a><h3>7.2.1.&nbsp;
Identification of DSKPP Messages</h3>

<p>The MIME-type for all DSKPP messages MUST be
</p>
<p>application/vnd.ietf.keyprov.dskpp+xml
</p>
<a name="anchor34"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.2.2"></a><h3>7.2.2.&nbsp;
HTTP Headers</h3>

<p>In order to avoid caching of responses carrying DSKPP messages by
          proxies, the following holds:
</p>
<p></p>
<ul class="text">
<li>When using HTTP/1.1, requesters SHOULD:
<ul class="text">
<li>Include a Cache-Control header field set to "no-cache,
                  no-store".
</li>
<li>Include a Pragma header field set to "no-cache".<br />
<br />

</li>
</ul>
</li>
<li>When using HTTP/1.1, responders SHOULD:
<ul class="text">
<li>Include a Cache-Control header field set to "no-cache,
                  no-must-revalidate, private".
</li>
<li>Include a Pragma header field set to "no-cache".
</li>
<li>NOT include a Validator, such as a Last-Modified or ETag
                  header.
</li>
</ul>
</li>
</ul>

<p>To handle content negotiation, HTTP requests MAY include an HTTP
          Accept header field. This header field SHOULD should be identified
          using the MIME type specified in <a class='info' href='#Subsection-Identification'>Section&nbsp;7.2.1<span> (</span><span class='info'>Identification of DSKPP Messages</span><span>)</span></a>. The Accept header MAY
          include additional content types defined by future versions of this
          protocol.
</p>
<p>There are no other restrictions on HTTP headers, besides the
          requirement to set the Content-Type header value to the MIME type
          specified in <a class='info' href='#Subsection-Identification'>Section&nbsp;7.2.1<span> (</span><span class='info'>Identification of DSKPP Messages</span><span>)</span></a>.
</p>
<a name="anchor35"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.2.3"></a><h3>7.2.3.&nbsp;
HTTP Operations</h3>

<p>Persistent connections as defined in HTTP/1.1 are OPTIONAL. DSKPP
          requests are mapped to HTTP requests with the POST method. DSKPP
          responses are mapped to HTTP responses.
</p>
<p>For the 4-pass DSKPP, messages within the protocol run are bound
          together. In particular, &lt;KeyProvServerHello&gt; is bound to the
          preceding &lt;KeyProvClientHello&gt; by being transmitted in the
          corresponding HTTP response. &lt;KeyProvServerHello&gt; MUST have a
          SessionID attribute, and the SessionID attribute of the subsequent
          &lt;KeyProvClientNonce&gt; message MUST be identical.
          &lt;KeyProvServerFinished&gt; is then once again bound to the rest
          through HTTP (and possibly through a SessionID).
</p>
<a name="anchor36"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.2.4"></a><h3>7.2.4.&nbsp;
HTTP Status Codes</h3>

<p>A DSKPP HTTP responder that refuses to perform a message exchange
          with a DSKPP HTTP requester SHOULD return a 403 (Forbidden)
          response. In this case, the content of the HTTP body is not
          significant. In the case of an HTTP error while processing a DSKPP
          request, the HTTP server MUST return a 500 (Internal Server Error)
          response. This type of error SHOULD be returned for HTTP-related
          errors detected before control is passed to the DSKPP processor, or
          when the DSKPP processor reports an internal error (for example, the
          DSKPP XML namespace is incorrect, or the DSKPP schema cannot be
          located). If a request is received that is not a DSKPP client
          message, the DSKPP responder MUST return a 400 (Bad request)
          response.
</p>
<p>In these cases (i.e., when the HTTP response code is 4xx or 5xx),
          the content of the HTTP body is not significant.
</p>
<p>Redirection status codes (3xx) apply as usual.
</p>
<p>Whenever the HTTP POST is successfully invoked, the DSKPP HTTP
          responder MUST use the 200 status code and provide a suitable DSKPP
          message (possibly with DSKPP error information included) in the HTTP
          body.
</p>
<a name="anchor37"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.2.5"></a><h3>7.2.5.&nbsp;
HTTP Authentication</h3>

<p>No support for HTTP/1.1 authentication is assumed.
</p>
<a name="Section-InitDSKPP"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.2.6"></a><h3>7.2.6.&nbsp;
Initialization of DSKPP</h3>

<p>If a user requests key initialization in a browsing session, and
          if that request has an appropriate Accept header (e.g., to a
          specific DSKPP server URL), the DSKPP server MAY respond by sending
          a DSKPP initialization message in an HTTP response with Content-Type
          set according to <a class='info' href='#Subsection-Identification'>Section&nbsp;7.2.1<span> (</span><span class='info'>Identification of DSKPP Messages</span><span>)</span></a>
          and response code set to 200 (OK). The initialization message MAY
          carry data in its body, such as the URL for the DSKPP client to use
          when contacting the DSKPP server. If the message does carry data,
          the data MUST be a valid instance of a &lt;KeyProvTrigger&gt;
          element.
</p>
<p>Note that if the user's request was directed to some other
          resource, the DSKPP server MUST NOT respond by combining the DSKPP
          content type with response code 200. In that case, the DSKPP server
          SHOULD respond by sending a DSKPP initialization message in an HTTP
          response with Content-Type set according to <a class='info' href='#Subsection-Identification'>Section&nbsp;7.2.1<span> (</span><span class='info'>Identification of DSKPP Messages</span><span>)</span></a> and response code set to
          406 (Not Acceptable).
</p>
<a name="anchor38"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.2.7"></a><h3>7.2.7.&nbsp;
Example Messages</h3>

<p></p>
<blockquote class="text"><dl>
<dt>a.</dt>
<dd>Initialization from DSKPP server:
</dd>
</dl></blockquote><p> </p>
<blockquote class="text">
<p>HTTP/1.1 200 OK<br />
<br />
Cache-Control: no-store<br />
Content-Type:
              application/vnd.ietf.keyprov.dskpp+xml<br />
Content-Length: &lt;some value&gt;<br />
<br />
DSKPP initialization data in XML form...
</p>
</blockquote>

<p></p>
<blockquote class="text"><dl>
<dt>b.</dt>
<dd>Initial request from DSKPP client:
</dd>
</dl></blockquote><p> </p>
<blockquote class="text">
<p>POST http://example.com/cgi-bin/DSKPP-server HTTP/1.1<br />
<br />
Cache-Control: no-cache, no-store<br />
Pragma: no-cache<br />
Host:
              www.example.com<br />
Content-Type:
              application/vnd.ietf.keyprov.dskpp+xml<br />
Content-Length: &lt;some value&gt;<br />
<br />
DSKPP data in XML form (supported version,
              supported algorithms...)
</p>
</blockquote>

<p></p>
<blockquote class="text"><dl>
<dt>c.</dt>
<dd>Initial response from DSKPP server:
</dd>
</dl></blockquote><p> </p>
<blockquote class="text">
<p>HTTP/1.1 200 OK<br />
<br />
Cache-Control: no-cache, no-must-revalidate,
              private<br />
Pragma: no-cache<br />
Content-Type:
              application/vnd.ietf.keyprov.dskpp+xml<br />
Content-Length: &lt;some value&gt;<br />
<br />
DSKPP data in XML form (server random nonce,
              server public key, ...)
</p>
</blockquote>

<a name="Section-Schema"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.8"></a><h3>8.&nbsp;
DSKPP XML Schema</h3>

<a name="anchor39"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.8.1"></a><h3>8.1.&nbsp;
General Processing Requirements</h3>

<p>Some DSKPP elements rely on the parties being able to compare
        received values with stored values. Unless otherwise noted, all
        elements that have the XML Schema "xs:string" type, or a type derived
        from it, MUST be compared using an exact binary comparison. In
        particular, DSKPP implementations MUST NOT depend on case-insensitive
        string comparisons, normalization or trimming of white space, or
        conversion of locale-specific formats such as numbers.
</p>
<p>Implementations that compare values that are represented using
        different character encodings MUST use a comparison method that
        returns the same result as converting both values to the Unicode
        character encoding, Normalization Form C <a class='info' href='#UNICODE'>[UNICODE]<span> (</span><span class='info'>Davis, M. and M. Duerst, &ldquo;Unicode Normalization Forms,&rdquo; March&nbsp;2001.</span><span>)</span></a>, and then performing an exact binary
        comparison.
</p>
<p>No collation or sorting order for attributes or element values is
        defined. Therefore, DSKPP implementations MUST NOT depend on specific
        sorting orders for values.
</p>
<a name="anchor40"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.8.2"></a><h3>8.2.&nbsp;
Schema</h3>

<p>
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>   &lt;?xml version="1.0" encoding="utf-8"?&gt;
   &lt;xs:schema
      xmlns:xs="http://www.w3.org/2001/XMLSchema"
      xmlns:dskpp="urn:ietf:params:xml:ns:keyprov:dskpp"
      xmlns:pskc="urn:ietf:params:xml:ns:keyprov:pskc"
      xmlns:ds="http://www.w3.org/2000/09/xmldsig#"
      targetNamespace="urn:ietf:params:xml:ns:keyprov:dskpp"
      elementFormDefault="qualified" attributeFormDefault="unqualified"
         version="1.0"&gt;
      &lt;xs:import namespace="http://www.w3.org/2000/09/xmldsig#"
         schemaLocation=
         "http://www.w3.org/TR/2002/REC-xmldsig-core-20020212/xmldsig-core-schema.xsd"/&gt;
      &lt;xs:import namespace="urn:ietf:params:xml:ns:keyprov:pskc"
         schemaLocation="keyprov-pskc-1.0.xsd"/&gt;
      &lt;xs:complexType name="AbstractRequestType" abstract="true"&gt;
         &lt;xs:annotation&gt;
            &lt;xs:documentation&gt; Basic types &lt;/xs:documentation&gt;
         &lt;/xs:annotation&gt;
         &lt;xs:attribute name="Version" type="dskpp:VersionType"
            use="required"/&gt;
      &lt;/xs:complexType&gt;

      &lt;xs:complexType name="AbstractResponseType" abstract="true"&gt;
         &lt;xs:annotation&gt;
            &lt;xs:documentation&gt; Basic types &lt;/xs:documentation&gt;
         &lt;/xs:annotation&gt;
         &lt;xs:attribute name="Version" type="dskpp:VersionType"
            use="required"/&gt;
         &lt;xs:attribute name="SessionID" type="dskpp:IdentifierType" /&gt;
         &lt;xs:attribute name="Status" type="dskpp:StatusCode" use="required"/&gt;
      &lt;/xs:complexType&gt;

      &lt;xs:simpleType name="VersionType"&gt;
         &lt;xs:restriction base="xs:string"&gt;
            &lt;xs:pattern value="\d{1,2}\.\d{1,3}" /&gt;
         &lt;/xs:restriction&gt;
      &lt;/xs:simpleType&gt;

      &lt;xs:simpleType name="IdentifierType"&gt;
         &lt;xs:restriction base="xs:string"&gt;
            &lt;xs:maxLength value="128" /&gt;
         &lt;/xs:restriction&gt;
      &lt;/xs:simpleType&gt;

      &lt;xs:simpleType name="StatusCode"&gt;
         &lt;xs:restriction base="xs:string"&gt;
            &lt;xs:enumeration value="Continue" /&gt;
            &lt;xs:enumeration value="Success" /&gt;
            &lt;xs:enumeration value="Abort" /&gt;
            &lt;xs:enumeration value="AccessDenied" /&gt;
            &lt;xs:enumeration value="MalformedRequest" /&gt;
            &lt;xs:enumeration value="UnknownRequest" /&gt;
            &lt;xs:enumeration value="UnknownCriticalExtension" /&gt;
            &lt;xs:enumeration value="UnsupportedVersion" /&gt;
            &lt;xs:enumeration value="NoSupportedKeyTypes" /&gt;
            &lt;xs:enumeration value="NoSupportedEncryptionAlgorithms" /&gt;
            &lt;xs:enumeration value="NoSupportedMacAlgorithms" /&gt;
            &lt;xs:enumeration value="NoProtocolVariants" /&gt;
            &lt;xs:enumeration value="NoSupportedKeyPackages" /&gt;
            &lt;xs:enumeration value="AuthenticationDataMissing" /&gt;
            &lt;xs:enumeration value="AuthenticationDataInvalid" /&gt;
            &lt;xs:enumeration value="InitializationFailed" /&gt;
            &lt;xs:enumeration value="ProvisioningPeriodExpired" /&gt;
         &lt;/xs:restriction&gt;
      &lt;/xs:simpleType&gt;

      &lt;xs:complexType name="DeviceIdentifierDataType"&gt;
         &lt;xs:choice&gt;
            &lt;xs:element name="DeviceId" type="pskc:DeviceInfoType" /&gt;
            &lt;xs:any namespace="##other" processContents="strict" /&gt;
         &lt;/xs:choice&gt;
      &lt;/xs:complexType&gt;

      &lt;xs:simpleType name="PlatformType"&gt;
         &lt;xs:restriction base="xs:string"&gt;
            &lt;xs:enumeration value="Hardware" /&gt;
            &lt;xs:enumeration value="Software" /&gt;
            &lt;xs:enumeration value="Unspecified" /&gt;
         &lt;/xs:restriction&gt;
      &lt;/xs:simpleType&gt;

      &lt;xs:complexType name="TokenPlatformInfoType"&gt;
         &lt;xs:attribute name="KeyLocation" type="dskpp:PlatformType"/&gt;
         &lt;xs:attribute name="AlgorithmLocation" type="dskpp:PlatformType"/&gt;
      &lt;/xs:complexType&gt;

      &lt;xs:simpleType name="NonceType"&gt;
         &lt;xs:restriction base="xs:base64Binary"&gt;
            &lt;xs:minLength value="16" /&gt;
         &lt;/xs:restriction&gt;
      &lt;/xs:simpleType&gt;

      &lt;xs:complexType name="AlgorithmsType"&gt;
         &lt;xs:sequence maxOccurs="unbounded"&gt;
            &lt;xs:element name="Algorithm" type="dskpp:AlgorithmType" /&gt;
         &lt;/xs:sequence&gt;
      &lt;/xs:complexType&gt;

      &lt;xs:simpleType name="AlgorithmType"&gt;
         &lt;xs:restriction base="xs:anyURI" /&gt;
      &lt;/xs:simpleType&gt;

      &lt;xs:complexType name="ProtocolVariantsType"&gt;
         &lt;xs:sequence&gt;
            &lt;xs:element name="FourPass" minOccurs="0" /&gt;
            &lt;xs:element name="TwoPass" type="dskpp:KeyProtectionDataType"
               minOccurs="0"/&gt;
         &lt;/xs:sequence&gt;
      &lt;/xs:complexType&gt;

      &lt;xs:complexType name="KeyProtectionDataType"&gt;
         &lt;xs:annotation&gt;
            &lt;xs:documentation xml:lang="en"&gt;
               This element is only valid for two-pass DSKPP.
            &lt;/xs:documentation&gt;
         &lt;/xs:annotation&gt;
         &lt;xs:sequence maxOccurs="unbounded"&gt;
            &lt;xs:element name="SupportedKeyProtectionMethod" type="xs:anyURI"/&gt;
            &lt;xs:element name="Payload" type="dskpp:PayloadType" minOccurs="0"/&gt;
         &lt;/xs:sequence&gt;
      &lt;/xs:complexType&gt;

      &lt;xs:complexType name="PayloadType"&gt;
         &lt;xs:choice&gt;
            &lt;xs:element name="Nonce" type="dskpp:NonceType" /&gt;
            &lt;xs:any namespace="##other" processContents="strict" /&gt;
         &lt;/xs:choice&gt;
      &lt;/xs:complexType&gt;

      &lt;xs:complexType name="KeyPackagesFormatType"&gt;
         &lt;xs:sequence maxOccurs="unbounded"&gt;
            &lt;xs:element name="KeyPackageFormat"
               type="dskpp:KeyPackageFormatType"/&gt;
         &lt;/xs:sequence&gt;
      &lt;/xs:complexType&gt;

      &lt;xs:simpleType name="KeyPackageFormatType"&gt;
         &lt;xs:restriction base="xs:anyURI" /&gt;
      &lt;/xs:simpleType&gt;

      &lt;xs:complexType name="AuthenticationDataType"&gt;
         &lt;xs:annotation&gt;
            &lt;xs:documentation xml:lang="en"&gt;
               Authentication data contains a MAC.
            &lt;/xs:documentation&gt;
         &lt;/xs:annotation&gt;
         &lt;xs:sequence&gt;
            &lt;xs:element name="ClientID"
               type="dskpp:IdentifierType" minOccurs="0"/&gt;
            &lt;xs:choice&gt;
               &lt;xs:element name="AuthenticationCodeMac"
                  type="dskpp:AuthenticationMacType"/&gt;
               &lt;xs:any namespace="##other" processContents="strict" /&gt;
            &lt;/xs:choice&gt;
         &lt;/xs:sequence&gt;
      &lt;/xs:complexType&gt;

      &lt;xs:complexType name="AuthenticationMacType"&gt;
         &lt;xs:sequence&gt;
            &lt;xs:element minOccurs="0" name="Nonce" type="dskpp:NonceType" /&gt;
            &lt;xs:element minOccurs="0" name="IterationCount" type="xs:int" /&gt;
            &lt;xs:element name="Mac" type="dskpp:MacType" /&gt;
         &lt;/xs:sequence&gt;
      &lt;/xs:complexType&gt;

      &lt;xs:complexType name="MacType"&gt;
         &lt;xs:simpleContent&gt;
            &lt;xs:extension base="xs:base64Binary"&gt;
               &lt;xs:attribute name="MacAlgorithm" type="xs:anyURI" /&gt;
            &lt;/xs:extension&gt;
         &lt;/xs:simpleContent&gt;
      &lt;/xs:complexType&gt;

      &lt;xs:complexType name="KeyPackageType"&gt;
         &lt;xs:sequence&gt;
            &lt;xs:element minOccurs="0" name="ServerID" type="xs:anyURI" /&gt;
            &lt;xs:element minOccurs="0" name="KeyProtectionMethod"
               type="xs:anyURI" /&gt;
            &lt;xs:choice&gt;
               &lt;xs:element name="KeyContainer" type="pskc:KeyContainerType" /&gt;
               &lt;xs:any namespace="##other" processContents="strict" /&gt;
            &lt;/xs:choice&gt;
         &lt;/xs:sequence&gt;
      &lt;/xs:complexType&gt;

      &lt;xs:complexType name="InitializationTriggerType"&gt;
         &lt;xs:sequence&gt;
            &lt;xs:element minOccurs="0" name="DeviceIdentifierData"
               type="dskpp:DeviceIdentifierDataType" /&gt;
            &lt;xs:element minOccurs="0" name="KeyID" type="xs:base64Binary" /&gt;
            &lt;xs:element minOccurs="0" name="TokenPlatformInfo"
               type="dskpp:TokenPlatformInfoType" /&gt;
            &lt;xs:element name="AuthenticationData" type="dskpp:AuthenticationDataType" /&gt;
            &lt;xs:element minOccurs="0" name="ServerUrl" type="xs:anyURI" /&gt;
            &lt;xs:any minOccurs="0" namespace="##other"
               processContents="strict" /&gt;
         &lt;/xs:sequence&gt;
      &lt;/xs:complexType&gt;

      &lt;xs:complexType name="ExtensionsType"&gt;
         &lt;xs:annotation&gt;
            &lt;xs:documentation&gt; Extension types &lt;/xs:documentation&gt;
         &lt;/xs:annotation&gt;
         &lt;xs:sequence maxOccurs="unbounded"&gt;
            &lt;xs:element name="Extension" type="dskpp:AbstractExtensionType" /&gt;
         &lt;/xs:sequence&gt;
      &lt;/xs:complexType&gt;

      &lt;xs:complexType name="AbstractExtensionType" abstract="true"&gt;
         &lt;xs:attribute name="Critical" type="xs:boolean" /&gt;
      &lt;/xs:complexType&gt;

      &lt;xs:complexType name="ClientInfoType"&gt;
         &lt;xs:complexContent mixed="false"&gt;
            &lt;xs:extension base="dskpp:AbstractExtensionType"&gt;
               &lt;xs:sequence&gt;
                  &lt;xs:element name="Data" type="xs:base64Binary" /&gt;
               &lt;/xs:sequence&gt;
            &lt;/xs:extension&gt;
         &lt;/xs:complexContent&gt;
      &lt;/xs:complexType&gt;

      &lt;xs:complexType name="ServerInfoType"&gt;
         &lt;xs:complexContent mixed="false"&gt;
            &lt;xs:extension base="dskpp:AbstractExtensionType"&gt;
               &lt;xs:sequence&gt;
                  &lt;xs:element name="Data" type="xs:base64Binary" /&gt;
               &lt;/xs:sequence&gt;
            &lt;/xs:extension&gt;
         &lt;/xs:complexContent&gt;
      &lt;/xs:complexType&gt;

      &lt;xs:element name="KeyProvTrigger" type="dskpp:KeyProvTriggerType"&gt;
         &lt;xs:annotation&gt;
            &lt;xs:documentation&gt; DSKPP PDUs &lt;/xs:documentation&gt;
         &lt;/xs:annotation&gt;
      &lt;/xs:element&gt;
      &lt;xs:complexType name="KeyProvTriggerType"&gt;
         &lt;xs:annotation&gt;
         &lt;xs:documentation xml:lang="en"&gt;
            Message used to trigger the device to initiate a
            DSKPP protocol run.
         &lt;/xs:documentation&gt;
         &lt;/xs:annotation&gt;
         &lt;xs:sequence&gt;
            &lt;xs:choice&gt;
               &lt;xs:element name="InitializationTrigger"
                  type="dskpp:InitializationTriggerType" /&gt;
               &lt;xs:any namespace="##other" processContents="strict" /&gt;
            &lt;/xs:choice&gt;
         &lt;/xs:sequence&gt;
         &lt;xs:attribute name="Version" type="dskpp:VersionType" /&gt;
      &lt;/xs:complexType&gt;

      &lt;xs:element name="KeyProvClientHello"
         type="dskpp:KeyProvClientHelloPDU"&gt;
         &lt;xs:annotation&gt;
            &lt;xs:documentation&gt; KeyProvClientHello PDU &lt;/xs:documentation&gt;
         &lt;/xs:annotation&gt;
      &lt;/xs:element&gt;
      &lt;xs:complexType name="KeyProvClientHelloPDU"&gt;
         &lt;xs:annotation&gt;
            &lt;xs:documentation xml:lang="en"&gt;
               Message sent from DSKPP client to DSKPP server to initiate a
               DSKPP session.
            &lt;/xs:documentation&gt;
         &lt;/xs:annotation&gt;
         &lt;xs:complexContent mixed="false"&gt;
            &lt;xs:extension base="dskpp:AbstractRequestType"&gt;
               &lt;xs:sequence&gt;
                  &lt;xs:element minOccurs="0" name="DeviceIdentifierData"
                     type="dskpp:DeviceIdentifierDataType" /&gt;
                  &lt;xs:element minOccurs="0" name="KeyID"
                     type="xs:base64Binary" /&gt;
                  &lt;xs:element minOccurs="0" name="ClientNonce"
                     type="dskpp:NonceType" /&gt;
                  &lt;xs:element name="SupportedKeyTypes"
                     type="dskpp:AlgorithmsType" /&gt;
                  &lt;xs:element name="SupportedEncryptionAlgorithms"
                     type="dskpp:AlgorithmsType" /&gt;
                  &lt;xs:element name="SupportedMacAlgorithms"
                     type="dskpp:AlgorithmsType" /&gt;
                  &lt;xs:element minOccurs="0" name="SupportedProtocolVariants"
                     type="dskpp:ProtocolVariantsType" /&gt;
                  &lt;xs:element minOccurs="0" name="SupportedKeyPackages"
                     type="dskpp:KeyPackagesFormatType" /&gt;
                  &lt;xs:element minOccurs="0" name="AuthenticationData"
                     type="dskpp:AuthenticationDataType" /&gt;
                  &lt;xs:element minOccurs="0" name="Extensions"
                     type="dskpp:ExtensionsType" /&gt;
               &lt;/xs:sequence&gt;
            &lt;/xs:extension&gt;
         &lt;/xs:complexContent&gt;
      &lt;/xs:complexType&gt;

      &lt;xs:element name="KeyProvServerHello"
         type="dskpp:KeyProvServerHelloPDU"&gt;
         &lt;xs:annotation&gt;
            &lt;xs:documentation&gt; KeyProvServerHello PDU &lt;/xs:documentation&gt;
         &lt;/xs:annotation&gt;
      &lt;/xs:element&gt;
      &lt;xs:complexType name="KeyProvServerHelloPDU"&gt;
         &lt;xs:annotation&gt;
            &lt;xs:documentation xml:lang="en"&gt;
               Response message sent from DSKPP server to DSKPP client
               in four-pass DSKPP.
            &lt;/xs:documentation&gt;
         &lt;/xs:annotation&gt;
         &lt;xs:complexContent mixed="false"&gt;
            &lt;xs:extension base="dskpp:AbstractResponseType"&gt;
               &lt;xs:sequence minOccurs="0"&gt;
                  &lt;xs:element name="KeyType" type="dskpp:AlgorithmType" /&gt;
                  &lt;xs:element name="EncryptionAlgorithm"
                     type="dskpp:AlgorithmType" /&gt;
                  &lt;xs:element name="MacAlgorithm" type="dskpp:AlgorithmType" /&gt;
                  &lt;xs:element name="EncryptionKey" type="ds:KeyInfoType" /&gt;
                  &lt;xs:element name="KeyPackageFormat"
                     type="dskpp:KeyPackageFormatType" /&gt;
                  &lt;xs:element name="Payload" type="dskpp:PayloadType" /&gt;
                  &lt;xs:element minOccurs="0" name="Extensions"
                     type="dskpp:ExtensionsType" /&gt;
                  &lt;xs:element minOccurs="0" name="Mac" type="dskpp:MacType" /&gt;
               &lt;/xs:sequence&gt;
            &lt;/xs:extension&gt;
         &lt;/xs:complexContent&gt;
      &lt;/xs:complexType&gt;

      &lt;xs:element name="KeyProvClientNonce"
         type="dskpp:KeyProvClientNoncePDU"&gt;
         &lt;xs:annotation&gt;
            &lt;xs:documentation&gt; KeyProvClientNonce PDU &lt;/xs:documentation&gt;
         &lt;/xs:annotation&gt;
      &lt;/xs:element&gt;
      &lt;xs:complexType name="KeyProvClientNoncePDU"&gt;
         &lt;xs:annotation&gt;
            &lt;xs:documentation xml:lang="en"&gt;
               Response message sent from DSKPP client to
               DSKPP server in a four-pass DSKPP session.
            &lt;/xs:documentation&gt;
         &lt;/xs:annotation&gt;
         &lt;xs:complexContent mixed="false"&gt;
            &lt;xs:extension base="dskpp:AbstractRequestType"&gt;
               &lt;xs:sequence&gt;
                  &lt;xs:element name="EncryptedNonce" type="xs:base64Binary" /&gt;
                  &lt;xs:element minOccurs="0" name="AuthenticationData"
                     type="dskpp:AuthenticationDataType" /&gt;
                  &lt;xs:element minOccurs="0" name="Extensions"
                     type="dskpp:ExtensionsType" /&gt;
               &lt;/xs:sequence&gt;
               &lt;xs:attribute name="SessionID" type="dskpp:IdentifierType"
                  use="required" /&gt;
            &lt;/xs:extension&gt;
         &lt;/xs:complexContent&gt;
      &lt;/xs:complexType&gt;

      &lt;xs:element name="KeyProvServerFinished"
         type="dskpp:KeyProvServerFinishedPDU"&gt;
         &lt;xs:annotation&gt;
            &lt;xs:documentation&gt; KeyProvServerFinished PDU &lt;/xs:documentation&gt;
         &lt;/xs:annotation&gt;
      &lt;/xs:element&gt;
      &lt;xs:complexType name="KeyProvServerFinishedPDU"&gt;
         &lt;xs:annotation&gt;
            &lt;xs:documentation xml:lang="en"&gt;
               Final message sent from DSKPP server to DSKPP client in a DSKPP
               session. A MAC value serves for key confirmation, and optional
               AuthenticationData serves for server authentication.
            &lt;/xs:documentation&gt;
         &lt;/xs:annotation&gt;
         &lt;xs:complexContent mixed="false"&gt;
            &lt;xs:extension base="dskpp:AbstractResponseType"&gt;
               &lt;xs:sequence minOccurs="0"&gt;
                  &lt;xs:element name="KeyPackage"
                     type="dskpp:KeyPackageType" /&gt;
                  &lt;xs:element minOccurs="0" name="Extensions"
                     type="dskpp:ExtensionsType" /&gt;
                  &lt;xs:element name="Mac" type="dskpp:MacType" /&gt;
                  &lt;xs:element minOccurs="0" name="AuthenticationData"
                     type="dskpp:AuthenticationMacType" /&gt;
               &lt;/xs:sequence&gt;
            &lt;/xs:extension&gt;
         &lt;/xs:complexContent&gt;
      &lt;/xs:complexType&gt;
    &lt;/xs:schema&gt;</pre></div>
<p>
</p>
<a name="anchor41"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.9"></a><h3>9.&nbsp;
Conformance Requirements</h3>

<p>In order to assure that all implementations of DSKPP can
      interoperate, the DSKPP server:
</p>
<p></p>
<blockquote class="text"><dl>
<dt>a.</dt>
<dd>MUST implement the four-pass variation of the protocol (<a class='info' href='#Subsection-FourPassUsage'>Section&nbsp;4<span> (</span><span class='info'>Four-Pass Protocol Usage</span><span>)</span></a>)<br />

</dd>
<dt>b.</dt>
<dd>MUST implement the two-pass variation of the protocol (<a class='info' href='#Subsecton-TwoPass'>Section&nbsp;5<span> (</span><span class='info'>Two-Pass Protocol Usage</span><span>)</span></a>)<br />

</dd>
<dt>c.</dt>
<dd>MUST support user authentication (<a class='info' href='#Subsection-UserAuth'>Section&nbsp;3.2.1<span> (</span><span class='info'>User Authentication</span><span>)</span></a>)<br />

</dd>
<dt>d.</dt>
<dd>MUST support the following key derivation functions:
<ul class="text">
<li>DSKPP-PRF-AES DSKPP-PRF realization (<a class='info' href='#Section-PRFRealizations'>refer to<span> (</span><span class='info'>Example of DSKPP-PRF Realizations</span><span>)</span></a> for an
              example)
</li>
<li>DSKPP-PRF-SHA256 DSKPP-PRF realization (<a class='info' href='#Section-PRFRealizations'>refer to<span> (</span><span class='info'>Example of DSKPP-PRF Realizations</span><span>)</span></a> for an
              example)<br />
<br />

</li>
</ul>
</dd>
<dt>e.</dt>
<dd>MUST support the following encryption mechanisms for protection
          of the client nonce in the four-pass protocol:
<ul class="text">
<li>Mechanism described in <a class='info' href='#Subsection-Enc'>Section&nbsp;4.2.4<span> (</span><span class='info'>KeyProvClientNonce</span><span>)</span></a><br />
<br />

</li>
</ul>
</dd>
<dt>f.</dt>
<dd>MUST support one of the following encryption algorithms for
          symmetric key operations, e.g., key wrap:
<ul class="text">
<li>KW-AES128 without padding; refer to
              http://www.w3.org/2001/04/xmlenc#kw-aes128 in <a class='info' href='#XMLENC'>[XMLENC]<span> (</span><span class='info'>W3C, &ldquo;XML Encryption Syntax and Processing,&rdquo; December&nbsp;2002.</span><span>)</span></a>
</li>
<li>KW-AES128 with padding; refer to
              http://www.w3.org/2001/04/xmlenc#kw-aes128 in <a class='info' href='#XMLENC'>[XMLENC]<span> (</span><span class='info'>W3C, &ldquo;XML Encryption Syntax and Processing,&rdquo; December&nbsp;2002.</span><span>)</span></a> and <a class='info' href='#AESKWPAD'>[AESKWPAD]<span> (</span><span class='info'>Housley, R. and M. Dworkin, &ldquo;Advanced Encryption Standard (AES) Key Wrap with Padding           Algorithm,&rdquo; March&nbsp;2009.</span><span>)</span></a>
</li>
<li>AES-CBC-128; refer to <a class='info' href='#FIPS197-AES'>[FIPS197&#8209;AES]<span> (</span><span class='info'>National Institute of Standards and             Technology, &ldquo;Specification for the Advanced Encryption Standard           (AES),&rdquo; November&nbsp;2001.</span><span>)</span></a><br />
<br />

</li>
</ul>
</dd>
<dt>g.</dt>
<dd>MUST support the following encryption algorithms for asymmetric
          key operations, e.g., key transport:
<ul class="text">
<li>RSA Encryption Scheme <a class='info' href='#PKCS-1'>[PKCS&#8209;1]<span> (</span><span class='info'>RSA Laboratories, &ldquo;RSA Cryptography Standard,&rdquo; June&nbsp;2002.</span><span>)</span></a><br />
<br />

</li>
</ul>
</dd>
<dt>h.</dt>
<dd>MUST support the following integrity/KDF MAC functions:
<ul class="text">
<li>DSKPP-PRF-AES (<a class='info' href='#Section-PRFRealizations'>Appendix&nbsp;D<span> (</span><span class='info'>Example of DSKPP-PRF Realizations</span><span>)</span></a>)
</li>
<li>DSKPP-PRF-SHA256 (<a class='info' href='#Section-PRFRealizations'>Appendix&nbsp;D<span> (</span><span class='info'>Example of DSKPP-PRF Realizations</span><span>)</span></a>)<br />
<br />

</li>
</ul>
</dd>
<dt>i.</dt>
<dd>MUST support the PSKC key package <a class='info' href='#PSKC'>[PSKC]<span> (</span><span class='info'>, &ldquo;Portable Symmetric Key Container,&rdquo; 2008.</span><span>)</span></a>;
          all three PSKC key protection methods (Key Transport, Key Wrap, and
          Passphrase-Based Key Wrap) MUST be implemented<br />

</dd>
<dt>j.</dt>
<dd>MAY support the ASN.1 key package as defined in <a class='info' href='#SKPC-ASN.1'>[SKPC&#8209;ASN.1]<span> (</span><span class='info'>, &ldquo;Symmetric Key Package Content Type,&rdquo; 2007.</span><span>)</span></a>
</dd>
</dl></blockquote>

<p>DSKPP clients MUST support either the two-pass or the four-pass
      variant of the protocol. DSKPP clients MUST fulfill all requirements
      listed in item (c) - (j).
</p>
<p>Of course, DSKPP is a security protocol, and one of its major
      functions is to allow only authorized parties to successfully initialize
      a cryptographic module with a new symmetric key. Therefore, a particular
      implementation may be configured with any of a number of restrictions
      concerning algorithms and trusted authorities that will prevent
      universal interoperability.
</p>
<a name="Section-Security"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.10"></a><h3>10.&nbsp;
Security Considerations</h3>

<a name="anchor42"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.10.1"></a><h3>10.1.&nbsp;
General</h3>

<p>DSKPP is designed to protect generated keying material from
        exposure. No other entities than the DSKPP server and the
        cryptographic module will have access to a generated K_TOKEN if the
        cryptographic algorithms used are of sufficient strength and, on the
        DSKPP client side, generation and encryption of R_C and generation of
        K_TOKEN take place as specified in the cryptographic module. This
        applies even if malicious software is present in the DSKPP client.
        However, as discussed in the following sub-sections, DSKPP does not
        protect against certain other threats resulting from man-in-the-middle
        attacks and other forms of attacks. DSKPP SHOULD, therefore, be run
        over a transport providing confidentiality and integrity, such as HTTP
        over Transport Layer Security (TLS) with a suitable ciphersuite, when
        such threats are a concern. Note that TLS ciphersuites with anonymous
        key exchanges are not suitable in those situations.
</p>
<a name="anchor43"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.10.2"></a><h3>10.2.&nbsp;
Active Attacks</h3>

<a name="anchor44"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.10.2.1"></a><h3>10.2.1.&nbsp;
Introduction</h3>

<p>An active attacker MAY attempt to modify, delete, insert, replay,
          or reorder messages for a variety of purposes including service
          denial and compromise of generated keying material.
</p>
<a name="Subsection-Messages"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.10.2.2"></a><h3>10.2.2.&nbsp;
Message Modifications</h3>

<p>Modifications to a &lt;KeyProvTrigger&gt; message will either
          cause denial-of-service (modifications of any of the identifiers or
          the authentication code) or will cause the DSKPP client to contact
          the wrong DSKPP server. The latter is in effect a man-in-the-middle
          attack and is discussed further in <a class='info' href='#Subsection-MITM'>Section&nbsp;10.2.7<span> (</span><span class='info'>Man-in-the-Middle</span><span>)</span></a>.
</p>
<p>An attacker may modify a &lt;KeyProvClientHello&gt; message. This
          means that the attacker could indicate a different key or device
          than the one intended by the DSKPP client, and could also suggest
          other cryptographic algorithms than the ones preferred by the DSKPP
          client, e.g., cryptographically weaker ones. The attacker could also
          suggest earlier versions of the DSKPP protocol, in case these
          versions have been shown to have vulnerabilities. These
          modifications could lead to an attacker succeeding in initializing
          or modifying another cryptographic module than the one intended
          (i.e., the server assigning the generated key to the wrong module),
          or gaining access to a generated key through the use of weak
          cryptographic algorithms or protocol versions. DSKPP implementations
          MAY protect against the latter by having strict policies about what
          versions and algorithms they support and accept. The former threat
          (assignment of a generated key to the wrong module) is not possible
          when the shared-key variant of DSKPP is employed (assuming existing
          shared keys are unique per cryptographic module), but is possible in
          the public-key variation. Therefore, DSKPP servers MUST NOT accept
          unilaterally provided device identifiers in the public-key
          variation. This is also indicated in the protocol description. In
          the shared-key variation, however, an attacker may be able to
          provide the wrong identifier (possibly also leading to the incorrect
          user being associated with the generated key) if the attacker has
          real-time access to the cryptographic module with the identified
          key. The result of this attack could be that the generated key is
          associated with the correct cryptographic module but the module is
          associated with the incorrect user. See further <a class='info' href='#Subsection-Interactions'>Section&nbsp;10.5<span> (</span><span class='info'>Attacks on the Interaction between DSKPP and User Authentication</span><span>)</span></a> for a discussion of this
          threat and possible countermeasures.
</p>
<p>An attacker may also modify a &lt;KeyProvServerHello&gt; message.
          This means that the attacker could indicate different key types,
          algorithms, or protocol versions than the legitimate server would,
          e.g., cryptographically weaker ones. The attacker may also provide a
          different nonce than the one sent by the legitimate server. Clients
          MAY protect against the former through strict adherence to policies
          regarding permissible algorithms and protocol versions. The latter
          (wrong nonce) will not constitute a security problem, as a generated
          key will not match the key generated on the legitimate server. Also,
          whenever the DSKPP run would result in the replacement of an
          existing key, the &lt;Mac&gt; element protects against modifications
          of R_S.
</p>
<p>Modifications of &lt;KeyProvClientNonce&gt; messages are also
          possible. If an attacker modifies the SessionID attribute, then, in
          effect, a switch to another session will occur at the server,
          assuming the new SessionID is valid at that time on the server. It
          still will not allow the attacker to learn a generated K_TOKEN since
          R_C has been wrapped for the legitimate server. Modifications of the
          &lt;EncryptedNonce&gt; element, e.g., replacing it with a value for
          which the attacker knows an underlying R'C, will not result in the
          client changing its pre-DSKPP state, since the server will be unable
          to provide a valid MAC in its final message to the client. The
          server MAY, however, end up storing K'TOKEN rather than K_TOKEN. If
          the cryptographic module has been associated with a particular user,
          then this could constitute a security problem. For a further
          discussion about this threat, and a possible countermeasure, see
          <a class='info' href='#Subsection-Interactions'>Section&nbsp;10.5<span> (</span><span class='info'>Attacks on the Interaction between DSKPP and User Authentication</span><span>)</span></a> below. Note that use
          of TLS does not protect against this attack if the attacker has
          access to the DSKPP client (e.g., through malicious software,
          "Trojans").
</p>
<p>Finally, attackers may also modify the
          &lt;KeyProvServerFinished&gt; message. Replacing the &lt;Mac&gt;
          element will only result in denial-of-service. Replacement of any
          other element may cause the DSKPP client to associate, e.g., the
          wrong service with the generated key. DSKPP SHOULD be run over a
          transport providing confidentiality and integrity when this is a
          concern.
</p>
<a name="anchor45"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.10.2.3"></a><h3>10.2.3.&nbsp;
Message Deletion</h3>

<p>Message deletion will not cause any other harm than
          denial-of-service, since a cryptographic module MUST NOT change its
          state (i.e., "commit" to a generated key) until it receives the
          final message from the DSKPP server and successfully has processed
          that message, including validation of its MAC. A deleted
          &lt;KeyProvServerFinished&gt; message will not cause the server to
          end up in an inconsistent state vis-a-vis the cryptographic module
          if the server implements the suggestions in <a class='info' href='#Subsection-Interactions'>Section&nbsp;10.5<span> (</span><span class='info'>Attacks on the Interaction between DSKPP and User Authentication</span><span>)</span></a>.
</p>
<a name="anchor46"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.10.2.4"></a><h3>10.2.4.&nbsp;
Message Insertion</h3>

<p>An active attacker may initiate a DSKPP run at any time, and
          suggest any device identifier. DSKPP server implementations MAY
          receive some protection against inadvertently initializing a key or
          inadvertently replacing an existing key or assigning a key to a
          cryptographic module by initializing the DSKPP run by use of the
          &lt;KeyProvTrigger&gt;. The &lt;AuthenticationData&gt; element
          allows the server to associate a DSKPP protocol run with, e.g., an
          earlier user-authenticated session. The security of this method,
          therefore, depends on the ability to protect the
          &lt;AuthenticationData&gt; element in the DSKPP initialization
          message. If an eavesdropper is able to capture this message, he may
          race the legitimate user for a key initialization. DSKPP over a
          transport providing confidentiality and integrity, coupled with the
          recommendations in <a class='info' href='#Subsection-Interactions'>Section&nbsp;10.5<span> (</span><span class='info'>Attacks on the Interaction between DSKPP and User Authentication</span><span>)</span></a>,
          is RECOMMENDED when this is a concern.
</p>
<p>Insertion of other messages into an existing protocol run is seen
          as equivalent to modification of legitimately sent messages.
</p>
<a name="anchor47"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.10.2.5"></a><h3>10.2.5.&nbsp;
Message Replay</h3>

<p>During 4-pass DSKPP, attempts to replay a previously recorded
          DSKPP message will be detected, as the use of nonces ensures that
          both parties are live. For example, a DSKPP client knows that a
          server it is communicating with is "live" since the server MUST
          create a MAC on information sent by the client.
</p>
<p>The same is true for 2-pass DSKPP thanks to the requirement that
          the client sends R in the &lt;KeyProvClientHello&gt; message and
          that the server includes R in the MAC computation.
</p>
<a name="anchor48"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.10.2.6"></a><h3>10.2.6.&nbsp;
Message Reordering</h3>

<p>An attacker may attempt to re-order 4-pass DSKPP messages but
          this will be detected, as each message is of a unique type. Note:
          Message re-ordering attacks cannot occur in 2-pass DSKPP since each
          party sends at most one message each.
</p>
<a name="Subsection-MITM"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.10.2.7"></a><h3>10.2.7.&nbsp;
Man-in-the-Middle</h3>

<p>In addition to other active attacks, an attacker posing as a
          man-in-the-middle may be able to provide his own public key to the
          DSKPP client. This threat and countermeasures to it are discussed in
          <a class='info' href='#Subsection-FourPassDataFlow'>Section&nbsp;4.1.1<span> (</span><span class='info'>Data Flow</span><span>)</span></a>. An attacker
          posing as a man-in-the-middle may also be acting as a proxy and,
          hence, may not interfere with DSKPP runs but still learn valuable
          information; see <a class='info' href='#Subsection-Passive'>Section&nbsp;10.3<span> (</span><span class='info'>Passive Attacks</span><span>)</span></a>.
</p>
<a name="Subsection-Passive"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.10.3"></a><h3>10.3.&nbsp;
Passive Attacks</h3>

<p>Passive attackers may eavesdrop on DSKPP runs to learn information
        that later on may be used to impersonate users, mount active attacks,
        etc.
</p>
<p>If DSKPP is not run over a transport providing confidentiality, a
        passive attacker may learn:</p>
<ul class="text">
<li>What cryptographic modules a particular user is in possession
            of
</li>
<li>The identifiers of keys on those cryptographic modules and
            other attributes pertaining to those keys, e.g., the lifetime of
            the keys
</li>
<li>DSKPP versions and cryptographic algorithms supported by a
            particular DSKPP client or server
</li>
<li>Any value present in an &lt;extension&gt; that is part of
            &lt;KeyProvClientHello&gt;
</li>
</ul>

<p>Whenever the above is a concern, DSKPP SHOULD be run over a
        transport providing confidentiality. If man-in-the-middle attacks for
        the purposes described above are a concern, the transport SHOULD also
        offer server-side authentication.
</p>
<a name="anchor49"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.10.4"></a><h3>10.4.&nbsp;
Cryptographic Attacks</h3>

<p>An attacker with unlimited access to an initialized cryptographic
        module may use the module as an "oracle" to pre-compute values that
        later on may be used to impersonate the DSKPP server. <a class='info' href='#Subsection-FourPassDataFlow'>Section&nbsp;4.1.1<span> (</span><span class='info'>Data Flow</span><span>)</span></a> contains a discussion of
        this threat and steps RECOMMENDED to protect against it.
</p>
<p>Implementers SHOULD also be aware that cryptographic algorithms
        become weaker with time. As new cryptographic techniques are developed
        and computing performance improves, the work factor to break a
        particular cryptographic algorithm will reduce. Therefore,
        cryptographic algorithm implementations SHOULD be modular allowing new
        algorithms to be readily inserted. That is, implementers SHOULD be
        prepared to regularly update the algorithms in their
        implementations.
</p>
<a name="Subsection-Interactions"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.10.5"></a><h3>10.5.&nbsp;
Attacks on the Interaction between DSKPP and User Authentication</h3>

<p>If keys generated in DSKPP will be associated with a particular
        user at the DSKPP server (or a server trusted by, and communicating
        with the DSKPP server), then in order to protect against threats where
        an attacker replaces a client-provided encrypted R_C with his own R'C
        (regardless of whether the public-key variation or the shared-secret
        variation of DSKPP is employed to encrypt the client nonce), the
        server SHOULD not commit to associate a generated K_TOKEN with the
        given cryptographic module until the user simultaneously has proven
        both possession of the device that hosts the cryptographic module
        containing K_TOKEN and some out-of-band provided authenticating
        information (e.g., an authentication code). For example, if the
        cryptographic module is a one-time password token, the user could be
        required to authenticate with both a one-time password generated by
        the cryptographic module and an out-of-band provided authentication
        code in order to have the server "commit" to the generated OTP value
        for the given user. Preferably, the user SHOULD perform this operation
        from another host than the one used to initialize keys on the
        cryptographic module, in order to minimize the risk of malicious
        software on the client interfering with the process.
</p>
<p>Note: This scenario, wherein the attacker replaces a
        client-provided R_C with his own R'C, does not apply to 2-pass DSKPP
        as the client does not provide any entropy to K_TOKEN. The attack as
        such (and its countermeasures) still applies to 2-pass DSKPP, however,
        as it essentially is a man-in-the-middle attack.
</p>
<p>Another threat arises when an attacker is able to trick a user to
        authenticate to the attacker rather than to the legitimate service
        before the DSKPP protocol run. If successful, the attacker will then
        be able to impersonate the user towards the legitimate service, and
        subsequently receive a valid DSKPP trigger. If the public-key variant
        of DSKPP is used, this may result in the attacker being able to (after
        a successful DSKPP protocol run) impersonate the user. Ordinary
        precautions MUST, therefore, be in place to ensure that users
        authenticate only to legitimate services.
</p>
<a name="anchor50"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.10.6"></a><h3>10.6.&nbsp;
Miscellaneous Considerations</h3>

<a name="anchor51"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.10.6.1"></a><h3>10.6.1.&nbsp;
Client Contributions to K_TOKEN Entropy</h3>

<p>In 4-pass DSKPP, both the client and the server provide
          randomizing material to K_TOKEN, in a manner that allows both
          parties to verify that they did contribute to the resulting key. In
          the 2-pass DSKPP version defined herein, only the server contributes
          to the entropy of K_TOKEN. This means that a broken or compromised
          (pseudo-)random number generator in the server may cause more damage
          than it would in the 4-pass variant. Server implementations SHOULD
          therefore take extreme care to ensure that this situation does not
          occur.
</p>
<a name="anchor52"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.10.6.2"></a><h3>10.6.2.&nbsp;
Key Confirmation</h3>

<p>4-pass DSKPP servers provide key confirmation through the MAC on
          R_C in the &lt;KeyProvServerFinished&gt; message. In the 2-pass
          DSKPP variant described herein, key confirmation is provided by the
          MAC including R, using K_MAC.
</p>
<a name="Subsection-ServerAuth"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.10.6.3"></a><h3>10.6.3.&nbsp;
Server Authentication</h3>

<p>DSKPP servers MUST authenticate themselves whenever a successful
          DSKPP 2-pass protocol run would result in an existing K_TOKEN being
          replaced by a K_TOKEN', or else a denial-of-service attack where an
          unauthorized DSKPP server replaces a K_TOKEN with another key would
          be possible. In 2-pass DSKPP, servers authenticate by including the
          AuthenticationDataType extension containing a MAC as described in
          <a class='info' href='#Subsecton-TwoPass'>Section&nbsp;5<span> (</span><span class='info'>Two-Pass Protocol Usage</span><span>)</span></a> for two-pass DSKPP.
</p>
<a name="anchor53"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.10.6.4"></a><h3>10.6.4.&nbsp;
User Authentication</h3>

<p>A DSKPP server MUST authenticate a client to ensure that K_TOKEN
          is delivered to the intended device. The following measures SHOULD
          be considered:
</p>
<p></p>
<ul class="text">
<li>When an Authentication Code is used for client
              authentication, a password dictionary attack on the
              authentication data is possible.
</li>
<li>The length of the Authentication Code when used over a
              non-secure channel SHOULD be longer than what is used over a
              secure channel. When a device, e.g., some mobile phones with
              small screens, cannot handle a long Authentication Code in a
              user-friendly manner, DSKPP SHOULD rely on a secure channel for
              communication.
</li>
<li>In the case that a non-secure channel has to be used, the
              Authentication Code SHOULD be sent to the server MAC'd as
              specified in <a class='info' href='#Subsection-AD'>Section&nbsp;3.4.1<span> (</span><span class='info'>User Authentication Data, AD</span><span>)</span></a>. The
              Authentication Code and nonce value MUST be strong enough to
              prevent offline brute-force recovery of the Authentication Code
              from the HMAC data. Given that the nonce value is sent in
              plaintext format over a non-secure transport, the cryptographic
              strength of the Authentication Data depends more on the quality
              of the Authentication Code.
</li>
<li>When the Authentication Code is sent from the DSKPP server to
              the device in a DSKPP initialization trigger message, an
              eavesdropper may be able to capture this message and race the
              legitimate user for a key initialization. To prevent this, the
              transport layer used to send the DSKPP trigger MUST provide
              confidentiality and integrity, e.g. a secure browser
              session.
</li>
</ul>

<a name="anchor54"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.10.6.5"></a><h3>10.6.5.&nbsp;
Key Protection in Two-Pass DSKPP</h3>

<p>Three key protection methods are defined for the different usages
          of 2-pass DSKPP, which MUST be supported by a key package format,
          such as <a class='info' href='#PSKC'>[PSKC]<span> (</span><span class='info'>, &ldquo;Portable Symmetric Key Container,&rdquo; 2008.</span><span>)</span></a> and <a class='info' href='#SKPC-ASN.1'>[SKPC&#8209;ASN.1]<span> (</span><span class='info'>, &ldquo;Symmetric Key Package Content Type,&rdquo; 2007.</span><span>)</span></a>. Therefore, key protection in the
          two-pass DSKPP is dependent upon the security of the key package
          format selected for a protocol run. Some considerations for the
          Passphrase-Based Key Wrap method follow.
</p>
<p>The passphrase-based key wrap method SHOULD depend upon the
          PBKDF2 function from <a class='info' href='#PKCS-5'>[PKCS&#8209;5]<span> (</span><span class='info'>RSA Laboratories, &ldquo;Password-Based Cryptography Standard,&rdquo; March&nbsp;1999.</span><span>)</span></a> to generate an
          encryption key from a passphrase and salt string. It is important to
          note that passphrase-based encryption is generally limited in the
          security that it provides despite the use of salt and iteration
          count in PBKDF2 to increase the complexity of attack.
          Implementations SHOULD therefore take additional measures to
          strengthen the security of the passphrase-based key wrap method. The
          following measures SHOULD be considered where applicable:
</p>
<p></p>
<ul class="text">
<li>The passphrase is the same as the one-time password component
              of the authentication code (see <a class='info' href='#Subsection-AD'>Section&nbsp;3.4.1<span> (</span><span class='info'>User Authentication Data, AD</span><span>)</span></a>) for a description of the AC
              format). The passphrase SHOULD be selected well, and usage
              guidelines such as the ones in <a class='info' href='#NIST-PWD'>[NIST&#8209;PWD]<span> (</span><span class='info'>National Institute of Standards and             Technology, &ldquo;Password Usage,&rdquo; May&nbsp;1985.</span><span>)</span></a>
              SHOULD be taken into account.
</li>
<li>A different passphrase SHOULD be used for every key
              initialization wherever possible (the use of a global passphrase
              for a batch of cryptographic modules SHOULD be avoided, for
              example). One way to achieve this is to use randomly-generated
              passphrases.
</li>
<li>The passphrase SHOULD be protected well if stored on the
              server and/or on the cryptographic module and SHOULD be
              delivered to the device's user using secure methods.
</li>
<li>User per-authentication SHOULD be implemented to ensure that
              K_TOKEN is not delivered to a rogue recipient.
</li>
<li>The iteration count in PBKDF2 SHOULD be high to impose more
              work for an attacker using brute-force methods (see <a class='info' href='#PKCS-5'>[PKCS&#8209;5]<span> (</span><span class='info'>RSA Laboratories, &ldquo;Password-Based Cryptography Standard,&rdquo; March&nbsp;1999.</span><span>)</span></a> for recommendations). However, it MUST
              be noted that the higher the count, the more work is required on
              the legitimate cryptographic module to decrypt the newly
              delivered K_TOKEN. Servers MAY use relatively low iteration
              counts to accommodate devices with limited processing power such
              as some PDA and cell phones when other security measures are
              implemented and the security of the passphrase-based key wrap
              method is not weakened.
</li>
<li>Transport level security (e.g. TLS) SHOULD be used where
              possible to protect a two-pass protocol run. Transport level
              security provides a second layer of protection for the newly
              generated K_TOKEN.
</li>
</ul>

<a name="anchor55"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.11"></a><h3>11.&nbsp;
Internationalization Considerations</h3>

<p>The DSKPP protocol is mostly meant for machine-to-machine
      communications; as such, most of its elements are tokens not meant for
      direct human consumption. If these tokens are presented to the end user,
      some localization may need to occur. DSKPP exchanges information using
      XML. All XML processors are required to understand UTF-8 and UTF-16
      encoding, and therefore all DSKPP clients and servers MUST understand
      UTF-8 and UTF-16 encoded XML. Additionally, DSKPP servers and clients
      MUST NOT encode XML with encodings other than UTF-8 or UTF-16.
</p>
<a name="anchor56"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.12"></a><h3>12.&nbsp;
IANA Considerations</h3>

<p>This document requires several IANA registrations, detailed
      below.
</p>
<a name="anchor57"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.12.1"></a><h3>12.1.&nbsp;
URN Sub-Namespace Registration</h3>

<p>This section registers a new XML namespace,
        "urn:ietf:params:xml:ns:keyprov:dskpp" per the guidelines in <a class='info' href='#RFC3688'>[RFC3688]<span> (</span><span class='info'>Mealling, M., &ldquo;The IETF XML Registry,&rdquo; January&nbsp;2004.</span><span>)</span></a>:
</p>
<p></p>
<blockquote class="text"><dl>
<dt>URI:</dt>
<dd>urn:ietf:params:xml:ns:keyprov:dskpp
</dd>
<dt>Registrant Contact:</dt>
<dd>IETF,
            KEYPROV Working Group (keyprov@ietf.org), Andrea Doherty
            (andrea.doherty@rsa.com)
</dd>
<dt>XML:</dt>
<dd>
</dd>
</dl></blockquote>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>   BEGIN
      &lt;?xml version="1.0"?&gt;
      &lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
         "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"&gt;
      &lt;html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en"&gt;
      &lt;head&gt;
         &lt;title&gt;DSKPP Messsages&lt;/title&gt;
      &lt;/head&gt;
      &lt;body&gt;
         &lt;h1&gt;Namespace for DSKPP Messages&lt;/h1&gt;
         &lt;h2&gt;urn:ietf:params:xml:ns:keyprov:dskpp&lt;/h2&gt;
         [NOTE TO IANA/RFC-EDITOR: Please replace XXXX below
         with the RFC number for this specification.]
         &lt;p&gt;See RFCXXXX&lt;/p&gt;
      &lt;/body&gt;
      &lt;/html&gt;
   END

</pre></div>
<a name="anchor58"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.12.2"></a><h3>12.2.&nbsp;
XML Schema Registration</h3>

<p>This section registers an XML schema as per the guidelines in <a class='info' href='#RFC3688'>[RFC3688]<span> (</span><span class='info'>Mealling, M., &ldquo;The IETF XML Registry,&rdquo; January&nbsp;2004.</span><span>)</span></a>.
</p>
<p></p>
<blockquote class="text"><dl>
<dt>URI:</dt>
<dd>urn:ietf:params:xml:ns:keyprov:dskpp
</dd>
<dt>Registrant Contact:</dt>
<dd>IETF,
            KEYPROV Working Group (keyprov@ietf.org), Andrea Doherty
            (andrea.doherty@rsa.com)
</dd>
<dt>Schema:</dt>
<dd>The XML for this
            schema can be found as the entirety of <a class='info' href='#Section-Schema'>Section&nbsp;8<span> (</span><span class='info'>DSKPP XML Schema</span><span>)</span></a> of this document.
</dd>
</dl></blockquote>

<a name="anchor59"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.12.3"></a><h3>12.3.&nbsp;
MIME Media Type Registration</h3>

<p>This section registers the "application/dskpp+xml" MIME type:
</p>
<p></p>
<blockquote class="text"><dl>
<dt>To:</dt>
<dd>ietf-types@iana.org
</dd>
<dt>Subject:</dt>
<dd>Registration of MIME media type
            application/dskpp+xml
</dd>
<dt>MIME media type name:</dt>
<dd>application
</dd>
<dt>MIME subtype name:</dt>
<dd>dskpp+xml
</dd>
<dt>Required parameters:</dt>
<dd>(none)
</dd>
<dt>Optional parameters:</dt>
<dd>charsetIndicates the character encoding of enclosed XML.
            Default is UTF-8.
</dd>
<dt>Encoding considerations:</dt>
<dd>Uses XML, which can employ
            8-bit characters, depending on the character encoding used. See
            <a class='info' href='#RFC3203'>[RFC3203]<span> (</span><span class='info'>Murata, M., St. Laurent, S., and D. Kohn, &ldquo;XML Media Types,&rdquo; January&nbsp;2001.</span><span>)</span></a>, Section 3.2.
</dd>
<dt>Security considerations:</dt>
<dd>This content type is
            designed to carry protocol data related to key management.
            Security mechanisms are built into the protocol to ensure that
            various threats are dealt with.
</dd>
<dt>Interoperability considerations:</dt>
<dd>This content type
            provides a basis for a protocol.
</dd>
<dt>Published specification:</dt>
<dd>RFC XXXX [NOTE TO
            IANA/RFC-EDITOR: Please replace XXXX with the RFC number for this
            specification.]
</dd>
<dt>Applications which use this media type:</dt>
<dd>Protocol for
            key exchange.
</dd>
<dt>Additional information:</dt>
<dd>Magic Number(s): (none)<br />
File extension(s): .xmls<br />
Macintosh File Type Code(s): (none)
</dd>
<dt>Person &amp; email address to contact for further information:</dt>
<dd>Andrea Doherty (andrea.doherty@rsa.com)
</dd>
<dt>Intended usage:</dt>
<dd>LIMITED USE
</dd>
<dt>Author/Change controller:</dt>
<dd>The IETF
</dd>
<dt>Other information:</dt>
<dd>This media type is a
            specialization of application/xml <a class='info' href='#RFC3203'>[RFC3203]<span> (</span><span class='info'>Murata, M., St. Laurent, S., and D. Kohn, &ldquo;XML Media Types,&rdquo; January&nbsp;2001.</span><span>)</span></a>,
            and many of the considerations described there also apply to
            application/dskpp+xml.
</dd>
</dl></blockquote>

<a name="anchor60"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.12.4"></a><h3>12.4.&nbsp;
Status Code Registry</h3>

<p>This section registers status codes included in each DSKPP response
        message. The status codes are defined in the schema in the
        &lt;StatusCode&gt; type definition contained in the XML schema in
        <a class='info' href='#Section-Schema'>Section&nbsp;8<span> (</span><span class='info'>DSKPP XML Schema</span><span>)</span></a>. The following summarizes the
        registry:
</p>
<p></p>
<blockquote class="text"><dl>
<dt>Related Registry:</dt>
<dd>KEYPROV
            DSKPP Registries, Status codes for DSKPP<br />
<br />

</dd>
<dt>Defining RFC:</dt>
<dd>RFC XXXX
            [NOTE TO IANA/RFC-EDITOR: Please replace XXXX with the RFC number
            for this specification.]<br />
<br />

</dd>
<dt>Registration/Assignment Procedures:</dt>
<dd>Following the policies outlined in <a class='info' href='#RFC3575'>[RFC3575]<span> (</span><span class='info'>Aboba, B., &ldquo;IANA Considerations for RADIUS,&rdquo; July&nbsp;2003.</span><span>)</span></a>, the IANA policy for assigning new values
            for the status codes for DSKPP MUST be "Specification Required"
            and their meanings MUST be documented in an RFC or in some other
            permanent and readily available reference, in sufficient detail
            that interoperability between independent implementations is
            possible. No mechanism to mark entries as "deprecated" is
            envisioned. It is possible to delete or update entries from the
            registry.<br />
<br />

</dd>
<dt>Registrant Contact:</dt>
<dd>IETF,
            KEYPROV working group (keyprov@ietf.org),<br />
Andrea Doherty (andrea.doherty@rsa.com)
</dd>
</dl></blockquote>

<a name="Section-IPR"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.13"></a><h3>13.&nbsp;
Intellectual Property Considerations</h3>

<p>RSA and RSA Security are registered trademarks or trademarks of RSA
      Security Inc. in the United States and/or other countries. The names of
      other products and services mentioned may be the trademarks of their
      respective owners.
</p>
<a name="anchor61"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.14"></a><h3>14.&nbsp;
Contributors</h3>

<p>This work is based on information contained in <a class='info' href='#RFC4758'>[RFC4758]<span> (</span><span class='info'>RSA, The Security Division of EMC, &ldquo;Cryptographic Token Key Initialization Protocol           (CT-KIP),&rdquo; November&nbsp;2006.</span><span>)</span></a>, authored by Magnus Nystrom, with enhancements
      borrowed from an individual Internet-Draft co-authored by Mingliang Pei
      and Salah Machani (e.g., User Authentication, and support for multiple
      key package formats).
</p>
<p>We would like to thank Philip Hoyer for his work in aligning DSKPP
      and PSKC schemas.
</p>
<p>We would also like to thank Hannes Tschofenig and Phillip
      Hallam-Baker for their draft reviews, feedback, and text
      contributions.
</p>
<a name="Section-Acknowledgements"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.15"></a><h3>15.&nbsp;
Acknowledgements</h3>

<p>We would like to thank the following for review of previous DSKPP
      document versions:<br />
<br />
</p>
<ul class="text">
<li>Dr. Ulrike Meyer (Review June 2007)<br />

</li>
<li>Niklas Neumann (Review June 2007)<br />

</li>
<li>Shuh Chang (Review June 2007)<br />

</li>
<li>Hannes Tschofenig (Review June 2007 and again in August
          2007)<br />

</li>
<li>Sean Turner (Reviews August 2007 and again in July 2008)<br />

</li>
<li>John Linn (Review August 2007)<br />

</li>
<li>Philip Hoyer (Review September 2007)<br />

</li>
<li>Thomas Roessler (Review November 2007)<br />

</li>
<li>Lakshminath Dondeti (Comments December 2007)<br />

</li>
<li>Pasi Eronen (Comments December 2007)<br />

</li>
<li>Phillip Hallam-Baker (Review and Edits November 2008 and again in
          January 2009)
</li>
</ul>

<p>We would also like to thank the following for their input to selected
      design aspects of the DSKPP protocol:<br />
<br />
</p>
<ul class="text">
<li>Anders Rundgren (Key Package Format and Client Authentication
          Data)<br />

</li>
<li>Thomas Roessler (HTTP Binding)<br />

</li>
<li>Hannes Tschofenig (HTTP Binding)<br />

</li>
<li>Phillip Hallam-Baker (Registry for Algorithms)
</li>
</ul>

<p>Finally, we would like to thank Robert Griffin for opening
      communication channels for us with the IEEE P1619.3 Key Management
      Group, and facilitating our groups in staying informed of potential
      areas (esp. key provisioning and global key identifiers of
      collaboration) of collaboration.
</p>
<a name="rfc.references"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.16"></a><h3>16.&nbsp;
References</h3>

<a name="rfc.references1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>16.1.&nbsp;Normative references</h3>
<table width="99%" border="0">
<tr><td class="author-text" valign="top"><a name="FIPS180-SHA">[FIPS180-SHA]</a></td>
<td class="author-text">National Institute of Standards and
            Technology, &ldquo;<a href="http://csrc.nist.gov/publications/fips/fips180-2/fips180-2withchangenotice.pdf">Secure Hash Standard</a>,&rdquo; FIPS&nbsp;180-2, February&nbsp;2004.</td></tr>
<tr><td class="author-text" valign="top"><a name="FIPS197-AES">[FIPS197-AES]</a></td>
<td class="author-text">National Institute of Standards and
            Technology, &ldquo;<a href="http://csrc.nist.gov/publications/fips/fips197/fips-197.pdf">Specification for the Advanced Encryption Standard
          (AES)</a>,&rdquo; FIPS&nbsp;197, November&nbsp;2001.</td></tr>
<tr><td class="author-text" valign="top"><a name="PKCS-1">[PKCS-1]</a></td>
<td class="author-text">RSA Laboratories, &ldquo;<a href="http://www.rsasecurity.com/rsalabs/pkcs/">RSA Cryptography Standard</a>,&rdquo; PKCS&nbsp;#1 Version 2.1, June&nbsp;2002.</td></tr>
<tr><td class="author-text" valign="top"><a name="PKCS-5">[PKCS-5]</a></td>
<td class="author-text">RSA Laboratories, &ldquo;<a href="http://www.rsasecurity.com/rsalabs/pkcs/">Password-Based Cryptography Standard</a>,&rdquo; PKCS&nbsp;#5 Version 2.0, March&nbsp;1999.</td></tr>
<tr><td class="author-text" valign="top"><a name="PKCS-5-XML">[PKCS-5-XML]</a></td>
<td class="author-text">RSA Laboratories, &ldquo;<a href="http://www.rsasecurity.com/rsalabs/pkcs/">XML Schema for PKCS #5 Version 2.0</a>,&rdquo; PKCS&nbsp;#5 Version 2.0 Amd.1 (FINAL DRAFT), October&nbsp;2006.</td></tr>
<tr><td class="author-text" valign="top"><a name="PSKC">[PSKC]</a></td>
<td class="author-text">&ldquo;<a href="org/internet-drafts/draft-hoyer-keyprov-portable-symmetric-key-container-03.txt">Portable Symmetric Key Container</a>,&rdquo; 2008.</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC2104">[RFC2104]</a></td>
<td class="author-text">Krawzcyk, H., <a href="mailto:">Bellare, M.</a>, and <a href="mailto:">R. Canetti</a>, &ldquo;<a href="http://www.ietf.org/rfc/rfc2104.txt">HMAC: Keyed-Hashing for Message Authentication</a>,&rdquo; RFC&nbsp;2104, February&nbsp;1997.</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC2119">[RFC2119]</a></td>
<td class="author-text">&ldquo;<a href="http://www.ietf.org/rfc/rfc2119.txt">Key words for use in RFCs to Indicate Requirement
          Levels</a>,&rdquo; BCP&nbsp;14, RFC&nbsp;2119, March&nbsp;1997.</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC3629">[RFC3629]</a></td>
<td class="author-text">&ldquo;<a href="http://www.ietf.org/rfc/rfc3629.txt">UTF-8, a transformation format of ISO10646</a>,&rdquo; STD&nbsp;63, RFC&nbsp;3629, November&nbsp;2003.</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4210">[RFC4210]</a></td>
<td class="author-text">Adams, C., Farrell, S., Kause, T., and T. Mononen, &ldquo;<a href="http://www.ietf.org/rfc/rfc4210.txt">Internet X.509 Public Key Infrastructure Certificate
          Management Protocol (CMP)</a>,&rdquo; RFC&nbsp;4210, September&nbsp;2005 (<a href="ftp://ftp.isi.edu/in-notes/rfc4210.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC5272">[RFC5272]</a></td>
<td class="author-text">Schaad, J. and M. Myers, &ldquo;<a href="http://www.ietf.org/rfc/rfc5272.txt">Certificate Management over CMS (CMC)</a>,&rdquo; RFC&nbsp;5272, June&nbsp;2008 (<a href="ftp://ftp.isi.edu/in-notes/rfc5272.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="UNICODE">[UNICODE]</a></td>
<td class="author-text">Davis, M. and <a href="mailto:">M. Duerst</a>, &ldquo;<a href="http://www.unicode.org/unicode/reports/tr15/tr15-21.html">Unicode Normalization Forms</a>,&rdquo; March&nbsp;2001.</td></tr>
<tr><td class="author-text" valign="top"><a name="XMLDSIG">[XMLDSIG]</a></td>
<td class="author-text">W3C, &ldquo;<a href="http://www.w3.org/TR/2002/REC-xmldsig-core-20020212/">XML Signature Syntax and Processing</a>,&rdquo; W3C&nbsp;Recommendation, February&nbsp;2002.</td></tr>
<tr><td class="author-text" valign="top"><a name="XMLENC">[XMLENC]</a></td>
<td class="author-text">W3C, &ldquo;<a href="http://www.w3.org/TR/2002/REC-xmldsig-core-20020212/">XML Encryption Syntax and Processing</a>,&rdquo; W3C&nbsp;Recommendation, December&nbsp;2002.</td></tr>
</table>

<a name="rfc.references2"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>16.2.&nbsp;Informative references</h3>
<table width="99%" border="0">
<tr><td class="author-text" valign="top"><a name="AESKWPAD">[AESKWPAD]</a></td>
<td class="author-text">Housley, R. and M. Dworkin, &ldquo;<a href="http://www.ietf.org/internet-drafts/draft-housley-aes-key-wrap-with-pad-02.txt">Advanced Encryption Standard (AES) Key Wrap with Padding
          Algorithm</a>,&rdquo; March&nbsp;2009.</td></tr>
<tr><td class="author-text" valign="top"><a name="CT-KIP-P11">[CT-KIP-P11]</a></td>
<td class="author-text">RSA Laboratories, &ldquo;<a href="http://www.rsasecurity.com/rsalabs/pkcs/">PKCS #11 Mechanisms for the Cryptographic Token Key
          Initialization Protocol</a>,&rdquo; PKCS&nbsp;#11 Version 2.20 Amd.2, December&nbsp;2005.</td></tr>
<tr><td class="author-text" valign="top"><a name="FAQ">[FAQ]</a></td>
<td class="author-text">RSA Laboratories, &ldquo;Frequently Asked Questions About Today's Cryptography,&rdquo; &nbsp;Version 4.1, 2000.</td></tr>
<tr><td class="author-text" valign="top"><a name="ISO3309">[ISO3309]</a></td>
<td class="author-text">&ldquo;ISO Information Processing Systems - Data Communication -
          High-Level Data Link Control Procedure - Frame Structure,&rdquo; IS&nbsp;3309, 3rd Edition, October&nbsp;1984.</td></tr>
<tr><td class="author-text" valign="top"><a name="NIST-PWD">[NIST-PWD]</a></td>
<td class="author-text">National Institute of Standards and
            Technology, &ldquo;<a href="http://www.itl.nist.gov/fipspubs/fip112.htm">Password Usage</a>,&rdquo; FIPS&nbsp;112, May&nbsp;1985.</td></tr>
<tr><td class="author-text" valign="top"><a name="NIST-SP800-38B">[NIST-SP800-38B]</a></td>
<td class="author-text">International Organization for
            Standardization, &ldquo;<a href="http://csrc.nist.gov/publications/nistpubs/800-38B/SP_800-38B.pdf">Recommendations for Block Cipher Modes of Operation: The CMAC
          Mode for Authentication</a>,&rdquo; NIST&nbsp;SP800-38B, May&nbsp;2005.</td></tr>
<tr><td class="author-text" valign="top"><a name="NIST-SP800-57">[NIST-SP800-57]</a></td>
<td class="author-text">National Institute of Standards and
            Technology, &ldquo;<a href="http://csrc.nist.gov/publications/nistpubs/800-57/sp800-57-Part1-revised2_Mar08-2007.pdf">Recommendation for Key Management - Part I: General
          (Revised)</a>,&rdquo; NIST&nbsp;800-57, March&nbsp;2007.</td></tr>
<tr><td class="author-text" valign="top"><a name="PKCS-11">[PKCS-11]</a></td>
<td class="author-text">RSA Laboratories, &ldquo;<a href="http://www.rsasecurity.com/rsalabs/pkcs/">Cryptographic Token Interface Standard</a>,&rdquo; PKCS&nbsp;#11 Version 2.20, June&nbsp;2004.</td></tr>
<tr><td class="author-text" valign="top"><a name="PKCS-12">[PKCS-12]</a></td>
<td class="author-text">&ldquo;<a href="ftp://ftp.rsasecurity.com/pub/pkcs/pkcs-12/pkcs-12v1.pdf">Personal Information Exchange Syntax Standard</a>,&rdquo; PKCS&nbsp;#12 Version 1.0, 2005.</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC2396">[RFC2396]</a></td>
<td class="author-text">Berners-Lee, T., <a href="mailto:">Fielding, R.</a>, and <a href="mailto:">L. Masinter</a>, &ldquo;<a href="http://www.ietf.org/rfc/rfc2396.txt">Uniform Resource Identifiers (URI): Generic Syntax</a>,&rdquo; RFC&nbsp;2396, August&nbsp;1998.</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC2616">[RFC2616]</a></td>
<td class="author-text">Fielding, R., <a href="mailto:">Gettys, J.</a>, <a href="mailto:">Mogul, J.</a>, <a href="mailto:">Frystyk, H.</a>, <a href="mailto:">Masinter, L.</a>, <a href="mailto:">Leach, P.</a>, and <a href="mailto:">T. Berners-Lee</a>, &ldquo;<a href="http://www.ietf.org/rfc/rfc2616.txt">Hypertext Transfer Protocol -- HTTP/1.1</a>,&rdquo; RFC&nbsp;2616, June&nbsp;1999.</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC3203">[RFC3203]</a></td>
<td class="author-text">Murata, M., <a href="mailto:">St. Laurent, S.</a>, and <a href="mailto:">D. Kohn</a>, &ldquo;<a href="http://www.ietf.org/rfc/rfc3203.txt">XML Media Types</a>,&rdquo; RFC&nbsp;3203, January&nbsp;2001.</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC3575">[RFC3575]</a></td>
<td class="author-text">Aboba, B., &ldquo;<a href="http://www.ietf.org/rfc/rfc3575.txt">IANA Considerations for RADIUS</a>,&rdquo; RFC&nbsp;3575, July&nbsp;2003.</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC3688">[RFC3688]</a></td>
<td class="author-text">Mealling, M., &ldquo;<a href="http://www.ietf.org/rfc/rfc3688.txt">The IETF XML Registry</a>,&rdquo; RFC&nbsp;3688, BCP&nbsp;81, January&nbsp;2004.</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4758">[RFC4758]</a></td>
<td class="author-text">RSA, The Security Division of EMC, &ldquo;<a href="http://www.ietf.org/rfc/rfc4758.txt">Cryptographic Token Key Initialization Protocol
          (CT-KIP)</a>,&rdquo; November&nbsp;2006.</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC5280">[RFC5280]</a></td>
<td class="author-text"><a href="mailto:">Cooper, D.</a>, <a href="mailto:">Santesson, S.</a>, <a href="mailto:">Farrell, S.</a>, <a href="mailto:">Boeyen, S.</a>, Housley, R., and <a href="mailto:">W. Polk</a>, &ldquo;<a href="http://www.ietf.org/rfc/rfc5280.txt">Internet X.509 Public Key Infrastructure Certificate and
          Certificate Revocation List (CRL) Profile</a>,&rdquo; RFC&nbsp;5280, May&nbsp;2008.</td></tr>
<tr><td class="author-text" valign="top"><a name="SKPC-ASN.1">[SKPC-ASN.1]</a></td>
<td class="author-text">&ldquo;<a href="http://www.ietf.org/internet-drafts/draft-ietf-keyprov-symmetrickeyformat-01.txt">Symmetric Key Package Content Type</a>,&rdquo; 2007.</td></tr>
<tr><td class="author-text" valign="top"><a name="XMLNS">[XMLNS]</a></td>
<td class="author-text">W3C, &ldquo;<a href="http://www.w3.org/TR/1999/REC-xml-names-19990114 ">Namespaces in XML</a>,&rdquo; W3C&nbsp;Recommendation, January&nbsp;1999.</td></tr>
</table>

<a name="Section-Usage-Scenarios"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.A"></a><h3>Appendix A.&nbsp;
Usage Scenarios</h3>

<p>DSKPP is expected to be used to provision symmetric keys to
      cryptographic modules in a number of different scenarios, each with its
      own special requirements, as described below. This appendix forms an
      informative part of the document.
</p>
<a name="UC1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.A.1"></a><h3>A.1.&nbsp;
Single Key Request</h3>

<p>The usual scenario is that a cryptographic module makes a request
        for a symmetric key from a provisioning server that is located on the
        local network or somewhere on the Internet. Depending upon the
        deployment scenario, the provisioning server may generate a new key
        on-the-fly or use a pre-generated key, e.g., one provided by a legacy
        back-end issuance server. The provisioning server assigns a unique key
        ID to the symmetric key and provisions it to the cryptographic
        module.
</p>
<a name="anchor64"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.A.2"></a><h3>A.2.&nbsp;
Multiple Key Requests</h3>

<p>A cryptographic module makes multiple requests for symmetric keys
        from the same provisioning server. The symmetric keys need not be of
        the same type, i.e., the keys may be used with different symmetric key
        cryptographic algorithms, including one-time password authentication
        algorithms, and the AES encryption algorithm.
</p>
<a name="anchor65"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.A.3"></a><h3>A.3.&nbsp;
User Authentication</h3>

<p>In some deployment scenarios, a key issuer may rely on a third
        party provisioning service. In this case, the issuer directs
        provisioning requests from the cryptographic module to the
        provisioning service. As such, it is the responsibility of the issuer
        to authenticate the user through some out-of-band means before
        granting him rights to acquire keys. Once the issuer has granted those
        rights, the issuer provides an authentication code to the user and
        makes it available to the provisioning service, so that the user can
        prove that he is authorized to acquire keys.
</p>
<a name="anchor66"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.A.4"></a><h3>A.4.&nbsp;
Provisioning Time-Out Policy</h3>

<p>An issuer may provide a time-limited authentication code to a user
        during registration, which the user will input into the cryptographic
        module to authenticate themselves with the provisioning server. The
        server will allow a key to be provisioned to the cryptographic module
        hosted by the user's device when user authentication is required only
        if the user inputs a valid authentication code within the fixed time
        period established by the issuer.
</p>
<a name="anchor67"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.A.5"></a><h3>A.5.&nbsp;
Key Renewal</h3>

<p>A cryptographic module requests renewal of the symmetric key
        material attached to a key ID, as opposed to keeping the key value
        constant and refreshing the metadata. Such a need may occur in the
        case when a user wants to upgrade her device that houses the
        cryptographic module or when a key has expired. When a user uses the
        same cryptographic module to, for example, perform strong
        authentication at multiple Web login sites, keeping the same key ID
        removes the need for the user to register a new key ID at each
        site.
</p>
<a name="anchor68"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.A.6"></a><h3>A.6.&nbsp;
Pre-Loaded Key Replacement</h3>

<p>This scenario represents a special case of symmetric key renewal in
        which a local administrator can authenticate the user procedurally
        before initiating the provisioning process. It also allows for a
        device issuer to pre-load a key onto a cryptographic module with a
        restriction that the key is replaced with a new key prior to use of
        the cryptographic module. Another variation of this scenario is the
        organization who recycles devices. In this case, a key issuer would
        provision a new symmetric key to a cryptographic module hosted on a
        device that was previously owned by another user.
</p>
<p>Note that this usage scenario is essentially the same as the
        previous scenario wherein the same key ID is used for renewal.
</p>
<a name="anchor69"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.A.7"></a><h3>A.7.&nbsp;
Pre-Shared Manufacturing Key</h3>

<p>A cryptographic module is loaded onto a smart card after the card
        is issued to a user. The symmetric key for the cryptographic module
        will then be provisioned using a secure channel mechanism present in
        many smart card platforms. This allows a direct secure channel to be
        established between the smart card chip and the provisioning server.
        For example, the card commands (i.e., Application Protocol Data Units,
        or APDUs) are encrypted with a pre-issued card manufacturer's key and
        sent directly to the smart card chip, allowing secure post-issuance
        in-the-field provisioning. This secure flow can pass Transport Layer
        Security (TLS) and other transport security boundaries.
</p>
<p>Note that two pre-conditions for this usage scenario are for the
        protocol to be tunneled and the provisioning server to know the
        correct pre-established manufacturer's key.
</p>
<a name="anchor70"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.A.8"></a><h3>A.8.&nbsp;
End-to-End Protection of Key Material</h3>

<p>In this scenario, transport layer security does not provide
        end-to-end protection of keying material transported from the
        provisioning server to the cryptographic module. For example, TLS may
        terminate at an application hosted on a PC rather than at the
        cryptographic module (i.e., the endpoint) located on a data storage
        device. Mutually authenticated key agreement provides end-to-end
        protection, which TLS cannot provide.
</p>
<a name="Section-Examples"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.B"></a><h3>Appendix B.&nbsp;
Examples</h3>

<p>This appendix contains example messages that illustrate parameters,
      encoding, and semantics in four-and two- pass DSKPP exchanges. The
      examples are written using XML, and are syntactically correct. MAC and
      cipher values are fictitious however. This appendix forms an informative
      part of the document.
</p>
<a name="anchor71"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.B.1"></a><h3>B.1.&nbsp;
Trigger Message</h3>

<p>
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;dskpp:KeyProvTrigger Version="1.0"
  xmlns:dskpp="urn:ietf:params:xml:ns:keyprov:dskpp"
  xmlns:pskc="urn:ietf:params:xml:ns:keyprov:pskc"&gt;
  &lt;dskpp:InitializationTrigger&gt;
    &lt;dskpp:DeviceIdentifierData&gt;
      &lt;dskpp:DeviceId&gt;
        &lt;pskc:Manufacturer&gt;ManufacturerABC&lt;/pskc:Manufacturer&gt;
        &lt;pskc:SerialNo&gt;XL0000000001234&lt;/pskc:SerialNo&gt;
        &lt;pskc:Model&gt;U2&lt;/pskc:Model&gt;
      &lt;/dskpp:DeviceId&gt;
    &lt;/dskpp:DeviceIdentifierData&gt;
    &lt;dskpp:KeyID&gt;SE9UUDAwMDAwMDAx&lt;/dskpp:KeyID&gt;
    &lt;dskpp:TokenPlatformInfo KeyLocation="Hardware"
      AlgorithmLocation="Software"/&gt;
    &lt;dskpp:AuthenticationData&gt;
      &lt;dskpp:ClientID&gt;31300257&lt;/dskpp:ClientID&gt;
      &lt;dskpp:AuthenticationCodeMac&gt;
        &lt;dskpp:IterationCount&gt;512&lt;/dskpp:IterationCount&gt;
        &lt;dskpp:Mac&gt;4bRJf9xXd3KchKoTenHJiw==&lt;/dskpp:Mac&gt;
      &lt;/dskpp:AuthenticationCodeMac&gt;
    &lt;/dskpp:AuthenticationData&gt;
    &lt;dskpp:ServerUrl&gt;https://www.somekeyprovservice.com/
      &lt;/dskpp:ServerUrl&gt;
  &lt;/dskpp:InitializationTrigger&gt;
&lt;/dskpp:KeyProvTrigger&gt;</pre></div>
<p>
</p>
<a name="anchor72"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.B.2"></a><h3>B.2.&nbsp;
Four-Pass Protocol</h3>

<a name="anchor73"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.B.2.1"></a><h3>B.2.1.&nbsp;
&lt;KeyProvClientHello&gt; Without a Preceding Trigger</h3>

<p>
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>   &lt;?xml version="1.0" encoding="UTF-8"?&gt;
   &lt;dskpp:KeyProvClientHello Version="1.0"
     xmlns:dskpp="urn:ietf:params:xml:ns:keyprov:dskpp"
     xmlns:pskc="urn:ietf:params:xml:ns:keyprov:pskc"
     xmlns:ds="http://www.w3.org/2000/09/xmldsig#"&gt;
     &lt;dskpp:DeviceIdentifierData&gt;
       &lt;dskpp:DeviceId&gt;
         &lt;pskc:Manufacturer&gt;ManufacturerABC&lt;/pskc:Manufacturer&gt;
         &lt;pskc:SerialNo&gt;XL0000000001234&lt;/pskc:SerialNo&gt;
         &lt;pskc:Model&gt;U2&lt;/pskc:Model&gt;
       &lt;/dskpp:DeviceId&gt;
     &lt;/dskpp:DeviceIdentifierData&gt;
     &lt;dskpp:SupportedKeyTypes&gt;
       &lt;dskpp:Algorithm&gt;http://www.ietf.org/keyprov/pskc#hotp
         &lt;/dskpp:Algorithm&gt;
       &lt;dskpp:Algorithm&gt;http://www.rsa.com/rsalabs/otps/schemas/2005/09/
      otps-wst#SecurID-AES&lt;/dskpp:Algorithm&gt;
     &lt;/dskpp:SupportedKeyTypes&gt;
     &lt;dskpp:SupportedEncryptionAlgorithms&gt;
       &lt;dskpp:Algorithm&gt;http://www.w3.org/2001/05/xmlenc#rsa_1_5
         &lt;/dskpp:Algorithm&gt;
       &lt;dskpp:Algorithm&gt;http://www.ietf.org/keyprov/dskpp#dskpp-prf-aes-128
         &lt;/dskpp:Algorithm&gt;
     &lt;/dskpp:SupportedEncryptionAlgorithms&gt;
     &lt;dskpp:SupportedMacAlgorithms&gt;
       &lt;dskpp:Algorithm&gt;http://www.ietf.org/keyprov/dskpp#dskpp-prf-aes-128
         &lt;/dskpp:Algorithm&gt;
     &lt;/dskpp:SupportedMacAlgorithms&gt;
     &lt;dskpp:SupportedProtocolVariants&gt;&lt;dskpp:FourPass/&gt;
       &lt;/dskpp:SupportedProtocolVariants&gt;
     &lt;dskpp:SupportedKeyPackages&gt;
       &lt;dskpp:KeyPackageFormat&gt;
         urn:ietf:params:xml:ns:keyprov:pskc#KeyContainer
       &lt;/dskpp:KeyPackageFormat&gt;
     &lt;/dskpp:SupportedKeyPackages&gt;
   &lt;/dskpp:KeyProvClientHello&gt;</pre></div>
<p>
</p>
<a name="anchor74"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.B.2.2"></a><h3>B.2.2.&nbsp;
&lt;KeyProvClientHello&gt; Assuming a Preceding Trigger</h3>

<p>
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>   &lt;?xml version="1.0" encoding="UTF-8"?&gt;
   &lt;dskpp:KeyProvClientHello Version="1.0"
     xmlns:dskpp="urn:ietf:params:xml:ns:keyprov:dskpp"
     xmlns:pskc="urn:ietf:params:xml:ns:keyprov:pskc"
     xmlns:ds="http://www.w3.org/2000/09/xmldsig#"&gt;
     &lt;dskpp:DeviceIdentifierData&gt;
       &lt;dskpp:DeviceId&gt;
         &lt;pskc:Manufacturer&gt;ManufacturerABC&lt;/pskc:Manufacturer&gt;
         &lt;pskc:SerialNo&gt;XL0000000001234&lt;/pskc:SerialNo&gt;
         &lt;pskc:Model&gt;U2&lt;/pskc:Model&gt;
       &lt;/dskpp:DeviceId&gt;
     &lt;/dskpp:DeviceIdentifierData&gt;
     &lt;dskpp:KeyID&gt;SE9UUDAwMDAwMDAx&lt;/dskpp:KeyID&gt;
     &lt;dskpp:SupportedKeyTypes&gt;
       &lt;dskpp:Algorithm&gt;http://www.ietf.org/keyprov/pskc#hotp&lt;/dskpp:Algorithm&gt;
       &lt;dskpp:Algorithm&gt;http://www.rsa.com/rsalabs/otps/schemas/2005/09/
         otps-wst#SecurID-AES&lt;/dskpp:Algorithm&gt;
     &lt;/dskpp:SupportedKeyTypes&gt;
     &lt;dskpp:SupportedEncryptionAlgorithms&gt;
       &lt;dskpp:Algorithm&gt;http://www.w3.org/2001/05/xmlenc#rsa_1_5
       &lt;/dskpp:Algorithm&gt;
     &lt;dskpp:Algorithm&gt;http://www.ietf.org/keyprov/dskpp#dskpp-prf-aes-128
       &lt;/dskpp:Algorithm&gt;
     &lt;/dskpp:SupportedEncryptionAlgorithms&gt;
     &lt;dskpp:SupportedMacAlgorithms&gt;
       &lt;dskpp:Algorithm&gt;http://www.ietf.org/keyprov/dskpp#dskpp-prf-aes-128
         &lt;/dskpp:Algorithm&gt;
     &lt;/dskpp:SupportedMacAlgorithms&gt;
     &lt;dskpp:SupportedProtocolVariants&gt;&lt;dskpp:FourPass/&gt;
       &lt;/dskpp:SupportedProtocolVariants&gt;
     &lt;dskpp:SupportedKeyPackages&gt;
       &lt;dskpp:KeyPackageFormat&gt;
         urn:ietf:params:xml:ns:keyprov:pskc#KeyContainer
       &lt;/dskpp:KeyPackageFormat&gt;
     &lt;/dskpp:SupportedKeyPackages&gt;
   &lt;/dskpp:KeyProvClientHello&gt;</pre></div>
<p>
</p>
<a name="anchor75"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.B.2.3"></a><h3>B.2.3.&nbsp;
&lt;KeyProvServerHello&gt; Without a Preceding Trigger</h3>

<p>
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>   &lt;?xml version="1.0" encoding="UTF-8"?&gt;
    &lt;dskpp:KeyProvServerHello Version="1.0" SessionID="4114" Status="Continue"
      xmlns:dskpp="urn:ietf:params:xml:ns:keyprov:dskpp"
      xmlns:pskc="urn:ietf:params:xml:ns:keyprov:pskc"
      xmlns:ds="http://www.w3.org/2000/09/xmldsig#"&gt;
      &lt;dskpp:KeyType&gt;
        http://www.rsa.com/rsalabs/otps/schemas/2005/09/otps-wst#SecurID-AES
      &lt;/dskpp:KeyType&gt;
      &lt;dskpp:EncryptionAlgorithm&gt;
        http://www.ietf.org/keyprov/dskpp#dskpp-prf-aes-128
      &lt;/dskpp:EncryptionAlgorithm&gt;
      &lt;dskpp:MacAlgorithm&gt;
        http://www.ietf.org/keyprov/dskpp#dskpp-prf-aes-128
      &lt;/dskpp:MacAlgorithm&gt;
      &lt;dskpp:EncryptionKey&gt;
        &lt;ds:KeyName&gt;KEY-1&lt;/ds:KeyName&gt;
      &lt;/dskpp:EncryptionKey&gt;
      &lt;dskpp:KeyPackageFormat&gt;
        urn:ietf:params:xml:ns:keyprov:pskc#KeyContainer
      &lt;/dskpp:KeyPackageFormat&gt;
      &lt;dskpp:Payload&gt;
        &lt;dskpp:Nonce&gt;qw2ewasde312asder394jw==&lt;/dskpp:Nonce&gt;
      &lt;/dskpp:Payload&gt;
    &lt;/dskpp:KeyProvServerHello&gt;</pre></div>
<p>
</p>
<a name="anchor76"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.B.2.4"></a><h3>B.2.4.&nbsp;
&lt;KeyProvServerHello&gt; Assuming Key Renewal</h3>

<p>
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>   &lt;?xml version="1.0" encoding="UTF-8"?&gt;
   &lt;dskpp:KeyProvServerHello Version="1.0" SessionID="4114"
     Status="Continue"
     xmlns:dskpp="urn:ietf:params:xml:ns:keyprov:dskpp"
     xmlns:pskc="urn:ietf:params:xml:ns:keyprov:pskc"
     xmlns:ds="http://www.w3.org/2000/09/xmldsig#"&gt;
     &lt;dskpp:KeyType&gt;
       urn:ietf:params:xml:schema:keyprov:otpalg#SecurID-AES
     &lt;/dskpp:KeyType&gt;
     &lt;dskpp:EncryptionAlgorithm&gt;
       http://www.ietf.org/keyprov/dskpp#dskpp-prf-aes-128
     &lt;/dskpp:EncryptionAlgorithm&gt;
     &lt;dskpp:MacAlgorithm&gt;
       http://www.ietf.org/keyprov/dskpp#dskpp-prf-aes-128
     &lt;/dskpp:MacAlgorithm&gt;
     &lt;dskpp:EncryptionKey&gt;
       &lt;ds:KeyName&gt;KEY-1&lt;/ds:KeyName&gt;
     &lt;/dskpp:EncryptionKey&gt;
     &lt;dskpp:KeyPackageFormat&gt;
       urn:ietf:params:xml:ns:keyprov:pskc#KeyContainer
     &lt;/dskpp:KeyPackageFormat&gt;
     &lt;dskpp:Payload&gt;
       &lt;dskpp:Nonce&gt;qw2ewasde312asder394jw==&lt;/dskpp:Nonce&gt;
     &lt;/dskpp:Payload&gt;
     &lt;dskpp:Mac
       MacAlgorithm="http://www.ietf.org/keyprov/dskpp#dskpp-prf-aes-128"&gt;
       cXcycmFuZG9tMzEyYXNkZXIzOTRqdw==
     &lt;/dskpp:Mac&gt;
   &lt;/dskpp:KeyProvServerHello&gt;</pre></div>
<p>
</p>
<a name="anchor77"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.B.2.5"></a><h3>B.2.5.&nbsp;
&lt;KeyProvClientNonce&gt; Using Default Encryption</h3>

<p>This message contains the nonce chosen by the cryptographic
          module, R_C, encrypted by the specified encryption key and
          encryption algorithm.
</p>
<p>
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;dskpp:KeyProvClientNonce Version="1.0" SessionID="4114"
  xmlns:dskpp="urn:ietf:params:xml:ns:keyprov:dskpp"&gt;
  &lt;dskpp:EncryptedNonce&gt;VXENc+Um/9/NvmYKiHDLaErK0gk=
    &lt;/dskpp:EncryptedNonce&gt;
  &lt;dskpp:AuthenticationData&gt;
    &lt;dskpp:ClientID&gt;31300257&lt;/dskpp:ClientID&gt;
    &lt;dskpp:AuthenticationCodeMac&gt;
      &lt;dskpp:IterationCount&gt;512&lt;/dskpp:IterationCount&gt;
      &lt;dskpp:Mac&gt;4bRJf9xXd3KchKoTenHJiw==&lt;/dskpp:Mac&gt;
    &lt;/dskpp:AuthenticationCodeMac&gt;
  &lt;/dskpp:AuthenticationData&gt;
&lt;/dskpp:KeyProvClientNonce&gt;</pre></div>
<p>
</p>
<a name="anchor78"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.B.2.6"></a><h3>B.2.6.&nbsp;
&lt;KeyProvServerFinished&gt; Using Default Encryption</h3>

<p>
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>   &lt;?xml version="1.0" encoding="UTF-8"?&gt;
   &lt;dskpp:KeyProvServerFinished Version="1.0" SessionID="4114" Status="Success"
     xmlns:dskpp="urn:ietf:params:xml:ns:keyprov:dskpp"
     xmlns:pskc="urn:ietf:params:xml:ns:keyprov:pskc"&gt;
     &lt;dskpp:KeyPackage&gt;
       &lt;KeyContainer Version="1.0" xmlns="urn:ietf:params:xml:ns:keyprov:pskc"&gt;
         &lt;KeyPackage&gt;
           &lt;DeviceInfo&gt;
            &lt;Manufacturer&gt;Manufacturer&lt;/Manufacturer&gt;
            &lt;SerialNo&gt;987654321&lt;/SerialNo&gt;
        &lt;/DeviceInfo&gt;
        &lt;CryptoModuleInfo&gt;
            &lt;Id&gt;CM_ID_001&lt;/Id&gt;
        &lt;/CryptoModuleInfo&gt;
        &lt;Key Id="12345678"
            Algorithm="urn:ietf:params:xml:ns:keyprov:pskc#totp"&gt;
            &lt;Issuer&gt;Issuer&lt;/Issuer&gt;
            &lt;AlgorithmParameters&gt;
                &lt;ResponseFormat Length="8" Encoding="DECIMAL"/&gt;
            &lt;/AlgorithmParameters&gt;
            &lt;Data&gt;
               &lt;Time&gt;
                 &lt;PlainValue&gt;0&lt;/PlainValue&gt;
               &lt;/Time&gt;
            &lt;/Data&gt;
            &lt;Policy&gt;
                &lt;PINPolicy MinLength="4" MaxLength="4"
                    PINKeyId="123456781" PINEncoding="DECIMAL"
                    PINUsageMode="Local"/&gt;
                &lt;KeyUsage&gt;OTP&lt;/KeyUsage&gt;
            &lt;/Policy&gt;
        &lt;/Key&gt;
       &lt;/KeyPackage&gt;
      &lt;/KeyContainer&gt;
     &lt;/dskpp:KeyPackage&gt;
     &lt;dskpp:Mac
       MacAlgorithm="http://www.ietf.org/keyprov/dskpp#dskpp-prf-aes-128"&gt;
       miidfasde312asder394jw==
     &lt;/dskpp:Mac&gt;
   &lt;/dskpp:KeyProvServerFinished&gt;</pre></div>
<p>
</p>
<a name="anchor79"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.B.3"></a><h3>B.3.&nbsp;
Two-Pass Protocol</h3>

<a name="Example-TwoPass-1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.B.3.1"></a><h3>B.3.1.&nbsp;
Example Using the Key Transport Method</h3>

<p>The client indicates support for all the Key Transport, Key Wrap,
          and Passphrase-Based Key Wrap key protection methods:
</p>
<p>
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>   &lt;?xml version="1.0" encoding="UTF-8"?&gt;
   &lt;dskpp:KeyProvClientHello Version="1.0"
     xmlns:dskpp="urn:ietf:params:xml:ns:keyprov:dskpp"
     xmlns:pskc="urn:ietf:params:xml:ns:keyprov:pskc"
     xmlns:ds="http://www.w3.org/2000/09/xmldsig#"&gt;
     &lt;dskpp:DeviceIdentifierData&gt;
       &lt;dskpp:DeviceId&gt;
         &lt;pskc:Manufacturer&gt;TokenVendorAcme&lt;/pskc:Manufacturer&gt;
         &lt;pskc:SerialNo&gt;987654321&lt;/pskc:SerialNo&gt;
         &lt;pskc:Model&gt;U2&lt;/pskc:Model&gt;
       &lt;/dskpp:DeviceId&gt;
     &lt;/dskpp:DeviceIdentifierData&gt;
     &lt;dskpp:ClientNonce&gt;xwQzwEl0CjPAiQeDxwRJdQ==&lt;/dskpp:ClientNonce&gt;
     &lt;dskpp:SupportedKeyTypes&gt;
       &lt;dskpp:Algorithm&gt;http://www.ietf.org/keyprov/pskc#hotp
         &lt;/dskpp:Algorithm&gt;
       &lt;dskpp:Algorithm&gt;
         http://www.rsa.com/rsalabs/otps/schemas/2005/09/otps-wst#SecurID-AES
       &lt;/dskpp:Algorithm&gt;
     &lt;/dskpp:SupportedKeyTypes&gt;
     &lt;dskpp:SupportedEncryptionAlgorithms&gt;
       &lt;dskpp:Algorithm&gt;http://www.w3.org/2001/05/xmlenc#rsa_1_5
         &lt;/dskpp:Algorithm&gt;
       &lt;dskpp:Algorithm&gt;http://www.w3.org/2001/04/xmlenc#kw-aes128
         &lt;/dskpp:Algorithm&gt;
       &lt;dskpp:Algorithm&gt;http://www.ietf.org/keyprov/dskpp#dskpp-prf-aes-128
         &lt;/dskpp:Algorithm&gt;
     &lt;/dskpp:SupportedEncryptionAlgorithms&gt;
     &lt;dskpp:SupportedMacAlgorithms&gt;
       &lt;dskpp:Algorithm&gt;http://www.ietf.org/keyprov/dskpp#dskpp-prf-aes-128
         &lt;/dskpp:Algorithm&gt;
     &lt;/dskpp:SupportedMacAlgorithms&gt;
     &lt;dskpp:SupportedProtocolVariants&gt;
       &lt;dskpp:TwoPass&gt;
         &lt;dskpp:SupportedKeyProtectionMethod&gt;
           urn:ietf:params:xml:schema:keyprov:dskpp#transport
         &lt;/dskpp:SupportedKeyProtectionMethod&gt;
         &lt;dskpp:Payload&gt;
            &lt;ds:KeyInfo xsi:type="ds:KeyInfoType"&gt;
                &lt;ds:X509Data&gt;
                    &lt;ds:X509Certificate&gt;
MIIB5zCCAVCgAwIBAgIESZp/vDANBgkqhkiG9w0BAQUFADA4M
Q0wCwYDVQQKEwRJRVRGMRMwEQYDVQQLEwpLZXlQcm92IFdHMRIwEAYDVQQDEwlQU0tDIF
Rlc3QwHhcNMDkwMjE3MDkxMzMyWhcNMTEwMjE3MDkxMzMyWjA4MQ0wCwYDVQQKEwRJRVR
GMRMwEQYDVQQLEwpLZXlQcm92IFdHMRIwEAYDVQQDEwlQU0tDIFRlc3QwgZ8wDQYJKoZI
hvcNAQEBBQADgY0AMIGJAoGBALCWLDa2ItYJ6su80hd1gL4cggQYdyyKK17btt/aS6Q/e
DsKjsPyFIODsxeKVV/uA3wLT4jQJM5euKJXkDajzGGOy92+ypfzTX4zDJMkh61SZwlHNJ
xBKilAM5aW7C+BQ0RvCxvdYtzx2LTdB+X/KMEBA7uIYxLfXH2Mnub3WIh1AgMBAAEwDQY
JKoZIhvcNAQEFBQADgYEAe875m84sYUJ8qPeZ+NG7REgTvlHTmoCdoByU0LBBLotUKuqf
rnRuXJRMeZXaaEGmzY1kLonVjQGzjAkU4dJ+RPmiDlYuHLZS41Pg6VMwY+03lhk6I5A/w
4rnqdkmwZX/NgXg06alnc2pBsXWhL4O7nk0S2ZrLMsQZ6HcsXgdmHo=
&lt;/ds:X509Certificate&gt;
                &lt;/ds:X509Data&gt;
            &lt;/ds:KeyInfo&gt;
         &lt;/dskpp:Payload&gt;
       &lt;/dskpp:TwoPass&gt;
     &lt;/dskpp:SupportedProtocolVariants&gt;
     &lt;dskpp:SupportedKeyPackages&gt;
       &lt;dskpp:KeyPackageFormat&gt;
         urn:ietf:params:xml:ns:keyprov:pskc#KeyContainer
       &lt;/dskpp:KeyPackageFormat&gt;
     &lt;/dskpp:SupportedKeyPackages&gt;
     &lt;dskpp:AuthenticationData&gt;
       &lt;dskpp:ClientID&gt;31300257&lt;/dskpp:ClientID&gt;
       &lt;dskpp:AuthenticationCodeMac&gt;
         &lt;dskpp:IterationCount&gt;512&lt;/dskpp:IterationCount&gt;
         &lt;dskpp:Mac&gt;4bRJf9xXd3KchKoTenHJiw==&lt;/dskpp:Mac&gt;
       &lt;/dskpp:AuthenticationCodeMac&gt;
     &lt;/dskpp:AuthenticationData&gt;
   &lt;/dskpp:KeyProvClientHello&gt;</pre></div>
<p>
</p>
<p>In this example, the server responds to the previous request by
          returning a key package in which the provisioning key was encrypted
          using the Key Transport key protection method.
</p>
<p>
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>   &lt;?xml version="1.0" encoding="UTF-8"?&gt;
   &lt;dskpp:KeyProvServerFinished Version="1.0" SessionID="4114"
     Status="Success"
     xmlns:dskpp="urn:ietf:params:xml:ns:keyprov:dskpp"
     xmlns:pskc="urn:ietf:params:xml:ns:keyprov:pskc"
     xmlns:ds="http://www.w3.org/2000/09/xmldsig#"
     xmlns:xenc="http://www.w3.org/2001/04/xmlenc#"&gt;
     &lt;dskpp:KeyPackage&gt;
       &lt;dskpp:ServerID&gt;https://www.somedskppservice.com/&lt;/dskpp:ServerID&gt;
       &lt;dskpp:KeyProtectionMethod&gt;
           urn:ietf:params:xml:schema:keyprov:dskpp#transport
       &lt;/dskpp:KeyProtectionMethod&gt;
       &lt;KeyContainer Version="1.0"
           xmlns="urn:ietf:params:xml:ns:keyprov:pskc"&gt;
         &lt;EncryptionKey&gt;
            &lt;ds:X509Data&gt;
&lt;ds:X509Certificate&gt;MIIB5zCCAVCgAwIBAgIESZp/vDANBgkqhkiG9w0BAQUFADA4M
Q0wCwYDVQQKEwRJRVRGMRMwEQYDVQQLEwpLZXlQcm92IFdHMRIwEAYDVQQDEwlQU0tDIF
Rlc3QwHhcNMDkwMjE3MDkxMzMyWhcNMTEwMjE3MDkxMzMyWjA4MQ0wCwYDVQQKEwRJRVR
GMRMwEQYDVQQLEwpLZXlQcm92IFdHMRIwEAYDVQQDEwlQU0tDIFRlc3QwgZ8wDQYJKoZI
hvcNAQEBBQADgY0AMIGJAoGBALCWLDa2ItYJ6su80hd1gL4cggQYdyyKK17btt/aS6Q/e
DsKjsPyFIODsxeKVV/uA3wLT4jQJM5euKJXkDajzGGOy92+ypfzTX4zDJMkh61SZwlHNJ
xBKilAM5aW7C+BQ0RvCxvdYtzx2LTdB+X/KMEBA7uIYxLfXH2Mnub3WIh1AgMBAAEwDQY
JKoZIhvcNAQEFBQADgYEAe875m84sYUJ8qPeZ+NG7REgTvlHTmoCdoByU0LBBLotUKuqf
rnRuXJRMeZXaaEGmzY1kLonVjQGzjAkU4dJ+RPmiDlYuHLZS41Pg6VMwY+03lhk6I5A/w
4rnqdkmwZX/NgXg06alnc2pBsXWhL4O7nk0S2ZrLMsQZ6HcsXgdmHo=
&lt;/ds:X509Certificate&gt;
            &lt;/ds:X509Data&gt;
         &lt;/EncryptionKey&gt;
         &lt;KeyPackage&gt;
            &lt;DeviceInfo&gt;
                &lt;Manufacturer&gt;TokenVendorAcme&lt;/Manufacturer&gt;
                &lt;SerialNo&gt;987654321&lt;/SerialNo&gt;
            &lt;/DeviceInfo&gt;
            &lt;Key
            Id="MBK000000001"
            Algorithm="urn:ietf:params:xml:ns:keyprov:pskc#hotp"&gt;
                &lt;Issuer&gt;Example-Issuer&lt;/Issuer&gt;
                &lt;AlgorithmParameters&gt;
                    &lt;ResponseFormat Length="6" Encoding="DECIMAL"/&gt;
                &lt;/AlgorithmParameters&gt;
                &lt;Data&gt;
                    &lt;Secret&gt;
                        &lt;EncryptedValue&gt;
                            &lt;xenc:EncryptionMethod
             Algorithm="http://www.w3.org/2001/04/xmlenc#rsa_1_5"/&gt;
                            &lt;xenc:CipherData&gt;
&lt;xenc:CipherValue&gt;hJ+fvpoMPMO9BYpK2rdyQYGIxiATYHTHC7e/sPLKYo5/r1v+4
xTYG3gJolCWuVMydJ7Ta0GaiBPHcWa8ctCVYmHKfSz5fdeV5nqbZApe6dofTqhRwZK6
Yx4ufevi91cjN2vBpSxYafvN3c3+xIgk0EnTV4iVPRCR0rBwyfFrPc4=
&lt;/xenc:CipherValue&gt;
                            &lt;/xenc:CipherData&gt;
                        &lt;/EncryptedValue&gt;
                    &lt;/Secret&gt;
                    &lt;Counter&gt;
                        &lt;PlainValue&gt;0&lt;/PlainValue&gt;
                    &lt;/Counter&gt;
                &lt;/Data&gt;
            &lt;/Key&gt;
         &lt;/KeyPackage&gt;
       &lt;/KeyContainer&gt;
     &lt;/dskpp:KeyPackage&gt;
     &lt;dskpp:Mac
       MacAlgorithm="http://www.ietf.org/keyprov/dskpp#dskpp-prf-aes-128"&gt;
       miidfasde312asder394jw==
     &lt;/dskpp:Mac&gt;
     &lt;dskpp:AuthenticationData&gt;
       &lt;dskpp:Mac&gt;4bRJf9xXd3KchKoTenHJiw==&lt;/dskpp:Mac&gt;
     &lt;/dskpp:AuthenticationData&gt;
   &lt;/dskpp:KeyProvServerFinished&gt;</pre></div>
<p>
</p>
<a name="anchor80"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.B.3.2"></a><h3>B.3.2.&nbsp;
Example Using the Key Wrap Method</h3>

<p>The client sends a request that specifies a shared key to protect
          the K_TOKEN, and the server responds using the Key Wrap key
          protection method. Authentication data in this example is based on
          an authentication code rather than a device certificate.
</p>
<p>
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>   &lt;?xml version="1.0" encoding="UTF-8"?&gt;
   &lt;dskpp:KeyProvClientHello Version="1.0"
     xmlns:dskpp="urn:ietf:params:xml:ns:keyprov:dskpp"
     xmlns:pskc="urn:ietf:params:xml:ns:keyprov:pskc"
     xmlns:ds="http://www.w3.org/2000/09/xmldsig#"
     xmlns:pkcs-5=
       "http://www.rsasecurity.com/rsalabs/pkcs/schemas/pkcs-5v2-0#"&gt;
     &lt;dskpp:DeviceIdentifierData&gt;
       &lt;dskpp:DeviceId&gt;
         &lt;pskc:Manufacturer&gt;TokenVendorAcme&lt;/pskc:Manufacturer&gt;
         &lt;pskc:SerialNo&gt;987654321&lt;/pskc:SerialNo&gt;
         &lt;pskc:Model&gt;U2&lt;/pskc:Model&gt;
       &lt;/dskpp:DeviceId&gt;
     &lt;/dskpp:DeviceIdentifierData&gt;
     &lt;dskpp:ClientNonce&gt;xwQzwEl0CjPAiQeDxwRJdQ==&lt;/dskpp:ClientNonce&gt;
     &lt;dskpp:SupportedKeyTypes&gt;
       &lt;dskpp:Algorithm&gt;http://www.ietf.org/keyprov/pskc#hotp
         &lt;/dskpp:Algorithm&gt;
       &lt;dskpp:Algorithm&gt;http://www.rsa.com/rsalabs/otps/schemas/2005/09/
         otps-wst#SecurID-AES&lt;/dskpp:Algorithm&gt;
     &lt;/dskpp:SupportedKeyTypes&gt;
     &lt;dskpp:SupportedEncryptionAlgorithms&gt;
       &lt;dskpp:Algorithm&gt;http://www.w3.org/2001/05/xmlenc#rsa_1_5
         &lt;/dskpp:Algorithm&gt;
       &lt;dskpp:Algorithm&gt;http://www.w3.org/2001/04/xmlenc#kw-aes128
         &lt;/dskpp:Algorithm&gt;
       &lt;dskpp:Algorithm&gt;http://www.rsasecurity.com/rsalabs/pkcs/schemas/
         pkcs-5#pbes2&lt;/dskpp:Algorithm&gt;
       &lt;dskpp:Algorithm&gt;http://www.ietf.org/keyprov/dskpp#dskpp-prf-aes-128
         &lt;/dskpp:Algorithm&gt;
     &lt;/dskpp:SupportedEncryptionAlgorithms&gt;
     &lt;dskpp:SupportedMacAlgorithms&gt;
       &lt;dskpp:Algorithm&gt;http://www.ietf.org/keyprov/dskpp#dskpp-prf-aes-128
         &lt;/dskpp:Algorithm&gt;
     &lt;/dskpp:SupportedMacAlgorithms&gt;
     &lt;dskpp:SupportedProtocolVariants&gt;
       &lt;dskpp:TwoPass&gt;
         &lt;dskpp:SupportedKeyProtectionMethod&gt;
           urn:ietf:params:xml:schema:keyprov:dskpp#wrap
         &lt;/dskpp:SupportedKeyProtectionMethod&gt;
         &lt;dskpp:Payload&gt;
           &lt;ds:KeyInfo xsi:type="ds:KeyInfoType"&gt;
             &lt;ds:KeyName&gt;Pre-shared-key&lt;/ds:KeyName&gt;
           &lt;/ds:KeyInfo&gt;
         &lt;/dskpp:Payload&gt;
       &lt;/dskpp:TwoPass&gt;
     &lt;/dskpp:SupportedProtocolVariants&gt;
     &lt;dskpp:SupportedKeyPackages&gt;
       &lt;dskpp:KeyPackageFormat&gt;
         urn:ietf:params:xml:ns:keyprov:pskc#KeyContainer
       &lt;/dskpp:KeyPackageFormat&gt;
     &lt;/dskpp:SupportedKeyPackages&gt;
     &lt;dskpp:AuthenticationData&gt;
       &lt;dskpp:ClientID&gt;31300257&lt;/dskpp:ClientID&gt;
       &lt;dskpp:AuthenticationCodeMac&gt;
         &lt;dskpp:IterationCount&gt;512&lt;/dskpp:IterationCount&gt;
         &lt;dskpp:Mac&gt;4bRJf9xXd3KchKoTenHJiw==&lt;/dskpp:Mac&gt;
       &lt;/dskpp:AuthenticationCodeMac&gt;
     &lt;/dskpp:AuthenticationData&gt;
   &lt;/dskpp:KeyProvClientHello&gt;</pre></div>
<p>
</p>
<p>In this example, the server responds to the previous request by
          returning a key package in which the provisioning key was encrypted
          using the Key Wrap key protection method.
</p>
<p>
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>   &lt;?xml version="1.0" encoding="UTF-8"?&gt;
   &lt;dskpp:KeyProvServerFinished Version="1.0" Status="Success"
     xmlns:dskpp="urn:ietf:params:xml:ns:keyprov:dskpp"
     xmlns:pskc="urn:ietf:params:xml:ns:keyprov:pskc"
     xmlns:ds="http://www.w3.org/2000/09/xmldsig#"
     xmlns:xenc="http://www.w3.org/2001/04/xmlenc#"&gt;
     &lt;dskpp:KeyPackage&gt;
       &lt;dskpp:ServerID&gt;https://www.somedskppservice.com/&lt;/dskpp:ServerID&gt;
       &lt;dskpp:KeyProtectionMethod&gt;
         urn:ietf:params:xml:schema:keyprov:dskpp#wrap
       &lt;/dskpp:KeyProtectionMethod&gt;
       &lt;KeyContainer Version="1.0" xmlns="urn:ietf:params:xml:ns:keyprov:pskc"&gt;
        &lt;EncryptionKey&gt;
            &lt;ds:KeyName&gt;Pre-shared-key&lt;/ds:KeyName&gt;
        &lt;/EncryptionKey&gt;
        &lt;MACMethod Algorithm="http://www.w3.org/2000/09/xmldsig#hmac-sha1"&gt;
            &lt;MACKey&gt;
                &lt;xenc:EncryptionMethod
            Algorithm="http://www.w3.org/2001/04/xmlenc#aes128-cbc"/&gt;
                &lt;xenc:CipherData&gt;
                    &lt;xenc:CipherValue&gt;
                R8+5I6m74doa0nRhaPejbt3elq9hLPGvxHgXVlYpbgA=
                    &lt;/xenc:CipherValue&gt;
                &lt;/xenc:CipherData&gt;
            &lt;/MACKey&gt;
        &lt;/MACMethod&gt;
        &lt;KeyPackage&gt;
            &lt;DeviceInfo&gt;
                &lt;Manufacturer&gt;Manufacturer&lt;/Manufacturer&gt;
                &lt;SerialNo&gt;987654321&lt;/SerialNo&gt;
            &lt;/DeviceInfo&gt;
            &lt;CryptoModuleInfo&gt;
                &lt;Id&gt;CM_ID_001&lt;/Id&gt;
            &lt;/CryptoModuleInfo&gt;
            &lt;Key Id="12345678"
            Algorithm="urn:ietf:params:xml:ns:keyprov:pskc#hotp"&gt;
                &lt;Issuer&gt;Issuer&lt;/Issuer&gt;
                &lt;AlgorithmParameters&gt;
                    &lt;ResponseFormat Length="8" Encoding="DECIMAL"/&gt;
                &lt;/AlgorithmParameters&gt;
                &lt;Data&gt;
                    &lt;Secret&gt;
                        &lt;EncryptedValue&gt;
                            &lt;xenc:EncryptionMethod
            Algorithm="http://www.w3.org/2001/04/xmlenc#aes128-cbc"/&gt;
                            &lt;xenc:CipherData&gt;
                                &lt;xenc:CipherValue&gt;
                          pgznhXdDh4LJ2G3mOY2RL7UA47yizMlXX3ADDcZd8Vs=
                                &lt;/xenc:CipherValue&gt;
                            &lt;/xenc:CipherData&gt;
                        &lt;/EncryptedValue&gt;
                        &lt;ValueMAC&gt;ooo0Swn6s/myD4o05FCfBHN0560=&lt;/ValueMAC&gt;
                    &lt;/Secret&gt;
                    &lt;Counter&gt;
                        &lt;PlainValue&gt;0&lt;/PlainValue&gt;
                    &lt;/Counter&gt;
                &lt;/Data&gt;
            &lt;/Key&gt;
        &lt;/KeyPackage&gt;
      &lt;/KeyContainer&gt;
     &lt;/dskpp:KeyPackage&gt;
     &lt;dskpp:Mac
       MacAlgorithm="http://www.ietf.org/keyprov/dskpp#dskpp-prf-aes-128"&gt;
       miidfasde312asder394jw==
     &lt;/dskpp:Mac&gt;
     &lt;dskpp:AuthenticationData&gt;
       &lt;dskpp:Mac&gt;4bRJf9xXd3KchKoTenHJiw==&lt;/dskpp:Mac&gt;
     &lt;/dskpp:AuthenticationData&gt;
   &lt;/dskpp:KeyProvServerFinished&gt;</pre></div>
<p>
</p>
<a name="anchor81"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.B.3.3"></a><h3>B.3.3.&nbsp;
Example Using the Passphrase-Based Key Wrap Method</h3>

<p>The client sends a request similar to that in <a class='info' href='#Example-TwoPass-1'>Appendix&nbsp;B.3.1<span> (</span><span class='info'>Example Using the Key Transport Method</span><span>)</span></a> with authentication data based on
          an authentication code, and the server responds using the
          Passphrase-Based Key Wrap method to encrypt the provisioning key
          (note that the encryption is derived from the password component of
          the authentication code). The authentication data is set in clear
          text when it is sent over a secure transport channel such as
          TLS.
</p>
<p>
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>   &lt;?xml version="1.0" encoding="UTF-8"?&gt;
   &lt;dskpp:KeyProvClientHello Version="1.0"
     xmlns:dskpp="urn:ietf:params:xml:ns:keyprov:dskpp"
     xmlns:pskc="urn:ietf:params:xml:ns:keyprov:pskc"
     xmlns:ds="http://www.w3.org/2000/09/xmldsig#"
     xmlns:pkcs-5=
       "http://www.rsasecurity.com/rsalabs/pkcs/schemas/pkcs-5v2-0#"&gt;
     &lt;dskpp:DeviceIdentifierData&gt;
       &lt;dskpp:DeviceId&gt;
         &lt;pskc:Manufacturer&gt;TokenVendorAcme&lt;/pskc:Manufacturer&gt;
         &lt;pskc:SerialNo&gt;987654321&lt;/pskc:SerialNo&gt;
         &lt;pskc:Model&gt;U2&lt;/pskc:Model&gt;
       &lt;/dskpp:DeviceId&gt;
     &lt;/dskpp:DeviceIdentifierData&gt;
     &lt;dskpp:ClientNonce&gt;xwQzwEl0CjPAiQeDxwRJdQ==&lt;/dskpp:ClientNonce&gt;
     &lt;dskpp:SupportedKeyTypes&gt;
       &lt;dskpp:Algorithm&gt;http://www.ietf.org/keyprov/pskc#hotp
         &lt;/dskpp:Algorithm&gt;
       &lt;dskpp:Algorithm&gt;
         http://www.rsa.com/rsalabs/otps/schemas/2005/09/otps-wst#SecurID-AES
       &lt;/dskpp:Algorithm&gt;
     &lt;/dskpp:SupportedKeyTypes&gt;
     &lt;dskpp:SupportedEncryptionAlgorithms&gt;
       &lt;dskpp:Algorithm&gt;http://www.w3.org/2001/05/xmlenc#rsa_1_5
         &lt;/dskpp:Algorithm&gt;
       &lt;dskpp:Algorithm&gt;http://www.w3.org/2001/04/xmlenc#kw-aes128
         &lt;/dskpp:Algorithm&gt;
       &lt;dskpp:Algorithm&gt;
         http://www.rsasecurity.com/rsalabs/pkcs/schemas/pkcs-5#pbes2
       &lt;/dskpp:Algorithm&gt;
       &lt;dskpp:Algorithm&gt;
         http://www.ietf.org/keyprov/dskpp#dskpp-prf-aes-128
       &lt;/dskpp:Algorithm&gt;
     &lt;/dskpp:SupportedEncryptionAlgorithms&gt;
     &lt;dskpp:SupportedMacAlgorithms&gt;
       &lt;dskpp:Algorithm&gt;
         http://www.ietf.org/keyprov/dskpp#dskpp-prf-aes-128
       &lt;/dskpp:Algorithm&gt;
     &lt;/dskpp:SupportedMacAlgorithms&gt;
     &lt;dskpp:SupportedProtocolVariants&gt;
       &lt;dskpp:TwoPass&gt;
         &lt;dskpp:SupportedKeyProtectionMethod&gt;
           urn:ietf:params:xml:schema:keyprov:dskpp#wrap
         &lt;/dskpp:SupportedKeyProtectionMethod&gt;
         &lt;dskpp:Payload&gt;
           &lt;ds:KeyInfo xsi:type="ds:KeyInfoType"&gt;
             &lt;ds:KeyName&gt;Key_001&lt;/ds:KeyName&gt;
           &lt;/ds:KeyInfo&gt;
         &lt;/dskpp:Payload&gt;
         &lt;dskpp:SupportedKeyProtectionMethod&gt;
           urn:ietf:params:xml:schema:keyprov:dskpp#passphrase-wrap
         &lt;/dskpp:SupportedKeyProtectionMethod&gt;
       &lt;/dskpp:TwoPass&gt;
     &lt;/dskpp:SupportedProtocolVariants&gt;
     &lt;dskpp:SupportedKeyPackages&gt;
       &lt;dskpp:KeyPackageFormat&gt;
         urn:ietf:params:xml:ns:keyprov:pskc#KeyContainer
       &lt;/dskpp:KeyPackageFormat&gt;
     &lt;/dskpp:SupportedKeyPackages&gt;
     &lt;dskpp:AuthenticationData&gt;
       &lt;dskpp:ClientID&gt;31300257&lt;/dskpp:ClientID&gt;
       &lt;dskpp:AuthenticationCodeMac&gt;
         &lt;dskpp:IterationCount&gt;512&lt;/dskpp:IterationCount&gt;
         &lt;dskpp:Mac&gt;4bRJf9xXd3KchKoTenHJiw==&lt;/dskpp:Mac&gt;
       &lt;/dskpp:AuthenticationCodeMac&gt;
     &lt;/dskpp:AuthenticationData&gt;
   &lt;/dskpp:KeyProvClientHello&gt;</pre></div>
<p>
</p>
<p>In this example, the server responds to the previous request by
          returning a key package in which the provisioning key was encrypted
          using the Passphrase-Based Key Wrap key protection method.
</p>
<p>
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;dskpp:KeyProvServerFinished Version="1.0" SessionID="4114"
Status="Success"
xmlns:dskpp="urn:ietf:params:xml:ns:keyprov:dskpp"
xmlns:pskc="urn:ietf:params:xml:ns:keyprov:pskc"
xmlns:dkey="http://www.w3.org/2009/xmlsec-derivedkey#"
xmlns:pkcs5=
  "http://www.rsasecurity.com/rsalabs/pkcs/schemas/pkcs-5v2-0#"
xmlns:ds="http://www.w3.org/2000/09/xmldsig#"
xmlns:xenc="http://www.w3.org/2001/04/xmlenc#"&gt;
	&lt;dskpp:KeyPackage&gt;
		&lt;dskpp:ServerID&gt;https://www.somedskppservice.com/
		&lt;/dskpp:ServerID&gt;
		&lt;dskpp:KeyProtectionMethod&gt;
          urn:ietf:params:xml:schema:keyprov:protocol#passphrase-wrap
       &lt;/dskpp:KeyProtectionMethod&gt;
		&lt;dskpp:KeyContainer Version="1.0"&gt;
          &lt;pskc:EncryptionKey&gt;
              &lt;dkey:DerivedKey&gt;
                  &lt;dkey:KeyDerivationMethod Algorithm=
 "http://www.rsasecurity.com/rsalabs/pkcs/schemas/pkcs-5v2-0#pbkdf2"&gt;
                      &lt;pkcs5:PBKDF2-params&gt;
                          &lt;Salt&gt;
                              &lt;Specified&gt;Ej7/PEpyEpw=&lt;/Specified&gt;
                          &lt;/Salt&gt;
                          &lt;IterationCount&gt;1000&lt;/IterationCount&gt;
                          &lt;KeyLength&gt;16&lt;/KeyLength&gt;
                          &lt;PRF/&gt;
                      &lt;/pkcs5:PBKDF2-params&gt;
                  &lt;/dkey:KeyDerivationMethod&gt;
                  &lt;xenc:ReferenceList&gt;
                      &lt;xenc:DataReference URI="#ED"/&gt;
                  &lt;/xenc:ReferenceList&gt;
                  &lt;dkey:MasterKeyName&gt;My Password 1&lt;/dkey:MasterKeyName&gt;
              &lt;/dkey:DerivedKey&gt;
          &lt;/pskc:EncryptionKey&gt;
          &lt;pskc:MACMethod
        Algorithm="http://www.w3.org/2000/09/xmldsig#hmac-sha1"&gt;
              &lt;pskc:MACKey&gt;
                  &lt;xenc:EncryptionMethod
            Algorithm="http://www.w3.org/2001/04/xmlenc#aes128-cbc"/&gt;
                  &lt;xenc:CipherData&gt;
                      &lt;xenc:CipherValue&gt;
2GTTnLwM3I4e5IO5FkufoNhk05y8DNyOHuSDuRZLn6DhIjoTY/dX4SkUAbQ
SWJblA7Dzi031L6FNnUrcjsGGcQ==
                      &lt;/xenc:CipherValue&gt;
                  &lt;/xenc:CipherData&gt;
              &lt;/pskc:MACKey&gt;
          &lt;/pskc:MACMethod&gt;
          &lt;pskc:KeyPackage&gt;
              &lt;pskc:DeviceInfo&gt;
                  &lt;pskc:Manufacturer&gt;TokenVendorAcme&lt;/pskc:Manufacturer&gt;
                  &lt;pskc:SerialNo&gt;987654321&lt;/pskc:SerialNo&gt;
              &lt;/pskc:DeviceInfo&gt;
              &lt;pskc:CryptoModuleInfo&gt;
                  &lt;pskc:Id&gt;CM_ID_001&lt;/pskc:Id&gt;
              &lt;/pskc:CryptoModuleInfo&gt;
              &lt;pskc:Key Algorithm=
        "urn:ietf:params:xml:ns:keyprov:pskc#hotp" Id="123456"&gt;
                  &lt;pskc:Issuer&gt;Example-Issuer&lt;/pskc:Issuer&gt;
                  &lt;pskc:AlgorithmParameters&gt;
                      &lt;pskc:ResponseFormat Length="8" Encoding="DECIMAL"/&gt;
                  &lt;/pskc:AlgorithmParameters&gt;
                  &lt;pskc:Data&gt;
                      &lt;pskc:Secret&gt;
                      &lt;pskc:EncryptedValue Id="ED"&gt;
                          &lt;xenc:EncryptionMethod
                        Algorithm=
"http://www.rsasecurity.com/rsalabs/pkcs/schemas/pkcs-5#pbes2"&gt;
                              &lt;pskc:EncryptionScheme
Algorithm="http://www.w3.org/2001/04/xmlenc#aes128-cbc"/&gt;
                              &lt;/xenc:EncryptionMethod&gt;
                              &lt;xenc:CipherData&gt;
                                  &lt;xenc:CipherValue&gt;
      oTvo+S22nsmS2Z/RtcoF8Hfh+jzMe0RkiafpoDpnoZTjPYZu6V+A4aEn032yCr4f
                              &lt;/xenc:CipherValue&gt;
                          &lt;/xenc:CipherData&gt;
                          &lt;/pskc:EncryptedValue&gt;
                          &lt;pskc:ValueMAC&gt;LP6xMvjtypbfT9PdkJhBZ+D6O4w=
                          &lt;/pskc:ValueMAC&gt;
                      &lt;/pskc:Secret&gt;
                  &lt;/pskc:Data&gt;
              &lt;/pskc:Key&gt;
          &lt;/pskc:KeyPackage&gt;
		&lt;/dskpp:KeyContainer&gt;
	&lt;/dskpp:KeyPackage&gt;
	&lt;dskpp:Mac MacAlgorithm="http://www.ietf.org/keyprov/dskpp#dskpp-prf-aes"&gt;
        miidfasde312asder394jw==
     &lt;/dskpp:Mac&gt;
&lt;/dskpp:KeyProvServerFinished&gt;</pre></div>
<p>
</p>
<a name="Section-Integration"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.C"></a><h3>Appendix C.&nbsp;
Integration with PKCS #11</h3>

<p>A DSKPP client that needs to communicate with a connected
      cryptographic module to perform a DSKPP exchange MAY use PKCS #11 <a class='info' href='#PKCS-11'>[PKCS&#8209;11]<span> (</span><span class='info'>RSA Laboratories, &ldquo;Cryptographic Token Interface Standard,&rdquo; June&nbsp;2004.</span><span>)</span></a> as a programming interface as described herein.
      This appendix forms an informative part of the document.
</p>
<a name="anchor82"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.C.1"></a><h3>C.1.&nbsp;
The 4-pass Variant</h3>

<p>When performing 4-pass DSKPP with a cryptographic module using the
        PKCS #11 programming interface, the procedure described in <a class='info' href='#CT-KIP-P11'>[CT&#8209;KIP&#8209;P11]<span> (</span><span class='info'>RSA Laboratories, &ldquo;PKCS #11 Mechanisms for the Cryptographic Token Key           Initialization Protocol,&rdquo; December&nbsp;2005.</span><span>)</span></a>, Appendix B, is RECOMMENDED.
</p>
<a name="anchor83"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.C.2"></a><h3>C.2.&nbsp;
The 2-pass Variant</h3>

<p>A suggested procedure to perform 2-pass DSKPP with a cryptographic
        module through the PKCS #11 interface using the mechanisms defined in
        <a class='info' href='#CT-KIP-P11'>[CT&#8209;KIP&#8209;P11]<span> (</span><span class='info'>RSA Laboratories, &ldquo;PKCS #11 Mechanisms for the Cryptographic Token Key           Initialization Protocol,&rdquo; December&nbsp;2005.</span><span>)</span></a> is as follows:
</p>
<p></p>
<blockquote class="text"><dl>
<dt>a.</dt>
<dd>On the client side, 
<blockquote class="text"><dl>
<dt>1.</dt>
<dd>The client selects a suitable slot and token (e.g., through
                use of the &lt;DeviceIdentifier&gt; or the
                &lt;PlatformInfo&gt; element of the DSKPP trigger
                message).
</dd>
<dt>2.</dt>
<dd>A nonce R is generated, e.g. by calling C_SeedRandom and
                C_GenerateRandom.
</dd>
<dt>3.</dt>
<dd>The client sends its first message to the server, including
                the nonce R.
</dd>
</dl></blockquote>
</dd>
<dt>b.</dt>
<dd>On the server side, 
<blockquote class="text"><dl>
<dt>1.</dt>
<dd>A generic key K_PROV = K_TOKEN | K_MAC (where '|' denotes
                concatenation) is generated, e.g. by calling C_GenerateKey
                (using key type CKK_GENERIC_SECRET). The template for K_PROV
                MUST allow it to be exported (but only in wrapped form, i.e.
                CKA_SENSITIVE MUST be set to CK_TRUE and CKA_EXTRACTABLE MUST
                also be set to CK_TRUE), and also to be used for further key
                derivation. From K, a token key K_TOKEN of suitable type is
                derived by calling C_DeriveKey using the PKCS #11 mechanism
                CKM_EXTRACT_KEY_FROM_KEY and setting the CK_EXTRACT_PARAMS to
                the first bit of the generic secret key (i.e. set to 0).
                Likewise, a MAC key K_MAC is derived from K_PROV by calling
                C_DeriveKey using the CKM_EXTRACT_KEY_FROM_KEY mechanism, this
                time setting CK_EXTRACT_PARAMS to the length of K_PROV (in
                bits) divided by two.
</dd>
<dt>2.</dt>
<dd>The server wraps K_PROV with either the public key of the
                DSKPP client or device, the pre-shared secret key, or the
                derived shared secret key by using C_WrapKey. If use of the
                DSKPP key wrap algorithm has been negotiated then the
                CKM_KIP_WRAP mechanism MUST be used to wrap K. When calling
                C_WrapKey, the hKey handle in the CK_KIP_PARAMS structure MUST
                be set to NULL_PTR. The pSeed parameter in the CK_KIP_PARAMS
                structure MUST point to the nonce R provided by the DSKPP
                client, and the ulSeedLen parameter MUST indicate the length
                of R. The hWrappingKey parameter in the call to C_WrapKey MUST
                be set to refer to the key wrapping key.
</dd>
<dt>3.</dt>
<dd>Next, the server needs to calculate a MAC using K_MAC. If
                use of the DSKPP MAC algorithm has been negotiated, then the
                MAC is calculated by calling C_SignInit with the CKM_KIP_MAC
                mechanism followed by a call to C_Sign. In the call to
                C_SignInit, K_MAC MUST be the signature key, the hKey
                parameter in the CK_KIP_PARAMS structure MUST be set to
                NULL_PTR, the pSeed parameter of the CT_KIP_PARAMS structure
                MUST be set to NULL_PTR, and the ulSeedLen parameter MUST be
                set to zero. In the call to C_Sign, the pData parameter MUST
                be set to the concatenation of the string ServerID and the
                nonce R, and the ulDataLen parameter MUST be set to the length
                of the concatenated string. The desired length of the MAC MUST
                be specified through the pulSignatureLen parameter and MUST be
                set to the length of R.
</dd>
<dt>4.</dt>
<dd>If the server also needs to authenticate its message (due
                to an existing K_TOKEN being replaced), the server MUST
                calculate a second MAC. Again, if use of the DSKPP MAC
                algorithm has been negotiated, then the MAC is calculated by
                calling C_SignInit with the CKM_KIP_MAC mechanism followed by
                a call to C_Sign. In this call to C_SignInit, the K_MAC'
                existing before this DSKPP protocol run MUST be the signature
                key (the implementation may specify K_MAC' to be the value of
                the K_TOKEN that is being replaced, or a version of K_MAC from
                the previous protocol run), the hKey parameter in the
                CK_KIP_PARAMS structure MUST be set to NULL, the pSeed
                parameter of the CT_KIP_PARAMS structure MUST be set to
                NULL_PTR, and the ulSeedLen parameter MUST be set to zero. In
                the call to C_Sign, the pData parameter MUST be set to the
                concatenation of the string ServerID and the nonce R, and the
                ulDataLen parameter MUST be set to the length of concatenated
                string. The desired length of the MAC MUST be specified
                through the pulSignatureLen parameter and MUST be set to the
                length of R.
</dd>
<dt>5.</dt>
<dd>The server sends its message to the client, including the
                wrapped key K_TOKEN, the MAC and possibly also the
                authenticating MAC.
</dd>
</dl></blockquote>
</dd>
<dt>c.</dt>
<dd>On the client side, 
<blockquote class="text"><dl>
<dt>1.</dt>
<dd>The client calls C_UnwrapKey to receive a handle to K.
                After this, the client calls C_DeriveKey twice: Once to derive
                K_TOKEN and once to derive K_MAC. The client MUST use the same
                mechanism (CKM_EXTRACT_KEY_FROM_KEY) and the same mechanism
                parameters as used by the server above. When calling
                C_UnwrapKey and C_DeriveKey, the pTemplate parameter MUST be
                used to set additional key attributes in accordance with local
                policy and as negotiated and expressed in the protocol. In
                particular, the value of the &lt;KeyID&gt; element in the
                server's response message MAY be used as CKA_ID for K_TOKEN.
                The key K_PROV MUST be destroyed after deriving K_TOKEN and
                K_MAC.
</dd>
<dt>2.</dt>
<dd>The MAC is verified in a reciprocal fashion as it was
                generated by the server. If use of the CKM_KIP_MAC mechanism
                has been negotiated, then in the call to C_VerifyInit, the
                hKey parameter in the CK_KIP_PARAMS structure MUST be set to
                NULL_PTR, the pSeed parameter MUST be set to NULL_PTR, and
                ulSeedLen MUST be set to 0. The hKey parameter of C_VerifyInit
                MUST refer to K_MAC. In the call to C_Verify, pData MUST be
                set to the concatenation of the string ServerID and the nonce
                R, and the ulDataLen parameter MUST be set to the length of
                the concatenated string, pSignature to the MAC value received
                from the server, and ulSignatureLen to the length of the MAC.
                If the MAC does not verify the protocol session ends with a
                failure. The token MUST be constructed to not "commit" to the
                new K_TOKEN or the new K_MAC unless the MAC verifies.
</dd>
<dt>3.</dt>
<dd>If an authenticating MAC was received (REQUIRED if the new
                K_TOKEN will replace an existing key on the token), then it is
                verified in a similar vein but using the K_MAC' associated
                with this server and existing before the protocol run (the
                implementation may specify K_MAC' to be the value of the
                K_TOKEN that is being replaced, or a version of K_MAC from the
                previous protocol run). Again, if the MAC does not verify the
                protocol session ends with a failure, and the token MUST be
                constructed no to "commit" to the new K_TOKEN or the new K_MAC
                unless the MAC verifies.
</dd>
</dl></blockquote>
</dd>
</dl></blockquote>

<a name="Section-PRFRealizations"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.D"></a><h3>Appendix D.&nbsp;
Example of DSKPP-PRF Realizations</h3>

<a name="anchor84"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.D.1"></a><h3>D.1.&nbsp;
Introduction</h3>

<p>This example appendix defines DSKPP-PRF in terms of AES <a class='info' href='#FIPS197-AES'>[FIPS197&#8209;AES]<span> (</span><span class='info'>National Institute of Standards and             Technology, &ldquo;Specification for the Advanced Encryption Standard           (AES),&rdquo; November&nbsp;2001.</span><span>)</span></a> and HMAC <a class='info' href='#RFC2104'>[RFC2104]<span> (</span><span class='info'>Krawzcyk, H., Bellare, M., and R. Canetti, &ldquo;HMAC: Keyed-Hashing for Message Authentication,&rdquo; February&nbsp;1997.</span><span>)</span></a>.
        This appendix forms an informative part of the document.
</p>
<a name="anchor85"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.D.2"></a><h3>D.2.&nbsp;
DSKPP-PRF-AES</h3>

<a name="anchor86"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.D.2.1"></a><h3>D.2.1.&nbsp;
Identification</h3>

<p>For cryptographic modules supporting this realization of
          DSKPP-PRF, the following URL MAY be used to identify this algorithm
          in DSKPP:
</p>
<p>http://www.ietf.org/keyprov/dskpp#dskpp-prf-aes-128
</p>
<p>When this URL is used to identify the encryption algorithm, the
          method for encryption of R_C values described in <a class='info' href='#Subsection-Enc'>Section&nbsp;4.2.4<span> (</span><span class='info'>KeyProvClientNonce</span><span>)</span></a> MUST be used.
</p>
<a name="anchor87"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.D.2.2"></a><h3>D.2.2.&nbsp;
Definition</h3>

<p>DSKPP-PRF-AES (k, s, dsLen)
</p>
<p>Input:
</p>
<p></p>
<blockquote class="text"><dl>
<dt>k</dt>
<dd>Encryption key to use
</dd>
<dt>s</dt>
<dd>Octet string consisting of randomizing material.
              The length of the string s is sLen.
</dd>
<dt>dsLen</dt>
<dd>Desired length of the output
</dd>
</dl></blockquote>

<p>Output:
</p>
<p></p>
<blockquote class="text"><dl>
<dt>DS</dt>
<dd>A pseudorandom string, dsLen-octets long
</dd>
</dl></blockquote>

<p>Steps:
</p>
<p></p>
<blockquote class="text"><dl>
<dt>1.</dt>
<dd>Let bLen be the output block size of AES in octets:<br />
bLen = (AES output block length in
              octets)<br />
(normally, bLen = 16)<br />
<br />

</dd>
<dt>2.</dt>
<dd>If dsLen &gt; (2**32 - 1) * bLen, output "derived data too
              long" and stop<br />

</dd>
<dt>3.</dt>
<dd>Let n be the number of bLen-octet blocks in the output data,
              rounding up, and let j be the number of octets in the last
              block:<br />
n = CEILING( dsLen / bLen)<br />
j = dsLen - (n - 1) * bLen<br />
<br />

</dd>
<dt>4.</dt>
<dd>For each block of the pseudorandom string DS, apply the
              function F defined below to the key k, the string s and the
              block index to compute the block:<br />
B1 = F
              (k, s, 1) ,<br />
B2 = F (k, s, 2) ,<br />
...<br />
Bn = F (k, s,
              n)
</dd>
</dl></blockquote>

<p>The function F is defined in terms of the CMAC construction from
          <a class='info' href='#NIST-SP800-38B'>[NIST&#8209;SP800&#8209;38B]<span> (</span><span class='info'>International Organization for             Standardization, &ldquo;Recommendations for Block Cipher Modes of Operation: The CMAC           Mode for Authentication,&rdquo; May&nbsp;2005.</span><span>)</span></a>, using AES as the block
          cipher:<br />
<br />
F (k, s, i) = CMAC-AES (k, INT (i)
          || s)<br />
<br />
where INT (i) is a four-octet encoding
          of the integer i, most significant octet first, and the output
          length of CMAC is set to bLen.<br />
<br />
Concatenate
          the blocks and extract the first dsLen octets to product the desired
          data string DS:<br />
<br />
DS = B1 || B2 || ... ||
          Bn&lt;0..j-1&gt;<br />
<br />
Output the derived data
          DS.
</p>
<a name="anchor88"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.D.2.3"></a><h3>D.2.3.&nbsp;
Example</h3>

<p>If we assume that dsLen = 16, then:
</p>
<p>n = 16 / 16 = 1
</p>
<p>j = 16 - (1 - 1) * 16 = 16
</p>
<p>DS = B1 = F (k, s, 1) = CMAC-AES (k, INT (1) || s)
</p>
<a name="anchor89"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.D.3"></a><h3>D.3.&nbsp;
DSKPP-PRF-SHA256</h3>

<a name="anchor90"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.D.3.1"></a><h3>D.3.1.&nbsp;
Identification</h3>

<p>For cryptographic modules supporting this realization of
          DSKPP-PRF, the following URL MAY be used to identify this algorithm
          in DSKPP:
</p>
<p>http://www.ietf.org/keyprov/dskpp#dskpp-prf-sha256
</p>
<p>When this URL is used to identify the encryption algorithm to
          use, the method for encryption of R_C values described in <a class='info' href='#Subsection-Enc'>Section&nbsp;4.2.4<span> (</span><span class='info'>KeyProvClientNonce</span><span>)</span></a> MUST be used.
</p>
<a name="anchor91"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.D.3.2"></a><h3>D.3.2.&nbsp;
Definition</h3>

<p>DSKPP-PRF-SHA256 (k, s, dsLen)
</p>
<p>Input:
</p>
<p></p>
<blockquote class="text"><dl>
<dt>k</dt>
<dd>Encryption key to use
</dd>
<dt>s</dt>
<dd>Octet string consisting of randomizing material.
              The length of the string s is sLen.
</dd>
<dt>dsLen</dt>
<dd>Desired length of the output
</dd>
</dl></blockquote>

<p>Output:
</p>
<p></p>
<blockquote class="text"><dl>
<dt>DS</dt>
<dd>A pseudorandom string, dsLen-octets long
</dd>
</dl></blockquote>

<p>Steps:
</p>
<p></p>
<blockquote class="text"><dl>
<dt>1.</dt>
<dd>Let bLen be the output size of SHA-256 in octets of <a class='info' href='#FIPS180-SHA'>[FIPS180&#8209;SHA]<span> (</span><span class='info'>National Institute of Standards and             Technology, &ldquo;Secure Hash Standard,&rdquo; February&nbsp;2004.</span><span>)</span></a> (no truncation is done on the HMAC
              output):<br />
bLen = 32<br />
(normally, bLen = 16)<br />
<br />

</dd>
<dt>2.</dt>
<dd>If dsLen &gt; (2**32 - 1) * bLen, output "derived data too
              long" and stop<br />

</dd>
<dt>3.</dt>
<dd>Let n be the number of bLen-octet blocks in the output data,
              rounding up, and let j be the number of octets in the last
              block:<br />
n = CEILING( dsLen / bLen)<br />
j = dsLen - (n - 1) * bLen<br />
<br />

</dd>
<dt>4.</dt>
<dd>For each block of the pseudorandom string DS, apply the
              function F defined below to the key k, the string s and the
              block index to compute the block:<br />
B1 = F
              (k, s, 1),<br />
B2 = F (k, s, 2),<br />
...<br />
Bn = F (k, s,
              n)
</dd>
</dl></blockquote>

<p>The function F is defined in terms of the HMAC construction from
          <a class='info' href='#RFC2104'>[RFC2104]<span> (</span><span class='info'>Krawzcyk, H., Bellare, M., and R. Canetti, &ldquo;HMAC: Keyed-Hashing for Message Authentication,&rdquo; February&nbsp;1997.</span><span>)</span></a>, using SHA-256 as the digest
          algorithm:<br />
<br />
F (k, s, i) = HMAC-SHA256 (k, INT
          (i) || s)<br />
<br />
where INT (i) is a four-octet
          encoding of the integer i, most significant octet first, and the
          output length of HMAC is set to bLen.<br />
<br />
Concatenate the blocks and extract the first dsLen
          octets to product the desired data string DS:<br />
<br />
DS = B1 || B2 || ... || Bn&lt;0..j-1&gt;<br />
<br />
Output the derived data DS.
</p>
<a name="anchor92"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.D.3.3"></a><h3>D.3.3.&nbsp;
Example</h3>

<p>If we assume that sLen = 256 (two 128-octet long values) and
          dsLen = 16, then:
</p>
<p>n = CEILING( 16 / 32 ) = 1
</p>
<p>j = 16 - (1 - 1) * 32 = 16
</p>
<p>B1 = F (k, s, 1) = HMAC-SHA256 (k, INT (1) || s)
</p>
<p>DS = B1&lt;0 ... 15&gt;
</p>
<p>That is, the result will be the first 16 octets of the HMAC
          output.
</p>
<a name="rfc.authors"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>Authors' Addresses</h3>
<table width="99%" border="0" cellpadding="0" cellspacing="0">
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Andrea Doherty</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">RSA, The Security Division of EMC</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">174 Middlesex Turnpike</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Bedford, MA  01730</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">USA</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:andrea.doherty@rsa.com">andrea.doherty@rsa.com</a></td></tr>
<tr cellpadding="3"><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Mingliang Pei</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Verisign, Inc.</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">487 E. Middlefield Road</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Mountain View, CA  94043</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">USA</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:mpei@verisign.com">mpei@verisign.com</a></td></tr>
<tr cellpadding="3"><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Salah Machani</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Diversinet Corp.</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">2225 Sheppard Avenue East, Suite 1801</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Toronto, Ontario  M2J 5C2</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Canada</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:smachani@diversinet.com">smachani@diversinet.com</a></td></tr>
<tr cellpadding="3"><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Magnus Nystrom</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">RSA, The Security Division of EMC</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Arenavagen 29</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Stockholm, Stockholm Ln  121 29</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">SE</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:magnus.nystrom@rsa.com">magnus.nystrom@rsa.com</a></td></tr>
</table>
</body></html>
