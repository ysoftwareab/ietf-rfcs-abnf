





 
 
Long-term Archive And Notary                           A. Jerman Blazic 
Services (LTANS)                                                 SETCCE 
Internet Draft                                                S. Saljic 
Intended status: Standards Track                                 SETCCE 
Expires: June 2, 2008                                        T. Gondrom 
                                                  Open Text Corporation 
                                                       December 2, 2007 
                                      
             Extensible Markup Language Evidence Record Syntax 
                      draft-ietf-ltans-xmlers-01.txt 


Status of this Memo 

   By submitting this Internet-Draft, each author represents that any 
   applicable patent or other IPR claims of which he or she is aware 
   have been or will be disclosed, and any of which he or she becomes 
   aware will be disclosed, in accordance with Section 6 of BCP 79. 

   Internet-Drafts are working documents of the Internet Engineering 
   Task Force (IETF), its areas, and its working groups. Note that other 
   groups may also distribute working documents as Internet-Drafts. 

   Internet-Drafts are draft documents valid for a maximum of six months 
   and may be updated, replaced, or obsoleted by other documents at any 
   time. It is inappropriate to use Internet-Drafts as reference 
   material or to cite them other than as "work in progress." 

   The list of current Internet-Drafts can be accessed at 
   http://www.ietf.org/ietf/1id-abstracts.txt. 

   The list of Internet-Draft Shadow Directories can be accessed at 
   http://www.ietf.org/shadow.html. 

   This Internet-Draft will expire on June 2, 2007. 

Copyright Notice 
 
 
 
Jerman Blazic, et. al.   Expires June 2, 2007                  [Page 1] 
 
Internet-Draft                  XMLERS                    December 2007 
    

   Copyright (C) The IETF Trust (2007). 

Abstract 

   In many scenarios, users must be able to demonstrate the (time) 
   existence, integrity and validity of data including signed data for 
   long or undetermined period of time. This document specifies XML 
   syntax and processing rules for creating evidence for long-term non-
   repudiation of existence of data. ERS-XML incorporates alternative 
   syntax and processing rules to ASN.1 ERS syntax by using XML 
   language. 

Conventions used in this document 

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", 
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this 
   document are to be interpreted as described in [RFC2119]. 



















 
 
Jerman Blazic, et. al.   Expires June 2, 2008                  [Page 2] 
    
Internet-Draft                  XMLERS                    December 2007 
    

Table of Contents 

    
   1. Introduction...................................................5 
      1.1. Motivation................................................5 
      1.2. General Overview and Requirements.........................7 
      1.3. Terminology...............................................8 
      1.4. Conventions Used in This Document........................10 
   2. Evidence Record...............................................10 
      2.1. Evidence Record Structure................................11 
      2.2. Archive Timestamp Sequence and Archive Timestamp Chain 
      Structure.....................................................13 
         2.2.1. Digest Method.......................................13 
      2.3. Archive Timestamp Structure..............................14 
         2.3.1. Time-Stamp Token....................................15 
         2.3.2. Hash Tree...........................................16 
         2.3.3. Merkle Hash-Tree....................................17 
            2.3.3.1. Generation of a Merkle Hash-Tree for a Group of 
            Archive Objects.........................................18 
            2.3.3.2. Generation of the Reduced Hash Tree for an Archive 
            Object..................................................20 
            2.3.3.3. Calculation of the root hash value from a reduced 
            hash tree...............................................21 
         2.3.4. Cryptographic Information...........................21 
   3. Generation of an Evidence Record..............................21 
      3.1. Initial Archive Timestamp................................22 
      3.2. Renewal Process..........................................23 
         3.2.1. Time-Stamp Renewal..................................24 
         3.2.2. Hash Tree Renewal...................................25 
   4. Verification of an Evidence Record............................26 
   5. XSD Schema for the Evidence Record............................28 
   6. Security Considerations.......................................31 
   7. IANA Considerations...........................................31 
   8. Conclusions...................................................31 
   9. Acknowledgments...............................................31 
   APPENDIX A: First Appendix.......................................32 
 
 
Jerman Blazic, et. al.   Expires June 2, 2008                  [Page 3] 
    
Internet-Draft                  XMLERS                    December 2007 
    

   10. References...................................................33 
      10.1. Normative References....................................34 
      10.2. Informative References..................................34 
   Author's Addresses...............................................34 
   Intellectual Property Statement..................................35 
   Disclaimer of Validity...........................................36 
    





























 
 
Jerman Blazic, et. al.   Expires June 2, 2008                  [Page 4] 
    
Internet-Draft                  XMLERS                    December 2007 
    

    

1. Introduction 

   The purpose of the document is to define XML Schema and processing 
   rules for Evidence Record Syntax in XML format. Document is related 
   to initial ASN.1 syntax for Evidence Record Syntax. 

1.1. Motivation 

   The evolution of electronic commerce and electronic data exchange in 
   general requires introduction of non-repudiation proof of data 
   existence as well as data integrity and authenticity. Such data and 
   non-repudiation proof of existence must endure for long periods of 
   time, even when information to prove data existence and integrity 
   weakens or cease to exist. Mechanisms such as digital signatures do 
   not provide absolute reliability on a long term basis. Algorithms and 
   cryptographic material used to create a signature can become weak in 
   course of time and information needed to validate digital signatures 
   may became compromised or simply cease to exist due to e.g. 
   decomposing certificate service provider. Providing a stable 
   environment for electronic data on a long term basis requires the 
   introduction of additional means to continually provide appropriate 
   level of trust in evidence on data existence, integrity and 
   authenticity. 

   Integrity and other authenticity related techniques used today all 
   suffer from the same problems of time related reliability degradation 
   including techniques for time stamping, generally recognized as data 
   existence proofs. Over long periods of time algorithms used may 
   become weak or encryption keys compromised. Some of the problems 
   might not even be technical related like decomposing time stamping 
   authority. To create a stable environment where proof of existence 
   and integrity can endure well into the future a new technical 
   approach must be used. 

 
 
Jerman Blazic, et. al.   Expires June 2, 2008                  [Page 5] 
    
Internet-Draft                  XMLERS                    December 2007 
    

   Long term non-repudiation of data existence and demonstration of data 
   integrity techniques have been already introduced by e.g. long term 
   signature syntaxes like [RFC3126]. Long term signature syntaxes 
   address mostly the long term endurance of digital signatures, while 
   evidence record syntax broadens this approach for data of any format. 

   The XMLERS syntax is based on Evidence Record Syntax as defined in 
   [RFC4998] and is addressing the same problem of long term non-
   repudiable proof of data existence and demonstration of data 
   integrity on long term basis. XMLERS does not supplement the ERS 
   syntax. It introduces the same approach in different format. 

   The use of XML format is already recognized by a wide range of 
   applications and services and is being selected as de-facto standard 
   for many applications based on data exchange. The introduction of 
   evidence record in XML format broadens the horizon of XML use and 
   presents harmonized syntax with growing community of XML based 
   standards. 

   Due to the difference in XML processing rules and other 
   characteristics of XML language, XMLERS does not present a direct 
   transformation of ERS in ASN.1 syntax. The XMLERS syntax is based on 
   different processing rules as defined in [RFC4998] and it does not 
   support e.g. import of ASN.1 values in XML tags. Creating Evidence 
   Records in XML syntax must follow the steps as defined in this draft. 
   XMLERS is a stand alone draft and based on [RFC4998] conceptually 
   only. 

   Evidence Record Syntax in XML format is based on long term archive 
   service requirements as defined in [RFC4810]. XMLERS syntax delivers 
   the same (level of) non-repudiable proof of data existence as ASN.1 
   ERS. The XML syntax supports archive data grouping (and de-grouping) 
   together with simple or complex time stamp renewal process. Evidence 
   records can be imbedded in the data itself or stored separately as 
   stand alone XML file. 

 
 
Jerman Blazic, et. al.   Expires June 2, 2008                  [Page 6] 
    
Internet-Draft                  XMLERS                    December 2007 
    

1.2. General Overview and Requirements 

   ERSXML draft (draft-ietf-ltans-xmlers-01) specifies XML syntax and 
   processing rules for creating evidence for long-term non-repudiation 
   of existence of data in a unit called "Evidence Record". The XMLERS 
   syntax is defined to meet the requirements for data structures of 
   [RFC4810]. This document also refers to ASN.1 ERS specification as 
   defined in [RFC4998]. 

   An Evidence Record may be generated and maintained for a single data 
   object or a group of data objects that form an archive object. Data 
   object (binary chunk or a file) may represent any kind of document or 
   part of it. Dependencies among data objects, their validation or any 
   other relation than "a data object is a part of particular archived 
   object" are out of the scope of this draft. 

   Timestamps as defined in [RFC3161] can cover only a single unit of 
   data. Evidence for an archive object is created by acquiring a 
   timestamp from a trustworthy authority for a specific value that is 
   unambiguously related to a single or more data objects. The Evidence 
   Record syntax enables processing of several archive objects within a 
   single processing pass and by acquiring only one timestamp to protect 
   all archive objects. 

   Besides a timestamp other artifacts are preserved as well: data 
   necessary to verify relation of the time-stamped value with a 
   specific data object, which is packed into a structure called "hash-
   tree"; and long term proofs for the formal verification of the time-
   stamp. 

   Due to the fact that digest algorithms or cryptographic methods used 
   may become weak or that certificates used within timestamp (and 
   signed data) may be revoked or expired, the collected evidence data 
   must be monitored and renewed before such event occurs. Procedures 
   for generation and renewing such evidence are already specified 
   within the [RFC4998], but they depend on defined ASN.1 data 
 
 
Jerman Blazic, et. al.   Expires June 2, 2008                  [Page 7] 
    
Internet-Draft                  XMLERS                    December 2007 
    

   structures. For the purpose of renewal of the evidence, digest values 
   of ASN.1 formatted data must be calculated and used in further 
   processing. Besides replacing an ASN.1 scheme with an XML scheme, 
   this document also introduces XML based procedures and processing 
   rules for creation and renewal of evidence data. 

1.3. Terminology 

   Archived data object: Data unit that is archived and has to be 
   preserved for a long time by the Long-term Archive Service. 

   Archived data object group: A multitude of data objects, which for 
   some reason belong together, e.g. a document file and a signature 
   file could be an archived data object group, which represent signed 
   data. 

   Archived object (AO): Archive data object or archive data object 
   group. 

   Archive Timestamp (ATS): An Archive Timestamp contains a time-stamp 
   token, useful data for validation and potentially list of hash 
   values. The basic idea is to time-stamp a specific value, constructed 
   from significant values (e.g. hash value of a list of hash values of 
   documents), which are unambiguously related to protected data 
   objects. 

   Archive Timestamp Sequence (ATSSeq): is a sequence of Archive 
   Timestamp Chains. 

   Archive Timestamp Chain (ATSC): holds a sequence of Archive 
   Timestamps generated during the preservation period. 

   Canonicalization: Processing rules for transforming an XML document 
   into its canonical form. Two XML document may have different physical 
   representation, but they may have a same canonical form. For example 

 
 
Jerman Blazic, et. al.   Expires June 2, 2008                  [Page 8] 
    
Internet-Draft                  XMLERS                    December 2007 
    

   a sort order of attributes does not change the meaning of the 
   document as defined in [XMLC14N]. 

   Cryptographic Information: Data or part of data related to the 
   validation process of signed data, e.g. digital certificates, digital 
   certificate chains, certificate revocation list, etc. 

   Digest Method: Digest method is an identifier for a digest algorithm, 
   which is a strong one-way function, for which it is computationally 
   infeasible to find an input that corresponds to a given output or to 
   find two different input values that correspond to the same output. 
   Digest algorithm transforms input data into short value of fixed 
   length. The output is called digest value, hash value or data 
   fingerprint. 

   Evidence: Information that may be used to resolve a dispute about 
   various aspects of authenticity, validity and existence of archived 
   data objects. 

   Evidence record: Collection of evidence for a given archived object 
   over time. An evidence record includes ordered collection of ATS, 
   which are grouped into ATSC and ATSSeq.  

   Long-term Archive Service (LTA): A service responsible for 
   generation, collection and maintenance (renewal) of evidence data. A 
   LTA service may also preserve data for long periods of time, i.e. 
   storage of archived data objects and evidence, etc. 

   Hash Tree: Collection of significant values of protected objects 
   (input objects and generated evidence within archival period). For 
   that purpose a Merkle Hash Tree [MER1980] may be constructed and 
   reduced for each archive object. 

   Reduced hash-tree: The process of reducing a Merkle hash-tree 
   [MER1980] to a list of lists of hash values. This is the basis of 
   storing the evidence for a single data object. 
 
 
Jerman Blazic, et. al.   Expires June 2, 2008                  [Page 9] 
    
Internet-Draft                  XMLERS                    December 2007 
    

   Timestamp (TS): A cryptographically secure confirmation generated by 
   a Time Stamping Authority (TSA) [RFC3161] specifies a structure for 
   timestamps and a protocol for communicating with a Timestamp 
   Authority. Besides this, other data structures and protocols may also 
   be appropriate, such as defined in [ISO-18014-1.2002], [ISO-18014-
   2.2002], [ISO-18014-3.2004], and [ANSI.X9-95.2005]. 

   Analogue to the [RFC4998] specification an Archive Timestamp relates 
   to a data object, if the hash value of this data object is part of 
   the first hash value list of the Archive Timestamp. An Archive 
   Timestamp relates to a data object group, if it relates to every data 
   object of the group and no other data objects. 

1.4. Conventions Used in This Document 

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", 
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this 
   document are to be interpreted as described in [RFC2119]. 

2. Evidence Record 

   An Evidence Record is a unit of data, which is to be used to prove 
   the existence of an archived object (a single data object or a group 
   of data objects) at a certain time. It is possible to store Evidence 
   Record separately from the archived object or to integrate it into 
   the data itself. 

   Evidence Record Syntax enables processing of several archive objects 
   (group processing) with a single process and by acquiring only one 
   timestamp to protect many archive objects, without a need to access 
   any other archive object or their evidence records while 
   demonstrating the validity for a particular archive object from the 
   group. 

   The Evidence Record contains one or several archive time-stamps 
   (ATS). An ATS contains a time-stamp token and possibly useful data 
 
 
Jerman Blazic, et. al.   Expires June 2, 2008                 [Page 10] 
    
Internet-Draft                  XMLERS                    December 2007 
    

   for validation. Initially, an ATS is acquired and later, before it 
   expires or becomes invalid, a new ATS is generated, which prolongs 
   the validity of archived object (of its data objects together with 
   all previously generated archive time-stamps). This process must 
   continue during the desired archiving period. 

2.1. Evidence Record Structure 

   In XML syntax the Evidence Record is represented by the 
   <EvidenceRecord> element, which has the following structure (where 
   "+" denotes one or more occurrences and "*" denotes zero or more 
   occurrences): 

   <EvidenceRecord> 
      <Version /> 
      <ArchiveTimeStampSequence> 
         <CanonicalizationMethod /> 
         <ArchiveTimeStampChain Order> 
            <DigestMethod /> 
            <ArchiveTimeStamp Order> 
               <HashTree /> * 
               <TimeStamp /> + 
               <CryptographicInformation /> * 
            </ArchiveTimeStamp>) + 
         </ArchiveTimeStampChain> + 
      </ArchiveTimeStampSequence> 
   </EvidenceRecord> 

   The XML tags have the following meanings: 

     <Version> tag indicates the syntax version, for compatibility with 
     future revisions of this specification and to distinguish it from 
     earlier non-conformant or proprietary versions of the XMLERS. 
     Current version of the XMLERS syntax is 01. 


 
 
Jerman Blazic, et. al.   Expires June 2, 2008                 [Page 11] 
    
Internet-Draft                  XMLERS                    December 2007 
    

     <ArchiveTimeStampSequence> is a sequence of 
     <ArchiveTimeStampChain>. 

     <CanonicalizationMethod> is a required element that specifies the 
     canonicalization algorithm applied to the 
     <ArchiveTimeStampSequence> or <ArchiveTimeStamp> element prior to 
     performing digest value calculations. 

     <ArchiveTimeStampChain> holds a sequence of Archive Timestamps 
     generated during the preservation period. Details on Archive 
     Timestamp Chains and Archive Timestamp Sequences are described in 
     section 2.3. The sequences of Archive Timestamp Chains and Archive 
     Timestamps are ordered and the order must be indicated with "Order" 
     attribute of the <ArchiveTimeStampChain> and <ArchiveTimeStamp> 
     element. 

     <DigestMethod> tag identifies the digest algorithms used to 
     calculated digest values over the archival period within an archive 
     time-stamp chain from archive data object(s), archive time-stamps, 
     archive time-stamp sequence and within time-stamp token. 

     <HashTree> tag holds a value or a structure of a reduced hash 
     tree(s) described in section 2.3.2.  

     <TimeStamp> tag holds a time stamp token provided by the Time-
     Stamping Authority. 

     <CryptographicInformation> tag allows the storage of data useful in 
     the process of time stamp or data signature validation. This could 
     include possible Trust Anchors, certificates, revocation 
     information or the current definition of the suitability of 
     cryptographic algorithms, past and present. These items may be 
     added based on the policy used. This data is protected by 
     successive time-stamp in the sequence of the time-stamps. 


 
 
Jerman Blazic, et. al.   Expires June 2, 2008                 [Page 12] 
    
Internet-Draft                  XMLERS                    December 2007 
    

2.2. Archive Timestamp Sequence and Archive Timestamp Chain Structure 

   <ArchiveTimeStampSequence> element contains an ordered sequence of 
   <ArchiveTimeStampChain> elements and <ArchiveTimeStampChain> element 
   is an ordered sequence of <ArchiveTimeStamp> elements. Order is 
   indicated with Order attribute.  

   The first <ArchiveTimeStampChain> element and its first 
   <ArchiveTimeStamp> are generated at the beginning of the archival 
   period, both having value of the Order attribute equal 1. 

   When this initial <ArchiveTimeStamp> must be renewed, a new 
   <ArchiveTimeStamp> is generated and depending on generation process, 
   it is placed: 

   o  as <ArchiveTimeStamp> element either in the same 
      <ArchiveTimeStampChain> element (see Time-Stamp Renewal) or  

   o  a new <ArchiveTimeStampChain> element is created to have newly 
      created <ArchiveTimeStamp> as the first element in a sequence (see 
      Hash Tree Renewal). The value of its Order attribute is increased 
      by one, and also if a new chain is created its Order attribute is 
      increased by one regarding to the previous chain. 

   Generally when a new ATS is created it is placed into the last ATSC 
   as a last child or a new ATSC is created and the new ATS is placed as 
   its first element. 

   The ATS with the largest Order attribute value is the last and must 
   be valid at the present time. 

2.2.1. Digest Method 

   Digest method is required element that identifies the digest 
   algorithm used to digest archive data object(s) and previously 
   generated long-term evidence over the archival period. It is 
 
 
Jerman Blazic, et. al.   Expires June 2, 2008                 [Page 13] 
    
Internet-Draft                  XMLERS                    December 2007 
    

   specified on the level of the ATSC and indicates the digest algorithm 
   that MUST be used for all digest value calculations related to 
   archive timestamps within this chain. 

   Within one archive time-stamp chain digest value calculations are 
   performed in following cases: 

   1. digest value of archived data object(s) at the beginning of the 
      archival period or at performing s hash-tree renewal 

   2. digest value of previous ATS when performing timestamp renewal 

   3. digest value of previous ATSCs when performing hash tree renewal 

   For cases 2) and 3) the calculation of digest value of an XML element 
   is needed. Before performing digest value calculation of an XML 
   element, a proper binary representation must be extracted from its 
   (abstract) XML data presentation. The binary representation is 
   determined by UTF-8 encoding and canonicalization of the XML element. 
   The XML element includes the entire text of the start and end tags as 
   well as all descendant markup and character data (i.e., the text and 
   sub-elements) between those tags.   

2.3. Archive Timestamp Structure 

   The process of construction of an ATS must unambiguously bind 
   archived object and time-stamped value and thus prove that archived 
   object existed and was identical, at the time of the timestamp, to 
   the currently present archived object (at the time of verification). 

   Therefore an ATS is a collection of the time-stamp token, an optional 
   structure (a hash tree) for digest values of objects that were 
   protected with that time-stamp token and optional structures 
   (cryptographic information) to store additional data needed for 
   formal verification of the time-stamp token, such as certificate 
   chain or certificate revocation list. 
 
 
Jerman Blazic, et. al.   Expires June 2, 2008                 [Page 14] 
    
Internet-Draft                  XMLERS                    December 2007 
    

   For the initial ATS the value to be time-stamped must be 
   unambiguously related to the archived object (to all of its data 
   objects). When the same digest algorithm is used with the successive 
   time-stamp (in the renewal process), it is enough that time-stamped 
   value is related only to the digest value of the last ATS. When a 
   different digest algorithm is used in the renewal process, the time-
   stamped value must be unambiguously related to the archive object and 
   all previously created ATSCs. 

2.3.1. Time-Stamp Token 

   Time-Stamp is an attestation generated by a Time Stamping Authority 
   (TSA) that a data item existed at a certain time. For example, 
   [RFC3161] specifies a structure for signed time-stamp tokens in ASN.1 
   format. The following structure example (reference to the Entrust XML 
   Schema for time-stamp) is a digital signature compliant to XMLDsig 
   specification containing time-stamp specific data, such as time-
   stamped value and time within <Object> element of a signature. 

   <element name="TimeStampInfo"> 
      <complexType> 
         <sequence> 
            <element ref="ts:Policy" />  
            <element ref="ts:Digest" />  
            <element ref="ts:SerialNumber" minOccurs="0" />  
            <element ref="ts:CreationTime" />  
            <element ref="ts:Accuracy" minOccurs="0" />  
            <element ref="ts:Ordering" minOccurs="0" />  
            <element ref="ts:Nonce" minOccurs="0" />  
            <element ref="ts:Extensions" minOccurs="0" />  
         </sequence> 
      </complexType> 
   </element> 



 
 
Jerman Blazic, et. al.   Expires June 2, 2008                 [Page 15] 
    
Internet-Draft                  XMLERS                    December 2007 
    

2.3.2. Hash Tree 

   The time-stamping service may be, for a large number of archived 
   objects, expensive and time-demanding, so the LTA may profit from 
   acquiring one time-stamp for many archived objects, which are not 
   otherwise related to each other. For that purpose a Merkle Hash Tree 
   [MER1980] may be constructed and reduced for each archive object. 

   Hash tree structure is a container for significant values, needed to 
   unambiguously relate time-stamped value to protected data objects, 
   and is represented by the <HashTree> element. 

   The lists of digest values are generated by reduction of an ordered 
   Merkle hash-tree. The leaves of this hash-tree are the digest values 
   of the data objects to be time-stamped. Every inner node of the tree 
   contains one digest value, which is generated by digesting the binary 
   sorted concatenation of the children nodes (leaves). The root digest 
   value, which represents unambiguously all data objects, is time-
   stamped. 

   Note that there are no restrictions to the quantity of hash value 
   lists and of their length. Also note that it is profitable but not 
   required to build hash-trees and reduce them. An Archive Time-Stamp 
   may consist only of one list of hash-values and a time-stamp or in 
   the extreme case, only a time-stamp with no hash value lists.  

   A sample of lists of hash values within Content node value: 

   <Sequence> 
      <DigestValue>5XQCAGgwJL2WZ6nv2OSGYlRFpK8=</DigestValue> 
      <DigestValue>wyFrW58ATzRch7VUPNY2P+75Q/I=</DigestValue> 
      <DigestValue>woCvx62tw0uc24v51xtNNxld5Kw=</DigestValue> 
      <DigestValue>7N2lphOrGx+/PCxtGwzbKIj+InQ=</DigestValue> 
      <DigestValue>zbCNhmQv+8kRo9W/0YedrpeZ1a8=</DigestValue> 
      <DigestValue>ThuhSOZhNj42vsIRg38epxj9qVo=</DigestValue> 
   </Sequence> 
 
 
Jerman Blazic, et. al.   Expires June 2, 2008                 [Page 16] 
    
Internet-Draft                  XMLERS                    December 2007 
    

   <Sequence> 
      <DigestValue>FX7AgSsZ0kaW8fHWi4BYDkAkZS0=</DigestValue> 
   </Sequence> 
   <Sequence> 
      <DigestValue>tWl/o/er7kGwIeip4g+xvzShMno=</DigestValue> 
   </Sequence> 
   <Sequence> 
      <DigestValue>+bY32LFVm/ynJj6TZss5J6BzYwI=</DigestValue> 
   </Sequence> 
   <Sequence> 
      <DigestValue>Eu05AI8VVqFkddHYyYXMs8cjXcU=</DigestValue> 
   </Sequence> 

   This sample represents a reduced hash tree. The first sequence (input 
   list) contains 6 digest values, which indicate 6 hash values of data 
   objects to be archived with archive time-stamp element. Sequences 
   that follow input list are used to calculate a final digest value to 
   be time-stamped. The reduced tree is result of reducing a Merkle 
   hash-tree as described in chapter 2.3.3. The digest values are always 
   represented as encoded base64 character data. 

2.3.3. Merkle Hash-Tree 

   A hash tree is a tree of digest values in which the leaves are hashes 
   of data blocks in, for instance, a file or set of files. Nodes 
   further up in the tree are the hashes of their respective children. 
   In the top of a hash tree there is a root hash value. 

   From Merkle Hash-Tree for each leaf a very small sub tree may be 
   extracted (a reduced tree), that holds enough information to 
   unambiguously bind the leaf value with the root hash value. After the 
   group processing of several archive objects (the root hash value, 
   that unambiguously bound together all archive objects, was time-
   stamped), for each archive object reduced tree is saved within its 
   evidence record (a hash tree within the last ATS). 

 
 
Jerman Blazic, et. al.   Expires June 2, 2008                 [Page 17] 
    
Internet-Draft                  XMLERS                    December 2007 
    

2.3.3.1. Generation of a Merkle Hash-Tree for a Group of Archive Objects 

   The Merkle Hash-Tree for a group of archive objects is built from 
   bottom to the root. First are collected leaves of the tree. The 
   leaves are digest values of archive objects: 

   1. Collect archive objects and for each archive object corresponding 
      data objects. 

   2. Calculate hash values of the archive objects and put them into 
      input list as follows: a digest value of an archive objects is a 
      digest value of its data object, if there is only one data object; 
      for more than one data objects a digest value is a digest value of 
      binary sorted, concatenated digest values of all containing data 
      objects. Note that for some hash values on the input list also 
      lists of their sub-hash values are stored (for archive objects 
      having more than one data object) 

   3. Group items in the input list by N (to make binary tree in pairs) 
      and for each group: binary ascending sort, concatenate and 
      calculate hash values with algorithm H. The result is a new input 
      list. 

   4. Repeat step 3, until only one hash value is left; this is the root 
      value of the hash tree to be time-stamped. 

   Example: The input list with 18 hashes, where the h'1 is generated 
   for a group of data objects (d4, d5, d6 and d7) and has been grouped 
   by 3. The group could be of any size (2, 3...). It is also possible 
   to extend the tree with "dummy" values; to make every node having the 
   same number of children. 





 
 
Jerman Blazic, et. al.   Expires June 2, 2008                 [Page 18] 
    
Internet-Draft                  XMLERS                    December 2007 
    

                    d1  -> h1 \ 
                               \ 
                    d2  -> h2  |-> h''1 
       G1                      /       \ 
   +--------+       d3  -> h3 /         \ 
   |d4 -> h4|\                           \ 
   |        | \     --------             | 
   |d5 -> h5|  \                         | 
   |        |  | -> h'1       \          | 
   |d6 -> h6|  /               \         | 
   |        | /     d8  -> h8  |-> h''2  |-> h'''1 
   |d7 -> h7|/                 /         |        \ 
   +--------+       d9  -> h9 /          |         \ 
                                         |         | 
                    --------             |         | 
                                         /         | 
                    d10 -> h10\         /          | 
                               \       /           | 
                    d11 -> h11 |-> h''3            | 
                               /                   | 
                    d12 -> h12/                    | 
                                                   |-> root hash value 
                    --------                       | 
                                                   | 
                    d13 -> h13\                    | 
                               \                   | 
                    d14 -> h14 |-> h''4            | 
                               /       \           | 
                    d15 -> h15/         \          / 
                                         \        / 
                    ---------            |-> h'''2 
                                         / 
                    d16 -> h16\         / 
                               \       / 
                    d17 -> h17 |-> h''5 
                               / 
 
 
Jerman Blazic, et. al.   Expires June 2, 2008                 [Page 19] 
    
Internet-Draft                  XMLERS                    December 2007 
    

                    d18 -> h18/ 
    
               Figure 1 Generation of the Reduced Hash Tree. 

2.3.3.2. Generation of the Reduced Hash Tree for an Archive Object 

   The following procedure describes generation of the reduced hash tree 
   for an archive object: 

   1. For selected archive object generate the first sequence of the 
      reduced tree, which contains the list of hash values of the data 
      objects contained in the archive object (one or more). Select node 
      with a hash value of the archive object. 

   2. Select all neighboring nodes, which have the same parent as 
      currently selected node and add their hash values as a new 
      sequence to the reduced tree. Select parent node. 

   3. Repeat step 2 until the root is reached. Note that parent nodes 
      are not saved in the list, they are computable. 

   Reduced Hash tree for data group (from the previous example): 

   <Sequence> 
      < DigestValue >h4</ DigestValue > 
      < DigestValue >h5</ DigestValue > 
      < DigestValue >h6</ DigestValue > 
      < DigestValue >h7</ DigestValue > 
   </Sequence> 
   <Sequence> 
      < DigestValue >h8</ DigestValue > 
      < DigestValue >h9</ DigestValue > 
   </Sequence> 
   <Sequence> 
      < DigestValue >h''1</ DigestValue > 
      < DigestValue >h''3</ DigestValue > 
 
 
Jerman Blazic, et. al.   Expires June 2, 2008                 [Page 20] 
    
Internet-Draft                  XMLERS                    December 2007 
    

   </Sequence> 
   <Sequence> 
      < DigestValue >h'''2</ DigestValue > 
   </Sequence> 

2.3.3.3. Calculation of the root hash value from a reduced hash tree 

   The following procedure describes generation of the root hash value 
   from a reduced hash tree: 

   1. Take the first sequence from a reduced hash tree, sort hash items, 
      concatenate them and calculate a hash value with algorithm H (the 
      one used for creation of the hash tree). 

   2. Remove this sequence from the reduced hash tree. 

   3. If a reduced hash tree is not empty, add previously calculated 
      hash value to the first sequence and go to step 1. If a reduced 
      hash tree is empty, then the last calculated hash value is the 
      root hash. 

2.3.4. Cryptographic Information 

   Digital certificates, CRLs or OCSP-Responses needed to verify the 
   time-stamp should be stored in the time-stamp itself. When this is 
   not possible, such data may be stored in <CryptographicInformation> 
   element (as a node value of its <Content> element). 

   The attribute Type is optional and is used to store processing 
   information about type of stored cryptographic information. 

3. Generation of an Evidence Record 

   The generation of an <EvidenceRecord> element can be described as 
   follows: 

 
 
Jerman Blazic, et. al.   Expires June 2, 2008                 [Page 21] 
    
Internet-Draft                  XMLERS                    December 2007 
    

   1. Select an archive object (an archive data object or an archive 
      data object group) to archive. 

   2. Create the initial ATS. This is the first ATS within the initial 
      Archive Time-Stamp Chain of the Archive Time-Stamp Sequence. 

   3. Refresh the Archive Time-Stamp when necessary, by Time-Stamp 
      Renewal or Hash-Tree Renewal. 

   In the case that only essential parts of documents or objects shall 
   be protected the application not defined in this draft must take care 
   of the right extraction of binary data to be covered for generation 
   of evidence record. 

   For example: an application may provide also evidence such as 
   certificates, revocation lists etc., needed to verify and validate 
   signed data objects. This evidence may be added to the archived group 
   of data object and will be protected within initial (and successive) 
   time-stamp(s).  

   Comment [AJB]: For the purpose of extraction inclusion of reference 
   tag should be defined, i.e. information on which data or piece of 
   data is digested. 

3.1. Initial Archive Timestamp 

   Initial ATS relates to a data object or a data object group that 
   represent an archived object. The generation of the initial ATS 
   elements can be done in a single process pass for one or for many 
   archived objects, described as follows: 

   1. Collect one or more archived objects to be time-stamped. 

   2. Select a valid digest algorithm H. The same digest algorithm MUST 
      be used to create the time-stamped values and the time-stamp. 

 
 
Jerman Blazic, et. al.   Expires June 2, 2008                 [Page 22] 
    
Internet-Draft                  XMLERS                    December 2007 
    

   3. Create an input list of digest values of archive objects 
      calculated with H (one digest value for each archived object). 
      Those digest values are the leaves of the hash tree for the whole 
      group of archived objects. 

      A hash tree to be included within the initial ATS of a single 
      archived object is generated as a reduced hash tree from the hash 
      tree for the whole group as defined in 2.3.3. Hash tree may be 
      omitted in the initial archive time-stamp, when an archive object 
      is having a single data object; then the time-stamped value must 
      match the digest value of that single data object. When an archive 
      object is composed of more than one data object, place digest 
      values of all data objects in a group, sort them in binary 
      ascending order, concatenate into single string and generate new 
      digest value. This digest value represents a digest value of that 
      archived object. The list of digest values of data objects must be 
      part of the first sequence in the hash tree (reduced hash tree) 
      for this archive object. 

   4. If there is more than one digest value on the input list, place 
      them in groups and sort each group in binary ascending order. 
      Concatenate group digest values and generate new digest values, 
      which represent inner nodes of the hash tree for the whole group. 
      Repeat this step until there is only one hash value left, which is 
      the root node value of the hash tree. 

   5. Acquire time-stamp for root node value. If the time-stamp is 
      valid, the initial archive time-stamp may be generated. 

3.2. Renewal Process 

   Before the cryptographic algorithms used within the last Archive 
   Time-Stamp becomes weak or the time-stamp certificates are 
   invalidated, the existence of Archive Time-Stamp or archive time-
   stamped data has to be reassured. This can be done by creating a new 
   archive time-stamp. Depending on whether the time-stamp becomes 
 
 
Jerman Blazic, et. al.   Expires June 2, 2008                 [Page 23] 
    
Internet-Draft                  XMLERS                    December 2007 
    

   invalid or the hash algorithm of the hash tree becomes weak, two 
   kinds of renewal processes are possible. 

   If the digest algorithm to be used (H) in the renewal process is the 
   same as one used in the last Archive Time-Stamp (H'), the digest 
   value of that Archive Time-Stamp is calculated and a new Archive 
   Time-Stamp is applied. This process is known simply as time-stamp 
   renewal. 

   The process of hash tree renewal occurs when the new digest algorithm 
   is (due to new cryptographic constrains) different than the one used 
   in the last Archive Time-Stamp (H <> H'). In this case new Archive 
   Time-stamp Chain is created and a digest value for a new Archive 
   Time-Stamp is digested from binary ascending sorted and concatenated: 

   o  digest values of data object(s) calculated with the new digest 
      algorithm and 

   o  digest value of all previously created Archive Time-Stamp Chains 
      calculated with the new digest algorithm (including ordered 
      archive timestamp chains and contained archive time stamps with 
      hash trees, cryptographic information, etc.). 

3.2.1. Time-Stamp Renewal 

   For the purpose of Time-Stamp Renewal, the complete content of the 
   <ArchiveTimeStamp> element of the preceding Archive Timestamp MUST be 
   hashed and time stamped by a new Archive Time-Stamp. A digest value 
   to be time-stamped within a new ATS is calculated as follows: 

   1. If the current ATS does not contain needed proof for long-term 
      formal validation of its time-stamp token within the time-stamp 
      token, collect needed data such as root certificates, certificate 
      revocation lists, etc., and include them in 
      <CryptographicInformation> element of the last Archive Time-Stamp 
      (each data object into separate <CryptographicInformation>). 
 
 
Jerman Blazic, et. al.   Expires June 2, 2008                 [Page 24] 
    
Internet-Draft                  XMLERS                    December 2007 
    

   2. Digest value is calculated from binary representation of the last 
      <ArchiveTimeStamp> element including added cryptographic 
      information. Acquire time-stamp for the calculated digest value. 
      If the time-stamp is valid, the new archive time-stamp may be 
      generated. 

   3. Increase the value order of the new ATS for one and place the new 
      ATS into last Archive Time-Stamp Chain. 

   The new ATS and its hash tree MUST use the same digest algorithm as 
   the preceding one, which is specified in the <DigestMethod> element 
   of the ATSC. 

3.2.2. Hash Tree Renewal 

   Hash tree renewal process is performed in case when the used hash 
   algorithm becomes weak. This process takes into account values of all 
   preceding Archive Time-Stamps as well as values of archive data 
   objects (covered by Archive Time-Stamp). Hash tree renewal procedure 
   is as follows: 

   1. If the current ATS does not contain needed proof for long-term 
      formal validation of its time-stamp token within the time-stamp 
      token, collect needed data such as root certificates, certificate 
      revocation lists, etc., and include them in 
      <CryptographicInformation> element of the last Archive Time-Stamp 
      (each data object into separate <CryptographicInformation>). 

   2. Select a (new) secure hash algorithm H and select data objects 
      d(i) referred to by initial Archive Time-Stamp. Generate hash 
      values h(i) = H(d(i)). In case the initial Archive Time-Stamp is 
      applied for more than one data object (data object group), then 
      more than one hash values are generated i.e., h(i_a), h(i_b).., 
      h(i_n) 


 
 
Jerman Blazic, et. al.   Expires June 2, 2008                 [Page 25] 
    
Internet-Draft                  XMLERS                    December 2007 
    

   3. Calculate the digest value hatsc(i) = H(ATSC(i))of the 
      canonicalized binary representation of the each previously 
      generated element <ArchiveTimeStampChain>. Note that Archive 
      Timestamp Chains and Archive Time stamps within MUST be ordered, 
      each respectively to its Order attribute. Binary sort calculated 
      digest values, concatenate them and calculate digest value 
      H(ATSCs). This is the digest value of all previously generated 
      ATSCs. 

   4. Binary ascending sort, concatenate all h(i) and H(ATSCs)and 
      generate digest value for the new archive time-stamp h(AO)= H( 
      binary ascending sorted (h(1),...,h(i),H(ATSCs)) 

      If this is a case of a group renewal in a single process pass, 
      build a new hash tree, where each h(AO), generated as described 
      above, is the tree leave value (it is treated as an archive object 
      hash for the new ATSC). The first hash value list in the reduced 
      hash tree for separate ATSs must contain h(i) for each data object 
      and H(ATSCs). 

   5. Create new <ArchiveTimeStampChain>, and place it into the existing 
      <ArchiveTimeStampSequence> as a last child. Create new 
      <ArchiveTimeStamp> element and place it into created 
      <ArchiveTimeStampChain> element. 

4. Verification of an Evidence Record 

   An Evidence Record shall prove that an archive object existed and has 
   not been changed from the time of a time-stamp token within the first 
   ATS. Every ATS, but the last, must be valid at the time of the next 
   ATS. In order to complete the non-repudiation proof for the data 
   objects, the last ATS has to be valid at the time when verification 
   is performed. 



 
 
Jerman Blazic, et. al.   Expires June 2, 2008                 [Page 26] 
    
Internet-Draft                  XMLERS                    December 2007 
    

   To verify the validity of an Evidence Record start with the first ATS 
   till the last ATS (ordered by attribute Order) and perform 
   verification for each ATS, as follows: 

   1. Get a digest method identifier H from the <DigestMethod> element 
      of the current ATS. 

   2. Make a list of digest values of objects that MUST be protected 
      with this ATS as follows: 

       a. If this ATS is the first in the ATSC chain: 

           i. Calculate digest values of archive data objects with H 
               and add each digest value to the digest values of 
               protected objects. 

          ii. If this is not the first ATS of the first ATSC in the 
               ATSSeq sequence (not the initial ATS), calculate digest 
               values with H of all ATSSeq's previous ATSCs (calculate 
               digest values of all previous ATSCs). Binary sort them in 
               ascending order, concatenate them and calculate a new 
               digest value. Add this digest value to the list of digest 
               values of protected objects. 

       b. If this ATS is not the first in the ATSC chain: 

           i. Calculate digest value with H of the previous ATS 
               element. Add this digest value to the list of digest 
               values of protected objects. 

   3. Get a first sequence of the hash tree of this ATS. If this ATS has 
      no hash tree element then: 

       a. If this ATS is not the first in the ATSSeq, exit with a 
          negative result. 

 
 
Jerman Blazic, et. al.   Expires June 2, 2008                 [Page 27] 
    
Internet-Draft                  XMLERS                    December 2007 
    

       b. If this ATS is the first in the ATSSeq, there must be only one 
          protected data object. The digest value of that data object 
          must be the same as the time-stamped value. If not, exit with 
          negative result.  

   4. If there is a digest value on a list of digest values of protected 
      objects, which can not be found on a first sequence of the hash 
      tree, exit with a negative result. Get the hash tree from the 
      current ATS and use H to calculate the root hash value (see 
      section 2.3.3.3. ) 

   5. Get time stamped value from the time stamp token. If calculated 
      root hash value from the hash tree does not match time stamped 
      value, exit with a negative result. 

   6. Verify timestamp cryptographically and formally (validate used 
      certificate and its chain). 

   7. If this ATS is the last ATS, check formal validity for the current 
      time (now), or get "valid from" time of the next ATS and verify 
      formal validity at that specific time. 

   8. If the needed information to verify formal validity is not found 
      within the timestamp or within its Cryptographic Information 
      section of ATS, exit with a negative result. 

5. XSD Schema for the Evidence Record 

   <?xml version="1.0" encoding="UTF-8" ?> 

   <xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema" 
   xmlns="http://www.setcce.org/schemas/ers" 
   xmlns:NS="http://www.setcce.org/schemas/ers" 
   targetNamespace="http://www.setcce.org/schemas/ers" 
   elementFormDefault="qualified" attributeFormDefault="unqualified"> 

 
 
Jerman Blazic, et. al.   Expires June 2, 2008                 [Page 28] 
    
Internet-Draft                  XMLERS                    December 2007 
    

   <xs:element name="EvidenceRecord"> 
     <xs:complexType><xs:sequence> 
     <xs:element name="CanonicalizationMethod" 
     type="CanonicalizationMethodType" minOccurs="1" 
     maxOccurs="1"></xs:element> 
     <xs:element name="ArchiveTimeStampSequence" minOccurs="1" 
     maxOccurs="1"> 
      <xs:complexType><xs:sequence> 
      <xs:element name="ArchiveTimeStampChain" minOccurs="0" 
      maxOccurs="unbounded"> 
         <xs:complexType><xs:sequence> 
         <xs:element name="ArchiveTimeStamp" minOccurs="1" 
         maxOccurs="unbounded"> 
            <xs:complexType><xs:sequence> 
            <xs:element name="HashTree" minOccurs="0" maxOccurs="1" 
            type="HashTreeType" /> 
            <xs:element name="TimeStamp" minOccurs="1"  maxOccurs="1"> 
               <xs:complexType mixed="true"><xs:sequence> 
               <xs:any namespace="##other" minOccurs="0" 
               maxOccurs="unbounded" /> 
               </xs:sequence></xs:complexType> 
               </xs:element> 
               <xs:element name="CryptographicInformation" minOccurs="0" 
               maxOccurs="unbounded"> 
               <xs:complexType mixed="true"><xs:sequence> 
               <xs:any namespace="##other" minOccurs="0" 
               maxOccurs="unbounded" /> 
               </xs:sequence></xs:complexType> 
               </xs:element> 
            </xs:sequence> 
         <xs:attribute name="Order" type="xs:integer" use="required" /> 
         </xs:complexType> 
 
 
Jerman Blazic, et. al.   Expires June 2, 2008                 [Page 29] 
    
Internet-Draft                  XMLERS                    December 2007 
    

      </xs:element> 
      <xs:element name="DigestMethod" type="DigestMethodType" />   
      </xs:sequence> 
      <xs:attribute name="Order" type="xs:integer" use="required" /> 
      </xs:complexType> 
      </xs:element> 
      </xs:sequence> 
      </xs:complexType> 
      </xs:element> 
      </xs:sequence> 
   <xs:attribute name="Version" type="xs:string" use="required" /> 
   </xs:complexType> 
   </xs:element> 
   <!-- TYPE DEFINITIONS--> 
   <xs:complexType name="DigestMethodType" mixed="true"> 
   <xs:sequence> 
   <xs:any namespace="##other" minOccurs="0" maxOccurs="unbounded" /> 
   </xs:sequence> 
   <xs:attribute name="Algorithm" type="xs:anyURI" use="required" /> 
   </xs:complexType> 
    
   <xs:complexType name="CanonicalizationMethodType" mixed="true"> 
   <xs:sequence> 
   <xs:any namespace="##any" minOccurs="0" maxOccurs="unbounded" /> 
   </xs:sequence> 
   <xs:attribute name="Algorithm" type="xs:anyURI" use="required" /> 
   </xs:complexType> 
    
   <xs:complexType name="HashTreeType" mixed="true"> 
   <xs:sequence> 
   <xs:element name="Sequence" minOccurs="1" maxOccurs="unbounded"> 
 
 
Jerman Blazic, et. al.   Expires June 2, 2008                 [Page 30] 
    
Internet-Draft                  XMLERS                    December 2007 
    

   <xs:complexType><xs:sequence> 
   <xs:element name="DigestValue" minOccurs="1" maxOccurs="unbounded" 
   type="xs:base64Binary"></xs:element> 
   </xs:sequence> 
   </xs:complexType> 
   </xs:element> 
   </xs:sequence> 
   </xs:complexType> 
   </xs:schema> 
    

6. Security Considerations 

   TBA 

7. IANA Considerations 

   TBA 

8. Conclusions 

   TBA 

9. Acknowledgments 

   This document was prepared using 2-Word-v2.0.template.dot. 








 
 
Jerman Blazic, et. al.   Expires June 2, 2008                 [Page 31] 
    
Internet-Draft                  XMLERS                    December 2007 
    

APPENDIX A: First Appendix 

   TBA 

    































 
 
Jerman Blazic, et. al.   Expires June 2, 2008                 [Page 32] 
    
Internet-Draft                  XMLERS                    December 2007 
    

10. References 

   [I-D.ietf-ltans-ers] Brandner, R., "Evidence Record Syntax (ERS)", 
             draft-ietf-ltans-ers-11 (work in progress), February 2007 

   [I-D.ietf-ltans-ltap] Jerman-Blazic, A., "Long-term Archive Protocol 
             (LTAP)", draft-ietf-ltans-ltap-03 (work in progress), 
             October 2006. 

   [I-D.ietf-ltans-reqs] Wallace, C., "Long-Term Archive Service 
             Requirements", draft-ietf-ltans-reqs-10 (work in progress), 
             December 2006. 

   [RFC2119] Bradner, S., "Key words for use in RFCs to Indicate 
             Requirement Levels", BPC 14, RFC 2119, March 1997. 

   [RFC3161] Adams, C., Cain, P., Pinkas, D., and R. Zuccherato, 
             "Internet X.509 Public Key Infrastructure Time-Stamp 
             Protocol (TSP)", RFC 3161, August 2001. 

   [RFC3280] Housley, R., Polk, W., Ford, W., and D. Solo, "Internet 
             X.509 Public Key Infrastructure Certificate and Certificate 
             Revocation List (CRL) Profile", RFC 3280, April 2002. 

   [RFC3852] Housley, R., "Cryptographic Message Syntax (CMS)", RFC 
             3852, July 2004. 

   [XMLC14N] Boyer, J., "Canonical XML", W3C Recommendation, March 2001.  

   [XMLDsig] Eastlake, D., "XML-Signature Syntax and 
             Processing",XMLDsig, July 2006. 

    
      


 
 
Jerman Blazic, et. al.   Expires June 2, 2008                 [Page 33] 
    
Internet-Draft                  XMLERS                    December 2007 
    

    

10.1. Normative References 

   TBA 

10.2. Informative References 

   [MER1980] Merkle, R., "Protocols for Public Key Cryptosystems, 
             Proceedings of the 1980 IEEE Symposium on Security and 
             Privacy (Oakland, CA, USA)", pages 122-134, April 1980. 

   [MIME]    Freed, N., "Multipurpose Internet Mail Extensions (MIME) 
             Part One: Format of Internet Message Bodies", RFC 2045, 
             November 1996. 

   [RFC3470] Hollenbeck, S., " Guidelines for the Use of Extensible 
             Markup Language (XML) within IETF Protocols ", RFC 3470, 
             January 2003. 

    

Author's Addresses 

   Aleksej Jerman Blazic 
   SETCCE 
   Jamova 39 
   1000 Ljubljana 
   Slovenia 
    
   Phone: +386 (0) 1 477 3505  
   Fax:   +386 (0) 1 477 3911  
   Email: aljosa@setcce.si 
    


 
 
Jerman Blazic, et. al.   Expires June 2, 2008                 [Page 34] 
    
Internet-Draft                  XMLERS                    December 2007 
    

   Svetlana Saljic  
   SETCCE 
   Jamova 39 
   1000 Ljubljana 
   Slovenia 
    
   Phone: +386 (0) 1 477 3861  
   Fax:   +386 (0) 1 477 3911  
   Email: svetlana.saljic@setcce.si 
    

   Tobias Gondrom 
   Open Text Corporation 
   Werner-von-Siemens-Ring 20 
   Grasbrunn, Munich D-85630 
   Germany 
    
   Phone: +49 (0) 89 4629 1816 
   Fax:   +49 (0) 89 4629 33 1816 
   Email: tobias.gondrom@opentext.com 
    

Intellectual Property Statement 

   The IETF takes no position regarding the validity or scope of any 
   Intellectual Property Rights or other rights that might be claimed to 
   pertain to the implementation or use of the technology described in 
   this document or the extent to which any license under such rights 
   might or might not be available; nor does it represent that it has 
   made any independent effort to identify any such rights.  Information 
   on the procedures with respect to rights in RFC documents can be 
   found in BCP 78 and BCP 79. 

   Copies of IPR disclosures made to the IETF Secretariat and any 
   assurances of licenses to be made available, or the result of an 
   attempt made to obtain a general license or permission for the use of 
 
 
Jerman Blazic, et. al.   Expires June 2, 2008                 [Page 35] 
    
Internet-Draft                  XMLERS                    December 2007 
    

   such proprietary rights by implementers or users of this 
   specification can be obtained from the IETF on-line IPR repository at 
   http://www.ietf.org/ipr. 

   The IETF invites any interested party to bring to its attention any 
   copyrights, patents or patent applications, or other proprietary 
   rights that may cover technology that may be required to implement 
   this standard.  Please address the information to the IETF at 
   ietf-ipr@ietf.org. 

Disclaimer of Validity 

   This document and the information contained herein are provided on an 
   "AS IS" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS 
   OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY, THE IETF TRUST AND 
   THE INTERNET ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS 
   OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF 
   THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED 
   WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. 

Copyright Statement 

   Copyright (C) The IETF Trust (2007). 

   This document is subject to the rights, licenses and restrictions 
   contained in BCP 78, and except as set forth therein, the authors 
   retain all their rights. 

Acknowledgment 

   Funding for the RFC Editor function is currently provided by the 
   Internet Society. 

    


 
 
Jerman Blazic, et. al.   Expires June 2, 2008                 [Page 36] 
    
