json-path = root-selector *(dot-selector        /
                               dot-wild-selector   /
                               index-selector      /
                               index-wild-selector /
                               union-selector      /
                               slice-selector      /
                               descendant-selector /
                               filter-selector)

root-selector  = "$"

dot-selector    = "." dot-member-name
dot-member-name = name-first *name-char
name-first =
                         ALPHA /
                         "_"   /           ; _
                         %x80-10FFFF       ; any non-ASCII Unicode character
name-char = DIGIT / name-first

DIGIT           =  %x30-39              ; 0-9
ALPHA           =  %x41-5A / %x61-7A    ; A-Z / a-z
dot-wild-selector    = "." "*"            ;  dot followed by asterisk

index-selector      = "[" (quoted-member-name / element-index) "]"

quoted-member-name  = string-literal

string-literal      = %x22 *double-quoted %x22 /       ; "string"
                         %x27 *single-quoted %x27         ; 'string'

double-quoted       = unescaped /
                         %x27      /                       ; '
                         ESC %x22  /                       ; \"
                         ESC escapable

single-quoted       = unescaped /
                         %x22      /                       ; "
                         ESC %x27  /                       ; \'
                         ESC escapable

ESC                 = %x5C                              ; \  backslash

unescaped           = %x20-21 /                         ; s. RFC 8259
                         %x23-26 /                         ; omit "
                         %x28-5B /                         ; omit '
                         %x5D-10FFFF                       ; omit \

escapable           = ( %x62 / %x66 / %x6E / %x72 / %x74 / ; \b \f \n \r \t
                             ; b /         ;  BS backspace U+0008
                             ; t /         ;  HT horizontal tab U+0009
                             ; n /         ;  LF line feed U+000A
                             ; f /         ;  FF form feed U+000C
                             ; r /         ;  CR carriage return U+000D
                             "/" /          ;  /  slash (solidus)
                             "\" /          ;  \  backslash (reverse solidus)
                             (%x75 hexchar) ;  uXXXX      U+XXXX
                         )

hexchar = non-surrogate / (high-surrogate "\" %x75 low-surrogate)
non-surrogate = ((DIGIT / "A"/"B"/"C" / "E"/"F") 3HEXDIG) /
                    ("D" %x30-37 2HEXDIG )
high-surrogate = "D" ("8"/"9"/"A"/"B") 2HEXDIG
low-surrogate = "D" ("C"/"D"/"E"/"F") 2HEXDIG

HEXDIG = DIGIT / "A" / "B" / "C" / "D" / "E" / "F"

element-index   = int                             ; decimal integer

int             = ["-"] ( "0" / (DIGIT1 *DIGIT) ) ; -  optional
DIGIT1          = %x31-39                         ; 1-9 non-zero digit

index-wild-selector    = "[" "*" "]"  ;  asterisk enclosed by brackets

slice-selector = "[" slice-index "]"

slice-index    = ws [start] ws ":" ws [end] [ws ":" ws [step] ws]

start          = int       ; included in selection
end            = int       ; not included in selection
step           = int       ; default: 1

ws             = *( %x20 / ; Space
                       %x09 / ; Horizontal tab
                       %x0A / ; Line feed or New line
                       %x0D ) ; Carriage return
n_start = Normalize(start, len)
n_end = Normalize(end, len)

lower = MIN(MAX(n_start, 0), len)
upper = MIN(MAX(n_end, 0), len)
upper = MIN(MAX(n_start, -1), len-1)
lower = MIN(MAX(n_end, -1), len-1)
i = lower
i = i + step
i = upper
i = i + step
descendant-selector = ".." ( dot-member-name      /  ; ..<name>
                                index-selector       /  ; ..[<index>]
                                index-wild-selector  /  ; ..[*]
                                "*"                     ; ..*
                              )

union-selector = "[" ws union-entry 1*(ws "," ws union-entry) ws "]"

union-entry    =  ( quoted-member-name /
                       element-index      /
                       slice-index
                     )

      Task (T1): This, besides slice-index, is currently one of only two
      places in the document that mentions whitespace.  Whitespace needs
      to be handled throughout the ABNF syntax.  Room Consensus at the
      2021-06-15 interim was that JSONPath generally is generous with
      allowing insignificant whitespace throughout.  Minimizing the
      impact of the many whitespace insertion points by choosing a rule
      name such as "S" was mentioned.  Some conventions will probably
      help with minimizing the number of places where S needs to be
      inserted.
filter-selector    = "[?" boolean-expr "]"

boolean-expr     = logical-or-expr
logical-or-expr  = logical-and-expr *("||" logical-and-expr)
                                                         ; disjunction
                                                         ; binds less tightly than conjunction
logical-and-expr = basic-expr *("&&" basic-expr)      ; conjunction
                                                         ; binds more tightly than disjunction

basic-expr   = exist-expr / paren-expr / (neg-op paren-expr) / relation-expr
exist-expr   = [neg-op] path                          ; path existence or non-existence
path         = rel-path / json-path
rel-path     = "@" *(dot-selector / index-selector)
paren-expr   = "(" boolean-expr ")"                   ; parenthesized expression
neg-op       = "!"                                    ; not operator

relation-expr = comp-expr /                           ; comparison test
                   regex-expr /                          ; regular expression test
                   contain-expr                          ; containment test

comp-expr    = comparable comp-op comparable
comparable   = number / string-literal /              ; primitive ...
                  true / false / null /                  ; values only
                  path                                   ; path value
comp-op      = "==" / "!=" /                          ; comparison ...
                  "<"  / ">"  /                          ; operators
                  "<=" / ">="

regex-expr   = regex-op regex
regex-op     = "=~"                                   ; regular expression match
regex        = <TO BE DEFINED>

contain-expr = containable in-op container
containable  = rel-path / json-path /                 ; path to primitive value
                  number / string-literal
in-op        = " in "                                 ; in operator
container    = rel-path / json-path / array-literal   ; resolves to array

number = [ minus ] jsint [ frac ] [ exp ]
decimal-point = %x2E       ; .
digit1-9 = %x31-39         ; 1-9
e = %x65 / %x45            ; e E
exp = e [ minus / plus ] 1*DIGIT
frac = decimal-point 1*DIGIT
jsint = zero / ( digit1-9 *DIGIT )
minus = %x2D               ; -
plus = %x2B                ; +
zero = %x30                ; 0

false = %x66.61.6c.73.65   ; false
null  = %x6e.75.6c.6c      ; null
true  = %x74.72.75.65      ; true
