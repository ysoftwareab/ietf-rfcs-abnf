

TLS Working Group                                               V. Gupta
Internet-Draft                                                  Sun Labs
Expires: December 2003                                   S. Blake-Wilson
                                                                     BCI
                                                              B. Moeller
                                       Technische Universitaet Darmstadt
                                                                 C. Hawk
                                                  Independent Consultant
                                                               June 2003


                       ECC Cipher Suites for TLS
                      <draft-ietf-tls-ecc-03.txt>

Status of this Memo

   This document is an Internet-Draft and is in full conformance with
   all provisions of Section 10 of RFC2026.

   Internet-Drafts are working documents of the Internet Engineering
   Task Force (IETF), its areas, and its working groups.  Note that
   other groups may also distribute working documents as Internet-
   Drafts.

   Internet-Drafts are draft documents valid for a maximum of six months
   and may be updated, replaced, or obsoleted by other documents at any
   time.  It is inappropriate to use Internet-Drafts as reference
   material or to cite them other than as "work in progress."

   The list of current Internet-Drafts can be accessed at http://
   www.ietf.org/ietf/1id-abstracts.txt.

   The list of Internet-Draft Shadow Directories can be accessed at
   http://www.ietf.org/shadow.html.

   This Internet-Draft will expire on September 30, 2003.

Copyright Notice

   Copyright (C) The Internet Society (2003).  All Rights Reserved.

Abstract

   This document describes new key exchange algorithms based on Elliptic
   Curve Cryptography (ECC) for the TLS (Transport Layer Security)
   protocol.  In particular, it specifies the use of Elliptic Curve
   Diffie-Hellman (ECDH) key agreement in a TLS handshake and the use of
   Elliptic Curve Digital Signature Algorithm (ECDSA) as a new
   authentication mechanism.



Gupta, et al.            Expires December 2003                  [Page 1]

Internet-Draft          ECC Cipher Suites for TLS              June 2003


   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
   document are to be interpreted as described in RFC 2119 [1].

   Please send comments on this document to the TLS mailing list.

Table of Contents

   1.  Introduction . . . . . . . . . . . . . . . . . . . . . . . . .  3
   2.  Key Exchange Algorithms  . . . . . . . . . . . . . . . . . . .  5
   2.1 ECDH_ECDSA . . . . . . . . . . . . . . . . . . . . . . . . . .  6
   2.2 ECDHE_ECDSA  . . . . . . . . . . . . . . . . . . . . . . . . .  7
   2.3 ECDH_RSA . . . . . . . . . . . . . . . . . . . . . . . . . . .  7
   2.4 ECDHE_RSA  . . . . . . . . . . . . . . . . . . . . . . . . . .  7
   2.5 ECDH_anon  . . . . . . . . . . . . . . . . . . . . . . . . . .  7
   3.  Client Authentication  . . . . . . . . . . . . . . . . . . . .  9
   3.1 ECDSA_sign . . . . . . . . . . . . . . . . . . . . . . . . . .  9
   3.2 ECDSA_fixed_ECDH . . . . . . . . . . . . . . . . . . . . . . . 10
   3.3 RSA_fixed_ECDH . . . . . . . . . . . . . . . . . . . . . . . . 10
   4.  Data Structures and Computations . . . . . . . . . . . . . . . 11
   4.1 Server Certificate . . . . . . . . . . . . . . . . . . . . . . 11
   4.2 Server Key Exchange  . . . . . . . . . . . . . . . . . . . . . 12
   4.3 Certificate Request  . . . . . . . . . . . . . . . . . . . . . 17
   4.4 Client Certificate . . . . . . . . . . . . . . . . . . . . . . 18
   4.5 Client Key Exchange  . . . . . . . . . . . . . . . . . . . . . 19
   4.6 Certificate Verify . . . . . . . . . . . . . . . . . . . . . . 20
   4.7 Elliptic Curve Certificates  . . . . . . . . . . . . . . . . . 22
   4.8 ECDH, ECDSA and RSA Computations . . . . . . . . . . . . . . . 22
   5.  Cipher Suites  . . . . . . . . . . . . . . . . . . . . . . . . 23
   6.  Security Considerations  . . . . . . . . . . . . . . . . . . . 25
   7.  Intellectual Property Rights . . . . . . . . . . . . . . . . . 26
   8.  Acknowledgments  . . . . . . . . . . . . . . . . . . . . . . . 27
       References . . . . . . . . . . . . . . . . . . . . . . . . . . 28
       Authors' Addresses . . . . . . . . . . . . . . . . . . . . . . 29
       Full Copyright Statement . . . . . . . . . . . . . . . . . . . 30
















Gupta, et al.            Expires December 2003                  [Page 2]

Internet-Draft          ECC Cipher Suites for TLS              June 2003


1. Introduction

   Elliptic Curve Cryptography (ECC) is emerging as an attractive
   public-key cryptosystem for mobile/wireless environments.  Compared
   to currently prevalent cryptosystems such as RSA, ECC offers
   equivalent security with smaller key sizes.  This is illustrated in
   the following table, based on [2], which gives approximate comparable
   key sizes for symmetric- and asymmetric-key cryptosystems based on
   the best-known algorithms for attacking them.

                   Symmetric    |  ECC    |  DH/DSA/RSA
                   -------------+---------+------------
                      80        |  163    |  1024
                     128        |  283    |  3072
                     192        |  409    |  7680
                     256        |  571    |  15360

                  Table 1: Comparable key sizes (in bits)


   Smaller key sizes result in power, bandwidth and computational
   savings that make ECC especially attractive for constrained
   environments.

   This document describes additions to TLS to support ECC.  In
   particular, it defines

   o  the use of the Elliptic Curve Diffie-Hellman (ECDH) key agreement
      scheme with long-term or ephemeral keys to establish the TLS
      premaster secret, and

   o  the use of fixed-ECDH certificates and ECDSA for authentication of
      TLS peers.

   The remainder of this document is organized as follows.  Section 2
   provides an overview of ECC-based key exchange algorithms for TLS.
   Section 3 describes the use of ECC certificates for client
   authentication.  Section 4 specifies various data structures needed
   for an ECC-based handshake, their encoding in TLS messages and the
   processing of those messages.  Section 5 defines new ECC-based cipher
   suites and identifies a small subset of these as recommended for all
   implementations of this specification.  Section 6, Section 7 and
   Section 8 mention security considerations, intellectual property
   rights, and acknowledgments, respectively.  This is followed by a
   list of references cited in this document and the authors' contact
   information.

   Implementation of this specification requires familiarity with both



Gupta, et al.            Expires December 2003                  [Page 3]

Internet-Draft          ECC Cipher Suites for TLS              June 2003


   TLS [3] and ECC [5][6][7][9] .


















































Gupta, et al.            Expires December 2003                  [Page 4]

Internet-Draft          ECC Cipher Suites for TLS              June 2003


2. Key Exchange Algorithms

   This document introduces five new ECC-based key exchange algorithms
   for TLS.  All of them use ECDH to compute the TLS premaster secret
   and differ only in the lifetime of ECDH keys (long-term or ephemeral)
   and the mechanism (if any) used to authenticate them.  The derivation
   of the TLS master secret from the premaster secret and the subsequent
   generation of bulk encryption/MAC keys and initialization vectors is
   independent of the key exchange algorithm and not impacted by the
   introduction of ECC.

    The table below summarizes the new key exchange algorithms which
   mimic DH_DSS, DH_RSA, DHE_DSS, DHE_RSA and DH_anon (see [3]),
   respectively.

          Key
          Exchange
          Algorithm           Description
          ---------           -----------

          ECDH_ECDSA          Fixed ECDH with ECDSA-signed certificates.

          ECDHE_ECDSA         Ephemeral ECDH with ECDSA signatures.

          ECDH_RSA            Fixed ECDH with RSA-signed certificates.

          ECDHE_RSA           Ephemeral ECDH with RSA signatures.

          ECDH_anon           Anonymous ECDH, no signatures.


                     Table 2: ECC key exchange algorithms


   Note that the anonymous key exchange algorithm does not provide
   authentication of the server or the client.  Like other anonymous TLS
   key exchanges, it is subject to man-in-the-middle attacks.
   Implementations of this algorithm SHOULD provide authentication by
   other means.

   Note that there is no structural difference between ECDH and ECDSA
   keys.  A certificate issuer may use X509.v3 keyUsage and
   extendedKeyUsage extensions to restrict the use of an ECC public key
   to certain computations.  This document refers to an ECC key as ECDH-
   capable if its use in ECDH is permitted.  ECDSA-capable is defined
   similarly.





Gupta, et al.            Expires December 2003                  [Page 5]

Internet-Draft          ECC Cipher Suites for TLS              June 2003


              Client                                        Server
              ------                                        ------

              ClientHello          -------->
                                                       ServerHello
                                                      Certificate*
                                                ServerKeyExchange*
                                              CertificateRequest*+
                                   <--------       ServerHelloDone
              Certificate*+
              ClientKeyExchange
              CertificateVerify*+
              [ChangeCipherSpec]
              Finished             -------->
                                                [ChangeCipherSpec]
                                   <--------              Finished

              Application Data     <------->      Application Data

                 Figure 1: Message flow in a full TLS handshake
                   * message is not sent under some conditions
                   + message is not sent unless the client is
                     authenticated


   Figure 1 shows all messages involved in the TLS key establishment
   protocol (aka full handshake).  The addition of ECC has direct impact
   only on the the server's Certificate message, the ServerKeyExchange,
   the ClientKeyExchange, the CertificateRequest, the client's
   Certificate message, and the CertificateVerify.  Next, we describe
   each ECC key exchange algorithm in greater detail in terms of the
   content and processing of these messages.  For ease of exposition, we
   defer discussion of client authentication and associated messages
   (identified with a + in Figure 1) until Section 3.

2.1 ECDH_ECDSA

   In ECDH_ECDSA, the server's certificate MUST contain an ECDH-capable
   public key and be signed with ECDSA.

   A ServerKeyExchange MUST NOT be sent (the server's certificate
   contains all the necessary keying information required by the client
   to arrive at the premaster secret).

   The client MUST generate an ECDH key pair on the same curve as the
   server's long-term public key and send its public key in the
   ClientKeyExchange message (except when using client authentication
   algorithm ECDSA_fixed_ECDH or RSA_fixed_ECDH, in which case the



Gupta, et al.            Expires December 2003                  [Page 6]

Internet-Draft          ECC Cipher Suites for TLS              June 2003


   modifications from section Section 3.2 or Section 3.3 apply).

   Both client and server MUST perform an ECDH operation and use the
   resultant shared secret as the premaster secret.  All ECDH
   calculations are performed as specified in Section 4.8

2.2 ECDHE_ECDSA

   In ECDHE_ECDSA, the server's certificate MUST contain an ECDSA-
   capable public key and be signed with ECDSA.

   The server MUST send its ephemeral ECDH public key and a
   specification of the corresponding curve in the ServerKeyExchange
   message.  These parameters MUST be signed with ECDSA using the
   private key corresponding to the public key in the server's
   Certificate.

   The client MUST generate an ECDH key pair on the same curve as the
   server's ephemeral ECDH key and send its public key in the
   ClientKeyExchange message.

   Both client and server MUST perform an ECDH operation (Section 4.8)
   and use the resultant shared secret as the premaster secret.

2.3 ECDH_RSA

   This key exchange algorithm is the same as ECDH_ECDSA except the
   server's certificate MUST be signed with RSA rather than ECDSA.

2.4 ECDHE_RSA

   This key exchange algorithm is the same as ECDHE_ECDSA except the
   server's certificate MUST contain an RSA public key authorized for
   signing and the signature in the ServerKeyExchange message MUST be
   computed with the corresponding RSA private key.  The server
   certificate MUST be signed with RSA.

2.5 ECDH_anon

   In ECDH_anon, the server's Certificate, the CertificateRequest, the
   client's Certificate, and the CertificateVerify messages MUST NOT be
   sent.

   The server MUST send an ephemeral ECDH public key and a specification
   of the corresponding curve in the ServerKeyExchange message.  These
   parameters MUST NOT be signed.

   The client MUST generate an ECDH key pair on the same curve as the



Gupta, et al.            Expires December 2003                  [Page 7]

Internet-Draft          ECC Cipher Suites for TLS              June 2003


   server's ephemeral ECDH key and send its public key in the
   ClientKeyExchange message.

   Both client and server MUST perform an ECDH operation and use the
   resultant shared secret as the premaster secret.  All ECDH
   calculations are performed as specified in Section 4.8













































Gupta, et al.            Expires December 2003                  [Page 8]

Internet-Draft          ECC Cipher Suites for TLS              June 2003


3. Client Authentication

   This document defines three new client authentication mechanisms
   named after the type of client certificate involved: ECDSA_sign,
   ECDSA_fixed_ECDH and RSA_fixed_ECDH.  The ECDSA_sign mechanism is
   usable with any of the non-anonymous ECC key exchange algorithms
   described in Section 2 as well as other non-anonymous (non-ECC) key
   exchange algorithms defined in TLS [3].  The ECDSA_fixed_ECDH and
   RSA_fixed_ECDH mechanisms are usable with ECDH_ECDSA and ECDH_RSA.
   Their use with ECDHE_ECDSA and ECDHE_RSA is prohibited because the
   use of a long-term ECDH client key would jeopardize the forward
   secrecy property of these algorithms.

   The server can request ECC-based client authentication by including
   one or more of these certificate types in its CertificateRequest
   message.  The server MUST NOT include any certificate types that are
   prohibited for the negotiated key exchange algorithm.  The client
   must check if it possesses a certificate appropriate for any of the
   methods suggested by the server and is willing to use it for
   authentication.

   If these conditions are not met, the client should send a client
   Certificate message containing no certificates.  In this case, the
   ClientKeyExchange should be sent as described in Section 2 and the
   CertificateVerify should not be sent.  If the server requires client
   authentication, it may respond with a fatal handshake failure alert.

   If the client has an appropriate certificate and is willing to use it
   for authentication, it MUST send that certificate in the client's
   Certificate message (as per Section 4.4) and prove possession of the
   private key corresponding to the certified key.  The process of
   determining an appropriate certificate and proving possession is
   different for each authentication mechanism and described below.

   NOTE: It is permissible for a server to request (and the client to
   send) a client certificate of a different type than the server
   certificate.

3.1 ECDSA_sign

   To use this authentication mechanism, the client MUST possess a
   certificate containing an ECDSA-capable public key and signed with
   ECDSA.

   The client MUST prove possession of the private key corresponding to
   the certified key by including a signature in the CertificateVerify
   message as described in Section 4.6.




Gupta, et al.            Expires December 2003                  [Page 9]

Internet-Draft          ECC Cipher Suites for TLS              June 2003


3.2 ECDSA_fixed_ECDH

   To use this authentication mechanism, the client MUST possess a
   certificate containing an ECDH-capable public key and that
   certificate MUST be signed with ECDSA.  Furthermore, the client's
   ECDH key MUST be on the same elliptic curve as the server's long-term
   (certified) ECDH key.

   When using this authentication mechanism, the client MUST send an
   empty ClientKeyExchange as described in Section 4.5 and MUST NOT send
   the CertificateVerify message.  The ClientKeyExchange is empty since
   the client's ECDH public key required by the server to compute the
   premaster secret is available inside the client's certificate.  The
   client's ability to arrive at the same premaster secret as the server
   (demonstrated by a successful exchange of Finished messages) proves
   possession of the private key corresponding to the certified public
   key and the CertificateVerify message is unnecessary.

3.3 RSA_fixed_ECDH

   This authentication mechanism is identical to ECDSA_fixed_ECDH except
   the client's certificate MUST be signed with RSA.





























Gupta, et al.            Expires December 2003                 [Page 10]

Internet-Draft          ECC Cipher Suites for TLS              June 2003


4. Data Structures and Computations

   This section specifies the data structures and computations used by
   ECC-based key mechanisms specified in Section 2 and Section 3.  The
   presentation language used here is the same as that used in TLS [3].
   Since this specification extends TLS, these descriptions should be
   merged with those in the TLS specification and any others that extend
   TLS.  This means that enum types may not specify all possible values
   and structures with multiple formats chosen with a select() clause
   may not indicate all possible cases.

4.1 Server Certificate

   When this message is sent:

   This message is sent in all non-anonymous ECC-based key exchange
   algorithms.

   Meaning of this message:

   This message is used to authentically convey the server's static
   public key to the client.  The following table shows the server
   certificate type appropriate for each key exchange algorithm.  ECC
   public keys must be encoded in certificates as described in Section
   4.7.

   NOTE: The server's Certificate message is capable of carrying a chain
   of certificates.  The restrictions mentioned in Table 3 apply only to
   the server's certificate (first in the chain).






















Gupta, et al.            Expires December 2003                 [Page 11]

Internet-Draft          ECC Cipher Suites for TLS              June 2003


          Key Exchange Algorithm  Server Certificate Type
          ----------------------  -----------------------

          ECDH_ECDSA              Certificate must contain an
                                  ECDH-capable public key. It
                                  must be signed with ECDSA.

          ECDHE_ECDSA             Certificate must contain an
                                  ECDSA-capable public key. It
                                  must be signed with ECDSA.

          ECDH_RSA                Certificate must contain an
                                  ECDH-capable public key. It
                                  must be signed with RSA.

          ECDHE_RSA               Certificate must contain an
                                  RSA public key authorized for
                                  use in digital signatures. It
                                  must be signed with RSA.

                    Table 3: Server certificate types


   Structure of this message:

   Identical to the TLS Certificate format.

   Actions of the sender:

   The server constructs an appropriate certificate chain and conveys it
   to the client in the Certificate message.

   Actions of the receiver:

   The client validates the certificate chain, extracts the server's
   public key, and checks that the key type is appropriate for the
   negotiated key exchange algorithm.

4.2 Server Key Exchange

   When this message is sent:

   This message is sent when using the ECDHE_ECDSA, ECDHE_RSA and
   ECDH_anon key exchange algorithms.

   Meaning of this message:

   This message is used to convey the server's ephemeral ECDH public key



Gupta, et al.            Expires December 2003                 [Page 12]

Internet-Draft          ECC Cipher Suites for TLS              June 2003


   (and the corresponding elliptic curve domain parameters) to the
   client.

   Structure of this message:

        enum { explicit_prime (1), explicit_char2 (2),
               named_curve (3), (255) } ECCurveType;

   explicit_prime:  Indicates the elliptic curve domain parameters are
      conveyed verbosely, and the underlying finite field is a prime
      field.

   explicit_char2:  Indicates the elliptic curve domain parameters are
      conveyed verbosely, and the underlying finite field is a
      characteristic 2 field.

   named_curve:  Indicates that a named curve is used.  This option
      SHOULD be used when applicable.


        struct {
            opaque a <1..2^8-1>;
            opaque b <1..2^8-1>;
            opaque seed <0..2^8-1>;
        } ECCurve;

   a, b:  These parameters specify the coefficients of the elliptic
      curve.  Each value contains the byte string representation of a
      field element following the conversion routine in Section 4.3.3 of
      ANSI X9.62 [7].

   seed:  This is an optional parameter used to derive the coefficients
      of a randomly generated elliptic curve.


        struct {
            opaque point <1..2^8-1>;
        } ECPoint;

   point:  This is the byte string representation of an elliptic curve
      point following the conversion routine in Section 4.3.6 of ANSI
      X9.62 [7].  Note that this byte string may represent an elliptic
      curve point in compressed or uncompressed form.  Implementations
      of this specification MUST support the uncompressed form and MAY
      support the compressed form.






Gupta, et al.            Expires December 2003                 [Page 13]

Internet-Draft          ECC Cipher Suites for TLS              June 2003


        enum { ec_basis_trinomial, ec_basis_pentanomial } ECBasisType;

   ec_basis_trinomial:  Indicates representation of a characteristic two
      field using a trinomial basis.

   ec_basis_pentanomial:  Indicates representation of a characteristic
      two field using a pentanomial basis.


        enum {
            sect163k1 (1), sect163r1 (2), sect163r2 (3),
            sect193r1 (4), sect193r2 (5), sect233k1 (6),
            sect233r1 (7), sect239k1 (8), sect283k1 (9),
            sect283r1 (10), sect409k1 (11), sect409r1 (12),
            sect571k1 (13), sect571r1 (14), secp160k1 (15),
            secp160r1 (16), secp160r2 (17), secp192k1 (18),
            secp192r1 (19), secp224k1 (20), secp224r1 (21),
            secp256k1 (22), secp256r1 (23), secp384r1 (24),
            secp521r1 (25), reserved (240..247), (255)
        } NamedCurve;

   sect163k1, etc:  Indicates use of the corresponding named curve
      specified in SEC 2 [12].  Note that many of these curves are also
      recommended in ANSI X9.62 [7], and FIPS 186-2 [9].  Values 240
      through 247 are reserved for private use.


























Gupta, et al.            Expires December 2003                 [Page 14]

Internet-Draft          ECC Cipher Suites for TLS              June 2003


        struct {
            ECCurveType    curve_type;
            select (curve_type) {
                case explicit_prime:
                    opaque      prime_p <1..2^8-1>;
                    ECCurve     curve;
                    ECPoint     base;
                    opaque      order <1..2^8-1>;
                    opaque      cofactor <1..2^8-1>;
                case explicit_char2:
                    uint16      m;
                    ECBasisType basis;
                    select (basis) {
                        case ec_trinomial:
                            opaque  k <1..2^8-1>;
                        case ec_pentanomial:
                            opaque  k1 <1..2^8-1>;
                            opaque  k2 <1..2^8-1>;
                            opaque  k3 <1..2^8-1>;
                    };
                    ECCurve     curve;
                    ECPoint     base;
                    opaque      order <1..2^8-1>;
                    opaque      cofactor <1..2^8-1>;
                case named_curve:
                    NamedCurve namedcurve;
            };
        } ECParameters;

   curve_type:  This identifies the type of the elliptic curve domain
      parameters.

   prime_p:  This is the odd prime defining the field Fp.

   curve:  Specifies the coefficients a and b (and optional seed) of the
      elliptic curve E.

   base:  Specifies the base point G on the elliptic curve.

   order:  Specifies the order n of the base point.

   cofactor:  Specifies the cofactor h = #E(Fq)/n, where #E(Fq)
      represents the number of points on the elliptic curve E defined
      over the field Fq.

   m:  This is the degree of the characteristic-two field F2^m.

   k:  The exponent k for the trinomial basis representation x^m + x^k



Gupta, et al.            Expires December 2003                 [Page 15]

Internet-Draft          ECC Cipher Suites for TLS              June 2003


      +1.

   k1, k2, k3:  The exponents for the pentanomial representation x^m +
      x^k3 + x^k2 + x^k1 + 1 (such that k3 > k2 > k1).

   namedcurve:  Specifies a recommended set of elliptic curve domain
      parameters.


        struct {
            ECParameters    curve_params;
            ECPoint         public;
        } ServerECDHParams;

   curve_params:  Specifies the elliptic curve domain parameters
      associated with the ECDH public key.

   public:  The ephemeral ECDH public key.

   The ServerKeyExchange message is extended as follows.

        enum { ec_diffie_hellman } KeyExchangeAlgorithm;

   ec_diffie_hellman:  Indicates the ServerKeyExchange message contains
      an ECDH public key.


        select (KeyExchangeAlgorithm) {
            case ec_diffie_hellman:
                ServerECDHParams    params;
                Signature           signed_params;
        } ServerKeyExchange;

   params:  Specifies the ECDH public key and associated domain
      parameters.

   signed_params:  A hash of the params, with the signature appropriate
      to that hash applied.  The private key corresponding to the
      certified public key in the server's Certificate message is used
      for signing.


          enum { ecdsa } SignatureAlgorithm;








Gupta, et al.            Expires December 2003                 [Page 16]

Internet-Draft          ECC Cipher Suites for TLS              June 2003


          select (SignatureAlgorithm) {
              case ecdsa:
                  digitally-signed struct {
                      opaque sha_hash[sha_size];
                  };
          } Signature;

   NOTE: SignatureAlgorithm is 'rsa' for the ECDHE_RSA key exchange
   algorithm and 'anonymous' for ECDH_anon.  These cases are defined in
   TLS [3].  SignatureAlgorithm is 'ecdsa' for ECDHE_ECDSA.  ECDSA
   signatures are generated and verified as described in Section 4.8.
   As per ANSI X9.62, an ECDSA signature consists of a pair of integers
   r and s.  These integers are both converted into byte strings of the
   same length as the curve order n using the conversion routine
   specified in Section 4.3.1 of [7].  The two byte strings are
   concatenated, and the result is placed in the signature field.

   Actions of the sender:

   The server selects elliptic curve domain parameters and an ephemeral
   ECDH public key corresponding to these parameters according to the
   ECKAS-DH1 scheme from IEEE 1363 [6].  It conveys this information to
   the client in the ServerKeyExchange message using the format defined
   above.

   Actions of the recipient:

   The client verifies the signature (when present) and retrieves the
   server's elliptic curve domain parameters and ephemeral ECDH public
   key from the ServerKeyExchange message.

4.3 Certificate Request

   When this message is sent:

   This message is sent when requesting client authentication.

   Meaning of this message:

   The server uses this message to suggest acceptable client
   authentication methods.

   Structure of this message:

   The TLS CertificateRequest message is extended as follows.






Gupta, et al.            Expires December 2003                 [Page 17]

Internet-Draft          ECC Cipher Suites for TLS              June 2003


        enum {
            ecdsa_sign(?), rsa_fixed_ecdh(?),
            ecdsa_fixed_ecdh(?), (255)
        } ClientCertificateType;

   ecdsa_sign, etc Indicates that the server would like to use the
      corresponding client authentication method specified in Section 3.

      EDITOR: The values used for ecdsa_sign, rsa_fixed_ecdh, and
      ecdsa_fixed_ecdh have been left as ?.  These values will be
      assigned when this draft progresses to RFC.  Earlier versions of
      this draft used the values 5, 6, and 7 - however these values have
      been removed since they are used differently by SSL 3.0 and their
      use by TLS is being deprecated.

   Actions of the sender:

   The server decides which client authentication methods it would like
   to use, and conveys this information to the client using the format
   defined above.

   Actions of the receiver:

   The client determines whether it has an appropriate certificate for
   use with any of the requested methods, and decides whether or not to
   proceed with client authentication.

4.4 Client Certificate

   When this message is sent:

   This message is sent in response to a CertificateRequest when a
   client has a suitable certificate.

   Meaning of this message:

   This message is used to authentically convey the client's static
   public key to the server.  The following table summarizes what client
   certificate types are appropriate for the ECC-based client
   authentication mechanisms described in Section 3.  ECC public keys
   must be encoded in certificates as described in Section 4.7.

   NOTE: The client's Certificate message is capable of carrying a chain
   of certificates.  The restrictions mentioned in Table 4 apply only to
   the client's certificate (first in the chain).






Gupta, et al.            Expires December 2003                 [Page 18]

Internet-Draft          ECC Cipher Suites for TLS              June 2003


          Client
          Authentication Method   Client Certificate Type
          ---------------------   -----------------------

          ECDSA_sign              Certificate must contain an
                                  ECDSA-capable public key and
                                  be signed with ECDSA.

          ECDSA_fixed_ECDH        Certificate must contain an
                                  ECDH-capable public key on the
                                  same elliptic curve as the server's
                                  long-term ECDH key. This certificate
                                  must be signed with ECDSA.

          RSA_fixed_ECDH          Certificate must contain an
                                  ECDH-capable public key on the
                                  same elliptic curve as the server's
                                  long-term ECDH key. This certificate
                                  must be signed with RSA.

                     Table 4: Client certificate types


   Structure of this message:

   Identical to the TLS client Certificate format.

   Actions of the sender:

   The client constructs an appropriate certificate chain, and conveys
   it to the server in the Certificate message.

   Actions of the receiver:

   The TLS server validates the certificate chain, extracts the client's
   public key, and checks that the key type is appropriate for the
   client authentication method.

4.5 Client Key Exchange

   When this message is sent:

   This message is sent in all key exchange algorithms.  If client
   authentication with ECDSA_fixed_ECDH or RSA_fixed_ECDH is used, this
   message is empty.  Otherwise, it contains the client's ephemeral ECDH
   public key.

   Meaning of the message:



Gupta, et al.            Expires December 2003                 [Page 19]

Internet-Draft          ECC Cipher Suites for TLS              June 2003


   This message is used to convey ephemeral data relating to the key
   exchange belonging to the client (such as its ephemeral ECDH public
   key).

   Structure of this message:

   The TLS ClientKeyExchange message is extended as follows.

        enum { yes, no } EphemeralPublicKey;

   yes, no:  Indicates whether or not the client is providing an
      ephemeral ECDH public key.  (In ECC ciphersuites, this is "yes"
      except when the client uses the ECDSA_fixed_ECDH or RSA_fixed_ECDH
      client authentication mechanism.)


        struct {
            select (EphemeralPublicKey) {
                case yes: ECPoint  ecdh_Yc;
                case no:  struct { };
            } ecdh_public;
        } ClientECDiffieHellmanPublic;

   ecdh_Yc:  Contains the client's ephemeral ECDH public key.


        struct {
            select (KeyExchangeAlgorithm) {
                case ec_diffie_hellman: ClientECDiffieHellmanPublic;
            } exchange_keys;
        } ClientKeyExchange;

   Actions of the sender:

   The client selects an ephemeral ECDH public key corresponding to the
   parameters it received from the server according to the ECKAS-DH1
   scheme from IEEE 1363 [6].  It conveys this information to the client
   in the ClientKeyExchange message using the format defined above.

   Actions of the recipient:

   The server retrieves the client's ephemeral ECDH public key from the
   ClientKeyExchange message and checks that it is on the same elliptic
   curve as the server's ECDH key.

4.6 Certificate Verify

   When this message is sent:



Gupta, et al.            Expires December 2003                 [Page 20]

Internet-Draft          ECC Cipher Suites for TLS              June 2003


   This message is sent when the client sends a client certificate
   containing a public key usable for digital signatures, e.g.  when the
   client is authenticated using the ECDSA_sign mechanism.

   Meaning of the message:

   This message contains a signature that proves possession of the
   private key corresponding to the public key in the client's
   Certificate message.

   Structure of this message:

   The TLS CertificateVerify message is extended as follows.

        enum { ecdsa } SignatureAlgorithm;

        select (SignatureAlgorithm) {
            case ecdsa:
                digitally-signed struct {
                    opaque sha_hash[sha_size];
                };
        } Signature;

   For the ecdsa case, the signature field in the CertificateVerify
   message contains an ECDSA signature computed over handshake messages
   exchanged so far.  ECDSA signatures are computed as described in
   Section 4.8.  As per ANSI X9.62, an ECDSA signature consists of a
   pair of integers r and s.  These integers are both converted into
   byte strings of the same length as the curve order n using the
   conversion routine specified in Section 4.3.1 of [7].  The two byte
   strings are concatenated, and the result is placed in the signature
   field.

   Actions of the sender:

   The client computes its signature over all handshake messages sent or
   received starting at client hello up to but not including this
   message.  It uses the private key corresponding to its certified
   public key to compute the signature which is conveyed in the format
   defined above.

   Actions of the receiver:

   The server extracts the client's signature from the CertificateVerify
   message, and verifies the signature using the public key it received
   in the client's Certificate message.





Gupta, et al.            Expires December 2003                 [Page 21]

Internet-Draft          ECC Cipher Suites for TLS              June 2003


4.7 Elliptic Curve Certificates

   X509 certificates containing ECC public keys or signed using ECDSA
   MUST comply with [14].  Clients SHOULD use the elliptic curve domain
   parameters recommended in ANSI X9.62 [7], FIPS 186-2 [9], and SEC 2
   [12].

4.8 ECDH, ECDSA and RSA Computations

   All ECDH calculations (including parameter and key generation as well
   as the shared secret calculation) MUST be performed according to [6]
   using

   o  the ECKAS-DH1 scheme with the ECSVDP-DH secret value derivation
      primitive, the KDF1 key derivation function using SHA-1 [8], and
      null key derivation parameters "P" for elliptic curve parameters
      where field elements are represented as octet strings of length 24
      or less (using the IEEE 1363 FE2OSP); in this case, the premaster
      secret is the output of the ECKAS-DH1 scheme, i.e.  the 20-byte
      SHA-1 output from the KDF.

   o  the ECKAS-DH1 scheme with the identity map as key derivation
      function for elliptic curve parameters where field elements are
      represented as octet strings of length more than 24; in this case,
      the premaster secret is the x-coordinate of the ECDH shared secret
      elliptic curve point, i.e.  the octet string Z in IEEE 1363
      terminology.

   Note that a new extension may be introduced in the future to allow
   the use of a different KDF during computation of the premaster
   secret.  In this event, the new KDF would be used in place of the
   process detailed above.  This may be desirable, for example, to
   support compatibility with the planned NIST key agreement standard.

   All ECDSA computations MUST be performed according to ANSI X9.62 [7]
   or its successors.  Data to be signed/verified is hashed and the
   result run directly through the ECDSA algorithm with no additional
   hashing.  The default hash function is SHA-1 [8] and sha_size (see
   Section 4.2 and Section 4.6) is 20.  However, an alternative hash
   function, such as one of the new SHA hash functions specified in FIPS
   180-2 [8], may be used instead if the certificate containing the EC
   public key explicitly requires use of another hash function.

   All RSA signatures must be generated and verified according to PKCS#1
   [10].






Gupta, et al.            Expires December 2003                 [Page 22]

Internet-Draft          ECC Cipher Suites for TLS              June 2003


5. Cipher Suites

   The table below defines new ECC cipher suites that use the key
   exchange algorithms specified in Section 2.

   EDITOR: Most of the cipher suites below have been left as ??.  The
   values 47-4C correspond to cipher suites which are known to have been
   implemented and are therefore proposed here.  The final determination
   of cipher suite numbers will occur when this draft progresses to RFC.
   Implementers using the values 47-4C should therefore be wary that
   these values may change.

     CipherSuite TLS_ECDH_ECDSA_WITH_NULL_SHA           = { 0x00, 0x47 }
     CipherSuite TLS_ECDH_ECDSA_WITH_RC4_128_SHA        = { 0x00, 0x48 }
     CipherSuite TLS_ECDH_ECDSA_WITH_DES_CBC_SHA        = { 0x00, 0x49 }
     CipherSuite TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA   = { 0x00, 0x4A }
     CipherSuite TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA    = { 0x00, 0x4B }
     CipherSuite TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA    = { 0x00, 0x4C }

     CipherSuite TLS_ECDHE_ECDSA_WITH_NULL_SHA          = { 0x00, 0x?? }
     CipherSuite TLS_ECDHE_ECDSA_WITH_RC4_128_SHA       = { 0x00, 0x?? }
     CipherSuite TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA  = { 0x00, 0x?? }
     CipherSuite TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA   = { 0x00, 0x?? }
     CipherSuite TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA   = { 0x00, 0x?? }

     CipherSuite TLS_ECDH_RSA_WITH_NULL_SHA             = { 0x00, 0x?? }
     CipherSuite TLS_ECDH_RSA_WITH_RC4_128_SHA          = { 0x00, 0x?? }
     CipherSuite TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA     = { 0x00, 0x?? }
     CipherSuite TLS_ECDH_RSA_WITH_AES_128_CBC_SHA      = { 0x00, 0x?? }
     CipherSuite TLS_ECDH_RSA_WITH_AES_256_CBC_SHA      = { 0x00, 0x?? }

     CipherSuite TLS_ECDHE_RSA_WITH_NULL_SHA            = { 0x00, 0x?? }
     CipherSuite TLS_ECDHE_RSA_WITH_RC4_128_SHA         = { 0x00, 0x?? }
     CipherSuite TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA    = { 0x00, 0x?? }
     CipherSuite TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA     = { 0x00, 0x?? }
     CipherSuite TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA     = { 0x00, 0x?? }

     CipherSuite TLS_ECDH_anon_NULL_WITH_SHA            = { 0x00, 0x?? }
     CipherSuite TLS_ECDH_anon_WITH_RC4_128_SHA         = { 0x00, 0x?? }
     CipherSuite TLS_ECDH_anon_WITH_3DES_EDE_CBC_SHA    = { 0x00, 0x?? }
     CipherSuite TLS_ECDH_anon_WITH_AES_128_CBC_SHA     = { 0x00, 0x?? }
     CipherSuite TLS_ECDH_anon_WITH_AES_256_CBC_SHA     = { 0x00, 0x?? }

                        Table 5: TLS ECC cipher suites


   The key exchange method, cipher, and hash algorithm for each of these
   cipher suites are easily determined by examining the name.  Ciphers



Gupta, et al.            Expires December 2003                 [Page 23]

Internet-Draft          ECC Cipher Suites for TLS              June 2003


   other than AES ciphers, and hash algorithms are defined in [3].  AES
   ciphers are defined in [11].

   Server implementations SHOULD support all of the following cipher
   suites, and client implementations SHOULD support at least one of
   them: TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA,
   TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA,
   TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA, and
   TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA.










































Gupta, et al.            Expires December 2003                 [Page 24]

Internet-Draft          ECC Cipher Suites for TLS              June 2003


6. Security Considerations

   This document is based on [3], [6], [7] and [11].  The appropriate
   security considerations of those documents apply.

   For ECDH (Section 4.8), this document specifies two different ways to
   compute the premaster secret.  The choice of the method is determined
   by the elliptic curve.  Earlier versions of this specification used
   the KDF1 key derivation function with SHA-1 in all cases; the current
   version keeps this key derivation function only for curves where
   field elements are represented as octet strings of length 24 or less
   (i.e.  up to 192 bits), but omits it for larger curves.

   Rationale: Using KDF1 with SHA-1 limits the security to at most 160
   bits, independently of the elliptic curve used for ECDH.  For large
   curves, this would result in worse security than expected.  Using a
   specific key derivation function for ECDH is not really necessary as
   TLS always uses its PRF to derive the master secret from the
   premaster secret.  For large curves, the current specification
   handles ECDH like the basic TLS specification [11] handles standard
   DH.  For smaller curves where the extra KDF1 step does not weaken
   security, the current specification keeps the KDF1 step to obtain
   compatibility with existing implementations of earlier versions of
   this specification.  Note that the threshold for switching between
   the two ECDH calculation methods is necessarily somewhat arbitrary;
   192-bit ECC corresponds to approximately 96 bits of security in the
   light of square root attacks, so the 160 bits provided by SHA-1 are
   comfortable at this limit.























Gupta, et al.            Expires December 2003                 [Page 25]

Internet-Draft          ECC Cipher Suites for TLS              June 2003


7. Intellectual Property Rights

   The IETF has been notified of intellectual property rights claimed in
   regard to the specification contained in this document.  For more
   information, consult the online list of claimed rights (http://
   www.ietf.org/ipr.html).

   The IETF takes no position regarding the validity or scope of any
   intellectual property or other rights that might be claimed to
   pertain to the implementation or use of the technology described in
   this document or the extent to which any license under such rights
   might or might not be available; neither does it represent that it
   has made any effort to identify any such rights.  Information on the
   IETF's procedures with respect to rights in standards-track and
   standards-related documentation can be found in [13].  Copies of
   claims of rights made available for publication and any assurances of
   licenses to be made available, or the result of an attempt made to
   obtain a general license or permission for the use of such
   proprietary rights by implementers or users of this specification can
   be obtained from the IETF Secretariat.































Gupta, et al.            Expires December 2003                 [Page 26]

Internet-Draft          ECC Cipher Suites for TLS              June 2003


8. Acknowledgments

   The authors wish to thank Bill Anderson and Tim Dierks.
















































Gupta, et al.            Expires December 2003                 [Page 27]

Internet-Draft          ECC Cipher Suites for TLS              June 2003


References

   [1]   Bradner, S., "Key Words for Use in RFCs to Indicate Requirement
         Levels", RFC 2119, March 1997.

   [2]   Lenstra, A. and E. Verheul, "Selecting Cryptographic Key
         Sizes", Journal of Cryptology 14 (2001) 255-293, <http://
         www.cryptosavvy.com/>.

   [3]   Dierks, T. and C. Allen, "The TLS Protocol Version 1.0", RFC
         2246, January 1999.

   [4]   Freier, A., Karlton, P. and P. Kocher, "The SSL Protocol
         Version 3.0", November 1996, <http://wp.netscape.com/eng/ssl3/
         draft302.txt>.

   [5]   SECG, "Elliptic Curve Cryptography", SEC 1, 2000, <http://
         www.secg.org/>.

   [6]   IEEE, "Standard Specifications for Public Key Cryptography",
         IEEE 1363, 2000.

   [7]   ANSI, "Public Key Cryptography For The Financial Services
         Industry: The Elliptic Curve Digital Signature Algorithm
         (ECDSA)", ANSI X9.62, 1998.

   [8]   NIST, "Secure Hash Standard", FIPS 180-2, 2002.

   [9]   NIST, "Digital Signature Standard", FIPS 186-2, 2000.

   [10]  RSA Laboratories, "PKCS#1: RSA Encryption Standard version
         1.5", PKCS 1, November 1993.

   [11]  Chown, P., "Advanced Encryption Standard (AES) Ciphersuites for
         Transport Layer Security (TLS)", RFC 3268, June 2002.

   [12]  SECG, "Recommended Elliptic Curve Domain Parameters", SEC 2,
         2000, <http://www.secg.org/>.

   [13]  Hovey, R. and S. Bradner, "The Organizations Involved in the
         IETF Standards Process", RFC 2028, BCP 11, October 1996.

   [14]  Polk, T., Housley, R. and L. Bassham, "Algorithms and
         Identifiers for the Internet X.509 Public Key Infrastructure
         Certificate and Certificate Revocation List (CRL) Profile", RFC
         3279, April 2002.





Gupta, et al.            Expires December 2003                 [Page 28]

Internet-Draft          ECC Cipher Suites for TLS              June 2003


Authors' Addresses

   Vipul Gupta
   Sun Microsystems Laboratories
   2600 Casey Avenue
   MS UMTV29-235
   Mountain View, CA  94303
   USA

   Phone: +1 650 336 1681
   EMail: vipul.gupta@sun.com


   Simon Blake-Wilson
   Basic Commerce & Industries, Inc.
   96 Spandia Ave
   Unit 606
   Toronto, ON  M6G 2T6
   Canada

   Phone: +1 416 214 5961
   EMail: sblakewilson@bcisse.com


   Bodo Moeller
   Technische Universitaet Darmstadt
   Alexanderstr. 10
   64283 Darmstadt
   Germany

   Phone: +49 6151 16 6628
   EMail: moeller@cdc.informatik.tu-darmstadt.de


   Chris Hawk
   Independent Consultant

   EMail: chris@socialeng.com













Gupta, et al.            Expires December 2003                 [Page 29]

Internet-Draft          ECC Cipher Suites for TLS              June 2003


Full Copyright Statement

   Copyright (C) The Internet Society (2003).  All Rights Reserved.

   This document and translations of it may be copied and furnished to
   others, and derivative works that comment on or otherwise explain it
   or assist in its implementation may be prepared, copied, published
   and distributed, in whole or in part, without restriction of any
   kind, provided that the above copyright notice and this paragraph are
   included on all such copies and derivative works.  However, this
   document itself may not be modified in any way, such as by removing
   the copyright notice or references to the Internet Society or other
   Internet organizations, except as needed for the purpose of
   developing Internet standards in which case the procedures for
   copyrights defined in the Internet Standards process must be
   followed, or as required to translate it into languages other than
   English.

   The limited permissions granted above are perpetual and will not be
   revoked by the Internet Society or its successors or assigns.

   This document and the information contained herein is provided on an
   "AS IS" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING
   TASK FORCE DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING
   BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION
   HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF
   MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.

Acknowledgement

   Funding for the RFC Editor function is currently provided by the
   Internet Society.



















Gupta, et al.          Expires December 2003                   [Page 30]

