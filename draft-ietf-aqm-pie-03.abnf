drop_prob_ = drop_prob_+ alpha*(current_qdelay-QDELAY_REF) + 
                     beta*(current_qdelay-qdelay_old);
qdelay_old_ = current_qdelay_. 

drop_prob_ = drop_prob_;
p = p*0.98;    //1- 1/64 is sufficient

current_qdelay = qlen/dq_rate_; 

burst_allowance_ = MAX_BURST;

burst_allowance_ = burst_allowance_ - T_UPDATE;

in_measurement_ = TRUE; 
measurement_start_ = now;
dq_count_ = 0;

dq_count_ = dq_count_ + deque_pkt_size;
dq_rate_ = dq_count/(now-start_); 
dq_count=0;
start_ = now

PIE_active_ = TRUE;
burst_allowance = MAX_BURST;

PIE_active_ = FALSE;
burst_allowance_ = MAX_BURST;

burst_allowance = burst_allowance - T_UPDATE;

        	
p = 0.02;

burst_allowance = MAX_BURST;
qdelay = PIE->current_qdelay_;

p = alpha*(qdelay - QDELAY_REF) + \
           beta*(qdelay-PIE->qdelay_old_);

p = p/128
p = p/16;
p = p/2;
p = p;
qdelay = queue_.byte_length() * avg_dq_time_/DQ_THRESHOLD;

p = alpha*(qdelay - QDELAY_REF) + \
           beta*(qdelay-PIE->qdelay_old_);

p = p/128
p = p/16;
p = p/2;
p = p;
p = 0.02;
dq_time = now - PIE->measurement_start_;
weight = DQ_THRESHOLD/2^16
