<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="en"><head><title>DTLS-SRTP Key
    Transport</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="description" content="DTLS-SRTP Key
    Transport">
<meta name="generator" content="xml2rfc v1.35 (http://xml.resource.org/)">
<meta name="viewport" content="width=600;" />
<style type='text/css'><!--
        body {
                font-family: verdana, charcoal, helvetica, arial, sans-serif;
                font-size: 85%;
		max-width: 40em; 
		color: #000; background-color: #FFF;
                margin: 2em;
        }
        h1, h2, h3, h4, h5, h6 {
                font-family: helvetica, monaco, "MS Sans Serif", arial, sans-serif;
                font-weight: bold; font-style: normal;
        }
        h1 { color: #900; background-color: transparent; text-align: right; }
        h3 { color: #333; background-color: transparent; }

        td.RFCbug {
                font-size: x-small; text-decoration: none;
                width: 30px; height: 30px; padding-top: 2px;
                text-align: justify; vertical-align: middle;
                background-color: #000;
        }
        td.RFCbug span.RFC {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: bold; color: #666;
        }
        td.RFCbug span.hotText {
                font-family: charcoal, monaco, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: normal; text-align: center; color: #FFF;
        }

        table.TOCbug { width: 30px; height: 15px; }
        td.TOCbug {
                text-align: center; width: 30px; height: 15px;
                color: #FFF; background-color: #900;
        }
        td.TOCbug a {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, sans-serif;
                font-weight: bold; font-size: x-small; text-decoration: none;
                color: #FFF; background-color: transparent;
        }

        td.header {
                font-family: arial, helvetica, sans-serif; font-size: x-small;
                vertical-align: top; width: 33%;
                color: #FFF; background-color: #666;
        }
        td.author { font-weight: bold; font-size: x-small; margin-left: 4em; }
        td.author-text { font-size: x-small; }

        /* info code from SantaKlauss at http://www.madaboutstyle.com/tooltip2.html */
        a.info {
                /* This is the key. */
                position: relative;
                z-index: 24;
                text-decoration: none;
        }
        a.info:hover {
                z-index: 25;
                color: #FFF; background-color: #900;
        }
        a.info span { display: none; }
        a.info:hover span.info {
                /* The span will display just on :hover state. */
                display: block;
                position: absolute;
                font-size: smaller;
                top: 2em; left: -5em; width: 15em;
                padding: 2px; border: 1px solid #333;
                color: #900; background-color: #EEE;
                text-align: left;
        }

        a { font-weight: bold; }
        a:link    { color: #900; background-color: transparent; }
        a:visited { color: #633; background-color: transparent; }
        a:active  { color: #633; background-color: transparent; }

        p { margin-left: 2em; margin-right: 2em; }
        p.copyright { font-size: x-small; }
        p.toc { font-size: 85%;
		max-width: 40em; 
		font-weight: bold; margin-left: 3em; }
        table.toc { margin: 0 0 0 3em; padding: 0; border: 0; vertical-align: text-top; }
        td.toc { font-size: 85%;
		max-width: 40em; 
		font-weight: bold; vertical-align: text-top; }

        ol.text { margin-left: 2em; margin-right: 2em; }
        ul.text { margin-left: 2em; margin-right: 2em; }
        li      { margin-left: 3em; }

        /* RFC-2629 <spanx>s and <artwork>s. */
        em     { font-style: italic; }
        strong { font-weight: bold; }
        dfn    { font-weight: bold; font-style: normal; }
        cite   { font-weight: normal; font-style: normal; }
        tt     { color: #036; }
        tt, pre, pre dfn, pre em, pre cite, pre span {
                font-family: "Courier New", Courier, monospace; font-size: small;
        }
        pre {
                text-align: left; padding: 4px;
                color: #000; background-color: #CCC;
        }
        pre dfn  { color: #900; }
        pre em   { color: #66F; background-color: #FFC; font-weight: normal; }
        pre .key { color: #33C; font-weight: bold; }
        pre .id  { color: #900; }
        pre .str { color: #000; background-color: #CFF; }
        pre .val { color: #066; }
        pre .rep { color: #909; }
        pre .oth { color: #000; background-color: #FCF; }
        pre .err { background-color: #FCC; }

        /* RFC-2629 <texttable>s. */
        table.all, table.full, table.headers, table.none {
                font-size: 85%;
		max-width: 40em; 
		text-align: center; border-width: 2px;
                vertical-align: top; border-collapse: collapse;
        }
        table.all, table.full { border-style: solid; border-color: black; }
        table.headers, table.none { border-style: none; }
        th {
                font-weight: bold; border-color: black;
                border-width: 2px 2px 3px 2px;
        }
        table.all th, table.full th { border-style: solid; }
        table.headers th { border-style: none none solid none; }
        table.none th { border-style: none; }
        table.all td {
                border-style: solid; border-color: #333;
                border-width: 1px 2px;
        }
        table.full td, table.headers td, table.none td { border-style: none; }

        hr { height: 1px; }
        hr.insert {
                width: 80%; border-style: none; border-width: 0;
                color: #CCC; background-color: #CCC;
        }
--></style>
</head>
<body>
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<table summary="layout" width="66%" border="0" cellpadding="0" cellspacing="0"><tr><td><table summary="layout" width="100%" border="0" cellpadding="2" cellspacing="1">
<tr><td class="header">AVT Working Group</td><td class="header">D. Wing</td></tr>
<tr><td class="header">Internet-Draft</td><td class="header">Cisco</td></tr>
<tr><td class="header">Intended status:  Standards Track</td><td class="header">July 14, 2008</td></tr>
<tr><td class="header">Expires:  January 15, 2009</td><td class="header">&nbsp;</td></tr>
</table></td></tr></table>
<h1><br />DTLS-SRTP Key
    Transport<br />draft-wing-avt-dtls-srtp-key-transport-02</h1>

<h3>Status of this Memo</h3>
<p>
By submitting this Internet-Draft,
each author represents that any applicable patent or other IPR claims of which
he or she is aware have been or will be disclosed,
and any of which he or she becomes aware will be disclosed,
in accordance with Section&nbsp;6 of BCP&nbsp;79.</p>
<p>
Internet-Drafts are working documents of the Internet Engineering
Task Force (IETF), its areas, and its working groups.
Note that other groups may also distribute working documents as
Internet-Drafts.</p>
<p>
Internet-Drafts are draft documents valid for a maximum of six months
and may be updated, replaced, or obsoleted by other documents at any time.
It is inappropriate to use Internet-Drafts as reference material or to cite
them other than as &ldquo;work in progress.&rdquo;</p>
<p>
The list of current Internet-Drafts can be accessed at
<a href='http://www.ietf.org/ietf/1id-abstracts.txt'>http://www.ietf.org/ietf/1id-abstracts.txt</a>.</p>
<p>
The list of Internet-Draft Shadow Directories can be accessed at
<a href='http://www.ietf.org/shadow.html'>http://www.ietf.org/shadow.html</a>.</p>
<p>
This Internet-Draft will expire on January 15, 2009.</p>

<h3>Abstract</h3>

<p>The existing DTLS-SRTP specification allows SRTP keys to be
      established between a pair of SRTP endpoints. However, when there are
      more than two participants in an RTP session, DTLS-SRTP is unable to
      provide a single key for all of the participants. This existing
      limitation of DTLS-SRTP prevents deploying DTLS-SRTP in certain
      scenarios.
</p>
<p>This document describes an extension to DTLS-SRTP, called Key
      Transport (KTR). This extension transports SRTP keying material from one
      DTLS-SRTP peer to another, so the same SRTP keying material can be used
      by multiple DTLS-SRTP peers. This extension eliminates the need to key
      each SRTP session individually, allowing cost-effective deployment of
      several DTLS-SRTP scenarios.
</p><a name="toc"></a><br /><hr />
<h3>Table of Contents</h3>
<p class="toc">
<a href="#anchor1">1.</a>&nbsp;
Introduction<br />
<a href="#anchor2">2.</a>&nbsp;
Notational Conventions<br />
<a href="#sec_scenarios">3.</a>&nbsp;
Scenarios<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section_point_multipoint">3.1.</a>&nbsp;
Point to Multipoint using the RFC 3550 mixer model<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#scenario-multicast">3.2.</a>&nbsp;
Point to Multipoint using Multicast<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec-video-switching">3.3.</a>&nbsp;
Point to Multipoint Using Video Switching MCUs<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec-scaling">3.4.</a>&nbsp;
Scaling to Large Groups<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec-scaling-lkh">3.4.1.</a>&nbsp;
Rekeying SRTP Quickly<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec-scaling-distributed">3.4.2.</a>&nbsp;
Distributed Key Servers<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor3">3.5.</a>&nbsp;
Interworking with Other SRTP Key Management Systems<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor4">3.5.1.</a>&nbsp;
Security Descriptions<br />
<a href="#sec_protocol_description">4.</a>&nbsp;
Protocol Description<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor5">4.1.</a>&nbsp;
key_transport (KTR) extension to DTLS-SRTP<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor6">4.2.</a>&nbsp;
KTR Primitives<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#procedures">4.3.</a>&nbsp;
Procedures for Network Elements<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#procedure_speaker">4.3.1.</a>&nbsp;
Speaker<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#procedure_mixer">4.3.2.</a>&nbsp;
Mixer<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#procedure_switcher">4.3.3.</a>&nbsp;
Switcher<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#procedure_listener">4.3.4.</a>&nbsp;
Listener<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor7">4.4.</a>&nbsp;
Key Transport SSRC and RTP SSRC Collisions<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor8">4.5.</a>&nbsp;
Fragmentation, Reassembly, and Retransmission<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor9">4.6.</a>&nbsp;
SDP extensions<br />
<a href="#anchor10">5.</a>&nbsp;
Examples<br />
<a href="#security_considerations">6.</a>&nbsp;
Security Considerations<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec-group-policy">6.1.</a>&nbsp;
Group Policy when Joining/Leaving<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#two-time-pad">6.2.</a>&nbsp;
Two-Time Pad<br />
<a href="#anchor11">7.</a>&nbsp;
Acknowledgements<br />
<a href="#anchor12">8.</a>&nbsp;
IANA Considerations<br />
<a href="#rfc.references1">9.</a>&nbsp;
References<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#rfc.references1">9.1.</a>&nbsp;
Normative References<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#rfc.references2">9.2.</a>&nbsp;
Informational References<br />
<a href="#ekt">Appendix&nbsp;A.</a>&nbsp;
Relationship with EKT<br />
<a href="#anchor15">Appendix&nbsp;B.</a>&nbsp;
Changes<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor16">B.1.</a>&nbsp;
Changes from -00 to -01<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor17">B.2.</a>&nbsp;
Changes from -01 to -02<br />
<a href="#rfc.authors">&#167;</a>&nbsp;
Author's Address<br />
<a href="#rfc.copyright">&#167;</a>&nbsp;
Intellectual Property and Copyright Statements<br />
</p>
<br clear="all" />

<a name="anchor1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1"></a><h3>1.&nbsp;
Introduction</h3>

<p>When <a class='info' href='#I-D.ietf-avt-dtls-srtp'>DTLS-SRTP<span> (</span><span class='info'>McGrew, D. and E. Rescorla, &ldquo;Datagram Transport Layer Security (DTLS) Extension to Establish Keys for Secure Real-time Transport Protocol (SRTP),&rdquo; February&nbsp;2009.</span><span>)</span></a> [I&#8209;D.ietf&#8209;avt&#8209;dtls&#8209;srtp]
      establishes <a class='info' href='#RFC3711'>Secure RTP<span> (</span><span class='info'>Baugher, M., McGrew, D., Naslund, M., Carrara, E., and K. Norrman, &ldquo;The Secure Real-time Transport Protocol (SRTP),&rdquo; March&nbsp;2004.</span><span>)</span></a> [RFC3711] master keys, each
      peer contributes part of the keying material to derive the SRTP master
      key. In some scenarios it is desirable for one peer to change its SRTP
      key and to transmit SRTP packets using an SRTP key that was not derived
      from the DTLS key exchange. This allows one peer to significantly reduce
      cryptographic operations in many scenarios as described in detail in
      <a class='info' href='#sec_scenarios'>Section&nbsp;3<span> (</span><span class='info'>Scenarios</span><span>)</span></a>.
</p>
<p>The extension described in this document allows transporting an SRTP
      master key from one DTLS peer to the other. Thus, DTLS Key Transport
      differs from normal DTLS-SRTP in that the SRTP master key is not derived
      from the TLS handshake.
</p>
<a name="anchor2"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2"></a><h3>2.&nbsp;
Notational Conventions</h3>

<p>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
      "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
      document are to be interpreted as described in <a class='info' href='#RFC2119'>[RFC2119]<span> (</span><span class='info'>Bradner, S., &ldquo;Key words for use in RFCs to Indicate Requirement Levels,&rdquo; March&nbsp;1997.</span><span>)</span></a>.
</p>
<p>A "listener" is an endpoint that only receives an SRTP stream. A
      "speaker" is an endpoint that only transmits an SRTP stream. And
      endpoint can be both a listener and a speaker.
</p>
<a name="sec_scenarios"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3"></a><h3>3.&nbsp;
Scenarios</h3>

<p>KTR allows mixers and video switchers to avoid having to encrypt each
      packet multiple times under multiple SRTP keys, by allowing a single
      SRTP key to be shared with the multiple recipients that are receiving
      the SRTP stream.
</p>
<p>Several SRTP scenarios that benefit from KTR are described in the
      following sections, using terminology from <a class='info' href='#RFC5117'>RTP
      Topologies<span> (</span><span class='info'>Westerlund, M. and S. Wenger, &ldquo;RTP Topologies,&rdquo; January&nbsp;2008.</span><span>)</span></a> [RFC5117].
</p>
<a name="section_point_multipoint"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.1"></a><h3>3.1.&nbsp;
Point to Multipoint using the RFC 3550 mixer model</h3>

<p>This RTP scenario is described in Section 3.4 of <a class='info' href='#RFC5117'>RTP Topologies<span> (</span><span class='info'>Westerlund, M. and S. Wenger, &ldquo;RTP Topologies,&rdquo; January&nbsp;2008.</span><span>)</span></a> [RFC5117].
</p>
<p>With DTLS-SRTP, this topology is computationally expensive for the
        video switcher because it has to encrypt the payload uniquely for each
        SRTP listener. Additionally, the architecture of a typical mixer
        requires each listener's SRTP to be encrypted serially, incurring
        additional delay for each successive listener. This is depicted below
        in <a class='info' href='#multipoint-without-kt'>Figure&nbsp;1<span> (</span><span class='info'>Point to Multipoint Mixer, without DTLS Key Transport</span><span>)</span></a>.
</p><br /><hr class="insert" />
<a name="multipoint-without-kt"></a>

<p>
</p><div style='display: table; width: 0; margin-left: auto; margin-right: auto'><pre>     +-------key=F-------+
     |                   |
     V               +-------+         +------------+
+----+----+          |       +--key=C-&gt;+ listener 1 |
| speaker +--key=A--&gt;+       |         +------------+
+---------+          |       |         +------------+
                     | mixer +--key=D-&gt;+ listener 2 |
+---------+          |       |         +------------+
| speaker +--key=B--&gt;+       |         +------------+
+----+----+          |       +--key=E-&gt;+ listener 3 |
     ^               +---+---+         +------------+
     |                   |
     +-------key=G-------+
</pre></div>
<p>
</p><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;1: Point to Multipoint Mixer, without DTLS Key Transport&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>With KTR, the mixer can maintain one outbound SRTP cryptographic
        context, and encrypt the SRTP once for all listeners. This is depicted
        below in <a class='info' href='#multipoint-with-kt'>Figure&nbsp;2<span> (</span><span class='info'>Point to Multipoint Mixer, with DTLS Key Transport</span><span>)</span></a>.
</p><br /><hr class="insert" />
<a name="multipoint-with-kt"></a>

<p>In the following figure, "=" indicates sessions where
          DTLS-SRTP Key Transport is used, and "-" indicates where only
          DTLS-SRTP is necessary. In this topology, only the listeners need
          support KTR so that the switcher and the listeners can benefit from
          KTR. In this scenario with DTLS-SRTP Key Transport, the mixer
          assumes an additional role -- group's key server -- and provides a
          common group SRTP key ("C") to all of the listeners. This group SRTP
          key is shared between all of the listeners. The two speakers,
          however, receive a unique stream (just as in the scenario above),
          but to prevent a two-time (pad<a class='info' href='#two-time-pad'>Section&nbsp;6.2<span> (</span><span class='info'>Two-Time Pad</span><span>)</span></a>),
          their content is encrypted using a different SRTP keys ("D" and
          "E").
</p><div style='display: table; width: 0; margin-left: auto; margin-right: auto'><pre>
     +=======key=D=======+
     |                   |
     V               +---+---+         +------------+
+---------+          |       +==key=C=&gt;+ listener 1 |
| speaker +--key=A--&gt;+       |         +------------+
+---------+          |       |         +------------+
                     | mixer +==key=C=&gt;+ listener 2 |
+---------+          |       |         +------------+
| speaker +--key=B--&gt;+       |         +------------+
+----+----+          |       +==key=C=&gt;+ listener 3 |
     ^               +---+---+         +------------+
     |                   |
     +=======key=E=======+
</pre></div>
<p>
</p><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;2: Point to Multipoint Mixer, with DTLS Key Transport&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>The mixer is aware of listeners leaving or joining, and the mixer
        can rekey the remaining active listeners.
</p>
<a name="scenario-multicast"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.2"></a><h3>3.2.&nbsp;
Point to Multipoint using Multicast</h3>

<p>This RTP topology is described in Section 3.2 of <a class='info' href='#RFC5117'>RTP Topologies<span> (</span><span class='info'>Westerlund, M. and S. Wenger, &ldquo;RTP Topologies,&rdquo; January&nbsp;2008.</span><span>)</span></a> [RFC5117].
</p>
<p>With DTLS-SRTP, this scenario is not attainable because each
        listener has a unique SRTP key. For this reason, <a class='info' href='#I-D.ietf-msec-gdoi-srtp'>[I&#8209;D.ietf&#8209;msec&#8209;gdoi&#8209;srtp]<span> (</span><span class='info'>Baugher, M., Rueegsegger, A., and S. Rowles, &ldquo;GDOI Key Establishment for the SRTP Data Security Protocol,&rdquo; December&nbsp;2007.</span><span>)</span></a> was developed by the MSEC
        working group.
</p>
<p>With KTR, this scenario is attainable because the same key can be
        provided to multiple listeners, as depicted below in <a class='info' href='#multipoint-multicast-with-kt'>Figure&nbsp;3<span> (</span><span class='info'>Point to Multipoint using Multicast with Key Transport</span><span>)</span></a>. This compares favorably
        with <a class='info' href='#I-D.ietf-msec-gdoi-srtp'>[I&#8209;D.ietf&#8209;msec&#8209;gdoi&#8209;srtp]<span> (</span><span class='info'>Baugher, M., Rueegsegger, A., and S. Rowles, &ldquo;GDOI Key Establishment for the SRTP Data Security Protocol,&rdquo; December&nbsp;2007.</span><span>)</span></a> when the group
        size is small enough that the speaker can perform key server functions
        (i.e., perform KTR) for all of the listeners.
</p><br /><hr class="insert" />
<a name="multipoint-multicast-with-kt"></a>

<p>
</p><div style='display: table; width: 0; margin-left: auto; margin-right: auto'><pre>                        +-------+            +------------+
                       /         \==key=A===&gt;+ listener 1 |
                      /           \          +------------+
+---------+           | multicast |          +------------+
| speaker +==key=A===&gt;+  network  +==key=A==&gt;+ listener 2 |
+---------+           |           |          +------------+
                      \           /          +------------+
                       \         /===key=A==&gt;+ listener 3 |
                        +-------+            +------------+</pre></div>
<p>
</p><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;3: Point to Multipoint using Multicast with Key Transport&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<a name="sec-video-switching"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.3"></a><h3>3.3.&nbsp;
Point to Multipoint Using Video Switching MCUs</h3>

<p>This RTP topology is described in Section 3.5 of <a class='info' href='#RFC5117'>RTP Topologies<span> (</span><span class='info'>Westerlund, M. and S. Wenger, &ldquo;RTP Topologies,&rdquo; January&nbsp;2008.</span><span>)</span></a> [RFC5117].
</p>
<p>With DTLS-SRTP, this topology is computationally expensive for the
        video switcher because it has to encrypt the payload uniquely for each
        SRTP listener. Additionally, the architecture of a typical video
        switcher requires each listener's SRTP to be encrypted serially,
        incurring additional delay for each successive listener. This is
        depicted below in <a class='info' href='#multipoint-video-without-kt'>Figure&nbsp;4<span> (</span><span class='info'>Point to Multipoint Video Switching, without DTLS Key Transport</span><span>)</span></a>.
</p><br /><hr class="insert" />
<a name="multipoint-video-without-kt"></a>

<p>In the following figure, KTR is used on all sessions and
          depicted by "=". In this scenario, both the speakers and listeners
          must support KTR so that the switcher and the listeners can benefit
          from KTR.
</p><div style='display: table; width: 0; margin-left: auto; margin-right: auto'><pre>
     +-------key=F-------+
     |                   |
     V               +---+------+         +------------+
+---------+          |          +==key=C=&gt;+ listener 1 |
| speaker +==key=A==&gt;+selected  |         +------------+
+---------+          |          |         +------------+
                     | switcher +==key=D=&gt;+ listener 2 |
+---------+          |          |         +------------+
| speaker +==key=B==&gt;+dropped   |         +------------+
+----+----+          |          +==key=E=&gt;+ listener 3 |
     ^               +---+------+         +------------+
     |                   |
     +-------key=G-------+</pre></div>
<p>
</p><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;4: Point to Multipoint Video Switching, without DTLS Key Transport&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>With DTLS key transport, this becomes easier; in fact, the video
        switcher doesn't need to decrypt the SRTP at all, but just make its
        decision (select the stream or drop the stream) and transmit the SRTP
        packets to the listeners. This is depicted below in <a class='info' href='#multipoint-video-with-kt'>Figure&nbsp;5<span> (</span><span class='info'>Point to Multipoint Video Switching, with DTLS Key Transport</span><span>)</span></a>.
</p><br /><hr class="insert" />
<a name="multipoint-video-with-kt"></a>

<p>
</p><div style='display: table; width: 0; margin-left: auto; margin-right: auto'><pre>     +-------key=B-------+
     |                   |
     V               +---+------+         +------------+
+----+----+          |          +==key=A=&gt;+ listener 1 |
| speaker +==key=A==&gt;+selected  |         +------------+
+---------+          |          |         +------------+
                     | switcher +==key=A=&gt;+ listener 2 |
+---------+          |          |         +------------+
| speaker +==key=B==&gt;+prev.spkr |         +------------+
+---------+          |          +==key=A=&gt;+ listener 3 |
     ^               +----------+         +------------+
     |                   |
     +-------key=A-------+</pre></div>
<p>
</p><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;5: Point to Multipoint Video Switching, with DTLS Key Transport&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>The video switcher is aware of listeners leaving or joining. The
        protocol described in this document allows the switcher to dictate, to
        the speaker, that the speaker use a new encryption key. This allows
        the switcher to enforce security, based on the switcher's policy
        (<a class='info' href='#sec-group-policy'>Section&nbsp;6.1<span> (</span><span class='info'>Group Policy when Joining/Leaving</span><span>)</span></a>). This is done by the video
        switcher sending a DTLS "your_new_srtp_key" message. The speaker will
        respond with a DTLS "new_srtp_key" message which echos the same key.
        The "new_srtp_key" message is relayed, by the switcher, to each of the
        active listeners.
</p>
<p>When there are multiple speakers, as shown in <a class='info' href='#multipoint-video-with-kt'>Figure&nbsp;5<span> (</span><span class='info'>Point to Multipoint Video Switching, with DTLS Key Transport</span><span>)</span></a> above, each speaker
        transmits with his own SRTP key. That SRTP key is derived from the
        DTLS handshake with the switcher. Each speaker uses KTR to signal the
        SSRC that it will use.
</p>
<a name="sec-scaling"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.4"></a><h3>3.4.&nbsp;
Scaling to Large Groups</h3>

<p>This section describes how DTLS-SRTP-Key-Transport supports large
        groups of listeners, both for unicast and multicast scenarios.
</p>
<a name="sec-scaling-lkh"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.4.1"></a><h3>3.4.1.&nbsp;
Rekeying SRTP Quickly</h3>

<p>When a new listener is added, or an existing listener is removed,
          a new SRTP master key is necessary to retain the security of the
          SRTP media. Normally this causes "n" cryptographic operations for
          "n" listeners. These cryptographic operations take time, and if the
          group is large enough or the processor slow enough, there can be a
          considerable delay before all listeners receive the new SRTP key
          (and can decrypt the stream).
</p>
<p>A solution to the problem is to use a subset difference based key
          management scheme <a class='info' href='#I-D.irtf-smug-subsetdifference'>[I&#8209;D.irtf&#8209;smug&#8209;subsetdifference]<span> (</span><span class='info'>Lotspiech, J., Naor, M., and D. Naor, &ldquo;Subset-Difference based Key Management for Secure           Multicast,&rdquo; .</span><span>)</span></a>. In this scheme, the
          key server (the speaker) can send a message so that every authorized
          listener -- but no unauthorized listeners -- can decrypt the
          message. The message contains the new SRTP key. The advantage of
          this scheme is that subset difference allows the message to be
          encrypted just once, no matter how many listeners there are.
</p>
<p>An implementation of subset-difference based key management is
          <a class='info' href='#RFC2627'>Logical Key Heirarchy (LKH)<span> (</span><span class='info'>Wallner, D., Harder, E., and R. Agee, &ldquo;Key Management for Multicast: Issues and Architectures,&rdquo; June&nbsp;1999.</span><span>)</span></a> [RFC2627]), which is
          useful for unicast and multicast. LKH is supported by primitives
          defined in this document, and the LKH "NET KEY" is communicated
          using the KTR primitive "LKH_NET_KEY".
</p>
<a name="sec-scaling-distributed"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.4.2"></a><h3>3.4.2.&nbsp;
Distributed Key Servers</h3>

<p>Another problem with all group scenarios is that because each
          listener establishes a DTLS-SRTP session with the speaker, only a
          finite number of listeners can be supported (the speaker cannot
          handle millions of DTLS-SRTP sessions). This is especially
          problematic for multicast, but is also a problem for "large"
          groups.
</p>
<p>One workaround to the problem is distributing the DTLS-SRTP
          keying to other devices in the network. In this scheme, one key
          server is responsible for a sensible number of listeners and has
          sufficient CPU power to update those listeners with new SRTP master
          keys. This is done with a new SDP attribute, dtls-srtp-ktr-server,
          which indicates the IP address and port of DTLS-SRTP server
          associated with the media line.
</p>
<p>There would need to be some communication between the KTR servers
          to communicate new SRTP keys to the listeners. This communication is
          for future study.
</p>
<a name="anchor3"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.5"></a><h3>3.5.&nbsp;
Interworking with Other SRTP Key Management Systems</h3>

<a name="anchor4"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.5.1"></a><h3>3.5.1.&nbsp;
Security Descriptions</h3>

<p>Today, <a class='info' href='#RFC4568'>Security Descriptions<span> (</span><span class='info'>Andreasen, F., Baugher, M., and D. Wing, &ldquo;Session Description Protocol (SDP) Security Descriptions for Media Streams,&rdquo; July&nbsp;2006.</span><span>)</span></a> [RFC4568] is
          used for distributing SRTP keys in several different IP PBX systems
          and is expected to be used by 3GPP's Long Term Evolution (LTE). The
          IP PBX systems are typically used within a single enterprise, and
          LTE is used within the confines of a mobile operator's network. A
          Session Border Controller is a reasonable solution to interwork
          between Security Descriptions (inside the enterprise or mobile
          operator) and DTLS-SRTP (outside the enterprise), and would be
          placed at the edge of the enterprise network or the edge of the
          mobile operator's network.
</p>
<p>However, due to the way Security Descriptions and DTLS-SRTP
          manage their SRTP keys, such an SBC has to authenticate, decrypt,
          re-encrypt, and re-authenticate the SRTP (and SRTCP) packets in one
          direction, as shown in <a class='info' href='#interworking-expensive'>Figure&nbsp;6<span> (</span><span class='info'>Interworking Security Descriptions and DTLS-SRTP</span><span>)</span></a>, below. This is not
          desirable as it increases the cost of this SBC.
</p><br /><hr class="insert" />
<a name="interworking-expensive"></a>

<p>
</p><div style='display: table; width: 0; margin-left: auto; margin-right: auto'><pre>RFC4568 endpoint             SBC               DTLS-SRTP endpoint
       |                      |                       |
  1.   |---key=A-------------&gt;|                       |
  2.   |                      |&lt;-DTLS-SRTP handshake-&gt;|
  3.   |&lt;--key=B--------------|                       |
  4.   |                      |&lt;--SRTP, encrypted w/B-|
  5.   |&lt;-SRTP, encrypted w/B-|                       |
  6.   |-SRTP, encrypted w/A-&gt;|                       |
  7.   |            (decrypt, re-encrypt)             |
  8.   |                      |-SRTP, encrypted w/C--&gt;|
       |                      |                       |</pre></div>
<p>
</p><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;6: Interworking Security Descriptions and DTLS-SRTP&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>The message flow is as follows (similar steps occur with
          SRTCP):</p>
<ol class="text">
<li>The <a class='info' href='#RFC4568'>Security Descriptions<span> (</span><span class='info'>Andreasen, F., Baugher, M., and D. Wing, &ldquo;Session Description Protocol (SDP) Security Descriptions for Media Streams,&rdquo; July&nbsp;2006.</span><span>)</span></a> [RFC4568]
              endpoint discloses its SRTP key to the SBC, using a=crypto in
              its SDP.
</li>
<li>SBC completes DTLS-SRTP handshake. From this handshake, the
              SBC derives the SRTP key for traffic from the DTLS-SRTP endpoint
              (key B) and to the DTLS-SRTP endpoint (key C).
</li>
<li>The SBC communicates the SRTP encryption key (key B) to the
              Security Descriptions endpoint (using a=crypto). (There is no
              way, with DTLS-SRTP, to communicate the Security Descriptions
              key to the DTLS-SRTP key endpoint.)
</li>
<li>The DTLS-SRTP endpoint sends an SRTP key, encrypted with its
              key B. This is received by the SBC.
</li>
<li>The received SRTP packet is simply forwarded; the SBC does
              not need to do anything with this packet as its key (key B) was
              already communicated in step 3.
</li>
<li>The Security Descriptions endpoint sends an SRTP packet,
              encrypted with its key A.
</li>
<li>The SBC has to authenticate and decrypt the SRTP packet
              (using key A), and re-encrypt it and generate an HMAC (using key
              C).
</li>
<li>The SBC sends the new SRTP packet.
</li>
</ol>

<p>KTR can help avoid the computaionally-expensive operation so the
          SBC does not need not perform any per-packet operations on the SRTP
          (or SRTCP) packets in either direction. With KTR the SBC can simply
          forward the SRTP (and SRTCP) packets in both directions without
          per-packet HMAC or cryptographic operations.
</p>
<p>To accomplish this, KTR must be supported on the DTLS-SRTP
          endpoint, which allows the SBC to transport the Security Description
          key to the KTR endpoint and send the DTLS-SRTP key to the Security
          Descriptions endpoint. This works equally well for both incoming and
          outgoing calls. An abbreviated message flow is shown in <a class='info' href='#interworking-cheap'>Figure&nbsp;7<span> (</span><span class='info'>Interworking Security Descriptions and KTR</span><span>)</span></a>, below.
</p><br /><hr class="insert" />
<a name="interworking-cheap"></a>

<p>
</p><div style='display: table; width: 0; margin-left: auto; margin-right: auto'><pre>RFC4568 endpoint             SBC               DTLS-SRTP endpoint
       |                      |                       |
  1.   |---key=A-------------&gt;|                       |
  2.   |                      |&lt;-DTLS-SRTP handshake-&gt;|
  3.   |&lt;--key=B--------------|                       |
  4.   |                      |--new_srtp_key:A------&gt;|
  5.   |                      |&lt;--SRTP, encrypted w/B-|
  5.   |&lt;-SRTP, encrypted w/B-|                       |
  6.   |-SRTP, encrypted w/A-&gt;|                       |
  7.   |                      |-SRTP, encrypted w/A--&gt;|
       |                      |                       |</pre></div>
<p>
</p><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;7: Interworking Security Descriptions and KTR&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>The message flow is as follows (similar steps occur with
          SRTCP):</p>
<ol class="text">
<li>Security Descriptions endpoint discloses its SRTP key to the
              SBC (a=crypto).
</li>
<li>SBC completes DTLS-SRTP handshake. From this handshake, the
              SBC derives the SRTP key for traffic from the DTLS-SRTP endpoint
              (key B) and to the DTLS-SRTP endpoint (key C).
</li>
<li>The SBC communicates the SRTP encryption key (key B) to the
              Security Descriptions endpoint.
</li>
<li>The SBC uses the KTR to indicate the key (key A) the SBC will
              encrypt packets with key A to the DTLS-SRTP endpoint.
</li>
<li>The DTLS-SRTP endpoint sends an SRTP key, encrypted with its
              key B. This is received by the SBC.
</li>
<li>The received SRTP packet is simply forwarded; the SBC does
              not need to do anything with this packet as its key (key B) was
              communicated in step 3.
</li>
<li>The Security Descriptions endpoint sends an SRTP packet,
              encrypted with its key A.
</li>
<li>The received SRTP packet is simply forwarded; the SBC does
              not need to do anything with this packet as its key (key A) was
              communicated in step 4.
</li>
</ol>

<a name="sec_protocol_description"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4"></a><h3>4.&nbsp;
Protocol Description</h3>

<p>This section describes the extension to the DTLS protocol for KTR,
      which allows securely communicating the SRTP key to the DTLS peer.
</p>
<a name="anchor5"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.1"></a><h3>4.1.&nbsp;
key_transport (KTR) extension to DTLS-SRTP</h3>

<p>This document adds a new negotiated extension called
        "key_transport", which MUST only be requested in conjunction with the
        "use_srtp" extension (Section 3.2 of <a class='info' href='#I-D.ietf-avt-dtls-srtp'>[I&#8209;D.ietf&#8209;avt&#8209;dtls&#8209;srtp]<span> (</span><span class='info'>McGrew, D. and E. Rescorla, &ldquo;Datagram Transport Layer Security (DTLS) Extension to Establish Keys for Secure Real-time Transport Protocol (SRTP),&rdquo; February&nbsp;2009.</span><span>)</span></a>). The DTLS server indicates
        its support for key_transport by including key_transport in its
        ServerHello message. If a DTLS client includes key_transport in its
        ClientHello, but does not receive key_transport in the ServerHello,
        the DTLS client MUST NOT send DTLS packets with the srtp_key_transport
        content-type.
</p>
<p>Support for the DTLS Key Transport extension is indicated in SDP
        with the "srtp-kt" attribute. Advertising support for the extension is
        necessary in SDP because in some cases it is required to establish an
        SRTP call. For example, a mixer may be able to only support SRTP
        listeners if those listeners implement DTLS Key Transport (because it
        lacks the CPU cycles necessary to encrypt SRTP uniquely for each
        listener).
</p><br /><hr class="insert" />
<a name="handshake_message_flow"></a>

<p>A message flow showing a DTLS client and DTLS server using
          the key_transport extension
</p><div style='display: table; width: 0; margin-left: auto; margin-right: auto'><pre>
Client                                               Server

ClientHello + use_srtp + key_transport
                             --------&gt;
                     ServerHello + use_srtp + key_transport
                                               Certificate*
                                         ServerKeyExchange*
                                        CertificateRequest*
                             &lt;--------      ServerHelloDone
Certificate*
ClientKeyExchange
CertificateVerify*
[ChangeCipherSpec]
Finished                     --------&gt;
                                         [ChangeCipherSpec]
                             &lt;--------             Finished
SRTP packets                 &lt;-------&gt;      SRTP packets
</pre></div>
<p>
</p><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;8: Handshake Message Flow&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>After successful negotiation of the key_transport extension, the
        DTLS client and server MAY exchange SRTP packets, encrypted using the
        KDF described in <a class='info' href='#I-D.ietf-avt-dtls-srtp'>[I&#8209;D.ietf&#8209;avt&#8209;dtls&#8209;srtp]<span> (</span><span class='info'>McGrew, D. and E. Rescorla, &ldquo;Datagram Transport Layer Security (DTLS) Extension to Establish Keys for Secure Real-time Transport Protocol (SRTP),&rdquo; February&nbsp;2009.</span><span>)</span></a>. This
        is normal and expected, even if Key Transport was negotiated by both
        sides, as neither side may (yet) have a need to alter the SRTP key.
        However, it is also possible that one (or both) peers will immediately
        send a new_srtp_key message before sending any SRTP.
</p>
<a name="anchor6"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.2"></a><h3>4.2.&nbsp;
KTR Primitives</h3>

<p>A new protocol is defined, called the srtp_key_transport protocol
        which uses srtp_key_transport content-type which consists of the
        following message types (primitives):
</p>
<p></p>
<blockquote class="text"><dl>
<dt>new_srtp_key_request:</dt>
<dd>request that the DTLS peer
            choose a new key. Valid responses are new_srtp_key and
            new_srtp_key_error.
</dd>
<dt>your_new_srtp_key:</dt>
<dd>Dictates a new SRTP key for the
            peer to use when the peer transmits its SRTP packets.
</dd>
<dt>new_srtp_key:</dt>
<dd>contains the new SRTP keying material,
            the master key, master salt, SSRC, rollover counter, and sequence
            number. This message is sent by a DTLS endpoint that wants to
            change its SRTP key beginning at the indicated sequence number.
            This does not change any cryptographic parameters (a new DTLS
            handshake is necessary for that), but only the DTLS key for the
            associated SRTP session. This message includes the SSRC that will
            be used for this key, which allows listeners to establish one SRTP
            crypto-context per speaker (necessary for the video switching
            scenario). The key chosen MUST be cryptographically random <a class='info' href='#RFC4086'>[RFC4086]<span> (</span><span class='info'>Eastlake, D., Schiller, J., and S. Crocker, &ldquo;Randomness Requirements for Security,&rdquo; June&nbsp;2005.</span><span>)</span></a>. This master keying material is processed
            by the standard SRTP key deriviation function (Section 4.3.1 of
            <a class='info' href='#RFC3711'>SRTP<span> (</span><span class='info'>Baugher, M., McGrew, D., Naslund, M., Carrara, E., and K. Norrman, &ldquo;The Secure Real-time Transport Protocol (SRTP),&rdquo; March&nbsp;2004.</span><span>)</span></a> [RFC3711]) to provide the session
            keys.
</dd>
<dt>new_key_activate:</dt>
<dd>indicates receiver is prepared to
            receive SRTP packets encrypted with the new key.
</dd>
<dt>lkh_net_key</dt>
<dd>The Logical Key Hierarchy NET KEY.
</dd>
<dt>new_srtp_key_failure:</dt>
<dd>indicates a failure.
</dd>
</dl></blockquote>

<p>At any time, the DTLS client or DTLS server MAY send a
        key_transport message, as shown in <a class='info' href='#new_key_message_flow'>Figure&nbsp;9<span> (</span><span class='info'>New Key Message Flow</span><span>)</span></a>. The sender of the new_srtp_key
        message MAY immediately start transmitting SRTP packets with this new
        key. However, to account for loss of the new_srtp_key message it is
        RECOMMENDED that the sender wait before changing to the new SRTP key
        until it receives the new_key_activate message or it times out waiting
        for the new_key_activate_message. The duration of this timeout may
        vary depending on the sensitivity of the content (e.g., 1 second or 10
        seconds). In any case, the new_srtp_key message is retransmitted until
        acknowledged by receipt of a new_key_activate message.
</p><br /><hr class="insert" />
<a name="new_key_message_flow"></a>

<p>
</p><div style='display: table; width: 0; margin-left: auto; margin-right: auto'><pre>Client / Server                             Server / Client

[new_srtp_key_request]        --------&gt;
                             &lt;--------         new_srtp_key
new_srtp_key_activiate        --------&gt;</pre></div>
<p>
</p><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;9: New Key Message Flow&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>The following figure shows the state machine for the protocol.
</p><br /><hr class="insert" />
<a name="state_machine"></a>

<p>
</p><div style='display: table; width: 0; margin-left: auto; margin-right: auto'><pre>      receive new_srtp_key_request from peer
         or decide to choose new SRTP key
                     |
                     |
send                 V
new_srtp_key  +---------------+    timeout
    +---------| Communicate   |--------+
    |         |     Key       |        |
    +--------&gt;|               |        |
              +---------------+        |
                |           ^          |
     receive    |           |   +----------------+
new_key_activate|           +---| send SRTP using|
                |               |  new SRTP key  |
        +----------------+      +----------------+
        | send SRTP using|
        |  new SRTP key  |
        +----------------+
                |
                V
               done</pre></div>
<p>
</p><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;10: Key Transport protocol state machine&nbsp;</b></font><br /></td></tr></table><hr class="insert" />
<br /><hr class="insert" />
<a name="datastructure"></a>

<p>Using the syntax described in <a class='info' href='#RFC4346'>TLS<span> (</span><span class='info'>Dierks, T. and E. Rescorla, &ldquo;The Transport Layer Security (TLS) Protocol Version 1.1,&rdquo; April&nbsp;2006.</span><span>)</span></a> [RFC4346], the following structures are
          used:
</p><div style='display: table; width: 0; margin-left: auto; margin-right: auto'><pre>
enum {
   new_srtp_key_request(0),
   your_new_srtp_key(1),
   new_srtp_key(2),
   new_srtp_key_activate(3),
   lkh_net_key(4),
   new_srtp_key_failure(128),
   (255)
} SRTPKeyTransportType;

struct {
   SRTPKeyTransportType keytrans_type;
   uint24 length;
   uint16 message_seq;
   uint24 fragment_offset;
   uint24 fragment_length;
   select (SRTPKeyTransportType) {
      case new_srtp_key_request:         NewSRTPKeyRequest;
      case your_new_srtp_key:            YourNewSRTPKey;
      case new_srtp_key:                 NewSRTPKey;
      case new_srtp_key_activate:        NewSRTPKeyActivate;
      case lkh_net_key:                  LKHNetKey;
      case new_srtp_key_failure:         NewSRTPKeyFailure;
    };
} KeyTransport;

struct {
    uint  random&lt;64&gt;;           // additional entropy for peer
} NewSRTPKeyRequest;

struct {
    boolean any_ssrc;           // true=this key applies to any SSRC
    uint32 ssrc;                // SSRC used for this key.
    uint   key&lt;16..32&gt;;         // change_cipher_spec decides
    uint   auth_tag&lt;4..10&gt;;     // the key and auth_tag length.
    uint   salt&lt;112&gt;;
    uint   roc&lt;32&gt;;
    uint   sequence&lt;16&gt;;
    uint   random&lt;64&gt;;          // random provides additional entropy
                                // for peer
} NewSRTPKey;

struct {
    uint  random&lt;64&gt;;           // additional entropy for peer
} NewSRTPKeyActivate;

struct {
    uint  lkhnetkeylength;      // length in bits, divided by 8
    uint  lkhnetkey&lt;128..1024&gt;; // LKH NET KEY
} LKHNetKey;

struct { } NewSRTPKeyFailure;</pre></div>
<p>
</p><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;11: Data Structures&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<a name="procedures"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.3"></a><h3>4.3.&nbsp;
Procedures for Network Elements</h3>

<p>A 'speaker' is an endpoint that terminates the DTLS-SRTP exchange
        and also sends SRTP data towards its peer(s). This is usually
        indicated by 'sendrecv' or 'sendonly'.
</p>
<p>A 'listener' is an endpoint that terminates the DTLS-SRTP exchange
        and also receives SRTP data from its peer(s). This is usually
        indicated by 'sendrecv' or 'recvonly'.
</p>
<p>As the Key Transport extension was negotiated during the DTLS-SRTP
        handshake, an endpoint can send Key Transport primitives, and can
        become a speaker or become a listener, at any point.
</p>
<a name="procedure_speaker"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.3.1"></a><h3>4.3.1.&nbsp;
Speaker</h3>

<p>When a new speaker joins, the speaker can immediately send SRTP
          using the key derived from the DTLS-SRTP handshake. There is no
          scaling advantage to all of the speakers using the same key (because
          their content is different), and if the speakers did use the same
          key it would also introduce the risk of a two-time pad.
</p>
<p>Once a speaker begins sending SRTP packets using a key
          communicated via KTR (i.e., the NewSRTPKey primitive), the speaker
          MUST NOT revert to using the SRTP key derived from the DTLS-SRTP
          handshake.
</p>
<p>If the speaker wants to use KTR, or is requested to change its
          SRTP key (via the NewSRTPKeyRequest primitive), the speaker chooses
          a new SRTP master key and salt, and chooses a sequence number a
          reasonable distance in the future (1 second is recommended). The
          speaker then sends this new key using the NewSRTPKey primitive. The
          NewSRTPKey primitive message is re-transmitted until acknowledged
          with a NewKeyActivate message. No matter if a NewKeyActiviate is
          received or not, the speaker changes keys at its previously-chosen
          sequence number.
</p>
<p>continue SRTP key may be determined via DTLS-SRTP or by a KTR
          primitives. In either case, the speaker's SRTP key and SSRC is
          communicated, to each peer.
</p>
<a name="procedure_mixer"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.3.2"></a><h3>4.3.2.&nbsp;
Mixer</h3>

<p>When a new speaker joins a mixer, the speaker does not need to
          support KTR, and no KTR procedures need to occur with the speaker.
          This is because the listener needs to decrypt and examine the
          speaker's stream, and the mixer will mix, re-originate (with its own
          SSRC) and re-encrypt the speaker's stream to the listeners.
</p>
<p>The mixer functions as a speaker (<a class='info' href='#procedure_speaker'>Section&nbsp;4.3.1<span> (</span><span class='info'>Speaker</span><span>)</span></a>) towards the listeners connected
          to the mixer.
</p>
<p>When a speaker leaves, there is no need to propagate that
          information beyond the mixer.
</p>
<p>When a listener joins or leaves, the mixer MUST rekey all of the
          listeners based on the conference policy (<a class='info' href='#sec-group-policy'>Section&nbsp;6.1<span> (</span><span class='info'>Group Policy when Joining/Leaving</span><span>)</span></a>).
</p>
<a name="procedure_switcher"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.3.3"></a><h3>4.3.3.&nbsp;
Switcher</h3>

<p>When a new speaker joins, the switcher communicates the speaker's
          key to all listeners using the NewSRTPKey primitive. In this way,
          whenever one of the speakers becomes the active speaker, the active
          speaker's SRTP can be immediately sent to all listeners.
</p>
<p>In the event there are a large number of (potentially active)
          speakers and it is not feasible to inform all listeners of all
          speaker's keys, the switcher MAY decide to defer informing
          listeneners of a speaker's key until the speaker becomes the active
          speaker. This can cause some clipping when a speaker becomes the
          active speaker.
</p>
<a name="procedure_listener"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.3.4"></a><h3>4.3.4.&nbsp;
Listener</h3>

<p>When a listener joins, the listener is provided the same SRTP
          master key as the other listeners. This is done with the NewSRTPKey
          primitive. SRTP master keys are associated with both an SSRC and the
          RTP sequence number. A single SRTP stream might have multiple keys
          active at any point in time, such as when other listeners are
          joining or leaving. For example, two NewSRTPKey primitives can
          indicate that for a single SSRC value, key "A" is for sequence
          numbers 100-200, and key B is for 200-300.
</p>
<p>If a listener is also a speaker, it also follows the rules of a
          speaker.
</p>
<p>A listener can receive an SRTP packet with an unknown SSRC which
          could caused by either:
</p>
<p></p>
<ul class="text">
<li>the speaker changed its SSRC (due to SSRC collision)
</li>
<li>the speaker changed its SRTP master key
</li>
</ul><p>the listener can attempt to authenticate the packet using
          the most-recently-used SRTP master key, which helps in the first
          case. If the second case has occurred, the listener can only wait
          until the sender (the speaker, the mixer, or the switcher) sends a
          NewSRTPKey primitive.
</p>
<a name="anchor7"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.4"></a><h3>4.4.&nbsp;
Key Transport SSRC and RTP SSRC Collisions</h3>

<p>Per <a class='info' href='#RFC3550'>[RFC3550]<span> (</span><span class='info'>Schulzrinne, H., Casner, S., Frederick, R., and V. Jacobson, &ldquo;RTP: A Transport Protocol for Real-Time Applications,&rdquo; July&nbsp;2003.</span><span>)</span></a>, if an RTP source notices an RTP
        SSRC collision, it is required to change its SSRC. If it has
        negotiated support for KTR, it then MUST also send a NewSRTPKey
        message indicating the new SSRC. The communication of the new SSRC is
        necessary if there are multiple speakers in the video switching
        scenario. However, because a speaker is not able to determine if their
        audio or their video is being switched, a speaker MUST always indicate
        a change in SSRC by following the procedure in this section for any
        SRTP stream (audio, video, or other).
</p>
<p>When this is done, in order to prevent clipping in listeners, it is
        RECOMMENDED that the speaker retain the same SRTP master key and
        salt.
</p>
<a name="anchor8"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.5"></a><h3>4.5.&nbsp;
Fragmentation, Reassembly, and Retransmission</h3>

<p>Much like the DTLS handshake itself, the KTR extension also needs
        to handle fragmentation and reassembly (to send a large key) and
        retransmission (to account for packet loss). This is to allow
        communicating SRTP keys which are longer than the network MTU. The
        same technique as DTLS's handshake are used to provide this function:
        message_seq, fragment_offset, and fragment_length.
</p>
<p>When transmitting the key transport message, the sender divides the
        message into a series of N contiguous data ranges. These ranges MUST
        NOT be larger than the maximum handshake fragment size and MUST
        jointly contain the entire key transport message. The ranges SHOULD
        NOT overlap. The sender then creates N key transport messages, all
        with the same message_seq value as the original key transport message.
        Each new message is labelled with the fragment_offset (the number of
        bytes contained in previous fragments) and the fragment_length (the
        length of this fragment). The length field in all messages is the same
        as the length field of the original message. An unfragmented message
        is a degenerate case with fragment_offset=0 and
        fragment_length=length.
</p>
<p>When a DTLS implementation receives a key transport message
        fragment, it MUST buffer it until it has the entire key transport
        message. DTLS implementations MUST be able to handle overlapping
        fragment ranges. This allows senders to retransmit key transport
        messages with smaller fragment sizes during path MTU discovery.
</p>
<a name="anchor9"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.6"></a><h3>4.6.&nbsp;
SDP extensions</h3>

<p>Two new SDP attributes are defined, dtls-srtp-ktr and
        dtls-srtp-ktr-server. dtls-srtp-ktr merely indicates the endpoint is
        capable of DTLS-SRTP-KTR, and is helpful to diagnose interoperability
        issues. dtls-srtp-ktr-server causes the DTLS handshake to occur with a
        different host than that indicated by the c/m lines, which is useful
        to help offload computational effort from the speaker (<a class='info' href='#sec-scaling-distributed'>Section&nbsp;3.4.2<span> (</span><span class='info'>Distributed Key Servers</span><span>)</span></a>). Either attribute can appear
        at the media level or session level.
</p>
<p>The <a class='info' href='#RFC5234'>ABNF<span> (</span><span class='info'>Crocker, D. and P. Overell, &ldquo;Augmented BNF for Syntax Specifications: ABNF,&rdquo; January&nbsp;2008.</span><span>)</span></a> [RFC5234] for new <a class='info' href='#RFC4566'>SDP<span> (</span><span class='info'>Handley, M., Jacobson, V., and C. Perkins, &ldquo;SDP: Session Description Protocol,&rdquo; July&nbsp;2006.</span><span>)</span></a> [RFC4566] attributes is as follows:
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
  ktr-server  = "dtls-srtp-ktr-server:" port
                [space nettype space addrtype
                 space connection-address]
  ktr-capable = "dtls-srtp-ktr"

</pre></div>
<p>Only the port is required; if the nettype is not
          indicated, the network type, address type, and connection-address
          are all the same as on the associated c= line.
</p>
<a name="anchor10"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5"></a><h3>5.&nbsp;
Examples</h3>
<br /><hr class="insert" />
<a name="fig_example_simple_offer_kt_required"></a>

<p>The following example shows how Key Transport would be
        requested in an offer, using "a=dtls-srtp-kt".
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
      v=0
      o=- 25678 753849 IN IP4 192.0.2.1
      s=
      c=IN IP4 192.0.2.1
      t=0 0
      m=audio 53456 UDP/TLS/RTP/SAVP 0
      a=fingerprint:SHA-1 \
        4A:AD:B9:B1:3F:82:18:3B:54:02:12:DF:3E:5D:49:6B:19:E5:7C:AB
      a=dtls-srtp-ktr</pre></div>
<p>
</p><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;12: Simple SDP offer showing Key Transport is required&nbsp;</b></font><br /></td></tr></table><hr class="insert" />
<br /><hr class="insert" />
<a name="fig_example_offer_kt_required"></a>

<p>Using the SDP syntax described in <a class='info' href='#I-D.ietf-mmusic-sdp-capability-negotiation'>[I&#8209;D.ietf&#8209;mmusic&#8209;sdp&#8209;capability&#8209;negotiation]<span> (</span><span class='info'>Andreasen, F., &ldquo;SDP Capability Negotiation,&rdquo; March&nbsp;2010.</span><span>)</span></a>, the
        following figure shows an offerer that requires DTLS Key Transport in
        order to set up this call as an SRTP call, otherwise it can set up
        this call as an RTP call. This is indicated by the ",2" on the
        "a=pcfg" line. If the answerer does not understand "a=dtls-srtp-kt"
        but does understand DTLS-SRTP and <a class='info' href='#I-D.ietf-mmusic-sdp-capability-negotiation'>[I&#8209;D.ietf&#8209;mmusic&#8209;sdp&#8209;capability&#8209;negotiation]<span> (</span><span class='info'>Andreasen, F., &ldquo;SDP Capability Negotiation,&rdquo; March&nbsp;2010.</span><span>)</span></a>, this can
        cannot be established using DTLS-SRTP; however, it can be established
        using RTP.
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
      v=0
      o=- 25678 753849 IN IP4 192.0.2.1
      s=
      c=IN IP4 192.0.2.1
      t=0 0
      m=audio 53456 RTP/AVP 0
      a=tcap:1 UDP/TLS/RTP/SAVP
      a=acap:1 fingerprint:SHA-1 \
        4A:AD:B9:B1:3F:82:18:3B:54:02:12:DF:3E:5D:49:6B:19:E5:7C:AB
      a=acap:2 dtls-srtp-ktr
      a=pcfg:1 t=1 a=1,2</pre></div>
<p>
</p><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;13: Example SDP offer showing Key Transport is required&nbsp;</b></font><br /></td></tr></table><hr class="insert" />
<br /><hr class="insert" />
<a name="fig_example_offer_kt_optional"></a>

<p>Using the SDP syntax described in <a class='info' href='#I-D.ietf-mmusic-sdp-capability-negotiation'>[I&#8209;D.ietf&#8209;mmusic&#8209;sdp&#8209;capability&#8209;negotiation]<span> (</span><span class='info'>Andreasen, F., &ldquo;SDP Capability Negotiation,&rdquo; March&nbsp;2010.</span><span>)</span></a>, the
        following figure shows an offerer that indicates support for DTLS Key
        Transport but does not require DTLS Key Transport in order to set up
        this call as an SRTP call. This is indicated by the ",[2]" on the
        "a=pcfg" line. If the answerer does not understand "a=dtls-srtp-kt"
        but does understand DTLS-SRTP and <a class='info' href='#I-D.ietf-mmusic-sdp-capability-negotiation'>[I&#8209;D.ietf&#8209;mmusic&#8209;sdp&#8209;capability&#8209;negotiation]<span> (</span><span class='info'>Andreasen, F., &ldquo;SDP Capability Negotiation,&rdquo; March&nbsp;2010.</span><span>)</span></a>, this call
        can still be established using DTLS-SRTP.
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
      v=0
      o=- 25678 753849 IN IP4 192.0.2.1
      s=
      c=IN IP4 192.0.2.1
      t=0 0
      m=audio 53456 RTP/AVP 0
      a=tcap:1 UDP/TLS/RTP/SAVP
      a=acap:1 fingerprint:SHA-1 \
          4A:AD:B9:B1:3F:82:18:3B:54:02:12:DF:3E:5D:49:6B:19:E5:7C:AB
      a=acap:2 dtls-srtp-ktr
      a=pcfg:1 t=1 a=1,[2]</pre></div>
<p>
</p><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;14: Example SDP offer showing Key Transport is optional&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>
</p><br /><hr class="insert" />
<a name="fig_example_ktr_server"></a>

<p>The following example shows a Key Transport offer where the
        DTLS-SRTP-KTR exchange occurs with another server.
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
      v=0
      o=- 25678 753849 IN IP4 192.0.2.1
      s=
      c=IN IP4 192.0.2.1
      t=0 0
      m=audio 53456 UDP/TLS/RTP/SAVP 0
      a=fingerprint:SHA-1 \
        4A:AD:B9:B1:3F:82:18:3B:54:02:12:DF:3E:5D:49:6B:19:E5:7C:AB
      a=dtls-srtp-ktr
      a=dtls-srtp-ktr-server:37382 IN IP4 192.0.2.2</pre></div>
<p>
</p><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;15: Example showing alternate key server&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<a name="security_considerations"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6"></a><h3>6.&nbsp;
Security Considerations</h3>

<p>In the point-to-multipoint scenario, <a class='info' href='#section_point_multipoint'>Section&nbsp;3.1<span> (</span><span class='info'>Point to Multipoint using the RFC 3550 mixer model</span><span>)</span></a>, all of the listeners know the
      key being used by the mixer. Any of those listeners could create SRTP
      packets that are encrypted with this same key, and send those SRTP
      packets to other listeners. In order to reduce the vulnerability to this
      threat, it is RECOMMENDED that the source transport address of received
      SRTP packets be discarded if they do not match the source transport
      address of the associated DTLS-SRTP session. Additionally, the network
      SHOULD prevent IP address spoofing <a class='info' href='#RFC2827'>[RFC2827]<span> (</span><span class='info'>Ferguson, P. and D. Senie, &ldquo;Network Ingress Filtering: Defeating Denial of Service Attacks which employ IP Source Address Spoofing,&rdquo; May&nbsp;2000.</span><span>)</span></a>.
</p>
<a name="sec-group-policy"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.1"></a><h3>6.1.&nbsp;
Group Policy when Joining/Leaving</h3>

<p>When sharing SRTP keys with several listeners, it is imperative
        that the SRTP is changed when a new listener is added or a listener is
        removed. This is because a legitimate listener should only be able to
        decrypt the SRTP stream while he is listening; he should not be able
        to decrypt the SRTP stream prior to joining the conference or after
        leaving the conference. Failing to change the key when a listener
        joins (or leaves) allows a listener to decrypt SRTP traffic prior to
        (or after) they are authorized participants in the conference.
</p>
<p>Policies for a specific user's access to a conference may be
        different from conference to conference. For example, a
        company-internal event announcing promotions might be accessible to
        all employees and have no need for re-keying when listeners join or
        leave the conference. As another example, a conference where a job
        candidate is interviewed should be rekeyed when the job candidate
        joins the conference and again when the job candidate leaves the
        conference.
</p>
<p>The protocol described in this document allows whichever policy is
        needed for a particular situation. The protocol itself does not
        enforce a certain policy; that is, the protocol itself does not ensure
        the SRTP key is changed when a listener leaves (or joins) the
        conference.
</p>
<p>The RTP sequence number in the NewSRTPKey primitive allows the old
        key to be used for a predictable period of time before switching to
        the new key. This can provide sufficient time for all listeners to
        learn the new SRTP key before the sender switches to the new key.
</p>
<a name="two-time-pad"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.2"></a><h3>6.2.&nbsp;
Two-Time Pad</h3>

<p>[[expand this section.]]
</p>
<p>In some scenarios, different data is sent to different
        participants. For example, in the audio mixer scenario, the active
        speaker receives a different stream than the other listeners; the
        active speaker's stream does not contain the active speaker's own
        input. It is critical that the same SRTP key is not used for the
        different content, or else a (so-called) "two-time pad" occurs
        (Section 9.1 of <a class='info' href='#RFC3711'>[RFC3711]<span> (</span><span class='info'>Baugher, M., McGrew, D., Naslund, M., Carrara, E., and K. Norrman, &ldquo;The Secure Real-time Transport Protocol (SRTP),&rdquo; March&nbsp;2004.</span><span>)</span></a>).
</p>
<p>The same SRTP key MUST NOT be used to send different data.
</p>
<a name="anchor11"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7"></a><h3>7.&nbsp;
Acknowledgements</h3>

<p>Thanks to David McGrew for his improvements to this document and to
      the underlying protocol. Thanks to Brian Weis, Sheela Rowles, and Mark
      Baugher for suggesting how GDOI-SRTP's key management could be used by
      DTLS-SRTP.
</p>
<p>Thanks to Flemming Andreasen for the reminder regarding two-time
      pads, to John Floroiu for reminder of salting key.
</p>
<a name="anchor12"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.8"></a><h3>8.&nbsp;
IANA Considerations</h3>

<p>[[This section will be completed in a future version of this
      document.]]
</p>
<p>To do: </p>
<ul class="text">
<li>Register new SDP attribute "dtls-srtp-ktr"
</li>
<li>Register new SDP attribute "dtls-srtp-ktr-server"
</li>
<li>new TLS content-type "key_transport" (26?)
</li>
</ul>

<a name="rfc.references"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.9"></a><h3>9.&nbsp;
References</h3>

<a name="rfc.references1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>9.1.&nbsp;Normative References</h3>
<table width="99%" border="0">
<tr><td class="author-text" valign="top"><a name="I-D.ietf-avt-dtls-srtp">[I-D.ietf-avt-dtls-srtp]</a></td>
<td class="author-text">McGrew, D. and E. Rescorla, &ldquo;<a href="http://www.ietf.org/internet-drafts/draft-ietf-avt-dtls-srtp-07.txt">Datagram Transport Layer Security (DTLS) Extension to Establish Keys for Secure Real-time Transport Protocol (SRTP)</a>,&rdquo; draft-ietf-avt-dtls-srtp-07 (work in progress), February&nbsp;2009 (<a href="http://www.ietf.org/internet-drafts/draft-ietf-avt-dtls-srtp-07.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="I-D.ietf-mmusic-sdp-capability-negotiation">[I-D.ietf-mmusic-sdp-capability-negotiation]</a></td>
<td class="author-text">Andreasen, F., &ldquo;<a href="http://www.ietf.org/internet-drafts/draft-ietf-mmusic-sdp-capability-negotiation-13.txt">SDP Capability Negotiation</a>,&rdquo; draft-ietf-mmusic-sdp-capability-negotiation-13 (work in progress), March&nbsp;2010 (<a href="http://www.ietf.org/internet-drafts/draft-ietf-mmusic-sdp-capability-negotiation-13.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC2119">[RFC2119]</a></td>
<td class="author-text"><a href="mailto:sob@harvard.edu">Bradner, S.</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>,&rdquo; BCP&nbsp;14, RFC&nbsp;2119, March&nbsp;1997 (<a href="http://www.rfc-editor.org/rfc/rfc2119.txt">TXT</a>, <a href="http://xml.resource.org/public/rfc/html/rfc2119.html">HTML</a>, <a href="http://xml.resource.org/public/rfc/xml/rfc2119.xml">XML</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC2827">[RFC2827]</a></td>
<td class="author-text">Ferguson, P. and D. Senie, &ldquo;<a href="http://tools.ietf.org/html/rfc2827">Network Ingress Filtering: Defeating Denial of Service Attacks which employ IP Source Address Spoofing</a>,&rdquo; BCP&nbsp;38, RFC&nbsp;2827, May&nbsp;2000 (<a href="http://www.rfc-editor.org/rfc/rfc2827.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4346">[RFC4346]</a></td>
<td class="author-text">Dierks, T. and E. Rescorla, &ldquo;<a href="http://tools.ietf.org/html/rfc4346">The Transport Layer Security (TLS) Protocol Version 1.1</a>,&rdquo; RFC&nbsp;4346, April&nbsp;2006 (<a href="http://www.rfc-editor.org/rfc/rfc4346.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4566">[RFC4566]</a></td>
<td class="author-text">Handley, M., Jacobson, V., and C. Perkins, &ldquo;<a href="http://tools.ietf.org/html/rfc4566">SDP: Session Description Protocol</a>,&rdquo; RFC&nbsp;4566, July&nbsp;2006 (<a href="http://www.rfc-editor.org/rfc/rfc4566.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC5234">[RFC5234]</a></td>
<td class="author-text">Crocker, D. and P. Overell, &ldquo;<a href="http://tools.ietf.org/html/rfc5234">Augmented BNF for Syntax Specifications: ABNF</a>,&rdquo; STD&nbsp;68, RFC&nbsp;5234, January&nbsp;2008 (<a href="http://www.rfc-editor.org/rfc/rfc5234.txt">TXT</a>).</td></tr>
</table>

<a name="rfc.references2"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>9.2.&nbsp;Informational References</h3>
<table width="99%" border="0">
<tr><td class="author-text" valign="top"><a name="I-D.ietf-msec-gdoi-srtp">[I-D.ietf-msec-gdoi-srtp]</a></td>
<td class="author-text">Baugher, M., Rueegsegger, A., and S. Rowles, &ldquo;<a href="http://www.ietf.org/internet-drafts/draft-ietf-msec-gdoi-srtp-01.txt">GDOI Key Establishment for the SRTP Data Security Protocol</a>,&rdquo; draft-ietf-msec-gdoi-srtp-01 (work in progress), December&nbsp;2007 (<a href="http://www.ietf.org/internet-drafts/draft-ietf-msec-gdoi-srtp-01.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="I-D.irtf-smug-subsetdifference">[I-D.irtf-smug-subsetdifference]</a></td>
<td class="author-text">Lotspiech, J., Naor, M., and D. Naor, &ldquo;<a href="http://tools.ietf.org/html/draft-irtf-smug-subsetdifference">Subset-Difference based Key Management for Secure
          Multicast</a>.&rdquo;</td></tr>
<tr><td class="author-text" valign="top"><a name="I-D.mcgrew-srtp-ekt">[I-D.mcgrew-srtp-ekt]</a></td>
<td class="author-text">McGrew, D., Andreasen, F., Wing, D., and L. Dondeti, &ldquo;<a href="http://www.ietf.org/internet-drafts/draft-mcgrew-srtp-ekt-06.txt">Encrypted Key Transport for Secure RTP</a>,&rdquo; draft-mcgrew-srtp-ekt-06 (work in progress), October&nbsp;2009 (<a href="http://www.ietf.org/internet-drafts/draft-mcgrew-srtp-ekt-06.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC2627">[RFC2627]</a></td>
<td class="author-text"><a href="mailto:dmwalln@orion.ncsc.mil">Wallner, D.</a>, <a href="mailto:ejh@tycho.ncsc.mil">Harder, E.</a>, and R. Agee, &ldquo;<a href="http://tools.ietf.org/html/rfc2627">Key Management for Multicast: Issues and Architectures</a>,&rdquo; RFC&nbsp;2627, June&nbsp;1999 (<a href="http://www.rfc-editor.org/rfc/rfc2627.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC3550">[RFC3550]</a></td>
<td class="author-text">Schulzrinne, H., Casner, S., Frederick, R., and V. Jacobson, &ldquo;<a href="http://tools.ietf.org/html/rfc3550">RTP: A Transport Protocol for Real-Time Applications</a>,&rdquo; STD&nbsp;64, RFC&nbsp;3550, July&nbsp;2003 (<a href="http://www.rfc-editor.org/rfc/rfc3550.txt">TXT</a>, <a href="http://www.rfc-editor.org/rfc/rfc3550.ps">PS</a>, <a href="http://www.rfc-editor.org/rfc/rfc3550.pdf">PDF</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC3711">[RFC3711]</a></td>
<td class="author-text">Baugher, M., McGrew, D., Naslund, M., Carrara, E., and K. Norrman, &ldquo;<a href="http://tools.ietf.org/html/rfc3711">The Secure Real-time Transport Protocol (SRTP)</a>,&rdquo; RFC&nbsp;3711, March&nbsp;2004 (<a href="http://www.rfc-editor.org/rfc/rfc3711.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4086">[RFC4086]</a></td>
<td class="author-text">Eastlake, D., Schiller, J., and S. Crocker, &ldquo;<a href="http://tools.ietf.org/html/rfc4086">Randomness Requirements for Security</a>,&rdquo; BCP&nbsp;106, RFC&nbsp;4086, June&nbsp;2005 (<a href="http://www.rfc-editor.org/rfc/rfc4086.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4568">[RFC4568]</a></td>
<td class="author-text">Andreasen, F., Baugher, M., and D. Wing, &ldquo;<a href="http://tools.ietf.org/html/rfc4568">Session Description Protocol (SDP) Security Descriptions for Media Streams</a>,&rdquo; RFC&nbsp;4568, July&nbsp;2006 (<a href="http://www.rfc-editor.org/rfc/rfc4568.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC5117">[RFC5117]</a></td>
<td class="author-text">Westerlund, M. and S. Wenger, &ldquo;<a href="http://tools.ietf.org/html/rfc5117">RTP Topologies</a>,&rdquo; RFC&nbsp;5117, January&nbsp;2008 (<a href="http://www.rfc-editor.org/rfc/rfc5117.txt">TXT</a>).</td></tr>
</table>

<a name="ekt"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.A"></a><h3>Appendix A.&nbsp;
Relationship with EKT</h3>

<p><a class='info' href='#I-D.mcgrew-srtp-ekt'>Encrypted Key Transport
      (EKT)<span> (</span><span class='info'>McGrew, D., Andreasen, F., Wing, D., and L. Dondeti, &ldquo;Encrypted Key Transport for Secure RTP,&rdquo; October&nbsp;2009.</span><span>)</span></a> [I&#8209;D.mcgrew&#8209;srtp&#8209;ekt] uses RTCP to send new SRTP keys. For EKT to operate, it
      needs to distribute its Key Encryption Key (KEK) to all authorized
      listeners, and EKT describes how Security Descriptions can be provide
      that function. While KTR could also provide the same function, KTR as
      described in this document does not support EKT.
</p>
<p>This is because EKT can not satisfy the video switching scenario
      (<a class='info' href='#sec-video-switching'>Section&nbsp;3.3<span> (</span><span class='info'>Point to Multipoint Using Video Switching MCUs</span><span>)</span></a>) when listeners are ejected
      or added to the group. In order for EKT to work in that scenario, the
      video switcher would have to synthesize RTCP packets on behalf of the
      video sender, or the video switcher would have to tell the video sender
      exactly how to generate its EKT KEK message for consumption by the
      DTLS-SRTP-Key-Transport listeners -- which is something only the video
      switcher should be responsible for doing. Even more complexity would be
      introduced if LKH is used between the video switcher and the listeners,
      because only the video switcher is aware of the group membership (the
      speaker is not) and the video switcher would have to communicate LKH
      hierarchical information to the speaker so the speaker could generate
      the EKT message. This would distribute LKH between the speaker and the
      video switcher. It is more desirable to retain LKH complexity within the
      video switcher -- as is proposed in <a class='info' href='#sec-scaling'>Section&nbsp;3.4<span> (</span><span class='info'>Scaling to Large Groups</span><span>)</span></a>.
</p>
<p>For the other scenarios, EKT or KTR would work equally well. But EKT
      still needs a way to securely communicate its Key Encryption Key to the
      authorized listeners, and if KTR was used to provide that function,
      there seems no value in using EKT to distribute new keys -- KTR can do
      that.
</p>
<p>For these reasons, KTR does not describe how it would work with
      EKT.
</p>
<a name="anchor15"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.B"></a><h3>Appendix B.&nbsp;
Changes</h3>

<p>[[Note to RFC Editor: Please remove this section prior to
      publication.]]
</p>
<a name="anchor16"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.B.1"></a><h3>B.1.&nbsp;
Changes from -00 to -01</h3>

<p></p>
<ul class="text">
<li>more closely aligned with <a class='info' href='#RFC5117'>RTP
            Topologies<span> (</span><span class='info'>Westerlund, M. and S. Wenger, &ldquo;RTP Topologies,&rdquo; January&nbsp;2008.</span><span>)</span></a> [RFC5117]
</li>
<li>added multicast scenario
</li>
<li>added voicemail storage/retrieval scenario
</li>
<li>added delete_srtp_key
</li>
<li>added your_new_srtp_key
</li>
<li>aligned SDP for DTLS-SRTP with
            draft-ietf-mmusic-sdp-dtls-00
</li>
<li>key change rules are now discussed in Security
            Considerations
</li>
</ul>

<a name="anchor17"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.B.2"></a><h3>B.2.&nbsp;
Changes from -01 to -02</h3>

<p></p>
<ul class="text">
<li>removed voicemail storage/retrieval scenario -- SPEECHSC found
            such a scenario does not work
</li>
<li>Described what occurs when a speaker joins/leaves, a listener
            joins/leaves, and what a mixer/switcher does (<a class='info' href='#procedures'>Section&nbsp;4.3<span> (</span><span class='info'>Procedures for Network Elements</span><span>)</span></a>).
</li>
<li>Removed primitives that can allow two-time pad.
</li>
<li>Added scenario for interworking with Security Descriptions
</li>
<li>Describe relationship with EKT (<a class='info' href='#ekt'>Appendix&nbsp;A<span> (</span><span class='info'>Relationship with EKT</span><span>)</span></a>)
</li>
</ul>

<a name="rfc.authors"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>Author's Address</h3>
<table width="99%" border="0" cellpadding="0" cellspacing="0">
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Dan Wing</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Cisco Systems, Inc.</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">170 West Tasman Drive</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">San Jose, CA  95134</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">USA</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:dwing@cisco.com">dwing@cisco.com</a></td></tr>
</table>
<a name="rfc.copyright"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>Full Copyright Statement</h3>
<p class='copyright'>
Copyright &copy; The IETF Trust (2008).</p>
<p class='copyright'>
This document is subject to the rights,
licenses and restrictions contained in BCP&nbsp;78,
and except as set forth therein,
the authors retain all their rights.</p>
<p class='copyright'>
This document and the information contained herein are provided
on an &ldquo;AS IS&rdquo; basis and THE CONTRIBUTOR,
THE ORGANIZATION HE/SHE REPRESENTS
OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY, THE IETF TRUST
AND THE INTERNET ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT
THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY
IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR
PURPOSE.</p>
<h3>Intellectual Property</h3>
<p class='copyright'>
The IETF takes no position regarding the validity or scope of any
Intellectual Property Rights or other rights that might be claimed
to pertain to the implementation or use of the technology
described in this document or the extent to which any license
under such rights might or might not be available; nor does it
represent that it has made any independent effort to identify any
such rights.
Information on the procedures with respect to
rights in RFC documents can be found in BCP&nbsp;78 and BCP&nbsp;79.</p>
<p class='copyright'>
Copies of IPR disclosures made to the IETF Secretariat and any
assurances of licenses to be made available,
or the result of an attempt made to obtain a general license or
permission for the use of such proprietary rights by implementers or
users of this specification can be obtained from the IETF on-line IPR
repository at <a href='http://www.ietf.org/ipr'>http://www.ietf.org/ipr</a>.</p>
<p class='copyright'>
The IETF invites any interested party to bring to its attention
any copyrights,
patents or patent applications,
or other
proprietary rights that may cover technology that may be required
to implement this standard.
Please address the information to the IETF at <a href='mailto:ietf-ipr@ietf.org'>ietf-ipr@ietf.org</a>.</p>
<h3>Acknowledgment</h3>
<p class='copyright'>
This document was produced
using xml2rfc&nbsp;v1.35 (of <a href='http://xml.resource.org/'>http://xml.resource.org/</a>)
from a source in RFC-2629 XML format.</p>
</body></html>
