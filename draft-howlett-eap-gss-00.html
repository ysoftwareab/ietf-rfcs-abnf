<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="en"><head><title>A GSS-API Mechanism for the Extensible Authentication Protocol</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="description" content="A GSS-API Mechanism for the Extensible Authentication Protocol">
<meta name="generator" content="xml2rfc v1.35 (http://xml.resource.org/)">
<meta name="viewport" content="width=600;" />
<style type='text/css'><!--
        body {
                font-family: verdana, charcoal, helvetica, arial, sans-serif;
                font-size: 85%;
		max-width: 40em; 
		color: #000; background-color: #FFF;
                margin: 2em;
        }
        h1, h2, h3, h4, h5, h6 {
                font-family: helvetica, monaco, "MS Sans Serif", arial, sans-serif;
                font-weight: bold; font-style: normal;
        }
        h1 { color: #900; background-color: transparent; text-align: right; }
        h3 { color: #333; background-color: transparent; }

        td.RFCbug {
                font-size: x-small; text-decoration: none;
                width: 30px; height: 30px; padding-top: 2px;
                text-align: justify; vertical-align: middle;
                background-color: #000;
        }
        td.RFCbug span.RFC {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: bold; color: #666;
        }
        td.RFCbug span.hotText {
                font-family: charcoal, monaco, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: normal; text-align: center; color: #FFF;
        }

        table.TOCbug { width: 30px; height: 15px; }
        td.TOCbug {
                text-align: center; width: 30px; height: 15px;
                color: #FFF; background-color: #900;
        }
        td.TOCbug a {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, sans-serif;
                font-weight: bold; font-size: x-small; text-decoration: none;
                color: #FFF; background-color: transparent;
        }

        td.header {
                font-family: arial, helvetica, sans-serif; font-size: x-small;
                vertical-align: top; width: 33%;
                color: #FFF; background-color: #666;
        }
        td.author { font-weight: bold; font-size: x-small; margin-left: 4em; }
        td.author-text { font-size: x-small; }

        /* info code from SantaKlauss at http://www.madaboutstyle.com/tooltip2.html */
        a.info {
                /* This is the key. */
                position: relative;
                z-index: 24;
                text-decoration: none;
        }
        a.info:hover {
                z-index: 25;
                color: #FFF; background-color: #900;
        }
        a.info span { display: none; }
        a.info:hover span.info {
                /* The span will display just on :hover state. */
                display: block;
                position: absolute;
                font-size: smaller;
                top: 2em; left: -5em; width: 15em;
                padding: 2px; border: 1px solid #333;
                color: #900; background-color: #EEE;
                text-align: left;
        }

        a { font-weight: bold; }
        a:link    { color: #900; background-color: transparent; }
        a:visited { color: #633; background-color: transparent; }
        a:active  { color: #633; background-color: transparent; }

        p { margin-left: 2em; margin-right: 2em; }
        p.copyright { font-size: x-small; }
        p.toc { font-size: 85%;
		max-width: 40em; 
		font-weight: bold; margin-left: 3em; }
        table.toc { margin: 0 0 0 3em; padding: 0; border: 0; vertical-align: text-top; }
        td.toc { font-size: 85%;
		max-width: 40em; 
		font-weight: bold; vertical-align: text-top; }

        ol.text { margin-left: 2em; margin-right: 2em; }
        ul.text { margin-left: 2em; margin-right: 2em; }
        li      { margin-left: 3em; }

        /* RFC-2629 <spanx>s and <artwork>s. */
        em     { font-style: italic; }
        strong { font-weight: bold; }
        dfn    { font-weight: bold; font-style: normal; }
        cite   { font-weight: normal; font-style: normal; }
        tt     { color: #036; }
        tt, pre, pre dfn, pre em, pre cite, pre span {
                font-family: "Courier New", Courier, monospace; font-size: small;
        }
        pre {
                text-align: left; padding: 4px;
                color: #000; background-color: #CCC;
        }
        pre dfn  { color: #900; }
        pre em   { color: #66F; background-color: #FFC; font-weight: normal; }
        pre .key { color: #33C; font-weight: bold; }
        pre .id  { color: #900; }
        pre .str { color: #000; background-color: #CFF; }
        pre .val { color: #066; }
        pre .rep { color: #909; }
        pre .oth { color: #000; background-color: #FCF; }
        pre .err { background-color: #FCC; }

        /* RFC-2629 <texttable>s. */
        table.all, table.full, table.headers, table.none {
                font-size: 85%;
		max-width: 40em; 
		text-align: center; border-width: 2px;
                vertical-align: top; border-collapse: collapse;
        }
        table.all, table.full { border-style: solid; border-color: black; }
        table.headers, table.none { border-style: none; }
        th {
                font-weight: bold; border-color: black;
                border-width: 2px 2px 3px 2px;
        }
        table.all th, table.full th { border-style: solid; }
        table.headers th { border-style: none none solid none; }
        table.none th { border-style: none; }
        table.all td {
                border-style: solid; border-color: #333;
                border-width: 1px 2px;
        }
        table.full td, table.headers td, table.none td { border-style: none; }

        hr { height: 1px; }
        hr.insert {
                width: 80%; border-style: none; border-width: 0;
                color: #CCC; background-color: #CCC;
        }
--></style>
</head>
<body>
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<table summary="layout" width="66%" border="0" cellpadding="0" cellspacing="0"><tr><td><table summary="layout" width="100%" border="0" cellpadding="2" cellspacing="1">
<tr><td class="header">Network Working Group</td><td class="header">S. Hartman, Ed.</td></tr>
<tr><td class="header">Internet-Draft</td><td class="header">Painless Security</td></tr>
<tr><td class="header">Intended status: Standards Track</td><td class="header">J. Howlett</td></tr>
<tr><td class="header">Expires: September 2, 2010</td><td class="header">JANET(UK)</td></tr>
<tr><td class="header">&nbsp;</td><td class="header">March 01, 2010</td></tr>
</table></td></tr></table>
<h1><br />A GSS-API Mechanism for the Extensible Authentication Protocol<br />draft-howlett-eap-gss-00.txt</h1>

<h3>Abstract</h3>

<p>This document defines protocols, procedures, and conventions to be employed by peers implementing the Generic Security Service Application Program Interface (GSS-API) when using the EAP mechanism.

</p>
<h3>Status of this Memo</h3>
<p>
This Internet-Draft is submitted to IETF in full
conformance with the provisions of BCP&nbsp;78 and BCP&nbsp;79.</p>
<p>
Internet-Drafts are working documents of the Internet Engineering
Task Force (IETF), its areas, and its working groups.
Note that other groups may also distribute working documents as
Internet-Drafts.</p>
<p>
Internet-Drafts are draft documents valid for a maximum of six months
and may be updated, replaced, or obsoleted by other documents at any time.
It is inappropriate to use Internet-Drafts as reference material or to cite
them other than as &ldquo;work in progress.&rdquo;</p>
<p>
The list of current Internet-Drafts can be accessed at
<a href='http://www.ietf.org/ietf/1id-abstracts.txt'>http://www.ietf.org/ietf/1id-abstracts.txt</a>.</p>
<p>
The list of Internet-Draft Shadow Directories can be accessed at
<a href='http://www.ietf.org/shadow.html'>http://www.ietf.org/shadow.html</a>.</p>
<p>
This Internet-Draft will expire on September 2, 2010.</p>

<h3>Copyright Notice</h3>
<p>
Copyright (c) 2010 IETF Trust and the persons identified as the
document authors.  All rights reserved.</p>
<p>
This document is subject to BCP 78 and the IETF Trust's Legal
Provisions Relating to IETF Documents
(http://trustee.ietf.org/license-info) in effect on the date of
publication of this document.  Please review these documents
carefully, as they describe your rights and restrictions with respect
to this document. Code Components extracted from this document must
include Simplified BSD License text as described in Section 4.e of
the Trust Legal Provisions and are provided without warranty as
described in the BSD License.</p>
<a name="toc"></a><br /><hr />
<h3>Table of Contents</h3>
<p class="toc">
<a href="#anchor1">1.</a>&nbsp;
Introduction<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor2">1.1.</a>&nbsp;
Discovery<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor3">1.2.</a>&nbsp;
Authentication<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor4">1.3.</a>&nbsp;
Secure Association Protocol<br />
<a href="#anchor5">2.</a>&nbsp;
Requirements notation<br />
<a href="#anchor6">3.</a>&nbsp;
EAP Channel Binding and Naming<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor7">3.1.</a>&nbsp;
Mechanism Name Format<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor8">3.2.</a>&nbsp;
Exported Mechanism Names<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor9">3.3.</a>&nbsp;
Acceptor Name RADIUS AVP<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor10">3.4.</a>&nbsp;
Proxy Verification of Acceptor Name<br />
<a href="#NEGO">4.</a>&nbsp;
Selection of EAP Method<br />
<a href="#CONTEXT">5.</a>&nbsp;
Context Tokens<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor11">5.1.</a>&nbsp;
Mechanisms and Encryption Types<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor12">5.2.</a>&nbsp;
Context Options<br />
<a href="#ACCEPTOR-SERVICES">6.</a>&nbsp;
Acceptor Services<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#CHANNEL-BINDING">6.1.</a>&nbsp;
GSS-API Channel
      Binding<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor13">6.2.</a>&nbsp;
Per-message security<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor14">6.3.</a>&nbsp;
Pseudo Random Function<br />
<a href="#anchor15">7.</a>&nbsp;
Authorization and Naming Extensions<br />
<a href="#anchor16">8.</a>&nbsp;
Applicability Considerations<br />
<a href="#anchor17">9.</a>&nbsp;
Security Considerations<br />
<a href="#rfc.references1">10.</a>&nbsp;
References<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#rfc.references1">10.1.</a>&nbsp;
Normative References<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#rfc.references2">10.2.</a>&nbsp;
Informative References<br />
<a href="#rfc.authors">&#167;</a>&nbsp;
Authors' Addresses<br />
</p>
<br clear="all" />

<a name="anchor1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1"></a><h3>1.&nbsp;
Introduction</h3>

<p>The Extensible Authentication Protocol (EAP) <a class='info' href='#RFC3748'>[RFC3748]<span> (</span><span class='info'>Aboba, B., Blunk, L., Vollbrecht, J., Carlson, J., and H. Levkowetz, &ldquo;Extensible Authentication Protocol (EAP),&rdquo; June&nbsp;2004.</span><span>)</span></a> defines a framework for authenticating a
      network access client and server in order to gain access to a
      network.  A variety of different EAP methods are in wide use;
      one of EAP's strengths is that for most types of credentials in
      common use, there is an EAP method that permits the credential
      to be used.
</p>
<p>EAP is often used in conjunction with a backend
      authentication server via RADIUS <a class='info' href='#RFC3579'>[RFC3579]<span> (</span><span class='info'>Aboba, B. and P. Calhoun, &ldquo;RADIUS (Remote Authentication Dial In User Service) Support For Extensible Authentication Protocol (EAP),&rdquo; September&nbsp;2003.</span><span>)</span></a> or
      Diameter <a class='info' href='#RFC4072'>[RFC4072]<span> (</span><span class='info'>Eronen, P., Hiller, T., and G. Zorn, &ldquo;Diameter Extensible Authentication Protocol (EAP) Application,&rdquo; August&nbsp;2005.</span><span>)</span></a>.  In this mode, the NAS
      simply tunnels EAP packets over the backend authentication
      protocol to a home EAP/AAA server for the client.  After EAP succeeds, the backend authentication
      protocol is used to communicate key material to the NAS.  In
      this mode, the NAS need not be aware of or have any specific
      support for the EAP method used between the client and the home
      EAP server.  The client and EAP server share a credential that
      depends on the EAP method; the NAS and AAA server share a
      credential based on the backend authentication protocol in use.
      The backend authentication server acts as a trusted third party
      enabling network access even though the client and NAS may not
      actually share any common authentication methods.  Using AAA
      proxies, this mode can be extended beyond one organization to
      provide federated authentication for network access. 
</p>
<p>The Generic Security Services Application Programming
      Interface (GSS-API) <a class='info' href='#RFC2743'>[RFC2743]<span> (</span><span class='info'>Linn, J., &ldquo;Generic Security Service Application Program Interface Version 2, Update 1,&rdquo; January&nbsp;2000.</span><span>)</span></a> provides a generic
      framework for applications to use security services including
      authentication and per-message data security services.  Between
      protocols that support GSS-API directly or protocols that
      support SASL <a class='info' href='#RFC4422'>[RFC4422]<span> (</span><span class='info'>Melnikov, A. and K. Zeilenga, &ldquo;Simple Authentication and Security Layer (SASL),&rdquo; June&nbsp;2006.</span><span>)</span></a>, many application
      protocols can use GSS-API for security services.  However, with
      the exception of Kerberos <a class='info' href='#RFC4121'>[RFC4121]<span> (</span><span class='info'>Zhu, L., Jaganathan, K., and S. Hartman, &ldquo;The Kerberos Version 5 Generic Security Service Application Program Interface (GSS-API) Mechanism: Version 2,&rdquo; July&nbsp;2005.</span><span>)</span></a>, few GSS-API
      mechanisms are in wide use on the Internet.  While GSS-API
      permits an application to be written independent of the specific
      GSS-API mechanism in use, there is no facility to separate the
      server from the implementation of the mechanism as there is with
      EAP and backend authentication servers.  
</p>
<p>The goal of this specification is to combine GSS-API's support
      for application protocols with EAP/AAA's support for common
      credential types and for authenticating to a server without
      requiring that server to specifically support the authentication
      method in use.  In addition, this specification supports the use
      of the Security Assertion Markup Language to transport
      assertions about attributes of client subjects to servers.
      Together this combination will provide federated authentication
      and authorisation for GSS-API applications.
</p>
<p>This mechanism is a GSS-API mechanism that encapsulates an
      EAP conversation.  From the perspective of RFC 3748, this
      specification defines a new lower-layer protocol for EAP.
</p>
<p>Section 1.3 of <a class='info' href='#RFC5247'>[RFC5247]<span> (</span><span class='info'>Aboba, B., Simon, D., and P. Eronen, &ldquo;Extensible Authentication Protocol (EAP) Key Management Framework,&rdquo; August&nbsp;2008.</span><span>)</span></a> outlines the typical conversation
      between EAP peers where an EAP key is derived:</p>
<ul class="text">
<li>Phase 0: Discovery
</li>
<li>  Phase 1: Authentication
</li>
<li>      1a: EAP authentication
</li>
<li>      1b: AAA Key Transport (optional)
</li>
<li>  Phase 2: Secure Association Protocol
</li>
<li>      2a: Unicast Secure Association
</li>
<li>      2b: Multicast Secure Association (optional)
</li>
</ul><p>

</p>
<a name="anchor2"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1.1"></a><h3>1.1.&nbsp;
Discovery</h3>

<p>GSS-API peers discover each other and discover support for
	GSS-API in an application-dependent mechanism.  SASL <a class='info' href='#RFC4422'>[RFC4422]<span> (</span><span class='info'>Melnikov, A. and K. Zeilenga, &ldquo;Simple Authentication and Security Layer (SASL),&rdquo; June&nbsp;2006.</span><span>)</span></a> describes how discovery of a particular
	SASL mechanism such as a GSS-API mechanism is conducted.
	The Simple and Protected Negotiation mechanism (SPNEGO) <a class='info' href='#RFC4178'>[RFC4178]<span> (</span><span class='info'>Zhu, L., Leach, P., Jaganathan, K., and W. Ingersoll, &ldquo;The Simple and Protected Generic Security Service Application Program Interface (GSS-API) Negotiation Mechanism,&rdquo; October&nbsp;2005.</span><span>)</span></a> provides another approach for discovering
	what GSS-API mechanisms are available.  The specific approach
	used for discovery is out of scope for this mechanism.
</p>
<a name="anchor3"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1.2"></a><h3>1.2.&nbsp;
Authentication</h3>

<p>GSS-API authenticates a party called the GSS-API initiator
	to the GSS-API acceptor, optionally providing authentication
	of the acceptor to the initiator.  Authentication starts with
	a mechanism-specific message called a context token sent from the
	initiator to the acceptor.  The acceptor may respond, followed
	by the initiator, and so on until authentication succeeds or
	fails.  GSS-API context tokens are reliably delivered by the
	application using GSS-API.  The application is responsible for
	in-order delivery and retransmission.
</p>
<p>EAP authentication can be started by either the peer
	or the authenticator.  The EAP peer maps onto the GSS-API initiator
	and the EAP authenticator and EAP server maps onto the GSS-API
	acceptor. EAP messages from the peer to the authenticator are
	called responses; messages from the authenticator to the peer
	are called requests.  
</p>
<p>This specification permits a GSS-API peer to hand-off the
	processing of the EAP packets to a remote EAP server by using
	AAA protocols such as RADIUS, RadSec or Diameter. In this
	case, the GSS-API peer acts as an EAP pass-through
	authenticator. 
If EAP authentication is successful, and where the chosen EAP method supports key derivation, EAP keying material may also be derived. If an AAA protocol is used, this can also be used to replicate the EAP Key from the EAP server to the EAP authenticator.
</p>
<p>See <a class='info' href='#CONTEXT'>Section&nbsp;5<span> (</span><span class='info'>Context Tokens</span><span>)</span></a> for details of the
	authentication exchange.
</p>
<a name="anchor4"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1.3"></a><h3>1.3.&nbsp;
Secure Association Protocol</h3>

<p>After authentication succeeds, GSS-API provides a number of
	per-message security services that can be used:</p>
<blockquote class="text">
<p>GSS_Wrap() provides integrity and optional
	confidentiality for a message.
</p>
<p>GSS_GetMIC() provides integrity protection for data
	sent independently of the GSS-API
</p>
<p>GSS_Pseudo_random <a class='info' href='#RFC4401'>[RFC4401]<span> (</span><span class='info'>Williams, N., &ldquo;A Pseudo-Random Function (PRF) API Extension for the Generic Security Service Application Program Interface (GSS-API),&rdquo; February&nbsp;2006.</span><span>)</span></a> provides key
	derivation functionality.
</p>
</blockquote><p>

</p>
<p>These services perform a function similar to security
	association protocols in network access.  Like security
	association protocols, these services need to be performed
	near the authenticator/acceptor even when a AAA protocol is
	used to separate the authenticator from the EAP server.  
	The key used for these per-message services is derived from 
	the EAP key; the EAP peer and authenticator derive this key 
	as a result of a successful EAP authentication. In the case 
	that the EAP authenticator is acting as a pass-through it 
	obtains it via the AAA protocol.  See <a class='info' href='#ACCEPTOR-SERVICES'>Section&nbsp;6<span> (</span><span class='info'>Acceptor Services</span><span>)</span></a> for details.
</p>
<a name="anchor5"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2"></a><h3>2.&nbsp;
Requirements notation</h3>

<p>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL",
            "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY",
            and "OPTIONAL" in this document are to be interpreted as
            described in <a class='info' href='#RFC2119'>[RFC2119]<span> (</span><span class='info'>Bradner, S., &ldquo;Key words for use in RFCs to Indicate Requirement Levels,&rdquo; March&nbsp;1997.</span><span>)</span></a>.
</p>
<a name="anchor6"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3"></a><h3>3.&nbsp;
EAP Channel Binding and Naming</h3>

<p> EAP authenticates a realm.  The peer knows that it has
      exchanged authentication with an EAP server in a given realm.
      Today, the peer does not typically know which NAS it is talking
      to securely.  That is often fine for network access.  However
      privileges to delegate to a chat server seem very different than
      privileges for a file server or trading site.  Also, an EAP peer
      knows the identity of the home realm, but perhaps not even the
      visited realm.  
</p>
<p>In contrast, GSS-API takes a name for both the initiator and
      acceptor as inputs to the authentication process.  When mutual
      authentication is used, both parties are authenticated.  The
      granularity of these names is somewhat mechanism dependent.  In
      the case of the Kerberos mechanism, the acceptor name typically
      identifies both the protocol in use (such as IMAP) and the
      specific instance of the service being connected to.  The
      acceptor name almost always identifies the administrative domain
      providing service.  
</p>
<p>An EAP GSS-API mechanism needs to provide GSS-API naming
      semantics in order to work with existing GSS-API applications.
      EAP channel binding <a class='info' href='#I-D.ietf-emu-chbind'>[I&#8209;D.ietf&#8209;emu&#8209;chbind]<span> (</span><span class='info'>Clancy, C. and K. Hoeper, &ldquo;Channel Binding Support for EAP Methods,&rdquo; October&nbsp;2009.</span><span>)</span></a> is used
      to provide GSS-API naming semantics.  Channel binding sends a
      set of attributes from the peer to the EAP server either as part
      of the EAP conversation or as part of a secure association
      protocol.  In addition, attributes are sent in the backend
      authentication protocol from the authenticator to the EAP
      server.  The EAP server confirms the consistency of these
      attributes.  Confirming attribute consistency also involves
      checking consistency against a local policy database as
      discussed below.  In particular, the peer sends the name of the
      acceptor it is authenticating to as part of channel binding.
      The acceptor sends its full name as part of the backend
      authentication protocol.  The EAP server confirms consistency of
      the names.
</p>
<p>EAP channel binding is easily confused with a facility in
      GSS-API also called channel binding.  GSS-API channel binding
      provides protection against man-in-the-middle attacks when
      GSS-API is used as authentication inside some tunnel; it is
      similar to a facility called cryptographic binding in EAP.  See
      <a class='info' href='#RFC5056'>[RFC5056]<span> (</span><span class='info'>Williams, N., &ldquo;On the Use of Channel Bindings to Secure Channels,&rdquo; November&nbsp;2007.</span><span>)</span></a> for a discussion of the differences
      between these two facilities and <a class='info' href='#CHANNEL-BINDING'>Section&nbsp;6.1<span> (</span><span class='info'>GSS-API Channel       Binding</span><span>)</span></a> for how GSS-API channel binding is
      handled in this mechanism.
</p>
<a name="anchor7"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.1"></a><h3>3.1.&nbsp;
Mechanism Name Format</h3>

<p>Before discussing how the initiator and acceptor names are
	validated in the AAA infrastructure, it is necessary to
	discuss what composes a name for an EAP GSS-API mechanism.
	GSS-API permits several types of generic names to be imported
	using GSS_Import_name().  Once a mechanism is chosen, these
	names are converted into a mechanism name form.  This section
	first discusses name types that need to be imported and then
	discusses  the structure of the mechanism name.
</p>
<p>The GSS_C_NT_USER_NAME form represents the name of an
	individual user.  From the standpoint of this mechanism it may
	take the form either of an undecorated user name or a network
	access identifier (NAI) <a class='info' href='#RFC4282'>[RFC4282]<span> (</span><span class='info'>Aboba, B., Beadles, M., Arkko, J., and P. Eronen, &ldquo;The Network Access Identifier,&rdquo; December&nbsp;2005.</span><span>)</span></a>.
</p>
<p>The GSS_C_NT_HOSTBASED_SERVICE name form  represents a
	service running on a host; it is textually represented as
	"HOST@SERVICE".  This name form is required by most SASL
	profiles and is used by many existing applications that use
	the Kerberos GSS-API mechanism.  While support for this name
	form is critical, it presents an interesting challenge in
	terms of channel binding.  Consider a case where the server
	communicates with a "server proxy," or a AAA server near the
	server.  That server proxy communicates with the EAP server.
	The EAP server and server proxy are in different
	administrative realms.  The server proxy is in a position to
	verify that the request comes from the indicated host.
	However the EAP server cannot make this determination
	directly.  So, the EAP server needs to determine whether to
	trust the server proxy to verify the host portion of the
	acceptor name.  This trust decision depends both on the host
	name and the realm of the server proxy.  In effect, the EAP
	server decides whether to trust that the realm of the server
	proxy is the right realm for the given hostname and then makes
	a trust decision about the server proxy itself.  The same
	problem appears in Kerberos: there, clients decide what
	Kerberos realm to trust for a given hostname.  
</p>
<p>Sometimes, the client may know what AAA realm a particular
	host should belong to.  In this case it would be desirable to
	use a name form that included a service, host and realm.
	Syntactically, this appears the same as the domain-based name
	discussed in <a class='info' href='#RFC5178'>[RFC5178]<span> (</span><span class='info'>Williams, N. and A. Melnikov, &ldquo;Generic Security Service Application Program Interface (GSS-API) Internationalization and Domain-Based Service Names and Name Type,&rdquo; May&nbsp;2008.</span><span>)</span></a>, but the semantics do
	not appear sufficiently similar to use the same name form.
</p>
<p>A name form is needed to identify a SAML endpoint and a
	specific instance of SAML metadata associated with that
	endpoint.  The metadata describes properties of the endpoint
	including public keys.  One of the motivating use cases is to
	be able to use GSS-API to build trust in this metadata.  In
	this case it is desirable to authenticate to an acceptor based
	on the endpoint and a cryptographic hash of the metadata.
</p>
<p>The mechanism name form must be able to represent all
	of these names.  In addition, the mechanism name form MUST
	make it easy for intermediate AAA proxies to extract the
	hostname portion when present.  One possible starting point is
	the Kerberos name form discussed in <a class='info' href='#RFC1964'>[RFC1964]<span> (</span><span class='info'>Linn, J., &ldquo;The Kerberos Version 5 GSS-API Mechanism,&rdquo; June&nbsp;1996.</span><span>)</span></a>.
	The major down side of that approach is that there is no
	guaranteed way to be able to extract a hostname from a
	Kerberos name.  Also, Kerberos naming may provide more
	flexibility than is needed.
</p>
<a name="anchor8"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.2"></a><h3>3.2.&nbsp;
Exported Mechanism Names</h3>

<p>GSS-API provides the GSS_Export_name call.  This call can
	be used to export the binary representation of a name.  This
	name form can be stored on access control lists for binary
	comparison.
</p>
<p>This section defines the format of the exported name token
	for this mechanism.
</p>
<a name="anchor9"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.3"></a><h3>3.3.&nbsp;
Acceptor Name RADIUS AVP</h3>

<p>This section defines an attribute-value pair for
	transporting the name of the acceptor in a RADIUS or Diameter
	message.  This AVP is included by the server to indicate the
	acceptor name it claims.  This AVP is included in channel
	bindings by the client to indicate what acceptor is
	authenticated against.
</p>
<a name="anchor10"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.4"></a><h3>3.4.&nbsp;
Proxy Verification of Acceptor Name</h3>

<a name="NEGO"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4"></a><h3>4.&nbsp;
Selection of EAP Method</h3>

<p>The specification currently describes a single GSS-API
      mechanism.  The peer and authenticator exchange EAP messages.
      The GSS-API mechanism specifies no constraints about what EAP
      method types are used; text in the specification says that
      negotiation of which EAP method to use happens at the EAP
      layer.
</p>
<p>EAP does not provide a facility for an EAP server to
      advertise what methods are available to a peer.  Instead, a
      server starts with its preferred method selection.  If the
      peer does not accept that method, the peer sends a NAK
      response containing the list of methods supported by the client.
</p>
<p> Providing
multiple facilities to negotiate which security mechanism to use is
undesirable.  Section 7.3 of <a class='info' href='#RFC4462'>[RFC4462]<span> (</span><span class='info'>Hutzelman, J., Salowey, J., Galbraith, J., and V. Welch, &ldquo;Generic Security Service Application Program Interface (GSS-API) Authentication and Key Exchange for the Secure Shell (SSH) Protocol,&rdquo; May&nbsp;2006.</span><span>)</span></a>describes the
problem referencing the SSH key exchange negotiation and the SPNEGO
GSS-API mechanism.  If a client preferred an EAP method A, a non-EAP
authentication mechanism B, and then an EAP method C, then the client
would have to commit to using EAP before learning whether A is
actually supported.  Such a client might end up using C when B is
available.  
</p>
<p>The standard solution to this problem is to perform all the
      negotiation at one layer.  In this case, rather than defining a
      single GSS-API mechanism, a family of mechanisms should be
      defined.  Each mechanism corresponds to an EAP method.  The EAP
      method type should be part of the GSS-API OID.  Then, a GSS-API
      rather than EAP facility can be used for negotiation.
</p>
<p>Unfortunately, using a family of mechanisms has a number of
      problems.  First, GSS-API assumes that both the initiator and
      acceptor know the entire set of mechanisms that are available.
      Some negotiation mechanisms are driven by the client; others are
      driven by the server.  With EAP GSS-API, the acceptor does not
      know what methods the EAP server implements.  The EAP server
      that is used depends on the identity of the client.  The best
      solution so far is to accept the disadvantages of multi-layer
      negotiation and commit to using EAP GSS-API before a specific
      EAP method.  This has two main disadvantages.  First,
      authentication may fail when other methods might allow
      authentication to succeed.  Second, a non-optimal security
      mechanism may be chosen.
</p>
<a name="CONTEXT"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5"></a><h3>5.&nbsp;
Context Tokens</h3>

<p>All context establishment tokens emitted by the EAP mechanism SHALL have the framing described in section 3.1 of [RFC2743], as illustrated by the following pseudo-ASN.1 structures:

</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
GSS-API DEFINITIONS ::=
         BEGIN

         MechType ::= OBJECT IDENTIFIER
         -- representing EAP mechanism
         GSSAPI-Token ::=
         -- option indication (delegation, etc.) indicated within
         -- mechanism-specific token
         [APPLICATION 0] IMPLICIT SEQUENCE {
                 thisMech MechType,
                 innerToken ANY DEFINED BY thisMech
                    -- contents mechanism-specific
                    -- ASN.1 structure not required
                 }
         END
</pre></div>
<p>The innerToken field contains  an EAP packet or special token.  The first EAP
      packet SHALL be a EAP response/identity packet from the
      initiator to acceptor.  The acceptor SHALL respond either with
      an EAP request or an EAP failure packet.
</p>
<p>The initiator and acceptor will continue exchanging
      response/request packets until authentication succeeds or
      fails.
</p>
<p>After the EAP authentication succeeds, channel binding tokens
      are exchanged; see <a class='info' href='#CHANNEL-BINDING'>Section&nbsp;6.1<span> (</span><span class='info'>GSS-API Channel       Binding</span><span>)</span></a> for
      details.  Currently, the channel binding tokens are the only
      types of special tokens in use.
</p>
<a name="anchor11"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.1"></a><h3>5.1.&nbsp;
Mechanisms and Encryption Types</h3>

<p>This mechanism family uses the security services of the
	Kerberos cryptographic framework <a class='info' href='#RFC3961'>[RFC3961]<span> (</span><span class='info'>Raeburn, K., &ldquo;Encryption and Checksum Specifications for Kerberos 5,&rdquo; February&nbsp;2005.</span><span>)</span></a>.  As
	such, a particular encryption type needs to be chosen.  A new
	GSS-API OID should be defined for EAP GSS-API with a given
	Kerberos crypto system.  This document defines the
	eap-aes128-cts-hmac-sha1-96 GSS-API mechanism. XXX define an
	OID for that and use the right language to get that into the
	appropriate SASL registry.
</p>
<a name="anchor12"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.2"></a><h3>5.2.&nbsp;
Context Options</h3>

<p>GSS-API provides a number of optional per-context services
	requested by flags on the call to GSS_Init_sec_context and
	indicated as outputs from both GSS_Init_sec_context and
	GSS_Accept_sec_context.  This section describes how these
	services are handled.
</p>
<p>Integrity, confidentiality, sequencing and replay detection
	are always available.  Regardless of what flags are requested
	in GSS_Init_sec_context, implementations MUST set the flag
	corresponding to these services in the output of
	GSS_Init_sec_context and GSS_Accept_sec_context.
</p>
<p>The PROT_READY service is never available with this
	mechanism.  Implementations MUST NOT offer this flag or permit
	per-message security services to be used before context
	establishment.
</p>
<p>Open issue: how is the mutual authentication request and
	return handled?  The big question here is figuring out how
	this interacts with EAP and transporting state back to a
	pass-through authenticator.
</p>
<p>Open issue: handling of lifetime parameters.  
</p>
<a name="ACCEPTOR-SERVICES"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6"></a><h3>6.&nbsp;
Acceptor Services</h3>

<p>The context establishment process may be passed through to a
      EAP server via a backend authentication protocol.  However after
      the EAP authentication succeeds, security services are provided
      directly by the acceptor.  
</p>
<p>This mechanism uses an RFC 3961 cryptographic key called the
      context root key (CRK).  The CRK is the result of the
      random-to-key operation consuming the appropriate number of bits
      from the EAP master session  key.  For example for
      aes128-cts-hmac-sha1-96, the random-to-key operation consumes 16
      octets of key material; thus the first 16 bytes of the master
      session key are input to random-to-key to form the CRK.
</p>
<a name="CHANNEL-BINDING"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.1"></a><h3>6.1.&nbsp;
GSS-API Channel
      Binding</h3>

<p>GSS-API channel binding <a class='info' href='#RFC5554'>[RFC5554]<span> (</span><span class='info'>Williams, N., &ldquo;Clarifications and Extensions to the Generic Security Service Application Program Interface (GSS-API) for the Use of Channel Bindings,&rdquo; May&nbsp;2009.</span><span>)</span></a> is a
	protected facility for exchanging a cryptographic name for an
	enclosing channel between the initiator and acceptor.  The
	initiator sends channel binding data and the acceptor confirms
	that channel binding data has been checked.
</p>
<p>The acceptor SHOULD accept any channel binding providing by
	the initiator if null channel bindings are passed into
	gss_accept_sec_context.  Protocols such as HTTP Negotiate
	depend on this behavior of some Kerberos implementations.  It
	is reasonable for the protocol to distinguish an acceptor
	ignoring channel bindings from an acceptor successfully
	validating them.  No facility is currently provided for an
	initiator implementation to expose this distinction to the
	initiator code.
</p>
<p>Define a token format, token ID and key usage for this token.
</p>
<a name="anchor13"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.2"></a><h3>6.2.&nbsp;
Per-message security</h3>

<p>The per-message tokens of section 4 of RFC 4121 are used.
	The CRK SHALL be treated as the initiator sub-session key, the
	acceptor sub-session key and the ticket session key.
</p>
<a name="anchor14"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.3"></a><h3>6.3.&nbsp;
Pseudo Random Function</h3>

<p>The pseudo random function defined in <a class='info' href='#RFC4402'>[RFC4402]<span> (</span><span class='info'>Williams, N., &ldquo;A Pseudo-Random Function (PRF) for the Kerberos V Generic Security Service Application Program Interface (GSS-API) Mechanism,&rdquo; February&nbsp;2006.</span><span>)</span></a> is used.
</p>
<a name="anchor15"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7"></a><h3>7.&nbsp;
Authorization and Naming Extensions</h3>

<p>One goal of this mechanism is to support retrieving a SAML
      assertion as a result of the EAP authentication.  The GSS-API
      naming extensions will be used to access this message.  This
      section will be expanded to discuss details.
</p>
<a name="anchor16"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.8"></a><h3>8.&nbsp;
Applicability Considerations</h3>

<p>Section 1.3 of RFC 3748 provides the applicability statement
      for EAP.  Among other constraints, EAP is scoped for use in
      network access.  This specification anticipates using EAP beyond
      its current scope.  The assumption is that some other document
      will discuss the issues surrounding the use of EAP for
      application authentication and expand EAP's applicability.  That
      document  will likely enumerate considerations that a specific
      use of EAP for application authentication needs to handle.
      Examples of such considerations might include the multi-layer
      negotiation issue, deciding when EAP or some other mechanism
      should be used, and so forth.  This section serves as a
      placeholder to discuss any such issues with regard to the use of
      EAP and GSS-API.
</p>
<a name="anchor17"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.9"></a><h3>9.&nbsp;
Security Considerations</h3>

<p>RFC 3748 discusses security issues surrounding EAP.  RFC 5247
      discusses the security and requirements surrounding key
      management that leverages the AAA infrastructure.  These
      documents are critical to the security analysis of this mechanism.
      
</p>
<p>RFC 2743 discusses generic security considerations for the
      GSS-API.  RFC 4121 discusses security issues surrounding the
      specific per-message services used in this mechanism.
</p>
<p>As discussed in <a class='info' href='#NEGO'>Section&nbsp;4<span> (</span><span class='info'>Selection of EAP Method</span><span>)</span></a>, this mechanism may
      introduce multiple layers of security negotiation into
      application protocols.  Multiple layer negotiations are
      vulnerable to a bid-down attack when a mechanism negotiated at
      the outer layer is preferred to some but not all mechanisms
      negotiated at the inner layer; see section 7.3 of <a class='info' href='#RFC4462'>[RFC4462]<span> (</span><span class='info'>Hutzelman, J., Salowey, J., Galbraith, J., and V. Welch, &ldquo;Generic Security Service Application Program Interface (GSS-API) Authentication and Key Exchange for the Secure Shell (SSH) Protocol,&rdquo; May&nbsp;2006.</span><span>)</span></a> for an example.  One possible approach to
      mitigate this attack is to construct security policy such that
      the preference for all mechanisms negotiated in the inner layer
      falls between preferences for two outer layer mechanisms or
      falls at one end of the overall ranked preferences including
      both the inner and outer layer.  Another approach is to only use
      this mechanism when it has specifically been selected for a
      given service.  The second approach is likely to be common in
      practice because one common deployment will involved an EAP
      supplicant interacting with a user to select a given identity.
      Only when an identity is successfully chosen by the user will
      this mechanism be attempted.
</p>
<p>The security of this mechanism depends on the use and
      verification of EAP channel binding.  Today EAP channel binding
      is in very limited deployment.  If EAP channel binding is not
      used, then the system may be vulnerable to phishing attacks
      where a user is diverted from one service to another.  These
      attacks are possible with EAP today although not typically with
      common GSS-API mechanisms.
</p>
<p>Every proxy in the AAA chain from the authenticator to the
      EAP server needs to be trusted to help verify channel bindings
      and to protect the integrity of key material.  GSS-API
      applications may be built to assume a trust model where the
      acceptor is directly responsible for authentication.  However,
      GSS-API is definitely used with trusted-third-party mechanisms
      such as Kerberos.
</p>
<a name="rfc.references"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.10"></a><h3>10.&nbsp;
References</h3>

<a name="rfc.references1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>10.1.&nbsp;Normative References</h3>
<table width="99%" border="0">
<tr><td class="author-text" valign="top"><a name="I-D.ietf-emu-chbind">[I-D.ietf-emu-chbind]</a></td>
<td class="author-text">Clancy, C. and K. Hoeper, &ldquo;<a href="http://www.ietf.org/internet-drafts/draft-ietf-emu-chbind-04.txt">Channel Binding Support for EAP Methods</a>,&rdquo; draft-ietf-emu-chbind-04 (work in progress), October&nbsp;2009 (<a href="http://www.ietf.org/internet-drafts/draft-ietf-emu-chbind-04.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC2119">[RFC2119]</a></td>
<td class="author-text"><a href="mailto:sob@harvard.edu">Bradner, S.</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>,&rdquo; BCP&nbsp;14, RFC&nbsp;2119, March&nbsp;1997 (<a href="http://www.rfc-editor.org/rfc/rfc2119.txt">TXT</a>, <a href="http://xml.resource.org/public/rfc/html/rfc2119.html">HTML</a>, <a href="http://xml.resource.org/public/rfc/xml/rfc2119.xml">XML</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC2743">[RFC2743]</a></td>
<td class="author-text"><a href="mailto:jlinn@rsasecurity.com">Linn, J.</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc2743">Generic Security Service Application Program Interface Version 2, Update 1</a>,&rdquo; RFC&nbsp;2743, January&nbsp;2000 (<a href="http://www.rfc-editor.org/rfc/rfc2743.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC3748">[RFC3748]</a></td>
<td class="author-text">Aboba, B., Blunk, L., Vollbrecht, J., Carlson, J., and H. Levkowetz, &ldquo;<a href="http://tools.ietf.org/html/rfc3748">Extensible Authentication Protocol (EAP)</a>,&rdquo; RFC&nbsp;3748, June&nbsp;2004 (<a href="http://www.rfc-editor.org/rfc/rfc3748.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC3961">[RFC3961]</a></td>
<td class="author-text">Raeburn, K., &ldquo;<a href="http://tools.ietf.org/html/rfc3961">Encryption and Checksum Specifications for Kerberos 5</a>,&rdquo; RFC&nbsp;3961, February&nbsp;2005 (<a href="http://www.rfc-editor.org/rfc/rfc3961.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4121">[RFC4121]</a></td>
<td class="author-text">Zhu, L., Jaganathan, K., and S. Hartman, &ldquo;<a href="http://tools.ietf.org/html/rfc4121">The Kerberos Version 5 Generic Security Service Application Program Interface (GSS-API) Mechanism: Version 2</a>,&rdquo; RFC&nbsp;4121, July&nbsp;2005 (<a href="http://www.rfc-editor.org/rfc/rfc4121.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4282">[RFC4282]</a></td>
<td class="author-text">Aboba, B., Beadles, M., Arkko, J., and P. Eronen, &ldquo;<a href="http://tools.ietf.org/html/rfc4282">The Network Access Identifier</a>,&rdquo; RFC&nbsp;4282, December&nbsp;2005 (<a href="http://www.rfc-editor.org/rfc/rfc4282.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4401">[RFC4401]</a></td>
<td class="author-text">Williams, N., &ldquo;<a href="http://tools.ietf.org/html/rfc4401">A Pseudo-Random Function (PRF) API Extension for the Generic Security Service Application Program Interface (GSS-API)</a>,&rdquo; RFC&nbsp;4401, February&nbsp;2006 (<a href="http://www.rfc-editor.org/rfc/rfc4401.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4402">[RFC4402]</a></td>
<td class="author-text">Williams, N., &ldquo;<a href="http://tools.ietf.org/html/rfc4402">A Pseudo-Random Function (PRF) for the Kerberos V Generic Security Service Application Program Interface (GSS-API) Mechanism</a>,&rdquo; RFC&nbsp;4402, February&nbsp;2006 (<a href="http://www.rfc-editor.org/rfc/rfc4402.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC5056">[RFC5056]</a></td>
<td class="author-text">Williams, N., &ldquo;<a href="http://tools.ietf.org/html/rfc5056">On the Use of Channel Bindings to Secure Channels</a>,&rdquo; RFC&nbsp;5056, November&nbsp;2007 (<a href="http://www.rfc-editor.org/rfc/rfc5056.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC5554">[RFC5554]</a></td>
<td class="author-text">Williams, N., &ldquo;<a href="http://tools.ietf.org/html/rfc5554">Clarifications and Extensions to the Generic Security Service Application Program Interface (GSS-API) for the Use of Channel Bindings</a>,&rdquo; RFC&nbsp;5554, May&nbsp;2009 (<a href="http://www.rfc-editor.org/rfc/rfc5554.txt">TXT</a>).</td></tr>
</table>

<a name="rfc.references2"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>10.2.&nbsp;Informative References</h3>
<table width="99%" border="0">
<tr><td class="author-text" valign="top"><a name="RFC1964">[RFC1964]</a></td>
<td class="author-text"><a href="mailto:John.Linn@ov.com">Linn, J.</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc1964">The Kerberos Version 5 GSS-API Mechanism</a>,&rdquo; RFC&nbsp;1964, June&nbsp;1996 (<a href="http://www.rfc-editor.org/rfc/rfc1964.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC3579">[RFC3579]</a></td>
<td class="author-text">Aboba, B. and P. Calhoun, &ldquo;<a href="http://tools.ietf.org/html/rfc3579">RADIUS (Remote Authentication Dial In User Service) Support For Extensible Authentication Protocol (EAP)</a>,&rdquo; RFC&nbsp;3579, September&nbsp;2003 (<a href="http://www.rfc-editor.org/rfc/rfc3579.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4072">[RFC4072]</a></td>
<td class="author-text">Eronen, P., Hiller, T., and G. Zorn, &ldquo;<a href="http://tools.ietf.org/html/rfc4072">Diameter Extensible Authentication Protocol (EAP) Application</a>,&rdquo; RFC&nbsp;4072, August&nbsp;2005 (<a href="http://www.rfc-editor.org/rfc/rfc4072.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4178">[RFC4178]</a></td>
<td class="author-text">Zhu, L., Leach, P., Jaganathan, K., and W. Ingersoll, &ldquo;<a href="http://tools.ietf.org/html/rfc4178">The Simple and Protected Generic Security Service Application Program Interface (GSS-API) Negotiation Mechanism</a>,&rdquo; RFC&nbsp;4178, October&nbsp;2005 (<a href="http://www.rfc-editor.org/rfc/rfc4178.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4422">[RFC4422]</a></td>
<td class="author-text">Melnikov, A. and K. Zeilenga, &ldquo;<a href="http://tools.ietf.org/html/rfc4422">Simple Authentication and Security Layer (SASL)</a>,&rdquo; RFC&nbsp;4422, June&nbsp;2006 (<a href="http://www.rfc-editor.org/rfc/rfc4422.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4462">[RFC4462]</a></td>
<td class="author-text">Hutzelman, J., Salowey, J., Galbraith, J., and V. Welch, &ldquo;<a href="http://tools.ietf.org/html/rfc4462">Generic Security Service Application Program Interface (GSS-API) Authentication and Key Exchange for the Secure Shell (SSH) Protocol</a>,&rdquo; RFC&nbsp;4462, May&nbsp;2006 (<a href="http://www.rfc-editor.org/rfc/rfc4462.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC5178">[RFC5178]</a></td>
<td class="author-text">Williams, N. and A. Melnikov, &ldquo;<a href="http://tools.ietf.org/html/rfc5178">Generic Security Service Application Program Interface (GSS-API) Internationalization and Domain-Based Service Names and Name Type</a>,&rdquo; RFC&nbsp;5178, May&nbsp;2008 (<a href="http://www.rfc-editor.org/rfc/rfc5178.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC5247">[RFC5247]</a></td>
<td class="author-text">Aboba, B., Simon, D., and P. Eronen, &ldquo;<a href="http://tools.ietf.org/html/rfc5247">Extensible Authentication Protocol (EAP) Key Management Framework</a>,&rdquo; RFC&nbsp;5247, August&nbsp;2008 (<a href="http://www.rfc-editor.org/rfc/rfc5247.txt">TXT</a>).</td></tr>
</table>

<a name="rfc.authors"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>Authors' Addresses</h3>
<table width="99%" border="0" cellpadding="0" cellspacing="0">
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Sam Hartman (editor)</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Painless Security</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:hartmans-ietf@mit.edu">hartmans-ietf@mit.edu</a></td></tr>
<tr cellpadding="3"><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Josh Howlett</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">JANET(UK)</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:josh.howlett@ja.net">josh.howlett@ja.net</a></td></tr>
</table>
</body></html>
