<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" 
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html lang="en" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head profile="http://www.w3.org/2006/03/hcard%20http://dublincore.org/documents/2008/08/04/dc-html/">
  <meta http-equiv="Content-Type" content="text/html; charset=us-ascii" />

  <title>OAuth 2.0 Threat Model and Security Considerations</title>

  <style type="text/css" title="Xml2Rfc (sans serif)">
  /*<![CDATA[*/
	  a {
	  text-decoration: none;
	  }
	  a.smpl {
	  color: black;
	  }
	  a:hover {
	  text-decoration: underline;
	  }
	  a:active {
	  text-decoration: underline;
	  }
	  address {
	  margin-top: 1em;
	  margin-left: 2em;
	  font-style: normal;
	  }
	  body {
	  color: black;
	  font-family: verdana, helvetica, arial, sans-serif;
	  font-size: 10pt;
	  
	  }
	  cite {
	  font-style: normal;
	  }
	  dd {
	  margin-right: 2em;
	  }
	  dl {
	  margin-left: 2em;
	  }
	
	  ul.empty {
	  list-style-type: none;
	  }
	  ul.empty li {
	  margin-top: .5em;
	  }
	  dl p {
	  margin-left: 0em;
	  }
	  dt {
	  margin-top: .5em;
	  }
	  h1 {
	  font-size: 14pt;
	  line-height: 21pt;
	  page-break-after: avoid;
	  }
	  h1.np {
	  page-break-before: always;
	  }
	  h1 a {
	  color: #333333;
	  }
	  h2 {
	  font-size: 12pt;
	  line-height: 15pt;
	  page-break-after: avoid;
	  }
	  h3, h4, h5, h6 {
	  font-size: 10pt;
	  page-break-after: avoid;
	  }
	  h2 a, h3 a, h4 a, h5 a, h6 a {
	  color: black;
	  }
	  img {
	  margin-left: 3em;
	  }
	  li {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  ol {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  ol p {
	  margin-left: 0em;
	  }
	  p {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  pre {
	  margin-left: 3em;
	  background-color: lightyellow;
	  padding: .25em;
	  }
	  pre.text2 {
	  border-style: dotted;
	  border-width: 1px;
	  background-color: #f0f0f0;
	  width: 69em;
	  }
	  pre.inline {
	  background-color: white;
	  padding: 0em;
	  }
	  pre.text {
	  border-style: dotted;
	  border-width: 1px;
	  background-color: #f8f8f8;
	  width: 69em;
	  }
	  pre.drawing {
	  border-style: solid;
	  border-width: 1px;
	  background-color: #f8f8f8;
	  padding: 2em;
	  }
	  table {
	  margin-left: 2em;
	  }
	  table.tt {
	  vertical-align: top;
	  }
	  table.full {
	  border-style: outset;
	  border-width: 1px;
	  }
	  table.headers {
	  border-style: outset;
	  border-width: 1px;
	  }
	  table.tt td {
	  vertical-align: top;
	  }
	  table.full td {
	  border-style: inset;
	  border-width: 1px;
	  }
	  table.tt th {
	  vertical-align: top;
	  }
	  table.full th {
	  border-style: inset;
	  border-width: 1px;
	  }
	  table.headers th {
	  border-style: none none inset none;
	  border-width: 1px;
	  }
	  table.left {
	  margin-right: auto;
	  }
	  table.right {
	  margin-left: auto;
	  }
	  table.center {
	  margin-left: auto;
	  margin-right: auto;
	  }
	  caption {
	  caption-side: bottom;
	  font-weight: bold;
	  font-size: 9pt;
	  margin-top: .5em;
	  }
	
	  table.header {
	  border-spacing: 1px;
	  width: 95%;
	  font-size: 10pt;
	  color: white;
	  }
	  td.top {
	  vertical-align: top;
	  }
	  td.topnowrap {
	  vertical-align: top;
	  white-space: nowrap; 
	  }
	  table.header td {
	  background-color: gray;
	  width: 50%;
	  }
	  table.header a {
	  color: white;
	  }
	  td.reference {
	  vertical-align: top;
	  white-space: nowrap;
	  padding-right: 1em;
	  }
	  thead {
	  display:table-header-group;
	  }
	  ul.toc, ul.toc ul {
	  list-style: none;
	  margin-left: 1.5em;
	  margin-right: 0em;
	  padding-left: 0em;
	  }
	  ul.toc li {
	  line-height: 150%;
	  font-weight: bold;
	  font-size: 10pt;
	  margin-left: 0em;
	  margin-right: 0em;
	  }
	  ul.toc li li {
	  line-height: normal;
	  font-weight: normal;
	  font-size: 9pt;
	  margin-left: 0em;
	  margin-right: 0em;
	  }
	  li.excluded {
	  font-size: 0pt;
	  }
	  ul p {
	  margin-left: 0em;
	  }
	
	  .comment {
	  background-color: yellow;
	  }
	  .center {
	  text-align: center;
	  }
	  .error {
	  color: red;
	  font-style: italic;
	  font-weight: bold;
	  }
	  .figure {
	  font-weight: bold;
	  text-align: center;
	  font-size: 9pt;
	  }
	  .filename {
	  color: #333333;
	  font-weight: bold;
	  font-size: 12pt;
	  line-height: 21pt;
	  text-align: center;
	  }
	  .fn {
	  font-weight: bold;
	  }
	  .hidden {
	  display: none;
	  }
	  .left {
	  text-align: left;
	  }
	  .right {
	  text-align: right;
	  }
	  .title {
	  color: #990000;
	  font-size: 18pt;
	  line-height: 18pt;
	  font-weight: bold;
	  text-align: center;
	  margin-top: 36pt;
	  }
	  .vcardline {
	  display: block;
	  }
	  .warning {
	  font-size: 14pt;
	  background-color: yellow;
	  }
	
	
	  @media print {
	  .noprint {
		display: none;
	  }
	
	  a {
		color: black;
		text-decoration: none;
	  }
	
	  table.header {
		width: 90%;
	  }
	
	  td.header {
		width: 50%;
		color: black;
		background-color: white;
		vertical-align: top;
		font-size: 12pt;
	  }
	
	  ul.toc a::after {
		content: leader('.') target-counter(attr(href), page);
	  }
	
	  ul.ind li li a {
		content: target-counter(attr(href), page);
	  }
	
	  .print2col {
		column-count: 2;
		-moz-column-count: 2;
		column-fill: auto;
	  }
	  }
	
	  @page {
	  @top-left {
		   content: "Internet-Draft"; 
	  } 
	  @top-right {
		   content: "December 2010"; 
	  } 
	  @top-center {
		   content: "Abbreviated Title";3
	  } 
	  @bottom-left {
		   content: "Doe"; 
	  } 
	  @bottom-center {
		   content: "Expires June 2011"; 
	  } 
	  @bottom-right {
		   content: "[Page " counter(page) "]"; 
	  } 
	  }
	
	  @page:first { 
		@top-left {
		  content: normal;
		}
		@top-right {
		  content: normal;
		}
		@top-center {
		  content: normal;
		}
	  }
  /*]]>*/
  </style>

  <link href="#rfc.toc" rel="Contents">
<link href="#rfc.section.1" rel="Chapter" title="1 Introduction">
<link href="#rfc.section.2" rel="Chapter" title="2 Overview">
<link href="#rfc.section.2.1" rel="Chapter" title="2.1 Scope">
<link href="#rfc.section.2.2" rel="Chapter" title="2.2 Attack Assumptions">
<link href="#rfc.section.2.3" rel="Chapter" title="2.3 Architectural assumptions">
<link href="#rfc.section.2.3.1" rel="Chapter" title="2.3.1 Authorization Servers">
<link href="#rfc.section.2.3.2" rel="Chapter" title="2.3.2 Resource Server">
<link href="#rfc.section.2.3.3" rel="Chapter" title="2.3.3 Client">
<link href="#rfc.section.2.3.3.1" rel="Chapter" title="2.3.3.1 Web Server">
<link href="#rfc.section.2.3.3.2" rel="Chapter" title="2.3.3.2 Native Applications">
<link href="#rfc.section.2.3.3.3" rel="Chapter" title="2.3.3.3 User Agent">
<link href="#rfc.section.2.3.3.4" rel="Chapter" title="2.3.3.4 Autonomous">
<link href="#rfc.section.3" rel="Chapter" title="3 Security Features">
<link href="#rfc.section.3.1" rel="Chapter" title="3.1 Tokens">
<link href="#rfc.section.3.2" rel="Chapter" title="3.2 Scope">
<link href="#rfc.section.3.3" rel="Chapter" title="3.3 Expires_In">
<link href="#rfc.section.3.4" rel="Chapter" title="3.4 Authorization Code">
<link href="#rfc.section.3.5" rel="Chapter" title="3.5 Redirect-URI">
<link href="#rfc.section.3.6" rel="Chapter" title="3.6 Access Token">
<link href="#rfc.section.3.7" rel="Chapter" title="3.7 Refresh Token">
<link href="#rfc.section.3.8" rel="Chapter" title="3.8 Client Authentication">
<link href="#rfc.section.4" rel="Chapter" title="4 Security Threat Model">
<link href="#rfc.section.4.1" rel="Chapter" title="4.1 Clients">
<link href="#rfc.section.4.1.1" rel="Chapter" title="4.1.1 Threat: Obtain Client Secrets">
<link href="#rfc.section.4.1.2" rel="Chapter" title="4.1.2 Threat: Obtain Refresh Tokens">
<link href="#rfc.section.4.1.3" rel="Chapter" title="4.1.3 Threat: Obtain Access Tokens">
<link href="#rfc.section.4.1.4" rel="Chapter" title="4.1.4 Threat: End-user credentials phished using compromised or embedded browser">
<link href="#rfc.section.4.2" rel="Chapter" title="4.2 Authorization Endpoint">
<link href="#rfc.section.4.2.1" rel="Chapter" title="4.2.1 Threat: Password phishing by counterfeit authorization server">
<link href="#rfc.section.4.2.2" rel="Chapter" title="4.2.2 Threat: User unintentionally grants too much access scope">
<link href="#rfc.section.4.2.3" rel="Chapter" title="4.2.3 Threat: Malicious client obtains existing authorization by fraud">
<link href="#rfc.section.4.2.4" rel="Chapter" title="4.2.4 Threat: Open redirector">
<link href="#rfc.section.4.3" rel="Chapter" title="4.3 Token endpoint">
<link href="#rfc.section.4.3.1" rel="Chapter" title="4.3.1 Threat: Eavesdropping access tokens">
<link href="#rfc.section.4.3.2" rel="Chapter" title="4.3.2 Threat: Obtain access tokens from authorization server database">
<link href="#rfc.section.4.3.3" rel="Chapter" title="4.3.3 Threat: Obtain client credentials over non secure transport">
<link href="#rfc.section.4.3.4" rel="Chapter" title="4.3.4 Threat: Obtain client secret from authorization server database">
<link href="#rfc.section.4.3.5" rel="Chapter" title="4.3.5 Threat: Obtain client secret by online guessing">
<link href="#rfc.section.4.3.6" rel="Chapter" title="4.3.6 DoS on dynamic client secret creation">
<link href="#rfc.section.4.4" rel="Chapter" title="4.4 Obtaining Authorization">
<link href="#rfc.section.4.4.1" rel="Chapter" title="4.4.1 Authorization Code">
<link href="#rfc.section.4.4.1.1" rel="Chapter" title="4.4.1.1 Threat: Malicious client obtains authorization">
<link href="#rfc.section.4.4.1.2" rel="Chapter" title="4.4.1.2 Threat: Eavesdropping authorization codes">
<link href="#rfc.section.4.4.1.3" rel="Chapter" title="4.4.1.3 Threat: Obtain authorization codes from authorization server database">
<link href="#rfc.section.4.4.1.4" rel="Chapter" title="4.4.1.4 Threat: Online guessing of authorization codes">
<link href="#rfc.section.4.4.1.5" rel="Chapter" title="4.4.1.5 Threat: Authorization code leaks when requesting access token">
<link href="#rfc.section.4.4.1.6" rel="Chapter" title="4.4.1.6 Threat: Authorization code phishing">
<link href="#rfc.section.4.4.1.7" rel="Chapter" title="4.4.1.7 Threat: Session fixation">
<link href="#rfc.section.4.4.1.8" rel="Chapter" title="4.4.1.8 Threat: DoS, Exhaustion of resources attacks">
<link href="#rfc.section.4.4.2" rel="Chapter" title="4.4.2 Implicit Grant">
<link href="#rfc.section.4.4.2.1" rel="Chapter" title="4.4.2.1 Threat: Access token leak in transport/end-points">
<link href="#rfc.section.4.4.2.2" rel="Chapter" title="4.4.2.2 Threat: Access token leak in browser history">
<link href="#rfc.section.4.4.2.3" rel="Chapter" title="4.4.2.3 Threat: Malicious client obtains authorization">
<link href="#rfc.section.4.4.3" rel="Chapter" title="4.4.3 Resource Owner Password Credentials">
<link href="#rfc.section.4.4.3.1" rel="Chapter" title="4.4.3.1 Threat: Accidental exposure of passwords at client site">
<link href="#rfc.section.4.4.3.2" rel="Chapter" title="4.4.3.2 Threat: Client obtains scopes without end-user authorization">
<link href="#rfc.section.4.4.3.3" rel="Chapter" title="4.4.3.3 Threat: Client obtains refresh token through automatic authorization">
<link href="#rfc.section.4.4.3.4" rel="Chapter" title="4.4.3.4 Threat: Obtain user passwords on transport">
<link href="#rfc.section.4.4.3.5" rel="Chapter" title="4.4.3.5 Threat: Obtain user passwords from authorization server database">
<link href="#rfc.section.4.4.3.6" rel="Chapter" title="4.4.3.6 Threat: Online guessing">
<link href="#rfc.section.4.4.4" rel="Chapter" title="4.4.4 Client Credentials">
<link href="#rfc.section.4.5" rel="Chapter" title="4.5 Refreshing an Access Token">
<link href="#rfc.section.4.5.1" rel="Chapter" title="4.5.1 Threat: Eavesdropping refresh tokens from authorization server">
<link href="#rfc.section.4.5.2" rel="Chapter" title="4.5.2 Threat: Obtaining refresh token from authorization server database">
<link href="#rfc.section.4.5.3" rel="Chapter" title="4.5.3 Threat: Obtain refresh token by online guessing">
<link href="#rfc.section.4.5.4" rel="Chapter" title="4.5.4 Threat: Obtain refresh token phishing by counterfeit authorization server">
<link href="#rfc.section.4.6" rel="Chapter" title="4.6 Accessing Protected Resources">
<link href="#rfc.section.4.6.1" rel="Chapter" title="4.6.1 Threat: Eavesdropping access tokens on transport">
<link href="#rfc.section.4.6.2" rel="Chapter" title="4.6.2 Threat: Replay authorized resource server requests">
<link href="#rfc.section.4.6.3" rel="Chapter" title="4.6.3 Threat: Guessing access tokens">
<link href="#rfc.section.4.6.4" rel="Chapter" title="4.6.4 Threat: Access token phishing by counterfeit resource server">
<link href="#rfc.section.4.6.5" rel="Chapter" title="4.6.5 Threat: Abuse of token by legitimate resource server or client">
<link href="#rfc.section.4.6.6" rel="Chapter" title="4.6.6 Threat: Leak of confidential data in HTTP-Proxies">
<link href="#rfc.section.4.6.7" rel="Chapter" title="4.6.7 Threat: Token leakage via logfiles and HTTP referrers">
<link href="#rfc.section.5" rel="Chapter" title="5 Security Considerations">
<link href="#rfc.section.5.1" rel="Chapter" title="5.1 General">
<link href="#rfc.section.5.1.1" rel="Chapter" title="5.1.1 Confidentiality of Requests">
<link href="#rfc.section.5.1.2" rel="Chapter" title="5.1.2 Server authentication">
<link href="#rfc.section.5.1.3" rel="Chapter" title="5.1.3 Always keep the resource owner informed">
<link href="#rfc.section.5.1.4" rel="Chapter" title="5.1.4 Credentials">
<link href="#rfc.section.5.1.4.1" rel="Chapter" title="5.1.4.1 Credential storage protection">
<link href="#rfc.section.5.1.4.1.1" rel="Chapter" title="5.1.4.1.1 Standard system security means">
<link href="#rfc.section.5.1.4.1.2" rel="Chapter" title="5.1.4.1.2 Standard SQL inj. Countermeasures">
<link href="#rfc.section.5.1.4.1.3" rel="Chapter" title="5.1.4.1.3 No cleartext storage of credentials">
<link href="#rfc.section.5.1.4.1.4" rel="Chapter" title="5.1.4.1.4 Encryption of credentials">
<link href="#rfc.section.5.1.4.1.5" rel="Chapter" title="5.1.4.1.5 Use of asymmetric cryptography">
<link href="#rfc.section.5.1.4.2" rel="Chapter" title="5.1.4.2 Online attacks on secrets">
<link href="#rfc.section.5.1.4.2.1" rel="Chapter" title="5.1.4.2.1 Password policy">
<link href="#rfc.section.5.1.4.2.2" rel="Chapter" title="5.1.4.2.2 High entropy of secrets">
<link href="#rfc.section.5.1.4.2.3" rel="Chapter" title="5.1.4.2.3 Lock accounts">
<link href="#rfc.section.5.1.4.2.4" rel="Chapter" title="5.1.4.2.4 Tar pit">
<link href="#rfc.section.5.1.4.2.5" rel="Chapter" title="5.1.4.2.5 Usage of CAPTCHAs">
<link href="#rfc.section.5.1.5" rel="Chapter" title="5.1.5 Tokens (access, refresh, code)">
<link href="#rfc.section.5.1.5.1" rel="Chapter" title="5.1.5.1 Limit token scope">
<link href="#rfc.section.5.1.5.2" rel="Chapter" title="5.1.5.2 Expiration time">
<link href="#rfc.section.5.1.5.3" rel="Chapter" title="5.1.5.3 Short expiration time">
<link href="#rfc.section.5.1.5.4" rel="Chapter" title="5.1.5.4 Limit number of usages/ One time usage">
<link href="#rfc.section.5.1.5.5" rel="Chapter" title="5.1.5.5 Bind tokens to a particular resource server (Audience)">
<link href="#rfc.section.5.1.5.6" rel="Chapter" title="5.1.5.6 Use endpoint address as token audience">
<link href="#rfc.section.5.1.5.7" rel="Chapter" title="5.1.5.7 Audience and Token scopes">
<link href="#rfc.section.5.1.5.8" rel="Chapter" title="5.1.5.8 Bind token to client id">
<link href="#rfc.section.5.1.5.9" rel="Chapter" title="5.1.5.9 Signed tokens">
<link href="#rfc.section.5.1.5.10" rel="Chapter" title="5.1.5.10 Encryption of token content">
<link href="#rfc.section.5.1.5.11" rel="Chapter" title="5.1.5.11 Random token value with high entropy">
<link href="#rfc.section.5.1.6" rel="Chapter" title="5.1.6 Access tokens">
<link href="#rfc.section.5.2" rel="Chapter" title="5.2 Authorization Server">
<link href="#rfc.section.5.2.1" rel="Chapter" title="5.2.1 Authorization Codes">
<link href="#rfc.section.5.2.1.1" rel="Chapter" title="5.2.1.1 Automatic revocation of derived tokens if abuse is detected">
<link href="#rfc.section.5.2.2" rel="Chapter" title="5.2.2 Refresh tokens">
<link href="#rfc.section.5.2.2.1" rel="Chapter" title="5.2.2.1 Restricted issuance of refresh tokens">
<link href="#rfc.section.5.2.2.2" rel="Chapter" title="5.2.2.2 Binding of refresh token to client_id">
<link href="#rfc.section.5.2.2.3" rel="Chapter" title="5.2.2.3 Refresh Token Replacement">
<link href="#rfc.section.5.2.2.4" rel="Chapter" title="5.2.2.4 Refresh Token Revocation">
<link href="#rfc.section.5.2.2.5" rel="Chapter" title="5.2.2.5 Combine refresh token requests with user-provided secret">
<link href="#rfc.section.5.2.2.6" rel="Chapter" title="5.2.2.6 Device identification">
<link href="#rfc.section.5.2.3" rel="Chapter" title="5.2.3 Client authentication and authorization">
<link href="#rfc.section.5.2.3.1" rel="Chapter" title="5.2.3.1 Don't issue secrets to clients with inappropriate security policy">
<link href="#rfc.section.5.2.3.2" rel="Chapter" title="5.2.3.2 Client_id only in combination with forced user consent">
<link href="#rfc.section.5.2.3.3" rel="Chapter" title="5.2.3.3 Client_id only in combination with redirect_uri">
<link href="#rfc.section.5.2.3.4" rel="Chapter" title="5.2.3.4 Deployment-specific client secrets">
<link href="#rfc.section.5.2.3.5" rel="Chapter" title="5.2.3.5 Validation of pre-registered redirect_uri">
<link href="#rfc.section.5.2.3.6" rel="Chapter" title="5.2.3.6 Client secret revocation">
<link href="#rfc.section.5.2.3.7" rel="Chapter" title="5.2.3.7 Use strong client authentication (e.g. client_assertion / client_token)">
<link href="#rfc.section.5.2.4" rel="Chapter" title="5.2.4 End-user authorization">
<link href="#rfc.section.5.2.4.1" rel="Chapter" title="5.2.4.1 Automatic processing of repeated authorizations requires client validation">
<link href="#rfc.section.5.2.4.2" rel="Chapter" title="5.2.4.2 Informed decisions based on transparency">
<link href="#rfc.section.5.2.4.3" rel="Chapter" title="5.2.4.3 Validation of client properties by end-user">
<link href="#rfc.section.5.2.4.4" rel="Chapter" title="5.2.4.4 Binding of authorization code to client_id">
<link href="#rfc.section.5.2.4.5" rel="Chapter" title="5.2.4.5 Binding of authorization code to redirect_uri">
<link href="#rfc.section.5.3" rel="Chapter" title="5.3 Client App Security">
<link href="#rfc.section.5.3.1" rel="Chapter" title="5.3.1 Don't store credentials in code or resources bundled with software packages">
<link href="#rfc.section.5.3.2" rel="Chapter" title="5.3.2 Standard web server protection measures (for config files and databases)">
<link href="#rfc.section.5.3.3" rel="Chapter" title="5.3.3 Store secrets in a secure storage">
<link href="#rfc.section.5.3.4" rel="Chapter" title="5.3.4 Utilize device lock to prevent unauthorized device access">
<link href="#rfc.section.5.3.5" rel="Chapter" title="5.3.5 Platform security measures">
<link href="#rfc.section.5.4" rel="Chapter" title="5.4 Resource Servers">
<link href="#rfc.section.5.4.1" rel="Chapter" title="5.4.1 Authorization headers">
<link href="#rfc.section.5.4.2" rel="Chapter" title="5.4.2 Authenticated requests">
<link href="#rfc.section.5.4.3" rel="Chapter" title="5.4.3 Signed requests">
<link href="#rfc.section.6" rel="Chapter" title="6 IANA Considerations">
<link href="#rfc.section.7" rel="Chapter" title="7 Acknowledgements">
<link href="#rfc.references" rel="Chapter" title="8 References">
<link href="#rfc.references.1" rel="Chapter" title="8.1 Normative References">
<link href="#rfc.references.2" rel="Chapter" title="8.2 Informative References">
<link href="#rfc.authors" rel="Chapter">


  <meta name="generator" content=
  "http://greenbytes.de/tech/webdav/rfc2629.xslt, Revision 1.539, 2011-01-02 17:13:00, XSLT vendor: SAXON 6.5.5 from Michael Kay http://saxon.sf.net/" />
  <link rel="schema.dct" href="http://purl.org/dc/terms/" />
  <meta name="dct.creator" content="Doe, J." />
  <meta name="dct.identifier" content="urn:ietf:id:draft-sample-input-00" />
  <meta name="dct.issued" scheme="ISO8601" content="2010-12" />
  
  <meta name="dct.abstract" content="This document gives security considerations based on a comprehensive threat model for the OAuth 2.0 Protocol." />
  <meta name="description" content="This document gives security considerations based on a comprehensive threat model for the OAuth 2.0 Protocol." />
  <meta name="keywords" content="security, oauth 2.0, threat model" />

</head>

<body>

  <table class="header">
    <tbody>
    
    	<tr>
<td class="left">Open Authentication Protocol</td>
<td class="right">T. Lodderstedt, Ed.</td>
</tr>
<tr>
<td class="left">Internet-Draft</td>
<td class="right">Deutsche Telekom AG</td>
</tr>
<tr>
<td class="left">Intended status: Standards Track</td>
<td class="right">M. McGloin</td>
</tr>
<tr>
<td class="left">Expires: September 15, 2011</td>
<td class="right">IBM</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">P. Hunt</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">Oracle Corporation</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">March 14, 2011</td>
</tr>

    	
    </tbody>
  </table>

  <p class="title">OAuth 2.0 Threat Model and Security Considerations<br />
  <span class="filename">draft-lodderstedt-oauth-security-01</span></p>
  
  <h1 id="rfc.abstract"><a href="#rfc.abstract">Abstract</a></h1>
<p>This document gives security considerations based on a comprehensive threat model for the OAuth 2.0 Protocol.</p>
<h1><a>Requirements Language</a></h1>
<p>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in <a href="#RFC2119">RFC 2119</a> <cite title="NONE">[RFC2119]</cite>.</p>
<h1 id="rfc.status"><a href="#rfc.status">Status of this Memo</a></h1>
<p>This Internet-Draft is submitted in full conformance with the provisions of BCP 78 and BCP 79.</p>
<p>Internet-Drafts are working documents of the Internet Engineering Task Force (IETF).  Note that other groups may also distribute working documents as Internet-Drafts.  The list of current Internet- Drafts is at http://datatracker.ietf.org/drafts/current/.</p>
<p>Internet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other documents at any time.  It is inappropriate to use Internet-Drafts as reference material or to cite them other than as "work in progress."</p>
<p>This Internet-Draft will expire on September 15, 2011.</p>
<h1 id="rfc.copyrightnotice"><a href="#rfc.copyrightnotice">Copyright Notice</a></h1>
<p>Copyright (c) 2011 IETF Trust and the persons identified as the document authors.  All rights reserved.</p>
<p>This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document.  Please review these documents carefully, as they describe your rights and restrictions with respect to this document.  Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.</p>

  
  <hr class="noprint" />
  <h1 class="np" id="rfc.toc"><a href="#rfc.toc">Table of Contents</a></h1>
  <ul class="toc">

  	<li>1.   <a href="#rfc.section.1">Introduction</a>
</li>
<li>2.   <a href="#rfc.section.2">Overview</a>
</li>
<li>2.1.   <a href="#rfc.section.2.1">Scope</a>
</li>
<li>2.2.   <a href="#rfc.section.2.2">Attack Assumptions</a>
</li>
<li>2.3.   <a href="#rfc.section.2.3">Architectural assumptions</a>
</li>
<li>2.3.1.   <a href="#rfc.section.2.3.1">Authorization Servers</a>
</li>
<li>2.3.2.   <a href="#rfc.section.2.3.2">Resource Server</a>
</li>
<li>2.3.3.   <a href="#rfc.section.2.3.3">Client</a>
</li>
<li>2.3.3.1.   <a href="#rfc.section.2.3.3.1">Web Server</a>
</li>
<li>2.3.3.2.   <a href="#rfc.section.2.3.3.2">Native Applications</a>
</li>
<li>2.3.3.3.   <a href="#rfc.section.2.3.3.3">User Agent</a>
</li>
<li>2.3.3.4.   <a href="#rfc.section.2.3.3.4">Autonomous</a>
</li>
<li>3.   <a href="#rfc.section.3">Security Features</a>
</li>
<li>3.1.   <a href="#rfc.section.3.1">Tokens</a>
</li>
<li>3.2.   <a href="#rfc.section.3.2">Scope</a>
</li>
<li>3.3.   <a href="#rfc.section.3.3">Expires_In</a>
</li>
<li>3.4.   <a href="#rfc.section.3.4">Authorization Code</a>
</li>
<li>3.5.   <a href="#rfc.section.3.5">Redirect-URI</a>
</li>
<li>3.6.   <a href="#rfc.section.3.6">Access Token</a>
</li>
<li>3.7.   <a href="#rfc.section.3.7">Refresh Token</a>
</li>
<li>3.8.   <a href="#rfc.section.3.8">Client Authentication</a>
</li>
<li>4.   <a href="#rfc.section.4">Security Threat Model</a>
</li>
<li>4.1.   <a href="#rfc.section.4.1">Clients</a>
</li>
<li>4.1.1.   <a href="#rfc.section.4.1.1">Threat: Obtain Client Secrets</a>
</li>
<li>4.1.2.   <a href="#rfc.section.4.1.2">Threat: Obtain Refresh Tokens</a>
</li>
<li>4.1.3.   <a href="#rfc.section.4.1.3">Threat: Obtain Access Tokens</a>
</li>
<li>4.1.4.   <a href="#rfc.section.4.1.4">Threat: End-user credentials phished using compromised or embedded browser</a>
</li>
<li>4.2.   <a href="#rfc.section.4.2">Authorization Endpoint</a>
</li>
<li>4.2.1.   <a href="#rfc.section.4.2.1">Threat: Password phishing by counterfeit authorization server</a>
</li>
<li>4.2.2.   <a href="#rfc.section.4.2.2">Threat: User unintentionally grants too much access scope</a>
</li>
<li>4.2.3.   <a href="#rfc.section.4.2.3">Threat: Malicious client obtains existing authorization by fraud</a>
</li>
<li>4.2.4.   <a href="#rfc.section.4.2.4">Threat: Open redirector</a>
</li>
<li>4.3.   <a href="#rfc.section.4.3">Token endpoint</a>
</li>
<li>4.3.1.   <a href="#rfc.section.4.3.1">Threat: Eavesdropping access tokens</a>
</li>
<li>4.3.2.   <a href="#rfc.section.4.3.2">Threat: Obtain access tokens from authorization server database</a>
</li>
<li>4.3.3.   <a href="#rfc.section.4.3.3">Threat: Obtain client credentials over non secure transport</a>
</li>
<li>4.3.4.   <a href="#rfc.section.4.3.4">Threat: Obtain client secret from authorization server database</a>
</li>
<li>4.3.5.   <a href="#rfc.section.4.3.5">Threat: Obtain client secret by online guessing</a>
</li>
<li>4.3.6.   <a href="#rfc.section.4.3.6">DoS on dynamic client secret creation</a>
</li>
<li>4.4.   <a href="#rfc.section.4.4">Obtaining Authorization</a>
</li>
<li>4.4.1.   <a href="#rfc.section.4.4.1">Authorization Code</a>
</li>
<li>4.4.1.1.   <a href="#rfc.section.4.4.1.1">Threat: Malicious client obtains authorization</a>
</li>
<li>4.4.1.2.   <a href="#rfc.section.4.4.1.2">Threat: Eavesdropping authorization codes</a>
</li>
<li>4.4.1.3.   <a href="#rfc.section.4.4.1.3">Threat: Obtain authorization codes from authorization server database</a>
</li>
<li>4.4.1.4.   <a href="#rfc.section.4.4.1.4">Threat: Online guessing of authorization codes</a>
</li>
<li>4.4.1.5.   <a href="#rfc.section.4.4.1.5">Threat: Authorization code leaks when requesting access token</a>
</li>
<li>4.4.1.6.   <a href="#rfc.section.4.4.1.6">Threat: Authorization code phishing</a>
</li>
<li>4.4.1.7.   <a href="#rfc.section.4.4.1.7">Threat: Session fixation</a>
</li>
<li>4.4.1.8.   <a href="#rfc.section.4.4.1.8">Threat: DoS, Exhaustion of resources attacks</a>
</li>
<li>4.4.2.   <a href="#rfc.section.4.4.2">Implicit Grant</a>
</li>
<li>4.4.2.1.   <a href="#rfc.section.4.4.2.1">Threat: Access token leak in transport/end-points</a>
</li>
<li>4.4.2.2.   <a href="#rfc.section.4.4.2.2">Threat: Access token leak in browser history</a>
</li>
<li>4.4.2.3.   <a href="#rfc.section.4.4.2.3">Threat: Malicious client obtains authorization</a>
</li>
<li>4.4.3.   <a href="#rfc.section.4.4.3">Resource Owner Password Credentials</a>
</li>
<li>4.4.3.1.   <a href="#rfc.section.4.4.3.1">Threat: Accidental exposure of passwords at client site</a>
</li>
<li>4.4.3.2.   <a href="#rfc.section.4.4.3.2">Threat: Client obtains scopes without end-user authorization</a>
</li>
<li>4.4.3.3.   <a href="#rfc.section.4.4.3.3">Threat: Client obtains refresh token through automatic authorization</a>
</li>
<li>4.4.3.4.   <a href="#rfc.section.4.4.3.4">Threat: Obtain user passwords on transport</a>
</li>
<li>4.4.3.5.   <a href="#rfc.section.4.4.3.5">Threat: Obtain user passwords from authorization server database</a>
</li>
<li>4.4.3.6.   <a href="#rfc.section.4.4.3.6">Threat: Online guessing</a>
</li>
<li>4.4.4.   <a href="#rfc.section.4.4.4">Client Credentials</a>
</li>
<li>4.5.   <a href="#rfc.section.4.5">Refreshing an Access Token</a>
</li>
<li>4.5.1.   <a href="#rfc.section.4.5.1">Threat: Eavesdropping refresh tokens from authorization server</a>
</li>
<li>4.5.2.   <a href="#rfc.section.4.5.2">Threat: Obtaining refresh token from authorization server database</a>
</li>
<li>4.5.3.   <a href="#rfc.section.4.5.3">Threat: Obtain refresh token by online guessing</a>
</li>
<li>4.5.4.   <a href="#rfc.section.4.5.4">Threat: Obtain refresh token phishing by counterfeit authorization server</a>
</li>
<li>4.6.   <a href="#rfc.section.4.6">Accessing Protected Resources</a>
</li>
<li>4.6.1.   <a href="#rfc.section.4.6.1">Threat: Eavesdropping access tokens on transport</a>
</li>
<li>4.6.2.   <a href="#rfc.section.4.6.2">Threat: Replay authorized resource server requests</a>
</li>
<li>4.6.3.   <a href="#rfc.section.4.6.3">Threat: Guessing access tokens</a>
</li>
<li>4.6.4.   <a href="#rfc.section.4.6.4">Threat: Access token phishing by counterfeit resource server</a>
</li>
<li>4.6.5.   <a href="#rfc.section.4.6.5">Threat: Abuse of token by legitimate resource server or client</a>
</li>
<li>4.6.6.   <a href="#rfc.section.4.6.6">Threat: Leak of confidential data in HTTP-Proxies</a>
</li>
<li>4.6.7.   <a href="#rfc.section.4.6.7">Threat: Token leakage via logfiles and HTTP referrers</a>
</li>
<li>5.   <a href="#rfc.section.5">Security Considerations</a>
</li>
<li>5.1.   <a href="#rfc.section.5.1">General</a>
</li>
<li>5.1.1.   <a href="#rfc.section.5.1.1">Confidentiality of Requests</a>
</li>
<li>5.1.2.   <a href="#rfc.section.5.1.2">Server authentication</a>
</li>
<li>5.1.3.   <a href="#rfc.section.5.1.3">Always keep the resource owner informed</a>
</li>
<li>5.1.4.   <a href="#rfc.section.5.1.4">Credentials</a>
</li>
<li>5.1.4.1.   <a href="#rfc.section.5.1.4.1">Credential storage protection</a>
</li>
<li>5.1.4.1.1.   <a href="#rfc.section.5.1.4.1.1">Standard system security means</a>
</li>
<li>5.1.4.1.2.   <a href="#rfc.section.5.1.4.1.2">Standard SQL inj. Countermeasures</a>
</li>
<li>5.1.4.1.3.   <a href="#rfc.section.5.1.4.1.3">No cleartext storage of credentials</a>
</li>
<li>5.1.4.1.4.   <a href="#rfc.section.5.1.4.1.4">Encryption of credentials</a>
</li>
<li>5.1.4.1.5.   <a href="#rfc.section.5.1.4.1.5">Use of asymmetric cryptography</a>
</li>
<li>5.1.4.2.   <a href="#rfc.section.5.1.4.2">Online attacks on secrets</a>
</li>
<li>5.1.4.2.1.   <a href="#rfc.section.5.1.4.2.1">Password policy</a>
</li>
<li>5.1.4.2.2.   <a href="#rfc.section.5.1.4.2.2">High entropy of secrets</a>
</li>
<li>5.1.4.2.3.   <a href="#rfc.section.5.1.4.2.3">Lock accounts</a>
</li>
<li>5.1.4.2.4.   <a href="#rfc.section.5.1.4.2.4">Tar pit</a>
</li>
<li>5.1.4.2.5.   <a href="#rfc.section.5.1.4.2.5">Usage of CAPTCHAs</a>
</li>
<li>5.1.5.   <a href="#rfc.section.5.1.5">Tokens (access, refresh, code)</a>
</li>
<li>5.1.5.1.   <a href="#rfc.section.5.1.5.1">Limit token scope</a>
</li>
<li>5.1.5.2.   <a href="#rfc.section.5.1.5.2">Expiration time</a>
</li>
<li>5.1.5.3.   <a href="#rfc.section.5.1.5.3">Short expiration time</a>
</li>
<li>5.1.5.4.   <a href="#rfc.section.5.1.5.4">Limit number of usages/ One time usage</a>
</li>
<li>5.1.5.5.   <a href="#rfc.section.5.1.5.5">Bind tokens to a particular resource server (Audience)</a>
</li>
<li>5.1.5.6.   <a href="#rfc.section.5.1.5.6">Use endpoint address as token audience</a>
</li>
<li>5.1.5.7.   <a href="#rfc.section.5.1.5.7">Audience and Token scopes</a>
</li>
<li>5.1.5.8.   <a href="#rfc.section.5.1.5.8">Bind token to client id</a>
</li>
<li>5.1.5.9.   <a href="#rfc.section.5.1.5.9">Signed tokens</a>
</li>
<li>5.1.5.10.   <a href="#rfc.section.5.1.5.10">Encryption of token content</a>
</li>
<li>5.1.5.11.   <a href="#rfc.section.5.1.5.11">Random token value with high entropy</a>
</li>
<li>5.1.6.   <a href="#rfc.section.5.1.6">Access tokens</a>
</li>
<li>5.2.   <a href="#rfc.section.5.2">Authorization Server</a>
</li>
<li>5.2.1.   <a href="#rfc.section.5.2.1">Authorization Codes</a>
</li>
<li>5.2.1.1.   <a href="#rfc.section.5.2.1.1">Automatic revocation of derived tokens if abuse is detected</a>
</li>
<li>5.2.2.   <a href="#rfc.section.5.2.2">Refresh tokens</a>
</li>
<li>5.2.2.1.   <a href="#rfc.section.5.2.2.1">Restricted issuance of refresh tokens</a>
</li>
<li>5.2.2.2.   <a href="#rfc.section.5.2.2.2">Binding of refresh token to client_id</a>
</li>
<li>5.2.2.3.   <a href="#rfc.section.5.2.2.3">Refresh Token Replacement</a>
</li>
<li>5.2.2.4.   <a href="#rfc.section.5.2.2.4">Refresh Token Revocation</a>
</li>
<li>5.2.2.5.   <a href="#rfc.section.5.2.2.5">Combine refresh token requests with user-provided secret</a>
</li>
<li>5.2.2.6.   <a href="#rfc.section.5.2.2.6">Device identification</a>
</li>
<li>5.2.3.   <a href="#rfc.section.5.2.3">Client authentication and authorization</a>
</li>
<li>5.2.3.1.   <a href="#rfc.section.5.2.3.1">Don't issue secrets to clients with inappropriate security policy</a>
</li>
<li>5.2.3.2.   <a href="#rfc.section.5.2.3.2">Client_id only in combination with forced user consent</a>
</li>
<li>5.2.3.3.   <a href="#rfc.section.5.2.3.3">Client_id only in combination with redirect_uri</a>
</li>
<li>5.2.3.4.   <a href="#rfc.section.5.2.3.4">Deployment-specific client secrets</a>
</li>
<li>5.2.3.5.   <a href="#rfc.section.5.2.3.5">Validation of pre-registered redirect_uri</a>
</li>
<li>5.2.3.6.   <a href="#rfc.section.5.2.3.6">Client secret revocation</a>
</li>
<li>5.2.3.7.   <a href="#rfc.section.5.2.3.7">Use strong client authentication (e.g. client_assertion / client_token)</a>
</li>
<li>5.2.4.   <a href="#rfc.section.5.2.4">End-user authorization</a>
</li>
<li>5.2.4.1.   <a href="#rfc.section.5.2.4.1">Automatic processing of repeated authorizations requires client validation</a>
</li>
<li>5.2.4.2.   <a href="#rfc.section.5.2.4.2">Informed decisions based on transparency</a>
</li>
<li>5.2.4.3.   <a href="#rfc.section.5.2.4.3">Validation of client properties by end-user</a>
</li>
<li>5.2.4.4.   <a href="#rfc.section.5.2.4.4">Binding of authorization code to client_id</a>
</li>
<li>5.2.4.5.   <a href="#rfc.section.5.2.4.5">Binding of authorization code to redirect_uri</a>
</li>
<li>5.3.   <a href="#rfc.section.5.3">Client App Security</a>
</li>
<li>5.3.1.   <a href="#rfc.section.5.3.1">Don't store credentials in code or resources bundled with software packages</a>
</li>
<li>5.3.2.   <a href="#rfc.section.5.3.2">Standard web server protection measures (for config files and databases)</a>
</li>
<li>5.3.3.   <a href="#rfc.section.5.3.3">Store secrets in a secure storage</a>
</li>
<li>5.3.4.   <a href="#rfc.section.5.3.4">Utilize device lock to prevent unauthorized device access</a>
</li>
<li>5.3.5.   <a href="#rfc.section.5.3.5">Platform security measures</a>
</li>
<li>5.4.   <a href="#rfc.section.5.4">Resource Servers</a>
</li>
<li>5.4.1.   <a href="#rfc.section.5.4.1">Authorization headers</a>
</li>
<li>5.4.2.   <a href="#rfc.section.5.4.2">Authenticated requests</a>
</li>
<li>5.4.3.   <a href="#rfc.section.5.4.3">Signed requests</a>
</li>
<li>6.   <a href="#rfc.section.6">IANA Considerations</a>
</li>
<li>7.   <a href="#rfc.section.7">Acknowledgements</a>
</li>
<li>8.   <a href="#rfc.references">References</a>
</li>
<li>8.1.   <a href="#rfc.references.1">Normative References</a>
</li>
<li>8.2.   <a href="#rfc.references.2">Informative References</a>
</li>
<li><a href="#rfc.authors">Authors' Addresses</a>
</li>


  </ul>

  <h1 id="rfc.section.1">
<a href="#rfc.section.1">1.</a> Introduction</h1>
<p id="rfc.section.1.p.1">This document gives security considerations based on a comprehensive threat model for the OAuth 2.0 Protocol <a href="#I-D.ietf-oauth-v2">[I-D.ietf-oauth-v2]</a>. It contains the following content:</p>

<ul>
<li>Documents any assumptions and scope considered when creating the threat model</li>
<li>Describe the security features in-built into the OAuth protocol and how they are intended to thwart attacks</li>
<li>Give a comprehensive threat model for OAuth and describes the respective counter measures to thwart those threats.</li>
</ul>

<p>Threats include any intentional attacks on OAuth tokens and resources protected by OAuth tokens as well as security risks introduced if the proper security measures are not put in place. Threats are structured along the lines of the protocol structure to aid development teams implement each part of the protocol securely. For example all threats for granting access or all threats for a particular client profile or all threats for protecting the resource server.</p>
<h1 id="rfc.section.2">
<a href="#rfc.section.2">2.</a> Overview</h1>
<p></p>
<h1 id="rfc.section.2.1">
<a href="#rfc.section.2.1">2.1.</a> Scope</h1>
<p id="rfc.section.2.1.p.1">The security considerations document only considers clients bound to a particular deployment as supported by <a href="#I-D.ietf-oauth-v2">[I-D.ietf-oauth-v2]</a>. Such deployments have the following characteristics:</p>
<p></p>

<ul>
<li>Resource server URLs are static and well-known at development time, authorization server URLs can be static or discovered.</li>
<li>Token scope values (e.g. applicable URLs and methods) are well-known at development time.</li>
<li>Client registration: Since registration of clients is out of scope of the current core spec, this document assumes a broad variety of options from static registration during development time to dynamic registration at runtime.</li>
</ul>

<p>The following are considered out of scope :</p>
<p></p>

<ul>
<li>Communication between authorization server and resource server</li>
<li>Token formats</li>
<li>Except for &#8222;Resource Owner Password Credentials&#8220; (see <a href="#I-D.ietf-oauth-v2">[I-D.ietf-oauth-v2]</a>, section 4.3), the mechanism used by authorization servers to authenticate the user</li>
<li>Mechanism by which a user obtained an assertion and any resulting attacks mounted as a result of the assertion being false.</li>
<li>Clients are not bound to a specific deployment: An example could by a mail client with support for contact list access via the portable contacts API (see <a href="#portable-contacts">[portable-contacts]</a>). Such clients cannot be registered upfront with a particular deployment and must dynamically discover the URLs relevant for the Oauth protocol.</li>
</ul>

<p> </p>
<h1 id="rfc.section.2.2">
<a href="#rfc.section.2.2">2.2.</a> Attack Assumptions</h1>
<p id="rfc.section.2.2.p.1">The following assumptions relate to an attacker and resources available to an attacker:</p>
<p></p>

<ul>
<li>It is assumed the attacker has full access to the network between the client and service provider and may eaves drop on any communications between the two.</li>
<li>It is assumed an attacker has unlimited resources to mount an attack.</li>
<li>It is assumed that 2 parties involved in the OAuth 3 legged protocol may collude to mount an attack against the 3rd party. For example, the client and authorization server may be under control of an attacker and collude to trick a user to gain access to resources.</li>
</ul>

<p> </p>
<h1 id="rfc.section.2.3">
<a href="#rfc.section.2.3">2.3.</a> Architectural assumptions</h1>
<p id="rfc.section.2.3.p.1">This section documents the assumptions about the features, limitations and design options of the different entities of a OAuth deployment along with the security-sensitive data-elements managed by those entity. These assumptions are the foundation of the treat analysis.</p>
<p id="rfc.section.2.3.p.2">The OAuth protocol leaves deployments with a certain degree of freedom how to implement and apply the standard. The core specification defines the core concepts of an authorization server and an resource server. Both servers can be implemented in the same server entity, or they may also be different entities. The later is typically the case for multi-service providers with a single authentication and authorization system, and are more typical in middleware architectures.</p>
<h1 id="rfc.section.2.3.1">
<a href="#rfc.section.2.3.1">2.3.1.</a> Authorization Servers</h1>
<p id="rfc.section.2.3.1.p.1">The following data elements MAY be stored or accessible on the authorization server:</p>
<p></p>

<ul>
<li>user names and passwords</li>
<li>client ids and secrets</li>
<li>client-specific refresh tokens</li>
<li>client-specific access tokens (in case of handle-based design)</li>
<li>HTTPS certificate/key</li>
<li>per authorization process (in case of handle-based design): redirect_uri, client_id, authorization code</li>
</ul>

<p> </p>
<h1 id="rfc.section.2.3.2">
<a href="#rfc.section.2.3.2">2.3.2.</a> Resource Server</h1>
<p id="rfc.section.2.3.2.p.1">The following data elements MAY be stored or accessible on the authorization server:</p>
<p></p>

<ul>
<li>user data (out of scope)</li>
<li>HTTPS certificate/key</li>
<li>authz server credentials (handle-based design), or</li>
<li>authz server shared secret/public key (assertion-based design)</li>
<li>access tokens (per request)</li>
</ul>

<p> It is assumed that a resource server has no knowledge of refresh tokens, user passwords, or client secrets.</p>
<h1 id="rfc.section.2.3.3">
<a href="#rfc.section.2.3.3">2.3.3.</a> Client</h1>
<p id="rfc.section.2.3.3.p.1">The following data elements are stored or accessible on the authorization server:</p>
<p></p>

<ul>
<li>client id (and secret)</li>
<li>refresh tokens (persistent) access tokens (transient)</li>
<li>trusted CA certs (HTTPS)</li>
<li>per authorization process: redirect_uri, authorization code</li>
</ul>

<p> </p>
<h1 id="rfc.section.2.3.3.1">
<a href="#rfc.section.2.3.3.1">2.3.3.1.</a> Web Server</h1>
<p id="rfc.section.2.3.3.1.p.1">Such clients typically represent a web site with its own user management and login mechanism and have the following characteristics:</p>
<p><a href="#code_flow">Section 4.4.1</a>).</p>

<ul>
<li>Tokens are bound to a single user identity at the site</li>
<li>Web servers are able to protect client secrets</li>
<li>The potential number of tokens affected by a security breach depends on number of site users.</li>
</ul>

<p>Such clients are implemented using the authorization code flow (see </p>
<h1 id="rfc.section.2.3.3.2">
<a href="#rfc.section.2.3.3.2">2.3.3.2.</a> Native Applications</h1>
<p id="rfc.section.2.3.3.2.p.1">This class of OAuth clients represent apps running on a user-controlled device, such as a notebook, PC, Tablet, Smartphone, or Gaming Console.</p>
<p id="rfc.section.2.3.3.2.p.2">Massively distributed applications such as these cannot reliably keep secrets confidential, which are issued per software package. This is because such secrets would need to be transferred to the user device as part of the installation process. An attacker could reverse engineer any secret from the binary or accompanying resources. Native Applications are able to protect per installation/instance secrets (e.g. refresh tokens) to some extent.</p>
<p id="rfc.section.2.3.3.2.p.3">Device platforms typically allow users to lock the device with a pin and to segregate different apps or users (multi-user operation systems).</p>
<p id="rfc.section.2.3.3.2.p.4">Some devices can be identified/authenticated (to varying degrees of assurance):</p>
<p></p>

<ul>
<li>Handsets and smart phones by its International Mobile Equipment Identity (IMEI)</li>
<li>Set top boxes, gaming consoles, others by using certificates and TPM module - Note: This does not help to identify client apps but may be used to bound tokens to devices and to detect token theft</li>
</ul>

<p>Mobile devices, such as handsets or smart phones have the following special characteristics:</p>
<p></p>

<ul>
<li>Limited input capabilities, therefore such clients typically obtain a refresh token in order to provide automatic login for sub-sequent application sessions</li>
<li>As mobile and small devices, they can get cloned, stolen or lost easier than other devices.</li>
<li>Security breach will affect single user (or a few users) only.</li>
</ul>

<p>For the purposes of this document, the scenario of attackers who control a smartphone device entirely is out of scope.</p>
<p id="rfc.section.2.3.3.2.p.7">There are several implementation options for native applications:</p>
<p></p>

<ul>
<li>The authorization code flow in combination with an embedded or external browser (<a href="#code_flow">Section 4.4.1</a>)</li>
<li>The implicte grant flow in combination with an embedded or external browser (<a href="#implicite_flow">Section 4.4.2</a>)</li>
<li>The resource owner password credentials flow can be used as well (<a href="#pwd_flow">Section 4.4.3</a>)</li>
</ul>

<p>Different threats exists for those implementation options, which are discussed in the respective sections of the threat model.</p>
<h1 id="rfc.section.2.3.3.3">
<a href="#rfc.section.2.3.3.3">2.3.3.3.</a> User Agent</h1>
<p id="rfc.section.2.3.3.3.p.1">[TBD]</p>
<p id="rfc.section.2.3.3.3.p.2">Such client are implemented using the implicite grant flow (<a href="#implicite_flow">Section 4.4.2</a>).</p>
<h1 id="rfc.section.2.3.3.4">
<a href="#rfc.section.2.3.3.4">2.3.3.4.</a> Autonomous</h1>
<p id="rfc.section.2.3.3.4.p.1">Autonomous clients access service providers using rights grants by client credentials only. Thus the autonomous client becomes the &#8222;user&#8220;. Authenticating autonomous clients is conceptually similar to end-user authentication since the issued tokens refer to the client's identity. Autonomous clients shall always be required to use a secret or some other form of authentication (e.g. client assertion in the form of a SAML assertion or STS token) acceptable to the authorization/token services. The client must ensure the confidentiality of client_secret or other credential.</p>
<h1 id="rfc.section.3">
<a href="#rfc.section.3">3.</a> Security Features</h1>
<p id="rfc.section.3.p.1">These are some of the security features which have been built into the OAuth 2.0 protocol to mitigate attacks and security issues.</p>
<h1 id="rfc.section.3.1">
<a href="#rfc.section.3.1">3.1.</a> Tokens</h1>
<p id="rfc.section.3.1.p.1">OAuth makes extensive use of tokens. Tokens can be implemented in 2 ways as follows:</p>
<p></p>

<dl>
<dt>Handle (or artifact)</dt>
<dd style="margin-left: 8">a reference to some internal data structure within the authorization server, the internal data structure contains the attributes of the token, such as user id, scope, etc. Handles typically require a communication between resource server and token server in order to validate the token and obtain token-bound data. Handles enable simple revocation and do not require cryptographic mechanisms to protected token content from being modified. As a disadvantage, they require additional resource/token server communication impacting on performance and scalability. An authorization code (OAuth Section 4.1.2) is an example of a 'handle' token. An access token may also be implemented as a handle token. A 'handle' token is often referred to as an 'opaque' token because the resource server does not need to be able to interpret the token directly, it simply uses the token.</dd>
<dt>Assertions (aka self-contained token)</dt>
<dd style="margin-left: 8">a parseable token. An assertion typically has a duration, an audience, and is digitally signed containing information about the user and the client. Examples of assertion formats are SAML assertions and Kerberos tickets. Assertions can typically directly be validated and used by a resource server without interactions with the authorization server. This results in better performance and scalability. Implementing token revocation is more difficult with assertions than with handles.</dd>
</dl>

<p>Tokens can be sent to resource server in two ways:</p>
<p></p>

<dl>
<dt>bearer token</dt>
<dd style="margin-left: 8">A 'bearer token' is a token that can be used by any client who has received the token (cf. <a href="#I-D.ietf-oauth-v2-bearer">[I-D.ietf-oauth-v2-bearer]</a> . Because mere possession is enough to use the token it is important that communication between end-points be secured to ensure that only authorized end-points may capture the token. The bearer token is convenient to client applications as it does not require them to do anything to use them (such as a proof of identity). Bearer tokens have similar characteristics to web SSO cookies used in browsers.</dd>
<dt>proof token</dt>
<dd style="margin-left: 8">A 'proof token' is a token that can only be used by a specific client. Each use of the token, requires the client to perform some action that proves that it is the authorized user of the token. Examples of this are MAC (mutual authentication) and HoK (holder-of-key) tokens (cf. <a href="#I-D.hammer-oauth-v2-mac-token">[I-D.hammer-oauth-v2-mac-token]</a>.</dd>
</dl>

<p> </p>
<h1 id="rfc.section.3.2">
<a href="#rfc.section.3.2">3.2.</a> Scope</h1>
<p id="rfc.section.3.2.p.1">A Scope represents the access authorization associated with a particular token with respect to resource servers, resources and methods on those resources. Scopes are the OAuth way to explicitly manage the power associated with an access token. A scope can be controlled by the authorization server and/or the end-user in order to limit access to resources for OAuth clients these parties deem less secure or trustworthy. Optionally, the client can request the scope to apply to the token but only for lesser scope than would otherwise be granted, e.g. to reduce the potential impact if this token is sent over non secure channels. A scope is typically complemented by a restriction on a token's lifetime.</p>
<h1 id="rfc.section.3.3">
<a href="#rfc.section.3.3">3.3.</a> Expires_In</h1>
<p id="rfc.section.3.3.p.1">Expires_In allows an authorization server (based on its policies or on behalf of the end-user) to limit the lifetime of the access token.  This mechanisms can be used to issue short-living tokens to OAuth clients the authorization server deems less secure or where sending tokens over non secure channels.</p>
<h1 id="rfc.section.3.4">
<a href="#rfc.section.3.4">3.4.</a> Authorization Code</h1>
<p id="rfc.section.3.4.p.1">An Authorization Code represents the intermediary result of a successful end-user authorization process and is used by the client to obtain access and refresh token. Authorization codes are sent to the client's redirect_uri instead of tokens for two purposes.</p>
<h1 id="rfc.section.3.5">
<a href="#rfc.section.3.5">3.5.</a> Redirect-URI</h1>
<p id="rfc.section.3.5.p.1">A Redirect-uri helps to identify clients and prevents phishing attacks from other clients attempting to trick the user into believing the phisher is the client. The redirect URI is pre-registered as requests with authorization code or token will be directed to that URI. Moreover, the value of the actual redirect_uri has to be presented and is verified when an authorization code is exchanged for tokens. This helps to prevent session fixation attacks.</p>
<h1 id="rfc.section.3.6">
<a href="#rfc.section.3.6">3.6.</a> Access Token</h1>
<p id="rfc.section.3.6.p.1">An Access Token is used by a client to access a resource. An access token must be acquired using a HTTP POST operation to ensure no logging or caching of requests. Access tokens typically have short life-spans (minutes or hours) that cover typical session lifetimes. An access token may be refreshed through the use of a Refresh Token.</p>
<p id="rfc.section.3.6.p.2">The short lifespan of an access token enables the possibility of revocation by requiring the client to refresh their access token at regular intervals.</p>
<h1 id="rfc.section.3.7">
<a href="#rfc.section.3.7">3.7.</a> Refresh Token</h1>
<p id="rfc.section.3.7.p.1">A Refresh Token is coupled with a short access token lifetime, can be used to grant longer access to resources without involving end user authorization. This offers an advantage where resource servers and authorization servers are not the same entity, e.g. in a distributed environment, as the refresh token must always be exchanged at the authorization server. The authorization server can revoke the refresh token at any time causing the granted access to be revoked once the current access token expires. Because of this, a short access token lifetime is important if timely revocation is a high priority.</p>
<h1 id="rfc.section.3.8">
<a href="#rfc.section.3.8">3.8.</a> Client Authentication</h1>
<p id="rfc.section.3.8.p.1">Authentication protocols have typically not taken into account the identity of the software component acting on behalf of the end-user.  OAuth does this in order to increase security level in delegated authorization scenarios and because the client will be able to act without the user's presence. By authenticating a client when requesting an access token, the token service is able to assess whether a given client and authorization code meets appropriate security requirements and binds the authorization code approved by the user to the client making the request.</p>
<p id="rfc.section.3.8.p.2">OAuth uses the <em>client_id</em> to collate associated request to the same originator, such as</p>
<p></p>

<ul>
<li>a particular end-user authorization process and the corresponding request on the tokens endpoint to exchange the authorization code for tokens or</li>
<li>the initial authorization and issuance of a tokens by an end-user to a particular client and sub-sequent requests by this client to obtain tokens w/o user consent (automatic processing of repeated authorization)</li>
</ul>

<p>The client identity may also be used by the authorization server to display relevant registration information to a user when requesting consent for scope requested by a particular client. The client identity may be used to limit the number of request for a particular client or to charge the client per request. Client Identity may furthermore be useful to differentiate (e.g. in server log files) between accesses by end-user, and delegated accesses by client on behalf of a user.</p>
<p id="rfc.section.3.8.p.4">The <em>client_secret</em> is used to verify the client identifier. This should only be used where the client is capable of keeping its secret confidential. The client identity can also be verified using the <em>redirect_uri</em> or by the <em>end-user</em>.</p>
<p id="rfc.section.3.8.p.5">Clients (and the trustworthiness of its identity) can be classifed by using the following parameters:</p>
<p></p>

<ul>
<li>Deployment-specific or -independent client_id (Note: for native apps, every installation of a particular app on a certain device is considered a deployment.)</li>
<li>Validated properties, such as app name or redirect_uri</li>
<li>Client_secret available</li>
</ul>

<p>Typical client categories are:</p>
<p></p>

<dl>
<dt>Deployment-independent client_id with pre-registered redirect_uri and without client_secret</dt>
<dd style="margin-left: 8">Such an identity is used by multiple installations of the same software package. The identity of such a client can only be validated with the help of the end-user. This is a viable option for native apps in order to identify the client for the purpose of displaying meta information about the client to the user and to differentiate clients in log files. Revocation of such an identity will affect ALL deployments of the respective software.</dd>
<dt>Deployment-independent client_id with pre-registered redirect_uri and with client_secre</dt>
<dd style="margin-left: 8">This is an option for native applications only, since web application would require different redirect URIs. This category is not advisable because the client secret cannot be protected appropriately (cf. <a href="#ObtainClientSecrets">Section 4.1.1</a>). Due to its security weaknesses, such client identities have the same trustlevel as deployment-independent clients without secret.  Revocation will affect ALL deployments.</dd>
<dt>Deployment-specific client_id with pre-registered redirect_uri and with client_secret</dt>
<dd style="margin-left: 8">The client registration process insures the validation of the client's properties, such as redirect_uri, website address, web site name, contacts. Such a client identity can be utilized for all relevant use cases cited above. This level can be achieved for web applications in combination with a manual or user-bound registration process. Achieving this level for native applications is much more difficult. Either the installation of the app is conducted by an administrator, who validates the clients authenticity, or the process from validating the app to the installation of the app on the device and the creation of the client credentials is controlled end-to-end by a single entity (e.g. app market provider). Revocation will affect a single deployment only.</dd>
<dt>Deployment-specific client_id with client_secret without validated properties</dt>
<dd style="margin-left: 8">Such a client can be recognized by the authorization server in transactions with subsequent requests (e.g. authorization and token issuance, refresh token issuance and access token refreshment). Automatic processing of re-authorizations could be allowed as well. Such client credentials can be generated automatically without any validation of client properties, which makes it another option especially for native apps. Revocation will affect a single deployment only.</dd>
</dl>

<p>Use of the client secret is considered a relatively weak form of credential for the client. Use of stronger mechanisms such as a client assertion (e.g. SAML), key cryptography, are preferred.</p>
<h1 id="rfc.section.4">
<a href="#rfc.section.4">4.</a> Security Threat Model</h1>
<p id="rfc.section.4.p.1">This sections gives a comprehensive threat model of OAuth 2.0.  Threats are grouped first by attackes directed against an OAuth component, which are client, authorization server, and resource server.  Subsequently, they are grouped by flow, e.g. obtain token or access protected resources. Every countermeasure description refers to a detailed description in <a href="#security_considerations">Section 5</a>.</p>
<h1 id="rfc.section.4.1">
<a href="#rfc.section.4.1">4.1.</a> Clients</h1>
<p id="rfc.section.4.1.p.1">This section describes possible threats directed to OAuth clients.</p>
<h1 id="rfc.section.4.1.1">
<a href="#rfc.section.4.1.1">4.1.1.</a> <a href="#ObtainClientSecrets" id="ObtainClientSecrets">Threat: Obtain Client Secrets</a>
</h1>
<p id="rfc.section.4.1.1.p.1">The attacker could try to get access to the secret of a particular client in order to:</p>
<p></p>

<ul>
<li>replay its tokens and authorization codes, or</li>
<li>obtain tokens on behalf of the attacked client with the privileges of that client.</li>
</ul>

<p>The resulting impact would be:</p>
<p></p>

<ul>
<li>Client authentication of access to authorization server can be bypassed</li>
<li>Stolen refresh tokens or authorization codes can be replayed</li>
</ul>

<p>Depending on the client category, there are the following approaches an attacker could utilize to obtain the client secret.</p>
<p><strong>Attack: Obtain Secret From Source Code or Binary.</strong> This applies for all client profiles and especially for open source projects, where the source code is public accessible. Even if the attacker does not has access to the source code, it could reverse engineer secrets from the binary of native apps.</p>
<p><em>Countermeasures:</em> </p>
<p><em></em> </p>

<ul>
<li>Don't issue secrets to clients with inappropriate security policy - <a href="#dont_issue">Section 5.2.3.1</a>
</li>
<li>Client_id only in combination with forced user consent - <a href="#forced_user_consent">Section 5.2.3.2</a>
</li>
<li>Deployment-specific client secrets - <a href="#depl_specific_secretes">Section 5.2.3.4</a>
</li>
<li>Client secret revocation - <a href="#client_secret_revocation">Section 5.2.3.6</a>
</li>
</ul>

<p> </p>
<p><strong>Attack: Obtain a Deployment-Specific Secret.</strong> An attacker may try to obtain the secret from a client installation, either from a web site (web server) or a particular devices (native app).</p>
<p><em>Countermeasures:</em> </p>
<p></p>

<ul>
<li>Web server: apply standard web server protection measures (for config files and databases) - <a href="#std_web">Section 5.3.2</a>
</li>
<li>Native apps: Store secrets in a secure local storage - <a href="#secure_storage">Section 5.3.3</a>
</li>
<li>Client secret revocation - <a href="#client_secret_revocation">Section 5.2.3.6</a>
</li>
</ul>

<p> </p>
<h1 id="rfc.section.4.1.2">
<a href="#rfc.section.4.1.2">4.1.2.</a> Threat: Obtain Refresh Tokens</h1>
<p id="rfc.section.4.1.2.p.1">Depending on the client type, there are different ways refresh tokens may be revealed to an attacker. The following sub-sections give a more detailed description of the different attacks with respect to different client types and further specialized countermeasures. Some generally applicable countermeasure to mitigate such attacks shall be given in advance:</p>
<p><strong></strong> </p>

<ul>
<li>The authorization server must validate the client id associated with the particular refresh token with every refresh request - <a href="#binding_refresh_client_id">Section 5.2.2.2</a>
</li>
<li>Limited scope tokens - <a href="#limit_scope">Section 5.1.5.1</a>
</li>
<li>Refresh token revocation - <a href="#refresh_revocation">Section 5.2.2.4</a>
</li>
<li>Client secret revocation - <a href="#client_secret_revocation">Section 5.2.3.6</a>
</li>
<li>Refresh tokens can automatically be replaced in order to detect unauthorized token usage by another party (Refresh Token Replacement) - <a href="#refresh_replace">Section 5.2.2.3</a>
</li>
</ul>

<p> </p>
<p><strong>Attack: Obtain Refresh Token from Web application.</strong> An attack may obtain the refresh tokens issued to a web server client. Impact: Exposure of all refresh tokens on that side.</p>
<p><em>Countermeasures:</em> <strong></strong> </p>

<ul>
<li>Standard web server protection measures - <a href="#std_web">Section 5.3.2</a>
</li>
<li>Use strong client authentication (e.g. client_assertion / client_token), so the attacker cannot obtain the client secret required to exchange the tokens - <a href="#strong_client_authn">Section 5.2.3.7</a>
</li>
</ul>

<p> </p>
<p><strong>Attack: Obtain Refresh Token from Native clients.</strong> On native clients, leakage of a refresh token typically affects a single user, only.</p>
<p><em>Read from local filesystem:</em> The attacker could try get file system access on the device and read the refresh tokens. The attacker could utilize a malicious app for that purpose.</p>
<p><em>Countermeasures:</em> </p>
<p><em></em> </p>

<ul>
<li>Store secrets in a secure storage - <a href="#secure_storage">Section 5.3.3</a>
</li>
<li>Utilize device lock to prevent unauthorized device access - <a href="#device_lock">Section 5.3.4</a>
</li>
</ul>

<p> </p>
<p><em>Steal device</em>: The host device (e.g.  mobile phone) may be stolen. In that case, the attacker gets access to all apps under the identity of the legitimate user.</p>
<p><em>Countermeasures:</em> </p>
<p><em></em> </p>

<ul>
<li>Utilize device lock to prevent unauthorized device access - <a href="#device_lock">Section 5.3.4</a>
</li>
<li>Where a user knows the device has been cloned, they can use this countermeasure (Refresh Token Revocation) - <a href="#refresh_revocation">Section 5.2.2.4</a>
</li>
</ul>

<p> </p>
<p><em>Clone device: </em>All device data and applications are copied to another device. Applications are used as-is on the target device.</p>
<p><em>Countermeasures:</em> </p>
<p><em></em> </p>

<ul>
<li>Combine refresh token request with device identification - <a href="#device_id">Section 5.2.2.6</a>
</li>
<li>Combine refresh token requests with user-provided secret - <a href="#user_secret">Section 5.2.2.5</a>
</li>
<li>Refresh Token Replacement - <a href="#refresh_replace">Section 5.2.2.3</a>
</li>
<li>Where a user knows the device has been cloned, they can use this countermeasure - Refresh Token Revocation - <a href="#refresh_revocation">Section 5.2.2.4</a>
</li>
</ul>

<p> </p>
<p><em>Obtain refresh tokens from backup:</em> A refresh token could be obtained from the backup of a client application, or device.</p>
<p><em>Countermeasures:</em> </p>
<p></p>

<ul><li>tbd</li></ul>

<p> </p>
<h1 id="rfc.section.4.1.3">
<a href="#rfc.section.4.1.3">4.1.3.</a> Threat: Obtain Access Tokens</h1>
<p id="rfc.section.4.1.3.p.1">Depending on the client type, there are different ways access tokens may be revealed to an attacker. Access tokens could be stolen from the device if the app stores them in a storage, which is accessible to other applications.</p>
<p id="rfc.section.4.1.3.p.2">Impact: Where the token is a bearer token and no additional mechanism is used to identify the client, the attacker can access all resources associated with the token and its.</p>
<p id="rfc.section.4.1.3.p.3">Countermeasures:</p>
<p></p>

<ul>
<li>Keep access tokens in transient memory and limit grants: <a href="#access_tokens">Section 5.1.6</a>
</li>
<li>Limited scope tokens - <a href="#limit_scope">Section 5.1.5.1</a>
</li>
<li>Combine refresh token requests with user-provided secret - <a href="#user_secret">Section 5.2.2.5</a>
</li>
<li>Client secret revocation - <a href="#client_secret_revocation">Section 5.2.3.6</a>
</li>
<li>Keep access tokens in private memory or apply same protection means as for refresh tokens - <a href="#refresh_tokens">Section 5.2.2</a>
</li>
<li>Keep access token lifetime short - <a href="#short_exp_time">Section 5.1.5.3</a>
</li>
</ul>

<p> </p>
<h1 id="rfc.section.4.1.4">
<a href="#rfc.section.4.1.4">4.1.4.</a> Threat: End-user credentials phished using compromised or embedded browser</h1>
<p id="rfc.section.4.1.4.p.1">A malicious app could attempt to phish end-user passwords by misusing an embedded browser in the end-user authorization process, or by presenting its own user-interface instead of allowing trusted system browser to render the authorization UI. By doing so, the usual visual trust mechanisms may be bypassed (e.g. TLS confirmation, web site mechanisms). By using an embedded or internal client app UI, the client app has access to additional information it should not have access to (e.g. uid/password).</p>
<p id="rfc.section.4.1.4.p.2">Impact: If the client app or the communication is compromised, the user would not be aware and all information in the authorization exchange could be captured such as username and password.</p>
<p id="rfc.section.4.1.4.p.3">Countermeasures:</p>
<p></p>

<ul>
<li>Client developers and end-user can be educated to trust an external System-Browser only.</li>
<li>Client apps could be validated prior publication in a app market.</li>
<li>Client developers should not collect authentication information directly from users and should instead use redirects to and back from a trusted external system-browser.</li>
</ul>

<p> </p>
<h1 id="rfc.section.4.2">
<a href="#rfc.section.4.2">4.2.</a> Authorization Endpoint</h1>
<p></p>
<h1 id="rfc.section.4.2.1">
<a href="#rfc.section.4.2.1">4.2.1.</a> Threat: Password phishing by counterfeit authorization server</h1>
<p id="rfc.section.4.2.1.p.1">OAuth makes no attempt to verify the authenticity of the Authorization Server. A hostile party could take advantage of this by intercepting the Client's requests and returning misleading or otherwise incorrect responses. This could be achieved using DNS or ARP spoofing. Wide deployment of OAuth and similar protocols may cause Users to become inured to the practice of being redirected to websites where they are asked to enter their passwords. If Users are not careful to verify the authenticity of these websites before entering their credentials, it will be possible for attackers to exploit this practice to steal Users' passwords.</p>
<p id="rfc.section.4.2.1.p.2">Countermeasures:</p>
<p></p>

<ul>
<li>Service providers should consider such attacks when developing services based on OAuth, and should require transport-layer security for any requests where the authenticity of the Service Provider or of request responses is an issue (see <a href="#server_authn">Section 5.1.2</a>).</li>
<li>Service Providers should attempt to educate Users about the risks phishing attacks pose, and should provide mechanisms that make it easy for Users to confirm the authenticity of their sites.</li>
</ul>

<p> </p>
<h1 id="rfc.section.4.2.2">
<a href="#rfc.section.4.2.2">4.2.2.</a> Threat: User unintentionally grants too much access scope</h1>
<p id="rfc.section.4.2.2.p.1">When obtaining end user authenticaton, the end-user may not understand the scope of the access being granted and to whom or they may end up providing a client with access to resources which should not be permitted.</p>
<p id="rfc.section.4.2.2.p.2">Countermeasures:</p>
<p></p>

<ul>
<li>Explain the scope (resources and the permissions) the user is about to grant in a understandable way - <a href="#informed_decisions">Section 5.2.4.2</a>
</li>
<li>Narrow scope based on client-specific policy - When obtaining end user authorization and where the client requests scope, the service provider may want to consider whether to honour that scope based on who the client is. That decision is between the client and service provider and is outside the scope of this spec. The service provider may also want to consider what scope to grant based on the profile used, e.g. providing lower scope where no client secret is provided from a native application. - <a href="#limit_scope">Section 5.1.5.1</a>
</li>
</ul>

<p> </p>
<h1 id="rfc.section.4.2.3">
<a href="#rfc.section.4.2.3">4.2.3.</a> Threat: Malicious client obtains existing authorization by fraud</h1>
<p id="rfc.section.4.2.3.p.1">Authorization servers may wish to automatically process authorization requests from Clients which have been previously authorized by the user. When the User is redirected to the authorization server's end-user authorization endpoint to grant access, the authorization server detects that the User has already granted access to that particular Client. Instead of prompting the User for approval, the authorization server automatically redirects the User back to the Provider.</p>
<p id="rfc.section.4.2.3.p.2">A malicious client may exploit that feature and try to obtain such an authorization code instead of the legimate client.</p>
<p id="rfc.section.4.2.3.p.3">Countermeasures:</p>
<p></p>

<ul>
<li>Service providers should not automatically process repeat authorizations where the client is not authenticated through a client secret or some other authentication mechanism such as signing with security certs (see <a href="#strong_client_authn">Section 5.2.3.7</a>) or validation of a pre-registered redirect uri (<a href="#val_redirect">Section 5.2.3.5</a> )</li>
<li>Service Providers can mitigate the risks associated with automatic processing by limiting the scope of Access Tokens obtained through automated approvals - <a href="#limit_scope">Section 5.1.5.1</a>
</li>
</ul>

<p> </p>
<h1 id="rfc.section.4.2.4">
<a href="#rfc.section.4.2.4">4.2.4.</a> Threat: Open redirector</h1>
<p id="rfc.section.4.2.4.p.1">An attacker could use the end-user authorization endpoint and the redirect_uri parameter to abuse the authorization server as redirector.</p>
<p id="rfc.section.4.2.4.p.2">Impact?</p>
<p id="rfc.section.4.2.4.p.3">Countermeasure</p>
<p></p>

<ul><li>don't redirect to redirect_uri, if client identity or redirect_uri could not be verified</li></ul>

<p> </p>
<h1 id="rfc.section.4.3">
<a href="#rfc.section.4.3">4.3.</a> Token endpoint</h1>
<p></p>
<h1 id="rfc.section.4.3.1">
<a href="#rfc.section.4.3.1">4.3.1.</a> Threat: Eavesdropping access tokens</h1>
<p id="rfc.section.4.3.1.p.1">The OAuth specification does not describe any mechanism for protecting Tokens from eavesdroppers when they are transmitted from the Service Provider to the Client.</p>
<p id="rfc.section.4.3.1.p.2">Countermeasures:</p>
<p></p>

<ul>
<li>Service Providers MUST ensure that these transmissions are protected using transport-layer mechanisms such as TLS or SSL (see <a href="#conf_requests">Section 5.1.1</a>).</li>
<li>If end-to-end confidentiality cannot be guaranteed, reducing scope (see <a href="#limit_scope">Section 5.1.5.1</a>) and expiry time (<a href="#short_exp_time">Section 5.1.5.3</a>) for access tokens can be used to reduce the damage in case of leaks.</li>
</ul>

<p> </p>
<h1 id="rfc.section.4.3.2">
<a href="#rfc.section.4.3.2">4.3.2.</a> Threat: Obtain access tokens from authorization server database</h1>
<p id="rfc.section.4.3.2.p.1">This threat is applicable if the authorization server stores access tokens as handles in a database. An attacker may obtain access tokens from the authorization server's database by gaining access to the database or launching a SQL injection attack. Impact: disclosure of all access tokens</p>
<p id="rfc.section.4.3.2.p.2">Countermeasures:</p>
<p></p>

<ul>
<li>System security measures - <a href="#std_sys">Section 5.1.4.1.1</a>
</li>
<li>Store access token hashes only - <a href="#noclear">Section 5.1.4.1.3</a>
</li>
<li>Standard SQL inj. Countermeasures - <a href="#std_sql">Section 5.1.4.1.2</a>
</li>
</ul>

<p> </p>
<h1 id="rfc.section.4.3.3">
<a href="#rfc.section.4.3.3">4.3.3.</a> Threat: Obtain client credentials over non secure transport</h1>
<p id="rfc.section.4.3.3.p.1">An attacker could attempt to eavesdrop the transmission of client credentials between client and server during the client authentication process or during Oauth token requests. Impact: Revelation of a client credential enabling the possibility for phishing or immitation of a client service.</p>
<p id="rfc.section.4.3.3.p.2">Countermeasures:</p>
<p></p>

<ul>
<li>Implement transport security through <a href="#conf_requests">Confidentiality of Requests</a>
</li>
<li>Alternative authentication means, which do not require to send plaintext credentials over the wire (Examples: Digest authentication)</li>
</ul>

<p> </p>
<h1 id="rfc.section.4.3.4">
<a href="#rfc.section.4.3.4">4.3.4.</a> Threat: Obtain client secret from authorization server database</h1>
<p id="rfc.section.4.3.4.p.1">An attacker may obtain valid client_id/secret combinations from the authorization server's database by gaining access to the database or launching a SQL injection attack. Impact: disclosure of all client_id/secret combinations. This allows the attacker to act on behalf of legitimate clients.</p>
<p id="rfc.section.4.3.4.p.2">Countermeasures:</p>
<p></p>

<ul><li>Ensure proper handling of credentials as per <a href="#cred_storage_prot">Credential storage protection</a>.</li></ul>

<p> </p>
<h1 id="rfc.section.4.3.5">
<a href="#rfc.section.4.3.5">4.3.5.</a> Threat: Obtain client secret by online guessing</h1>
<p id="rfc.section.4.3.5.p.1">An attacker may try to guess valid client_id/secret pairs.  Impact: disclosure of single client_id/secret pair.</p>
<p id="rfc.section.4.3.5.p.2">Countermeasures:</p>
<p></p>

<ul>
<li>High entropy of secrets - <a href="#high_entropy">Section 5.1.4.2.2</a>
</li>
<li>Lock accounts - <a href="#lock_accounts">Section 5.1.4.2.3</a>
</li>
</ul>

<p> </p>
<h1 id="rfc.section.4.3.6">
<a href="#rfc.section.4.3.6">4.3.6.</a> DoS on dynamic client secret creation</h1>
<p id="rfc.section.4.3.6.p.1">If a Service Provider includes a nontrivial amount of entropy in client secrets and if the service provider automatically grants them, an attacker could exhaust the pool by repeatedly applying for them.</p>
<p id="rfc.section.4.3.6.p.2">Countermeasures:</p>
<p></p>

<ul><li>The service provider should consider some verification step for new clients. The service provider should include a nontrivial amount of entropy in client secrets.</li></ul>

<p> </p>
<h1 id="rfc.section.4.4">
<a href="#rfc.section.4.4">4.4.</a> Obtaining Authorization</h1>
<p id="rfc.section.4.4.p.1">This section covers threats which are specific to certain flows utilized to obtain access tokens. Each flow is characterized by response types and/or grant types on the end-user authorization and tokens endpoint, respectively.</p>
<p></p>
<h1 id="rfc.section.4.4.1">
<a href="#rfc.section.4.4.1">4.4.1.</a> <a href="#code_flow" id="code_flow">Authorization Code</a>
</h1>
<p></p>
<h1 id="rfc.section.4.4.1.1">
<a href="#rfc.section.4.4.1.1">4.4.1.1.</a> Threat: Malicious client obtains authorization</h1>
<p id="rfc.section.4.4.1.1.p.1">Attacker abuses valid client id</p>
<p id="rfc.section.4.4.1.1.p.2">countermeasures</p>
<p></p>

<ul>
<li>client validation</li>
<li>client authentication</li>
<li>user consent</li>
</ul>

<p> </p>
<h1 id="rfc.section.4.4.1.2">
<a href="#rfc.section.4.4.1.2">4.4.1.2.</a> Threat: Eavesdropping authorization codes</h1>
<p id="rfc.section.4.4.1.2.p.1">The OAuth specification does not describe any mechanism for protecting authorization codes from eavesdroppers when they are transmitted from the Service Provider to the Client and where the Service Provider Grants an Access Token.</p>
<p id="rfc.section.4.4.1.2.p.2">Note: A description of a similar attack on the SAML protocol can be found at http://www.oasis-open.org/committees/download.php/3405/oasis-sstc-saml-bindings-1.1.pdf (&#167;4.1.1.9.1).</p>
<p id="rfc.section.4.4.1.2.p.3">Countermeasures:</p>
<p></p>

<ul>
<li>The authorization server SHOULD enforce a one time usage restriction (see <a href="#one_time_usage">Section 5.1.5.4</a>).</li>
<li>Authorization server as well as the client MUST ensure that these transmissions are protected using transport-layer mechanisms such as TLS or SSL (see <a href="#conf_requests">Section 5.1.1</a>).</li>
<li>The authorization server shall require the client to authenticate wherever possible, so the binding of the authorization code to a certain client can be validated in a reliable way (see <a href="#bind_code_client_id">Section 5.2.4.4</a>).</li>
<li>Limited duration of authorization codes - <a href="#short_exp_time">Section 5.1.5.3</a>
</li>
<li>If an Authorization Server observes multiple attempts to redeem a authorization code, the Authorization Server may want to revoke all tokens granted based on the authorization code (see <a href="#automatic_code_revocation">Section 5.2.1.1</a>).</li>
<li>In the absence of these countermeasures, reducing scope (<a href="#limit_scope">Section 5.1.5.1</a>) and expiry time (<a href="#short_exp_time">Section 5.1.5.3</a>) for access tokens can be used to reduce the damage in case of leaks.</li>
</ul>

<p> </p>
<h1 id="rfc.section.4.4.1.3">
<a href="#rfc.section.4.4.1.3">4.4.1.3.</a> Threat: Obtain authorization codes from authorization server database</h1>
<p id="rfc.section.4.4.1.3.p.1">This threat is applicable if the authorization server stores authorization codes as handles in a database. An attacker may obtain authorization codes from the authorization server's database by gaining access to the database or launching a SQL injection attack. Impact: disclosure of all authorization codes, most likely along with the respective redirect_uri and client_id values.</p>
<p id="rfc.section.4.4.1.3.p.2">Countermeasures:</p>
<p></p>

<ul>
<li>Credential storage protection can be employed - <a href="#cred_storage_prot">Section 5.1.4.1</a>
</li>
<li>System security measures - <a href="#std_sys">Section 5.1.4.1.1</a>
</li>
<li>Store access token hashes only - <a href="#noclear">Section 5.1.4.1.3</a>
</li>
<li>Standard SQL inj. Countermeasures - <a href="#std_sql">Section 5.1.4.1.2</a>
</li>
</ul>

<p> </p>
<h1 id="rfc.section.4.4.1.4">
<a href="#rfc.section.4.4.1.4">4.4.1.4.</a> Threat: Online guessing of authorization codes</h1>
<p id="rfc.section.4.4.1.4.p.1">An attacker may try to guess valid authorization code values and send it using the grant type &#8222;code&#8220; in order to obtain a valid access token. Impact: disclosure of single access token (+probably refresh token)</p>
<p id="rfc.section.4.4.1.4.p.2">Countermeasures:</p>
<p></p>

<ul>
<li>For handle-based designs: <a href="#random_entropy">Section 5.1.5.11</a>
</li>
<li>For assertion-based designs: <a href="#signed_tokens">Section 5.1.5.9</a>
</li>
<li>Binding of authorization code to client_id, adds another value the attacker has to guess - <a href="#bind_code_client_id">Section 5.2.4.4</a>
</li>
<li>Binding of authorization code to redirect_uri, adds another value the attacker has to guess - <a href="#bind_code_redirect">Section 5.2.4.5</a>
</li>
<li>Short expiration time - <a href="#short_exp_time">Section 5.1.5.3</a>
</li>
</ul>

<p> </p>
<h1 id="rfc.section.4.4.1.5">
<a href="#rfc.section.4.4.1.5">4.4.1.5.</a> Threat: Authorization code leaks when requesting access token</h1>
<p id="rfc.section.4.4.1.5.p.1">Authorization codes are passed via the browser which may unintentionally leak those codes to untrusted web sites and attackers by different ways:</p>
<p></p>

<ul>
<li>Referer headers: browsers frequently pass a &#8220;referer&#8221; header when a web page embeds content, or when a user travels from one web page to another web page.  These referer headers may be sent even when the origin site does not trust the destination site. The referer header is commonly logged for traffic analysis purposes.</li>
<li>Request logs: web server request logs commonly include query parameters on requests.</li>
<li>Open redirectors: web sites sometimes need to send users to another destination via a redirector. Open redirectors pose a particular risk to web-based delegation protocols because the redirector can leak verification codes to untrusted destination sites.</li>
<li>Browser history: web browsers commonly record visited URLs in the browser history. Another user of the same web browser may be able to view URLs that were visited by previous users.</li>
</ul>

<p>Similar attacks on the SAML protocol are discussed in: http://www.thomasgross.net/publications/papers/GroPfi2006-SAML2_Analysis_Janus.WSSS_06.pdf and http://www.oasis-open.org/committees/download.php/11191/sstc-gross-sec-analysis-response-01.pdf.</p>
<p id="rfc.section.4.4.1.5.p.3">Countermeasures:</p>
<p></p>

<ul>
<li>The authorization server shall require the client to authenticate wherever possible, so the binding of the authorization code to a certain client can be validated in a reliable way (see <a href="#bind_code_client_id">Section 5.2.4.4</a>).</li>
<li>Authorization codes must be time-limited (see <a href="#short_exp_time">Section 5.1.5.3</a>)</li>
<li>Authorization codes should be single-use tokens (<a href="#one_time_usage">Section 5.1.5.4</a>)</li>
<li>If an Authorization Server observes multiple attempts to redeem a authorization code, the Authorization Server may want to revoke all tokens granted based on the authorization code (see <a href="#automatic_code_revocation">Section 5.2.1.1</a>)</li>
<li>The resource server may reload the target page of the redirect_uri in order to automatically cleanup the browser cache.</li>
</ul>

<p> </p>
<h1 id="rfc.section.4.4.1.6">
<a href="#rfc.section.4.4.1.6">4.4.1.6.</a> Threat: Authorization code phishing</h1>
<p id="rfc.section.4.4.1.6.p.1">A hostile party could act as the client web server and get access to the authorization code. This could be achieved using DNS or ARP spoofing. </p>
<p id="rfc.section.4.4.1.6.p.2">Impact: This affects web applications and may lead to a disclosure of authorization codes and, potentially, the corresponding access and refresh tokens.</p>
<p id="rfc.section.4.4.1.6.p.3">Countermeasures:</p>
<p></p>

<ul>
<li>The browser shall be utilized to authenticate the redirect_uri of the client using server authentication - <a href="#server_authn">Section 5.1.2</a>
</li>
<li>The authorization server shall require the client to authenticate with a secret, so the binding of the authorization code to a certain client can be validated in a reliable way (see <a href="#bind_code_client_id">Section 5.2.4.4</a>).</li>
</ul>

<p> </p>
<h1 id="rfc.section.4.4.1.7">
<a href="#rfc.section.4.4.1.7">4.4.1.7.</a> Threat: Session fixation</h1>
<p id="rfc.section.4.4.1.7.p.1">The session fixation attack leverages the 3-legged OAuth flow in an attempt to get another user to log-in and authorize access on behalf of the attacker. The victim, seeing only a normal request from an expected application, approves the request. The attacker then uses the victim's authorization to gain access to the information unknowingly authorized by the victim.</p>
<p id="rfc.section.4.4.1.7.p.2">In this attack, the attacker is using a known client application (consumer site), and a target OAuth resource provider.  The attack depends on the victim expecting the consumer site to request access to the resource provider.</p>
<p id="rfc.section.4.4.1.7.p.3">The attacker utilizes the following flow:</p>
<p id="rfc.section.4.4.1.7.p.4">The attacker initiates browser access to the consumer site, and initates access to data from the resource provider. The consumer site, initiates an authorization request and receives a redirect_uri back from the resource provider's authorization server. Instead of following the link, the attacker stops the process and saves the redirect_uri. The attacker modifies the redirect_uri to allow control to be returned to the attacker site.</p>
<p id="rfc.section.4.4.1.7.p.5">The attacker tricks another user (the victim) to open that redirect_uri and to authorize access (e.g. an email link, or blog link). The way the attacker achieve that goal is out of scope.</p>
<p id="rfc.section.4.4.1.7.p.6">Having clicked, the link, the victim is requested to authenticate and authorize the consumer site to have access.</p>
<p id="rfc.section.4.4.1.7.p.7">The authorization server redirects the user agent to the attackers web site instead of the original target web site.</p>
<p id="rfc.section.4.4.1.7.p.8">The attacker obtains the authorization code from its web site, constructs a redirect_uri to the target web site (or app) based on the original authorization request's redirect_uri and the newly obtained authorization code and directs its user agent to this URL.</p>
<p id="rfc.section.4.4.1.7.p.9">The web uses the authorization code to fetch a token from the authorization server and associates this token with the attacker's user account on this site.</p>
<p id="rfc.section.4.4.1.7.p.10">Countermeasures:</p>
<p></p>

<ul>
<li>The attacker must use another redirect_uri for its authorization process than the target web site because it needs to intercept the flow. So if the authorization server associates the authorization code with the redirect_uri of a particular end-user authorization, such a change (and with that such an attack) can be detected - see <a href="#bind_code_client_id">Section 5.2.4.4</a>
</li>
<li>The authorization server may also enforce the usage and validation of pre-registered redirect Uris (see <a href="#val_redirect">Section 5.2.3.5</a>).</li>
<li>For native apps, one could also consider to use deployment-specific client ids and secrets (see <a href="#depl_specific_secretes">Section 5.2.3.4</a>, along with the binding of authorization code to client_id (see <a href="#bind_code_client_id">Section 5.2.4.4</a>), to detect a session fixation because the attacker does not have access the deployment-specific secret. Thus he will not be able to exchange the authorization code.</li>
<li>The client may consider to use other flows, which are not vulnerable to session fixation attacks (see <a href="#implicite_flow">Section 4.4.2</a> or <a href="#pwd_flow">Section 4.4.3</a>).</li>
</ul>

<p> </p>
<h1 id="rfc.section.4.4.1.8">
<a href="#rfc.section.4.4.1.8">4.4.1.8.</a> Threat: DoS, Exhaustion of resources attacks</h1>
<p id="rfc.section.4.4.1.8.p.1">If a Service Provider includes a nontrivial amount of entropy in authorization codes or access tokens (limiting the number of possible codes/tokens) and automatically grants either without user intervention and has no limit on code or access tokens per user, an attacker could exhaust the pool by repeatedly directing user(s) browser to request code or access tokens. This is because more entropy means a larger number of tokens can be issued.</p>
<p id="rfc.section.4.4.1.8.p.2">Countermeasures:</p>
<p></p>

<ul><li>The service provider should consider limiting the number of access tokens granted per user. The service provider should include a nontrivial amount of entropy in authorization codes.</li></ul>

<p> </p>
<h1 id="rfc.section.4.4.2">
<a href="#rfc.section.4.4.2">4.4.2.</a> <a href="#implicite_flow" id="implicite_flow">Implicit Grant</a>
</h1>
<p></p>
<h1 id="rfc.section.4.4.2.1">
<a href="#rfc.section.4.4.2.1">4.4.2.1.</a> Threat: Access token leak in transport/end-points</h1>
<p id="rfc.section.4.4.2.1.p.1">Description: the access token is directly returned to the client as part of the redirect URL. This token might be eavesdropped by an attacker. The token is sent from server to client via a URI fragment of the redirect_uri. If the communication is not secured or the end-point is not secured, the token could be leaked by parsing the returned URI. Impact: the attacker would be able to assume the same rights granted by the token.</p>
<p id="rfc.section.4.4.2.1.p.2">Countermeasures:</p>
<p></p>

<ul>
<li>Confidentiality of Requests - <a href="#conf_requests">Section 5.1.1</a>
</li>
<li>Bind token to client id - <a href="#bind_token_client_id">Section 5.1.5.8</a>
</li>
</ul>

<p> </p>
<h1 id="rfc.section.4.4.2.2">
<a href="#rfc.section.4.4.2.2">4.4.2.2.</a> Threat: Access token leak in browser history</h1>
<p id="rfc.section.4.4.2.2.p.1">An attacker could obtain the token from the browsers history.</p>
<p id="rfc.section.4.4.2.2.p.2">Countermeasures:</p>
<p></p>

<ul>
<li>Shorten token duration (see <a href="#short_exp_time">Section 5.1.5.3</a>) and reduced scope of the token may reduce the impact of that attack (see <a href="#limit_scope">Section 5.1.5.1</a>).</li>
<li>Make these requests non-cachable</li>
<li>Native apps can directly embedd a browser widget and therewith gain full control of the cache. So the app can cleanup browser history after authorization process.</li>
</ul>

<p> </p>
<h1 id="rfc.section.4.4.2.3">
<a href="#rfc.section.4.4.2.3">4.4.2.3.</a> Threat: Malicious client obtains authorization</h1>
<p id="rfc.section.4.4.2.3.p.1">An malicious client could attempt to obtain a token by fraud.  Client secrets are not an effective countermeasure in this case.</p>
<p id="rfc.section.4.4.2.3.p.2">The following countermeasures are advisable:</p>
<p></p>

<ul>
<li>Always require user consent and let end-user validate client identity - <a href="#validation_end_user">Section 5.2.4.3</a>
</li>
<li>No automatic processing of repeated authorizations - <a href="#automatic_processing">Section 5.2.4.1</a>
</li>
</ul>

<p> </p>
<h1 id="rfc.section.4.4.3">
<a href="#rfc.section.4.4.3">4.4.3.</a> <a href="#pwd_flow" id="pwd_flow">Resource Owner Password Credentials</a>
</h1>
<p id="rfc.section.4.4.3.p.1">The &#8220;password&#8221; grant type (see OAuth Core Section 4.3), often used for legacy/migration reasons, allows a client to request an access token using an end-users user-id and password along with its own credential. The &#8220;password&#8221; grant-type has higher risk because it maintains the uid/password anti-pattern.  Additionally, because the user does not have control over the authorization process, clients using this grant-type are not limited by scope, but instead have potentially the same capabilities as the user themselves. As there is no authorization step, the ability to offer token revocation is bypassed.</p>
<p id="rfc.section.4.4.3.p.2">Impact: The resource server can only differentiate scope based on the access token being associated with a particular client. The client could also acquire long-living tokens and pass them up to a attacker web service for further abuse. The client, eavesdroppers, or end-points could eavesdrop user id and password.</p>
<p id="rfc.section.4.4.3.p.3">Countermeasures:</p>
<p></p>

<ul>
<li>Except for migration reasons, minimize use of this grant type</li>
<li>The authorization server must validate the client id associated with the particular refresh token with every refresh request - <a href="#binding_refresh_client_id">Section 5.2.2.2</a>
</li>
<li>Service Providers MUST ensure that these transmissions are protected using transport-layer mechanisms such as TLS or SSL (see <a href="#conf_requests">Section 5.1.1</a>).</li>
</ul>

<p> </p>
<h1 id="rfc.section.4.4.3.1">
<a href="#rfc.section.4.4.3.1">4.4.3.1.</a> Threat: Accidental exposure of passwords at client site</h1>
<p id="rfc.section.4.4.3.1.p.1">If an authorization server does not provide enough protection, an attacker or disgruntled employee could retrieve the passwords for a client</p>
<p id="rfc.section.4.4.3.1.p.2">Countermeasures:</p>
<p></p>

<ul>
<li>Use other flows, which do not rely on the client's cooperation for secure resource owner credential handling</li>
<li>Use digest authentication instead of plaintext credential processing</li>
<li>Obfuscation of passwords in logs</li>
</ul>

<p> </p>
<h1 id="rfc.section.4.4.3.2">
<a href="#rfc.section.4.4.3.2">4.4.3.2.</a> Threat: Client obtains scopes without end-user authorization</h1>
<p id="rfc.section.4.4.3.2.p.1">All interaction with the resource owner is performed by the client. Thus it might, intentionally or unintentionally, happen that the client obtains a token with scope unknown for or unintended by the resource owner. For example, the resource owner might think the client needs and acquires read-only access to its media storage only but the client tries to acquire an access token with full access permissions.</p>
<p id="rfc.section.4.4.3.2.p.2">Countermeasures:</p>
<p></p>

<ul>
<li>Use other flows, which do not rely on the client's cooperation for resource owner interaction</li>
<li>The authorization server may generally restrict the scope of access tokens (<a href="#limit_scope">Section 5.1.5.1</a>) issued by this flow. If the particular client is trustworthy and can be authenticated in a reliable way, the authorization server could relax that restriction. Resource owners may prescribe (e.g. in their preferences) what the maximum permission for client using this flow shall be.</li>
<li>The authorization server could notify the resource owner by an appropriate media, e.g. e-Mail, of the grant issued (see <a href="#informed">Section 5.1.3</a>).</li>
</ul>

<p> </p>
<h1 id="rfc.section.4.4.3.3">
<a href="#rfc.section.4.4.3.3">4.4.3.3.</a> Threat: Client obtains refresh token through automatic authorization</h1>
<p id="rfc.section.4.4.3.3.p.1">All interaction with the resource owner is performed by the client. Thus it might, intentionally or unintentionally, happen that the client obtains a long-term authorization represented by a refresh token even if the resource owner did not intend so.</p>
<p id="rfc.section.4.4.3.3.p.2">Countermeasures:</p>
<p></p>

<ul>
<li>Use other flows, which do not rely on the client's cooperation for resource owner interaction</li>
<li>The authorization server may generally refuse to issue refresh tokens in this flow (see <a href="#restricted_refresh">Section 5.2.2.1</a>). If the particular client is trustworthy and can be authenticated in a reliable way (cf.  client authentication), the authorization server could relax that restriction. Resource owners may allow or deny (e.g. in their preferences) to issue refresh tokens using this flow as well.</li>
<li>The authorization server could notify the resource owner by an appropriate media, e.g. e-Mail, of the refresh token issued (see <a href="#informed">Section 5.1.3</a>).</li>
</ul>

<p> </p>
<h1 id="rfc.section.4.4.3.4">
<a href="#rfc.section.4.4.3.4">4.4.3.4.</a> Threat: Obtain user passwords on transport</h1>
<p id="rfc.section.4.4.3.4.p.1">An attacker could attempt to eavesdrop the transmission of end-user credentials with the grant type &#8222;password&#8220; between client and server.</p>
<p id="rfc.section.4.4.3.4.p.2">Impact: disclosure of a single end-users password.</p>
<p id="rfc.section.4.4.3.4.p.3">Countermeasures:</p>
<p></p>

<ul>
<li>Confidentiality of Requests - <a href="#conf_requests">Section 5.1.1</a>
</li>
<li>alternative authentication means, which do not require to send plaintext credentials over the wire (Examples: Digest authentication)</li>
</ul>

<p> </p>
<h1 id="rfc.section.4.4.3.5">
<a href="#rfc.section.4.4.3.5">4.4.3.5.</a> Threat: Obtain user passwords from authorization server database</h1>
<p id="rfc.section.4.4.3.5.p.1">An attacker may obtain valid username/password combinations from the authorization server's database by gaining access to the database or launching a SQL injection attack.</p>
<p id="rfc.section.4.4.3.5.p.2">Impact: disclosure of all username/password combinations. The impact may exceed the service providers domain since many users tend to use the same credentials on different services.</p>
<p id="rfc.section.4.4.3.5.p.3">Countermeasures:</p>
<p></p>

<ul><li>Credential storage protection can be employed - <a href="#cred_storage_prot">Section 5.1.4.1</a>
</li></ul>

<p> </p>
<h1 id="rfc.section.4.4.3.6">
<a href="#rfc.section.4.4.3.6">4.4.3.6.</a> Threat: Online guessing</h1>
<p id="rfc.section.4.4.3.6.p.1">An attacker may try to guess valid username/password combinations using the grant type &#8222;password&#8220;.</p>
<p id="rfc.section.4.4.3.6.p.2">Impact: Revelation of a single username/password combination.</p>
<p id="rfc.section.4.4.3.6.p.3">Countermeasures:</p>
<p></p>

<ul>
<li>Password policy - <a href="#pwd_policy">Section 5.1.4.2.1</a>
</li>
<li>Lock accounts - <a href="#lock_accounts">Section 5.1.4.2.3</a>
</li>
<li>Tar pit - <a href="#tar_pit">Section 5.1.4.2.4</a>
</li>
<li>CAPTCHA - <a href="#captchas">Section 5.1.4.2.5</a>
</li>
<li>Abandon on grant type &#8222;password&#8220;</li>
<li>Client authentication (see <a href="#client_aa">Section 5.2.3</a>) will provide another authentication factor and thus hinder the attack.</li>
</ul>

<p> </p>
<h1 id="rfc.section.4.4.4">
<a href="#rfc.section.4.4.4">4.4.4.</a> Client Credentials</h1>
<p id="rfc.section.4.4.4.p.1">[TBD]</p>
<h1 id="rfc.section.4.5">
<a href="#rfc.section.4.5">4.5.</a> Refreshing an Access Token</h1>
<p></p>
<h1 id="rfc.section.4.5.1">
<a href="#rfc.section.4.5.1">4.5.1.</a> Threat: Eavesdropping refresh tokens from authorization server</h1>
<p id="rfc.section.4.5.1.p.1">The OAuth specification does not describe any mechanism for protecting Tokens from eavesdroppers when they are transmitted from the Service Provider to the Client.</p>
<p id="rfc.section.4.5.1.p.2">Countermeasures:</p>
<p></p>

<ul>
<li>Service Providers MUST ensure that these transmissions are protected using transport-layer mechanisms such as TLS or SSL (see <a href="#conf_requests">Section 5.1.1</a>).</li>
<li>If end-to-end confidentiality cannot be guaranteed, reducing scope (see <a href="#limit_scope">Section 5.1.5.1</a>) and expiry time (see <a href="#short_exp_time">Section 5.1.5.3</a>) for issued access tokens can be used to reduce the damage in case of leaks.</li>
</ul>

<p> </p>
<h1 id="rfc.section.4.5.2">
<a href="#rfc.section.4.5.2">4.5.2.</a> Threat: Obtaining refresh token from authorization server database</h1>
<p id="rfc.section.4.5.2.p.1">This threat is applicable if the authorization server stores refresh tokens as handles in a database. An attacker may obtain refresh tokens from the authorization server's database by gaining access to the database or launching a SQL injection attack.</p>
<p id="rfc.section.4.5.2.p.2">Impact: disclosure of all refresh tokens</p>
<p id="rfc.section.4.5.2.p.3">Countermeasures:</p>
<p></p>

<ul>
<li>Credential storage protection - <a href="#cred_storage_prot">Section 5.1.4.1</a>
</li>
<li>Bind token to client id, if the attacker cannot obtain the required id and secret - <a href="#bind_token_client_id">Section 5.1.5.8</a>
</li>
</ul>

<p> </p>
<h1 id="rfc.section.4.5.3">
<a href="#rfc.section.4.5.3">4.5.3.</a> Threat: Obtain refresh token by online guessing</h1>
<p id="rfc.section.4.5.3.p.1">An attacker may try to guess valid refresh token values and send it using the grant type &#8222;refresh_token&#8220; in order to obtain a valid access token.</p>
<p id="rfc.section.4.5.3.p.2">Impact: exposure of single refresh token and derivable access tokens.</p>
<p id="rfc.section.4.5.3.p.3">Countermeasures:</p>
<p></p>

<ul>
<li>For handle-based designs - <a href="#random_entropy">Section 5.1.5.11</a>
</li>
<li>For assertion-based designs - <a href="#signed_tokens">Section 5.1.5.9</a>
</li>
<li>Bind token to client id, because the attacker would guess the matching client id, too - <a href="#bind_token_client_id">Section 5.1.5.8</a>
</li>
</ul>

<p> </p>
<h1 id="rfc.section.4.5.4">
<a href="#rfc.section.4.5.4">4.5.4.</a> Threat: Obtain refresh token phishing by counterfeit authorization server</h1>
<p id="rfc.section.4.5.4.p.1">An attacker could try to obtain valid refresh tokens by proxying requests to the authorization server. Given the assumption that the authorization server URL is well-known at development time or can at least be obtained from a well-known resource server, the attacker must utilize some kind of spoofing in order to suceed.</p>
<p id="rfc.section.4.5.4.p.2">Countermeasures:</p>
<p></p>

<ul><li>Server authentication (as described in <a href="#server_authn">Section 5.1.2</a>)</li></ul>

<p> </p>
<h1 id="rfc.section.4.6">
<a href="#rfc.section.4.6">4.6.</a> Accessing Protected Resources</h1>
<p></p>
<h1 id="rfc.section.4.6.1">
<a href="#rfc.section.4.6.1">4.6.1.</a> Threat: Eavesdropping access tokens on transport</h1>
<p id="rfc.section.4.6.1.p.1">An attacker could try to obtain a valid access token on transport between client and resource server. As access tokens are shared secrets between authorization and resource server, they MUST by treated with the same care as other credentials (e.g. end-user passwords).</p>
<p id="rfc.section.4.6.1.p.2">Countermeasures:</p>
<p></p>

<ul>
<li>Access tokens sent as bearer tokens, SHOULD NOT be sent in the clear over an insecure channel. Instead transport protection means shall be utilized to prevent eavesdropping by an attacker (see <a href="#conf_requests">Section 5.1.1</a>).</li>
<li>A short lifetime reduces impact in case tokens are compromised (see <a href="#short_exp_time">Section 5.1.5.3</a>).</li>
<li>The access token can be bound to a client's identity and require the client to authenticate with the resource server (see <a href="#authn_requests">Section 5.4.2</a>). Client authentication MUST be performed without exposing the required secret to the transport channel.</li>
</ul>

<p> </p>
<h1 id="rfc.section.4.6.2">
<a href="#rfc.section.4.6.2">4.6.2.</a> Threat: Replay authorized resource server requests</h1>
<p id="rfc.section.4.6.2.p.1">An attacker could attempt to replay valid requests in order to obtain or to modify/destroy user data.</p>
<p id="rfc.section.4.6.2.p.2">Countermeasures:</p>
<p></p>

<ul>
<li>The resource server should utilize transport security measure in order to prevent such attacks (see <a href="#conf_requests">Section 5.1.1</a>). This would prevent the attacker from capturing valid requests.</li>
<li>Alternatively, the resource server could employ signed requests (see <a href="#signed_requests">Section 5.4.3</a>) along with nounces and timestamps in order to uniquely identify requests.  The resource server MUST detect and refuse every replayed request.</li>
</ul>

<p> </p>
<h1 id="rfc.section.4.6.3">
<a href="#rfc.section.4.6.3">4.6.3.</a> Threat: Guessing access tokens</h1>
<p id="rfc.section.4.6.3.p.1">Where the token is a handle, the attacker may use attempt to guess the access token values based on knowledge they have from other access tokens.</p>
<p id="rfc.section.4.6.3.p.2">Impact: Access to a single user's data.</p>
<p id="rfc.section.4.6.3.p.3">Countermeasures:</p>
<p></p>

<ul>
<li>Handle Tokens should have a reasonable entropy (see <a href="#random_entropy">Section 5.1.5.11</a>) in order to make guessing a valid token value difficult.</li>
<li>Assertion (or self-contained token ) tokens contents SHALL be protected by a digital signature (see <a href="#signed_tokens">Section 5.1.5.9</a>).</li>
<li>Security can be further strengthened by using a short access token duration (see <a href="#exp_time">Section 5.1.5.2</a> and <a href="#short_exp_time">Section 5.1.5.3</a>).</li>
</ul>

<p> </p>
<h1 id="rfc.section.4.6.4">
<a href="#rfc.section.4.6.4">4.6.4.</a> Threat: Access token phishing by counterfeit resource server</h1>
<p id="rfc.section.4.6.4.p.1">An attacker may pretend to be a particular resource server and to accept tokens from a particular authorization server. If the client sends a valid access tokens to this counterfeit resource server, the server in turn may use that token to access other services on behalf of the resource owner.</p>
<p id="rfc.section.4.6.4.p.2">Countermeasures:</p>
<p></p>

<ul>
<li>Clients SHOULD not make authenticated requests with an access token to unfamiliar resource servers, regardless of the presence of a secure channel. If the resource server address is well-known to the client, it may authenticate the resource servers (see <a href="#server_authn">Section 5.1.2</a>).</li>
<li>Associate the endpoint address of the resource server the client talked to with the access token (e.g. in an audience field) and validate association at legitimate resource server.  The endpoint address validation policy may be strict (exact match) or more relaxed (e.g. same host). This would require to tell the authorization server the resource server endpoint address in the authorization process.</li>
<li>Associate an access token with a client and authenticate the client with resource server requests (typically via signature in order to not disclose secret to a potential attacker). This prevents the attack because the counterfeit server is assumed to miss the capabilities to correctly authenticate on behalf of the legitimate client to the resource server (<a href="#authn_requests">Section 5.4.2</a>).</li>
<li>Restrict the token scope (see <a href="#limit_scope">Section 5.1.5.1</a>) and or limit the token to a certain resource server (<a href="#bind_token_rs">Section 5.1.5.5</a>).</li>
</ul>

<p> </p>
<h1 id="rfc.section.4.6.5">
<a href="#rfc.section.4.6.5">4.6.5.</a> Threat: Abuse of token by legitimate resource server or client</h1>
<p id="rfc.section.4.6.5.p.1">A legitimate resource server could attempt to use an access token to access another resource servers. Similarily, a client could try to use a token obtained for one server on another resource server.</p>
<p id="rfc.section.4.6.5.p.2">Countermeasures:</p>
<p></p>

<ul><li>Tokens should be restricted to particular resource servers (see <a href="#bind_token_rs">Section 5.1.5.5</a>).</li></ul>

<p> </p>
<h1 id="rfc.section.4.6.6">
<a href="#rfc.section.4.6.6">4.6.6.</a> Threat: Leak of confidential data in HTTP-Proxies</h1>
<p id="rfc.section.4.6.6.p.1">The HTTP Authorization scheme (OAuth HTTP Authorization Scheme) is optional. However, [RFC2616](Fielding, R., Gettys, J., Mogul, J., Frystyk, H., Masinter, L., Leach, P., and T. Berners-Lee, &#8220;Hypertext Transfer Protocol -- HTTP/1.1,&#8221; .) relies on the Authorization and WWW-Authenticate headers to distinguish authenticated content so that it can be protected. Proxies and caches, in particular, may fail to adequately protect requests not using these headers. For example, private authenticated content may be stored in (and thus retrievable from) publicly-accessible caches.</p>
<p id="rfc.section.4.6.6.p.2">CounterMeasures:</p>
<p></p>

<ul>
<li>Service Providers not using the HTTP Authorization scheme (OAuth HTTP Authorization Scheme - see <a href="#authz_header">Section 5.4.1</a>) should take care to use other mechanisms, such as the Cache-Control header, to ensure that authenticated content is protected.</li>
<li>Reducing scope (see <a href="#limit_scope">Section 5.1.5.1</a>) and expiry time (<a href="#short_exp_time">Section 5.1.5.3</a>) for access tokens can be used to reduce the damage in case of leaks.</li>
</ul>

<p> </p>
<h1 id="rfc.section.4.6.7">
<a href="#rfc.section.4.6.7">4.6.7.</a> Threat: Token leakage via logfiles and HTTP referrers</h1>
<p id="rfc.section.4.6.7.p.1">If access tokens are sent via URI query parameters, such tokens may leak to log files and HTTP referrers.</p>
<p id="rfc.section.4.6.7.p.2">Countermeasures:</p>
<p></p>

<ul>
<li>Use authorization headers or POST parameters instead of URI request parameters (see <a href="#authz_header">Section 5.4.1</a>).</li>
<li>Set logging configuration appropriately</li>
<li>Prevent unauthorized persons from access to system log files (see <a href="#std_sys">Section 5.1.4.1.1</a>)</li>
<li>HTTP referrers can be prevented by reloading the target page again without URI parameters</li>
<li>Abuse of leaked access tokens can be prevented by enforcing authenticated requests (see <a href="#authn_requests">Section 5.4.2</a>).</li>
<li>The impact of token leakage may be reduced by limiting scope (see <a href="#limit_scope">Section 5.1.5.1</a>) and duration (see <a href="#short_exp_time">Section 5.1.5.3</a>) and enforcing one time token usage (see <a href="#one_time_usage">Section 5.1.5.4</a>).</li>
</ul>

<p> </p>
<h1 id="rfc.section.5">
<a href="#rfc.section.5">5.</a> <a href="#security_considerations" id="security_considerations">Security Considerations</a>
</h1>
<p id="rfc.section.5.p.1">This section describes the countermeasures as recommended to mitigate the threats as described in Section 4.</p>
<p></p>
<h1 id="rfc.section.5.1">
<a href="#rfc.section.5.1">5.1.</a> General</h1>
<p></p>
<h1 id="rfc.section.5.1.1">
<a href="#rfc.section.5.1.1">5.1.1.</a> <a href="#conf_requests" id="conf_requests">Confidentiality of Requests</a>
</h1>
<p id="rfc.section.5.1.1.p.1">This is applicable to all requests sent from client to authorization server or resource server. While OAuth provides a mechanism for verifying the integrity of requests, it provides no guarantee of request confidentiality. Unless further precautions are taken, eavesdroppers will have full access to request content and may be able to mount attacks through using content of request, e.g.  secrets or tokens, or mount replay attacks.</p>
<p id="rfc.section.5.1.1.p.2">Attacks can be mitigated by using transport-layer mechanisms such as TLS or SSL. VPN may considered as well.</p>
<p id="rfc.section.5.1.1.p.3">This is a countermeasure against the following threats:</p>
<p></p>

<ul>
<li>Replay of access tokens obtained on tokens endpoint or resource server's endpoint</li>
<li>Replay of refresh tokens obtained on tokens endpoint</li>
<li>Replay of authorization codes obtained on tokens endpoint (redirect?)</li>
<li>Replay of user passwords and client secrets</li>
</ul>

<p> </p>
<h1 id="rfc.section.5.1.2">
<a href="#rfc.section.5.1.2">5.1.2.</a> <a href="#server_authn" id="server_authn">Server authentication</a>
</h1>
<p id="rfc.section.5.1.2.p.1">HTTPS server authentication or similar means can be used to authenticate the identity of a server. The goal is to reliably bind the DNS name of the server to the public key presented by the server during connection establishment.</p>
<p id="rfc.section.5.1.2.p.2">The client MUST validate the binding of the server to its domain name. If the server fails to prove that binding, it is condered a men-in-the-middle. The security measure depends on the certification authorities the client trusts for that purpose. Clients should carefully select those trusted CAs and protect the storage for trusted CA certificates from modifications.</p>
<p id="rfc.section.5.1.2.p.3">This is a countermeasure against the following threats:</p>
<p></p>

<ul>
<li>Spoofing</li>
<li>Proxying</li>
<li>Phishing by conterfeit servers</li>
</ul>

<p> </p>
<h1 id="rfc.section.5.1.3">
<a href="#rfc.section.5.1.3">5.1.3.</a> <a href="#informed" id="informed">Always keep the resource owner informed</a>
</h1>
<p id="rfc.section.5.1.3.p.1">Transparency to the resource owner is a key element of the OAuth protocol. The user shall always be in control of the authorization processes and get the necessary information to meet informed decisions. Moreover, user involvement is a further security countermeasure. The user can probably recognize certain kinds of attacks better than the authorization server. Information can be presented/exchanged during the authorization process, after the authorization process, and every time the user wishes to get informed by using techniques such as:</p>
<p></p>

<ul>
<li>User consent forms</li>
<li>Notification messages (e-Mail, SMS, &#8230;)</li>
<li>Activity/Event logs</li>
<li>User self-care apps or portals</li>
</ul>

<p> </p>
<h1 id="rfc.section.5.1.4">
<a href="#rfc.section.5.1.4">5.1.4.</a> Credentials</h1>
<p id="rfc.section.5.1.4.p.1">This sections describes countermeasures used to protect all kind of credentials from unauthorized access and abuse. Credentials are long term secrets, such as client secrets and user passwords as well as all kinds of tokens (refresh and access token) or authorization codes.</p>
<h1 id="rfc.section.5.1.4.1">
<a href="#rfc.section.5.1.4.1">5.1.4.1.</a> <a href="#cred_storage_prot" id="cred_storage_prot">Credential storage protection</a>
</h1>
<p></p>
<h1 id="rfc.section.5.1.4.1.1">
<a href="#rfc.section.5.1.4.1.1">5.1.4.1.1.</a> <a href="#std_sys" id="std_sys">Standard system security means</a>
</h1>
<p id="rfc.section.5.1.4.1.1.p.1">A server system may be locked down so that no attacker may get access to sensible configuration files and databases.</p>
<p></p>
<h1 id="rfc.section.5.1.4.1.2">
<a href="#rfc.section.5.1.4.1.2">5.1.4.1.2.</a> <a href="#std_sql" id="std_sql">Standard SQL inj. Countermeasures</a>
</h1>
<p id="rfc.section.5.1.4.1.2.p.1">[TBD]</p>
<h1 id="rfc.section.5.1.4.1.3">
<a href="#rfc.section.5.1.4.1.3">5.1.4.1.3.</a> <a href="#noclear" id="noclear">No cleartext storage of credentials</a>
</h1>
<p id="rfc.section.5.1.4.1.3.p.1">The authorization server may consider to not store credential in clear text. Typical approaches are to store hashes instead.  If the credential lacks a reasonable entropy level (because it is a user password) an additional salt will harden the storage to prevent offline dictionary attacks. Note: Some authentication protocols require the authorization server to have access to the secret in the clear. Those protocols cannot be implemented if the server only has access to hashes.</p>
<h1 id="rfc.section.5.1.4.1.4">
<a href="#rfc.section.5.1.4.1.4">5.1.4.1.4.</a> Encryption of credentials</h1>
<p id="rfc.section.5.1.4.1.4.p.1">[TBD]</p>
<h1 id="rfc.section.5.1.4.1.5">
<a href="#rfc.section.5.1.4.1.5">5.1.4.1.5.</a> Use of asymmetric cryptography</h1>
<p id="rfc.section.5.1.4.1.5.p.1">Usage of asymmetric cryptography will free the authorization server of the obligation to manage credentials. Nevertheless, it MUST ensure the integrity of the respective public keys.</p>
<h1 id="rfc.section.5.1.4.2">
<a href="#rfc.section.5.1.4.2">5.1.4.2.</a> <a href="#online_secrets" id="online_secrets">Online attacks on secrets</a>
</h1>
<p></p>
<h1 id="rfc.section.5.1.4.2.1">
<a href="#rfc.section.5.1.4.2.1">5.1.4.2.1.</a> <a href="#pwd_policy" id="pwd_policy">Password policy</a>
</h1>
<p id="rfc.section.5.1.4.2.1.p.1">The authorization server may decide to enforce a complex user password policy in order to increase the user passwords' entropy. This will hinder online password attacks.</p>
<h1 id="rfc.section.5.1.4.2.2">
<a href="#rfc.section.5.1.4.2.2">5.1.4.2.2.</a> <a href="#high_entropy" id="high_entropy">High entropy of secrets</a>
</h1>
<p id="rfc.section.5.1.4.2.2.p.1">When creating token handles or other secrets not intended for usage by human users, the authorization server MUST include a reasonable level of entropy in order to mitigate the risk of guessing attacks.</p>
<p id="rfc.section.5.1.4.2.2.p.2">The token value MUST be constructed from a cryptographically strong random or pseudo-random number sequence [RFC1750] generated by the Authorization Server. The probability of any two Authorization Code values being identical MUST be less than or equal to 2^(-128) and SHOULD be less than or equal to 2^(-160).</p>
<h1 id="rfc.section.5.1.4.2.3">
<a href="#rfc.section.5.1.4.2.3">5.1.4.2.3.</a> <a href="#lock_accounts" id="lock_accounts">Lock accounts</a>
</h1>
<p id="rfc.section.5.1.4.2.3.p.1">Online attacks on passwords can be mitigated by locking the respective accounts after a certain number of failed attempts.</p>
<p id="rfc.section.5.1.4.2.3.p.2">Note: This measure can be abused to lock down legitimate service users.</p>
<h1 id="rfc.section.5.1.4.2.4">
<a href="#rfc.section.5.1.4.2.4">5.1.4.2.4.</a> <a href="#tar_pit" id="tar_pit">Tar pit</a>
</h1>
<p id="rfc.section.5.1.4.2.4.p.1">The authorization server may react on failed attempts to authenticate by username/password by temporarily locking the respective account and delaying the response for a certain duration. This duration may increase with the number of failed attempts. The objective is to slow the attackes attempts on a certain username down.</p>
<p id="rfc.section.5.1.4.2.4.p.2">Note: this may require a more complex and stateful design of the authorization server.</p>
<h1 id="rfc.section.5.1.4.2.5">
<a href="#rfc.section.5.1.4.2.5">5.1.4.2.5.</a> <a href="#captchas" id="captchas">Usage of CAPTCHAs</a>
</h1>
<p id="rfc.section.5.1.4.2.5.p.1">The idea is to prevent programms from automatically checkinga huge number of passwords by requiring human interaction.</p>
<p id="rfc.section.5.1.4.2.5.p.2">Note: this has a negative impact on user experience.</p>
<h1 id="rfc.section.5.1.5">
<a href="#rfc.section.5.1.5">5.1.5.</a> Tokens (access, refresh, code)</h1>
<p></p>
<h1 id="rfc.section.5.1.5.1">
<a href="#rfc.section.5.1.5.1">5.1.5.1.</a> <a href="#limit_scope" id="limit_scope">Limit token scope</a>
</h1>
<p id="rfc.section.5.1.5.1.p.1">The authorization server may decide to reduce or limit the scope associated with a token. Basis of this decision is out of scope, examples are:</p>
<p></p>

<ul>
<li>a client-specific policy, e.g. issue only less powerful tokens to unauthenticated clients,</li>
<li>a service-specific policy, e.g. it a very sensible service,</li>
<li>a resource-owner specific setting, or</li>
<li>combinations of such policies and preferences.</li>
</ul>

<p>The authorization server may allow different scopes dependent on the grant type. For example, end-user authorization via direct interaction with the end-user (authorization code) might be considered more reliable than direct authorization via gran type username/password. This means will reduce the impact of the following threats:</p>
<p></p>

<ul>
<li>token leakage</li>
<li>token issuance to malicious software</li>
<li>unintended issuance of to powerful tokens with resource owner credentials flow</li>
</ul>

<p> </p>
<h1 id="rfc.section.5.1.5.2">
<a href="#rfc.section.5.1.5.2">5.1.5.2.</a> <a href="#exp_time" id="exp_time">Expiration time</a>
</h1>
<p id="rfc.section.5.1.5.2.p.1">Tokens should generally expire after a reasonable duration.  This complements and strengthens other security measures (such as signatures) and reduces the impact of all kinds of token leaks.</p>
<h1 id="rfc.section.5.1.5.3">
<a href="#rfc.section.5.1.5.3">5.1.5.3.</a> <a href="#short_exp_time" id="short_exp_time">Short expiration time</a>
</h1>
<p id="rfc.section.5.1.5.3.p.1">A short expiration time for tokens is a protection means against the following threats:</p>
<p></p>

<ul>
<li>replay</li>
<li>reduce impact of token leak</li>
<li>reduce likelyhood of sucessful online guessing</li>
</ul>

<p>Note: Short token duration requires preciser clock synchronisation between authorization server and resource server.  Furthermore, shorter duration may require more token refreshments (access token) or repeated end-user authorization processes (authorization code and refresh token).</p>
<h1 id="rfc.section.5.1.5.4">
<a href="#rfc.section.5.1.5.4">5.1.5.4.</a> <a href="#one_time_usage" id="one_time_usage">Limit number of usages/ One time usage</a>
</h1>
<p id="rfc.section.5.1.5.4.p.1">The authorization server may restrict the number of request, which can be performed with a certain token. This mechanism can be used to mitigate the following threats:</p>
<p></p>

<ul>
<li>replay of tokens</li>
<li>reduce likelyhood of sucessful online guessing</li>
</ul>

<p>Additionally, If an Authorization Server observes multiple attempts to redeem a authorization code, the Authorization Server may want to revoke all tokens granted based on the authorization code.</p>
<h1 id="rfc.section.5.1.5.5">
<a href="#rfc.section.5.1.5.5">5.1.5.5.</a> <a href="#bind_token_rs" id="bind_token_rs">Bind tokens to a particular resource server (Audience)</a>
</h1>
<p id="rfc.section.5.1.5.5.p.1">Authorization servers in multi-service environments may consider to issue tokens with different content to different resource servers and to explicitely indicate in the token the target server a token is intended to be sent to (cf. Audience in SAML Assertions). This countermeasure can be used in the following situations:</p>
<p></p>

<ul>
<li>It reduce the impact of a successful replay attempt, since the token is applicable to a single resource server, only.</li>
<li>It prevents abuse of a token by a rough resource server or client, since the token can only be used on that server. It is rejected by other servers.</li>
<li>It reduce the impact of a leakage of a valid token to a conterfeit resource server.</li>
</ul>

<p> </p>
<h1 id="rfc.section.5.1.5.6">
<a href="#rfc.section.5.1.5.6">5.1.5.6.</a> <a href="#endpoint_audience" id="endpoint_audience">Use endpoint address as token audience</a>
</h1>
<p id="rfc.section.5.1.5.6.p.1">This may be used to indicate to a resource server, which endpoint address has been used to obtain the token. This measure will allow to detect requests from a counterfeit resource server, since such token will contain the endpoint address of that server.</p>
<h1 id="rfc.section.5.1.5.7">
<a href="#rfc.section.5.1.5.7">5.1.5.7.</a> <a href="#audience_token_scope" id="audience_token_scope">Audience and Token scopes</a>
</h1>
<p id="rfc.section.5.1.5.7.p.1">Deployments may consider to use only tokens with explicitely defined scope, where every scope is associated with a particular resource server. This approach can be used to mitigate attacks, where a resource server or client uses a token for a different then the intended purpose.</p>
<h1 id="rfc.section.5.1.5.8">
<a href="#rfc.section.5.1.5.8">5.1.5.8.</a> <a href="#bind_token_client_id" id="bind_token_client_id">Bind token to client id</a>
</h1>
<p id="rfc.section.5.1.5.8.p.1">An authorization server may bind a token to a certain client identity. This identity match must be validated for every request with that token. This means can be used, to</p>
<p></p>

<ul>
<li>detect token leakage and</li>
<li>prevent token abuse.</li>
</ul>

<p>Note: Validating the client identity may require the target server to authenticate the client's identity. This authentication can be based on secrets managed independent of the token (e.g. pre-registered client id/secret on authorization server) or sent with the token itself (e.g. as part of the encrypted token content).</p>
<h1 id="rfc.section.5.1.5.9">
<a href="#rfc.section.5.1.5.9">5.1.5.9.</a> <a href="#signed_tokens" id="signed_tokens">Signed tokens</a>
</h1>
<p id="rfc.section.5.1.5.9.p.1">Self-contained tokens shall be signed in order to detect any attempt to modify or produce faked tokens.</p>
<h1 id="rfc.section.5.1.5.10">
<a href="#rfc.section.5.1.5.10">5.1.5.10.</a> <a href="#enc_token" id="enc_token">Encryption of token content</a>
</h1>
<p id="rfc.section.5.1.5.10.p.1">Self-contained may be encrypted for privacy reasons or to protect system internal data.</p>
<h1 id="rfc.section.5.1.5.11">
<a href="#rfc.section.5.1.5.11">5.1.5.11.</a> <a href="#random_entropy" id="random_entropy">Random token value with high entropy</a>
</h1>
<p id="rfc.section.5.1.5.11.p.1">When creating token handles, the authorization server MUST include a reasonable level of entropy in order to mitigate the risk of guessing attacks. The token value MUST be constructed from a cryptographically strong random or pseudo-random number sequence [RFC1750] generated by the Authorization Server. The probability of any two Authorization Code values being identical MUST be less than or equal to 2^(-128) and SHOULD be less than or equal to 2^(-160).</p>
<h1 id="rfc.section.5.1.6">
<a href="#rfc.section.5.1.6">5.1.6.</a> <a href="#access_tokens" id="access_tokens">Access tokens</a>
</h1>
<p></p>

<ul>
<li>keep them in transient memory (accessible by the client app only)</li>
<li>exposure to 3rd parties (malicious app)</li>
<li>limit number of access tokens granted to a user</li>
</ul>

<p> </p>
<h1 id="rfc.section.5.2">
<a href="#rfc.section.5.2">5.2.</a> Authorization Server</h1>
<p></p>
<h1 id="rfc.section.5.2.1">
<a href="#rfc.section.5.2.1">5.2.1.</a> Authorization Codes</h1>
<p></p>
<h1 id="rfc.section.5.2.1.1">
<a href="#rfc.section.5.2.1.1">5.2.1.1.</a> <a href="#automatic_code_revocation" id="automatic_code_revocation">Automatic revocation of derived tokens if abuse is detected</a>
</h1>
<p id="rfc.section.5.2.1.1.p.1">If an Authorization Server observes multiple attempts to redeem a authorization code, the Authorization Server may want to revoke all tokens granted based on the authorization code.</p>
<h1 id="rfc.section.5.2.2">
<a href="#rfc.section.5.2.2">5.2.2.</a> <a href="#refresh_tokens" id="refresh_tokens">Refresh tokens</a>
</h1>
<p></p>
<h1 id="rfc.section.5.2.2.1">
<a href="#rfc.section.5.2.2.1">5.2.2.1.</a> <a href="#restricted_refresh" id="restricted_refresh">Restricted issuance of refresh tokens</a>
</h1>
<p id="rfc.section.5.2.2.1.p.1">The authorization server may decide based on an appropriate policy not to issue refresh tokens. Since refresh tokens areo long term credentials, they may be subject theft. For example, if the authorization server does not trust a client to securely store such tokens, it may refuse to issue such a client a refresh token.</p>
<h1 id="rfc.section.5.2.2.2">
<a href="#rfc.section.5.2.2.2">5.2.2.2.</a> <a href="#binding_refresh_client_id" id="binding_refresh_client_id">Binding of refresh token to client_id</a>
</h1>
<p id="rfc.section.5.2.2.2.p.1">The authorization server MUST bind every refresh token to the id of the client such a token was originally issued to and validate this binding for every request to refresh that token.  This measure is a countermeasure against refresh token theft or leakage.</p>
<p id="rfc.section.5.2.2.2.p.2">Note: This binding MUST be protected from unauthorized modifications.</p>
<h1 id="rfc.section.5.2.2.3">
<a href="#rfc.section.5.2.2.3">5.2.2.3.</a> <a href="#refresh_replace" id="refresh_replace">Refresh Token Replacement</a>
</h1>
<p id="rfc.section.5.2.2.3.p.1">Refresh token replacement is intended to automatically detect and prevent attempts to use the same refresh token in parallel from different apps/devices. This happens if a token gets stolen from the client and is subsequently used by the attacker and the legitimate client. The basic idea is to change the refresh token value with every refresh request in order to detect attempts to obtain access tokens using old refresh tokens. Since the authorization server cannot determine whether the attacker or the legitimate client is trying to access, in case of such an access attempt the valid refresh token and the access authorization associated with it are both revoked.</p>
<p id="rfc.section.5.2.2.3.p.2">The OAuth specification supports this measure in that the tokens response allows the authorization server to return a new refresh token even for requests with grant type &#8222;refresh_token&#8220;.</p>
<p id="rfc.section.5.2.2.3.p.3">Note: this measure may cause problems in clustered environments since usage of the currently valid refresh token must be ensured.  In such an environment, other measures might be more appropriate.</p>
<h1 id="rfc.section.5.2.2.4">
<a href="#rfc.section.5.2.2.4">5.2.2.4.</a> <a href="#refresh_revocation" id="refresh_revocation">Refresh Token Revocation</a>
</h1>
<p id="rfc.section.5.2.2.4.p.1">The authorization server may allow clients or end-users to explicitely request the invalidation of refresh tokens.</p>
<p id="rfc.section.5.2.2.4.p.2">This is a countermeasure againts:</p>
<p></p>

<ul>
<li>device theft</li>
<li>...</li>
</ul>

<p> </p>
<h1 id="rfc.section.5.2.2.5">
<a href="#rfc.section.5.2.2.5">5.2.2.5.</a> <a href="#user_secret" id="user_secret">Combine refresh token requests with user-provided secret</a>
</h1>
<p id="rfc.section.5.2.2.5.p.1">The exchange of a refresh token can be bound to the presence of a certain user-provided secret, such as a PIN, a password or a SIM card. This is a kind of multi-factor authentication on the tokens endpoint, since an attacker must possess both factors in order to be able to obtain an access token.</p>
<h1 id="rfc.section.5.2.2.6">
<a href="#rfc.section.5.2.2.6">5.2.2.6.</a> <a href="#device_id" id="device_id">Device identification</a>
</h1>
<p id="rfc.section.5.2.2.6.p.1">The authorization server may require to bind authentication credentials to a device identifier or token assigned to that device. As the IMEI can be spoofed, that is not suitable, For mobile phones, a registration process can be used to assign a unique token to the device using an sms message. That token or identifer can then be validated with when authenticating user credentials.</p>
<p id="rfc.section.5.2.2.6.p.2">This is a countermeasure against the following threats:</p>
<p></p>

<ul>
<li>phishing attacks</li>
<li>...</li>
</ul>

<p> </p>
<h1 id="rfc.section.5.2.3">
<a href="#rfc.section.5.2.3">5.2.3.</a> <a href="#client_aa" id="client_aa">Client authentication and authorization</a>
</h1>
<p id="rfc.section.5.2.3.p.1">As described in Section 3 (Security Features), clients are identified, authenticated and authorized for several purposes, such as a</p>
<p></p>

<ul>
<li>Collate sub-sequent requests to the same client,</li>
<li>Indicate the trustworthiness of a particular client to the end-user,</li>
<li>Authorize access of clients to certain features on the authorization or resource server, and</li>
<li>Log a client identity to log files for analysis or statics.</li>
</ul>

<p>Due to the different capababilities and characterictics of the different client types, there are different ways to support achieve objectives, which will be described in this section.  Generally spoken, authorization server providers should be aware of the security policy and deployment of a particular clients and adapt its treatment accordingly. For example, one approach could be to treat all clients as less trustworthy and unsecure. On the other extrem, a service provider could activate every client installation by hand of an administrator and that way gain confidence in the identity of the software package and the security of the environment the client is installed in. And there are several approaches in between.</p>
<h1 id="rfc.section.5.2.3.1">
<a href="#rfc.section.5.2.3.1">5.2.3.1.</a> <a href="#dont_issue" id="dont_issue">Don't issue secrets to clients with inappropriate security policy</a>
</h1>
<p id="rfc.section.5.2.3.1.p.1">Authorization servers should not issue secrets to clients, if these cannot sufficiently protect it. This prevents the server from overestimating the value of a sucessful authentication of the client.</p>
<p id="rfc.section.5.2.3.1.p.2">For example, it is of limited benefit to create a single client id and secret which is shared by all installations of a native app. First of all, this secret must be somehow transmitted from the developer via the respective distribution channel, e.g. an app market, to all installations of the app on end-user devices. So the secret is typically burned into the source code of the app or a associated resource bundle, which cannot be entirely protected from reverse engineering. Second, effectively such secrets cannot be revoked since this would immediatly put all installations out of work. Moreover, since the authorization server cannot really trust on the client's identity, it would be dangerous to indicate to end-users the trustworthiness of the client.</p>
<p id="rfc.section.5.2.3.1.p.3">There are other ways to achieve a reasonable security level, as described in the following sections.</p>
<h1 id="rfc.section.5.2.3.2">
<a href="#rfc.section.5.2.3.2">5.2.3.2.</a> <a href="#forced_user_consent" id="forced_user_consent">Client_id only in combination with forced user consent</a>
</h1>
<p id="rfc.section.5.2.3.2.p.1">The authorization may issue a client id, but only accept authorization request, which are approved by the end-user. This measure precludes automatic authorization processes. This is a countermeasure for clients without secret against the following threats:</p>
<p></p>

<ul>
<li>...</li>
<li>...</li>
</ul>

<p> </p>
<h1 id="rfc.section.5.2.3.3">
<a href="#rfc.section.5.2.3.3">5.2.3.3.</a> <a href="#client_id_redirect" id="client_id_redirect">Client_id only in combination with redirect_uri</a>
</h1>
<p id="rfc.section.5.2.3.3.p.1">The authorization may issue a client id, but bind this client_id to a certain pre-configured redirect_uri. So any authorization request with another redirect_uri is refused automatically. Alternatively, the authorization server may not accept any dynamic redirect_uri for such a client_id and instead always redirect to the well-known pre-configured redirect_uri.  This is a countermeasure for clients of LOA 2 against the following threats:</p>
<p></p>

<ul>
<li>...</li>
<li>...</li>
</ul>

<p> </p>
<h1 id="rfc.section.5.2.3.4">
<a href="#rfc.section.5.2.3.4">5.2.3.4.</a> <a href="#depl_specific_secretes" id="depl_specific_secretes">Deployment-specific client secrets</a>
</h1>
<p id="rfc.section.5.2.3.4.p.1">A authorization server may issue separate client ids and corresponding secrets to the different deployments of a client.</p>
<p id="rfc.section.5.2.3.4.p.2">For web applications, this could mean to create one client_id and client_secret per web site a software package is installed on.  So the provider of that particular site could request client id and secret from the authorization server during setup of the web site. This would also allow to validate some of the properties of that web site, such as redirect_uri, address, and whatever proofs useful. The web site provider has to ensure the security of the client secret on the site. As a result, such client could reach LOA 7.</p>
<p id="rfc.section.5.2.3.4.p.3">For native applications, things are more complicated because every installation of the app on any device is another deployment.  Deployment specific secrets will require</p>
<p></p>

<ol>
<li>Either to obtain a client_id and client_secret during download process from the app market, or</li>
<li>During installation on the device.</li>
</ol>

<p>Either approach will require an automated mechanism for issuing client ids and secrets, which is currently not defined by OAuth.</p>
<p id="rfc.section.5.2.3.4.p.5">The first approach would allow to achieve LOA 7, whereas the second option does not allow to validate properties of the client thus can achieve at most LOA 6. But this would at least help to prevent several replay attacks. Moreover, deployment-specific client_id and secret allow to selectively revoke all refresh tokens of a specific deployment at once. This is a countermeasure against the following threats:</p>
<p></p>

<ul>
<li>...</li>
<li>...</li>
</ul>

<p> </p>
<h1 id="rfc.section.5.2.3.5">
<a href="#rfc.section.5.2.3.5">5.2.3.5.</a> <a href="#val_redirect" id="val_redirect">Validation of pre-registered redirect_uri</a>
</h1>
<p id="rfc.section.5.2.3.5.p.1">An authorization server may require clients to register their redirect_uri or a pattern (TBD: make definition more precise) thereof. The way this registration is performed is out of scope of this document. Every actual redirect_uri sent with the respective client_id to the end-user authorization endpoint must comply with that pattern. Otherwise the authorization server must assume the inbound GET request has been sent by an attacker and refuse it.</p>
<p id="rfc.section.5.2.3.5.p.2">Note: the authorization server MUST NOT redirect the user agent back to the redirect_uri of the authorization request.</p>
<p></p>

<ul>
<li>Session fixation: allows to detect session fixation attempts already after first redirect to end-user authorization endpoint</li>
<li>For clients of LOA 2/5/7, this measure also helps to detect malicious apps early in the end-user authorization process.  This reduces the need for a interactive validation by the user.</li>
</ul>

<p>The underlying assumption of this measure is that an attacker must use another redirect_uri in order to get access to the authorization code. Deployments might consider the possibility of an attacker using spoofing attacks to a victims device to circumvent this security measure. This is a countermeasure against the following threats:</p>
<p></p>

<ul>
<li>session fixation</li>
<li>malicious apps (for deployment-specific clients with secret)</li>
</ul>

<p>Note: Pre-registering clients might not scale in some deployments (manual process) or require dynamic client registration (not specified yet). With the lack of dynamic client registration, it only works for clients bound to certain deployments at development/configuration time. As soon as dynamic resource server discovery gets involved, that's no longer feasable.</p>
<h1 id="rfc.section.5.2.3.6">
<a href="#rfc.section.5.2.3.6">5.2.3.6.</a> <a href="#client_secret_revocation" id="client_secret_revocation">Client secret revocation</a>
</h1>
<p id="rfc.section.5.2.3.6.p.1">An authorization server may revoke a client's secret in order to prevent abuse of a revealed secret.</p>
<p id="rfc.section.5.2.3.6.p.2">Note: This measure will immediately invalidate any authorization code or refresh token issued to the respective client. This might be unintentionally for client identifiers and secrets used across multiple deployments of a particular native or web application.</p>
<p id="rfc.section.5.2.3.6.p.3">This a countermeasure against:</p>
<p></p>

<ul>
<li>...</li>
<li>...</li>
</ul>

<p> </p>
<h1 id="rfc.section.5.2.3.7">
<a href="#rfc.section.5.2.3.7">5.2.3.7.</a> <a href="#strong_client_authn" id="strong_client_authn">Use strong client authentication (e.g. client_assertion / client_token)</a>
</h1>
<p id="rfc.section.5.2.3.7.p.1">Assumption: prevents an attacker from obtaining a client secret because this secret is kept in some hardware security module?</p>
<h1 id="rfc.section.5.2.4">
<a href="#rfc.section.5.2.4">5.2.4.</a> End-user authorization</h1>
<p></p>
<h1 id="rfc.section.5.2.4.1">
<a href="#rfc.section.5.2.4.1">5.2.4.1.</a> <a href="#automatic_processing" id="automatic_processing">Automatic processing of repeated authorizations requires client validation</a>
</h1>
<p id="rfc.section.5.2.4.1.p.1">Service providers should not automatically process repeat authorizations where the client is not authenticated through a client secret or some other authentication mechanism such as signing with security certs (5.7.2.7. Use strong client authentication (e.g. client_assertion / client_token)) or validation of a pre-registered redirect uri (5.7.2.5. Validation of pre-registered redirect_uri ).</p>
<h1 id="rfc.section.5.2.4.2">
<a href="#rfc.section.5.2.4.2">5.2.4.2.</a> <a href="#informed_decisions" id="informed_decisions">Informed decisions based on transparency</a>
</h1>
<p id="rfc.section.5.2.4.2.p.1">The authorization server shall intelligible explain to the end-user what happens in the authorization process and what the consequences are. For example, the user shall understand what access he is about to grant to which client for what duration. It shall also be obvious to the user, whether the server is able to reliably certify certain client properties (web site address, security policy).</p>
<h1 id="rfc.section.5.2.4.3">
<a href="#rfc.section.5.2.4.3">5.2.4.3.</a> <a href="#validation_end_user" id="validation_end_user">Validation of client properties by end-user</a>
</h1>
<p id="rfc.section.5.2.4.3.p.1">In the authorization process, the user is typically asked to approve a client's request for authorization. This is an important security mechanism by itself because the end-users can be involed in the validation of client properties, such as whether the client name known to the authorization server fits the name of the web site or the app the end-user is using. This measure is especially helpful in all situation where the authorization server is unable to authenticate the client. It is a countermeasure against:</p>
<p></p>

<ul>
<li>Malicious app</li>
<li>...</li>
</ul>

<p> </p>
<h1 id="rfc.section.5.2.4.4">
<a href="#rfc.section.5.2.4.4">5.2.4.4.</a> <a href="#bind_code_client_id" id="bind_code_client_id">Binding of authorization code to client_id</a>
</h1>
<p id="rfc.section.5.2.4.4.p.1">The authorization server MUST bind every authorization code to the id of the respective client which initiated the end-user authorization process. This measure is a countermeasure against:</p>
<p></p>

<ul>
<li>Session fixation since an attacker cannot use another client_id to exchange an authorization code into a token</li>
<li>Online guessing of authorization codes</li>
</ul>

<p>Note: This binding MUST be protected from unauthorized modifications.</p>
<h1 id="rfc.section.5.2.4.5">
<a href="#rfc.section.5.2.4.5">5.2.4.5.</a> <a href="#bind_code_redirect" id="bind_code_redirect">Binding of authorization code to redirect_uri</a>
</h1>
<p id="rfc.section.5.2.4.5.p.1">The authorization server MAY bind every authorization code to the redirect_uri used as redirect target of the client in the end-user authorization process. This binding MUST be validated when the client attempts to exchange the respective authorization code for an access token. This measure is a countermeasure against session fixation since an attacker cannot use another redirect_uri to exchange an authorization code into a token.</p>
<p></p>
<h1 id="rfc.section.5.3">
<a href="#rfc.section.5.3">5.3.</a> Client App Security</h1>
<p></p>
<h1 id="rfc.section.5.3.1">
<a href="#rfc.section.5.3.1">5.3.1.</a> <a href="#cred_software" id="cred_software">Don't store credentials in code or resources bundled with software packages</a>
</h1>
<p id="rfc.section.5.3.1.p.1">[Anything more to say ? :-)]</p>
<h1 id="rfc.section.5.3.2">
<a href="#rfc.section.5.3.2">5.3.2.</a> <a href="#std_web" id="std_web">Standard web server protection measures (for config files and databases)</a>
</h1>
<p></p>
<h1 id="rfc.section.5.3.3">
<a href="#rfc.section.5.3.3">5.3.3.</a> <a href="#secure_storage" id="secure_storage">Store secrets in a secure storage</a>
</h1>
<p id="rfc.section.5.3.3.p.1">The are different way to store secrets of all kinds (tokens, client secrets) securely on a device or server.</p>
<p id="rfc.section.5.3.3.p.2">Most multi-user operation systems seggregate the personal storage of the different system users. Moreover, most modern smartphone operating systems even support to store app-specific data in separat areas of the file systems and protect it from access by other apps.  Additionally, apps can implements confidential data itself using a user-supplied secret, such as PIN or password.</p>
<p id="rfc.section.5.3.3.p.3">Another option is to swap refresh token storage to a trusted backend server. This mean in turn requires a resilient authentication mechanisms between client and backend server. Note: Applications must ensure that confidential data are kept confidential even after readin from secure storage, which typically means to keep this data in the local memory of the app.</p>
<h1 id="rfc.section.5.3.4">
<a href="#rfc.section.5.3.4">5.3.4.</a> <a href="#device_lock" id="device_lock">Utilize device lock to prevent unauthorized device access</a>
</h1>
<p></p>
<h1 id="rfc.section.5.3.5">
<a href="#rfc.section.5.3.5">5.3.5.</a> Platform security measures</h1>
<p></p>

<ul>
<li>Validation process</li>
<li>software package signatures</li>
<li>Remote removal</li>
<li>
</ul>

<p> </p>
<h1 id="rfc.section.5.4">
<a href="#rfc.section.5.4">5.4.</a> Resource Servers</h1>
<p></p>
<h1 id="rfc.section.5.4.1">
<a href="#rfc.section.5.4.1">5.4.1.</a> <a href="#authz_header" id="authz_header">Authorization headers</a>
</h1>
<p id="rfc.section.5.4.1.p.1">Authorization headers are recognized and specially treated by HTTP proxies and servers. Thus the usage of such headers for sending access tokens to resource servers reduces the likelihood of leakage or unintended storage of authenticated requests in general and especially Authorization headers.</p>
<h1 id="rfc.section.5.4.2">
<a href="#rfc.section.5.4.2">5.4.2.</a> <a href="#authn_requests" id="authn_requests">Authenticated requests</a>
</h1>
<p id="rfc.section.5.4.2.p.1">An authorization server may bind tokens to a certain client identitiy and encourage resource servers to validate that binding.  This will require the resource server to authenticate the originator of a request as the legitimate owner of a particular token. There are a couple of options to implement this countermeasure:</p>
<p></p>

<ul>
<li>The authorization server may associate the distinguished name of the client with the token (either internally or in the payload of an self-contained token). The client then uses client certificate-based HTTP authentication on the resource server's endpoint to authenticate its identity and the resource server validates the name with the name referenced by the token.</li>
<li>same as before, but the client uses his private key to sign the request to the resource server (public key is either contained in the token or sent along with the request)</li>
<li>Alternatively, the authorization server may issue a token-bound secret, which the client uses to sign the request.  The resource server obtains the secret either directly from the authorization server or it is contained in an encrypted section of the token. That way the resource server does not "know" the client but is able to validate whether the authorization server issued the token to that client</li>
</ul>

<p>This mechanisms is a countermeasure against abuse of tokens by counterfeit resource servers.</p>
<h1 id="rfc.section.5.4.3">
<a href="#rfc.section.5.4.3">5.4.3.</a> <a href="#signed_requests" id="signed_requests">Signed requests</a>
</h1>
<p id="rfc.section.5.4.3.p.1">A resource server may decide to accept signed requests only, either to replace transport level security measures or to complement such measures. Every signed request must be uniquly identifiable and must not be processed twice by the resource server. This countermeasure helps to mitigate:</p>
<p></p>

<ul>
<li>modifications of the message and</li>
<li>replay attempts</li>
</ul>

<p> </p>
<h1 id="rfc.section.6">
<a href="#rfc.section.6">6.</a> <a href="#IANA" id="IANA">IANA Considerations</a>
</h1>
<p id="rfc.section.6.p.1">This document makes no request of IANA.</p>
<p id="rfc.section.6.p.2">Note to RFC Editor: this section may be removed on publication as an RFC.</p>
<h1 id="rfc.section.7">
<a href="#rfc.section.7">7.</a> <a href="#Acknowledgements" id="Acknowledgements">Acknowledgements</a>
</h1>
<p id="rfc.section.7.p.1">We would like to thank Francisco Corella for his feedback.</p>
<h1 id="rfc.references">
<a href="#rfc.references">8.</a> References</h1>
<h1 id="rfc.references.1">
<a href="#rfc.references.1">8.1.</a> Normative References</h1>
<table><tbody>
<tr>
<td class="reference"><b id="RFC2119">[RFC2119]</b></td>
<td class="top">
<a href="mailto:sob@harvard.edu" title="Harvard University">Bradner, S.</a>, "<a href="http://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>", BCP 14, RFC 2119, March 1997.</td>
</tr>
<tr>
<td class="reference"><b id="I-D.ietf-oauth-v2">[I-D.ietf-oauth-v2]</b></td>
<td class="top">
<a>Hammer-Lahav, E</a>, <a>Recordon, D</a> and <a>D Hardt</a>, "<a href="http://tools.ietf.org/html/draft-ietf-oauth-v2-22">The OAuth 2.0 Authorization Protocol</a>", Internet-Draft draft-ietf-oauth-v2-22, September 2011.</td>
</tr>
</tbody></table>
<h1 id="rfc.references.2">
<a href="#rfc.references.2">8.2.</a> Informative References</h1>
<table><tbody>
<tr>
<td class="reference"><b id="I-D.lodderstedt-oauth-revocation">[I-D.lodderstedt-oauth-revocation]</b></td>
<td class="top">
<a>Lodderstedt, T</a>, <a>Dronia, S</a> and <a>M Scurtescu</a>, "<a href="http://tools.ietf.org/html/draft-lodderstedt-oauth-revocation-03">Token Revocation</a>", Internet-Draft draft-lodderstedt-oauth-revocation-03, September 2011.</td>
</tr>
<tr>
<td class="reference"><b id="I-D.ietf-oauth-v2-bearer">[I-D.ietf-oauth-v2-bearer]</b></td>
<td class="top">
<a>Jones, M</a>, <a>Hardt, D</a> and <a>D Recordon</a>, "<a href="http://tools.ietf.org/html/draft-ietf-oauth-v2-bearer-14">The OAuth 2.0 Authorization Protocol: Bearer Tokens</a>", Internet-Draft draft-ietf-oauth-v2-bearer-14, November 2011.</td>
</tr>
<tr>
<td class="reference"><b id="I-D.hammer-oauth-v2-mac-token">[I-D.hammer-oauth-v2-mac-token]</b></td>
<td class="top">
<a>Hammer-Lahav, E</a>, <a>Barth, A</a> and <a>B Adida</a>, "<a href="http://tools.ietf.org/html/draft-hammer-oauth-v2-mac-token-05">HTTP Authentication: MAC Access Authentication</a>", Internet-Draft draft-hammer-oauth-v2-mac-token-05, May 2011.</td>
</tr>
<tr>
<td class="reference"><b id="portable-contacts">[portable-contacts]</b></td>
<td class="top">
<a>Smarr, J.</a>, "<a>Portable Contacts 1.0 Draft C</a>", August 2008.</td>
</tr>
</tbody></table>
<h1 id="rfc.authors"><a href="#rfc.authors">Authors' Addresses</a></h1>
<div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Dr.-Ing. Torsten Lodderstedt</span> editor
	  <span class="n hidden">
		<span class="family-name">Lodderstedt</span>
	  </span>
	</span>
	<span class="org vcardline">Deutsche Telekom AG</span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality"></span> 
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline"></span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:torsten@lodderstedt.net">torsten@lodderstedt.net</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Mark McGloin</span> 
	  <span class="n hidden">
		<span class="family-name">McGloin</span>
	  </span>
	</span>
	<span class="org vcardline">IBM</span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality"></span> 
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline"></span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:mark.mcgloin@ie.ibm.com">mark.mcgloin@ie.ibm.com</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Phil Hunt</span> 
	  <span class="n hidden">
		<span class="family-name">Hunt</span>
	  </span>
	</span>
	<span class="org vcardline">Oracle Corporation</span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality"></span> 
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline"></span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:phil.hunt@yahoo.com">phil.hunt@yahoo.com</a></span>

  </address>
</div>

</body>
</html>