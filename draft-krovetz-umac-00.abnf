AuthTag = f(Nonce) xor h(Msg).

w = WORD-LEN            (4)
l = UMAC-OUTPUT-LEN     (8)
n = L1-KEY-LEN          (1024)
k = UMAC-KEY-LEN        (16)
s = L1-OPERATIONS-SIGN  (UNSIGNED)
e = ENDIAN-FAVORITE     (LITTLE)

n = length(S) / WORD-LEN
T = <empty string>
SReversed_i = W_{WORD-LEN} || W_{WORD-LEN - 1} || ... || W_1
T = T || SReversed_i

L1-OPERATIONS-SIGN == SIGNED) then

     "S *_n T" as uint2str(str2sint(S) * str2sint(T) mod 2^n, n/8), and

     "S +_n T" as uint2str(str2sint(S) + str2sint(T) mod 2^n, n/8).
L1-OPERATIONS-SIGN == UNSIGNED) then we define

     "S *_n T" as uint2str(str2uint(S) * str2uint(T) mod 2^n, n/8), and

     "S +_n T" as uint2str(str2uint(S) + str2uint(T) mod 2^n, n/8).

n = ceil(numbytes / 16)
T = zeroes(15) || uint2str(index, 1)
Y = <empty string>

T = AES(K, T)
Y = Y || T

Y = Y[1..numbytes]

Nonce = Nonce || zeroes(16 - length(Nonce))

i = floor(16 / UMAC-OUTPUT-LEN)
numlowbits = floor(lg(i))

nlowbitsnum = str2uint(Nonce) mod 2^numlowbits
Nonce = Nonce xor uint2str(nlowbitsnum, 16)
T = AES(K', Nonce)
Y = T[ nlowbitsnum      * UMAC-OUTPUT-LEN + 1 ..
               (nlowbitsnum + 1) * UMAC-OUTPUT-LEN]

K_1 = KDF(K, 128, UMAC-KEY-LEN)
K_2 = KDF(K, 129, UMAC-KEY-LEN)
Y = AES(K_1, Nonce)
Y = AES(K_1, Nonce) || AES(K_2, Nonce)
Y = Y[1..UMAC-OUTPUT-LEN]

t = length(M) / 4
Y = zeroes(8)
i = 1
Y = Y +_64 ((M_{i+0} +_32 K_{i+0}) *_64 (M_{i+4} +_32 K_{i+4}))
Y = Y +_64 ((M_{i+1} +_32 K_{i+1}) *_64 (M_{i+5} +_32 K_{i+5}))
Y = Y +_64 ((M_{i+2} +_32 K_{i+2}) *_64 (M_{i+6} +_32 K_{i+6}))
Y = Y +_64 ((M_{i+3} +_32 K_{i+3}) *_64 (M_{i+7} +_32 K_{i+7}))
i = i + 8

t = ceil(length(M) / L1-KEY-LEN)
Len = uint2str(L1-KEY-LEN * 8, 8)
Y = <empty string>
Y = Y || (NH-32(K, M_i) +_64 Len)

Len = uint2str(length(M_t) * 8, 8)
M_t = zeropad(M_t, 32)
Y = Y || (NH-32(K, M_t) +_64 Len)

wordbytes = wordbits / 8
p = prime(wordbits)
offset = 2^wordbits - p
marker = p - 1

n = length(M) / wordbytes
y = 1
m = str2uint(M_i)
y = (k * y + marker) mod p
y = (k * y + (m - offset)) mod p
y = (k * y + m) mod p

Mask64  = uint2str(0x01ffffff01ffffff, 8)
Mask128 = uint2str(0x01ffffff01ffffff01ffffff01ffffff, 16)
k64    = str2uint(K[1..8]  and Mask64)
k128   = str2uint(K[9..24] and Mask128)

y = POLY(64, 2^64 - 2^32,  k64, M)

M_1 = M[1 .. 2^17]
M_2 = M[2^17 + 1 .. length(M)]
M_2 = zeropad(M_2 || uint2str(0x80,1), 16)
y = POLY(64, 2^64 - 2^32, k64, M_1)
y = POLY(128, 2^128 - 2^96, k128, uint2str(y, 16) || M_2)

Y = uint2str(y, 16)

y = 0

M_i = M [(i - 1) * 2 + 1 .. i * 2]
K_i = K1[(i - 1) * 8 + 1 .. i * 8]
m_i = str2uint(M_i)
k_i = str2uint(K_i) mod prime(36)

y = (m_1 * k_1 + ... + m_8 * k_8) mod prime(36)
y = y mod 2^32
Y = uint2str(y, 4)
Y = Y xor K2

streams = ceil(UMAC-OUTPUT-LEN / WORD-LEN)

L1Key  = KDF(K, 0, L1-KEY-LEN + (streams - 1) * 16)
L2Key  = KDF(K, 1, streams * 24)
L3Key1 = KDF(K, 2, streams * 64)
L3Key2 = KDF(K, 3, streams * 4)

Y = <empty string>
L1Key_i  = L1Key [(i-1) * 16 + 1 .. (i-1) * 16 + L1-KEY-LEN]
L2Key_i  = L2Key [(i-1) * 24 + 1 .. i * 24]
L3Key1_i = L3Key1[(i-1) * 64 + 1 .. i * 64]
L3Key2_i = L3Key2[(i-1) * 4  + 1 .. i * 4]

A = L1-HASH-32(L1Key_i, M)
B = zeroes(8) || A
B = L2-HASH-32(L2Key_i, A)
C = L3-HASH-32(L3Key1_i, L3Key2_i, B)
Y = Y || C
Y = Y[1 .. UMAC-OUTPUT-LEN]

t = length(M) / 2
Y = zeroes(4)
i = 1
Y = Y +_32 ((M_{i+0} +_16 K_{i+0}) *_32 (M_{i+ 8} +_16 K_{i+ 8}))
Y = Y +_32 ((M_{i+1} +_16 K_{i+1}) *_32 (M_{i+ 9} +_16 K_{i+ 9}))
Y = Y +_32 ((M_{i+2} +_16 K_{i+2}) *_32 (M_{i+10} +_16 K_{i+10}))
Y = Y +_32 ((M_{i+3} +_16 K_{i+3}) *_32 (M_{i+11} +_16 K_{i+11}))
Y = Y +_32 ((M_{i+4} +_16 K_{i+4}) *_32 (M_{i+12} +_16 K_{i+12}))
Y = Y +_32 ((M_{i+5} +_16 K_{i+5}) *_32 (M_{i+13} +_16 K_{i+13}))
Y = Y +_32 ((M_{i+6} +_16 K_{i+6}) *_32 (M_{i+14} +_16 K_{i+14}))
Y = Y +_32 ((M_{i+7} +_16 K_{i+7}) *_32 (M_{i+15} +_16 K_{i+15}))
i = i + 16

t = ceil(length(M) / L1-KEY-LEN)
Len = uint2str(L1-KEY-LEN * 8, 4)
Y = <empty string>
Y = Y || (NH-16(K, M_i) +_32 Len)

Len = uint2str(length(M_t) * 8, 4)
M_t = zeropad(M_t, 32)
Y = Y || (NH-16(K, M_t) +_32 Len)

Mask32  = uint2str(0x1fffffff, 4)
Mask64  = uint2str(0x01ffffff01ffffff, 8)
Mask128 = uint2str(0x01ffffff01ffffff01ffffff01ffffff, 16)
k_32    = str2uint(K[1..4]   and Mask32)
k64    = str2uint(K[5..12]  and Mask64)
k128   = str2uint(K[13..28] and Mask128)

y = POLY(32, 2^32 - 6, k_32, M)

M_1 = M[1 .. 2^11]
M_2 = M[2^11 + 1 .. length(M)]
M_2 = zeropad(M_2 || uint2str(0x80,1), 8)
y = POLY(32, 2^32 - 6,    k_32, M_1)
y = POLY(64, 2^64 - 2^32, k64, uint2str(y, 8) || M_2)

M_1 = M[1 .. 2^11]
M_2 = M[2^11 + 1 .. 2^33]
M_3 = M[2^33 + 1 .. length(M)]
M_3 = zeropad(M || uint2str(0x80,1), 16)
y = POLY(32,  2^32 - 6,     k_32,  M_1)
y = POLY(64,  2^64 - 2^32,  k64,  uint2str(y,  8) || M_2)
y = POLY(128, 2^128 - 2^96, k128, uint2str(y, 16) || M_3)

Y = uint2str(y, 16)

y = 0

M_i = M[(i - 1) * 2 + 1 .. i * 2]
K_i = K1[(i - 1) * 4 + 1 .. i * 4]
m_i = str2uint(M_i)
k_i = str2uint(K_i) mod prime(19)

y = (m_1 * k_1 + ... + m_8 * k_8) mod prime(19)
y = y mod 2^16
Y = uint2str(y, 2)
Y = Y xor K2

streams = ceil(UMAC-OUTPUT-LEN / WORD-LEN)

L1Key  = KDF(K, 0, L1-KEY-LEN + (streams - 1) * 16)
L2Key  = KDF(K, 1, streams * 28)
L3Key1 = KDF(K, 2, streams * 32)
L3Key2 = KDF(K, 3, streams * 2)

Y = <empty string>
L1Key_i  = L1Key [(i-1) * 16 + 1 .. (i-1) * 16 + L1-KEY-LEN]
L2Key_i  = L2Key [(i-1) * 28 + 1 .. i * 28]
L3Key1_i = L3Key1[(i-1) * 32 + 1 .. i * 32]
L3Key2_i = L3Key2[(i-1) * 2 + 1  .. i * 2]

A = L1-HASH-16(L1Key_i, M)
B = zeroes(12) || A
B = L2-HASH-16(L2Key_i, A)
C = L3-HASH-16(L3Key1_i, L3Key2_i, B)
Y = Y || C
Y = Y[1 .. UMAC-OUTPUT-LEN]

HashedMessage = UHASH-16(K, M)
HashedMessage = UHASH-32(K, M)
Pad              = PDF(K, Nonce)
AuthTag          = Pad xor HashedMessage

