<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="en"><head><title>Third Party Authorization in the Session Initiation Protocol</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="description" content="Third Party Authorization in the Session Initiation Protocol">
<meta name="keywords" content="I-D, Internet-Draft">
<meta name="generator" content="xml2rfc v1.35 (http://xml.resource.org/)">
<meta name="viewport" content="width=600;" />
<style type='text/css'><!--
        body {
                font-family: verdana, charcoal, helvetica, arial, sans-serif;
                font-size: 85%;
		max-width: 40em; 
		color: #000; background-color: #FFF;
                margin: 2em;
        }
        h1, h2, h3, h4, h5, h6 {
                font-family: helvetica, monaco, "MS Sans Serif", arial, sans-serif;
                font-weight: bold; font-style: normal;
        }
        h1 { color: #900; background-color: transparent; text-align: right; }
        h3 { color: #333; background-color: transparent; }

        td.RFCbug {
                font-size: x-small; text-decoration: none;
                width: 30px; height: 30px; padding-top: 2px;
                text-align: justify; vertical-align: middle;
                background-color: #000;
        }
        td.RFCbug span.RFC {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: bold; color: #666;
        }
        td.RFCbug span.hotText {
                font-family: charcoal, monaco, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: normal; text-align: center; color: #FFF;
        }

        table.TOCbug { width: 30px; height: 15px; }
        td.TOCbug {
                text-align: center; width: 30px; height: 15px;
                color: #FFF; background-color: #900;
        }
        td.TOCbug a {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, sans-serif;
                font-weight: bold; font-size: x-small; text-decoration: none;
                color: #FFF; background-color: transparent;
        }

        td.header {
                font-family: arial, helvetica, sans-serif; font-size: x-small;
                vertical-align: top; width: 33%;
                color: #FFF; background-color: #666;
        }
        td.author { font-weight: bold; font-size: x-small; margin-left: 4em; }
        td.author-text { font-size: x-small; }

        /* info code from SantaKlauss at http://www.madaboutstyle.com/tooltip2.html */
        a.info {
                /* This is the key. */
                position: relative;
                z-index: 24;
                text-decoration: none;
        }
        a.info:hover {
                z-index: 25;
                color: #FFF; background-color: #900;
        }
        a.info span { display: none; }
        a.info:hover span.info {
                /* The span will display just on :hover state. */
                display: block;
                position: absolute;
                font-size: smaller;
                top: 2em; left: -5em; width: 15em;
                padding: 2px; border: 1px solid #333;
                color: #900; background-color: #EEE;
                text-align: left;
        }

        a { font-weight: bold; }
        a:link    { color: #900; background-color: transparent; }
        a:visited { color: #633; background-color: transparent; }
        a:active  { color: #633; background-color: transparent; }

        p { margin-left: 2em; margin-right: 2em; }
        p.copyright { font-size: x-small; }
        p.toc { font-size: 85%;
		max-width: 40em; 
		font-weight: bold; margin-left: 3em; }
        table.toc { margin: 0 0 0 3em; padding: 0; border: 0; vertical-align: text-top; }
        td.toc { font-size: 85%;
		max-width: 40em; 
		font-weight: bold; vertical-align: text-top; }

        ol.text { margin-left: 2em; margin-right: 2em; }
        ul.text { margin-left: 2em; margin-right: 2em; }
        li      { margin-left: 3em; }

        /* RFC-2629 <spanx>s and <artwork>s. */
        em     { font-style: italic; }
        strong { font-weight: bold; }
        dfn    { font-weight: bold; font-style: normal; }
        cite   { font-weight: normal; font-style: normal; }
        tt     { color: #036; }
        tt, pre, pre dfn, pre em, pre cite, pre span {
                font-family: "Courier New", Courier, monospace; font-size: small;
        }
        pre {
                text-align: left; padding: 4px;
                color: #000; background-color: #CCC;
        }
        pre dfn  { color: #900; }
        pre em   { color: #66F; background-color: #FFC; font-weight: normal; }
        pre .key { color: #33C; font-weight: bold; }
        pre .id  { color: #900; }
        pre .str { color: #000; background-color: #CFF; }
        pre .val { color: #066; }
        pre .rep { color: #909; }
        pre .oth { color: #000; background-color: #FCF; }
        pre .err { background-color: #FCC; }

        /* RFC-2629 <texttable>s. */
        table.all, table.full, table.headers, table.none {
                font-size: 85%;
		max-width: 40em; 
		text-align: center; border-width: 2px;
                vertical-align: top; border-collapse: collapse;
        }
        table.all, table.full { border-style: solid; border-color: black; }
        table.headers, table.none { border-style: none; }
        th {
                font-weight: bold; border-color: black;
                border-width: 2px 2px 3px 2px;
        }
        table.all th, table.full th { border-style: solid; }
        table.headers th { border-style: none none solid none; }
        table.none th { border-style: none; }
        table.all td {
                border-style: solid; border-color: #333;
                border-width: 1px 2px;
        }
        table.full td, table.headers td, table.none td { border-style: none; }

        hr { height: 1px; }
        hr.insert {
                width: 80%; border-style: none; border-width: 0;
                color: #CCC; background-color: #CCC;
        }
--></style>
</head>
<body>
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<table summary="layout" width="66%" border="0" cellpadding="0" cellspacing="0"><tr><td><table summary="layout" width="100%" border="0" cellpadding="2" cellspacing="1">
<tr><td class="header">DISPATCH</td><td class="header">S. Lawrence</td></tr>
<tr><td class="header">Internet-Draft</td><td class="header">Nortel Networks, Inc.</td></tr>
<tr><td class="header">Intended status: Informational</td><td class="header">May 03, 2009</td></tr>
<tr><td class="header">Expires: November 4, 2009</td><td class="header">&nbsp;</td></tr>
</table></td></tr></table>
<h1><br />Third Party Authorization in the Session Initiation Protocol<br />draft-lawrence-sip-3rd-party-authorization-00</h1>

<h3>Status of this Memo</h3>
<p>
This Internet-Draft is submitted to IETF in full
conformance with the provisions of BCP&nbsp;78 and BCP&nbsp;79.</p>
<p>
Internet-Drafts are working documents of the Internet Engineering
Task Force (IETF), its areas, and its working groups.
Note that other groups may also distribute working documents as
Internet-Drafts.</p>
<p>
Internet-Drafts are draft documents valid for a maximum of six months
and may be updated, replaced, or obsoleted by other documents at any time.
It is inappropriate to use Internet-Drafts as reference material or to cite
them other than as &ldquo;work in progress.&rdquo;</p>
<p>
The list of current Internet-Drafts can be accessed at
<a href='http://www.ietf.org/ietf/1id-abstracts.txt'>http://www.ietf.org/ietf/1id-abstracts.txt</a>.</p>
<p>
The list of Internet-Draft Shadow Directories can be accessed at
<a href='http://www.ietf.org/shadow.html'>http://www.ietf.org/shadow.html</a>.</p>
<p>
This Internet-Draft will expire on November 4, 2009.</p>

<h3>Copyright Notice</h3>
<p>
Copyright (c) 2009 IETF Trust and the persons identified as the
document authors.  All rights reserved.</p>
<p>
This document is subject to BCP 78 and the IETF Trust's Legal
Provisions Relating to IETF Documents in effect on the date of
publication of this document (http://trustee.ietf.org/license-info).
Please review these documents carefully, as they describe your
rights and restrictions with respect to this document.</p>

<h3>Abstract</h3>

<p>
        This draft describes some circumstances that are common in SIP
        deployments which lack a rigorous authorization model, and points
        out some ways in which this has resulted in poor security
        characteristics. 
      
</p>
<p>
        The purpose of this document is to stimulate discussion of the
        identified problem and proposed requirements for any solution.
      
</p>
<p>
        Comments are solicited, and should be directed to the DISPATCH
        working group list at 'dispatch@ietf.org'.
      
</p><a name="toc"></a><br /><hr />
<h3>Table of Contents</h3>
<p class="toc">
<a href="#intro">1.</a>&nbsp;
Introduction<br />
<a href="#problem">2.</a>&nbsp;
Problem Description<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor1">2.1.</a>&nbsp;
Authentication vs Authorization<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor2">2.2.</a>&nbsp;
The Locality of Authority and Enforcement<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor3">2.2.1.</a>&nbsp;
User Agent Based Authorization Scales Poorly<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#delivery">2.2.2.</a>&nbsp;
Request Delivery as an Authorization Indication<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#examples">2.3.</a>&nbsp;
Examples of Distributed Authorization and Enforcement in SIP<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#example.dialog-event">2.3.1.</a>&nbsp;
Dialog Event Subscriptions<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#example.invite.gateway">2.3.2.</a>&nbsp;
INVITE at a PSTN Gateway<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#example.join">2.3.3.</a>&nbsp;
INVITE with Join<br />
<a href="#requirements">3.</a>&nbsp;
Candidate Solution Requirements<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#ThirdParty">3.1.</a>&nbsp;
Authorizing Third Party Requirements<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor4">3.1.1.</a>&nbsp;
Third Party Topologies<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor5">3.2.</a>&nbsp;
Authorization and Integrity Protection<br />
<a href="#anchor6">4.</a>&nbsp;
IANA Considerations<br />
<a href="#anchor7">5.</a>&nbsp;
Security Considerations<br />
<a href="#anchor8">6.</a>&nbsp;
Acknowledgments<br />
<a href="#rfc.references1">7.</a>&nbsp;
Informative References<br />
<a href="#rfc.authors">&#167;</a>&nbsp;
Author's Address<br />
</p>
<br clear="all" />

<a name="intro"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1"></a><h3>1.&nbsp;
Introduction</h3>

<p>
        This draft attempts to make the case that SIP lacks a mechanism
        needed to provide for the implementation and enforcement of
        security policy in typical deployments.  It's purpose is to present
        the problem, outline some requirements for a solution, and to pose
        the question of whether or not is is an area the IETF community
        considers worth designing solutions for.
      
</p>
<p>
        This draft does not propose any mechanisms to address the problem
        it describes; it also does not comprehensively evaluate the
        relevance of existing SIP security mechanisms (either standardize
        or proposed) in addressing this problem.  Both are possible areas
        for future work.
      
</p>
<a name="problem"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2"></a><h3>2.&nbsp;
Problem Description</h3>

<p>
        The Session Initiation Protocol (SIP) <a class='info' href='#RFC3261'>[RFC3261]<span> (</span><span class='info'>Rosenberg, J., Schulzrinne, H., Camarillo, G., Johnston, A., Peterson, J., Sparks, R., Handley, M., and E. Schooler, &ldquo;SIP: Session Initiation Protocol,&rdquo; June&nbsp;2002.</span><span>)</span></a>, by
        design, distributes functionality broadly throughout the network -
        it is often characterised as "pushing intellegence out to the
        edge".  This sometimes means that important security policy
        enforcement must also be distributed.  SIP currently lacks some
        features that facilitate this distribution of security enforcement.
      
</p>
<a name="anchor1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2.1"></a><h3>2.1.&nbsp;
Authentication vs Authorization</h3>

<p>
          It is important when considering the problems described in this
          memo to keep in mind the difference between Authentication and
          Authorization:
          </p>
<blockquote class="text"><dl>
<dt>Authentication</dt>
<dd>
              
              is the process of confirming some identity.
            
</dd>
<dt>Authorization</dt>
<dd>
              
              is the process of deciding whether or not something is
              permitted by a security policy.
            
</dd>
</dl></blockquote><p>
          Usually an Authorization decision depends upon an Authentication.
          For example, if Alice tries to call Bob and a proxy between them
          is deciding whether or not to allow the call, it must first
          Authenticate that the request is from Alice, and then consult the
          policy to see whether or not Alice is Authorized to make calls to
          Bob.

          </p>
<blockquote class="text">
<p>
              It is an unfortunate historical error that the header name used
              to carry Authentication information in a SIP (or HTTP) request
              is named "Authorization", which only increases the confusion
              between these two concepts.
            
</p>
</blockquote><p>
        
</p>
<p>
          In the remainder of this document, the modifier "Authorizing" is
          applied to various entities to designate the party that is making
          an Authorization decision - consulting a security policy and any
          relevant information - to determine whether or not a SIP request
          is permitted by the policy.
        
</p>
<a name="anchor2"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2.2"></a><h3>2.2.&nbsp;
The Locality of Authority and Enforcement</h3>

<p>
          In a distributed system, the ultimate enforcement of a security
          policy is best implemented as closely as possible to the object
          of that policy.  In less abstract terms: if the goal of a policy
          is to control access to a resource, then the ultimate enforcement
          of whether or not to grant access to the resource is best made by
          an entity local to that resource.  Any separation between the
          resource that is the object of the policy and the entity
          implementing the enforcement of that policy introduces a gap
          which an attacker may be able to exploit.  Because it is not
          always possible to colocate the policy decision at the point of
          enforcement, it is sometimes necessary to have an Authorizing
          entity in one part of a distributed system that then conveys the
          appropriate decision to another at which the enforcement action
          takes place.
        
</p>
<p>
          In SIP, the optimal enforcement point is often at either the
          ultimate UAS that is the target of a request, or at an 
          Intermediate Entity whose role includes the enforcement of policy
          at the edge of an administrative domain.  In this document, the
          term:
          </p>
<blockquote class="text"><dl>
<dt>Intermediate Entity</dt>
<dd>
              
              is used to mean any SIP entity that receives SIP requests and
              sends requests somehow related to those received requests to
              other targets.  The term includes Proxies, Application
              Servers, Back To Back User Agents, and any other entity that
              acts as forwarding or translating entity with SIP on both
              "sides".
            
</dd>
</dl></blockquote><p>
          However, these systems, and especially User Agents, are often not
          the appropriate place to actually make the Authorization
          decision.  For various reasons it is sometimes appropriate to
          make the Authorization decision somewhere other than the point of
          enforcement, and in these cases at present SIP lacks a standard
          means to convey the results of that decision.
        
</p>
<p>
          Most specifications of SIP mechanisms expect that a request will
          be subjected to an authorization decision by the receiving User
          Agent Server.  If the Alice's UA sends a request to Bob's UA, it
          is Bob's UA that decides (presumably after authenticating that the
          request is really from Alice) whether or not Alice should be
          allowed whatever access the request requires.  This model is the
          correct one in many cases, especially those in which the actual
          authorization decision can be made by the human user: if the
          request is for Bob's presence information, the UA can let Bob
          decide whether Alice should be allowed to see his presence and
          respond appropriately.
        
</p>
<p>
          Using the user to make the authorization decision is not always
          appropriate, however - it fits poorly or not at all when:

          </p>
<blockquote class="text"><dl>
<dt>There is no way to consult a user</dt>
<dd>
              <br />

              Many kinds of UAs either don't have a "user" to consult (such
              as a PSTN gateway or a ceiling-mounted paging system
              speaker), or don't have a user interface adequate to
              construct a query (an ATA).
            
</dd>
<dt>Consulting the user is the wrong thing to do</dt>
<dd>
              <br />

              The nature of the request may be such that consulting the
              user would be counter to the nature of the request.  If the
              request is that Alice, a call center manager, be silently
              conferenced in order to monitor a call between a customer and
              Bob, a service representative under her supervision, then
              alerting Bob that Alice wishes to listen to the call would
              defeat the purpose.
            
</dd>
<dt>Asking the user would be ambiguous</dt>
<dd>
              <br />

              The request might be such that the user either could not
              understand the question or be such that the user cannot
              reasonably be expected to understand why permission should be
              granted.  If Bob were asked whether or not Alice should be
              allowed to receive dialog event notices regarding the call he
              is on now, he would probably not understand the question and
              be annoyed at the interruption of his call; he could not tell
              whether this was in support of a future request to Join the
              call, a future request that Alice be able to call him when he
              becomes available, or just in support of lighting the Busy
              Lamp for his line on Alice's phone.
            
</dd>
</dl></blockquote><p>
        
</p>
<a name="anchor3"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2.2.1"></a><h3>2.2.1.&nbsp;
User Agent Based Authorization Scales Poorly</h3>

<p>
            Placing the authorization decision in the ultimate User Agent
            Server suffers from a scaling problem: the size and complexity
            of the authorization decision scales with the number of
            possible interactions.  While Bob's UA may be able to
            authenticate that a particular request came from Alices UA, if
            Alice and Bob are in a large administrative domain, the problem
            of deciding which users in that domain are authorized to make
            which requests grows too large to reasonably implement inside
            many UAs.  Even if the problem is just one of storing the
            appropriate access control lists, it is not reasonable to
            replicate the lists into all UAs (and perhaps not desirable
            from a security perspective, since this decreases the security
            of the lists themselves).
          
</p>
<p>
            Even aside from the problem of database sizes that may be
            required for authorization decisions in the ultimate UAS, the
            non-uniformity of facilities in UAS makes central control of
            security policy impractical.  If an organization wishes to
            create a security policy for a particular kind of request, the
            capabilities offered by UAs are too limited for any but the
            most primitive of possiblities (and often not even that).
            For example, one might want to make different rules for whether
            a particular request be allowed at one time of day but not at
            another.  Since few UAs will have that capability (and since
            the means of expressing it probably vary even among those that
            did), an organization that needed such a policy would have to
            make the authorization decision elsewhere, but other than
            preventing delivery of the request, there is no standard way to
            communicate the result of that authorization decision to the
            UAS.
          
</p>
<a name="delivery"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2.2.2"></a><h3>2.2.2.&nbsp;
Request Delivery as an Authorization Indication</h3>

<p>
            Today, authorization control that is not local to the target
            UAS usually takes the form of delivery control: an Intermediate
            entity makes an authorization decision and either delivers the
            request onwards toward the target UAS or rejects it.  The fact
            that the target UAS recieves the request from the authorizing
            entity is the indication that the request has been authorized.
            There are a number of problems with this as a security policy
            enforcement architecture:

            </p>
<blockquote class="text"><dl>
<dt>Passive participation by the recipient</dt>
<dd>
                <br />

                In many cases, the agent that is the recipient of the
                "authorized" request is not enforcing the requirement that
                the request be processed by the authorizing entity.  It
                will act on any request it receives, and only the fact that
                the rest of the well behaved requestors will route through
                the Authorizing Intermediate allows the security policy to
                be enforced at all.  An attacker who can find a way to
                route requests such that they do not pass through the
                Authorizing entity will find the target UAS happy to accept
                them.
              
</dd>
<dt>Use of IP addresses as authenticators</dt>
<dd>
                <br />

                The most common form that "delivery as authorization" takes
                is that the IP address(es) of one or more Authorizing
                Intermediates is configured into the UAS such that only
                requests from those Intermediates are to be considered to
                have been authorized.  Most often, the UAS uses the peer
                address from the UDP or TCP level as the authentication
                indication.  Since techniques for spoofing IP addresses are
                well known, this is a very weak basis upon which to build
                any security.  In some particularly weak implementations,
                the presence of an IP address value in the Via headers has
                been seen to be used as an authenticator; this does not
                even merit further discussion.
              
</dd>
<dt>TLS peer authentication</dt>
<dd>
                <br />

                A much stronger but unfortunately less common version of
                "delivery as authorization" is the use of a mutually
                authenticated TLS transport between an Intermediate and the
                point of enforcement.  This has the advantage that it is
                based on the identities in the certificates, so given a
                usable certificate infrastructure and good implementations,
                at least the authentication component of the decision is a
                strong one.  This solution is especially well suited to
                authorizing requests as they cross a boundary between one
                administrative domain and another (such as between an
                enterprise and a telephony service provider).  It is,
                however, limited by the fact that it only allows one degree
                of separation between the Authorizing entity and the
                Enforcing entity - they may not be more than a single SIP
                hop apart for this to be a usable authorization indication.
                It is also worth noting that even in this limited
                deployment mode, there is no well-defined indication
                included in the SIP signalling that explicitly communicates
                that a particular message has been authorized by the
                sender; the indication is always implicit.
              
</dd>
</dl></blockquote><p>

            This last problem - the fact that for delivery to work as an
            authorization indication, the authorizing and enforcing
            entities must be adjacent - creates another more subtle
            architectural problem.  The requirement for adjacency
            interferes with a property of SIP that is otherwise one of its
            great strengths: that a proxy (or other well-behaved
            Intermediate) need not understand every aspect of the requests
            and responses it forwards.  It is this property that allows
            User Agents to evolve new capabilities, and, so long as they
            are able to find other UAs with complementary features, to use
            those capabilities without the SIP routing fabric between them
            needing to be upgraded.  If there is a security property of
            some new capability, and authorization decisions appropriate to
            that new capability are not easily implementable in the
            originating and terminating UAs themselves, then there is only
            one place in the SIP routing fabric where the authorization
            decision can be placed: adjacent to the target UAS.
          
</p>
<a name="examples"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2.3"></a><h3>2.3.&nbsp;
Examples of Distributed Authorization and Enforcement in SIP</h3>

<p>
            The following are examples of SIP operations that currently
            suffer from poor security properties in many deployments and/or
            are not well supported by User Agents in part because providing
            appropriate security is problematic.  It is by no means an
            exhaustive list.
          
</p>
<a name="example.dialog-event"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2.3.1"></a><h3>2.3.1.&nbsp;
Dialog Event Subscriptions</h3>

<p>
            The dialog event package <a class='info' href='#RFC4235'>[RFC4235]<span> (</span><span class='info'>Rosenberg, J., Schulzrinne, H., and R. Mahy, &ldquo;An INVITE-Initiated Dialog Event Package for the Session Initiation Protocol (SIP),&rdquo; November&nbsp;2005.</span><span>)</span></a>:
            </p>
<blockquote class="text">
<p>
                allows users to subscribe to another
                user and to receive notification of the changes in state of INVITE-
                initiated dialog usages in which the subscribed-to user is involved.
              
</p>
</blockquote><p>
            A SUBSCRIBE request <a class='info' href='#RFC3265'>[RFC3265]<span> (</span><span class='info'>Roach, A., &ldquo;Session Initiation Protocol (SIP)-Specific Event Notification,&rdquo; June&nbsp;2002.</span><span>)</span></a> for the "dialog"
            package allows the requesting UA to ask for NOTIFY messages
            that include the dialog state and identifiers (call-id and tag
            values) for, potentially, all dialogs at the recieving UA.
            There are many legitimate purposes for such a request, since
            they are needed to implement a number of desirable features in
            a distributed communications system.  However, the SUBSCRIBE
            request does not communicate what feature the request is being
            made to support, nor can the NOTIFY communicating the dialog
            information restrict the purposes for which it is used.  The
            dialog package specification includes some recommendations on
            how to construct security policies in a UAS so as to restrict
            access to dialog identifiers and other sensitive information,
            but because leaving out parts of the information would often
            disable desired features in a distributed system, it is common
            for implementations to include all the dialog information, and
            to accept any requests they receive (in effect passively
            implementing a request delivery authorization policy as
            described in <a class='info' href='#delivery'>Section&nbsp;2.2.2<span> (</span><span class='info'>Request Delivery as an Authorization Indication</span><span>)</span></a>).
          
</p>
<p>
            <a class='info' href='#RFC4538'>[RFC4538]<span> (</span><span class='info'>Rosenberg, J., &ldquo;Request Authorization through Dialog Identification in the Session Initiation Protocol (SIP),&rdquo; June&nbsp;2006.</span><span>)</span></a> defines the SIP Target-Dialog header field
            </p>
<blockquote class="text">
<p>
                This header field is used in requests that create SIP
                dialogs.  It indicates to the recipient that the sender is aware of
                an existing dialog with the recipient, either because the sender is
                on the other side of that dialog, or because it has access to the
                dialog identifiers.  The recipient can then authorize the request
                based on this awareness.
              
</p>
</blockquote><p>
            This authorization by awareness of dialog identifiers is used
            in many SIP services, so having weak authorization mechanisms
            in the UASes responsible for those identifiers creates
            vulnerabilities elsewhere.
          
</p>
<a name="example.invite.gateway"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2.3.2"></a><h3>2.3.2.&nbsp;
INVITE at a PSTN Gateway</h3>

<p>
            One of the most common operations in SIP telephony is the
            gateway function - receiving a SIP INVITE request and using the
            information in it to initiate a PSTN call setup request.
            Because a PSTN call is often a potentially expensive billable
            event, enforcement of access control is important.  In many
            (perhaps most) SIP telephony deployments, the actual
            authorization decision is not implemented in the gateway
            itself, but in some Intermediate system between the requesting
            UAC and the gateway; gateways typically implement at most a
            request delivery authorization policy as described in <a class='info' href='#delivery'>Section&nbsp;2.2.2<span> (</span><span class='info'>Request Delivery as an Authorization Indication</span><span>)</span></a>.
          
</p>
<a name="example.join"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2.3.3"></a><h3>2.3.3.&nbsp;
INVITE with Join</h3>

<p>
            <a class='info' href='#RFC3911'>[RFC3911]<span> (</span><span class='info'>Mahy, R. and D. Petrie, &ldquo;The Session Initiation Protocol (SIP) &quot;Join&quot; Header,&rdquo; October&nbsp;2004.</span><span>)</span></a> defines the Join header field "to logically
            join an existing SIP dialog with a new SIP dialog"; the
            specification notes that:
            </p>
<blockquote class="text">
<p>
                This primitive can be used to enable a variety of features,
                for example: "Barge-In", answering-machine-style "Message
                Screening" and "Call Center Monitoring".
              
</p>
</blockquote><p>
            The Join mechanism is a good example of a primitive that,
            depending on the service it is being used to implement, can
            have very different authorization requirements - but the UAS
            may not be able to easily distinguish what the service is and
            therefor know which to requirements to apply.  A simple example
            is an INVITE-with-Join request received by a phone, containing
            SDP that requests that the joining phone receive media but not
            provide any to be mixed into the call: this request may have
            resulted from
            </p>
<ul class="text">
<li>
                The human User using the receiving UAS may have (through
                out-of-band means) asked a colleague to listen to the call
                so as to provide advice or to be available as a
                witness to what transpired on a sensitive call.
              
</li>
<li>
                The request may come from that Users supervisor in order to
                determine (as allowed by the management policies that
                govern their relationship) whether or not the User is
                conducting the call appropriately.
              
</li>
</ul><p>
            At the protocol level, these two requests may be
            indistinguishable, but in the former case it would be
            appropriate for the UAS to query the user to authorize the Join
            request (and useful to that User to receive an indication that
            the monitoring has begun), while in the latter case it would
            defeat the purpose of the request to do so.  In any case, it
            would clearly be inappropriate for a phone to unconditionally
            and without notice accept any such request.
          
</p>
<a name="requirements"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3"></a><h3>3.&nbsp;
Candidate Solution Requirements</h3>

<p>
        This draft argues that SIP would be improved by a mechanism that
        allowed for a small number of entities in a given deployment to
        make Authorization decisions with respect to SIP requests according
        to a locally defined policy, and have a secure means of
        communicating that a given has been authorized.  This would allow
        other SIP entities (whether Intermediate Systems or User Agent
        Servers) to make very simple enforcement decisions based on whether
        or not a request had been authorized by an authority they
        recognize.  The complexity of the security configuration for most
        SIP entities would be reduced to recognition and validation of a
        small number of valid authorizors.
      
</p>
<p>
        This section proposes some requirements that any solution would
        need to meet in order to address the problem described in <a class='info' href='#problem'>Section&nbsp;2<span> (</span><span class='info'>Problem Description</span><span>)</span></a> and be usable and incrementally deployable in
        existing SIP usage.
      
</p>
<p>
        </p>
<blockquote class="text">
<p>
            The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD",
            "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be
            interpreted as described in <a class='info' href='#RFC2119'>RFC-2119<span> (</span><span class='info'>Bradner, S., &ldquo;Key words for use in RFCs to Indicate Requirement Levels,&rdquo; March&nbsp;1997.</span><span>)</span></a> [RFC2119].
          
</p>
</blockquote><p>
      
</p>
<p>
        These proposed requirements use the following terms (the
        definitions of which are admittedly somewhat vague):

        </p>
<blockquote class="text"><dl>
<dt>Authorization Indication</dt>
<dd>
            
            The information incorporated into a SIP message that
            indicates that a request is authorized within some security
            policy.  No specific forms are suggested for Authorization
            Indications in this draft.
          
</dd>
<dt>Authorizing Third Party</dt>
<dd>
            
            Any implementation that can receive a SIP message generated by
            some originating UAC, evaluate that request with respect to
            some security policy, and generate an Authorization Indication
            to be incorporated into some other SIP message such that a
            later recipient of that SIP message or one derived from it can
            be assured that the request is allowed under the security
            policy.
          
</dd>
</dl></blockquote><p>
      
</p>
<a name="ThirdParty"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.1"></a><h3>3.1.&nbsp;
Authorizing Third Party Requirements</h3>

<p>
          SIP deployments often contain many different 'types' of
          implementations: some, like User Agents and Proxies, that are
          well defined by the existing formal specifications, and others
          that are less rigorously defined but meet practical needs and are
          essential to functionality required by end users.  This reality
          must be recognized in order for any solution to be deployable in
          real (rather than just hypothetical architecturally "pure") SIP
          networks.  This implies that the definition of an Authorizing
          Third Party is very flexible:

          The following are suggested requirements relating to which
          implementation roles can act as an Authorizing Third Party:

          </p>
<blockquote class="text"><dl>
<dt>R1</dt>
<dd>
              It MUST be possible for a UAS to act as an Authorizing Third
              Party, incorporating an Authorization Indication in a
              response (see <a class='info' href='#redirector-pattern'>Figure&nbsp;2<span> (</span><span class='info'>Authorizing Redirector</span><span>)</span></a> and
              <a class='info' href='#redirector-intermediate-pattern'>Figure&nbsp;3<span> (</span><span class='info'>Authorizing Redirection At Intermediate</span><span>)</span></a>).
            
</dd>
<dt>R2</dt>
<dd>
              It MUST be possible for a Proxy to act as an Authorizing Third Party,
              incorporating an Authorization Indication in requests it
              forwards (see <a class='info' href='#intermediate-pattern'>Figure&nbsp;1<span> (</span><span class='info'>Authorizing Intermediate</span><span>)</span></a> and
              <a class='info' href='#redirector-intermediate-pattern'>Figure&nbsp;3<span> (</span><span class='info'>Authorizing Redirection At Intermediate</span><span>)</span></a>).
            
</dd>
<dt>R3</dt>
<dd>
              It MUST be possible for other non-Proxy intermediate systems,
              such as Back-To-Back User Agents to act as an Authorizing Third
              Party, incorporating an Authorization Indication in requests
              they forward.
            
</dd>
</dl></blockquote><p>

          The following are suggested requirements relating to the kinds
          of SIP messages a Third Party Authentication could be used with:

          </p>
<blockquote class="text"><dl>
<dt>R4</dt>
<dd>
              It MUST be possible to include an Authorization
              Indication in a REFER request such that when the UA that
              is the target of the REFER makes a request as directed by
              the REFER, that new request can include an Authorization
              Indication (see <a class='info' href='#refer-pattern'>Figure&nbsp;4<span> (</span><span class='info'>Authorizing Referror</span><span>)</span></a>).
            
</dd>
<dt>R5</dt>
<dd>
              It MUST be possible to include an Authorization Indication in
              both dialog-forming and in-dialog requests.
            
</dd>
</dl></blockquote><p>
        
</p>
<a name="anchor4"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.1.1"></a><h3>3.1.1.&nbsp;
Third Party Topologies</h3>

<p>
            In real SIP networks, Intermediate entites can appear in
            unexpected places - a solution that does not recognize that
            fact will not be useful.

            </p>
<blockquote class="text"><dl>
<dt>R6</dt>
<dd>
                It MUST be possible for an Authorization Indication to be
                usefully forwarded by an Intermediate system that does not
                implement the Third Party Authorization mechanisms.  
              
</dd>
</dl></blockquote><p>

            The requirement above does NOT mean that it must be possible to
            forward any Authorization Indication through any intermediate
            system at all and always be useful - such a requirement would not be
            possible to meet.  The objective is that at least "well
            behaved" intermediates have some chance of forwarding; defining
            "well behaved" in this context will be an important part of
            evaluating any proposed mechanism.
          
</p>
<p>
            <a class='info' href='#intermediate-pattern'>Figure&nbsp;1<span> (</span><span class='info'>Authorizing Intermediate</span><span>)</span></a> illustrates a topology in which an
            Intermediate system adds the authorizing information, changing
            the original request (r1) into the authorized request (ar):
            <br /><hr class="insert" />
<a name="intermediate-pattern"></a>
</p>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
       +----\  \-------+              +----\  \-------+
   +--&gt;|    other      &gt;--r1-+    +--&gt;|    other      &gt;--ar-+
   |   | intermediates |     |    |   | intermediates |     |
   |   +-----\  \------+     |    |   +-----\  \------+     |
  r1                         |   ar                         |
   |                         V    |                         V
+--^--------------+     +--------------+       +---------------+
| Originating UAC |     | Authorizing  |       | Enforcing UAS |
+-----------------+     | Intermediate |       +---------------+
                        +--------------+

</pre></div><p>
<table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;1: Authorizing Intermediate&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

          
</p>
<p>
            <a class='info' href='#redirector-pattern'>Figure&nbsp;2<span> (</span><span class='info'>Authorizing Redirector</span><span>)</span></a> illustrates a topology in which a
            Redirecting system includes the authorizing information in a
            redirect (3xx) response (r1r) to the original request (r1),
            causing the UAC to generate the authorized request (ar):

            <br /><hr class="insert" />
<a name="redirector-pattern"></a>
</p>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
+--------------+
| Authorizing  |
| Redirector   |
+--------------+
    ^     |
   r1    r1r
    |     V
+-----------------+       +----\  \-------+       +---------------+
| Originating UAC |--ar--&gt;|    other      &gt;--ar--&gt;| Enforcing UAS |
+-----------------+       | intermediates |       +---------------+
                          +-----\  \------+

</pre></div><p>
<table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;2: Authorizing Redirector&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

          
</p>
<p>
            <a class='info' href='#redirector-intermediate-pattern'>Figure&nbsp;3<span> (</span><span class='info'>Authorizing Redirection At Intermediate</span><span>)</span></a> combines
            elements of the previous two topologies; the Originating UAC
            sends the original request (r1) to an Intermediate system,
            which then sends a request (r2) to a Redirecting system (r2),
            which then adds the authorizing information to its redirect
            (3xx) response (r2r), causing the Intermediate system to
            generate the authorized request (ar).  Either the r1 path or
            the ar path might contain other intermediates.

            <br /><hr class="insert" />
<a name="redirector-intermediate-pattern"></a>
</p>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
                           +--------------+
                           | Authorizing  |
                           | Redirector   |
                           +--------------+
                               ^     |
                              r2    r2r
                               |     V
+-----------------+       +----\  \-------+       +---------------+
| Originating UAC |--r1--&gt;|    other      &gt;--ar--&gt;| Enforcing UAS |
+-----------------+       | intermediates |       +---------------+
                          +-----\  \------+



</pre></div><p>
<table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;3: Authorizing Redirection At Intermediate&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

          
</p>
<p>
            <a class='info' href='#refer-pattern'>Figure&nbsp;4<span> (</span><span class='info'>Authorizing Referror</span><span>)</span></a> illustrates a topology in which the
            Originating UAC incorporates an Authorization Indication into a
            REFER request sent to some other UAC.  The Referred UAC incorporates the
            Authorization Indication into the resulting request (ar), 
            communicating to the Enforcing UAS that the Originating UAC
            authorized the request.
            <br /><hr class="insert" />
<a name="refer-pattern"></a>
</p>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
+--------------+
| Originating  |
|  UAC         |
+--------------+
    |
   REFER
    |
    V
+--------------+       +----\  \-------+       +---------------+
| Referred UAC |--ar--&gt;|    other      &gt;--ar--&gt;| Enforcing UAS |
+--------------+       | intermediates |       +---------------+
                       +-----\  \------+

</pre></div><p>
<table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;4: Authorizing Referror&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

          
</p>
<a name="anchor5"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.2"></a><h3>3.2.&nbsp;
Authorization and Integrity Protection</h3>

<p>
          It is tempting to suggest the requirement that it be impossible
          for an attacker to modify a SIP message containing an
          Authorization Indication, or to copy an Authorization Indication
          from one SIP message to another without detection.
          Unfortunately, it is an integral part of the SIP architecture
          that SIP messages are modified as they move from one system to
          another; these modifications are not only unavoidable but
          essential to the correct operation of the SIP protocol as
          currently defined.  There are also important use cases (see <a class='info' href='#refer-pattern'>Figure&nbsp;4<span> (</span><span class='info'>Authorizing Referror</span><span>)</span></a>) in which an Authorization Indication is
          explicitly meant to be copied from one request to another.  The
          following requirements for message integrity protection are
          suggested:

          </p>
<blockquote class="text"><dl>
<dt>R7</dt>
<dd>
              It MUST be possible for an Authorization Indication to
              include integrity protection of the parts of a request
              that it authorizes.
            
</dd>
<dt>R8</dt>
<dd>
              It MUST be possible for an Intermediate system to detect
              what parts of a request are integrity protected so that
              the Intermediate system can either avoid changing the
              protected parts or return an error that indicates that
              the request cannot be satisified because of the
              protection.
            
</dd>
<dt>R9</dt>
<dd>
              It MUST be possible for an Enforcing system to determine
              what parts of a request are integrity protected by the
              Authorization Indication and what parts are not.
            
</dd>
<dt>R10</dt>
<dd>
              It MUST be possible for an Enforcing system to determine
              the identity of the party that provided the Authorization
              Indication as distinct from the Originating UAC.
            
</dd>
</dl></blockquote><p>
        
</p>
<a name="anchor6"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4"></a><h3>4.&nbsp;
IANA Considerations</h3>

<p>
        None until a solution is described.
      
</p>
<a name="anchor7"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5"></a><h3>5.&nbsp;
Security Considerations</h3>

<p>
        This memo attempts to make the case that the current definition and
        deployment of the Session Inition Protocol is missing a mechanism
        important to appropriately secured operation in at least many of
        the environments in which it is used.  <a class='info' href='#requirements'>Section&nbsp;3<span> (</span><span class='info'>Candidate Solution Requirements</span><span>)</span></a> attempts to bound a solution space,
        and as such should be read carefully to determine whether or not
        appropriate goals have been described.
      
</p>
<a name="anchor8"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6"></a><h3>6.&nbsp;
Acknowledgments</h3>

<p>
        The author would like to thank Hadriel Kaplan, 
        Michael Procter, Mary Barnes, and Marek Dutkiewicz for invaluable
        feedback on pre-publication drafts of this document.
      
</p>
<a name="rfc.references1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>7.&nbsp;Informative References</h3>
<table width="99%" border="0">
<tr><td class="author-text" valign="top"><a name="RFC2119">[RFC2119]</a></td>
<td class="author-text"><a href="mailto:sob@harvard.edu">Bradner, S.</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>,&rdquo; BCP&nbsp;14, RFC&nbsp;2119, March&nbsp;1997 (<a href="ftp://ftp.isi.edu/in-notes/rfc2119.txt">TXT</a>, <a href="http://xml.resource.org/public/rfc/html/rfc2119.html">HTML</a>, <a href="http://xml.resource.org/public/rfc/xml/rfc2119.xml">XML</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC3261">[RFC3261]</a></td>
<td class="author-text">Rosenberg, J., Schulzrinne, H., Camarillo, G., Johnston, A., Peterson, J., Sparks, R., Handley, M., and E. Schooler, &ldquo;<a href="http://tools.ietf.org/html/rfc3261">SIP: Session Initiation Protocol</a>,&rdquo; RFC&nbsp;3261, June&nbsp;2002 (<a href="ftp://ftp.isi.edu/in-notes/rfc3261.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC3265">[RFC3265]</a></td>
<td class="author-text">Roach, A., &ldquo;<a href="http://tools.ietf.org/html/rfc3265">Session Initiation Protocol (SIP)-Specific Event Notification</a>,&rdquo; RFC&nbsp;3265, June&nbsp;2002 (<a href="ftp://ftp.isi.edu/in-notes/rfc3265.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC3911">[RFC3911]</a></td>
<td class="author-text">Mahy, R. and D. Petrie, &ldquo;<a href="http://tools.ietf.org/html/rfc3911">The Session Initiation Protocol (SIP) "Join" Header</a>,&rdquo; RFC&nbsp;3911, October&nbsp;2004 (<a href="ftp://ftp.isi.edu/in-notes/rfc3911.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4235">[RFC4235]</a></td>
<td class="author-text">Rosenberg, J., Schulzrinne, H., and R. Mahy, &ldquo;<a href="http://tools.ietf.org/html/rfc4235">An INVITE-Initiated Dialog Event Package for the Session Initiation Protocol (SIP)</a>,&rdquo; RFC&nbsp;4235, November&nbsp;2005 (<a href="ftp://ftp.isi.edu/in-notes/rfc4235.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4538">[RFC4538]</a></td>
<td class="author-text">Rosenberg, J., &ldquo;<a href="http://tools.ietf.org/html/rfc4538">Request Authorization through Dialog Identification in the Session Initiation Protocol (SIP)</a>,&rdquo; RFC&nbsp;4538, June&nbsp;2006 (<a href="ftp://ftp.isi.edu/in-notes/rfc4538.txt">TXT</a>).</td></tr>
</table>

<a name="rfc.authors"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>Author's Address</h3>
<table width="99%" border="0" cellpadding="0" cellspacing="0">
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Scott Lawrence</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Nortel Networks, Inc.</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">600 Technology Park</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Billerica, MA  01821</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">USA</td></tr>
<tr><td class="author" align="right">Phone:&nbsp;</td>
<td class="author-text">+1 978 288 5508</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:scott.lawrence@nortel.com">scott.lawrence@nortel.com</a></td></tr>
</table>
</body></html>
