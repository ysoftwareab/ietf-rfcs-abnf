<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="en"><head><title>Operations Model for Router Keying</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="description" content="Operations Model for Router Keying">
<meta name="generator" content="xml2rfc v1.35 (http://xml.resource.org/)">
<meta name="viewport" content="width=600;" />
<style type='text/css'><!--
        body {
                font-family: verdana, charcoal, helvetica, arial, sans-serif;
                font-size: 85%;
		max-width: 60em; 
		color: #000; background-color: #FFF;
                margin: 2em;
        }
        h1, h2, h3, h4, h5, h6 {
                font-family: helvetica, monaco, "MS Sans Serif", arial, sans-serif;
                font-weight: bold; font-style: normal;
        }
        h1 { color: #900; background-color: transparent; text-align: right; }
        h3 { color: #333; background-color: transparent; }

        td.RFCbug {
                font-size: x-small; text-decoration: none;
                width: 30px; height: 30px; padding-top: 2px;
                text-align: justify; vertical-align: middle;
                background-color: #000;
        }
        td.RFCbug span.RFC {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: bold; color: #666;
        }
        td.RFCbug span.hotText {
                font-family: charcoal, monaco, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: normal; text-align: center; color: #FFF;
        }

        table.TOCbug { width: 30px; height: 15px; }
        td.TOCbug {
                text-align: center; width: 30px; height: 15px;
                color: #FFF; background-color: #900;
        }
        td.TOCbug a {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, sans-serif;
                font-weight: bold; font-size: x-small; text-decoration: none;
                color: #FFF; background-color: transparent;
        }

        td.header {
                font-family: arial, helvetica, sans-serif; font-size: x-small;
                vertical-align: top; width: 33%;
                color: #FFF; background-color: #666;
        }
        td.author { font-weight: bold; font-size: x-small; margin-left: 4em; }
        td.author-text { font-size: x-small; }

        /* info code from SantaKlauss at http://www.madaboutstyle.com/tooltip2.html */
        a.info {
                /* This is the key. */
                position: relative;
                z-index: 24;
                text-decoration: none;
        }
        a.info:hover {
                z-index: 25;
                color: #FFF; background-color: #900;
        }
        a.info span { display: none; }
        a.info:hover span.info {
                /* The span will display just on :hover state. */
                display: block;
                position: absolute;
                font-size: smaller;
                top: 2em; left: -5em; width: 15em;
                padding: 2px; border: 1px solid #333;
                color: #900; background-color: #EEE;
                text-align: left;
        }

        a { font-weight: bold; }
        a:link    { color: #900; background-color: transparent; }
        a:visited { color: #633; background-color: transparent; }
        a:active  { color: #633; background-color: transparent; }

        p { margin-left: 2em; margin-right: 2em; }
        p.copyright { font-size: x-small; }
        p.toc { font-size: 85%;
		max-width: 60em; 
		font-weight: bold; margin-left: 3em; }
        table.toc { margin: 0 0 0 3em; padding: 0; border: 0; vertical-align: text-top; }
        td.toc { font-size: 85%;
		max-width: 60em; 
		font-weight: bold; vertical-align: text-top; }

        ol.text { margin-left: 2em; margin-right: 2em; }
        ul.text { margin-left: 2em; margin-right: 2em; }
        li      { margin-left: 3em; }

        /* RFC-2629 <spanx>s and <artwork>s. */
        em     { font-style: italic; }
        strong { font-weight: bold; }
        dfn    { font-weight: bold; font-style: normal; }
        cite   { font-weight: normal; font-style: normal; }
        tt     { color: #036; }
        tt, pre, pre dfn, pre em, pre cite, pre span {
                font-family: "Courier New", Courier, monospace; font-size: small;
        }
        pre {
                text-align: left; padding: 4px;
                color: #000; background-color: #CCC;
        }
        pre dfn  { color: #900; }
        pre em   { color: #66F; background-color: #FFC; font-weight: normal; }
        pre .key { color: #33C; font-weight: bold; }
        pre .id  { color: #900; }
        pre .str { color: #000; background-color: #CFF; }
        pre .val { color: #066; }
        pre .rep { color: #909; }
        pre .oth { color: #000; background-color: #FCF; }
        pre .err { background-color: #FCC; }

        /* RFC-2629 <texttable>s. */
        table.all, table.full, table.headers, table.none {
                font-size: 85%;
		max-width: 60em; 
		text-align: center; border-width: 2px;
                vertical-align: top; border-collapse: collapse;
        }
        table.all, table.full { border-style: solid; border-color: black; }
        table.headers, table.none { border-style: none; }
        th {
                font-weight: bold; border-color: black;
                border-width: 2px 2px 3px 2px;
        }
        table.all th, table.full th { border-style: solid; }
        table.headers th { border-style: none none solid none; }
        table.none th { border-style: none; }
        table.all td {
                border-style: solid; border-color: #333;
                border-width: 1px 2px;
        }
        table.full td, table.headers td, table.none td { border-style: none; }

        hr { height: 1px; }
        hr.insert {
                width: 80%; border-style: none; border-width: 0;
                color: #CCC; background-color: #CCC;
        }
--></style>
</head>
<body>
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<table summary="layout" width="66%" border="0" cellpadding="0" cellspacing="0"><tr><td><table summary="layout" width="100%" border="0" cellpadding="2" cellspacing="1">
<tr><td class="header">Network Working Group</td><td class="header">S. Hartman</td></tr>
<tr><td class="header">Internet-Draft</td><td class="header">Painless Security</td></tr>
<tr><td class="header">Intended status: Informational</td><td class="header">D. Zhang</td></tr>
<tr><td class="header">Expires: April 28, 2011</td><td class="header">Huawei</td></tr>
<tr><td class="header">&nbsp;</td><td class="header">October 25, 2010</td></tr>
</table></td></tr></table>
<h1><br />Operations Model for Router Keying<br />draft-hartman-karp-ops-model-01.txt</h1>

<h3>Abstract</h3>

<p>Developing an operational and management model for routing protocol security that works across protocols will be critical to the success of routing protocol security efforts. This document discusses issues and begins to consider development of these models.
</p>
<h3>Status of this Memo</h3>
<p>
This Internet-Draft is submitted  in full
conformance with the provisions of BCP&nbsp;78 and BCP&nbsp;79.</p>
<p>
Internet-Drafts are working documents of the Internet Engineering
Task Force (IETF).  Note that other groups may also distribute
working documents as Internet-Drafts.  The list of current
Internet-Drafts is at http://datatracker.ietf.org/drafts/current/.</p>
<p>
Internet-Drafts are draft documents valid for a maximum of six months
and may be updated, replaced, or obsoleted by other documents at any time.
It is inappropriate to use Internet-Drafts as reference material or to cite
them other than as &ldquo;work in progress.&rdquo;</p>
<p>
This Internet-Draft will expire on April 28, 2011.</p>

<h3>Copyright Notice</h3>
<p>
Copyright (c) 2010 IETF Trust and the persons identified as the
document authors.  All rights reserved.</p>
<p>
This document is subject to BCP 78 and the IETF Trust's Legal
Provisions Relating to IETF Documents
(http://trustee.ietf.org/license-info) in effect on the date of
publication of this document.  Please review these documents
carefully, as they describe your rights and restrictions with respect
to this document. Code Components extracted from this document must
include Simplified BSD License text as described in Section 4.e of
the Trust Legal Provisions and are provided without warranty as
described in the Simplified BSD License.</p>
<a name="toc"></a><br /><hr />
<h3>Table of Contents</h3>
<p class="toc">
<a href="#anchor1">1.</a>&nbsp;
Introduction<br />
<a href="#anchor2">2.</a>&nbsp;
Requirements notation<br />
<a href="#anchor3">3.</a>&nbsp;
Breakdown of KARP configuration<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor4">3.1.</a>&nbsp;
Integrity of the Key Table<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor5">3.2.</a>&nbsp;
Management of Key Table<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor6">3.3.</a>&nbsp;
Protocol Limitations from the Key Table<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor7">3.4.</a>&nbsp;
VRFs<br />
<a href="#anchor8">4.</a>&nbsp;
Credentials and Authorization<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#PRESHARED">4.1.</a>&nbsp;
Preshared Keys<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor9">4.2.</a>&nbsp;
Asymmetric Keys<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor10">4.3.</a>&nbsp;
Public Key Infrastructure<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor11">4.4.</a>&nbsp;
The role of Central Servers<br />
<a href="#anchor12">5.</a>&nbsp;
Grouping Peers Together<br />
<a href="#anchor13">6.</a>&nbsp;
Administrator Involvement<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor14">6.1.</a>&nbsp;
Enrollment<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor15">6.2.</a>&nbsp;
Handling Faults<br />
<a href="#anchor16">7.</a>&nbsp;
Upgrade Considerations<br />
<a href="#anchor17">8.</a>&nbsp;
Related Work<br />
<a href="#anchor18">9.</a>&nbsp;
Security Considerations<br />
<a href="#anchor19">10.</a>&nbsp;
Acknowledgments<br />
<a href="#rfc.references1">11.</a>&nbsp;
References<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#rfc.references1">11.1.</a>&nbsp;
Normative References<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#rfc.references2">11.2.</a>&nbsp;
Informative References<br />
<a href="#rfc.authors">&#167;</a>&nbsp;
Authors' Addresses<br />
</p>
<br clear="all" />

<a name="anchor1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1"></a><h3>1.&nbsp;
Introduction</h3>

<p>The KARP working group is designing improvements to the cryptographic authentication of IETF routing protocols. These improvements include improvements to how integrity functions are handled within each protocol as well as designing an automated key management solution.
</p>
<p>This document discusses issues to consider when thinking
      about the operational and management model for KARP. Each
      implementation will take its own approach to management; this is
      one area for vendor differentiation. However, it is desirable to
      have a common baseline for the management objects allowing
      administrators, security architects and protocol designers to
      understand what management capabilities they can depend on in
      heterogeneous environments. Similarly, designing and deploying
      the protocol will be easier with thought paid to a common
      operational model. This will also help with the design of
      NetConf schemas or MIBs later.
</p>
<a name="anchor2"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2"></a><h3>2.&nbsp;
Requirements notation</h3>

<p>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL",
            "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY",
            and "OPTIONAL" in this document are to be interpreted as
            described in <a class='info' href='#RFC2119'>[RFC2119]<span> (</span><span class='info'>Bradner, S., &ldquo;Key words for use in RFCs to Indicate Requirement Levels,&rdquo; March&nbsp;1997.</span><span>)</span></a>.
</p>
<a name="anchor3"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3"></a><h3>3.&nbsp;
Breakdown of KARP configuration</h3>

<p>There are multiple ways of structuring configuration
      information. One factor to consider is the scope of the
      configuration information. Several protocols are peer-to-peer routing protocols where
      a different key could potentially be used for each
      neighbor. Other protocols require the same group key to be used
      for all nodes in an administrative domain or routing area. In
      other cases, the same group key needs to be used for all routers
      on an interface, but different group keys can be used for each
      interface.
</p>
<p> Within situations where a per-interface,
      per-area or per-peer key can be used for manually configured
      long-term keys, that flexibility may not
      be desirable from an operational standpoint. For example
      consider OSPF [RFC2328]. Each OSPF link needs to use the same
      authentication configuration, including the set of keys used for
      reception and the set of keys used for transmission, but may use
      different keys for different links. The most general management
      model would be to configure keys per link. However for
      deployments where the area uses the same key it would be
      strongly desirable to configure the key as a property of the
      area. If the keys are configured per-link, they can get out of
      sync. In order to support generality of configuration and common
      operational situations, it would be desirable to have some sort of inheritance
      where default configurations are made per-area unless overridden
      per-interface.
</p>
<p>As described in <a class='info' href='#I-D.housley-saag-crypto-key-table'>[I&#8209;D.housley&#8209;saag&#8209;crypto&#8209;key&#8209;table]<span> (</span><span class='info'>Housley, R. and T. Polk, &ldquo;Database of Long-Lived Symmetric Cryptographic Keys,&rdquo; October&nbsp;2010.</span><span>)</span></a>, the cryptographic
      keys are separated from the interface configuration into their
      own configuration store. This document should specify how key
      selection interacts with the key table. One possible approach
      would be to assume that all keys that permit use on a given
      interface would be used on that interface. This model
      would need to be expanded in cases where keys are configured
      per-area or per-domain. It's not clear why "all" is permitted as
      an interface specification in this model; it seems unlikely that
      it would be desirable to use the same set of keys for two
      different instances of an IGP or across autonomous system
      boundaries. 
</p>
<p>Another model is that the interface
      specification in the key table is a restriction. Then a set of
      keys from the key table is attached to an interface, area or
      routing domain using an additional configuration step. This avoids the previous problems at the expense
      of significant complexity of configuration. 
</p>
<p>Operational
      Requirements: KARP MUST support configuration of keys at the
      most general scope for the underlying protocol; protocols
      supporting per-peer keys MUST permit configuration of per-peer
      keys, protocols supporting per-interface keys MUST support
      configuration of per-interface keys, and so on. KARP MUST NOT
      permit configuration of an inappropriate key scope. For example,
      configuration of separate keys per interface MUST NOT be
      supported for a protocol requiring per-area keys.
</p>
<a name="anchor4"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.1"></a><h3>3.1.&nbsp;
Integrity of the Key Table</h3>

<p>The routing key table <a class='info' href='#I-D.housley-saag-crypto-key-table'>[I&#8209;D.housley&#8209;saag&#8209;crypto&#8209;key&#8209;table]<span> (</span><span class='info'>Housley, R. and T. Polk, &ldquo;Database of Long-Lived Symmetric Cryptographic Keys,&rdquo; October&nbsp;2010.</span><span>)</span></a> provides a very
	general mechanism to abstract the storage of keys for routing
	protocols. To avoid misconfiguration and simplify problem
	determination, the router MUST verify the internal consistency
	of entries added to the table. At a minimum, the router MUST
	verify:
</p>
<ul class="text">
<li>The cryptographic algorithms are valid for the
	    protocol.
</li>
<li>The key derivation function is valid for the protocol.
</li>
<li>The direction is valid for the protocol; for example
	    protocols that require the same session key be used in
	    both directions MUST have a direction of both.
</li>
<li>The peer and interface specification is consistent with
	    the protocol.
</li>
</ul><p>

</p>
<p>Other checks are possible. For example the router could
	verify that if a key is associated with a peer, that peer is a
	configured peer for the specified protocol. However, this may
	be undesirable. It may be desirable to load a key table when
	some peers have not yet been configured. Also, it may be
	desirable to share portions of a key table across devices even
	when their current configuration does not require an adjacency
	with a particular peer in the interest of uniform
	configuration or preparing for fail-over. 
</p>
<a name="anchor5"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.2"></a><h3>3.2.&nbsp;
Management of Key Table</h3>

<p>Several management operations will be quite common. For
	service provider deployments the configuration management
	system can simply update the key table. However, for smaller
	deployments, efficient management operations are
	important.
</p>
<p>As part of adding a new key it is typically desirable to
	set an expiration time for an old key. The management
	interface SHOULD provide a mechanism to easily update the
	expiration time for a current key used with a given peer or
	interface. Also when adding a key it is desirable to push the
	key out to nodes that will need it, allowing use for receiving
	packets then later enabling transmit. This can be accomplished
	automatically by providing a delay between when a key becomes
	valid for reception and transmission. However, some
	environments may not be able to predict when all the necessary
	changes will be made. In these cases having a mechanism to
	enable a key for sending is desirable.
</p>
<a name="anchor6"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.3"></a><h3>3.3.&nbsp;
Protocol Limitations from the Key Table</h3>

<p>The format of the key table imposes a few limitations on
	routing protocols. The first is that the key ID is 16 bits;
	some routing protocols have 32-bit key identifiers. A key
	mapping table as discussed in 4.1 of <a class='info' href='#I-D.polk-saag-rtg-auth-keytable'>[I&#8209;D.polk&#8209;saag&#8209;rtg&#8209;auth&#8209;keytable]<span> (</span><span class='info'>Polk, T. and R. Housley, &ldquo;Routing Authentication Using A Database of Long-Lived Cryptographic Keys,&rdquo; July&nbsp;2010.</span><span>)</span></a> could be used to
	map to the larger key identifier. However it's probably
	desirable to either decide that only 16 bits of the key ID
	space is to be used or to expand the identifier space in the
	key table. From a management standpoint we need to make
	concrete requirements around whether a key ID is per-protocol
	or whether subspaces in the key ID space are reserved for each
	protocol. This is necessary so that implementations from
	different vendors can be managed consistently.
</p>
<p>The second requirement that the key table places is that
	the key ID is scoped fairly broadly. At least within some
	protocols such as OSPF, the key ID might only need to be
	unique per-link or per-peer. That is, packets sent on two different interfaces
	could use key ID 32 even if the keys were different for these interfaces. An implementation could use the interface and the key ID as a lookup to find the right key. However,
	the key table draft requires that a key ID be sufficient to
	look up a key, meaning that the key ID is a globally scoped
	identifier. There is nothing wrong with this restriction, but
	it does need to be noted when assigning key IDs for a
	domain. 
</p>
<p>Consideration is required for how an automated key
	management protocol will assign key IDs for group keys. All
	members of the group may need to use the same key ID. This
	requires careful coordination of global key IDs. Interactions
	with the peer key ID field may make this easier; this requires
	additional study.
</p>
<a name="anchor7"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.4"></a><h3>3.4.&nbsp;
VRFs</h3>

<p>Many core and enterprise routers support multiple routing
	instances. For example a router serving multiple VPNs is
	likely to have a forwarding/routing instance for each of these
	VPNs. We need to decide how the key table and other
	configuration information for KARP interacts with this. The
	obvious first-order answer is that each routing instance gets
	its own key table. However, we need to consider how these
	instances interact with each other and confirm this makes sense.
</p>
<a name="anchor8"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4"></a><h3>4.&nbsp;
Credentials and Authorization</h3>

<p>Several methods for authentication have been proposed for
      KARP. The simplest is preshared keys used directly as traffic
      keys. In this mode, the traffic integrity keys are directly
      configured. This is the mode supported by today's routing
      protocols.
</p>
<p>As discussed in <a class='info' href='#I-D.polk-saag-rtg-auth-keytable'>[I&#8209;D.polk&#8209;saag&#8209;rtg&#8209;auth&#8209;keytable]<span> (</span><span class='info'>Polk, T. and R. Housley, &ldquo;Routing Authentication Using A Database of Long-Lived Cryptographic Keys,&rdquo; July&nbsp;2010.</span><span>)</span></a>, preshared keys can be used as the input to a key derivation
      function (KDF) to generate traffic keys. For example the TCP
      Authentication Option (TCP-AO) <a class='info' href='#RFC5925'>[RFC5925]<span> (</span><span class='info'>Touch, J., Mankin, A., and R. Bonica, &ldquo;The TCP Authentication Option,&rdquo; June&nbsp;2010.</span><span>)</span></a> derives
      keys based on the initial TCP session state. Typically a KDF
      will combine a long-term key with public inputs exchanged as
      part of the protocol to form fresh session keys. a KDF could
      potentially be used with some inputs that are configured along
      with the long-term key. Also, it's possible that inputs to a KDF
      will be private and exchanged as part of the protocol, although
      this will be uncommon in KARP's uses of KDFs. 
</p>
<p>Preshared keys could also be used by an automated key
      management protocol. In this mode, preshared keys would be used
      for authentication. However traffic keys would be
      generated by some key agreement mechanism or transported in a key encryption key derived from the preshared key. This mode may provide better replay protection. Also,
      in the absence of active attackers, key agreement strategies
      such as Diffie-Hellman can be used to produce high-quality
      traffic keys even from relatively weak preshared keys.
</p>
<p>Public keys can be used for authentication. The design guide
      <a class='info' href='#I-D.ietf-karp-design-guide'>[I&#8209;D.ietf&#8209;karp&#8209;design&#8209;guide]<span> (</span><span class='info'>Lebovitz, G. and M. Bhatia, &ldquo;Keying and Authentication for Routing Protocols (KARP) Design Guidelines,&rdquo; September&nbsp;2010.</span><span>)</span></a> describes a mode in which routers
      have the hashes of peer routers' public keys. In this mode, a
      traditional public-key infrastructure is not required. The
      advantage of this mode is that a router only contains its own
      keying material, limiting the scope of a compromise. The
      disadvantage is that when a router is added or deleted from the
      set of authorized routers, all routers that peer need to be
      updated. Note that self-signed certificates are a common way of
      communicating public-keys in this style of authentication.
</p>
<p>Certificates signed by a certification authority or some
      other PKI could be used. The advantage of this approach is that
      routers may not need to be directly updated when peers are added
      or removed. The disadvantage is that more complexity and cost is
      required.
</p>
<p>Each of these approaches has a different set of management
      and operational requirements. Key differences include how
      authorization is handled and how identity works. This section
      discusses these differences.
</p>
<a name="PRESHARED"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.1"></a><h3>4.1.&nbsp;
Preshared Keys</h3>

<p>In the protocol, manual preshared keys are either unnamed
	or named by a small integer (typically 16 or 32 bits) key
	ID. Implementations that support multiple keys for protocols
	that have no names for keys need to try all possible keys
	before deciding a packet cannot be validated <a class='info' href='#RFC4808'>[RFC4808]<span> (</span><span class='info'>Bellovin, S., &ldquo;Key Change Strategies for TCP-MD5,&rdquo; March&nbsp;2007.</span><span>)</span></a>. Typically  key IDs are names used by  one group or peer.
</p>
<p>Manual preshared keys are often known by a group of peers
	rather than  just one peer. This is an interesting security property:
	it is impossible to identify the peer sending a message
	cryptographically; it is only possible to identify a group of
	peers using cryptographic means. Within the routing threat
	model the peer sending a message can be identified only
	because peers are trusted and thus can be assumed to correctly
	label the packets they send. This contrasts with a protocol
	where cryptographic means such as digital signatures are used
	to verify the origin of a message. As a consequence,
	authorization is typically based on knowing the preshared key
	rather than on being a particular peer. Note that once an
	authorization decision is made, the peer can assert its
	identity; this identity is trusted just as the routing
	information from the peer is trusted. However, for the process
	of authorization, it would be more complicated to identify
	peers this way and would not gain a security benefit in most
	deployments.
</p>
<p>Preshared keys used with key derivation function similarly
	to manual preshared keys. However to form the actual traffic
	keys, session or peer specific information is combined with
	the key. From an authorization standpoint, the derivation key
	works the same as a manual key. An additional routing protocol
	step or transport step forms the key that is actually used.
</p>
<p>Preshared keys that are used via automatic key management have not been specified. Their naming
	and authorization may differ. In particular, such keys may end
	up being known only by two peers. Alternatively they may also
	be known by a group of peers. Authorization could potentially
	be based on peer identity, although it is likely that knowing
	the right key will be sufficient. There does not appear to be
	a compelling reason to decouple the authorization of a key for
	some purpose from authorization of peers holding that key to
	perform the authorized function.
</p>
<p>Care needs to be taken when symmetric keys are used for
	multiple purposes. Consider the implications of using the same
	preshared key for two interfaces: it becomes impossible to
	distinguish a router on one interface from a router on another
	interface. So, a router that is trusted to participate in a
	routing protocol on one interface becomes implicitly trusted
	for the other interfaces that share the key. For many cases,
	such as link-state routers in the same routing area, there is
	no significant advantage that an attacker could gain from this
	trust within the KARP threat model. However, distance-vector
	protocols, such as BGP and RIP, permit routes to be filtered
	across a trust boundary. For these protocols, participation in
	one interface might be more advantageous than
	another. Operationally, when this trust distinction is
	important to a deployment, different keys need to be used on
	each side of the trust boundary. Key derivation can help
	prevent this problem in cases of accidental
	misconfiguration. However, key derivation cannot protect
	against a situation where a system was incorrectly trusted to
	have the key used to perform the derivation. To the extent
	that there are multiple zones of trust and a routing protocol
	is determining whether a particular router is within a certain
	zone, the question of untrusted actors is within the scope of
	the routing threat model.
</p>
<p>Key derivation can be part of a management solution to a
	desire to have multiple keys for different zones of trust. A
	master key could be combined with peer, link or area
	identifiers to form a router-specific preshared key that is
	loaded onto routers. Provider that the master key lives only
	on the management server and not the individual routers, trust
	is preserved. However in many cases, generating independent
	keys for the routers and storing the result is more
	practical. If the master key were somehow compromised, all the
	resulting keys would need to be changed. However if
	independent keys are used, the scope of a compromise may be
	more limited.
</p>
<p>More subtle problems with key separation can appear in protocol design. Two protocols that use the same traffic keys may work together in unintended ways permitting one protocol to be used to attack the other. Consider two hypothetical protocols. Protocol A starts its messages with a set of extensions that are ignored if not understood. Protocol B has a fixed header at the beginning of its messages but ends messages with extension information. It may be that the same message is valid both as part of protocol A and protocol B. An attacker may be able to gain an advantage by getting a router to generate this message with one protocol under situations where the other protocol would not generate the message. This hypothetical example is overly simplistic; real-world attacks exploiting key separation weaknesses tend to be complicated and involve specific properties of the cryptographic functions involved. The key point is that whenever the same key is used in multiple protocols, attacks may be possible. All the involved protocols need to be analyzed to understand the scope of potential attacks. 
</p>
<p>Key separation attacks interact with the KARP operational model in a number of ways. Administrators need to be aware of situations where using the same manual traffic key with two different protocols (or the same protocol in different contexts) creates attack opportunities. Design teams should consider how their protocol might interact with other routing protocols and describe any attacks discovered so that administrators can understand the operational implications. When designing automated key management or new cryptographic authentication within routing protocols, we need to be aware that administrators expect to be able to use the same preshared keys in multiple contexts. As a result, we should use appropriate key derivation functions so that different cryptographic keys are used even when the same initial input key is used.
</p>
<a name="anchor9"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.2"></a><h3>4.2.&nbsp;
Asymmetric Keys</h3>

<p>Outside of a PKI, public keys are expected to be known by
	the hash of a key or (potentially self-signed)
	certificate. The Session Description Protocol provides a
	standardized mechanism for naming keys (in that case
	certificates) based on hashes  (section 5 <a class='info' href='#RFC4572'>[RFC4572]<span> (</span><span class='info'>Lennox, J., &ldquo;Connection-Oriented Media Transport over the Transport Layer Security (TLS) Protocol in the Session Description Protocol (SDP),&rdquo; July&nbsp;2006.</span><span>)</span></a>). KARP SHOULD adopt this approach
	or another approach already standardized within the IETF
	rather than inventing a new mechanism for naming public
	keys.
</p>
<p>A public key is typically expected to belong to one
	peer. As a peer generates new keys and retires old keys, its
	public key may change. For this reason, from a management
	standpoint, peers should be thought of as associated with
	multiple public keys rather than as containing a single public
	key hash as an attribute of the peer object.
</p>
<p>Authorization of public keys could be done either by key
	hash or by peer identity. Performing authorizations by peer
	identity should make it easier to update the key of a peer
	without risk of losing authorizations for that peer. However
	management interfaces need to be carefully designed to avoid
	making this extra level of indirection complicated for
	operators.
</p>
<a name="anchor10"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.3"></a><h3>4.3.&nbsp;
Public Key Infrastructure</h3>

<p>When a PKI is used, certificates are used. The certificate
	binds a key to a name of a peer. The key management protocol
	is responsible for exchanging certificates and validating them
 to a trust anchor. 
</p>
<p>Authorization needs to be done in terms of peer identities
	not in terms of keys. One reason for this is that when a peer
	changes its key, the new certificate needs to be sufficient
	for authentication to continue functioning even though the key
	has never been seen before. 
</p>
<p>Potentially authorization could be performed in terms of
	groups of peers rather than single peers. An advantage of this
	is that it may be possible to add a new router with no
	authentication related configuration of the peers of that
	router. For example, a domain could decide that any router
	with a particular keyPurposeID signed by the organization's
	certificate authority is permitted to join the IGP. Just as in
	configurations where cryptographic authentication is not used,
	automatic discovery of this router can establish appropriate
	adjacencies.
</p>
<p>Assuming that potentially self-signed certificates are used
	by routers that wish to use public keys but that do not need a
	PKI, then PKI and the infrastructureless mode of public-key
	operation described in the previous section can work well
	together. One router could identify its peers based on names
	and use certificate validation. Another router could use
	hashes of certificates. This could be very useful for border
	routers between two organizations. Smaller organizations could
	use public keys and larger organizations could use PKI.
</p>
<a name="anchor11"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.4"></a><h3>4.4.&nbsp;
The role of Central Servers</h3>

<p>An area to explore is the role of central servers like
	RADIUS or directories. As discussed in the design-guide, a
	system where keys are pushed by a central management system is
	undesirable as an end result for KARP. However central servers
	may play a role in authorization and key rollover. For example
	a node could send a hash of a public key to a RADIUS
	server. 
</p>
<p>If central servers do play a role it will be critical to
	make sure that they are not required during routine operation
	or a cold-start of a network. They are more likely to play a
	role in enrollment of new peers or key migration/compromise.
</p>
<p>Another area where central servers may play a role is for group key agreement. As an example, <a class='info' href='#I-D.liu-ospfv3-automated-keying-req'>[I&#8209;D.liu&#8209;ospfv3&#8209;automated&#8209;keying&#8209;req]<span> (</span><span class='info'>Liu, Y., &ldquo;OSPFv3 Automated Group Keying Requirements,&rdquo; July&nbsp;2007.</span><span>)</span></a> discusses the potential need for key agreement servers in OSPF. Other routing protocols that use multicast or broadcast such as IS-IS are likely to need a similar approach.
</p>
<a name="anchor12"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5"></a><h3>5.&nbsp;
Grouping Peers Together</h3>

<p>One significant management consideration will be the grouping
      of management objects necessary to determine who is authorized
      to act as a peer for a given routing action. As discussed
      previously, the following objects are potentially required:</p>
<ul class="text">
<li>Key objects are required. Symmetric keys may be
      preshared. Asymmetric public keys may be used directly for
      authorization as well. During key transitions more than one key
      may refer to a given peer. Group preshared keys may refer to
      multiple peers.
</li>
<li>A peer is a router that this router might wish to
      communicate with. Peers may be identified by names or keys.
</li>
<li>Groups of peers may be authorized for a given routing protocol.
</li>
</ul><p>

</p>
<p>Establishing a management model is difficult because of the
      complex relationships between each set of objects. As discussed
      there may be more than one key for a peer. However in the
      preshared key case, there may be more than one peer for a
      key. This is true both for group security association protocols
      such as an IGP or one-to-one protocols where the same key is
      used administratively. In some of these situations, it may be
      undesirable to explicitly enumerate the peers in the
      configuration; for example IGP peers are auto-discovered for
      broadcast links but not for non-broadcast multi-access
      links.
</p>
<p>Peers may be identified either by name or key. If peers are
      identified by key it is probably strongly desirable from an
      operational standpoint to consider any peer identifiers or name
      to be a local matter and not require the names or identifiers to
      be synchronized. Obviously if peers are identified by names (for
      example with certificates in a PKI), identifiers need to be
      synchronized between the authorized peer and the peer making the
      authorization decision. 
</p>
<p>In many cases peers will explicitly be identified. In these
      cases it is possible to attach the authorization information
      (keys or identifiers) to the peer's configuration object. Two
      cases do not involve enumerating peers. The first is the case
      where preshared keys are shared among a group of peers. It is
      likely that this case can be treated from a management
      standpoint as a single peer representing all the peers that
      share the keys. The other case is one where certificates in a
      PKI are used to introduce peers to a router. In this case,
      rather than configuring peers, , the router needs to be
      configured with information on what certificates represent
      acceptable peers.
</p>
<p>Another consideration is what routing protocols share
      peers. For example it may be common for LDP peers to also be
      peers of some other routing protocol. Also, RSVP-TE may be
      associated with some TE-based IGP. In some of these cases it
      would be desirable to use the same authorization information for
      both routing protocols.
</p>
<p>In order to develop a management model for authorization, the
      working group needs to consider several questions. What
      protocols support auto-discovery of peers? What protocols
      require more configuration of a peer than simply the peer's
      authorization information and network address? What management
      operations are going to be common as security information for
      peers is configured and updated? What operations will be common
      while performing key transitions or while migrating to new
      security technologies?
</p>
<a name="anchor13"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6"></a><h3>6.&nbsp;
Administrator Involvement</h3>

<p>One key operational question is what areas will administrator
      involvement be required. Likely areas where involvement may be
      useful includes enrollment of new peers. Fault recovery should
      also be considered.
</p>
<a name="anchor14"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.1"></a><h3>6.1.&nbsp;
Enrollment</h3>

<p>One area where the management of routing security needs to
	be optimized is the deployment of a new router. In some cases
	a new router may be deployed on an existing network where
	routing to management servers is already available. In other
	cases, routers may be deployed as part of connecting or
	creating a site. Here, the router and infrastructure may not
	be available until the router has securely authenticated. This
	problem is similar to the problem of getting initial
	configuration of routing instances onto the router. However,
	especially in cases where asymmetric keys or per-peer
	preshared keys are used, the configuration of other routers
	needs to be modified to bring up the security
	association. Also, there has been discussion of generating
	keys on routers and not allowing them to leave devices. This
	also impacts what strategies are possible. For example this
	might mean that routers need to be booted in a secure
	environment where keys can be generated, and public keys
	copied to a management server to push out the new public key
	to potential peers. Then, the router needs to be packaged,
	moved to where it will be deployed and set up.Alternatives are
	possible; it is critical that we understand how what we
	propose impacts operators.
</p>
<p>We need to work through examples with operators familiar
	with specific real-world deployment practices and understand
	how proposed security mechanisms will interact with these
	practices. 
</p>
<a name="anchor15"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.2"></a><h3>6.2.&nbsp;
Handling Faults</h3>

<p>Faults may interact with operational practice in at least
	two ways. First, security solutions may introduce faults. For
	example if certificates expire in a PKI, previous adjacencies
	may no longer form. Operational practice will require a way of
	repairing these errors. This may end up being very similar to
	deploying a router that is connecting a new site as the
	security fault may have partitioned the network. However,
	unlike a new deployment, the event is unplanned. Strategies
	such as configuring a router and shipping it to a site may not
	be appropriate for recovering a fault even though they may be
	more useful for new deployments.
</p>
<p>Monitoring will play a critical role in avoiding security
	faults such as certificate expiration. However, the protocols
	MUST still have adequate operational mechanisms to recover
	from these situations. Also, some faults, such as those
	resulting from a compromise or actual attack on a facility are
	inherent and may not be prevented.
</p>
<p>A second class of faults is equipment faults that impact
	security. For example if keys are stored on a router and never
	moved from that device, failure of a router implies a need to
	update security provisioning on the replacement router and its
	peers.
</p>
<p>To address these operational considerations, we should
	identify circumstances surrounding recovery from today's
	faults and understand how protocols will impact mechanisms
	used today.
</p>
<a name="anchor16"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7"></a><h3>7.&nbsp;
Upgrade Considerations</h3>

<p>It needs to be possible to deploy automated key management in
      an organization without either having to disable existing
      security or disrupting routing. As a result, it needs to be
      possible to perform a phased upgrade from manual keying to
      automated key management.
</p>
<p>For peer-to-peer protocols such as BGP, this is likely to be
      relatively easy. First, code that supports automated key
      management needs to be loaded on both peers. Then the adjacency
      can be upgraded. The configuration can be updated to switch to
      automated key management when the second router reboots.
</p>
<p>The situation is more complicated for multicast
      protocols. It's probably not reasonable to bring down an entire
      link to reconfigure it as using automated key management. Two
      approaches should be considered. One is to support key table
      rows from the automated key management and manually configured
      for the same link at the same time. Coordinating this may be
      tricky. Another possibility is for the automated key management
      protocol to actually select the same traffic key that is being
      used manually 
</p>
<a name="anchor17"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.8"></a><h3>8.&nbsp;
Related Work</h3>

<p>Discuss draft-housley-saag-*, draft-polk-saag-*, the discussions in the KARP framework, etc.
</p>
<a name="anchor18"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.9"></a><h3>9.&nbsp;
Security Considerations</h3>

<p>This document does not define a protocol. It does discuss the operational and management implications of several security technologies.
</p>
<a name="anchor19"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.10"></a><h3>10.&nbsp;
Acknowledgments</h3>

<p>Funding for Sam Hartman's work on this memo is provided by Huawei.
</p>
<p>The authors would like to thank Gregory Lebovitz, Russ White
      and  Bill
      Atwood for valuable reviews.
</p>
<a name="rfc.references"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.11"></a><h3>11.&nbsp;
References</h3>

<a name="rfc.references1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>11.1.&nbsp;Normative References</h3>
<table width="99%" border="0">
<tr><td class="author-text" valign="top"><a name="I-D.housley-saag-crypto-key-table">[I-D.housley-saag-crypto-key-table]</a></td>
<td class="author-text">Housley, R. and T. Polk, &ldquo;<a href="http://www.ietf.org/internet-drafts/draft-housley-saag-crypto-key-table-04.txt">Database of Long-Lived Symmetric Cryptographic Keys</a>,&rdquo; draft-housley-saag-crypto-key-table-04 (work in progress), October&nbsp;2010 (<a href="http://www.ietf.org/internet-drafts/draft-housley-saag-crypto-key-table-04.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC2119">[RFC2119]</a></td>
<td class="author-text"><a href="mailto:sob@harvard.edu">Bradner, S.</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>,&rdquo; BCP&nbsp;14, RFC&nbsp;2119, March&nbsp;1997 (<a href="http://www.rfc-editor.org/rfc/rfc2119.txt">TXT</a>, <a href="http://xml.resource.org/public/rfc/html/rfc2119.html">HTML</a>, <a href="http://xml.resource.org/public/rfc/xml/rfc2119.xml">XML</a>).</td></tr>
</table>

<a name="rfc.references2"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>11.2.&nbsp;Informative References</h3>
<table width="99%" border="0">
<tr><td class="author-text" valign="top"><a name="I-D.ietf-karp-design-guide">[I-D.ietf-karp-design-guide]</a></td>
<td class="author-text">Lebovitz, G. and M. Bhatia, &ldquo;<a href="http://www.ietf.org/internet-drafts/draft-ietf-karp-design-guide-01.txt">Keying and Authentication for Routing Protocols (KARP) Design Guidelines</a>,&rdquo; draft-ietf-karp-design-guide-01 (work in progress), September&nbsp;2010 (<a href="http://www.ietf.org/internet-drafts/draft-ietf-karp-design-guide-01.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="I-D.liu-ospfv3-automated-keying-req">[I-D.liu-ospfv3-automated-keying-req]</a></td>
<td class="author-text">Liu, Y., &ldquo;<a href="http://www.ietf.org/internet-drafts/draft-liu-ospfv3-automated-keying-req-01.txt">OSPFv3 Automated Group Keying Requirements</a>,&rdquo; draft-liu-ospfv3-automated-keying-req-01 (work in progress), July&nbsp;2007 (<a href="http://www.ietf.org/internet-drafts/draft-liu-ospfv3-automated-keying-req-01.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="I-D.polk-saag-rtg-auth-keytable">[I-D.polk-saag-rtg-auth-keytable]</a></td>
<td class="author-text">Polk, T. and R. Housley, &ldquo;<a href="http://www.ietf.org/internet-drafts/draft-polk-saag-rtg-auth-keytable-03.txt">Routing Authentication Using A Database of Long-Lived Cryptographic Keys</a>,&rdquo; draft-polk-saag-rtg-auth-keytable-03 (work in progress), July&nbsp;2010 (<a href="http://www.ietf.org/internet-drafts/draft-polk-saag-rtg-auth-keytable-03.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC2328">[RFC2328]</a></td>
<td class="author-text"><a href="mailto:jmoy@casc.com">Moy, J.</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc2328">OSPF Version 2</a>,&rdquo; STD&nbsp;54, RFC&nbsp;2328, April&nbsp;1998 (<a href="http://www.rfc-editor.org/rfc/rfc2328.txt">TXT</a>, <a href="http://xml.resource.org/public/rfc/html/rfc2328.html">HTML</a>, <a href="http://xml.resource.org/public/rfc/xml/rfc2328.xml">XML</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4572">[RFC4572]</a></td>
<td class="author-text">Lennox, J., &ldquo;<a href="http://tools.ietf.org/html/rfc4572">Connection-Oriented Media Transport over the Transport Layer Security (TLS) Protocol in the Session Description Protocol (SDP)</a>,&rdquo; RFC&nbsp;4572, July&nbsp;2006 (<a href="http://www.rfc-editor.org/rfc/rfc4572.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4808">[RFC4808]</a></td>
<td class="author-text">Bellovin, S., &ldquo;<a href="http://tools.ietf.org/html/rfc4808">Key Change Strategies for TCP-MD5</a>,&rdquo; RFC&nbsp;4808, March&nbsp;2007 (<a href="http://www.rfc-editor.org/rfc/rfc4808.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC5925">[RFC5925]</a></td>
<td class="author-text">Touch, J., Mankin, A., and R. Bonica, &ldquo;<a href="http://tools.ietf.org/html/rfc5925">The TCP Authentication Option</a>,&rdquo; RFC&nbsp;5925, June&nbsp;2010 (<a href="http://www.rfc-editor.org/rfc/rfc5925.txt">TXT</a>).</td></tr>
</table>

<a name="rfc.authors"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>Authors' Addresses</h3>
<table width="99%" border="0" cellpadding="0" cellspacing="0">
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Sam Hartman</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Painless Security</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:hartmans-ietf@mit.edu">hartmans-ietf@mit.edu</a></td></tr>
<tr cellpadding="3"><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Dacheng Zhang</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Huawei</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:zhangdacheng@huawei.com">zhangdacheng@huawei.com</a></td></tr>
</table>
</body></html>
