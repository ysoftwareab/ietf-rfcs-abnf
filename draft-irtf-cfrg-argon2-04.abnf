H_0 = H^(64)(LE32(p) || LE32(T) || LE32(m) || LE32(t) || LE32(v) || LE32(y) || LE32(length(P)) || P || LE32(length(S)) || S ||  LE32(length(K)) || K || LE32(length(X)) || X)

                              H_0 generation

C = B[0][q-1] XOR B[1][q-1] XOR ... XOR B[p-1][q-1]

                                Final block

r = ceil(T/32)-2
V_1 = H^(64)(LE32(T)||A)
V_2 = H^(64)(V_1)
V_r = H^(64)(V_{r-1})
J_1 = int32(extract(B[i][j-1], 1))
J_2 = int32(extract(B[i][j-1], 2))

                         Deriving J1,J2 in Argon2d

x = J_1^2 / 2^(32)
y = (|W| * x) / 2^(32)
z = |W| - 1 - y

                           Computing J1, part 2

a = (a + b + 2 * trunc(a) * trunc(b)) mod 2^(64)
d = (d XOR a) >>> 32
c = (c + d + 2 * trunc(c) * trunc(d)) mod 2^(64)
b = (b XOR c) >>> 24

a = (a + b + 2 * trunc(a) * trunc(b)) mod 2^(64)
d = (d XOR a) >>> 16
c = (c + d + 2 * trunc(c) * trunc(d)) mod 2^(64)
b = (b XOR c) >>> 63

                               Details of GB

data_independent_addressing = (instance->type == Argon2_i);

pseudo_rands = (uint64_t *)malloc(sizeof(uint64_t) *
                                       (instance->segment_length));

starting_index = 0;

starting_index = 2;
curr_offset = position.lane * instance->lane_length +
                   position.slice * instance->segment_length +
                   starting_index;

prev_offset = curr_offset + instance->lane_length - 1;
prev_offset = curr_offset - 1;
prev_offset = curr_offset - 1;
pseudo_rand = pseudo_rands[i];
pseudo_rand = instance->memory[prev_offset].v[0];
ref_lane = ((pseudo_rand >> 32)) % instance->lanes;

ref_lane = position.lane;
ref_index = index_alpha(instance, &position,
                               pseudo_rand & 0xFFFFFFFF,
ref_lane == position.lane);

ref_block = instance->memory +
                   instance->lane_length * ref_lane + ref_index;
curr_block = instance->memory + curr_offset;
reference_area_size =
reference_area_size = position->slice *
                                instance->segment_length +
                                position->index - 1;
reference_area_size = position->slice *
                                instance->segment_length +
                                ((position->index == 0) ? (-1) : 0);
reference_area_size = instance->lane_length -
                              instance->segment_length +
                              position->index - 1;
reference_area_size = instance->lane_length -
                              instance->segment_length +
                              ((position->index == 0) ? (-1) : 0);
relative_position = pseudo_rand;
relative_position = relative_position * relative_position >> 32;
relative_position = reference_area_size - 1 -
                        (reference_area_size * relative_position >> 32);

start_position = 0;

start_position = (position->slice == ARGON2_SYNC_POINTS - 1)
                        ? 0
                        : (position->slice + 1) *
                        instance->segment_length;
absolute_position = (start_position + relative_position) %
                         instance->lane_length; /* absolute position */
thread = calloc(instance->lanes, sizeof(argon2_thread_handle_t));
thr_data = calloc(instance->lanes, sizeof(argon2_thread_data));
rc = argon2_thread_join(thread[l - instance->threads]);
rc = argon2_thread_create(&thread[l], &fill_segment_thr,
                                  (void *)&thr_data[l]);
rc = argon2_thread_join(thread[l]);
