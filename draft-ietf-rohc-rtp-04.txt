



Network Working Group              Carsten Bormann (ed.), TZI/Uni Bremen
INTERNET-DRAFT
Expires: April 2000
                                          Carsten Burmeister, Matsushita
                                              Christopher Clanton, Nokia
                                          Mikael Degermark, U of Arizona
                                           Hideaki Fukushima, Matsushita
                                                    Hans Hannu, Ericsson
                                             Lars-Erik Jonsson, Ericsson
                                              Rolf Hakenberg, Matsushita
                                                      Tmima Koren, Cisco
                                                         Khiem Le, Nokia
                                                      Zhigang Liu, Nokia
                                              Anton Martensson, Ericsson
                                            Akihiro Miyazaki, Matsushita
                                               Krister Svanbro, Ericsson
                                               Thomas Wiebke, Matsushita
                                                    Haihong Zheng, Nokia

                                                        October 11, 2000
                     RObust Header Compression (ROHC)
                       <draft-ietf-rohc-rtp-04.txt>




Status of this memo

   This document is an Internet-Draft and is in full conformance with
   all provisions of Section 10 of RFC2026.

   Internet-Drafts are working documents of the Internet Engineering
   Task Force (IETF), its areas, and its working groups. Note that other
   groups may also distribute working documents as Internet-Drafts.

   Internet-Drafts are draft documents valid for a maximum of six months
   and may be updated, replaced, or obsoleted by other documents at any
   time. It is inappropriate to use Internet-Drafts as reference
   material or cite them other than as "work in progress".

   The list of current Internet-Drafts can be accessed at
   http://www.ietf.org/ietf/lid-abstracts.txt

   The list of Internet-Draft Shadow Directories can be accessed at
   http://www.ietf.org/shadow.html

   This document is a product of the IETF ROHC WG. Comments should be
   directed to its mailing list, rohc@cdt.luth.se.





Bormann (ed.)                                                   [Page 1]

INTERNET-DRAFT          Robust Header Compression           Oct 11, 2000



Abstract

   Existing header compression schemes do not work well when used over
   links with significant error rates and long round-trip times. For
   many bandwidth limited links where header compression is essential,
   such characteristics are common.

   A highly robust and efficient header compression scheme for
   RTP/UDP/IP and UDP/IP is specified in this document. The scheme can
   adapt to the characteristics of the link over which it is used and
   also to the properties of the packet streams whose headers it
   compresses.


Revision History

   -04: Complete 5.5 and 5.8.  Remove section 7 (no longer needed) and
          renumber.  Restructure section 5 to clearly separate the
          profiles.
   -03: Redo packet formats to allow new ROHC framework. Fill in gaps.
   -02: Major changes after 48th IETF
   -01: Minor editorial changes for 48th IETF
   -00: Document created from ROHC submissions






























Bormann (ed.)                                                   [Page 2]

INTERNET-DRAFT          Robust Header Compression           Oct 11, 2000


Table of contents

   Status of this memo.................................................1
   Abstract............................................................2
   Revision History....................................................2
   Table of contents...................................................3
   0.  ROHC WG internal short-term time plan...........................7
   1.  Introduction....................................................8
   2.  Terminology....................................................10
   3.  Background.....................................................14
   3.1.  Header compression fundamentals..............................14
   3.2.  Existing header compression schemes..........................14
   3.3.  Requirements on a new header compression scheme..............16
   3.4.  Classification of header fields..............................16
   4.  Header compression framework...................................18
   4.1.  Operating assumptions .......................................18
   4.2.  Dynamicity...................................................19
   4.3.  Compression and decompression states.........................20
   4.3.1.  Compressor states..........................................21
   4.3.1.1.  Initialization and Refresh (IR) State....................21
   4.3.1.2.  First Order (FO) State...................................21
   4.3.1.3.  Second Order (SO) State..................................22
   4.3.2.  Decompressor states........................................22
   4.4.  Modes of operation...........................................23
   4.4.1.  Unidirectional mode - U-mode...............................23
   4.4.2.  Bi-directional optimistic mode - O-mode....................24
   4.4.3.  Bi-directional reliable mode - R-mode......................24
   4.5.  Encoding methods.............................................25
   4.5.1.  Least Significant Bits (LSB) encoding .....................25
   4.5.2.  Window-based LSB encoding (W-LSB encoding).................27
   4.5.2.  Scaled RTP Timestamp encoding .............................28
   4.5.4.  Timer-Based Compression of RTP Timestamp...................29
   4.5.5.  Offset IP-ID encoding......................................32
   4.5.6.  Self-describing variable-length values. ...................33
   4.5.7.  Encoded values across several fields in compressed headers.34
   5.  The protocol...................................................35
   5.1.  Data structures..............................................35
   5.1.1.  Per-channel parameters.....................................35
   5.1.2.  Per-context parameters, profiles...........................35
   5.1.3.  Contexts and context identifiers ..........................36
   5.2. ROHC Packets & packet types...................................36
   5.2.1.  ROHC feedback .............................................38
   5.2.2.  ROHC feedback packet type .................................39
   5.2.3.  ROHC IR packet type .......................................41
   5.2.4.  ROHC Initial decompressor processing ......................42
   5.2.5.  ROHC RTP Packet formats from compressor to decompressor ...43
   5.2.6.  Parameters needed for mode transition in ROHC RTP..........44
   5.3.  Operation in unidirectional mode.............................45
   5.3.1.  Compressor states and logic (U-mode).......................45
   5.3.1.1.  State transition logic (U-mode)..........................45
   5.3.1.1.1.  Optimistic approach, upwards transition................45



Bormann (ed.)                                                   [Page 3]

INTERNET-DRAFT          Robust Header Compression           Oct 11, 2000


   5.3.1.1.2.  Timeouts, downward transition..........................46
   5.3.1.1.3.  Need for updates, downward transition..................46
   5.3.1.2.  Compression logic and packets used (U-mode)..............46
   5.3.1.3.  Feedback in unidirectional mode..........................46
   5.3.2.  Decompressor states and logic (U-mode).....................46
   5.3.2.1.  State transition logic (U-mode)..........................47
   5.3.2.2.  Decompression logic (U-mode).............................47
   5.3.2.2.1.  Decide whether decompression is allowed................47
   5.3.2.2.2.  Reconstruct and verify the header......................47
   5.3.2.2.3.  Actions upon CRC failure...............................48
   5.3.2.2.3.1.  Correction of SN wrap-around.........................49
   5.3.2.2.3.2.  Repair of incorrect SN updates.......................49
   5.3.2.2.3.3.  Judge whether bit error or context damage............51
   5.3.2.3.  Feedback in unidirectional mode..........................51
   5.4.  Operation in bi-directional optimistic mode..................52
   5.4.1.  Compressor states and logic (O-mode).......................52
   5.4.1.1.  State transition logic...................................52
   5.4.1.1.1.  Negative acknowledgements (NACKs), downward transition.52
   5.4.1.1.2.  Optional acknowledgements, upwards transition..........52
   5.4.1.2.  Compression logic and packets used.......................53
   5.4.2.  Decompressor states and logic (O-mode).....................53
   5.4.2.1.  Decompression logic, timer-based timestamp decompression.53
   5.4.2.2.  Feedback logic (O-mode)..................................53
   5.5.  Operation in bi-directional reliable mode....................54
   5.5.1.  Compressor states and logic (R-mode).......................54
   5.5.1.1.  State transition logic (R-mode)..........................54
   5.5.1.1.1 Upwards transition.......................................55
   5.5.1.1.2 Downward transition......................................55
   5.5.1.2.  Compression logic and packets used (R-mode)..............55
   5.5.2.  Decompressor states and logic (R-mode).....................56
   5.5.2.1.  Decompression logic (R-mode).............................56
   5.5.2.2.  Feedback logic (R-mode)..................................56
   5.6.  Mode transitions.............................................57
   5.6.1.  Compression and decompression during mode transitions......57
   5.6.2.  Transition from Unidirectional to Optimistic mode..........58
   5.6.3.  From Optimistic to Reliable mode...........................59
   5.6.4.  From Unidirectional to Reliable mode.......................59
   5.6.5.  From Reliable to Optimistic mode...........................59
   5.6.6.  Transition to Unidirectional mode..........................60
   5.7.  Packet formats ..............................................62
   5.7.1.  Packet type 0: UO-0, R-0, R-0-CRC .........................65
   5.7.2.  Packet type 1 (R-mode): R-1, R-1-TS, R-1-ID ...............65
   5.7.3.  Packet type 1 (UO-modes): UO-1, UO-1-ID, UO-1-TS ..........67
   5.7.4.  Packet type 2: UOR-2 ......................................68
   5.7.5.  Extension formats .........................................69
   5.7.5.1 RND flags and packet types ................................73
   5.7.5.2 Flags/Fields in context ...................................74
   5.7.6.  Feedback packets and formats ..............................75
   5.7.6.2 Feedback formats for ROHC RTP..............................75
   5.7.6.3 ROHC RTP Feedback options .................................76
   5.7.6.4 The CRC option ............................................76



Bormann (ed.)                                                   [Page 4]

INTERNET-DRAFT          Robust Header Compression           Oct 11, 2000


   5.7.6.5 The REJECT option .........................................77
   5.7.6.6 The SN option .............................................77
   5.7.6.7 The CLOCK option ..........................................77
   5.7.6.8 The JITTER option .........................................78
   5.7.6.9 The LOSS option ...........................................79
   5.7.6.10 Unknown option types .....................................79
   5.7.6.11 RTP feedback example .....................................79
   5.7.7  RTP IR and IR-DYN packets...................................80
   5.7.7.2. Basic structure of the IR-DYN packet......................81
   5.7.7.3.  Initialization of IPv6 Header [IPv6].....................82
   5.7.7.4. Initialization of IPv4 Header [IPv4, section 3.1].........84
   5.7.7.5. Initialization of UDP Header [RFC-768]....................85
   5.7.7.6. Initialization of RTP Header [RTP]........................85
   5.8 List-based compression.........................................86
   5.8.1 Table-based item compression.................................87
   5.8.1.1 Translation Table in R-mode................................88
   5.8.1.2 Translation Table in U/O-modes.............................88
   5.8.2 Reference list determination.................................89
   5.8.2.1 Reference list in R-mode and UO-modes......................89
   5.8.3 Encoding Schemes for the compressed list.....................92
   5.8.4.  Special Handling for IP Extension Headers..................94
   5.8.4.1.  Next Header Field........................................94
   5.8.4.2.  Authentication Header (AH)...............................96
   5.8.4.3.  Encapsulating Security Payload Header....................96
   5.8.4.4.  Mobile IPv6 Related Destination Option Header............97
   5.8.4.5.  Mobile IPv4 Extension Headers............................98
   5.8.4.6.  GRE Header...............................................98
   5.8.5.  Format of Compressed Lists.................................98
   5.8.5.1.  Format of IP Extension Hdr(s) field......................98
   5.8.5.2 Format of Compressed CSRC List.............................99
   5.8.6 Compressed list formats......................................99
   5.8.6.1  Encoding Type 0 (generic scheme)..........................99
   5.8.6.2 Encoding Type 1 (insertion only scheme)...................101
   5.8.6.3 Encoding Type 2 (removal only scheme).....................102
   5.8.6.4 Encoding Type 3 (remove then insert scheme) ..............103
   5.8.7 CRC coverage for extension headers .........................103
   5.9.  Header compression CRCs, coverage and polynomials...........103
   5.9.1.  IR & IR-DYN packet CRCs...................................104
   5.9.2.  CRCs in compressed packets................................104
   5.10. ROHC UNCOMPRESSED _ no compression (Profile 0)..............105
   5.10.1 IR packet..................................................105
   5.10.2 Normal packet..............................................106
   5.10.3 States and Modes...........................................106
   5.10.4 Feedback...................................................107
   5.11. ROHC UDP - non-RTP UDP/IP compression (Profile 2)...........107
   5.11.1 Initialization.............................................108
   5.11.2 States and Modes...........................................108
   5.11.3 Packet types...............................................109
   5.11.4 Extensions.................................................110
   5.11.5 IP-ID......................................................111
   5.11.6. Feedback..................................................111



Bormann (ed.)                                                   [Page 5]

INTERNET-DRAFT          Robust Header Compression           Oct 11, 2000


   6.  Implementation issues.........................................112
   6.1.  Reverse decompression.......................................112
   6.2.  RTCP........................................................113
   6.3.  Implementation parameters and signals.......................113
   6.3.1.  ROHC implementation parameters at compressor:.............114
   6.3.2.  ROHC implementation parameters at decompressor:...........115
   6.5.  Handling of resource limitations at the decompressor........115
   7.  Security considerations.......................................115
   8.  Acknowledgements..............................................116
   8z.  Intellectual property considerations.........................117
   9.  References....................................................118
   10.  Authors' addresses...........................................118
   Appendix A.  Detailed classification of header fields.............120
   A.1.  General classification......................................120
   A.1.1.  IPv6 header fields........................................121
   A.1.2.  IPv4 header fields........................................122
   A.1.3.  UDP header fields.........................................124
   A.1.4.  RTP header fields.........................................125
   A.1.5.  Summary for IP/UDP/RTP....................................126
   A.2.  Analysis of change patterns of header fields................126
   A.2.1.  IPv4 Identification.......................................128
   A.2.2.  IP Traffic-Class / Type-Of-Service........................129
   A.2.3.  IP Hop-Limit / Time-To-Live...............................130
   A.2.4.  UDP Checksum..............................................130
   A.2.5.  RTP CSRC Counter..........................................130
   A.2.6.  RTP Marker................................................130
   A.2.7.  RTP Payload Type..........................................130
   A.2.8.  RTP Sequence Number.......................................130
   A.2.9.  RTP Timestamp.............................................130
   A.2.10.  RTP Contributing Sources (CSRC)..........................131
   A.3.  Header compression strategies...............................131
   A.3.1.  Do not send at all........................................131
   A.3.2.  Transmit only initially...................................132
   A.3.3.  Transmit initially, but be prepared to update.............132
   A.3.4.  Be prepared to update or send as-is frequently............132
   A.3.5.  Guarantee continuous robustness...........................132
   A.3.6.  Transmit as-is in all packets.............................133
   A.3.7.  Establish and be prepared to update delta.................133
   Appendix B.  Encoding Examples....................................134
   B.1.  Basic W-LSB.................................................134
   B.2.  Timer-Based Compression.....................................135



   (Editor's note: The TOC has not necessarily been updated.)









Bormann (ed.)                                                   [Page 6]

INTERNET-DRAFT          Robust Header Compression           Oct 11, 2000


0.  ROHC WG internal short-term time plan

   This document captures the state of the ROHC RTP specification as on
   October 11, 2000.  For information, the ROHC WG internal short-term
   time plan that led to this document is as follows:

       18 September    ROHC-02 completed

               Draft review and discussion

               Complementary contributions created

       29 September    Cutoff for draft review and discussion

       02 October      ROHC-03 completed

       04 October      Judge whether draft ready for last call

   As of Oct 04, the WG chairs believe this draft is not yet ready for
   last call on Oct 04. At least the following points are identified as
   to be completed:

                          Complete section 5.5.
                          Merge section 5.8 and 7.3.
                          Align terminology in informational Appendix E.

       10 October      ROHC-04 completed (this document)

   Time plan for continued work is as follows.

       13 October      Cutoff for draft review and discussion

       16 October      ROHC-05 completed

   WG Last call at completion of ROHC-05 on October 16.



















Bormann (ed.)                                                   [Page 7]

INTERNET-DRAFT          Robust Header Compression           Oct 11, 2000



1.  Introduction

   During the last five years, two communication technologies in
   particular have become commonly used by the general public: cellular
   telephony and the Internet. Cellular telephony has provided its users
   with the revolutionary possibility of always being reachable with
   reasonable service quality no matter where they are. The main service
   provided by the dedicated terminals has been speech. The Internet, on
   the other hand, has from the beginning been designed for multiple
   services and its flexibility for all kinds of usage has been one of
   its strengths. Internet terminals have usually been general-purpose
   and have been attached over fixed connections. The experienced
   quality of some services (such as Internet telephony) has sometimes
   been low.

   Today, IP telephony is gaining momentum thanks to improved technical
   solutions. It seems reasonable to believe that in the years to come,
   IP will become a commonly used way to carry telephony. Some future
   cellular telephony links might also be based on IP and IP telephony.
   Cellular phones may have become more general-purpose, and may have IP
   stacks supporting not only audio and video, but also web browsing,
   email, gaming, etc.

   One of the scenarios we are envisioning might then be the one in
   Figure 1.1, where two mobile terminals are communicating with each
   other. Both are connected to base stations over cellular links, and
   the base stations are connected to each other through a wired (or
   possibly wireless) network. Instead of two mobile terminals, there
   could of course be one mobile and one wired terminal, but the case
   with two cellular links is technically more demanding.


   Mobile            Base                      Base            Mobile
   Terminal          Station                   Station         Terminal


         |  ~   ~   ~  \ /                       \ /  ~   ~   ~   ~  |
         |              |                         |                  |
      +--+              |                         |               +--+
      |  |              |                         |               |  |
      |  |              |                         |               |  |
      +--+              |                         |               +--+
                        |                         |
                        |=========================|

            Cellular              Wired               Cellular
            Link                  Network             Link

        Figure 1.1 : Scenario for IP telephony over cellular links




Bormann (ed.)                                                   [Page 8]

INTERNET-DRAFT          Robust Header Compression           Oct 11, 2000


   It is obvious that the wired network can be IP-based. With the
   cellular links, the situation is less clear. IP could be terminated
   in the fixed network, and special solutions implemented for each
   supported service over the cellular link. However, this would limit
   the flexibility of the services supported. If technically and
   economically feasible, a solution with pure IP all the way from
   terminal to terminal would have certain advantages. However, to make
   this a viable alternative, a number of problems have to be addressed,
   in particular problems regarding bandwidth efficiency.

   For cellular phone systems, it is of vital importance to use the
   scarce radio resources in an efficient way. A sufficient number of
   users per cell is crucial, otherwise deployment costs will be
   prohibitive [CELL]. The quality of the voice service should also be
   as good as in today's cellular systems. It is likely that even with
   support for new services, lower quality of the voice service is
   acceptable only if costs are significantly reduced.

   A problem with IP over cellular links when used for interactive voice
   conversations is the large header overhead. Speech data for IP
   telephony will most likely be carried by RTP [RTP]. A packet will
   then, in addition to link layer framing, have an IP [IPv4] header (20
   octets), a UDP [UDP] header (8 octets), and an RTP header (12 octets)
   for a total of 40 octets. With IPv6 [IPv6], the IP header is 40
   octets for a total of 60 octets. The size of the payload depends on
   the speech coding and frame sizes being used and may be as low as 15-
   20 octets.

   From these numbers, the need for reducing header sizes for efficiency
   reasons is obvious. However, cellular links have characteristics that
   make header compression as defined in [IPHC,CRTP,PPPHC] perform less
   than well. The most important characteristic is the lossy behavior of
   cellular links, where a bit error rate (BER) as high as 1e-3 must be
   accepted to keep the radio resources efficiently utilized [CELL]. In
   severe operating situations, the BER can be as high as 1e-2. The
   other problematic characteristic is the long round-trip time (RTT) of
   the cellular link, which can be as high as 100-200 milliseconds
   [CELL]. An additional problem is that the residual BER is nontrivial,
   i.e., lower layers can sometimes deliver frames containing undetected
   errors. A viable header compression scheme for cellular links must be
   able to handle loss on the link between the compression and
   decompression point as well as loss before the compression point.

   Bandwidth is the most costly resource in cellular links. Processing
   power is very cheap in comparison. Implementation or computational
   simplicity of a header compression scheme is therefore of less
   importance than its compression ratio and robustness.







Bormann (ed.)                                                   [Page 9]

INTERNET-DRAFT          Robust Header Compression           Oct 11, 2000


2.  Terminology

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
   document are to be interpreted as described in RFC 2119.

   BER

     Bit Error Rate. Cellular radio links can have a rather high BER. In
     this document BER is usually given as a probability, but one also
     needs to consider the error distribution as bit errors are not
     independent.

   Cellular links

     Wireless links between mobile terminals and base stations. The BER
     and the RTT are rather high in order to achieve an efficient system
     overall.

   Compression efficiency

     The performance of a header compression scheme can be described
     with three parameters, compression efficiency, robustness and
     compression transparency. The compression efficiency is determined
     by how much the header sizes are reduced by the compression scheme.

   Compression transparency

     The performance of a header compression scheme can be described
     with three parameters, compression efficiency, robustness and
     compression transparency. The compression transparency is a measure
     for how well the scheme ensures that the decompressed headers are
     semantically identical to the original headers. If all decompressed
     headers are semantically identical to the corresponding original
     headers, the transparency is 100 per cent. Compression transparency
     is high when damage propagation is low.

   Context

     The context is the state which the compressor uses to compress a
     header and which the decompressor uses to decompress a header. The
     context basically contains the uncompressed version of the last
     header sent (compressor) or received (decompressor) over the link,
     except for fields in the header that are included "as-is" in
     compressed headers or can be inferred from, e.g., the size of the
     link-level frame. The context can also contain additional
     information describing the packet stream, for example the typical
     inter-packet increase in sequence numbers or timestamps.

   Context damage




Bormann (ed.)                                                  [Page 10]

INTERNET-DRAFT          Robust Header Compression           Oct 11, 2000


     When the context of the decompressor is not consistent with the
     context of the compressor, header decompression may fail to
     reproduce the original header. This situation can occur when the
     context of the decompressor has not been initialized properly or
     when packets have been lost or damaged between compressor and
     decompressor. Packets for which the decompressor detects they
     cannot be decompressed due to inconsistent contexts are said to be
     lost due to context damage.

   Context repair mechanism

     To avoid excessive context damage, a context repair mechanism is
     needed. Context repair mechanisms can be based on explicit requests
     for context updates, periodic updates sent by the compressor, or
     methods for local repair at the decompressor side.

   CRC-DYNAMIC

     Opposite of CRC-STATIC.

   CRC-STATIC

     A CRC over the original header is the primary mechanism of ROHC to
     detect incorrect decompression. In order to decrease computational
     complexity, the fields of the header are conceptually rearranged
     when computing the CRC, such that it is first computed over octets
     which are static (called CRC-STATIC in this document) and then over
     octets whose values are expected to change between packets (CRC-
     DYNAMIC). In this manner, the intermediate result of the CRC
     computation, after it has covered the CRC-STATIC fields, can be
     reused for several packets. The restarted CRC computation only
     covers the CRC-DYNAMIC octets.  See also section 5.9.

   Damage propagation

     Generation of incorrect decompressed headers due to damage to
     previous packet(s).

   Loss propagation

     Failure to decompress headers due to loss of previous frame(s).

   Error detection

     Detection of errors. If error detection is not perfect, there will
     be residual errors.

   Error propagation

     Damage propagation or loss propagation.




Bormann (ed.)                                                  [Page 11]

INTERNET-DRAFT          Robust Header Compression           Oct 11, 2000


   FLR

     Frame Loss Rate, given as a probability that a frame is lost on the
     channel between compressor and decompressor.  (In contrast, frames
     lost due to context damage contribute to the packet loss rate.)

   Frame

     Packet emitted by the compressor/received by the decompressor.
     Note that, in this document, there is no relationship to other
     (e.g. physical layer) frame concepts such as radio frames.

   Header compression profile

     A header compression profile is a specification of how to compress
     the headers of a certain kind of packet stream over a certain kind
     of link. Compression profiles provide the details of the header
     compression framework introduced in this document. The profile
     concept makes use of profile identifiers to separate different
     profiles which are used when setting up the compression scheme. All
     variations and parameters of the header compression scheme that are
     not part of the context state are handled by different profile
     identifiers.

   Packet

     Generally, a unit of transmission and reception (protocol data
     unit).  Specifically, when contrasted to "frame", the packet
     compressed and then decompressed by ROHC.  Also called
     "uncompressed packet".

   Pre-HC links

     Pre-HC links are all links a packet has traversed before the header
     compression point. If we consider a path with cellular links as
     first and last hops, the Pre-HC links for the compressor at the
     last link are the first cellular link plus the wired links in
     between.

   Residual error

     Error introduced during transmission and not detected by lower-
     layer error detection schemes.

   Robustness

     The performance of a header compression scheme can be described
     with three parameters, compression efficiency, robustness and
     compression transparency. A robust scheme tolerates errors on the
     link over which header compression takes place (including both




Bormann (ed.)                                                  [Page 12]

INTERNET-DRAFT          Robust Header Compression           Oct 11, 2000


     frame losses and residual bit errors) without losing additional
     packets, introducing additional errors, or using more bandwidth.

   RTT

     Round-trip time -- The time it takes to send a packet from
     compressor to decompressor and back again from decompressor to
     compressor.

   Simplex link

     A simplex (or unidirectional) link is a point to point link without
     a return channel. Over simplex links, header compression must rely
     on periodic refreshes since feedback from the decompressor can not
     be sent to the compressor.

   Spectrum efficiency

     Radio resources are limited and expensive. Therefore they must be
     used efficiently to make the system economically feasible. In
     cellular systems this is achieved by maximizing the number of users
     served within each cell, while the quality of the provided services
     is kept at an acceptable level. A consequence of efficient spectrum
     use is a high rate of errors (frame loss and residual bit errors),
     even after channel coding with error correction.

   String

     A sequence of headers in which the values of all fields being
     compressed change with a fixed pattern with respect to a sequence
     number, so that it can be compressed by representing it with a
     sequence of ROHC headers that essentially just carry an encoded
     sequence number. Note that fields not currently being compressed
     (e.g. random IP-ID, UDP checksum) are irrelevant to this
     definition.

   Timestamp stride

     The timestamp stride (TS STRIDE) is the expected increase in the
     timestamp value between two RTP packets with consecutive sequence
     numbers.













Bormann (ed.)                                                  [Page 13]

INTERNET-DRAFT          Robust Header Compression           Oct 11, 2000


3.  Background

   This chapter provides a background to the subject of header
   compression. The fundamental ideas are described together with
   descriptions of existing header compression schemes, their drawbacks
   and requirements and motivation for new header compression solutions.


3.1.  Header compression fundamentals

   The main reason why header compression can be done at all is the fact
   that there is significant redundancy between header fields, both
   within the same packet header but in particular between consecutive
   packets belonging to the same packet stream. By sending static field
   information only initially and utilizing dependencies and
   predictability for other fields, the header size can be significantly
   reduced for most packets.

   In general, header compression methods maintain a context, which is
   essentially the uncompressed version of the last header sent over the
   link, plus some additional information, at both compressor and
   decompressor. Compression and decompression are done relative to the
   context. When compressed headers carry differences from the previous
   header, each compressed header will update the context of the
   decompressor. In this case, when a packet is lost between compressor
   and decompressor, the context of the decompressor will be brought out
   of sync since it is not updated correctly. A header compression
   method must have a way to repair the context, i.e., bring it into
   sync, after such events.


3.2.  Existing header compression schemes

   The original header compression scheme, CTCP [VJHC], was invented by
   Van Jacobson. CTCP compresses the 40 octet IP+TCP header to 4 octets.
   The CTCP compressor detects transport-level retransmissions and sends
   a header that updates the context completely when they occur. This
   repair mechanism does not require any explicit signaling between
   compressor and decompressor.

   A general IP header compression scheme, IP header compression [IPHC],
   improves somewhat on CTCP and can compress arbitrary IP, TCP, and UDP
   headers. When compressing non-TCP headers, IPHC does not use delta
   encoding and is robust. When compressing TCP, the repair mechanism of
   CTCP is augmented with a link-level nacking scheme which speeds up
   the repair. IPHC does not compress RTP headers.

   CRTP [CRTP, IPHC] by Casner and Jacobson is a header compression
   scheme that compresses 40 octets of IPv4/UDP/RTP headers to a minimum
   of 2 octets when no UDP checksum is present. If the UDP checksum is
   present, the minimum CRTP header is 4 octets. CRTP cannot use the



Bormann (ed.)                                                  [Page 14]

INTERNET-DRAFT          Robust Header Compression           Oct 11, 2000


   same repair mechanism as CTCP since UDP/RTP does not retransmit.
   Instead, CRTP uses explicit signaling messages from decompressor to
   compressor, called CONTEXT_STATE messages, to indicate that the
   context is out of sync. The link roundtrip time will thus limit the
   speed of this context repair mechanism.

   On lossy links with long roundtrip times, such as most cellular
   links, CRTP does not perform well. Each lost packet over the link
   causes several subsequent packets to be lost since the context is out
   of sync during at least one link roundtrip time. This behavior is
   documented in [CRTPC]. For voice conversations such long loss events
   will degrade the voice quality. Moreover, bandwidth is wasted by the
   large headers sent by CRTP when updating the context. [CRTPC] found
   that CRTP did not perform well enough for a lossy cellular link. It
   is clear that CRTP alone is not a viable header compression scheme
   for IP telephony over cellular links.

   To avoid losing packets due to the context being out of sync, CRTP
   decompressors can attempt to repair the context locally by using a
   mechanism known as TWICE. Each CRTP packet contains a counter which
   is incremented by one for each packet sent out by the CRTP
   compressor. If the counter increases by more than one, at least one
   packet was lost over the link. The decompressor then attempts to
   repair the context by guessing how the lost packet(s) would have
   updated it. The guess is then verified by decompressing the packet
   and checking the UDP checksum - if it succeeds, the repair is deemed
   successful and the packet can be forwarded or delivered. TWICE has
   got its name from the observation that when the compressed packet
   stream is regular, the correct guess is to apply the update in the
   current packet twice. [CRTPC] found that even with TWICE, CRTP
   doubled the number of lost packets. TWICE improves CRTP performance
   significantly. However, there are several problems with using TWICE:

   1) It becomes mandatory to use the UDP checksum:

      - the minimal compressed header size increases by 100% to 4
        octets.

      - most speech codecs developed for cellular links tolerate errors
        in the encoded data. Such codecs will not want to enable the UDP
        checksum, since they do want damaged packets to be delivered.

      - errors in the payload will make the UDP checksum fail when the
        guess is correct (and might make it succeed when it is wrong).

   2) Loss in an RTP stream that occurs before the compression point
      will make updates in CRTP headers less regular. Simple-minded
      versions of TWICE will then perform badly. More sophisticated
      versions would need more repair attempts to succeed.





Bormann (ed.)                                                  [Page 15]

INTERNET-DRAFT          Robust Header Compression           Oct 11, 2000




3.3.  Requirements on a new header compression scheme

   The major problem with CRTP is that it is not sufficiently robust
   against packets being damaged between compressor and decompressor. A
   viable header compression scheme must be less fragile. This increased
   robustness must be obtained without increasing the compressed header
   size; a larger header would make IP telephony over cellular links
   economically unattractive.

   A major cause of the bad performance of CRTP over cellular links is
   the long link roundtrip time, during which many packets are lost when
   the context is out of sync. This problem can be attacked directly by
   finding ways to reduce the link roundtrip time. Future generations of
   cellular technologies may indeed achieve lower link roundtrip times.
   However, these will probably always be rather high [CELL]. The
   benefits in terms of lower loss and smaller bandwidth demands if the
   context can be repaired locally will be present even if the link
   roundtrip time is decreased. A reliable way to detect a successful
   context repair is then needed.

   One might argue that a better way to solve the problem is to improve
   the cellular link so that packet loss is less likely to occur. Such
   modifications do not appear to come for free, however. If links were
   made (almost) error free, the system might not be able to support a
   sufficiently large number of users per cell and might thus be
   economically infeasible [CELL].

   One might also argue that the speech codecs should be able to deal
   with the kind of packet loss induced by CRTP, in particular since the
   speech codecs probably must be able to deal with packet loss anyway
   if the RTP stream crosses the Internet. While the latter is true, the
   kind of loss induced by CRTP is difficult to deal with. It is usually
   not possible to completely hide a loss event where well over 100 ms
   worth of sound is completely lost. If such loss occurs frequently at
   both ends of the end-to-end path, the speech quality will suffer.

   A detailed description of the requirements specified for ROHC may be
   found in [REQ].


3.4.  Classification of header fields

   As mentioned earlier, header compression is possible due to the fact
   that there is much redundancy between header field values within
   packets, but especially between consecutive packets. To utilize these
   properties for header compression, it is important to understand the
   change patterns of the various header fields.





Bormann (ed.)                                                  [Page 16]

INTERNET-DRAFT          Robust Header Compression           Oct 11, 2000


   All header fields have been classified in detail in appendix A. The
   fields are first classified on a high level and then some of them are
   studied more in detail. Finally, the appendix concludes with
   recommendations about how the various fields should be handled by
   header compression algorithms. The main conclusion that can be drawn
   is that most of the header fields can easily be compressed away since
   they never or seldom change. Only 5 fields, with a combined size of
   about 10 octets, need more sophisticated mechanisms. Those fields
   are:

    - IPv4 Identification (16 bits)   - IP-ID
    - UDP Checksum (16 bits)
    - RTP Marker (1 bit)              - M-bit
    - RTP Sequence Number (16 bits)   - SN
    - RTP Timestamp (32 bits)         - TS

   The analysis in Appendix A reveals that the values of the TS and IP-
   ID fields can usually be predicted from the RTP Sequence Number,
   which increments by one for each packet emitted by an RTP source. M-
   bit is also usually the same, but needs to be communicated explicitly
   occasionally. The UDP checksum should not be predicted and is sent
   as-is when enabled.

   The way ROHC RTP compression operates, then, is to first establish
   functions from SN to the other fields, and then reliably communicate
   the SN. Whenever a function from SN to another field changes, i.e.,
   the existing function gives a result which is different from the
   field in the header to be compressed, additional information is sent
   to update the parameters of that function.

























Bormann (ed.)                                                  [Page 17]

INTERNET-DRAFT          Robust Header Compression           Oct 11, 2000



4.  Header compression framework


4.1.  Operating assumptions

   The cellular links which are a primary target for ROHC have a number
   of characteristics that are briefly described here. ROHC requires
   functionality from lower layers which is outlined here and more
   thoroughly described in the lower layer guidelines document [LLG].

   Channels

     ROHC header-compressed packets flow on channels. Unlike many fixed
     links, some cellular radio links can have several channels
     connecting the same pair of nodes. Each channel can have different
     characteristics in terms of error rate, bandwidth, etc.

   Context identifiers

     On some channels, the ability to transport multiple packet streams
     is required.  It can also be feasible to have channels dedicated to
     individual packet streams. Therefore, ROHC uses a distinct context
     identifier space per channel and can eliminate context identifiers
     completely in channels where only a single packet stream is
     compressed.

   Packet type indication

     Packet type indication is done in the header compression scheme
     itself. Unless the link already has a way of indicating packet
     types which can be used, such as PPP, this provides smaller
     compressed headers, overall. It may also be less difficult to
     allocate a single packet type, rather than many, in order to run
     ROHC over links such as PPP.

   Reordering

     The channel between compressor and decompressor is not assumed to
     reorder packets, i.e., the decompressor receives packets in the
     same order as the compressor sends them.  (Reordering before the
     compression point, however, is dealt with, i.e., there is no
     assumption that the compressor will only receive packets in
     sequence.)

   Packet length


     ROHC is designed under the assumption that lower layers indicate
     the length of a compressed packet. ROHC packets do not contain
     length information for the payload.



Bormann (ed.)                                                  [Page 18]

INTERNET-DRAFT          Robust Header Compression           Oct 11, 2000



   Framing

     The link layer must provide framing, which makes it possible to
     distinguish frame boundaries and individual frames.

   Error detection/protection

     The ROHC scheme has been designed to cope with residual errors in
     the headers delivered to the decompressor. CRCs and sanity checks
     are used to prevent or reduce damage propagation. However, it is
     RECOMMENDED that lower layers deploy error detection for ROHC
     headers and do not deliver ROHC headers with high residual error
     rates.

     Without giving a hard limit on the residual error rate acceptable
     to ROHC, it is noted that for a residual bit error rate of at most
     1E-5, the ROHC scheme has been designed not to increase the number
     of damaged headers, i.e., the number of damaged headers due to
     damage propagation is designed to be less than the number of
     damaged headers caught by the ROHC error detection scheme.

   Negotiation

     In addition to the packet handling mechanisms above, the link layer
     MUST provide a way to negotiate header compression parameters.
     (For unidirectional links, this negotiation may be performed out-
     of-band or even a-priori.)


4.2.  Dynamicity

   The ROHC protocol achieves its compression gain by establishing state
   at both ends of the link, i.e., at the compressor and at the
   decompressor. Different parts of the state are established at
   different times and with different frequency; hence, it can be said
   some state is more dynamic that other state.

   Some state is established at the time a channel is established; ROHC
   assumes the existence of an out-of-band negotiation protocol (such as
   PPP), or pre-defined channel state (most useful for uni-directional
   links). In both cases, we speak of "negotiated channel state".  ROHC
   does not assume that this state can change dynamically during the
   channel lifetime (and does not explicitly support such changes,
   although some changes may be innocuous from a protocol point of
   view).  An example of negotiated channel state is the maximum size of
   packet headers that can be compressed (MAX_HEADER).

   Other state is associated with the individual packet streams in the
   channel; this state is said to be part of the context.  Using context
   identifiers (CIDs), multiple packet streams with different contexts



Bormann (ed.)                                                  [Page 19]

INTERNET-DRAFT          Robust Header Compression           Oct 11, 2000


   can share a channel.  The highest context identifier to be used is
   one of the members of the negotiated channel state, as well as the
   selection of one of two ways to indicate the CID in the compressed
   header.

   It is up to the compressor to decide which packets to associate with
   a context (or, equivalently, which packets constitute a single
   stream); however, ROHC is efficient only when all packets of a stream
   share certain properties, such as having the same values for fields
   that are described as "static" in this document (e.g., the IP
   addresses, port numbers, and RTP parameters such as the payload
   type). The efficiency of ROHC RTP also depends on the compressor
   seeing most RTP sequence numbers.

   Streams need not share all characteristics important for compression.
   ROHC has a notion of compression profiles: a compression profile
   denotes a pre-defined set of such characteristics.  To provide for
   extensibility, the negotiated channel state includes the set of
   profiles acceptable to the decompressor. The context state includes
   the profile currently in use for the context.

   Other elements of the context state may include:  The current value
   of all header fields (from this one can deduce whether an IPv4 header
   is present in the header chain, and whether UDP checksums are
   enabled), as well as additional compression context that is not part
   of an uncompressed header: e.g., TS STRIDE, IP-ID characteristics (in
   network byte order? random?), a number of old reference headers, and
   the compressor/decompressor state machines (see next section).


4.3.  Compression and decompression states

   Header compression with ROHC can be characterized as an interaction
   between two state machines, one compressor machine and one
   decompressor machine, each instantiated once per context. The
   compressor and the decompressor have three states each, which in many
   ways are related to each other even if the meaning of the states are
   slightly different for the two parties. Both machines start in the
   lowest compression state and transits gradually to higher states.
   Transitions need not be synchronized between the two machines. In
   normal operation it is only the compressor that temporarily transits
   back to lower states.

   Subsequent sections present an overview of the state machines and
   their corresponding states respectively, starting with the
   compressor.








Bormann (ed.)                                                  [Page 20]

INTERNET-DRAFT          Robust Header Compression           Oct 11, 2000


4.3.1.  Compressor states

   For ROHC compression, the three compressor states are the
   Initialization and Refresh (IR), First Order (FO), and Second Order
   (SO) states. The compressor starts in the lowest compression state
   (IR) and transits gradually to higher compression states. The
   compressor will always operate in the highest possible compression
   state, under the constraint that the compressor is sufficiently
   confident that the decompressor has the information necessary to
   decompress a header compressed according to that state.

    +----------+                +----------+                +----------+
    | IR State |   <-------->   | FO State |   <-------->   | SO State |
    +----------+                +----------+                +----------+

   Decisions about transitions between the various compression states
   are taken by the compressor based on:

      - variations in packet headers.
      - positive feedback from decompressor (Acknowledgements - ACKs)
      - negative feedback from decompressor (Negative ACKs - NACKs)
      - periodic timeouts (when no feedback is used)

   How transitions are performed is explained in detail in chapter 5 for
   each mode of operation.


4.3.1.1.  Initialization and Refresh (IR) State

   The purpose of the IR state is to initialize the static parts of the
   context at the decompressor or to recover after failure. In this
   state, the compressor sends complete header information. This
   includes all static and non-static fields in uncompressed form plus
   some additional information. Refreshes may also be performed on non-
   static information only.

   The compressor stays in IR state until it is rather confident that
   the decompressor has received the static information correctly.


4.3.1.2.  First Order (FO) State

   The purpose of the FO state is to efficiently communicate
   irregularities in the packet stream. When operating in this state,
   the compressor rarely sends complete information and the information
   sent is usually compressed at least partially. The difference between
   IR and FO should therefore be clear.

   The compressor enters this state from the IR state, and from the SO
   state whenever the headers of the packet stream do not conform to
   their previous pattern. It stays in FO state until it is confident



Bormann (ed.)                                                  [Page 21]

INTERNET-DRAFT          Robust Header Compression           Oct 11, 2000


   that the decompressor has acquired all the parameters of the new
   pattern. Changes in fields that are always irregular are communicated
   in all packets and are therefore part of what is a uniform pattern.

   Since packets sent in the FO state usually carry context updating
   information, successful transmission of this information may be of
   vital importance for successful decompression of subsequent packets.
   The decompression process is sensitive to loss of, or damage to, such
   packets.


4.3.1.3.  Second Order (SO) State

   This is the state where compression is optimal. The compressor enters
   SO state when the header to be compressed is completely predictable
   given the SN, and the compressor is sufficiently confident that the
   decompressor has acquired all parameters of the functions from SN to
   other fields. Packets sent in SO state are almost independent of each
   other and error sensitivity is therefore low. However, successful
   decompression of packets sent in SO state requires that the
   information sent in preceding FO state operations has been
   successfully received by the decompressor.

   The compressor leaves this state and goes back to the FO state when
   the header no longer conforms to the uniform pattern and can not be
   independently compressed based on previous context information.


4.3.2.  Decompressor states

   The decompressor starts in its lowest compression state, "No Context"
   and gradually transits to higher states. The decompressor state
   machine normally never leaves the "Full Context" state when it once
   has started to work in that state.

    +--------------+         +----------------+         +--------------+
    |  No Context  |  <--->  | Static Context |  <--->  | Full Context |
    +--------------+         +----------------+         +--------------+

   When initially working in the "No Context" state, the decompressor
   has never successfully decompressed any packet. When a packet once
   has been decompressed correctly (upon reception of an initialization
   packet with static and dynamic information, for example), the
   decompressor can transit all the way to "Full Context" state, and
   only upon repeated failures will it transit back to lower states.
   However, when that happens it first transits back to "Static Context"
   state. There, reception of any packet sent in FO state is normally
   sufficient to enable transition to "Full Context" state again. Only
   when decompression of several packets sent in FO state fails in
   "Static Context" state will the decompressor go all the way back to
   the "No Context" state.



Bormann (ed.)                                                  [Page 22]

INTERNET-DRAFT          Robust Header Compression           Oct 11, 2000



   When state transitions are performed is explained in detail in
   chapter 5.


4.4.  Modes of operation.

   The ROHC scheme has three modes of operation, called Unidirectional,
   Bi-directional Optimistic, and Bi-directional Reliable mode.

   It is important to understand the difference between states, as
   described in previous chapter, and modes. These abstractions are
   orthogonal to each other. The state abstraction is the same for all
   modes of operation, while the mode controls the logic of state
   transitions and what actions to perform in each state.

                          +----------------------+
                          |  Unidirectional Mode |
                          |   +--+  +--+  +--+   |
                          |   |IR|  |FO|  |SO|   |
                          |   +--+  +--+  +--+   |
                          +----------------------+
                            ^                  ^
                           /                    \
                          /                      \
                         v                        v
     +----------------------+                  +----------------------+
     |   Optimistic Mode    |                  |    Reliable Mode     |
     |   +--+  +--+  +--+   |                  |   +--+  +--+  +--+   |
     |   |IR|  |FO|  |SO|   | <--------------> |   |IR|  |FO|  |SO|   |
     |   +--+  +--+  +--+   |                  |   +--+  +--+  +--+   |
     +----------------------+                  +----------------------+

   The optimal mode to operate in depends on the characteristics of the
   environment of the compression protocol, such as feedback abilities,
   error probabilities and distributions, header size variation effects,
   etc. All ROHC implementations MUST implement and support all three
   modes of operation. The three modes are briefly described in the
   following subsections.

   Detailed descriptions of the three modes of operation regarding
   compression and decompression logic are given in chapter 5. The mode
   transition mechanisms are also described in chapter 5.


4.4.1.  Unidirectional mode - U-mode

   When in the unidirectional mode of operation, packets are sent in one
   direction only; from compressor to decompressor. This mode therefore
   makes ROHC usable over links where a return path from decompressor to
   compressor is not available or is undesirable.



Bormann (ed.)                                                  [Page 23]

INTERNET-DRAFT          Robust Header Compression           Oct 11, 2000



   In U-mode, transitions between compressor states are performed based
   only on periodic timeouts and irregularities in the header field
   change patterns in the compressed packet stream. Due to the periodic
   refreshes and the lack of feedback for initiation of error recovery,
   compression in the unidirectional mode will be less efficient and
   have a slightly higher probability for loss propagation compared to
   any of the bi-directional modes.

   Compression with ROHC MUST start in the unidirectional mode.
   Transition to any of the bi-directional modes can be performed as
   soon as a packet has reached the decompressor and it has replied with
   a feedback packet indicating that a mode transition is desired (see
   chapter 5).


4.4.2.  Bi-directional optimistic mode - O-mode

   The bi-directional optimistic mode is similar to the unidirectional
   mode. The difference is that a feedback channel is used to send error
   recovery requests and (optionally) acknowledgments of significant
   context updates from decompressor to compressor (not for sequence
   number updates only). Periodic refreshes are not used in the bi-
   directional optimistic mode.

   O-mode is designed for good compression efficiency and sparse usage
   of the return channel while maintaining reasonable robustness. Loss
   of compressor-decompressor synchronization and introduction of loss
   propagation is rare even under high probabilistic error rates, but
   can occur with longer consecutive loss events. When loss propagation
   does occur, the amount is limited by the CRC check and NACKing scheme
   used. Nevertheless, this mode is not completely robust against loss
   propagation.


4.4.3.  Bi-directional reliable mode - R-mode

   The bi-directional reliable mode differs in many ways from the
   previous two. The most important differences are a more intensive
   usage of the feedback channel and a stricter logic at both the
   compressor and the decompressor that prevents loss of context
   synchronization between compressor and decompressor except for very
   high residual bit error rates. Feedback is sent to acknowledge all
   context updates, including updates of the sequence number field.
   However, not every packet updates the context in reliable mode.

   The chief advantage of R-mode is almost complete robustness against
   packet loss between compressor and decompressor. Loss propagation can
   never occur due to header compression when operating in this mode.
   For reasonably well-behaving links, the price is slightly higher
   overhead in some cases and additional feedback traffic.



Bormann (ed.)                                                  [Page 24]

INTERNET-DRAFT          Robust Header Compression           Oct 11, 2000



4.5.  Encoding methods

   This chapter describes the encoding methods that are used for
   different header fields. How the methods are applied to each field
   (e.g., values of associated parameters) is specified in section 5.7.


4.5.1. Least Significant Bits (LSB) encoding

   Least Significant Bits (LSB) encoding is used for header fields whose
   values are usually subject to small changes. With LSB encoding, the k
   least significant bits of the field value are transmitted instead of
   the original field value, where k is a positive integer. After
   receiving k bits, the decompressor derives the original value using a
   previously received value as reference (v_ref).

   The scheme is guaranteed to be correct if the compressor and the
   decompressor agree on an interpretation interval

     1) in which the original value resides, and
     2) in which the original value is the only value that has the exact
        same k least significant bits as those transmitted.

   The interpretation interval can be described as a function f(v_ref,
   k). Let

      f(v_ref, k) = [v_ref - p, v_ref + (2^k - 1) - p]

   where p is an integer.


      <------- interpretation interval (size is 2^k) ------->
      |-------------+---------------------------------------|
   v_ref - p        v_ref                        v_ref + (2^k-1) - p


   The function f has the following property: for any value k, k least
   significant bits will uniquely identify a value in f(v_ref, k).

   The parameter p is introduced so that the interpretation interval can
   be shifted with respect to v_ref. Choosing a good value for p will
   yield more efficient encoding for fields with certain
   characteristics. Examples of appropriate values of p are

   a) for field values that are expected to always increase, p can be
      set to -1. The interpretation interval becomes
      [v_ref + 1, v_ref + 2^k].

   b) for field values that stay the same or increase, p can be set to
      0. The interpretation interval becomes [v_ref, v_ref + 2^k - 1].



Bormann (ed.)                                                  [Page 25]

INTERNET-DRAFT          Robust Header Compression           Oct 11, 2000


   c) for field values that are expected to have small deviations around
      a constant value, p can be set to 2^(k-1)-1. The interpretation
      interval becomes [v_ref - 2^(k-1) + 1, v_ref + 2^(k-1)].

   d) for field values that are expected to have small negative changes
      and larger positive changes, such as the RTP TS for video, or RTP
      SN when there is misordering, p can be set to 2^(k-2). The
      interval becomes [v_ref - 2^(k-2) + 1, v_ref + 3 * 2^(k-2)], i.e.,
      3/4 of the interval is used for positive changes.

   The following is a simplified procedure for LSB compression and
   decompression, it is modified for robustness and damage propagation
   protection in the next subsection:

     1) The compressor (decompressor) always uses v_ref_c (v_ref_d), the
        last value that has been compressed (decompressed), as v_ref;

     2) When compressing a value v, the compressor finds the minimal
        value of k such that v falls into the interval f(v_ref_c, k).
        Call this function k = g(v_ref_c, v).

        When only a few distinct values of k are possible, for example
        due to limitations imposed by packet formats (see section 5.7),
        the compressor will instead pick the smallest k of those
        possible such that v is in the interval f(v_ref_c, k).

     3) When receiving m LSBs, the decompressor uses the interpretation
        interval f(v_ref_d, m), called interval d. It picks as the
        decompressed value the one in interval_d whose LSBs match the
        received m bits.

   The scheme is complicated by two factors: packet loss between the
   compressor and decompressor, and transmission errors undetected by
   the lower layer. In the former case, the compressor and decompressor
   will lose the synchronization of v_ref, and thus also of the
   interpretation interval. If v is still covered by the
   intersection(interval_c, interval_d), decompression will be correct.
   Otherwise, incorrect decompression will happen. The next section will
   address this issue further.

   In the case of undetected transmission errors, the corrupted LSBs
   will give an incorrectly decompressed value that will later be used
   as v_ref_d, which in turn is likely to lead to damage propagation.
   This problem is addressed by using a secure reference, i.e., a
   reference value whose correctness is verified by a protecting CRC.
   Consequently, the procedure 1) above is modified as follows:

    1) a) the compressor always uses as v_ref_c the last value that has
          been compressed and sent with a protecting CRC.
       b) the decompressor always uses as v_ref_d the last correct
          value, as verified by a succeeding CRC.



Bormann (ed.)                                                  [Page 26]

INTERNET-DRAFT          Robust Header Compression           Oct 11, 2000



   Note that in U/O mode, 1) b) is modified so that if decompression of
   the SN fails using the last verified SN reference, another
   decompression attempt is made using the last but one verified SN
   reference. This procedure dampens damage propagation when a small CRC
   fails to detect a damaged value.


4.5.2.  Window-based LSB encoding (W-LSB encoding)

   This section describes how to modify the simplified algorithm in
   4.5.1 to achieve robustness.

   The compressor may not be able to determine the exact value of
   v_ref_d that will be used by the decompressor for a particular value
   v, since some candidates for v_ref_d may have been lost or damaged.
   However, by using feedback or by making reasonable assumptions the
   compressor can limit the candidate set. The compressor then
   calculates k such that no matter which v_ref_d in the candidate set
   the decompressor uses, v is covered by the resulting interval_d.

   Since the decompressor always uses the last received value where the
   CRC succeeded as the reference, the compressor maintains a sliding
   window (VSW) containing the candidates for v_ref_d. VSW is initially
   empty. The following operations are performed on VSW by the
   compressor:

     1) After sending a value v (compressed or uncompressed) protected
        by a CRC, the compressor adds v to the VSW;
     2) For each value v being compressed, the compressor chooses k =
        max(g(v, v_min), g(v, v_max)), where v_min and v_max are the
        minimal and maximal values in VSW, and g is the function defined
        in the previous section;
     3) When the compressor has sufficient confidence that a certain
        value v will not be used as a reference by the decompressor, the
        window is advanced by removing v and all values older than v.
        The confidence may be obtained by various means. In R mode an
        ACK from the decompressor implies that values older than the
        ACKed one can be removed from VSW. In U/O mode there is always a
        CRC to verify correct decompression, and a VSW with a limited
        maximum width is used. The window width is an implementation
        dependent optimization parameter.

   Note that the decompressor follows the procedure described in the
   previous section, except that in R mode it MUST ACK each value
   received with a CRC (see also section 5.5).








Bormann (ed.)                                                  [Page 27]

INTERNET-DRAFT          Robust Header Compression           Oct 11, 2000


4.5.2. Scaled RTP Timestamp encoding

   The RTP Timestamp (TS) will usually not increase by an arbitrary
   number from packet to packet. Instead, the increase is normally an
   integral multiple of some unit (TS_STRIDE). For example, in the case
   of audio, the sample rate is normally 8Khz and one voice frame may
   cover 20 ms. Furthermore, each voice frame is usually carried in one
   RTP packet. In this case, the RTP increment is always n * 160 (= 8000
   * 0.02), for some integer n. Note that silence periods has no impact
   on this as the sample clock at the source normally keeps running
   without changing either frame rate or frame boundaries.

   For the case of video, there is usually a TS_STRIDE as well when we
   consider the video frame level. The sample rate for most video codecs
   is 90Khz. If the video frame rate is fixed, say to 30 frames/second,
   the TS will increase by n * 3000 (= n * 90000 / 30) between video
   frames. Note that a video frame is often divided into several RTP
   packets to achieve robustness against packet loss. In this case
   several RTP packets will carry the same TS.

   When using scaled RTP Timestamp encoding, the TS is downscaled by a
   factor of TS_STRIDE before compression. This saves

       floor(log2(TS_STRIDE))

   bits for each compressed TS. The following equality holds between TS
   and TS SCALED:

       TS = TS SCALED * TS STRIDE + TS OFFSET

   TS STRIDE is explicitly, and TS OFFSET implicitly, communicated to
   the decompressor. The following algorithm is used:

     1. Initialization: The compressor sends to the decompressor the
        value of TS_STRIDE (e.g., via in-band signaling, see packet
        format section) and the absolute value of one or several TS. The
        latter are used by the decompressor to initialize TS_OFFSET to
        (absolute value) modulo TS_STRIDE. Note that TS OFFSET is the
        same regardless of which absolute value is used, as long as the
        unscaled TS value does not wrap around, see 4) below.

     2. Compression: After initialization, the compressor no longer
        compresses the original TS values. Instead, it compresses the
        down-scaled values: TS_SCALED = TS / TS_STRIDE. The compression
        method could be either W-LSB encoding or the timer-based
        encoding described in the next section.


     3. Decompression: When receiving the compressed value of TS_SCALED,
        the decompressor first derives the value of the original




Bormann (ed.)                                                  [Page 28]

INTERNET-DRAFT          Robust Header Compression           Oct 11, 2000


        TS_SCALED. The original RTP TS is then calculated as TS =
        TS_SCALED * TS_STRIDE + TS_OFFSET.


     4. Wrap around: Wrap around of the unscaled 32-bit TS will
        invalidate the current value of TS_OFFSET used in the equation
        above. For example, let's assume TS_STRIDE = 160 = 0xA0 and the
        current TS = 0xFFFFFFF0. TS_OFFSET is then 0x50 = 80. Then if
        the next RTP TS = 0x00000130 (i.e., the increment is 160 * 2 =
        320), the new TS_OFFSET should be 0x00000130 modulo 0xA0 = 0x90
        = 144. The compressor is not required to re-initialize TS OFFSET
        at wrap around. Instead, the decompressor MUST detect wrap
        around of the unscaled TS (which is trivial) and update
        TS_OFFSET to


           TS OFFSET = (Wrapped around unscaled TS) modulo TS STRIDE

   This scaling method can be applied to many frame-based codecs.
   However, the value of TS_STRIDE might change during a session, for
   example due to adaptation strategies. If that happens, the unscaled
   TS is compressed until re-initialization of the new TS_STRIDE and
   TS_OFFSET is completed.


4.5.4.  Timer-Based Compression of RTP Timestamp

   The RTP timestamp [RFC 1889] is defined to identify the number of the
   first sample used to generate the payload. When RTP packets carry
   payloads corresponding to a fixed sampling interval, the sampling is
   done at a constant rate, and packets are generated in lock-step with
   sampling, the timestamp will closely follow a linear pattern as a
   function of the time of day. This is the case for conversational
   media, such as interactive speech. The linear ratio is determined by
   the source sample rate. The linear pattern can be complicated by
   packetization (e.g., in the case of video where a video frame usually
   corresponds to several RTP packets) or frame re-arrangement (e.g.,
   MPEG B-frames are sent out-of-order by some video codecs).

   With a fixed sample rate of 8kHz, 20 ms in time domain is equivalent
   to an increment of 160 in the unscaled TS domain, and to an increment
   of 1 in the scaled TS domain with TS_STRIDE=160.

   As a consequence, the (scaled) TS of headers coming to the
   decompressor will follow a linear pattern as a function of time of
   day, with some deviation due to the delay jitter between the source
   and the decompressor. In normal operation, i.e., no crashes or
   failures, the delay jitter will be bounded to meet the requirements
   of conversational real-time traffic.  Hence, by using a local clock
   the decompressor can obtain an approximation of the (scaled) TS in
   the header to be decompressed by considering its arrival time. The



Bormann (ed.)                                                  [Page 29]

INTERNET-DRAFT          Robust Header Compression           Oct 11, 2000


   approximation can then be refined with the k LSBs of the (scaled) TS
   carried in the header. The required value of k to ensure correct
   decompression is a function of the jitter between the source and
   decompressor.

   If the compressor knows the potential jitter introduced between
   compressor and decompressor, it can determine k by using a local
   clock to estimate jitter in packet arrival times, or alternatively it
   can use a fixed k and discard packets arriving too much out of time.

   The advantages of this scheme include:

   a) The size of the compressed TS is constant and small. In
      particular, it does NOT depend on the length of silence intervals.
      This is in contrast to other TS compression techniques, which at
      the beginning of a talk-spurt requires sending a number of bits
      dependent on the duration of the preceding silence interval.

   b) No synchronization is required between the clock local to the
      compressor and the clock local to the decompressor.

   Note that although this scheme can be made to work using both scaled
   and unscaled TS, in practice it is always combined with scaled TS
   encoding because of the less demanding requirement on the clock
   resolution, e.g., 20 ms instead of 1/8 ms. Therefore, the algorithm
   described below assumes that the clock-based encoding scheme operates
   on the scaled TS. The case of unscaled TS would be similar, with
   changes to scale factors.

   Compressor: its major task is to determine the value of k. Its
   sliding window, TSW, now contains not only potential reference values
   for the TS, but also their times of arrival at the compressor.

     1) The compressor maintains a sliding window TSW = {(T_j, a_j),
        for each header j that can be used as a reference}, where T_j is
        the scaled TS for header j, and a_j is the arrival time of
        header j. The TSW fills the same purpose as the VSW of section
        4.5.2.

     2) When a new header n arrives with T_n as the scaled TS, the
        compressor notes the arrival time a_n. It then calculates

        Max_Jitter_BC =

            max {|(T_n - T_j) - ((a_n - a_j) / TIME_STRIDE)|,
                 for all headers j in TSW},

        where TIME_STRIDE is the time interval equivalent to one
        TS_STRIDE, e.g., 20 ms. Max_Jitter_BC is the maximum observed
        jitter before the compressor, in units of TS_STRIDE, for the
        headers in TSW.



Bormann (ed.)                                                  [Page 30]

INTERNET-DRAFT          Robust Header Compression           Oct 11, 2000



     3) k is calculated as: k = ceiling(log2(2 * J + 1), where J =
        Max_Jitter_BC + Max_Jitter_CD + 2.

        Max_Jitter_CD is the upper bound of jitter expected on the
        communication channel between compressor and decompressor (CD-
        CC). It depends only on the characteristics of CD-CC.

        The factor 2 accounts for the quantization error introduced by
        the clocks at the compressor and decompressor, which can be +/-
        1.

        Note that the calculation of k follows the compression algorithm
        described in section 4.5.1, with p = 2^(k-1) - 1.

     4) TSW is subject to the same window operations as in section
        4.5.2, 1) and 3), except that the values added and removed are
        paired with their arrival times.

   Decompressor:

     1) The decompressor uses as its reference header the last correctly
        (as verified by CRC) decompressed header. It maintains the pair
        (T_ref, a_ref), where T_ref is the scaled TS of the reference
        header, and a_ref is the arrival time of the reference header.

     2) When receiving a compressed header n at time a_n, the
        approximation of the original scaled TS is calculated as:

            T_approx = T_ref + (a_n - a_ref) / TIME_STRIDE.

     3) The approximation is then refined by the k least significant
        bits carried in header n, following the decompression algorithm
        of section 4.5.1, with p = 2^(k-1) - 1.

   Note: the algorithm does not assume any particular pattern in the
   packets arriving to the compressor, i.e., it tolerates reordering
   before the compressor and non-increasing RTP timestamp behavior.

   Note: Integer arithmetic is used in all equations above. If
   TIME_STRIDE is not equal to an integral number of clock ticks, time
   must be normalized such that TIME_STRIDE is an integral number of
   clock ticks. For example, if a clock tick is 20 ms and TIME STRIDE is
   30 ms, (a_n - a_ref) in 2) can be multiplied by 3 and TIME_STRIDE can
   have the value 2.

   Note: the clock resolution of compressor or decompressor can be worse
   than TIME_STRIDE, in which case the difference, i.e., actual
   resolution - TIME_STRIDE, is treated as additional jitter in the
   calculation of k.




Bormann (ed.)                                                  [Page 31]

INTERNET-DRAFT          Robust Header Compression           Oct 11, 2000


   Note: the clock resolution of the decompressor may be communicated to
   the compressor using the CLOCK feedback option.

   Note: the decompressor may observe the jitter and report this to the
   compressor using the JITTER feedback option. The compressor may use
   this information to refine its estimate of Max_Jitter_CD.

4.5.5.  Offset IP-ID encoding

   As all IPv4 packets have an IP Identifier to allow for fragmentation,
   ROHC provides for transparent compression of this ID.  There is no
   explicit support in ROHC for the IPv6 fragmentation header, so there
   is never a need to discuss IP IDs outside the context of IPv4.

   This section assumes (initially) that the IPv4 stack at the source
   host assigns IP-ID to the value of a 2-byte counter which is
   increased by one after each assignment to an outgoing packet.
   Therefore, the IP-ID field of a particular IPv4 packet flow will
   increment by 1 from packet to packet except when the source has
   emitted intermediate packets not belonging to that flow.

   For such IPv4 stacks, the RTP SN will increase by 1 for each packet
   emitted and the IP-ID will increase by at least the same amount.
   Thus, it is more efficient to compress the offset, i.e., (IP-ID - RTP
   SN), instead of IP-ID itself.

   The following text describes how to compress/decompress the sequence
   of offsets using W-LSB encoding/decoding, with p = 0 (see section
   4.5.1).  All IP-ID arithmetic is done using unsigned 16-bit
   quantities, i.e. modulo 2^16.

   Compressor:

     The compressor uses W-LSB encoding to compress a sequence of
     offsets

        Offset_i = ID_i - SN_i,

     where ID_i and SN_i are the values of the IP-ID and RTP SN of
     header i. The sliding window contains such offsets and not the
     values of header fields, but the rules for adding and deleting
     offsets from the window otherwise follow section 4.5.2.

   Decompressor:

     The reference header is the last correctly (as verified by CRC)
     decompressed header.

     When receiving a compressed packet m, the decompressor calculates
     Offset_ref = ID_ref - SN_ref, where ID_ref and SN_ref are the
     values of IP-ID and RTP SN in the reference header, respectively.



Bormann (ed.)                                                  [Page 32]

INTERNET-DRAFT          Robust Header Compression           Oct 11, 2000


     Then W-LSB decoding is used to decompress Offset_m, using the
     received LSBs in packet m and Offset_ref. Note that m may contain
     zero LSBs for Offset_m, in which case Offset_m = Offset_ref.

     Finally, the IP-ID for packet m is regenerated as

       IP-ID for m = decompressed SN of packet m + Offset_m


   Network byte order:

   Some IPv4 stacks do use a counter to generate IP ID values as
   described, but do not transmit the contents of this counter in
   network byte order, but instead send the two octets reversed. In this
   case, the compressor can compress the IP-ID field after swapping the
   bytes. Consequently, the decompressor also swaps the bytes of the IP-
   ID after decompression to regenerate the original IP-ID. This
   requires that the compressor and the decompressor synchronize on the
   byte order of the IP-ID field using the NBO or NBO2 flag (see section
   5.7.)

   Random IP Identifier:

   Some IPv4 stacks generate the IP Identifier values using a pseudo-
   random number generator. While this may provide some security
   benefits, it makes it pointless to attempt compressing the field.
   Therefore, the compressor should detect such random behavior of the
   field. After detection and synchronization with the decompressor
   using the RND or RND2 flag, the field is sent as-is in its entirety
   as additional octets after the compressed header.


4.5.6.  Self-describing variable-length values.

   The values of TS STRIDE and a few other compression parameters can
   vary widely. TS STRIDE can be 160 for voice and 90 000 for 1 f/s
   video. To optimize the transfer of such values, a variable number of
   octets is used to encode them. The first few bits of the encoded
   value determines its length.

   1 octet: first bit is zero. 7 bits transferred. Up to 127 decimal.
               Encoded octets in hexadecimal: 00 to 7F

   2 octets: first bits 10. 14 bits. Up to 16 383 decimal.
               Encoded octets in hexadecimal: 80 00 to BF FF

   3 octets: first bits 110. 21 bits. Up to 2 097 151 decimal.
               Encoded octets in hexadecimal: C0 00 00 to DF FF FF

   4 octets: first bits 111. 29 bits. Up to 536 870 911 decimal.
               Encoded octets in hexadecimal: E0 00 00 00 to FF FF FF FF



Bormann (ed.)                                                  [Page 33]

INTERNET-DRAFT          Robust Header Compression           Oct 11, 2000




4.5.7.  Encoded values across several fields in compressed headers.

   When a compressed header has an extension, pieces of an encoded value
   can be present in more than one field. When an encoded value is split
   over several fields in this manner, the more significant bits of the
   value are closer to the beginning of the header. If the number of
   bits available in compressed header fields exceeds the number of bits
   of the value, the most significant field is padded with zeroes in its
   most significant bits.

   For example, an unscaled TS value can be transferred using an UOR-2
   header (see section 5.7) with an extension of type 3. The Tsc bit of
   the extension is then unset and the variable length TS field of the
   extension is 4 octets (see section 4.5.6). The UOR-2 TS field will
   contain the most significant three bits of the unscaled TS, and the
   4-octet TS field in the extension contains the remaining 29 bits.




































Bormann (ed.)                                                  [Page 34]

INTERNET-DRAFT          Robust Header Compression           Oct 11, 2000


5.  The protocol


5.1.  Data structures

   The ROHC protocol is based on a number of parameters that form part
   of the negotiated channel state and the per-context state.  This
   section describes some of this state in an abstract way.
   Implementations can use a different structure and representation of
   this state.  In particular, negotiation protocols that set up per-
   channel state need to establish the information that constitutes the
   negotiated channel state, but not necessarily have to exchange it in
   the form it is described here.

5.1.1.  Per-channel parameters

   MAX_CID: non-negative integer; highest context ID number to be used
   by the compressor (note that this parameter is not coupled to, but in
   effect further constrained by, LARGE_CIDS).

   LARGE_CIDS: Boolean; if false, the short CID representation (0 bytes
   or 1 prefix byte, covering CID 0 to 15) is used, if true, the
   embedded CID representation (1 or 2 embedded CID bytes covering CID 0
   to 16383) is used.

   PROFILES: Set of non-negative integers, indicating which profiles are
   supported by the decompressor.

   FEEDBACK_FOR: Optional reference to a channel in the reverse
   direction.  If set, this indicates which channel any feedback sent on
   this channel refers to (see 5.7.6.1).

5.1.2.  Per-context parameters, profiles

   Per-context parameters are established in the I/R headers (see
   section 5.7).  Note that the profile parameter influences the
   semantics of the packet type identifiers and packet types of the
   profile used for a specific context.  This document describes
   profiles 0, 1, and 2; further profiles may be defined when ROHC is
   extended in the future.

   Profile 0 is for sending uncompressed IP packets. See section 5.10.

   Profile 1 is for RTP/UDP/IP compression, see sections 5.3 to 5.9.

   Profile 2 is for UDP/IP compression, i.e., compression of the first
       12 octets of the UDP payload is not attempted. See section 5.11.







Bormann (ed.)                                                  [Page 35]

INTERNET-DRAFT          Robust Header Compression           Oct 11, 2000



5.1.3.  Contexts and context identifiers

   Associated with each compressed flow is a context, which is the state
   compressor and decompressor maintains in order to correctly compress
   or decompress the headers of the flow. Contexts are identified by a
   context identifier, CID, which is sent along with compressed headers
   and feedback information.

   The CID space is distinct for each channel, i.e., CID 3 over channel
   A and CID 3 over channel B do not refer to the same context, even if
   the endpoints of A and B are the same nodes.  In particular, CIDs for
   any pairs of forward and reverse channels are not related (forward
   and reverse channels need not even have the same size CID space).

   Context information is conceptually kept in a table. The context
   table is indexed using the CID which is sent along with compressed
   headers and feedback information. The CID space can be negotiated to
   be either small, which means that CIDs can take the values 0 through
   15, or large, which means that CIDs take values between 0 and 2^14-1
   = 16383. Whether the CID space is large or small is negotiated no
   later than when a channel is established.

   A small CID is either CID 0, which is represented using zero bits, or
   CID 1 to 15, which are represented using a packet type plus four
   bits.  A large CID is represented using the encoding scheme of
   section 4.5.6., limited to two octets.


5.2. ROHC Packets & packet types

   A ROHC packet has the following general format.

    --- --- --- --- --- --- --- ---
   /           Padding             /
    --- --- --- --- --- --- --- ---
   /           Feedback            /
    --- --- --- --- --- --- --- ---
   /            Header             /
    --- --- --- --- --- --- --- ---
   /           Payload             /
    --- --- --- --- --- --- --- ---

   Padding is any number (zero or more) of padding octets.

   Padding Octet

     0   1   2   3   4   5   6   7
   +---+---+---+---+---+---+---+---+
   | 1   1   1   0   0   0   0   0 |
   +---+---+---+---+---+---+---+---+



Bormann (ed.)                                                  [Page 36]

INTERNET-DRAFT          Robust Header Compression           Oct 11, 2000



   (Note that the Padding Octet looks like, and in some implementations
   can be processed as, an Add-CID Octet for CID 0.)

   Either of Feedback or Header must be present. Header is either a
   profile-specific header or an IR header (see 5.2.5). Feedback and
   Header either

   1) do not carry any CID information (indicating CID zero), or

   2) start with one Add-CID Octet (see below), or

   3) contain embedded CID information of length one or two octets.

   Alternatives 1) and 2) apply only to compressed headers in channels
   where the CID space is small, and feedback related to such headers.
   Alternative 3) applies only to compressed headers in channels where
   the CID space is large, and feedback related to such headers.

   Add-CID Octet

     0   1   2   3   4   5   6   7
   +---+---+---+---+---+---+---+---+
   | 1   1   1   0 |      CID      |
   +---+---+---+---+---+---+---+---+

      CID:   0x1 through 0xF indicates CIDs 1 through 15.
             (0x0 indicates a padding octet.)


   All packet types except the feedback type have the following general
   format:

     0              x-1  x       7
    --- --- --- --- --- --- --- ---
   |         Add-CID octet         | if for CID 1-15 and small CIDs
   +---+--- --- --- ---+--- --- ---+
   | type indication   |   body    | 1 octet (8-x bits of body)
   +---+--- ---+---+---+--- --- ---+
   |                               |
   /    0, 1, or 2 octets of CID   / 1 or 2 octets if large CIDs
   |                               |
   +---+---+---+---+---+---+---+---+
   /             body              /  variable
   +---+---+---+---+---+---+---+---+

   The large CID, if present, is encoded according to section 4.5.6.







Bormann (ed.)                                                  [Page 37]

INTERNET-DRAFT          Robust Header Compression           Oct 11, 2000


5.2.1.  ROHC feedback

   Feedback carries information from decompressor to compressor. The
   following principal kinds of feedback is supported. In addition to
   the kind of feedback, other information may be included in profile-
   specific feedback information.

   ACK         : Acknowledges successful decompression of a packet,
                 which means that the context is up to date with a
                 high probability.

   NACK        : Indicates that the dynamic context of the
                decompressor is out of sync. Generated when several
                packets have failed to decompressed correctly.

   STATIC-NACK : Indicates that the static context of the decompressor
                 is not valid or has not been established.

   It is anticipated that feedback to the compressor can be realized in
   many ways, depending on the properties of the particular lower layer.
   The exact details of how feedback is realized is to be specified in a
   "ROHC over X" document, for each lower layer X in question. As
   examples, feedback might be realized using

   1) lower-layer specific mechanisms, or

   2) a dedicated feedback-only channel, realized for example by the
      lower layer providing a way to indicate that a packet is a
      feedback packet, or

   3) a dedicated feedback-only channel, where the timing of the
      feedback provides information about which compressed packet caused
      the feedback, or

   4) interleaving of feedback packets among normal compressed packets
      going in the same direction as the feedback (lower layers do not
      indicate feedback), or

   5) piggybacking of feedback information in compressed packets going
      in the same direction as the feedback (this technique may reduce
      the per-feedback overhead).

   6) Interleaving and piggybacking in the same channel, i.e., both 4)
      and 5).

   Alternatives 1-3 do not place any particular requirements on the ROHC
   packet type scheme. Alternatives 4-6 do, however. The ROHC packet
   type scheme has been designed to allow alternatives 4-6, these may be
   used for example over PPP.





Bormann (ed.)                                                  [Page 38]

INTERNET-DRAFT          Robust Header Compression           Oct 11, 2000


   A)the ROHC scheme provides a feedback packet type. The packet type
     is able to carry variable-length feedback information.

   B)The feedback information sent in a particular channel is passed
     to, and interpreted by, the compressor associated with feedback on
     that channel. Thus, the feedback information must contain CID
     information if the associated compressor can use more than one
     context. How a compressor is associated with feedback on a
     particular channel needs to be defined in a "ROHC over X"
     document.

   C)The ROHC feedback information format is octet-aligned, i.e.,
     starts at an octet boundary, to allow using the format over a
     dedicated feedback channel, 2).

   D)To allow piggybacking, 5), it is possible to deduce the length of
     feedback information by examining the first few octets of the
     feedback. This allows the decompressor to pass piggybacked
     feedback information to the associated same-side compressor
     without understanding its format. The length information decouples
     the decompressor from the compressor in the sense that the
     decompressor can process the compressed header immediately without
     waiting for the compressor to hand it back after parsing the
     feedback information.

5.2.2.  ROHC feedback packet type


   Feedback sent in a ROHC channel has the following format:

     0   1   2   3   4   5   6   7
    --- --- --- --- --- --- --- ---
   |         Add-CID octet         |  if for CID!=0 for small CIDs
   +---+---+---+---+---+---+---+---+
   | 1   1   1   1   1   0 | Code  |  feedback type octet
   +---+---+---+---+---+---+---+---+
   :             Size              :  if Code=0
   +---+---+---+---+---+---+---+---+
   |                               |
   /   0-2 octets of CID info      /  1-2 octets if for large CIDs
   |                               |
   +---+---+---+---+---+---+---+---+
   /           feedback            /
   +---+---+---+---+---+---+---+---+

       Code:   0 indicates that a Size octet is present.
               1-3 indicates the feedback size. The feedback size
               includes the CID info field but not the Add-CID octet.

      Size: indicates the size of feedback plus CID info (not including
            the Add-CID octet).



Bormann (ed.)                                                  [Page 39]

INTERNET-DRAFT          Robust Header Compression           Oct 11, 2000



      CID info: 1-2 octets if for large CIDs. Encoded according to
                section 4.5.6.

      Feedback: Profile-specific feedback information.

   The Add-CID octet or CID info identifies the context the feedback
   refers to.

   The total size of the feedback information is determinable upon
   reception by the decompressor. By inspecting the Code field and
   possibly the Size field, the decompressor can determine the size of
   the feedback. This explicit length information allows piggybacking
   and also sending of more than one feedback element in interleaved
   feedback. The decompressor does not need to know whether the
   associated compressor uses large or small CIDs.

   When the decompressor has determined the size of the feedback, it
   removes the feedback type octet and the Size field and gives the rest
   to the same-side associated compressor together with an indication of
   its total size (including Add-CID octet if present). The information
   received by the compressor has the following structure.

   Feedback information received by compressor

     0   1   2   3   4   5   6   7
    --- --- --- --- --- --- --- ---
   |         Add-CID octet         |  if for CID!=0 for small CIDs
   +---+---+---+---+---+---+---+---+
   |                               |
   /   0-2 octets of CID info      /  1-2 octets if for large CIDs
   |                               |
   +---+---+---+---+---+---+---+---+
   /           feedback            /
   +---+---+---+---+---+---+---+---+


   The ROHC scheme requires that feedback has either of the following
   two formats

   FEEDBACK-1

     0   1   2   3   4   5   6   7
   +---+---+---+---+---+---+---+---+
   | profile specific information  | 1 octet
   +---+---+---+---+---+---+---+---+


   FEEDBACK-2

     0   1   2   3   4   5   6   7



Bormann (ed.)                                                  [Page 40]

INTERNET-DRAFT          Robust Header Compression           Oct 11, 2000


   +---+---+---+---+---+---+---+---+
   |Acktype|                       |
   +---+---+   profile specific    / at least 2 octets
   /             information       |
   +---+---+---+---+---+---+---+---+

     Acktype:  0 = ACK
               1 = NACK
               2 = STATIC-NACK
               3 is reserved (must not be used)


   The compressor can use the following logic to parse received feedback
   information.

      1) If for large CIDs, the feedback will always start with a CID
         encoded according to section 4.5.6. If the first bit is 0, the
         CID uses one octet. If the first bit is 1, the CID uses two
         octets.
      2) If for small CIDs and the size is one octet, the feedback is a
         FEEDBACK-1 (see 5.7.6.2).
      3) If for small CIDs, the size is larger than one octet, and the
         feedback starts with the two bits 11, the feedback starts with
         an Add-CID octet. If the size is 2, it is followed by a
         FEEDBACK-1. If the size is larger than 2 the Add-CID is
         followed by a FEEDBACK-2.
      4) Otherwise, there is no Add-CID octet and the feedback starts
         with a FEEDBACK-2.

5.2.3.  ROHC IR packet type


   The IR header associates a CID with a profile. It has the following
   general format.

     0   1   2   3   4   5   6   7
    --- --- --- --- --- --- --- ---
   |         Add-CID octet         |  if for CID!=0 for small CIDs
   +---+---+---+---+---+---+---+---+
   | 1   1   1   1   1   1   0 | x |  IR type octet
   +---+---+---+---+---+---+---+---+
   |                               |
   /      0-2 octets of CID        /  1-2 octets if for large CIDs
   |                               |
   +---+---+---+---+---+---+---+---+
   |            Profile            |  1 octet
   +---+---+---+---+---+---+---+---+
   |              CRC              |  1 octet
   +---+---+---+---+---+---+---+---+
   |                               |
   / profile specific information  /  variable length



Bormann (ed.)                                                  [Page 41]

INTERNET-DRAFT          Robust Header Compression           Oct 11, 2000


   |                               |
    - - - - - - - - - - - - - - - -

     x:  profile specific information

     Profile: the profile to be associated with the CID.

     CRC: 8-bit CRC computed using the polynomial of section 5.9.1. Its
         coverage is profile-dependent, but it should cover at least
         the initial part of the packet ending with the Profile field.
         Any information which initializes the context of the
         decompressor should be protected by the CRC.

     Profile specific information: this part of the IR packet is
         defined by the individual profiles.

5.2.4.  ROHC Initial decompressor processing

   The following packet types are reserved in the ROHC scheme:

   1110:    Padding or Add-CID octet
   111110:  Feedback
   1111110: IR packet

   Other packet types can be used at will by individual profiles.

   The following steps is an outline of initial decompressor processing
   which upon reception of a ROHC packet can determine its contents.

   1) If the first octet is a Padding Octet (11100000),
           strip away all initial Padding Octets and goto next step.

   2) If the first remaining octet starts with 1110, it is an Add-CID
      octet.
           remember the Add-CID octet; remove octet.

   3) If the first remaining octet starts with 111110, this is feedback.
           find the size of the feedback, call it s;
           Remove the feedback type octet;
           Remove the size octet if code was 0;
           If an Add-CID was found in 2),
               Prepend it to the feedback;
               Let s be s+1;
           Send feedback of length s to same-side associated compressor;
           If packet exhausted, stop. Otherwise goto 2);

   4) Here, it is known that the rest is forward information.

   5) If the forward traffic uses small CIDs, there is no large CID in
      the packet. If an Add-CID immediately preceded the packet (step
      2), it has the CID of the Add-CID. Otherwise it has CID 0.



Bormann (ed.)                                                  [Page 42]

INTERNET-DRAFT          Robust Header Compression           Oct 11, 2000



   6) If the forward traffic uses large CIDs, the CID starts with the
      second remaining octet.

   7) Use the CID to find the context. The profile noted in the context
      determines how the rest of the packet should be interpreted.

   The procedure for examining the first few octets of the feedback to
   find its size is as follows:

     Examine the two bits which immediately follow the feedback packet
     type. When these bits are
         1-3: the size of the feedback is given by the bits.
         0:   a Size octet, which explicitly gives the size of the
              feedback, is present after the feedback type octet.


5.2.5.  ROHC RTP Packet formats from compressor to decompressor


   ROHC RTP uses three packet types to identify compressed headers, and
   two for initialization/refresh. The format of a compressed packet can
   depend on the mode. Therefore a naming scheme of the form

       <modes format is used in>-<packet type number>-<some property>

   is used to uniquely identify the format when necessary. E.g, UOR-2,
   R-1. For exact formats of the packet types, see section 5.7.

   Packet type zero: R-0, R-0-CRC, UO-0.

     This, the minimal, packet type is used when parameters of all SN-
     functions are known by the decompressor, and the header to be
     compressed adheres to those functions. Thus, only the W-LSB encoded
     RTP SN needs to be communicated.

     R-mode:  Only if a CRC is present (packet type R-0-CRC) may the
     header be used as a reference for subsequent decompression.

     U-mode and O-mode: A small CRC is present in the UO-0 packet.

   Packet type 1: R-1, R-1-ID, R-1-TS, UO-1, UO-1-ID, UO-1-TS.

     This packet type is used when the number of bits needed for the SN
     exceeds those available in packet type zero, or when the parameters
     of the SN-functions for RTP TS or IP-ID change.

     R-mode: R-1-* packets are not used as references for subsequent
     decompression. Values for other fields than the RTP TS or IP-ID can
     be communicated using an extension, but they do not update the
     context.



Bormann (ed.)                                                  [Page 43]

INTERNET-DRAFT          Robust Header Compression           Oct 11, 2000



     U-mode and O-mode: Only the values of RTP SN, RTP TS and IP-ID can
     be used as references for future compression. Non-updating values
     can be provided for other fields using an extension (UO-1-ID).

   Packet type 2: UOR-2, UOR-2-ID, UOR-2-TS

     This packet type can be used to change the parameters of any SN-
     function, except for those for most static fields. Headers of
     packets transferred using packet type 2 can be used as references
     for subsequent decompression.

   Packet type 5: IR

     This packet type communicates the static part of the context, i.e.,
     the value of the constant SN-functions. It can optionally also
     communicate the dynamic part of the context, i.e., the parameters
     of the non-constant SN-functions.

   Packet type 6: IR-DYN

     This packet type communicates the dynamic part of the context,
     i.e., the parameters of non-constant SN-functions.


5.2.6.  Parameters needed for mode transition in ROHC RTP

   The packet type UOR-2 is common for all modes. It can carry an
   extension with a mode parameter which can take the values U  =
   Unidirectional, O = Bi-directional Optimistic, and R= Bi-directional
   Reliable.

   Feedback of types ACK, NACK, and STATIC-NACK carry sequence numbers
   and feedback packets can also carry a mode parameter indicating the
   desired compression mode: U, O, or R.

   As a shorthand, the notation PACKET(mode) is used to indicate which
   mode value a packet carries. For example, an ACK with mode parameter
   R is written ACK(R), and an UOR-2 with mode parameter O is written
   UOR-2(O).














Bormann (ed.)                                                  [Page 44]

INTERNET-DRAFT          Robust Header Compression           Oct 11, 2000


5.3.  Operation in unidirectional mode

5.3.1.  Compressor states and logic (U-mode)

   Below is the state machine for the compressor in unidirectional mode.
   Details of the transitions between states and compression logic are
   given subsequent to the figure.

                            Optimistic approach
      +------>------>------>------>------>------>------>------>------+
      |                                                              |
      |        Optimistic approach         Optimistic approach       |
      |      +------>------>------+      +------>------>------+      |
      |      |                    |      |                    |      |
      |      |                    v      |                    v      v
    +----------+                +----------+                +----------+
    | IR State |                | FO State |                | SO State |
    +----------+                +----------+                +----------+
      ^      ^                    |      ^                    |      |
      |      |      Timeout       |      |  Timeout / Update  |      |
      |      +------<------<------+      +------<------<------+      |
      |                                                              |
      |                           Timeout                            |
      +------<------<------<------<------<------<------<------<------+


5.3.1.1.  State transition logic (U-mode)

   The transition logic for compression states in unidirectional mode is
   based on three principles; the optimistic approach principle,
   timeouts, and the need for updates.


5.3.1.1.1.  Optimistic approach, upwards transition

   Transition to higher compression state in unidirectional mode is
   carried out according to the optimistic approach principle. This
   means that the compressor transits to a higher compression state when
   it is rather confident that the decompressor has received enough
   information to correctly decompress packets sent according to the
   higher compression state.

   When the compressor is in IR state, it will stay there until it
   assumes that the decompressor has correctly received the static
   context information. For transition from FO to SO state, the
   compressor should be confident that the decompressor has all
   parameters needed to decompress according to a fixed pattern.

   The compressor normally gets its confidence about decompressor status
   by sending several packets with the same information according to the
   lower compression state. If the decompressor receives any of these



Bormann (ed.)                                                  [Page 45]

INTERNET-DRAFT          Robust Header Compression           Oct 11, 2000


   packets, it will be in sync with the compressor. The number of
   consecutive packets to send for confidence is not defined in this
   document.


5.3.1.1.2.  Timeouts, downward transition

   By using the optimistic approach described above, there will always
   be a possibility for failure since the decompressor may not have
   received sufficient information for correct decompression. Therefore,
   the compressor MUST periodically transit to lower compression states.
   Periodic transition to IR state SHOULD be carried out less often than
   transition to FO state. Two different timeouts SHOULD therefore be
   used for these transitions. For an example of how to implement
   periodic refreshes, see [IPHC] chapter 3.3.1-3.3.2.


5.3.1.1.3.  Need for updates, downward transition

   In addition to the downward state transitions carried out due to
   periodic timeouts, the compressor must also immediately transit back
   to FO state when the header to be compressed does not confirm to the
   established pattern.


5.3.1.2.  Compression logic and packets used (U-mode)

   The compressor chooses the smallest possible packet format that can
   communicate the desired changes, and has the required bits for W-LSB
   encoded values. Sliding windows used in W-LSB encoding have a fixed
   width, not defined in this document.


5.3.1.3.  Feedback in unidirectional mode

   The unidirectional mode of operation is designed to operate over
   links where a feedback channel is not available. If a feedback
   channel is available, however, the decompressor MAY send an
   acknowledgment of successful decompression with the mode parameter
   set to U (send an IR-ACK(U)). When the compressor receives such a
   message, it MAY disable (or increase the interval between) periodic
   IR refreshes.


5.3.2.  Decompressor states and logic (U-mode)

   Below is the state machine for the decompressor in unidirectional
   mode. Details of the transitions between states and decompression
   logic are given subsequent to the figure.

                                  Success



Bormann (ed.)                                                  [Page 46]

INTERNET-DRAFT          Robust Header Compression           Oct 11, 2000


                 +-->------>------>------>------>------>--+
                 |                                        |
     No Static   |            No Dynamic        Success   |    Success
      +-->--+    |             +-->--+      +--->----->---+    +-->--+
      |     |    |             |     |      |             |    |     |
      |     v    |             |     v      |             v    |     v
    +--------------+         +----------------+         +--------------+
    |  No Context  |         | Static Context |         | Full Context |
    +--------------+         +----------------+         +--------------+
       ^                         |        ^                         |
       |    Repeated failure     |        |    Repeated failure     |
       +-----<------<------<-----+        +-----<------<------<-----+


5.3.2.1.  State transition logic (U-mode)

   The state transition logic of the decompressor is much simpler than
   for the compressor side. It is also common for all the three modes of
   operation. Successful decompression will always move the decompressor
   to the Full Context state. Repeated failed decompression will force
   the decompressor to transit downwards to a lower state. The
   decompressor does not attempt to decompress headers at all in the No
   Context and Static Context states unless sufficient information is
   included in the packet itself.


5.3.2.2.  Decompression logic (U-mode)

   Decompression in unidirectional mode is carried out following three
   steps which are described in subsequent sections.


5.3.2.2.1.  Decide whether decompression is allowed

   In Full Context state, decompression may be attempted regardless of
   what kind of packet is received. However, for the other states
   decompression is not always allowed. In the No Context state, only IR
   packets, which carry the static information fields may be
   decompressed. Further, when in the Static Context state, only packets
   carrying a 7- or 8-bit CRC can be decompressed (i.e., IR, IR-DYN, or
   UOR-2 packets). If decompression may not be performed the packet is
   discarded, unless the optional delayed decompression mechanism is
   used, see section 6.1.


5.3.2.2.2.  Reconstruct and verify the header

   When reconstructing the header, the decompressor takes the header
   information already stored in the context, and updates it with the
   information received in current header.




Bormann (ed.)                                                  [Page 47]

INTERNET-DRAFT          Robust Header Compression           Oct 11, 2000


   The sequence number is reconstructing by replacing the sequence
   number LSBs in the context with those received in the header. The
   resulting value is then verified to be within the expected
   interpretation interval based on previously decompressed value v_ref,
   see chapter 4.5.1. If not within this interval, an interpretation
   adjustment should be applied by adding or subtracting Nxinterval_size
   to/from the reconstructed value. If the interpretation is adjusted,
   the old value MUST be stored together with a flag telling that this
   happened. First when the next packet has been correctly decompressed,
   this flag can be reset and the old value discarded.

   If RTP Timestamp and IP Identification fields are not included in the
   received header, they are supposed to be calculated based on the
   sequence number. The IP Identifier is usually increasing with the
   same delta as the sequence number and the timestamp with the same
   delta times a fixed value. See chapters 4.5.3 and 4.5.5 for details
   about how these fields are encoded in compressed headers.

   When working in unidirectional mode, all decompressed headers carry a
   CRC which MUST be used to verify decompression.


5.3.2.2.3.  Actions upon CRC failure

   A mismatch in the 3-bit CRC can be caused by one or more of:

     1. residual bit errors in the current header,

     2. a damaged context due to residual bit errors in previous
        headers, or

     3. loss of many consecutive packets which causes the 4-bit SN LSB
        to wrap around without the compressor noticing this (which is,
        in essence, another kind of context damage).

   The 3-bit CRC present in some header formats will reliably detect
   context damage eventually, since the probability of undetected
   context damage decreases exponentially with each new header
   processed.  However, residual bit errors in the current header are
   only detected with good probability, not reliably.

   When a CRC mismatch is caused by residual bit errors in the current
   header (case 1 above), the decompressor should stay in its current
   state to avoid unnecessary loss of subsequent packets. On the other
   hand, when the mismatch is caused by a damaged context, the
   decompressor can attempt to repair the context but if that fails, it
   must move to a lower state to avoid delivering incorrect headers.
   When the mismatch is caused by long loss, the decompressor might
   attempt additional decompression attempts.





Bormann (ed.)                                                  [Page 48]

INTERNET-DRAFT          Robust Header Compression           Oct 11, 2000


   In the following sections the various actions to take in case of CRC
   failure are described in detail. If these mechanisms fail in finding
   the reason for the CRC mismatch, additional decompression attempts
   SHOULD NOT be performed.

5.3.2.2.3.1.  Correction of SN wrap-around

   If many consecutive packets are lost there will be a risk of sequence
   number LSB wrap around. The decompressor might be able to detect this
   situation and avoiding context damage by using a local clock. The
   following algorithm can be used:

     a.The decompressor notes the arrival time, a(i), of each incoming
       packet i. Arrival times of packets where decompression fails are
       discarded.

     b.When decompression fails, the decompressor computes INTERVAL =
       a(i) - a(i-1), i.e., the time elapsed between the arrival of the
       previous correctly decompressed packet and the current packet.

     c.If wrap-around has occurred, INTERVAL will correspond to at
       least 16 inter-packet times. Based on an estimate of the packet
       inter-arrival time, obtained for example using a moving average
       of arrival times, TS STRIDE, or TS TIME, the decompressor judges
       if INTERVAL can correspond to 16 or more inter-packet times.

     d.If INTERVAL is judged to be at least 16 packet inter-arrival
       times, the decompressor adds 16 to the SN of the context and
       attempts to decompress the packet using the new context.

     e.If this decompression succeeds, the decompressor updates the
       context but SHOULD NOT deliver the packet to upper layers. The
       following packet is also decompressed and updates the context if
       its CRC succeeds, but SHOULD be discarded. If decompression of
       the third packet using the new context also succeeds, the
       context repair is deemed successful and this and subsequent
       decompressed packets are delivered to the upper layers.

     f.If any of the three decompression attempts in d. and e. fails,
       the decompressor discards the packets and moves to the Static
       Context state.

   Using this mechanism, the decompressor may be able to repair the
   context after excessive loss, at the expense of discarding two
   packets.


5.3.2.2.3.2.  Repair of incorrect SN updates

   The CRC can fail to detect residual errors in the compressed header
   because of its limited length, i.e., the incorrectly decompressed



Bormann (ed.)                                                  [Page 49]

INTERNET-DRAFT          Robust Header Compression           Oct 11, 2000


   packet can happen to have the same CRC as the original uncompressed
   packet, causing the incorrectly decompressed packet to be accepted
   and the context being updated. This can lead to an erroneous
   reference SN being used in W-LSB decoding, as the reference SN is
   updated for each successfully decompressed header of certain types.

   If this happens, the decompressor will detect the incorrect
   decompression of the following packet with high probability, but it
   does not know the reason for the failure. The following mechanism
   allows the decompressor to judge if the context was updated
   incorrectly by an earlier packet.

   a. The decompressor maintains two decompressed SN: the last one
      (ref 0) and the one before that (ref -1).

   b. When receiving a compressed header the SN (SN curr1) is
      decompressed using ref 0 as the reference value. The other header
      fields are decompressed using this decompressed SN curr1.

   c. If the decompressed header generated in b. passes the CRC test
      the references are shifted as follows:
        ref -1 = ref 0
        ref 0  = SN curr1.

   d. If the decompressed header generated in b. does not pass the CRC
      test and the SN (SN curr2) that is the result of the
      decompression with reference ref -1 is different from SN curr1,
      an additional decompression attempt is performed with SN curr2.

   e. If the decompressed header generated in b. does not pass the CRC
      test and the SN (SN curr2) that is the result of the
      decompression with reference ref -1 is the same as SN curr1 an
      additional decompression attempt is not useful. The algorithm of
      5.3.2.2.3.3 SHOULD be used to find the reason for the CRC
      failure.

   f. If the decompressed header generated in d. passes the CRC test
      ref -1 is not changed while ref 0 is set to SN curr2.

   g. If the decompressed header generated in d. does not pass the CRC
      test the algorithm of 5.3.2.2.3.3 SHOULD be used to try to find
      the reason for the CRC failure.

   The purpose of this algorithm is to repair the context. If the header
   generated in d. passes the CRC test the references are updated
   according to f., but two more headers MUST also be successfully
   decompressed before the repair is deemed successful. Of the three
   successful headers, the first two SHOULD be discarded and only the
   third delivered to upper layers. If decompression of any of the three
   headers fail, the decompressor MUST discard that header and the
   previously generated headers, and move to the Static Context state.



Bormann (ed.)                                                  [Page 50]

INTERNET-DRAFT          Robust Header Compression           Oct 11, 2000




5.3.2.2.3.3.  Judge whether bit error or context damage

   When the CRC check fails, the first step should be to check whether a
   SN wrap-around has occurred, as described in 5.3.2.2.3.1. If that
   attempt fails, repair of a possible incorrect SN update should be
   carried out, as described in previous section.

   However, if both these attempts fail there are two possible reasons
   for the CRC failure either bit errors that have not been detected by
   the link layer or an unrecoverable context damage. It is impossible
   to know which of these is the cause for failure but there are some
   simple rules for how to act when this happens.

   a. For the first CRC failures, assume bit error and simply discard
      the packet. A context request MAY be sent at this time.

   b. When several consecutive decompressed packets have been erroneous,
      context damage SHOULD be assumed and a context request be sent.
      The decompressor MUST also move to Static Context state and
      discard all packets until an update is received.


5.3.2.3.  Feedback in unidirectional mode

   To improve performance for the unidirectional mode over a link that
   does have a feedback channel, the decompressor MAY send an
   acknowledgment when decompression succeeds. Setting the mode
   parameter in the IR-ACK packet to U indicates that the compressor is
   to stay in unidirectional mode.  When receiving an IR-ACK(U), the
   compressor should reduce the frequency of IR packets since the static
   information has been correctly received, but it is not required to
   stop sending IR packets. If IR packets continue to arrive, the
   decompressor MAY repeat the IR-ACK(U), but it SHOULD not repeat the
   IR-ACK(U) continuously.


















Bormann (ed.)                                                  [Page 51]

INTERNET-DRAFT          Robust Header Compression           Oct 11, 2000


5.4.  Operation in bi-directional optimistic mode

5.4.1.  Compressor states and logic (O-mode)

   Below is the state machine for the compressor in bi-directional
   optimistic mode. Details of each state, the transitions between
   states and compression logic are given subsequent to the figure.

                         Optimistic approach / ACK
      +------>------>------>------>------>------>------>------>------+
      |                                                              |
      |      Optimistic appr. / ACK      Optimistic appr. / ACK      |
      |      +------>------>------+      +------>------>------+      |
      |      |                    |      |                    |      |
      |      |                    v      |                    v      v
    +----------+                +----------+                +----------+
    | IR State |                | FO State |                | SO State |
    +----------+                +----------+                +----------+
      ^      ^                    |      ^                    |      |
      |      |    STATIC-NACK     |      |    NACK / Update   |      |
      |      +------<------<------+      +------<------<------+      |
      |                                                              |
      |                         STATIC-NACK                          |
      +------<------<------<------<------<------<------<------<------+


5.4.1.1.  State transition logic

   The transition logic for compression states in bi-directional
   optimistic mode has much in common with the logic of the
   unidirectional mode. The optimistic approach principle and
   transitions because of the need for updates works in the same way as
   described in chapter 5.3.1. However, in optimistic mode there are no
   timeouts. Instead, the optimistic mode makes use of feedback from
   decompressor to compressor both for transitions in the backward
   direction and for improved forward transition.

5.4.1.1.1.  Negative acknowledgements (NACKs), downward transition

   Negative acknowledgements (NACKs), also called context requests,
   obviate the periodic updates needed in unidirectional mode. Upon
   reception of a NACK the compressor transits back to the FO state and
   sends context updates to the decompressor. Similarly, reception of a
   STATIC-NACK packet makes the compressor transit back to IR state.

5.4.1.1.2.  Optional acknowledgements, upwards transition

   In addition to the NACKs, also positive feedback (ACKs) MAY be used
   for PT2 packets in the bi-directional optimistic mode. Upon reception
   of an ACK, the compressor knows that the decompressor has received
   the acknowledged packet and transition to a higher compression state



Bormann (ed.)                                                  [Page 52]

INTERNET-DRAFT          Robust Header Compression           Oct 11, 2000


   can be carried out without any doubts. Since this functionality is
   optional, a compressor MUST NOT expect to get such ACKs initially.
   First after reception of an acknowledgement for a PT2 packet, the
   compressor can expect to get ACKs for such packets also after that.


5.4.1.2.  Compression logic and packets used

   The compression logic is the same for bi-directional optimistic mode
   as for the unidirectional mode (see section 5.3.1.2).


5.4.2.  Decompressor states and logic (O-mode)

   The decompression states and the state transition logic are the same
   as for the unidirectional case (see section 5.3.2). What differs is
   the decompression and feedback logic.


5.4.2.1.  Decompression logic, timer-based timestamp decompression

   In bi-directional mode, timer-based timestamp decompression may be
   used to improve compression efficiency if the RTP timestamp increases
   linearly. The mechanisms used are those described in 4.5.4.


5.4.2.2.  Feedback logic (O-mode)

   The feedback logic defines what feedback to send due to different
   events when operating in the various states. As mentioned above,
   there are four principal kinds of feedback that can be used; ACK, IR-
   ACK, NACK and STATIC-NACK. Further, the logic described below will
   refer to three kind of packets that can be received by the
   decompressor; Initialization and Refresh (IR or IR-DYN) packets, type
   1 or 2 (UO-1 or UOR-2) packets and UO-0 packets. An UO-0 packet
   carries a packet header compressed according to a fixed pattern while
   type 1 and 2 packets are used when this patterns is broken.

   Below, rules for which feedback to use when are defined. For the
   optional feedback, it is REQUIRED that if used once, the decompressor
   MUST continue to send optional feedback for the lifetime of the
   packet stream.

   In NC state: - When an IR packet is correctly decompressed, send an
                  IR-ACK with the mode parameter set to O
                - When type 1 or 2 packet, or UO-0 packet is received
                  or decompression of an IR packet has failed, send a
                  STATIC-NACK with the mode parameter set to O

   In SC state: - When an IR packet is correctly decompressed, send an
                  IR-ACK with the mode parameter set to O



Bormann (ed.)                                                  [Page 53]

INTERNET-DRAFT          Robust Header Compression           Oct 11, 2000


                - When an UOR2 packet is correctly decompressed,
                  optionally send an ACK with the mode parameter set to
                  O
                - When a type 0 or 1 packet is received, send a NACK
                  with the mode parameter set to O
                - When decompression of a type 1 or 2, or an IR packet
                  has failed, send a STATIC-NACK with the mode
                  parameter set to O

   In FC state: - When an IR packet is correctly decompressed, send an
                  IR-ACK with the mode parameter set to O
                - When an UOR2 packet is correctly decompressed,
                  optionally send an ACK with the mode parameter set to
                  O
                - When a type 0 or 1 packet is correctly decompressed,
                  no feedback is sent
                - When decompression of any packet has failed, send a
                  NACK with the mode parameter set to O


5.5.  Operation in bi-directional reliable mode

5.5.1.  Compressor states and logic (R-mode)

   Below is the state machine for the compressor in bi-directional
   reliable mode. Details of each state, the transitions between states
   and compression logic are given subsequent to the figure.

                                       ACK
      +------>------>------>------>------>------>------>------+
      |                                                       |
      |               ACK                         ACK         |   ACK
      |      +------>------>------+      +------>------>------+  +->-+
      |      |                    |      |                    |  |   |
      |      |                    v      |                    v  |   v
    +----------+                +----------+                +----------+
    | IR State |                | FO State |                | SO State |
    +----------+                +----------+                +----------+
      ^      ^                    |      ^                    |      |
      |      |    STATIC-NACK     |      |    NACK / Update   |      |
      |      +------<------<------+      +------<------<------+      |
      |                                                              |
      |                         STATIC-NACK                          |
      +------<------<------<------<------<------<------<------<------+


5.5.1.1.  State transition logic (R-mode)

   The transition logic for compression states in reliable mode is based
   on three principles: the proactive approach principle, the need for
   updates, and negative acknowledgements.



Bormann (ed.)                                                  [Page 54]

INTERNET-DRAFT          Robust Header Compression           Oct 11, 2000




5.5.1.1.1 Upwards transition

   The upwards transition is determined by the proactive approach.  The
   transition procedure is similar to the one described in section
   5.3.1.1.1, with one important difference -- the compressor bases its
   confidence only on the acknowledgements sent by the decompressor.
   This ensures that the synchronization between the compression context
   and decompression context will never be lost due to packet losses.


5.5.1.1.2 Downward transition

   Downward transitions are triggered by the need for updates or by
   negative acknowledgement (NACKs and STATIC_NACKs), as described in
   section 5.3.1.1.3 and 5.4.1.1.1, respectively. Note that NACKs should
   rarely occur in R-mode, as updates are protected by a 7- or 8-bit CRC
   (see 5.5.2.1) and are only used if acknowledged.


5.5.1.2.  Compression logic and packets used (R-mode)

   The compressor starts in IR state by sending IR packets. It transits
   to FO state once it receives an ACK. In FO state, it sends the
   smallest packets that can communicate the changes with respect to the
   values in the sliding windows, according to W-LSB. Those packets
   could be of type R-1*, UOR-2, or even IR-DYN.

   The compressor will transit to SO state after it detects a string AND
   has received an ACK (or two, if the pattern of the string has not
   been previously established) that referred to a header belonging to
   the string. In SO state, R-0* packets will be sent.

   In R-mode, only a packet carrying a 7- or 8-bit CRC can update the
   decompression context, i.e., R-0-CRC, UOR-2, IR-DYN, IR. Therefore,
   only field values of such packets are inserted into the encoding
   sliding windows (see section 5.5).

   The compressor SHOULD avoid sending updating packets, except in the
   following cases:
   1) when the update can lead to a transition to SO state, or
   2) when it is desirable to shrink sliding windows, e.g., because W-
   LSB encoding would need too many bits (note: reception of an ACK is
   the only event that causes sliding windows to shrink).









Bormann (ed.)                                                  [Page 55]

INTERNET-DRAFT          Robust Header Compression           Oct 11, 2000




5.5.2.  Decompressor states and logic (R-mode)

   The decompression states and the state transition logic are the same
   as for the unidirectional case (see section 5.3.2). What differs is
   the decompression and feedback logic.


5.5.2.1.  Decompression logic (R-mode)

   Decompression of a header is always allowed because of the proactive
   approach taken by the compressor: headers are always compressed
   relative to an acknowledged header.

   When the decompressor is capable of timer-based compression of RTP
   Timestamp (e.g., it has access to a clock with sufficient resolution
   and the jitter introduced internally in the receiving node is
   sufficiently small) it SHOULD signal that it is ready to do timer-
   based compression of the RTP timestamp. (The compressor will then
   decide based on its knowledge of the channel and the observed
   properties of the packet stream.)

   A CRC mismatch can only occur due to 1) residual bit errors in the
   current header, and/or 2) a damaged context due to residual bit
   errors in previous headers. Although it is impossible to determine
   which is the real cause, case 1 is more likely, as a header
   reconstructed according to a damaged packet is unlikely to pass the
   7- or 8-bit CRC. The decompressor should take the action described in
   5.3.2.2.3.3.


5.5.2.2.  Feedback logic (R-mode)

   The feedback logic for the bi-directional reliable mode is very
   simple:

   - When an updating packet (i.e. a packet carrying a 7- or 8-bit CRC)
   is correctly decompressed, send an ACK(R). (The R mode indication may
   be implicit when the mode transition was not recent.)

   - When context damage is detected, send a NACK(R) if in Full Context
   state, or a STATIC_NACK(R) if in Static Context state.

   - Feedback MUST NOT be sent for packets not updating the context
   (i.e. packets that do not carry a CRC)








Bormann (ed.)                                                  [Page 56]

INTERNET-DRAFT          Robust Header Compression           Oct 11, 2000


5.6.  Mode transitions

   [[Chapter 5.6 is locked by Lars-Erik.]]

   The decision to move from one compression mode to another is taken by
   the decompressor and the possible mode transitions are shown in the
   figure below. Subsequent chapters describe how the transitions are
   performed together with exceptions for the compression and
   decompression functionality during transitions.

                         +-------------------------+
                         | Unidirectional (U) mode |
                         +-------------------------+
                           / ^                 \ ^
                          / /Feedback(U)        \ \Feedback(U)
                         / /                     \ \
                        / /                       \ \
            Feedback(O)/ /              Feedback(R)\ \
                      v /                           v \
      +---------------------+    Feedback(R)    +-------------------+
      | Optimistic (O) mode | ----------------> | Reliable (R) mode |
      |                     | <---------------- |                   |
      +---------------------+    Feedback(O)    +-------------------+


5.6.1.  Compression and decompression during mode transitions

   The following sections assume that compressor and decompressor for
   each context maintains a variable, whose value is the current
   compression mode for that context. The value of the variable controls
   which packet types to use, actions taken, etc, for that context.

   Subsequent chapters define exactly when to change the value of the
   MODE variable. When ROHC transits between compression modes, there
   are several cases where the behavior of compressor or decompressor
   must be restricted during the transition phase. These restrictions
   are defined by exception parameters that specifies which restrictions
   to apply. The transition descriptions in subsequent chapters refer to
   these exception parameters and defines when and to what values they
   are set. All mode related parameters are listed below together with
   their possible values, with explanations and restrictions:

   Parameters for the compressor side:

      - C_MODE
                Possible values for the C_MODE parameter are
                (U)NIDIRECTIONAL, (O)PTIMISTIC and (R)ELIABLE. C MODE
                MUST be initialized to U.

      - C_TRANS




Bormann (ed.)                                                  [Page 57]

INTERNET-DRAFT          Robust Header Compression           Oct 11, 2000


                Possible values for the C_TRANS parameter are (P)ENDING
                and (D)ONE. C TRANS MUST be initialized to D. When C
                TRANS is P, it is REQUIRED that
                1) the compressor only uses packet formats common to
                   all modes,
                2) it does not transit to SO state.
                3) New mode transition requests are ignored.

   Parameters for the decompressor side:

      - D_MODE
                Possible values for the D_MODE parameter are
                (U)NIDIRECTIONAL, (O)PTIMISTIC and (R)ELIABLE. C MODE
                MUST be initialized to U.


      - D_TRANS
                Possible values for the D_TRANS parameter are
                (I)NITIATED, (P)ENDING and (D)ONE. D TRANS MUST be
                initialized to D. A mode transition can be initiated
                only when D TRANS is D. While D TRANS is I, the
                decompressor sends a NACK or ACK for all received
                packets.


5.6.2.  Transition from Unidirectional to Optimistic mode

   As long as there is a feedback channel available, the decompressor
   can at any moment decide to initiate transition from unidirectional
   to bi-directional Optimistic mode. All feedback packets can be used
   with the mode parameter set to O and the decompressor can then
   directly start working in Optimistic mode. The compressor transits
   from unidirectional to optimistic mode as soon as it receives any
   feedback packet with the mode parameter set to O. The transition
   procedure is described below:

               Compressor                     Decompressor
              ----------------------------------------------
                    |                               |
                    |        ACK(R)/NACK(R) +-<-<-<-|  D_MODE = O
                    |       +-<-<-<-<-<-<-<-+       |
    C_MODE = O      |-<-<-<-+                       |
                    |                               |

   If the feedback packet is lost, the compressor will continue to work
   in unidirectional mode, but as soon as any feedback packet reaches
   the compressor it will transit to Optimistic mode.







Bormann (ed.)                                                  [Page 58]

INTERNET-DRAFT          Robust Header Compression           Oct 11, 2000



5.6.3.  From Optimistic to Reliable mode

   Transition from Optimistic to Reliable mode is permitted only after
   at least one packet has been correctly decompressed, which means that
   at least the static part of the context is established. An ACK(R) or
   a NACK(R) feedback packet is sent to initiate the mode transition.
   The compressor MUST NOT use packet types 0 or 1 during transition.
   The transition procedure is described below:

               Compressor                     Decompressor
              ----------------------------------------------
                    |                               |
                    |        ACK(R)/NACK(R) +-<-<-<-|  D_TRANS = I
                    |       +-<-<-<-<-<-<-<-+       |
    C_TRANS = P     |-<-<-<-+                       |
    C_MODE = R      |                               |
                    |->->->-+   FO(SN0,R)           |
                    |       +->->->->->->->-+       |
                    |->-..                  +->->->-|  D TRANS = P
                    |->-..                          |  D_MODE = R
                    |           ACK(SN0,R)  +-<-<-<-|
                    |       +-<-<-<-<-<-<-<-+       |
    C_TRANS = D     |-<-<-<-+                       |
                    |                               |
                    |->->->-+ SO (Reliable mode)    |
                    |       +->->->->->->->-+       |
                    |                       +->->->-|  D_TRANS = D
                    |                               |

   As long as the decompressor has not received an FO packet with the
   mode transition parameter set to R, it must stay in Optimistic mode.
   The compressor must stay in FO state until it has received an ACK for
   an FO packet sent with the mode transition parameter set to R
   (indicated by the sequence number).


5.6.4.  From Unidirectional to Reliable mode

   Since transition from Unidirectional to Optimistic mode do not
   require any handshakes, it is possible to transit directly from
   Unidirectional to Reliable mode, following the same transition
   procedure in 5.6.3 above.


5.6.5.  From Reliable to Optimistic mode

   Either the ACK(O) or the NACK(O) feedback packet is used to initiate
   the transition from Reliable to Optimistic mode and the compressor
   MUST always run in FO state during transition. The transition
   procedure is described below:



Bormann (ed.)                                                  [Page 59]

INTERNET-DRAFT          Robust Header Compression           Oct 11, 2000



               Compressor                     Decompressor
              ----------------------------------------------
                    |                               |
                    |        ACK(O)/NACK(O) +-<-<-<-|  D_TRANS = I
                    |       +-<-<-<-<-<-<-<-+       |
    C_TRANS = P     |-<-<-<-+                       |
    C_MODE = O      |                               |
                    |->->->-+   FO(SN0,O)           |
                    |       +->->->->->->->-+       |
                    |->-..                  +->->->-|  D_MODE = O
                    |->-..                          |
                    |           ACK(SN0,O)  +-<-<-<-|
                    |       +-<-<-<-<-<-<-<-+       |
    C_TRANS = D     |-<-<-<-+                       |
                    |                               |
                    |->->->-+ SO (Optimistic mode)  |
                    |       +->->->->->->->-+       |
                    |                       +->->->-|  D_TRANS = D
                    |                               |

   As long as the decompressor has not received an FO packet with the
   mode transition parameter set to O, it must stay in Reliable mode.
   The compressor must stay in FO state until it has received an ACK for
   a FO packet sent with the mode transition parameter set to O
   (indicated by the sequence number).


5.6.6.  Transition to Unidirectional mode

   It is possible to force transition back to unidirectional mode if the
   decompressor desires to do so. Independent of which mode it starts
   from, a three way handshake MUST be carried out to ensure correct
   transition on the compressor side. The transition procedure is
   described below:

               Compressor                     Decompressor
              ----------------------------------------------
                    |                               |
                    |        ACK(U)/NACK(U) +-<-<-<-|  D_TRANS = I
                    |       +-<-<-<-<-<-<-<-+       |
    C_TRANS = P     |-<-<-<-+                       |
    C_MODE = U      |                               |
                    |->->->-+   FO(SN0,U)           |
                    |       +->->->->->->->-+       |
                    |->-..                  +->->->-|
                    |->-..                          |
                    |           ACK(SN0,U)  +-<-<-<-|
                    |       +-<-<-<-<-<-<-<-+       |
    C_TRANS = D     |-<-<-<-+                       |
                    |                               |



Bormann (ed.)                                                  [Page 60]

INTERNET-DRAFT          Robust Header Compression           Oct 11, 2000


                    |->->->-+ SO (Uni. mode)        |
                    |       +->->->->->->->-+       |
                    |                       +->->->-|  D_TRANS = D
                    |                               |  D_MODE = U

   The decompressor must continue to send feedback until it knows that
   the compressor is ready with the transition.















































Bormann (ed.)                                                  [Page 61]

INTERNET-DRAFT          Robust Header Compression           Oct 11, 2000



5.7.  Packet formats

   Similar fields occur in several formats, therefore it is explained
   here how these fields are used. The following notation is used:

     bits(X) = the number of bits for field X present in the compressed
                   header (including extension).

     field(X) = the value of field X in the compressed header.

     context(X) = the value of field X as established in the context.

     value(X) = field(X) if X is present in the compressed header, else
                context(X).

     hdr(X) = the value of field X in the uncompressed or
              decompressed header.



   The following fields occur in several headers and extensions.

   SN    The compressed RTP sequence number.

     Compressed with W-LSB. The interpretation intervals, see section
     4.5.1, are defined as follows:

           p = -1                  if bits(SN) <= 4
           p = 2^(bits(SN)-2) - 1  if bits(SN) >  4


   IP-ID   A compressed IP-ID field.

     IP-ID fields in compressed base headers carry the compressed IP-ID
     of the innermost IPv4 header whose corresponding RND flag is not 1.

     The rules below assume the IP-ID is for the innermost IP header. If
     it is for an outer IP header, the RND2 and NBO2 flags should be
     used instead of RND and NBO.

     If value(RND)=0, hdr(IP-ID) is compressed using Offset IP-ID
     encoding, see section 4.5.5., using p=0 and default-slope(IP-ID
     offset)=0.

     If value(RND)=1, IP-ID is the uncompressed hdr(IP-ID). IP-ID is
     then passed as additional octets at the end of the compressed
     header, after any Extensions.






Bormann (ed.)                                                  [Page 62]

INTERNET-DRAFT          Robust Header Compression           Oct 11, 2000


     If value(NBO)=1, the octets of hdr(IP-ID) are swapped before
     compression and after decompression. It is pointless but not
     harmful to set both NBO and RND.


   TS    The compressed RTP Timestamp value.

     If value(TIME_STRIDE) > 0, Timer-based compression of RTP
     Timestamp, see section 4.5.4., is used.

     If value(Tsc)=1, Scaled RTP Timestamp encoding is used before
     compression, see section 4.5.3., and default-slope(TS) = 1.

     If value(Tsc)=0, the Timestamp value is compressed as-is, and
     default-slope(TS) = value(TS_STRIDE).


   CRC   CRC over the original, uncompressed, header.

     For 3-bit CRCs, the polynomial of section 5.9.2 is used.
     For 7-bit CRCs, the polynomial of section 5.9.2 is used.
     For 8-bit CRCs, the polynomial of section 5.9.1 is used.


   M   RTP Marker bit.

     Context(M) is initially zero and is never updated. Value(M)=1 only
     when field(M)=1.


























Bormann (ed.)                                                  [Page 63]

INTERNET-DRAFT          Robust Header Compression           Oct 11, 2000


   The general format for a compressed RTP header is as follows

     0   1   2   3   4   5   6   7
    --- --- --- --- --- --- --- ---
   |         Add-CID octet         | if for CID 1-15 and small CIDs
   +---+---+---+---+---+---+---+---+
   |   first octet of base header  | (with type indication)
   +---+---+---+---+---+---+---+---+
   |                               |
   /   0, 1, or 2 octets of CID    / 1-2 octets if large CIDs
   |                               |
   +---+---+---+---+---+---+---+---+
   /   remainder of base header    / variable number of bits
   +---+---+---+---+---+---+---+---+
   /     Extension (see 5.7.5)     / extension, if X=1 in base header
    --- --- --- --- --- --- --- ---
   /   IP-ID of inner Ipv4 header  / 2 octets, if value(RND)=1
    --- --- --- --- --- --- --- ---
   /   IP-ID of outer IPv4 header  / 2 octets, if value(RND2)=1
    --- --- --- --- --- --- --- ---
   /         UDP Checksum          / 2 oct, if context(UDP Checksum)!= 0
    --- --- --- --- --- --- --- ---
   /    AH data for outer list     / variable  (see 5.8.4.2)
    --- --- --- --- --- --- --- ---
   /    AH data for inner list     / variable  (see 5.8.4.2)
    --- --- --- --- --- --- --- ---

   In subsequent sections, the position of the large CID is indicated
   using the notation

   +===+===+===+===+===+===+===+===+


   Whether the UDP Checksum field is present or not is controlled by the
   value of the UDP Checksum in the context. If non-zero, the UDP
   checksum is enabled and sent along with each packet. If zero, the UDP
   Checksum is disabled and not sent. Should hdr(UDP checksum) be non-
   zero when context(UDP Checksum) is non-zero, the header cannot be
   compressed. It must be sent uncompressed or the context reinitialized
   using an IR-packet.

   When an IPv4 header is present in the static context, for which the
   corresponding RND flag has not been established to be 1, packet types
   R-1 and UO-1 MUST NOT be used.

   When no IPv4 header is present in the static context, or the RND
   flags for all IPv4 headers in the context have been established to be
   1, packet types R-1-ID, R-1-TS, UO-1-ID, and UO-1-TS MUST NOT be
   used.

   During the transient state when an RND flag is being established,



Bormann (ed.)                                                  [Page 64]

INTERNET-DRAFT          Robust Header Compression           Oct 11, 2000


   packet types R-1-ID, R-1-TS, UO-1-ID, or UO-1-TS, MUST NOT be used.
   This implies that the RND flag(s) of the Extension 3 may have to be
   consulted before the format of a base header carrying an Extension 3
   can be determined.


5.7.1. Packet type 0: UO-0, R-0, R-0-CRC

   Packet type 0 is indicated by the first bit being 0:

   R-0

     0   1   2   3   4   5   6   7
   +---+---+---+---+---+---+---+---+
   | 0 | 0 |          SN           |
   +===+===+===+===+===+===+===+===+

     Updating properties: R-0 packets do not update any part of the
     context.


   R-0-CRC

     0   1   2   3   4   5   6   7
   +---+---+---+---+---+---+---+---+
   | 0 | 1 |            SN         |
   +===+===+===+===+===+===+===+===+
   |SN |            CRC            |
   +---+---+---+---+---+---+---+---+

     Updating properties: R-0-CRC packets updates context(RTP sequence
     number).

     Note: the SN field straddles the CID field.


   UO-0

     0   1   2   3   4   5   6   7
   +---+---+---+---+---+---+---+---+
   | 0 |      SN       |    CRC    |
   +===+===+===+===+===+===+===+===+

     Updating properties: The UO-0 packet updates the current value of
     context(RTP sequence number).


5.7.2. Packet type 1 (R-mode): R-1, R-1-TS, R-1-ID

   Packet type 1 is indicated by the first bits being 10




Bormann (ed.)                                                  [Page 65]

INTERNET-DRAFT          Robust Header Compression           Oct 11, 2000


   R-1

     0   1   2   3   4   5   6   7
   +---+---+---+---+---+---+---+---+
   | 1   0 |          SN           |
   +===+===+===+===+===+===+===+===+
   | M | X |          TS           |
   +---+---+---+---+---+---+---+---+

     Note: R-1 cannot be used if the context contains at least one IPv4
     header with value(RND) = 0.  This disambiguates it from R-1-ID and
     R-1-TS.

   R-1-ID

     0   1   2   3   4   5   6   7
   +---+---+---+---+---+---+---+---+
   | 1   0 |          SN           |
   +===+===+===+===+===+===+===+===+
   | M | X |T=0|       IP-ID       |
   +---+---+---+---+---+---+---+---+

     Note: R-1-ID cannot be used if there is no IPv4 header in the
     context or if value(RND) and value(RND2) are both 1.

   R-1-TS

     0   1   2   3   4   5   6   7
   +---+---+---+---+---+---+---+---+
   | 1   0 |          SN           |
   +===+===+===+===+===+===+===+===+
   | M | X |T=1|        TS         |
   +---+---+---+---+---+---+---+---+

     Note: R-1-TS cannot be used if there is no IPv4 header in the
     context or if value(RND) and value(RND2) are both 1.

     X: X=0 indicates that no Extension is present,
        X=1 indicates that an Extension is present.

     T: T=0 indicates format R-1-ID,
        T=1 indicates format R-1-TS.

     Updating properties: R-1* headers do not update any part of the
     context.









Bormann (ed.)                                                  [Page 66]

INTERNET-DRAFT          Robust Header Compression           Oct 11, 2000


5.7.3. Packet type 1 (UO-modes): UO-1, UO-1-ID, UO-1-TS

   UO-1

     0   1   2   3   4   5   6   7
   +---+---+---+---+---+---+---+---+
   | 1   0 |          TS           |
   +===+===+===+===+===+===+===+===+
   | M |      SN       |    CRC    |
   +---+---+---+---+---+---+---+---+

     Note: UO-1 cannot be used if the context contains at least one IPv4
     header with value(RND) = 0.  This disambiguates it from UO-1-ID and
     UO-1-TS.


   UO-1-ID

     0   1   2   3   4   5   6   7
   +---+---+---+---+---+---+---+---+
   | 1   0 |T=0|       IP-ID       |
   +===+===+===+===+===+===+===+===+
   | X |        SN     |    CRC    |
   +---+---+---+---+---+---+---+---+

     Note: UO-1-ID cannot be used if there is no IPv4 header in the
     context or if value(RND) and value(RND2) are both 1.


   UO-1-TS

     0   1   2   3   4   5   6   7
   +---+---+---+---+---+---+---+---+
   | 1   0 |T=1|        TS         |
   +===+===+===+===+===+===+===+===+
   | M |      SN       |    CRC    |
   +---+---+---+---+---+---+---+---+

     Note: UO-1-TS cannot be used if there is no IPv4 header in the
     context or if value(RND) and value(RND2) are both 1.

     X: X=0 indicates that no Extension is present,
        X=1 indicates that an Extension is present.

     T: T=0 indicates format UO-1-ID, T=1 indicates format UO-1-TS.

     Updating properties: UO-1* packets update context(RTP sequence
     number). UO-1 and UO-1-TS packets update context(RTP Timestamp).
     UO-1-ID packets update context(IP-ID). Values provided in
     Extensions, other than in other SN, TS, or IP-ID fields, do not
     update the context.



Bormann (ed.)                                                  [Page 67]

INTERNET-DRAFT          Robust Header Compression           Oct 11, 2000


5.7.4. Packet type 2: UOR-2

   Packet type 2 is indicated by the first bits being 110

   UOR-2

     0   1   2   3   4   5   6   7
   +---+---+---+---+---+---+---+---+
   | 1   1   0 |        TS         |
   +===+===+===+===+===+===+===+===+
   |TS | M |          SN           |
   +---+---+---+---+---+---+---+---+
   | X |            CRC            |
   +---+---+---+---+---+---+---+---+

     Note: UOR-2 cannot be used if the context contains at least one
     IPv4 header with value(RND) = 0.  This disambiguates it from UOR-2-
     ID and UOR-2-TS.


   UOR-2-ID

     0   1   2   3   4   5   6   7
   +---+---+---+---+---+---+---+---+
   | 1   1   0 |       IP-ID       |
   +===+===+===+===+===+===+===+===+
   |T=0| M |          SN           |
   +---+---+---+---+---+---+---+---+
   | X |            CRC            |
   +---+---+---+---+---+---+---+---+

     Note: UOR-2-ID cannot be used if there is no IPv4 header in the
     context or if value(RND) and value(RND2) are both 1.

   UOR-2-TS

     0   1   2   3   4   5   6   7
   +---+---+---+---+---+---+---+---+
   | 1   1   0 |        TS         |
   +===+===+===+===+===+===+===+===+
   |T=1| M |          SN           |
   +---+---+---+---+---+---+---+---+
   | X |            CRC            |
   +---+---+---+---+---+---+---+---+

     Note: UOR-2-TS cannot be used if there is no IPv4 header in the
     context or if value(RND) and value(RND2) are both 1.

     X: X=0 indicates that no Extension is present,
        X=1 indicates that an Extension is present.




Bormann (ed.)                                                  [Page 68]

INTERNET-DRAFT          Robust Header Compression           Oct 11, 2000


     T: T=0 indicates format UOR-2-ID, T=1 indicates format UOR-2-TS.

     Updating properties: All values provided in UOR-2* packets update
     the context, unless explicitly stated otherwise.


5.7.5. Extension formats

   Fields in extensions are concatenated with the corresponding field in
   the base compressed header, if any. Bits in an extension are more
   significant than bits in the base compressed header.

   The TS field is scaled in all extensions, as it is in the base
   header, except optionally when using extension 3 where the Tsc flag
   can indicate that the TS field is not scaled. Value(TS_STRIDE) is
   used as the scale factor when scaling the TS field.

   In the following three extensions, the interpretation of the fields
   depend on whether there is a T-bit in the base compressed header, and
   if so, on the value of that field. When there is no T-bit, +T and -T
   both mean TS. This is the case when  there are no IPv4 headers in the
   static context, and when all IPv4 headers in the static context have
   their corresponding RND flag set (i.e., RND=1).

   If there is a T-bit,

     T = 1   indicates that +T is TS, and
                            -T is IP-ID.

     T = 0   indicates that +T is IP-ID, and
                            -T is TS.


   Extension 0:

     0   1   2   3   4   5   6   7
   +---+---+---+---+---+---+---+---+
   | 0   0 |    SN     |    +T     |
   +---+---+---+---+---+---+---+---+

   Extension 1:

   +---+---+---+---+---+---+---+---+
   | 0   1 |    SN     |    +T     |
   +---+---+---+---+---+---+---+---+
   |              -T               |
   +---+---+---+---+---+---+---+---+

   Extension 2:

   +---+---+---+---+---+---+---+---+



Bormann (ed.)                                                  [Page 69]

INTERNET-DRAFT          Robust Header Compression           Oct 11, 2000


   | 1   0 |    SN     |    +T     |
   +---+---+---+---+---+---+---+---+
   |              +T               |
   +---+---+---+---+---+---+---+---+
   |              -T               |
   +---+---+---+---+---+---+---+---+

   Extension 3 is a more elaborate extension which can give values for
   fields other than SN, TS, and IP-ID. Three optional flag octets
   indicates changes to IP header(s) and RTP header, respectively.

   Extension 3:

      0     1     2     3     4     5     6     7
   +-----+-----+-----+-----+-----+-----+-----+-----+
   |  1     1  |  S  |R-TS | Tsc |  I  | ip  | rtp |            (FLAGS)
   +-----+-----+-----+-----+-----+-----+-----+-----+
   |              Inner IP hdr flags         | ip2 |  if ip=1
    ..... ..... ..... ..... ..... ..... ..... .....
   |              Outer IP hdr flags               |  if ip2=1
    ..... ..... ..... ..... ..... ..... ..... .....
   |                      SN                       |  if S=1
    ..... ..... ..... ..... ..... ..... ..... .....
   /       TS (encoded as in section 4.5.6.)       /  1-4 oct, if R-TS=1
    ..... ..... ..... ..... ..... ..... ..... .....
   |                                               |
   /            Inner IP header fields             /  variable, if ip=1
   |                                               |
    ..... ..... ..... ..... ..... ..... ..... .....
   |                     IP-ID                     |  2 octets if I=1
    ..... ..... ..... ..... ..... ..... ..... .....
   |                                               |
   /            Outer IP header fields             /  variable, if ip2=1
   |                                               |
    ..... ..... ..... ..... ..... ..... ..... .....
   |                                               |
   /          RTP header flags and fields          /  variable, if rtp=1
   |                                               |
    ..... ..... ..... ..... ..... ..... ..... .....

     S, R-TS, I, ip, rtp, ip2: Indicate presence of fields as shown to
     the right of each field above.

     Tsc: Tsc=0 indicates that TS is not scaled.
          Tsc=1 indicates that TS is scaled according to section 4.5.3,
          using value(TS STRIDE).
          Context(Tsc) is always 1. If scaling is not desired, the
          compressor will establish TS_STRIDE = 1

     SN: see beginning of section 5.7.




Bormann (ed.)                                                  [Page 70]

INTERNET-DRAFT          Robust Header Compression           Oct 11, 2000


     TS: Variable number of bits of TS, encoded according to
         section 4.5.6. See beginning of section 5.7.

     IP-ID: see beginning of section 5.7.


   Inner IP header flags

     These correspond to the inner IP header if there are two, and the
     single IP header otherwise.

      0     1     2     3     4     5     6     7
    ..... ..... ..... ..... ..... ..... ..... .....
   | TOS | TTL | DF  | PR  | IPX | NBO | RND | ip2 |  if ip=1
    ..... ..... ..... ..... ..... ..... ..... .....

     TOS, TTL, PR, IPX: Indicates presence of fields as shown to the
        right of the field in question below.

     DF: Don't Fragment bit of IP header.

     NBO: Indicates whether the octets of hdr(IP identifier) of this IP
     header are swapped before compression and after decompression.
     NBO=1 indicates that the octets need not be swapped. NBO=0
     indicates that the octets are to be swapped. See section 4.5.5.

     RND: Indicates whether hdr(IP identifier) is not to be compressed
     but instead sent as-is in compressed headers.

     IP2: Indicates presence of Outer IP header fields. Unless the
     static context contains two IP headers, IP2 is always zero.


   Inner IP header fields

    ..... ..... ..... ..... ..... ..... ..... .....
   |         Type of Service/ Traffic Class        |  if TOS=1
    ..... ..... ..... ..... ..... ..... ..... .....
   |         Time to live/ Hop Limit               |  if TTL=1
    ..... ..... ..... ..... ..... ..... ..... .....
   |         Protocol/ Next Header                 |  if PR=1
    ..... ..... ..... ..... ..... ..... ..... .....
   /         IP extension hdrs                     /  variable, if IPX=1
    ..... ..... ..... ..... ..... ..... ..... .....


     Type of Service/Traffic Class: That field in the IP header,
     absolute value.

     Time to live/ Hop Limit: That field in the IP header.




Bormann (ed.)                                                  [Page 71]

INTERNET-DRAFT          Robust Header Compression           Oct 11, 2000


     Protocol/ Next Header: That field in the IP header.

     IP extension hdr(s): According to section 5.8.5.


   Outer IP header flags

     The fields in this part of the Extension 3 header refers to the
     outermost IP header.

      0     1     2     3     4     5     6     7
    ..... ..... ..... ..... ..... ..... ..... .....
   | TOS2| TTL2| DF2 | PR2 |IPX2 |NBO2 |RND2 |  I2 |  if ip2=1
    ..... ..... ..... ..... ..... ..... ..... .....

     These flags are the same as the Inner IP header flags, but refer to
     the outer IP header instead of the inner IP header. The following
     flag, however, has no counterpart in the Inner IP header flags:

        I2: indicates presence of the IP-ID field.


   Outer IP header fields

    ..... ..... ..... ..... ..... ..... ..... .....
   |         Type of Service/ Traffic Class        |  if TOS2=1
    ..... ..... ..... ..... ..... ..... ..... .....
   |         Time to live/ Hop Limit               |  if TTL2=1
    ..... ..... ..... ..... ..... ..... ..... .....
   |         Protocol/ Next Header                 |  if PR2=1
    ..... ..... ..... ..... ..... ..... ..... .....
   /         IP extension hdr(s)                   / variable, if IPX2=1
    ..... ..... ..... ..... ..... ..... ..... .....
   |                     IP-ID                     |  2 octets if I2=1
    ..... ..... ..... ..... ..... ..... ..... .....

     The fields in this part of the Extension 3 are as for the Inner IP
     header fields, but refers to the outer IP header instead of the
     inner IP header. The following field, however, has no counterpart
     among the Inner IP header fields:

        IP-ID: the compressed Identifier field of the outer IP header,
        unless the inner header is an IPv6 header, in which case I2 is
        always zero.










Bormann (ed.)                                                  [Page 72]

INTERNET-DRAFT          Robust Header Compression           Oct 11, 2000


   RTP header flags and fields

      0     1     2     3     4     5     6     7
    ..... ..... ..... ..... ..... ..... ..... .....
   |   Mode    |R-PT |R-P  | R-X |CSRC | TSS | IPT |  if rtp=1
    ..... ..... ..... ..... ..... ..... ..... .....
   |  M  |             RTP PT                      |  if R-PT=1
    ..... ..... ..... ..... ..... ..... ..... .....
   /           Compressed CSRC-list                /  if CSRC=1
    ..... ..... ..... ..... ..... ..... ..... .....
   /                  TS STRIDE                    /  1-4 oct if TSS=1
    ..... ..... ..... ..... ..... ..... ..... ....
   /           TIME STRIDE (milliseconds)          /  1-4 oct if IPT=1
    ..... ..... ..... ..... ..... ..... ..... .....

     Mode: Compression mode. 0 = Reserved,
                             1 = Unidirectional,
                             2 = Bi-directional Optimistic,
                             3 = Bi-directional Reliable.

     R-PT, CSRC, TSS, IPT: Indicate presence of fields as shown to the
        right of each field below.

     R-P: RTP Padding bit, absolute value.

     R-X: RTP eXtension bit, absolute value.

     M: see beginning of section 5.7.

     RTP PT: Absolute value of RTP Payload type field.

     Compressed CSRC-list: see section 5.8.1.

     TS STRIDE: Predicted increment/decrement of the RTP Timestamp
     field, when it changes. Encoded as in section 4.5.6.

     TIME STRIDE: Predicted time interval between changes in RTP
     Timestamp, in milliseconds. Also indication that compressor desires
     to do Timer-based compression of the RTP Timestamp field, see
     section 4.5.4. Encoded as in section 4.5.6.


5.7.5.1   RND flags and packet types

   The values of the RND flag or RND2 flag is changed by sending UOR-2
   packets with an Extension 3 where the flag(s) have the new value. In
   U mode, the UOR-2 with Extension 3 is sent several times in order to
   ensure that the decompressor receives at least one. In O mode and R
   mode, the UOR-2 with Extension 3 is repeated until an  acknowledgment
   for a packet with the new RND flag value(s) is received.




Bormann (ed.)                                                  [Page 73]

INTERNET-DRAFT          Robust Header Compression           Oct 11, 2000


   The decompressor updates the value of its RND and RND2 flags whenever
   it receives an UOR-2 with an Extension 3 carrying values for RND or
   RND2, and the UOR-2 CRC verifies successful decompression.

   When an IPv4 header is present in the static context, for which the
   corresponding RND flag has not been established to be 1, packet types
   R-1 and UO-1 MUST NOT be used.

   When no IPv4 header is present in the static context, or the RND
   flags for all IPv4 headers in the context have been established to be
   1, packet types R-1-ID, R-1-TS, UO-1-ID, and UO-1-TS MUST NOT be
   used.

   During the transient state when an RND flag is being established,
   packet types R-1-ID, R-1-TS, UO-1-ID, or UO-1-TS, MUST NOT be used.
   This implies that the RND flag(s) of the Extension 3 may have to be
   consulted before the exact format of a base header carrying an
   Extension 3 can be determined, i.e., whether a T-bit is present or
   not.


5.7.5.2   Flags/Fields in context

   Some flags and fields in Extension 3 need to be maintained in the
   context of the decompressor. Their values are established using the
   mechanism appropriate to the compression mode, unless otherwise
   indicated in the table below and in referred sections.

   Flag/Field      Initial value   comment
   ---------------------------------------------------------------------
     Mode          Unidirectional  See section 5.x.x

     NBO               1
     RND               0

     NBO2              1
     RND2              0

     TS STRIDE         1
     TIME STRIDE       0
     Tsc               0           Tsc is always 0 in context.
                                   Can be 1 only when an Ext 3
                                   is present.











Bormann (ed.)                                                  [Page 74]

INTERNET-DRAFT          Robust Header Compression           Oct 11, 2000


5.7.6. Feedback packets and formats

   When the roundtrip time between compressor and decompressor is large,
   several packets can be in flight. Therefore, several packets can be
   received by the decompressor after feedback has been sent and before
   the compressor has reacted to feedback. Moreover, decompression can
   fail due to residual errors in the compressed header.

   Therefore,

   a) in O-mode the decompressor SHOULD limit the rate at which feedback
      regarding successful decompression is sent (if sent at all).
   b) When decompression fails, feedback SHOULD be sent only when
      decompression of several consecutive packets have failed, and then
      the rate at which feedback is sent should be limited.
   c) When packets are received for a rejected packet stream, the rate
      at which feedback is sent SHOULD be limited.

   A compressor MAY limit the rate at which feedback is sent by only
   sending feedback for every k packets provoking the same (kind of)
   feedback. A suitable value for k is implementation dependent; k might
   be chosen such that feedback is sent 1-3 times per link roundtrip
   time.

   See section 5.2.2 for a discussion concerning ways to provide
   feedback information to the compressor.


5.7.6.2 Feedback formats for ROHC RTP

   The following is the format for feedback information for ROHC RTP.
   See also 5.2.2.

   Several feedback formats carry a field labeled SN. The SN field
   contains LSBs of an RTP sequence number. The sequence number to use
   is the sequence number of the header which caused the feedback
   informatoin to be sent. If that sequence number cannot be determined,
   for example when decompression fails, the sequence number to use is
   that of the last successfully decompressed header. If no sequence
   number is available, the SN field is zero.


   FEEDBACK-1

     0   1   2   3   4   5   6   7
   +---+---+---+---+---+---+---+---+
   |              SN               |
   +---+---+---+---+---+---+---+---+

     A FEEDBACK-1 is an ACK. In order to send a NACK or a STATIC-NACK,
     FEEDBACK-2 must be used. FEEDBACK-1 does not contain any mode



Bormann (ed.)                                                  [Page 75]

INTERNET-DRAFT          Robust Header Compression           Oct 11, 2000


     information, FEEDBACK-2 must be used when mode information is
     required.


   FEEDBACK-2

     0   1   2   3   4   5   6   7
   +---+---+---+---+---+---+---+---+
   |Acktype| Mode  |      SN       |
   +---+---+---+---+---+---+---+---+
   |              SN               |
   +---+---+---+---+---+---+---+---+
   /       Feedback options        /
   +---+---+---+---+---+---+---+---+

     Acktype:  0 = ACK
               1 = NACK
               2 = STATIC-NACK
               3 is reserved (must not be used)

     Mode:     0 is reserved
               1 = Unidirectional mode
               2 = Bi-directional Optimistic mode
               3 = Bi-directional Reliable mode

     Feedback options: A variable number of feedback options, see
        section 5.7.6.3. Options may appear in any order.


5.7.6.3  ROHC RTP Feedback options

   A ROHC RTP Feedback option has variable length and the following
   general format

     0   1   2   3   4   5   6   7
   +---+---+---+---+---+---+---+---+
   |   Opt Type    |   Opt Len     |
   +---+---+---+---+---+---+---+---+
   /          option data          /  Opt Len octets
   +---+---+---+---+---+---+---+---+

   Sections 5.7.6.4-9 describe the currently defined ROHC RTP feedback
   options.


5.7.6.4  The CRC option

   The CRC option contains an 8-bit CRC computed over the entire
   feedback payload, without the packet type and code octet, but
   including any CID fields, using the polynomial of section 5.9.1. If
   the CID is given with an Add-CID octet, the Add-CID octet immediately



Bormann (ed.)                                                  [Page 76]

INTERNET-DRAFT          Robust Header Compression           Oct 11, 2000


   precedes the FEEDBACK-1 or FEEDBACK-2 format. For purposes of
   computing the CRC, the CRC fields of all CRC options are zero.

     0   1   2   3   4   5   6   7
   +---+---+---+---+---+---+---+---+
   |  Opt Type = 1 |  Opt Len = 1  |
   +---+---+---+---+---+---+---+---+
   |              CRC              |
   +---+---+---+---+---+---+---+---+

   When receiving feedback information with a CRC option, the compressor
   MUST verify the information by computing the CRC and comparing the
   result with the CRC carried in the CRC option. If the two are not
   identical, the feedback information MUST be ignored.


5.7.6.5 The REJECT option

   The REJECT option informs the compressor that the decompressor does
   not have sufficient resources to handle the flow.

     0   1   2   3   4   5   6   7
   +---+---+---+---+---+---+---+---+
   |  Opt Type = 2 |  Opt Len = 0  |
   +---+---+---+---+---+---+---+---+

   When receiving a REJECT option, the compressor stops compressing the
   packet stream, and should refrain from attempting to increase the
   number of compressed packet streams for some time. Any FEEDBACK
   packet carrying a REJECT option MUST also carry a CRC option.


5.7.6.6 The SN option

   The SN option provides 8 additional bits of SN.

     0   1   2   3   4   5   6   7
   +---+---+---+---+---+---+---+---+
   |  Opt Type = 3 |  Opt Len = 1  |
   +---+---+---+---+---+---+---+---+
   |              SN               |
   +---+---+---+---+---+---+---+---+


5.7.6.7 The CLOCK option

   The CLOCK option informs the compressor of the clock resolution of
   the decompressor. This is needed to allow the compressor to estimate
   the jitter introduced by the clock of the decompressor when doing
   Timer-based compression of the RTP timestamp.




Bormann (ed.)                                                  [Page 77]

INTERNET-DRAFT          Robust Header Compression           Oct 11, 2000


     0   1   2   3   4   5   6   7
   +---+---+---+---+---+---+---+---+
   |  Opt Type = 4 |  Opt Len = 1  |
   +---+---+---+---+---+---+---+---+
   |     clock resolution (ms)     |
   +---+---+---+---+---+---+---+---+

   The smallest clock resolution which can be indicated is 1
   millisecond. The value zero has a special meaning: it indicates that
   the decompressor cannot do Timer-based compression of the RTP
   timestamp. Any FEEDBACK packet carrying a CLOCK option SHOULD also
   carry a CRC option.


5.7.6.8  The JITTER option

   The JITTER option allows the decompressor to report the maximum
   jitter it has observed lately, using the following formula which is
   very similar to the formula for Max_Jitter BC in section 4.5.4.

   Let Observation window i contain the decompressor's best
   approximation of the TSW of the compressor (see section 4.5.4) when
   header i is received.

      Max_Jitter i_=

            max {|(T_i - T_j) - ((a_i - a_j) / TIME_STRIDE)|,
                 for all headers j in Observation window i}

      Max Jitter =

            max { Max Jitter i, for a large number of recent headers i }

   This information may be used by the compressor to refine the formula
   for determining k when doing Timer-based compression of the RTP
   Timestamp.

     0   1   2   3   4   5   6   7
   +---+---+---+---+---+---+---+---+
   |  Opt Type = 5 |  Opt Len = 1  |
   +---+---+---+---+---+---+---+---+
   |          Max Jitter           |
   +---+---+---+---+---+---+---+---+

   The decompressor MAY ignore the oldest observed values of Max Jitter
   i. Thus, the reported Max Jitter may decrease. Robustness will be
   reduced if the compressor uses a jitter estimate which is too small.
   Therefore, a FEEDBACK packet carrying a JITTER option SHOULD also
   carry a CRC option. Moreover, the compressor MAY ignore decreasing
   Max Jitter values.




Bormann (ed.)                                                  [Page 78]

INTERNET-DRAFT          Robust Header Compression           Oct 11, 2000



5.7.6.9The LOSS option

   The LOSS option allows the decompressor to report the largest
   observed number of packets lost in sequence. This information MAY be
   used by the compressor to adjust the size of the reference window
   used in U and O mode.

     0   1   2   3   4   5   6   7
   +---+---+---+---+---+---+---+---+
   |  Opt Type = 6 |  Opt Len = 1  |
   +---+---+---+---+---+---+---+---+
   | longest loss event (packets)  |
   +---+---+---+---+---+---+---+---+

   The decompressor MAY choose to ignore the oldest loss events. Thus,
   the value reported may decrease. Since setting the reference window
   too small can reduce robustness, a FEEDBACK packet carrying a LOSS
   option SHOULD also carry a CRC option. The compressor MAY choose to
   ignore decreasing loss values.


5.7.6.10  Unknown option types

   If an option type unknown to the compressor is encountered,
   it must continue parsing the rest of the FEEDBACK packet, which is
   possible since the length of the option is explicit, but MUST
   otherwise ignore the unknown option.


5.7.6.11  RTP feedback example

   Feedback for CID 8 indicating an ACK for SN 17 and Bi-directional
   Reliable mode can have the following format.

   Assuming small CIDs:

     0   1   2   3   4   5   6   7
   +---+---+---+---+---+---+---+---+
   | 1   1   1   0 | 1   0   0   0 |  Add-CID octet with CID=8
   +---+---+---+---+---+---+---+---+
   | 1   1   1   1   1   0 |   2   |  feedback packet type, Code=2
   +---+---+---+---+---+---+---+---+
   | 0   1 | 1   1 |  SN MSB = 0   |  AckType = ACK, Mode = Reliable
   +---+---+---+---+---+---+---+---+
   |          SN LSB=17            |
   +---+---+---+---+---+---+---+---+

         The first, third, and fourth octet would be delivered.

   The FEEDBACK-1 format may also be used. Assuming large CIDs:



Bormann (ed.)                                                  [Page 79]

INTERNET-DRAFT          Robust Header Compression           Oct 11, 2000



     0   1   2   3   4   5   6   7
   +---+---+---+---+---+---+---+---+
   | 1   1   1   1   1   0 |   2   |  feedback packet type, Code=2
   +---+---+---+---+---+---+---+---+
   | 0   0   0   0   1   0   0   0 |  large CID with value 8
   +---+---+---+---+---+---+---+---+
   |             SN=17             |
   +---+---+---+---+---+---+---+---+

         The second and third octet would be delivered.

   Assuming small CIDs:

     0   1   2   3   4   5   6   7
   +---+---+---+---+---+---+---+---+
   | 1   1   1   0 | 1   0   0   0 |  Add-CID octet with CID=8
   +---+---+---+---+---+---+---+---+
   | 1   1   1   1   1   0 |   1   |  feedback packet type, Code=1
   +---+---+---+---+---+---+---+---+
   |             SN=17             |
   +---+---+---+---+---+---+---+---+

        The first and third octet would be delivered.


5.7.7  RTP IR and IR-DYN packets

   The subheaders which are compressible are split into a STATIC part
   and a DYNAMIC part. These parts are defined in sections 5.7.6.3-*.

   The structure of a chain of subheaders is determined by each header
   having a Next Header, or Protocol, field. This field identifies the
   type of the following header. Each Static part below contains that
   field and allows parsing of the Static chain.


5.7.7.1 Basic structure of the IR packet

   This packet type communicates the static part of the context, i.e.,
   the value of the constant SN-functions. It can optionally also
   communicate the dynamic part of the context, i.e., the parameters of
   non-constant SN-functions. It can also optionally communicate the
   payload of an original packet, if any.

     0   1   2   3   4   5   6   7
    --- --- --- --- --- --- --- ---
   |         Add-CID octet         |  if for CID!=0 for small CIDs
   +---+---+---+---+---+---+---+---+
   | 1   1   1   1   1   1   0 | D |




Bormann (ed.)                                                  [Page 80]

INTERNET-DRAFT          Robust Header Compression           Oct 11, 2000


   +---+---+---+---+---+---+---+---+
   |                               |
   /    0-2 octets of CID info     /  1-2 octets if for large CIDs
   |                               |
   +---+---+---+---+---+---+---+---+
   |            Profile            |  1 octet
   +---+---+---+---+---+---+---+---+
   |              CRC              |  1 octet
   +---+---+---+---+---+---+---+---+
   |                               |
   |         Static chain          |  variable length
   |                               |
   +---+---+---+---+---+---+---+---+
   |                               |
   |         Dynamic chain         |  present if D=1, variable length
   |                               |
    - - - - - - - - - - - - - - - -
   |                               |
   |           Payload             |  variable length
   |                               |
    - - - - - - - - - - - - - - - -

     D:   D=1 indicates that the dynamic chain is present.

     Profile:  Indicates transport/application of this stream.

          CRC: 8-bit CRC, computed according to section 5.9.1.

     Static chain: A chain of static subheader information.

     Dynamic chain: A chain of dynamic subheader information. What
     dynamic information is present is inferred from the Static chain.

     Payload: payload of corresponding original packet, if any. Presence
     inferred from packet size.


5.7.7.2. Basic structure of the IR-DYN packet

   This packet type communicates the dynamic part of the context, i.e.,
   the parameters of non-constant SN-functions.

     0   1   2   3   4   5   6   7
    --- --- --- --- --- --- --- ---
   |         Add-CID octet         |  if for CID!=0 for small CIDs
   +---+---+---+---+---+---+---+---+
   | 1   1   1   1   1   1   1   0 |
   +---+---+---+---+---+---+---+---+
   |                               |
   /     0-2 octets of CID info    /  1-2 octets if for large CIDs




Bormann (ed.)                                                  [Page 81]

INTERNET-DRAFT          Robust Header Compression           Oct 11, 2000


   |                               |
   +---+---+---+---+---+---+---+---+
   |            Profile            |  1 octet
   +---+---+---+---+---+---+---+---+
   |              CRC              |  1 octet
   +---+---+---+---+---+---+---+---+
   |                               |
   /         Dynamic chain         /  variable length
   |                               |
   +---+---+---+---+---+---+---+---+
   |                               |
   /           Payload             /  variable length
   |                               |
    - - - - - - - - - - - - - - - -

     Profile:  Indicates transport/application of this stream.

     CRC: 8-bit checksum covering original header, computed according to
     section 5.9.1.

     Dynamic chain: A chain of dynamic subheader information. What
     dynamic information is present is inferred from the Static chain of
     the context.

     Payload: payload of corresponding original packet, if any.
              (Presence of payload is inferred from length of packet.)


   NOTE: The static and dynamic chains of IR or IR-DYN packets for
   profile 0 MUST end with static and dynamic parts for an RTP header.
   If not, the packet MUST be discarded and the context must not be
   updated.

   NOTE: The static or dynamic chains of IR or IR-DYN packets for
   profile 1 MUST end with static and dynamic parts for a UDP header.
   If not, the packet MUST be discarded and the packet must not be
   updated.


5.7.7.3.  Initialization of IPv6 Header [IPv6]

      Static part:

        +---+---+---+---+---+---+---+---+
        |  Version = 6  |Flow Label(msb)|   1 octet
        +---+---+---+---+---+---+---+---+
        /        Flow Label (lsb)       /   2 octets
        +---+---+---+---+---+---+---+---+
        |          Next Header          |   1 octet
        +---+---+---+---+---+---+---+---+
        /        Source Address         /   16 octets



Bormann (ed.)                                                  [Page 82]

INTERNET-DRAFT          Robust Header Compression           Oct 11, 2000


        +---+---+---+---+---+---+---+---+
        /      Destination Address      /   16 octets
        +---+---+---+---+---+---+---+---+

      Dynamic part:

        +---+---+---+---+---+---+---+---+
        |         Traffic Class         |   1 octet
        +---+---+---+---+---+---+---+---+
        |           Hop Limit           |   1 octet
        +---+---+---+---+---+---+---+---+
        / Generic extension header list /  variable length
        +---+---+---+---+---+---+---+---+


      Eliminated:

         Payload Length

      Extras

         Generic extension header list
              Encoded according to section 5.8.6.1, with all header
              items present in uncompressed form.

   CRC-DYNAMIC: Payload Length field (octets 5-6).

   CRC-STATIC: All other fields (octets 1-4, 7-40).

   CRC coverage for extension headers is defined in section 5.8.7.
























Bormann (ed.)                                                  [Page 83]

INTERNET-DRAFT          Robust Header Compression           Oct 11, 2000


5.7.7.4. Initialization of IPv4 Header [IPv4, section 3.1].

      Static part:

           Version, Protocol, Source Address, Destination Address.

        +---+---+---+---+---+---+---+---+
        |  Version = 4  |       0       |
        +---+---+---+---+---+---+---+---+
        |           Protocol            |
        +---+---+---+---+---+---+---+---+
        /        Source Address         /   4 octets
        +---+---+---+---+---+---+---+---+
        /      Destination Address      /   4 octets
        +---+---+---+---+---+---+---+---+

      Dynamic part:

           Type of Service, Time to Live, Identification, DF, RND, NBO,
           extension header list.

         +---+---+---+---+---+---+---+---+
         |        Type of Service        |
         +---+---+---+---+---+---+---+---+
         |         Time to Live          |
         +---+---+---+---+---+---+---+---+
         /        Identification         /   2 octets
         +---+---+---+---+---+---+---+---+
         |DF |RND|NBO|         0         |
         +---+---+---+---+---+---+---+---+
         / Generic extension header list /  variable length
         +---+---+---+---+---+---+---+---+


      Eliminated:

         IHL               (must be 5)
         Total Length      (inferred in decompressed packets)
         MF flag           (More Fragments flag, must be 0)
         Fragment Offset   (must be 0)
         Header Checksum   (inferred in decompressed packets)
         Options, Padding  (must not be present)

     Extras:

        RND, NBO           See section 5.7.

        Generic extension header list
                           Encoded according to section 5.8.6.1, with
                           all header items present in uncompressed
                           form.



Bormann (ed.)                                                  [Page 84]

INTERNET-DRAFT          Robust Header Compression           Oct 11, 2000




     CRC-DYNAMIC: Total Length, Identification, Header Checksum
                    (octets 3-4, 5-6, 11-12).

     CRC-STATIC: All other fields (octets 1-2, 7-10, 13-20)

     CRC coverage for extension headers covered in section 5.8.7.


5.7.7.5. Initialization of UDP Header [RFC-768].

    Static part:

        +---+---+---+---+---+---+---+---+
        /          Source Port          /   2 octets
        +---+---+---+---+---+---+---+---+
        /       Destination Port        /   2 octets
        +---+---+---+---+---+---+---+---+

    Dynamic part:

        +---+---+---+---+---+---+---+---+
        /           Checksum            /   2 octets
        +---+---+---+---+---+---+---+---+

    Eliminated:

         Length

   The Length field of the UDP header MUST match the Length field(s) of
   preceding subheaders, i.e., there must not be any padding after the
   UDP payload that is covered by the IP Length.


   CRC-DYNAMIC: Length field, Checksum (octets 5-8).

   CRC-STATIC: All other fields (octets 1-4).


5.7.7.6. Initialization of RTP Header [RTP].

      Static part:

         SSRC.

           0   1   2   3   4   5   6   7
         +---+---+---+---+---+---+---+---+
         /             SSRC              /   4 octets
         +---+---+---+---+---+---+---+---+




Bormann (ed.)                                                  [Page 85]

INTERNET-DRAFT          Robust Header Compression           Oct 11, 2000




      Dynamic part:

           P, X, CC, PT, M, sequence number, timestamp, timestamp
           stride, CSRC identifiers.

           0   1   2   3   4   5   6   7
         +---+---+---+---+---+---+---+---+
         |  V=2  | P | X |      CC       |
         +---+---+---+---+---+---+---+---+
         | M |            PT             |
         +---+---+---+---+---+---+---+---+
         /      RTP sequence number      /  2 octets
         +---+---+---+---+---+---+---+---+
         /   RTP timestamp (absolute)    /  4 octets
         +---+---+---+---+---+---+---+---+
         /      Generic CSRC list        /  variable length
         +---+---+---+---+---+---+---+---+
         /   TS-Stride, 4.5.6 encoding   /  1-4 octets
         +---+---+---+---+---+---+---+---+


      Eliminated:

         Nothing.

      Extras:

         TS-Stride           (See section 4.5.3.)
        Generic CSRC list   CSRC list encoded according to section
                            5.8.6.1, with all CSRC items present.

      CRC-DYNAMIC: Octet containing M-bit, sequence number field,
                   timestamp (octets 2-8).

      CRC-STATIC: All other fields (octets 1, 9-12, original CSRC list).


5.8 List-based compression

   Header information from the packet stream to be compressed can be
   structured as an ordered list, which is largely constant between
   packets. The generic structure of such a list is as follows.

            +--------+--------+--...--+--------+
      list: | item 1 | item 2 |       | item n |
            +--------+--------+--...--+--------+

   This section describes the compression scheme for such information.
   The basic idea of list-based compression is that



Bormann (ed.)                                                  [Page 86]

INTERNET-DRAFT          Robust Header Compression           Oct 11, 2000



   1) while the list is constant, no information regarding the list is
      sent in compressed headers.

   2) Small changes in the list are represented as additions (Insertion
      scheme) or deletions (Removal scheme), or both (Remove Then Insert
      scheme).

   3) The list can also be sent in its entirety, with each individual
      item compressed (Generic scheme).

   There are two kinds of lists: CSRC lists in RTP packets, and
   extension header chains in IP packets (both IPv4 and IPv6).

   IPv6 base headers and IPv4 headers can not be part of an extension
   header chain. Headers which can be part of extension header chains
   include
   a) the AH header,
   b) the null ESP header,
   c) the minimal encapsulation header [RFC-2004, section 3.1],
   d) IPv6 extension headers.

[[Here we should add some IPv4 mobile IP headers]]

[[Add GRE header]]

   The table-based item compression scheme (5.8.1), which reduces the
   size of each item is described first. Then it is defined which
   reference list to use in the insertion and removal schemes (5.8.2).
   List encoding schemes are described in section 5.8.3., and a few
   special handling cases in 5.8.5. Finally, exact formats are described
   in 5.8.5 through 5.8.6.


5.8.1 Table-based item compression

   In the table based item compression scheme, the compressor assigns
   each item in a list a unique identifier Index. The compressor
   conceptually maintains a table with all items, indexed by Index. The
   (Index, item) pair are sent together in compressed lists until the
   compressor gains enough confidence that the decompressor has observed
   the mapping between the item and its Index. Such confidence is
   obtained by receiving an acknowledgment from the decompressor in R-
   mode, and in UO-modes by sending L (Index, item) pairs (not
   necessarily consecutively). Thereafter, the Index alone is sent in
   compressed lists to indicate the corresponding item. The compressor
   may reassign an existing Index to a new item, and then needs to
   reestablish the mapping in the same manner as above.

   The decompressor also conceptually maintains a table that contains
   all item and Index pairs it knows about. The table is updated



Bormann (ed.)                                                  [Page 87]

INTERNET-DRAFT          Robust Header Compression           Oct 11, 2000


   whenever an (Index, item) pair is received. The decompressor
   retrieves the item from the table whenever an Index without an
   accompanying item is received.


5.8.1.1 Translation Table in R-mode

   At the compressor side, an entry in the Translation Table
   conceptually has the following structure.

              +-------+------+---------------+
      index i | Known | item | SN1, SN2, ... |
              +-------+------+---------------+

   The Known flag indicates whether the mapping between Index i and item
   has been established, i.e., if index i alone can be sent in
   compressed lists. Known is initially zero. It is also set to zero
   whenever Index i is assigned to a new item. Known is set to one when
   the corresponding item and Index pair is acknowledged.
   Acknowledgments are based on the RTP sequence number, so a list of
   RTP sequence numbers of each packet which contain the item and Index
   pair is included in the translation table. When a packet with a
   sequence number in the sequence number list is acknowledged, the
   Known flag is set, and the sequence number list can be discarded.

   Each entry in the Translation Table at the decompressor side
   conceptually has the following structure.

              +-------+------+
      index i | Known | item |
              +-------+------+

   All Known fields are initiated to zero. Whenever the decompressor
   receives an (Index, item) pair, it inserts item into the table at
   position Index and sets the Known flag in that entry to one. If an
   index without an accompanying item is received for which the Known
   flag is zero, the header MUST be discarded and a NACK SHOULD be sent.


5.8.1.2 Translation Table in U/O-modes

   At the compressor side, each entry in the Translation Table
   conceptually has the following structure.

            +-------+------+---------+
      Index | Known | item | Counter |
            +-------+------+---------+

   The Index, Known, and item fields have the same meaning as in section
   5.8.2.2.




Bormann (ed.)                                                  [Page 88]

INTERNET-DRAFT          Robust Header Compression           Oct 11, 2000


   Known is set when the (Index, item) pair has been sent in L
   compressed lists (not necessarily consequtively). The Counter field
   keeps track of how many times the pair has been sent. Counter is set
   to 0 for each new entry added to the table, and whenever Index is
   assigned to a new item. Counter is incremented by 1 whenever an
   (Index, item) pair is sent. When the counter reaches L, the Known
   field is set and thereafter only the Index needs to be sent in
   compressed lists.

   At the decompressor side, the Translation Table is the same as the
   Translation Table defined in R-mode.


5.8.2 Reference list determination

   In reference based compression schemes (i.e., addition or deletion
   based schemes), compression and decompression of a header list
   (curr_list) is based on a reference list (ref_list) which is assumed
   to be present in the context of both compressor and decompressor. The
   compressed list is an encoding of the differences between curr_list
   and ref_list. Upon reception of a compressed list, the decompressor
   applies the differences to its reference list to obtain the original
   list.

   To identify the reference list (to be) used, each compressed list
   carries an identifier (ref_id). The reference list is established
   with different methods in R-mode and UO-modes.


5.8.2.1 Reference list in R-mode and UO-modes

   In R-mode, the reference list is chosen based on acknowledgments,
   i.e., the compressor uses as ref_list the latest list which has been
   acknowledged by the decompressor. The ref_list is updated only upon
   receiving an acknowledgment. The least significant bits of the RTP
   sequence number of the acknowledged packet is used as the ref_id.

   In UO-modes, a sequence of identical lists are considered as
   belonging to the same generation and are all assigned the same
   generation identifier (gen_id). Gen_id increases by 1 each time the
   list changes and is carried in compressed and uncompressed lists that
   are candidates for being used as reference lists. The principal
   method of establishing a list in U0-modes is to repeat it L times.
   However, acknowledgments may be sent in UO-modes, and whenever an
   acknowledgment for a header is received, the list of that header is
   considered known and need not be repeated further.

   The logic of the compressor and the decompressor for reference based
   list compression is similar to that for SN and TS. The principal
   difference is that the decompressor maintains a sliding window with




Bormann (ed.)                                                  [Page 89]

INTERNET-DRAFT          Robust Header Compression           Oct 11, 2000


   candidates for ref_list, and retrieves ref_list from the sliding
   window based on the ref_id of the compressed list.

   Logic of compressor:

   a)In the IR state, the compressor sends Generic lists (see 5.8.5)
     containing all items of the current list to establish or refresh
     the context of the decompressor.

     In R-mode, such Generic lists are sent until a header is
     acknowledged. The list of that header can be used as a reference
     list to compress subsequent lists.

     In UO-mode, the compressor sends generation identifiers with the
     Generic lists until
     1) a generation id has been repeated L times, or
     2) an acknowledgment for a header carrying a generation id has
        been received.
     The repeated or acknowledged list can be used as a reference list
     to compress subsequent lists and is kept together with its
     generation id.

   b)When not in IR-state, the compressor moves to FO-state when it
     observes a difference between curr_list and the previous list. It
     sends compressed lists based on ref_list to update the context of
     the decompressor. (However, see d)

     In R-mode, the compressor keeps sending compressed lists using the
     same reference until it receives an acknowledgment for a packet
     containing the newest list. The compressor may then move to SO
     state with regards to the list.

     In UO-modes, the compressor keeps sending compressed lists with
     generation identifiers until
     1) a generation id has been repeated L times, or
     2) an acknowledgment for a header carrying the latest generation
        id has been received.
     The repeated or acknowledged list is used as the future reference
     list. The compressor may move to SO state with regards to the
     list.

   c)In R-mode, the compressor maintains a sliding window containing
     the lists which have been sent to update the context of the
     decompressor and have not yet been acknowledged. The sliding
     window shrinks when an acknowledgment arrives: all list sent
     before the acknowledged list are removed. The compressor may use
     the Index to represent items of lists in the sliding window.

     In UO-modes, the compressor needs to store
        1) the reference list and its generation id, and




Bormann (ed.)                                                  [Page 90]

INTERNET-DRAFT          Robust Header Compression           Oct 11, 2000


        2) if the current generation id is different from the reference
           generation: the current list and the sequence numbers with
           which the current list has been sent.
     2) is needed to determine if an acknowledgment is for the latest
     generation. It is not needed in U-mode.

   d)In UO-modes, the compressor may choose to not send a generation
     identifier with a compressed list. Such lists without generation
     identifiers are not assigned a new generation identifier and must
     not be used as future reference lists. They do not update the
     context. This feature is useful when a new list is repeated few
     times and the list then reverts back to its old value.

   Logic of decompressor:

   e)In R-mode, the decompressor acknowledges all received uncompressed
     or compressed lists which establish or update the context. (Such
     compressed headers contain a CRC.)

     In O-mode, the decompressor MAY acknowledge a list with a new
     generation identifier, see section 5.4.2.2.

     In U-mode, the decompressor MAY acknowledge a list sent in an IR
     packet, see section 5.3.2.3.

   f)The decompressor maintains a sliding window which contains the
     lists that may be used as reference lists.

     In R-mode, the sliding window contains lists which have been
     acknowledged but not yet used as reference lists.

     In UO-mode, the sliding window contains at most one list per
     generation. It contains all generations seen by the decompressor
     newer than the last generation used as a reference.

   g)When the decompressor receives a compressed list, it retrieves the
     proper ref_list from the sliding window based on the ref_id, and
     decompresses the compressed list obtaining curr_list.

     In R-mode, curr_list is inserted into the sliding window if an
     acknowledgment is sent for it. The sliding window is shrunk by
     removing all lists received before ref_list.

     In UO-mode, curr_list is inserted into the sliding window together
     with its generation identifier if the compressed list had a
     generation identifier and the sliding window does not contain a
     list with that generation identifer. All lists with generations
     older than ref_id are removed from the sliding window.






Bormann (ed.)                                                  [Page 91]

INTERNET-DRAFT          Robust Header Compression           Oct 11, 2000


5.8.3 Encoding Schemes for the compressed list

   Four encoding schemes for the compressed list are described here. The
   exact format of the compressed CSRC list and compressed IP extension
   header list using these encoding schemes are described in sections
   5.8.5 and 5.8.6.

   Generic scheme

     In contrast to subsequent schemes, this scheme does not rely on a
     reference list having been established. The entire list is sent,
     using table based compression for each individual item. The
     generic scheme is always used when establishing the context of the
     decompressor and may also be used at other times, as the
     compressor sees fit.

   Insertion Only scheme

     When the new list can be constructed from ref_list by adding
     items, a list of the added items is sent (using table based
     compression), along with the positions in ref_list where the new
     items will be inserted. An insertion bit mask indicates the
     insertion positions in ref_list.

     Upon reception of a list compressed according to the Insertion
     Only scheme, curr_list is obtained by scanning the insertion bit
     mask from left to right. When a '0' is observed, an item is copied
     from the ref_list. When a '1' is observed, an item is copied from
     the list of added items. If a '1' is observed when the list of
     added items has been exhausted, an error has occurred and
     decompression fails. The header must not be delivered to upper
     layers, should be discarded, and must neither be acknowledged nor
     used as a reference.

     To construct the insertion bit mask and the list of added items,
     the compressor MAY use the algorithm described with the following
     steps.

     1) An empty bit list and an empty Inserted Item list are generated
        as the starting point.

     2) Start by considering the first item of curr_list and ref_list.

     3) If curr_list has a different item than ref_list,

            a set bit (1) is appended to the bit list;
            the first item in curr_list (represented using table-based
               item compression) is appended to the Inserted Item list;
            advance to the next item of the curr_list;

        otherwise,



Bormann (ed.)                                                  [Page 92]

INTERNET-DRAFT          Robust Header Compression           Oct 11, 2000



            a zero bit (0) is appended to the bit list;
            advance to the next item of the curr_list;
            advance to the next item of the ref_list.

     4) Repeat 3) until curr_list has been exhausted.

     5) If the length of the bit list is less than the required bit mask
        length, append additional zeroes.

   Removal Only scheme

     This scheme can be used when curr_list can be obtained by removing
     some items in ref_list. The positions of the items which are in
     ref_list, but not in curr_list, are sent as a removal bit mask.

     Upon reception of the compressed list, the decompressor obtains
     curr_list by scanning the removal bit mask from left to right.
     When a '0' is observed, the next item of ref_list is copied into
     curr_list. When a '1' is observed, the next item of ref_list is
     skipped over without being copied. If a '0' is observed when
     ref_list has been exhausted, an error has occurred and
     decompression fails. The header must not be delivered to upper
     layers, should be discarded, and must neither be acknowledged nor
     used as a reference.

     To construct the removal bit mask and the list of added items, the
     compressor MAY use the algorithm described with the following
     steps.

     1) An empty bit list is generated as the starting point.

     2) Start by considering the first item of curr_list and ref_list.

     3) If curr_list has a different item than ref_list,

            a set bit (1) is appended to the bit list;
            advance to the next item of the ref_list;

        otherwise,

            a zero bit (0) is appended to the bit list;
            advance to the next item of the curr_list;
            advance to the next item of the ref_list.

     4) Repeat 3) until curr_list has been exhausted.

     5) If the length of the bit list is less than the required bit mask
        length, append additional ones.

   Remove Then Insert scheme



Bormann (ed.)                                                  [Page 93]

INTERNET-DRAFT          Robust Header Compression           Oct 11, 2000



     In this scheme, curr_list is obtained by first removing items from
     ref_list, and then inserting items into the resulting list. A
     removal bit mask, an insertion bit mask, and a list of added items
     is sent.

     Upon reception of the compressed list, the decompressor processes
     the removal bit mask as in the Removal Only scheme. The resulting
     list is then used as the reference list when the insertion bit
     mask and the list of added items is processed as in the Insertion
     Only scheme.


5.8.4.  Special Handling for IP Extension Headers

   In CSRC list compression, each CSRC is assigned an index. In
   contrast, in IP extension header list compression an index is usually
   associated with a type of extension header. When there is more than
   one IP header, there is more than one list of extension headers. An
   index per type per list is then used.

   The association to a type means that a new index need not always be
   used each time a field in an IP extension header changes. However,
   when a field in an extension header changes, the mapping between the
   index and the new value of the extension header needs to be
   established, except in the special handling cases defined in the
   following subsections.

5.8.4.1.  Next Header Field

   The next header field in an IP header or extension header changes
   whenever the type of the immediately following header changes, e.g.,
   when a new extension header is inserted after it, when the immediate
   subsequent extension header is removed from the list, or when the
   order of several extension headers is changed. Thus it may not be
   uncommon that for a given header, the next header field changes while
   the remaining fields do not change.

   Therefore, in the case that only the next header field changes, the
   extension header is considered to be unchanged and rules for special
   treatment of the change in the next header field is defined as
   follows.

   a) In the case that a subsequent extension header is removed from
     the list, the new value of the next header field is obtained from
     the reference extension header list. For example, assume that the
     reference header list (ref_list) consists of headers A, B and C
     (ref_ext_hdr A, B, C), and the current extension header list
     (curr_list) only consists of extension headers A and C
     (curr_ext_hdr A, C). The order and value of the next header field
     of these extension headers are as follows.



Bormann (ed.)                                                  [Page 94]

INTERNET-DRAFT          Robust Header Compression           Oct 11, 2000



        ref_list:
        +--------+-----+    +--------+-----+    +--------+-----+
        | type B |     |    | type C |     |    | type D |     |
        +--------+     |    +--------+     |    +--------+     |
        |              |    |              |    |              |
        +--------------+    +--------------+    +--------------+
         ref_ext_hdr A        ref_ext_hdr B       ref_ext_hdr C

        curr_list:
        +--------+-----+    +--------+-----+
        | type C |     |    | type D |     |
        +--------+     |    +--------+     |
        |              |    |              |
        +--------------+    +--------------+
         curr_ext_hdr A      curr_ext_hdr C

     Comparing the curr_ext_hdr A in curr_list and the ref_ext_hdr A
     in ref_list, the value of next header field is changed from
     "type B" to "type C" because of removal of extension header B.
     The new value of the next header field in curr_ext_hdr A, i.e.,
     "type C" does not need to be sent to the decompressor. Instead, it
     is retrieved from the next header field of the removed ref_ext_hdr
     B.

   b) In the case that a new extension header is inserted after an
     existing extension header, the next header field in the
     communicated item will carry the type of itself, rather than the
     type of the header that follows. For example, assume that the
     reference header list (ref_list) consists of headers A and C
     (ref_ext_hdr A, C), and the current header list (curr_list)
     consists of headers A, B and C (curr_ext_hdr A, B, C). The order
     and the value of the next header field of these extension headers
     are as follows.

        ref_list:
        +--------+-----+    +--------+-----+
        | type C |     |    | type D |     |
        +--------+     |    +--------+     |
        |              |    |              |
        +--------------+    +--------------+
         ref_ext_hdr A        ref_ext_hdr C

        curr_list:
        +--------+-----+    +--------+-----+    +--------+-----+
        | type B |     |    | type C |     |    | type D |     |
        +--------+     |    +--------+     |    +--------+     |
        |              |    |              |    |              |
        +--------------+    +--------------+    +--------------+
         curr_ext_hdr A      curr_ext_hdr B      curr_ext_hdr C




Bormann (ed.)                                                  [Page 95]

INTERNET-DRAFT          Robust Header Compression           Oct 11, 2000


     Comparing the curr_list and the ref_list, the value of the next
     header field in extension header A is changed from "type C" to
     "type B".

     The uncompressed curr_ext_hdr B is carried in the compressed
     header list. However, it carries "type B" instead of "type C" in
     its next header field. When the decompressor inserts a new header
     after curr_ext_hdr A, the next header field of A is taken from the
     new header, and the next header field of the new header is taken
     from ref_ext_hdr A.


5.8.4.2.  Authentication Header (AH)

   The sequence number field in the AH contains a monotonically
   increasing counter value for a security association. Therefore,
   when comparing curr_list with ref_list, if the sequence number in AH
   changes and SPI field doesn't change, the AH is not considered as
   changed.

   If the sequence number in the AH linearly increases as RTP sequence
   number increases and the compressor is confident that the
   decompressor has obtained the pattern, the sequence number in AH need
   not be sent. The decompressor applies linear extrapolation to
   reconstruct the sequence number in the AH.

   Otherwise, a compressed sequence number is included in the IPX
   compression field in an extension 3 of an UOR-2 header.

   The authentication data field in AH changes from packet to packet
   and is sent as-is. If the uncompressed AH is sent, the authentication
   data field is sent inside the uncompressed AH; otherwise, it is sent
   after the compressed IP/UDP/RTP and IPv6 extension headers and before
   the payload. See beginning of section 5.7.


5.8.4.3.  Encapsulating Security Payload Header

   When the Encapsulating Security Payload Header (ESP) is used, the UDP
   and RTP headers are both encrypted and cannot be compressed. The ESP
   header thus ends header chain. An ESP profile has been defined for
   packet streams with ESP headers.

   A special case is the null ESP header, which can be used for
   authentication. For the null ESP header, subsequent headers are not
   encrypted and the RTP profile can be used for the stream.

   In ESP, the only fields that can be compressed are the SPI and the
   sequence number.





Bormann (ed.)                                                  [Page 96]

INTERNET-DRAFT          Robust Header Compression           Oct 11, 2000


   a) In the case that the SPI field changes, the new value of the SPI
      field needs to be established.

   b) When there is no change in the SPI field, the ESP is not
      considered to be changed.

   The sequence number in ESP has the same behavior as the sequence
   number field in AH. When it increases linearly, it need not be sent.
   When it does not increase linearly, a compressed sequence number is
   included in the IPX compression field in an extension 3 of an UOR-2
   header.


5.8.4.4.  Mobile IPv6 Related Destination Option Header

   A Destination Option Header that carries one or more mobile IPv6
   related options (Binding Update option (BU), Binding Request option
   (BR), Binding Acknowledgment option (BA), or Home Address option
   (HA)) can be sent compressed or uncompressed.

   The option list carried in the destination option header could in
   principle be compressed using the list compression scheme. However,
   to keep the algorithm simple, the following simplified scheme is
   used.

   Each type of option in the destination option header can be sent
   compressed or uncompressed. The sequence of the compressed or
   uncompressed option in the compressed option list must be the same as
   in the original option list. A particular option can be sent
   compressed when the compressor observes that all the fields except
   sequence number field in BU and BA are unchanged and when it has
   sufficient confidence that an option with the same option type has
   been received by the decompressor.

   Such confidence is obtained by the acknowledgment in R-mode and can
   be obtained by an acknowledgment in O-mode. In UO-mode, an option
   which has been sent L times is also considered to be known. Mobile
   IPv6 related options are sent every once in a while and normally not
   in a large number of consecutive packets. However, whenever an option
   type has been sent L times (not necessarily consecutively), it is
   assumed to be known to the decompressor.

   The format of the compressed option depends on the option type. The
   compressed BU and BA options contain the option type field followed
   by the sequence number field. The compressed BR and BA options
   contain only the option type field. Unknown options are sent
   uncompressed.

   compressed BU or BA:

     0   1   2   3   4   5   6   7



Bormann (ed.)                                                  [Page 97]

INTERNET-DRAFT          Robust Header Compression           Oct 11, 2000


   +---+---+---+---+---+---+---+---+
   |          Option Type          |
   +---+---+---+---+---+---+---+---+
   |                               |
   +        Sequence Number        +
   |                               |
   +---+---+---+---+---+---+---+---+


   compressed BR or HA:

     0   1   2   3   4   5   6   7
   +---+---+---+---+---+---+---+---+
   |          Option Type          |
   +---+---+---+---+---+---+---+---+

   A bit mask indicating whether or not the corresponding MIPv6 related
   option is sent compressed is included. If a particular option is not
   included in current packet, the corresponding bit is set to 0. The
   format of such bit masks is shown in section 5.8.6.1.

5.8.4.5.  Mobile IPv4 Extension Headers

   [[TBW]]

5.8.4.6.  GRE Header

   [[TBW.  This seems nearly trivial, except that we need space for
   another sequence number in the IP extension headers field.  We're out
   of bits there...]

5.8.5.  Format of Compressed Lists

5.8.5.1.  Format of IP Extension Hdr(s) field

   In Extension 3 (section 5.7.5), there is a field called IP extension
   hdr(s). This section describes the format of that field.

         0     1     2     3     4     5     6     7
      +-----+-----+-----+-----+-----+-----+-----+-----+
      | ASeq| ESeq| CL  | res | CBU | CBA | CBR | CHA | 1 octet
      +-----+-----+-----+-----+-----+-----+-----+-----+
      /    compressed AH Seq Number, 1 or 4 octets    / if ASeq=1
       ----- ----- ----- ----- ----- ----- ----- -----
      /    compressed ESP Seq Number, 1 or 4 octets   / if Eseq=1
       ----- ----- ----- ----- ----- ----- ----- -----
      /    compressed header list, variable length    / if CL=1
       ----- ----- ----- ----- ----- ----- ----- -----

      ASeq: indicates presence of compressed AH Seq Number
      ESeq: indicates presence of compressed ESP Seq Number



Bormann (ed.)                                                  [Page 98]

INTERNET-DRAFT          Robust Header Compression           Oct 11, 2000


      CL: indicates presence of compressed header list
      res: reserved. Set to zero when sending, ignored when received.
      CBU: indicates if Binding Update option is sent compressed
      CBA: indicates if Binding Ack option is sent compressed
      CBR: indicates if Binding Request option is sent compressed
      CHA: indicates if Home Address option is sent compressed
   When ASeq or ESeq is set, the corresponding header item (AH or ESP
   header) is compressed. When not set, the corresponding header item is
   sent uncompressed or is not present.

   When CBU, CBA, CBR, or CHA is zero, this means that the option in
   question is either not present or not compressed.

   The format of compressed AH Seq Number and compressed ESP Seq Number
   can be either of the following:

     0   1   2   3   4   5   6   7       0   1   2   3   4   5   6   7
   +---+---+---+---+---+---+---+---+   +---+---+---+---+---+---+---+---+
   | 0 |   LSB of sequence number  |   | 1 |                           |
   +---+---+---+---+---+---+---+---+   +---+                           +
                                       |                               |
                                       +     LSB of sequence number    +
                                       |                               |
                                       +                               +
                                       |                               |
                                       +---+---+---+---+---+---+---+---+

   The format of the compressed IPv6 extension hdr field is described in
   section 5.8.6.


5.8.5.2 Format of Compressed CSRC List

   The Compressed CSRC List field in the RTP header part of an extension
   3 (section 5.7.5) is as in section 5.8.6.


5.8.6 Compressed list formats

   This section describes the format of compressed lists. It is the same
   for header lists and CSRC lists; items are CSRC identifiers for CSRC
   lists, and uncompressed or compressed headers as described in
   5.8.4.2-4 for header lists.

5.8.6.1  Encoding Type 0 (generic scheme)

     0   1   2   3   4   5   6   7
   +---+---+---+---+---+---+---+---+
   | ET=0  |GP |PS |    CC = m     |
   +---+---+---+---+---+---+---+---+
   :            gen_id             :  1 octet, if GP=1



Bormann (ed.)                                                  [Page 99]

INTERNET-DRAFT          Robust Header Compression           Oct 11, 2000


   +---+---+---+---+---+---+---+---+
   |        XI 1, ..., XI m        |  m octets, or m*4 bits
   /                --- --- --- ---/
   |               |    Padding    |  if PS=0 and m is odd.
   +---+---+---+---+---+---+---+---+
   |                               |
   /       item 1, ..., item n     /  n * 4 octets
   |                               |
   +---+---+---+---+---+---+---+---+

      ET: encoding type is zero.

      PS: indicates size of XI fields
            PS=0 indicates 4-bit XI fields
            PS=1 indicates 8-bit XI fields

      GP: indicates presence of gen_id field

      CC: CSRC counter from original RTP header

     gen_id: identifier for a sequence of identical lists. It is
        present in UO-mode when the compressor decides that it may use
        this list as a future reference list.

      XI 1, ..., XI m: m XI items. The format of an XI item is

                     +---+---+---+---+
         when PS=0:  | X |   Index   |
                     +---+---+---+---+

                       0   1   2   3   4   5   6   7
                     +---+---+---+---+---+---+---+---+
         when PS=1:  | X |           Index           |
                     +---+---+---+---+---+---+---+---+

           X = 1: indicates that the item corresponding to the Index
                  is sent in the item 0, ..., item n list
           X = 0: indicates that the item corresponding to the Index is
                  not sent.

        When 4-bit XI items are used and m>1, the XI items are placed
        in octets in the following manner:

                       0   1   2   3   4   5   6   7
                     +---+---+---+---+---+---+---+---+
                     |     XI k      |     XI k+1    |
                     +---+---+---+---+---+---+---+---+

      Padding: a 4-bit padding field is present when PS=0 and m is odd.
         The Padding field is set to zero when sending and ignored when
         receiving.



Bormann (ed.)                                                 [Page 100]

INTERNET-DRAFT          Robust Header Compression           Oct 11, 2000



      Item 1, ..., item n:
         Each item corresponds to an XI with X=1 in XI 1, ..., XI m.


5.8.6.2 Encoding Type 1 (insertion only scheme)

     0   1   2   3   4   5   6   7
   +---+---+---+---+---+---+---+---+
   | ET=1  |GP |PS |     XI 1      |
   +---+---+---+---+---+---+---+---+
   :            gen_id             :  1 octet, if GP=1
   +---+---+---+---+---+---+---+---+
   |            ref_id             |
   +---+---+---+---+---+---+---+---+
   /      insertion bit mask       /  1-2 octets
   +---+---+---+---+---+---+---+---+
   |            XI list            |  k octets, or (k-1)*4 bits
   /                --- --- --- ---/
   |               |    Padding    |  if PS=0 and k is even.
   +---+---+---+---+---+---+---+---+
   |                               |
   /      item 1, ..., item n      /  n * 4 octets
   |                               |
   +---+---+---+---+---+---+---+---+

   Unless explicitly stated otherwise, fields have the same meaning and
   values as for encoding type 0.

      ET: encoding type is one (1).

      XI 1: when PS=0, the first 4-bit XI item is placed here.
        when PS=1, the field is set to zero when sending, and ignored
        when receiving.

      ref_id: the identifier of the reference CSRC list used when the
        list was compressed. It is the 8 least significant bits of
        the RTP sequence number in R-mode and gen_id (see section
        5.8.2) in UO-modes.

     insertion bit mask: bit-mask indicating the positions where new
        items are to be inserted. See Insertion Only scheme in section
        5.8.3. The bit-mask can have either of the following two
        formats

              0   1   2   3   4   5   6   7
            +---+---+---+---+---+---+---+---+
            | 0 |        7-bit mask         |  bit 1 is first bit
            +---+---+---+---+---+---+---+---+

            +---+---+---+---+---+---+---+---+



Bormann (ed.)                                                 [Page 101]

INTERNET-DRAFT          Robust Header Compression           Oct 11, 2000


            | 1 |                           |  bit 1 is first bit
            +---+      15-bit mask          +
            |                               |  bit 7 is last bit
            +---+---+---+---+---+---+---+---+

     XI list: XI fields for items to be inserted. When the insertion
        bit mask has k ones, the total number of XI fields is k. When
        PS=1, all XI fields are in the XI list. When PS=0, the first XI
        field is in the XI 1 field, and the remaining k-1 XI fields are
        in the XI list.

     Padding: present when PS=0 and k is even.

     item 1, ..., item n: an item for each XI field with the X bit set.


5.8.6.3 Encoding Type 2 (removal only scheme)

     0   1   2   3   4   5   6   7
   +---+---+---+---+---+---+---+---+
   | ET=2  |GP |res|     Count     |
   +---+---+---+---+---+---+---+---+
   :            gen_id             :  1 octet, if GP=1
   +---+---+---+---+---+---+---+---+
   |            ref_id             |
   +---+---+---+---+---+---+---+---+
   /       removal bit mask        /  1-2 octets
   +---+---+---+---+---+---+---+---+

   Unless explicitly stated otherwise, fields have the same meaning and
   values as in section 5.8.5.2.

      ET: Encoding type is 2.

     res: Reserved. Set to zero when sending, ignored when received.

     Count: number of elements in ref_list.

     removal bit mask: indicates the elements in ref_list to be removed
        in order to obtain the current list. See section 5.8.3. The
        removal bit mask has the same format as the insertion bit mask
        of section 5.8.5.3.












Bormann (ed.)                                                 [Page 102]

INTERNET-DRAFT          Robust Header Compression           Oct 11, 2000


5.8.6.4 Encoding Type 3 (remove then insert scheme)

   See section 5.8.3 for a description of the Remove then insert scheme.

     0   1   2   3   4   5   6   7
   +---+---+---+---+---+---+---+---+
   | ET=3  |GP |PS |     XI 1      |
   +---+---+---+---+---+---+---+---+
   :            gen_id             :  1 octet, if GP=1
   +---+---+---+---+---+---+---+---+
   |            ref_id             |
   +---+---+---+---+---+---+---+---+
   /       removal bit mask        /  1-2 octets
   +---+---+---+---+---+---+---+---+
   /      insertion bit mask       /  1-2 octets
   +---+---+---+---+---+---+---+---+
   |            XI list            |  k octets, or (k-1)*4 bits
   /                --- --- --- ---/
   |               |    Padding    |  if PS=0 and k is even.
   +---+---+---+---+---+---+---+---+
   |                               |
   /      item 1, ..., item n      /  n * 4 octets
   |                               |
   +---+---+---+---+---+---+---+---+

   The fields in this header has the same meaning and formats as in
   section 5.8.5.2, except when explicitly stated otherwise below.

      ET: Encoding type is 3.

      removal bit mask: see section 5.8.5.3.


5.8.7  CRC coverage for extension headers

   All fields of Extension headers are CRC-STATIC, with the following
   exceptions which are CRC-DYNAMIC.

   1) Entire AH header.
   2) Entire ESP header.
   3) Sequence numbers in Mobile IP related options, i.e., sequence
      numbers in BU and BA options.
   4) [[Add text for M-IPv4 and GRE]]


5.9.  Header compression CRCs, coverage and polynomials

   This chapter describes how to calculate the CRCs used in packet
   headers defined in this document.





Bormann (ed.)                                                 [Page 103]

INTERNET-DRAFT          Robust Header Compression           Oct 11, 2000



5.9.1.  IR & IR-DYN packet CRCs

   The CRC in the IR and IR-DYN packet is calculated over the entire IR
   or IR-DYN packet, excluding Payload and including CID. For purposes
   of computing the CRC, the CRC field in the header is set to zero.

   The initial content of the CRC register is to be preset to all 1's.

   The CRC polynomial to be used is:

     C(x) = 1 + x + x^2 + x^8


5.9.2.  CRCs in compressed packets

   The CRC in compressed headers is calculated over all octets of the
   entire original header, before compression, in the following manner.

   The octets of the header are classified as either CRC-STATIC or CRC-
   DYNAMIC, and the CRC is calculated over:

   1) the concatenated CRC-STATIC octets of the original header, placed
      in the same order as they appear in the original header, followed
      by

   2) the concatenated CRC-DYNAMIC octets of the original header, placed
      in the same order as they appear in the original header.

   The intent is that the state of the CRC computation after 1) will be
   saved. As long as the CRC-STATIC octets do not change, the CRC
   calculation will then only need to process the CRC-DYNAMIC octets.

   For a typical RTP/UDP/IPv4 header, 25 octets are CRC-STATIC and 15
   are CRC-DYNAMIC. For a typical RTP/UDP/IPv6 header, 49 octets are
   CRC-STATIC and 11 are CRC-DYNAMIC. This technique will thus reduce
   the computational complexity of the CRC calculation by roughly 60%
   for RTP/UDP/IPv4 and by roughly 80% for RTP/UDP/IPv6.

   Note: whenever the CRC-STATIC fields change, the new saved CRC state
   after 1) is compared with the old state. If the states are identical,
   the CRC cannot catch the error that the decompressor has not updated
   the static context. The compressor should then require an ACK in O
   mode and send the information for a longer time in U mode. Optimistic
   transition from IR or FO state should not be attempted in this case.

   The initial content of the CRC register is preset to all 1's.

   The polynomial to be used for the 3 bit CRC is:

     C(x) = 1 + x + x^3



Bormann (ed.)                                                 [Page 104]

INTERNET-DRAFT          Robust Header Compression           Oct 11, 2000



   The polynomial to be used for the 7 bit CRC is:

     C(x) = 1 + x + x^2 + x^3 + x^6 + x^7

   The CRC in compressed packets is calculated over the entire original
   header, before compression.


5.10. ROHC UNCOMPRESSED _ no compression (Profile 0)

   In ROHC, compression has not been defined for all kinds of IP
   headers. Profile 0 provides a way to send IP packets without
   compressing them. This can be used for IP fragments, RTCP packets,
   and in general for any packet for which compression of the header has
   not been defined, is not possible due to resource constraints, or is
   not desirable for any other reason.

   After initialization, the only overhead for sending packets using
   Profile 0 is the size of the CID. When uncompressed packets are
   frequent, Profile 0 should be associated with a CID with size zero or
   one octet. There is no need to associate Profile 0 with more than one
   CID.

5.10.1 IR packet

   The initialization packet (IR packet) for Profile 0 has the following
   format:

     0   1   2   3   4   5   6   7
    --- --- --- --- --- --- --- ---
   |         Add-CID octet         |  if for CID!=0 for small CIDs
   +---+---+---+---+---+---+---+---+
   | 1   1   1   1   1   1   0 |res|
   +---+---+---+---+---+---+---+---+
   |                               |
   /    0-2 octets of CID info     /  1-2 octets if for large CIDs
   |                               |
   +---+---+---+---+---+---+---+---+
   |          Profile = 0          |  1 octet
   +---+---+---+---+---+---+---+---+
   |              CRC              |  1 octet
   +---+---+---+---+---+---+---+---+
   |                               |  (optional)
   /           IP packet           /  variable length
   |                               |
    - - - - - - - - - - - - - - - -

      res: Always zero.

      Profile: 0.



Bormann (ed.)                                                 [Page 105]

INTERNET-DRAFT          Robust Header Compression           Oct 11, 2000



      CRC: 8-bit CRC, computed using the polynomial of section 5.9.1.
         The CRC is covers the first octet of the IR packet through the
         Profile octet of the IR packet, i.e., it does not cover the
         CRC itself nor the IP packet.

      IP packet: An uncompressed IP packet may be included in the IR
         packet. The decompressor determines if the IP packet is
         present by considering the length of the IR packet.


5.10.2 Normal packet

   A Normal packet is a normal IP packet plus CID information. When the
   channel uses small CIDs, and profile 0 is associated with a CID >0,
   an Add-CID octet is prepended to the IP packet. When the channel uses
   large CIDs, the CID is placed so that it starts at the second octet
   of the Normal packet.

     0   1   2   3   4   5   6   7
    --- --- --- --- --- --- --- ---
   |         Add-CID octet         |  if for CID!=0 for small CIDs
   +---+---+---+---+---+---+---+---+
   |   first octet of IP packet    |
   +---+---+---+---+---+---+---+---+
   |                               |
   /    0-2 octets of CID info     /  1-2 octets if for large CIDs
   |                               |
   +---+---+---+---+---+---+---+---+
   |                               |
   /      rest of IP packet        /  variable length
   |                               |
   +---+---+---+---+---+---+---+---+

   Note that the first octet of the IP packet starts with the bit
   pattern 0100 (IPv4) or 0110 (IPv6). This does not conflict with any
   reserved packet types. Hence, no bits in addition to the CID are
   needed. The profile is reasonably future-proof since problems do not
   occur until IP version 14.


5.10.3 States and Modes

   There are two modes in Profile 0: Unidirectional mode and Bi-
   directional mode. In Unidirectional mode, the compressor repeats the
   IR packet periodically. In Bi-directional mode, the compressor never
   repeats the IR packet. Compressor and decompressor always start in
   Unidirectional mode. Whenever feedback is received, the compressor
   moves to Bi-directional mode.





Bormann (ed.)                                                 [Page 106]

INTERNET-DRAFT          Robust Header Compression           Oct 11, 2000


   The compressor can be in either of two states: the IR state or the
   Normal state. It starts in the IR state.

   a) IR State: Only IR packets can be sent. After sending a small
      number of IR packets, one when refreshing, the compressor moves
      to the Normal state.

   b) Normal state: Only Normal packets can be sent. When in
      Unidirectional mode, the compressor periodically transits back to
      the IR state. The length of the period is implementation
      dependent, but should be fairly long. Exponential backoff may be
      used.

   c) When feedback is received in any state, the compressor moves  to
      Bi-directional mode.

   The decompressor can be in either of two states: NO_CONTEXT or
   FULL_CONTEXT. It starts in NO_CONTEXT.

   d) When an IR packet is received in the NO_CONTEXT state, the
      decompressor first verifies the packet using the CRC. If the
      packet is ok, the decompressor 1) moves to the FULL_CONTEXT
      state, 2) delivers the IP packet to upper layers if present, 3)
      MAY send an ACK. If the packet is not ok, it is discarded without
      further action.

   e) When any other packet is received in the NO_CONTEXT state, it is
      discarded without further action.

   f) When an IR packet is received in the FULL_CONTEXT state, the
      packet is first verified using the CRC. If ok, the decompressor
      1) delivers the IP packet to upper layers if present, 2) MAY send
      an ACK. If the packet is not ok, no action is taken.

   g) When a Normal packet is received in the FULL_CONTEXT state, the
      CID information is removed and the IP packet is delivered to
      upper layers.


5.10.4 Feedback

   The only kind of feedback in Profile 0 is ACKs. Profile 0 must not be
   rejected. Profile 0 should be associated with at most one CID. ACKs
   use the FEEDBACK-1 format of section 5.2. The value of the profile-
   specific octet in the FEEDBACK-1 ACK is 0 (zero).


5.11. ROHC UDP - non-RTP UDP/IP compression (Profile 2)

   UDP/IP headers do not have a sequence number which is as well-behaved
   as the RTP sequence number. For UDP/IPv4, there is an IP-ID field



Bormann (ed.)                                                 [Page 107]

INTERNET-DRAFT          Robust Header Compression           Oct 11, 2000


   which may be echoed in feedback information, but when no IPv4 header
   is present such feedback identification becomes problematic.

   Therefore, in the ROHC UDP profile, the compressor generates a 16-bit
   sequence number SN which increases by one for each packet received in
   the packet stream. This sequence number is thus relatively well-
   behaved and can serve as the basis for most mechanisms described for
   ROHC RTP. It is called SN or UDP SN below. Unless stated otherwise,
   the mechanisms of ROHC RTP are used also for ROHC UDP, with the UDP
   SN taking the role of the RTP sequence number.


5.11.1 Initialization

   The static context for ROHC UDP streams can be initialized in either
   of two ways;

   1) By using an IR packet as in section 5.7.7.1, where the profile is
      one (2) and the static chain ends with the static part of an UDP
      packet. At the compressor, UDP SN is initialized to a random value
      when the IR packet is sent.

   2) By reusing an existing context, where the existing static chain
      contains the static part of a UDP packet, e.g., the context of a
      stream compressed using ROHC RTP (profile 1). This is done with an
      IR-DYN packet (section 5.7.7.2) with profile = 2, where the
      dynamic chain corresponds to the prefix of the existing static
      chain that ends with the UDP header. UDP SN is initialized to the
      RTP sequence number if the earlier profile was profile 1, and to a
      random number otherwise.

   For ROHC UDP, the dynamic part of a UDP packet is different from
   section 5.7.7.5; a two-octet field containing the UDP SN is added
   after the Checksum field. This affects the format of dynamic chains
   in IR and IR-DYN packets.

   Note: 2) can be used for packet streams where the initial assumption
   was that they were RTP streams, so compression started with profile
   1, and it later becomes evident that they are not RTP streams.


5.11.2 States and Modes

   ROHC UDP uses the same states and modes as ROHC RTP. Mode transitions
   and state logic is the same except when explicitly stated otherwise.
   Mechanisms dealing with fields in the RTP header (except the RTP SN)
   are not used. The decompressed UDP SN is never included in any header
   delivered to upper layers. The UDP SN is used in place of the RTP SN
   in feedback.





Bormann (ed.)                                                 [Page 108]

INTERNET-DRAFT          Robust Header Compression           Oct 11, 2000


5.11.3 Packet types

   The general format of a ROHC UDP packet is the same as for ROHC RTP
   (see beginning of section 5.7.). Padding and CIDs are the same, as is
   the feedback packet type (5.7.6.1) and the feedback. IR and IR-DYN
   packets (5.7.7) are changed as described in 5.11.2.

   The general format of compressed packets is also the same, but there
   are differences in specific formats and extensions as follows. The
   differences are caused by removal of all RTP specific information
   except the RTP SN which is replaced by the UDP SN.

   Unless explicitly stated below, the packet formats are as in sections
   5.7.1-6.

   R-1

      The TS field is replaced by an IP-ID field. M flag has become
      another bit of IP-ID. X bit has moved. Formats R-1-ID and R-1-TS
      are not used.

     0   1   2   3   4   5   6   7
   +---+---+---+---+---+---+---+---+
   | 1   0 |          SN           |
   +===+===+===+===+===+===+===+===+
   | X |           IP-ID           |
   +---+---+---+---+---+---+---+---+


   UO-1

      The TS field is replaced by an IP-ID field. M-flag has become
      part of SN. Formats UO-1-ID and UO-1-TS are not used.

     0   1   2   3   4   5   6   7
   +---+---+---+---+---+---+---+---+
   | 1   0 |         IP-ID         |
   +===+===+===+===+===+===+===+===+
   |        SN         |    CRC    |
   +---+---+---+---+---+---+---+---+

   UOR-2

      New format.

     0   1   2   3   4   5   6   7
   +---+---+---+---+---+---+---+---+
   | 1   1   0 |        SN         |
   +===+===+===+===+===+===+===+===+
   | X |            CRC            |
   +---+---+---+---+---+---+---+---+



Bormann (ed.)                                                 [Page 109]

INTERNET-DRAFT          Robust Header Compression           Oct 11, 2000






5.11.4 Extensions

   Extensions are as in 5.7.5, with the following exceptions:

   Extension 0:

     +---+---+---+---+---+---+---+---+
     | 0   0 |    SN     |   IP-ID   |
     +---+---+---+---+---+---+---+---+

   Extension 1:

     +---+---+---+---+---+---+---+---+
     | 0   1 |    SN     |   IP-ID   |
     +---+---+---+---+---+---+---+---+
     |             IP-ID             |
     +---+---+---+---+---+---+---+---+

   Extension 2:

     +---+---+---+---+---+---+---+---+
     | 0   1 |    SN     |   IP-ID2  |
     +---+---+---+---+---+---+---+---+
     |            IP-ID2             |
     +---+---+---+---+---+---+---+---+
     |             IP-ID             |
     +---+---+---+---+---+---+---+---+

        IP-ID2: for outer IP-ID field.

   Extension 3 is the same as Extension 3 in section 5.7.5, with the
   following exceptions.

   1) The initial flag octet has the following format:

         0     1     2     3     4     5     6     7
      +-----+-----+-----+-----+-----+-----+-----+-----+
      |  1     1  |  S  |   Mode    |  I  | ip  | ip2 |
      +-----+-----+-----+-----+-----+-----+-----+-----+

      Mode: replaces R-TS and Tsc of 5.7.5. Provides mode information
         as was earlier done in RTP header flags and fields.

      ip2: replaces rtp-bit of 5.7.5. Moved here from the Inner IP hdr
         flags octet (that bit is now always zero).





Bormann (ed.)                                                 [Page 110]

INTERNET-DRAFT          Robust Header Compression           Oct 11, 2000


   2) The bit which was the ip2 flag in the Inner IP hdr flags in 5.7.5
      is reserved. It is set to zero when sending and ignored when
      receiving.


5.11.5 IP-ID

   Treated as in ROHC RTP but offset is from UDP SN.


5.11.6. Feedback

   Feedback is as for ROHC RTP with the following exceptions:

   1) UDP SN replaces RTP SN in feedback.
   2) The CLOCK option (5.7.6.7) is not used.
   3) The JITTER option (5.7.6.8) is not used.
   4) The feedback formats of section 5.7.6.2 are replaced by the
      following:  [[Not sure they do need to be replaced...]]



































Bormann (ed.)                                                 [Page 111]

INTERNET-DRAFT          Robust Header Compression           Oct 11, 2000


6.  Implementation issues

   This document specifies mechanisms for the protocol, while much of
   the usage of these mechanisms is left to the implementers to decide
   upon. This chapter is aimed to give guidelines, ideas and suggestions
   for implementing the scheme.


6.1.  Reverse decompression

   This chapter describes an OPTIONAL decompressor operation to reduce
   discarded packets due to an invalid context.

   Once a context becomes invalid (e.g., in the case when more
   consecutive packet losses than expected has occurred), subsequent
   compressed packets cannot be decompressed correctly immediately.
   Reverse decompression aims at decompressing such packets later
   instead of discarding them, by storing them until the context has
   been updated and validated and then attempting decompression.

   Let the sequence of stored packets be i, i+1, ..., i+k, where i is
   the first packet and I+k is the packet before the context was
   updated. The decompressor will attempt to recover the stored packets
   in reverse order, i.e., starting with i+k, and working towards i.
   When a stored packet has been reconstructed, its correctness is
   verified using its CRC. Packets not carrying a CRC must not be
   delivered to upper layers. Packets where the CRC succeeds, are
   delivered to upper layers in the original order, i.e., i, ..., i+k.

   Note that this reverse decompression introduces buffering while
   waiting for the context to be validated and thereby introduces
   additional delay. Thus, it should be used only when some amount of
   delay is acceptable. For example, for video packets belonging to the
   same video frame, the delay of packet arrival time does not cause
   presentation time delay. Delay-insensitive streaming applications can
   also be tolerant to such delay. If the decompressor cannot determine
   if the application can tolerate delay, it should not do reverse
   decompression.

   The following illustrates the decompression procedure in some detail:

   1. The decompressor stores compressed packets that cannot be
      decompressed correctly due to an invalid context.

   2. When the decompressor has received a context updating packet and
      the context has been validated, it starts to recover the stored
      packets in reverse order. Decompression is carried out followed
      by the last decompressed packet to its previous packet as if the
      two packets were reordered. After that, the decompressor checks
      the correctness of the reconstructed header using the CRC.




Bormann (ed.)                                                 [Page 112]

INTERNET-DRAFT          Robust Header Compression           Oct 11, 2000


   3. If the CRC indicates successful decompression, the decompressor
      stores the complete packet and attempts to decompress the
      preceeding packet. In this way, the stored packets are recovered
      until no compressed packets are left. For each packet, the
      decompressor checks the correctness of the decompressed headers
      using header compression CRC.

   4. If the CRC indicates an incorrectly decompressed packet, the
      reverse decompression attempt must be terminated and all
      remaining uncompressed packets must be discarded.

   5. Finally, the decompressor forwards all the correctly decompressed
      packets to upper layers in the original order.

6.2.  RTCP

   RTCP is the RTP Control Protocol, [RTP]. RTCP is based on periodic
   transmission of control packets to all participants in a session,
   using the same distribution mechanism as for data packets. Its
   primary function is to provide feedback from the data receivers on
   the quality of the data distribution. The feedback information may be
   used for issues related to congestion control functions, and directly
   useful for control of adaptive encodings.

   In an RTP session there will be two types of packet streams; one with
   the RTP-header and application data, and a second stream with the
   RTCP control information. The difference between the streams at the
   transport level is the UDP port numbers, which is plus one for RTCP.
   The ROHC header compressor implementation has several ways at hand to
   handle the RTCP stream.

     1. One compressor/decompressor entity for both streams and carried
        on the same channel using CIDs to distinguish between them. On
        the RTCP stream, basically only IP/UDP compression will be
        utilized.

     2. Two compressor/decompressor entities, one for RTP and another
        one for RTCP, and the streams carried on their own channel. This
        means that they will not share the same CID number space.

     3. RTCP headers may be sent uncompressed using profile 0.


6.3.  Implementation parameters and signals

   A ROHC implementation may have two kinds of parameters; configuration
   parameters that are mandatory and must be negotiated between
   compressor and decompressor peers, and also implementation parameters
   that are optional and when used, mandate how a ROHC implementation is
   to operate.




Bormann (ed.)                                                 [Page 113]

INTERNET-DRAFT          Robust Header Compression           Oct 11, 2000



   Configuration parameters are mandatory and must be negotiated between
   compressor and decompressor, so they have the same values at
   compressor and decompressor. An example of a configuration parameter
   is whether context identification bits (CID) should be used or not.

   Implementation parameters make it possible to mandate how an
   implementation of a ROHC compressor or decompressor should operate.
   Implementation parameters have local significance, are optional to
   use and are thus not necessary to negotiate between compressor and
   decompressor.  Note: this does not preclude that implementation
   parameters may be signaled or negotiated using lower layer
   functionality in order to set the way a ROHC implementation operate.
   Some implementation parameters are valid only at either of compressor
   or decompressor. Implementation parameters may further be divided
   into parameters that describe the way an implementation operates and
   into parameters that trigger a specific event, i.e., signals.

6.3.1.  ROHC implementation parameters at compressor:

   CONTEXT_REFRESH -  signal
   This parameters triggers a complete refresh of the context at the
   decompressor, both static and dynamic part. The compressor MUST, when
   CONTEXT_REFRESH is triggered, fully refresh the context by sending
   IR/DYN headers until it is reasonably confident that the decompressor
   contexts are refreshed. The context refresh MUST be done for all
   contexts at the compressor. This parameter may for instance be used
   to do context relocation at e.g. a cellular handover that result in a
   change of compression point in the radio access network.

   NO_OF_HEADER_SIZES - values:  positive integer value
   This parameter should only be used when HEADER_SIZES_USED is used. In
   that case, this parameter mandates the number of header sizes a ROHC
   implementation can use. With this number is set, the ROHC
   implementation at the compressor MUST NOT use more different header
   sizes than the value of this parameter mandates. The ROHC
   implementation should be able to determine itself which header sizes
   to use. Note: one header size may be used for several header formats.

   HEADER_SIZES_USED - values: list of positive integer values
   This parameter should only be used when NO_OF_HEADER_SIZES is used.
   In that case, this parameter tells which header sizes in bytes that
   may be used by the ROHC implementation. The information about used
   header sizes in this parameter, may then be used to configure lower
   layers.

   For the two parameters above the following MUST apply:
   NO_OF_HEADER_SIZES must be equal to the number of list elements in
   HEADER_SIZES_USED





Bormann (ed.)                                                 [Page 114]

INTERNET-DRAFT          Robust Header Compression           Oct 11, 2000


6.3.2.  ROHC implementation parameters at decompressor:

   MODE - values: [U_mode, O_mode, R_mode]
   This parameter triggers a mode transition using the mechanism
   described in chapter 5 when the parameter changes value, i.e. to
   U_mode (Unidirectional mode), O_mode (bidirectional Optimistic mode)
   or R_mode (bidirectional Reliable mode). The mode transition is made
   from the current mode to the new mode as signaled in the
   implementation parameter. For example, if the current mode is
   bidirectional optimistic mode, MODE should have the value: O_mode. If
   the MODE is changed to R_mode, a mode transition MUST be made from
   bidirectional optimistic mode to bidirectional reliable mode. MODE
   should not only serve as a trigger for mode transitions, but also
   make it visible which mode ROHC operates in.

   TIMER_BASED_TS_COMPRESSION - values: [YES, NO]
   This parameter determines whether timer-based time stamp compression
   as described in chapter X.X should be used or not. It SHOULD be used
   when the parameter has the value YES, and it MUST NOT be used when
   the parameter has the value NO.

   REVERSE_DECOMPRESSION - values: [YES, NO]
   This parameter determines whether reverse decompression as described
   in chapter X.X should be used or not. It MUST be used when the
   parameter has the value YES, and it MUST NOT be used when the
   parameter has the value NO.

6.5.  Handling of resource limitations at the decompressor

   In a point to point link the two nodes can agree on the number of
   compressed sessions they are prepared to support for this link.  It
   may, however, not be possible for the decompressor to accurately
   predict when it will run out of resources.  ROHC allows the
   negotiated number of contexts to be larger than could be accommodated
   in the worst case.  Then, as context resources are consumed, an
   attempt to set up a new context may be rejected by the decompressor,
   using the REJECT option of the feedback payload.

   Upon reception of a REJECT option, the compressor SHOULD wait for a
   while before attempting to compress additional streams destined to
   the rejecting host.


7.  Security considerations

   Because encryption eliminates the redundancy that header compression
   schemes try to exploit, there is some inducement to forego encryption
   of headers in order to enable operation over low-bandwidth links.
   However, for those cases where encryption of data (and not headers)
   is sufficient, RTP does specify an alternative encryption method in




Bormann (ed.)                                                 [Page 115]

INTERNET-DRAFT          Robust Header Compression           Oct 11, 2000


   which only the RTP payload is encrypted and the headers are left in
   the clear. That would still allow header compression to be applied.

   ROHC compression is transparent with regards to the RTP sequence
   number and RTP timestamp fields, so the values of those fields can be
   trusted by payload encryption schemes.

   A malfunctioning or malicious header compressor could cause the
   header decompressor to reconstitute packets that do not match the
   original packets but still have valid IP, UDP and RTP headers and
   possibly also valid UDP checksums. Such corruption may be detected
   with end-to-end authentication and integrity mechanisms which will
   not be affected by the compression. Moreover, this header compression
   scheme uses an internal checksum for verification of re-constructed
   headers. This reduces the probability of producing decompressed
   headers not matching the original ones without this being noticed.

   Denial-of-service attacks are possible if an intruder can introduce
   (for example) bogus STATIC, DYNAMIC or FEEDBACK packets onto the link
   and thereby cause compression efficiency to be reduced. However, an
   intruder having the ability to inject arbitrary packets at the link
   layer in this manner raises additional security issues that dwarf
   those related to the use of header compression.


8.  Acknowledgements

   When designing this protocol, earlier header compression ideas
   described in [CJHC], [IPHC] and [CRTP] have been important sources of
   knowledge.

   Thanks to Takeshi Yoshimura at NTT DoCoMo for providing the reverse
   decompression section (6.1). Thanks also to Andreas Jonsson (Lulea
   University), who made a great job supporting this work in his study
   of header field change patterns. Thanks also to all others who have
   given comments.


















Bormann (ed.)                                                 [Page 116]

INTERNET-DRAFT          Robust Header Compression           Oct 11, 2000



8z.  Intellectual property considerations

   (Editor's note: this section will go to www.ietf.org/ipr and be
   replaced by the standard reference to that, but for now it is left in
   the draft to simplify working on it.)

   This proposal in is conformity with RFC 2026.

   Telefonaktiebolaget LM Ericsson and its subsidiaries, in accordance
   with corporate policy, will for submissions rightfully made by its
   employees which are adopted or recommended as a standard by the IETF
   offer patent licensing as follows:

   If part(s) of a submission by Ericsson employees is (are) included in
   a standard and Ericsson has patents and/or patent application(s) that
   are essential to implementation of such included part(s) in said
   standard, Ericsson is prepared to grant - on the basis of reciprocity
   (grant-back) - a license on such included part(s) on reasonable, non-
   discriminatory terms and conditions.

   For the avoidance of doubt this general patent licensing undertaking
   applies to this proposal.


   Nokia has filed patent applications that might possibly have
   technical relation to this contribution.


   Matsushita has filed patent applications that might possibly have
   technical relation to this contribution.
   If part(s) of the contribution by Matsushita employee is (are)
   included in a standard and Matsushita has patents and/or patent
   application(s) that are essential to implementation of such included
   part(s) in said standard, Matsushita is prepared to grant - on the
   basis of reciprocity (grantback) - a license on such included part(s)
   on reasonable, non-discriminatory terms and conditions (in according
   with paragraph 10.3.3 of the RFC 2026).


   NTT DoCoMo, Inc. also declares this text may relevant to their
   patent, and offer patent licensing as follows:

   If part(s) of this text provided by NTT DoCoMo employees is (are)
   included in a standard and NTT DoCoMo has patents and/or patent
   application(s) that are essential to implementation of such included
   part(s) in said standard, NTT DoCoMo is prepared to grant - on the
   basis of reciprocity (grant-back) - a license on such included
   part(s) on reasonable, non-discriminatory terms and conditions.





Bormann (ed.)                                                 [Page 117]

INTERNET-DRAFT          Robust Header Compression           Oct 11, 2000


9.  References

   [UDP]    Jon Postel, "User Datagram Protocol", RFC 768, August 1980.

   [IPv4]   Jon Postel, "Internet Protocol", RFC 791, September 1981.

   [IPv6]   Steven Deering, Robert Hinden, "Internet Protocol, Version 6
            (IPv6) Specification", RFC 2460, December 1998.

   [RTP]    Henning Schulzrinne, Stephen Casner, Ron Frederick, Van
            Jacobson, "RTP: A Transport Protocol for Real-Time
            Applications", RFC 1889, January 1996.

   [HDLC]   William Simpson, "PPP in HDLC-like framing", RFC 1662, 1994.

   [VJHC]   Van Jacobson, "Compressing TCP/IP Headers for Low-Speed
            Serial Links", RFC 1144, February 1990.

   [IPHC]   Mikael Degermark, Bjorn Nordgren, Stephen Pink, "IP Header
            Compression", RFC 2507, February 1999.

   [CRTP]   Steven Casner, Van Jacobson, "Compressing IP/UDP/RTP Headers
            for Low-Speed Serial Links", RFC 2508, February 1999.

   [PPPHC]  Mathias Engan, Steven Casner, Carsten Bormann, "IP Header
            Compression over PPP", RFC 2509, February 1999.

   [CRTPC]  M. Degermark, H. Hannu, L.E. Jonsson, K. Svanbro,
           "Evaluation of CRTP Performance over Cellular Radio
           Networks", IEEE Personal Communication Magazine, Volume 7,
           number 4, pp. 20-25, August 2000

   [REQ]   Mikael Degermark, "Requirements for robust IP/UDP/RTP header
           compression", Internet Draft (work in progress), June 2000.
           <draft-ietf-rohc-rtp-requirements-01.txt>

   [LLG]   Krister Svanbro, "Lower Layer Guidelines for Robust
           RTP/UDP/IP Header Compression", Internet Draft (work in
           progress), October 2000.
           <draft-ietf-rohc-rtp-lower-layer-guidelines-00.txt>

   [CELL]   Lars Westberg, Morgan Lindqvist, "Realtime traffic over
            cellular access networks", Internet Draft
           (work in progress), May 2000.
            <draft-westberg-realtime-cellular-02.txt>

10.  Authors' addresses

   Carsten Bormann               Tel: +49 421 218 7024
   Universitaet Bremen TZI       Fax: +49 421 218 7000
   Postfach 330440               EMail: cabo@tzi.org



Bormann (ed.)                                                 [Page 118]

INTERNET-DRAFT          Robust Header Compression           Oct 11, 2000


   D-28334 Bremen, GERMANY

   Carsten Burmeister            Tel.  +49-6103-766-263
   Rolf Hakenberg                Tel.  +49-6103-766-162
   Thomas Wiebke                 Tel.  +49-6103-766-161
   Panasonic European Laboratories GmbH   Fax.  +49-6103-766-166
   Monzastr. 4c                  Email: burmeister@panasonic.de
   63225 Langen, Germany         Email: hakenberg@panasonic.de
                                 Email: wiebke@panasonic.de

   Mikael Degermark              Tel: +1 520 621-3498
   The University of Arizona     Fax: +1 520 621-4642
   Dept of Computer Science      Email: micke@cs.arizona.edu
   P.O. Box 210077
   Tucson, AZ 85721-0077, USA

   Hideaki Fukushima             Email: fukusima@isl.mei.co.jp
   Akihiro Miyazaki              Email: akihiro@isl.mei.co.jp
   Matsushita Electric Industrial Co., Ltd    Tel.  +81-6-6900-9192
   1006, Kadoma, Kadoma City, Osaka, Japan    Fax.  +81-6-6900-9193

   Hans Hannu                    Tel: +46 920 20 21 84
   Lars-Erik Jonsson             Tel: +46 920 20 21 07
   Krister Svanbro               Tel: +46 920 20 20 77
   Box 920                       Fax: +46 920 20 20 99
   Ericsson Erisoft AB           EMail: lars-erik.jonsson@ericsson.com
   SE-971 28 Lulea, Sweden       Email: krister.svanbro@ericsson.com
                                 EMail: hans.hannu@ericsson.com

   Khiem Le                      Tel: +1-972-894-4882
   Zhigang Liu                   Tel: +1 972 894-5935
   Haihong Zheng                 Tel: +1 972 894-4232
   Nokia Research Center         Fax: +1 972 894-4589
   6000 Connection Drive         Email: khiem.le@nokia.com
   Irving, TX 75039, USA         Email: zhigang.liu@nokia.com
                                 Email: haihong.zheng@nokia.com

   Anton Martensson              Tel: +46 8 404 3881
   Ericsson Radio Systems AB     Fax: +46 8 757 5550
   Torshamnsgatan 23
   SE-164 80 Stockholm, Sweden   Email: anton.martensson@era.ericsson.se













Bormann (ed.)                                                 [Page 119]

INTERNET-DRAFT          Robust Header Compression           Oct 11, 2000


Appendix A.  Detailed classification of header fields

   Header compression is possible due to the fact that most header
   fields do not vary randomly from packet to packet. Many of the fields
   exhibit static behavior or changes in a more or less predictable way.
   When designing a header compression scheme, it is of fundamental
   importance to understand the behavior of the fields in detail.

   In this appendix, all IP, UDP and RTP header fields are classified
   and analyzed in two steps. First, we have a general classification in
   A.1 where the fields are classified based on stable knowledge and
   assumptions. The general classification does not take into account
   the change characteristics of changing fields because those will vary
   more or less depending on the implementation and on the application
   used. A less stable but more detailed analysis considering the change
   characteristics is then done in A.2. Finally, A.3 summarizes this
   appendix with conclusions about how the various header fields should
   be handled by the header compression scheme to optimize compression
   and functionality.

A.1.  General classification

   On a general level, the header fields are separated into 5 classes:

   INFERRED       These fields contain values that can be inferred from
                  other values, for example the size of the frame
                  carrying the packet, and thus does not have to be
                  handled at all by the compression scheme.

   STATIC         These fields are expected to be constant throughout
                  the lifetime of the packet stream. Static information
                  must in some way be communicated once.

   STATIC-DEF     STATIC fields whose values define a packet stream.
                  They are in general handled as STATIC.

   STATIC-KNOWN   These STATIC fields are expected to have well-known
                  values and therefore do not need to be communicated
                  at all.

   CHANGING       These fields are expected to vary in some way, either
                  randomly, within a limited value set or range, or in
                  some other manner.


   In this section, each of the IP, UDP and RTP header fields is
   assigned to one of these classes. For all fields except those
   classified as CHANGING, the motives for the classification are also
   stated. CHANGING fields are in A.2 further examined and classified
   based on their expected change behavior.




Bormann (ed.)                                                 [Page 120]

INTERNET-DRAFT          Robust Header Compression           Oct 11, 2000


A.1.1.  IPv6 header fields

    +---------------------+-------------+----------------+
    | Field               | Size (bits) |    Class       |
    +---------------------+-------------+----------------+
    | Version             |      4      |  STATIC-KNOWN  |
    | Traffic Class       |      8      |    CHANGING    |
    | Flow Label          |     20      |   STATIC-DEF   |
    | Payload Length      |     16      |    INFERRED    |
    | Next Header         |      8      |  STATIC-KNOWN  |
    | Hop Limit           |      8      |    CHANGING    |
    | Source Address      |    128      |   STATIC-DEF   |
    | Destination Address |    128      |   STATIC-DEF   |
    +---------------------+-------------+----------------+


   Version

     The version field states which IP version the packet is based on.
     Packets with different values in this field must be handled by
     different IP stacks. For header compression, different compression
     profiles must also be used. When compressor and decompressor have
     negotiated which profile to use, the IP version is also known to
     both parties. The field is therefore classified as STATIC-KNOWN.


   Flow Label

     This field may be used to identify packets belonging to a specific
     packet stream. If not used, the value should be set to zero.
     Otherwise, all packets belonging to the same stream must have the
     same value in this field, it being one of the fields defining the
     stream. The field is therefore classified as STATIC-DEF.


   Payload Length

     Information about the packet length (and then also payload length)
     is expected to be provided by the link layer. The field is
     therefore classified as INFERRED.


   Next Header

     This field is expected to have the same value in all packets of a
     packet stream. As for the version number, a certain compression
     profile can only handle a specific next header which means that
     this value is known when profile has been negotiated. The field is
     therefore classified as STATIC-KNOWN.





Bormann (ed.)                                                 [Page 121]

INTERNET-DRAFT          Robust Header Compression           Oct 11, 2000


   Source and Destination addresses

     These fields are part of the definition of a stream and must thus
     be constant for all packets in the stream. The fields are therefore
     classified as STATIC-DEF.


   Summarizing the bits corresponding to the classes gives:

    +--------------+--------------+
    | Class        | Size (octets)|
    +--------------+--------------+
    | INFERRED     |       2      |
    | STATIC-DEF   |     34.5     |
    | STATIC-KNOWN |      1.5     |
    | CHANGING     |       2      |
    +--------------+--------------+


A.1.2.  IPv4 header fields

    +---------------------+-------------+----------------+
    | Field               | Size (bits) |     Class      |
    +---------------------+-------------+----------------+
    | Version             |      4      |  STATIC-KNOWN  |
    | Header Length       |      4      |  STATIC-KNOWN  |
    | Type Of Service     |      8      |    CHANGING    |
    | Packet Length       |     16      |    INFERRED    |
    | Identification      |     16      |    CHANGING    |
    | Reserved flag       |      1      |  STATIC-KNOWN  |
    | May Fragment flag   |      1      |     STATIC     |
    | Last Fragment flag  |      1      |  STATIC-KNOWN  |
    | Fragment Offset     |     13      |  STATIC-KNOWN  |
    | Time To Live        |      8      |    CHANGING    |
    | Protocol            |      8      |  STATIC-KNOWN  |
    | Header Checksum     |     16      |    INFERRED    |
    | Source Address      |     32      |   STATIC-DEF   |
    | Destination Address |     32      |   STATIC-DEF   |
    +---------------------+-------------+----------------+


   Version

     The version field states which IP version the packet is based on
     and packets with different values in this field must be handled by
     different IP stacks. For header compression, different compression
     profiles must also be used. When compressor and decompressor has
     negotiated which profile to use, the IP version is also well known
     to both parties. The field is therefore classified as STATIC-KNOWN.





Bormann (ed.)                                                 [Page 122]

INTERNET-DRAFT          Robust Header Compression           Oct 11, 2000


   Header Length

     As long as there are no options present in the IP header, the
     header length is constant and well known. If there are options, the
     fields would be STATIC, but we assume no options. The field is
     therefore classified as STATIC-KNOWN.


   Packet Length

     Information about the packet length is expected to be provided by
     the link layer. The field is therefore classified as INFERRED.


   Flags

     The Reserved flag must be set to zero and is therefore classified
     as STATIC-KNOWN. The May Fragment flag will be constant for all
     packets in a stream and is therefore classified as STATIC. Finally,
     the Last Fragment bit is expected to be zero because fragmentation
     is NOT expected, due to the small packet size expected. The Last
     Fragment bit is therefore classified as STATIC-KNOWN.


   Fragment Offset

     With the assumption that no fragmentation occurs, the fragment
     offset is always zero. The field is therefore classified as STATIC-
     KNOWN.


   Protocol

     This field is expected to have the same value in all packets of a
     packet stream. As for the version number, a certain compression
     profile can only handle a specific next header which means that
     this value is well known when profile has been negotiated. The
     field is therefore classified as STATIC-KNOWN.


   Header Checksum

     The header checksum protects individual hops from processing a
     corrupted header. When almost all IP header information is
     compressed away, there is no need to have this additional checksum;
     instead it can be regenerate at the decompressor side. The field is
     therefore classified as INFERRED.


   Source and Destination addresses




Bormann (ed.)                                                 [Page 123]

INTERNET-DRAFT          Robust Header Compression           Oct 11, 2000


     These fields are part of the definition of a stream and must thus
     be constant for all packets in the stream. The fields are therefore
     classified as STATIC-DEF.


   Summarizing the bits corresponding to the classes gives:

    +--------------+--------------+
    | Class        | Size (octets)|
    +--------------+--------------+
    | INFERRED     |      4       |
    | STATIC       |    1 bit     |
    | STATIC-DEF   |      8       |
    | STATIC-KNOWN |   3 +7 bits  |
    | CHANGING     |      4       |
    +--------------+--------------+


A.1.3.  UDP header fields

    +------------------+-------------+-------------+
    | Field            | Size (bits) |    Class    |
    +------------------+-------------+-------------+
    | Source Port      |     16      | STATIC-DEF  |
    | Destination Port |     16      | STATIC-DEF  |
    | Length           |     16      |  INFERRED   |
    | Checksum         |     16      |  CHANGING   |
    +------------------+-------------+-------------+


   Source and Destination ports

     These fields are part of the definition of a stream and must thus
     be constant for all packets in the stream. The fields are therefore
     classified as STATIC-DEF.


   Length

     This field is redundant and is therefore classified as INFERRED.


   Summarizing the bits corresponding to the classes gives:

    +------------+--------------+
    | Class      | Size (octets)|
    +------------+--------------+
    | INFERRED   |       2      |
    | STATIC-DEF |       4      |
    | CHANGING   |       2      |
    +------------+--------------+



Bormann (ed.)                                                 [Page 124]

INTERNET-DRAFT          Robust Header Compression           Oct 11, 2000




A.1.4.  RTP header fields

    +-----------------+-------------+----------------+
    | Field           | Size (bits) |     Class      |
    +-----------------+-------------+----------------+
    | Version         |      2      |  STATIC-KNOWN  |
    | Padding         |      1      |     STATIC     |
    | Extension       |      1      |     STATIC     |
    | CSRC Counter    |      4      |    CHANGING    |
    | Marker          |      1      |    CHANGING    |
    | Payload Type    |      7      |    CHANGING    |
    | Sequence Number |     16      |    CHANGING    |
    | Timestamp       |     32      |    CHANGING    |
    | SSRC            |     32      |   STATIC-DEF   |
    | CSRC            |   0(-480)   |    CHANGING    |
    +-----------------+-------------+----------------+


   Version

     There exists only one working RTP version and that is version 2.
     The field is therefore classified as STATIC-KNOWN.


   Padding

     The use of this field depends on the application, but when payload
     padding is used it is likely to be present in all packets. The
     field is therefore classified as STATIC.


   Extension

     If RTP extensions is used by the application, it is likely to be an
     extension present in all packets (but use of extensions is very
     uncommon). However, for safety's sake this field is classified as
     STATIC and not STATIC-KNOWN.


   SSRC

     This field is part of the definition of a stream and must thus be
     constant for all packets in the stream. The field is therefore
     classified as STATIC-DEF.








Bormann (ed.)                                                 [Page 125]

INTERNET-DRAFT          Robust Header Compression           Oct 11, 2000




   Summarizing the bits corresponding to the classes gives:

    +--------------+--------------+
    | Class        | Size (octets)|
    +--------------+--------------+
    | STATIC       |    2 bits    |
    | STATIC-DEF   |      4       |
    | STATIC-KNOWN |    2 bits    |
    | CHANGING     |  7.5(-67.5)  |
    +--------------+--------------+


A.1.5.  Summary for IP/UDP/RTP

   If we summarize this for IP/UDP/RTP we get:

    +----------------+--------------+--------------+
    | Class \ IP ver | IPv6 (octets)| IPv4 (octets)|
    +----------------+--------------+--------------+
    | INFERRED       |       4      |       6      |
    | STATIC         |    2 bits    |    3 bits    |
    | STATIC-DEF     |     42.5     |      16      |
    | STATIC-KNOWN   |   1 +6 bits  |   4 +1 bit   |
    | CHANGING       |  11.5(-71.5) |  13.5(-73.5) |
    +----------------+--------------+--------------+
    | Total          |   60(-120)   |   40(-100)   |
    +----------------+--------------+--------------+


A.2.  Analysis of change patterns of header fields

   To design suitable mechanisms for efficient compression of all header
   fields, their change patterns must be analyzed. For this reason, an
   extended classification is done based on the general classification
   in A.1, considering the fields which were labeled CHANGING in that
   classification. Different applications will use the fields in
   different ways, which may affect their behavior. When this is the
   case, typical behavior for conversational audio and video will be
   discussed.

   The CHANGING fields are separated into five different subclasses:

   STATIC                These are fields that were classified as
                         CHANGING on a general basis, but are classified
                         as STATIC here due to certain additional
                         assumptions.

   SEMISTATIC            These fields are STATIC most of the time.
                         However, occasionally the value changes but



Bormann (ed.)                                                 [Page 126]

INTERNET-DRAFT          Robust Header Compression           Oct 11, 2000


                         reverts to its original value after a known
                         number of packets.

   RARELY-CHANGING (RC)  These are fields that change their values
                         occasionally and then keep their new values.

   ALTERNATING           These fields alternate between a small number
                         of different values.

   IRREGULAR             These, finally, are the fields for which no
                         useful change pattern can be identified.

   To further expand the classification possibilities without increasing
   complexity, the classification can be done either according to the
   values of the field and/or according to the values of the deltas for
   the field.

   When the classification is done, other details are also stated
   regarding possible additional knowledge about the field values and/or
   field deltas, according to the classification. For fields classified
   as STATIC or SEMISTATIC, the case could be that the value of the
   field is not only STATIC but also well KNOWN a priori (two states for
   SEMISTATIC fields). For fields with non-irregular change behavior, it
   could be known that changes usually are within a LIMITED range
   compared to the maximal change for the field. For other fields, the
   values are completely UNKNOWN.

   Table A.1 classifies all the CHANGING fields based on their expected
   change patterns, especially for conversational audio and video.



    +------------------------+-------------+-------------+-------------+
    |         Field          | Value/Delta |    Class    |  Knowledge  |
    +========================+=============+=============+=============+
    |             Sequential |    Delta    |    STATIC   |    KNOWN    |
    |             -----------+-------------+-------------+-------------+
    | IPv4 Id:    Seq. jump  |    Delta    |      RC     |   LIMITED   |
    |             -----------+-------------+-------------+-------------+
    |             Random     |    Value    |  IRREGULAR  |   UNKNOWN   |
    +------------------------+-------------+-------------+-------------+
    | IP TOS / Tr. Class     |    Value    |      RC     |   UNKNOWN   |
    +------------------------+-------------+-------------+-------------+
    | IP TTL / Hop Limit     |    Value    | ALTERNATING |   LIMITED   |
    +------------------------+-------------+-------------+-------------+
    |               Disabled |    Value    |    STATIC   |    KNOWN    |
    | UDP Checksum: ---------+-------------+-------------+-------------+
    |               Enabled  |    Value    |  IRREGULAR  |   UNKNOWN   |
    +------------------------+-------------+-------------+-------------+
    |                 No mix |    Value    |    STATIC   |    KNOWN    |
    | RTP CSRC Count: -------+-------------+-------------+-------------+



Bormann (ed.)                                                 [Page 127]

INTERNET-DRAFT          Robust Header Compression           Oct 11, 2000


    |                 Mixed  |    Value    |      RC     |   LIMITED   |
    +------------------------+-------------+-------------+-------------+
    | RTP Marker             |    Value    |  SEMISTATIC | KNOWN/KNOWN |
    +------------------------+-------------+-------------+-------------+
    | RTP Payload Type       |    Value    |      RC     |   UNKNOWN   |
    +------------------------+-------------+-------------+-------------+
    | RTP Sequence Number    |    Delta    |    STATIC   |    KNOWN    |
    +------------------------+-------------+-------------+-------------+
    | RTP Timestamp          |    Delta    |      RC     |   LIMITED   |
    +------------------------+-------------+-------------+-------------+
    |                 No mix |      -      |      -      |      -      |
    | RTP CSRC List:  -------+-------------+-------------+-------------+
    |                 Mixed  |    Value    |      RC     |   UNKNOWN   |
    +------------------------+-------------+-------------+-------------+

           Table A.1 : Classification of CHANGING header fields

   The following subsections discuss the various header fields in
   detail. Note that table A.1 and the discussions below do not consider
   changes caused by loss or reordering before the compression point.


A.2.1.  IPv4 Identification

   The Identification field (IP ID) of the IPv4 header is there to
   identify which fragments constitute a datagram when reassembling
   fragmented datagrams. The IPv4 specification does not specify exactly
   how this field is to be assigned values, only that each packet should
   get an IP ID that is unique for the source-destination pair and
   protocol for the time the datagram (or any of its fragments) could be
   alive in the network. This means that assignment of IP ID values can
   be done in various ways, which we have separated into three classes.

   Sequential

      This assignment policy keeps a separate counter for each outgoing
      packet stream and thus the IP ID value will increment by one for
      each packet in the stream. Therefore, the delta value of the
      field is constant and well known a priori. When RTP is used on
      top of UDP and IP, the IP ID value follows the RTP sequence
      number. This assignment policy is the most desirable for header
      compression purposes but its usage is not as common as it should
      be. The reason is that it can be realized only if UDP and IP are
      implemented together so that UDP, which separates packet streams
      by the port identification, can make IP use separate ID counters
      for each packet stream.

   Sequential jump

      This is the most common assignment policy in today's IP stacks.
      The difference from the sequential method is that only one



Bormann (ed.)                                                 [Page 128]

INTERNET-DRAFT          Robust Header Compression           Oct 11, 2000


      counter is used for all connections. When the sender is running
      more than one packet stream simultaneously, the IP ID can
      increase by more than one. The IP ID values will be much more
      predictable and require less bits to transfer than random values,
      and the packet-to-packet increment (determined by the number of
      active outgoing packet streams and sending frequencies) will
      usually be limited.

   Random

      Some IP stacks assign IP ID values using a pseudo-random number
      generator. There is thus no correlation between the ID values of
      subsequent datagrams. Therefore there is no way to predict the IP
      ID value for the next datagram. For header compression purposes,
      this means that the IP ID field needs to be sent uncompressed
      with each datagram, resulting in two extra octets of header. IP
      stacks in cellular terminals SHOULD NOT use this IP ID assignment
      policy.

   It should be noted that the ID is an IPv4 mechanism and is therefore
   not needed at all in IPv6 profiles. For IPv4 the ID could be handled
   in three different ways. Firstly, we have the inefficient but
   reliable solution where the ID field is sent as-is in all packets,
   increasing the compressed headers with two octets. This is the best
   way to handle the ID field if the sender uses random assignment of
   the ID field. Secondly, there can be solutions with more flexible
   mechanisms requiring less bits for the ID handling as long as
   sequential jump assignment is used. Such solutions will probably
   require even more bits if random assignment is used by the sender.
   Knowledge about the sender's assignment policy could therefore be
   useful when choosing between the two solutions above. Finally, even
   for IPv4, header compression could be designed without any additional
   information for the ID field included in compressed headers. To use
   such schemes, it must be known that the sender makes use of the pure
   sequential assignment policy for the ID field. That might not be
   possible to know, which implies that the applicability of such
   solutions is very uncertain. However, designers of IPv4 stacks for
   cellular terminals SHOULD use the sequential policy.


A.2.2.  IP Traffic-Class / Type-Of-Service

   The Traffic-Class (IPv6) or Type-Of-Service (IPv4) field is expected
   to be constant during the lifetime of a packet stream or to change
   relatively seldom.









Bormann (ed.)                                                 [Page 129]

INTERNET-DRAFT          Robust Header Compression           Oct 11, 2000


A.2.3.  IP Hop-Limit / Time-To-Live

   The Hop-Limit (IPv6) or Time-To-Live (IPv4) field is expected to be
   constant during the lifetime of a packet stream or to alternate
   between a limited number of values due to route changes.


A.2.4.  UDP Checksum

   The UDP checksum is optional. If disabled, its value is constantly
   zero and could be compressed away. If enabled, its value depends on
   the payload, which for compression purposes is equivalent to it
   changing randomly with every packet.


A.2.5.  RTP CSRC Counter

   This is a counter indicating the number of CSRC items present in the
   CSRC list. This number is expected to be almost constant on a packet-
   to-packet basis and change by small amount. As long as no RTP mixer
   is used, the value of this field is zero.

A.2.6.  RTP Marker

   For audio the marker bit should be set only in the first packet of a
   talkspurt while for video it should be set in the last packet of
   every picture. This means that in both cases the RTP marker is
   classified as SEMISTATIC with well-known values for both states.


A.2.7.  RTP Payload Type

   Changes of the RTP payload type within a packet stream are expected
   to be rare. Applications could adapt to congestion by changing
   payload type and/or frame sizes, but that is not expected to happen
   frequently.


A.2.8.  RTP Sequence Number

   The RTP sequence number will be incremented by one for each packet
   sent.


A.2.9.  RTP Timestamp

   In the audio case:

      As long as there are no pauses in the audio stream, the RTP
      timestamp will be incremented by a constant delta, corresponding
      to the number of samples in the speech frame. It will thus mostly



Bormann (ed.)                                                 [Page 130]

INTERNET-DRAFT          Robust Header Compression           Oct 11, 2000


      follow the RTP sequence number. When there has been a silent
      period and a new talkspurt begins, the timestamp will jump in
      proportion to the length of the silent period. However, the
      increment will probably be within a relatively limited range.

   In the video case:

      The timestamp change between two consecutive packets will either
      be zero or increase by a multiple of a fixed value corresponding
      to the picture clock frequency. The timestamp can also decrease
      by a multiple of the fixed value if B-pictures are used. The
      delta interval, expressed as a multiple of the picture clock
      frequency, is in most cases very limited.


A.2.10.  RTP Contributing Sources (CSRC)

   The participants in a session, which are identified by the CSRC
   fields, are expected to be almost the same on a packet-to-packet
   basis with relatively few additions or removals. As long as RTP
   mixers are not used, no CSRC fields are present at all.

A.3.  Header compression strategies

   This section elaborates on what has been done in previous sections.
   Based in the classifications, recommendations are given on how to
   handle the various fields in the header compression process. Seven
   different actions are possible and these are listed together with the
   fields to which each action applies.


A.3.1.  Do not send at all

   The fields that have well known values a priori do not have to be
   sent at all. These are:

   - IP Version
   - IPv6 Payload Length
   - IPv6 Next Header
   - IPv4 Header Length
   - IPv4 Reserved Flag
   - IPv4 Last Fragment Flag
   - IPv4 Fragment Offset
   - IPv4 Protocol
   - UDP Checksum (if disabled)
   - RTP Version








Bormann (ed.)                                                 [Page 131]

INTERNET-DRAFT          Robust Header Compression           Oct 11, 2000


A.3.2.  Transmit only initially

   The fields that are constant throughout the lifetime of the packet
   stream have to be transmitted and correctly delivered to the
   decompressor only once. These are:

   - IP Source Address
   - IP Destination Address
   - IPv6 Flow Label
   - IPv4 May Fragment Flag
   - UDP Source Port
   - UDP Destination Port
   - RTP Padding Flag
   - RTP Extension Flag
   - RTP SSRC


A.3.3.  Transmit initially, but be prepared to update

   The fields that are changing only occasionally must be transmitted
   initially but there must also be a way to update these fields with
   new values if they change. These fields are:

   - IPv6 Traffic Class
   - IPv6 Hop Limit
   - IPv4 Type Of Service (TOS)
   - IPv4 Time To Live (TTL)
   - RTP CSRC Counter
   - RTP Payload Type
   - RTP CSRC List


A.3.4.  Be prepared to update or send as-is frequently

   For fields that normally are either constant or whose values can be
   deduced from some other field but frequently diverge from that
   behavior, there must be an efficient way to update the field value or
   send it as-is in some packets. Those fields are:

   - IPv4 Identification (if not sequentially assigned)
   - RTP Marker
   - RTP Timestamp


A.3.5.  Guarantee continuous robustness

   Fields that behave like a counter with a fixed delta for ALL packets,
   the only requirement on the transmission encoding is that packet
   losses between compressor and decompressor must be tolerable. If more
   than one such field exists, all these can be communicated together.
   Such fields can also be used to interpret the values for fields



Bormann (ed.)                                                 [Page 132]

INTERNET-DRAFT          Robust Header Compression           Oct 11, 2000


   listed in the previous section. Fields that have this counter
   behavior are:

   - IPv4 Identification (if sequentially assigned)
   - RTP Sequence Number


A.3.6.  Transmit as-is in all packets

   Fields that have completely random values for each packet must be
   included as-is in all compressed headers. Those fields are:

   - IPv4 Identification (if randomly assigned)
   - UDP Checksum (if enabled)


A.3.7.  Establish and be prepared to update delta

   Finally, there is a field that is usually increasing by a fixed delta
   and is correlated to another field. For this field it would make
   sense to make that delta part of the context state. The delta must
   then be possible to initiate and update in the same way as the fields
   listed in A.3.3. The field to which this applies is:

   - RTP Timestamp





























Bormann (ed.)                                                 [Page 133]

INTERNET-DRAFT          Robust Header Compression           Oct 11, 2000



Appendix B.  Encoding Examples

   [[Editor's note: Not quite finished updating this with current
   terminology.]]

B.1.  Basic W-LSB

   The examples below illustrate the operation of window-based LSB-
   coding under various scenarios.  The field values used in the
   examples could correspond to any fields that we wish to compress.
   The examples illustrate the scenario where the compressed field has
   resolution of one bit.

      Example 1: Normal operation (no packet loss prior to compressor,
   no reodering prior to compressor).

   Suppose packets with header fields 279, 280, 281, 282, and 283 have
   been sent, and 279 and 283 are fields of potential reference packets.

   The current window is {279, 283}.  When a packet with field value 284
   is received next, W-LSB computes the following values:

      New Value   VMax    VMin             r                   # LSBs
         284      283     279    max[|284-279|,|284-283|]=5       4

   The window is unmodified if we assuming the new packet {284} is not a
   potential reference.  The field is encoded using 4 bits in this case,
   and the actual encoded value is the 4 least significant bits of 284
   (10011100) which = 1100.

      Example 2:  Packet Loss prior to compressor.

   Suppose packets with header fields 279, 280, 281, 282, and 283 have
   been sent, and 279 and 283 are fields of potential reference packets
   such that the VSW is again {279, 283}.

   If a packet with field value = 290 is received next, W-LSB computes
   the following values

      New Value  VMax  VMin             r                # LSBs
        290      283   279   max[|290-283|,|290-279|]=11    5

   So the field is encoded using 5 bits.  Actual encoded value is the 5
   LSBs of 290 (100100010) which = 00010.

   If we assume the new value is a potential reference, the new window
   is {279, 283, 290}.

      Example 3:  Packet Misordering prior to compressor.




Bormann (ed.)                                                 [Page 134]

INTERNET-DRAFT          Robust Header Compression           Oct 11, 2000


   Suppose packets with header fields 279, 280, 281, 282, and 283 have
   been sent, and 279 and 283 are fields of potential reference packets
   such that the window is again {279, 283}.

   If a packet with field value = 278 is received next, W-LSB computes
   the following values

      New Value     VMax    VMin             r                  # LSBs
        278         283     279   max[|278-283|,|278-279|]=5      4

   So the field is encoded using 4 bits.  Actual encoded value is the 4
   LSBs of 278 (10010110) which = 0110.

   If we assume the new value is a potential reference, the new window
   is {283, 290, 278}.

   The decompressor behavior in all the example cases is the same- it
   uses as a reference a specific decompressed header field value. For
   example let's assume that the last correctly decompressed packet
   which qualifies as a reference was the packet with header field =
   291.  Now suppose the encoded field value of 303 (10001111) is
   received and = 01111.  The two values closest values to 291 which
   have LSBs = 01111 are 271 and 303.  303 is closest, therefore it is
   correctly selected as the uncompressed field value.

B.2.  Timer-Based Compression

   As a an example of timer-based compression, consider the case of a
   voice codec (20 ms), such that TS_stride = 160.  Assume T_current and
   p_TS_current are 357 and 351, respectively, and that we have sliding
   window TSW which contains the following values 4 entries:

           j           T_j         p_TS_j

           1            9            7
           2            8            6
           3            7            4
           4            3            1

      j above is the packet number.

      In this case we have

      Network_jitter(1)=|(357-9)-(351-7)|=4 (80 ms Network Jitter)
      Network_jitter(2)=|(357-8)-(351-6)|=4  (80 ms Network Jitter)
      Network_jitter(3)=|(357-7)-(351-4)|=3 (60 ms Network Jitter)
      Network_jitter(4)=|(357-3)-(351-1)|=4  (80 ms Network Jitter)

      So Max_Network_Jitter = 4.





Bormann (ed.)                                                 [Page 135]

INTERNET-DRAFT          Robust Header Compression           Oct 11, 2000


      We assume a maximum CD-CC jitter of 2 (40 ms); the total jitter to
   be handled in this case is then

           J = 4 + 2 + 2 = 8 packets (160 ms)

      and k = 5 bits (since 2 * 5 + 1 < 2^5).  The compressor sends the
   5 LSBs of p_TS_current to the decompressor (351 = 101011111, so the
   encoded TS value = 11111).

      When the decompressor receives this value, it first attempts to
   estimate the timestamp by computing the time difference between the
   last reference established and the current packet

            T_current - T_ref, where T_ref is the value of the wall
   clock time at which the reference headers was received by the
   decompressor


      That value is added to p_TS_ref, the packed RTP TS of the
   reference header, to get the estimate.

      Assume that at the decompressor packet #3 is used as the
   reference:


           - T_current = 359
           - T_ref = 7
           - p_TS_ref = 4

      Note:

      T_current is picked here as any value; the difference between it
   and T_ref represents the length of the silence interval as observed
   at the decompressor.  Then:

           T_current - T_ref = 359 - 7 = 352
           p_TS_current(estimate) = 352 + 4 = 356


      The decompressor searches for the closest value to 356 which has,
   in this case, LSBs = 11111.  The value in this case is 351, the
   original p_TS.


      If instead the compressor were to send the timestamp jump as
   simply the difference in consecutive packed RTP Timestamps, that
   value would be

      p_TS_current - p_TS_ref = 351-4 = 347 = 101011011

      So over twice as many bits would be sent for a silence interval of



Bormann (ed.)                                                 [Page 136]

INTERNET-DRAFT          Robust Header Compression           Oct 11, 2000



           347 (20 ms) = 6.94 seconds

      Due to basic conversational real-time requirements, the cumulative
   jitter in normal operation is expected to be at most only a few times
   T stride for voice.  For this reason, the FO payload formats in
   section 4.3 are optimized (in terms of representing different k-
   length encoded TS values) for the case of k=4 (handles up to 16
   discrepencies in the timestamp).  The remaining formats allow a wide
   range of jitter conditions (outside of just voice) to be handled as
   well.







































   This Internet-Draft expires April 10, 2001.



