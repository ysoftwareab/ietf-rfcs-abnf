D_ITER = 0x00 in the iterations of the LM-OTS algorithms

D_PBLC = 0x01 when computing the hash of all of the iterates in
D_MESG = 0x02 when computing the hash of the message in the LM-
D_LEAF = 0x03 when computing the hash of the leaf of an LMS
D_INTR = 0x04 when computing the hash of an interior node of an
D_I = 0x05 when computing the I value for a nonroot LM tree in
D_PRG = 0x06 in the recommended pseudorandom process for
tmp = x[i]
tmp = H(S || tmp || u16str(i) || u8str(j) || D_ITER)
K = H(S || y[0] || ... || y[p-1] || D_PBLC)

sum = 0
sum = sum + (2^w - 1) - coef(S, i, w)
Q = H(S || C || message || D_MESG )
a = coef(Q || Cksm(Q), i, w)
tmp = x[i]
tmp = H(S || tmp || u16str(i) || u8str(j) || D_ITER)
Q = H(S || C || message || D_MESG)
a = coef(Q || Cksm(Q), i, w)
tmp = y[i]
tmp = H(S || tmp || u16str(i) || u8str(j) || D_ITER)
Kc = H(S || z[0] || z[1] || ... || z[p-1] || D_PBLC)

S = I || q
tmp = H(I || Kc || u32str(node_num) || D_LEAF)
i = 0
node_num = 2^h + q
tmp = H(I || path[i] || tmp || u32str(node_num/2) || D_INTR)
tmp = H(I || tmp || path[i] || u32str(node_num/2) || D_INTR)
node_num = node_num/2
i = i + 1

key = pub
sig = siglist[i]
msg = publist[i]
key = msg
ots_reserved         = 0,
lmots_sha256_n32_w1  = 1,
lmots_sha256_n32_w2  = 2,
lmots_sha256_n32_w4  = 3,
lmots_sha256_n32_w8  = 4
hbs_reserved       = 0,
lms_sha256_n32_h20 = 1,
lms_sha256_n32_h10 = 2,
lms_sha256_n32_h5  = 3,
n=16, the LM-OTS iterates a 55-byte value (that is, the string that
c = Cksm(H(message)) (see Section 4.7).  To attempt a forgery, an
a = coef(h, j, w), and

b = coef(c, k, w), and

u = ceil(8*n/w)
v = ceil((floor(lg((2^w - 1) * u)) + 1) / w)
ls = (number of bits in sum) - (v * w)
p = u + v

level = 0;
r = node_num
siblings = ""
siblings = (pop(data stack) || siblings)
level = pop(integer stack)
r = node_num
public_key = pop(data stack)

