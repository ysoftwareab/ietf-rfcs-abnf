z  =  (x + y) mod 2^32.

H0 = 67452301

H1 = EFCDAB89

H2 = 98BADCFE

H3 = 10325476

H4 = C3D2E1F0.

TEMP = S^5(A) + f(t;B,C,D) + E + W(t) + K(t);

E = D;  D = C;  C = S^30(B);  B = A; A = TEMP;

MASK = 0000000F.  Then processing of M(i) is as follows:

      a. Divide M(i) into 16 words W[0], ... , W[15], where W[0] is the
         left-most word.

      b. Let A = H0, B = H1, C = H2, D = H3, E = H4.

      c. For t = 0 to 79 do

s = t AND MASK;

TEMP = S^5(A) + f(t;B,C,D) + E + W[s] + K(t);

E = D; D = C; C = S^30(B); B = A; A = TEMP;

shaSuccess = 0,
A = context->Intermediate_Hash[0];
B = context->Intermediate_Hash[1];
C = context->Intermediate_Hash[2];
D = context->Intermediate_Hash[3];
E = context->Intermediate_Hash[4];

temp =  SHA1CircularShift(5,A) +
                ((B & C) | ((~B) & D)) + E + W[t] + K[0];
E = D;
D = C;
C = SHA1CircularShift(30,B);

B = A;
A = temp;
temp = SHA1CircularShift(5,A) + (B ^ C ^ D) + E + W[t] + K[1];
E = D;
D = C;
C = SHA1CircularShift(30,B);
B = A;
A = temp;
temp = SHA1CircularShift(5,A) +
               ((B & C) | (B & D) | (C & D)) + E + W[t] + K[2];
E = D;
D = C;
C = SHA1CircularShift(30,B);
B = A;
A = temp;
temp = SHA1CircularShift(5,A) + (B ^ C ^ D) + E + W[t] + K[3];
E = D;
D = C;
C = SHA1CircularShift(30,B);
B = A;
A = temp;
err = SHA1Reset(&sha);
err = SHA1Input(&sha,
                  (const unsigned char *) testarray[j],
                  strlen(testarray[j]));
err = SHA1Result(&sha, Message_Digest);
err = SHA1Input(&sha,(const unsigned char *) testarray[1], 1);
err = SHA1Reset(0);
