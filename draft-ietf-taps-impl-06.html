<!DOCTYPE html>
<html lang="en" class="Internet-Draft">
<head>
<meta charset="utf-8">
<meta content="Common,Latin" name="scripts">
<meta content="initial-scale=1.0" name="viewport">
<title>Implementing Interfaces to Transport Services</title>
<meta content="Anna Brunstrom" name="author">
<meta content="Tommy Pauly" name="author">
<meta content="Theresa Enghardt" name="author">
<meta content="Karl-Johan Grinnemo" name="author">
<meta content="Tom Jones" name="author">
<meta content="Philipp S. Tiesel" name="author">
<meta content="Colin Perkins" name="author">
<meta content="Michael Welzl" name="author">
<meta content="
       The Transport Services architecture   defines a system that allows applications to use transport networking protocols flexibly. This document serves as a guide to implementation on how to build such a system. 
    " name="description">
<meta content="xml2rfc 2.40.1" name="generator">
<meta content="Internet-Draft" name="keyword">
<meta content="draft-ietf-taps-impl-06" name="ietf.draft">
<link href="/tmp/draft-ietf-taps-impl-06-0y3q96cb.xml" rel="alternate" type="application/rfc+xml">
<link href="#copyright" rel="license">
<style type="text/css">/*

  NOTE: Changes at the bottom of this file overrides some earlier settings.

  Once the style has stabilized and has been adopted as an official RFC style,
  this can be consolidated so that style settings occur only in one place, but
  for now the contents of this file consists first of the initial CSS work as
  provided to the RFC Formatter (xml2rfc) work, followed by itemized and
  commented changes found necssary during the development of the v3
  formatters.

*/

/* fonts */
@import url('https://fonts.googleapis.com/css?family=Noto+Sans'); /* Sans-serif */
@import url('https://fonts.googleapis.com/css?family=Noto+Serif'); /* Serif (print) */
@import url('https://fonts.googleapis.com/css?family=Roboto+Mono'); /* Monospace */

@viewport {
  zoom: 1.0;
  width: extend-to-zoom;
}
@-ms-viewport {
  width: extend-to-zoom;
  zoom: 1.0;
}
/* general and mobile first */
html {
}
body {
  max-width: 90%;
  margin: 1.5em auto;
  color: #222;
  background-color: #fff;
  font-size: 14px;
  font-family: 'Noto Sans', Arial, Helvetica, sans-serif;
  line-height: 1.6;
  scroll-behavior: smooth;
}
.ears {
  display: none;
}

/* headings */
#title, h1, h2, h3, h4, h5, h6 {
  margin: 1em 0 0.5em;
  font-weight: bold;
  line-height: 1.3;
}
#title {
  clear: both;
  border-bottom: 1px solid #ddd;
  margin: 0 0 0.5em 0;
  padding: 1em 0 0.5em;
}
.author {
  padding-bottom: 4px;
}
h1 {
  font-size: 26px;
  margin: 1em 0;
}
h2 {
  font-size: 22px;
  margin-top: -20px;  /* provide offset for in-page anchors */
  padding-top: 33px;
}
h3 {
  font-size: 18px;
  margin-top: -36px;  /* provide offset for in-page anchors */
  padding-top: 42px;
}
h4 {
  font-size: 16px;
  margin-top: -36px;  /* provide offset for in-page anchors */
  padding-top: 42px;
}
h5, h6 {
  font-size: 14px;
}
#n-copyright-notice {
  border-bottom: 1px solid #ddd;
  padding-bottom: 1em;
  margin-bottom: 1em;
}
/* general structure */
p {
  padding: 0;
  margin: 0 0 1em 0;
  text-align: left;
}
div, span {
  position: relative;
}
div {
  margin: 0;
}
.alignRight.art-text {
  background-color: #f9f9f9;
  border: 1px solid #eee;
  border-radius: 3px;
  padding: 1em 1em 0;
  margin-bottom: 1.5em;
}
.alignRight.art-text pre {
  padding: 0;
}
.alignRight {
  margin: 1em 0;
}
.alignRight > *:first-child {
  border: none;
  margin: 0;
  float: right;
  clear: both;
}
.alignRight > *:nth-child(2) {
  clear: both;
  display: block;
  border: none;
}
svg {
  display: block;
}
.alignCenter.art-text {
  background-color: #f9f9f9;
  border: 1px solid #eee;
  border-radius: 3px;
  padding: 1em 1em 0;
  margin-bottom: 1.5em;
}
.alignCenter.art-text pre {
  padding: 0;
}
.alignCenter {
  margin: 1em 0;
}
.alignCenter > *:first-child {
  border: none;
  /* this isn't optimal, but it's an existence proof.  PrinceXML doesn't
     support flexbox yet.
  */
  display: table;
  margin: 0 auto;
}

/* lists */
ol, ul {
  padding: 0;
  margin: 0 0 1em 2em;
}
ol ol, ul ul, ol ul, ul ol {
  margin-left: 1em;
}
li {
  margin: 0 0 0.25em 0;
}
.ulCompact li {
  margin: 0;
}
ul.empty, .ulEmpty {
  list-style-type: none;
}
ul.empty li, .ulEmpty li {
  margin-top: 0.5em;
}
ul.compact, .ulCompact,
ol.compact, .olCompact {
  line-height: 100%;
  margin: 0 0 0 2em;
}

/* definition lists */
dl {
}
dl > dt {
  float: left;
  margin-right: 1em;
}
/* 
dl.nohang > dt {
  float: none;
}
*/
dl > dd {
  margin-bottom: .8em;
  min-height: 1.3em;
}
dl.compact > dd, .dlCompact > dd {
  margin-bottom: 0em;
}
dl > dd > dl {
  margin-top: 0.5em;
  margin-bottom: 0em;
}

/* links */
a {
  text-decoration: none;
}
a[href] {
  color: #22e; /* Arlen: WCAG 2019 */
}
a[href]:hover {
  background-color: #f2f2f2;
}
figcaption a[href],
a[href].selfRef {
  color: #222;
}
/* XXX probably not this:
a.selfRef:hover {
  background-color: transparent;
  cursor: default;
} */

/* Figures */
tt, code, pre, code {
  background-color: #f9f9f9;
  font-family: 'Roboto Mono', monospace;
}
pre {
  border: 1px solid #eee;
  margin: 0;
  padding: 1em;
}
img {
  max-width: 100%;
}
figure {
  margin: 0;
}
figure blockquote {
  margin: 0.8em 0.4em 0.4em;
}
figcaption {
  font-style: italic;
  margin: 0 0 1em 0;
}
@media screen {
  pre {
    overflow-x: auto;
    max-width: 100%;
    max-width: calc(100% - 22px);
  }
}

/* aside, blockquote */
aside, blockquote {
  margin-left: 0;
  padding: 1.2em 2em;
}
blockquote {
  background-color: #f9f9f9;
  color: #111; /* Arlen: WCAG 2019 */
  border: 1px solid #ddd;
  border-radius: 3px;
  margin: 1em 0;
}
cite {
  display: block;
  text-align: right;
  font-style: italic;
}

/* tables */
table {
  width: 100%;
  margin: 0 0 1em;
  border-collapse: collapse;
  border: 1px solid #eee;
}
th, td {
  text-align: left;
  vertical-align: top;
  padding: 0.5em 0.75em;
}
th {
  text-align: left;
  background-color: #e9e9e9;
}
tr:nth-child(2n+1) > td {
  background-color: #f5f5f5;
}
table caption {
  font-style: italic;
  margin: 0;
  padding: 0;
  text-align: left;
}
table p {
  /* XXX to avoid bottom margin on table row signifiers. If paragraphs should
     be allowed within tables more generally, it would be far better to select on a class. */
  margin: 0;
}

/* pilcrow */
a.pilcrow {
  color: #666; /* Arlen: AHDJ 2019 */
  text-decoration: none;
  visibility: hidden;
  user-select: none;
  -ms-user-select: none;
  -o-user-select:none;
  -moz-user-select: none;
  -khtml-user-select: none;
  -webkit-user-select: none;
  -webkit-touch-callout: none;
}
@media screen {
  aside:hover > a.pilcrow,
  p:hover > a.pilcrow,
  blockquote:hover > a.pilcrow,
  div:hover > a.pilcrow,
  li:hover > a.pilcrow,
  pre:hover > a.pilcrow {
    visibility: visible;
  }
  a.pilcrow:hover {
    background-color: transparent;
  }
}

/* misc */
hr {
  border: 0;
  border-top: 1px solid #eee;
}
.bcp14 {
  font-variant: small-caps;
}

.role {
  font-variant: all-small-caps;
}

/* info block */
#identifiers {
  margin: 0;
  font-size: 0.9em;
}
#identifiers dt {
  width: 3em;
  clear: left;
}
#identifiers dd {
  float: left;
  margin-bottom: 0;
}
#identifiers .authors .author {
  display: inline-block;
  margin-right: 1.5em;
}
#identifiers .authors .org {
  font-style: italic;
}

/* The prepared/rendered info at the very bottom of the page */
.docInfo {
  color: #666; /* Arlen: WCAG 2019 */
  font-size: 0.9em;
  font-style: italic;
  margin-top: 2em;
}
.docInfo .prepared {
  float: left;
}
.docInfo .prepared {
  float: right;
}

/* table of contents */
#toc  {
  padding: 0.75em 0 2em 0;
  margin-bottom: 1em;
}
nav.toc ul {
  margin: 0 0.5em 0 0;
  padding: 0;
  list-style: none;
}
nav.toc li {
  line-height: 1.3em;
  margin: 0.75em 0;
  padding-left: 1.2em;
  text-indent: -1.2em;
}
/* references */
.references dt {
  text-align: right;
  font-weight: bold;
  min-width: 7em;
}
.references dd {
  margin-left: 8em;
  overflow: auto;
}

.refInstance {
  margin-bottom: 1.25em;
}

.references .ascii {
  margin-bottom: 0.25em;
}

/* index */
.index ul {
  margin: 0 0 0 1em;
  padding: 0;
  list-style: none;
}
.index ul ul {
  margin: 0;
}
.index li {
  margin: 0;
  text-indent: -2em;
  padding-left: 2em;
  padding-bottom: 5px;
}
.indexIndex {
  margin: 0.5em 0 1em;
}
.index a {
  font-weight: 700;
}
/* make the index two-column on all but the smallest screens */
@media (min-width: 600px) {
  .index ul {
    -moz-column-count: 2;
    -moz-column-gap: 20px;
  }
  .index ul ul {
    -moz-column-count: 1;
    -moz-column-gap: 0;
  }
}

/* authors */
address.vcard {
  font-style: normal;
  margin: 1em 0;
}

address.vcard .nameRole {
  font-weight: 700;
  margin-left: 0;
}
address.vcard .label {
  font-family: "Noto Sans",Arial,Helvetica,sans-serif;
  margin: 0.5em 0;
}
address.vcard .type {
  display: none;
}
.alternative-contact {
  margin: 1.5em 0 1em;
}
hr.addr {
  border-top: 1px dashed;
  margin: 0;
  color: #ddd;
  max-width: calc(100% - 16px);
}

/* temporary notes */
.rfcEditorRemove::before {
  position: absolute;
  top: 0.2em;
  right: 0.2em;
  padding: 0.2em;
  content: "The RFC Editor will remove this note";
  color: #9e2a00; /* Arlen: WCAG 2019 */
  background-color: #ffd; /* Arlen: WCAG 2019 */
}
.rfcEditorRemove {
  position: relative;
  padding-top: 1.8em;
  background-color: #ffd; /* Arlen: WCAG 2019 */
  border-radius: 3px;
}
.cref {
  background-color: #ffd; /* Arlen: WCAG 2019 */
  padding: 2px 4px;
}
.crefSource {
  font-style: italic;
}
/* alternative layout for smaller screens */
@media screen and (max-width: 1023px) {
  body {
    padding-top: 2em;
  }
  #title {
    padding: 1em 0;
  }
  h1 {
    font-size: 24px;
  }
  h2 {
    font-size: 20px;
    margin-top: -18px;  /* provide offset for in-page anchors */
    padding-top: 38px;
  }
  #identifiers dd {
    max-width: 60%;
  }
  #toc {
    position: fixed;
    z-index: 2;
    top: 0;
    right: 0;
    padding: 0;
    margin: 0;
    background-color: inherit;
    border-bottom: 1px solid #ccc;
  }
  #toc h2 {
    margin: -1px 0 0 0;
    padding: 4px 0 4px 6px;
    padding-right: 1em;
    min-width: 190px;
    font-size: 1.1em;
    text-align: right;
    background-color: #444;
    color: white;
    cursor: pointer;
  }
  #toc h2::before { /* css hamburger */
    float: right;
    position: relative;
    width: 1em;
    height: 1px;
    left: -164px;
    margin: 6px 0 0 0;
    background: white none repeat scroll 0 0;
    box-shadow: 0 4px 0 0 white, 0 8px 0 0 white;
    content: "";
  }
  #toc nav {
    display: none;
    padding: 0.5em 1em 1em;
    overflow: auto;
    height: calc(100vh - 48px);
    border-left: 1px solid #ddd;
  }
}

/* alternative layout for wide screens */
@media screen and (min-width: 1024px) {
  body {
    max-width: 724px;
    margin: 42px auto;
    padding-left: 1.5em;
    padding-right: 29em;
  }
  #toc {
    position: fixed;
    top: 42px;
    right: 42px;
    width: 25%;
    margin: 0;
    padding: 0 1em;
    z-index: 1;
  }
  #toc h2 {
    border-top: none;
    border-bottom: 1px solid #ddd;
    font-size: 1em;
    font-weight: normal;
    margin: 0;
    padding: 0.25em 1em 1em 0;
  }
  #toc nav {
    display: block;
    height: calc(90vh - 84px);
    bottom: 0;
    padding: 0.5em 0 0;
    overflow: auto;
  }
  img { /* future proofing */
    max-width: 100%;
    height: auto;
  }
}

/* pagination */
@media print {
  body {

    width: 100%;
  }
  p {
    orphans: 3;
    widows: 3;
  }
  #n-copyright-notice {
    border-bottom: none;
  }
  #toc, #n-introduction {
    page-break-before: always;
  }
  #toc {
    border-top: none;
    padding-top: 0;
  }
  figure, pre {
    page-break-inside: avoid;
  }
  figure {
    overflow: scroll;
  }
  h1, h2, h3, h4, h5, h6 {
    page-break-after: avoid;
  }
  h2+*, h3+*, h4+*, h5+*, h6+* {
    page-break-before: avoid;
  }
  pre {
    white-space: pre-wrap;
    word-wrap: break-word;
    font-size: 10pt;
  }
  table {
    border: 1px solid #ddd;
  }
  td {
    border-top: 1px solid #ddd;
  }
}

/* This is commented out here, as the string-set: doesn't
   pass W3C validation currently */
/*
.ears thead .left {
  string-set: ears-top-left content();
}

.ears thead .center {
  string-set: ears-top-center content();
}

.ears thead .right {
  string-set: ears-top-right content();
}

.ears tfoot .left {
  string-set: ears-bottom-left content();
}

.ears tfoot .center {
  string-set: ears-bottom-center content();
}

.ears tfoot .right {
  string-set: ears-bottom-right content();
}
*/

@page :first {
  padding-top: 0;
  @top-left {
    content: normal;
    border: none;
  }
  @top-center {
    content: normal;
    border: none;
  }
  @top-right {
    content: normal;
    border: none;
  }
}

@page {
  size: A4;
  margin-bottom: 45mm;
  padding-top: 20px;
  /* The follwing is commented out here, but set appropriately by in code, as
     the content depends on the document */
  /*
  @top-left {
    content: 'Internet-Draft';
    vertical-align: bottom;
    border-bottom: solid 1px #ccc;
  }
  @top-left {
    content: string(ears-top-left);
    vertical-align: bottom;
    border-bottom: solid 1px #ccc;
  }
  @top-center {
    content: string(ears-top-center);
    vertical-align: bottom;
    border-bottom: solid 1px #ccc;
  }
  @top-right {
    content: string(ears-top-right);
    vertical-align: bottom;
    border-bottom: solid 1px #ccc;
  }
  @bottom-left {
    content: string(ears-bottom-left);
    vertical-align: top;
    border-top: solid 1px #ccc;
  }
  @bottom-center {
    content: string(ears-bottom-center);
    vertical-align: top;
    border-top: solid 1px #ccc;
  }
  @bottom-right {
      content: '[Page ' counter(page) ']';
      vertical-align: top;
      border-top: solid 1px #ccc;
  }
  */

}

/* Changes introduced to fix issues found during implementation */
/* Make sure links are clickable even if overlapped by following H* */
a {
  z-index: 2;
}
/* Separate body from document info even without intervening H1 */
section {
  clear: both;
}


/* Top align author divs, to avoid names without organization dropping level with org names */
.author {
  vertical-align: top;
}

/* Leave room in document info to show Internet-Draft on one line */
#identifiers dt {
  width: 8em;
}

/* Don't waste quite as much whitespace between label and value in doc info */
#identifiers dd {
  margin-left: 1em;
}

/* Give floating toc a background color (needed when it's a div inside section */
#toc {
  background-color: white;
}

/* Make the collapsed ToC header render white on gray also when it's a link */
@media screen and (max-width: 1023px) {
  #toc h2 a,
  #toc h2 a:link,
  #toc h2 a:focus,
  #toc h2 a:hover,
  #toc a.toplink,
  #toc a.toplink:hover {
    color: white;
    background-color: #444;
    text-decoration: none;
  }
}

/* Give the bottom of the ToC some whitespace */
@media screen and (min-width: 1024px) {
  #toc {
    padding: 0 0 1em 1em;
  }
}

/* Style section numbers with more space between number and title */
.section-number {
  padding-right: 0.5em;
}

/* prevent monospace from becoming overly large */
tt, code, pre, code {
  font-size: 95%;
}

/* Fix the height/width aspect for ascii art*/
pre.sourcecode,
.art-text pre {
  line-height: 1.12;
}


/* Add styling for a link in the ToC that points to the top of the document */
a.toplink {
  float: right;
  margin-right: 0.5em;
}

/* Fix the dl styling to match the RFC 7992 attributes */
dl > dt,
dl.dlParallel > dt {
  float: left;
  margin-right: 1em;
}
dl.dlNewline > dt {
  float: none;
}

/* Provide styling for table cell text alignment */
table td.text-left,
table th.text-left {
  text-align: left;
}
table td.text-center,
table th.text-center {
  text-align: center;
}
table td.text-right,
table th.text-right {
  text-align: right;
}

/* Make the alternative author contact informatio look less like just another
   author, and group it closer with the primary author contact information */
.alternative-contact {
  margin: 0.5em 0 0.25em 0;
}
address .non-ascii {
  margin: 0 0 0 2em;
}

/* With it being possible to set tables with alignment
  left, center, and right, { width: 100%; } does not make sense */
table {
  width: auto;
}

/* Avoid reference text that sits in a block with very wide left margin,
   because of a long floating dt label.*/
.references dd {
  overflow: visible;
}

/* Control caption placement */
caption {
  caption-side: bottom;
}

/* Limit the width of the author address vcard, so names in right-to-left
   script don't end up on the other side of the page. */

address.vcard {
  max-width: 30em;
  margin-right: auto;
}

/* For address alignment dependent on LTR or RTL scripts */
address div.left {
  text-align: left;
}
address div.right {
  text-align: right;
}

/* Provide table alignment support.  We can't use the alignX classes above
   since they do unwanted things with caption and other styling. */
table.right {
 margin-left: auto;
 margin-right: 0;
}
table.center {
 margin-left: auto;
 margin-right: auto;
}
table.left {
 margin-left: 0;
 margin-right: auto;
}

/* Give the table caption label the same styling as the figcaption */
caption a[href] {
  color: #222;
}

@media print {
  .toplink {
    display: none;
  }

  /* avoid overwriting the top border line with the ToC header */
  #toc {
    padding-top: 1px;
  }

  /* Avoid page breaks inside dl and author address entries */
  .vcard {
    page-break-inside: avoid;
  }

}
/* Avoid wrapping of URLs in references */
@media screen {
  .references a {
    white-space: nowrap;
  }
}
/* Tweak the bcp14 keyword presentation */
.bcp14 {
  font-variant: small-caps;
  font-weight: bold;
  font-size: 0.9em;
}
/* Tweak the invisible space above H* in order not to overlay links in text above */
 h2 {
  margin-top: -18px;  /* provide offset for in-page anchors */
  padding-top: 31px;
 }
 h3 {
  margin-top: -18px;  /* provide offset for in-page anchors */
  padding-top: 24px;
 }
 h4 {
  margin-top: -18px;  /* provide offset for in-page anchors */
  padding-top: 24px;
 }
/* Float artwork pilcrow to the right */
@media screen {
  .artwork a.pilcrow {
    display: block;
    line-height: 0.7;
    margin-top: 0.15em;
  }
}
/* Make pilcrows on dd visible */
@media screen {
  dd:hover > a.pilcrow {
    visibility: visible;
  }
}
/* Make the placement of figcaption match that of a table's caption
   by removing the figure's added bottom margin */
.alignLeft.art-text,
.alignCenter.art-text,
.alignRight.art-text {
   margin-bottom: 0;
}
.alignLeft,
.alignCenter,
.alignRight {
  margin: 1em 0 0 0;
}
/* In print, the pilcrow won't show on hover, so prevent it from taking up space,
   possibly even requiring a new line */
@media print {
  a.pilcrow {
    display: none;
  }
}
/* Styling for the external metadata */
div#external-metadata {
  background-color: #eee;
  padding: 0.5em;
  margin-bottom: 0.5em;
  display: none;
}
div#internal-metadata {
  padding: 0.5em;                       /* to match the external-metadata padding */
}
/* Styling for title RFC Number */
h1#rfcnum {
  clear: both;
  margin: 0 0 -1em;
  padding: 1em 0 0 0;
}
/* Make .olPercent look the same as <ol><li> */
dl.olPercent > dd {
  margin: 0 0 0.25em 0;
  min-height: initial;
}
/* Give aside some styling to set it apart */
aside {
  border-left: 1px solid #ddd;
  margin: 1em 0 1em 2em;
  padding: 0.2em 2em;
}
aside > dl,
aside > ol,
aside > ul,
aside > table,
aside > p {
  margin-bottom: 0.5em;
}
/* Additional page break settings */
@media print {
  figcaption, table caption {
    page-break-before: avoid;
  }
}
/* Font size adjustments for print */
@media print {
  body  { font-size: 10pt;      line-height: normal; max-width: 96%; }
  h1    { font-size: 1.72em;    padding-top: 1.5em; } /* 1*1.2*1.2*1.2 */
  h2    { font-size: 1.44em;    padding-top: 1.5em; } /* 1*1.2*1.2 */
  h3    { font-size: 1.2em;     padding-top: 1.5em; } /* 1*1.2 */
  h4    { font-size: 1em;       padding-top: 1.5em; }
  h5, h6 { font-size: 1em;      margin: initial; padding: 0.5em 0 0.3em; }
}
/* Sourcecode margin in print, when there's no pilcrow */
@media print {
  .artwork,
  .sourcecode {
    margin-bottom: 1em;
  }
}
/*
  The margin-left: 0 on <dd> removes all distinction
  between levels from nested <dl>s.  Undo that.
*/
dl.olPercent > dd,
dd {
  margin-left: revert;
}
/* Avoid narrow tables forcing too narrow table captions, which may render badly */
table {
  min-width: 20em;
}
/* ol type a */
ol.type-a { list-style-type: lower-alpha; }
ol.type-A { list-style-type: upper-alpha; }
ol.type-i { list-style-type: lower-roman; }
ol.type-I { list-style-type: lower-roman; }
/* Apply the print table and row borders in general, on request from the RPC,
and increase the contrast between border and odd row background sligthtly */
table {
  border: 1px solid #ddd;
}
td {
  border-top: 1px solid #ddd;
}
tr:nth-child(2n+1) > td {
  background-color: #f8f8f8;
}
/* Use style rules to govern display of the TOC. */
@media screen and (max-width: 1023px) {
  #toc nav { display: none; }
  #toc.active nav { display: block; }
}
</style>
<link href="rfc-local.css" rel="stylesheet" type="text/css">
</head>
<body>
<script src="metadata.min.js"></script>
<table class="ears">
<thead><tr>
<td class="left">Internet-Draft</td>
<td class="center">TAPS Implementation</td>
<td class="right">March 2020</td>
</tr></thead>
<tfoot><tr>
<td class="left">Brunstrom, et al.</td>
<td class="center">Expires 10 September 2020</td>
<td class="right">[Page]</td>
</tr></tfoot>
</table>
<div id="external-metadata" class="document-information"></div>
<div id="internal-metadata" class="document-information">
<dl id="identifiers">
<dt class="label-workgroup">Workgroup:</dt>
<dd class="workgroup">TAPS Working Group</dd>
<dt class="label-internet-draft">Internet-Draft:</dt>
<dd class="internet-draft">draft-ietf-taps-impl-06</dd>
<dt class="label-published">Published:</dt>
<dd class="published">
<time datetime="2020-03-09" class="published">9 March 2020</time>
    </dd>
<dt class="label-intended-status">Intended Status:</dt>
<dd class="intended-status">Informational</dd>
<dt class="label-expires">Expires:</dt>
<dd class="expires"><time datetime="2020-09-10">10 September 2020</time></dd>
<dt class="label-authors">Authors:</dt>
<dd class="authors">
<div class="author">
      <div class="author-name">A. Brunstrom, <span class="editor">Ed.</span>
</div>
<div class="org">Karlstad University</div>
</div>
<div class="author">
      <div class="author-name">T. Pauly, <span class="editor">Ed.</span>
</div>
<div class="org">Apple Inc.</div>
</div>
<div class="author">
      <div class="author-name">T. Enghardt</div>
<div class="org">TU Berlin</div>
</div>
<div class="author">
      <div class="author-name">K-J. Grinnemo</div>
<div class="org">Karlstad University</div>
</div>
<div class="author">
      <div class="author-name">T. Jones</div>
<div class="org">University of Aberdeen</div>
</div>
<div class="author">
      <div class="author-name">P. Tiesel</div>
<div class="org">TU Berlin</div>
</div>
<div class="author">
      <div class="author-name">C. Perkins</div>
<div class="org">University of Glasgow</div>
</div>
<div class="author">
      <div class="author-name">M. Welzl</div>
<div class="org">University of Oslo</div>
</div>
</dd>
</dl>
</div>
<h1 id="title">Implementing Interfaces to Transport Services</h1>
<section id="section-abstract">
      <h2 id="abstract"><a href="#abstract" class="selfRef">Abstract</a></h2>
<p id="section-abstract-1">The Transport Services architecture <span>[<a href="#I-D.ietf-taps-arch" class="xref">I-D.ietf-taps-arch</a>]</span> defines a system that allows applications to use transport networking protocols flexibly. This document serves as a guide to implementation on how to build such a system.<a href="#section-abstract-1" class="pilcrow">¶</a></p>
</section>
<div id="status-of-memo">
<section id="section-boilerplate.1">
        <h2 id="name-status-of-this-memo">
<a href="#name-status-of-this-memo" class="section-name selfRef">Status of This Memo</a>
        </h2>
<p id="section-boilerplate.1-1">
        This Internet-Draft is submitted in full conformance with the
        provisions of BCP 78 and BCP 79.<a href="#section-boilerplate.1-1" class="pilcrow">¶</a></p>
<p id="section-boilerplate.1-2">
        Internet-Drafts are working documents of the Internet Engineering Task
        Force (IETF). Note that other groups may also distribute working
        documents as Internet-Drafts. The list of current Internet-Drafts is
        at <span><a href="https://datatracker.ietf.org/drafts/current/">https://datatracker.ietf.org/drafts/current/</a></span>.<a href="#section-boilerplate.1-2" class="pilcrow">¶</a></p>
<p id="section-boilerplate.1-3">
        Internet-Drafts are draft documents valid for a maximum of six months
        and may be updated, replaced, or obsoleted by other documents at any
        time. It is inappropriate to use Internet-Drafts as reference
        material or to cite them other than as "work in progress."<a href="#section-boilerplate.1-3" class="pilcrow">¶</a></p>
<p id="section-boilerplate.1-4">
        This Internet-Draft will expire on 10 September 2020.<a href="#section-boilerplate.1-4" class="pilcrow">¶</a></p>
</section>
</div>
<div id="copyright">
<section id="section-boilerplate.2">
        <h2 id="name-copyright-notice">
<a href="#name-copyright-notice" class="section-name selfRef">Copyright Notice</a>
        </h2>
<p id="section-boilerplate.2-1">
            Copyright (c) 2020 IETF Trust and the persons identified as the
            document authors. All rights reserved.<a href="#section-boilerplate.2-1" class="pilcrow">¶</a></p>
<p id="section-boilerplate.2-2">
            This document is subject to BCP 78 and the IETF Trust's Legal
            Provisions Relating to IETF Documents
            (<span><a href="https://trustee.ietf.org/license-info">https://trustee.ietf.org/license-info</a></span>) in effect on the date of
            publication of this document. Please review these documents
            carefully, as they describe your rights and restrictions with
            respect to this document. Code Components extracted from this
            document must include Simplified BSD License text as described in
            Section 4.e of the Trust Legal Provisions and are provided without
            warranty as described in the Simplified BSD License.<a href="#section-boilerplate.2-2" class="pilcrow">¶</a></p>
</section>
</div>
<div id="toc">
<section id="section-toc.1">
        <a href="#" onclick="scroll(0,0)" class="toplink">▲</a><h2 id="name-table-of-contents">
<a href="#name-table-of-contents" class="section-name selfRef">Table of Contents</a>
        </h2>
<nav class="toc"><ul class="toc ulEmpty">
<li class="toc ulEmpty" id="section-toc.1-1.1">
            <p id="section-toc.1-1.1.1"><a href="#section-1" class="xref">1</a>.  <a href="#name-introduction" class="xref">Introduction</a><a href="#section-toc.1-1.1.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.2">
            <p id="section-toc.1-1.2.1"><a href="#section-2" class="xref">2</a>.  <a href="#name-implementing-connection-obj" class="xref">Implementing Connection Objects</a><a href="#section-toc.1-1.2.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.3">
            <p id="section-toc.1-1.3.1"><a href="#section-3" class="xref">3</a>.  <a href="#name-implementing-pre-establishm" class="xref">Implementing Pre-Establishment</a><a href="#section-toc.1-1.3.1" class="pilcrow">¶</a></p>
<ul class="toc ulEmpty">
<li class="toc ulEmpty" id="section-toc.1-1.3.2.1">
                <p id="section-toc.1-1.3.2.1.1"><a href="#section-3.1" class="xref">3.1</a>.  <a href="#name-configuration-time-errors" class="xref">Configuration-time errors</a><a href="#section-toc.1-1.3.2.1.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.3.2.2">
                <p id="section-toc.1-1.3.2.2.1"><a href="#section-3.2" class="xref">3.2</a>.  <a href="#name-role-of-system-policy" class="xref">Role of system policy</a><a href="#section-toc.1-1.3.2.2.1" class="pilcrow">¶</a></p>
</li>
</ul>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.4">
            <p id="section-toc.1-1.4.1"><a href="#section-4" class="xref">4</a>.  <a href="#name-implementing-connection-est" class="xref">Implementing Connection Establishment</a><a href="#section-toc.1-1.4.1" class="pilcrow">¶</a></p>
<ul class="toc ulEmpty">
<li class="toc ulEmpty" id="section-toc.1-1.4.2.1">
                <p id="section-toc.1-1.4.2.1.1"><a href="#section-4.1" class="xref">4.1</a>.  <a href="#name-candidate-gathering" class="xref">Candidate Gathering</a><a href="#section-toc.1-1.4.2.1.1" class="pilcrow">¶</a></p>
<ul class="toc ulEmpty">
<li class="toc ulEmpty" id="section-toc.1-1.4.2.1.2.1">
                    <p id="section-toc.1-1.4.2.1.2.1.1"><a href="#section-4.1.1" class="xref">4.1.1</a>.  <a href="#name-gathering-endpoint-candidat" class="xref">Gathering Endpoint Candidates</a><a href="#section-toc.1-1.4.2.1.2.1.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.4.2.1.2.2">
                    <p id="section-toc.1-1.4.2.1.2.2.1"><a href="#section-4.1.2" class="xref">4.1.2</a>.  <a href="#name-structuring-options-as-a-tr" class="xref">Structuring Options as a Tree</a><a href="#section-toc.1-1.4.2.1.2.2.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.4.2.1.2.3">
                    <p id="section-toc.1-1.4.2.1.2.3.1"><a href="#section-4.1.3" class="xref">4.1.3</a>.  <a href="#name-branch-types" class="xref">Branch Types</a><a href="#section-toc.1-1.4.2.1.2.3.1" class="pilcrow">¶</a></p>
</li>
</ul>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.4.2.2">
                <p id="section-toc.1-1.4.2.2.1"><a href="#section-4.2" class="xref">4.2</a>.  <a href="#name-branching-order-of-operatio" class="xref">Branching Order-of-Operations</a><a href="#section-toc.1-1.4.2.2.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.4.2.3">
                <p id="section-toc.1-1.4.2.3.1"><a href="#section-4.3" class="xref">4.3</a>.  <a href="#name-sorting-branches" class="xref">Sorting Branches</a><a href="#section-toc.1-1.4.2.3.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.4.2.4">
                <p id="section-toc.1-1.4.2.4.1"><a href="#section-4.4" class="xref">4.4</a>.  <a href="#name-candidate-racing" class="xref">Candidate Racing</a><a href="#section-toc.1-1.4.2.4.1" class="pilcrow">¶</a></p>
<ul class="toc ulEmpty">
<li class="toc ulEmpty" id="section-toc.1-1.4.2.4.2.1">
                    <p id="section-toc.1-1.4.2.4.2.1.1"><a href="#section-4.4.1" class="xref">4.4.1</a>.  <a href="#name-delayed" class="xref">Delayed</a><a href="#section-toc.1-1.4.2.4.2.1.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.4.2.4.2.2">
                    <p id="section-toc.1-1.4.2.4.2.2.1"><a href="#section-4.4.2" class="xref">4.4.2</a>.  <a href="#name-failover" class="xref">Failover</a><a href="#section-toc.1-1.4.2.4.2.2.1" class="pilcrow">¶</a></p>
</li>
</ul>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.4.2.5">
                <p id="section-toc.1-1.4.2.5.1"><a href="#section-4.5" class="xref">4.5</a>.  <a href="#name-completing-establishment" class="xref">Completing Establishment</a><a href="#section-toc.1-1.4.2.5.1" class="pilcrow">¶</a></p>
<ul class="toc ulEmpty">
<li class="toc ulEmpty" id="section-toc.1-1.4.2.5.2.1">
                    <p id="section-toc.1-1.4.2.5.2.1.1"><a href="#section-4.5.1" class="xref">4.5.1</a>.  <a href="#name-determining-successful-esta" class="xref">Determining Successful Establishment</a><a href="#section-toc.1-1.4.2.5.2.1.1" class="pilcrow">¶</a></p>
</li>
</ul>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.4.2.6">
                <p id="section-toc.1-1.4.2.6.1"><a href="#section-4.6" class="xref">4.6</a>.  <a href="#name-establishing-multiplexed-co" class="xref">Establishing multiplexed connections</a><a href="#section-toc.1-1.4.2.6.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.4.2.7">
                <p id="section-toc.1-1.4.2.7.1"><a href="#section-4.7" class="xref">4.7</a>.  <a href="#name-handling-racing-with-unconn" class="xref">Handling racing with "unconnected" protocols</a><a href="#section-toc.1-1.4.2.7.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.4.2.8">
                <p id="section-toc.1-1.4.2.8.1"><a href="#section-4.8" class="xref">4.8</a>.  <a href="#name-implementing-listeners" class="xref">Implementing listeners</a><a href="#section-toc.1-1.4.2.8.1" class="pilcrow">¶</a></p>
<ul class="toc ulEmpty">
<li class="toc ulEmpty" id="section-toc.1-1.4.2.8.2.1">
                    <p id="section-toc.1-1.4.2.8.2.1.1"><a href="#section-4.8.1" class="xref">4.8.1</a>.  <a href="#name-implementing-listeners-for-" class="xref">Implementing listeners for Connected Protocols</a><a href="#section-toc.1-1.4.2.8.2.1.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.4.2.8.2.2">
                    <p id="section-toc.1-1.4.2.8.2.2.1"><a href="#section-4.8.2" class="xref">4.8.2</a>.  <a href="#name-implementing-listeners-for-u" class="xref">Implementing listeners for Unconnected Protocols</a><a href="#section-toc.1-1.4.2.8.2.2.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.4.2.8.2.3">
                    <p id="section-toc.1-1.4.2.8.2.3.1"><a href="#section-4.8.3" class="xref">4.8.3</a>.  <a href="#name-implementing-listeners-for-m" class="xref">Implementing listeners for Multiplexed Protocols</a><a href="#section-toc.1-1.4.2.8.2.3.1" class="pilcrow">¶</a></p>
</li>
</ul>
</li>
</ul>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.5">
            <p id="section-toc.1-1.5.1"><a href="#section-5" class="xref">5</a>.  <a href="#name-implementing-sending-and-re" class="xref">Implementing Sending and Receiving Data</a><a href="#section-toc.1-1.5.1" class="pilcrow">¶</a></p>
<ul class="toc ulEmpty">
<li class="toc ulEmpty" id="section-toc.1-1.5.2.1">
                <p id="section-toc.1-1.5.2.1.1"><a href="#section-5.1" class="xref">5.1</a>.  <a href="#name-sending-messages" class="xref">Sending Messages</a><a href="#section-toc.1-1.5.2.1.1" class="pilcrow">¶</a></p>
<ul class="toc ulEmpty">
<li class="toc ulEmpty" id="section-toc.1-1.5.2.1.2.1">
                    <p id="section-toc.1-1.5.2.1.2.1.1"><a href="#section-5.1.1" class="xref">5.1.1</a>.  <a href="#name-message-properties" class="xref">Message Properties</a><a href="#section-toc.1-1.5.2.1.2.1.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.5.2.1.2.2">
                    <p id="section-toc.1-1.5.2.1.2.2.1"><a href="#section-5.1.2" class="xref">5.1.2</a>.  <a href="#name-send-completion" class="xref">Send Completion</a><a href="#section-toc.1-1.5.2.1.2.2.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.5.2.1.2.3">
                    <p id="section-toc.1-1.5.2.1.2.3.1"><a href="#section-5.1.3" class="xref">5.1.3</a>.  <a href="#name-batching-sends" class="xref">Batching Sends</a><a href="#section-toc.1-1.5.2.1.2.3.1" class="pilcrow">¶</a></p>
</li>
</ul>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.5.2.2">
                <p id="section-toc.1-1.5.2.2.1"><a href="#section-5.2" class="xref">5.2</a>.  <a href="#name-receiving-messages" class="xref">Receiving Messages</a><a href="#section-toc.1-1.5.2.2.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.5.2.3">
                <p id="section-toc.1-1.5.2.3.1"><a href="#section-5.3" class="xref">5.3</a>.  <a href="#name-handling-of-data-for-fast-o" class="xref">Handling of data for fast-open protocols</a><a href="#section-toc.1-1.5.2.3.1" class="pilcrow">¶</a></p>
</li>
</ul>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.6">
            <p id="section-toc.1-1.6.1"><a href="#section-6" class="xref">6</a>.  <a href="#name-implementing-message-framer" class="xref">Implementing Message Framers</a><a href="#section-toc.1-1.6.1" class="pilcrow">¶</a></p>
<ul class="toc ulEmpty">
<li class="toc ulEmpty" id="section-toc.1-1.6.2.1">
                <p id="section-toc.1-1.6.2.1.1"><a href="#section-6.1" class="xref">6.1</a>.  <a href="#name-defining-message-framers" class="xref">Defining Message Framers</a><a href="#section-toc.1-1.6.2.1.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.6.2.2">
                <p id="section-toc.1-1.6.2.2.1"><a href="#section-6.2" class="xref">6.2</a>.  <a href="#name-sender-side-message-framing" class="xref">Sender-side Message Framing</a><a href="#section-toc.1-1.6.2.2.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.6.2.3">
                <p id="section-toc.1-1.6.2.3.1"><a href="#section-6.3" class="xref">6.3</a>.  <a href="#name-receiver-side-message-frami" class="xref">Receiver-side Message Framing</a><a href="#section-toc.1-1.6.2.3.1" class="pilcrow">¶</a></p>
</li>
</ul>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.7">
            <p id="section-toc.1-1.7.1"><a href="#section-7" class="xref">7</a>.  <a href="#name-implementing-connection-man" class="xref">Implementing Connection Management</a><a href="#section-toc.1-1.7.1" class="pilcrow">¶</a></p>
<ul class="toc ulEmpty">
<li class="toc ulEmpty" id="section-toc.1-1.7.2.1">
                <p id="section-toc.1-1.7.2.1.1"><a href="#section-7.1" class="xref">7.1</a>.  <a href="#name-pooled-connection" class="xref">Pooled Connection</a><a href="#section-toc.1-1.7.2.1.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.7.2.2">
                <p id="section-toc.1-1.7.2.2.1"><a href="#section-7.2" class="xref">7.2</a>.  <a href="#name-handling-path-changes" class="xref">Handling Path Changes</a><a href="#section-toc.1-1.7.2.2.1" class="pilcrow">¶</a></p>
</li>
</ul>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.8">
            <p id="section-toc.1-1.8.1"><a href="#section-8" class="xref">8</a>.  <a href="#name-implementing-connection-ter" class="xref">Implementing Connection Termination</a><a href="#section-toc.1-1.8.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.9">
            <p id="section-toc.1-1.9.1"><a href="#section-9" class="xref">9</a>.  <a href="#name-cached-state" class="xref">Cached State</a><a href="#section-toc.1-1.9.1" class="pilcrow">¶</a></p>
<ul class="toc ulEmpty">
<li class="toc ulEmpty" id="section-toc.1-1.9.2.1">
                <p id="section-toc.1-1.9.2.1.1"><a href="#section-9.1" class="xref">9.1</a>.  <a href="#name-protocol-state-caches" class="xref">Protocol state caches</a><a href="#section-toc.1-1.9.2.1.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.9.2.2">
                <p id="section-toc.1-1.9.2.2.1"><a href="#section-9.2" class="xref">9.2</a>.  <a href="#name-performance-caches" class="xref">Performance caches</a><a href="#section-toc.1-1.9.2.2.1" class="pilcrow">¶</a></p>
</li>
</ul>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.10">
            <p id="section-toc.1-1.10.1"><a href="#section-10" class="xref">10</a>. <a href="#name-specific-transport-protocol" class="xref">Specific Transport Protocol Considerations</a><a href="#section-toc.1-1.10.1" class="pilcrow">¶</a></p>
<ul class="toc ulEmpty">
<li class="toc ulEmpty" id="section-toc.1-1.10.2.1">
                <p id="section-toc.1-1.10.2.1.1"><a href="#section-10.1" class="xref">10.1</a>.  <a href="#name-tcp" class="xref">TCP</a><a href="#section-toc.1-1.10.2.1.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.10.2.2">
                <p id="section-toc.1-1.10.2.2.1"><a href="#section-10.2" class="xref">10.2</a>.  <a href="#name-udp" class="xref">UDP</a><a href="#section-toc.1-1.10.2.2.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.10.2.3">
                <p id="section-toc.1-1.10.2.3.1"><a href="#section-10.3" class="xref">10.3</a>.  <a href="#name-udp-multicast-receive" class="xref">UDP Multicast Receive</a><a href="#section-toc.1-1.10.2.3.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.10.2.4">
                <p id="section-toc.1-1.10.2.4.1"><a href="#section-10.4" class="xref">10.4</a>.  <a href="#name-tls" class="xref">TLS</a><a href="#section-toc.1-1.10.2.4.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.10.2.5">
                <p id="section-toc.1-1.10.2.5.1"><a href="#section-10.5" class="xref">10.5</a>.  <a href="#name-dtls" class="xref">DTLS</a><a href="#section-toc.1-1.10.2.5.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.10.2.6">
                <p id="section-toc.1-1.10.2.6.1"><a href="#section-10.6" class="xref">10.6</a>.  <a href="#name-http" class="xref">HTTP</a><a href="#section-toc.1-1.10.2.6.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.10.2.7">
                <p id="section-toc.1-1.10.2.7.1"><a href="#section-10.7" class="xref">10.7</a>.  <a href="#name-quic" class="xref">QUIC</a><a href="#section-toc.1-1.10.2.7.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.10.2.8">
                <p id="section-toc.1-1.10.2.8.1"><a href="#section-10.8" class="xref">10.8</a>.  <a href="#name-http-2-transport" class="xref">HTTP/2 transport</a><a href="#section-toc.1-1.10.2.8.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.10.2.9">
                <p id="section-toc.1-1.10.2.9.1"><a href="#section-10.9" class="xref">10.9</a>.  <a href="#name-sctp" class="xref">SCTP</a><a href="#section-toc.1-1.10.2.9.1" class="pilcrow">¶</a></p>
</li>
</ul>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.11">
            <p id="section-toc.1-1.11.1"><a href="#section-11" class="xref">11</a>. <a href="#name-iana-considerations" class="xref">IANA Considerations</a><a href="#section-toc.1-1.11.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.12">
            <p id="section-toc.1-1.12.1"><a href="#section-12" class="xref">12</a>. <a href="#name-security-considerations" class="xref">Security Considerations</a><a href="#section-toc.1-1.12.1" class="pilcrow">¶</a></p>
<ul class="toc ulEmpty">
<li class="toc ulEmpty" id="section-toc.1-1.12.2.1">
                <p id="section-toc.1-1.12.2.1.1"><a href="#section-12.1" class="xref">12.1</a>.  <a href="#name-considerations-for-candidat" class="xref">Considerations for Candidate Gathering</a><a href="#section-toc.1-1.12.2.1.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.12.2.2">
                <p id="section-toc.1-1.12.2.2.1"><a href="#section-12.2" class="xref">12.2</a>.  <a href="#name-considerations-for-candidate" class="xref">Considerations for Candidate Racing</a><a href="#section-toc.1-1.12.2.2.1" class="pilcrow">¶</a></p>
</li>
</ul>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.13">
            <p id="section-toc.1-1.13.1"><a href="#section-13" class="xref">13</a>. <a href="#name-acknowledgements" class="xref">Acknowledgements</a><a href="#section-toc.1-1.13.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.14">
            <p id="section-toc.1-1.14.1"><a href="#section-14" class="xref">14</a>. <a href="#name-references" class="xref">References</a><a href="#section-toc.1-1.14.1" class="pilcrow">¶</a></p>
<ul class="toc ulEmpty">
<li class="toc ulEmpty" id="section-toc.1-1.14.2.1">
                <p id="section-toc.1-1.14.2.1.1"><a href="#section-14.1" class="xref">14.1</a>.  <a href="#name-normative-references" class="xref">Normative References</a><a href="#section-toc.1-1.14.2.1.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.14.2.2">
                <p id="section-toc.1-1.14.2.2.1"><a href="#section-14.2" class="xref">14.2</a>.  <a href="#name-informative-references" class="xref">Informative References</a><a href="#section-toc.1-1.14.2.2.1" class="pilcrow">¶</a></p>
</li>
</ul>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.15">
            <p id="section-toc.1-1.15.1"><a href="#section-appendix.a" class="xref">Appendix A</a>.  <a href="#name-additional-properties" class="xref">Additional Properties</a><a href="#section-toc.1-1.15.1" class="pilcrow">¶</a></p>
<ul class="toc ulEmpty">
<li class="toc ulEmpty" id="section-toc.1-1.15.2.1">
                <p id="section-toc.1-1.15.2.1.1"><a href="#section-a.1" class="xref">A.1</a>.  <a href="#name-properties-affecting-sortin" class="xref">Properties Affecting Sorting of Branches</a><a href="#section-toc.1-1.15.2.1.1" class="pilcrow">¶</a></p>
</li>
</ul>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.16">
            <p id="section-toc.1-1.16.1"><a href="#section-appendix.b" class="xref">Appendix B</a>.  <a href="#name-reasons-for-errors" class="xref">Reasons for errors</a><a href="#section-toc.1-1.16.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.17">
            <p id="section-toc.1-1.17.1"><a href="#section-appendix.c" class="xref">Appendix C</a>.  <a href="#name-existing-implementations" class="xref">Existing Implementations</a><a href="#section-toc.1-1.17.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.18">
            <p id="section-toc.1-1.18.1"><a href="#section-appendix.d" class="xref"></a><a href="#name-authors-addresses" class="xref">Authors' Addresses</a><a href="#section-toc.1-1.18.1" class="pilcrow">¶</a></p>
</li>
</ul>
</nav>
</section>
</div>
<div id="introduction">
<section id="section-1">
      <h2 id="name-introduction">
<a href="#section-1" class="section-number selfRef">1. </a><a href="#name-introduction" class="section-name selfRef">Introduction</a>
      </h2>
<p id="section-1-1">The Transport Services architecture <span>[<a href="#I-D.ietf-taps-arch" class="xref">I-D.ietf-taps-arch</a>]</span> defines a system that allows applications to use transport networking protocols flexibly. The interface such a system exposes to applications is defined as the Transport Services API <span>[<a href="#I-D.ietf-taps-interface" class="xref">I-D.ietf-taps-interface</a>]</span>. This API is designed to be generic across multiple transport protocols and sets of protocols features.<a href="#section-1-1" class="pilcrow">¶</a></p>
<p id="section-1-2">This document serves as a guide to implementation on how to build a system that provides a Transport Services API. It is the job of an implementation of a Transport Services system to turn the requests of an application into decisions on how to establish connections, and how to transfer data over those connections once established. The terminology used in this document is based on the Architecture <span>[<a href="#I-D.ietf-taps-arch" class="xref">I-D.ietf-taps-arch</a>]</span>.<a href="#section-1-2" class="pilcrow">¶</a></p>
</section>
</div>
<div id="implementing-connection-objects">
<section id="section-2">
      <h2 id="name-implementing-connection-obj">
<a href="#section-2" class="section-number selfRef">2. </a><a href="#name-implementing-connection-obj" class="section-name selfRef">Implementing Connection Objects</a>
      </h2>
<p id="section-2-1">The connection objects that are exposed to applications for Transport Services are:<a href="#section-2-1" class="pilcrow">¶</a></p>
<ul>
<li id="section-2-2.1">the Preconnection, the bundle of properties that describes the application constraints on the transport;<a href="#section-2-2.1" class="pilcrow">¶</a>
</li>
<li id="section-2-2.2">the Connection, the basic object that represents a flow of data in either direction between the Local and Remote Endpoints;<a href="#section-2-2.2" class="pilcrow">¶</a>
</li>
<li id="section-2-2.3">and the Listener, a passive waiting object that delivers new Connections.<a href="#section-2-2.3" class="pilcrow">¶</a>
</li>
</ul>
<p id="section-2-3">Preconnection objects should be implemented as bundles of properties that an application can both read and write. Once a Preconnection has been used to create an outbound Connection or a Listener, the implementation should ensure that the copy of the properties held by the Connection or Listener is immutable. This may involve performing a deep-copy if the application is still able to modify properties on the original Preconnection object.<a href="#section-2-3" class="pilcrow">¶</a></p>
<p id="section-2-4">Connection objects represent the interface between the application and the implementation to manage transport state, and conduct data transfer. During the process of establishment (<a href="#conn-establish" class="xref">Section 4</a>), the Connection will be unbound to a specific transport flow, since there may be multiple candidate Protocol Stacks being raced. Once the Connection is established, the object should be considered mapped to a specific Protocol Stack. The notion of a Connection maps to many different protocols, depending on the Protocol Stack. For example, the Connection may ultimately represent the interface into a TCP connection, a TLS session over TCP, a UDP flow with fully-specified local and remote endpoints, a DTLS session, a SCTP stream, a QUIC stream, or an HTTP/2 stream.<a href="#section-2-4" class="pilcrow">¶</a></p>
<p id="section-2-5">Listener objects are created with a Preconnection, at which point their configuration should be considered immutable by the implementation. The process of listening is described in <a href="#listen" class="xref">Section 4.8</a>.<a href="#section-2-5" class="pilcrow">¶</a></p>
</section>
</div>
<div id="implementing-pre-establishment">
<section id="section-3">
      <h2 id="name-implementing-pre-establishm">
<a href="#section-3" class="section-number selfRef">3. </a><a href="#name-implementing-pre-establishm" class="section-name selfRef">Implementing Pre-Establishment</a>
      </h2>
<p id="section-3-1">During pre-establishment the application specifies the Endpoints to be used for communication as well as its preferences via Selection Properties and, if desired, also Connection Properties. Generally, Connection Properties should be configured as early as possible, as they may serve as input to decisions that are made by the implementation (the Capacity Profile may guide usage of a protocol offering scavenger-type congestion control, for example). In the remainder of this document, we only refer to Selection Properties because they are the more typical case and have to be handled by all implementations.<a href="#section-3-1" class="pilcrow">¶</a></p>
<p id="section-3-2">The implementation stores these objects and properties as part of the Preconnection object for use during connection establishment. For Selection Properties that are not provided by the application, the implementation must use the default values specified in the Transport Services API (<span>[<a href="#I-D.ietf-taps-interface" class="xref">I-D.ietf-taps-interface</a>]</span>).<a href="#section-3-2" class="pilcrow">¶</a></p>
<div id="configuration-time-errors">
<section id="section-3.1">
        <h3 id="name-configuration-time-errors">
<a href="#section-3.1" class="section-number selfRef">3.1. </a><a href="#name-configuration-time-errors" class="section-name selfRef">Configuration-time errors</a>
        </h3>
<p id="section-3.1-1">The transport system should have a list of supported protocols available, which each have transport features reflecting the capabilities of the protocol. Once an application specifies its Transport Parameters, the transport system should match the required and prohibited properties against the transport features of the available protocols.<a href="#section-3.1-1" class="pilcrow">¶</a></p>
<p id="section-3.1-2">In the following cases, failure should be detected during pre-establishment:<a href="#section-3.1-2" class="pilcrow">¶</a></p>
<ul>
<li id="section-3.1-3.1">The application requested Protocol Properties that include requirements or prohibitions that cannot be satisfied by any of the available protocols. For example, if an application requires "Configure Reliability per Message", but no such protocol is available on the host running the transport system, e.g., because SCTP is not supported by the operating system, this should result in an error.<a href="#section-3.1-3.1" class="pilcrow">¶</a>
</li>
<li id="section-3.1-3.2">The application requested Protocol Properties that are in conflict with each other, i.e., the required and prohibited properties cannot be satisfied by the same protocol. For example, if an application prohibits "Reliable Data Transfer" but then requires "Configure Reliability per Message", this mismatch should result in an error.<a href="#section-3.1-3.2" class="pilcrow">¶</a>
</li>
</ul>
<p id="section-3.1-4">It is important to fail as early as possible in such cases in order to avoid allocating resources, e.g., to endpoint resolution, only to find out later that there is no protocol that satisfies the requirements.<a href="#section-3.1-4" class="pilcrow">¶</a></p>
</section>
</div>
<div id="role-of-system-policy">
<section id="section-3.2">
        <h3 id="name-role-of-system-policy">
<a href="#section-3.2" class="section-number selfRef">3.2. </a><a href="#name-role-of-system-policy" class="section-name selfRef">Role of system policy</a>
        </h3>
<p id="section-3.2-1">The properties specified during pre-establishment have a close connection to system policy. The implementation is responsible for combining and reconciling several different sources of preferences when establishing Connections. These include, but are not limited to:<a href="#section-3.2-1" class="pilcrow">¶</a></p>
<ol start="1" type="1" class="normal type-1" id="section-3.2-2">
          <li id="section-3.2-2.1">Application preferences, i.e., preferences specified during the pre-establishment via Selection Properties.<a href="#section-3.2-2.1" class="pilcrow">¶</a>
</li>
<li id="section-3.2-2.2">Dynamic system policy, i.e., policy compiled from internally and externally acquired information about available network interfaces, supported transport protocols, and current/previous Connections. Examples of ways to externally retrieve policy-support information are through OS-specific statistics/measurement tools and tools that reside on middleboxes and routers.<a href="#section-3.2-2.2" class="pilcrow">¶</a>
</li>
<li id="section-3.2-2.3">Default implementation policy, i.e., predefined policy by OS or application.<a href="#section-3.2-2.3" class="pilcrow">¶</a>
</li>
</ol>
<p id="section-3.2-3">In general, any protocol or path used for a connection must conform to all three sources of constraints. Any violation of any of the layers should cause a protocol or path to be considered ineligible for use. For an example of application preferences leading to constraints, an application may prohibit the use of metered network interfaces for a given Connection to avoid user cost. Similarly, the system policy at a given time may prohibit the use of such a metered network interface from the application's process. Lastly, the implementation itself may default to disallowing certain network interfaces unless explicitly requested by the application and allowed by the system.<a href="#section-3.2-3" class="pilcrow">¶</a></p>
<p id="section-3.2-4">It is expected that the database of system policies and the method of looking up these policies will vary across various platforms. An implementation should attempt to look up the relevant policies for the system in a dynamic way to make sure it is reflecting an accurate version of the system policy, since the system's policy regarding the application's traffic may change over time due to user or administrative changes.<a href="#section-3.2-4" class="pilcrow">¶</a></p>
</section>
</div>
</section>
</div>
<div id="conn-establish">
<section id="section-4">
      <h2 id="name-implementing-connection-est">
<a href="#section-4" class="section-number selfRef">4. </a><a href="#name-implementing-connection-est" class="section-name selfRef">Implementing Connection Establishment</a>
      </h2>
<p id="section-4-1">The process of establishing a network connection begins when an application expresses intent to communicate with a remote endpoint by calling Initiate. (At this point, any constraints or requirements the application may have on the connection are available from pre-establishment.) The process can be considered complete once there is at least one Protocol Stack that has completed any required setup to the point that it can transmit and receive the application's data.<a href="#section-4-1" class="pilcrow">¶</a></p>
<p id="section-4-2">Connection establishment is divided into two top-level steps: Candidate Gathering, to identify the paths, protocols, and endpoints to use, and Candidate Racing, in which the necessary protocol handshakes are conducted so that the transport system can select which set to use. This document structures candidates for racing as a tree.<a href="#section-4-2" class="pilcrow">¶</a></p>
<p id="section-4-3">The most simple example of this process might involve identifying the single IP address to which the implementation wishes to connect, using the system's current default interface or path, and starting a TCP handshake to establish a stream to the specified IP address. However, each step may also vary depending on the requirements of the connection: if the endpoint is defined as a hostname and port, then there may be multiple resolved addresses that are available; there may also be multiple interfaces or paths available, other than the default system interface; and some protocols may not need any transport handshake to be considered "established" (such as UDP), while other connections may utilize layered protocol handshakes, such as TLS over TCP.<a href="#section-4-3" class="pilcrow">¶</a></p>
<p id="section-4-4">Whenever an implementation has multiple options for connection establishment, it can view the set of all individual connection establishment options as a single, aggregate connection establishment. The aggregate set conceptually includes every valid combination of endpoints, paths, and protocols. As an example, consider an implementation that initiates a TCP connection to a hostname + port endpoint, and has two valid interfaces available (Wi-Fi and LTE). The hostname resolves to a single IPv4 address on the Wi-Fi network, and resolves to the same IPv4 address on the LTE network, as well as a single IPv6 address. The aggregate set of connection establishment options can be viewed as follows:<a href="#section-4-4" class="pilcrow">¶</a></p>
<div class="artwork art-text alignLeft" id="section-4-5">
<pre>
Aggregate [Endpoint: www.example.com:80] [Interface: Any]   [Protocol: TCP]
|-&gt; [Endpoint: 192.0.2.1:80]       [Interface: Wi-Fi] [Protocol: TCP]
|-&gt; [Endpoint: 192.0.2.1:80]       [Interface: LTE]   [Protocol: TCP]
|-&gt; [Endpoint: 2001:DB8::1.80]     [Interface: LTE]   [Protocol: TCP]
</pre><a href="#section-4-5" class="pilcrow">¶</a>
</div>
<p id="section-4-6">Any one of these sub-entries on the aggregate connection attempt would satisfy the original application intent. The concern of this section is the algorithm defining which of these options to try, when, and in what order.<a href="#section-4-6" class="pilcrow">¶</a></p>
<p id="section-4-7">During Candidate Gathering, an implementation first excludes all protocols and
paths that match a Prohibit or do not match all Require properties.
Then, the implementation will sort branches according to Preferred
properties, Avoided properties, and possibly other criteria.<a href="#section-4-7" class="pilcrow">¶</a></p>
<div id="gathering">
<section id="section-4.1">
        <h3 id="name-candidate-gathering">
<a href="#section-4.1" class="section-number selfRef">4.1. </a><a href="#name-candidate-gathering" class="section-name selfRef">Candidate Gathering</a>
        </h3>
<p id="section-4.1-1">The step of gathering candidates involves identifying which paths, protocols, and endpoints may be used for a given Connection. This list is determined by the requirements, prohibitions, and preferences of the application as specified in the Selection Properties.<a href="#section-4.1-1" class="pilcrow">¶</a></p>
<div id="gathering-endpoint-candidates">
<section id="section-4.1.1">
          <h4 id="name-gathering-endpoint-candidat">
<a href="#section-4.1.1" class="section-number selfRef">4.1.1. </a><a href="#name-gathering-endpoint-candidat" class="section-name selfRef">Gathering Endpoint Candidates</a>
          </h4>
<p id="section-4.1.1-1">Both Local and Remote Endpoint Candidates must be discovered during connection establishment.  To support ICE, or similar protocols, that involve out-of-band indirect signalling to exchange candidates with the Remote Endpoint, it's important to be able to query the set of candidate Local Endpoints, and give the protocol stack a set of candidate Remote Endpoints, before it attempts to establish connections.<a href="#section-4.1.1-1" class="pilcrow">¶</a></p>
<div id="local-endpoint-candidates">
<section id="section-4.1.1.1">
            <h5 id="name-local-endpoint-candidates">
<a href="#section-4.1.1.1" class="section-number selfRef">4.1.1.1. </a><a href="#name-local-endpoint-candidates" class="section-name selfRef">Local Endpoint candidates</a>
            </h5>
<p id="section-4.1.1.1-1">The set of possible Local Endpoints is gathered.  In the simple case, this merely enumerates the local interfaces and protocols, allocates ephemeral source ports.  For example, a system that has WiFi and Ethernet and supports IPv4 and IPv6 might gather four candidate locals (IPv4 on Ethernet, IPv6 on Ethernet, IPv4 on WiFi, and IPv6 on WiFi) that can form the source for a transient.<a href="#section-4.1.1.1-1" class="pilcrow">¶</a></p>
<p id="section-4.1.1.1-2">If NAT traversal is required, the process of gathering Local Endpoints becomes broadly equivalent to the ICE candidate gathering phase <span>[<a href="#RFC5245" class="xref">RFC5245</a>]</span>.  The endpoint determines its server reflexive Local Endpoints (i.e., the translated address of a local, on the other side of a NAT) and relayed locals (e.g., via a TURN server or other relay), for each interface and network protocol.  These are added to the set of candidate Local Endpoints for this connection.<a href="#section-4.1.1.1-2" class="pilcrow">¶</a></p>
<p id="section-4.1.1.1-3">Gathering Local Endpoints is primarily a local operation, although it might involve exchanges with a STUN server to derive server reflexive locals, or with a TURN server or other relay to derive relayed locals.  It does not involve communication with the Remote Endpoint.<a href="#section-4.1.1.1-3" class="pilcrow">¶</a></p>
</section>
</div>
<div id="remote-endpoint-candidates">
<section id="section-4.1.1.2">
            <h5 id="name-remote-endpoint-candidates">
<a href="#section-4.1.1.2" class="section-number selfRef">4.1.1.2. </a><a href="#name-remote-endpoint-candidates" class="section-name selfRef">Remote Endpoint Candidates</a>
            </h5>
<p id="section-4.1.1.2-1">The Remote Endpoint is typically a name that needs to be resolved into a set of possible addresses that can be used for communication.  Resolving the Remote Endpoint is the process of recursively performing such name lookups, until fully resolved, to return the set of candidates for the remote of this connection.<a href="#section-4.1.1.2-1" class="pilcrow">¶</a></p>
<p id="section-4.1.1.2-2">How this is done will depend on the type of the Remote Endpoint, and can also be specific to each Local Endpoint.  A common case is when the Remote Endpoint is a DNS name, in which case it is resolved to give a set of IPv4 and IPv6 addresses representing that name.  Some types of remote might require more complex resolution.  Resolving the Remote Endpoint for a peer-to-peer connection might involve communication with a rendezvous server, which in turn contacts the peer to gain consent to communicate and retrieve its set of candidate locals, which are returned and form the candidate remote addresses for contacting that peer.<a href="#section-4.1.1.2-2" class="pilcrow">¶</a></p>
<p id="section-4.1.1.2-3">Resolving the remote is not a local operation.  It will involve a directory service, and can require communication with the remote to rendezvous and exchange peer addresses.  This can expose some or all of the candidate locals to the remote.<a href="#section-4.1.1.2-3" class="pilcrow">¶</a></p>
</section>
</div>
</section>
</div>
<div id="structuring-options-as-a-tree">
<section id="section-4.1.2">
          <h4 id="name-structuring-options-as-a-tr">
<a href="#section-4.1.2" class="section-number selfRef">4.1.2. </a><a href="#name-structuring-options-as-a-tr" class="section-name selfRef">Structuring Options as a Tree</a>
          </h4>
<p id="section-4.1.2-1">When an implementation responsible for connection establishment needs to consider multiple options, it should logically structure these options as a hierarchical tree. Each leaf node of the tree represents a single, coherent connection attempt, with an Endpoint, a Path, and a set of protocols that can directly negotiate and send data on the network. Each node in the tree that is not a leaf represents a connection attempt that is either underspecified, or else includes multiple distinct options. For example. when connecting on an IP network, a connection attempt to a hostname and port is underspecified, because the connection attempt requires a resolved IP address as its remote endpoint. In this case, the node represented by the connection attempt to the hostname is a parent node, with child nodes for each IP address. Similarly, an implementation that is allowed to connect using multiple interfaces will have a parent node of the tree for the decision between the paths, with a branch for each interface.<a href="#section-4.1.2-1" class="pilcrow">¶</a></p>
<p id="section-4.1.2-2">The example aggregate connection attempt above can be drawn as a tree by grouping the addresses resolved on the same interface into branches:<a href="#section-4.1.2-2" class="pilcrow">¶</a></p>
<div class="artwork art-text alignLeft" id="section-4.1.2-3">
<pre>
                             ||
                +==========================+
                |  www.example.com:80/Any  |
                +==========================+
                  //                    \\
+==========================+       +==========================+
| www.example.com:80/Wi-Fi |       |  www.example.com:80/LTE  |
+==========================+       +==========================+
             ||                      //                    \\
  +====================+  +====================+  +======================+
  | 192.0.2.1:80/Wi-Fi |  |  192.0.2.1:80/LTE  |  |  2001:DB8::1.80/LTE  |
  +====================+  +====================+  +======================+
</pre><a href="#section-4.1.2-3" class="pilcrow">¶</a>
</div>
<p id="section-4.1.2-4">The rest of this section will use a notation scheme to represent this tree. The parent (or trunk) node of the tree will be represented by a single integer, such as "1". Each child of that node will have an integer that identifies it, from 1 to the number of children. That child node will be uniquely identified by concatenating its integer to it's parents identifier with a dot in between, such as "1.1" and "1.2". Each node will be summarized by a tuple of three elements: Endpoint, Path, and Protocol. The above example can now be written more succinctly as:<a href="#section-4.1.2-4" class="pilcrow">¶</a></p>
<div class="artwork art-text alignLeft" id="section-4.1.2-5">
<pre>
1 [www.example.com:80, Any, TCP]
  1.1 [www.example.com:80, Wi-Fi, TCP]
    1.1.1 [192.0.2.1:80, Wi-Fi, TCP]
  1.2 [www.example.com:80, LTE, TCP]
    1.2.1 [192.0.2.1:80, LTE, TCP]
    1.2.2 [2001:DB8::1.80, LTE, TCP]
</pre><a href="#section-4.1.2-5" class="pilcrow">¶</a>
</div>
<p id="section-4.1.2-6">When an implementation views this aggregate set of connection attempts as a single connection establishment, it only will use one of the leaf nodes to transfer data. Thus, when a single leaf node becomes ready to use, then the entire connection attempt is ready to use by the application. Another way to represent this is that every leaf node updates the state of its parent node when it becomes ready, until the trunk node of the tree is ready, which then notifies the application that the connection as a whole is ready to use.<a href="#section-4.1.2-6" class="pilcrow">¶</a></p>
<p id="section-4.1.2-7">A connection establishment tree may be degenerate, and only have a single leaf node, such as a connection attempt to an IP address over a single interface with a single protocol.<a href="#section-4.1.2-7" class="pilcrow">¶</a></p>
<div class="artwork art-text alignLeft" id="section-4.1.2-8">
<pre>
1 [192.0.2.1:80, Wi-Fi, TCP]
</pre><a href="#section-4.1.2-8" class="pilcrow">¶</a>
</div>
<p id="section-4.1.2-9">A parent node may also only have one child (or leaf) node, such as a when a hostname resolves to only a single IP address.<a href="#section-4.1.2-9" class="pilcrow">¶</a></p>
<div class="artwork art-text alignLeft" id="section-4.1.2-10">
<pre>
1 [www.example.com:80, Wi-Fi, TCP]
  1.1 [192.0.2.1:80, Wi-Fi, TCP]
</pre><a href="#section-4.1.2-10" class="pilcrow">¶</a>
</div>
</section>
</div>
<div id="branch-types">
<section id="section-4.1.3">
          <h4 id="name-branch-types">
<a href="#section-4.1.3" class="section-number selfRef">4.1.3. </a><a href="#name-branch-types" class="section-name selfRef">Branch Types</a>
          </h4>
<p id="section-4.1.3-1">There are three types of branching from a parent node into one or more child nodes. Any parent node of the tree must only use one type of branching.<a href="#section-4.1.3-1" class="pilcrow">¶</a></p>
<div id="derived-endpoints">
<section id="section-4.1.3.1">
            <h5 id="name-derived-endpoints">
<a href="#section-4.1.3.1" class="section-number selfRef">4.1.3.1. </a><a href="#name-derived-endpoints" class="section-name selfRef">Derived Endpoints</a>
            </h5>
<p id="section-4.1.3.1-1">If a connection originally targets a single endpoint, there may be multiple endpoints of different types that can be derived from the original. The connection library should order the derived endpoints according to application preference, system policy and expected performance.<a href="#section-4.1.3.1-1" class="pilcrow">¶</a></p>
<p id="section-4.1.3.1-2">DNS hostname-to-address resolution is the most common method of endpoint derivation. When trying to connect to a hostname endpoint on a traditional IP network, the implementation should send DNS queries for both A (IPv4) and AAAA (IPv6) records if both are supported on the local link. The algorithm for ordering and racing these addresses should follow the recommendations in Happy Eyeballs <span>[<a href="#RFC8305" class="xref">RFC8305</a>]</span>.<a href="#section-4.1.3.1-2" class="pilcrow">¶</a></p>
<div class="artwork art-text alignLeft" id="section-4.1.3.1-3">
<pre>
1 [www.example.com:80, Wi-Fi, TCP]
  1.1 [2001:DB8::1.80, Wi-Fi, TCP]
  1.2 [192.0.2.1:80, Wi-Fi, TCP]
  1.3 [2001:DB8::2.80, Wi-Fi, TCP]
  1.4 [2001:DB8::3.80, Wi-Fi, TCP]
</pre><a href="#section-4.1.3.1-3" class="pilcrow">¶</a>
</div>
<p id="section-4.1.3.1-4">DNS-Based Service Discovery can also provide an endpoint derivation step. When trying to connect to a named service, the client may discover one or more hostname and port pairs on the local network using multicast DNS. These hostnames should each be treated as a branch which can be attempted independently from other hostnames. Each of these hostnames may also resolve to one or more addresses, thus creating multiple layers of branching.<a href="#section-4.1.3.1-4" class="pilcrow">¶</a></p>
<div class="artwork art-text alignLeft" id="section-4.1.3.1-5">
<pre>
1 [term-printer._ipp._tcp.meeting.ietf.org, Wi-Fi, TCP]
  1.1 [term-printer.meeting.ietf.org:631, Wi-Fi, TCP]
    1.1.1 [31.133.160.18.631, Wi-Fi, TCP]
</pre><a href="#section-4.1.3.1-5" class="pilcrow">¶</a>
</div>
</section>
</div>
<div id="alternate-paths">
<section id="section-4.1.3.2">
            <h5 id="name-alternate-paths">
<a href="#section-4.1.3.2" class="section-number selfRef">4.1.3.2. </a><a href="#name-alternate-paths" class="section-name selfRef">Alternate Paths</a>
            </h5>
<p id="section-4.1.3.2-1">If a client has multiple network interfaces available to it, such as mobile client with both Wi-Fi and Cellular connectivity, it can attempt a connection over either interface. This represents a branch point in the connection establishment. Like with derived endpoints, the interfaces should be ranked based on preference, system policy, and performance. Attempts should be started on one interface, and then on other interfaces successively after delays based on expected round-trip-time or other available metrics.<a href="#section-4.1.3.2-1" class="pilcrow">¶</a></p>
<div class="artwork art-text alignLeft" id="section-4.1.3.2-2">
<pre>
1 [192.0.2.1:80, Any, TCP]
  1.1 [192.0.2.1:80, Wi-Fi, TCP]
  1.2 [192.0.2.1:80, LTE, TCP]
</pre><a href="#section-4.1.3.2-2" class="pilcrow">¶</a>
</div>
<p id="section-4.1.3.2-3">This same approach applies to any situation in which the client is aware of multiple links or views of the network. Multiple Paths, each with a coherent set of addresses, routes, DNS server, and more, may share a single interface. A path may also represent a virtual interface service such as a Virtual Private Network (VPN).<a href="#section-4.1.3.2-3" class="pilcrow">¶</a></p>
<p id="section-4.1.3.2-4">The list of available paths should be constrained by any requirements or prohibitions the application sets, as well as system policy.<a href="#section-4.1.3.2-4" class="pilcrow">¶</a></p>
</section>
</div>
<div id="protocol-options">
<section id="section-4.1.3.3">
            <h5 id="name-protocol-options">
<a href="#section-4.1.3.3" class="section-number selfRef">4.1.3.3. </a><a href="#name-protocol-options" class="section-name selfRef">Protocol Options</a>
            </h5>
<p id="section-4.1.3.3-1">Differences in possible protocol compositions and options can also provide a branching point in connection establishment. This allows clients to be resilient to situations in which a certain protocol is not functioning on a server or network.<a href="#section-4.1.3.3-1" class="pilcrow">¶</a></p>
<p id="section-4.1.3.3-2">This approach is commonly used for connections with optional proxy server configurations. A single connection may be allowed to use an HTTP-based proxy, a SOCKS-based proxy, or connect directly. These options should be ranked and attempted in succession.<a href="#section-4.1.3.3-2" class="pilcrow">¶</a></p>
<div class="artwork art-text alignLeft" id="section-4.1.3.3-3">
<pre>
1 [www.example.com:80, Any, HTTP/TCP]
  1.1 [192.0.2.8:80, Any, HTTP/HTTP Proxy/TCP]
  1.2 [192.0.2.7:10234, Any, HTTP/SOCKS/TCP]
  1.3 [www.example.com:80, Any, HTTP/TCP]
    1.3.1 [192.0.2.1:80, Any, HTTP/TCP]
</pre><a href="#section-4.1.3.3-3" class="pilcrow">¶</a>
</div>
<p id="section-4.1.3.3-4">This approach also allows a client to attempt different sets of application and transport protocols that may provide preferable characteristics when available. For example, the protocol options could involve QUIC <span>[<a href="#I-D.ietf-quic-transport" class="xref">I-D.ietf-quic-transport</a>]</span> over UDP on one branch, and HTTP/2 <span>[<a href="#RFC7540" class="xref">RFC7540</a>]</span> over TLS over TCP on the other:<a href="#section-4.1.3.3-4" class="pilcrow">¶</a></p>
<div class="artwork art-text alignLeft" id="section-4.1.3.3-5">
<pre>
1 [www.example.com:443, Any, Any HTTP]
  1.1 [www.example.com:443, Any, QUIC/UDP]
    1.1.1 [192.0.2.1:443, Any, QUIC/UDP]
  1.2 [www.example.com:443, Any, HTTP2/TLS/TCP]
    1.2.1 [192.0.2.1:443, Any, HTTP2/TLS/TCP]
</pre><a href="#section-4.1.3.3-5" class="pilcrow">¶</a>
</div>
<p id="section-4.1.3.3-6">Another example is racing SCTP with TCP:<a href="#section-4.1.3.3-6" class="pilcrow">¶</a></p>
<div class="artwork art-text alignLeft" id="section-4.1.3.3-7">
<pre>
1 [www.example.com:80, Any, Any Stream]
  1.1 [www.example.com:80, Any, SCTP]
    1.1.1 [192.0.2.1:80, Any, SCTP]
  1.2 [www.example.com:80, Any, TCP]
    1.2.1 [192.0.2.1:80, Any, TCP]
</pre><a href="#section-4.1.3.3-7" class="pilcrow">¶</a>
</div>
<p id="section-4.1.3.3-8">Implementations that support racing protocols and protocol options should maintain a history of which protocols and protocol options successfully established, on a per-network basis (see <a href="#performance-caches" class="xref">Section 9.2</a>). This information can influence future racing decisions to prioritize or prune branches.<a href="#section-4.1.3.3-8" class="pilcrow">¶</a></p>
</section>
</div>
</section>
</div>
</section>
</div>
<div id="branching-order-of-operations">
<section id="section-4.2">
        <h3 id="name-branching-order-of-operatio">
<a href="#section-4.2" class="section-number selfRef">4.2. </a><a href="#name-branching-order-of-operatio" class="section-name selfRef">Branching Order-of-Operations</a>
        </h3>
<p id="section-4.2-1">Branch types must occur in a specific order relative to one another to avoid creating leaf nodes with invalid or incompatible settings. In the example above, it would be invalid to branch for derived endpoints (the DNS results for www.example.com) before branching between interface paths, since usable DNS results on one network may not necessarily be the same as DNS results on another network due to local network entities, supported address families, or enterprise network configurations. Implementations must be careful to branch in an order that results in usable leaf nodes whenever there are multiple branch types that could be used from a single node.<a href="#section-4.2-1" class="pilcrow">¶</a></p>
<p id="section-4.2-2">The order of operations for branching, where lower numbers are acted upon first, should be:<a href="#section-4.2-2" class="pilcrow">¶</a></p>
<ol start="1" type="1" class="normal type-1" id="section-4.2-3">
          <li id="section-4.2-3.1">Alternate Paths<a href="#section-4.2-3.1" class="pilcrow">¶</a>
</li>
<li id="section-4.2-3.2">Protocol Options<a href="#section-4.2-3.2" class="pilcrow">¶</a>
</li>
<li id="section-4.2-3.3">Derived Endpoints<a href="#section-4.2-3.3" class="pilcrow">¶</a>
</li>
</ol>
<p id="section-4.2-4">Branching between paths is the first in the list because results across multiple interfaces are likely not related to one another: endpoint resolution may return different results, especially when using locally resolved host and service names, and which protocols are supported and preferred may differ across interfaces. Thus, if multiple paths are attempted, the overall connection can be seen as a race between the available paths or interfaces.<a href="#section-4.2-4" class="pilcrow">¶</a></p>
<p id="section-4.2-5">Protocol options are checked next in order. Whether or not a set of protocol, or protocol-specific options, can successfully connect is generally not dependent on which specific IP address is used. Furthermore, the protocol stacks being attempted may influence or altogether change the endpoints being used. Adding a proxy to a connection's branch will change the endpoint to the proxy's IP address or hostname. Choosing an alternate protocol may also modify the ports that should be selected.<a href="#section-4.2-5" class="pilcrow">¶</a></p>
<p id="section-4.2-6">Branching for derived endpoints is the final step, and may have multiple layers of derivation or resolution, such as DNS service resolution and DNS hostname resolution.<a href="#section-4.2-6" class="pilcrow">¶</a></p>
<p id="section-4.2-7">For example, if the application has indicated both a preference for WiFi over LTE and for a feature only available in SCTP, branches will be first sorted accord to path selection, with WiFi at the top. Then, branches with SCTP will be sorted to the top within their subtree according to the properties influencing protocol selection. However, if the implementation has cached the information that SCTP is not available on the path over WiFi, there is no SCTP node in the WiFi subtree. Here, the path over WiFi will be tried first, and, if connection establishment succeeds, TCP will be used. So the Selection Property of preferring WiFi takes precedence over the Property that led to a preference for SCTP.<a href="#section-4.2-7" class="pilcrow">¶</a></p>
<div class="artwork art-text alignLeft" id="section-4.2-8">
<pre>
1. [www.example.com:80, Any, Any Stream]
1.1 [192.0.2.1:80, Wi-Fi, Any Stream]
1.1.1 [192.0.2.1:80, Wi-Fi, TCP]
1.2 [192.0.3.1:80, LTE, Any Stream]
1.2.1 [192.0.3.1:80, LTE, SCTP]
1.2.2 [192.0.3.1:80, LTE, TCP]
</pre><a href="#section-4.2-8" class="pilcrow">¶</a>
</div>
</section>
</div>
<div id="branch-sorting">
<section id="section-4.3">
        <h3 id="name-sorting-branches">
<a href="#section-4.3" class="section-number selfRef">4.3. </a><a href="#name-sorting-branches" class="section-name selfRef">Sorting Branches</a>
        </h3>
<p id="section-4.3-1">Implementations should sort the branches of the tree of connection options in order of their preference rank.
Leaf nodes on branches with higher rankings represent connection attempts that will be raced first.
Implementations should order the branches to reflect the preferences expressed by the application for its new connection, including Selection Properties, which are specified in <span>[<a href="#I-D.ietf-taps-interface" class="xref">I-D.ietf-taps-interface</a>]</span>.<a href="#section-4.3-1" class="pilcrow">¶</a></p>
<p id="section-4.3-2">In addition to the properties provided by the application, an implementation may include additional criteria such as cached performance estimates, see <a href="#performance-caches" class="xref">Section 9.2</a>, or system policy, see <a href="#role-of-system-policy" class="xref">Section 3.2</a>, in the ranking.
Two examples of how Selection and Connection Properties may be used to sort branches are provided below:<a href="#section-4.3-2" class="pilcrow">¶</a></p>
<ul>
<li id="section-4.3-3.1">"Interface Instance or Type":
If the application specifies an interface type to be preferred or avoided, implementations should rank paths accordingly.
If the application specifies an interface type to be required or prohibited, we expect an implementation to not include the non-conforming paths into the three.<a href="#section-4.3-3.1" class="pilcrow">¶</a>
</li>
<li id="section-4.3-3.2">
            <p id="section-4.3-3.2.1">"Capacity Profile":
An implementation may use the Capacity Profile to prefer paths optimized for the application's expected traffic pattern according to cached performance estimates, see <a href="#performance-caches" class="xref">Section 9.2</a>:<a href="#section-4.3-3.2.1" class="pilcrow">¶</a></p>
<ul>
<li id="section-4.3-3.2.2.1">Scavenger:
Prefer paths with the highest expected available bandwidth, based on observed maximum throughput<a href="#section-4.3-3.2.2.1" class="pilcrow">¶</a>
</li>
<li id="section-4.3-3.2.2.2">Low Latency/Interactive:
Prefer paths with the lowest expected Round Trip Time<a href="#section-4.3-3.2.2.2" class="pilcrow">¶</a>
</li>
<li id="section-4.3-3.2.2.3">Constant-Rate Streaming:
Prefer paths that can satisfy the requested Stream Send or Stream Receive Bitrate, based on observed maximum throughput<a href="#section-4.3-3.2.2.3" class="pilcrow">¶</a>
</li>
</ul>
</li>
</ul>
<p id="section-4.3-4">Implementations should process properties in the following order: Prohibit, Require, Prefer, Avoid.
If Selection Properties contain any prohibited properties, the implementation should first purge branches containing nodes with these properties. For required properties, it should only keep branches that satisfy these requirements. Finally, it should order branches according to preferred properties, and finally use avoided properties as a tiebreaker.
When ordering branches, an implementation may give more weight to properties that the application has explicitly set than to properties that are default.<a href="#section-4.3-4" class="pilcrow">¶</a></p>
<p id="section-4.3-5">As the available protocols and paths on a specific system and in a specific context may vary, the result of sorting and the outcome of racing may vary even given the same Selection and Connection Properties. However, an implementation ought to aim to provide a consistent outcome to applications, e.g., by preferring protocols and paths that existing Connections with similar Properties are already using.<a href="#section-4.3-5" class="pilcrow">¶</a></p>
</section>
</div>
<div id="candidate-racing">
<section id="section-4.4">
        <h3 id="name-candidate-racing">
<a href="#section-4.4" class="section-number selfRef">4.4. </a><a href="#name-candidate-racing" class="section-name selfRef">Candidate Racing</a>
        </h3>
<p id="section-4.4-1">The primary goal of the Candidate Racing process is to successfully negotiate a protocol stack to an endpoint over an interface--to connect a single leaf node of the tree--with as little delay and as few unnecessary connections attempts as possible. Optimizing these two factors improves the user experience, while minimizing network load.<a href="#section-4.4-1" class="pilcrow">¶</a></p>
<p id="section-4.4-2">This section covers the dynamic aspect of connection establishment. While the tree described above is a useful conceptual and architectural model, an implementation does not know what the full tree may become up front, nor will many of the possible branches be used in the common case.<a href="#section-4.4-2" class="pilcrow">¶</a></p>
<p id="section-4.4-3">There are three different approaches to racing the attempts for different nodes of the connection establishment tree:<a href="#section-4.4-3" class="pilcrow">¶</a></p>
<ol start="1" type="1" class="normal type-1" id="section-4.4-4">
          <li id="section-4.4-4.1">Immediate<a href="#section-4.4-4.1" class="pilcrow">¶</a>
</li>
<li id="section-4.4-4.2">Delayed<a href="#section-4.4-4.2" class="pilcrow">¶</a>
</li>
<li id="section-4.4-4.3">Failover<a href="#section-4.4-4.3" class="pilcrow">¶</a>
</li>
</ol>
<p id="section-4.4-5">Each approach is appropriate in different use-cases and branch types. However, to avoid consuming unnecessary network resources, implementations should not use immediate racing as a default approach.<a href="#section-4.4-5" class="pilcrow">¶</a></p>
<p id="section-4.4-6">The timing algorithms for racing should remain independent across branches of the tree. Any timers or racing logic is isolated to a given parent node, and is not ordered precisely with regards to other children of other nodes.<a href="#section-4.4-6" class="pilcrow">¶</a></p>
<div id="delayed">
<section id="section-4.4.1">
          <h4 id="name-delayed">
<a href="#section-4.4.1" class="section-number selfRef">4.4.1. </a><a href="#name-delayed" class="section-name selfRef">Delayed</a>
          </h4>
<p id="section-4.4.1-1">Delayed racing can be used whenever a single node of the tree has multiple child nodes. Based on the order determined when building the tree, the first child node will be initiated immediately, followed by the next child node after some delay. Once that second child node is initiated, the third child node (if present) will begin after another delay, and so on until all child nodes have been initiated, or one of the child nodes successfully completes its negotiation.<a href="#section-4.4.1-1" class="pilcrow">¶</a></p>
<p id="section-4.4.1-2">Delayed racing attempts occur in parallel. Implementations should not terminate an earlier child connection attempt upon starting a secondary child.<a href="#section-4.4.1-2" class="pilcrow">¶</a></p>
<p id="section-4.4.1-3">The delay between starting child nodes should be based on the properties of the previously started child node. For example, if the first child represents an IP address with a known route, and the second child represents another IP address, the delay between starting the first and second IP addresses can be based on the expected retransmission cadence for the first child's connection (derived from historical round-trip-time). Alternatively, if the first child represents a branch on a Wi-Fi interface, and the second child represents a branch on an LTE interface, the delay should be based on the expected time in which the branch for the first interface would be able to establish a connection, based on link quality and historical round-trip-time.<a href="#section-4.4.1-3" class="pilcrow">¶</a></p>
<p id="section-4.4.1-4">Any delay should have a defined minimum and maximum value based on the branch type. Generally, branches between paths and protocols should have longer delays than branches between derived endpoints. The maximum delay should be considered with regards to how long a user is expected to wait for the connection to complete.<a href="#section-4.4.1-4" class="pilcrow">¶</a></p>
<p id="section-4.4.1-5">If a child node fails to connect before the delay timer has fired for the next child, the next child should be started immediately.<a href="#section-4.4.1-5" class="pilcrow">¶</a></p>
</section>
</div>
<div id="failover">
<section id="section-4.4.2">
          <h4 id="name-failover">
<a href="#section-4.4.2" class="section-number selfRef">4.4.2. </a><a href="#name-failover" class="section-name selfRef">Failover</a>
          </h4>
<p id="section-4.4.2-1">If an implementation or application has a strong preference for one branch over another, the branching node may choose to wait until one child has failed before starting the next. Failure of a leaf node is determined by its protocol negotiation failing or timing out; failure of a parent branching node is determined by all of its children failing.<a href="#section-4.4.2-1" class="pilcrow">¶</a></p>
<p id="section-4.4.2-2">An example in which failover is recommended is a race between a protocol stack that uses a proxy and a protocol stack that bypasses the proxy. Failover is useful in case the proxy is down or misconfigured, but any more aggressive type of racing may end up unnecessarily avoiding a proxy that was preferred by policy.<a href="#section-4.4.2-2" class="pilcrow">¶</a></p>
</section>
</div>
</section>
</div>
<div id="completing-establishment">
<section id="section-4.5">
        <h3 id="name-completing-establishment">
<a href="#section-4.5" class="section-number selfRef">4.5. </a><a href="#name-completing-establishment" class="section-name selfRef">Completing Establishment</a>
        </h3>
<p id="section-4.5-1">The process of connection establishment completes when one leaf node of the tree has completed negotiation with the remote endpoint successfully, or else all nodes of the tree have failed to connect. The first leaf node to complete its connection is then used by the application to send and receive data.<a href="#section-4.5-1" class="pilcrow">¶</a></p>
<p id="section-4.5-2">It is useful to process success and failure throughout the tree by child nodes reporting to their parent nodes (towards the trunk of the tree). For example, in the following case, if 1.1.1 fails to connect, it reports the failure to 1.1. Since 1.1 has no other child nodes, it also has failed and reports that failure to 1. Because 1.2 has not yet failed, 1 is not considered to have failed. Since 1.2 has not yet started, it is started and the process continues. Similarly, if 1.1.1 successfully connects, then it marks 1.1 as connected, which propagates to the trunk node 1. At this point, the connection as a whole is considered to be successfully connected and ready to process application data<a href="#section-4.5-2" class="pilcrow">¶</a></p>
<div class="artwork art-text alignLeft" id="section-4.5-3">
<pre>
1 [www.example.com:80, Any, TCP]
  1.1 [www.example.com:80, Wi-Fi, TCP]
    1.1.1 [192.0.2.1:80, Wi-Fi, TCP]
  1.2 [www.example.com:80, LTE, TCP]
...
</pre><a href="#section-4.5-3" class="pilcrow">¶</a>
</div>
<p id="section-4.5-4">If a leaf node has successfully completed its connection, all other attempts should be made ineligible for use by the application for the original request. New connection attempts that involve transmitting data on the network should not be started after another leaf node has completed successfully, as the connection as a whole has been established. An implementation may choose to let certain handshakes and negotiations complete in order to gather metrics to influence future connections. Similarly, an implementation may choose to hold onto fully established leaf nodes that were not the first to establish for use as part of a Pooled Connection, see <a href="#pooled-connections" class="xref">Section 7.1</a>, or in future connections. In both cases, keeping additional connections is generally not recommended since those attempts were slower to connect and may exhibit less desirable properties.<a href="#section-4.5-4" class="pilcrow">¶</a></p>
<div id="determining-successful-establishment">
<section id="section-4.5.1">
          <h4 id="name-determining-successful-esta">
<a href="#section-4.5.1" class="section-number selfRef">4.5.1. </a><a href="#name-determining-successful-esta" class="section-name selfRef">Determining Successful Establishment</a>
          </h4>
<p id="section-4.5.1-1">Implementations may select the criteria by which a leaf node is considered to be successfully connected differently on a per-protocol basis. If the only protocol being used is a transport protocol with a clear handshake, like TCP, then the obvious choice is to declare that node "connected" when the last packet of the three-way handshake has been received. If the only protocol being used is an "unconnected" protocol, like UDP, the implementation may consider the node fully "connected" the moment it determines a route is present, before sending any packets on the network, see further <a href="#unconnected-racing" class="xref">Section 4.7</a>.<a href="#section-4.5.1-1" class="pilcrow">¶</a></p>
<p id="section-4.5.1-2">For protocol stacks with multiple handshakes, the decision becomes more nuanced. If the protocol stack involves both TLS and TCP, an implementation could determine that a leaf node is connected after the TCP handshake is complete, or it can wait for the TLS handshake to complete as well. The benefit of declaring completion when the TCP handshake finishes, and thus stopping the race for other branches of the tree, is that there will be less burden on the network from other connection attempts. On the other hand, by waiting until the TLS handshake is complete, an implementation avoids the scenario in which a TCP handshake completes quickly, but TLS negotiation is either very slow or fails altogether in particular network conditions or to a particular endpoint. To avoid the issue of TLS possibly failing, the implementation should not generate a Ready event for the Connection until TLS is established.<a href="#section-4.5.1-2" class="pilcrow">¶</a></p>
<p id="section-4.5.1-3">If all of the leaf nodes fail to connect during racing, i.e. none of the configurations that satisfy all requirements given in the Transport Parameters actually work over the available paths, then the transport system should notify the application with an InitiateError event. An InitiateError event should also be generated in case the transport system finds no usable candidates to race.<a href="#section-4.5.1-3" class="pilcrow">¶</a></p>
</section>
</div>
</section>
</div>
<div id="establish-mux">
<section id="section-4.6">
        <h3 id="name-establishing-multiplexed-co">
<a href="#section-4.6" class="section-number selfRef">4.6. </a><a href="#name-establishing-multiplexed-co" class="section-name selfRef">Establishing multiplexed connections</a>
        </h3>
<p id="section-4.6-1">Multiplexing several Connections over a single underlying transport connection requires that the Connections to be multiplexed belong to the same Connection Group (as is indicated by the application using the Clone call). When the underlying transport connection supports multi-streaming, the Transport System can map each Connection in the Connection Group to a different stream.
Thus, when the Connections that are offered to an application by the Transport System are multiplexed,
the Transport System may implement the establishment of a new Connection by simply beginning to use
a new stream of an already established transport connection and there is no need for a connection establishment
procedure. This, then, also means that there may not
be any "establishment" message (like a TCP SYN), but the application can simply start sending
or receiving. Therefore, when the Initiate action of a Transport System is called without Messages being
handed over, it cannot be guaranteed that the other endpoint will have any way to know about this, and hence
a passive endpoint's ConnectionReceived event may not be called upon an active endpoint's Inititate.
Instead, calling the ConnectionReceived event may be delayed until the first Message arrives.<a href="#section-4.6-1" class="pilcrow">¶</a></p>
</section>
</div>
<div id="unconnected-racing">
<section id="section-4.7">
        <h3 id="name-handling-racing-with-unconn">
<a href="#section-4.7" class="section-number selfRef">4.7. </a><a href="#name-handling-racing-with-unconn" class="section-name selfRef">Handling racing with "unconnected" protocols</a>
        </h3>
<p id="section-4.7-1">While protocols that use an explicit handshake to validate a Connection to a peer can be used for racing multiple establishment attempts in parallel, "unconnected" protocols such as raw UDP do not offer a way to validate the presence of a peer or the usability of a Connection without application feedback. An implementation should consider such a protocol stack to be established as soon as a local route to the peer endpoint is confirmed.<a href="#section-4.7-1" class="pilcrow">¶</a></p>
<p id="section-4.7-2">However, if a peer is not reachable over the network using the unconnected protocol, or data cannot be exchanged for any other reason, the application may want to attempt using another candidate Protocol Stack. The implementation should maintain the list of other candidate Protocol Stacks that were eligible to use. In the case that the application signals that the initial Protocol Stack is failing for some reason and that another option should be attempted, the Connection can be updated to point to the next candidate Protocol Stack. This can be viewed as an application-driven form of Protocol Stack racing.<a href="#section-4.7-2" class="pilcrow">¶</a></p>
</section>
</div>
<div id="listen">
<section id="section-4.8">
        <h3 id="name-implementing-listeners">
<a href="#section-4.8" class="section-number selfRef">4.8. </a><a href="#name-implementing-listeners" class="section-name selfRef">Implementing listeners</a>
        </h3>
<p id="section-4.8-1">When an implementation is asked to Listen, it registers with the system to wait for incoming traffic to the Local Endpoint. If no Local Endpoint is specified, the implementation should either use an ephemeral port or generate an error.<a href="#section-4.8-1" class="pilcrow">¶</a></p>
<p id="section-4.8-2">If the Selection Properties do not require a single network interface or path, but allow the use of multiple paths, the Listener object should register for incoming traffic on all of the network interfaces or paths that conform to the Properties. The set of available paths can change over time, so the implementation should monitor network path changes and register and de-register the Listener across all usable paths. When using multiple paths, the Listener is generally expected to use the same port for listening on each.<a href="#section-4.8-2" class="pilcrow">¶</a></p>
<p id="section-4.8-3">If the Selection Properties allow multiple protocols to be used for listening, and the implementation supports it, the Listener object should register across the eligble protocols for each path. This means that inbound Connections delivered by the implementation may have heterogeneous protocol stacks.<a href="#section-4.8-3" class="pilcrow">¶</a></p>
<div id="implementing-listeners-for-connected-protocols">
<section id="section-4.8.1">
          <h4 id="name-implementing-listeners-for-">
<a href="#section-4.8.1" class="section-number selfRef">4.8.1. </a><a href="#name-implementing-listeners-for-" class="section-name selfRef">Implementing listeners for Connected Protocols</a>
          </h4>
<p id="section-4.8.1-1">Connected protocols such as TCP and TLS-over-TCP have a strong mapping between the Local and Remote Endpoints (five-tuple) and their protocol connection state. These map well into Connection objects. Whenever a new inbound handshake is being started, the Listener should generate a new Connection object and pass it to the application.<a href="#section-4.8.1-1" class="pilcrow">¶</a></p>
</section>
</div>
<div id="implementing-listeners-for-unconnected-protocols">
<section id="section-4.8.2">
          <h4 id="name-implementing-listeners-for-u">
<a href="#section-4.8.2" class="section-number selfRef">4.8.2. </a><a href="#name-implementing-listeners-for-u" class="section-name selfRef">Implementing listeners for Unconnected Protocols</a>
          </h4>
<p id="section-4.8.2-1">Unconnected protocols such as UDP and UDP-lite generally do not provide the same mechanisms that connected protocols do to offer Connection objects. Implementations should wait for incoming packets for unconnected protocols on a listening port and should perform five-tuple matching of packets to either existing Connection objects or the creation of new Connection objects. On platforms with facilities to create a "virtual connection" for unconnected protocols implementations should use these mechanisms to minimise the handling of datagrams intended for already created Connection objects.<a href="#section-4.8.2-1" class="pilcrow">¶</a></p>
</section>
</div>
<div id="implementing-listeners-for-multiplexed-protocols">
<section id="section-4.8.3">
          <h4 id="name-implementing-listeners-for-m">
<a href="#section-4.8.3" class="section-number selfRef">4.8.3. </a><a href="#name-implementing-listeners-for-m" class="section-name selfRef">Implementing listeners for Multiplexed Protocols</a>
          </h4>
<p id="section-4.8.3-1">Protocols that provide multiplexing of streams into a single five-tuple can listen both for entirely new connections (a new HTTP/2 stream on a new TCP connection, for example) and for new sub-connections (a new HTTP/2 stream on an existing connection). If the abstraction of Connection presented to the application is mapped to the multiplexed stream, then the Listener should deliver new Connection objects in the same way for either case. The implementation should allow the application to introspect the Connection Group marked on the Connections to determine the grouping of the multiplexing.<a href="#section-4.8.3-1" class="pilcrow">¶</a></p>
</section>
</div>
</section>
</div>
</section>
</div>
<div id="implementing-sending-and-receiving-data">
<section id="section-5">
      <h2 id="name-implementing-sending-and-re">
<a href="#section-5" class="section-number selfRef">5. </a><a href="#name-implementing-sending-and-re" class="section-name selfRef">Implementing Sending and Receiving Data</a>
      </h2>
<p id="section-5-1">The most basic mapping for sending a Message is an abstraction of datagrams, in which the transport protocol naturally deals in discrete packets. Each Message here corresponds to a single datagram. Generally, these will be short enough that sending and receiving will always use a complete Message.<a href="#section-5-1" class="pilcrow">¶</a></p>
<p id="section-5-2">For protocols that expose byte-streams, the only delineation provided by the protocol is the end of the stream in a given direction. Each Message in this case corresponds to the entire stream of bytes in a direction. These Messages may be quite long, in which case they can be sent in multiple parts.<a href="#section-5-2" class="pilcrow">¶</a></p>
<p id="section-5-3">Protocols that provide the framing (such as length-value protocols, or protocols that use delimiters) provide data boundaries that may be longer than a traditional packet datagram. Each Message for framing protocols corresponds to a single frame, which may be sent either as a complete Message, or in multiple parts.<a href="#section-5-3" class="pilcrow">¶</a></p>
<div id="sending-messages">
<section id="section-5.1">
        <h3 id="name-sending-messages">
<a href="#section-5.1" class="section-number selfRef">5.1. </a><a href="#name-sending-messages" class="section-name selfRef">Sending Messages</a>
        </h3>
<p id="section-5.1-1">The effect of the application sending a Message is determined by the top-level protocol in the established Protocol Stack. That is, if the top-level protocol provides an abstraction of framed messages over a connection, the receiving application will be able to obtain multiple Messages on that connection, even if the framing protocol is built on a byte-stream protocol like TCP.<a href="#section-5.1-1" class="pilcrow">¶</a></p>
<div id="msg-properties">
<section id="section-5.1.1">
          <h4 id="name-message-properties">
<a href="#section-5.1.1" class="section-number selfRef">5.1.1. </a><a href="#name-message-properties" class="section-name selfRef">Message Properties</a>
          </h4>
<ul>
<li id="section-5.1.1-1.1">Lifetime: this should be implemented by removing the Message from its queue of pending Messages after the Lifetime has expired. A queue of pending Messages within the transport system implementation that have yet to be handed to the Protocol Stack can always support this property, but once a Message has been sent into the send buffer of a protocol, only certain protocols may support de-queueing a message. For example, TCP cannot remove bytes from its send buffer, while in case of SCTP, such control over the SCTP send buffer can be exercised using the partial reliability extension <span>[<a href="#RFC8303" class="xref">RFC8303</a>]</span>. When there is no standing queue of Messages within the system, and the Protocol Stack does not support removing a Message from its buffer, this property may be ignored.<a href="#section-5.1.1-1.1" class="pilcrow">¶</a>
</li>
<li id="section-5.1.1-1.2">Priority: this represents the ability to prioritize a Message over other Messages. This can be implemented by the system re-ordering Messages that have yet to be handed to the Protocol Stack, or by giving relative priority hints to protocols that support priorities per Message. For example, an implementation of HTTP/2 could choose to send Messages of different Priority on streams of different priority.<a href="#section-5.1.1-1.2" class="pilcrow">¶</a>
</li>
<li id="section-5.1.1-1.3">Ordered: when this is false, it disables the requirement of in-order-delivery for protocols that support configurable ordering.<a href="#section-5.1.1-1.3" class="pilcrow">¶</a>
</li>
<li id="section-5.1.1-1.4">Idempotent: when this is true, it means that the Message can be used by mechanisms that might transfer it multiple times - e.g., as a result of racing multiple transports or as part of TCP Fast Open.<a href="#section-5.1.1-1.4" class="pilcrow">¶</a>
</li>
<li id="section-5.1.1-1.5">Final: when this is true, it means that a transport connection can be closed immediately after its transmission.<a href="#section-5.1.1-1.5" class="pilcrow">¶</a>
</li>
<li id="section-5.1.1-1.6">Corruption Protection Length: when this is set to any value other than -1, it limits the required checksum in protocols that allow limiting the checksum length (e.g. UDP-Lite).<a href="#section-5.1.1-1.6" class="pilcrow">¶</a>
</li>
<li id="section-5.1.1-1.7">Transmission Profile: TBD - because it's not final in the API yet.  Old text follows: when this is set to "Interactive/Low Latency", the Message should be sent immediately, even when this comes at the cost of using the network capacity less efficiently. For example, small messages can sometimes be bundled to fit into a single data packet for the sake of reducing header overhead; such bundling should not be used. For example, in case of TCP, the Nagle algorithm should be disabled when Interactive/Low Latency is selected as the capacity profile. Scavenger/Bulk can translate into usage of a congestion control mechanism such as LEDBAT, and/or the capacity profile can lead to a choice of a DSCP value as described in <span>[<a href="#I-D.ietf-taps-minset" class="xref">I-D.ietf-taps-minset</a>]</span>).<a href="#section-5.1.1-1.7" class="pilcrow">¶</a>
</li>
<li id="section-5.1.1-1.8">Singular Transmission: when this is true, the application requests to avoid transport-layer segmentation or network-layer fragmentation. Some transports implement network-layer fragmentation avoidance (Path MTU Discovery) without exposing this functionality to the application; in this case, only transport-layer segmentation should be avoided, by fitting the message into a single transport-layer segment or otherwise failing. Otherwise, network-layer fragmentation should be avoided--e.g. by requesting the IP Don't Fragment bit to be set in case of UDP(-Lite) and IPv4 (SET_DF in <span>[<a href="#RFC8304" class="xref">RFC8304</a>]</span>).<a href="#section-5.1.1-1.8" class="pilcrow">¶</a>
</li>
</ul>
</section>
</div>
<div id="send-completion">
<section id="section-5.1.2">
          <h4 id="name-send-completion">
<a href="#section-5.1.2" class="section-number selfRef">5.1.2. </a><a href="#name-send-completion" class="section-name selfRef">Send Completion</a>
          </h4>
<p id="section-5.1.2-1">The application should be notified whenever a Message or partial Message has been consumed by the Protocol Stack, or has failed to send. The meaning of the Message being consumed by the stack may vary depending on the protocol. For a basic datagram protocol like UDP, this may correspond to the time when the packet is sent into the interface driver. For a protocol that buffers data in queues, like TCP, this may correspond to when the data has entered the send buffer.<a href="#section-5.1.2-1" class="pilcrow">¶</a></p>
</section>
</div>
<div id="batching-sends">
<section id="section-5.1.3">
          <h4 id="name-batching-sends">
<a href="#section-5.1.3" class="section-number selfRef">5.1.3. </a><a href="#name-batching-sends" class="section-name selfRef">Batching Sends</a>
          </h4>
<p id="section-5.1.3-1">Since sending a Message may involve a context switch between the application and the transport system, sending patterns that involve multiple small Messages can incur high overhead if each needs to be enqueued separately. To avoid this, the application should have a way to indicate a batch of Send actions, during which time the implementation will hold off on processing Messages until the batch is complete. This can also help context switches when enqueuing data in the interface driver if the operation can be batched.<a href="#section-5.1.3-1" class="pilcrow">¶</a></p>
</section>
</div>
</section>
</div>
<div id="receiving-messages">
<section id="section-5.2">
        <h3 id="name-receiving-messages">
<a href="#section-5.2" class="section-number selfRef">5.2. </a><a href="#name-receiving-messages" class="section-name selfRef">Receiving Messages</a>
        </h3>
<p id="section-5.2-1">Similar to sending, Receiving a Message is determined by the top-level protocol in the established Protocol Stack. The main difference with Receiving is that the size and boundaries of the Message are not known beforehand. The application can communicate in its Receive action the parameters for the Message, which can help the implementation know how much data to deliver and when. For example, if the application only wants to receive a complete Message, the implementation should wait until an entire Message (datagram, stream, or frame) is read before delivering any Message content to the application. This requires the implementation to understand where messages end, either via a supplied deframer or because the top-level protocol in the established Protocol Stack preserves message boundaries; if, on the other hand, the top-level protocol only supports a byte-stream and no deframers were supported, the application must specify the minimum number of bytes of Message content it wants to receive (which may be just a single byte) to control the flow of received data.<a href="#section-5.2-1" class="pilcrow">¶</a></p>
<p id="section-5.2-2">If a Connection becomes finished before a requested Receive action can be satisfied, the implementation should deliver any partial Message content outstanding, or if none is available, an indication that there will be no more received Messages.<a href="#section-5.2-2" class="pilcrow">¶</a></p>
</section>
</div>
<div id="fastopen">
<section id="section-5.3">
        <h3 id="name-handling-of-data-for-fast-o">
<a href="#section-5.3" class="section-number selfRef">5.3. </a><a href="#name-handling-of-data-for-fast-o" class="section-name selfRef">Handling of data for fast-open protocols</a>
        </h3>
<p id="section-5.3-1">Several protocols allow sending higher-level protocol or application data within the first packet of their protocol establishment, such as TCP Fast Open <span>[<a href="#RFC7413" class="xref">RFC7413</a>]</span> and TLS 1.3 <span>[<a href="#RFC8446" class="xref">RFC8446</a>]</span>. This approach is referred to as sending Zero-RTT (0-RTT) data. This is a desirable property, but poses challenges to an implementation that uses racing during connection establishment.<a href="#section-5.3-1" class="pilcrow">¶</a></p>
<p id="section-5.3-2">If the application has 0-RTT data to send in any protocol handshakes, it needs to provide this data before the handshakes have begun. When racing, this means that the data should be provided before the process of connection establishment has begun. If the application wants to send 0-RTT data, it must indicate this to the implementation by setting the Idempotent send parameter to true when sending the data. In general, 0-RTT data may be replayed (for example, if a TCP SYN contains data, and the SYN is retransmitted, the data will be retransmitted as well), but racing means that different leaf nodes have the opportunity to send the same data independently. If data is truly idempotent, this should be permissible.<a href="#section-5.3-2" class="pilcrow">¶</a></p>
<p id="section-5.3-3">Once the application has provided its 0-RTT data, an implementation should keep a copy of this data and provide it to each new leaf node that is started and for which a 0-RTT protocol is being used.<a href="#section-5.3-3" class="pilcrow">¶</a></p>
<p id="section-5.3-4">It is also possible that protocol stacks within a particular leaf node use 0-RTT handshakes without any idempotent application data. For example, TCP Fast Open could use a Client Hello from TLS as its 0-RTT data, shortening the cumulative handshake time.<a href="#section-5.3-4" class="pilcrow">¶</a></p>
<p id="section-5.3-5">0-RTT handshakes often rely on previous state, such as TCP Fast Open cookies, previously established TLS tickets, or out-of-band distributed pre-shared keys (PSKs). Implementations should be aware of security concerns around using these tokens across multiple addresses or paths when racing. In the case of TLS, any given ticket or PSK should only be used on one leaf node. If implementations have multiple tickets available from a previous connection, each leaf node attempt must use a different ticket. In effect, each leaf node will send the same early application data, yet encoded (encrypted) differently on the wire.<a href="#section-5.3-5" class="pilcrow">¶</a></p>
</section>
</div>
</section>
</div>
<div id="implementing-message-framers">
<section id="section-6">
      <h2 id="name-implementing-message-framer">
<a href="#section-6" class="section-number selfRef">6. </a><a href="#name-implementing-message-framer" class="section-name selfRef">Implementing Message Framers</a>
      </h2>
<p id="section-6-1">Message Framers are pieces of code that define simple transformations
between application Message data and raw transport protocol data. A Framer
can encapsulate or encode outbound Messages, and decapsulate or decode
inbound data into Messages.<a href="#section-6-1" class="pilcrow">¶</a></p>
<p id="section-6-2">While many protocols can be represented as Message Framers, for the
purposes of the Transport Services interface these are ways for applications
or application frameworks to define their own Message parsing to be
included within a Connection's Protocol Stack. As an example, TLS can
serve the purpose of framing data over TCP, but is exposed as a protocol
natively supported by the Transport Services interface.<a href="#section-6-2" class="pilcrow">¶</a></p>
<p id="section-6-3">Most Message Framers fall into one of two categories:<a href="#section-6-3" class="pilcrow">¶</a></p>
<ul>
<li id="section-6-4.1">Header-prefixed record formats, such as a basic Type-Length-Value (TLV) structure<a href="#section-6-4.1" class="pilcrow">¶</a>
</li>
<li id="section-6-4.2">Delimiter-separated formats, such as HTTP/1.1.<a href="#section-6-4.2" class="pilcrow">¶</a>
</li>
</ul>
<p id="section-6-5">Common Message Framers can be provided by the Transport Services implementation,
but an implementation ought to allow custom Message Framers to be defined by
the application or some other piece of software. This section describes one
possible interface for defining Message Framers as an example.<a href="#section-6-5" class="pilcrow">¶</a></p>
<div id="defining-message-framers">
<section id="section-6.1">
        <h3 id="name-defining-message-framers">
<a href="#section-6.1" class="section-number selfRef">6.1. </a><a href="#name-defining-message-framers" class="section-name selfRef">Defining Message Framers</a>
        </h3>
<p id="section-6.1-1">A Message Framer is primarily defined by the set of code that handles events
for a framer implementation, specifically how it handles inbound and outbound data
parsing. The piece of code that implements custom framing logic will be referred to
as the "framer implementation", which may be provided by the Transport Services
implementation or the application itself. The Message Framer refers to the object
or piece of code within the main Connection implementation that delivers events
to the custom framer implementation whenever data is ready to be parsed or framed.<a href="#section-6.1-1" class="pilcrow">¶</a></p>
<p id="section-6.1-2">When a Connection establishment attempt begins, an event can be delivered to
notify the framer implementation that a new Connection is being created.
Similarly, a stop event can be delivered when a Connection is being torn down.
The framer implementation can use the Connection object to look up specific
properties of the Connection or the network being used that may influence how
to frame Messages.<a href="#section-6.1-2" class="pilcrow">¶</a></p>
<div class="artwork art-text alignLeft" id="section-6.1-3">
<pre>
MessageFramer -&gt; Start(Connection)
MessageFramer -&gt; Stop(Connection)
</pre><a href="#section-6.1-3" class="pilcrow">¶</a>
</div>
<p id="section-6.1-4">When a Message Framer generates a <code>Start</code> event, the framer implementation
has the opportunity to start writing some data prior to the Connection delivering
its <code>Ready</code> event. This allows the implementation to communicate control data to the
remote endpoint that can be used to parse Messages.<a href="#section-6.1-4" class="pilcrow">¶</a></p>
<div class="artwork art-text alignLeft" id="section-6.1-5">
<pre>
MessageFramer.MakeConnectionReady(Connection)
</pre><a href="#section-6.1-5" class="pilcrow">¶</a>
</div>
<p id="section-6.1-6">Similarly, when a Message Framer generates a <code>Stop</code> event, the framer implementation has the opportunity to write some final data or clear up its local state before the <code>Closed</code> event is delivered to the Application. The framer implementation can indicate that it has finished with this.<a href="#section-6.1-6" class="pilcrow">¶</a></p>
<div class="artwork art-text alignLeft" id="section-6.1-7">
<pre>
MessageFramer.MakeConnectionClosed(Connection)
</pre><a href="#section-6.1-7" class="pilcrow">¶</a>
</div>
<p id="section-6.1-8">At any time if the implementation encounters a fatal error, it can also cause the Connection
to fail and provide an error.<a href="#section-6.1-8" class="pilcrow">¶</a></p>
<div class="artwork art-text alignLeft" id="section-6.1-9">
<pre>
MessageFramer.FailConnection(Connection, Error)
</pre><a href="#section-6.1-9" class="pilcrow">¶</a>
</div>
<p id="section-6.1-10">Should the framer implementation deem the candidate selected during racing unsuitable it can signal this by failing the Connection prior to marking it as ready.
If there are no other candidates available, the Connection will fail. Otherwise, the Connection will select a different candidate and the Message Framer will generate a new <code>Start</code> event.<a href="#section-6.1-10" class="pilcrow">¶</a></p>
<p id="section-6.1-11">Before an implementation marks a Message Framer as ready, it can also dynamically
add a protocol or framer above it in the stack. This allows protocols like STARTTLS,
that need to add TLS conditionally, to modify the Protocol Stack based on a handshake result.<a href="#section-6.1-11" class="pilcrow">¶</a></p>
<div class="artwork art-text alignLeft" id="section-6.1-12">
<pre>
otherFramer := NewMessageFramer()
MessageFramer.PrependFramer(Connection, otherFramer)
</pre><a href="#section-6.1-12" class="pilcrow">¶</a>
</div>
</section>
</div>
<div id="send-framing">
<section id="section-6.2">
        <h3 id="name-sender-side-message-framing">
<a href="#section-6.2" class="section-number selfRef">6.2. </a><a href="#name-sender-side-message-framing" class="section-name selfRef">Sender-side Message Framing</a>
        </h3>
<p id="section-6.2-1">Message Framers generate an event whenever a Connection sends a new Message.<a href="#section-6.2-1" class="pilcrow">¶</a></p>
<div class="artwork art-text alignLeft" id="section-6.2-2">
<pre>
MessageFramer -&gt; NewSentMessage&lt;Connection, MessageData, MessageContext, IsEndOfMessage&gt;
</pre><a href="#section-6.2-2" class="pilcrow">¶</a>
</div>
<p id="section-6.2-3">Upon receiving this event, a framer implementation is responsible for
performing any necessary transformations and sending the resulting data back to the Message Framer, which will in turn send it to the next protocol. Implementations SHOULD ensure that there is a way to pass the original data
through without copying to improve performance.<a href="#section-6.2-3" class="pilcrow">¶</a></p>
<div class="artwork art-text alignLeft" id="section-6.2-4">
<pre>
MessageFramer.Send(Connection, Data)
</pre><a href="#section-6.2-4" class="pilcrow">¶</a>
</div>
<p id="section-6.2-5">To provide an example, a simple protocol that adds a length as a header would receive
the <code>NewSentMessage</code> event, create a data representation of the length of the Message
data, and then send a block of data that is the concatenation of the length header and the original
Message data.<a href="#section-6.2-5" class="pilcrow">¶</a></p>
</section>
</div>
<div id="receive-framing">
<section id="section-6.3">
        <h3 id="name-receiver-side-message-frami">
<a href="#section-6.3" class="section-number selfRef">6.3. </a><a href="#name-receiver-side-message-frami" class="section-name selfRef">Receiver-side Message Framing</a>
        </h3>
<p id="section-6.3-1">In order to parse a received flow of data into Messages, the Message Framer
notifies the framer implementation whenever new data is available to parse.<a href="#section-6.3-1" class="pilcrow">¶</a></p>
<div class="artwork art-text alignLeft" id="section-6.3-2">
<pre>
MessageFramer -&gt; HandleReceivedData&lt;Connection&gt;
</pre><a href="#section-6.3-2" class="pilcrow">¶</a>
</div>
<p id="section-6.3-3">Upon receiving this event, the framer implementation can inspect the inbound data. The
data is parsed from a particular cursor representing the unprocessed data. The
application requests a specific amount of data it needs to have available in order to parse.
If the data is not available, the parse fails.<a href="#section-6.3-3" class="pilcrow">¶</a></p>
<div class="artwork art-text alignLeft" id="section-6.3-4">
<pre>
MessageFramer.Parse(Connection, MinimumIncompleteLength, MaximumLength) -&gt; (Data, MessageContext, IsEndOfMessage)
</pre><a href="#section-6.3-4" class="pilcrow">¶</a>
</div>
<p id="section-6.3-5">The framer implementation can directly advance the receive cursor once it has
parsed data to effectively discard data (for example, discard a header
once the content has been parsed).<a href="#section-6.3-5" class="pilcrow">¶</a></p>
<p id="section-6.3-6">To deliver a Message to the application, the framer implementation can either directly
deliver data that it has allocated, or deliver a range of data directly from the underlying
transport and simultaneously advance the receive cursor.<a href="#section-6.3-6" class="pilcrow">¶</a></p>
<div class="artwork art-text alignLeft" id="section-6.3-7">
<pre>
MessageFramer.AdvanceReceiveCursor(Connection, Length)
MessageFramer.DeliverAndAdvanceReceiveCursor(Connection, MessageContext, Length, IsEndOfMessage)
MessageFramer.Deliver(Connection, MessageContext, Data, IsEndOfMessage)
</pre><a href="#section-6.3-7" class="pilcrow">¶</a>
</div>
<p id="section-6.3-8">Note that <code>MessageFramer.DeliverAndAdvanceReceiveCursor</code> allows the framer implementation
to earmark bytes as part of a Message even before they are received by the transport. This allows the delivery
of very large Messages without requiring the implementation to directly inspect all of the bytes.<a href="#section-6.3-8" class="pilcrow">¶</a></p>
<p id="section-6.3-9">To provide an example, a simple protocol that parses a length as a header value would
receive the <code>HandleReceivedData</code> event, and call <code>Parse</code> with a minimum and maximum
set to the length of the header field. Once the parse succeeded, it would call
<code>AdvanceReceiveCursor</code> with the length of the header field, and then call
<code>DeliverAndAdvanceReceiveCursor</code> with the length of the body that was parsed from
the header, marking the new Message as complete.<a href="#section-6.3-9" class="pilcrow">¶</a></p>
</section>
</div>
</section>
</div>
<div id="implementing-connection-management">
<section id="section-7">
      <h2 id="name-implementing-connection-man">
<a href="#section-7" class="section-number selfRef">7. </a><a href="#name-implementing-connection-man" class="section-name selfRef">Implementing Connection Management</a>
      </h2>
<p id="section-7-1">Once a Connection is established, the Transport Services system allows applications to interact with the Connection by modifying or inspecting
Connection Properties. A Connection can also generate events in the form of Soft Errors.<a href="#section-7-1" class="pilcrow">¶</a></p>
<p id="section-7-2">The set of Connection Properties that are supported for setting and getting on a Connection are described in <span>[<a href="#I-D.ietf-taps-interface" class="xref">I-D.ietf-taps-interface</a>]</span>. For
any properties that are generic, and thus could apply to all protocols being used by a Connection, the Transport System should store the properties
in a generic storage, and notify all protocol instances in the Protocol Stack whenever the properties have been modified by the application.
For protocol-specfic properties, such as the User Timeout that applies to TCP, the Transport System only needs to update the relevant protocol instance.<a href="#section-7-2" class="pilcrow">¶</a></p>
<p id="section-7-3">If an error is encountered in setting a property (for example, if the application tries to set a TCP-specific property on a Connection that is
not using TCP), the action should fail gracefully. The application may be informed of the error, but the Connection itself should not be terminated.<a href="#section-7-3" class="pilcrow">¶</a></p>
<p id="section-7-4">The Transport Services implementation should allow protocol instances in the Protocol Stack to pass up arbitrary generic or protocol-specific
errors that can be delivered to the application as Soft Errors. These allow the application to be informed of ICMP errors, and other similar events.<a href="#section-7-4" class="pilcrow">¶</a></p>
<div id="pooled-connections">
<section id="section-7.1">
        <h3 id="name-pooled-connection">
<a href="#section-7.1" class="section-number selfRef">7.1. </a><a href="#name-pooled-connection" class="section-name selfRef">Pooled Connection</a>
        </h3>
<p id="section-7.1-1">For protocols that employ request/response pairs and do not require in-order delivery of the responses, like HTTP, the transport implementation may distribute interactions across several underlying transport connections. 
For these kinds of protocols, implementations may hide the connection management and only expose a single Connection object and the individual requests/responses as messages.
These Pooled Connections can use multiple connections or multiple streams of multi-streaming connections between endpoints, as long as all of these satisfy the requirements, and prohibitions specified in the Selection Properties of the Pooled Connection. 
This enables implementations to realize transparent connection coalescing, connection migration, and to perform per-message endpoint and path selection by choosing among these underlying connections.<a href="#section-7.1-1" class="pilcrow">¶</a></p>
</section>
</div>
<div id="handling-path-changes">
<section id="section-7.2">
        <h3 id="name-handling-path-changes">
<a href="#section-7.2" class="section-number selfRef">7.2. </a><a href="#name-handling-path-changes" class="section-name selfRef">Handling Path Changes</a>
        </h3>
<p id="section-7.2-1">When a path change occurs, the Transport Services implementation is responsible for notifying Protocol Instances in the Protocol Stack.
If the Protocol Stack includes a transport protocol that supports multipath connectivity, an update to the available paths should inform the Protocol Instance of the new set of paths that are permissible based on the Selection Properties passed by the application. A multipath protocol can establish new subflows over new paths, and should tear down subflows over paths that are no longer available. Pooled Connections <a href="#pooled-connections" class="xref">Section 7.1</a> may add or remove underlying transport connections in a similar manner. If the Protocol Stack includes a transport protocol that does not support multipath, but support migrating between paths, the update to available paths can be used as the trigger to migrating the connection. For protocols that do not support multipath or migration, the Protocol Instances may be informed of the path change, but should not be forcibly disconnected if the previously used path becomes unavailable. An exception to this case is if the System Policy changes to prohibit traffic from the Connection based on its properties, in which case the Protocol Stack should be disconnected.<a href="#section-7.2-1" class="pilcrow">¶</a></p>
</section>
</div>
</section>
</div>
<div id="implementing-connection-termination">
<section id="section-8">
      <h2 id="name-implementing-connection-ter">
<a href="#section-8" class="section-number selfRef">8. </a><a href="#name-implementing-connection-ter" class="section-name selfRef">Implementing Connection Termination</a>
      </h2>
<p id="section-8-1">With TCP, when an application closes a connection, this
means that it has no more data to send (but expects all data that has been
handed over to be reliably delivered). However, with TCP only, "close" does
not mean that the application will stop receiving data. This is related to TCP's ability to
support half-closed connections.<a href="#section-8-1" class="pilcrow">¶</a></p>
<p id="section-8-2">SCTP is an example of a protocol that does not support such half-closed connections.
Hence, with SCTP, the meaning of "close" is stricter: an application has no more data
to send (but expects all data that has been handed over to be reliably delivered), and will
also not receive any more data.<a href="#section-8-2" class="pilcrow">¶</a></p>
<p id="section-8-3">Implementing a protocol independent transport system means that the exposed
semantics must be the strictest subset of the semantics of all supported protocols.
Hence, as is common with all reliable transport protocols, after a Close action, the
application can expect to have its reliability requirements honored regarding the data
it has given to the Transport System, but it cannot expect to be able to read any
more data after calling Close.<a href="#section-8-3" class="pilcrow">¶</a></p>
<p id="section-8-4">Abort differs from Close only in that no guarantees are given regarding data
that the application has handed over to the Transport System before calling Abort.<a href="#section-8-4" class="pilcrow">¶</a></p>
<p id="section-8-5">As explained in <a href="#establish-mux" class="xref">Section 4.6</a>, when a new stream is multiplexed on an already
existing connection of a Transport Protocol Instance, there is no need for a connection
establishment procedure. Because the Connections that are offered by the Transport System
can be implemented as streams that are multiplexed on a transport protocol's connection,
it can therefore not be guaranteed that one Endpoint's Initiate action
provokes a ConnectionReceived event at its peer.<a href="#section-8-5" class="pilcrow">¶</a></p>
<p id="section-8-6">For Close (provoking a Finished event) and Abort (provoking a ConnectionError event), the
same logic applies: while it is desirable to be informed when a peer closes or aborts a
Connection, whether this is possible depends on the underlying protocol, and no guarantees
can be given. With SCTP, the transport system can use the stream reset procedure to cause
a Finish event upon a Close action from the peer <span>[<a href="#NEAT-flow-mapping" class="xref">NEAT-flow-mapping</a>]</span>.<a href="#section-8-6" class="pilcrow">¶</a></p>
</section>
</div>
<div id="cached-state">
<section id="section-9">
      <h2 id="name-cached-state">
<a href="#section-9" class="section-number selfRef">9. </a><a href="#name-cached-state" class="section-name selfRef">Cached State</a>
      </h2>
<p id="section-9-1">Beyond a single Connection's lifetime, it is useful for an implementation to keep state and history. This cached
state can help improve future Connection establishment due to re-using results and credentials, and favoring paths and protocols that performed well in the past.<a href="#section-9-1" class="pilcrow">¶</a></p>
<p id="section-9-2">Cached state may be associated with different Endpoints for the same Connection, depending on the protocol generating the cached content.
For example, session tickets for TLS are associated with specific endpoints, and thus should be cached based on a Connection's
hostname Endpoint (if applicable). On the other hand, performance characteristics of a path are more likely tied to the IP address
and subnet being used.<a href="#section-9-2" class="pilcrow">¶</a></p>
<div id="protocol-state-caches">
<section id="section-9.1">
        <h3 id="name-protocol-state-caches">
<a href="#section-9.1" class="section-number selfRef">9.1. </a><a href="#name-protocol-state-caches" class="section-name selfRef">Protocol state caches</a>
        </h3>
<p id="section-9.1-1">Some protocols will have long-term state to be cached in association with Endpoints. This state often has some time after which
it is expired, so the implementation should allow each protocol to specify an expiration for cached content.<a href="#section-9.1-1" class="pilcrow">¶</a></p>
<p id="section-9.1-2">Examples of cached protocol state include:<a href="#section-9.1-2" class="pilcrow">¶</a></p>
<ul>
<li id="section-9.1-3.1">The DNS protocol can cache resolution answers (A and AAAA queries, for example), associated with a Time To Live (TTL) to
be used for future hostname resolutions without requiring asking the DNS resolver again.<a href="#section-9.1-3.1" class="pilcrow">¶</a>
</li>
<li id="section-9.1-3.2">TLS caches session state and tickets based on a hostname, which can be used for resuming sessions with a server.<a href="#section-9.1-3.2" class="pilcrow">¶</a>
</li>
<li id="section-9.1-3.3">TCP can cache cookies for use in TCP Fast Open.<a href="#section-9.1-3.3" class="pilcrow">¶</a>
</li>
</ul>
<p id="section-9.1-4">Cached protocol state is primarily used during Connection establishment for a single Protocol Stack, but may be used to influence an
implementation's preference between several candidate Protocol Stacks. For example, if two IP address Endpoints are otherwise
equally preferred, an implementation may choose to attempt a connection to an address for which it has a TCP Fast Open cookie.<a href="#section-9.1-4" class="pilcrow">¶</a></p>
<p id="section-9.1-5">Applications must have a way to flush protocol cache state if desired. This may be necessary, for example, if
application-layer identifiers rotate and clients wish to avoid linkability via trackable TLS tickets or TFO cookies.<a href="#section-9.1-5" class="pilcrow">¶</a></p>
</section>
</div>
<div id="performance-caches">
<section id="section-9.2">
        <h3 id="name-performance-caches">
<a href="#section-9.2" class="section-number selfRef">9.2. </a><a href="#name-performance-caches" class="section-name selfRef">Performance caches</a>
        </h3>
<p id="section-9.2-1">In addition to protocol state, Protocol Instances should provide data into a performance-oriented cache to help guide future protocol and path selection. Some performance information can be gathered generically across several protocols to allow predictive comparisons between protocols on given paths:<a href="#section-9.2-1" class="pilcrow">¶</a></p>
<ul>
<li id="section-9.2-2.1">Observed Round Trip Time<a href="#section-9.2-2.1" class="pilcrow">¶</a>
</li>
<li id="section-9.2-2.2">Connection Establishment latency<a href="#section-9.2-2.2" class="pilcrow">¶</a>
</li>
<li id="section-9.2-2.3">Connection Establishment success rate<a href="#section-9.2-2.3" class="pilcrow">¶</a>
</li>
</ul>
<p id="section-9.2-3">These items can be cached on a per-address and per-subnet granularity, and averaged between different values. The information should be cached on a per-network basis, since it is expected that different network attachments will have different performance characteristics. Besides Protocol Instances, other system entities may also provide data into performance-oriented caches. This could for instance be signal strength information reported by radio modems like Wi-Fi and mobile broadband or information about the battery-level of the device. Furthermore, the system may cache the observed maximum throughput on a path as an estimate of the available bandwidth.<a href="#section-9.2-3" class="pilcrow">¶</a></p>
<p id="section-9.2-4">An implementation should use this information, when possible, to determine preference between candidate paths, endpoints, and protocol options. Eligible options that historically had significantly better performance than others should be selected first when gathering candidates (see <a href="#gathering" class="xref">Section 4.1</a>) to ensure better performance for the application.<a href="#section-9.2-4" class="pilcrow">¶</a></p>
<p id="section-9.2-5">The reasonable lifetime for cached performance values will vary depending on the nature of the value. Certain information, like the connection establishment success rate to a Remote Endpoint using a given protocol stack, can be stored for a long period of time (hours or longer), since it is expected that the capabilities of the Remote Endpoint are not changing very quickly. On the other hand, Round Trip Time observed by TCP over a particular network path may vary over a relatively short time interval. For such values, the implementation should remove them from the cache more quickly, or treat older values with less confidence/weight.<a href="#section-9.2-5" class="pilcrow">¶</a></p>
</section>
</div>
</section>
</div>
<div id="specific-transport-protocol-considerations">
<section id="section-10">
      <h2 id="name-specific-transport-protocol">
<a href="#section-10" class="section-number selfRef">10. </a><a href="#name-specific-transport-protocol" class="section-name selfRef">Specific Transport Protocol Considerations</a>
      </h2>
<p id="section-10-1">Each protocol that can run as part of a Transport Services implementation defines both its API mapping as well as implementation details.
API mappings for a protocol apply most to Connections in which the given protocol is the "top" of the Protocol Stack. For example, the mapping of the <code>Send</code> function for TCP applies to Connections in which the application directly sends over TCP. If HTTP/2 is used on top of TCP, the HTTP/2 mappings take precendence.<a href="#section-10-1" class="pilcrow">¶</a></p>
<p id="section-10-2">Each protocol has a notion of Connectedness. Possible values for Connectedness are:<a href="#section-10-2" class="pilcrow">¶</a></p>
<ul>
<li id="section-10-3.1">Unconnected. Unconnected protocols do not establish explicit state between endpoints, and do not perform a handshake during Connection establishment.<a href="#section-10-3.1" class="pilcrow">¶</a>
</li>
<li id="section-10-3.2">Connected. Connected protocols establish state between endpoints, and perform a handshake during Connection establishment. The handshake may be 0-RTT to send data or resume a session, but bidirectional traffic is required to confirm connectedness.<a href="#section-10-3.2" class="pilcrow">¶</a>
</li>
<li id="section-10-3.3">Multiplexing Connected. Multiplexing Connected protocols share properties with Connected protocols, but also explictly support opening multiple application-level flows. This means that they can support cloning new Connection objects without a new explicit handshake.<a href="#section-10-3.3" class="pilcrow">¶</a>
</li>
</ul>
<p id="section-10-4">Protocols also define a notion of Data Unit. Possible values for Data Unit are:<a href="#section-10-4" class="pilcrow">¶</a></p>
<ul>
<li id="section-10-5.1">Byte-stream. Byte-stream protocols do not define any Message boundaries of their own apart from the end of a stream in each direction.<a href="#section-10-5.1" class="pilcrow">¶</a>
</li>
<li id="section-10-5.2">Datagram. Datagram protocols define Message boundaries at the same level of transmission, such that only complete (not partial) Messages are supported.<a href="#section-10-5.2" class="pilcrow">¶</a>
</li>
<li id="section-10-5.3">Message. Message protocols support Message boundaries that can be sent and received either as complete or partial Messages. Maximum Message lengths can be defined, and Messages can be partially reliable.<a href="#section-10-5.3" class="pilcrow">¶</a>
</li>
</ul>
<p id="section-10-6">Below, primitives in the style of "CATEGORY.[SUBCATEGORY].PRIMITIVENAME.PROTOCOL"  (e.g., "CONNECT.SCTP") refer to the primitives with the same name in section 4 of <span>[<a href="#RFC8303" class="xref">RFC8303</a>]</span>. For further implementation details, the description of these primitives in <span>[<a href="#RFC8303" class="xref">RFC8303</a>]</span> points to section 3, which refers back to the specifications for each protocol. This back-tracking method applies to all elements of <span>[<a href="#I-D.ietf-taps-minset" class="xref">I-D.ietf-taps-minset</a>]</span> (see appendix D of <span>[<a href="#I-D.ietf-taps-interface" class="xref">I-D.ietf-taps-interface</a>]</span>): they are listed in appendix A of <span>[<a href="#I-D.ietf-taps-minset" class="xref">I-D.ietf-taps-minset</a>]</span> with an implementation hint in the same style, pointing back to section 4 of <span>[<a href="#RFC8303" class="xref">RFC8303</a>]</span>.<a href="#section-10-6" class="pilcrow">¶</a></p>
<div id="tcp">
<section id="section-10.1">
        <h3 id="name-tcp">
<a href="#section-10.1" class="section-number selfRef">10.1. </a><a href="#name-tcp" class="section-name selfRef">TCP</a>
        </h3>
<p id="section-10.1-1">Connectedness: Connected<a href="#section-10.1-1" class="pilcrow">¶</a></p>
<p id="section-10.1-2">Data Unit: Byte-stream<a href="#section-10.1-2" class="pilcrow">¶</a></p>
<p id="section-10.1-3">API mappings for TCP are as follows:<a href="#section-10.1-3" class="pilcrow">¶</a></p>
<dl class="dlParallel" id="section-10.1-4">
          <dt id="section-10.1-4.1">Connection Object:</dt>
<dd id="section-10.1-4.2">
  TCP connections between two hosts map directly to Connection objects.<a href="#section-10.1-4.2" class="pilcrow">¶</a>
</dd>
<dt id="section-10.1-4.3">Initiate:</dt>
<dd id="section-10.1-4.4">
  CONNECT.TCP. Calling <code>Initiate</code> on a TCP Connection causes it to reserve a local port, and send a SYN to the Remote Endpoint.<a href="#section-10.1-4.4" class="pilcrow">¶</a>
</dd>
<dt id="section-10.1-4.5">InitiateWithSend:</dt>
<dd id="section-10.1-4.6">
  CONNECT.TCP with parameter "user message". Early idempotent data is sent on a TCP Connection in the SYN, as TCP Fast Open data.<a href="#section-10.1-4.6" class="pilcrow">¶</a>
</dd>
<dt id="section-10.1-4.7">Ready:</dt>
<dd id="section-10.1-4.8">
  A TCP Connection is ready once the three-way handshake is complete.<a href="#section-10.1-4.8" class="pilcrow">¶</a>
</dd>
<dt id="section-10.1-4.9">InitiateError:</dt>
<dd id="section-10.1-4.10">
  Failure of CONNECT.TCP. TCP can throw various errors during connection setup. Specifically, it is important to handle a RST being sent by the peer during the handshake.<a href="#section-10.1-4.10" class="pilcrow">¶</a>
</dd>
<dt id="section-10.1-4.11">ConnectionError:</dt>
<dd id="section-10.1-4.12">
  Once established, TCP throws errors whenever the connection is disconnected, such as due to receiving a RST from the peer; or hitting a TCP retransmission timeout.<a href="#section-10.1-4.12" class="pilcrow">¶</a>
</dd>
<dt id="section-10.1-4.13">Listen:</dt>
<dd id="section-10.1-4.14">
  LISTEN.TCP. Calling <code>Listen</code> for TCP binds a local port and prepares it to receive inbound SYN packets from peers.<a href="#section-10.1-4.14" class="pilcrow">¶</a>
</dd>
<dt id="section-10.1-4.15">ConnectionReceived:</dt>
<dd id="section-10.1-4.16">
  TCP Listeners will deliver new connections once they have replied to an inbound SYN with a SYN-ACK.<a href="#section-10.1-4.16" class="pilcrow">¶</a>
</dd>
<dt id="section-10.1-4.17">Clone:</dt>
<dd id="section-10.1-4.18">
  Calling <code>Clone</code> on a TCP Connection creates a new Connection with equivalent parameters. The two Connections are otherwise independent.<a href="#section-10.1-4.18" class="pilcrow">¶</a>
</dd>
<dt id="section-10.1-4.19">Send:</dt>
<dd id="section-10.1-4.20">
  SEND.TCP. TCP does not on its own preserve Message boundaries. Calling <code>Send</code> on a TCP connection lays out the bytes on the TCP send stream without any other delineation. Any Message marked as Final will cause TCP to send a FIN once the Message has been completely written, by calling CLOSE.TCP immediately upon successful termination of SEND.TCP.<a href="#section-10.1-4.20" class="pilcrow">¶</a>
</dd>
<dt id="section-10.1-4.21">Receive:</dt>
<dd id="section-10.1-4.22">
  With RECEIVE.TCP, TCP delivers a stream of bytes without any Message delineation. All data delivered in the <code>Received</code> or <code>ReceivedPartial</code> event will be part of a single stream-wide Message that is marked Final (unless a Message Framer is used). EndOfMessage will be delivered when the TCP Connection has received a FIN (CLOSE-EVENT.TCP or ABORT-EVENT.TCP) from the peer.<a href="#section-10.1-4.22" class="pilcrow">¶</a>
</dd>
<dt id="section-10.1-4.23">Close:</dt>
<dd id="section-10.1-4.24">
  Calling <code>Close</code> on a TCP Connection indicates that the Connection should be gracefully closed (CLOSE.TCP) by sending a FIN to the peer and waiting for a FIN-ACK before delivering the <code>Closed</code> event.<a href="#section-10.1-4.24" class="pilcrow">¶</a>
</dd>
<dt id="section-10.1-4.25">Abort:</dt>
<dd id="section-10.1-4.26">
  Calling <code>Abort</code> on a TCP Connection indicates that the Connection should be immediately closed by sending a RST to the peer (ABORT.TCP).<a href="#section-10.1-4.26" class="pilcrow">¶</a>
</dd>
</dl>
</section>
</div>
<div id="udp">
<section id="section-10.2">
        <h3 id="name-udp">
<a href="#section-10.2" class="section-number selfRef">10.2. </a><a href="#name-udp" class="section-name selfRef">UDP</a>
        </h3>
<p id="section-10.2-1">Connectedness: Unconnected<a href="#section-10.2-1" class="pilcrow">¶</a></p>
<p id="section-10.2-2">Data Unit: Datagram<a href="#section-10.2-2" class="pilcrow">¶</a></p>
<p id="section-10.2-3">API mappings for UDP are as follows:<a href="#section-10.2-3" class="pilcrow">¶</a></p>
<dl class="dlParallel" id="section-10.2-4">
          <dt id="section-10.2-4.1">Connection Object:</dt>
<dd id="section-10.2-4.2">
  UDP connections represent a pair of specific IP addresses and ports on two hosts.<a href="#section-10.2-4.2" class="pilcrow">¶</a>
</dd>
<dt id="section-10.2-4.3">Initiate:</dt>
<dd id="section-10.2-4.4">
  CONNECT.UDP. Calling <code>Initiate</code> on a UDP Connection causes it to reserve a local port, but does not generate any traffic.<a href="#section-10.2-4.4" class="pilcrow">¶</a>
</dd>
<dt id="section-10.2-4.5">InitiateWithSend:</dt>
<dd id="section-10.2-4.6">
  Early data on a UDP Connection does not have any special meaning. The data is sent whenever the Connection is Ready.<a href="#section-10.2-4.6" class="pilcrow">¶</a>
</dd>
<dt id="section-10.2-4.7">Ready:</dt>
<dd id="section-10.2-4.8">
  A UDP Connection is ready once the system has reserved a local port and has a path to send to the Remote Endpoint.<a href="#section-10.2-4.8" class="pilcrow">¶</a>
</dd>
<dt id="section-10.2-4.9">InitiateError:</dt>
<dd id="section-10.2-4.10">
  UDP Connections can only generate errors on initiation due to port conflicts on the local system.<a href="#section-10.2-4.10" class="pilcrow">¶</a>
</dd>
<dt id="section-10.2-4.11">ConnectionError:</dt>
<dd id="section-10.2-4.12">
  Once in use, UDP throws "soft errors" (ERROR.UDP(-Lite)) upon receiving ICMP notifications indicating failures in the network.<a href="#section-10.2-4.12" class="pilcrow">¶</a>
</dd>
<dt id="section-10.2-4.13">Listen:</dt>
<dd id="section-10.2-4.14">
  LISTEN.UDP. Calling <code>Listen</code> for UDP binds a local port and prepares it to receive inbound UDP datagrams from peers.<a href="#section-10.2-4.14" class="pilcrow">¶</a>
</dd>
<dt id="section-10.2-4.15">ConnectionReceived:</dt>
<dd id="section-10.2-4.16">
  UDP Listeners will deliver new connections once they have received traffic from a new Remote Endpoint.<a href="#section-10.2-4.16" class="pilcrow">¶</a>
</dd>
<dt id="section-10.2-4.17">Clone:</dt>
<dd id="section-10.2-4.18">
  Calling <code>Clone</code> on a UDP Connection creates a new Connection with equivalent parameters. The two Connections are otherwise independent.<a href="#section-10.2-4.18" class="pilcrow">¶</a>
</dd>
<dt id="section-10.2-4.19">Send:</dt>
<dd id="section-10.2-4.20">
  SEND.UDP(-Lite). Calling <code>Send</code> on a UDP connection sends the data as the payload of a complete UDP datagram. Marking Messages as Final does not change anything in the datagram's contents. Upon sending a UDP datagram, some relevant fields and flags in the IP header can be controlled: DSCP (SET_DSCP.UDP(-Lite)), DF in IPv4 (SET_DF.UDP(-Lite)) and ECN flag (SET_ECN.UDP(-Lite)).<a href="#section-10.2-4.20" class="pilcrow">¶</a>
</dd>
<dt id="section-10.2-4.21">Receive:</dt>
<dd id="section-10.2-4.22">
  RECEIVE.UDP(-Lite). UDP only delivers complete Messages to <code>Received</code>, each of which represents a single datagram received in a UDP packet. Upon receiving a UDP datagram, the ECN flag from the IP header can be obtained (GET_ECN.UDP(-Lite)).<a href="#section-10.2-4.22" class="pilcrow">¶</a>
</dd>
<dt id="section-10.2-4.23">Close:</dt>
<dd id="section-10.2-4.24">
  Calling <code>Close</code> on a UDP Connection (ABORT.UDP(-Lite)) releases the local port reservation.<a href="#section-10.2-4.24" class="pilcrow">¶</a>
</dd>
<dt id="section-10.2-4.25">Abort:</dt>
<dd id="section-10.2-4.26">
  Calling <code>Abort</code> on a UDP Connection (ABORT.UDP(-Lite)) is identical to calling <code>Close</code>.<a href="#section-10.2-4.26" class="pilcrow">¶</a>
</dd>
</dl>
</section>
</div>
<div id="udp-multicast-receive">
<section id="section-10.3">
        <h3 id="name-udp-multicast-receive">
<a href="#section-10.3" class="section-number selfRef">10.3. </a><a href="#name-udp-multicast-receive" class="section-name selfRef">UDP Multicast Receive</a>
        </h3>
<p id="section-10.3-1">Connectedness: Unconnected<a href="#section-10.3-1" class="pilcrow">¶</a></p>
<p id="section-10.3-2">Data Unit: Datagram<a href="#section-10.3-2" class="pilcrow">¶</a></p>
<p id="section-10.3-3">API mappings for Receiving Multicast UDP are as follows:<a href="#section-10.3-3" class="pilcrow">¶</a></p>
<dl class="dlParallel" id="section-10.3-4">
          <dt id="section-10.3-4.1">Connection Object:</dt>
<dd id="section-10.3-4.2">
  Established UDP Multicast Receive connections represent a pair of specific IP addresses and ports.  The "unidirectional receive" transport property is required, and the local endpoint must be configured with a group IP address and a port.<a href="#section-10.3-4.2" class="pilcrow">¶</a>
</dd>
<dt id="section-10.3-4.3">Initiate:</dt>
<dd id="section-10.3-4.4">
  Calling <code>Initiate</code> on a UDP Multicast Receive Connection causes an immediate InitiateError.  This is an unsupported operation.<a href="#section-10.3-4.4" class="pilcrow">¶</a>
</dd>
<dt id="section-10.3-4.5">InitiateWithSend:</dt>
<dd id="section-10.3-4.6">
  Calling <code>InitiateWithSend</code> on a UDP Multicast Receive Connection causes an immediate InitiateError.  This is an unsupported operation.<a href="#section-10.3-4.6" class="pilcrow">¶</a>
</dd>
<dt id="section-10.3-4.7">Ready:</dt>
<dd id="section-10.3-4.8">
  A UDP Multicast Receive Connection is ready once the system has received traffic for the appropriate group and port.<a href="#section-10.3-4.8" class="pilcrow">¶</a>
</dd>
<dt id="section-10.3-4.9">InitiateError:</dt>
<dd id="section-10.3-4.10">
  UDP Multicast Receive Connections generate an InitiateError if Initiate is called.<a href="#section-10.3-4.10" class="pilcrow">¶</a>
</dd>
<dt id="section-10.3-4.11">ConnectionError:</dt>
<dd id="section-10.3-4.12">
  Once in use, UDP throws "soft errors" (ERROR.UDP(-Lite)) upon receiving ICMP notifications indicating failures in the network.<a href="#section-10.3-4.12" class="pilcrow">¶</a>
</dd>
<dt id="section-10.3-4.13">Listen:</dt>
<dd id="section-10.3-4.14">
  LISTEN.UDP. Calling <code>Listen</code> for UDP Multicast Receive binds a local port, prepares it to receive inbound UDP datagrams from peers, and issues a multicast host join.  If a remote endpoint with an address is supplied, the join is Source-specific Multicast, and the path selection is based on the route to the remote endpoint.  If a remote endpoint is not supplied, the join is Any-source Multicast, and the path selection is based on the outbound route to the group supplied in the local endpoint.<a href="#section-10.3-4.14" class="pilcrow">¶</a>
</dd>
<dt id="section-10.3-4.15">ConnectionReceived:</dt>
<dd id="section-10.3-4.16">
  UDP Multicast Receive Listeners will deliver new connections once they have received traffic from a new Remote Endpoint.<a href="#section-10.3-4.16" class="pilcrow">¶</a>
</dd>
<dt id="section-10.3-4.17">Clone:</dt>
<dd id="section-10.3-4.18">
  Calling <code>Clone</code> on a UDP Multicast Receive Connection creates a new Connection with equivalent parameters. The two Connections are otherwise independent.<a href="#section-10.3-4.18" class="pilcrow">¶</a>
</dd>
<dt id="section-10.3-4.19">Send:</dt>
<dd id="section-10.3-4.20">
  SEND.UDP(-Lite). Calling <code>Send</code> on a UDP Multicast Receive connection causes an immediate SendError.  This is an unsupported operation.<a href="#section-10.3-4.20" class="pilcrow">¶</a>
</dd>
<dt id="section-10.3-4.21">Receive:</dt>
<dd id="section-10.3-4.22">
  RECEIVE.UDP(-Lite). The Receive operation in a UDP Multicast Receive connection only delivers complete Messages to <code>Received</code>, each of which represents a single datagram received in a UDP packet. Upon receiving a UDP datagram, the ECN flag from the IP header can be obtained (GET_ECN.UDP(-Lite)).<a href="#section-10.3-4.22" class="pilcrow">¶</a>
</dd>
<dt id="section-10.3-4.23">Close:</dt>
<dd id="section-10.3-4.24">
  Calling <code>Close</code> on a UDP Multicast Receive Connection (ABORT.UDP(-Lite)) releases the local port reservation and leaves the group.<a href="#section-10.3-4.24" class="pilcrow">¶</a>
</dd>
<dt id="section-10.3-4.25">Abort:</dt>
<dd id="section-10.3-4.26">
  Calling <code>Abort</code> on a UDP Multicast Receive Connection (ABORT.UDP(-Lite)) is identical to calling <code>Close</code>.<a href="#section-10.3-4.26" class="pilcrow">¶</a>
</dd>
</dl>
</section>
</div>
<div id="tls">
<section id="section-10.4">
        <h3 id="name-tls">
<a href="#section-10.4" class="section-number selfRef">10.4. </a><a href="#name-tls" class="section-name selfRef">TLS</a>
        </h3>
<p id="section-10.4-1">The mapping of a TLS stream abstraction into the application is equivalent to the contract provided by TCP (see <a href="#tcp" class="xref">Section 10.1</a>), and builds upon many of the actions of TCP connections.<a href="#section-10.4-1" class="pilcrow">¶</a></p>
<p id="section-10.4-2">Connectedness: Connected<a href="#section-10.4-2" class="pilcrow">¶</a></p>
<p id="section-10.4-3">Data Unit: Byte-stream<a href="#section-10.4-3" class="pilcrow">¶</a></p>
<dl class="dlParallel" id="section-10.4-4">
          <dt id="section-10.4-4.1">Connection Object:</dt>
<dd id="section-10.4-4.2">
  Connection objects represent a single TLS connection running over a TCP connection between two hosts.<a href="#section-10.4-4.2" class="pilcrow">¶</a>
</dd>
<dt id="section-10.4-4.3">Initiate:</dt>
<dd id="section-10.4-4.4">
  Calling <code>Initiate</code> on a TLS Connection causes it to first initiate a TCP connection. Once the TCP protocol is Ready, the TLS handshake will be performed as a client (starting by sending a <code>client_hello</code>, and so on).<a href="#section-10.4-4.4" class="pilcrow">¶</a>
</dd>
<dt id="section-10.4-4.5">InitiateWithSend:</dt>
<dd id="section-10.4-4.6">
  Early idempotent data is supported by TLS 1.3, and sends encrypted application data in the first TLS message when performing session resumption. For older versions of TLS, or if a session is not being resumed, the initial data will be delayed until the TLS handshake is complete. TCP Fast Option can also be enabled automatically.<a href="#section-10.4-4.6" class="pilcrow">¶</a>
</dd>
<dt id="section-10.4-4.7">Ready:</dt>
<dd id="section-10.4-4.8">
  A TLS Connection is ready once the underlying TCP connection is Ready, and TLS handshake is also complete and keys have been established to encrypt application data.<a href="#section-10.4-4.8" class="pilcrow">¶</a>
</dd>
<dt id="section-10.4-4.9">InitiateError:</dt>
<dd id="section-10.4-4.10">
  In addition to TCP initiation errors, TLS can generate errors during its handshake. Examples of error include a failure of the peer to successfully authenticate, the peer rejecting the local authentication, or a failure to match versions or algorithms.<a href="#section-10.4-4.10" class="pilcrow">¶</a>
</dd>
<dt id="section-10.4-4.11">ConnectionError:</dt>
<dd id="section-10.4-4.12">
  TLS connections will generate TCP errors, or errors due to failures to rekey or decrypt received messages.<a href="#section-10.4-4.12" class="pilcrow">¶</a>
</dd>
<dt id="section-10.4-4.13">Listen:</dt>
<dd id="section-10.4-4.14">
  Calling <code>Listen</code> for TLS listens on TCP, and sets up received connections to perform server-side TLS handshakes.<a href="#section-10.4-4.14" class="pilcrow">¶</a>
</dd>
<dt id="section-10.4-4.15">ConnectionReceived:</dt>
<dd id="section-10.4-4.16">
  TLS Listeners will deliver new connections once they have successfully completed both TCP and TLS handshakes.<a href="#section-10.4-4.16" class="pilcrow">¶</a>
</dd>
<dt id="section-10.4-4.17">Clone:</dt>
<dd id="section-10.4-4.18">
  As with TCP, calling <code>Clone</code> on a TLS Connection creates a new Connection with equivalent parameters. The two Connections are otherwise independent.<a href="#section-10.4-4.18" class="pilcrow">¶</a>
</dd>
<dt id="section-10.4-4.19">Send:</dt>
<dd id="section-10.4-4.20">
  Like TCP, TLS does not preserve message boundaries. Although application data is framed natively in TLS, there is not a general guarantee that these TLS messages represent semantically meaningful application stream boundaries. Rather, sending data on a TLS Connection only guarantees that the application data will be transmitted in an encrypted form. Marking Messages as Final causes a <code>close_notify</code> to be generated once the data has been written.<a href="#section-10.4-4.20" class="pilcrow">¶</a>
</dd>
<dt id="section-10.4-4.21">Receive:</dt>
<dd id="section-10.4-4.22">
  Like TCP, TLS delivers a stream of bytes without any Message delineation. The data is decrypted prior to being delivered to the application. If a <code>close_notify</code> is received, the stream-wide Message will be delivered with EndOfMessage set.<a href="#section-10.4-4.22" class="pilcrow">¶</a>
</dd>
<dt id="section-10.4-4.23">Close:</dt>
<dd id="section-10.4-4.24">
  Calling <code>Close</code> on a TLS Connection indicates that the Connection should be gracefully closed by sending a <code>close_notify</code> to the peer and waiting for a corresponding <code>close_notify</code> before delivering the <code>Closed</code> event.<a href="#section-10.4-4.24" class="pilcrow">¶</a>
</dd>
<dt id="section-10.4-4.25">Abort:</dt>
<dd id="section-10.4-4.26">
  Calling <code>Abort</code> on a TCP Connection indicates that the Connection should be immediately closed by sending a <code>close_notify</code>, optionally preceded by <code>user_canceled</code>, to the peer. Implementations do not need to wait to receive <code>close_notify</code> before delivering the <code>Closed</code> event.<a href="#section-10.4-4.26" class="pilcrow">¶</a>
</dd>
</dl>
</section>
</div>
<div id="dtls">
<section id="section-10.5">
        <h3 id="name-dtls">
<a href="#section-10.5" class="section-number selfRef">10.5. </a><a href="#name-dtls" class="section-name selfRef">DTLS</a>
        </h3>
<p id="section-10.5-1">DTLS follows the same behavior as TLS (<a href="#tls" class="xref">Section 10.4</a>), with the notable exception of not inheriting behavior directly from TCP. Differences from TLS are detailed below, and all cases not explicitly mentioned should be considered the same as TLS.<a href="#section-10.5-1" class="pilcrow">¶</a></p>
<p id="section-10.5-2">Connectedness: Connected<a href="#section-10.5-2" class="pilcrow">¶</a></p>
<p id="section-10.5-3">Data Unit: Datagram<a href="#section-10.5-3" class="pilcrow">¶</a></p>
<dl class="dlParallel" id="section-10.5-4">
          <dt id="section-10.5-4.1">Connection Object:</dt>
<dd id="section-10.5-4.2">
  Connection objects represent a single DTLS connection running over a set of UDP ports between two hosts.<a href="#section-10.5-4.2" class="pilcrow">¶</a>
</dd>
<dt id="section-10.5-4.3">Initiate:</dt>
<dd id="section-10.5-4.4">
  Calling <code>Initiate</code> on a DTLS Connection causes it reserve a UDP local port, and begin sending handshake messages to the peer over UDP. These messages are reliable, and will be automatically retransmitted.<a href="#section-10.5-4.4" class="pilcrow">¶</a>
</dd>
<dt id="section-10.5-4.5">Ready:</dt>
<dd id="section-10.5-4.6">
  A DTLS Connection is ready once the TLS handshake is complete and keys have been established to encrypt application data.<a href="#section-10.5-4.6" class="pilcrow">¶</a>
</dd>
<dt id="section-10.5-4.7">Send:</dt>
<dd id="section-10.5-4.8">
  Sending over DTLS does preserve message boundaries in the same way that UDP datagrams do. Marking a Message as Final does send a <code>close_notify</code> like TLS.<a href="#section-10.5-4.8" class="pilcrow">¶</a>
</dd>
<dt id="section-10.5-4.9">Receive:</dt>
<dd id="section-10.5-4.10">
  Receiving over DTLS delivers one decrypted Message for each received DTLS datagram. If a <code>close_notify</code> is received, a Message will be delivered that is marked as Final.<a href="#section-10.5-4.10" class="pilcrow">¶</a>
</dd>
</dl>
</section>
</div>
<div id="http">
<section id="section-10.6">
        <h3 id="name-http">
<a href="#section-10.6" class="section-number selfRef">10.6. </a><a href="#name-http" class="section-name selfRef">HTTP</a>
        </h3>
<p id="section-10.6-1">HTTP requests and responses map naturally into Messages, since they are delineated chunks of data with metadata that can be sent over a transport. To that end, HTTP can be seen as the most prevalent framing protocol that runs on top of streams like TCP, TLS, etc.<a href="#section-10.6-1" class="pilcrow">¶</a></p>
<p id="section-10.6-2">In order to use a transport Connection that provides HTTP Message support, the establishment and closing of the connection can be treated as it would without the framing protocol. Sending and receiving of Messages, however, changes to treat each Message as a well-delineated HTTP request or response, with the content of the Message representing the body, and the Headers being provided in Message metadata.<a href="#section-10.6-2" class="pilcrow">¶</a></p>
<p id="section-10.6-3">Connectedness: Multiplexing Connected<a href="#section-10.6-3" class="pilcrow">¶</a></p>
<p id="section-10.6-4">Data Unit: Message<a href="#section-10.6-4" class="pilcrow">¶</a></p>
<dl class="dlParallel" id="section-10.6-5">
          <dt id="section-10.6-5.1">Connection Object:</dt>
<dd id="section-10.6-5.2">
  Connection objects represent a flow of HTTP messages between a client and a server, which may be an HTTP/1.1 connection over TCP, or a single stream in an HTTP/2 connection.<a href="#section-10.6-5.2" class="pilcrow">¶</a>
</dd>
<dt id="section-10.6-5.3">Initiate:</dt>
<dd id="section-10.6-5.4">
  Calling <code>Initiate</code> on an HTTP connection intiates a TCP or TLS connection as a client.<a href="#section-10.6-5.4" class="pilcrow">¶</a>
</dd>
<dt id="section-10.6-5.5">Clone:</dt>
<dd id="section-10.6-5.6">
  Calling <code>Clone</code> on an HTTP Connection opens a new stream on an existing HTTP/2 connection when possible. If the underlying version does not support multiplexed streams, calling <code>Clone</code> simply creates a new parallel connection.<a href="#section-10.6-5.6" class="pilcrow">¶</a>
</dd>
<dt id="section-10.6-5.7">Send:</dt>
<dd id="section-10.6-5.8">
  When an application sends an HTTP Message, it is expected to provide HTTP header values as a MessageContext in a canonical form, along with any associated HTTP message body as the Message data. The HTTP header values are encoded in the specific version format upon sending.<a href="#section-10.6-5.8" class="pilcrow">¶</a>
</dd>
<dt id="section-10.6-5.9">Receive:</dt>
<dd id="section-10.6-5.10">
  HTTP Connections deliver Messages in which HTTP header values attached to MessageContexts, and HTTP bodies in Message data.<a href="#section-10.6-5.10" class="pilcrow">¶</a>
</dd>
<dt id="section-10.6-5.11">Close:</dt>
<dd id="section-10.6-5.12">
  Calling <code>Close</code> on an HTTP Connection will only close the underlying TLS or TCP connection if the HTTP version does not support multiplexing. For HTTP/2, for example, closing the connection
only closes a specific stream.<a href="#section-10.6-5.12" class="pilcrow">¶</a>
</dd>
</dl>
</section>
</div>
<div id="quic">
<section id="section-10.7">
        <h3 id="name-quic">
<a href="#section-10.7" class="section-number selfRef">10.7. </a><a href="#name-quic" class="section-name selfRef">QUIC</a>
        </h3>
<p id="section-10.7-1">QUIC provides a multi-streaming interface to an encrypted transport. Each stream can be viewed as equivalent to a TLS stream over TCP, so a natural mapping is to present each QUIC stream as an individual Connection. The protocol for the stream will be considered Ready whenever the underlying QUIC connection is established to the point that this stream's data can be sent. For streams after the first stream, this will likely be an immediate operation.<a href="#section-10.7-1" class="pilcrow">¶</a></p>
<p id="section-10.7-2">Closing a single QUIC stream, presented to the application as a Connection, does not imply closing the underlying QUIC connection itself. Rather, the implementation may choose to close the QUIC connection once all streams have been closed (often after some timeout), or after an individual stream Connection sends an Abort.<a href="#section-10.7-2" class="pilcrow">¶</a></p>
<p id="section-10.7-3">Connectedness: Multiplexing Connected<a href="#section-10.7-3" class="pilcrow">¶</a></p>
<p id="section-10.7-4">Data Unit: Stream<a href="#section-10.7-4" class="pilcrow">¶</a></p>
<dl class="dlParallel" id="section-10.7-5">
          <dt id="section-10.7-5.1">Connection Object:</dt>
<dd id="section-10.7-5.2">
  Connection objects represent a single QUIC stream on a QUIC connection.<a href="#section-10.7-5.2" class="pilcrow">¶</a>
</dd>
</dl>
</section>
</div>
<div id="http2-transport">
<section id="section-10.8">
        <h3 id="name-http-2-transport">
<a href="#section-10.8" class="section-number selfRef">10.8. </a><a href="#name-http-2-transport" class="section-name selfRef">HTTP/2 transport</a>
        </h3>
<p id="section-10.8-1">Similar to QUIC (<a href="#quic" class="xref">Section 10.7</a>), HTTP/2 provides a multi-streaming interface. This will generally use HTTP as the unit of Messages over the streams, in which each stream can be represented as a transport Connection. The lifetime of streams and the HTTP/2 connection should be managed as described for QUIC.<a href="#section-10.8-1" class="pilcrow">¶</a></p>
<p id="section-10.8-2">It is possible to treat each HTTP/2 stream as a raw byte-stream instead of a carrier for HTTP messages, in which case the Messages over the streams can be represented similarly to the TCP stream (one Message per direction, see <a href="#tcp" class="xref">Section 10.1</a>).<a href="#section-10.8-2" class="pilcrow">¶</a></p>
<p id="section-10.8-3">Connectedness: Multiplexing Connected<a href="#section-10.8-3" class="pilcrow">¶</a></p>
<p id="section-10.8-4">Data Unit: Stream<a href="#section-10.8-4" class="pilcrow">¶</a></p>
<dl class="dlParallel" id="section-10.8-5">
          <dt id="section-10.8-5.1">Connection Object:</dt>
<dd id="section-10.8-5.2">
  Connection objects represent a single HTTP/2 stream on a HTTP/2 connection.<a href="#section-10.8-5.2" class="pilcrow">¶</a>
</dd>
</dl>
</section>
</div>
<div id="sctp">
<section id="section-10.9">
        <h3 id="name-sctp">
<a href="#section-10.9" class="section-number selfRef">10.9. </a><a href="#name-sctp" class="section-name selfRef">SCTP</a>
        </h3>
<p id="section-10.9-1">Connectedness: Connected<a href="#section-10.9-1" class="pilcrow">¶</a></p>
<p id="section-10.9-2">Data Unit: Message<a href="#section-10.9-2" class="pilcrow">¶</a></p>
<p id="section-10.9-3">API mappings for SCTP are as follows:<a href="#section-10.9-3" class="pilcrow">¶</a></p>
<dl class="dlParallel" id="section-10.9-4">
          <dt id="section-10.9-4.1">Connection Object:</dt>
<dd id="section-10.9-4.2">
  Connection objects represent a flow of SCTP messages between a client and a server, which may be an SCTP association or a stream in a SCTP association. How to map Connection objects to streams is described in <span>[<a href="#NEAT-flow-mapping" class="xref">NEAT-flow-mapping</a>]</span>; in the following, a similar method is described.
To map Connection objects to SCTP streams without head-of-line blocking on the sender
side, both the sending and receiving SCTP implementation must support message interleaving <span>[<a href="#RFC8260" class="xref">RFC8260</a>]</span>.
Both SCTP implementations must also support stream reconfiguration. Finally, both communicating endpoints
must be aware of this intended multiplexing; <span>[<a href="#NEAT-flow-mapping" class="xref">NEAT-flow-mapping</a>]</span> describes a
way for a Transport System to negotiate the stream mapping capability using SCTP's adaptation layer indication,
such that this functionality would only take effect if both ends sides are aware of it.
The first flow, for which the SCTP association has been created, will always use stream id zero.
All additional flows are assigned to unused stream ids in growing order. To avoid a conflict
when both endpoints map new flows simultaneously, the peer which initiated the transport connection
will use even stream numbers whereas the remote side will map its flows to odd stream numbers.
Both sides maintain a status map of the assigned stream numbers. Generally, new streams
must consume the lowest available (even or odd, depending on the side) stream number; this
rule is relevant when lower numbers become available because Connection objects associated
to the streams are closed.<a href="#section-10.9-4.2" class="pilcrow">¶</a>
</dd>
<dt id="section-10.9-4.3">Initiate:</dt>
<dd id="section-10.9-4.4">
  If this is the only Connection object that is assigned to the SCTP association or stream mapping has
not been negotiated, CONNECT.SCTP is called. Else, a new stream is used: if there are enough streams
available, <code>Initiate</code> is just a local operation that assigns a new stream number to the Connection object.
The number of streams is negotiated as a parameter of the prior CONNECT.SCTP call, and it represents a
trade-off between local resource usage and the number of Connection objects that can be mapped
without requiring a reconfiguration signal. When running out of streams, ADD_STREAM.SCTP must be called.<a href="#section-10.9-4.4" class="pilcrow">¶</a>
</dd>
<dt id="section-10.9-4.5">InitiateWithSend:</dt>
<dd id="section-10.9-4.6">
  If this is the only Connection object that is assigned to the SCTP association or stream mapping has
not been negotiated, CONNECT.SCTP is called with the "user message" parameter. Else, a new stream
is used (see <code>Initiate</code> for how to handle running out of streams), and this just sends the first message
on a new stream.<a href="#section-10.9-4.6" class="pilcrow">¶</a>
</dd>
<dt id="section-10.9-4.7">Ready:</dt>
<dd id="section-10.9-4.8">
            <code>Initiate</code> or <code>InitiateWithSend</code> returns without an error, i.e. SCTP's four-way handshake has completed. If an association with the peer already exists, and stream mapping has been negotiated and enough streams are available, a Connection Object instantly becomes Ready after calling <code>Initiate</code> or <code>InitiateWithSend</code>.<a href="#section-10.9-4.8" class="pilcrow">¶</a>
</dd>
<dt id="section-10.9-4.9">InitiateError:</dt>
<dd id="section-10.9-4.10">
  Failure of CONNECT.SCTP.<a href="#section-10.9-4.10" class="pilcrow">¶</a>
</dd>
<dt id="section-10.9-4.11">ConnectionError:</dt>
<dd id="section-10.9-4.12">
  TIMEOUT.SCTP or ABORT-EVENT.SCTP.<a href="#section-10.9-4.12" class="pilcrow">¶</a>
</dd>
<dt id="section-10.9-4.13">Listen:</dt>
<dd id="section-10.9-4.14">
  LISTEN.SCTP. If an association with the peer already exists and stream mapping has been negotiated, <code>Listen</code> just expects to receive a new message on a new stream id (chosen in accordance with the stream number assignment procedure described above).<a href="#section-10.9-4.14" class="pilcrow">¶</a>
</dd>
<dt id="section-10.9-4.15">ConnectionReceived:</dt>
<dd id="section-10.9-4.16">
  LISTEN.SCTP returns without an error (a result of successful CONNECT.SCTP from the peer), or, in case of stream mapping, the first message has arrived on a new stream (in this case, <code>Receive</code> is also invoked).<a href="#section-10.9-4.16" class="pilcrow">¶</a>
</dd>
<dt id="section-10.9-4.17">Clone:</dt>
<dd id="section-10.9-4.18">
  Calling <code>Clone</code> on an SCTP association creates a new Connection object and assigns it a new stream number in accordance with the stream number assignment procedure described above. If there are not enough streams available, ADD_STREAM.SCTP must be called.<a href="#section-10.9-4.18" class="pilcrow">¶</a>
</dd>
<dt id="section-10.9-4.19">Priority (Connection):</dt>
<dd id="section-10.9-4.20">
  When this value is changed, or a Message with Message Property <code>Priority</code> is sent, and there are multiple
Connection objects assigned to the same SCTP association,
CONFIGURE_STREAM_SCHEDULER.SCTP is called to adjust the priorities of streams in the SCTP association.<a href="#section-10.9-4.20" class="pilcrow">¶</a>
</dd>
<dt id="section-10.9-4.21">Send:</dt>
<dd id="section-10.9-4.22">
  SEND.SCTP. Message Properties such as <code>Lifetime</code> and <code>Ordered</code> map to parameters of this primitive.<a href="#section-10.9-4.22" class="pilcrow">¶</a>
</dd>
<dt id="section-10.9-4.23">Receive:</dt>
<dd id="section-10.9-4.24">
  RECEIVE.SCTP. The "partial flag" of RECEIVE.SCTP invokes a <code>ReceivedPartial</code> event.<a href="#section-10.9-4.24" class="pilcrow">¶</a>
</dd>
</dl>
<p id="section-10.9-5">Close:
If this is the only Connection object that is assigned to the SCTP association, CLOSE.SCTP is called. Else, the Connection object is one out of several Connection objects that are assigned to the same SCTP assocation, and RESET_STREAM.SCTP must be called, which informs the peer that the stream will no longer be used for mapping and can be used by future <code>Initiate</code>, <code>InitiateWithSend</code> or <code>Listen</code> calls. At the peer, the event RESET_STREAM-EVENT.SCTP will fire, which the peer must answer by issuing RESET_STREAM.SCTP too. The resulting local RESET_STREAM-EVENT.SCTP informs the transport system that the stream number can now be re-used by the next <code>Initiate</code>, <code>InitiateWithSend</code> or <code>Listen</code> calls.<a href="#section-10.9-5" class="pilcrow">¶</a></p>
<p id="section-10.9-6">Abort:
If this is the only Connection object that is assigned to the SCTP association, ABORT.SCTP is called. Else, the Connection object is one out of several Connection objects that are assigned to the same SCTP assocation, and shutdown proceeds as described under <code>Close</code>.<a href="#section-10.9-6" class="pilcrow">¶</a></p>
</section>
</div>
</section>
</div>
<div id="iana-considerations">
<section id="section-11">
      <h2 id="name-iana-considerations">
<a href="#section-11" class="section-number selfRef">11. </a><a href="#name-iana-considerations" class="section-name selfRef">IANA Considerations</a>
      </h2>
<p id="section-11-1">RFC-EDITOR: Please remove this section before publication.<a href="#section-11-1" class="pilcrow">¶</a></p>
<p id="section-11-2">This document has no actions for IANA.<a href="#section-11-2" class="pilcrow">¶</a></p>
</section>
</div>
<div id="security-considerations">
<section id="section-12">
      <h2 id="name-security-considerations">
<a href="#section-12" class="section-number selfRef">12. </a><a href="#name-security-considerations" class="section-name selfRef">Security Considerations</a>
      </h2>
<div id="considerations-for-candidate-gathering">
<section id="section-12.1">
        <h3 id="name-considerations-for-candidat">
<a href="#section-12.1" class="section-number selfRef">12.1. </a><a href="#name-considerations-for-candidat" class="section-name selfRef">Considerations for Candidate Gathering</a>
        </h3>
<p id="section-12.1-1">Implementations should avoid downgrade attacks that allow network interference to cause the implementation to select less secure, or entirely insecure, combinations of paths and protocols.<a href="#section-12.1-1" class="pilcrow">¶</a></p>
</section>
</div>
<div id="considerations-for-candidate-racing">
<section id="section-12.2">
        <h3 id="name-considerations-for-candidate">
<a href="#section-12.2" class="section-number selfRef">12.2. </a><a href="#name-considerations-for-candidate" class="section-name selfRef">Considerations for Candidate Racing</a>
        </h3>
<p id="section-12.2-1">See <a href="#fastopen" class="xref">Section 5.3</a> for security considerations around racing with 0-RTT data.<a href="#section-12.2-1" class="pilcrow">¶</a></p>
<p id="section-12.2-2">An attacker that knows a particular device is racing several options during connection establishment may be able to block packets for the first connection attempt, thus inducing the device to fall back to a secondary attempt. This is a problem if the secondary attempts have worse security properties that enable further attacks. Implementations should ensure that all options have equivalent security properties to avoid incentivizing attacks.<a href="#section-12.2-2" class="pilcrow">¶</a></p>
<p id="section-12.2-3">Since results from the network can determine how a connection attempt tree is built, such as when DNS returns a list of resolved endpoints, it is possible for the network to cause an implementation to consume significant on-device resources. Implementations should limit the maximum amount of state allowed for any given node, including the number of child nodes, especially when the state is based on results from the network.<a href="#section-12.2-3" class="pilcrow">¶</a></p>
</section>
</div>
</section>
</div>
<div id="acknowledgements">
<section id="section-13">
      <h2 id="name-acknowledgements">
<a href="#section-13" class="section-number selfRef">13. </a><a href="#name-acknowledgements" class="section-name selfRef">Acknowledgements</a>
      </h2>
<p id="section-13-1">This work has received funding from the European Union's Horizon 2020 research and
innovation programme under grant agreement No. 644334 (NEAT).<a href="#section-13-1" class="pilcrow">¶</a></p>
<p id="section-13-2">This work has been supported by Leibniz Prize project funds of DFG - German
Research Foundation: Gottfried Wilhelm Leibniz-Preis 2011 (FKZ FE 570/4-1).<a href="#section-13-2" class="pilcrow">¶</a></p>
<p id="section-13-3">This work has been supported by the UK Engineering and Physical Sciences
Research Council under grant EP/R04144X/1.<a href="#section-13-3" class="pilcrow">¶</a></p>
<p id="section-13-4">This work has been supported by the Research Council of Norway under its "Toppforsk"
programme through the "OCARINA" project.<a href="#section-13-4" class="pilcrow">¶</a></p>
<p id="section-13-5">Thanks to Stuart Cheshire, Josh Graessley, David Schinazi, and Eric Kinnear for their implementation and design efforts, including Happy Eyeballs, that heavily influenced this work.<a href="#section-13-5" class="pilcrow">¶</a></p>
</section>
</div>
<section id="section-14">
      <h2 id="name-references">
<a href="#section-14" class="section-number selfRef">14. </a><a href="#name-references" class="section-name selfRef">References</a>
      </h2>
<section id="section-14.1">
        <h3 id="name-normative-references">
<a href="#section-14.1" class="section-number selfRef">14.1. </a><a href="#name-normative-references" class="section-name selfRef">Normative References</a>
        </h3>
<dl class="references">
<dt id="I-D.ietf-taps-arch">[I-D.ietf-taps-arch]</dt>
<dd>
<span class="refAuthor">Pauly, T.</span><span class="refAuthor">, Trammell, B.</span><span class="refAuthor">, Brunstrom, A.</span><span class="refAuthor">, Fairhurst, G.</span><span class="refAuthor">, Perkins, C.</span><span class="refAuthor">, Tiesel, P.</span><span class="refAuthor">, and C. Wood</span>, <span class="refTitle">"An Architecture for Transport Services"</span>, <span class="refContent">Work in Progress</span>, <span class="seriesInfo">Internet-Draft, draft-ietf-taps-arch-06</span>, <time datetime="2019-12-23">23 December 2019</time>, <span>&lt;<a href="http://www.ietf.org/internet-drafts/draft-ietf-taps-arch-06.txt">http://www.ietf.org/internet-drafts/draft-ietf-taps-arch-06.txt</a>&gt;</span>. </dd>
<dt id="I-D.ietf-taps-interface">[I-D.ietf-taps-interface]</dt>
<dd>
<span class="refAuthor">Trammell, B.</span><span class="refAuthor">, Welzl, M.</span><span class="refAuthor">, Enghardt, T.</span><span class="refAuthor">, Fairhurst, G.</span><span class="refAuthor">, Kuehlewind, M.</span><span class="refAuthor">, Perkins, C.</span><span class="refAuthor">, Tiesel, P.</span><span class="refAuthor">, Wood, C.</span><span class="refAuthor">, and T. Pauly</span>, <span class="refTitle">"An Abstract Application Layer Interface to Transport Services"</span>, <span class="refContent">Work in Progress</span>, <span class="seriesInfo">Internet-Draft, draft-ietf-taps-interface-05</span>, <time datetime="2019-11-04">4 November 2019</time>, <span>&lt;<a href="http://www.ietf.org/internet-drafts/draft-ietf-taps-interface-05.txt">http://www.ietf.org/internet-drafts/draft-ietf-taps-interface-05.txt</a>&gt;</span>. </dd>
<dt id="I-D.ietf-taps-minset">[I-D.ietf-taps-minset]</dt>
<dd>
<span class="refAuthor">Welzl, M.</span><span class="refAuthor"> and S. Gjessing</span>, <span class="refTitle">"A Minimal Set of Transport Services for End Systems"</span>, <span class="refContent">Work in Progress</span>, <span class="seriesInfo">Internet-Draft, draft-ietf-taps-minset-11</span>, <time datetime="2018-09-27">27 September 2018</time>, <span>&lt;<a href="http://www.ietf.org/internet-drafts/draft-ietf-taps-minset-11.txt">http://www.ietf.org/internet-drafts/draft-ietf-taps-minset-11.txt</a>&gt;</span>. </dd>
<dt id="RFC7413">[RFC7413]</dt>
<dd>
<span class="refAuthor">Cheng, Y.</span><span class="refAuthor">, Chu, J.</span><span class="refAuthor">, Radhakrishnan, S.</span><span class="refAuthor">, and A. Jain</span>, <span class="refTitle">"TCP Fast Open"</span>, <span class="seriesInfo">RFC 7413</span>, <span class="seriesInfo">DOI 10.17487/RFC7413</span>, <time datetime="2014-12">December 2014</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc7413">https://www.rfc-editor.org/info/rfc7413</a>&gt;</span>. </dd>
<dt id="RFC7540">[RFC7540]</dt>
<dd>
<span class="refAuthor">Belshe, M.</span><span class="refAuthor">, Peon, R.</span><span class="refAuthor">, and M. Thomson, Ed.</span>, <span class="refTitle">"Hypertext Transfer Protocol Version 2 (HTTP/2)"</span>, <span class="seriesInfo">RFC 7540</span>, <span class="seriesInfo">DOI 10.17487/RFC7540</span>, <time datetime="2015-05">May 2015</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc7540">https://www.rfc-editor.org/info/rfc7540</a>&gt;</span>. </dd>
<dt id="RFC8260">[RFC8260]</dt>
<dd>
<span class="refAuthor">Stewart, R.</span><span class="refAuthor">, Tuexen, M.</span><span class="refAuthor">, Loreto, S.</span><span class="refAuthor">, and R. Seggelmann</span>, <span class="refTitle">"Stream Schedulers and User Message Interleaving for the Stream Control Transmission Protocol"</span>, <span class="seriesInfo">RFC 8260</span>, <span class="seriesInfo">DOI 10.17487/RFC8260</span>, <time datetime="2017-11">November 2017</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc8260">https://www.rfc-editor.org/info/rfc8260</a>&gt;</span>. </dd>
<dt id="RFC8303">[RFC8303]</dt>
<dd>
<span class="refAuthor">Welzl, M.</span><span class="refAuthor">, Tuexen, M.</span><span class="refAuthor">, and N. Khademi</span>, <span class="refTitle">"On the Usage of Transport Features Provided by IETF Transport Protocols"</span>, <span class="seriesInfo">RFC 8303</span>, <span class="seriesInfo">DOI 10.17487/RFC8303</span>, <time datetime="2018-02">February 2018</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc8303">https://www.rfc-editor.org/info/rfc8303</a>&gt;</span>. </dd>
<dt id="RFC8304">[RFC8304]</dt>
<dd>
<span class="refAuthor">Fairhurst, G.</span><span class="refAuthor"> and T. Jones</span>, <span class="refTitle">"Transport Features of the User Datagram Protocol (UDP) and Lightweight UDP (UDP-Lite)"</span>, <span class="seriesInfo">RFC 8304</span>, <span class="seriesInfo">DOI 10.17487/RFC8304</span>, <time datetime="2018-02">February 2018</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc8304">https://www.rfc-editor.org/info/rfc8304</a>&gt;</span>. </dd>
<dt id="RFC8305">[RFC8305]</dt>
<dd>
<span class="refAuthor">Schinazi, D.</span><span class="refAuthor"> and T. Pauly</span>, <span class="refTitle">"Happy Eyeballs Version 2: Better Connectivity Using Concurrency"</span>, <span class="seriesInfo">RFC 8305</span>, <span class="seriesInfo">DOI 10.17487/RFC8305</span>, <time datetime="2017-12">December 2017</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc8305">https://www.rfc-editor.org/info/rfc8305</a>&gt;</span>. </dd>
<dt id="RFC8446">[RFC8446]</dt>
<dd>
<span class="refAuthor">Rescorla, E.</span>, <span class="refTitle">"The Transport Layer Security (TLS) Protocol Version 1.3"</span>, <span class="seriesInfo">RFC 8446</span>, <span class="seriesInfo">DOI 10.17487/RFC8446</span>, <time datetime="2018-08">August 2018</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc8446">https://www.rfc-editor.org/info/rfc8446</a>&gt;</span>. </dd>
</dl>
</section>
<section id="section-14.2">
        <h3 id="name-informative-references">
<a href="#section-14.2" class="section-number selfRef">14.2. </a><a href="#name-informative-references" class="section-name selfRef">Informative References</a>
        </h3>
<dl class="references">
<dt id="I-D.ietf-quic-transport">[I-D.ietf-quic-transport]</dt>
<dd>
<span class="refAuthor">Iyengar, J.</span><span class="refAuthor"> and M. Thomson</span>, <span class="refTitle">"QUIC: A UDP-Based Multiplexed and Secure Transport"</span>, <span class="refContent">Work in Progress</span>, <span class="seriesInfo">Internet-Draft, draft-ietf-quic-transport-27</span>, <time datetime="2020-02-21">21 February 2020</time>, <span>&lt;<a href="http://www.ietf.org/internet-drafts/draft-ietf-quic-transport-27.txt">http://www.ietf.org/internet-drafts/draft-ietf-quic-transport-27.txt</a>&gt;</span>. </dd>
<dt id="NEAT-flow-mapping">[NEAT-flow-mapping]</dt>
<dd>
<span class="refTitle">"Transparent Flow Mapping for NEAT (in Workshop on Future of Internet Transport (FIT 2017))"</span>, <time datetime="2017">2017</time>. </dd>
<dt id="RFC5245">[RFC5245]</dt>
<dd>
<span class="refAuthor">Rosenberg, J.</span>, <span class="refTitle">"Interactive Connectivity Establishment (ICE): A Protocol for Network Address Translator (NAT) Traversal for Offer/Answer Protocols"</span>, <span class="seriesInfo">RFC 5245</span>, <span class="seriesInfo">DOI 10.17487/RFC5245</span>, <time datetime="2010-04">April 2010</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc5245">https://www.rfc-editor.org/info/rfc5245</a>&gt;</span>. </dd>
</dl>
</section>
</section>
<div id="appendix-non-consensus">
<section id="section-appendix.a">
      <h2 id="name-additional-properties">
<a href="#section-appendix.a" class="section-number selfRef">Appendix A. </a><a href="#name-additional-properties" class="section-name selfRef">Additional Properties</a>
      </h2>
<p id="section-appendix.a-1">This appendix discusses implementation considerations for additional parameters and properties that could be used to enhance transport protocol and/or path selection, or the transmission of messages given a Protocol Stack that implements them.
These are not part of the interface, and may be removed from the final document, but are presented here to support discussion within the TAPS working group as to whether they should be added to a future revision of the base specification.<a href="#section-appendix.a-1" class="pilcrow">¶</a></p>
<div id="branch-sorting-non-consensus">
<section id="section-a.1">
        <h2 id="name-properties-affecting-sortin">
<a href="#section-a.1" class="section-number selfRef">A.1. </a><a href="#name-properties-affecting-sortin" class="section-name selfRef">Properties Affecting Sorting of Branches</a>
        </h2>
<p id="section-a.1-1">In addition to the Protocol and Path Selection Properties discussed in <a href="#branch-sorting" class="xref">Section 4.3</a>, the following properties under discussion can influence branch sorting:<a href="#section-a.1-1" class="pilcrow">¶</a></p>
<ul>
<li id="section-a.1-2.1">Bounds on Send or Receive Rate:
If the application indicates a bound on the expected Send or Receive bitrate, an implementation may prefer a path that can likely provide the desired bandwidth, based on cached maximum throughput, see <a href="#performance-caches" class="xref">Section 9.2</a>. The application may know the Send or Receive Bitrate from metadata in adaptive HTTP streaming, such as MPEG-DASH.<a href="#section-a.1-2.1" class="pilcrow">¶</a>
</li>
<li id="section-a.1-2.2">Cost Preferences:
If the application indicates a preference to avoid expensive paths, and some paths are associated with a monetary cost, an implementation should decrease the ranking of such paths. If the application indicates that it prohibits using expensive paths, paths that are associated with a cost should be purged from the decision tree.<a href="#section-a.1-2.2" class="pilcrow">¶</a>
</li>
</ul>
</section>
</div>
</section>
</div>
<div id="appendix-reasons-errors">
<section id="section-appendix.b">
      <h2 id="name-reasons-for-errors">
<a href="#section-appendix.b" class="section-number selfRef">Appendix B. </a><a href="#name-reasons-for-errors" class="section-name selfRef">Reasons for errors</a>
      </h2>
<p id="section-appendix.b-1">The Transport Services API <span>[<a href="#I-D.ietf-taps-interface" class="xref">I-D.ietf-taps-interface</a>]</span> allows for the several generic error types to specify a more detailed reason as to why an error occurred. This appendix lists some of the possible reasons.<a href="#section-appendix.b-1" class="pilcrow">¶</a></p>
<ul>
<li id="section-appendix.b-2.1">InvalidConfiguration:
The transport properties and endpoints provided by the application are either contradictory or incomplete. Examples include the lack of a remote endpoint on an active open or using a multicast group address while not requesting a unidirectional receive.<a href="#section-appendix.b-2.1" class="pilcrow">¶</a>
</li>
<li id="section-appendix.b-2.2">NoCandidates:
The configuration is valid, but none of the available transport protocols can satisfy the transport properties provided by the application.<a href="#section-appendix.b-2.2" class="pilcrow">¶</a>
</li>
<li id="section-appendix.b-2.3">ResolutionFailed:
The remote or local specifier provided by the application can not be resolved.<a href="#section-appendix.b-2.3" class="pilcrow">¶</a>
</li>
<li id="section-appendix.b-2.4">EstablishmentFailed:
The TAPS system was unable to establish a transport-layer connection to the remote endpoint specified by the application.<a href="#section-appendix.b-2.4" class="pilcrow">¶</a>
</li>
<li id="section-appendix.b-2.5">PolicyProhibited:
The system policy prevents the transport system from performing the action requested by the application.<a href="#section-appendix.b-2.5" class="pilcrow">¶</a>
</li>
<li id="section-appendix.b-2.6">NotCloneable:
The protocol stack is not capable of being cloned.<a href="#section-appendix.b-2.6" class="pilcrow">¶</a>
</li>
<li id="section-appendix.b-2.7">MessageTooLarge:
The message size is too big for the transport system to handle.<a href="#section-appendix.b-2.7" class="pilcrow">¶</a>
</li>
<li id="section-appendix.b-2.8">ProtocolFailed:
The underlying protocol stack failed.<a href="#section-appendix.b-2.8" class="pilcrow">¶</a>
</li>
<li id="section-appendix.b-2.9">InvalidMessageProperties:
The message properties are either contradictory to the transport properties or they can not be satisfied by the transport system.<a href="#section-appendix.b-2.9" class="pilcrow">¶</a>
</li>
<li id="section-appendix.b-2.10">DeframingFailed:
The data that was received by the underlying protocol stack could not be deframed.<a href="#section-appendix.b-2.10" class="pilcrow">¶</a>
</li>
<li id="section-appendix.b-2.11">ConnectionAborted:
The connection was aborted by the peer.<a href="#section-appendix.b-2.11" class="pilcrow">¶</a>
</li>
<li id="section-appendix.b-2.12">Timeout:
Delivery of a message was not possible after a timeout.<a href="#section-appendix.b-2.12" class="pilcrow">¶</a>
</li>
</ul>
</section>
</div>
<div id="appendix-implementations">
<section id="section-appendix.c">
      <h2 id="name-existing-implementations">
<a href="#section-appendix.c" class="section-number selfRef">Appendix C. </a><a href="#name-existing-implementations" class="section-name selfRef">Existing Implementations</a>
      </h2>
<p id="section-appendix.c-1">This appendix gives an overview of existing implementations, at the time of writing, of transport systems that are (to some degree) in line with this document.<a href="#section-appendix.c-1" class="pilcrow">¶</a></p>
<ul>
<li id="section-appendix.c-2.1">
          <p id="section-appendix.c-2.1.1">Apple's Network.framework:<a href="#section-appendix.c-2.1.1" class="pilcrow">¶</a></p>
<ul>
<li id="section-appendix.c-2.1.2.1">Network.framework is a transport-level API built for C, Objective-C, and Swift. It a connect-by-name API that supports transport security protocols. It provides userspace implementations of TCP, UDP, TLS, DTLS, proxy protocols, and allows extension via custom framers.<a href="#section-appendix.c-2.1.2.1" class="pilcrow">¶</a>
</li>
<li id="section-appendix.c-2.1.2.2">Documentation: <a href="https://developer.apple.com/documentation/network">https://developer.apple.com/documentation/network</a><a href="#section-appendix.c-2.1.2.2" class="pilcrow">¶</a>
</li>
</ul>
</li>
<li id="section-appendix.c-2.2">
          <p id="section-appendix.c-2.2.1">NEAT:<a href="#section-appendix.c-2.2.1" class="pilcrow">¶</a></p>
<ul>
<li id="section-appendix.c-2.2.2.1">NEAT is the output of the European H2020 research project "NEAT"; it is a user-space library for protocol-independent communication on top of TCP, UDP and SCTP, with many more features such as a policy manager.<a href="#section-appendix.c-2.2.2.1" class="pilcrow">¶</a>
</li>
<li id="section-appendix.c-2.2.2.2">Code: <a href="https://github.com/NEAT-project/neat">https://github.com/NEAT-project/neat</a><a href="#section-appendix.c-2.2.2.2" class="pilcrow">¶</a>
</li>
<li id="section-appendix.c-2.2.2.3">NEAT project: <a href="https://www.neat-project.org">https://www.neat-project.org</a><a href="#section-appendix.c-2.2.2.3" class="pilcrow">¶</a>
</li>
</ul>
</li>
<li id="section-appendix.c-2.3">
          <p id="section-appendix.c-2.3.1">PyTAPS:<a href="#section-appendix.c-2.3.1" class="pilcrow">¶</a></p>
<ul>
<li id="section-appendix.c-2.3.2.1">A TAPS implementation based on Python asyncio, offering protocol-independent communication to applications on top of TCP, UDP and TLS, with support for multicast.<a href="#section-appendix.c-2.3.2.1" class="pilcrow">¶</a>
</li>
<li id="section-appendix.c-2.3.2.2">Code: <a href="https://github.com/fg-inet/python-asyncio-taps">https://github.com/fg-inet/python-asyncio-taps</a><a href="#section-appendix.c-2.3.2.2" class="pilcrow">¶</a>
</li>
</ul>
</li>
</ul>
</section>
</div>
<div id="authors-addresses">
<section id="section-appendix.d">
      <h2 id="name-authors-addresses">
<a href="#name-authors-addresses" class="section-name selfRef">Authors' Addresses</a>
      </h2>
<address class="vcard">
        <div dir="auto" class="left"><span class="fn nameRole">Anna Brunstrom (<span class="role">editor</span>)</span></div>
<div dir="auto" class="left"><span class="org">Karlstad University</span></div>
<div dir="auto" class="left"><span class="street-address">Universitetsgatan 2</span></div>
<div dir="auto" class="left"><span class="locality">651 88 Karlstad</span></div>
<div dir="auto" class="left"><span class="country-name">Sweden</span></div>
<div class="email">
<span>Email:</span>
<a href="mailto:anna.brunstrom@kau.se" class="email">anna.brunstrom@kau.se</a>
</div>
</address>
<address class="vcard">
        <div dir="auto" class="left"><span class="fn nameRole">Tommy Pauly (<span class="role">editor</span>)</span></div>
<div dir="auto" class="left"><span class="org">Apple Inc.</span></div>
<div dir="auto" class="left"><span class="street-address">One Apple Park Way</span></div>
<div dir="auto" class="left">
<span class="locality">Cupertino, California 95014</span>,  </div>
<div dir="auto" class="left"><span class="country-name">United States of America</span></div>
<div class="email">
<span>Email:</span>
<a href="mailto:tpauly@apple.com" class="email">tpauly@apple.com</a>
</div>
</address>
<address class="vcard">
        <div dir="auto" class="left"><span class="fn nameRole">Theresa Enghardt</span></div>
<div dir="auto" class="left"><span class="org">TU Berlin</span></div>
<div dir="auto" class="left"><span class="street-address">Marchstrasse 23</span></div>
<div dir="auto" class="left"><span class="locality">10587 Berlin</span></div>
<div dir="auto" class="left"><span class="country-name">Germany</span></div>
<div class="email">
<span>Email:</span>
<a href="mailto:theresa@inet.tu-berlin.de" class="email">theresa@inet.tu-berlin.de</a>
</div>
</address>
<address class="vcard">
        <div dir="auto" class="left"><span class="fn nameRole">Karl-Johan Grinnemo</span></div>
<div dir="auto" class="left"><span class="org">Karlstad University</span></div>
<div dir="auto" class="left"><span class="street-address">Universitetsgatan 2</span></div>
<div dir="auto" class="left"><span class="locality">651 88 Karlstad</span></div>
<div dir="auto" class="left"><span class="country-name">Sweden</span></div>
<div class="email">
<span>Email:</span>
<a href="mailto:karl-johan.grinnemo@kau.se" class="email">karl-johan.grinnemo@kau.se</a>
</div>
</address>
<address class="vcard">
        <div dir="auto" class="left"><span class="fn nameRole">Tom Jones</span></div>
<div dir="auto" class="left"><span class="org">University of Aberdeen</span></div>
<div dir="auto" class="left"><span class="street-address">Fraser Noble Building</span></div>
<div dir="auto" class="left"><span class="locality">Aberdeen, AB24 3UE</span></div>
<div dir="auto" class="left"><span class="country-name">United Kingdom</span></div>
<div class="email">
<span>Email:</span>
<a href="mailto:tom@erg.abdn.ac.uk" class="email">tom@erg.abdn.ac.uk</a>
</div>
</address>
<address class="vcard">
        <div dir="auto" class="left"><span class="fn nameRole">Philipp S. Tiesel</span></div>
<div dir="auto" class="left"><span class="org">TU Berlin</span></div>
<div dir="auto" class="left"><span class="street-address">Einsteinufer 25</span></div>
<div dir="auto" class="left"><span class="locality">10587 Berlin</span></div>
<div dir="auto" class="left"><span class="country-name">Germany</span></div>
<div class="email">
<span>Email:</span>
<a href="mailto:philipp@tiesel.net" class="email">philipp@tiesel.net</a>
</div>
</address>
<address class="vcard">
        <div dir="auto" class="left"><span class="fn nameRole">Colin Perkins</span></div>
<div dir="auto" class="left"><span class="org">University of Glasgow</span></div>
<div dir="auto" class="left"><span class="street-address">School of Computing Science</span></div>
<div dir="auto" class="left"><span class="locality">Glasgow G12 8QQ</span></div>
<div dir="auto" class="left"><span class="country-name">United Kingdom</span></div>
<div class="email">
<span>Email:</span>
<a href="mailto:csp@csperkins.org" class="email">csp@csperkins.org</a>
</div>
</address>
<address class="vcard">
        <div dir="auto" class="left"><span class="fn nameRole">Michael Welzl</span></div>
<div dir="auto" class="left"><span class="org">University of Oslo</span></div>
<div dir="auto" class="left"><span class="street-address">PO Box 1080 Blindern</span></div>
<div dir="auto" class="left"><span class="locality">0316  Oslo</span></div>
<div dir="auto" class="left"><span class="country-name">Norway</span></div>
<div class="email">
<span>Email:</span>
<a href="mailto:michawe@ifi.uio.no" class="email">michawe@ifi.uio.no</a>
</div>
</address>
</section>
</div>
<script>const toc = document.getElementById("toc");
toc.querySelector("h2").addEventListener("click", e => {
  toc.classList.toggle("active");
});
toc.querySelector("nav").addEventListener("click", e => {
  toc.classList.remove("active");
});
</script>
</body>
</html>
