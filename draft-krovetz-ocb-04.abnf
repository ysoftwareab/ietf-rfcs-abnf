L_0 = double(L_$)
L_i = double(L_{i-1}) for every integer i > 0
   
A == A_1 || A_2 || ... || A_m || A_*, and
Sum_0 = zeros(128)
Offset_0 = zeros(128)
Offset_i = Offset_{i-1} xor L_{ntz(i)}
Sum_i = Sum_{i-1} xor ENCIPHER(K, A_i xor Offset_i)
CipherInput = (A_* || 1 || zeros(127-bitlen(A_*))) xor Offset_*
Sum = Sum_m xor ENCIPHER(K, CipherInput)
Sum = Sum_m
L_0 = double(L_$)
L_i = double(L_{i-1}) for every integer i > 0
   
P == P_1 || P_2 || ... || P_m || P_*, and
Nonce = zeros(127-bitlen(N)) || 1 || N
bottom = str2num(Nonce[123..128])
Ktop = ENCIPHER(K, Nonce[1..122] || zeros(6))
Stretch = Ktop || (Ktop[1..64] xor Ktop[9..72])
Offset_0 = Stretch[1+bottom..128+bottom]
Checksum_0 = zeros(128)
   
Offset_i = Offset_{i-1} xor L_{ntz(i)}
C_i = Offset_i xor ENCIPHER(K, P_i xor Offset_i)
Checksum_i = Checksum_{i-1} xor P_i
Pad = ENCIPHER(K, Offset_*)
Tag = ENCIPHER(K, Checksum_* xor Offset_* xor L_$) xor HASH(K,A)
Tag = ENCIPHER(K, Checksum_m xor Offset_m xor L_$) xor HASH(K,A)
C = C_1 || C_2 || ... || C_m || C_* || Tag[1..TAGLEN]

L_0 = double(L_$)
L_i = double(L_{i-1}) for every integer i > 0
   
C == C_1 || C_2 || ... || C_m || C_* || T,
Nonce = zeros(127-bitlen(N)) || 1 || N
bottom = str2num(Nonce[123..128])
Ktop = ENCIPHER(K, Nonce[1..122] || zeros(6))
Stretch = Ktop || (Ktop[1..64] xor Ktop[9..72])
Offset_0 = Stretch[1+bottom..128+bottom]
Checksum_0 = zeros(128)
   
Offset_i = Offset_{i-1} xor L_{ntz(i)}
P_i = Offset_i xor DECIPHER(K, C_i xor Offset_i)
Checksum_i = Checksum_{i-1} xor P_i
Pad = ENCIPHER(K, Offset_*)
Tag = ENCIPHER(K, Checksum_* xor Offset_* xor L_$) xor HASH(K,A)
Tag = ENCIPHER(K, Checksum_m xor Offset_m xor L_$) xor HASH(K,A)
P = P_1 || P_2 || ... || P_m || P_*
P = INVALID
K = zeros(KEYLEN)           // Keylength of AES in use
S = zeros(8i)            // i bytes of zeros
N = zeros(88) || <i>     // 11 byte zero followed by 1 byte i
C = C || OCB-ENCRYPT(K,N,S,S)
C = C || OCB-ENCRYPT(K,N,<empty string>,S)
C = C || OCB-ENCRYPT(K,N,S,<empty string>)
N = zeros(96)
