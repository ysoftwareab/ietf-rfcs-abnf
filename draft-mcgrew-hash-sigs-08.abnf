D_PBLC = 0x8080 when computing the hash of all of the iterates
D_MESG = 0x8181 when computing the hash of the message in the
D_LEAF = 0x8282 when computing the hash of the leaf of an LMS
D_INTR = 0x8383 when computing the hash of an interior node of
i = a value between 0 and 264; this is used in the LM-OTS
tmp = x[i]
tmp = H(I || u32str(q) || u16str(i) || u8str(j) || tmp)
K = H(I || u32str(q) || u16str(D_PBLC) || y[0] || ... || y[p-1])

sum = 0
sum = sum + (2^w - 1) - coef(S, i, w)
Q = H(I || u32str(q) || u16str(D_MESG) || C || message)
a = coef(Q || Cksm(Q), i, w)
tmp = x[i]
tmp = H(I || u32str(q) || u16str(i) || u8str(j) || tmp)
Q = H(I || u32str(q) || u16str(D_MESG) || C || message)
a = coef(Q || Cksm(Q), i, w)
tmp = y[i]
tmp = H(I || u32str(q) || u16str(i) || u8str(j) || tmp)
Kc = H(I || u32str(q) || u16str(D_PBLC) || z[0] || z[1] || ... || z[p-1])

node_num = 2^h + q
tmp = H(I || u32str(node_num) || u16str(D_LEAF) || Kc)
i = 0
tmp = H(I||u32str(node_num/2)||u16str(D_INTR)||path[i]||tmp)
tmp = H(I||u32str(node_num/2)||u16str(D_INTR)||tmp||path[i])
node_num = node_num/2
i = i + 1
Tc = tmp
Nspk = strTou32(first four bytes of S)
key = pub
sig = siglist[i]
msg = publist[i]
key = msg
lmots_reserved       = 0,
lmots_sha256_n32_w1  = 1,
lmots_sha256_n32_w2  = 2,
lmots_sha256_n32_w4  = 3,
lmots_sha256_n32_w8  = 4
hbs_reserved       = 0,
lms_sha256_n32_h5  = 5,
lms_sha256_n32_h10 = 6,
lms_sha256_n32_h15 = 7,
lms_sha256_n32_h20 = 8,
lms_sha256_n32_h25 = 9,
c = Cksm(H(message)) (see Section 4.6).  To attempt a forgery, an
a = coef(h, j, w), and

b = coef(c, k, w), and

u = ceil(8*n/w)
v = ceil((floor(lg((2^w - 1) * u)) + 1) / w)
ls = 16 - (v * w)
p = u + v

r = i + num_lmots_keys;
temp = H(I || u32str(r) || u16str(D_LEAF) || OTS_PUBKEY[i])
j = i;
r = (r - 1)/2;
j = (j-1) / 2;
left_side = pop(data stack);
temp = H(I || u32str(r) || u16str(D_INTR) || left_side || temp)
public_key = pop(data stack)

