<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="en"><head><title>Object-based pNFS Operations</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="description" content="Object-based pNFS Operations">
<meta name="generator" content="xml2rfc v1.35 (http://xml.resource.org/)">
<meta name="viewport" content="width=600;" />
<style type='text/css'><!--
        body {
                font-family: verdana, charcoal, helvetica, arial, sans-serif;
                font-size: 85%;
		max-width: 40em; 
		color: #000; background-color: #FFF;
                margin: 2em;
        }
        h1, h2, h3, h4, h5, h6 {
                font-family: helvetica, monaco, "MS Sans Serif", arial, sans-serif;
                font-weight: bold; font-style: normal;
        }
        h1 { color: #900; background-color: transparent; text-align: right; }
        h3 { color: #333; background-color: transparent; }

        td.RFCbug {
                font-size: x-small; text-decoration: none;
                width: 30px; height: 30px; padding-top: 2px;
                text-align: justify; vertical-align: middle;
                background-color: #000;
        }
        td.RFCbug span.RFC {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: bold; color: #666;
        }
        td.RFCbug span.hotText {
                font-family: charcoal, monaco, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: normal; text-align: center; color: #FFF;
        }

        table.TOCbug { width: 30px; height: 15px; }
        td.TOCbug {
                text-align: center; width: 30px; height: 15px;
                color: #FFF; background-color: #900;
        }
        td.TOCbug a {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, sans-serif;
                font-weight: bold; font-size: x-small; text-decoration: none;
                color: #FFF; background-color: transparent;
        }

        td.header {
                font-family: arial, helvetica, sans-serif; font-size: x-small;
                vertical-align: top; width: 33%;
                color: #FFF; background-color: #666;
        }
        td.author { font-weight: bold; font-size: x-small; margin-left: 4em; }
        td.author-text { font-size: x-small; }

        /* info code from SantaKlauss at http://www.madaboutstyle.com/tooltip2.html */
        a.info {
                /* This is the key. */
                position: relative;
                z-index: 24;
                text-decoration: none;
        }
        a.info:hover {
                z-index: 25;
                color: #FFF; background-color: #900;
        }
        a.info span { display: none; }
        a.info:hover span.info {
                /* The span will display just on :hover state. */
                display: block;
                position: absolute;
                font-size: smaller;
                top: 2em; left: -5em; width: 15em;
                padding: 2px; border: 1px solid #333;
                color: #900; background-color: #EEE;
                text-align: left;
        }

        a { font-weight: bold; }
        a:link    { color: #900; background-color: transparent; }
        a:visited { color: #633; background-color: transparent; }
        a:active  { color: #633; background-color: transparent; }

        p { margin-left: 2em; margin-right: 2em; }
        p.copyright { font-size: x-small; }
        p.toc { font-size: 85%;
		max-width: 40em; 
		font-weight: bold; margin-left: 3em; }
        table.toc { margin: 0 0 0 3em; padding: 0; border: 0; vertical-align: text-top; }
        td.toc { font-size: 85%;
		max-width: 40em; 
		font-weight: bold; vertical-align: text-top; }

        ol.text { margin-left: 2em; margin-right: 2em; }
        ul.text { margin-left: 2em; margin-right: 2em; }
        li      { margin-left: 3em; }

        /* RFC-2629 <spanx>s and <artwork>s. */
        em     { font-style: italic; }
        strong { font-weight: bold; }
        dfn    { font-weight: bold; font-style: normal; }
        cite   { font-weight: normal; font-style: normal; }
        tt     { color: #036; }
        tt, pre, pre dfn, pre em, pre cite, pre span {
                font-family: "Courier New", Courier, monospace; font-size: small;
        }
        pre {
                text-align: left; padding: 4px;
                color: #000; background-color: #CCC;
        }
        pre dfn  { color: #900; }
        pre em   { color: #66F; background-color: #FFC; font-weight: normal; }
        pre .key { color: #33C; font-weight: bold; }
        pre .id  { color: #900; }
        pre .str { color: #000; background-color: #CFF; }
        pre .val { color: #066; }
        pre .rep { color: #909; }
        pre .oth { color: #000; background-color: #FCF; }
        pre .err { background-color: #FCC; }

        /* RFC-2629 <texttable>s. */
        table.all, table.full, table.headers, table.none {
                font-size: 85%;
		max-width: 40em; 
		text-align: center; border-width: 2px;
                vertical-align: top; border-collapse: collapse;
        }
        table.all, table.full { border-style: solid; border-color: black; }
        table.headers, table.none { border-style: none; }
        th {
                font-weight: bold; border-color: black;
                border-width: 2px 2px 3px 2px;
        }
        table.all th, table.full th { border-style: solid; }
        table.headers th { border-style: none none solid none; }
        table.none th { border-style: none; }
        table.all td {
                border-style: solid; border-color: #333;
                border-width: 1px 2px;
        }
        table.full td, table.headers td, table.none td { border-style: none; }

        hr { height: 1px; }
        hr.insert {
                width: 80%; border-style: none; border-width: 0;
                color: #CCC; background-color: #CCC;
        }
--></style>
</head>
<body>
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<table summary="layout" width="66%" border="0" cellpadding="0" cellspacing="0"><tr><td><table summary="layout" width="100%" border="0" cellpadding="2" cellspacing="1">
<tr><td class="header">NFSv4</td><td class="header">B. Halevy</td></tr>
<tr><td class="header">Internet-Draft</td><td class="header">B. Welch</td></tr>
<tr><td class="header">Intended status: Standards Track</td><td class="header">J. Zelenka</td></tr>
<tr><td class="header">Expires: December 21, 2008</td><td class="header">Panasas</td></tr>
<tr><td class="header">&nbsp;</td><td class="header">June 19, 2008</td></tr>
</table></td></tr></table>
<h1><br />Object-based pNFS Operations<br />draft-ietf-nfsv4-pnfs-obj-09</h1>

<h3>Status of this Memo</h3>
<p>
By submitting this Internet-Draft,
each author represents that any applicable patent or other IPR claims of which
he or she is aware have been or will be disclosed,
and any of which he or she becomes aware will be disclosed,
in accordance with Section&nbsp;6 of BCP&nbsp;79.</p>
<p>
Internet-Drafts are working documents of the Internet Engineering
Task Force (IETF), its areas, and its working groups.
Note that other groups may also distribute working documents as
Internet-Drafts.</p>
<p>
Internet-Drafts are draft documents valid for a maximum of six months
and may be updated, replaced, or obsoleted by other documents at any time.
It is inappropriate to use Internet-Drafts as reference material or to cite
them other than as &ldquo;work in progress.&rdquo;</p>
<p>
The list of current Internet-Drafts can be accessed at
<a href='http://www.ietf.org/ietf/1id-abstracts.txt'>http://www.ietf.org/ietf/1id-abstracts.txt</a>.</p>
<p>
The list of Internet-Draft Shadow Directories can be accessed at
<a href='http://www.ietf.org/shadow.html'>http://www.ietf.org/shadow.html</a>.</p>
<p>
This Internet-Draft will expire on December 21, 2008.</p>

<h3>Abstract</h3>

<p>
      This Internet-Draft provides a description of the object-based
      pNFS extension for NFSv4.  This is a companion to the main
      pnfs specification in the NFSv4 Minor Version 1 Internet Draft,
      which is currently draft-ietf-nfsv4-minorversion1-23.
      
</p>
<h3>Requirements Language</h3>

<p>The key words &quot;MUST&quot;, &quot;MUST NOT&quot;,
&quot;REQUIRED&quot;, &quot;SHALL&quot;, &quot;SHALL NOT&quot;,
&quot;SHOULD&quot;, &quot;SHOULD NOT&quot;, &quot;RECOMMENDED&quot;,
&quot;MAY&quot;, and &quot;OPTIONAL&quot; in this document are to be
interpreted as described in <a class='info' href='#RFC2119'>RFC 2119<span> (</span><span class='info'>Bradner, S., &ldquo;Key words for use in RFCs to Indicate Requirement Levels,&rdquo; March&nbsp;1997.</span><span>)</span></a> [1].

</p><a name="toc"></a><br /><hr />
<h3>Table of Contents</h3>
<p class="toc">
<a href="#anchor1">1.</a>&nbsp;
Introduction<br />
<a href="#xdr_desc">2.</a>&nbsp;
XDR Description of the Objects-Based Layout Protocol<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor2">2.1.</a>&nbsp;
Basic Data Type Definitions<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#pnfs_osd_objid4">2.1.1.</a>&nbsp;
pnfs_osd_objid4<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#pnfs_osd_version4">2.1.2.</a>&nbsp;
pnfs_osd_version4<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#pnfs_osd_object_cred4">2.1.3.</a>&nbsp;
pnfs_osd_object_cred4<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#pnfs_osd_raid_algorithm4">2.1.4.</a>&nbsp;
pnfs_osd_raid_algorithm4<br />
<a href="#anchor3">3.</a>&nbsp;
Object Storage Device Addressing and Discovery<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#pnfs_osd_targetid_type4">3.1.</a>&nbsp;
pnfs_osd_targetid_type4<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#pnfs_osd_deviceaddr4">3.2.</a>&nbsp;
pnfs_osd_deviceaddr4<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor4">3.2.1.</a>&nbsp;
SCSI Target Identifier<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor5">3.2.2.</a>&nbsp;
Device Network Address<br />
<a href="#anchor6">4.</a>&nbsp;
Object-Based Layout<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#pnfs_osd_data_map4">4.1.</a>&nbsp;
pnfs_osd_data_map4<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#pnfs_osd_layout4">4.2.</a>&nbsp;
pnfs_osd_layout4<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#Data Mapping Schemes">4.3.</a>&nbsp;
Data Mapping Schemes<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#Simple Striping">4.3.1.</a>&nbsp;
Simple Striping<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#Nested Striping">4.3.2.</a>&nbsp;
Nested Striping<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#Mirroring">4.3.3.</a>&nbsp;
Mirroring<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#RAID Algorithms">4.4.</a>&nbsp;
RAID Algorithms<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#PNFS_OSD_RAID_0">4.4.1.</a>&nbsp;
PNFS_OSD_RAID_0<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#PNFS_OSD_RAID_4">4.4.2.</a>&nbsp;
PNFS_OSD_RAID_4<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#PNFS_OSD_RAID_5">4.4.3.</a>&nbsp;
PNFS_OSD_RAID_5<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#PNFS_OSD_RAID_PQ">4.4.4.</a>&nbsp;
PNFS_OSD_RAID_PQ<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor7">4.4.5.</a>&nbsp;
RAID Usage and Implementation Notes<br />
<a href="#anchor8">5.</a>&nbsp;
Object-Based Layout Update<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#pnfs_osd_deltaspaceused4">5.1.</a>&nbsp;
pnfs_osd_deltaspaceused4<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#pnfs_osd_layoutupdate4">5.2.</a>&nbsp;
pnfs_osd_layoutupdate4<br />
<a href="#anchor9">6.</a>&nbsp;
Recovering from Client I/O Errors<br />
<a href="#anchor10">7.</a>&nbsp;
Object-Based Layout Return<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#pnfs_osd_errno4">7.1.</a>&nbsp;
pnfs_osd_errno4<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#pnfs_osd_ioerr4">7.2.</a>&nbsp;
pnfs_osd_ioerr4<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#pnfs_osd_layoutreturn4">7.3.</a>&nbsp;
pnfs_osd_layoutreturn4<br />
<a href="#anchor11">8.</a>&nbsp;
Object-Based Creation Layout Hint<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#pnfs_osd_layouthint4">8.1.</a>&nbsp;
pnfs_osd_layouthint4<br />
<a href="#anchor12">9.</a>&nbsp;
Layout Segments<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor13">9.1.</a>&nbsp;
CB_LAYOUTRECALL and LAYOUTRETURN<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor14">9.2.</a>&nbsp;
LAYOUTCOMMIT<br />
<a href="#anchor15">10.</a>&nbsp;
Recalling Layouts<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#CB_RECALL_ANY">10.1.</a>&nbsp;
CB_RECALL_ANY<br />
<a href="#Client Fencing">11.</a>&nbsp;
Client Fencing<br />
<a href="#Security Considerations">12.</a>&nbsp;
Security Considerations<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#OSD Security Data Types">12.1.</a>&nbsp;
OSD Security Data Types<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor16">12.2.</a>&nbsp;
The OSD Security Protocol<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor17">12.3.</a>&nbsp;
Protocol Privacy Requirements<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#Revoking Capabilities">12.4.</a>&nbsp;
Revoking Capabilities<br />
<a href="#IANA Considerations">13.</a>&nbsp;
IANA Considerations<br />
<a href="#rfc.references1">14.</a>&nbsp;
References<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#rfc.references1">14.1.</a>&nbsp;
Normative References<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#rfc.references2">14.2.</a>&nbsp;
Informative References<br />
<a href="#anchor20">Appendix&nbsp;A.</a>&nbsp;
Acknowledgments<br />
<a href="#rfc.authors">&#167;</a>&nbsp;
Authors' Addresses<br />
<a href="#rfc.copyright">&#167;</a>&nbsp;
Intellectual Property and Copyright Statements<br />
</p>
<br clear="all" />

<a name="anchor1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1"></a><h3>1.&nbsp;
Introduction</h3>

<p>
In pNFS, the file server returns typed layout structures that describe where
file data is located.  There are different layouts for different storage systems
and methods of arranging data on storage devices.  This document describes
the layouts used 
with object-based storage devices (OSD) that are accessed
according to the OSD storage protocol standard
(<a class='info' href='#osd standard'>SNIA T10/1355-D<span> (</span><span class='info'>Weber, R., &ldquo;SCSI Object-Based Storage Device Commands,&rdquo; July&nbsp;2004.</span><span>)</span></a> [2]).
 
</p>
<p>
An "object" is a container for data and attributes, and files are stored in
one or more objects.  The OSD protocol specifies several operations on
objects, including READ, WRITE, FLUSH, GET ATTRIBUTES, SET ATTRIBUTES, CREATE and DELETE.
However, using the object-based layout the client only uses the READ, WRITE, GET ATTRIBUTES and FLUSH
commands. The other commands are only used by the pNFS server.
 
</p>
<p>
An object-based layout for pNFS includes object identifiers, capabilities
that allow clients to READ or WRITE those objects, and various parameters
that control how file data is striped across their component objects.
The OSD protocol 
has a capability-based security scheme that allows the
pNFS server to control what operations and what objects can be used by clients.
This scheme is described in more detail in the 
<a class='info' href='#Security Considerations'>Security Considerations section<span> (</span><span class='info'>Security Considerations</span><span>)</span></a>.
 
</p>
<a name="xdr_desc"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2"></a><h3>2.&nbsp;
XDR Description of the Objects-Based Layout Protocol</h3>

<p>
This document contains the <a class='info' href='#XDR'>XDR<span> (</span><span class='info'>Eisler, M., &ldquo;XDR: External Data Representation Standard,&rdquo; May&nbsp;2006.</span><span>)</span></a> [3] description of the
NFSv4.1 objects layout protocol.
The XDR description is embedded in this document in a way that makes it simple
for the reader to extract into a ready to compile form.
The reader can feed this document into the following shell script to produce
the machine readable XDR description of the NFSv4.1 objects layout protocol:
 
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
#!/bin/sh
grep '^ *///' $* | sed 's?^ *///??'
</pre></div>
<p>
I.e. if the above script is stored in a file called "extract.sh", and
this document is in a file called "spec.txt", then the reader can do:
 
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
sh extract.sh &lt; spec.txt &gt; pnfs_osd_prot.x
</pre></div>
<p>
The effect of the script is to remove leading white space from each
line, plus a sentinel sequence of "///".
 
</p>
<p>
The embedded XDR file header follows.
Subsequent XDR descriptions, with the sentinel sequence are
embedded throughout the document.
 
</p>
<p>
Note that the XDR code contained in this document depends on types from
the NFSv4.1 nfs4_prot.x file (<a class='info' href='#NFS41_DOT_X'>[8]<span> (</span><span class='info'>Shepler, S., Eisler, M., and D. Noveck, &ldquo;NFSv4 Minor Version 1 XDR Description,&rdquo; May&nbsp;2008.</span><span>)</span></a>).
This includes both nfs types that end with a 4,
such as offset4, length4, etc,
as well as more generic types such as uint32_t and uint64_t.
 
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
////*
/// * This file was machine generated for
/// * draft-ietf-nfsv4-pnfs-obj-09
/// * Last updated Thu Jun 19 07:35:44 UTC 2008
/// *
/// * Copyright (C) The IETF Trust (2007-2008)
/// * All Rights Reserved.
/// *
/// * Copyright (C) The Internet Society (1998-2006).
/// * All Rights Reserved.
/// */
///
////*
/// * pnfs_osd_prot.x
/// */
///
///%#include &lt;nfs4_prot.x&gt;
///
</pre></div>
<a name="anchor2"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2.1"></a><h3>2.1.&nbsp;
Basic Data Type Definitions</h3>

<p>
The following sections define basic data types and constants
used by the Object-Based Layout protocol.
 
</p>
<a name="pnfs_osd_objid4"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2.1.1"></a><h3>2.1.1.&nbsp;
pnfs_osd_objid4</h3>

<p>
An object is identified by a number, somewhat like an inode number.
The object storage model has a two level scheme, where the objects
within an object storage device are grouped into partitions.
  
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
///struct pnfs_osd_objid4 {
///    deviceid4       oid_device_id;
///    uint64_t        oid_partition_id;
///    uint64_t        oid_object_id;
///};
///
</pre></div>
<p>
The pnfs_osd_objid4 type is used to identify an object within a partition
on a specified object storage device.
"oid_device_id" selects the
object storage device from the set of available storage devices.
The device is identified with the deviceid4 type, which
is an index into addressing information about that device
returned by the GETDEVICELIST and GETDEVICEINFO operations.
The deviceid4 data type is defined in
<a class='info' href='#NFSv4.1'>NFSv4.1 draft<span> (</span><span class='info'>Shepler, S., Eisler, M., and D. Noveck, &ldquo;NFSv4 Minor Version 1,&rdquo; May&nbsp;2008.</span><span>)</span></a> [9].
Within an OSD, a partition is identified with a 64-bit number, "oid_partition_id".
Within a partition, an object is identified with a 64-bit number, "oid_object_id".
Creation and management of partitions
is outside the scope of this standard, and is a facility provided
by the object storage file system.
  
</p>
<a name="pnfs_osd_version4"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2.1.2"></a><h3>2.1.2.&nbsp;
pnfs_osd_version4</h3>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
///enum pnfs_osd_version4 {
///    PNFS_OSD_MISSING    = 0,
///    PNFS_OSD_VERSION_1  = 1,
///    PNFS_OSD_VERSION_2  = 2
///};
///
</pre></div>
<p>
Pnfs_osd_version4 is used to indicate the OSD protocol version or whether
an object is missing (i.e., unavailable).  Some of the object-based layout
supported raid algorithms
encode redundant information and can compensate for missing
components, but the data placement algorithm needs to know
what parts are missing.
  
</p>
<p>
At this time the OSD standard is at version 1.0, and
we anticipate a version 2.0 of the standard
((<a class='info' href='#OSD2'>SNIA T10/1729-D<span> (</span><span class='info'>Weber, R., &ldquo;SCSI Object-Based Storage Device Commands -2 (OSD-2),&rdquo; January&nbsp;2008.</span><span>)</span></a> [10])).
The second generation OSD protocol has additional proposed 
features to support more
robust error recovery, snapshots, and byte-range capabilities.
Therefore, the OSD version is explicitly called out
in the information returned in the layout.
(This information can also be deduced by looking inside
the capability type at the format field, which is the first byte.
The format value is 0x1 for an OSD v1 capability.
However, it seems most robust to call out the version explicitly.)
  
</p>
<a name="pnfs_osd_object_cred4"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2.1.3"></a><h3>2.1.3.&nbsp;
pnfs_osd_object_cred4</h3>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
///enum pnfs_osd_cap_key_sec4 {
///    PNFS_OSD_CAP_KEY_SEC_NONE = 0,
///    PNFS_OSD_CAP_KEY_SEC_SSV  = 1
///};
///
///struct pnfs_osd_object_cred4 {
///    pnfs_osd_objid4         oc_object_id;
///    pnfs_osd_version4       oc_osd_version;
///    pnfs_osd_cap_key_sec4   oc_cap_key_sec;
///    opaque                  oc_capability_key&lt;&gt;;
///    opaque                  oc_capability&lt;&gt;;
///};
///
</pre></div>
<p>
The pnfs_osd_object_cred4 structure is used to identify each component
comprising the file.
The "oc_object_id" identifies the component object,
the "oc_osd_version" represents
the osd protocol version, or whether that component is unavailable, and
the "oc_capability" and "oc_capability_key",
along with the "oda_systemid" from the pnfs_osd_deviceaddr4,
provide the OSD security credentials needed
to access that object. The "oc_cap_key_sec" value denotes the method used to secure
the oc_capability_key
(see <a class='info' href='#OSD Security Data Types'>Section&nbsp;12.1<span> (</span><span class='info'>OSD Security Data Types</span><span>)</span></a> for more details).
  
</p>
<p>
To comply with the OSD security requirements the capability key SHOULD
be transferred securely to prevent eavesdropping (see <a class='info' href='#Security Considerations'>Section&nbsp;12<span> (</span><span class='info'>Security Considerations</span><span>)</span></a>).
Therefore, a client SHOULD either issue the LAYOUTGET or GETDEVICEINFO operations via RPCSEC_GSS
with the privacy service or to previously establish an SSV for the sessions
via the NFSv4.1 SET_SSV operation.
The pnfs_osd_cap_key_sec4 type is used to identify the method used by the
server to secure the capability key.
   </p>
<ul class="text">
<li>
PNFS_OSD_CAP_KEY_SEC_NONE denotes that the oc_capability_key is not encrypted
in which case the client SHOULD issue the LAYOUTGET or GETDEVICEINFO operations with
RPCSEC_GSS with the privacy service or the NFSv4.1 transport should
be secured by using methods that are external to NFSv4.1 like the use of
<a class='info' href='#RFC4301'>IPSEC<span> (</span><span class='info'>Kent, S. and K. Seo, &ldquo;Security Architecture for the Internet Protocol,&rdquo; December&nbsp;2005.</span><span>)</span></a> [11] for transporting the NFSV4.1 protocol.
    
</li>
<li>
PNFS_OSD_CAP_KEY_SEC_SSV denotes that the oc_capability_key contents are
encrypted using the SSV GSS context and the capability key as
inputs to the GSS_Wrap() function (see <a class='info' href='#GSS-API'>GSS-API<span> (</span><span class='info'>Linn, J., &ldquo;Generic Security Service Application 	Program Interface Version 2, Update 1,&rdquo; January&nbsp;2000.</span><span>)</span></a> [4]) with
the conf_req_flag set to TRUE.  The client MUST use the secret SSV key
as part of the client's GSS context to decrypt the capability key
using the value of the oc_capability_key field as the input_message to the
GSS_unwrap() function. Note that to prevent eavesdropping of the SSV key
the client SHOULD issue SET_SSV via RPCSEC_GSS with the privacy service.
    
</li>
</ul><p>
  
</p>
<p>
The actual method chosen depends on whether the client established
a SSV key with the server and whether it issued the 
operation with the RPCSEC_GSS privacy method.
Naturally, if the client did not establish a SSV key via SET_SSV
the server MUST use the PNFS_OSD_CAP_KEY_SEC_NONE method.
Otherwise, if the operation was not issued with the RPCSEC_GSS
privacy method the server SHOULD secure the oc_capability_key with the
PNFS_OSD_CAP_KEY_SEC_SSV method.  The server MAY use the
PNFS_OSD_CAP_KEY_SEC_SSV method also when the operation
was issued with the RPCSEC_GSS privacy method.
  
</p>
<a name="pnfs_osd_raid_algorithm4"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2.1.4"></a><h3>2.1.4.&nbsp;
pnfs_osd_raid_algorithm4</h3>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
///enum pnfs_osd_raid_algorithm4 {
///    PNFS_OSD_RAID_0     = 1,
///    PNFS_OSD_RAID_4     = 2,
///    PNFS_OSD_RAID_5     = 3,
///    PNFS_OSD_RAID_PQ    = 4     /* Reed-Solomon P+Q */
///};
///
</pre></div>
<p>
pnfs_osd_raid_algorithm4 represents the data redundancy
algorithm used to protect the file's contents.
See <a class='info' href='#RAID Algorithms'>Section&nbsp;4.4<span> (</span><span class='info'>RAID Algorithms</span><span>)</span></a> for more details.
  
</p>
<a name="anchor3"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3"></a><h3>3.&nbsp;
Object Storage Device Addressing and Discovery</h3>

<p>
Data operations to an OSD require the client to know the "address"
of each OSD's root object. The root object is synonymous with SCSI logical unit.
The client specifies SCSI logical units to its SCSI protocol stack using a
representation local to the client. Because these representations
are local, GETDEVICEINFO must return information that can be used
by the client to select the correct local representation.
 
</p>
<p>
In the block world, a set offset (logical block number or track/sector)
contains a disk label. This label identifies the disk uniquely.
In contrast, an OSD has a standard set of attributes on its root object.
For device identification purposes
the OSD System ID (root information attribute number 3) and the 
OSD Name (root information attribute number 9) are used as the label.
These appear in the pnfs_osd_deviceaddr4 type below under the
"oda_systemid" and "oda_osdname" fields.
 
</p>
<p>
   In some situations, SCSI target discovery may need to be driven based
   on information contained in the GETDEVICEINFO response. One example of
   this is iSCSI targets that are not known to the client until a layout
   has been requested.
   The information provided as the "targetid", "netaddr", and "lun"
   fields in the pnfs_osd_deviceaddr4 type described below
   (see <a class='info' href='#pnfs_osd_deviceaddr4'>Section&nbsp;3.2<span> (</span><span class='info'>pnfs_osd_deviceaddr4</span><span>)</span></a>),
   allows the client to probe a specific device given its network address
   and optionally its iSCSI Name
   (see <a class='info' href='#iSCSI'>iSCSI<span> (</span><span class='info'>IBM, IBM, Cisco Systems, Hewlett-Packard Co., and IBM, &ldquo;Internet Small Computer Systems Interface (iSCSI),&rdquo; April&nbsp;2004.</span><span>)</span></a> [5]),
   or when the device network address is omitted,
   to discover the object storage device using the provided
   device name or SCSI device identifier
   (See <a class='info' href='#SPC-3'>SPC-3<span> (</span><span class='info'>Weber, R., &ldquo;SCSI Primary Commands - 3 (SPC-3),&rdquo; May&nbsp;2005.</span><span>)</span></a> [6].)
 
</p>
<p>
   The oda_systemid is implicitly used by the client, by using the object credential
   signing key to sign each request with the request integrity check value.
   This method protects the client from unintentionally accessing a device if
   the device address mapping was changed (or revoked).
   The server computes the capability key using its own view of the systemid
   associated with the respective deviceid present in the credential.  If the
   client's view of the deviceid mapping is stale, the client will use the wrong
   systemid (which must be system-wide unique) and the I/O request to the OSD will
   fail to pass the integrity check verification.
 
</p>
<p>
   To recover from this condition the client should report the error and
   return the layout using LAYOUTRETURN, and invalidate all the device address mappings
   associated with this layout.
   The client can then ask for a new layout if it wishes using LAYOUTGET and
   resolve the referenced deviceids using GETDEVICEINFO or GETDEVICELIST.
 
</p>
<p>
 The server MUST provide the oda_systemid and SHOULD also provide the oda_osdname.
 When the OSD name is present the client SHOULD get the root information
 attributes whenever it establishes communication with the OSD and verify
 that the OSD name it got from the OSD matches the one sent by the metadata server.
 To do so, the client uses the root_obj_cred credentials.
 
</p>
<a name="pnfs_osd_targetid_type4"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.1"></a><h3>3.1.&nbsp;
pnfs_osd_targetid_type4</h3>

<p>
   The following enum specifies the manner in which a scsi target can
   be specified. The target can be specified as an SCSI Name, or as a
   SCSI Device Identifier.
  
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
///enum pnfs_osd_targetid_type4 {
///    OBJ_TARGET_ANON             = 1,
///    OBJ_TARGET_SCSI_NAME        = 2,
///    OBJ_TARGET_SCSI_DEVICE_ID   = 3
///};
///
</pre></div>
<a name="pnfs_osd_deviceaddr4"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.2"></a><h3>3.2.&nbsp;
pnfs_osd_deviceaddr4</h3>

<p>
The specification for an object device address is as follows:
  
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
///union pnfs_osd_targetid4 switch (pnfs_osd_targetid_type4 oti_type) {
///    case OBJ_TARGET_SCSI_NAME:
///        string              oti_scsi_name&lt;&gt;;
///
///    case OBJ_TARGET_SCSI_DEVICE_ID:
///        opaque              oti_scsi_device_id&lt;&gt;;
///
///    default:
///        void;
///};
///
///union pnfs_osd_targetaddr4 switch (bool ota_available) {
///    case TRUE:
///        netaddr4            ota_netaddr;
///    case FALSE:
///        void;
///};
///
///struct pnfs_osd_deviceaddr4 {
///    pnfs_osd_targetid4      oda_targetid;
///    pnfs_osd_targetaddr4    oda_targetaddr;
///    uint64_t                oda_lun;
///    opaque                  oda_systemid&lt;&gt;;
///    pnfs_osd_object_cred4   oda_root_obj_cred;
///    opaque                  oda_osdname&lt;&gt;;
///};
///
</pre></div>
<a name="anchor4"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.2.1"></a><h3>3.2.1.&nbsp;
SCSI Target Identifier</h3>

<p>
When "oda_targetid" is specified as a OBJ_TARGET_SCSI_NAME,
the "oti_scsi_name" string MUST be formatted as a "iSCSI Name" as specified in
<a class='info' href='#iSCSI'>iSCSI<span> (</span><span class='info'>IBM, IBM, Cisco Systems, Hewlett-Packard Co., and IBM, &ldquo;Internet Small Computer Systems Interface (iSCSI),&rdquo; April&nbsp;2004.</span><span>)</span></a> [5] and <a class='info' href='#iscsi-naming-format'>[7]<span> (</span><span class='info'>Hewlett-Packard Co., Hewlett-Packard Co., and Hewlett-Packard Co., &ldquo;T11 Network Address Authority (NAA) Naming Format for iSCSI Node Names,&rdquo; February&nbsp;2005.</span><span>)</span></a>.
Note that the specification of the oti_scsi_name string format is outside
the scope of this document.  Parsing the string is based on the string
prefix, e.g. "iqn.", "eui.", or "naa." and more formats MAY be specified
in the future in accordance with iSCSI Names properties.
   
</p>
<p>
Currently, the iSCSI Name provides for naming the target device using
a string formmatted as an iSCSI Qualified Name (IQN) or as an
<a class='info' href='#EUI'>EUI<span> (</span><span class='info'>IEEE, &ldquo;Guidelines for 64-bit Global Identifier (EUI-64) Registration Authority,&rdquo; .</span><span>)</span></a> [12] string.
Those are typically used to identify iSCSI or
<a class='info' href='#SRP'>SRP<span> (</span><span class='info'>T10/ANSI INCITS 365-2002, &ldquo;SCSI RDMA Protocol (SRP),&rdquo; .</span><span>)</span></a> [13] devices.
The Network Address Authority (NAA) string format
(see <a class='info' href='#iscsi-naming-format'>[7]<span> (</span><span class='info'>Hewlett-Packard Co., Hewlett-Packard Co., and Hewlett-Packard Co., &ldquo;T11 Network Address Authority (NAA) Naming Format for iSCSI Node Names,&rdquo; February&nbsp;2005.</span><span>)</span></a>) provides for naming
the device using globally unique identifiers, as defined in
<a class='info' href='#FC-FS-2'>FC-FS<span> (</span><span class='info'>T11 1619-D/ANSI INCITS 424-2007, &ldquo;Fibre Channel Framing and Signaling - 2 (FC-FS-2),&rdquo; August&nbsp;2006.</span><span>)</span></a> [14].  These are typically used to identify
Fibre Channel or <a class='info' href='#SAS'>SAS<span> (</span><span class='info'>T10 1601-D/ANSI INCITS 417-2006, &ldquo;Serial Attached SCSI - 1.1 (SAS-1.1),&rdquo; September&nbsp;2005.</span><span>)</span></a> [15] (Serial Attached SCSI) devices.
In particular, such devices that are dual-attached both over Fibre Channel or
SAS, and over iSCSI.
   
</p>
<p>
When "oda_targetid" is specified as a OBJ_TARGET_SCSI_DEVICE_ID,
the "oti_scsi_device_id" opaque field MUST be formatted as a SCSI Device Identifier
as defined in <a class='info' href='#SPC-3'>SPC-3<span> (</span><span class='info'>Weber, R., &ldquo;SCSI Primary Commands - 3 (SPC-3),&rdquo; May&nbsp;2005.</span><span>)</span></a> [6] VPD Page 83h
(Section 7.6.3. "Device Identification VPD Page".)
If the Device Identifier is identical to the OSD System ID, as given by
oda_systemid, the server SHOULD provide a zero-length oti_scsi_device_id&lt;&gt
opaque value 
Note that similarly to the "oti_scsi_name",
the specification of the oti_scsi_device_id opaque contents is outside
the scope of this document and more formats MAY be specified
in the future in accordance with SPC-3.
   
</p>
<p>
The OBJ_TARGET_ANON pnfs_osd_targetid_type4 MAY be used for providing no
target identification.  In this case only the OSD System ID and optionally, the
provided network address, are used to locate to device.
   
</p>
<a name="anchor5"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.2.2"></a><h3>3.2.2.&nbsp;
Device Network Address</h3>

<p>
The optional "oda_targetaddr" field MAY be provided by the server as a hint to
accelerate device discovery over e.g., the iSCSI transport protocol.
The network address is given with the netaddr4 type, which
specifies a TCP/IP based endpoint (as specified in <a class='info' href='#NFSv4.1'>NFSv4.1 draft<span> (</span><span class='info'>Shepler, S., Eisler, M., and D. Noveck, &ldquo;NFSv4 Minor Version 1,&rdquo; May&nbsp;2008.</span><span>)</span></a> [9]).
When given, the client SHOULD use it to probe for the SCSI device at the
given network address.  The client MAY still use other discovery mechanisms
such as <a class='info' href='#iSNS'>iSNS<span> (</span><span class='info'>Tseng, J., Gibbons, K., Travostino, F., Du Laney, C., and J. Souza, &ldquo;Internet Storage Name Service (iSNS),&rdquo; September&nbsp;2005.</span><span>)</span></a> [16] to locate the device using the oda_targetid.
In particular, such external name service, SHOULD be used when the devices
may be attached to the network using multiple connections, and/or multiple
storage fabrics (e.g. Fibre-Channel and iSCSI.)
   
</p>
<a name="anchor6"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4"></a><h3>4.&nbsp;
Object-Based Layout</h3>

<p>
The layout4 type is defined in the
<a class='info' href='#NFSv4.1'>NFSv4.1 draft<span> (</span><span class='info'>Shepler, S., Eisler, M., and D. Noveck, &ldquo;NFSv4 Minor Version 1,&rdquo; May&nbsp;2008.</span><span>)</span></a> [9] as follows:
 
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
enum layouttype4 {
    LAYOUT4_NFSV4_1_FILES   = 1,
    LAYOUT4_OSD2_OBJECTS    = 2,
    LAYOUT4_BLOCK_VOLUME    = 3
};

struct layout_content4 {
    layouttype4             loc_type;
    opaque                  loc_body&lt;&gt;;
};

struct layout4 {
    offset4                 lo_offset;
    length4                 lo_length;
    layoutiomode4           lo_iomode;
    layout_content4         lo_content;
};

</pre></div>
<p>
This document defines structure associated with
the layouttype4 value, LAYOUT4_OSD2_OBJECTS.
The <a class='info' href='#NFSv4.1'>NFSv4.1 draft<span> (</span><span class='info'>Shepler, S., Eisler, M., and D. Noveck, &ldquo;NFSv4 Minor Version 1,&rdquo; May&nbsp;2008.</span><span>)</span></a> [9] specifies the loc_body structure as an XDR type "opaque".
The opaque layout is uninterpreted by the generic pNFS client layers, but obviously
must be interpreted by the object-storage layout driver.  This section defines the
structure of this opaque value, pnfs_osd_layout4.
 
</p>
<a name="pnfs_osd_data_map4"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.1"></a><h3>4.1.&nbsp;
pnfs_osd_data_map4</h3>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
///struct pnfs_osd_data_map4 {
///    uint32_t                    odm_num_comps;
///    length4                     odm_stripe_unit;
///    uint32_t                    odm_group_width;
///    uint32_t                    odm_group_depth;
///    uint32_t                    odm_mirror_cnt;
///    pnfs_osd_raid_algorithm4    odm_raid_algorithm;
///};
///
</pre></div>
<p>
The pnfs_osd_data_map4 structure parameterizes the algorithm that maps
a file's contents over the component objects.
Instead of limiting the system to simple striping
scheme where loss of a single component object results in
data loss, the map parameters support mirroring
and more complicated schemes that protect against loss
of a component object.
  
</p>
<p>
"odm_num_comps" is the number of component objects the file is striped over.
The server MAY grow the file by adding more components to the stripe
while clients hold valid layouts until the file has reached its final
stripe width.  The file length in this case MUST be limited to
the number of bytes in a full stripe.
  
</p>
<p>
The "odm_stripe_unit" is the number of bytes placed on one
component before advancing to the next one in the list
of components.  The number of bytes in a full stripe
is odm_stripe_unit times the number of components.
In some raid schemes, a stripe includes redundant
information (i.e., parity) that lets the system
recover from loss or damage to a component object.
  
</p>
<p>
The "odm_group_width" and "odm_group_depth" parameters allow
a nested striping pattern (See <a class='info' href='#Nested Striping'>Section&nbsp;4.3.2<span> (</span><span class='info'>Nested Striping</span><span>)</span></a> for details).
If there is no nesting,
then odm_group_width and odm_group_depth MUST be zero.
The size of the components array MUST be a multiple
of odm_group_width.
  
</p>
<p>
The "odm_mirror_cnt" is used to replicate a file by replicating its component objects.
If there is no mirroring, then odm_mirror_cnt MUST be 0.
If odm_mirror_cnt is greater than zero, then the size of the component
array MUST be a multiple of (odm_mirror_cnt+1).
  
</p>
<p>
See <a class='info' href='#Data Mapping Schemes'>Section&nbsp;4.3<span> (</span><span class='info'>Data Mapping Schemes</span><span>)</span></a> for more details.
  
</p>
<a name="pnfs_osd_layout4"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.2"></a><h3>4.2.&nbsp;
pnfs_osd_layout4</h3>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
///struct pnfs_osd_layout4 {
///    pnfs_osd_data_map4      olo_map;
///    uint32_t                olo_comps_index;
///    pnfs_osd_object_cred4   olo_components&lt;&gt;;
///};
///
</pre></div>
<p>
The pnfs_osd_layout4 structure specifies a layout over a set of 
component objects.
The "olo_components" field is an array of object identifiers
and security credentials that grant
access to each object.
The organization of the data is defined by the pnfs_osd_data_map4 type
that specifies how the file's data is mapped onto the component objects
(i.e., the striping pattern).
The data placement algorithm that maps file data
onto component objects assume that each component object
occurs exactly once in the array of components.
Therefore, component objects MUST appear in the olo_components array
only once.
The components array may represent all objects comprising the file,
in which case "olo_comps_index" is set to zero and the number of entries
in the olo_components array is equal to olo_map.odm_num_comps.
The server MAY return fewer components than odm_num_comps, provided
that the returned components are sufficient to access any byte
in the layout's data range (e.g., a sub-stripe of "odm_group_width" components).
In this case, olo_comps_index represents the position of the returned
components array within the full array of components that comprise
the file.
  
</p>
<p>
Note that the layout depends on the file size, which the client learns
from the generic return parameters of LAYOUTGET,
by doing GETATTR commands to the metadata server.
The client uses the file size
to decide if it
should fill holes with zeros, or return a short read.
Striping patterns can cause cases where component objects are shorter
than other components because a hole happens to correspond to the
last part of the component object.
  
</p>
<a name="Data Mapping Schemes"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.3"></a><h3>4.3.&nbsp;
Data Mapping Schemes</h3>

<p>
This section describes the different data mapping schemes
in detail.
The object layout always uses a "dense"
layout as described in
<a class='info' href='#NFSv4.1'>NFSv4.1 draft<span> (</span><span class='info'>Shepler, S., Eisler, M., and D. Noveck, &ldquo;NFSv4 Minor Version 1,&rdquo; May&nbsp;2008.</span><span>)</span></a> [9].
This means that the second stripe unit of the
file starts at offset 0 of the second component,
rather than at offset stripe_unit bytes.
After a full stripe has been written, the
next stripe unit is appended to the first component
object in the list without any holes in the component objects.
  
</p>
<a name="Simple Striping"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.3.1"></a><h3>4.3.1.&nbsp;
Simple Striping</h3>

<p>
The mapping from the logical
offset within a file (L) to the component object C and
object-specific offset O is defined by the following equations:
   
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
L = logical offset into the file
W = total number of components
S = W * stripe_unit
N = L / S
C = (L-(N*S)) / stripe_unit
O = (N*stripe_unit)+(L%stripe_unit)
</pre></div>
<p>
In these equations, S is the number of bytes in a full stripe,
and N is the stripe number.  C is an index into the array of components,
so it selects a particular object storage device.
Both N and C count from zero.
O is the offset within the object that corresponds to the file offset.
Note that this computation does not accommodate the same
object appearing in the olo_components array multiple times.
   
</p>
<p>
For example, consider an object striped over four devices, &lt;D0 D1 D2 D3&gt;.
The stripe_unit is 4096 bytes. The stripe width S is thus 4 * 4096 = 16384.
   
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
Offset 0:
  N = 0 / 16384 = 0
  C = 0-0/4096 = 0 (D0)
  O = 0*4096 + (0%4096) = 0

Offset 4096:
  N = 4096 / 16384 = 0
  C = (4096-(0*16384)) / 4096 = 1 (D1)
  O = (0*4096)+(4096%4096) = 0

Offset 9000:
  N = 9000 / 16384 = 0
  C = (9000-(0*16384)) / 4096 = 2 (D2)
  O = (0*4096)+(9000%4096) = 808

Offset 132000:
  N = 132000 / 16384 = 8
  C = (132000-(8*16384)) / 4096 = 0 (D0)
  O = (8*4096) + (132000%4096) = 33696
</pre></div>
<a name="Nested Striping"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.3.2"></a><h3>4.3.2.&nbsp;
Nested Striping</h3>

<p>
The odm_group_width and odm_group_depth parameters allow
a nested striping pattern.
odm_group_width defines the width
of a data stripe and odm_group_depth defines
how many stripes are written before advancing
to the next group of components in the
list of component objects for the file.
The math used to map from a file offset to
a component object and offset within that
object is shown below.
The computations
map from the logical offset L to the component index C and offset relative O
within that component object.
   
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
L = logical offset into the file
W = total number of components
S = stripe_unit * group_depth * W
T = stripe_unit * group_depth * group_width
U = stripe_unit * group_width
M = L / S
G = (L - (M * S)) / T
H = (L - (M * S)) % T
N = H / U
C = (H - (N * U)) / stripe_unit + G * group_width
O = L % stripe_unit + N * stripe_unit + M * group_depth * stripe_unit
</pre></div>
<p>
In these equations, S is the number of bytes striped across all
component objects before the pattern repeats.  T is the number of bytes
striped within a group of component objects before advancing to the next group.
U is the number of bytes in a stripe within a group.
M is the "major" (i.e., across all components) stripe number,
and N is the "minor" (i.e., across the group) stripe number.
G counts the groups from the beginning of the major stripe,
and H is the byte offset within the group.
   
</p>
<p>
For example, consider an object striped over 100 devices with
a group_width of 10, a group_depth of 50, and a stripe_unit of 1 MB.
In this scheme, 500 MB are written to the first 10 components,
and 5000 MB is written before the pattern wraps back around to the
first component in the array.
   
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
Offset 0:
  W = 100
  S = 1 MB * 50 * 100 = 5000 MB
  T = 1 MB * 50 * 10 = 500 MB
  U = 1 MB * 10 = 10 MB
  M = 0 / 5000 MB = 0
  G = (0 - (0 * 5000 MB)) / 500 MB = 0
  H = (0 - (0 * 5000 MB)) % 500 MB = 0
  N = 0 / 10 MB = 0
  C = (0 - (0 * 10 MB)) / 1 MB + 0 * 10 = 0
  O = 0 % 1 MB + 0 * 1 MB + 0 * 50 * 1 MB = 0

Offset 27 MB:
  M = 27 MB / 5000 MB = 0
  G = (27 MB - (0 * 5000 MB)) / 500 MB = 0
  H = (27 MB - (0 * 5000 MB)) % 500 MB = 27 MB
  N = 27 MB / 10 MB = 2
  C = (27 MB - (2 * 10 MB)) / 1 MB + 0 * 10 = 7
  O = 27 MB % 1 MB + 2 * 1 MB + 0 * 50 * 1 MB = 2 MB

Offset 7232 MB:
  M = 7232 MB / 5000 MB = 1
  G = (7232 MB - (1 * 5000 MB)) / 500 MB = 4
  H = (7232 MB - (1 * 5000 MB)) % 500 MB = 232 MB
  N = 232 MB / 10 MB = 23
  C = (232 MB - (23 * 10 MB)) / 1 MB + 4 * 10 = 42
  O = 7232 MB % 1 MB + 23 * 1 MB + 1 * 50 * 1 MB = 73 MB
</pre></div>
<a name="Mirroring"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.3.3"></a><h3>4.3.3.&nbsp;
Mirroring</h3>

<p>
The odm_mirror_cnt is used to replicate a file by replicating its component objects.
If there is no mirroring, then odm_mirror_cnt MUST be 0.
If odm_mirror_cnt is greater than zero, then the size of the olo_components
array MUST be a multiple of (odm_mirror_cnt+1).
Thus, for a classic mirror on two objects, odm_mirror_cnt is one.
Note that mirroring can be defined over any raid algorithm and striping
pattern (either simple or nested).
If odm_group_width is also non-zero, then the size of the olo_components array MUST be a
multiple of odm_group_width * (odm_mirror_cnt+1).
Replicas are adjacent in the olo_components array,
and the value C produced by the above equations is not
a direct index into the olo_components array.  Instead,
the following equations determine the replica component index RCi,
where i ranges from 0 to odm_mirror_cnt.
   
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
C = component index for striping or two-level striping
i ranges from 0 to odm_mirror_cnt, inclusive
RCi = C * (odm_mirror_cnt+1) + i
</pre></div>
<a name="RAID Algorithms"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.4"></a><h3>4.4.&nbsp;
RAID Algorithms</h3>

<p>
pnfs_osd_raid_algorithm4 determines the algorithm and placement of
redundant data.
This section defines the different RAID algorithms.
  
</p>
<a name="PNFS_OSD_RAID_0"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.4.1"></a><h3>4.4.1.&nbsp;
PNFS_OSD_RAID_0</h3>

<p>
PNFS_OSD_RAID_0 means there is no
parity data, so all bytes in the component objects are
data bytes located by the above equations for C and O.
If a component object is marked as PNFS_OSD_MISSING,
the pNFS client MUST either return an I/O error if this component
is attempted to be read or alternatively, it can
retry the READ against the pNFS server.
   
</p>
<a name="PNFS_OSD_RAID_4"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.4.2"></a><h3>4.4.2.&nbsp;
PNFS_OSD_RAID_4</h3>

<p>
PNFS_OSD_RAID_4 means that the last component object,
or the last in each group (if odm_group_width is greater than zero),
contains parity information computed over the rest of
the stripe with an XOR operation.
If a component object is unavailable, the client can
read the rest of the stripe units in the damaged stripe
and recompute the missing stripe unit by XORing the other
stripe units in the stripe.  Or the client can replay
the READ against the pNFS server which will presumably
perform the reconstructed read on the client's behalf.
   
</p>
<p>
When parity is present in the file,
then there is an additional computation to map from the file offset L
to the offset that accounts for embedded parity, L'.
First compute L', and then use L' in the above equations for C and O.
   
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
L = file offset, not accounting for parity
P = number of parity devices in each stripe
W = group_width, if not zero, else size of olo_components array
N = L / (W-P * stripe_unit)
L' = N * (W * stripe_unit) +
     (L % (W-P * stripe_unit))
</pre></div>
<a name="PNFS_OSD_RAID_5"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.4.3"></a><h3>4.4.3.&nbsp;
PNFS_OSD_RAID_5</h3>

<p>
PNFS_OSD_RAID_5 means that the position of the parity data
is rotated on each stripe or each group (if odm_group_width is greater than zero).
In the first stripe, the last
component holds the parity.  In the second stripe, the
next-to-last component holds the parity, and so on.
In this scheme, all stripe units are rotated so that I/O
is evenly spread across objects as the file is read
sequentially.  The rotated parity layout is illustrated here,
with numbers indicating the stripe unit.
   
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
0 1 2 P
4 5 P 3
8 P 6 7
P 9 a b
</pre></div>
<p>
To compute the component object C, first compute the
offset that accounts for parity L' and use that to
compute C.  Then rotate C to get C'.
Finally, increase C' by one if the parity
information comes at or before C' within that stripe.
The following equations illustrate this by computing I,
which is the index of the component that contains
parity for a given stripe.
   
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
L = file offset, not accounting for parity
W = odm_group_width, if not zero, else size of olo_components array
N = L / (W-1 * stripe_unit)
(Compute L' as describe above)
(Compute C based on L' as described above)
C' = (C - (N%W)) % W
I = W - (N%W) - 1
if (C' &lt;= I) {
  C'++
}
</pre></div>
<a name="PNFS_OSD_RAID_PQ"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.4.4"></a><h3>4.4.4.&nbsp;
PNFS_OSD_RAID_PQ</h3>

<p>
PNFS_OSD_RAID_PQ is a double-parity scheme that uses
the Reed-Solomon P+Q encoding scheme <a class='info' href='#Error Correcting Codes'>[17]<span> (</span><span class='info'>MacWilliams, F. and N. Sloane, &ldquo;The Theory of Error-Correcting Codes, Part I,&rdquo; 1977.</span><span>)</span></a>.
In this layout,
the last two component objects hold the P and Q data,
respectively.  P is parity computed with XOR, and
Q is a more complex equation that is not described here.
The equations given above for embedded parity can be
used to map a file offset to the correct component
object by setting the number of parity components to 2
instead of 1 for RAID4 or RAID5.
Clients may simply choose to read data through the
metadata server if two components are missing or
damaged.
   
</p>
<p>
Issue: This scheme also has a RAID_4 like layout where
the ECC blocks are stored on the same components on every stripe
and a rotated, RAID-5 like layout where the stripe units are rotated.
Should we make the following properties orthogonal: RAID_4 or RAID_5 (i.e.,
non-rotated or rotated), and then have the number of parity components
and the associated algorithm be the orthogonal parameter?
   
</p>
<a name="anchor7"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.4.5"></a><h3>4.4.5.&nbsp;
RAID Usage and Implementation Notes</h3>

<p>
RAID layouts with redundant data in their stripes
require additional serialization of updates to
ensure correct operation. Otherwise, if two clients simultaneously
write to the same logical range of an object, the result could include
different data in the same ranges of mirrored tuples, or corrupt parity
information.  It is the
responsibility of the metadata server to enforce serialization
requirements such as this. For example, the metadata server may do
so by not granting overlapping write layouts within mirrored objects.
   
</p>
<a name="anchor8"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5"></a><h3>5.&nbsp;
Object-Based Layout Update</h3>

<p>
layoutupdate4 is used in the LAYOUTCOMMIT operation
to convey updates to the layout and additional information to
the metadata server.  It is defined in the
<a class='info' href='#NFSv4.1'>NFSv4.1 draft<span> (</span><span class='info'>Shepler, S., Eisler, M., and D. Noveck, &ldquo;NFSv4 Minor Version 1,&rdquo; May&nbsp;2008.</span><span>)</span></a> [9] as follows:
 
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
struct layoutupdate4 {
    layouttype4             lou_type;
    opaque                  lou_body&lt;&gt;;
};
</pre></div>
<p>
The layoutupdate4 type is an opaque value at the generic pNFS client level.
If the lou_type layout type is LAYOUT4_OSD2_OBJECTS, then
the lou_body opaque value is defined by the pnfs_osd_layoutupdate4 type.
 
</p>
<p>
Object-Based pNFS clients are not allowed to modify the layout.
Therefore, the information passed in pnfs_osd_layoutupdate4
is used only to update the file's attributes.
In addition to the generic information the client can pass to the metadata
server in LAYOUTCOMMIT such as the highest offset the client wrote to and
the last time it modified the file, the client MAY use pnfs_osd_layoutupdate4
to convey the capacity consumed (or released) by writes using the layout,
and to indicate that I/O errors were encountered by such writes.
 
</p>
<a name="pnfs_osd_deltaspaceused4"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.1"></a><h3>5.1.&nbsp;
pnfs_osd_deltaspaceused4</h3>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
///union pnfs_osd_deltaspaceused4 switch (bool dsu_valid) {
///    case TRUE:
///        int64_t     dsu_delta;
///    case FALSE:
///        void;
///};
///
</pre></div>
<p>
pnfs_osd_deltaspaceused4 is used to convey space utilization information
at the time of LAYOUTCOMMIT.  For the file system to properly maintain
capacity used information, it needs to track how much capacity was
consumed by WRITE operations performed by the client.  In this protocol,
the OSD returns the capacity consumed by a write (*), which can be
different than the number of bytes written
because of internal overhead like block-level allocation and
indirect blocks, and the client reflects this back to the pNFS server
so it can accurately track quota.  The pNFS server can choose to
trust this information coming from the clients and therefore
avoid querying the OSDs at the time of LAYOUTCOMMIT.
If the client is unable to obtain this information from the OSD,
it simply returns invalid olu_delta_space_used.
  
</p>
<p>
(*) Note: At the time this document is written,
a per-command used capacity attribute is not yet standardized
by <a class='info' href='#OSD2'>OSD2 draft<span> (</span><span class='info'>Weber, R., &ldquo;SCSI Object-Based Storage Device Commands -2 (OSD-2),&rdquo; January&nbsp;2008.</span><span>)</span></a> [10].
The client MAY use vendor-specific attributes to calculate space utilization,
provided that the vendor defines and publishes a suitable vendor-specific
attributes page for current-command attributes as defined by
<a class='info' href='#OSD2'>OSD2 draft<span> (</span><span class='info'>Weber, R., &ldquo;SCSI Object-Based Storage Device Commands -2 (OSD-2),&rdquo; January&nbsp;2008.</span><span>)</span></a> [10], Section 7.1.2.2.
  
</p>
<a name="pnfs_osd_layoutupdate4"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.2"></a><h3>5.2.&nbsp;
pnfs_osd_layoutupdate4</h3>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
///struct pnfs_osd_layoutupdate4 {
///    pnfs_osd_deltaspaceused4    olu_delta_space_used;
///    bool                        olu_ioerr_flag;
///};
///
</pre></div>
<p>
"olu_delta_space_used" is used to convey capacity usage
information back to the metadata server.
  
</p>
<p>
The "olu_ioerr_flag" is used when I/O errors were encountered while writing
the file.  The client MUST report the errors using the pnfs_osd_ioerr4
structure (See <a class='info' href='#pnfs_osd_errno4'>Section&nbsp;7.1<span> (</span><span class='info'>pnfs_osd_errno4</span><span>)</span></a>) at LAYOUTRETURN time.
  
</p>
<p>
If the client updated the file successfully before hitting the
I/O errors it MAY use LAYOUTCOMMIT to update the metadata server as
described above.  Typically, in the error-free case, the server MAY
turn around and update the file's attributes on the storage devices.
However, if I/O errors were encountered the server better not attempt
to write the new attributes on the storage devices until it receives
the I/O error report, therefore the client MUST set the olu_ioerr_flag
to true.
Note that in this case, the client SHOULD send both the
LAYOUTCOMMIT and LAYOUTRETURN operations in the same COMPOUND RPC.
  
</p>
<a name="anchor9"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6"></a><h3>6.&nbsp;
Recovering from Client I/O Errors</h3>

<p>
The pNFS client may encounter errors when directly accessing
the object storage devices.
However, it is the responsibility of the metadata server to
handle the I/O errors.
When the LAYOUT4_OSD2_OBJECTS layout type is used, the client
MUST report the I/O errors to the server at LAYOUTRETURN time
using the pnfs_osd_ioerr4 structure (See <a class='info' href='#pnfs_osd_errno4'>Section&nbsp;7.1<span> (</span><span class='info'>pnfs_osd_errno4</span><span>)</span></a>).
 
</p>
<p>
The metadata server analyzes the error and determines the required
recovery operations such as repairing any parity inconsistencies,
recovering media failures, or reconstructing missing objects.
 
</p>
<p>
The metadata server SHOULD recall any outstanding layouts to allow it
exclusive write access to the stripes being recovered and to prevent other
clients from hitting the same error condition.
In these cases, the server MUST complete recovery before handing out
any new layouts to the affected byte ranges.
 
</p>
<p>
Although is it MAY be acceptable for the client to propagate a
corresponding error to the application that initiated the I/O operation
and drop any unwritten data, the client SHOULD attempt to retry the original
I/O operation by requesting a new layout using LAYOUTGET and retry the
I/O operation(s) using the new layout or the client MAY just retry the
I/O operation(s) using regular NFS READ or WRITE operations via the metadata
server.  The client SHOULD attempt to retrieve a new layout and retry the I/O
operation using OSD commands first and only if the error persists, retry
the I/O operation via the metadata server.
 
</p>
<a name="anchor10"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7"></a><h3>7.&nbsp;
Object-Based Layout Return</h3>

<p>
layoutreturn_file4 is used in the LAYOUTRETURN operation
to convey layout-type specific information to the server.
It is defined in the
<a class='info' href='#NFSv4.1'>NFSv4.1 draft<span> (</span><span class='info'>Shepler, S., Eisler, M., and D. Noveck, &ldquo;NFSv4 Minor Version 1,&rdquo; May&nbsp;2008.</span><span>)</span></a> [9] as follows:
 
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
struct layoutreturn_file4 {
        offset4         lrf_offset;
        length4         lrf_length;
        stateid4        lrf_stateid;
        /* layouttype4 specific data */
        opaque          lrf_body&lt;&gt;;
};

union layoutreturn4 switch(layoutreturn_type4 lr_returntype) {
        case LAYOUTRETURN4_FILE:
                layoutreturn_file4      lr_layout;
        default:
                void;
};

struct LAYOUTRETURN4args {
        /* CURRENT_FH: file */
        bool                    lora_reclaim;
        layoutreturn_stateid    lora_recallstateid;
        layouttype4             lora_layout_type;
        layoutiomode4           lora_iomode;
        layoutreturn4           lora_layoutreturn;
};

</pre></div>
<p>
If the lora_layout_type layout type is LAYOUT4_OSD2_OBJECTS, then
the lrf_body opaque value is defined by the pnfs_osd_layoutreturn4 type.
 
</p>
<p>
The pnfs_osd_layoutreturn4 type allows the client to report I/O error information
back to the metadata server as defined below.
 
</p>
<a name="pnfs_osd_errno4"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.1"></a><h3>7.1.&nbsp;
pnfs_osd_errno4</h3>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
///enum pnfs_osd_errno4 {
///    PNFS_OSD_ERR_EIO            = 1,
///    PNFS_OSD_ERR_NOT_FOUND      = 2,
///    PNFS_OSD_ERR_NO_SPACE       = 3,
///    PNFS_OSD_ERR_BAD_CRED       = 4,
///    PNFS_OSD_ERR_NO_ACCESS      = 5,
///    PNFS_OSD_ERR_UNREACHABLE    = 6,
///    PNFS_OSD_ERR_RESOURCE       = 7
///};
///
</pre></div>
<p>
pnfs_osd_errno4 is used to represent error types when read/write errors
are reported to the metadata server.
The error codes serve as hints to the metadata server that may help it
in diagnosing the exact reason for the error and in repairing it.

  </p>
<ul class="text">
<li>
PNFS_OSD_ERR_EIO indicates the operation failed because the
Object Storage Device experienced a failure trying to access the
object.  The most common source of these errors is media errors,
but other internal errors might cause this. In this case,
the metadata server should go examine the broken object 
more closely, hence it should be used as the default error code.
   
</li>
<li>
PNFS_OSD_ERR_NOT_FOUND indicates the object ID specifies an object that
does not exist on the Object Storage Device.
   
</li>
<li>
PNFS_OSD_ERR_NO_SPACE indicates the operation failed because the
Object Storage Device ran out of free capacity during the operation.
   
</li>
<li>
PNFS_OSD_ERR_BAD_CRED indicates the security parameters are not valid.
The primary cause of this is that the capability has expired,
or the access policy tag (a.k.a, capability version number) has
been changed to revoke capabilities.  The client will need to
return the layout and get a new one with fresh capabilities.
   
</li>
<li>
PNFS_OSD_ERR_NO_ACCESS indicates the capability does not allow
the requested operation.  This should not occur in normal operation
because the metadata server should give out correct capabilities,
or none at all.
   
</li>
<li>
PNFS_OSD_ERR_UNREACHABLE indicates the client did not complete
the I/O operation at the Object Storage Device
due to a communication failure.  Whether the I/O operation
was executed by the OSD or not is undetermined.
   
</li>
<li>
PNFS_OSD_ERR_RESOURCE indicates the client did not issue
the I/O operation due to a local problem on the initiator (i.e. client)
side, e.g., when running out of memory.  The client
MUST guarantee that the OSD command was never dispatched to the OSD.
   
</li>
</ul><p>
  
</p>
<a name="pnfs_osd_ioerr4"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.2"></a><h3>7.2.&nbsp;
pnfs_osd_ioerr4</h3>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
///struct pnfs_osd_ioerr4 {
///    pnfs_osd_objid4     oer_component;
///    length4             oer_comp_offset;
///    length4             oer_comp_length;
///    bool                oer_iswrite;
///    pnfs_osd_errno4     oer_errno;
///};
///
</pre></div>
<p>
The pnfs_osd_ioerr4 structure is used to return error indications
for objects that generated errors during data transfers.
These are hints to the
metadata server that there are problems with that object.
For each error, "oer_component", "oer_comp_offset", and "oer_comp_length"
represent the object
and byte range within the component object in which the error occurred,
"oer_iswrite" is set to "true" if the failed OSD operation was data modifying, and
"oer_errno" represents the type of error.
  
</p>
<p>
Component byte ranges in the optional pnfs_osd_ioerr4 structure are
used for recovering the object and MUST be set by the client to cover all
failed I/O operations to the component.
  
</p>
<a name="pnfs_osd_layoutreturn4"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.3"></a><h3>7.3.&nbsp;
pnfs_osd_layoutreturn4</h3>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
///struct pnfs_osd_layoutreturn4 {
///    pnfs_osd_ioerr4             olr_ioerr_report&lt;&gt;;
///};
///
</pre></div>
<p>
When OSD I/O operations failed, "olr_ioerr_report&lt;&gt;" is used to report these errors
to the metadata server as an array of elements of type pnfs_osd_ioerr4.
Each element in the array represents an error that occured on
the object specified by oer_component.
If no errors are to be reported, the size of the olr_ioerr_report&lt;&gt; array
is set to zero.
  
</p>
<a name="anchor11"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.8"></a><h3>8.&nbsp;
Object-Based Creation Layout Hint</h3>

<p>
The layouthint4 type is defined in the 
<a class='info' href='#NFSv4.1'>NFSv4.1 draft<span> (</span><span class='info'>Shepler, S., Eisler, M., and D. Noveck, &ldquo;NFSv4 Minor Version 1,&rdquo; May&nbsp;2008.</span><span>)</span></a> [9] as follows:
 
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
struct layouthint4 {
    layouttype4           loh_type;
    opaque                loh_body&lt;&gt;;
};
</pre></div>
<p>
The layouthint4 structure is used by the client to pass in a
hint about the type of layout it would like created for a particular
file.
If the loh_type layout type is LAYOUT4_OSD2_OBJECTS, then
the loh_body opaque value is defined by the pnfs_osd_layouthint4 type.
 
</p>
<a name="pnfs_osd_layouthint4"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.8.1"></a><h3>8.1.&nbsp;
pnfs_osd_layouthint4</h3>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
///union pnfs_osd_max_comps_hint4 switch (bool omx_valid) {
///    case TRUE:
///        uint32_t            omx_max_comps;
///    case FALSE:
///        void;
///};
///
///union pnfs_osd_stripe_unit_hint4 switch (bool osu_valid) {
///    case TRUE:
///        length4             osu_stripe_unit;
///    case FALSE:
///        void;
///};
///
///union pnfs_osd_group_width_hint4 switch (bool ogw_valid) {
///    case TRUE:
///        uint32_t            ogw_group_width;
///    case FALSE:
///        void;
///};
///
///union pnfs_osd_group_depth_hint4 switch (bool ogd_valid) {
///    case TRUE:
///        uint32_t            ogd_group_depth;
///    case FALSE:
///        void;
///};
///
///union pnfs_osd_mirror_cnt_hint4 switch (bool omc_valid) {
///    case TRUE:
///        uint32_t            omc_mirror_cnt;
///    case FALSE:
///        void;
///};
///
///union pnfs_osd_raid_algorithm_hint4 switch (bool ora_valid) {
///    case TRUE:
///        pnfs_osd_raid_algorithm4    ora_raid_algorithm;
///    case FALSE:
///        void;
///};
///
///struct pnfs_osd_layouthint4 {
///    pnfs_osd_max_comps_hint4        olh_max_comps_hint;
///    pnfs_osd_stripe_unit_hint4      olh_stripe_unit_hint;
///    pnfs_osd_group_width_hint4      olh_group_width_hint;
///    pnfs_osd_group_depth_hint4      olh_group_depth_hint;
///    pnfs_osd_mirror_cnt_hint4       olh_mirror_cnt_hint;
///    pnfs_osd_raid_algorithm_hint4   olh_raid_algorithm_hint;
///};
///
</pre></div>
<p>
This type conveys hints for the desired data map.
All parameters are optional so the client can give values for only
the parameters it cares about, e.g. it can provide a hint for the desired
number of mirrored components, regardless of the the raid algorithm selected
for the file.  The server should make an attempt to honor the hints 
but it can ignore any or all of them at its own discretion and
without failing the respective CREATE operation.
  
</p>
<p>
The "olh_max_comps_hint" can be used to limit the total number of component
objects comprising the file.  All other hints correspond directly to the
different fields of pnfs_osd_data_map4.
  
</p>
<a name="anchor12"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.9"></a><h3>9.&nbsp;
Layout Segments</h3>

<p>
The pnfs layout operations operate on logical byte ranges.
There is no requirement in the protocol for any relationship between
byte ranges used in LAYOUTGET to acquire layouts and byte ranges used
in CB_LAYOUTRECALL, LAYOUTCOMMIT, or LAYOUTRETURN.
However, using OSD byte-range capabilities poses limitations on these operations
since the capabilities associated with layout segments cannot be merged
or split.
The following guidelines should be followed for proper operation of
object-based layouts.
 
</p>
<a name="anchor13"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.9.1"></a><h3>9.1.&nbsp;
CB_LAYOUTRECALL and LAYOUTRETURN</h3>

<p>
In general, the object-based layout driver should keep track of each
layout segment it got, keeping record of the segment's iomode, offset,
and length.
The server should allow the client to get multiple overlapping layout
segments but is free to recall the layout to prevent overlap.
  
</p>
<p>
In response to CB_LAYOUTRECALL, the client should return all layout
segments matching the given iomode and overlapping with the recalled range.
When returning the layouts for this byte range with LAYOUTRETURN the client
MUST NOT return a sub-range of a layout segment it has;
each LAYOUTRETURN sent MUST completely cover at least one outstanding layout
segment.
  
</p>
<p>
The server, in turn, should release any segment that exactly matches the
clientid, iomode, and byte range given in LAYOUTRETURN.
If no exact match is found then the server should release all layout segments
matching the clientid and iomode and that are fully contained in the
returned byte range.
If none are found and the byte range is a subset of an outstanding layout
segment with for the same clientid and iomode, then the client can be
considered malfunctioning and the server SHOULD recall all layouts from
this client to reset its state.  If this behavior repeats the server
SHOULD deny all LAYOUTGETs from this client.
  
</p>
<a name="anchor14"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.9.2"></a><h3>9.2.&nbsp;
LAYOUTCOMMIT</h3>

<p>
LAYOUTCOMMIT is only used by object-based pNFS to convey modified attributes
hints and/or to report I/O errors to the MDS.
Therefore, the offset and length in LAYOUTCOMMIT4args are reserved for future
use and should be set to 0.
  
</p>
<a name="anchor15"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.10"></a><h3>10.&nbsp;
Recalling Layouts</h3>

<p>
The object-based metadata server should recall outstanding layouts
in the following cases:

 </p>
<ul class="text">
<li>
  When the file's security policy changes, i.e. ACLs or permission mode bits
are set.
  
</li>
<li>
  When the file's aggregation map changes, rendering outstanding layouts invalid.
  
</li>
<li>
  When there are sharing conflicts. For example, the server will issue
stripe aligned layout segments for RAID-5 objects.  To prevent corruption
of the file's parity, Multiple clients must not hold valid write layouts
for the same stripes.
An outstanding RW layout should be recalled when a conflicting LAYOUTGET
is received from a different client for LAYOUTIOMODE4_RW and for a byte-range
overlapping with the outstanding layout segment.
  
</li>
</ul><p>
 
</p>
<a name="CB_RECALL_ANY"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.10.1"></a><h3>10.1.&nbsp;
CB_RECALL_ANY</h3>

<p>
The metadata server can use the CB_RECALL_ANY callback operation to notify
the client to return some or all of its layouts.
The <a class='info' href='#NFSv4.1'>NFSv4.1 draft<span> (</span><span class='info'>Shepler, S., Eisler, M., and D. Noveck, &ldquo;NFSv4 Minor Version 1,&rdquo; May&nbsp;2008.</span><span>)</span></a> [9] defines
the following types:
  
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
const RCA4_TYPE_MASK_OBJ_LAYOUT_MIN     = 8;
const RCA4_TYPE_MASK_OBJ_LAYOUT_MAX     = 9;

struct  CB_RECALL_ANY4args      {
    uint32_t        craa_objects_to_keep;
    bitmap4         craa_type_mask;
};
</pre></div>
<p>
Typically, CB_RECALL_ANY will be used to recall client state when the server
needs to reclaim resources. The craa_type_mask bitmap specifies the type of
resources that are recalled and the craa_objects_to_keep value specifies
how many of the recalled objects the client is allowed to keep.

The object-based layout type mask flags are defined as follows.
They represent the iomode of the recalled layouts.
In response, the client SHOULD return layouts of the recalled iomode
that it needs the least,
keeping at most craa_objects_to_keep object-based layouts.
  
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
///enum pnfs_osd_cb_recall_any_mask {
///    PNFS_OSD_RCA4_TYPE_MASK_READ = 8,
///    PNFS_OSD_RCA4_TYPE_MASK_RW   = 9
///};
///
</pre></div>
<p>
The PNFS_OSD_RCA4_TYPE_MASK_READ flag notifies the client to return layouts
of iomode LAYOUTIOMODE4_READ.
Similarly, the PNFS_OSD_RCA4_TYPE_MASK_RW flag notifies the client to return layouts
of iomode LAYOUTIOMODE4_RW.
When both mask flags are set, the client is notified to return layouts
of either iomode.
  
</p>
<a name="Client Fencing"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.11"></a><h3>11.&nbsp;
Client Fencing</h3>

<p>
In cases where clients are uncommunicative and their lease has expired
or when clients fail to return recalled layouts in a timely manner the
server MAY revoke client layouts and/or device address mappings and reassign
these resources to other clients.
To avoid data corruption, the metadata server MUST fence off the revoked
clients from the respective objects as described in <a class='info' href='#Revoking Capabilities'>Section&nbsp;12.4<span> (</span><span class='info'>Revoking Capabilities</span><span>)</span></a>.
 
</p>
<a name="Security Considerations"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.12"></a><h3>12.&nbsp;
Security Considerations</h3>

<p>
  The pNFS extension partitions the NFSv4 file system protocol into
  two parts, the control path and the data path (storage protocol).
  The control path contains all the new operations described by this
  extension; all existing NFSv4 security mechanisms and features apply
  to the control path.  The combination of components in a pNFS system
  is required to preserve the
  security properties of NFSv4 with respect to an entity accessing
  data via a client, including security countermeasures to defend
  against threats that NFSv4 provides defenses for in environments
  where these threats are considered significant.
 
</p>
<p>
  The metadata server enforces the file access-control policy at LAYOUTGET time.
  The client should use suitable authorization credentials for getting the
  layout for the requested iomode (READ or RW) and the server verifies the
  permissions and ACL for these credentials, possibly returning NFS4ERR_ACCESS
  if the client is not allowed the requested iomode.  If the LAYOUTGET
  operation succeeds the client receives, as part of the layout, a set of
  object capabilities allowing it I/O access to the specified objects
  corresponding to the requested iomode.  When the client acts on I/O operations
  on behalf of its local users it MUST authenticate and authorize the user by
  issuing respective OPEN and ACCESS calls to the metadata server, similarly
  to having NFSv4 data delegations.  If access is allowed the client uses the
  corresponding (READ or RW) capabilities to perform the I/O operations at the
  object-storage devices.  When the metadata server receives a request to change
  file's permissions or ACL it SHOULD recall all layouts for that file
  and it MUST change the capability version attribute on all objects comprising
  the file to implicitly invalidate any outstanding capabilities before
  committing to the new permissions and ACL.  Doing this will ensure that
  clients re-authorize their layouts according to the modified permissions and
  ACL by requesting new layouts.  Recalling the layouts in this case is courtesy
  of the server intended to prevent clients from getting an error on I/Os done
  after the capability version changed.
 
</p>
<p>
   The object storage protocol MUST implement the security aspects
   described in version 1 of the T10
   <a class='info' href='#osd standard'>OSD protocol definition<span> (</span><span class='info'>Weber, R., &ldquo;SCSI Object-Based Storage Device Commands,&rdquo; July&nbsp;2004.</span><span>)</span></a> [2].
  The standard defines four security methods: NOSEC, CAPKEY, CMDRSP,
  and ALLDATA.  To provide minimum level of security allowing verification
  and enforcement of the server access control policy using the layout
  security credentials, the NOSEC security method MUST NOT be used for
  any I/O operation.

   The remainder of this section gives an overview of the security mechanism
   described in that standard.  The goal is to give the reader a basic
   understanding of the object security model.  Any discrepancies
   between this text and the actual standard are obviously to be
   resolved in favor of the OSD standard.
 
</p>
<a name="OSD Security Data Types"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.12.1"></a><h3>12.1.&nbsp;
OSD Security Data Types</h3>

<p>
There are three main data types associated with object security:
a capability, a credential, and security parameters.
The capability is a set of fields that specifies an object
and what operations can be performed on it.
A credential is a signed capability.  Only a security manager
that knows the secret device keys can correctly sign a capability
to form a valid credential.
In pNFS, the file server acts as the security manager and
returns signed capabilities (i.e., credentials) to the pNFS client.
The security parameters are values computed by the issuer of OSD
commands (i.e., the client) that prove they hold valid credentials.
The client uses the credential as a signing key to sign the
requests it makes to OSD, and puts the resulting signatures
into the security_parameters field of the OSD command.
The object storage device uses the secret keys it shares with
the security manager to validate the signature values in
the security parameters.
  
</p>
<p>
The security types are opaque to the generic layers of the
pNFS client.
The credential contents are defined as opaque within the pnfs_osd_object_cred4 
type.
Instead of repeating the definitions here,
the reader is referred to section 4.9.2.2 of the OSD standard.
  
</p>
<a name="anchor16"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.12.2"></a><h3>12.2.&nbsp;
The OSD Security Protocol</h3>

<p>
  The object storage protocol relies on a cryptographically secure
  capability to control accesses at the object storage devices.
  Capabilities are generated by the metadata server, returned to the
  client, and used by the client as described below to authenticate
  their requests to the Object Storage Device (OSD).  Capabilities
  therefore achieve the required access and open mode checking.  They
  allow the file server to define and check a policy (e.g., open mode)
  and the OSD to enforce that policy without knowing
  the details (e.g., user IDs and ACLs).
  
</p>
<p>
  Since capabilities are tied to layouts, and since they are used to
  enforce access control, when the file ACL or mode changes the outstanding
  capabilities MUST be revoked to enforce the new access permissions.
  The server SHOULD recall layouts to allow clients to gracefully
  return their capabilities before the access permissions change.
  
</p>
<p>
  Each capability is specific to a particular object, an operation
  on that object, a byte range within the object (in OSDv2), and has an explicit
  expiration time.  The capabilities are signed with a secret key
  that is shared by the object storage devices (OSD) and the metadata
  managers.  Clients do not have device keys so they are unable to
  forge the signatures in the security parameters.
  The combination of a capability, the OSD system id, and a signature is called
  a "credential" in the OSD specification.
  
</p>
<p>
  The details of the security and privacy model for Object Storage
  are defined in the T10 OSD standard.
  The following sketch of the algorithm should help the
  reader understand the basic model.
  
</p>
<p>
  LAYOUTGET returns a CapKey and a Cap which, together with the OSD SystemID,
  are also called a credential.
  It is a capability and a signature over that capability and the SystemID.
  The OSD Standard refers to the CapKey as the "Credential integrity
  check value" and to the ReqMAC as the "Request integrity check value".
   </p>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
CapKey = MAC&lt;SecretKey&gt;(Cap, SystemID)
Credential = {Cap, SystemID, CapKey}
</pre></div><p>

  The client uses CapKey to sign all the requests it issues
  for that object using the respective Cap.  In other words,
  the Cap appears in the request to the storage device, and
  that request is signed with the CapKey as follows:
   </p>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
ReqMAC = MAC&lt;CapKey&gt;(Req, ReqNonce)
Request = {Cap, Req, ReqNonce, ReqMAC}
</pre></div><p>

  The following is sent to the OSD: {Cap, Req, ReqNonce, ReqMAC}.
  The OSD uses the SecretKey it shares with the metadata server
  to compare the ReqMAC the client sent with a locally computed value:
   </p>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
LocalCapKey = MAC&lt;SecretKey&gt;(Cap, SystemID)
LocalReqMAC = MAC&lt;LocalCapKey&gt;(Req, ReqNonce)
</pre></div><p>

  and if they match the
  OSD assumes that the capabilities came from an authentic
  metadata server and allows access to the object, as allowed
  by the Cap.
  
</p>
<a name="anchor17"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.12.3"></a><h3>12.3.&nbsp;
Protocol Privacy Requirements</h3>

<p>
  Note that if the server LAYOUTGET reply,
  holding CapKey and Cap, is snooped by another client, it can
  be used to generate valid OSD requests (within the Cap
  access restrictions).
  
</p>
<p>
  To provide the required privacy requirements for the capability key
  returned by LAYOUTGET, the <a class='info' href='#GSS-API'>GSS-API<span> (</span><span class='info'>Linn, J., &ldquo;Generic Security Service Application 	Program Interface Version 2, Update 1,&rdquo; January&nbsp;2000.</span><span>)</span></a> [4]
  framework can be used, e.g. by using the RPCSEC_GSS
  privacy method to send the LAYOUTGET operation or by
  using the SSV key to encrypt the oc_capability_key using the GSS_Wrap() function.
  Two general ways to
  provide privacy in the absence of GSS-API that are independent
  of NFSv4 are either an isolated network such as a VLAN or a
  secure channel provided by <a class='info' href='#RFC4301'>IPsec<span> (</span><span class='info'>Kent, S. and K. Seo, &ldquo;Security Architecture for the Internet Protocol,&rdquo; December&nbsp;2005.</span><span>)</span></a> [11].
  
</p>
<a name="Revoking Capabilities"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.12.4"></a><h3>12.4.&nbsp;
Revoking Capabilities</h3>

<p>
At any time, the metadata server may invalidate all outstanding
capabilities on an object by changing its POLICY ACCESS TAG attribute.
The value of the POLICY ACCESS TAG is part of a capability, and it
must match the state of the object attribute.  If they do not match,
the OSD rejects accesses to the object with the sense key set to
ILLEGAL REQUEST and an additional sense code set to INVALID FIELD IN CDB.
When a client attempts to use a capability and is rejected
this way, it should issue a LAYOUTCOMMIT
for the object and specify PNFS_OSD_BAD_CRED in the olr_ioerr_report
parameter. The client may elect to issue a compound
LAYOUTRETURN/LAYOUTGET (or LAYOUTCOMMIT/LAYOUTRETURN/LAYOUTGET)
to attempt to fetch a refreshed set of capabilities.
  
</p>
<p>
The metadata server may elect to change the access policy tag
on an object at any time, for any reason (with the understanding
that there is likely an associated performance penalty, especially
if there are outstanding layouts for this object). The metadata
server MUST revoke outstanding capabilities when any one of
the following occurs:
   </p>
<ul class="text">
<li>The permissions on the object change,
</li>
<li>a conflicting mandatory byte-range lock is granted, or
</li>
<li>a layout is revoked and reassigned to another client.
</li>
</ul><p>
  
</p>
<p>
A pNFS client will typically hold one layout for each byte range for either
READ or READ/WRITE. The client's credentials are checked by the metadata server
at LAYOUTGET time and it is the client's responsibility to enforce access
control among multiple users accessing the same file. It is neither required
nor expected that the pNFS client will obtain a separate layout for each user
accessing a shared object. The client SHOULD use OPEN and ACCESS calls to check user
permissions when performing I/O so that the server's access control policies
are correctly enforced. The result of the ACCESS operation may be cached
while the client holds a valid layout as the server is expected to recall
layouts when the file's access permissions or ACL change.
  
</p>
<a name="IANA Considerations"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.13"></a><h3>13.&nbsp;
IANA Considerations</h3>

<p>
As described in the <a class='info' href='#NFSv4.1'>NFSv4.1 draft<span> (</span><span class='info'>Shepler, S., Eisler, M., and D. Noveck, &ldquo;NFSv4 Minor Version 1,&rdquo; May&nbsp;2008.</span><span>)</span></a> [9],
new layout type numbers will be requested from IANA.
This document defines the protocol associated with the existing
layout type number, LAYOUT4_OSD2_OBJECTS, and it requires no further
actions for IANA.
 
</p>
<a name="rfc.references"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.14"></a><h3>14.&nbsp;
References</h3>

<a name="rfc.references1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>14.1.&nbsp;Normative References</h3>
<table width="99%" border="0">
<tr><td class="author-text" valign="top"><a name="RFC2119">[1]</a></td>
<td class="author-text"><a href="mailto:sob@harvard.edu">Bradner, S.</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>,&rdquo; RFC&nbsp;2119, March&nbsp;1997 (<a href="http://www.ietf.org/rfc/rfc2119.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="osd standard">[2]</a></td>
<td class="author-text">Weber, R., &ldquo;<a href="http://www.t10.org/ftp/t10/drafts/osd/osd-r10.pdf">SCSI Object-Based Storage Device Commands</a>,&rdquo; July&nbsp;2004.</td></tr>
<tr><td class="author-text" valign="top"><a name="XDR">[3]</a></td>
<td class="author-text">Eisler, M., &ldquo;<a href="http://tools.ietf.org/html/rfc4506">XDR: External Data Representation Standard</a>,&rdquo; STD&nbsp;67, RFC&nbsp;4506, May&nbsp;2006 (<a href="http://www.ietf.org/rfc/rfc4506.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="GSS-API">[4]</a></td>
<td class="author-text"><a href="mailto:jlinn@rsasecurity.com">Linn, J.</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc2743">Generic Security Service Application
	Program Interface Version 2, Update 1</a>,&rdquo; RFC&nbsp;2743, January&nbsp;2000 (<a href="ftp://ftp.isi.edu/in-notes/rfc2743.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="iSCSI">[5]</a></td>
<td class="author-text">IBM, IBM, Cisco Systems, Hewlett-Packard Co., and IBM, &ldquo;<a href="http://www.ietf.org/rfc/rfc3720.txt">Internet Small Computer Systems Interface (iSCSI)</a>,&rdquo; RFC&nbsp;3720, April&nbsp;2004 (<a href="http://www.ietf.org/rfc/rfc3720.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="SPC-3">[6]</a></td>
<td class="author-text">Weber, R., &ldquo;<a href="SCSI Primary Commands - 3 (SPC-3)">SCSI Primary Commands - 3 (SPC-3)</a>,&rdquo; INCITS&nbsp;408-2005, May&nbsp;2005.</td></tr>
<tr><td class="author-text" valign="top"><a name="iscsi-naming-format">[7]</a></td>
<td class="author-text">Hewlett-Packard Co., Hewlett-Packard Co., and Hewlett-Packard Co., &ldquo;<a href="http://www.ietf.org/rfc/rfc3980.txt">T11 Network Address Authority (NAA) Naming Format for iSCSI Node Names</a>,&rdquo; RFC&nbsp;3980, February&nbsp;2005 (<a href="http://www.ietf.org/rfc/rfc3980.txt">TXT</a>).</td></tr>
</table>

<a name="rfc.references2"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>14.2.&nbsp;Informative References</h3>
<table width="99%" border="0">
<tr><td class="author-text" valign="top"><a name="NFS41_DOT_X">[8]</a></td>
<td class="author-text">Shepler, S., Eisler, M., and D. Noveck, &ldquo;<a href="http://www.ietf.org/internet-drafts/draft-ietf-nfsv4-minorversion1-dot-x-06.txt">NFSv4 Minor Version 1 XDR Description</a>,&rdquo; May&nbsp;2008.</td></tr>
<tr><td class="author-text" valign="top"><a name="NFSv4.1">[9]</a></td>
<td class="author-text">Shepler, S., Eisler, M., and D. Noveck, &ldquo;<a href="http://www.ietf.org/internet-drafts/draft-ietf-nfsv4-minorversion1-23.txt">NFSv4 Minor Version 1</a>,&rdquo; May&nbsp;2008.</td></tr>
<tr><td class="author-text" valign="top"><a name="OSD2">[10]</a></td>
<td class="author-text">Weber, R., &ldquo;<a href="http://www.t10.org/ftp/t10/drafts/osd2/osd2r03.pdf">SCSI Object-Based Storage Device Commands -2 (OSD-2)</a>,&rdquo; January&nbsp;2008.</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4301">[11]</a></td>
<td class="author-text">Kent, S. and K. Seo, &ldquo;<a href="http://tools.ietf.org/html/rfc4301">Security Architecture for the Internet Protocol</a>,&rdquo; RFC&nbsp;4301, December&nbsp;2005 (<a href="http://www.ietf.org/rfc/rfc4301.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="EUI">[12]</a></td>
<td class="author-text">IEEE, &ldquo;<a href="http://standards.ieee.org/regauth/oui/tutorials/EUI64.html">Guidelines for 64-bit Global Identifier (EUI-64) Registration Authority</a>&rdquo; (<a href="http://standards.ieee.org/regauth/oui/tutorials/EUI64.html">HTML</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="SRP">[13]</a></td>
<td class="author-text">T10/ANSI INCITS 365-2002, &ldquo;<a href="http://ftp.t10.org/ftp/t10/drafts/srp/srp-r16a.pdf">SCSI RDMA Protocol (SRP)</a>,&rdquo; INCITS&nbsp;365-2002 (<a href="http://ftp.t10.org/ftp/t10/drafts/srp/srp-r16a.pdf">PDF</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="FC-FS-2">[14]</a></td>
<td class="author-text">T11 1619-D/ANSI INCITS 424-2007, &ldquo;<a href="http://www.t11.org/t11/stat.nsf/upnum/1619-d">Fibre Channel Framing and Signaling - 2 (FC-FS-2)</a>,&rdquo; INCITS&nbsp;424-2007, August&nbsp;2006.</td></tr>
<tr><td class="author-text" valign="top"><a name="SAS">[15]</a></td>
<td class="author-text">T10 1601-D/ANSI INCITS 417-2006, &ldquo;<a href="http://www.t10.org/ftp/t10/drafts/sas1/sas1r10.pdf">Serial Attached SCSI - 1.1 (SAS-1.1)</a>,&rdquo; INCITS&nbsp;417-2006, September&nbsp;2005 (<a href="http://www.t10.org/ftp/t10/drafts/sas1/sas1r10.pdf">PDF</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="iSNS">[16]</a></td>
<td class="author-text">Tseng, J., Gibbons, K., Travostino, F., Du Laney, C., and J. Souza, &ldquo;<a href="http://www.ietf.org/rfc/rfc4171.txt">Internet Storage Name Service (iSNS)</a>,&rdquo; RFC&nbsp;4171, September&nbsp;2005 (<a href="http://www.ietf.org/rfc/rfc4171.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="Error Correcting Codes">[17]</a></td>
<td class="author-text">MacWilliams, F. and N. Sloane, &ldquo;The Theory of Error-Correcting Codes, Part I,&rdquo; 1977.</td></tr>
</table>

<a name="anchor20"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.A"></a><h3>Appendix A.&nbsp;
Acknowledgments</h3>

<p>
    Todd Pisek was a co-editor of the initial drafts for this document.
    Daniel E. Messinger and Pete Wyckoff reviewed and commented on this document.
 
</p>
<a name="rfc.authors"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>Authors' Addresses</h3>
<table width="99%" border="0" cellpadding="0" cellspacing="0">
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Benny Halevy</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Panasas, Inc.</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">1501 Reedsdale St. Suite 400</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Pittsburgh, PA  15233</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">USA</td></tr>
<tr><td class="author" align="right">Phone:&nbsp;</td>
<td class="author-text">+1-412-323-3500</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:bhalevy@panasas.com">bhalevy@panasas.com</a></td></tr>
<tr><td class="author" align="right">URI:&nbsp;</td>
<td class="author-text"><a href="http://www.panasas.com/">http://www.panasas.com/</a></td></tr>
<tr cellpadding="3"><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Brent Welch</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Panasas, Inc.</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">6520 Kaiser Drive</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Fremont, CA  95444</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">USA</td></tr>
<tr><td class="author" align="right">Phone:&nbsp;</td>
<td class="author-text">+1-650-608-7770</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:welch@panasas.com">welch@panasas.com</a></td></tr>
<tr><td class="author" align="right">URI:&nbsp;</td>
<td class="author-text"><a href="http://www.panasas.com/">http://www.panasas.com/</a></td></tr>
<tr cellpadding="3"><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Jim Zelenka</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Panasas, Inc.</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">1501 Reedsdale St. Suite 400</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Pittsburgh, PA  15233</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">USA</td></tr>
<tr><td class="author" align="right">Phone:&nbsp;</td>
<td class="author-text">+1-412-323-3500</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:jimz@panasas.com">jimz@panasas.com</a></td></tr>
<tr><td class="author" align="right">URI:&nbsp;</td>
<td class="author-text"><a href="http://www.panasas.com/">http://www.panasas.com/</a></td></tr>
</table>
<a name="rfc.copyright"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>Full Copyright Statement</h3>
<p class='copyright'>
Copyright &copy; The IETF Trust (2008).</p>
<p class='copyright'>
This document is subject to the rights,
licenses and restrictions contained in BCP&nbsp;78,
and except as set forth therein,
the authors retain all their rights.</p>
<p class='copyright'>
This document and the information contained herein are provided
on an &ldquo;AS IS&rdquo; basis and THE CONTRIBUTOR,
THE ORGANIZATION HE/SHE REPRESENTS
OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY, THE IETF TRUST
AND THE INTERNET ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT
THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY
IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR
PURPOSE.</p>
<h3>Intellectual Property</h3>
<p class='copyright'>
The IETF takes no position regarding the validity or scope of any
Intellectual Property Rights or other rights that might be claimed
to pertain to the implementation or use of the technology
described in this document or the extent to which any license
under such rights might or might not be available; nor does it
represent that it has made any independent effort to identify any
such rights.
Information on the procedures with respect to
rights in RFC documents can be found in BCP&nbsp;78 and BCP&nbsp;79.</p>
<p class='copyright'>
Copies of IPR disclosures made to the IETF Secretariat and any
assurances of licenses to be made available,
or the result of an attempt made to obtain a general license or
permission for the use of such proprietary rights by implementers or
users of this specification can be obtained from the IETF on-line IPR
repository at <a href='http://www.ietf.org/ipr'>http://www.ietf.org/ipr</a>.</p>
<p class='copyright'>
The IETF invites any interested party to bring to its attention
any copyrights,
patents or patent applications,
or other
proprietary rights that may cover technology that may be required
to implement this standard.
Please address the information to the IETF at <a href='mailto:ietf-ipr@ietf.org'>ietf-ipr@ietf.org</a>.</p>
</body></html>
