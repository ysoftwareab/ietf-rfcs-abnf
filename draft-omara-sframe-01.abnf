sframe_secret = HKDF-Extract(K, 'SFrame10')
sframe_key = HKDF-Expand(sframe_secret, 'key', AEAD.Nk)
sframe_salt = HKDF-Expand(sframe_secret, 'salt', AEAD.Nn)
frame_ctr = encode_big_endian(CTR, AEAD.Nn)
frame_nonce = xor(sframe_salt, frame_ctr)

header = encode_sframe_header(S, CTR, KID)
frame_aad = header + frame_metadata

encrypted_frame = AEAD.Encrypt(sframe_key, frame_nonce, frame_aad, frame)
frame_ctr = encode_big_endian(CTR, AEAD.Nn)
frame_nonce = xor(sframe_salt, frame_ctr)
frame_aad = header + frame_metadata

Signature = Sign(Key, AuthTag(Frame N) || AuthTag(Frame N-1) || ...|| AuthTag(Frame N-M))

   The authentication tags for the previous frames covered by the
   signature and the signature itself will be appended at end of the
   frame, after the current frame authentication tag, in the same order
   that the signature was calculated, and the SFrame header metadata
   signature bit (S) will be set to 1.


       +^ +------------------+
       |  | SFrame header S=1|
       |  +------------------+
       |  |  Encrypted       |
       |  |  payload         |
       |  |                  |
       |^ +------------------+ ^+
       |  |  Auth Tag N      |  |
       |  +------------------+  |
       |  |  Auth Tag N-1    |  |
       |  +------------------+  |
       |  |    ........      |  |
       |  +------------------+  |
       |  |  Auth Tag N-M    |  |
       |  +------------------+ ^|
       |  | NUM | Signature  :  |
       |  +-----+            +  |
       |  :                  |  |
       |  +------------------+  |
       |                        |
       +-> Authenticated with   +-> Signed with
           Auth Tag N               Signature

                      Encrypted Frame with Signature

   Note that the authentication tag for the current frame will only
   authenticate the SFrame header and the encrypted payload, ant not the
   signature nor the previous frames's authentication tags (N-1 to N-M)
   used to calculate the signature.

   The last byte (NUM) after the authentication tag list and before the
   signature indicates the number of the authentication tags from
   previous frames present in the current frame.  All the
   authentications tags MUST have the same size, which MUST be equal to
   the authentication tag size of the current frame.  The signature is
   fixed size depending on the signature algorithm used (for example, 64
   bytes for Ed25519).

   The receiver has to keep track of all the frames received but yet not
   verified, by storing the authentication tags of each received frame.
   When a signature is received, the receiver will verify it with the
   signature key associated to the key id of the frame the signature was
   sent in.  If the verification is successful, the received will mark
   the frames as authenticated and remove them from the list of the not
   verified frames.  It is up to the application to decide what to do
   when signature verification fails.

   When using SVC, the hash will be calculated over all the frames of
   the different spatial layers within the same superframe/picture.
   However the SFU will be able to drop frames within the same stream
   (either spatial or temporal) to match target bitrate.

   If the signature is sent on a frame which layer that is dropped by
   the SFU, the receiver will not receive it and will not be able to
   perform the signature of the other received layers.

   An easy way of solving the issue would be to perform signature only
   on the base layer or take into consideration the frame dependency
   graph and send multiple signatures in parallel (each for a branch of
   the dependency graph).

   In case of simulcast or K-SVC, each spatial layer should be
   authenticated with different signatures to prevent the SFU to discard
   frames with the signature info.

   In any case, it is possible that the frame with the signature is lost
   or the SFU drops it, so the receiver MUST be prepared to not receive
   a signature for a frame and remove it from the pending to be verified
   list after a timeout.

aead_secret = HKDF-Extract(K, 'SFrame10 AES CM AEAD')
enc_key = HKDF-Expand(aead_secret, 'enc', Nk)
auth_key = HKDF-Expand(aead_secret, 'auth', Nh)

aad_len = encode_big_endian(len(aad), 8)
auth_data = aad_len + aad + ct
tag = HMAC(auth_key, auth_data)
ct = AES-CM.Encrypt(key, nonce, pt)
tag = compute_tag(aad, ct)
candidate_tag = compute_tag(aad, inner_ct)
sframe_epoch_secret = MLS-Exporter("SFrame 10 MLS", "", AEAD.Nk)

KID = (sender_index << E) + (epoch % (1 << E))

OverheadPerPacket = 11 + MAC length Overhead bps = PacketPerSecond *
