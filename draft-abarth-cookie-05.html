<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="en"><head><title>HTTP State Management Mechanism</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="description" content="HTTP State Management Mechanism">
<meta name="keywords" content="Internet-Draft">
<meta name="generator" content="xml2rfc v1.35 (http://xml.resource.org/)">
<meta name="viewport" content="width=600;" />
<style type='text/css'><!--
        body {
                font-family: verdana, charcoal, helvetica, arial, sans-serif;
                font-size: 85%;
		max-width: 40em; 
		color: #000; background-color: #FFF;
                margin: 2em;
        }
        h1, h2, h3, h4, h5, h6 {
                font-family: helvetica, monaco, "MS Sans Serif", arial, sans-serif;
                font-weight: bold; font-style: normal;
        }
        h1 { color: #900; background-color: transparent; text-align: right; }
        h3 { color: #333; background-color: transparent; }

        td.RFCbug {
                font-size: x-small; text-decoration: none;
                width: 30px; height: 30px; padding-top: 2px;
                text-align: justify; vertical-align: middle;
                background-color: #000;
        }
        td.RFCbug span.RFC {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: bold; color: #666;
        }
        td.RFCbug span.hotText {
                font-family: charcoal, monaco, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: normal; text-align: center; color: #FFF;
        }

        table.TOCbug { width: 30px; height: 15px; }
        td.TOCbug {
                text-align: center; width: 30px; height: 15px;
                color: #FFF; background-color: #900;
        }
        td.TOCbug a {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, sans-serif;
                font-weight: bold; font-size: x-small; text-decoration: none;
                color: #FFF; background-color: transparent;
        }

        td.header {
                font-family: arial, helvetica, sans-serif; font-size: x-small;
                vertical-align: top; width: 33%;
                color: #FFF; background-color: #666;
        }
        td.author { font-weight: bold; font-size: x-small; margin-left: 4em; }
        td.author-text { font-size: x-small; }

        /* info code from SantaKlauss at http://www.madaboutstyle.com/tooltip2.html */
        a.info {
                /* This is the key. */
                position: relative;
                z-index: 24;
                text-decoration: none;
        }
        a.info:hover {
                z-index: 25;
                color: #FFF; background-color: #900;
        }
        a.info span { display: none; }
        a.info:hover span.info {
                /* The span will display just on :hover state. */
                display: block;
                position: absolute;
                font-size: smaller;
                top: 2em; left: -5em; width: 15em;
                padding: 2px; border: 1px solid #333;
                color: #900; background-color: #EEE;
                text-align: left;
        }

        a { font-weight: bold; }
        a:link    { color: #900; background-color: transparent; }
        a:visited { color: #633; background-color: transparent; }
        a:active  { color: #633; background-color: transparent; }

        p { margin-left: 2em; margin-right: 2em; }
        p.copyright { font-size: x-small; }
        p.toc { font-size: 85%;
		max-width: 40em; 
		font-weight: bold; margin-left: 3em; }
        table.toc { margin: 0 0 0 3em; padding: 0; border: 0; vertical-align: text-top; }
        td.toc { font-size: 85%;
		max-width: 40em; 
		font-weight: bold; vertical-align: text-top; }

        ol.text { margin-left: 2em; margin-right: 2em; }
        ul.text { margin-left: 2em; margin-right: 2em; }
        li      { margin-left: 3em; }

        /* RFC-2629 <spanx>s and <artwork>s. */
        em     { font-style: italic; }
        strong { font-weight: bold; }
        dfn    { font-weight: bold; font-style: normal; }
        cite   { font-weight: normal; font-style: normal; }
        tt     { color: #036; }
        tt, pre, pre dfn, pre em, pre cite, pre span {
                font-family: "Courier New", Courier, monospace; font-size: small;
        }
        pre {
                text-align: left; padding: 4px;
                color: #000; background-color: #CCC;
        }
        pre dfn  { color: #900; }
        pre em   { color: #66F; background-color: #FFC; font-weight: normal; }
        pre .key { color: #33C; font-weight: bold; }
        pre .id  { color: #900; }
        pre .str { color: #000; background-color: #CFF; }
        pre .val { color: #066; }
        pre .rep { color: #909; }
        pre .oth { color: #000; background-color: #FCF; }
        pre .err { background-color: #FCC; }

        /* RFC-2629 <texttable>s. */
        table.all, table.full, table.headers, table.none {
                font-size: 85%;
		max-width: 40em; 
		text-align: center; border-width: 2px;
                vertical-align: top; border-collapse: collapse;
        }
        table.all, table.full { border-style: solid; border-color: black; }
        table.headers, table.none { border-style: none; }
        th {
                font-weight: bold; border-color: black;
                border-width: 2px 2px 3px 2px;
        }
        table.all th, table.full th { border-style: solid; }
        table.headers th { border-style: none none solid none; }
        table.none th { border-style: none; }
        table.all td {
                border-style: solid; border-color: #333;
                border-width: 1px 2px;
        }
        table.full td, table.headers td, table.none td { border-style: none; }

        hr { height: 1px; }
        hr.insert {
                width: 80%; border-style: none; border-width: 0;
                color: #CCC; background-color: #CCC;
        }
--></style>
</head>
<body>
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<table summary="layout" width="66%" border="0" cellpadding="0" cellspacing="0"><tr><td><table summary="layout" width="100%" border="0" cellpadding="2" cellspacing="1">
<tr><td class="header">None (yet)</td><td class="header">A. Barth</td></tr>
<tr><td class="header">Internet-Draft</td><td class="header">U.C. Berkeley</td></tr>
<tr><td class="header">Expires: May 29, 2010</td><td class="header">November 25, 2009</td></tr>
</table></td></tr></table>
<h1><br />HTTP State Management Mechanism<br />draft-abarth-cookie-05</h1>

<h3>Abstract</h3>

<p>This document defines the HTTP Cookie and Set-Cookie headers.
      </p>
<blockquote class="text">
<p>NOTE: Much of the text herein is completely wrong.  If you have
        suggestions for improving the draft, please send email to
        http-state@ietf.org.  Suggestions with test cases are especially
        appreciated.
</p>
</blockquote><p>
      
</p>
<h3>Status of this Memo</h3>
<p>
This Internet-Draft is submitted to IETF in full
conformance with the provisions of BCP&nbsp;78 and BCP&nbsp;79.</p>
<p>
Internet-Drafts are working documents of the Internet Engineering
Task Force (IETF), its areas, and its working groups.
Note that other groups may also distribute working documents as
Internet-Drafts.</p>
<p>
Internet-Drafts are draft documents valid for a maximum of six months
and may be updated, replaced, or obsoleted by other documents at any time.
It is inappropriate to use Internet-Drafts as reference material or to cite
them other than as &ldquo;work in progress.&rdquo;</p>
<p>
The list of current Internet-Drafts can be accessed at
<a href='http://www.ietf.org/ietf/1id-abstracts.txt'>http://www.ietf.org/ietf/1id-abstracts.txt</a>.</p>
<p>
The list of Internet-Draft Shadow Directories can be accessed at
<a href='http://www.ietf.org/shadow.html'>http://www.ietf.org/shadow.html</a>.</p>
<p>
This Internet-Draft will expire on May 29, 2010.</p>

<h3>Copyright Notice</h3>
<p>
Copyright (c) 2009 IETF Trust and the persons identified as the
document authors.  All rights reserved.</p>
<p>
This document is subject to BCP 78 and the IETF Trust's Legal
Provisions Relating to IETF Documents
(http://trustee.ietf.org/license-info) in effect on the date of
publication of this document.  Please review these documents
carefully, as they describe your rights and restrictions with respect
to this document. Code Components extracted from this document must
include Simplified BSD License text as described in Section 4.e of
the Trust Legal Provisions and are provided without warranty as
described in the BSD License.</p>
<p>
This document may contain material from IETF Documents or IETF
Contributions published or made publicly available before November
10, 2008.  The person(s) controlling the copyright in some of this
material may not have granted the IETF Trust the right to allow
modifications of such material outside the IETF Standards Process.
Without obtaining an adequate license from the person(s) controlling
the copyright in such materials, this document may not be modified
outside the IETF Standards Process, and derivative works of it may
not be created outside the IETF Standards Process, except to format
it for publication as an RFC or to translate it into languages other
than English.</p>
<a name="toc"></a><br /><hr />
<h3>Table of Contents</h3>
<p class="toc">
<a href="#intro">1.</a>&nbsp;
Introduction<br />
<a href="#anchor1">2.</a>&nbsp;
Terminology<br />
<a href="#anchor2">3.</a>&nbsp;
Overview<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor3">3.1.</a>&nbsp;
Examples<br />
<a href="#anchor4">4.</a>&nbsp;
Protocol Description<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor5">4.1.</a>&nbsp;
Set-Cookie<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor6">4.1.1.</a>&nbsp;
Syntax<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor7">4.1.2.</a>&nbsp;
Semantics<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor14">4.2.</a>&nbsp;
Cookie<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor15">4.2.1.</a>&nbsp;
Syntax<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor16">4.2.2.</a>&nbsp;
Semantics<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor17">4.3.</a>&nbsp;
Controlling Caching<br />
<a href="#anchor18">5.</a>&nbsp;
User Agent Conformance<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor19">5.1.</a>&nbsp;
Parsing the Set-Cookie Header<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor20">5.1.1.</a>&nbsp;
The Max-Age Attribute<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor21">5.1.2.</a>&nbsp;
The Expires Attribute<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor22">5.1.3.</a>&nbsp;
The Domain Attribute<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor23">5.1.4.</a>&nbsp;
The Path Attribute<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor24">5.1.5.</a>&nbsp;
The Secure Attribute<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor25">5.1.6.</a>&nbsp;
The HttpOnly Attribute<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor26">5.2.</a>&nbsp;
Storage Model<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor27">5.3.</a>&nbsp;
The Cookie Header<br />
<a href="#anchor28">6.</a>&nbsp;
Implementation Considerations<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor29">6.1.</a>&nbsp;
Set-Cookie Content<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor30">6.2.</a>&nbsp;
Implementation Limits<br />
<a href="#anchor31">7.</a>&nbsp;
Security Considerations<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor32">7.1.</a>&nbsp;
Clear Text<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor33">7.2.</a>&nbsp;
Weak Isolation<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor34">7.3.</a>&nbsp;
Cookie Spoofing<br />
<a href="#anchor35">8.</a>&nbsp;
Other, Similar, Proposals<br />
<a href="#anchor36">Appendix&nbsp;A.</a>&nbsp;
Acknowledgements<br />
<a href="#anchor37">Appendix&nbsp;B.</a>&nbsp;
Tabled Items<br />
<a href="#rfc.authors">&#167;</a>&nbsp;
Author's Address<br />
</p>
<br clear="all" />

<a name="intro"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1"></a><h3>1.&nbsp;
Introduction</h3>

<p>This document defines the HTTP Cookie and Set-Cookie header.
</p>
<a name="anchor1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2"></a><h3>2.&nbsp;
Terminology</h3>

<p>The terms user agent, client, server, proxy, and origin server have
      the same meaning as in the HTTP/1.0 specification.
</p>
<p>Fully-qualified host name (FQHN) means either the fully-qualified
      domain name (FQDN) of a host (i.e., a completely specified domain name
      ending in a top-level domain such as .com or .uk), or the numeric
      Internet Protocol (IP) address of a host.  The fully qualified domain
      name is preferred; use of numeric IP addresses is strongly
      discouraged.  [TODO: What does "strongly discouraged" mean?]
</p>
<p>The terms request-host and request-URI refer to the values the
      client would send to the server as, respectively, the host (but not
      port) and abs_path portions of the absoluteURI (http_URL) of the HTTP
      request line.  Note that request-host must be a FQHN.  Hosts names can
      be specified either as an IP address or a FQHN string.
</p>
<p>Because it was used in Netscape's original implementation of state
      management, we will use the term cookie to refer to the state
      information that passes between an origin server and user agent, and
      that gets stored by the user agent.
</p>
<a name="anchor2"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3"></a><h3>3.&nbsp;
Overview</h3>

<p>We outline here a way for an origin server to send state
      information to the user agent, and for the user agent to return the
      state information to the origin server.
</p>
<p>The origin server initiates a session, if it so desires, by
      including a Set-Cookie header in an HTTP response.  (Note that
      "session" here does not refer to a persistent network connection but
      to a logical session created from HTTP requests and responses.  The
      presence or absence of a persistent connection should have no effect
      on the use of cookie-derived
      sessions).
</p>
<p>A user agent returns a Cookie request header (see below) to the
      origin server if it chooses to continue a session.  The origin server
      may ignore it or use it to determine the current state of the
      session.  It may send the client a Set-Cookie response header
      with the same or different information, or it may send no Set-Cookie
      header at all.
</p>
<p>Servers may return a Set-Cookie response headers with any
      response.  User agents should send Cookie request headers, subject to
      other rules detailed below, with every request.
</p>
<p>An origin server may include multiple Set-Cookie headers in a
      response.  Note that an intervening gateway MUST NOT fold multiple
      Set-Cookie headers into a single header.
</p>
<p>[TODO: Overview the Set-Cookie and Cookie headers.]
</p>
<a name="anchor3"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.1"></a><h3>3.1.&nbsp;
Examples</h3>

<p>[TODO: Put some examples here.
</p>
<a name="anchor4"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4"></a><h3>4.&nbsp;
Protocol Description</h3>

<p>The cookie protocol consists of two HTTP headers: the Set-Cookie
      header and the Cookie header.  The server sends the Set-Cookie header
      is to the user agent in an HTTP response, causing the user agent to
      modify the Cookie header it returns to the server.
</p>
<p>This section describes the syntax and semantics of the protocol.
      Detailed conformance requirements for user agents are given in Section
      [TODO].
</p>
<a name="anchor5"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.1"></a><h3>4.1.&nbsp;
Set-Cookie</h3>

<a name="anchor6"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.1.1"></a><h3>4.1.1.&nbsp;
Syntax</h3>

<p>Informally, the Set-Cookie response header comprises the token
          Set-Cookie:, followed by a cookie.  Each cookie begins with a
          name-value-pair, followed by zero or more semi-colon-separated
          attribute-value pairs.
</p>
<p>[TODO: Consider replacing this grammar with the one from
          2009-11-07-Yui-Naruse.txt.]
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>

  set-cookie-header = "Set-Cookie:" name-value-pairs
  name-value-pairs  = name-value-pair *(";" name-value-pair)
  name-value-pair   = name ["=" value]        ; optional value
  name              = token
  value             = *CHAR

</pre></div>
<p>The valid character for the value production vary depending on
          the attribute name.
</p>
<p>[TODO: Investigate what token actually means.]
</p>
<p>Attributes names are case-insensitive.  White space is
          permitted between tokens.  Servers MUST NOT include two attributes
          with the same name.  Note that although the above syntax
          description shows value as optional, some attributes require
          values.
</p>
<p>The cookie-value is opaque to the user agent and MAY be
          anything the origin server chooses to send, possibly in a
          server-selected printable ASCII encoding.  "Opaque" implies that
          the content is of interest and relevance only to the origin
          server.  The content may, in fact, be readable by anyone who
          examines the Set-Cookie header.
</p>
<p>NOTE: The syntax above allows whitespace between the attribute
          and the U+3D ("=") character.  Servers wishing to interoperate
          with some legacy user agents might wish to elide this extra white
          space to maximize compatibility.
</p>
<a name="anchor7"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.1.2"></a><h3>4.1.2.&nbsp;
Semantics</h3>

<p>When the user agent receives a Set-Cookie header, the user
          agent stores the cookie in its cookie store.  When the user agent
          makes another HTTP request to the origin server, the user agent
          returns the cookie in the Cookie header.
</p>
<p>The server can override the default handling of cookies by
          specifying cookie attributes.  User agents ignore unrecognized
          cookie attributes.
</p>
<a name="anchor8"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.1.2.1"></a><h3>4.1.2.1.&nbsp;
Max-Age</h3>

<p>[TODO: Consider removing Max-Age from the server conformance
            section because it's not supported by IE.]
            </p>
<blockquote class="text"><dl>
<dt>Syntax</dt>
<dd>A sequence of ASCII numerals.
</dd>
<dt>Semantics</dt>
<dd>The value of the Max-Age attribute
              represents the maximum lifetime of the cookie, measured in
              seconds from the moment the user agent receives the cookie. If
              the server does not supply an Expires or a Max-Age attribute,
              the lifetime of the cookie is limited to the current session (as
              defined by the user agent).
</dd>
</dl></blockquote><p>
            
</p>
<a name="anchor9"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.1.2.2"></a><h3>4.1.2.2.&nbsp;
Expires</h3>

<p>
            </p>
<blockquote class="text"><dl>
<dt>Syntax</dt>
<dd>An RFC 1123 date [cite].  (Note that user
              agents use very forgiving date parers; see Section
              [TODO]).
</dd>
<dt>Semantics</dt>
<dd>The value of the Expires attribute
              represents the maximum lifetime of the cookie, represented as
              the point in time at which the cookie expires. If the server
              does not supply an Expires or a Max-Age attribute, the
              lifetime of the cookie is limited to the current session (as
              defined by the user agent).
</dd>
</dl></blockquote><p>
            
</p>
<a name="anchor10"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.1.2.3"></a><h3>4.1.2.3.&nbsp;
Domain</h3>

<p>[TODO: Test Domain.]  The Domain attribute specifies the
            domain for which the cookie is valid.  The leading dot isn't
            required.  If there is no Domain attribute, the default is to
            return the cookie only to the origin server.  [TODO: You can
            only set cookies for related domains.]
</p>
<a name="anchor11"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.1.2.4"></a><h3>4.1.2.4.&nbsp;
Path</h3>

<p>
            </p>
<blockquote class="text"><dl>
<dt>Syntax</dt>
<dd>A sequence of characters beginning with a
              "/" character.
</dd>
<dt>Semantics</dt>
<dd>The Path attribute specifies the scope
              of the cookie within a given FQDN.  The user agent will
              include a cookie in an HTTP request only if the Request-URI's
              path matches, or is a subdirectory of, the cookie's Path
              attribute (where the "/" character is interpreted as a
              directory separator).  The default value for the Path
              attribute is the directory of the Request-URI when the cookie
              was received.
</dd>
</dl></blockquote><p>
          
</p>
<a name="anchor12"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.1.2.5"></a><h3>4.1.2.5.&nbsp;
Secure</h3>

<p>
            </p>
<blockquote class="text"><dl>
<dt>Syntax</dt>
<dd>Servers MUST NOT include a value.
</dd>
<dt>Semantics</dt>
<dd>The user agent SHOULD protect the
              confidentiality of cookies with the Secure attribute by not
              transmitting Secure cookies over an "insecure" channel (where
              "insecure" is defined by the user agent).
</dd>
</dl></blockquote><p>
            
</p>
<a name="anchor13"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.1.2.6"></a><h3>4.1.2.6.&nbsp;
HttpOnly</h3>

<p>
            </p>
<blockquote class="text"><dl>
<dt>Syntax</dt>
<dd>Servers MUST NOT include a value.
</dd>
<dt>Semantics</dt>
<dd>The user agent SHOULD protect
              confidentiality of cookies with the HttpOnly attribute by not
              revealing their contents via "non-HTTP" APIs.  (Note that this
              document does not define which APIs are "non-HTTP".)
              
</dd>
</dl></blockquote><p>
            
</p>
<a name="anchor14"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.2"></a><h3>4.2.&nbsp;
Cookie</h3>

<a name="anchor15"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.2.1"></a><h3>4.2.1.&nbsp;
Syntax</h3>

<p>The user agent returns stored cookies to the origin server in
          the Cookie header.  The Cookie header shares a common syntax with
          the Set-Cookie header, but the semantics of the header differ
          dramatically.
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>

  cookie-header     = "Cookie:" name-value-pairs
  name-value-pairs  = name-value-pair *(";" name-value-pair)
  name-value-pair   = name "=" value
  name              = token
  value             = *CHAR

</pre></div>
<p>NOTE: If the server supplies a Set-Cookie header that does not
          conform to the grammar in Section [TODO], the user agent might not
          supply a Cookie header that conforms to the preceding grammar.
</p>
<a name="anchor16"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.2.2"></a><h3>4.2.2.&nbsp;
Semantics</h3>

<p>Each name-value-pair represents a cookie stored by the user
          agent.  The cookie name is returned in as the name and the cookie
          value is returned as the value.
</p>
<p>The meaning of the cookies in the Cookie header is not defined
          by this document.  Servers are expected to imbue these cookies
          with server-specific semantics.
</p>
<a name="anchor17"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.3"></a><h3>4.3.&nbsp;
Controlling Caching</h3>

<p>[TODO: Should we go into this much detail here?  This seems
        redundant with the HTTP specs.]
</p>
<p>An origin server must be cognizant of the effect of possible
        caching of both the returned resource and the Set-Cookie header.
        Caching "public" documents is desirable.  For example, if the origin
        server wants to use a public document such as a "front door" page as
        a sentinel to indicate the beginning of a session for which a
        Set-Cookie response header must be generated, the page should be
        stored in caches "pre-expired" so that the origin server will see
        further requests.  "Private documents", for example those that
        contain information strictly private to a session, should not be
        cached in shared caches.
</p>
<p>If the cookie is intended for use by a single user, the Set-Cookie
        header should not be cached.  A Set-Cookie header that is intended to
        be shared by multiple users may be cached.
</p>
<p>The origin server should send the following additional HTTP/1.1
        response headers, depending on circumstances:  [TODO: Is this good
        advice?]
        </p>
<ul class="text">
<li>To suppress caching of the Set-Cookie header: Cache-control: no-
          cache="set-cookie".
</li>
</ul><p>
        
</p>
<p>and one of the following:
        </p>
<ul class="text">
<li>To suppress caching of a private document in shared caches:
          Cache-Control: private.
</li>
<li>To allow caching of a document and require that it be validated
          before returning it to the client: Cache-Control:
          must-revalidate.
</li>
<li>To allow caching of a document, but to require that proxy caches
          (not user agent caches) validate it before returning it to the
          client: Cache-Control: proxy-revalidate.
</li>
<li>To allow caching of a document and request that it be validated
          before returning it to the client (by "pre-expiring" it):
          Cache-Control: max-age=0.  Not all caches will revalidate the
          document in every case.
</li>
</ul><p>
        
</p>
<p>HTTP/1.1 servers must send Expires: old-date (where old-date is a
        date long in the past) on responses containing Set-Cookie response
        headers unless they know for certain (by out of band means) that
        there are no downstream HTTP/1.0 proxies.  HTTP/1.1 servers may send
        other Cache-Control directives that permit caching by HTTP/1.1
        proxies in addition to the Expires: old-date directive; the
        Cache-Control directive will override the Expires: old-date for
        HTTP/1.1 proxies.
</p>
<a name="anchor18"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5"></a><h3>5.&nbsp;
User Agent Conformance</h3>

<p>Not all origin servers conform to the behavior specified in the
      previous section.  To ensure interoperability, user agents MUST
      process cookies in a manner that is "black-box" indistinguishable from
      the requirements in this section.
</p>
<a name="anchor19"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.1"></a><h3>5.1.&nbsp;
Parsing the Set-Cookie Header</h3>

<p>Let an LWS character be either a U+20 (SPACE) or a U+09 (TAB)
        character.
</p>
<p>When a user agent receives an Set-Cookie header in an HTTP
        response, the user agent *receives a set-cookie-string*
        consisting of the value of the header.
</p>
<p>A user agent MUST use the following algorithm to parse
        set-cookie-strings:
        </p>
<ol class="text">
<li>[TODO: Deal with "," characters.  My current thinking is that
          we don't actually have to do anything special for them.]
</li>
<li>If the header contains a U+3B (";") character:
          
<blockquote class="text">
<p>the name-value-pair string is characters up to, but not
            including, the first U+3B (";"), and the
            unparsed-cookie-attributes are the remainder of the header
            (including the U+3B (";") in question).
</p>
</blockquote>
          Otherwise:
          
<blockquote class="text">
<p>the name-value-pair string is all the character contained in
            the header, and the unparsed-cookie-attributes is the empty
            string.
</p>
</blockquote>
          
</li>
<li>If the name-value-pair string contains a U+3D ("=") character:
          
<blockquote class="text">
<p>the (possibly empty) name string is the characters up to, but
            not including, the first U+3D ("=") character, and the (possibly
            empty) value string is the characters after the first U+3D ("=")
            character.
</p>
</blockquote>
          Otherwise:
          
<blockquote class="text">
<p>the name string is empty, and the value string is the entire
            name-value-pair string.
</p>
</blockquote>
          
</li>
<li>Remove any leading or trailing space from the name
          string and the value string.
</li>
<li>The cookie-name is the name string, and the cookie-value is the
          value string.
</li>
</ol><p>
        
</p>
<p>The user agent MUST use the following algorithm to parse the
        unparsed-attributes:
        </p>
<ol class="text">
<li>If the unparsed-attributes string is empty, skip the rest of these
          steps.
</li>
<li>Consume the first character of the unparsed-attributes (which
          will be a U+3B (";") character).
</li>
<li>If the remaining unparsed-attributes contains a U+3B (";")
          character:
          
<blockquote class="text">
<p>Consume the characters of the unparsed-attributes up to, but
            not including, the first U+3B (";") character.
</p>
</blockquote>
          Otherwise:
          
<blockquote class="text">
<p>Consume the remainder of the unparsed-attributes.
</p>
</blockquote>
          The characters consumed in this step comprise the
          attribute-value-pair string.
</li>
<li>If the attribute-value-pair string contains a U+3D ("=")
          character:
          
<blockquote class="text">
<p>the (possibly empty) name string is the characters up to, but
            not including, the first U+3D ("=") character, and the (possibly
            empty) value string is the characters after the first U+3D ("=")
            character .
</p>
</blockquote>
          Otherwise:
          
<blockquote class="text">
<p>the name string is the entire attribute-value-pair string,
            and the value string is empty.  (Note that this step differs
            from the analogous step when parsing the name-value-pair
            string.)
</p>
</blockquote>
          
</li>
<li>Remove any leading or trailing space from the name string and
          the value string.
</li>
<li>If the name is a ASCII case-insensitive match for an entry in
          the following table, process the value string as instructed.
          <div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>

       Attribute  |  Instruction
      ------------+---------------------
       Max-Age    |  See Section [TODO]
       Expires    |  See Section [TODO]
       Domain     |  See Section [TODO]
       Path       |  See Section [TODO]
       Secure     |  See Section [TODO]
       HttpOnly   |  See Section [TODO]

</pre></div>
          
</li>
<li>Return to Step 1.
</li>
</ol><p>
        
</p>
<p>[TODO: Can parsing a cookie ever fail?  Doesn't look like
        it!  Well, unless you count "Set-Cookie: " as a fail...]
</p>
<p>When the user agent finishes parsing the set-cookie-string
        header, the user agent *receives a cookie* from the origin server
        with name cookie-name, value cookie-value, and attributes
        cookie-attribute-list.
</p>
<a name="anchor20"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.1.1"></a><h3>5.1.1.&nbsp;
The Max-Age Attribute</h3>

<p>When the user agent receives a cookie attribute with a name
          string that case-insensitively matches the string "Max-Age", the
          user agent MUST process the value string as follows.
</p>
<p>If the first character of the value string is not a DIGIT or a
          "-" character, the user agent MUST ignore the attribute.
</p>
<p>If the remainder of value string contains a non-DIGIT
          character, the user agent MUST ignore the attribute.
</p>
<p>Let delta-seconds be the contents of the value string converted
          to an integer.
</p>
<p>If delta-seconds is less than or equal to 0, then append an
          attribute named Expires (note the name conversion) to the
          cookie-attribute-list with a value equal to the current date and
          time.
</p>
<p>If delta-seconds is strictly greater than 0, then append an
          attribute named Expires (note the name conversion) to the
          cookie-attribute-list with a value equal to the current date and
          time plus delta-seconds seconds.
</p>
<a name="anchor21"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.1.2"></a><h3>5.1.2.&nbsp;
The Expires Attribute</h3>

<p>Unfortunately, cookie dates are quite complex for historical
          reasons.
</p>
<p>When the user agent receives a cookie attribute with a name
          string that case-insensitively matches the string "Expires", the
          user agent MUST process the value string as follows.
</p>
<p>If the attribute lacks a value or the value is the empty string,
          abort these steps.
</p>
<p>Using the grammar below, divide the value of the attribute into
          date-tokens.
          </p>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>

      cookie-date     = date-token-list
      date-token-list = date-token [ delimiter date-token-list ]
      delimiter       = U+09 / U+20 / U+21 / U+22 / U+23 / U+24 /
                        U+25 / U+26 / U+27 / U+28 / U+29 / U+2A /
                        U+2B / U+2C / U+2D / U+2E / U+2F / U+3B /
                        U+3C / U+3D / U+3E / U+3F / U+40 / U+5B /
                        U+5C / U+5D / U+5E / U+5F / U+60 / U+7B /
                        U+7C / U+7D / U+7E
      date-token      = day-of-month / month / year / time / mystery
      day-of-month    = 2DIGIT / DIGIT
      month           = "jan" [ mystery ] / "feb" [ mystery ] /
                        "mar" [ mystery ] / "apr" [ mystery ] /
                        "may" [ mystery ] / "jun" [ mystery ] /
                        "jul" [ mystery ] / "aug" [ mystery ] /
                        "sep" [ mystery ] / "oct" [ mystery ] /
                        "nov" [ mystery ] / "dec" [ mystery ]
      year            = 5DIGIT / 4DIGIT / 3DIGIT / 2DIGIT / DIGIT
      time            = 2DIGIT ":" 2DIGIT ":" 2DIGIT
      mystery         = (anything except a delimiter)

</pre></div><p>

          
</p>
<p>Process each data-token sequentially in the order the
          date-tokens appear in the attribute value:
          </p>
<ol class="text">
<li>If the found-day-of-month flag is not set and the token matches
            the day-of-month production, set the found-day-of-month flag and set
            the day-of-month-value to the number denoted by the token.  Skip
            the remaining sub-steps and continue to the next token.
</li>
<li>If the found-month flag is not set and the token matches the
            month production, set the found-month flag and set the month-value
            to the month denoted by the token.  Skip the remaining sub-steps
            and continue to the next token.
</li>
<li>If the found-year flag is not set and the token matches the
            year production, set the found-year flag and set the year-value
            to the number denoted by the token.  Skip the remaining sub-steps
            and continue to the next token.
</li>
<li>If the found-time flag is not set and the token matches the
            time production, set the found-time flag and set the hour-value,
            minute-value, and second-value to the numbers denoted by the
            digits in the token, respectively.  Skip the remaining sub-steps
            and continue to the next token.
</li>
</ol><p>
          
</p>
<p>Abort these steps if
          </p>
<ul class="text">
<li>at least one of the found-day-of-month, found-month,
            found-year, or found-time flags is not set,
</li>
<li>the day-of-month-value is less than 1 or greater than 31,
</li>
<li>the year-value is less than 1601 or greater than 30827,
</li>
<li>the hour-value is greater than 23,
</li>
<li>the minute-value is greater than 59, or
</li>
<li>the second-value is greater than 59.
</li>
</ul><p>
          
</p>
<p>If the year-value is greater than 68 and less than 100, increment
          the year-value by 1900.
</p>
<p>If the year-value is greater than or equal to 0 and less than
          69, increment the year-value by 2000.
</p>
<p>Let the expiry-time be the date whose day-of-month,
          month, year, hour, minute, and second (in GMT) are the
          day-of-month-value, the month-value, the year-value, the hour-value,
          the minute-value, and the second-value, respectively.
</p>
<p>If the expiry-time is later than the last date the user agent
          can represent, the user agent MAY replace the expiry-time with the
          last representable date.
</p>
<p>If the expiry-time is earlier than the first date the user agent
          can represent, the user agent MAY replace the expiry-time with the
          first representable date.
</p>
<p>Append an attribute named Expires to the cookie-attribute-list
          with a value equal to expiry-time.
</p>
<a name="anchor22"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.1.3"></a><h3>5.1.3.&nbsp;
The Domain Attribute</h3>

<p>When the user agent receives a cookie attribute with a name
          string that case-insensitively matches the string "Domain", the user
          agent MUST process the value string as follows:
          </p>
<ul class="text">
<li>If the value string is empty, then ignore the attribute.
            [TODO: Add a test for this with multiple Domain attributes.]
</li>
<li>If the first character of the value string is ".", then append
            an attribute named Domain to the cookie-attribute-list with a
            value equal to value string excluding the leading "." character.
</li>
<li>If the first character of the value string is not ".", then append
            an attribute named Domain to the cookie-attribute-list with a
            value equal to value string and mark the attribute as host-only.
</li>
<li>[TODO: Deal with domains that have an insufficient number of
            fields.]
</li>
<li>Otherwise, ignore the attribute.
</li>
</ul><p>
          
</p>
<a name="anchor23"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.1.4"></a><h3>5.1.4.&nbsp;
The Path Attribute</h3>

<p>The user agent MUST use the following algorithm to compute the
          default-path of a cookie:
          </p>
<ol class="text">
<li>Let uri-path be the path portion of the URI from which the
            user agent received the cookie.  [TODO: Define this more
            precisely.]
</li>
<li>If the first character of the uri-path is not a "/"
            character, output "/" and skip the remaining steps.
</li>
<li>If the uri-path contains only a single "/" character, output
            "/" and skip the remaining steps.
</li>
<li>Output the characters of the uri-path from the first
            character up to, and but not including, the right-most "/".
</li>
</ol><p>
          
</p>
<p>A request-path path-matches a cookie-path if the cookie-path is
          a prefix of the request-path and at least one of the following
          conditions hold:
          </p>
<ul class="text">
<li>The last character of the cookie-path is "/".
</li>
<li>The first character of the request-path that is not
            included in the cookie-path is a "/" character.
</li>
</ul><p>
          
</p>
<p>When the user agent receives a cookie attribute with a name
          string that case-insensitively matches the string "Path", the user
          agent MUST process the value string as follows:
          </p>
<ul class="text">
<li>If the value string is empty, then append an attribute named
            Path to the cookie-attribute-list with a value equal to
            default-path of the cookie.  [TODO: Is this right if there are
            more than one path attribute?]
</li>
<li>If the value string is non-empty and the first character is
            "/", then append an attribute named Path to the
            cookie-attribute-list with a value equal to value string.
</li>
<li>Otherwise, ignore the attribute.
</li>
</ul><p>
          
</p>
<p>[TODO: Test \ ? ; # $ % etc]
</p>
<a name="anchor24"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.1.5"></a><h3>5.1.5.&nbsp;
The Secure Attribute</h3>

<p>When the user agent receives a cookie attribute with a name
          string that case-insensitively matches the string "Secure", the
          user agent MUST append an attribute named Secure to the
          cookie-attribute-list with an empty value regardless of the value
          string.
</p>
<a name="anchor25"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.1.6"></a><h3>5.1.6.&nbsp;
The HttpOnly Attribute</h3>

<p>When the user agent receives a cookie attribute with a name
          string that case-insensitively matches the string "HttpOnly", the
          user agent MUST append an attribute named HttpOnly to the
          cookie-attribute-list with an empty value regardless of the value
          string.
</p>
<a name="anchor26"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.2"></a><h3>5.2.&nbsp;
Storage Model</h3>

<p>When the user agent receives a cookie, the user agent SHOULD
        record the cookie in its cookie store as follows.
</p>
<p>A user agent MAY ignore received cookies in their entirety if the
        user agent is configured to block receiving cookie for a particular
        response.  For example, the user agent might wish to block receiving
        cookies from "third-party" responses.
</p>
<p>The user agent stores the following fields about each cookie:
        </p>
<ul class="text">
<li>name (a sequence of bytes)
</li>
<li>value (a sequence of bytes)
</li>
<li>expiry (a date)
</li>
<li>domain (a cookie-domain)
</li>
<li>path (a sequence of bytes)
</li>
<li>creation (a date)
</li>
<li>last-access (a date)
</li>
<li>persistent (a Boolean)
</li>
<li>host-only (a Boolean)
</li>
<li>secure-only (a Boolean)
</li>
<li>http-only (a Boolean)
</li>
</ul><p>
        
</p>
<p>When the user agent receives a cookie, the user agent MUST follow
        the following algorithm:
        </p>
<ol class="text">
<li>Create a new cookie based on the parsed Set-Cookie
          header:
          
<ol class="text">
<li>Create a new cookie with the following default field values:
            
<ul class="text">
<li>name = the cookie-name
</li>
<li>value = the cookie-value
</li>
<li>expiry = the latest representable date
</li>
<li>domain = the request-host
</li>
<li>path = the cookie's default-path
</li>
<li>last-access = the date and time the cookie was received
</li>
<li>persistent = false
</li>
<li>host-only = true
</li>
<li>secure-only = false
</li>
<li>http-only = false
</li>
</ul>
            
</li>
<li>Update the default field values according to the
            cookie-attributes:
            
<blockquote class="text"><dl>
<dt>expiry</dt>
<dd>If the cookie-attributes contains at least
              one valid Expires attribute, store the expiry-value of the last
              such attribute in the expiry field. Store the value true in the
              persistent field. [TODO: Test that this really works when mixing
              Max-Age and Expires.]
</dd>
<dt>domain</dt>
<dd>If the cookie-attributes contains at least
              one Domain attribute, store the value of the last such
              attribute in the domain field.  Store the value false in the
              host-only field.  [TODO: Reject cookies for unrelated
              domains.] [TODO: If the URL's host is an IP address, let
              Domain to be an IP address if it matches the URL's host
              exactly, but set the host-only flag. ]
</dd>
<dt>path</dt>
<dd>If the cookie-attributes contains at least
              one Path attribute, store the value of the last such attribute
              in the path field.
</dd>
<dt>secure-only</dt>
<dd>If the cookie-attributes contains at
              least one Secure attribute, store the value true in the
              secure-only field.
</dd>
<dt>http-only</dt>
<dd>If the cookie-attributes contains at
              least one HttpOnly attribute, store the value true in the
              http-only field.
</dd>
</dl></blockquote>
            
</li>
</ol>
          
</li>
<li>Remove from the cookie store all cookies that have the share
          the same name, domain, path, and host-only fields as the newly
          created cookie.  [TODO: Validate this list!]  [TODO: There's some
          funny business around http-only here.]
</li>
<li>Insert the newly created cookie into the cookie store.
</li>
</ol><p>
        
</p>
<p>The user agent MUST evict a cookie from the cookie store if A
        cookie exists in the cookie store with an expiry date in the
        past.
</p>
<p>The user agent MAY evict a cookie from the cookie store if the
        number of cookies sharing a domain field exceeds some predetermined
        upper bound (such as 50 cookies).  [TODO: Explain where 50 comes
        from.]
</p>
<p>The user agent MAY evict cookies from the cookie store if the
        cookie store exceeds some maximum storage bound (such as 3000
        cookies).  [TODO: Explain where 3000 comes from.]
</p>
<p>When the user agent evicts cookies from the cookie store, the
        user agent MUST evict cookies in the following priority order:
        </p>
<ol class="text">
<li>Cookies with an expiry date in the past.
</li>
<li>Cookies that share a domain field more than a predetermined
          number of other cookies.
</li>
<li>All other cookies.
</li>
</ol><p>
        
</p>
<p>If two cookies have the same removal priority, the user agent
        MUST evict the cookie with the least recent last-access date
        first.
</p>
<p>When "the current session is over", the user agent MUST remove from
        the cookie store all cookies with the persistent field set to
        false.
        </p>
<blockquote class="text">
<p>NOTE: This document does not define when "the current session
          is over."  Many user agents remove non-persistent cookies when
          they exit.  However, other user agent expire non-persistent
          cookies using other heuristics.
</p>
</blockquote><p> 
        
</p>
<a name="anchor27"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.3"></a><h3>5.3.&nbsp;
The Cookie Header</h3>

<p>When the user agent generates an HTTP request for a particular
        URI, the user agent SHOULD attach exactly one HTTP header named
        Cookie if the cookie-string (defined below) for that URI is
        non-empty.
</p>
<p>A user agent MAY elide the Cookie header in its entirety if the
        user agent is configured to block sending cookie for a particular
        request.  For example, the user agent might wish to block sending
        cookies during "third-party" requests.
</p>
<p>The user agent MUST use the following algorithm to compute the
        cookie-string from a cookie store and from a URI:
        </p>
<ol class="text">
<li>Let cookie-list be the set of cookies from the cookie store
          that meet the following requirements:
          
<ul class="text">
<li>The cookie's domain field must domain-match the URI's
            host. [TODO: Spec me]
</li>
<li>The cookie's path field must path-match the URI's path.
</li>
<li>If the cookie's host-only flag is set, the cookie's domain
            field must denote exactly the same FQDN as the URI's host.
            [TODO: Internet Explorer does not implement this requirement but
            most other major implementations do.]
</li>
<li>If the cookie's secure-only field is true, then 
            the URI's scheme must denote a "secure" protocol.
            
<blockquote class="text">
<p>NOTE: The notion of an "secure" protocol is not defined by
              this document.  Typically, user agents consider a protocol
              secure if the protocol makes use of transport-layer security,
              such as TLS.  For example, most user agents consider "https"
              to be a scheme that denotes a secure protocol.
</p>
</blockquote>
            
</li>
<li>If the cookie's http-only field is true, then include the
            cookie unless the cookie-string is begin generated for a
            "non-HTTP" API.  (Note that this document does not define which
            APIs are "non-HTTP".)
</li>
</ul>
          NOTE: The Cookie header will not contain any expired cookies
          because cookies past their expiry date are removed from the cookie
          store immediately.
</li>
<li>Sort the cookie-list in the following order:
          
<ul class="text">
<li>Cookies with longer path fields are listed before cookies
            with shorter path field.
</li>
<li>Among cookies that have equal length path fields, cookies
            with earlier creation dates are listed before cookies with later
            creation dates.
</li>
</ul>
          
</li>
<li>Update the last-access field of each cookie in the cookie-list
          to the current date.
</li>
<li>Serialize the cookie-list into a cookie-string by processing each
          cookie in the cookie-list in order:
          
<ol class="text">
<li>If the cookie's name field is non-empty, output the cookie's
            name field followed by the character U+3D ("=").
</li>
<li>Output the cookie's value field.
</li>
<li>If there is an unprocessed cookie in the cookie-list, output
            the characters U+3B and U+20 ("; ")
</li>
</ol>
          
</li>
</ol><p>
        
</p>
<a name="anchor28"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6"></a><h3>6.&nbsp;
Implementation Considerations</h3>

<a name="anchor29"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.1"></a><h3>6.1.&nbsp;
Set-Cookie Content</h3>

<p>An origin server's content should probably be divided into disjoint
        application areas, some of which require the use of state information.
        The application areas can be distinguished by their request URLs.  The
        Set-Cookie header can incorporate information about the application
        areas by setting the Path attribute for each one.
</p>
<p>The session information can obviously be clear or encoded text that
        describes state.  However, if it grows too large, it can become
        unwieldy.  Therefore, an implementor might choose for the session
        information to be a key to a server-side resource.  [TODO: Describe
        briefly how to generate a decent session key.]
</p>
<p>[TODO: We could recommend that servers encrypt and mac their cookie
        data.]
</p>
<p>[TODO: Mention issues that arise from having multiple concurrent
        sessions.]
</p>
<a name="anchor30"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.2"></a><h3>6.2.&nbsp;
Implementation Limits</h3>

<p>Practical user agent implementations have limits on the number
        and size of cookies that they can store.  General-use user agents
        SHOULD provide each of the following minimum capabilities:
        </p>
<ul class="text">
<li>At least 4096 bytes per cookie (as measured by the size of the
          characters that comprise the cookie non-terminal in the syntax
          description of the Set-Cookie header).  [TODO: Validate]
</li>
<li>At least 50 cookies per domain.  [TODO: History lesson]
</li>
<li>At least 3000 cookies total.
</li>
</ul><p>
        
</p>
<p>The information in a Set-Cookie response header must be retained
        in its entirety.  If for some reason there is inadequate space to
        store the cookie, the cookie must be discarded, not truncated.
</p>
<p>Applications should use as few and as small cookies as possible, and
        they should cope gracefully with the loss of a cookie.  [TODO: Could
        mention latency issues that arise from having tons of cookies.] 
</p>
<a name="anchor31"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7"></a><h3>7.&nbsp;
Security Considerations</h3>

<a name="anchor32"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.1"></a><h3>7.1.&nbsp;
Clear Text</h3>

<p>The information in the Set-Cookie and Cookie headers is
        transmitted in the clear.  Three consequences are:
        </p>
<ol class="text">
<li>Any sensitive information that is conveyed in in the headers is
          exposed to an eavesdropper.
</li>
<li>A malicious intermediary could alter the headers as they travel
          in either direction, with unpredictable results.
</li>
<li>A malicious client could alter the Cookie header before
          transmission, with unpredictable results.
</li>
</ol><p>
        
</p>
<p>These facts imply that information of a personal and/or financial
        nature should be sent over a secure channel.  For less sensitive
        information, or when the content of the header is a database key, an
        origin server should be vigilant to prevent a bad Cookie value from
        causing failures.
</p>
<a name="anchor33"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.2"></a><h3>7.2.&nbsp;
Weak Isolation</h3>

<p>[TODO: Weak isolation by port.]
</p>
<p>[TODO: Weak isolation by scheme (e.g., ftp, gopher, etc).]
</p>
<a name="anchor34"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.3"></a><h3>7.3.&nbsp;
Cookie Spoofing</h3>

<p>[TODO: Mention integrity issue where a sibling domain can inject
        cookies.]
</p>
<p>[TODO: Mention integrity issue where a HTTP can inject cookies
        into HTTPS.]
</p>
<a name="anchor35"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.8"></a><h3>8.&nbsp;
Other, Similar, Proposals</h3>

<p>[TODO: Describe relation to the Netscape Cookie Spec, RFC 2109,
      RFC 2629, and cookie-v2.]
</p>
<a name="anchor36"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.A"></a><h3>Appendix A.&nbsp;
Acknowledgements</h3>

<p>This document borrows heavily from RFC 2109.  [TODO: Figure out the
      proper way to credit the authors of RFC 2109.]
</p>
<a name="anchor37"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.B"></a><h3>Appendix B.&nbsp;
Tabled Items</h3>

<p>Tabled items:
      </p>
<ul class="text">
<li>Public suffix.
</li>
</ul><p>
      
</p>
<a name="rfc.authors"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>Author's Address</h3>
<table width="99%" border="0" cellpadding="0" cellspacing="0">
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Adam Barth</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">University of California, Berkeley</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:abarth@eecs.berkeley.edu">abarth@eecs.berkeley.edu</a></td></tr>
<tr><td class="author" align="right">URI:&nbsp;</td>
<td class="author-text"><a href="http://www.adambarth.com/">http://www.adambarth.com/</a></td></tr>
</table>
</body></html>
