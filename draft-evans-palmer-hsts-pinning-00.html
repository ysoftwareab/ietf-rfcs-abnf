<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" 
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html lang="en" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head profile="http://www.w3.org/2006/03/hcard%20http://dublincore.org/documents/2008/08/04/dc-html/">
  <meta http-equiv="Content-Type" content="text/html; charset=us-ascii" />

  <title>Certificate Pinning Extension for HSTS</title>

  <style type="text/css" title="Xml2Rfc (sans serif)">
  /*<![CDATA[*/
	  a {
	  text-decoration: none;
	  }
	  a.smpl {
	  color: black;
	  }
	  a:hover {
	  text-decoration: underline;
	  }
	  a:active {
	  text-decoration: underline;
	  }
	  address {
	  margin-top: 1em;
	  margin-left: 2em;
	  font-style: normal;
	  }
	  body {
	  color: black;
	  font-family: verdana, helvetica, arial, sans-serif;
	  font-size: 10pt;
	  
	  }
	  cite {
	  font-style: normal;
	  }
	  dd {
	  margin-right: 2em;
	  }
	  dl {
	  margin-left: 2em;
	  }
	
	  ul.empty {
	  list-style-type: none;
	  }
	  ul.empty li {
	  margin-top: .5em;
	  }
	  dl p {
	  margin-left: 0em;
	  }
	  dt {
	  margin-top: .5em;
	  }
	  h1 {
	  font-size: 14pt;
	  line-height: 21pt;
	  page-break-after: avoid;
	  }
	  h1.np {
	  page-break-before: always;
	  }
	  h1 a {
	  color: #333333;
	  }
	  h2 {
	  font-size: 12pt;
	  line-height: 15pt;
	  page-break-after: avoid;
	  }
	  h3, h4, h5, h6 {
	  font-size: 10pt;
	  page-break-after: avoid;
	  }
	  h2 a, h3 a, h4 a, h5 a, h6 a {
	  color: black;
	  }
	  img {
	  margin-left: 3em;
	  }
	  li {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  ol {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  ol p {
	  margin-left: 0em;
	  }
	  p {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  pre {
	  margin-left: 3em;
	  background-color: lightyellow;
	  padding: .25em;
	  }
	  pre.text2 {
	  border-style: dotted;
	  border-width: 1px;
	  background-color: #f0f0f0;
	  width: 69em;
	  }
	  pre.inline {
	  background-color: white;
	  padding: 0em;
	  }
	  pre.text {
	  border-style: dotted;
	  border-width: 1px;
	  background-color: #f8f8f8;
	  width: 69em;
	  }
	  pre.drawing {
	  border-style: solid;
	  border-width: 1px;
	  background-color: #f8f8f8;
	  padding: 2em;
	  }
	  table {
	  margin-left: 2em;
	  }
	  table.tt {
	  vertical-align: top;
	  }
	  table.full {
	  border-style: outset;
	  border-width: 1px;
	  }
	  table.headers {
	  border-style: outset;
	  border-width: 1px;
	  }
	  table.tt td {
	  vertical-align: top;
	  }
	  table.full td {
	  border-style: inset;
	  border-width: 1px;
	  }
	  table.tt th {
	  vertical-align: top;
	  }
	  table.full th {
	  border-style: inset;
	  border-width: 1px;
	  }
	  table.headers th {
	  border-style: none none inset none;
	  border-width: 1px;
	  }
	  table.left {
	  margin-right: auto;
	  }
	  table.right {
	  margin-left: auto;
	  }
	  table.center {
	  margin-left: auto;
	  margin-right: auto;
	  }
	  caption {
	  caption-side: bottom;
	  font-weight: bold;
	  font-size: 9pt;
	  margin-top: .5em;
	  }
	
	  table.header {
	  border-spacing: 1px;
	  width: 95%;
	  font-size: 10pt;
	  color: white;
	  }
	  td.top {
	  vertical-align: top;
	  }
	  td.topnowrap {
	  vertical-align: top;
	  white-space: nowrap; 
	  }
	  table.header td {
	  background-color: gray;
	  width: 50%;
	  }
	  table.header a {
	  color: white;
	  }
	  td.reference {
	  vertical-align: top;
	  white-space: nowrap;
	  padding-right: 1em;
	  }
	  thead {
	  display:table-header-group;
	  }
	  ul.toc, ul.toc ul {
	  list-style: none;
	  margin-left: 1.5em;
	  margin-right: 0em;
	  padding-left: 0em;
	  }
	  ul.toc li {
	  line-height: 150%;
	  font-weight: bold;
	  font-size: 10pt;
	  margin-left: 0em;
	  margin-right: 0em;
	  }
	  ul.toc li li {
	  line-height: normal;
	  font-weight: normal;
	  font-size: 9pt;
	  margin-left: 0em;
	  margin-right: 0em;
	  }
	  li.excluded {
	  font-size: 0pt;
	  }
	  ul p {
	  margin-left: 0em;
	  }
	
	  .comment {
	  background-color: yellow;
	  }
	  .center {
	  text-align: center;
	  }
	  .error {
	  color: red;
	  font-style: italic;
	  font-weight: bold;
	  }
	  .figure {
	  font-weight: bold;
	  text-align: center;
	  font-size: 9pt;
	  }
	  .filename {
	  color: #333333;
	  font-weight: bold;
	  font-size: 12pt;
	  line-height: 21pt;
	  text-align: center;
	  }
	  .fn {
	  font-weight: bold;
	  }
	  .hidden {
	  display: none;
	  }
	  .left {
	  text-align: left;
	  }
	  .right {
	  text-align: right;
	  }
	  .title {
	  color: #990000;
	  font-size: 18pt;
	  line-height: 18pt;
	  font-weight: bold;
	  text-align: center;
	  margin-top: 36pt;
	  }
	  .vcardline {
	  display: block;
	  }
	  .warning {
	  font-size: 14pt;
	  background-color: yellow;
	  }
	
	
	  @media print {
	  .noprint {
		display: none;
	  }
	
	  a {
		color: black;
		text-decoration: none;
	  }
	
	  table.header {
		width: 90%;
	  }
	
	  td.header {
		width: 50%;
		color: black;
		background-color: white;
		vertical-align: top;
		font-size: 12pt;
	  }
	
	  ul.toc a::after {
		content: leader('.') target-counter(attr(href), page);
	  }
	
	  ul.ind li li a {
		content: target-counter(attr(href), page);
	  }
	
	  .print2col {
		column-count: 2;
		-moz-column-count: 2;
		column-fill: auto;
	  }
	  }
	
	  @page {
	  @top-left {
		   content: "Internet-Draft"; 
	  } 
	  @top-right {
		   content: "December 2010"; 
	  } 
	  @top-center {
		   content: "Abbreviated Title";3
	  } 
	  @bottom-left {
		   content: "Doe"; 
	  } 
	  @bottom-center {
		   content: "Expires June 2011"; 
	  } 
	  @bottom-right {
		   content: "[Page " counter(page) "]"; 
	  } 
	  }
	
	  @page:first { 
		@top-left {
		  content: normal;
		}
		@top-right {
		  content: normal;
		}
		@top-center {
		  content: normal;
		}
	  }
  /*]]>*/
  </style>

  <link href="#rfc.toc" rel="Contents">
<link href="#rfc.section.1" rel="Chapter" title="1 Introduction">
<link href="#rfc.section.1.1" rel="Chapter" title="1.1 About Notation">
<link href="#rfc.section.2" rel="Chapter" title="2 Server and Client Behavior">
<link href="#rfc.section.2.1" rel="Chapter" title="2.1 Noting and Validating Pins">
<link href="#rfc.section.2.2" rel="Chapter" title="2.2 Interactions With Built-in HSTS Lists">
<link href="#rfc.section.2.3" rel="Chapter" title="2.3 Un-pinning">
<link href="#rfc.section.2.4" rel="Chapter" title="2.4 Pinning Self-Signed Leaf Certificates">
<link href="#rfc.section.3" rel="Chapter" title="3 Security Considerations">
<link href="#rfc.section.3.1" rel="Chapter" title="3.1 Deployment Guidance">
<link href="#rfc.section.3.2" rel="Chapter" title="3.2 Disasters Relating to Compromises of Certificates">
<link href="#rfc.section.3.2.1" rel="Chapter" title="3.2.1 The private key for the pinned leaf is stolen">
<link href="#rfc.section.3.2.2" rel="Chapter" title="3.2.2 The root or intermediary CA is compromised">
<link href="#rfc.section.3.3" rel="Chapter" title="3.3 Disasters Relating to Certificate Mismanagement">
<link href="#rfc.section.3.3.1" rel="Chapter" title="3.3.1 The leaf certificate expires">
<link href="#rfc.section.3.3.2" rel="Chapter" title="3.3.2 The leaf certificate is lost">
<link href="#rfc.section.3.3.3" rel="Chapter" title="3.3.3 The CA is extorting the operator approaching renewal/expiry time">
<link href="#rfc.section.3.4" rel="Chapter" title="3.4 Disasters Relating to Vulnerabilities in the Known HSTS Host">
<link href="#rfc.section.3.4.1" rel="Chapter" title="3.4.1 The host is vulnerable to HTTP header injection">
<link href="#rfc.section.3.4.2" rel="Chapter" title="3.4.2 The host suffers full server-side compromise">
<link href="#rfc.section.4" rel="Chapter" title="4 Usability Considerations">
<link href="#rfc.section.5" rel="Chapter" title="5 Economic Considerations">
<link href="#rfc.section.6" rel="Chapter" title="6 Ideas">
<link href="#rfc.section.6.1" rel="Chapter" title="6.1 Requiring Backup Pins">
<link href="#rfc.section.6.2" rel="Chapter" title="6.2 Prepopulating Pin Lists">
<link href="#rfc.section.6.3" rel="Chapter" title="6.3 Tools to Assist Creation of Header">
<link href="#rfc.section.6.4" rel="Chapter" title="6.4 Pinning Subresources">
<link href="#rfc.section.6.5" rel="Chapter" title="6.5 Pinning Without Requiring HTTPS">
<link href="#rfc.section.7" rel="Chapter" title="7 Acknowledgements">
<link href="#rfc.section.8" rel="Chapter" title="8 What's Changed">
<link href="#rfc.references" rel="Chapter" title="9 References">
<link href="#rfc.appendix.Appendix%20A" rel="Chapter" title="Appendix A Fingerprint Generation">
<link href="#rfc.authors" rel="Chapter">


  <meta name="generator" content=
  "http://greenbytes.de/tech/webdav/rfc2629.xslt, Revision 1.539, 2011-01-02 17:13:00, XSLT vendor: SAXON 6.5.5 from Michael Kay http://saxon.sf.net/" />
  <link rel="schema.dct" href="http://purl.org/dc/terms/" />
  <meta name="dct.creator" content="Doe, J." />
  <meta name="dct.identifier" content="urn:ietf:id:draft-sample-input-00" />
  <meta name="dct.issued" scheme="ISO8601" content="2010-12" />
  
  <meta name="dct.abstract" content="This memo describes an extension to the HTTP Strict Transport Security specification allowing web host operators to instruct UAs to remember ("pin") hosts' cryptographic identities for a given period of time. During that time, UAs will require that the host present a certificate chain including at least one public key whose fingerprint matches one or more of the pinned fingerprints for that host. By effectively reducing the scope of authorities who can authenticate the domain during the lifetime of the pin, we hope pinning reduces the incidence of man-in-the-middle attacks due to compromised Certification Authorities and other authentication errors and attacks." />
  <meta name="description" content="This memo describes an extension to the HTTP Strict Transport Security specification allowing web host operators to instruct UAs to remember ("pin") hosts' cryptographic identities for a given period of time. During that time, UAs will require that the host present a certificate chain including at least one public key whose fingerprint matches one or more of the pinned fingerprints for that host. By effectively reducing the scope of authorities who can authenticate the domain during the lifetime of the pin, we hope pinning reduces the incidence of man-in-the-middle attacks due to compromised Certification Authorities and other authentication errors and attacks." />
  <meta name="keywords" content="I-D, Internet-Draft, Certificate, X.509, Certification authority, Certificate pinning, HTTPS, TLS, SSL" />

</head>

<body>

  <table class="header">
    <tbody>
    
    	<tr>
<td class="left">Web Security</td>
<td class="right">C. Evans</td>
</tr>
<tr>
<td class="left">Internet-Draft</td>
<td class="right">C. Palmer</td>
</tr>
<tr>
<td class="left">Expires: March 24, 2012</td>
<td class="right">Google, Inc.</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">September 21, 2011</td>
</tr>

    	
    </tbody>
  </table>

  <p class="title">Certificate Pinning Extension for HSTS<br />
  <span class="filename">draft-evans-palmer-hsts-pinning-00</span></p>
  
  <h1 id="rfc.abstract"><a href="#rfc.abstract">Abstract</a></h1>
<p>This memo describes an extension to the HTTP Strict Transport Security specification allowing web host operators to instruct UAs to remember ("pin") hosts' cryptographic identities for a given period of time. During that time, UAs will require that the host present a certificate chain including at least one public key whose fingerprint matches one or more of the pinned fingerprints for that host. By effectively reducing the scope of authorities who can authenticate the domain during the lifetime of the pin, we hope pinning reduces the incidence of man-in-the-middle attacks due to compromised Certification Authorities and other authentication errors and attacks.</p>
<h1 id="rfc.status"><a href="#rfc.status">Status of this Memo</a></h1>
<p>This Internet-Draft is submitted in full conformance with the provisions of BCP 78 and BCP 79.</p>
<p>Internet-Drafts are working documents of the Internet Engineering Task Force (IETF).  Note that other groups may also distribute working documents as Internet-Drafts.  The list of current Internet- Drafts is at http://datatracker.ietf.org/drafts/current/.</p>
<p>Internet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other documents at any time.  It is inappropriate to use Internet-Drafts as reference material or to cite them other than as "work in progress."</p>
<p>This Internet-Draft will expire on March 24, 2012.</p>
<h1 id="rfc.copyrightnotice"><a href="#rfc.copyrightnotice">Copyright Notice</a></h1>
<p>Copyright (c) 2011 IETF Trust and the persons identified as the document authors.  All rights reserved.</p>
<p>This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document.  Please review these documents carefully, as they describe your rights and restrictions with respect to this document.  Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.</p>
<h1 id="rfc.section.1">
<a href="#rfc.section.1">1.</a> <a href="#introduction" id="introduction">Introduction</a>
</h1>
<p id="rfc.section.1.p.1">We propose to extend the HSTS HTTP header to enable a web host to express to UAs which certificate(s) UAs may expect to be present in the host's certificate chain in future connections. We call this "certificate pinning". The Google Chrome/ium browser ships with a static set of pins, and individual users can extend the set of pins. Although effective, this does not scale. This proposal addresses the scale problem.</p>
<p id="rfc.section.1.p.2">Deploying certificate pinning safely will require operational and organizational maturity due to the risk that HSTS Hosts may "brick" themselves by pinning to a certificate that becomes invalid. We discuss potential mitigations for those risks. We believe that, with care, host operators can greatly reduce the risk of MITM attacks and other false-authentication problems for their users without incurring undue risk.</p>
<p id="rfc.section.1.p.3">This document extends the version of HSTS defined in <a href="#hsts-spec">[hsts-spec]</a> and follows that document's notational and naming conventions.</p>
<p id="rfc.section.1.p.4">This draft is being discussed on the WebSec Working Group mailing list, websec@ietf.org.</p>
<h1 id="rfc.section.1.1">
<a href="#rfc.section.1.1">1.1.</a> <a href="#notation" id="notation">About Notation</a>
</h1>
<p id="rfc.section.1.1.p.1">The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119.</p>
<p id="rfc.section.1.1.p.2">This document includes some pseudocode examples written in a Python-like language, to clarify UA behavior. The examples assume that a global data structure, hsts_metadata, exists and contains the HSTS metadata that the UA has accumulated over time. It is indexable by domain name and includes the usual HSTS parameters (maxAge, includesSubDomains) as well as the new HSTS parameter, pins, that this document introduces. It also assumes a hypothetical X.509 datatype, denoted with a variable named "certificate", that includes likely X.509 fields such as public_key (which would correspond to the SubjectPublicKeyInfo field in a real X.509 certificate).</p>
<p id="rfc.section.1.1.p.3">There are also some working code examples using the Python and Go languages.</p>
<p id="rfc.section.1.1.p.4">The examples are intended to be illustrative, not necessarily precise or using algorithms that a real, optimized UA would employ.</p>
<h1 id="rfc.section.2">
<a href="#rfc.section.2">2.</a> <a href="#server-client-behavior" id="server-client-behavior">Server and Client Behavior</a>
</h1>
<p id="rfc.section.2.p.1">To set a pin, HSTS Hosts use a new STS extension directive (STS-d-ext) in their HSTS response header field: pins. To enable pin revocation (<a href="#un-pinning">Section 2.3</a>), hosts may also use the new breakv and breakc directives.</p>
<div id="#rfc.figure.1"></div>
<div id="#directive-abnf"></div>
<pre>
STS-d-ext-pin    =    "pins" OWS "=" OWS [fingerprints]
STS-d-ext-breakv =    "breakv" OWS "=" OWS fp-type "/" base64-digits
STS-d-ext-breakc =    "breakc" OWS "=" OWS base64-digits

fingerprints     =     fingerprint
                       / fingerprint "," fingerprints

fingerprint      =     fp-type "/" base64-digits

fp-type          =     "sha1"
                       / "sha256"
</pre>
<p id="rfc.section.2.p.2">Here is an example response header field using the pins extension (folded for clarity):</p>
<div id="#rfc.figure.2"></div>
<div id="#pins-example"></div>
<pre>
Strict-Transport-Security: max-age=500; includeSubDomains;
    pins=sha1/4n972HfV354KP560yw4uqe/baXc=,
    sha1/IvGeLsbqzPxdI0b0wuj2xVTdXgc=
</pre>
<p id="rfc.section.2.p.3">Here is an example response header field using both the pins and the breakv extensions (folded for clarity):</p>
<div id="#rfc.figure.3"></div>
<div id="#breakv-example"></div>
<pre>
Strict-Transport-Security: max-age=500; includeSubDomains;
    pins=sha1/4n972HfV354KP560yw4uqe/baXc=,
    sha1/IvGeLsbqzPxdI0b0wuj2xVTdXgc=;
    breakv=sha1/jUQEXH7Q2Ly+Xn/yFWJxAHT3fDc=
</pre>
<p id="rfc.section.2.p.4">The fingerprint is the SHA-1 (or SHA-256) hash of the raw SubjectPublicKeyInfo field of the certificate, encoded in base-64 for brevity. We pin public keys, rather than entire certificates, to enable operators to generate new certificates containing old public keys (see <a href="#why-fingerprint-key">[why-fingerprint-key]</a>). (Although host operators may do this, certification authorities already do. Additionally, when UAs check certificate chains, they do so by checking that each certificate is signed by its parent's public key, making the public key &#8212; not the certificate &#8212; the essential identifier.)</p>
<p id="rfc.section.2.p.5">See <a href="#fingerprint-generation">Appendix Appendix A</a> for an example program that generates public key fingerprints from SubjectPublicKeyInfo fields in certificates.</p>
<p id="rfc.section.2.p.6">The breakv directive communicates to UAs a pin break verifier, and the breakc directive communicates the pin break code. Hosts SHOULD generate pin break codes and verifiers. When present, UAs MUST note pin break verifiers and honor pin break codes. See <a href="#un-pinning">Section 2.3</a> for a discussion of verifiers and codes.</p>
<h1 id="rfc.section.2.1">
<a href="#rfc.section.2.1">2.1.</a> <a href="#noting-validating" id="noting-validating">Noting and Validating Pins</a>
</h1>
<p id="rfc.section.2.1.p.1">Upon receipt of this header field, the UA will note the HSTS Host as a Known Pinned HSTS Host. When connecting to a Known Pinned HSTS Host, the UA will compare the public key fingerprint(s) in the Host's certificate chain to the pinned fingerprints, and will fail closed unless at least one public key in the chain has a fingerprint matching one of the pinned fingerprints. (Following the HSTS specification, TLS errors for HSTS hosts must be hard, with no chance for the user to click through any warnings or errors. We treat fingerprint mismatch in the same way.)</p>
<p id="rfc.section.2.1.p.2">Note that to validate pins, UAs must necessarily read the headers of a response. In case of mismatch, UAs SHOULD NOT read the response body as part of failing hard.</p>
<div id="#rfc.figure.4"></div>
<div id="#validation-example"></div>
<p>This pseudocode illustrates how UAs validate the certificate chains they receive from Known Pinned HSTS Hosts.  </p>
<pre>
def chain_is_pinned_valid(chain, pins):
    for certificate in chain:
        for fingerprint in pins:
            if certificate.public_key.fingerprint == fingerprint:
                return True

    return False

# ...
if not chain_is_pinned_valid(request.tls_info.certificate_chain,
                             hsts_metadata[request.hostname].pins):
    request.fail()
# ...
</pre>
<p id="rfc.section.2.1.p.3">The pin list appearing in an HSTS header MUST have at least one pin matching one of the public key fingerprints in the chain that was validated for the HTTPS connection. This defends against HTTP header injection attacks (see <a href="#header-injection">Section 3.4.1</a>).</p>
<p id="rfc.section.2.1.p.4">UAs MUST cache pins and pin break verifiers for Known Pinned HSTS Hosts, and MIGHT AS WELL do so in the same manner as other HSTS metadata. If the maxAge directive is present in the HSTS response header, the HSTS metadata &#8212; including fingerprints in the pins directive &#8212; expire at that time.</p>
<h1 id="rfc.section.2.2">
<a href="#rfc.section.2.2">2.2.</a> <a href="#interactions-built-in" id="interactions-built-in">Interactions With Built-in HSTS Lists</a>
</h1>
<p id="rfc.section.2.2.p.1">UAs MAY choose to implement built-in certificate pins, alongside any built-in HSTS opt-in list. UAs MUST allow users to override a built-in pin list, including turning it off.</p>
<p id="rfc.section.2.2.p.2">Hosts can update built-in pin lists by using this extension. Similarly, UAs can update their built-in pin lists with software updates. In either case, UAs MUST use the newest information &#8212; built-in or set via HSTS &#8212; when validating certificate chains for the host.</p>
<h1 id="rfc.section.2.3">
<a href="#rfc.section.2.3">2.3.</a> <a href="#un-pinning" id="un-pinning">Un-pinning</a>
</h1>
<p id="rfc.section.2.3.p.1">Hosts can enable pin revocation for their previously-pinned key fingerprints by setting pin break verifiers using the breakv directive. Then, when hosts want to break pins, they set the pin break code in their HSTS headers using the breakc directive. (This idea is due to Perrin in <a href="#pin-break-codes">[pin-break-codes]</a>.)</p>
<p id="rfc.section.2.3.p.2">Pin break codes are short random strings, kept secret until the host operator wants to break the pins. Pin break verifiers are simply hashes of the codes. Generating codes and verifiers, and verifying that codes match a previously set verifier, is trivial. See <a href="#python-verifiers">Figure 5</a>.</p>
<div id="#rfc.figure.5"></div>
<div id="#python-verifiers"></div>
<pre>
def make_pin_break():
    code = os.urandom(16)
    verifier = hashlib.sha1(code).digest()
    return base64.b64encode(code), base64.b64encode(verifier)

def verify_code(code, verifier):
    c = base64.b64decode(code)
    v = hashlib.sha1(c).digest()
    return verifier == base64.b64encode(v)


if __name__ == "__main__":
    import sys

    if 1 == len(sys.argv):
        print make_pin_break()
    elif 3 == len(sys.argv):
        print verify_code(sys.argv[1], sys.argv[2])
</pre>
<p id="rfc.section.2.3.p.3">Hosts can request that UAs forget pinned fingerprints by issuing a valid HSTS header containing the pin break code. UAs MUST forget all pinned fingerprints associated with the matching pin break verifier, and MUST NOT forget any pinned fingerprints not associated with that verifier.</p>
<p id="rfc.section.2.3.p.4">In the event that a host sends an HSTS header containing a breakc that does not match a breakv the UA has previously noted, the UA MUST ignore that breakc and MUST process any pins or breakv directives as normal. This is so that hosts can break old pins but still successfully set new pins and verifiers in UAs that have not previously (or recently) noted the host.</p>
<p id="rfc.section.2.3.p.5">Host operators SHOULD keep the pin break code secret, and SHOULD generate codes that are computationally infeasible to guess (such as by using their system's cryptographic random number generator; note that a 128-bit security level suffices).</p>
<h1 id="rfc.section.2.4">
<a href="#rfc.section.2.4">2.4.</a> <a href="#pinning-self-signed" id="pinning-self-signed">Pinning Self-Signed Leaf Certificates</a>
</h1>
<p id="rfc.section.2.4.p.1">To the extent that UAs allow or enable hosts to authenticate themselves with self-signed end entity certificates, they MAY also allow hosts to pin the public keys in such certificates. The usability and security implications of this practice are outside the scope of this specification.</p>
<h1 id="rfc.section.3">
<a href="#rfc.section.3">3.</a> <a href="#security-considerations" id="security-considerations">Security Considerations</a>
</h1>
<h1 id="rfc.section.3.1">
<a href="#rfc.section.3.1">3.1.</a> <a href="#deployment-guidance" id="deployment-guidance">Deployment Guidance</a>
</h1>
<p id="rfc.section.3.1.p.1">To recover from disasters of various types, as described below, we recommend that HSTS Hosts follow these guidelines.</p>
<p></p>

<ul>
<li>Operators SHOULD have a safety net: they should generate a backup key pair, get it signed by a different (root and/or intermediary) CA than their live certificate(s), store it safely offline, and set this backup pin in their pins directive.  <ul><li>Having a backup certificate was always a good idea anyway.</li></ul>
<p> </p>
</li>
<li>It is most economical to have the backup certificate signed by a completely different signature chain than the live certificate, to maximize recoverability in the event of either root or intermediary signer compromise.</li>
<li>Operators SHOULD periodically exercise their backup pin plan &#8212; an untested backup is no backup at all.</li>
<li>Operators SHOULD have a diverse certificate portfolio. They should pin to a few different roots, owned by different companies if possible.</li>
<li>Operators SHOULD start small. Operators SHOULD first deploy HSTS certificate pinning by setting a maxAge of minutes or a few hours, and gradually increase maxAge as they gain confidence in their operational capability.</li>
</ul>
<h1 id="rfc.section.3.2">
<a href="#rfc.section.3.2">3.2.</a> <a href="#compromise-disasters" id="compromise-disasters">Disasters Relating to Compromises of Certificates</a>
</h1>
<h1 id="rfc.section.3.2.1">
<a href="#rfc.section.3.2.1">3.2.1.</a> <a href="#leaf-compromise" id="leaf-compromise">The private key for the pinned leaf is stolen</a>
</h1>
<p id="rfc.section.3.2.1.p.1">If a leaf certificate is compromised, the host is likely to have experienced a complete compromise, in which case the problem is greater than certificates and pins. See <a href="#server-compromise">Section 3.4.2</a>.</p>
<h1 id="rfc.section.3.2.2">
<a href="#rfc.section.3.2.2">3.2.2.</a> <a href="#signer-compromise" id="signer-compromise">The root or intermediary CA is compromised</a>
</h1>
<p id="rfc.section.3.2.2.p.1">This disaster will affect many hosts (HSTS Hosts and other), and will likely require a client software update (e.g. to revoke the signing CA and/or the false certificates it issued).</p>
<p id="rfc.section.3.2.2.p.2">If the operator has a backup pin whose signature chain is still valid, they should deploy it. In this case, the host need not even degrade from Known Pinned to Known.</p>
<h1 id="rfc.section.3.3">
<a href="#rfc.section.3.3">3.3.</a> <a href="#certificate-management-disasters" id="certificate-management-disasters">Disasters Relating to Certificate Mismanagement</a>
</h1>
<h1 id="rfc.section.3.3.1">
<a href="#rfc.section.3.3.1">3.3.1.</a> <a href="#leaf-expiration" id="leaf-expiration">The leaf certificate expires</a>
</h1>
<p id="rfc.section.3.3.1.p.1">Operators should deploy their backup pin.</p>
<p id="rfc.section.3.3.1.p.2">Note that when evaluating a pinned certificate, the UA MUST un-pin the fingerprint if the certificate has expired. If a pin list becomes empty, the UA downgrades the host from Known Pinned HSTS Host to Known HSTS Host. The usual HTTPS validation procedure now applies.</p>
<p id="rfc.section.3.3.1.p.3">Operators should get any CA to sign a new cert with updated expiry, based on the existing, unchanged public key.</p>
<p></p>

<ul>
<li>And/or, operators should deploy their backup pin and/or have a CA sign an all-new key.</li>
<li>Operators should continue to set pins in their HSTS header, and UAs will upgrade from Known HSTS Host to Known Pinned HSTS Host when the fingerprint(s) refer(s) to valid certificate(s) again.</li>
</ul>
<h1 id="rfc.section.3.3.2">
<a href="#rfc.section.3.3.2">3.3.2.</a> <a href="#leaf-loss" id="leaf-loss">The leaf certificate is lost</a>
</h1>
<p id="rfc.section.3.3.2.p.1">Operators should deploy their backup pin. Alternately, if they pinned to a root or intermediary signer, they should get a new leaf certificate signed by one of those signers.</p>
<p id="rfc.section.3.3.2.p.2">Operators SHOULD attempt to get the certificate revoked by whatever means available (extant revocation mechanisms like CRL or OCSP, blacklisting in the UA, or future revocation mechanisms).  </p>

<ul><li>We know that extant revocation mechanisms are unreliable. Operators SHOULD NOT not depend on them.</li></ul>

<p> </p>
<h1 id="rfc.section.3.3.3">
<a href="#rfc.section.3.3.3">3.3.3.</a> <a href="#ca-extortion" id="ca-extortion">The CA is extorting the operator approaching renewal/expiry time</a>
</h1>
<p id="rfc.section.3.3.3.p.1">If the backup pin chains to a different signer, the operator should deploy it. (They should then get a new backup pin.)</p>
<p id="rfc.section.3.3.3.p.2">The time running up to renewal can be used to serve additional HSTS public key hashes, pinning to new root CAs.</p>
<p></p>

<ul><li>Hosts can also disable pinning altogether as described above.</li></ul>
<p id="rfc.section.3.3.3.p.4">If the host is pinned to leaves or its own intermediary, operators can simply get a different root CA to sign the existing public key.</p>
<p id="rfc.section.3.3.3.p.5">If the operator fails to get new certs in time, and the host is pinned only to the one root CA, the solution is simple; see <a href="#leaf-expiration">Section 3.3.1</a>.</p>
<h1 id="rfc.section.3.4">
<a href="#rfc.section.3.4">3.4.</a> <a href="#vulnerability-disasters" id="vulnerability-disasters">Disasters Relating to Vulnerabilities in the Known HSTS Host</a>
</h1>
<h1 id="rfc.section.3.4.1">
<a href="#rfc.section.3.4.1">3.4.1.</a> <a href="#header-injection" id="header-injection">The host is vulnerable to HTTP header injection</a>
</h1>
<p id="rfc.section.3.4.1.p.1">Note that header injection vulnerabilities are in general more severe than merely disabling pinning for individual users.</p>
<p id="rfc.section.3.4.1.p.2">The attacker could set additional pins for certificates he controls, or pin break verifiers for codes he controls, allowing him to undetectably MITM clients. When or if the client is outside the scope of the attacker's MITM attack, the result is DoS.</p>
<p id="rfc.section.3.4.1.p.3">The attacker could disable HSTS and pins.</p>
<h1 id="rfc.section.3.4.2">
<a href="#rfc.section.3.4.2">3.4.2.</a> <a href="#server-compromise" id="server-compromise">The host suffers full server-side compromise</a>
</h1>
<p id="rfc.section.3.4.2.p.1">After setting up a new host, operators should deploy the backup pin. Alternately, if the host is pinned to a root or intermediary signer, the operator should get a new leaf certificate signed by one of those signers.</p>
<p id="rfc.section.3.4.2.p.2">Operators SHOULD attempt to get the certificate containing the compromised private key revoked by whatever means available (extant revocation mechanisms like CRL or OCSP, blacklisting in the UA, or future revocation mechanisms).  </p>

<ul><li>We know that extant revocation mechanisms are unreliable. Do not depend on them.</li></ul>

<p> </p>
<h1 id="rfc.section.4">
<a href="#rfc.section.4">4.</a> <a href="#usability" id="usability">Usability Considerations</a>
</h1>
<p id="rfc.section.4.p.1">When pinning works to detect impostor Known Pinned HSTS Hosts, users will experience denial of service. UAs SHOULD explain the reason why. If it happens that true positives (actual attacks) outnumber false positives (hosts bricking themselves by accident), the feature will gain a positive reputation. Note that pinning has started life with a good reputation because it provoked the discovery of the DigiNotar CA compromise. (When DigiNotar signed a certificate for *.google.com in August 2011, Chrome users discovered the attack due to the pre-loaded pins for Google domains.)</p>
<p id="rfc.section.4.p.2">We believe that, in general, DoS is a better failure mode than user account/session compromise or other result of TLS compromise.</p>
<p id="rfc.section.4.p.3">UAs MUST have a way for users to clear current pins that were set by HSTS. UAs SHOULD have a way for users to query the current state of Known (Pinned) HSTS Hosts.</p>
<h1 id="rfc.section.5">
<a href="#rfc.section.5">5.</a> <a href="#economic" id="economic">Economic Considerations</a>
</h1>
<p id="rfc.section.5.p.1">If pinning becomes common, host operators might become incentivized to choose CAs that get compromised less often, or respond better to compromise. This will require information to flow into the market, and for people to interpret no news post-compromise as bad news. Pinning itself will provide some of that information, as will sources like UA vendor communications, the EFF SSL Observatory, the Qualys SSL survey, etc.</p>
<p id="rfc.section.5.p.2">The disaster recovery plans described above all incur new costs for host operators, and increase the size of the certificate market. Arguably, well-run hosts had already absorbed these costs because (e.g.) backup certificates from different CAs were necessary disaster recovery mechanisms even before certificate pinning. Small sites &#8212; which although small might still need to provide good security &#8212; may not be able to afford the disaster recovery mechanisms we recommend. (The cost of the backup certificate is not the issue; it is more the operational costs in safely storing the backup and testing that it works.) Thus, low-risk pinning may be available only to large sites; small sites may have to choose no pinning or potentially bricking their host (up to the maxAge window). This is not worse than the status quo.</p>
<h1 id="rfc.section.6">
<a href="#rfc.section.6">6.</a> <a href="#ideas" id="ideas">Ideas</a>
</h1>
<h1 id="rfc.section.6.1">
<a href="#rfc.section.6.1">6.1.</a> <a href="#requiring-backup" id="requiring-backup">Requiring Backup Pins</a>
</h1>
<p id="rfc.section.6.1.p.1">Because bricking risk mitigation requires a backup pin, UAs could require that the pins directive have at least two fingerprints, at least one of which does not match any of the public keys in any of the certificates in the chain. (This idea due to Tom Sepez.)</p>
<h1 id="rfc.section.6.2">
<a href="#rfc.section.6.2">6.2.</a> <a href="#prepopulating" id="prepopulating">Prepopulating Pin Lists</a>
</h1>
<p id="rfc.section.6.2.p.1">HSTS-based certificate pinning, unlike built-in pinning, suffers from the bootstrap problem. To work around this, we could pre-populate a built-in pin list with public keys as observed in the wild by one or more global observers, such as Googlebot, the EFF SSL Observatory, Convergence notaries, and so on.</p>
<p id="rfc.section.6.2.p.2">One problem with this approach is that it does not involve host operators. It is best to get operator consent before signing them up for a potentially risky new protocol such as this. Therefore we leave this idea for work (including third-party UA extensions).</p>
<h1 id="rfc.section.6.3">
<a href="#rfc.section.6.3">6.3.</a> <a href="#tooling" id="tooling">Tools to Assist Creation of Header</a>
</h1>
<p id="rfc.section.6.3.p.1">It would be good to provide tools that read X.509 certificate chains and generate example HSTS headers that operators can easily add to their webs erver configurations.</p>
<h1 id="rfc.section.6.4">
<a href="#rfc.section.6.4">6.4.</a> <a href="#pinning-subresources" id="pinning-subresources">Pinning Subresources</a>
</h1>
<p id="rfc.section.6.4.p.1">Many hosts have pages that load subresources from domains not under the control, or under only partial control, of the main host's operators.  For example, popular hosts often use CDNs, and CDN customers may have only limited, if any, ability to influence the configuration of the CDN's servers. (This long-standing problem is independent of certificate pinning.)</p>
<p id="rfc.section.6.4.p.2">To a limited extent, the includeSubDomains HSTS directive can address this: if the CDN host has a name that is a subdomain of the main host (e.g. assets-from-cdn.example.com points to CDN-owned servers), and if the main host's operators can guaranteeably keep up-to-date with the CDN's server certificate fingerprints &#8212; perhaps as part of example.com's contract with the CDN &#8212; then the problem may be solved.</p>
<p id="rfc.section.6.4.p.3">CDNs SHOULD also use certificate pinning independently of any of their customers.</p>
<p id="rfc.section.6.4.p.4">Although one can imagine an extension to this specification allowing the main resource to set pins for subresources in other domains, it is complex and fragile both from technical and business perspectives. The UA would have to accept those pins for the subresource domains ONLY when loading resources from the subdomains as part of a page load of the main host. The independence of the two domains' operations teams would still pose synchronization problems, and potentially increase the bricking risk.</p>
<p id="rfc.section.6.4.p.5">Therefore, except in simple cases, this document leaves the cross-domain subresource problem to future work. Operational experience with HSTS-based certificate pinning should guide the development of a plan to handle the problem.</p>
<h1 id="rfc.section.6.5">
<a href="#rfc.section.6.5">6.5.</a> <a href="#pinning-without-https" id="pinning-without-https">Pinning Without Requiring HTTPS</a>
</h1>
<p id="rfc.section.6.5.p.1">Some host operators would like to take advantage of certificate pinning without requiring HTTPS, but having clients require pins in the event that they do connect to the host with HTTPS. As specified above, the current HSTS-based mechanism does not allow for this: clients that receive the pins directive via HSTS will also therefore require HTTPS &#8212; that is the purpose of HSTS after all. To have an additional directive, e.g. mode=optional, would not work because older clients that support HSTS but not the mode extension would effectively require HTTPS.</p>
<p id="rfc.section.6.5.p.2">Alternatives include (a) putting the pins directive in a new header instead of extending HSTS; and (b) some kind of hack like setting maxAge=0 and having an additional directive to keep the pins alive (e.g.  pinMaxAge). These alternatives seem ugly to us and we welcome suggestions for a better way to support this deployment scenario.</p>
<h1 id="rfc.section.7">
<a href="#rfc.section.7">7.</a> <a href="#acknowledgements" id="acknowledgements">Acknowledgements</a>
</h1>
<p id="rfc.section.7.p.1">Thanks to Jeff Hodges, Adam Langley, Nicolas Lidzborski, SM, and Yoav Nir for suggestions and edits that clarified the text. Trevor Perrin for providing the pin break codes mechanism. Adam Langley provided the SPKI fingerprint generation code.</p>
<h1 id="rfc.section.8">
<a href="#rfc.section.8">8.</a> <a href="#what-changed" id="what-changed">What's Changed</a>
</h1>
<p id="rfc.section.8.p.1">This is the first draft of this proposal submitted as an official Internet Draft.</p>
<h1 id="rfc.references">
<a href="#rfc.references">9.</a> References</h1>
<table><tbody>
<tr>
<td class="reference"><b id="hsts-spec">[hsts-spec]</b></td>
<td class="top">
<a title="PayPal, Inc.">Hodges, J.</a>, <a title="Carnegie Mellon University">Jackson, C.</a> and <a title="Google, Inc.">A. Barth</a>, "<a>HTTP Strict Transport Security (HSTS)</a>", August 2011.</td>
</tr>
<tr>
<td class="reference"><b id="why-fingerprint-key">[why-fingerprint-key]</b></td>
<td class="top">
<a>Langley, A.</a>, "<a>Public Key Pinning</a>", May 2011.</td>
</tr>
<tr>
<td class="reference"><b id="pin-break-codes">[pin-break-codes]</b></td>
<td class="top">
<a>Perrin, T.</a>, "<a>Self-Asserted Key Pinning</a>", September 2011.</td>
</tr>
<tr>
<td class="reference"><b id="rfc-2119">[rfc-2119]</b></td>
<td class="top">
<a>Bradner, S.</a>, "<a>Key words for use in RFCs to Indicate Requirement Levels</a>", March 1997.</td>
</tr>
</tbody></table>
<h1 id="rfc.appendix.Appendix A">
<a href="#rfc.appendix.Appendix%20A">Appendix A.</a> <a href="#fingerprint-generation" id="fingerprint-generation">Fingerprint Generation</a>
</h1>
<p id="rfc.section.Appendix A.p.1">This Go program generates public key fingerprints, suitable for use in pinning, from PEM-encoded certificates.</p>
<div id="#rfc.figure.6"></div>
<div id="#fingerprint-generation-figure"></div>
<pre>
package main

import (
       "io/ioutil"
       "os"
       "crypto/sha1"
       "crypto/x509"
       "encoding/base64"
       "encoding/pem"
       "fmt"
)

func main() {
       if len(os.Args) &lt; 2 {
               fmt.Printf("Usage: %s PEM-filename\n", os.Args[0])
               os.Exit(1)
       }
       pemBytes, err := ioutil.ReadFile(os.Args[1])
       if err != nil {
               panic(err.String())
       }
       block, _ := pem.Decode(pemBytes)
       if block == nil {
               panic("No PEM structure found")
       }
       derBytes := block.Bytes
       certs, err := x509.ParseCertificates(derBytes)
       if err != nil {
               panic(err.String())
       }
       cert := certs[0]
       h := sha1.New()
       h.Write(cert.RawSubjectPublicKeyInfo)
       digest := h.Sum()

       fmt.Printf("Hex: %x\nBase64: %s\n", digest,
               base64.StdEncoding.EncodeToString(digest))
}
</pre>
<h1 id="rfc.authors"><a href="#rfc.authors">Authors' Addresses</a></h1>
<div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Chris Evans</span> 
	  <span class="n hidden">
		<span class="family-name">Evans</span>
	  </span>
	</span>
	<span class="org vcardline">Google, Inc.</span>
	<span class="adr">
	  <span>1600 Amphitheater Pkwy</span>

	  <span class="vcardline">
		<span class="locality">Mountain View</span>,  
		<span class="region">CA</span> 
		<span class="code">94043</span>
	  </span>
	  <span class="country-name vcardline">US</span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:cevans@google.com">cevans@google.com</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Chris Palmer</span> 
	  <span class="n hidden">
		<span class="family-name">Palmer</span>
	  </span>
	</span>
	<span class="org vcardline">Google, Inc.</span>
	<span class="adr">
	  <span>1600 Amphitheater Pkwy</span>

	  <span class="vcardline">
		<span class="locality">Mountain View</span>,  
		<span class="region">CA</span> 
		<span class="code">94043</span>
	  </span>
	  <span class="country-name vcardline">US</span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:palmer@google.com">palmer@google.com</a></span>

  </address>
</div>
  
  <hr class="noprint" />
  <h1 class="np" id="rfc.toc"><a href="#rfc.toc">Table of Contents</a></h1>
  <ul class="toc">

  	<li>1.   <a href="#rfc.section.1">Introduction</a>
</li>
<li>1.1.   <a href="#rfc.section.1.1">About Notation</a>
</li>
<li>2.   <a href="#rfc.section.2">Server and Client Behavior</a>
</li>
<li>2.1.   <a href="#rfc.section.2.1">Noting and Validating Pins</a>
</li>
<li>2.2.   <a href="#rfc.section.2.2">Interactions With Built-in HSTS Lists</a>
</li>
<li>2.3.   <a href="#rfc.section.2.3">Un-pinning</a>
</li>
<li>2.4.   <a href="#rfc.section.2.4">Pinning Self-Signed Leaf Certificates</a>
</li>
<li>3.   <a href="#rfc.section.3">Security Considerations</a>
</li>
<li>3.1.   <a href="#rfc.section.3.1">Deployment Guidance</a>
</li>
<li>3.2.   <a href="#rfc.section.3.2">Disasters Relating to Compromises of Certificates</a>
</li>
<li>3.2.1.   <a href="#rfc.section.3.2.1">The private key for the pinned leaf is stolen</a>
</li>
<li>3.2.2.   <a href="#rfc.section.3.2.2">The root or intermediary CA is compromised</a>
</li>
<li>3.3.   <a href="#rfc.section.3.3">Disasters Relating to Certificate Mismanagement</a>
</li>
<li>3.3.1.   <a href="#rfc.section.3.3.1">The leaf certificate expires</a>
</li>
<li>3.3.2.   <a href="#rfc.section.3.3.2">The leaf certificate is lost</a>
</li>
<li>3.3.3.   <a href="#rfc.section.3.3.3">The CA is extorting the operator approaching renewal/expiry time</a>
</li>
<li>3.4.   <a href="#rfc.section.3.4">Disasters Relating to Vulnerabilities in the Known HSTS Host</a>
</li>
<li>3.4.1.   <a href="#rfc.section.3.4.1">The host is vulnerable to HTTP header injection</a>
</li>
<li>3.4.2.   <a href="#rfc.section.3.4.2">The host suffers full server-side compromise</a>
</li>
<li>4.   <a href="#rfc.section.4">Usability Considerations</a>
</li>
<li>5.   <a href="#rfc.section.5">Economic Considerations</a>
</li>
<li>6.   <a href="#rfc.section.6">Ideas</a>
</li>
<li>6.1.   <a href="#rfc.section.6.1">Requiring Backup Pins</a>
</li>
<li>6.2.   <a href="#rfc.section.6.2">Prepopulating Pin Lists</a>
</li>
<li>6.3.   <a href="#rfc.section.6.3">Tools to Assist Creation of Header</a>
</li>
<li>6.4.   <a href="#rfc.section.6.4">Pinning Subresources</a>
</li>
<li>6.5.   <a href="#rfc.section.6.5">Pinning Without Requiring HTTPS</a>
</li>
<li>7.   <a href="#rfc.section.7">Acknowledgements</a>
</li>
<li>8.   <a href="#rfc.section.8">What's Changed</a>
</li>
<li>9.   <a href="#rfc.references">References</a>
</li>
<li>Appendix A.   <a href="#rfc.appendix.Appendix%20A">Fingerprint Generation</a>
</li>
<li><a href="#rfc.authors">Authors' Addresses</a>
</li>


  </ul>

  

</body>
</html>