AGING = pow(2, (LG_AGING-30) );       // Convert lg([B/s]) to [B/ns]
CRITICALqL = CRITICALqL_us * 1000             // Convert [us] to [ns]
CRITICALqLSCORE = CRITICALqLSCORE_us * 1000   // Convert [us] to [ns]
CRITICALqLPRODUCT = CRITICALqL * CRITICALqLSCORE

ATTEMPTS = 2; // Max attempts to pick a bucket (vendor-specific)
BI_SIZE = 5;  // Bit-width of index number for non-default buckets
NBUCKETS = pow(2, BI_SIZE);  // No. of non-default buckets
MASK = NBUCKETS-1;           // convenient constant, filled with ones

                          // Queue Protection exit states
EXIT_SUCCESS  = 0;     // Forward the packet
EXIT_SANCTION = 1;     // Redirect the packet

MAX_PROB      = 1; // For integer arithmetic, would use a large int
                      //  e.g., 2^31, to allow space for overflow
MAXTH = MAXTH_us * 1000;   // Max marking threshold [ns]
FLOOR =  2 * 8 * MAX FRAME SIZE * 10^9 / MAX RATE;
RANGE = (1 << LG_RANGE);      // Range of ramp [ns]
MINTH = max ( MAXTH - RANGE, FLOOR);
MAXTH = MINTH + RANGE;           // Max marking threshold [ns]


qdelay = qL.qdelay(...);
probNative = calcProbNative(qdelay);

bckt_id = pick_bucket(packet.uflow);
qLscore = fill_bucket(buckets[bckt_id], packet.size, probNative);

h32   = hash32(uflw);     // 32-bit hash of flow ID
hsav  = NBUCKETS;         // Default bucket
now   = get_time_now();

h = h32 & MASK;
hsav = h;                  // set it as the interim bucket
probNative = MAX_PROB;
probNative = MAX_PROB * (qdelay - MINTH)/RANGE;
probNative = 0;
