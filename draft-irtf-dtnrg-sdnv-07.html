<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="en"><head><title>Using Self-Delimiting Numeric Values in Protocols</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="description" content="Using Self-Delimiting Numeric Values in Protocols">
<meta name="keywords" content="SDNV, DTN">
<meta name="generator" content="xml2rfc v1.35 (http://xml.resource.org/)">
<meta name="viewport" content="width=600;" />
<style type='text/css'><!--
        body {
                font-family: verdana, charcoal, helvetica, arial, sans-serif;
                font-size: 85%;
		max-width: 60em; 
		color: #000; background-color: #FFF;
                margin: 2em;
        }
        h1, h2, h3, h4, h5, h6 {
                font-family: helvetica, monaco, "MS Sans Serif", arial, sans-serif;
                font-weight: bold; font-style: normal;
        }
        h1 { color: #900; background-color: transparent; text-align: right; }
        h3 { color: #333; background-color: transparent; }

        td.RFCbug {
                font-size: x-small; text-decoration: none;
                width: 30px; height: 30px; padding-top: 2px;
                text-align: justify; vertical-align: middle;
                background-color: #000;
        }
        td.RFCbug span.RFC {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: bold; color: #666;
        }
        td.RFCbug span.hotText {
                font-family: charcoal, monaco, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: normal; text-align: center; color: #FFF;
        }

        table.TOCbug { width: 30px; height: 15px; }
        td.TOCbug {
                text-align: center; width: 30px; height: 15px;
                color: #FFF; background-color: #900;
        }
        td.TOCbug a {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, sans-serif;
                font-weight: bold; font-size: x-small; text-decoration: none;
                color: #FFF; background-color: transparent;
        }

        td.header {
                font-family: arial, helvetica, sans-serif; font-size: x-small;
                vertical-align: top; width: 33%;
                color: #FFF; background-color: #666;
        }
        td.author { font-weight: bold; font-size: x-small; margin-left: 4em; }
        td.author-text { font-size: x-small; }

        /* info code from SantaKlauss at http://www.madaboutstyle.com/tooltip2.html */
        a.info {
                /* This is the key. */
                position: relative;
                z-index: 24;
                text-decoration: none;
        }
        a.info:hover {
                z-index: 25;
                color: #FFF; background-color: #900;
        }
        a.info span { display: none; }
        a.info:hover span.info {
                /* The span will display just on :hover state. */
                display: block;
                position: absolute;
                font-size: smaller;
                top: 2em; left: -5em; width: 15em;
                padding: 2px; border: 1px solid #333;
                color: #900; background-color: #EEE;
                text-align: left;
        }

        a { font-weight: bold; }
        a:link    { color: #900; background-color: transparent; }
        a:visited { color: #633; background-color: transparent; }
        a:active  { color: #633; background-color: transparent; }

        p { margin-left: 2em; margin-right: 2em; }
        p.copyright { font-size: x-small; }
        p.toc { font-size: 85%;
		max-width: 60em; 
		font-weight: bold; margin-left: 3em; }
        table.toc { margin: 0 0 0 3em; padding: 0; border: 0; vertical-align: text-top; }
        td.toc { font-size: 85%;
		max-width: 60em; 
		font-weight: bold; vertical-align: text-top; }

        ol.text { margin-left: 2em; margin-right: 2em; }
        ul.text { margin-left: 2em; margin-right: 2em; }
        li      { margin-left: 3em; }

        /* RFC-2629 <spanx>s and <artwork>s. */
        em     { font-style: italic; }
        strong { font-weight: bold; }
        dfn    { font-weight: bold; font-style: normal; }
        cite   { font-weight: normal; font-style: normal; }
        tt     { color: #036; }
        tt, pre, pre dfn, pre em, pre cite, pre span {
                font-family: "Courier New", Courier, monospace; font-size: small;
        }
        pre {
                text-align: left; padding: 4px;
                color: #000; background-color: #CCC;
        }
        pre dfn  { color: #900; }
        pre em   { color: #66F; background-color: #FFC; font-weight: normal; }
        pre .key { color: #33C; font-weight: bold; }
        pre .id  { color: #900; }
        pre .str { color: #000; background-color: #CFF; }
        pre .val { color: #066; }
        pre .rep { color: #909; }
        pre .oth { color: #000; background-color: #FCF; }
        pre .err { background-color: #FCC; }

        /* RFC-2629 <texttable>s. */
        table.all, table.full, table.headers, table.none {
                font-size: 85%;
		max-width: 60em; 
		text-align: center; border-width: 2px;
                vertical-align: top; border-collapse: collapse;
        }
        table.all, table.full { border-style: solid; border-color: black; }
        table.headers, table.none { border-style: none; }
        th {
                font-weight: bold; border-color: black;
                border-width: 2px 2px 3px 2px;
        }
        table.all th, table.full th { border-style: solid; }
        table.headers th { border-style: none none solid none; }
        table.none th { border-style: none; }
        table.all td {
                border-style: solid; border-color: #333;
                border-width: 1px 2px;
        }
        table.full td, table.headers td, table.none td { border-style: none; }

        hr { height: 1px; }
        hr.insert {
                width: 80%; border-style: none; border-width: 0;
                color: #CCC; background-color: #CCC;
        }
--></style>
</head>
<body>
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<table summary="layout" width="66%" border="0" cellpadding="0" cellspacing="0"><tr><td><table summary="layout" width="100%" border="0" cellpadding="2" cellspacing="1">
<tr><td class="header">Network Working Group</td><td class="header">W. Eddy</td></tr>
<tr><td class="header">Internet-Draft</td><td class="header">MTI Systems</td></tr>
<tr><td class="header">Intended status: Informational</td><td class="header">E. Davies</td></tr>
<tr><td class="header">Expires: April 14, 2011</td><td class="header">Folly Consulting</td></tr>
<tr><td class="header">&nbsp;</td><td class="header">October 11, 2010</td></tr>
</table></td></tr></table>
<h1><br />Using Self-Delimiting Numeric Values in Protocols<br />draft-irtf-dtnrg-sdnv-07</h1>

<h3>Abstract</h3>

<p>

Self-Delimiting Numeric Values (SDNVs) have recently been introduced as a field
type in proposed Delay-Tolerant Networking protocols. SDNVs encode an
arbitrary-length non-negative integer or arbitrary-length bit-string with
minimum overhead. They are intended to provide protocol flexibility without
sacrificing economy, and to assist in future-proofing protocols under
development. This document describes formats and algorithms for SDNV encoding
and decoding, along with notes on implementation and usage.  This document is a
product of the Delay Tolerant Networking Research Group and has been reviewed
by that group.  No objections to its publication as an RFC were raised.


</p>
<h3>Status of this Memo</h3>
<p>
This Internet-Draft is submitted  in full
conformance with the provisions of BCP&nbsp;78 and BCP&nbsp;79.</p>
<p>
Internet-Drafts are working documents of the Internet Engineering
Task Force (IETF).  Note that other groups may also distribute
working documents as Internet-Drafts.  The list of current
Internet-Drafts is at http://datatracker.ietf.org/drafts/current/.</p>
<p>
Internet-Drafts are draft documents valid for a maximum of six months
and may be updated, replaced, or obsoleted by other documents at any time.
It is inappropriate to use Internet-Drafts as reference material or to cite
them other than as &ldquo;work in progress.&rdquo;</p>
<p>
This Internet-Draft will expire on April 14, 2011.</p>

<h3>Copyright Notice</h3>
<p>
Copyright (c) 2010 IETF Trust and the persons identified as the
document authors.  All rights reserved.</p>
<p>
This document is subject to BCP 78 and the IETF Trust's Legal
Provisions Relating to IETF Documents
(http://trustee.ietf.org/license-info) in effect on the date of
publication of this document.  Please review these documents
carefully, as they describe your rights and restrictions with respect
to this document. Code Components extracted from this document must
include Simplified BSD License text as described in Section 4.e of
the Trust Legal Provisions and are provided without warranty as
described in the Simplified BSD License.</p>
<a name="toc"></a><br /><hr />
<h3>Table of Contents</h3>
<p class="toc">
<a href="#intro">1.</a>&nbsp;
Introduction<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor1">1.1.</a>&nbsp;
Problems with Fixed Value Fields<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor2">1.2.</a>&nbsp;
SDNVs for DTN Protocols<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor3">1.3.</a>&nbsp;
SDNV Usage<br />
<a href="#definition">2.</a>&nbsp;
Definition of SDNVs<br />
<a href="#basic">3.</a>&nbsp;
Basic Algorithms<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#enc">3.1.</a>&nbsp;
Encoding Algorithm<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#dec">3.2.</a>&nbsp;
Decoding Algorithm<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#limitations">3.3.</a>&nbsp;
Limitations of Implementations<br />
<a href="#comp">4.</a>&nbsp;
Comparison to Alternatives<br />
<a href="#anchor4">5.</a>&nbsp;
Security Considerations<br />
<a href="#anchor5">6.</a>&nbsp;
IANA Considerations<br />
<a href="#anchor6">7.</a>&nbsp;
Acknowledgements<br />
<a href="#rfc.references1">8.</a>&nbsp;
Informative References<br />
<a href="#append">Appendix&nbsp;A.</a>&nbsp;
SNDV Python Source Code<br />
<a href="#rfc.authors">&#167;</a>&nbsp;
Authors' Addresses<br />
</p>
<br clear="all" />

<a name="intro"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1"></a><h3>1.&nbsp;
Introduction</h3>

<p>

	This document is a product of the Internet Research Task Force (IRTF)
	Delay-Tolerant Networking (DTN) Research Group (DTNRG).  The document
	has received review and support within the DTNRG, as discussed in the
	Acknowledgements section of this document.


</p>
<p>

This document begins by describing the drawbacks of using fixed-width protocol fields.
It then provides some background on the Self-Delimiting
Numeric Values (SDNVs) proposed for use in DTN protocols, and motivates their
potential applicability in other networking protocols.
One example of SDNVs being used outside of the DTN protocols is in Hixie's Web
Socket protocol <a class='info' href='#I-D.hixie-thewebsocketprotocol'>[I&#8209;D.hixie&#8209;thewebsocketprotocol]<span> (</span><span class='info'>Hickson, I., &ldquo;The WebSocket protocol,&rdquo; May&nbsp;2010.</span><span>)</span></a>, which includes a
binary frame length indicator field identical to an SDNV.  The DTNRG
has created SDNVs to meet the challenges it attempts to solve, and it has been
noted that SDNVs closely resemble certain constructs within ASN.1 and even
older ITU protocols, so the problems are not new or unique to DTN.  SDNVs focus
strictly on numeric values or bitstrings, while other mechanisms have been
developed for encoding more complex data structures, such as ASN.1 encoding
rules, and Haverty's MSDTP <a class='info' href='#RFC0713'>[RFC0713]<span> (</span><span class='info'>Haverty, J., &ldquo;MSDTP-Message Services Data Transmission Protocol,&rdquo; April&nbsp;1976.</span><span>)</span></a>.  Because of this focus,
SDNVs are can be quickly implemented with only a small amount of code.



</p>
<p>

	SDNVs are tersely defined in both the bundle protocol <a class='info' href='#RFC5050'>[RFC5050]<span> (</span><span class='info'>Scott, K. and S. Burleigh, &ldquo;Bundle Protocol Specification,&rdquo; November&nbsp;2007.</span><span>)</span></a> and LTP <a class='info' href='#RFC5326'>[RFC5326]<span> (</span><span class='info'>Ramadas, M., Burleigh, S., and S. Farrell, &ldquo;Licklider Transmission Protocol - Specification,&rdquo; September&nbsp;2008.</span><span>)</span></a> specifications,
	due to the flow of document production in the DTNRG.  This document
	clarifies and further explains the motivations and engineering
	decisions behind SDNVs.


</p>
<a name="anchor1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1.1"></a><h3>1.1.&nbsp;
Problems with Fixed Value Fields</h3>

<p>

Protocol designers commonly face an optimization problem in determining the
proper size for header fields.  There is a strong desire to keep fields as
small as possible, in order to reduce the protocol's overhead, and
also allow for fast processing.  Since protocols can be used many years (even
decades) after they are designed, and networking technology has tended to
change rapidly, it is not uncommon for the use, deployment, or performance of a
particular protocol to be limited or infringed upon by the length of some
header field being too short.  Two well-known examples of this phenomenon are
the TCP advertised receive window, and the IPv4 address length.


</p>
<p>

TCP segments contain an advertised receive window field that is fixed at 16
bits <a class='info' href='#RFC0793'>[RFC0793]<span> (</span><span class='info'>Postel, J., &ldquo;Transmission Control Protocol,&rdquo; September&nbsp;1981.</span><span>)</span></a>, encoding a maximum value of around 65 kilobytes.
The purpose of this value is to provide flow control, by allowing a receiver to
specify how many sent bytes its peer can have outstanding (unacknowledged) at
any time, thus allowing the receiver to limit its buffer size.  As network
speeds have grown by several orders of magnitude since TCP's inception, the
combination of the 65 kilobyte maximum advertised window and long round-trip
times prevented TCP senders from being able to achieve the high throughput that the
underlying network supported.  This limitation was remedied through the use of
the Window Scale option <a class='info' href='#RFC1323'>[RFC1323]<span> (</span><span class='info'>Jacobson, V., Braden, B., and D. Borman, &ldquo;TCP Extensions for High Performance,&rdquo; May&nbsp;1992.</span><span>)</span></a>, which provides a multiplier
for the advertised window field.  However, the Window Scale multiplier is fixed
for the duration of the connection, requires support from each end of a TCP connection, and limits
the precision of the advertised receive window, so this is certainly a
less-than-ideal solution.  Because of the field width limit in the original
design however, the Window Scale is necessary for TCP to reach high sending
rates.


</p>
<p>

An IPv4 address is fixed at 32 bits <a class='info' href='#RFC0791'>[RFC0791]<span> (</span><span class='info'>Postel, J., &ldquo;Internet Protocol,&rdquo; September&nbsp;1981.</span><span>)</span></a> (as a historical
note, an early version 0 IP header format specification in <a class='info' href='#IEN21'>[IEN21]<span> (</span><span class='info'>Cerf, V. and J. Postel, &ldquo;Specification of Internetwork Transmission Control Program: TCP Version 3,&rdquo; January&nbsp;1978.</span><span>)</span></a> used
variable-length addresses in multiples of 8-bits up to 120-bits).  Due to the
way that subnetting and assignment of address blocks was performed, the number
of IPv4 addresses has been seen as a limit to the growth of the Internet <a class='info' href='#Hain05'>[Hain05]<span> (</span><span class='info'>Hain, T., &ldquo;A Pragmatic Report on IPv4 Address Space Consumption,&rdquo; September&nbsp;2005.</span><span>)</span></a>.  Two divergent paths to solve this problem have been the
use of Network Address Translators (NATs) and the development of IPv6.  NATs
have caused a number of other issues and problems <a class='info' href='#RFC2993'>[RFC2993]<span> (</span><span class='info'>Hain, T., &ldquo;Architectural Implications of NAT,&rdquo; November&nbsp;2000.</span><span>)</span></a>,
leading to increased complexity and fragility, as well as forcing work-arounds
to be engineered for many other protocols to function within a NATed
environment.  The IPv6 solution's transitional work has been underway for
several years, but has still only just begun to have visible impact on the
global Internet.


</p>
<p>

Of course, in both the case of the TCP receive window and IPv4 address length,
the field size chosen by the designers seemed like a good idea at the time.
The fields were more than big enough for the originally perceived usage of the
protocols, and yet were small enough to allow the headers to remain
compact and relatively easy and efficient to parse on machines of the time.
The fixed sizes that were defined represented a tradeoff between the
scalability of the protocol versus the overhead and efficiency of processing.
In both cases, these engineering decisions turned out to be painfully
restrictive in the longer term.


</p>
<a name="anchor2"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1.2"></a><h3>1.2.&nbsp;
SDNVs for DTN Protocols</h3>

<p>

In specifications for the DTN Bundle Protocol (BP) <a class='info' href='#RFC5050'>[RFC5050]<span> (</span><span class='info'>Scott, K. and S. Burleigh, &ldquo;Bundle Protocol Specification,&rdquo; November&nbsp;2007.</span><span>)</span></a> and
Licklider Transmission Protocol (LTP) <a class='info' href='#RFC5326'>[RFC5326]<span> (</span><span class='info'>Ramadas, M., Burleigh, S., and S. Farrell, &ldquo;Licklider Transmission Protocol - Specification,&rdquo; September&nbsp;2008.</span><span>)</span></a>, SDNVs have
been used for several fields including identifiers, payload/header lengths, and
serial (sequence) numbers.  SDNVs were developed for use in these types of
fields, to avoid sending more bytes than needed, as well as avoiding fixed
sizes that may not end up being appropriate.  For example, since LTP is
intended primarily for use in long-delay interplanetary communications <a class='info' href='#RFC5325'>[RFC5325]<span> (</span><span class='info'>Burleigh, S., Ramadas, M., and S. Farrell, &ldquo;Licklider Transmission Protocol - Motivation,&rdquo; September&nbsp;2008.</span><span>)</span></a>, where links may be fairly low in capacity, it is
desirable to avoid the header overhead of routinely sending a 64-bit field
where a 16-bit field would suffice.  Since many of the nodes implementing LTP
are expected to be beyond the current range of human spaceflight, upgrading
their on-board LTP implementations to use longer values if the defined fields
are found to be too short would also be problematic.  Furthermore, extensions
similar in mechanism to TCP's Window Scale option are unsuitable for use in DTN
protocols since, due to high delays, DTN protocols must avoid handshaking and
configuration parameter negotiation to the greatest extent possible.  All of
these reasons make the choice of SDNVs for use in DTN protocols attractive.


</p>
<a name="anchor3"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1.3"></a><h3>1.3.&nbsp;
SDNV Usage</h3>

<p>

In short, an SDNV is simply a way of representing non-negative integers
(both positive integers of arbitrary magnitude and 0), without expending
much unnecessary space.  This definition allows SDNVs to represent many
common protocol header fields, such as:


</p>
<p>

</p>
<ul class="text">
<li>

Random identification fields as used in the IPsec Security Parameters Index or
in IP headers for fragment reassembly (Note: the 16-bit IP ID field for
fragment reassembly was recently found to be too short in some environments
<a class='info' href='#RFC4963'>[RFC4963]<span> (</span><span class='info'>Heffner, J., Mathis, M., and B. Chandler, &ldquo;IPv4 Reassembly Errors at High Data Rates,&rdquo; July&nbsp;2007.</span><span>)</span></a>), 


</li>
<li>

Sequence numbers as in TCP or SCTP,


</li>
<li>

Values used in cryptographic algorithms such as RSA keys, Diffie-Hellman key-agreement, or coordinates of points on elliptic curves.


</li>
<li>

Message lengths as used in file transfer protocols.


</li>
<li>

Nonces and cookies.


</li>
<li>

Etc.


</li>
</ul><p>

</p>
<p>

As any bit-field can be interpreted as an unsigned integer, SDNVs can also
encode arbitrary-length bit-fields, including bit-fields representing signed
integers or other data types; however, this document assumes SDNV encoding and
decoding in terms of unsigned integers.  Implementations may differ in the
interface that they provide to SDNV encoding and decoding functions, in terms
of whether the values are numeric, bit-fields, etc.; this detail does not
alter the representation or algorithms described in this document.


</p>
<p>

The use of SDNVs rather than fixed length fields gives protocol designers the
ability to ameliorate the consequences of making difficult-to-reverse field-sizing
decisions, as the SDNV format grows and shrinks depending on the
particular value encoded.  SDNVs do not necessarily provide optimal encodings
for values of any particular length, however they allow protocol designers to
avoid potential blunders in assigning fixed lengths, and remove the complexity
involved with either negotiating field lengths or constructing protocol
extensions.


</p>
<p>

To our knowledge, at this time, no IETF transport or network-layer protocol designed for use outside of the
DTN domain has proposed to use SDNVs; however there is no inherent reason not
to use SDNVs more broadly in the future.  The two examples cited here, of fields
that have proven too small in general Internet protocols, are only a small
sampling of the much larger set of similar instances that the authors can think
of.  Outside the Internet protocols, within ASN.1 and previous ITU protocols, constructs very similar to SDNVs have been used for many years due to engineering concerns very similar to those facing the DTNRG.


</p>
<p>

Many protocols use a Type-Length-Value method for encoding variable length
fields (e.g. TCP's options format, or many of the fields in IKEv2).  An SDNV
is equivalent to combining the length and value portions of this type of field,
with the overhead of the length portion amortized out over the bytes of the
value.  The penalty paid for this in an SDNV may be several extra bytes for
long values (e.g. 1024 bit RSA keys).  See <a class='info' href='#comp'>Section&nbsp;4<span> (</span><span class='info'>Comparison to Alternatives</span><span>)</span></a> for further
discussion and a comparison.


</p>
<p>

As is shown in later sections, for large values, the current SDNV scheme is
fairly inefficient in terms of space (1/8 of the bits are overhead) and not
particularly easy to encode/decode in comparison to alternatives.  The best use
of SDNVs may often be to define the Length field of a TLV structure to be an
SDNV whose value is the length of the TLV's Value field.  In this way, one can
avoid forcing large numbers from being directly encoded as an SDNV, yet retain
the extensibility that using SDNVs grants.


</p>
<a name="definition"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2"></a><h3>2.&nbsp;
Definition of SDNVs</h3>

<p>

Early in the work of the DTNRG, it was agreed that the properties of an
SDNV were useful for DTN protocols.  The exact SDNV format used by the
DTNRG evolved somewhat over time before the publication of the initial
RFCs on LTP and the BP.  An ealier version bore resemblance to the ASN.1
<a class='info' href='#ASN1'>[ASN1]<span> (</span><span class='info'>ITU-T Rec. X.680, &ldquo;Abstract Syntax Notation One (ASN.1). Specification of Basic Notation,&rdquo; 2002.</span><span>)</span></a> Basic Encoding Rules (BER) <a class='info' href='#ASN1-BER'>[ASN1&#8209;BER]<span> (</span><span class='info'>ITU-T Rec. X.690, &ldquo;Abstract Syntax Notation One (ASN.1). Encoding Rules: Specification of Basic Encoding Rules (BER), Canonical Encoding Rules (CER) and Distinguished Encoding Rules (DER),&rdquo; 2002.</span><span>)</span></a> for
lengths (Section 8.1.3 of X.690).  The current SDNV format is the one used by
ASN.1 BER for encoding tag identifiers greater than or equal to 31 (Section
8.1.2.4.2 of X.690).  A comparison between the current SDNV format and the
early SDNV format is made in <a class='info' href='#comp'>Section&nbsp;4<span> (</span><span class='info'>Comparison to Alternatives</span><span>)</span></a>.


</p>
<p>
	

</p>
<p>

The format currently used is very simple.  Before encoding, an integer is
represented as a left-to-right bitstring beginning with its most significant
bit, and ending with its least signifcant bit.  If the bitstring's length is not a multiple of 7, then the string is left-padded with zeros.  When transmitted, the bits are
encoded into a series of bytes.  The low-order 7 bits of each byte in the
encoded format are taken left-to-right from the integer's bitstring
representation.  The most significant bit of each 
byte specifies whether it is the final byte of the encoded value (when it holds
a 0), or not (when it holds a 1).  


</p>
<p>For example:
</p>
<p>
</p>
<ul class="text">
<li>1 (decimal) is represented by the bitstring "0000001" and encoded as the
single byte 0x01 (in hexadecimal)
</li>
<li>128 is represented by the bitstring "10000001 00000000" and encoded as the
bytes 0x81 followed by 0x00.
</li>
<li>Other values can be found in the test vectors of the source code in <a class='info' href='#append'>Appendix&nbsp;A<span> (</span><span class='info'>SNDV Python Source Code</span><span>)</span></a>
</li>
</ul><p>

</p>
<p>

To be perfectly clear, and avoid potential interoperability issues (as have
occurred with ASN.1 BER time values), we explicitly state two considerations
regarding zero-padding.  (1) When encoding SDNVs, any leading (most
significant) zero bits in the input number might be discarded by the SDNV
encoder.  Protocols that use SDNVs should not rely on leading-zeros being
retained after encoding and decoding operations.  (2) When decoding SDNVs, the
relevant number of leading zeros required to pad up to a machine word or other
natural data unit might be added.  These are put in the most-significant
positions in order to not change the value of the number.  Protocols using
SDNVs should consider situations where lost zero-padding may be problematic.


</p>
<p>

The issues of zero-padding are particularly relevant where
an SDNV is being used to represent a bit field to be transmitted by a protocol. 
The specification of the protocol and any associated IANA registry should 
specify the allocation and usage of bit positions within the unencoded field.
Both sender and receiver will know of this allocation so that they are
implicitly aware of the width of the bit field.
Unassigned and reserved bits in the unencoded field will be treated as zeroes 
by the SDNV encoding prior to transmission.  Assuming the bit positions are 
numbered starting from 0 at the least significant bit position in the integer 
representation, then if higher numbered positions in the field contain all zeroes,
the encoding process may not transmit these bits explicitly 
(e.g., if all the bit positions numbered 7 or higher are zeroes then the
transmitted SDNV can consist of just one octet).  On reception the decoding
process will treat any untransmitted higher numbered bits as zeroes.


</p>
<a name="basic"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3"></a><h3>3.&nbsp;
Basic Algorithms</h3>

<p>

This section describes some simple algorithms for creating and parsing SDNV
fields.  These may not be the most efficient algorithms possible, however,
they are easy to read, understand, and implement.  <a class='info' href='#append'>Appendix&nbsp;A<span> (</span><span class='info'>SNDV Python Source Code</span><span>)</span></a>
contains Python source code implementing the routines described here.


</p>
<a name="enc"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.1"></a><h3>3.1.&nbsp;
Encoding Algorithm</h3>

<p>

There is a very simple algorithm for the encoding operation that converts a
non-negative integer (value n, of length 1+floor(log n) bits) into an SDNV.  This
algorithm takes n as its only argument and returns a string of bytes:


</p>
<p>
</p>
<ul class="text">
<li>

(Initial Step) Set a variable X to a byte sharing the least significant 7
bits of n, and with 0 in the most significant bit, and a variable Y to n, right-shifted by 7 bits.


</li>
<li>

(Recursion Step) If Y == 0, return X.  Otherwise, set Z to the
bitwise-or of 0x80 with the 7 least significant bits of Y, and append Z to X.  Right-shift Y by 7 bits and repeat the Recursion Step.


</li>
</ul><p>

</p>
<p>

This encoding algorithm has time complexity of O(log n),
since it takes a number of steps equal to ceil(n/7), and no additional
space beyond the size of the result (8/7 log n) is required.  One aspect of
this algorithm is that it assumes strings can be efficiently appended to new
bytes.  One way to implement this is to allocate a buffer for the expected
length of the result and fill that buffer one byte at a time from the right
end.


</p>
<p>

If, for some reason, an implementation requires an encoded SDNV to be some
specific length (possibly related to a machine word), any leftmost zero-padding
included needs to properly set the high-order bit in each byte of padding.


</p>
<a name="dec"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.2"></a><h3>3.2.&nbsp;
Decoding Algorithm</h3>

<p>

Decoding SNDVs is a more difficult operation than encoding them, due to the
fact that no bound on the resulting value is known until the SDNV is parsed, at
which point the value itself is already known.  This means that if space is
allocated for decoding the value of an SDNV into, it is never known whether
this space will be overflowed until it is 7 bits away from happening.


</p>
<p>

(Initial Step) Set the result to 0.  Set an index to the first byte of the encoded
SDNV.


</p>
<p>

(Recursion Step) Shift the result left 7 bits.  Add the low-order 7 bits of the
value at the index to the result.  If the high-order bit under the pointer is
a 1, advance the index by one byte within the encoded SDNV and repeat the Recursion Step, otherwise
return the current value of the result. 


</p>
<p>

This decoding algorithm takes no more additional space than what is required
for the result (7/8 the length of the SDNV) and the pointer.  The complication
is that before the result can be left-shifted in the Recursion Step, an
implementation needs to first make sure that this won't cause any bits to be
lost, and re-allocate a larger piece of memory for the result, if required.
The pure time complexity is the same as for the encoding algorithm given, but
if re-allocation is needed due to the inability to predict the size of the
result, decoding may be slower.


</p>
<p>
	
These decoding steps include removal of any leftmost zero-padding that might be
used by an encoder to create encodings of a certain length.


</p>
<a name="limitations"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.3"></a><h3>3.3.&nbsp;
Limitations of Implementations</h3>

<p>

Because of efficiency considerations or convenience of internal representation
of decoded integers, implementations may choose to limit the number of bits in
SDNVs that they will handle.  To avoid interoperability problems any protocol
that uses SDNVs must specify the largest number of bits in an SDNV that an 
implementation of that protocol is expected to handle.


</p>
<p>

For example Section 4.1 of <a class='info' href='#RFC5050'>[RFC5050]<span> (</span><span class='info'>Scott, K. and S. Burleigh, &ldquo;Bundle Protocol Specification,&rdquo; November&nbsp;2007.</span><span>)</span></a> specifies that implementations
of the DTN Bundle Protocol are not required to handle SDNVs with more than 64
bits in their unencoded value.  Accordingly integer values transmitted in SDNVs
have an upper limit and SDNV encoded flag fields must be limited to 64 bit positions
in any future revisions of the protocol unless the restriction is altered.


</p>
<a name="comp"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4"></a><h3>4.&nbsp;
Comparison to Alternatives</h3>

<p>

This section compares three alternative ways of implementing the concept of
SDNVs: (1) the TLV scheme commonly used in the Internet family, and many other
families of protocols, (2) the old style of SDNVs (both the SDNV-8 and SDNV-16)
defined in an early stage of LTP's development <a class='info' href='#BRF04'>[BRF04]<span> (</span><span class='info'>Burleigh, S., Ramadas, M., and S. Farrell, &ldquo;Licklider Transmission Protocol,&rdquo; May&nbsp;2004.</span><span>)</span></a>, and (3)
the current SDNV format.


</p>
<p>

The TLV method uses two fixed-length fields to hold the Type and Length
elements that then imply the syntax and semantics of the Value element.  This
is only similar to an SDNV in that the value element can grow or shrink within
the bounds capable of being conveyed by the Length field.  Two fundamental
differences between TLVs and SDNVs are that through the Type element, TLVs also
contain some notion of what their contents are semantically, while SDNVs are
simply generic non-negative integers, and protocol engineers still have to choose
fixed field lengths for the Type and Length fields in the TLV format.


</p>
<p>

Some protocols use TLVs where the value conveyed within the Length field needs
to be decoded into the actual length of the Value field.  This may be
accomplished through simple multiplication, left-shifting, or a look-up table.
In any case, this tactic limits the granularity of the possible Value lengths,
and can contribute some degree of bloat if Values do not fit neatly within the
available decoded Lengths.


</p>
<p>

In the SDNV format originally used by LTP, parsing the first byte of the SDNV
told an implementation how much space was required to hold the contained value.
There were two different types of SDNVs defined for different ranges of use.
The SDNV-8 type could hold values up to 127 in a single byte, while the SDNV-16
type could hold values up to 32,767 in 2 bytes.  Both formats could encode
values requiring up to N bytes in N+2 bytes, where N&lt;127.  The major
difference between this old SDNV format and the current SDNV format is
that the new format is not as easily decoded as the old format was, but the new
format also has absolutely no limitation on its length.


</p>
<p>

The advantage in ease of parsing the old format manifests itself in two
aspects: (1) the size of the value is determinable ahead of time, in a way
equivalent to parsing a TLV, and (2) the actual value is directly encoded and
decoded, without shifting and masking bits as is required in the new format.
For these reasons, the old format requires less computational overhead to deal
with, but is also very limited, in that it can only hold a 1024-bit number, at
maximum.  Since according to IETF Best Current Practices, an asymmetric
cryptography key needed to last for a long term requires using moduli of over
1228 bits <a class='info' href='#RFC3766'>[RFC3766]<span> (</span><span class='info'>Orman, H. and P. Hoffman, &ldquo;Determining Strengths For Public Keys Used For Exchanging Symmetric Keys,&rdquo; April&nbsp;2004.</span><span>)</span></a>, this could be seen as a severe limitation
of the old-style of SDNVs, which the currently-used style does not suffer from.


</p>
<p>

<a class='info' href='#comptab'>Table&nbsp;1</a> compares the maximum values that can be encoded into
SDNVs of various lengths using the old SDNV-8/16 method and the current SDNV
method.  The only place in this table where SDNV-16 is used rather than SDNV-8
is in the 2-byte row.  Starting with a single byte, the two methods are
equivalent, but when using 2 bytes, the old method is a more compact encoding
by one bit.  From 3 to 7 bytes of length though, the current SDNV format is
more compact, since it only requires one bit per byte of overhead, whereas the
old format used a full byte.  Thus, at 8 bytes, both schemes are equivalent in
efficiency since they both use 8 bits of overhead.  Up to 129 bytes, the old
format is more compact than the current one, although after this limit it
becomes unusable.


</p><br /><hr class="insert" />
<a name="comptab"></a>
<table class="full" align="center" border="0" cellpadding="2" cellspacing="2">
<col align="center"><col align="center"><col align="center"><col align="center"><col align="center">
<tr><th align="center">Bytes</th><th align="center">SDNV-8/16 Maximum Value</th><th align="center">SDNV Maximum Value</th><th align="center">SDNV-8/16 Overhead Bits</th><th align="center">SDNV Overhead Bits</th></tr>
<tr>
<td align="center">1</td>
<td align="center">127</td>
<td align="center">127</td>
<td align="center">1</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">32,767</td>
<td align="center">16,383</td>
<td align="center">1</td>
<td align="center">2</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">65,535</td>
<td align="center">2,097,151</td>
<td align="center">8</td>
<td align="center">3</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">2^24 - 1</td>
<td align="center">2^28 - 1</td>
<td align="center">8</td>
<td align="center">4</td>
</tr>
<tr>
<td align="center">5</td>
<td align="center">2^32 - 1</td>
<td align="center">2^35 - 1</td>
<td align="center">8</td>
<td align="center">5</td>
</tr>
<tr>
<td align="center">6</td>
<td align="center">2^40 - 1</td>
<td align="center">2^42 - 1</td>
<td align="center">8</td>
<td align="center">6</td>
</tr>
<tr>
<td align="center">7</td>
<td align="center">2^48 - 1</td>
<td align="center">2^49 - 1</td>
<td align="center">8</td>
<td align="center">7</td>
</tr>
<tr>
<td align="center">8</td>
<td align="center">2^56 - 1</td>
<td align="center">2^56 - 1</td>
<td align="center">8</td>
<td align="center">8</td>
</tr>
<tr>
<td align="center">9</td>
<td align="center">2^64 - 1</td>
<td align="center">2^63 - 1</td>
<td align="center">8</td>
<td align="center">9</td>
</tr>
<tr>
<td align="center">10</td>
<td align="center">2^72 - 1</td>
<td align="center">2^70 - 1</td>
<td align="center">8</td>
<td align="center">10</td>
</tr>
<tr>
<td align="center">16</td>
<td align="center">2^120 - 1</td>
<td align="center">2^112 - 1</td>
<td align="center">8</td>
<td align="center">16</td>
</tr>
<tr>
<td align="center">32</td>
<td align="center">2^248 - 1</td>
<td align="center">2^224 - 1</td>
<td align="center">8</td>
<td align="center">32</td>
</tr>
<tr>
<td align="center">64</td>
<td align="center">2^504 - 1</td>
<td align="center">2^448 - 1</td>
<td align="center">8</td>
<td align="center">64</td>
</tr>
<tr>
<td align="center">128</td>
<td align="center">2^1016 - 1</td>
<td align="center">2^896 - 1</td>
<td align="center">8</td>
<td align="center">128</td>
</tr>
<tr>
<td align="center">129</td>
<td align="center">2^1024 - 1</td>
<td align="center">2^903 - 1</td>
<td align="center">8</td>
<td align="center">129</td>
</tr>
<tr>
<td align="center">130</td>
<td align="center">N/A</td>
<td align="center">2^910 - 1</td>
<td align="center">N/A</td>
<td align="center">130</td>
</tr>
<tr>
<td align="center">256</td>
<td align="center">N/A</td>
<td align="center">2^1792 - 1</td>
<td align="center">N/A</td>
<td align="center">256</td>
</tr>
</table>
<br clear="all" />
<table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Table 1&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>

In general, it seems like the most promising use of SDNVs may be to define the
Length field of a TLV structure to be an SDNV whose value is the length of the
TLV's Value field.  This leverages the strengths of the SDNV format and limits
the effects of its weaknesses.


</p>
<p>

Another aspect of comparison between SDNVs and alternatives using fixed-length
fields is the result of errors in transmission.  Bit-errors in an SDNV can
result in either errors in the decoded value, or parsing errors in subsequent
fields of the protocol.  In fixed-length fields, bit errors always result in
errors to the decoded value rather than parsing errors in subsequent fields.
If the decoded values from either type of field encoding (SDNV or
fixed-length) are used as indexes, offsets, or lengths of further fields in
the protocol, similar failures result.


</p>
<a name="anchor4"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5"></a><h3>5.&nbsp;
Security Considerations</h3>

<p>
The only security considerations with regards to SDNVs are that code which
parses SDNVs should have bounds-checking logic and be capable of handling
cases where an SDNV's value is beyond the code's ability to parse.  These
precautions can prevent potential exploits involving SDNV decoding routines.

</p>
<p>
Stephen Farrell noted that very early definitions of SDNVs also allowed
negative integers.  This was considered a potential security hole, since it
could expose implementations to underflow attacks during SDNV decoding.  There
is a precedent in that many existing TLV decoders map the Length field to a
signed integer and are vulnerable in this way.  An SDNV decoder should be based
on unsigned types and not have this issue.

</p>
<a name="anchor5"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6"></a><h3>6.&nbsp;
IANA Considerations</h3>

<p>This document has no IANA considerations.
</p>
<a name="anchor6"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7"></a><h3>7.&nbsp;
Acknowledgements</h3>

<p>
Scott Burleigh, Manikantan Ramadas, Michael Demmer, Stephen Farrell, and other
members of the IRTF DTN Research Group contributed to the development and usage
of SDNVs in DTN protocols.  George Jones and Keith Scott from Mitre, Lloyd
Wood, Gerardo Izquierdo, Joel Halpern, Peter TB Brett, Kevin Fall, and Elwyn
Davies also contributed useful comments on and criticisms of this document.
DTNRG last call comments on the draft were sent to the mailing list by Lloyd
Wood, Will Ivancic, Jim Wyllie, William Edwards, Hans Kruse, Janico
Greifenberg, Teemu Karkkainen, Stephen Farrell, and Scott Burleigh.  Further
constructive comments were incorporated from Dave Crocker.


</p>
<p>

Work on this document was performed at NASA's Glenn Research Center, in support
of the NASA Space Communications Architecture Working Group (SCAWG), NASA's
Earth Science Technology Office (ESTO), and the FAA/Eurocontrol Future
Communications Study (FCS) in the 2005-2007 timeframe, while the editor was an
employee of Verizon Federal Network Systems.


</p>
<a name="rfc.references1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>8.&nbsp;Informative References</h3>
<table width="99%" border="0">
<tr><td class="author-text" valign="top"><a name="ASN1">[ASN1]</a></td>
<td class="author-text">ITU-T Rec. X.680, &ldquo;Abstract Syntax Notation One (ASN.1). Specification of Basic Notation,&rdquo; ISO/IEC&nbsp;8824-1:2002, 2002.</td></tr>
<tr><td class="author-text" valign="top"><a name="ASN1-BER">[ASN1-BER]</a></td>
<td class="author-text">ITU-T Rec. X.690, &ldquo;Abstract Syntax Notation One (ASN.1). Encoding Rules: Specification of Basic Encoding Rules (BER), Canonical Encoding Rules (CER) and Distinguished Encoding Rules (DER),&rdquo; ISO/IEC&nbsp;8825-1:2002, 2002.</td></tr>
<tr><td class="author-text" valign="top"><a name="BRF04">[BRF04]</a></td>
<td class="author-text">Burleigh, S., Ramadas, M., and S. Farrell, &ldquo;Licklider Transmission Protocol,&rdquo; draft-irtf-dtnrg-ltp-00&nbsp;(replaced), May&nbsp;2004.</td></tr>
<tr><td class="author-text" valign="top"><a name="Hain05">[Hain05]</a></td>
<td class="author-text">Hain, T., &ldquo;A Pragmatic Report on IPv4 Address Space Consumption,&rdquo; Internet Protocol Journal&nbsp;Vol. 8, No. 3, September&nbsp;2005.</td></tr>
<tr><td class="author-text" valign="top"><a name="I-D.hixie-thewebsocketprotocol">[I-D.hixie-thewebsocketprotocol]</a></td>
<td class="author-text">Hickson, I., &ldquo;<a href="http://www.ietf.org/internet-drafts/draft-hixie-thewebsocketprotocol-76.txt">The WebSocket protocol</a>,&rdquo; draft-hixie-thewebsocketprotocol-76 (work in progress), May&nbsp;2010 (<a href="http://www.ietf.org/internet-drafts/draft-hixie-thewebsocketprotocol-76.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="IEN21">[IEN21]</a></td>
<td class="author-text">Cerf, V. and J. Postel, &ldquo;Specification of Internetwork Transmission Control Program: TCP Version 3,&rdquo; Internet Experimental Note&nbsp;21, January&nbsp;1978.</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC0713">[RFC0713]</a></td>
<td class="author-text"><a href="mailto:JFH@MIT-DMS">Haverty, J.</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc713">MSDTP-Message Services Data Transmission Protocol</a>,&rdquo; RFC&nbsp;713, April&nbsp;1976 (<a href="http://www.rfc-editor.org/rfc/rfc713.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC0791">[RFC0791]</a></td>
<td class="author-text">Postel, J., &ldquo;<a href="http://tools.ietf.org/html/rfc791">Internet Protocol</a>,&rdquo; STD&nbsp;5, RFC&nbsp;791, September&nbsp;1981 (<a href="http://www.rfc-editor.org/rfc/rfc791.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC0793">[RFC0793]</a></td>
<td class="author-text">Postel, J., &ldquo;<a href="http://tools.ietf.org/html/rfc793">Transmission Control Protocol</a>,&rdquo; STD&nbsp;7, RFC&nbsp;793, September&nbsp;1981 (<a href="http://www.rfc-editor.org/rfc/rfc793.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC1323">[RFC1323]</a></td>
<td class="author-text"><a href="mailto:van@CSAM.LBL.GOV">Jacobson, V.</a>, <a href="mailto:Braden@ISI.EDU">Braden, B.</a>, and <a href="mailto:dab@cray.com">D. Borman</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc1323">TCP Extensions for High Performance</a>,&rdquo; RFC&nbsp;1323, May&nbsp;1992 (<a href="http://www.rfc-editor.org/rfc/rfc1323.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC2993">[RFC2993]</a></td>
<td class="author-text">Hain, T., &ldquo;<a href="http://tools.ietf.org/html/rfc2993">Architectural Implications of NAT</a>,&rdquo; RFC&nbsp;2993, November&nbsp;2000 (<a href="http://www.rfc-editor.org/rfc/rfc2993.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC3766">[RFC3766]</a></td>
<td class="author-text">Orman, H. and P. Hoffman, &ldquo;<a href="http://tools.ietf.org/html/rfc3766">Determining Strengths For Public Keys Used For Exchanging Symmetric Keys</a>,&rdquo; BCP&nbsp;86, RFC&nbsp;3766, April&nbsp;2004 (<a href="http://www.rfc-editor.org/rfc/rfc3766.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4963">[RFC4963]</a></td>
<td class="author-text">Heffner, J., Mathis, M., and B. Chandler, &ldquo;<a href="http://tools.ietf.org/html/rfc4963">IPv4 Reassembly Errors at High Data Rates</a>,&rdquo; RFC&nbsp;4963, July&nbsp;2007 (<a href="http://www.rfc-editor.org/rfc/rfc4963.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC5050">[RFC5050]</a></td>
<td class="author-text">Scott, K. and S. Burleigh, &ldquo;<a href="http://tools.ietf.org/html/rfc5050">Bundle Protocol Specification</a>,&rdquo; RFC&nbsp;5050, November&nbsp;2007 (<a href="http://www.rfc-editor.org/rfc/rfc5050.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC5325">[RFC5325]</a></td>
<td class="author-text">Burleigh, S., Ramadas, M., and S. Farrell, &ldquo;<a href="http://tools.ietf.org/html/rfc5325">Licklider Transmission Protocol - Motivation</a>,&rdquo; RFC&nbsp;5325, September&nbsp;2008 (<a href="http://www.rfc-editor.org/rfc/rfc5325.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC5326">[RFC5326]</a></td>
<td class="author-text">Ramadas, M., Burleigh, S., and S. Farrell, &ldquo;<a href="http://tools.ietf.org/html/rfc5326">Licklider Transmission Protocol - Specification</a>,&rdquo; RFC&nbsp;5326, September&nbsp;2008 (<a href="http://www.rfc-editor.org/rfc/rfc5326.txt">TXT</a>).</td></tr>
</table>

<a name="append"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.A"></a><h3>Appendix A.&nbsp;
SNDV Python Source Code</h3>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
# sdnv_decode() takes a string argument (s), which is assumed to be
#   an SDNV, and optionally a number (slen) for the maximum number of
#   bytes to parse from the string.  The function returns a pair of
#   the non-negative integer n that is the numeric value encoded in
#   the SDNV, and integer that is the distance parsed into the input
#   string.  If the slen argument is not given (or is not a non-zero
#   number) then, s is parsed up to the first byte whose high-order
#   bit is 0 -- the length of the SDNV portion of s does not have to
#   be pre-computed by calling code.  If the slen argument is given
#   as a non-zero value, then slen bytes of s are parsed.  The value
#   for n of -1 is returned for any type of parsing error.
#
# NOTE: In python, integers can be of arbitrary size.  In other
#   languages, such as C, SDNV-parsing routines should take
#   precautions to avoid overflow (e.g. by using the Gnu MP library,
#   or similar).
#
def sdnv_decode(s, slen=0):
  n = long(0)
  for i in range(0, len(s)):
    v = ord(s[i])
    n = n&lt;&lt;7
    n = n + (v &amp; 0x7F)
    if v&gt;&gt;7 == 0:
      slen = i+1
      break
    elif i == len(s)-1 or (slen != 0 and i &gt; slen):
      n = -1 # reached end of input without seeing end of SDNV
  return (n, slen)

# sdnv_encode() returns the SDNV-encoded string that represents n.
#   An empty string is returned if n is not a non-negative integer
def sdnv_encode(n):
  r = ""
  # validate input
  if n &gt;= 0 and (type(n) in [type(int(1)), type(long(1))]):
    flag = 0
    done = False
    while not done:
      # encode lowest 7 bits from n
      newbits = n &amp; 0x7F
      n = n&gt;&gt;7
      r = chr(newbits + flag) + r
      if flag == 0:
        flag = 0x80
      if n == 0:
        done = True
  return r


# test cases from LTP and BP internet-drafts, only print failures
def sdnv_test():
  tests = [(0xABC, chr(0x95) + chr(0x3C)),
           (0x1234, chr(0xA4) + chr (0x34)),
           (0x4234, chr(0x81) + chr(0x84) + chr(0x34)),
           (0x7F, chr(0x7F))]

  for tp in tests:
    # test encoding function
    if sdnv_encode(tp[0]) != tp[1]:
      print "sdnv_encode fails on input %s" % hex(tp[0])
    # test decoding function
    if sdnv_decode(tp[1])[0] != tp[0]:
      print "sdnv_decode fails on input %s, giving %s" % \
            (hex(tp[0]), sdnv_decode(tp[1]))
</pre></div>
<a name="rfc.authors"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>Authors' Addresses</h3>
<table width="99%" border="0" cellpadding="0" cellspacing="0">
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Wesley M. Eddy</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">MTI Systems</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">NASA Glenn Research Center</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">MS 500-ASRC; 21000 Brookpark Rd</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Cleveland, OH  44135</td></tr>
<tr><td class="author" align="right">Phone:&nbsp;</td>
<td class="author-text">216-433-6682</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:wes@mti-systems.com">wes@mti-systems.com</a></td></tr>
<tr cellpadding="3"><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Elwyn Davies</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Folly Consulting</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Soham  </td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">UK</td></tr>
<tr><td class="author" align="right">Phone:&nbsp;</td>
<td class="author-text"></td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:elwynd@folly.org.uk">elwynd@folly.org.uk</a></td></tr>
<tr><td class="author" align="right">URI:&nbsp;</td>
<td class="author-text"><a href=""></a></td></tr>
</table>
</body></html>
