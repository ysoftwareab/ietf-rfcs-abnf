start = element-dhcp

element-dhcp = element dhcp {
     element subnet {
       element network { ipv4-address-content },
       element prefix-length {
         xsd:short { minInclusive = "0" maxInclusive = "32" }
       }
       element-range?,
       element leases {
         element-lease*
       }?,
     }*
element-range = element range {
      element low  { ipv4-address-content },
      element high { ipv4-address-content }
element-lease = element lease {
      attribute ip-address { ipv4-address-content },
      element starts  { xsd:dateTime },
      element ends    { xsd:dateTime },
      element mac-address { mac-address-content }
element-servers = element servers {
    element service {
      element name  { xsd:string },
      element port  { xsd:unsignedShort }
    }+ >> dml:unique ["port"]
element-dhcp = element dhcp {
     element subnet {
       element prefix {
         element network { ipv4-address-content },
         element prefix-length {
           xsd:short { minInclusive = "0" maxInclusive = "32" }
         }
       },
       element-range
     }+ >> dml:key ["concat(prefix/network, '/', prefix/prefix-length)"]
element-subnet = element subnet {
     element network { ipv4-address-content },
     element prefix-length {
       xsd:short { minInclusive = "0" maxInclusive = "32" }
     },
     element interface-filter {
       element interface { xsd:token }+
         >> dml:keyref ["//int:interface"]
     }
element-interfaces = element int:interfaces {
     element int:interface {
       element int:ifIndex { xsd:token },
       element int:ifType  { xsd:token }
     }+ >> dml:key ["int:ifIndex"]
element-leases = element leases {
     element lease {
       attribute ip-address { ipv4-address-content },
       element starts  { xsd:dateTime },
       element ends    { xsd:dateTime },
       element mac-address { mac-address-content }
     }*
element-subnet =   element subnet {
   element network { ipv4-address-content },
   element prefix-length {
     xsd:short { minInclusive = "0" maxInclusive = "32" }
   }
element-dhcp = element dhcp {
   [
     sch:pattern [
       sch:rule  [
context = "//dhcp:dhcp"
test = "dhcp:default-lease-time <= dhcp:max-lease-time"
test="dhcp:default-lease-time &lt;= dhcp:max-lease-time">
value="//dhcp:interface-filter/dhcp:interface"/>
start = element-config
element-config = element cfg:config { root-config-contents }

root-config-contents = empty

revokeLeaseType = element revoke-lease {
     element address { ipv4-address-content }+
diagnostics="keyref-fail-en keyref-fail-fr">
value="//dhcp:interface-filter/dhcp:interface"/>
start = element-config
element-config = element cfg:config { root-config-contents }

root-config-contents = empty

element-interfaces = element interfaces {
   element interface {
     element ifIndex { xsd:token },
     element ifType  { xsd:token }
   }+ >> dml:key [ "ifIndex"]
element-dhcp = element dhcp {
    global-timer-elements,
    subnet-elements,
    element-shared-network* >> dml:key ["@name"]
global-timer-elements = (
   [
     sch:pattern [
       sch:rule  [
context = "//dhcp:dhcp"
test = "dhcp:default-lease-time <= dhcp:max-lease-time"
element-shared-network = element shared-network {
    attribute name { token },
    subnet-elements
subnet-elements =  element-subnet*
   >> dml:key ["concat(network, '/', prefix-length)"]
   >> dml:manual-validation-rule [
     "Verify that none of the subnets overlap with other subnets." ]

element-subnet = element subnet {
    element-network,
    element-prefix-length,
    element-range?
      >> dml:existence []
      >> dml:manual-validation-rule [
        "Verify the range is within the subnet."
    ],
    element-dhcp-options?,
    element max-lease-time { xsd:unsignedInt }?
      >> dml:units ["s"]  >> dml:status ["deprecated"],
    element leases {
      element-lease* >> sch:key ["@ip-address"]
    }? >> dml:info-type ["status"],
    element-interface-filter?
element-network = element network {
    ipv4-address-content
element-prefix-length = element prefix-length {
    xsd:short { minInclusive = "0" maxInclusive = "32" }
element-range = element range {
    element low  { ipv4-address-content }?,
    element high { ipv4-address-content }?
element-dhcp-options = element dhcp-options {
    element-router-list-option? &
    element-domain-list-option? &
    element-custom-option* >> dml:key ["@option"]
element-lease = element lease {
    attribute ip-address { ipv4-address-content },
    element starts  { xsd:dateTime },
    element ends    { xsd:dateTime },
    element mac-address { mac-address-content }
element-router-list-option = element router-list {
    element router { ipv4-address-content }+
      >> dml:order ["user-order"]
element-domain-list-option = element domain-list {
    element domain { token }+
element-custom-option = element custom {
    attribute option { xsd:unsignedByte },
    (
        element ip-address { ipv4-address-content }
      | element string { string }
    )
element-interface-filter = element interface-filter {
   element interface { token }+ >> dml:keyref ["//int:interface"]
ipv4-address-content = xsd:token { pattern =
   "((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}" ~
   "(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])"
   }
mac-address-content  = xsd:token { pattern =
   "(([0-9a-fA-F]{2}):?){5}[0-9a-fA-F]{2}" }



element-dml = element dml {
   attribute dmlVersion { "1.0" }? &
   dml-contents
dml-contents = (
   dataModelVersion &
   organization* &
   contact-info* &
   list-order* &
   data-category* &
   mustUse-flag* &
   container-existence* &
   manual-validation* &
   units* &
   mustUnderstand*
dataModelVersion = element dataModelVersion { xsd:string }

organization = element organization { string-with-lang }
contact-info = element contact { xsd:anyURI }

unique = element unique { xsd:anyURI }
key = element key { xsd:anyURI }
keyref = element keyref { xsd:anyURI }

data-category = element info-type {
   attribute minAccess { xsd:string }?,
   attribute maxAccess { xsd:string }?,
   ("config" | "status" | "statistics" | "action" | "notify")
 }  >> compat:defaultValue ["config"]

mustUse-flag = element mustUse { xsd:boolean }
               >> compat:defaultValue ["false"]

manual-validation = element manual-validation-rule { string-with-lang }

list-order = element order { "any-order" | "user-order" }
               >> compat:defaultValue ["any-order"]

container-existence = element existence { empty }

units = element units {
  xsd:string { pattern="[^: \n\r\t]+" }
  # allow familiar units, but no whitespace or absolute URIs here
  |
  xsd:anyURI { pattern="([a-zA-Z][a-zA-Z0-9\-\+\.]*:|\.\./|\./|#).*" }
  # allow absolute URIs, plus relative URIs with ./ or ../
  # prohibit relative URIs that could look like a unit, ex: m/s
string-with-lang = (
   attribute xml:lang { xsd:language },
   xsd:string
mustUnderstand = element mustUnderstand { xsd:NCName }


