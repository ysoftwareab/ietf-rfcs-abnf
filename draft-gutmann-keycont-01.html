<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="en"><head><title>Key Management through Key Continuity (KCM)</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="description" content="Key Management through Key Continuity (KCM)">
<meta name="keywords" content="Internet-Draft">
<meta name="generator" content="xml2rfc v1.35 (http://xml.resource.org/)">
<meta name="viewport" content="width=600;" />
<style type='text/css'><!--
        body {
                font-family: verdana, charcoal, helvetica, arial, sans-serif;
                font-size: 85%;
		max-width: 40em; 
		color: #000; background-color: #FFF;
                margin: 2em;
        }
        h1, h2, h3, h4, h5, h6 {
                font-family: helvetica, monaco, "MS Sans Serif", arial, sans-serif;
                font-weight: bold; font-style: normal;
        }
        h1 { color: #900; background-color: transparent; text-align: right; }
        h3 { color: #333; background-color: transparent; }

        td.RFCbug {
                font-size: x-small; text-decoration: none;
                width: 30px; height: 30px; padding-top: 2px;
                text-align: justify; vertical-align: middle;
                background-color: #000;
        }
        td.RFCbug span.RFC {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: bold; color: #666;
        }
        td.RFCbug span.hotText {
                font-family: charcoal, monaco, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: normal; text-align: center; color: #FFF;
        }

        table.TOCbug { width: 30px; height: 15px; }
        td.TOCbug {
                text-align: center; width: 30px; height: 15px;
                color: #FFF; background-color: #900;
        }
        td.TOCbug a {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, sans-serif;
                font-weight: bold; font-size: x-small; text-decoration: none;
                color: #FFF; background-color: transparent;
        }

        td.header {
                font-family: arial, helvetica, sans-serif; font-size: x-small;
                vertical-align: top; width: 33%;
                color: #FFF; background-color: #666;
        }
        td.author { font-weight: bold; font-size: x-small; margin-left: 4em; }
        td.author-text { font-size: x-small; }

        /* info code from SantaKlauss at http://www.madaboutstyle.com/tooltip2.html */
        a.info {
                /* This is the key. */
                position: relative;
                z-index: 24;
                text-decoration: none;
        }
        a.info:hover {
                z-index: 25;
                color: #FFF; background-color: #900;
        }
        a.info span { display: none; }
        a.info:hover span.info {
                /* The span will display just on :hover state. */
                display: block;
                position: absolute;
                font-size: smaller;
                top: 2em; left: -5em; width: 15em;
                padding: 2px; border: 1px solid #333;
                color: #900; background-color: #EEE;
                text-align: left;
        }

        a { font-weight: bold; }
        a:link    { color: #900; background-color: transparent; }
        a:visited { color: #633; background-color: transparent; }
        a:active  { color: #633; background-color: transparent; }

        p { margin-left: 2em; margin-right: 2em; }
        p.copyright { font-size: x-small; }
        p.toc { font-size: 85%;
		max-width: 40em; 
		font-weight: bold; margin-left: 3em; }
        table.toc { margin: 0 0 0 3em; padding: 0; border: 0; vertical-align: text-top; }
        td.toc { font-size: 85%;
		max-width: 40em; 
		font-weight: bold; vertical-align: text-top; }

        ol.text { margin-left: 2em; margin-right: 2em; }
        ul.text { margin-left: 2em; margin-right: 2em; }
        li      { margin-left: 3em; }

        /* RFC-2629 <spanx>s and <artwork>s. */
        em     { font-style: italic; }
        strong { font-weight: bold; }
        dfn    { font-weight: bold; font-style: normal; }
        cite   { font-weight: normal; font-style: normal; }
        tt     { color: #036; }
        tt, pre, pre dfn, pre em, pre cite, pre span {
                font-family: "Courier New", Courier, monospace; font-size: small;
        }
        pre {
                text-align: left; padding: 4px;
                color: #000; background-color: #CCC;
        }
        pre dfn  { color: #900; }
        pre em   { color: #66F; background-color: #FFC; font-weight: normal; }
        pre .key { color: #33C; font-weight: bold; }
        pre .id  { color: #900; }
        pre .str { color: #000; background-color: #CFF; }
        pre .val { color: #066; }
        pre .rep { color: #909; }
        pre .oth { color: #000; background-color: #FCF; }
        pre .err { background-color: #FCC; }

        /* RFC-2629 <texttable>s. */
        table.all, table.full, table.headers, table.none {
                font-size: 85%;
		max-width: 40em; 
		text-align: center; border-width: 2px;
                vertical-align: top; border-collapse: collapse;
        }
        table.all, table.full { border-style: solid; border-color: black; }
        table.headers, table.none { border-style: none; }
        th {
                font-weight: bold; border-color: black;
                border-width: 2px 2px 3px 2px;
        }
        table.all th, table.full th { border-style: solid; }
        table.headers th { border-style: none none solid none; }
        table.none th { border-style: none; }
        table.all td {
                border-style: solid; border-color: #333;
                border-width: 1px 2px;
        }
        table.full td, table.headers td, table.none td { border-style: none; }

        hr { height: 1px; }
        hr.insert {
                width: 80%; border-style: none; border-width: 0;
                color: #CCC; background-color: #CCC;
        }
--></style>
</head>
<body>
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<table summary="layout" width="66%" border="0" cellpadding="0" cellspacing="0"><tr><td><table summary="layout" width="100%" border="0" cellpadding="2" cellspacing="1">
<tr><td class="header">Network Working Group</td><td class="header">P. Gutmann</td></tr>
<tr><td class="header">Internet-Draft</td><td class="header">University of Auckland</td></tr>
<tr><td class="header">Intended status: BCP</td><td class="header">September 29, 2008</td></tr>
<tr><td class="header">Expires: April 2, 2009</td><td class="header">&nbsp;</td></tr>
</table></td></tr></table>
<h1><br />Key Management through Key Continuity (KCM)<br />draft-gutmann-keycont-01.txt</h1>

<h3>Status of this Memo</h3>
<p>
By submitting this Internet-Draft,
each author represents that any applicable patent or other IPR claims of which
he or she is aware have been or will be disclosed,
and any of which he or she becomes aware will be disclosed,
in accordance with Section&nbsp;6 of BCP&nbsp;79.</p>
<p>
Internet-Drafts are working documents of the Internet Engineering
Task Force (IETF), its areas, and its working groups.
Note that other groups may also distribute working documents as
Internet-Drafts.</p>
<p>
Internet-Drafts are draft documents valid for a maximum of six months
and may be updated, replaced, or obsoleted by other documents at any time.
It is inappropriate to use Internet-Drafts as reference material or to cite
them other than as &ldquo;work in progress.&rdquo;</p>
<p>
The list of current Internet-Drafts can be accessed at
<a href='http://www.ietf.org/ietf/1id-abstracts.txt'>http://www.ietf.org/ietf/1id-abstracts.txt</a>.</p>
<p>
The list of Internet-Draft Shadow Directories can be accessed at
<a href='http://www.ietf.org/shadow.html'>http://www.ietf.org/shadow.html</a>.</p>
<p>
This Internet-Draft will expire on April 2, 2009.</p>

<h3>Abstract</h3>

<p>

This memo provides advice and Best Current Practice for implementors and
deployers of security applications that wish to use the key continuity method
of key management.

      
</p><a name="toc"></a><br /><hr />
<h3>Table of Contents</h3>
<p class="toc">
<a href="#introduction">1.</a>&nbsp;
Introduction<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#mustshouldmay">1.1.</a>&nbsp;
Conventions Used in This Document<br />
<a href="#kcm-description">2.</a>&nbsp;
Key Management through Key Continuity<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#ssh-kcm">2.1.</a>&nbsp;
Key Continuity in SSH<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tls-kcm">2.2.</a>&nbsp;
Key Continuity in SSL/TLS and IPsec<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#other-kcm">2.3.</a>&nbsp;
Key Continuity in Other Security Protocols<br />
<a href="#using">3.</a>&nbsp;
Using Key Continuity for Key Management<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#key-generation">3.1.</a>&nbsp;
Key Generation<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#oob-auth">3.2.</a>&nbsp;
Optional out-of-band Authentication<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#key-rollover">3.3.</a>&nbsp;
Key Rollover<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#service-mapping">3.4.</a>&nbsp;
Key &lt;-&gt; Host/Service Mapping<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#user-interface">3.5.</a>&nbsp;
User Interface<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#trust-lifetimes">3.6.</a>&nbsp;
Trust Lifetimes<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#fingerprints">3.7.</a>&nbsp;
Key Hash/Fingerprint Truncation<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#key-storage">3.8.</a>&nbsp;
Key Information Storage<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#external-auth">3.9.</a>&nbsp;
Key Continuity via External Authorities<br />
<a href="#data-formats">4.</a>&nbsp;
Key Continuity Data Storage<br />
<a href="#discussion">5.</a>&nbsp;
Discussion<br />
<a href="#security">6.</a>&nbsp;
Security Considerations<br />
<a href="#iana">7.</a>&nbsp;
IANA Considerations<br />
<a href="#rfc.references1">8.</a>&nbsp;
References<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#rfc.references1">8.1.</a>&nbsp;
Normative References<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#rfc.references2">8.2.</a>&nbsp;
Informative References<br />
<a href="#rfc.authors">&#167;</a>&nbsp;
Author's Address<br />
<a href="#rfc.copyright">&#167;</a>&nbsp;
Intellectual Property and Copyright Statements<br />
</p>
<br clear="all" />

<a name="introduction"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1"></a><h3>1.&nbsp;
Introduction</h3>

<p>

There are many ways of managing the identification of remote entities.  One
simple but also highly effective method is the use of key continuity, a means
of ensuring that that the entity a user is dealing with today is the same as
the one they were dealing with last week (this principle is sometimes referred
to as continuity of identity).  In the case of cryptographic protocols the
problem becomes one of determining whether a file server, mail server, online
store, or bank that a user dealt with last week is still the same one this
week.  Using key continuity to verify this means that if the remote entity
used a given key to communicate/authenticate itself last week then the use of
the same key this week indicates that it's the same entity. This doesn't
require any third-party attestation because it can be done directly by
comparing last week's key to this week's one.  This is the basis for key
management through key continuity: Once you've got a known-good key, you can
verify a remote entity's identity by verifying that they're still using the
same key.  This document describes the principles that underly key management
through key continuity, and provides guidelines for its use in practice.

      
</p>
<a name="mustshouldmay"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1.1"></a><h3>1.1.&nbsp;
Conventions Used in This Document</h3>

<p>

The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD",
"SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be
interpreted as described in <a class='info' href='#RFC2119'>[RFC2119]<span> (</span><span class='info'>Bradner, S., &ldquo;Key words for use in RFCs to Indicate Requirement Levels,&rdquo; March&nbsp;1997.</span><span>)</span></a>.

        
</p>
<a name="kcm-description"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2"></a><h3>2.&nbsp;
Key Management through Key Continuity</h3>

<p>

In its most basic form, key management through key continuity consists of two
steps:

      
</p>
<p>
        </p>
<blockquote class="text"><dl>
<dt>Step 1</dt>
<dd>On the first connection exchange key(s), possibly with additional
out-of-band authentication.
</dd>
<dt>Step 2</dt>
<dd>On subsequent connections ensure that the key being used matches the one
exchanged initially.
</dd>
</dl></blockquote><p>
      
</p>
<p>

In more formal terms, the key continuity method of key management may be
regarded as a variation of the baby-duck security model
<a class='info' href='#Duckling1'>[Duckling1]<span> (</span><span class='info'>Stajano, F. and R. Anderson, &ldquo;The Resurrecting Duckling: Security Issues in Ad-Hoc Wireless Networking,&rdquo; April&nbsp;1999.</span><span>)</span></a> <a class='info' href='#Duckling2'>[Duckling2]<span> (</span><span class='info'>Stajano, F., &ldquo;The Resurrecting Duckling - What Next?,&rdquo; April&nbsp;2000.</span><span>)</span></a> in which a
newly-initialised device (either one fresh out of the box or one reset to its
ground state) imprints upon the first device that it sees in the same way that
a newly hatched duckling imprints on the first moving object that it sees as
its mother.

      
</p>
<a name="ssh-kcm"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2.1"></a><h3>2.1.&nbsp;
Key Continuity in SSH</h3>

<p>

SSH <a class='info' href='#SSH'>[SSH]<span> (</span><span class='info'>Ylonen, T. and C. Lonvick, &ldquo;The Secure Shell (SSH) Transport Layer Protocol,&rdquo; Janaury&nbsp;2006.</span><span>)</span></a> was the first widely-used security application that
used key continuity as its primary form of key managment.  The first time that
a user connects to an SSH server, the client application displays a warning
that it's been given a new public key that it's never encountered before, and
asks the user whether they want to continue.  When the user clicks "Yeah,
sure, whatever" (although the button is more frequently labelled "OK"), the
client application remembers the key that was used, and compares it to future
keys used by the server.  If the key is the same each time, there's a good
chance that it's the same server (SSH terminology refers to this as the
known-hosts mechanism).  In addition to this SSH allows a user to verify the
key via its fingerprint, which can be conveniently exchanged via out-of-band
means. The fingerprint is a universal key identifier consisting of the hash of
the key components or the hash of the certificate if the key is in the form of
a certificate.

      
</p>
<p>

SSH is the original key-continuity solution, but unfortunately it doesn't
provide complete continuity.  When the server is rebuilt, the connection to
the previous key is lost unless the sysadmin has remembered to archive the
configuration and keying information after they set up the server (some OS
distributions can migrate keys over during an OS upgrade, so this can vary
somewhat depending on the OS and how total the replacement of system
components is).  Since SSH is often used to secure access to
kernel-of-the-week open-source Unix systems the breaking of the chain of
continuity can happen more frequently than would first appear.

      
</p>
<p>

Some of the problem is due to the ease with which an SSH key changeover can
occur.  In the PKI world this process is so painful that the same key is
typically reused and recycled in perpetuity, ensuring key continuity at some
cost in security since a compromise of a key recycled over a period of several
years compromises all data that the key protected in that time unless a
mechanism that provides perfect forward secrecy is used (it rarely is).  In
contrast an SSH key can be replaced quickly and easily, limiting its exposure
to attack but breaking the chain of continuity.  A solution to this problem
would be to have the server automatically generate and certify key n+1 when
key n is taken into use, with key n+1 saved to offline media such as a floppy
disk or USB memory token for future use when the system or SSH server is
reinstalled/replaced.  In this way continuity to the previous, known server
key is maintained.  Periodically rolling over the key (even without it being
motivated by the existing system/server being replaced) is good practice since
it limits the exposure of any one key.  This would require a small change to
the SSH protocol to allow an old-with-new key exchange message to be set after
the changeover has occurred.

        
</p>
<a name="tls-kcm"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2.2"></a><h3>2.2.&nbsp;
Key Continuity in SSL/TLS and IPsec</h3>

<p>

Unlike SSH, SSL/TLS <a class='info' href='#TLS'>[TLS]<span> (</span><span class='info'>Dierks, T. and E. Rescorla, &ldquo;The Transport Layer Security (TLS) Protocol,&rdquo; April&nbsp;2006.</span><span>)</span></a> and IPsec <a class='info' href='#IPsec'>[IPsec]<span> (</span><span class='info'>Kent, S. and K. Seo, &ldquo;Security Architecture for the Internet Protocol,&rdquo; December&nbsp;2005.</span><span>)</span></a> were
designed to rely on an external key management infrastructure, although at a
pinch both can function without it by using shared keys, typically passwords.
The lack of such an infrastructure has been addressed in two ways.  In SSL the
client (particularly in its most widespread form, the web browser) contains a
large collection of hardcoded CA certificates (over a hundred) that are
trusted to issue SSL server certificates.  Many of these hardcoded CAs are
completely unknown, follow dubious practices such as using weak 512-bit keys
or keys with 40-year lifetimes, appear moribund, or have had their CA keys
on-sold to various third parties when the original owners went out of business
<a class='info' href='#NotDead'>[NotDead]<span> (</span><span class='info'>Gutmann, P., &ldquo;PKI: It's Not Dead, Just Resting,&rdquo; August&nbsp;2002.</span><span>)</span></a>.  All of these CAs are assigned the same level of
trust, which means that the whole system is only as secure as the least secure
CA, since compromising or subverting any one of the CAs compromises the entire
collection (in PKI terminology what's being implemented is unbounded universal
cross-certification among all of the CAs).

      
</p>
<p>

The second solution, used by both SSL/TLS and IPsec, is to use self-issued
certificates where the user acts as their own CA and issues themselves
certificates that then have to be installed on client/peer machines.  In both
cases the security provided is little better than for SSH keys unless the
client is careful to disable all CA certificates except for the one or two
that they trust, a process that requires around 700 mouse clicks for Internet
Explorer 6.  A further downside of this is that the client software will now
throw up warning dialogs prophesying all manner of doom and destruction when
an attempt is made to connect to a server with a certificate from a
now-untrusted CA, although research by security usability researchers
indicates that invalid or untrusted certificates have little to no effect on
users anyway so this is probably not a big deal <a class='info' href='#Hardening'>[Hardening]<span> (</span><span class='info'>Xia, H. and J. Brustoloni, &ldquo;Hardening Web Browsers Against Man-in-the-Middle and Eavesdropping Attacks,&rdquo; May&nbsp;2005.</span><span>)</span></a>.

      
</p>
<p>

The same key-continuity solution used in SSH can be used here, and is already
employed by some SSL clients such as MTAs which have to deal with self-issued
and similar informal certificates more frequently than other applications such
as web servers.  This is because of their use in STARTTLS, an extension to
SMTP that provides opportunistic TLS-based encryption for mail transfers.
Similar facilities exist for other mail protocols such as POP and IMAP, with
the mechanism being particularly popular with SMTP server administrators
because it provides a means of authenticating legitimate users to prevent
misuse by spammers.  Since the mail servers are set up and configured by
sysadmins rather than commercial organisations worried about adverse user
reactions to browser warning dialogs they typically make use of self-issued
certificates since there's no point in paying a CA for the same thing.

      
</p>
<p>

Key continuity management among STARTTLS implementations is still somewhat
haphazard.  Since STARTTLS is intended to be a completely transparent,
fire-and-forget solution, the ideal setup would automatically generate a
certificate on the server side when the software is installed and use standard
SSH-style key continuity management on the client, with optional out-of-band
verification via the key/certificate fingerprint.  Some implementations
(typically open-source ones) support this fully, some support various aspects
of it (for example requiring tedious manual operations for certificate
generation or key/certificate verification), and some (typically commercial
ones) require the use of certificates from commercial CAs, an even more
tedious (and expensive) manual operation.

        
</p>
<a name="other-kcm"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2.3"></a><h3>2.3.&nbsp;
Key Continuity in Other Security Protocols</h3>

<p>

A similar model is used in SIP, in which the first connection exchanges a
(typically) self-signed certificate which is then checked for continuity on
subsequent connects.  Further measures such as the use of speaker voice
recognition can be used to provide additional authentication for the SIP
exchange.  A similar principle has been used in several secure IP-phone
protocols, which (for example) have one side read out a hash of the key over
the secure link, relying for its security on the fact that real-time voice
spoofing is relatively difficult to perform.

        
</p>
<a name="using"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3"></a><h3>3.&nbsp;
Using Key Continuity for Key Management</h3>

<p>

<a class='info' href='#kcm-description'>Section&nbsp;2<span> (</span><span class='info'>Key Management through Key Continuity</span><span>)</span></a> outlined a number of considerations that
need to be taken into account when using key continuity as a form of key
management.  These are covered in the following subsections.

      
</p>
<a name="key-generation"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.1"></a><h3>3.1.&nbsp;
Key Generation</h3>

<p>

The simplest key-continuity approach automatically (and transparently)
generates the key when the application that uses it is installed or configured
for the first time.  If the underlying protocol uses certificates then the
application would generate a standard self-signed certificate at this point,
otherwise it can use whatever key format the underlying protocol uses,
typically raw public key components encoded in a protocol-specific manner.

        
</p>
<a name="oob-auth"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.2"></a><h3>3.2.&nbsp;
Optional out-of-band Authentication</h3>

<p>

If possible, the initial exchange should use additional out-of-band
authentication to authenticate the key.  A standard technique is to generate a
hash or fingerprint of the key and verify the hash through out-of-band means.
All standard security protocols have a notion of a key hash in some form,
whether it be an X.509 certificate fingerprint, a PGP/OpenPGP
<a class='info' href='#OpenPGP'>[OpenPGP]<span> (</span><span class='info'>Callas, J., Donnerhacke, L., Hal, H., Shaw, D., and R. Thayer, &ldquo;OpenPGP Message Format,&rdquo; November&nbsp;2007.</span><span>)</span></a> key fingerprint, or an SSH key fingerprint and the
use of key authentication channels such as PGP key fingerprints printed on
business cards or in email signatures is a long-established practice.
Unfortunately research has shown that this form of authentication is (at least
in the case of SSH fingerprints) relatively easily defeated
<a class='info' href='#Fingerprints'>[Fingerprints]<span> (</span><span class='info'>, &ldquo;Fuzzy Fingerprints: Attacking Vulnerabilities in the Human Brain,&rdquo; October&nbsp;2003.</span><span>)</span></a>, see <a class='info' href='#external-auth'>Section&nbsp;3.9<span> (</span><span class='info'>Key Continuity via External Authorities</span><span>)</span></a> for a more
practical solution to this problem

      
</p>
<p>

An extended form of this style of authentication has been proposed in the form
of cryptoIDs, long-lived fingerprints tied to a (user-controlled) root key
that's used to certify sub-keys on demand.  The intent of a cryptoID is to
associate it with user information such as their name and email address and
treat it as a standard part of the user identity data.  For example a key
change notification would be handled in the same way as an email address
change notification, making it part of the standard user
information-propagation channels.

      
</p>
<p>

The out-of-band verification of the hash/fingerprint is done in a
situation-specific manner.  For example when the key is used in a VoIP
application the communicating parties may read the hash value over the link,
relying on speaker voice recognition and the difficulty of performing
real-time continous-speech spoofing for security.  When the key is used to
secure access to a network server the hash may be communicated in person, over
the phone, printed on a business card, or published in some other well-known
location. When the key is used to secure access to a bank server the hash may
be communicated using a PIN mailer, or by having the user visit their bank
branch.  Although it's impossible to enumerate every situation here, applying
a modicum of common sense should provide the corerct approach for specific
situations.

      
</p>
<p>

Other distribution mechanisms are also possible.  For example when configuring
a machine the administrator can pre-install the key information when the
operating system is installed, in the same way that many systems come
pre-configured with trusted X.509 certificates.

        
</p>
<a name="key-rollover"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.3"></a><h3>3.3.&nbsp;
Key Rollover</h3>

<p>

When a key needs to be replaced the new key should ideally be authenticated
using forward-chaining authentication from the current key.  For example if
the key is in the form of an X.509 certificate or PGP key, the current key can
sign the new key.  If the key consists solely of raw key components exchanged
during a protocol handshake, this type of forward-chaining authentication
isn't possible without modifying the underlying protocol.  Protocol designers
may wish to take into account the requirements for forward-chaining
authentication when designing new protocols or updating existing ones.

        
</p>
<a name="service-mapping"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.4"></a><h3>3.4.&nbsp;
Key &lt;-&gt; Host/Service Mapping</h3>

<p>

A key will usually be associated with a service type (for example "SSH" or
"TLS"), a host, and a port (typically the port is specified implicitly by the
service type, but it may also be specified explicitly if a nonstandard port is
used).  When storing key continuity data, the service/host/port information
should always be stored exactly as seen by the user, without any subsequent
expansion, conversion, or other translation.  For example if the user knows a
host as www.example.com then the key continuity data should be stored under
this name, and not under the associated IP address(es).  Applying the WYSIWYG
principle to the name that the user sees prevents problems with things like
virtual hosting (where badguy.example.com has the same IP address as
goodguy.example.com), hosts that have been moved to a new IP address, and so
on.

        
</p>
<a name="user-interface"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.5"></a><h3>3.5.&nbsp;
User Interface</h3>

<p>

Providing a usable user interface for security features has historically
proven to be an extremely difficult undertaking <a class='info' href='#Phishing'>[Phishing]<span> (</span><span class='info'>Jakobsson, M., Ed. and S. Myers, Ed., &ldquo;Phishing and Countermeasures,&rdquo; 2007.</span><span>)</span></a>.  A
feature of key continuity management is that in its simplest form it requires
very little UI: if the key crosses a certain trust threshold (length of use,
number of times it's been used, rating(s) from an external key continuity
authority, and so on) then the connection can be allowed, otherwise it's
disallowed.  If an external authority is used this becomes particularly
simple.

      
</p>
<p>

Unfortunately this basic strategy may not be suitable in all cases.  In
particular if no external authority is available or the key is unknown then
requiring that the user wait for a set number of days until it's certain that
the key doesn't belong to an ephemeral phishing site will no doubt cause user
acceptance problems.  The general-case key bootstrap problem appears to be an
unsolveable one, althoug a great many hypotheses and workable but
situation-specific solutions do exist.  If should be remembered though that
the intent of key continuity management is to ensure key continuity and not
key initial authentication.  Designing an appropriate user interface for a key
continuity mechanism is (as with all security user interface designs) a
challenging problem.  <a class='info' href='#Usability'>[Usability]<span> (</span><span class='info'>Gutmann, P., &ldquo;Security Usability,&rdquo; September&nbsp;2008.</span><span>)</span></a> provides extensive guidance
on effectively communicating the issues to users, and potential traps and
pitfalls to avoid.

        
</p>
<a name="trust-lifetimes"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.6"></a><h3>3.6.&nbsp;
Trust Lifetimes</h3>

<p>

Like real-world trust, trust of keys can both increase and decrease over time.
In current key trust models, trust is purely boolean, starting out untrusted
and then becoming completely trusted for all eternity once the user clicks OK
on a dialog requesting that the key be trusted.  In the real world trust
doesn't work like this, but must be built up over time.  Similarly, trust can
decay over time.

      
</p>
<p>

Rather than making trust a purely boolean value, you can remember how many
times a key has been safely used of for how long the key has been around and
increase or decrease the trust in it over time.  For example a new key should
be regarded with suspicion unless verified by out-of-band means, which slowly
decreases with repeated use.  A key that's been used once should have a much
lower trust level than one that's been used a hundred times, something that
the current boolean model that's typically used with certificates isn't
capable of providing.

        
</p>
<a name="fingerprints"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.7"></a><h3>3.7.&nbsp;
Key Hash/Fingerprint Truncation</h3>

<p>

The use of the full hash/fingerprint when the authentication process is being
performed by humans can be quite cumbersome, requiring the transmission and
verification of (for the most common hash algorithm, SHA-1), 40 hex digits.
Implementors may consider truncating the hash value to make it easier to work
with.  For example a 64-bit hash value provides a moderate level of security
while still allowing the value to be printed on media such as business cards
and communicated and checked by humans.  Although such a short hash value
isn't secure against an intensive brute-force attack, it is sufficient to stop
all but the most dedicated attackers, and certainly far more secure than
simply accepting the key at face value as is currently widely done.
Implementors should consider the relative merits of usability vs. security
when deciding to truncate the key hash/fingerprint.

        
</p>
<a name="key-storage"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.8"></a><h3>3.8.&nbsp;
Key Information Storage</h3>

<p>

Configuration information of this kind is typically stored using a two-level
scheme, systemwide information set up when then operating system is installed
or configured and managed by the system administrator and per-user information
which is private to each user.  For example on Unix systems the systemwide
configuration data is traditionally stored in /etc or /var, with
per-userconfiguration data stored in the user's home directory.  Under Windows
the systemwide configuration data is stored under an OS service account and
the per-user configuration data is stored in the user's registry branch.  The
systemwide configuration provides an initial known-good set of key &lt;-&gt;
identity mappings, with per-user data providing additional user-specific
information that doesn't affect any other users on the system.

      
</p>
<p>

Note that the use of plaintext host names may make the information vulnerable
to address harvesting by an attacker who has gained read access to the file,
since it identifies remote hosts that the user/local host software implicitly
trusts. For example a worm might use it to identify remote hosts to attack.
In addition a plaintext record of sites that a user has interacted with
cryptographically may present privacy concerns.
<a class='info' href='#AddressHarvest'>[AddressHarvest]<span> (</span><span class='info'>Schechter, S., Jung, J., Stockwell, W., and C. McLain, &ldquo;Inoculating SSH Against Address-Harvesting,&rdquo; February&nbsp;2006.</span><span>)</span></a> contains more information on this type of
attack, and possible countermeasures.

      
</p>
<p>

The key continuity data should be protected by at least OS-level security
measures if they are available and if it's regarded as particularly sensitive
or if it's used on a shared machine like a home PC where everyone shares the
same account then it can be given additional protection through encapsulation
in PGP or S/MIME security envelopes or through the use of other cryptographic
protection mechanisms such as cryptographic checksums or MACs.  When
encapsulated using PGP or S/MIME the key data is no longer in its original
form and will need to be extracted in order to be used.  Alternatively if
integrity protection only is considered sufficient then a mechanism like a PGP
or S/MIME detached signature can be stored alongside the key data so that the
data can be used directly while still allowing it to be verified.

        
</p>
<a name="external-auth"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.9"></a><h3>3.9.&nbsp;
Key Continuity via External Authorities</h3>

<p>

Directly managing key continuity on end-user systems may not always be the
best approach to take.  For one thing the system needs to manage and record a
(potentially unbounded) number of locations that the user has visited, which
can be problematic if the system has limited storage capacity, although in
practice this is likely to be fairly limited since most users interact with
only a very small number of sites that use encryption.  A larger concern
though is the fact that when the user visits a site that they've never been to
before they initially have no key continuity information to rely upon, the
key/trust bootstrap problem.

      
</p>
<p>

The bootstrap problem can be addressed through the use of an external
authority to manage the key continuity information.  A key continuity external
authority records how long a particular key has been in use by a particular
cryptographic service and returns this information in response to queries.
Note that this differs very significantly from the information that CAs
provide.  A commercial CA guarantees that money changed hands and that some
form of identity checking took place while the only information that a key
continuity authority provides is the amount of time that a particular key has
been in use by that service.  Since the lifetime of a typical phishing site
currently runs at around 12 hours (well under the response time of any
blacklist or site-rating system), a key continuity authority provides a means
of singling out phishing sites and similar short-lived traps for users, making
it necessary to operate a phishing site continuously at the same location for
a considerable amount of time in order to build up the necessary key
continuity history.  A key continuity authority therefore implements a form of
key whitelist that can be run directly alongside the (relatively ineffective)
site blacklists already used by some applications like web browsers.  Note
that in order to ensure true continuity of use key continuity authorities
should re-check keys at random intervals to ensure that a site and its key
really are around for the entire time interval and not just during the initial
check and the final phish.

      
</p>
<p>

Use of an external key continuity authority carries with it a variety of
aplication- and situation-specific considerations such as which external
authority to trust, whether the communications need to be authenticated and/or
encrypted or not, potential privacy concerns when using an external authority,
tradeoffs of speed/throughput vs. security, and so on.  A more detailed
analysis may be found in <a class='info' href='#Perspectives'>[Perspectives]<span> (</span><span class='info'>Wendlandt, D., Andersen, D., and A. Perrig, &ldquo;Perspectives: Improving SSH-style Host Authentication with Multi-Path Probing,&rdquo; June&nbsp;2008.</span><span>)</span></a>.

        
</p>
<a name="data-formats"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4"></a><h3>4.&nbsp;
Key Continuity Data Storage</h3>

<p>

<a class='info' href='#comment.Note'>[Note]<span> (</span><span class='info'>This may be better off in its own RFC, although since it's pretty cross-jurisdictional there's no obvious domain to put it under. The main motivation for including it here is to avoid a profusion of incompatible homebrew formats, with applications having to support a mass of oddball variants in order to authenticate keys</span><span>)</span></a><a name='Note'></a>

      
</p>
<p>

Applications require a standardised means of associating hosts with keys.  The
following text-based format, inspired by the /etc/passwd format, is
recommended for easy exchange of key continuity data across applications.  The
format of the key data file using using Augmented BNF <a class='info' href='#ABNF'>[ABNF]<span> (</span><span class='info'>Crocker, D. and P. Overell, &ldquo;Augmented BNF for Syntax Specifications: ABNF,&rdquo; October&nbsp;2005.</span><span>)</span></a> is
as follows.

        </p>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
  keydata = keydef | comment | blank

  keydef = algorithm ":" key-hash ":" service ":" host ":" port rfu CRLF

  comment = "#" *(WSP / VCHAR) CRLF

  blank = *(WSP) CRLF

  algorithm = *(ALPHA / DIGIT)

  key-hash = *(HEXDIG)

  service = *(ALPHA)

  host = [wherever this is specified]

  port = *(DIGIT) / ""

  rfu = "" / ":" *(WSP / VCHAR)
</pre></div><p>


The algorithm field contains the hash/fingerprint algorithm, usually "sha1".
This allows multiple hash algorithms to be used for a fingerprint.  For
example while the current standard algorithm is SHA-1, some legacy
implementations may require MD5, and future implementations may use SHA-1
successors.

      
</p>
<p>

The key-hash field contains the hash/fingerprint of the key.  This value may
be truncated as described in section 3.  When comparing truncated hashes for
equality, the first min( hash1_length, hash2_length ) bytes of the two values
are compared.

      
</p>
<p>

The service field specifies the service or protocol that the hash/fingerprint
applies to.  For example if both a TLS and and SSH server were running on the
same host, the protocol field would be used to distinguish between the key
hashes for the two servers.

      
</p>
<p>

The host-name and (optional) host-port fields contain the host name and port
that the key corresponds to.  Typically the port is implicitly specified in
the service field, but it may also be explicitly specified here.

      
</p>
<p>

For example a typical key continuity data file might consist of:

        </p>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
  # Sample key continuity data file

  sha1:B65427F83CED23A70263F8247C8D94192F751983:tls:www.example.com:443
  sha1:17A2FE37808F3E84:ssh:ssh.example.com:22
  md5:B2071C526B19F27C:ssh:ssh.example.com:22
</pre></div><p>


The first entry contains the fingerprint of an X.509 certificate used by the
web server for www.example.com.  The second and third entries contain the
(truncated) fingerprint of the SSH key used by the server ssh.example com,
first in the standard SHA-1 format and then in the alternative MD5 format.

        
</p>
<a name="discussion"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5"></a><h3>5.&nbsp;
Discussion</h3>

<p>

The intent of this format is to follow the widely-used and recognised
/etc/passwd file format with which many users will be familiar.  The format
has been kept deliberately simple in order to avoid designing a
general-purpose security assertion language such as KeyNote
<a class='info' href='#KeyNote'>[KeyNote]<span> (</span><span class='info'>Blaze, M., Feigenbaum, J., Ioannidis, J., and A. Keromytis, &ldquo;The KeyNote Trust-Management System Version 2,&rdquo; September&nbsp;1999.</span><span>)</span></a> or SAML <a class='info' href='#SAML'>[SAML]<span> (</span><span class='info'>, &ldquo;Security Assertion Markup Language (SAML), Version 2.0,&rdquo; 2008.</span><span>)</span></a>.  While this will no
doubt not suit all users, it should suffice for most, while remaining simple
enough to encourage widespread adoption.

      
</p>
<p>

There are two options available for storing the key-continuity data, the
single-file format described above, and one entry per file.  The latter makes
it possible to use mechanisms like rsync to update individual entries/files
across systems, but leads to an explosion of hard-to-manage tiny files, each
containing a little piece of configuration data.  It also makes it impossible
to secure the configuration data via mechanisms such as PGP or S/MIME.
Finally, the number of users who would use rsync to manage these files, when
compared to the total user base, is essentially nonexistent.  For this reason
the single-file approach is preferred.

      
</p>
<a name="security"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6"></a><h3>6.&nbsp;
Security Considerations</h3>

<p>

Publishing a BCP on the topic of key/trust verification may make the authors a
lightning rod for complaints of the form "this is just pretend security, you
really need a &lt;insert sender's favourite authentication system&gt;".

      
</p>
<a name="iana"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7"></a><h3>7.&nbsp;
IANA Considerations</h3>

<p>

This document has no IANA Actions.

      
</p>
<a name="rfc.references"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.8"></a><h3>8.&nbsp;
References</h3>

<a name="rfc.references1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>8.1.&nbsp;Normative References</h3>
<table width="99%" border="0">
<tr><td class="author-text" valign="top"><a name="ABNF">[ABNF]</a></td>
<td class="author-text">Crocker, D. and P. Overell, &ldquo;<a href="http://tools.ietf.org/html/rfc4234">Augmented BNF for Syntax Specifications: ABNF</a>,&rdquo; RFC&nbsp;4234, October&nbsp;2005 (<a href="http://www.ietf.org/rfc/rfc4234.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC2119">[RFC2119]</a></td>
<td class="author-text"><a href="mailto:sob@harvard.edu">Bradner, S.</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>,&rdquo; BCP&nbsp;14, RFC&nbsp;2119, March&nbsp;1997 (<a href="ftp://ftp.isi.edu/in-notes/rfc2119.txt">TXT</a>, <a href="http://xml.resource.org/public/rfc/html/rfc2119.html">HTML</a>, <a href="http://xml.resource.org/public/rfc/xml/rfc2119.xml">XML</a>).</td></tr>
</table>

<a name="rfc.references2"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>8.2.&nbsp;Informative References</h3>
<table width="99%" border="0">
<tr><td class="author-text" valign="top"><a name="AddressHarvest">[AddressHarvest]</a></td>
<td class="author-text">Schechter, S., Jung, J., Stockwell, W., and C. McLain, &ldquo;Inoculating SSH Against Address-Harvesting,&rdquo; Proceedings of the 2006 Network and Distributed Systems Security Symposium&nbsp;2006, February&nbsp;2006.</td></tr>
<tr><td class="author-text" valign="top"><a name="Duckling1">[Duckling1]</a></td>
<td class="author-text">Stajano, F. and R. Anderson, &ldquo;The Resurrecting Duckling: Security Issues in Ad-Hoc Wireless Networking,&rdquo; Proceedings of the 7th International Workshop on Security Protocols&nbsp;1999, Springer-Verlag Lecture Notes in Computer Science&nbsp;1796, April&nbsp;1999.</td></tr>
<tr><td class="author-text" valign="top"><a name="Duckling2">[Duckling2]</a></td>
<td class="author-text">Stajano, F., &ldquo;The Resurrecting Duckling - What Next?,&rdquo; Proceedings of the 8th International Workshop on Security Protocols&nbsp;2000, Springer-Verlag Lecture Notes in Computer Science&nbsp;2133, April&nbsp;2000.</td></tr>
<tr><td class="author-text" valign="top"><a name="Fingerprints">[Fingerprints]</a></td>
<td class="author-text">&ldquo;<a href="http://www.thc.org/papers/ffp.html">Fuzzy Fingerprints: Attacking Vulnerabilities in the Human Brain</a>,&rdquo; October&nbsp;2003.</td></tr>
<tr><td class="author-text" valign="top"><a name="Hardening">[Hardening]</a></td>
<td class="author-text">Xia, H. and J. Brustoloni, &ldquo;Hardening Web Browsers Against Man-in-the-Middle and Eavesdropping Attacks,&rdquo; Proceedings of the 14th International World Wide Web Conference&nbsp;2005, May&nbsp;2005.</td></tr>
<tr><td class="author-text" valign="top"><a name="IPsec">[IPsec]</a></td>
<td class="author-text">Kent, S. and K. Seo, &ldquo;<a href="http://tools.ietf.org/html/rfc4301">Security Architecture for the Internet Protocol</a>,&rdquo; RFC&nbsp;4301, December&nbsp;2005 (<a href="http://www.ietf.org/rfc/rfc4301.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="KeyNote">[KeyNote]</a></td>
<td class="author-text">Blaze, M., Feigenbaum, J., Ioannidis, J., and A. Keromytis, &ldquo;<a href="http://tools.ietf.org/html/rfc2704">The KeyNote Trust-Management System Version 2</a>,&rdquo; RFC&nbsp;2704, September&nbsp;1999 (<a href="http://www.ietf.org/rfc/rfc2704.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="NotDead">[NotDead]</a></td>
<td class="author-text">Gutmann, P., &ldquo;PKI: It's Not Dead, Just Resting,&rdquo; IEEE Computer&nbsp;August 2002, August&nbsp;2002.</td></tr>
<tr><td class="author-text" valign="top"><a name="OpenPGP">[OpenPGP]</a></td>
<td class="author-text">Callas, J., Donnerhacke, L., Hal, H., Shaw, D., and R. Thayer, &ldquo;<a href="http://tools.ietf.org/html/rfc4880">OpenPGP Message Format</a>,&rdquo; RFC&nbsp;4880, November&nbsp;2007 (<a href="http://www.ietf.org/rfc/rfc4880.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="Perspectives">[Perspectives]</a></td>
<td class="author-text">Wendlandt, D., Andersen, D., and A. Perrig, &ldquo;Perspectives: Improving SSH-style Host Authentication with Multi-Path Probing,&rdquo; Proceedings of the 2008 USENIX Annual Technical Conference&nbsp;2008, June&nbsp;2008.</td></tr>
<tr><td class="author-text" valign="top"><a name="Phishing">[Phishing]</a></td>
<td class="author-text">Jakobsson, M., Ed. and S. Myers, Ed., &ldquo;Phishing and Countermeasures,&rdquo; 2007.</td></tr>
<tr><td class="author-text" valign="top"><a name="SAML">[SAML]</a></td>
<td class="author-text">&ldquo;<a href="http://saml.xml.org/saml-specifications">Security Assertion Markup Language (SAML), Version 2.0</a>,&rdquo; 2008.</td></tr>
<tr><td class="author-text" valign="top"><a name="SSH">[SSH]</a></td>
<td class="author-text">Ylonen, T. and C. Lonvick, &ldquo;<a href="http://tools.ietf.org/html/rfc4253">The Secure Shell (SSH) Transport Layer Protocol</a>,&rdquo; RFC&nbsp;4253, Janaury&nbsp;2006 (<a href="http://www.ietf.org/rfc/rfc4253.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="TLS">[TLS]</a></td>
<td class="author-text">Dierks, T. and E. Rescorla, &ldquo;<a href="http://tools.ietf.org/html/rfc4346">The Transport Layer Security (TLS) Protocol</a>,&rdquo; RFC&nbsp;4346, April&nbsp;2006 (<a href="http://www.ietf.org/rfc/rfc4346.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="Usability">[Usability]</a></td>
<td class="author-text">Gutmann, P., &ldquo;<a href="http://www.cs.auckland.ac.nz/~pgut001/pubs/usability.pdf">Security Usability</a>,&rdquo; September&nbsp;2008.</td></tr>
</table>

<a name="rfc.authors"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>Author's Address</h3>
<table width="99%" border="0" cellpadding="0" cellspacing="0">
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Peter Gutmann</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">University of Auckland</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Department of Computer Science</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">New Zealand</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:pgut001@cs.auckland.ac.nz">pgut001@cs.auckland.ac.nz</a></td></tr>
</table>
<a name="rfc.copyright"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>Full Copyright Statement</h3>
<p class='copyright'>
Copyright &copy; The IETF Trust (2008).</p>
<p class='copyright'>
This document is subject to the rights,
licenses and restrictions contained in BCP&nbsp;78,
and except as set forth therein,
the authors retain all their rights.</p>
<p class='copyright'>
This document and the information contained herein are provided
on an &ldquo;AS IS&rdquo; basis and THE CONTRIBUTOR,
THE ORGANIZATION HE/SHE REPRESENTS
OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY, THE IETF TRUST
AND THE INTERNET ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT
THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY
IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR
PURPOSE.</p>
<h3>Intellectual Property</h3>
<p class='copyright'>
The IETF takes no position regarding the validity or scope of any
Intellectual Property Rights or other rights that might be claimed
to pertain to the implementation or use of the technology
described in this document or the extent to which any license
under such rights might or might not be available; nor does it
represent that it has made any independent effort to identify any
such rights.
Information on the procedures with respect to
rights in RFC documents can be found in BCP&nbsp;78 and BCP&nbsp;79.</p>
<p class='copyright'>
Copies of IPR disclosures made to the IETF Secretariat and any
assurances of licenses to be made available,
or the result of an attempt made to obtain a general license or
permission for the use of such proprietary rights by implementers or
users of this specification can be obtained from the IETF on-line IPR
repository at <a href='http://www.ietf.org/ipr'>http://www.ietf.org/ipr</a>.</p>
<p class='copyright'>
The IETF invites any interested party to bring to its attention
any copyrights,
patents or patent applications,
or other
proprietary rights that may cover technology that may be required
to implement this standard.
Please address the information to the IETF at <a href='mailto:ietf-ipr@ietf.org'>ietf-ipr@ietf.org</a>.</p>
</body></html>
