<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" 
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html lang="en" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head profile="http://www.w3.org/2006/03/hcard%20http://dublincore.org/documents/2008/08/04/dc-html/">
  <meta http-equiv="Content-Type" content="text/html; charset=us-ascii" />

  <title>DomainKeys Security Tagging (DOSETA)</title>

  <style type="text/css" title="Xml2Rfc (sans serif)">
  /*<![CDATA[*/
	  a {
	  text-decoration: none;
	  }
	  a.smpl {
	  color: black;
	  }
	  a:hover {
	  text-decoration: underline;
	  }
	  a:active {
	  text-decoration: underline;
	  }
	  address {
	  margin-top: 1em;
	  margin-left: 2em;
	  font-style: normal;
	  }
	  body {
	  color: black;
	  font-family: verdana, helvetica, arial, sans-serif;
	  font-size: 10pt;
	  
	  }
	  cite {
	  font-style: normal;
	  }
	  dd {
	  margin-right: 2em;
	  }
	  dl {
	  margin-left: 2em;
	  }
	
	  ul.empty {
	  list-style-type: none;
	  }
	  ul.empty li {
	  margin-top: .5em;
	  }
	  dl p {
	  margin-left: 0em;
	  }
	  dt {
	  margin-top: .5em;
	  }
	  h1 {
	  font-size: 14pt;
	  line-height: 21pt;
	  page-break-after: avoid;
	  }
	  h1.np {
	  page-break-before: always;
	  }
	  h1 a {
	  color: #333333;
	  }
	  h2 {
	  font-size: 12pt;
	  line-height: 15pt;
	  page-break-after: avoid;
	  }
	  h3, h4, h5, h6 {
	  font-size: 10pt;
	  page-break-after: avoid;
	  }
	  h2 a, h3 a, h4 a, h5 a, h6 a {
	  color: black;
	  }
	  img {
	  margin-left: 3em;
	  }
	  li {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  ol {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  ol p {
	  margin-left: 0em;
	  }
	  p {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  pre {
	  margin-left: 3em;
	  background-color: lightyellow;
	  padding: .25em;
	  }
	  pre.text2 {
	  border-style: dotted;
	  border-width: 1px;
	  background-color: #f0f0f0;
	  width: 69em;
	  }
	  pre.inline {
	  background-color: white;
	  padding: 0em;
	  }
	  pre.text {
	  border-style: dotted;
	  border-width: 1px;
	  background-color: #f8f8f8;
	  width: 69em;
	  }
	  pre.drawing {
	  border-style: solid;
	  border-width: 1px;
	  background-color: #f8f8f8;
	  padding: 2em;
	  }
	  table {
	  margin-left: 2em;
	  }
	  table.tt {
	  vertical-align: top;
	  }
	  table.full {
	  border-style: outset;
	  border-width: 1px;
	  }
	  table.headers {
	  border-style: outset;
	  border-width: 1px;
	  }
	  table.tt td {
	  vertical-align: top;
	  }
	  table.full td {
	  border-style: inset;
	  border-width: 1px;
	  }
	  table.tt th {
	  vertical-align: top;
	  }
	  table.full th {
	  border-style: inset;
	  border-width: 1px;
	  }
	  table.headers th {
	  border-style: none none inset none;
	  border-width: 1px;
	  }
	  table.left {
	  margin-right: auto;
	  }
	  table.right {
	  margin-left: auto;
	  }
	  table.center {
	  margin-left: auto;
	  margin-right: auto;
	  }
	  caption {
	  caption-side: bottom;
	  font-weight: bold;
	  font-size: 9pt;
	  margin-top: .5em;
	  }
	
	  table.header {
	  border-spacing: 1px;
	  width: 95%;
	  font-size: 10pt;
	  color: white;
	  }
	  td.top {
	  vertical-align: top;
	  }
	  td.topnowrap {
	  vertical-align: top;
	  white-space: nowrap; 
	  }
	  table.header td {
	  background-color: gray;
	  width: 50%;
	  }
	  table.header a {
	  color: white;
	  }
	  td.reference {
	  vertical-align: top;
	  white-space: nowrap;
	  padding-right: 1em;
	  }
	  thead {
	  display:table-header-group;
	  }
	  ul.toc, ul.toc ul {
	  list-style: none;
	  margin-left: 1.5em;
	  margin-right: 0em;
	  padding-left: 0em;
	  }
	  ul.toc li {
	  line-height: 150%;
	  font-weight: bold;
	  font-size: 10pt;
	  margin-left: 0em;
	  margin-right: 0em;
	  }
	  ul.toc li li {
	  line-height: normal;
	  font-weight: normal;
	  font-size: 9pt;
	  margin-left: 0em;
	  margin-right: 0em;
	  }
	  li.excluded {
	  font-size: 0pt;
	  }
	  ul p {
	  margin-left: 0em;
	  }
	
	  .comment {
	  background-color: yellow;
	  }
	  .center {
	  text-align: center;
	  }
	  .error {
	  color: red;
	  font-style: italic;
	  font-weight: bold;
	  }
	  .figure {
	  font-weight: bold;
	  text-align: center;
	  font-size: 9pt;
	  }
	  .filename {
	  color: #333333;
	  font-weight: bold;
	  font-size: 12pt;
	  line-height: 21pt;
	  text-align: center;
	  }
	  .fn {
	  font-weight: bold;
	  }
	  .hidden {
	  display: none;
	  }
	  .left {
	  text-align: left;
	  }
	  .right {
	  text-align: right;
	  }
	  .title {
	  color: #990000;
	  font-size: 18pt;
	  line-height: 18pt;
	  font-weight: bold;
	  text-align: center;
	  margin-top: 36pt;
	  }
	  .vcardline {
	  display: block;
	  }
	  .warning {
	  font-size: 14pt;
	  background-color: yellow;
	  }
	
	
	  @media print {
	  .noprint {
		display: none;
	  }
	
	  a {
		color: black;
		text-decoration: none;
	  }
	
	  table.header {
		width: 90%;
	  }
	
	  td.header {
		width: 50%;
		color: black;
		background-color: white;
		vertical-align: top;
		font-size: 12pt;
	  }
	
	  ul.toc a::after {
		content: leader('.') target-counter(attr(href), page);
	  }
	
	  ul.ind li li a {
		content: target-counter(attr(href), page);
	  }
	
	  .print2col {
		column-count: 2;
		-moz-column-count: 2;
		column-fill: auto;
	  }
	  }
	
	  @page {
	  @top-left {
		   content: "Internet-Draft"; 
	  } 
	  @top-right {
		   content: "December 2010"; 
	  } 
	  @top-center {
		   content: "Abbreviated Title";3
	  } 
	  @bottom-left {
		   content: "Doe"; 
	  } 
	  @bottom-center {
		   content: "Expires June 2011"; 
	  } 
	  @bottom-right {
		   content: "[Page " counter(page) "]"; 
	  } 
	  }
	
	  @page:first { 
		@top-left {
		  content: normal;
		}
		@top-right {
		  content: normal;
		}
		@top-center {
		  content: normal;
		}
	  }
  /*]]>*/
  </style>

  <link href="#rfc.toc" rel="Contents">
<link href="#rfc.section.1" rel="Chapter" title="1 Introduction">
<link href="#rfc.section.1.1" rel="Chapter" title="1.1 Comments and Issues">
<link href="#rfc.section.2" rel="Chapter" title="2 Framework">
<link href="#rfc.section.2.1" rel="Chapter" title="2.1 DOSETA Architecture">
<link href="#rfc.section.2.2" rel="Chapter" title="2.2 Terminology">
<link href="#rfc.section.2.2.1" rel="Chapter" title="2.2.1 Identity">
<link href="#rfc.section.2.2.2" rel="Chapter" title="2.2.2 Actors">
<link href="#rfc.section.2.3" rel="Chapter" title="2.3 Syntax">
<link href="#rfc.section.2.3.1" rel="Chapter" title="2.3.1 Whitespace">
<link href="#rfc.section.2.3.2" rel="Chapter" title="2.3.2 Common ABNF Tokens">
<link href="#rfc.section.2.3.3" rel="Chapter" title="2.3.3 Imported ABNF Tokens">
<link href="#rfc.section.2.3.4" rel="Chapter" title="2.3.4 D-Quoted-Printable">
<link href="#rfc.section.3" rel="Chapter" title="3 DOSETA Library">
<link href="#rfc.section.3.1" rel="Chapter" title="3.1 Normalization for Transport Robustness">
<link href="#rfc.section.3.2" rel="Chapter" title="3.2 Canonicalization">
<link href="#rfc.section.3.2.1" rel="Chapter" title="3.2.1 Header Canonicalization Algorithms">
<link href="#rfc.section.3.2.2" rel="Chapter" title="3.2.2 Content Canonicalization Algorithms">
<link href="#rfc.section.3.2.3" rel="Chapter" title="3.2.3 Canonicalization Examples">
<link href="#rfc.section.3.3" rel="Chapter" title="3.3 Tag=Value Parameters">
<link href="#rfc.section.3.4" rel="Chapter" title="3.4 Key Management">
<link href="#rfc.section.3.5" rel="Chapter" title="3.5 Selectors for Keys">
<link href="#rfc.section.3.6" rel="Chapter" title="3.6 DNS Binding for Key Retrieval">
<link href="#rfc.section.3.6.1" rel="Chapter" title="3.6.1 Namespace">
<link href="#rfc.section.3.6.2" rel="Chapter" title="3.6.2 Resource Record Types for Key Storage">
<link href="#rfc.section.3.7" rel="Chapter" title="3.7 Stored Key Data">
<link href="#rfc.section.4" rel="Chapter" title="4 DOSETA H/C Signing Template">
<link href="#rfc.section.4.1" rel="Chapter" title="4.1 Cryptographic Algorithms">
<link href="#rfc.section.4.2" rel="Chapter" title="4.2 Signature Data Structure">
<link href="#rfc.section.4.3" rel="Chapter" title="4.3 Additional Tags">
<link href="#rfc.section.4.4" rel="Chapter" title="4.4 Signature Calculations">
<link href="#rfc.section.4.5" rel="Chapter" title="4.5 Signer Actions">
<link href="#rfc.section.4.5.1" rel="Chapter" title="4.5.1 Determine Whether the Data Should Be Signed and by Whom">
<link href="#rfc.section.4.5.2" rel="Chapter" title="4.5.2 Select a Private Key and Corresponding Selector Information">
<link href="#rfc.section.4.5.3" rel="Chapter" title="4.5.3 Determine the Header Fields to Sign">
<link href="#rfc.section.4.5.4" rel="Chapter" title="4.5.4 Compute the Message Signature">
<link href="#rfc.section.4.5.5" rel="Chapter" title="4.5.5 Insert the DOSETA&#8209;Signature Header Field">
<link href="#rfc.section.4.6" rel="Chapter" title="4.6 Verifier Actions">
<link href="#rfc.section.4.6.1" rel="Chapter" title="4.6.1 Extract Signatures from the Message">
<link href="#rfc.section.4.6.2" rel="Chapter" title="4.6.2 Validate the Signature Header Field">
<link href="#rfc.section.4.6.3" rel="Chapter" title="4.6.3 Get the Public Key">
<link href="#rfc.section.4.6.4" rel="Chapter" title="4.6.4 Compute the Verification">
<link href="#rfc.section.4.6.5" rel="Chapter" title="4.6.5 Communicate Verification Results">
<link href="#rfc.section.4.6.6" rel="Chapter" title="4.6.6 Interpret Results/Apply Local Policy">
<link href="#rfc.section.4.7" rel="Chapter" title="4.7 Requirements for Tailoring the Signing Service">
<link href="#rfc.section.5" rel="Chapter" title="5 Semantics of Multiple Signatures">
<link href="#rfc.section.5.1" rel="Chapter" title="5.1 Example Scenarios">
<link href="#rfc.section.5.2" rel="Chapter" title="5.2 Interpretation">
<link href="#rfc.section.6" rel="Chapter" title="6 DOSETA Claims Registry Definition">
<link href="#rfc.section.7" rel="Chapter" title="7 Considerations">
<link href="#rfc.section.7.1" rel="Chapter" title="7.1 IANA Considerations">
<link href="#rfc.section.7.1.1" rel="Chapter" title="7.1.1 DKIM Registries">
<link href="#rfc.section.7.1.2" rel="Chapter" title="7.1.2 Claims Registry">
<link href="#rfc.section.7.2" rel="Chapter" title="7.2 Security Considerations">
<link href="#rfc.references" rel="Chapter" title="8 References">
<link href="#rfc.references.1" rel="Chapter" title="8.1 Normative References">
<link href="#rfc.references.2" rel="Chapter" title="8.2 Informative References">
<link href="#rfc.appendix.Appendix%20A" rel="Chapter" title="Appendix A Creating a Public Key">
<link href="#rfc.appendix.Appendix%20B" rel="Chapter" title="Appendix B Acknowledgements">
<link href="#rfc.appendix.Appendix%20C" rel="Chapter" title="Appendix C Example -- DKIM Using DOSETA">
<link href="#rfc.appendix.Appendix%20C.1" rel="Chapter" title="Appendix C.1 Signing and Verification Protocol">
<link href="#rfc.appendix.Appendix%20C.2" rel="Chapter" title="Appendix C.2 Extensions to DOSETA Template">
<link href="#rfc.appendix.Appendix%20C.2.1" rel="Chapter" title="Appendix C.2.1 Signature Data Structure">
<link href="#rfc.appendix.Appendix%20C.2.1.1" rel="Chapter" title="Appendix C.2.1.1 Content Length Limits">
<link href="#rfc.appendix.Appendix%20C.2.1.2" rel="Chapter" title="Appendix C.2.1.2 Signature Verification">
<link href="#rfc.appendix.Appendix%20C.2.2" rel="Chapter" title="Appendix C.2.2 Stored Key Data">
<link href="#rfc.authors" rel="Chapter">


  <meta name="generator" content=
  "http://greenbytes.de/tech/webdav/rfc2629.xslt, Revision 1.539, 2011-01-02 17:13:00, XSLT vendor: SAXON 6.5.5 from Michael Kay http://saxon.sf.net/" />
  <link rel="schema.dct" href="http://purl.org/dc/terms/" />
  <meta name="dct.creator" content="Doe, J." />
  <meta name="dct.identifier" content="urn:ietf:id:draft-sample-input-00" />
  <meta name="dct.issued" scheme="ISO8601" content="2010-12" />
  
  <meta name="dct.abstract" content="DomainKeys Security Tagging (DOSETA) is a component mechanism that enables easy development of security-related services, such as for authentication or encryption. It uses self-certifying keys based on domain names. The domain name owner can be any actor involved in the handling of the data, such as the author's organization, a server operator or one of their agents. The DOSETA Library provides a collection of common capabilities, including canonicalization, parameter tagging and key retrieval. The DOSETA Signing Template creates common framework for a signature of data that are in a "header/content" form. Defining the meaning of a signature is the responsibility of the service that incorporates DOSETA. Data security is enforced through the use of cryptographic algorithms. " />
  <meta name="description" content="DomainKeys Security Tagging (DOSETA) is a component mechanism that enables easy development of security-related services, such as for authentication or encryption. It uses self-certifying keys based on domain names. The domain name owner can be any actor involved in the handling of the data, such as the author's organization, a server operator or one of their agents. The DOSETA Library provides a collection of common capabilities, including canonicalization, parameter tagging and key retrieval. The DOSETA Signing Template creates common framework for a signature of data that are in a "header/content" form. Defining the meaning of a signature is the responsibility of the service that incorporates DOSETA. Data security is enforced through the use of cryptographic algorithms. " />
  <meta name="keywords" content="" />

</head>

<body>

  <table class="header">
    <tbody>
    
    	<tr>
<td class="left">Network Working Group</td>
<td class="right">D. Crocker</td>
</tr>
<tr>
<td class="left">Internet-Draft</td>
<td class="right">Brandenburg InternetWorking</td>
</tr>
<tr>
<td class="left">Intended status: Informational</td>
<td class="right">M. Kucherawy</td>
</tr>
<tr>
<td class="left">Expires: January 13, 2012</td>
<td class="right">Cloudmark</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">July 12, 2011</td>
</tr>

    	
    </tbody>
  </table>

  <p class="title">DomainKeys Security Tagging (DOSETA)<br />
  <span class="filename">draft-crocker-doseta-base-03</span></p>
  
  <h1 id="rfc.abstract"><a href="#rfc.abstract">Abstract</a></h1>
<p>DomainKeys Security Tagging (DOSETA) is a component mechanism that enables easy development of security-related services, such as for authentication or encryption. It uses self-certifying keys based on domain names. The domain name owner can be any actor involved in the handling of the data, such as the author's organization, a server operator or one of their agents. The DOSETA Library provides a collection of common capabilities, including canonicalization, parameter tagging and key retrieval. The DOSETA Signing Template creates common framework for a signature of data that are in a "header/content" form. Defining the meaning of a signature is the responsibility of the service that incorporates DOSETA. Data security is enforced through the use of cryptographic algorithms. </p>
<h1 id="rfc.status"><a href="#rfc.status">Status of this Memo</a></h1>
<p>This Internet-Draft is submitted in full conformance with the provisions of BCP 78 and BCP 79.</p>
<p>Internet-Drafts are working documents of the Internet Engineering Task Force (IETF).  Note that other groups may also distribute working documents as Internet-Drafts.  The list of current Internet- Drafts is at http://datatracker.ietf.org/drafts/current/.</p>
<p>Internet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other documents at any time.  It is inappropriate to use Internet-Drafts as reference material or to cite them other than as "work in progress."</p>
<p>This Internet-Draft will expire on January 13, 2012.</p>
<h1 id="rfc.copyrightnotice"><a href="#rfc.copyrightnotice">Copyright Notice</a></h1>
<p>Copyright (c) 2011 IETF Trust and the persons identified as the document authors.  All rights reserved.</p>
<p>This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document.  Please review these documents carefully, as they describe your rights and restrictions with respect to this document.</p>

  
  <hr class="noprint" />
  <h1 class="np" id="rfc.toc"><a href="#rfc.toc">Table of Contents</a></h1>
  <ul class="toc">

  	<li>1.   <a href="#rfc.section.1">Introduction</a>
</li>
<li>1.1.   <a href="#rfc.section.1.1">Comments and Issues</a>
</li>
<li>2.   <a href="#rfc.section.2">Framework</a>
</li>
<li>2.1.   <a href="#rfc.section.2.1">DOSETA Architecture</a>
</li>
<li>2.2.   <a href="#rfc.section.2.2">Terminology</a>
</li>
<li>2.2.1.   <a href="#rfc.section.2.2.1">Identity</a>
</li>
<li>2.2.2.   <a href="#rfc.section.2.2.2">Actors</a>
</li>
<li>2.3.   <a href="#rfc.section.2.3">Syntax</a>
</li>
<li>2.3.1.   <a href="#rfc.section.2.3.1">Whitespace</a>
</li>
<li>2.3.2.   <a href="#rfc.section.2.3.2">Common ABNF Tokens</a>
</li>
<li>2.3.3.   <a href="#rfc.section.2.3.3">Imported ABNF Tokens</a>
</li>
<li>2.3.4.   <a href="#rfc.section.2.3.4">D-Quoted-Printable</a>
</li>
<li>3.   <a href="#rfc.section.3">DOSETA Library</a>
</li>
<li>3.1.   <a href="#rfc.section.3.1">Normalization for Transport Robustness</a>
</li>
<li>3.2.   <a href="#rfc.section.3.2">Canonicalization</a>
</li>
<li>3.2.1.   <a href="#rfc.section.3.2.1">Header Canonicalization Algorithms</a>
</li>
<li>3.2.2.   <a href="#rfc.section.3.2.2">Content Canonicalization Algorithms</a>
</li>
<li>3.2.3.   <a href="#rfc.section.3.2.3">Canonicalization Examples</a>
</li>
<li>3.3.   <a href="#rfc.section.3.3">Tag=Value Parameters</a>
</li>
<li>3.4.   <a href="#rfc.section.3.4">Key Management</a>
</li>
<li>3.5.   <a href="#rfc.section.3.5">Selectors for Keys</a>
</li>
<li>3.6.   <a href="#rfc.section.3.6">DNS Binding for Key Retrieval</a>
</li>
<li>3.6.1.   <a href="#rfc.section.3.6.1">Namespace</a>
</li>
<li>3.6.2.   <a href="#rfc.section.3.6.2">Resource Record Types for Key Storage</a>
</li>
<li>3.7.   <a href="#rfc.section.3.7">Stored Key Data</a>
</li>
<li>4.   <a href="#rfc.section.4">DOSETA H/C Signing Template</a>
</li>
<li>4.1.   <a href="#rfc.section.4.1">Cryptographic Algorithms</a>
</li>
<li>4.2.   <a href="#rfc.section.4.2">Signature Data Structure</a>
</li>
<li>4.3.   <a href="#rfc.section.4.3">Additional Tags</a>
</li>
<li>4.4.   <a href="#rfc.section.4.4">Signature Calculations</a>
</li>
<li>4.5.   <a href="#rfc.section.4.5">Signer Actions</a>
</li>
<li>4.5.1.   <a href="#rfc.section.4.5.1">Determine Whether the Data Should Be Signed and by Whom</a>
</li>
<li>4.5.2.   <a href="#rfc.section.4.5.2">Select a Private Key and Corresponding Selector Information</a>
</li>
<li>4.5.3.   <a href="#rfc.section.4.5.3">Determine the Header Fields to Sign</a>
</li>
<li>4.5.4.   <a href="#rfc.section.4.5.4">Compute the Message Signature</a>
</li>
<li>4.5.5.   <a href="#rfc.section.4.5.5">Insert the DOSETA&#8209;Signature Header Field</a>
</li>
<li>4.6.   <a href="#rfc.section.4.6">Verifier Actions</a>
</li>
<li>4.6.1.   <a href="#rfc.section.4.6.1">Extract Signatures from the Message</a>
</li>
<li>4.6.2.   <a href="#rfc.section.4.6.2">Validate the Signature Header Field</a>
</li>
<li>4.6.3.   <a href="#rfc.section.4.6.3">Get the Public Key</a>
</li>
<li>4.6.4.   <a href="#rfc.section.4.6.4">Compute the Verification</a>
</li>
<li>4.6.5.   <a href="#rfc.section.4.6.5">Communicate Verification Results</a>
</li>
<li>4.6.6.   <a href="#rfc.section.4.6.6">Interpret Results/Apply Local Policy</a>
</li>
<li>4.7.   <a href="#rfc.section.4.7">Requirements for Tailoring the Signing Service</a>
</li>
<li>5.   <a href="#rfc.section.5">Semantics of Multiple Signatures</a>
</li>
<li>5.1.   <a href="#rfc.section.5.1">Example Scenarios</a>
</li>
<li>5.2.   <a href="#rfc.section.5.2">Interpretation</a>
</li>
<li>6.   <a href="#rfc.section.6">DOSETA Claims Registry Definition</a>
</li>
<li>7.   <a href="#rfc.section.7">Considerations</a>
</li>
<li>7.1.   <a href="#rfc.section.7.1">IANA Considerations</a>
</li>
<li>7.1.1.   <a href="#rfc.section.7.1.1">DKIM Registries</a>
</li>
<li>7.1.2.   <a href="#rfc.section.7.1.2">Claims Registry</a>
</li>
<li>7.2.   <a href="#rfc.section.7.2">Security Considerations</a>
</li>
<li>8.   <a href="#rfc.references">References</a>
</li>
<li>8.1.   <a href="#rfc.references.1">Normative References</a>
</li>
<li>8.2.   <a href="#rfc.references.2">Informative References</a>
</li>
<li>Appendix A.   <a href="#rfc.appendix.Appendix%20A">Creating a Public Key</a>
</li>
<li>Appendix B.   <a href="#rfc.appendix.Appendix%20B">Acknowledgements</a>
</li>
<li>Appendix C.   <a href="#rfc.appendix.Appendix%20C">Example -- DKIM Using DOSETA</a>
</li>
<li>Appendix C.1.   <a href="#rfc.appendix.Appendix%20C.1">Signing and Verification Protocol</a>
</li>
<li>Appendix C.2.   <a href="#rfc.appendix.Appendix%20C.2">Extensions to DOSETA Template</a>
</li>
<li>Appendix C.2.1.   <a href="#rfc.appendix.Appendix%20C.2.1">Signature Data Structure</a>
</li>
<li>Appendix C.2.1.1.   <a href="#rfc.appendix.Appendix%20C.2.1.1">Content Length Limits</a>
</li>
<li>Appendix C.2.1.2.   <a href="#rfc.appendix.Appendix%20C.2.1.2">Signature Verification</a>
</li>
<li>Appendix C.2.2.   <a href="#rfc.appendix.Appendix%20C.2.2">Stored Key Data</a>
</li>
<li><a href="#rfc.authors">Authors' Addresses</a>
</li>


  </ul>

  <h1 id="rfc.section.1">
<a href="#rfc.section.1">1.</a> Introduction</h1>
<p id="rfc.section.1.p.1">DomainKeys Security Tagging (DOSETA) is a component mechanism enabling development of security-related services, such as for authentication or encryption; it uses self-certifying keys based on domain names <a href="#RFC1034">[RFC1034]</a>. The domain name owner can be any actor involved in the handling of the data, such as the author's organization, a server operator or one of their agents. The DOSETA Library provides a collection of common capabilities, including canonicalization, parameter tagging and key retrieval. The DOSETA Signing Template creates common framework for signing data that are in a "header/content" form. Defining the intended meaning of a signature is the responsibility of the service that incorporates DOSETA. Data security is enforced through the use of cryptographic algorithms. </p>
<p id="rfc.section.1.p.2">The approach taken by DOSETA differs from previous approaches to data signing -- such as, Secure/Multipurpose Internet Mail Extensions (S/MIME) <a href="#RFC1847">[RFC1847]</a>, OpenPGP <a href="#RFC4880">[RFC4880]</a> -- in that: </p>

<ul>
<li>The message signature can be packaged independently of the data it is signing, so that neither human viewers of the data nor existing data handling software is confused by security-related content appearing in the Content.</li>
<li>There is no dependency on having public and private key pairs being issued by well-known, trusted certificate authorities. </li>
<li>There is no dependency on the deployment of any new Internet protocols or services for public key distribution or revocation.</li>
<li>Specific security services can be limited to those needed by the service using them.</li>
</ul>
<p id="rfc.section.1.p.3">DOSETA: </p>

<ul>
<li>enables compatibility with the existing data handling infrastructure and is transparent to the fullest extent possible</li>
<li>requires minimal new infrastructure</li>
<li>can support a variety of implementation configurations, in order to reduce deployment time</li>
<li>can be deployed incrementally</li>
<li>allows delegation of signing to third parties</li>
</ul>
<p id="rfc.section.1.p.4">DOSETA derives from Domain Keys Identified Mail (DKIM) <a href="#RFC5672">[RFC5672]</a> and has extracted the core portions of the its signing specification <a href="#DKIMSign">[DKIMSign]</a>, so that they can be applied to other security-related services. For example, the core could support a DKIM-like signing service for web pages, and it could support a data ion mechanism using the same DNS-based, self-certified key service as DKIM. </p>
<p id="rfc.section.1.p.5">DOSETA features include: </p>

<ul class="empty"><li><dl>
<dt>Identity:  </dt>
<dd style="margin-left: 8">DOSETA distinguishes the identity of the DOSETA signature's producer from that of any other identifier associated with the data, such as the data's purported author. In particular, the DOSETA header field includes the DOSETA Domain Identifier (DDI), per <a href="#identitydefs">Section 2.2.1</a>. DOSETA consumers can use the DDI to decide how they want to process the data.  The DDI can be directly included in the attributes of the data or can be recorded elsewhere. <dl>
<dt>NOTE:  </dt>
<dd style="margin-left: 8">DOSETA does not, itself, specify that the identity it uses is required to match any other associated identifier. Those other identifiers already carry their own semantics which might conflict with the use of the identifier needed by DOSETA. However a particular DOSETA-based security service might choose to add constraints on the choice of identifier, such as having it match another identifier that is associated with the data.</dd>
</dl>
</dd>
<dt>Scalability:  </dt>
<dd style="margin-left: 8">DOSETA is designed to easily support the extreme scaling requirements that characterize Internet data identification. </dd>
<dt>Key Management:  </dt>
<dd style="margin-left: 8">DOSETA differs from traditional hierarchical public-key systems in that no Certificate Authority infrastructure is required; the verifier requests the public key from a repository under the domain name associated with the use of DOSETA directly, rather than requiring consultation of a certificate authority. That is, DOSETA provides self-certifying keys.</dd>
<dt></dt>
<dd style="margin-left: 8">The DNS is the initial mechanism for DOSETA public keys. Thus, DOSETA currently depends on DNS administration and the security of the DNS system.  DOSETA is designed to be extensible to other key fetching services as they become available.</dd>
<dt>Data Integrity:  </dt>
<dd style="margin-left: 8">When DOSETA is used to sign data -- independent of the semantics of that signature -- there is a computed hash of some or all of the data that ensures detection of changes to that data, between the times of signing and verifying. </dd>
</dl></li></ul>
<h1 id="rfc.section.1.1">
<a href="#rfc.section.1.1">1.1.</a> Comments and Issues</h1>
<p></p>

<dl>
<dt>[RFC EDITOR]  </dt>
<dd style="margin-left: 8">Remove this sub-section prior to publication.</dd>
</dl>

<p> </p>
<p id="rfc.section.1.1.p.2">Possible applications:</p>

<ul>
<li>JSON structure</li>
<li>XMPP message</li>
<li>XML object</li>
<li>vCard</li>
<li>vCal</li>
<li>Web page signing?</li>
<li>Web ad authentication</li>
<li>Handle System</li>
</ul>

<p> </p>
<div id="#rfc.figure.1"></div>
<pre>http://www.trusteddomain.org/mailman/listinfo/doseta-discuss</pre>
<p></p>

<dl>
<dt>Discussion Venue:</dt>
<dd style="margin-left: 8">Discussion of this draft should take place on the doseta-discuss mailing list. It is located at:<ul class="empty"><li></ul>
<p> </p>
</dd>
</dl>

<p> </p>
<h1 id="rfc.section.2">
<a href="#rfc.section.2">2.</a> <a href="#framework" id="framework">Framework</a>
</h1>
<p id="rfc.section.2.p.1">This section provides the technical background for the remainder of the document. </p>
<h1 id="rfc.section.2.1">
<a href="#rfc.section.2.1">2.1.</a> <a href="#arch" id="arch">DOSETA Architecture</a>
</h1>
<p id="rfc.section.2.1.p.1">As component technology, DOSETA is meant to be incorporated into a service. This specification provides an underlying set of common features and a template for using them to provide a signing service, such as for authenticating an identifier.  Hence, the pieces can be depicted as follows, with DKIM being shown as a specific service that incorporates DOSETA:</p>
<div id="#rfc.figure.2"></div>
<pre>
    +--------+       +----------+           +-----------------+
    |  DKIM  |       | MIMEAUTH |           | Message Privacy |
    +---+----+       +-----+----+           +--------+--------+
        |                  |                         |
 ++=====V==================V========++               |
 ||                                 ||               |
 || Header/Content Signing Template ||               |
 ||                                 ||               |
 ++================+================++               |
                   |                                 |
++=================V=================================V============++
||                                                                ||
||                      D O S E T A     L I B R A R Y             ||
|| +------------------+ +------------+ +-------------+ +--------+ ||
|| |                  | | Key        | | Parameter   | | Tags   | ||
|| | Canonicalization | | Management | | Format      | | Header | ||
|| |                  | | (DNS)      | | (tag=value) | | Field  | ||
|| +------------------+ +------------+ +-------------+ +--------+ ||
||                                                                ||
++================================================================++
                  </pre>
<p><a href="#DKIMSign">[DKIMSign]</a>. MIMEAUTH is an exemplar use of DOSETA, specified in <a href="#mimeauth">[mimeauth]</a>. Message Privacy is a generic term, indicating any service that provides encryption; it is expected that such a service can use the DOSETA core library, but not take advantage of the DOSETA signing template. </p>
<p id="rfc.section.2.1.p.3">The library comprises:</p>

<dl>
<dt>Canonicalization: </dt>
<dd style="margin-left: 8">This ensures common data representation and robustness against some forms of data modification during transit. It is discussed in <a href="#canon">Section 3.2</a> and <a href="#normalize">Section 3.1</a>.</dd>
<dt>Key Management: </dt>
<dd style="margin-left: 8">This covers the mechanisms for discovering and obtaining signature key information by a verifier. It is discussed in <a href="#keymgmt">Section 3.4</a>, <a href="#selectors">Section 3.5</a>, and <a href="#dnsbind">Section 3.6</a>.</dd>
<dt>Format: </dt>
<dd style="margin-left: 8">This describes a simple syntax for encoding parametric information and is discussed in <a href="#tagval">Section 3.3</a>.</dd>
<dt>Tags: </dt>
<dd style="margin-left: 8">These are common parameters for the stored public key record, defined in <a href="#keydata">Section 3.7</a> and the common parameters for the signature record that is associated with the signed data, defined in <a href="#signeddatastruct">Section 4.2</a>.</dd>
</dl>

<p> </p>
<h1 id="rfc.section.2.2">
<a href="#rfc.section.2.2">2.2.</a> <a href="#terminology" id="terminology">Terminology</a>
</h1>
<p id="rfc.section.2.2.p.1">Within the specification, the label "[TEMPLATE]" is used to indicate actions that are required for tailoring the use of DOSETA into a specific service.</p>
<p id="rfc.section.2.2.p.2">The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in <a href="#RFC2119">[RFC2119]</a>.</p>
<p id="rfc.section.2.2.p.3">Additional terms for this document are divided among Identity and Actors.</p>
<h1 id="rfc.section.2.2.1">
<a href="#rfc.section.2.2.1">2.2.1.</a> <a href="#identitydefs" id="identitydefs">Identity</a>
</h1>
<p></p>

<dl>
<dt>Identity:  </dt>
<dd style="margin-left: 8">A person, role, or organization. In the context of DOSETA, examples include author, author's organization, an ISP along the handling path, an independent trust assessment service, and a data processing intermediary operator.</dd>
<dt>Identifier:  </dt>
<dd style="margin-left: 8">A label that refers to an identity. The primary example is a domain name.</dd>
<dt>DOSETA Domain Identifier (DDI):  </dt>
<dd style="margin-left: 8">A single domain name that serves as an identifier, referring to the DOSETA key owner's identity. The DDI is specified in <a href="#signeddatastruct">Section 4.2</a>. Within this specification, the name has only basic domain name semantics; any possible owner-specific semantics MUST be provided in the specification that incorporates DOSETA. </dd>
<dt>Identity Assessor:  </dt>
<dd style="margin-left: 8">A module that consumes DOSETA's payload output. The module is dedicated to the assessment of the delivered identifier. Optionally, other DOSETA (and non-DOSETA) values can also be delivered to this module as well as to a more general message evaluation filtering engine.  However, this additional activity is outside the scope of the DOSETA specification. </dd>
</dl>

<p> </p>
<h1 id="rfc.section.2.2.2">
<a href="#rfc.section.2.2.2">2.2.2.</a> Actors</h1>
<p></p>

<dl>
<dt>Producer:  </dt>
<dd style="margin-left: 8">An element in the data handling system that produces a cryptographic encoding, on behalf of a domain, is referred to as a Producer. For example, a signer is a type of producer.</dd>
<dt>Consumer:  </dt>
<dd style="margin-left: 8">An element in the data handling system that processes an existing cryptographic encoding, on behalf of a domain, is referred to as a consumer. For example, a verifier is a type of consumer.</dd>
<dt>Signer:  </dt>
<dd style="margin-left: 8">An element in the data handling system that creates a digital signature, on behalf of a domain, is referred to as a signer. This element specifies an actor that is a type of DOSETA producer.  The actor might operate through a client, server or other agent such as a reputation service. The core requirement is that the data MUST be signed before it leaves the control of the signer's administrative domain. </dd>
<dt>Verifier:  </dt>
<dd style="margin-left: 8">An element in the data handling system that verifies signatures is referred to as a verifier. This element is a consumer of a signing service. It might be a client, server, or other agent, such as a reputation service. In most cases it is expected that a verifier will be close to an end user of the data or some consuming agent such as a data processing intermediary. </dd>
</dl>

<p> </p>
<h1 id="rfc.section.2.3">
<a href="#rfc.section.2.3">2.3.</a> Syntax</h1>
<p id="rfc.section.2.3.p.1">This section specifies foundational syntactic constructs used in the remainder of the document.</p>
<p id="rfc.section.2.3.p.2">Syntax descriptions use Augmented BNF (ABNF) <a href="#RFC5234">[RFC5234]</a>. </p>
<h1 id="rfc.section.2.3.1">
<a href="#rfc.section.2.3.1">2.3.1.</a> <a href="#whitespace" id="whitespace">Whitespace</a>
</h1>
<p id="rfc.section.2.3.1.p.1">There are three forms of whitespace: </p>

<ul class="empty"><li><dl>
<dt>WSP:  </dt>
<dd style="margin-left: 8">represents simple whitespace, that is, a space or a tab character (formally defined in <a href="#RFC5234">[RFC5234]</a>).</dd>
<dt>LWSP:  </dt>
<dd style="margin-left: 8">is linear whitespace, defined as WSP plus CRLF (formally defined in <a href="#RFC5234">[RFC5234]</a>).</dd>
<dt>FWS:  </dt>
<dd style="margin-left: 8">is folding whitespace. It allows multiple lines to be joined with each a separated by a sequence having CRLF followed by at least one whitespace.</dd>
</dl></li></ul>
<div id="#rfc.figure.3"></div>
<p id="rfc.section.2.3.1.p.2">The formal syntax for these are (WSP and LWSP are given for information only): </p>

<p>ABNF:</p>
<pre>WSP  =  SP / HTAB
LWSP =  *(WSP / CRLF WSP)
FWS  =  [*WSP CRLF] 1*WSP</pre>
<ul class="empty"><li></ul>

<p> </p>
<p id="rfc.section.2.3.1.p.3">The definition of FWS is identical to that in <a href="#RFC5322">[RFC5322]</a> except for the exclusion of obs-FWS.</p>
<h1 id="rfc.section.2.3.2">
<a href="#rfc.section.2.3.2">2.3.2.</a> Common ABNF Tokens</h1>
<div id="#rfc.figure.4"></div>
<p id="rfc.section.2.3.2.p.1">The following tokens are used in this document: </p>

<p>ABNF:</p>
<pre>hyphenated-word =  ALPHA 
                   [ *(ALPHA / DIGIT / "-") 
                   (ALPHA / DIGIT) ]
ALPHADIGITPS    =  (ALPHA / DIGIT / "+" / "/")
base64string    =  ALPHADIGITPS *([FWS] ALPHADIGITPS)
                   [ [FWS] "=" [ [FWS] "=" ] ] 
hdr-name        =  field-name
qp-hdr-value    =  D-quoted-printable
                        ; with "|" encoded</pre>
<ul class="empty"><li></ul>

<p> </p>
<h1 id="rfc.section.2.3.3">
<a href="#rfc.section.2.3.3">2.3.3.</a> Imported ABNF Tokens</h1>
<p id="rfc.section.2.3.3.p.1">The following tokens are imported from other RFCs as noted.  Those RFCs SHOULD be considered definitive.</p>
<p id="rfc.section.2.3.3.p.2">From <a href="#RFC5321">[RFC5321]</a>: </p>

<ul class="empty"><li><dl>
<dt>&lt;local-part&gt;  </dt>
<dd style="margin-left: 8">Implementation Warning: This permits quoted strings)</dd>
<dt>&lt;sub-domain&gt;</dt>
<dd style="margin-left: 8"></dd>
</dl></li></ul>
<p id="rfc.section.2.3.3.p.3">From <a href="#RFC5322">[RFC5322]</a>: </p>

<ul class="empty"><li><dl>
<dt>&lt;field-name&gt;  </dt>
<dd style="margin-left: 8">(name of a header field)</dd>
</dl></li></ul>
<p id="rfc.section.2.3.3.p.4">From <a href="#RFC2045">[RFC2045]</a>: </p>

<ul class="empty"><li><dl>
<dt>&lt;qp-section&gt;  </dt>
<dd style="margin-left: 8">a single line of quoted-printable-encoded text</dd>
<dt>&lt;hex-octet&gt; </dt>
<dd style="margin-left: 8">a quoted-printable encoded octet)</dd>
</dl></li></ul>

<p> </p>
<p></p>

<dl>
<dt>NOTE:  </dt>
<dd style="margin-left: 8">Be aware that the ABNF in <a href="#RFC2045">[RFC2045]</a> does not obey the rules of <a href="#RFC5234">[RFC5234]</a> and MUST be interpreted accordingly, particularly as regards case folding.</dd>
</dl>

<p> </p>
<p id="rfc.section.2.3.3.p.6">Other tokens not defined herein are imported from <a href="#RFC5234">[RFC5234]</a>. These are intuitive primitives such as SP, HTAB, WSP, ALPHA, DIGIT, CRLF, etc.</p>
<h1 id="rfc.section.2.3.4">
<a href="#rfc.section.2.3.4">2.3.4.</a> <a href="#D-quoted-printable" id="D-quoted-printable">D-Quoted-Printable</a>
</h1>
<p id="rfc.section.2.3.4.p.1">The D-Quoted-Printable encoding syntax resembles that described in Quoted-Printable <a href="#RFC2045">[RFC2045]</a>, Section 6.7: </p>

<ul>
<li>Any character MAY be encoded as an "=" followed by two hexadecimal digits from the alphabet "0123456789ABCDEF" (no lowercase characters permitted) representing the hexadecimal-encoded integer value of that character.</li>
<li>All control characters (those with values &lt; %x20), 8-bit characters (values &gt; %x7F), and the characters DEL (%x7F), SPACE (%x20), and semicolon (";", %x3B) MUST be encoded.</li>
<li>All whitespace, including SPACE, CR, and LF characters, MUST be encoded.</li>
<li>After encoding, FWS MAY be added at arbitrary locations in order to avoid excessively long lines; such whitespace is NOT part of the value, and MUST be removed before decoding.</li>
</ul>
<div id="#rfc.figure.5"></div>
<p id="rfc.section.2.3.4.p.2">The formal syntax for D-Quoted-Printable is: </p>

<p>ABNF:</p>
<pre>D-quoted-printable =  *(FWS / hex-octet / D-safe-char)
                         ; hex-octet is from RFC2045
D-safe-char        =  %x21-3A / %x3C / %x3E-7E 
                         ; '!' - ':', '&lt;', '&gt;' - '~'
                         ; Characters not listed as "mail-safe"
                         ; in [RFC2049] are also not
                         ; recommended.</pre>
<ul class="empty"><li></ul>
<p id="rfc.section.2.3.4.p.3">D-Quoted-Printable differs from Quoted-Printable as defined in <a href="#RFC2045">[RFC2045]</a> in several important ways: </p>

<ol>
<li>Whitespace in the input text, including CR and LF, MUST be encoded. <a href="#RFC2045">[RFC2045]</a> does not require such encoding, and does not permit encoding of CR or LF characters that are part of a CRLF line break.</li>
<li>Whitespace in the encoded text is ignored. This is to allow tags encoded using D-Quoted-Printable to be wrapped as needed. In particular, <a href="#RFC2045">[RFC2045]</a> requires that line breaks in the input be represented as physical line breaks; that is not the case here.</li>
<li>The "soft line break" syntax ("=" as the last non-whitespace character on the line) does not apply.</li>
<li>D-Quoted-Printable does not require that encoded lines be no more than 76 characters long (although there might be other requirements depending on the context in which the encoded text is being used).</li>
</ol>
<h1 id="rfc.section.3">
<a href="#rfc.section.3">3.</a> <a href="#library" id="library">DOSETA Library</a>
</h1>
<p id="rfc.section.3.p.1">DOSETA's library of functional components is distinguished by a DNS-based, self-certifying public key mechanism, common data normalization and canonicalization algorithms, and a common parameter encoding mechanism.</p>
<h1 id="rfc.section.3.1">
<a href="#rfc.section.3.1">3.1.</a> <a href="#normalize" id="normalize">Normalization for Transport Robustness</a>
</h1>
<p id="rfc.section.3.1.p.1">Some messages, particularly those using 8-bit characters, are subject to modification during transit, notably from conversion to 7-bit form. Such conversions will break DOSETA signatures.  Similarly, data that is not compliant with its associated standard, might be subject to corrective efforts intermediaries. See Section 8 of <a href="#RFC4409">[RFC4409]</a> for examples of changes that are commonly made to email. Such "corrections" might break DOSETA signatures or have other undesirable effects. </p>
<p id="rfc.section.3.1.p.2">In order to minimize the chances of such breakage, signers convert the data to a suitable encoding, such as quoted-printable or base64, as described in <a href="#RFC2045">[RFC2045]</a> before signing. Specification and use of such conversions is outside the scope of DOSETA.</p>
<p id="rfc.section.3.1.p.3">If the data is submitted to a DOSETA process with any local encoding that will be modified before transmission, that modification to a canonical form MUST be done before DOSETA processing. For Text data in particular, bare CR or LF characters (used by some systems as a local line separator convention) MUST be converted to the CRLF sequences before the data is signed. Any conversion of this sort SHOULD be applied to the data actually sent to the recipient(s), not just to the version presented to the signing algorithm.</p>
<p id="rfc.section.3.1.p.4">More generally, a DOSETA producer MUST use the data as it is expected to be received by the DOSETA consumer rather than in some local or internal form.</p>
<h1 id="rfc.section.3.2">
<a href="#rfc.section.3.2">3.2.</a> <a href="#canon" id="canon">Canonicalization</a>
</h1>
<p id="rfc.section.3.2.p.1">Some data handling systems modify the original data during transit, potentially invalidating a cryptographic function. In some cases, mild modification of data can be immaterial to the validity of a DOSETA-based service. In these cases, a canonicalization algorithm that survives modest handling modification is preferred.</p>
<p id="rfc.section.3.2.p.2">In other cases, preservation of the exact, original bits is required; even minor modifications need to result in a failure.  Hence a canonicalization algorithm is needed that does not tolerate any in-transit modification of the data.</p>
<p id="rfc.section.3.2.p.3">To satisfy basic requirements, two canonicalization algorithms are defined: a "simple" algorithm that tolerates almost no modification and a "relaxed" algorithm that tolerates common modifications such as whitespace replacement and data line rewrapping.</p>
<p id="rfc.section.3.2.p.4">Data presented for canonicalization MUST already be in "network normal" format -- text is ASCII encoded, lines are separated with CRLF characters, etc.) See <a href="#normalize">Section 3.1</a> for information about normalizing data.</p>
<p id="rfc.section.3.2.p.5">Data handling systems sometimes treat different portions of text differentially and might be subject to more or less likelihood of breaking a signature. DOSETA currently covers two types of data:</p>

<ul class="empty"><li><dl>
<dt>Header:   </dt>
<dd style="margin-left: 8">Attribute:value sets, in the style of Internet Mail header fields or MIME header fields</dd>
<dt>Content:  </dt>
<dd style="margin-left: 8">Lines of ASCII text</dd>
</dl></li></ul>
<p id="rfc.section.3.2.p.6">Some DOSETA producers might be willing to accept modifications to some portions of the data, but not other portions. For DOSETA, a producer MAY specify one algorithm for the header and another for the content. </p>
<p id="rfc.section.3.2.p.7">If no canonicalization algorithm is specified, the "simple" algorithm defaults for each part. DOSETA producers MUST implement both of the base canonicalization algorithms. Because additional canonicalization algorithms might be defined in the future, producers MUST ignore any unrecognized canonicalization algorithms.</p>
<p id="rfc.section.3.2.p.8">Canonicalization simply prepares the data for presentation to the DOSETA processing algorithm. </p>

<dl>
<dt>NOTE:  </dt>
<dd style="margin-left: 8">Canonicalization operates on a copy of the data; it MUST NOT change the transmitted data in any way. Canonicalization of distinct data portions is described below.</dd>
</dl>
<h1 id="rfc.section.3.2.1">
<a href="#rfc.section.3.2.1">3.2.1.</a> <a href="#hdrcanon" id="hdrcanon">Header Canonicalization Algorithms</a>
</h1>
<p id="rfc.section.3.2.1.p.1">This section describes basic entries for the Header Canonicalization IANA registry defined in <a href="#DKIMSign">[DKIMSign]</a>, , which also applies to DOSETA header canonicalization. </p>

<dl>
<dt>simple:  </dt>
<dd style="margin-left: 8">The "simple" header canonicalization algorithm is for a set of "attribute:value" textual data structures, such as email header fields <a href="#RFC5322">[RFC5322]</a>. It does not change the original Header fields in any way. Header fields MUST be presented to the processing algorithm exactly as they are in the data being processed. In particular, header field names MUST NOT be case folded and whitespace MUST NOT be changed.</dd>
<dt>relaxed:  </dt>
<dd style="margin-left: 8">The "relaxed" header canonicalization algorithm is for a set of "attribute:value" textual data structures, such as email header fields <a href="#RFC5322">[RFC5322]</a>. It does not change the original Header fields in any way. The following steps MUST be applied in order: <ul>
<li>Convert all header field names (not the header field values) to lowercase. For example, convert "SUBJect: AbC" to "subject: AbC".</li>
<li>Unfold all header field continuation lines as described in <a href="#RFC5322">[RFC5322]</a>; in particular, lines with terminators embedded in continued header field values (that is, CRLF sequences followed by WSP) MUST be interpreted without the CRLF.  Implementations MUST NOT remove the CRLF at the end of the header field value.</li>
<li>Convert all sequences of one or more WSP characters to a single SP character. WSP characters here include those before and after a line folding boundary.</li>
<li>Delete all WSP characters at the end of each unfolded header field value.</li>
<li>Delete any WSP characters remaining before and after the colon separating the header field name from the header field value. The colon separator MUST be retained.</li>
</ul>
</dd>
</dl>
<h1 id="rfc.section.3.2.2">
<a href="#rfc.section.3.2.2">3.2.2.</a> <a href="#contentcanon" id="contentcanon">Content Canonicalization Algorithms</a>
</h1>
<div id="#rfc.figure.6"></div>
<pre>uoq1oCgLlTqpdDX/iUbLy7J1Wic=</pre>
<div id="#rfc.figure.7"></div>
<pre>frcCV1k9oG9oKj3dpUqdJg1PxRT2RSN/XKdLCPjaYaY=</pre>
<div id="#rfc.figure.8"></div>
<pre>2jmj7l5rSw0yVb/vlWAYkK/YBwk=</pre>
<div id="#rfc.figure.9"></div>
<pre>47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU=</pre>
<p id="rfc.section.3.2.2.p.1">This section describes basic entries for the Message Canonicalization IANA registry defined in <a href="#DKIMSign">[DKIMSign]</a>, which also applies to DOSETA Content. </p>

<dl>
<dt>simple:  </dt>
<dd style="margin-left: 8">The "simple" Content canonicalization algorithm is for lines of ASCII text, such as occur in the body of email <a href="#RFC5322">[RFC5322]</a>. It ignores all empty lines at the end of the Content. An empty line is a line of zero length after removal of the line terminator. If there is no Content or no trailing CRLF on the Content, a CRLF is added. It makes no other changes to the Content. In more formal terms, the "simple" Content canonicalization algorithm converts "0*CRLF" at the end of the Content to a single "CRLF".</dd>
<dt></dt>
<dd style="margin-left: 8">Note that a completely empty or missing Content is canonicalized as a single "CRLF"; that is, the canonicalized length will be 2 octets.</dd>
<dt></dt>
<dd style="margin-left: 8">The sha1 value (in base64) for an empty Content (canonicalized to a "CRLF") is: </dd>
<dt>relaxed:  </dt>
<dd style="margin-left: 8">The "relaxed" Content canonicalization algorithm is for lines of ASCII text, such as occur in the body of email <a href="#RFC5322">[RFC5322]</a>. It MUST apply the following steps (a) and (b) in order:<ol style="list-style-type: lower-alpha">
<li>Reduce whitespace: <ul>
<li>Ignore all whitespace at the end of lines.  Implementations MUST NOT remove the CRLF at the end of the line.</li>
<li>Reduce all sequences of WSP within a line to a single SP character.</li>
</ul>
</li>
<li>Ignore all empty lines at the end of the Content. "Empty line" is defined in <a href="#contentcanon">Section 3.2.2</a>. If the Content is non-empty, but does not end with a CRLF, a CRLF is added. (For email, this is only possible when using extensions to SMTP or non-SMTP transport mechanisms.)</li>
</ol>
<p> The sha1 value (in base64) for an empty Content (canonicalized to a null input) is: </p>
<dl>
<dt>NOTE: </dt>
<dd style="margin-left: 8">The relaxed Content canonicalization algorithm can enable certain types of extremely crude "ASCII Art" attacks in which a message can be conveyed, by adjusting the spacing between words. If this is a concern, the "simple" Content canonicalization algorithm is more appropriate for use.</dd>
</dl>
<p> </p>
</dd>
</dl>
<h1 id="rfc.section.3.2.3">
<a href="#rfc.section.3.2.3">3.2.3.</a> Canonicalization Examples</h1>
<p id="rfc.section.3.2.3.p.1">In the following examples, actual whitespace is used only for clarity. The actual input and output text is designated using bracketed descriptors: "&lt;SP&gt;" for a space character, "&lt;HTAB&gt;" for a tab character, and "&lt;CRLF&gt;" for a carriage-return/line-feed sequence. For example, "X &lt;SP&gt; Y" and "X&lt;SP&gt;Y" represent the same three characters.</p>
<div id="#rfc.figure.10"></div>
<p></p>

<p>Example 1: An email message reading:</p>
<pre>A: &lt;SP&gt; X &lt;CRLF&gt;
B &lt;SP&gt; : &lt;SP&gt; Y &lt;HTAB&gt;&lt;CRLF&gt;
                &lt;HTAB&gt; Z &lt;SP&gt;&lt;SP&gt;&lt;CRLF&gt;
&lt;CRLF&gt;
&lt;SP&gt; C &lt;SP&gt;&lt;CRLF&gt;
D &lt;SP&gt;&lt;HTAB&gt;&lt;SP&gt; E &lt;CRLF&gt;
&lt;CRLF&gt;
&lt;CRLF&gt;</pre>
<div id="#rfc.figure.11"></div>
<p></p>

<p>when canonicalized using relaxed canonicalization for both Header and Content results in a Header reading:</p>
<pre>a:X &lt;CRLF&gt;
b:Y &lt;SP&gt; Z &lt;CRLF&gt;</pre>
<div id="#rfc.figure.12"></div>
<p></p>

<p>and a Content reading:</p>
<pre>&lt;SP&gt; C &lt;CRLF&gt;
D &lt;SP&gt; E &lt;CRLF&gt;</pre>
<p></p>
<div id="#rfc.figure.13"></div>
<p></p>

<p>Example 2: The same message canonicalized using simple canonicalization for both Header and Content results in a header reading:</p>
<pre>A: &lt;SP&gt; X &lt;CRLF&gt;
B &lt;SP&gt; : &lt;SP&gt; Y &lt;HTAB&gt;&lt;CRLF&gt;
       &lt;HTAB&gt; Z &lt;SP&gt;&lt;SP&gt;&lt;CRLF&gt;</pre>
<div id="#rfc.figure.14"></div>
<p></p>

<p>and a Content reading:</p>
<pre>&lt;SP&gt; C &lt;SP&gt;&lt;CRLF&gt;
D &lt;SP&gt;&lt;HTAB&gt;&lt;SP&gt; E &lt;CRLF&gt;</pre>
<p></p>
<div id="#rfc.figure.15"></div>
<p></p>

<p>Example 3: When processed using relaxed Header canonicalization and simple Content canonicalization, the canonicalized version has a header of:</p>
<pre>a:X &lt;CRLF&gt;
b:Y &lt;SP&gt; Z &lt;CRLF&gt;</pre>
<div id="#rfc.figure.16"></div>
<p></p>

<p>and a Content reading:</p>
<pre>&lt;SP&gt; C &lt;SP&gt;&lt;CRLF&gt;
D &lt;SP&gt;&lt;HTAB&gt;&lt;SP&gt; E &lt;CRLF&gt;</pre>
<h1 id="rfc.section.3.3">
<a href="#rfc.section.3.3">3.3.</a> <a href="#tagval" id="tagval">Tag=Value Parameters</a>
</h1>
<p id="rfc.section.3.3.p.1">DOSETA uses a simple "tag=value" parameter syntax in several contexts, such as when representing associated cryptographic data and domain key records.</p>
<p id="rfc.section.3.3.p.2">Values are a series of strings containing either plain text, "base64" text (as defined in <a href="#RFC2045">[RFC2045]</a>, Section&#160;6.8), "qp-section" (ibid, Section&#160;6.7), or "D-quoted-printable" (as defined in Section&#160;2.6). The definition of a tag will determine the specific encoding for its associated value. Unencoded semicolon (";") characters MUST NOT occur in the tag value, since that separates tag-specs. </p>

<dl>
<dt>NOTE:  </dt>
<dd style="margin-left: 8">The "plain text" defined below, as "tag-value", only supports use of 7-bit characters.  However, it is likely that support of UTF-8 Unicode <a href="#UTF8">[UTF8]</a> data will eventually be deemed important. </dd>
</dl>
<div id="#rfc.figure.17"></div>
<p id="rfc.section.3.3.p.3">Formally the syntax rules are as follows: </p>

<p>ABNF:</p>
<pre>tag-list  =  tag-spec 0*( ";" tag-spec ) [ ";" ]
tag-spec  =  [FWS] tag-name [FWS] "=" [FWS] tag-value [FWS]
tag-name  =  ALPHA 0*ALNUMPUNC
tag-value =  [ tval 0*( 1*(WSP / FWS) tval ) ]
                ; WSP and FWS prohibited at beginning and end
tval      =  1*VALCHAR
VALCHAR   =  %x21-3A / %x3C-7E
                ; EXCLAMATION to TILDE except SEMICOLON
ALNUMPUNC =  ALPHA / DIGIT / "_"</pre>
<ul class="empty"><li></ul>

<p> </p>

<dl>
<dt>NOTE: </dt>
<dd style="margin-left: 8">WSP is allowed anywhere around tags. In particular, any WSP after the "=" and any WSP before the terminating ";" is not part of the value. However, WSP inside the value is significant.</dd>
</dl>

<p> </p>
<p id="rfc.section.3.3.p.4">Tags MUST interpret a VALCHAR as case-sensitive, unless the specific tag description of semantics specifies case insensitivity.</p>
<p id="rfc.section.3.3.p.5">Tags MUST be unique; duplicate names MUST NOT occur within a single tag-list. If a tag name does occur more than once, the entire tag-list is invalid.</p>
<p id="rfc.section.3.3.p.6">Whitespace within a value MUST be retained unless explicitly excluded by the specific tag description.</p>
<p id="rfc.section.3.3.p.7">Tag=value pairs that represent the default value MAY be included to aid legibility.</p>
<p id="rfc.section.3.3.p.8">Unrecognized tags MUST be ignored.</p>
<p id="rfc.section.3.3.p.9">Tags that have an empty value are not the same as omitted tags.  An omitted tag is treated as having the default value; a tag with an empty value explicitly designates the empty string as the value. </p>
<h1 id="rfc.section.3.4">
<a href="#rfc.section.3.4">3.4.</a> <a href="#keymgmt" id="keymgmt">Key Management</a>
</h1>
<p id="rfc.section.3.4.p.1">Applications require some level of assurance that a producer is authorized to use a cited public. Many applications achieve this by using public key certificates issued by a trusted authority. For applications with modest certification requirements, DOSETA achieves a sufficient level of security, with excellent scaling properties, by simply having the consumer query the purported producer's DNS entry (or a supported equivalent) in order to retrieve the public key. The safety of this model is increased by the use of DNSSEC <a href="#RFC4033">[RFC4033]</a> for the key records in the DNS.</p>
<p id="rfc.section.3.4.p.2">DOSETA keys might be stored in multiple types of key servers and in multiple formats. As long as the key-related information is the same and as long as the security properties of key storage and retrieval are the same, DOSETA's operation is unaffected by the actual source of a key. </p>
<div id="#rfc.figure.18"></div>
<p></p>

<p>The abstract key lookup algorithm is:</p>
<pre>public-key = D-find-key(q-val, d-val, s-val)</pre>
<ul class="empty"><li><dl>
<dt>q-val:  </dt>
<dd style="margin-left: 8">The type of the lookup, as specified in the "q" parameter (<a href="#signeddatastruct">Section 4.2</a>)</dd>
<dt>d-val:  </dt>
<dd style="margin-left: 8">The domain of the signature, as specified in the "d" parameter (<a href="#signeddatastruct">Section 4.2</a>)</dd>
<dt>s-val:  </dt>
<dd style="margin-left: 8">The selector of the lookup as specified in the "s" parameter (<a href="#signeddatastruct">Section 4.2</a>)</dd>
<dt>D-find-key:  </dt>
<dd style="margin-left: 8">A function that uses q-val to determine the specific details for accessing the desired stored Key record.</dd>
</dl></li></ul>

<p> </p>
<p id="rfc.section.3.4.p.4">This document defines a single binding between the abstract lookup algorithm and a physical instance, using DNS TXT records, per <a href="#dnsbind">Section 3.6</a>. Other bindings can be defined.</p>
<h1 id="rfc.section.3.5">
<a href="#rfc.section.3.5">3.5.</a> <a href="#selectors" id="selectors">Selectors for Keys</a>
</h1>
<p id="rfc.section.3.5.p.1">It can be extremely helpful to support multiple DOSETA keys for the same domain name. For example: </p>

<ul class="empty"><li><ul>
<li>Rolling over from one key to another is a common security administration requirement; for an operational service this is made far easier when the old and new keys are supported simultaneously.</li>
<li>Domains that want to delegate signing capability for a specific address for a given duration to a partner, such as an advertising provider or other outsourced function.</li>
<li>Domains that want to allow frequent travelers to generate signed data locally without the need to connect to a particular server.</li>
<li>"Affinity" domains (such as, college alumni associations) that provide data forwarding, but that do not operate a data origination agent for outgoing data.</li>
</ul></li></ul>
<p id="rfc.section.3.5.p.2">To these ends, DOSETA includes a mechanism that supports multiple concurrent public keys per signing domain. The key namespace is subdivided using "selectors". For example, selectors might indicate the names of office locations (for example, "sanfrancisco", "coolumbeach", and "reykjavik"), the signing date (for example, "january2005", "february2005", etc.), or even an individual user.</p>
<p id="rfc.section.3.5.p.3">For further administrative convenience, sub-division of selectors is allowed, distinguished as dotted sub-components of the selector name. When keys are retrieved from the DNS, periods in selectors define DNS label boundaries in a manner similar to the conventional use in domain names. Selector components might be used to combine dates with locations, for example, "march2005.reykjavik". In a DNS implementation, this can be used to allow delegation of a portion of the selector namespace.</p>
<div id="#rfc.figure.19"></div>
<p></p>

<p>ABNF:</p>
<pre>selector =  sub-domain *( "." sub-domain )</pre>
<ul class="empty"><li></ul>

<p> </p>
<p id="rfc.section.3.5.p.5">The number of public keys and the corresponding selectors for each domain are determined by the domain owner. Many domain owners will be satisfied with just one selector, whereas administratively distributed organizations might choose to manage disparate selectors and key pairs in different regions or on different servers.</p>
<p id="rfc.section.3.5.p.6">As noted, selectors make it possible to seamlessly replace public keys on a routine basis. If a domain wishes to change from using a public key associated with selector "january2005" to a public key associated with selector "february2005", it merely makes sure that both public keys are advertised in the public-key repository concurrently for the transition period during which data might be in transit prior to verification. At the start of the transition period, the outbound servers are configured to sign with the "february2005" private key. At the end of the transition period, the "january2005" public key is removed from the public-key repository. </p>

<ul class="empty"><li><dl>
<dt>NOTE:  </dt>
<dd style="margin-left: 8">A key can also be revoked as described below. The distinction between revoking and removing a key selector record is subtle. When phasing out keys as described above, a signing domain would probably simply remove the key record after the transition period. However, a signing domain could elect to revoke the key (but maintain the key record) for a further period. There is no defined semantic difference between a revoked key and a removed key.</dd>
</dl></li></ul>
<p id="rfc.section.3.5.p.7">While some domains might wish to make selector values well known, others will want to take care not to allocate selector names in a way that allows harvesting of data by outside parties. For example, if per-user keys are issued, the domain owner will need to make the decision as to whether to associate this selector directly with the name of a registered end-user, or make it some unassociated random value, such as a fingerprint of the public key. </p>

<ul class="empty"><li><dl>
<dt>NOTE:  </dt>
<dd style="margin-left: 8">The ability to reuse a selector with a new key (for example, changing the key associated with a user's name) makes it impossible to tell the difference between data that didn't verify because the key is no longer valid versus a data that is actually forged. For this reason, reuse of selectors with different keys is ill-advised. A better strategy is to assign new keys to new selectors.</dd>
</dl></li></ul>
<h1 id="rfc.section.3.6">
<a href="#rfc.section.3.6">3.6.</a> <a href="#dnsbind" id="dnsbind">DNS Binding for Key Retrieval</a>
</h1>
<p id="rfc.section.3.6.p.1">This section defines a binding using DNS TXT records as a key service. All implementations MUST support this binding.</p>
<h1 id="rfc.section.3.6.1">
<a href="#rfc.section.3.6.1">3.6.1.</a> Namespace</h1>
<div id="#rfc.figure.20"></div>
<p id="rfc.section.3.6.1.p.1">A DOSETA key is stored in a subdomain named: </p>

<p>ABNF:</p>
<pre>dns-record =  s "._domainkey." d</pre>
<ul class="empty"><li><dl>
<dt>s:  </dt>
<dd style="margin-left: 8">is the selector of the lookup as specified in the "s" parameter (<a href="#signeddatastruct">Section 4.2</a>); use of selectors is discussed in <a href="#selectors">Section 3.5</a>
</dd>
<dt>d:  </dt>
<dd style="margin-left: 8">is the domain of the signature, as specified in the "d" parameter (<a href="#signeddatastruct">Section 4.2</a>)</dd>
</dl></li></ul>

<p> </p>

<dl>
<dt>NOTE:  </dt>
<dd style="margin-left: 8">The string constant "_domainkey" is used to mark a sub-tree that contains unified DOSETA key information. This string is a constant, rather than being a different string for different key-based services, with the view that keys are agnostic about the service they are used for. That is, there is no semantic or security benefit in having a different constant string for different key services. That said, a new service is certainly free to define a new constant and maintain and entirely independent set of keys.</dd>
</dl>
<div id="#rfc.figure.21"></div>
<pre>foo.bar._domainkey.example.com</pre>
<p id="rfc.section.3.6.1.p.2">Given a DOSETA&#8209;Signature field with a "d" parameter of "example.com" and an "s" parameter of "foo.bar", the DNS query will be for: </p>
<p id="rfc.section.3.6.1.p.3">Wildcard DNS records (for example, *.bar._domainkey.example.com) do not make sense in the context of DOSETA and their presence can be problematic.  Hence DNS wildcards with DOSETA SHOULD NOT be used. Note also that wildcards within domains (for example, s._domainkey.*.example.com) are not supported by the DNS.</p>
<h1 id="rfc.section.3.6.2">
<a href="#rfc.section.3.6.2">3.6.2.</a> Resource Record Types for Key Storage</h1>
<p id="rfc.section.3.6.2.p.1">The DNS Resource Record type used is specified by an option to the query-type ("q") parameter. The only option defined in this base specification is "txt", indicating the use of a DNS TXT Resource Record (RR), as defined in <a href="#keydata">Section 3.7</a>. A later extension of this standard might define another RR type.</p>
<p id="rfc.section.3.6.2.p.2">Strings in a TXT RR MUST be concatenated together before use, with no intervening whitespace. TXT RRs MUST be unique for a particular selector name; that is, if there are multiple records in an RRset, the results are undefined.</p>
<h1 id="rfc.section.3.7">
<a href="#rfc.section.3.7">3.7.</a> <a href="#keydata" id="keydata">Stored Key Data</a>
</h1>
<p id="rfc.section.3.7.p.1">This section defines a syntax for encoding stored key data within an unstructured environment such as the simple text environment of a DNS TXT record. </p>

<ul class="empty"><li><dl>
<dt>[TEMPLATE]  </dt>
<dd style="margin-left: 8">(Key Retrieval) A service that incorporates DOSETA MAY define the specific mechanism by which consumers can obtain associated public keys. This might be as easy as referencing an existing key management system or it might require a new set of conventions.</dd>
<dt></dt>
<dd style="margin-left: 8">Absent an explicit specification for key retrieval, the default mechanism is specified in <a href="#dnsbind">Section 3.6</a>. Use of this means sharing the set of public keys with DKIM and other DOSETA-based services.</dd>
</dl></li></ul>

<p> </p>
<p id="rfc.section.3.7.p.2">The overall syntax is a tag-list as described in <a href="#tagval">Section 3.3</a>. The base set of valid tags is described below. Other tags MAY be present and MUST be ignored by any implementation that does not understand them.</p>
<div id="#rfc.figure.22"></div>
<p></p>

<p>ABNF:</p>
<pre>key-k-tag        = %x76 [FWS] "=" [FWS] key-k-tag-type
key-k-tag-type   = "rsa" / x-key-k-tag-type
x-key-k-tag-type = hyphenated-word   ; for future extension</pre>
<div id="#rfc.figure.23"></div>
<p>ABNF:</p>
<pre>key-n-tag    = %x6e [FWS] "=" [FWS] qp-section</pre>
<div id="#rfc.figure.24"></div>
<p>ABNF:</p>
<pre>key-p-tag    = %x70 [FWS] "=" [ [FWS] base64string]</pre>
<ul class="empty"><li>
<dl>
<dt>k=  </dt>
<dd style="margin-left: 8">Key type (MAY be include; default is "rsa"). Signers and verifiers MUST support the "rsa" key type. The "rsa" key type indicates that an ASN.1 DER-encoded <a href="#ITU-X660-1997">[ITU-X660-1997]</a> RSAPublicKey <a href="#RFC3447">[RFC3447]</a> (see Sections <a href="#selectors">Section 3.5</a> and A.1.1) is being used in the "p" parameter. (Note: the "p" parameter further encodes the value using the base64 algorithm.) Unrecognized key types MUST be ignored. </dd>
<dt></dt>
<dd style="margin-left: 8">
<ul class="empty"><li></ul>
<p> </p>
</dd>
<dt>n=  </dt>
<dd style="margin-left: 8">Notes that might be of interest to a human (MAY be included; default is empty). No interpretation is made by any program. This tag should be used sparingly in any key server mechanism that has space limitations (notably DNS).  This is intended for use by administrators, not end users.</dd>
<dt></dt>
<dd style="margin-left: 8">
<ul class="empty"><li></ul>
<p> </p>
</dd>
<dt>p=  </dt>
<dd style="margin-left: 8">Public-key data (MUST be included).  An empty value means that this public key has been revoked. The syntax and semantics of this tag value before being encoded in base64 are defined by the "k" parameter. <ul class="empty"><li></ul>
<p> </p>
<dl>
<dt>NOTE:  </dt>
<dd style="margin-left: 8">If a private key has been compromised or otherwise disabled (for example, an outsourcing contract has been terminated), a signer might want to explicitly state that it knows about the selector, but also have all queries using that selector result in a failed verification. Verifiers SHOULD ignore any DOSETA&#8209;Signature header fields with a selector referencing a revoked key.</dd>
<dt>NOTE: </dt>
<dd style="margin-left: 8">A base64string is permitted to include white space (FWS) at arbitrary places; however, any CRLFs MUST be followed by at least one WSP character. Implementors and administrators are cautioned to ensure that selector TXT records conform to this specification.</dd>
</dl>
<p> </p>
</dd>
</dl>
<p> </p>
</li></ul>

<p> </p>
<h1 id="rfc.section.4">
<a href="#rfc.section.4">4.</a> <a href="#template" id="template">DOSETA H/C Signing Template</a>
</h1>
<p id="rfc.section.4.p.1">This section specifies the basic components of a signing mechanism; it is similar to the one defined for DKIM. This template for a signing service can be mapped to a two-part -- header/content -- data model. As for DKIM this separates specification of the signer's identity from any other identifiers that might be associated with that data.</p>

<ul class="empty"><li><dl>
<dt>NOTE:  </dt>
<dd style="margin-left: 8">The use of hashing and signing algorithms by DOSETA inherently provides a degree of data integrity protection, between the signing and verifying steps. However it does not necessarily "authenticate" the data that is signed. For example, it does not inherently validate the accuracy of the data or declare that the signer is the author or owner of the data. To the extent that authentication is meant by the presence of a signature, that needs to be specified as part of the semantics for the service based upon this template.</dd>
<dt>[TEMPLATE]  </dt>
<dd style="margin-left: 8">(Header/Content Mapping) The service incorporating this mechanism MUST define the precise mappings onto the template provided in this section. (Data lacking a header component might still be possible to cast in a header/content form, where the header comprises on the DOSETA Signature information.)</dd>
<dt></dt>
<dd style="margin-left: 8">The service also MUST define the precise meaning of a signature.</dd>
</dl></li></ul>
<h1 id="rfc.section.4.1">
<a href="#rfc.section.4.1">4.1.</a> <a href="#cryptoalgs" id="cryptoalgs">Cryptographic Algorithms</a>
</h1>
<p id="rfc.section.4.1.p.1">DOSETA supports multiple digital signature algorithms: </p>
<p></p>

<ul class="empty"><li><dl>
<dt>rsa-sha1:  </dt>
<dd style="margin-left: 8">The rsa-sha1 Signing Algorithm computes a message hash as described in <a href="#sigcalc">Section 4.4</a> below using SHA-1 <a href="#FIPS-180-2-2002">[FIPS-180-2-2002]</a> as a hashing algorithm. That hash is then signed by the signer using the RSA algorithm (defined in PKCS#1 version 1.5 <a href="#RFC3447">[RFC3447]</a>) as the crypt-alg and the signer's private key. The hash MUST NOT be truncated or converted into any form other than the native binary form before being signed. The signing algorithm SHOULD use a public exponent of 65537.</dd>
<dt>rsa-sha256:  </dt>
<dd style="margin-left: 8">The rsa-sha256 Signing Algorithm computes a message hash as described in <a href="#RFC5451">[RFC5451]</a> below using SHA-256 <a href="#FIPS-180-2-2002">[FIPS-180-2-2002]</a> as the hash-alg. That hash is then signed by the signer using the RSA algorithm (defined in PKCS#1 version 1.5 <a href="#RFC3447">[RFC3447]</a>) as the crypt-alg and the signer's private key. The hash MUST NOT be truncated or converted into any form other than the native binary form before being signed.</dd>
<dt>Other:  </dt>
<dd style="margin-left: 8">Other algorithms MAY be defined in the future. Verifiers MUST ignore any signatures using algorithms that they do not implement.</dd>
</dl></li></ul>

<p> Signers MUST implement and SHOULD sign using rsa-sha256. Verifiers MUST implement rsa-sha256. </p>

<dl>
<dt>NOTE:  </dt>
<dd style="margin-left: 8">Although sha256 is strongly encouraged, some senders of low-security messages (such as routine newsletters) might prefer to use sha1 because of reduced CPU requirements to compute a sha1 hash. In general, sha256 is always preferred, whenever possible.</dd>
</dl>
<p id="rfc.section.4.1.p.3">Selecting appropriate key sizes is a trade-off between cost, performance, and risk. Since short RSA keys more easily succumb to off-line attacks, signers MUST use RSA keys of at least 1024 bits for long-lived keys. Verifiers MUST be able to validate signatures with keys ranging from 512 bits to 2048 bits, and they MAY be able to validate signatures with larger keys.  Verifier policies might use the length of the signing key as one metric for determining whether a signature is acceptable.</p>
<p id="rfc.section.4.1.p.4">Factors that ought to influence the key size choice include the following: </p>

<ul class="empty"><li><ul>
<li>The practical constraint that large (for example, 4096 bit) keys might not fit within a 512-byte DNS UDP response packet</li>
<li>The security constraint that keys smaller than 1024 bits are subject to off-line attacks</li>
<li>Larger keys impose higher CPU costs to verify and sign data</li>
<li>Keys can be replaced on a regular basis, thus their lifetime can be relatively short</li>
<li>The security goals of this specification are modest compared to typical goals of other systems that employ digital signatures</li>
</ul></li></ul>
<p id="rfc.section.4.1.p.5">See <a href="#RFC3766">[RFC3766]</a> for further discussion on selecting key sizes.</p>
<h1 id="rfc.section.4.2">
<a href="#rfc.section.4.2">4.2.</a> <a href="#signeddatastruct" id="signeddatastruct">Signature Data Structure</a>
</h1>
<p id="rfc.section.4.2.p.1">A signature of data is stored into an data structure associated with the signed data. This structure contains all of the signature&#8209; and key&#8209;fetching data. This DOSETA&#8209;Signature structure is a tag-list as defined in <a href="#tagval">Section 3.3</a>. </p>

<ul class="empty"><li><dl>
<dt>[TEMPLATE]  </dt>
<dd style="margin-left: 8">(Signature Association) A service that incorporates DOSETA MUST define the exact means by which the Signature structure is associated with the data.</dd>
</dl></li></ul>
<p id="rfc.section.4.2.p.2">When the DOSETA&#8209;Signature structure is part of a sequence of structures -- such as being added to an email header -- it SHOULD NOT be reordered and SHOULD be pre-pended to the message. (This is the same handling as is given to email trace Header fields, defined in Section&#160;3.6 of <a href="#RFC5322">[RFC5322]</a>.) </p>
<p id="rfc.section.4.2.p.3">The tags are specified below. Tags described as &lt;qp-section&gt; are encoded as described in Section&#160;6.7 of MIME Part One <a href="#RFC2045">[RFC2045]</a>, with the additional conversion of semicolon characters to "=3B"; intuitively, this is one line of quoted-printable encoded text. The D-quoted-printable syntax is defined in <a href="#D-quoted-printable">Section 2.3.4</a>.</p>
<div id="#rfc.figure.25"></div>
<p id="rfc.section.4.2.p.4">Tags on the DOSETA&#8209;Signature structure along with their type and requirement status are shown below. Unrecognized tags MUST be ignored. </p>

<p>ABNF:</p>
<pre>sig-v-tag       = %x76 [FWS] "=" [FWS] "1"</pre>
<div id="#rfc.figure.26"></div>
<p>ABNF:</p>
<pre>
sig-a-tag       = %x61 [FWS] "=" [FWS] sig-a-tag-alg
sig-a-tag-alg   = sig-a-tag-k "-" sig-a-tag-h
sig-a-tag-k     = "rsa" / x-sig-a-tag-k
sig-a-tag-h     = "sha1" / "sha256" / x-sig-a-tag-h
x-sig-a-tag-k   = ALPHA *(ALPHA / DIGIT)   
                     ; for later extension
x-sig-a-tag-h   = ALPHA *(ALPHA / DIGIT)   
                     ; for later extension</pre>
<div id="#rfc.figure.27"></div>
<p>ABNF:</p>
<pre>sig-b-tag       = %x62 [FWS] "=" [FWS] sig-b-tag-data
sig-b-tag-data  = base64string</pre>
<div id="#rfc.figure.28"></div>
<p>ABNF:</p>
<pre>sig-bh-tag      = %x62 %x68 [FWS] "=" [FWS] sig-bh-tag-data
sig-bh-tag-data = base64string</pre>
<div id="#rfc.figure.29"></div>
<p>ABNF:</p>
<pre>sig-bh-tag      = %x63 [FWS] "=" [FWS] sig-c-header "/" sig-c-content</pre>
<div id="#rfc.figure.30"></div>
<p>ABNF:</p>
<pre>sig-c-tag       = %x63 [FWS] "=" [FWS] sig-c-tag-alg
                  ["/" sig-c-tag-alg]
sig-c-tag-alg   = "simple" / "relaxed" / x-sig-c-tag-alg
x-sig-c-tag-alg = hyphenated-word    ; for later extension</pre>
<div id="#rfc.figure.31"></div>
<p>ABNF:</p>
<pre>sig-cl-tag        = %x63 %x6C [FWS] "=" [FWS]
                                        sig-cl-tag-claim
                                        ["/" sig-c-tag-claim]
sig-c-tag-claim   = hyphenated-word 
                       ; per DOSETA Claims Registry</pre>
<div id="#rfc.figure.32"></div>
<p>ABNF:</p>
<pre>
sig-d-tag       = %x64 [FWS] "=" [FWS] domain-name
domain-name     = sub-domain 1*("." sub-domain) 
                     ; from RFC 5321 Domain, 
                     ; but excluding address-literal</pre>
<div id="#rfc.figure.33"></div>
<p>ABNF:</p>
<pre>sig-h-tag       = %x68 [FWS] "=" [FWS] hdr-name
                   0*( [FWS] ":" [FWS] hdr-name )</pre>
<div id="#rfc.figure.34"></div>
<p>ABNF:</p>
<pre>sig-q-tag        = %x71 [FWS] "=" [FWS] sig-q-tag-method
                      *([FWS] ":" [FWS] sig-q-tag-method)
sig-q-tag-method = "dns/txt" / x-sig-q-tag-type
                   ["/" x-sig-q-tag-args]
x-sig-q-tag-type = hyphenated-word  ; for future extension
x-sig-q-tag-args = qp-hdr-value</pre>
<div id="#rfc.figure.35"></div>
<p>ABNF:</p>
<pre>sig-s-tag    = %x73 [FWS] "=" [FWS] selector</pre>
<div id="#rfc.figure.36"></div>
<p>ABNF:</p>
<pre>sig-t-tag    = %x74 [FWS] "=" [FWS] 1*12DIGIT</pre>
<div id="#rfc.figure.37"></div>
<p>ABNF:</p>
<pre>sig-x-tag    = %x78 [FWS] "=" [FWS]
               1*12DIGIT</pre>
<ul class="empty"><li><dl>
<dt>v=  </dt>
<dd style="margin-left: 8">Version (MUST be included). This tag defines the version of this specification that applies to the signature record. It MUST have the value "1". Note that verifiers MUST do an exact string comparison on this value; for example, "1" is not the same as "1.0". <ul class="empty"><li></ul>
<p> </p>
<dl>
<dt>NOTE: </dt>
<dd style="margin-left: 8">DOSETA&#8209;Signature version numbers are expected to increase arithmetically as new versions of this specification are released.</dd>
</dl>
<p> </p>
</dd>
<dt>a=  </dt>
<dd style="margin-left: 8">The algorithm used to generate the signature (MUST be included). Verifiers MUST support "rsa-sha1" and "rsa-sha256"; signers SHOULD sign using "rsa-sha256". See <a href="#cryptoalgs">Section 4.1</a> for a description of algorithms.</dd>
<dt></dt>
<dd style="margin-left: 8">
<ul class="empty"><li></ul>
<p> </p>
</dd>
<dt>b=  </dt>
<dd style="margin-left: 8">The signature data (MUST be included). Whitespace is ignored in this value and MUST be ignored when reassembling the original signature. In particular, the signing process can safely insert FWS in this value in arbitrary places to conform to line-length limits. See Signer Actions (<a href="#signer">Section 4.5</a>) for how the signature is computed.</dd>
<dt></dt>
<dd style="margin-left: 8">
<ul class="empty"><li></ul>
<p> </p>
</dd>
<dt>bh=  </dt>
<dd style="margin-left: 8">The hash of the canonicalized Content (body), as limited by the "l" parameter (MUST be included). Whitespace is ignored in this value and MUST be ignored when reassembling the original signature. In particular, the signing process can safely insert FWS in this value in arbitrary places to conform to line-length limits.  See <a href="#sigcalc">Section 4.4</a> for how the Content hash is computed. <ul class="empty"><li></ul>
<p> </p>
</dd>
<dt>c=  </dt>
<dd style="margin-left: 8">Data canonicalization (MAY be included; default is "simple/simple"). This tag informs the verifier of the type of canonicalization used to prepare the message for signing. It consists of two names separated by a "slash" (%d47) character, corresponding to the header and Content canonicalization algorithms respectively: <ul class="empty"><li>
<dl>
<dt>sig-c-header:  </dt>
<dd style="margin-left: 8">A value from Header Canonicalization IANA registry defined in <a href="#DKIMSign">[DKIMSign]</a>
</dd>
<dt>sig-c-content:  </dt>
<dd style="margin-left: 8">A value from Message Canonicalization IANA registry defined in <a href="#DKIMSign">[DKIMSign]</a>
</dd>
</dl>
<p> </p>
</li></ul>
<p> These algorithms are described in </p>
<a href="#canon">Section 3.2</a>. If only one algorithm is named, that algorithm is used for the header and "simple" is used for the Content. For example, "c=relaxed" is treated the same as "c=relaxed/simple".</dd>
<dt></dt>
<dd style="margin-left: 8">
<ul class="empty"><li></ul>
<p> </p>
</dd>
<dt>cl=  </dt>
<dd style="margin-left: 8">A list of semantic claims, asserting the set of "meanings" intended by the signer, such as author validity or content validity (SHOULD be included; default is "handled"}. The list of supported claims comprises values from the DOSETA Claims IANA registry, defined in <a href="#dosetaclaims">Section 6</a> using values listed in <a href="#ianaclaims">Section 7.1.2</a>. </dd>
<dt></dt>
<dd style="margin-left: 8">
<ul class="empty"><li></ul>
<p> </p>
</dd>
<dt>d=  </dt>
<dd style="margin-left: 8">The DDI doing the signing (MUST be included). Hence, the DDI value is used to form the query for the public key. The DDI MUST correspond to a valid DNS name under which the DOSETA key record is published. The conventions and semantics used by a signer to create and use a specific DDI are outside the scope of the DOSETA Signing specification, as is any use of those conventions and semantics. When presented with a signature that does not meet these requirements, verifiers MUST consider the signature invalid.</dd>
<dt></dt>
<dd style="margin-left: 8">Internationalized domain names MUST be encoded as described in <a href="#RFC5890">[RFC5890]</a>.</dd>
<dt></dt>
<dd style="margin-left: 8"><ul class="empty"><li><dl>
<dt>[TEMPLATE]  </dt>
<dd style="margin-left: 8">(Semantics) The service incorporating DOSETA MUST define the semantics of a signature.</dd>
</dl></li></ul></dd>
<dt></dt>
<dd style="margin-left: 8">
<ul class="empty"><li></ul>
<p> </p>
</dd>
<dt>h=  </dt>
<dd style="margin-left: 8">Signed Header fields (MUST be included). A colon-separated list of header field names that identify the Header fields presented to the signing algorithm. The field MUST contain the complete list of Header fields in the order presented to the signing algorithm. The field MAY contain names of Header fields that do not exist when signed; nonexistent Header fields do not contribute to the signature computation (that is, they are treated as the null input, including the header field name, the separating colon, the header field value, and any CRLF terminator). The field MUST NOT include the DOSETA Signature header field that is being created or verified, but might include others. Folding whitespace (FWS) MAY be included on either side of the colon separator.  Header field names MUST be compared against actual header field names in a case-insensitive manner.  This list MUST NOT be empty. See <a href="#fields2sign">Section 4.5.3</a> for a discussion of choosing Header fields to sign.</dd>
<dt></dt>
<dd style="margin-left: 8"><ul class="empty"><li></ul></dd>
<dt></dt>
<dd style="margin-left: 8">By "signing" Header fields that do not actually exist, a signer can prevent insertion of those Header fields before verification. However, since a signer cannot possibly know all possible Header fields that might be created in the future, the security of this solution is not total.</dd>
<dt></dt>
<dd style="margin-left: 8">The exclusion of the header field name and colon as well as the header field value for non-existent Header fields prevents an attacker from inserting an actual header field with a null value.</dd>
<dt>q=  </dt>
<dd style="margin-left: 8">A colon-separated list of query methods used to retrieve the public key (MAY be included; default is "dns/txt"). Each query method is of the form "type[/options]", where the syntax and semantics of the options depend on the type and specified options. If there are multiple query mechanisms listed, the choice of query mechanism MUST NOT change the interpretation of the signature. Implementations MUST use the recognized query mechanisms in the order presented.  Unrecognized query mechanisms MUST be ignored. </dd>
<dt></dt>
<dd style="margin-left: 8">Currently, the only valid value is "dns/txt", which defines the DNS TXT record lookup algorithm described elsewhere in this document. The only option defined for the "dns" query type is "txt", which MUST be included. Verifiers and signers MUST support "dns/txt".</dd>
<dt></dt>
<dd style="margin-left: 8">
<ul class="empty"><li></ul>
<p> </p>
</dd>
<dt>s=  </dt>
<dd style="margin-left: 8">The selector subdividing the namespace for the "d=" (domain) tag (MUST be included).</dd>
<dt></dt>
<dd style="margin-left: 8">
<ul class="empty"><li></ul>
<p> </p>
</dd>
<dt>t=  </dt>
<dd style="margin-left: 8">Signature Timestamp (SHOULD be included; default is an unknown creation time). The time that this signature was created. The format is the number of seconds since 00:00:00 on January 1, 1970 in the UTC time zone. The value is expressed as an unsigned integer in decimal ASCII. This value is not constrained to fit into a 31- or 32-bit integer. Implementations SHOULD be prepared to handle values up to at least 10^12 (until approximately AD 200,000; this fits into 40 bits).  To avoid denial-of-service attacks, implementations MAY consider any value longer than 12 digits to be infinite. Leap seconds are not counted.  Implementations MAY ignore signatures that have a timestamp in the future.</dd>
<dt></dt>
<dd style="margin-left: 8">
<ul class="empty"><li></ul>
<p> </p>
</dd>
<dt>x=  </dt>
<dd style="margin-left: 8">Signature Expiration (SHOULD be included; default is no expiration). The format is the same as in the "t" parameter, represented as an absolute date, not as a time delta from the signing timestamp. The value is expressed as an unsigned integer in decimal ASCII, with the same constraints on the value in the "t=" tag. Signatures MAY be considered invalid if the verification time at the verifier is past the expiration date. Ideally verification time is when a message is first received at the administrative domain of the verifier; otherwise the current time SHOULD be used. The value of the "x" parameter MUST be greater than the value of the "t" parameter if both are present.</dd>
<dt></dt>
<dd style="margin-left: 8">
<dl>
<dt>NOTE: </dt>
<dd style="margin-left: 8">The "x" parameter is not intended as an anti-replay defense.</dd>
<dt>NOTE: </dt>
<dd style="margin-left: 8">Due to clock drift, the receiver's notion of when to consider the signature expired might not match exactly when the sender is expecting. Receivers MAY add a 'fudge factor' to allow for such possible drift. </dd>
<dt></dt>
<dd style="margin-left: 8"></dd>
</dl>
<p> </p>
</dd>
</dl></li></ul>
<h1 id="rfc.section.4.3">
<a href="#rfc.section.4.3">4.3.</a> <a href="#addedtags" id="addedtags">Additional Tags</a>
</h1>
<p id="rfc.section.4.3.p.1">Some applications can benefit from additional, common functional enhancements. These are defined here, as options to the core mechanism. </p>
<div id="#rfc.figure.38"></div>
<pre>key-id-tag   = %x69 %64 [FWS] "=" [FWS] hyphenated-word </pre>
<p></p>

<ul class="empty"><li>
<dl>
<dt>id=  </dt>
<dd style="margin-left: 8">The local identifier, restricting the scope of the DDI, such as to a specific user.  This value is combined with the DDI, to specify the identifier to be used for assessment.  Administrative choices for selectors can provide different keys for different local identifiers. See <a href="#selectors">Section 3.5</a><ul class="empty"><li>ABNF: </li></ul>
<p> </p>
</dd>
</dl>
<p> </p>
</li></ul>

<p> </p>
<h1 id="rfc.section.4.4">
<a href="#rfc.section.4.4">4.4.</a> <a href="#sigcalc" id="sigcalc">Signature Calculations</a>
</h1>
<p id="rfc.section.4.4.p.1">Hashing and cryptographic signature algorithms are combined into a procedure for computing a digital signature. Producers will choose appropriate parameters for the signing process.  Consumers will use the tags that are then passed as an associated DOSETA&#8209;Signature header field. <a href="#signeddatastruct">Section 4.2</a>. In the following discussion, the names of the tags are parameters in that field. </p>
<p id="rfc.section.4.4.p.2">The basic operations for producing a signature are canonicalization, hashing and signing. Canonicalization removes irrelevant variations. Hashing produces a very short representation for the data and signing produces a unique, protected string to be exchanged. </p>

<ul class="empty"><li><dl>
<dt>NOTE:  </dt>
<dd style="margin-left: 8">Canonicalization (see <a href="#canon">Section 3.2</a>) prepares a separate representation of the data for additional processing; it does not affect the original, transmitted data in any way.</dd>
</dl></li></ul>
<p id="rfc.section.4.4.p.3">Producers MUST compute hashes in the order defined. Consumers MAY compute them in any order convenient to the producer, provided that the result is semantically identical to the semantics that would occur, had they been computed in this order.</p>
<p id="rfc.section.4.4.p.4">The combined hashing and signing algorithms are: </p>

<ul class="empty"><li><dl>
<dt>Content Hash:  </dt>
<dd style="margin-left: 8"><ol>
<li>Truncate the content to the length specified in the "l" parameter. </li>
<li>Canonicalize the truncated content, using the algorithm specified in the "c" parameter. </li>
<li>Hash the canonicalized content, using the hashing algorithm specified in the "a" parameter.</li>
<li>Convert the resulting hash to base64 form. </li>
<li>Signers then insert the base64 result into the "bh" parameter of the DOSETA&#8209;Signature field; verifiers compare their hash with the value in the "bh" parameter.</li>
</ol></dd>
<dt>Header Hash:  </dt>
<dd style="margin-left: 8"><ol>
<li>Select the header fields specified by the "h" parameter.</li>
<li>Ensure that each field is terminated by a single CRLF.</li>
<li>Canonicalize each of these fields, using the header canonicalization algorithm specified in the "c" parameter. </li>
<li>Select the DOSETA&#8209;Signature field that exists (verifying), or will be inserted (signing), in the header.</li>
<li>From that field, delete the value portion of the "b" parameter, including all surrounding whitespace; that is, treat the "b" parameter as containing an empty string. </li>
<li>Canonicalize the resulting field, using the Header canonicalization algorithm specified in the "c" parameter, but remove the trailing CRLF, if present. </li>
<li>Using the hashing algorithm specified in the "a" parameter, hash the sequence: <ol>
<li>the canonicalized header fields, in the order specified by the "h" parameter, </li>
<li>the output from the content hash, and</li>
<li>the canonicalized DOSETA&#8209;Signature field.</li>
</ol>
</li>
</ol></dd>
<dt>Signature:  </dt>
<dd style="margin-left: 8">
<ol>
<li>Obtain the relevant key associated with the relevant domain and selector; for signing this is a private key; for verifying this is a public key. </li>
<li>Obtain the header hash produced by the previous calculation.</li>
<li>Using the signing algorithm specified in the "a" parameter, and the relevant key, process the hash.</li>
</ol>
<p> </p>
</dd>
</dl></li></ul>

<p> </p>
<p id="rfc.section.4.4.p.5">All tags cited in the "h" parameter MUST be included even if they are not understood by the verifier. Note that the DOSETA&#8209;Signature field is presented to the hash algorithm after the content hash is processed, rather than with the rest of the header fields that are processed before the content hash. The DOSETA&#8209;Signature header structure MUST NOT be cited in its own h= tag. If present, other DOSETA&#8209;Signature header fields MAY be cited and included in the signature process (see <a href="#multisig">Section 5</a>).</p>
<p id="rfc.section.4.4.p.6">When calculating the hash on data that will be transmitted using additional encoding, such as base64 or quoted-printable, signers MUST compute the hash after the encoding. Likewise, the verifier MUST incorporate the values into the hash before decoding the base64 or quoted-printable text. However, the hash MUST be computed before transport level encodings such as SMTP "dot-stuffing" (the modification of lines beginning with a "." to avoid confusion with the SMTP end-of-message marker, as specified in <a href="#RFC5321">[RFC5321]</a>).</p>
<p id="rfc.section.4.4.p.7">With the exception of the canonicalization procedure described in <a href="#canon">Section 3.2</a>, the DOSETA signing process treats the content as a simple string of octets. DOSETA content MAY be either simple lines of plain-text or as a MIME object; no special treatment is afforded to MIME content. </p>
<div id="#rfc.figure.39"></div>
<p id="rfc.section.4.4.p.8">Formally, the algorithm for the signature is as follows: </p>

<p>ABNF: </p>
<pre>content-hash =  hash-alg (canon-content, l-param)
data-hash    =  hash-alg (h-headers, D-SIG, content-hash) 
signature    =  sig-alg (d-domain, selector, data-hash) </pre>
<ul class="empty"><li></ul>

<p> </p>
<p id="rfc.section.4.4.p.9">where: </p>

<ul class="empty"><li><dl>
<dt>content-hash:  </dt>
<dd style="margin-left: 8">is the output from hashing the content, using hash-alg.</dd>
<dt>hash-alg:  </dt>
<dd style="margin-left: 8">is the hashing algorithm specified in the "a" parameter.</dd>
<dt>canon-content:  </dt>
<dd style="margin-left: 8">is a canonicalized representation of the content.</dd>
<dt>l-param:  </dt>
<dd style="margin-left: 8">is the length-of-content value of the "l" parameter.</dd>
<dt>data-hash:  </dt>
<dd style="margin-left: 8">is the output from using the hash-alg algorithm, to hash the header including the DKIM&#8209;Signature header, and the content hash.</dd>
<dt>h-headers:  </dt>
<dd style="margin-left: 8">is the list of headers to be signed, as specified in the "h" parameter.</dd>
<dt>D-SIG:  </dt>
<dd style="margin-left: 8">is the canonicalized DOSETA&#8209;Signature field without the signature value portion of the parameter, itself; that is, an empty parameter value.</dd>
<dt>canon-content:  </dt>
<dd style="margin-left: 8">is the canonicalized data content (respectively) as defined in <a href="#canon">Section 3.2</a> (excluding the DOSETA&#8209;Signature field). </dd>
<dt>signature:  </dt>
<dd style="margin-left: 8">is the signature value produced by the signing algorithm.</dd>
<dt>sig-alg:  </dt>
<dd style="margin-left: 8">is the signature algorithm specified by the "a" parameter.</dd>
<dt>d-domain:  </dt>
<dd style="margin-left: 8">is the domain name specified in the "d" parameter.</dd>
<dt>selector:  </dt>
<dd style="margin-left: 8">is the selector value specified in the "s" parameter.</dd>
</dl></li></ul>

<p> </p>

<dl>
<dt>NOTE:  </dt>
<dd style="margin-left: 8">Many digital signature APIs provide both hashing and application of the RSA private key using a single "sign()" primitive. When using such an API, the last two steps in the algorithm would probably be combined into a single call that would simultaneously perform both "a-hash-alg" and the "sig-alg".</dd>
</dl>
<h1 id="rfc.section.4.5">
<a href="#rfc.section.4.5">4.5.</a> <a href="#signer" id="signer">Signer Actions</a>
</h1>
<p id="rfc.section.4.5.p.1">The following steps are performed in order by signers.</p>
<h1 id="rfc.section.4.5.1">
<a href="#rfc.section.4.5.1">4.5.1.</a> Determine Whether the Data Should Be Signed and by Whom</h1>
<p id="rfc.section.4.5.1.p.1">A signer can obviously only sign data using domains for which it has a private key and the necessary knowledge of the corresponding public key and selector information.  However, there are a number of other reasons beyond the lack of a private key why a signer could choose not to sign the data. </p>

<dl>
<dt>NOTE:  </dt>
<dd style="margin-left: 8">Signing modules can be incorporated into any portion of a service, as deemed appropriate, including end-systems, servers and intermediaries.  Wherever implemented, signers need to beware of the semantics of signing data. An example of how this can be problematic is that within a trusted enclave the signing address might be derived from the data according to local policy; the derivation is based on local trust rather than explicit validation.</dd>
</dl>
<p id="rfc.section.4.5.1.p.2">If the data cannot be signed for some reason, the disposition of that data is a local policy decision.</p>
<h1 id="rfc.section.4.5.2">
<a href="#rfc.section.4.5.2">4.5.2.</a> <a href="#selectpriv" id="selectpriv">Select a Private Key and Corresponding Selector Information</a>
</h1>
<p id="rfc.section.4.5.2.p.1">This specification does not define the basis by which a signer ought to choose which private key and selector information to use. Currently, all selectors are equal, with respect to this specification. So the choices ought to largely be a matter of administrative convenience.  Distribution and management of private keys is also outside the scope of this document. </p>

<dl>
<dt>NOTE:  </dt>
<dd style="margin-left: 8">A signer SHOULD use a private key with an associated selector record that is expected to still be valid by time the verifier is likely to have an opportunity to validate the signature. The signer SHOULD anticipate that verifiers can choose to defer validation, perhaps until the message is actually read by the final recipient. In particular, when rotating to a new key pair, signing SHOULD immediately commence with the new private key, but the old public key SHOULD be retained for a reasonable validation interval before being removed from the key server.</dd>
</dl>
<h1 id="rfc.section.4.5.3">
<a href="#rfc.section.4.5.3">4.5.3.</a> <a href="#fields2sign" id="fields2sign">Determine the Header Fields to Sign</a>
</h1>
<p id="rfc.section.4.5.3.p.1">Signers SHOULD NOT sign an existing header field that is likely to be legitimately modified or removed in transit.  Signers MAY include any other Header fields present at the time of signing at the discretion of the signer. </p>

<dl>
<dt>NOTE:  </dt>
<dd style="margin-left: 8">The choice of which Header fields to sign is non-obvious. One strategy is to sign all existing, non-repeatable Header fields. An alternative strategy is to sign only Header fields that are likely to be displayed to or otherwise be likely to affect the processing of the Content at the receiver. A third strategy is to sign only "well known" headers. Note that verifiers might treat unsigned Header fields with extreme skepticism, including refusing to display them to the end user or even ignoring the signature if it does not cover certain Header fields. </dd>
</dl>
<p id="rfc.section.4.5.3.p.2">The DOSETA&#8209;Signature header field is always implicitly signed and MUST NOT be included in the "h" parameter except to indicate that other preexisting signatures are also signed.</p>
<p id="rfc.section.4.5.3.p.3">Signers MAY claim to have signed Header fields that do not exist (that is, signers MAY include the header field name in the "h" parameter even if that header field does not exist in the message). When computing the signature, the non-existing header field MUST be treated as the null string (including the header field name, header field value, all punctuation, and the trailing CRLF). </p>

<dl>
<dt>NOTE: </dt>
<dd style="margin-left: 8">This allows signers to explicitly assert the absence of a header field; if that header field is added later the signature will fail.</dd>
<dt>NOTE: </dt>
<dd style="margin-left: 8">A header field name need only be listed once more than the actual number of that header field in a message at the time of signing in order to prevent any further additions. For example, if there is a single Comments header field at the time of signing, listing Comments twice in the "h" parameter is sufficient to prevent any number of Comments Header fields from being appended; it is not necessary (but is legal) to list Comments three or more times in the "h" parameter.</dd>
</dl>
<div id="#rfc.figure.40"></div>
<pre>Received: &lt;A&gt;
Received: &lt;B&gt;
Received: &lt;c&gt; </pre>
<div id="#rfc.figure.41"></div>
<p id="rfc.section.4.5.3.p.4">Signers choosing to sign an existing header field that occurs more than once in the message (such as Received) MUST sign the physically last instance of that header field in the header block. Signers wishing to sign multiple instances of such a header field MUST include the header field name multiple times in the h= tag of the DOSETA&#8209;Signature header field, and MUST sign such Header fields in order from the bottom of the header field block to the top. The signer MAY include more instances of a header field name in h= than there are actual corresponding Header fields to indicate that additional Header fields of that name SHOULD NOT be added. </p>

<p>then the resulting DOSETA&#8209;Signature header field ought to read:</p>
<pre>
DKIM-Signature: ... h=Received : Received :...</pre>
<ul class="empty">
<li>EXAMPLE:</li>
<li>If the signer wishes to sign two existing Received Header fields, and the existing header contains: </li>
</ul>
<p id="rfc.section.4.5.3.p.5">Signers need to be careful of signing Header fields that might have additional instances added later in the delivery process, since such Header fields might be inserted after the signed instance or otherwise reordered. Trace Header fields (such as Received) and Resent-* blocks are the only fields prohibited by <a href="#RFC5322">[RFC5322]</a> from being reordered. In particular, since DOSETA&#8209;Signature Header fields might be reordered by some intermediate MTAs, signing existing DOSETA&#8209;Signature Header fields is error-prone. </p>

<dl>
<dt>NOTE: </dt>
<dd style="margin-left: 8">Despite the fact that <a href="#RFC5322">[RFC5322]</a> permits Header fields to be reordered (with the exception of Received Header fields), reordering of signed Header fields with multiple instances by intermediate MTAs will cause DOSETA signatures to be broken; such anti-social behavior ought to be avoided.</dd>
<dt>NOTE: </dt>
<dd style="margin-left: 8">Although not required by this specification, all end-user visible Header fields SHOULD be signed to avoid possible "indirect spamming". For example, if the Subject header field is not signed, a spammer can resend a previously signed mail, replacing the legitimate subject with a one-line spam.</dd>
</dl>
<h1 id="rfc.section.4.5.4">
<a href="#rfc.section.4.5.4">4.5.4.</a> Compute the Message Signature</h1>
<p id="rfc.section.4.5.4.p.1">The signer MUST compute the message hash as described in <a href="#sigcalc">Section 4.4</a> and then sign it using the selected public-key algorithm. This will result in a DOSETA&#8209;Signature header field that will include the Content hash and a signature of the header hash, where that header includes the DOSETA&#8209;Signature header field itself.</p>
<p id="rfc.section.4.5.4.p.2">Entities such as mailing list managers that implement DOSETA and that modify the message or a header field (for example, inserting unsubscribe information) before retransmitting the message SHOULD check any existing signature on input and MUST make such modifications before re-signing the message.</p>
<p id="rfc.section.4.5.4.p.3">The signer MAY elect to limit the number of bytes of the Content that will be included in the hash and hence signed.  The length actually hashed SHOULD be inserted in the "l=" tag of the DOSETA&#8209;Signature header field.</p>
<h1 id="rfc.section.4.5.5">
<a href="#rfc.section.4.5.5">4.5.5.</a> Insert the DOSETA&#8209;Signature Header Field</h1>
<p id="rfc.section.4.5.5.p.1">Finally, the signer MUST insert the DOSETA&#8209;Signature header field created in the previous step prior to transmitting the data. The DOSETA&#8209;Signature header field MUST be the same as used to compute the hash as described above, except that the value of the "b" parameter MUST be the appropriately signed hash computed in the previous step, signed using the algorithm specified in the "a" parameter of the DOSETA&#8209;Signature header field and using the private key corresponding to the selector given in the "s=" tag of the DOSETA&#8209;Signature header field, as chosen above in <a href="#selectpriv">Section 4.5.2</a></p>
<p id="rfc.section.4.5.5.p.2">The DOSETA&#8209;Signature header field MUST be inserted before any other DOSETA&#8209;Signature fields in the header block. </p>

<dl>
<dt>NOTE: </dt>
<dd style="margin-left: 8">The easiest way to achieve this is to insert the DOSETA&#8209;Signature header field at the beginning of the header block. In particular, it might be placed before any existing Received Header fields. This is consistent with treating DOSETA&#8209;Signature as a trace header field.</dd>
</dl>
<h1 id="rfc.section.4.6">
<a href="#rfc.section.4.6">4.6.</a> <a href="#verifier" id="verifier">Verifier Actions</a>
</h1>
<p id="rfc.section.4.6.p.1">Since a signer MAY remove or revoke a public key at any time, it is recommended that verification occur in a timely manner.  In many configurations, the most timely place is during acceptance by the border MTA or shortly thereafter. In particular, deferring verification until the message is accessed by the end user is discouraged.</p>
<p id="rfc.section.4.6.p.2">A border or intermediate server MAY verify the data signature(s). An server that has performed verification MAY communicate the result of that verification by adding a verification header field to incoming data.</p>
<p id="rfc.section.4.6.p.3">A verifying server MAY implement a policy with respect to unverifiable data, regardless of whether or not it applies the verification header field to signed messages.</p>
<p id="rfc.section.4.6.p.4">Verifiers MUST produce a result that is semantically equivalent to applying the following steps in the order listed. In practice, several of these steps can be performed in parallel in order to improve performance.</p>
<h1 id="rfc.section.4.6.1">
<a href="#rfc.section.4.6.1">4.6.1.</a> <a href="#extractsig" id="extractsig">Extract Signatures from the Message</a>
</h1>
<p id="rfc.section.4.6.1.p.1">The order in which verifiers try DOSETA&#8209;Signature Header fields is not defined; verifiers MAY try signatures in any order they like. For example, one implementation might try the signatures in textual order, whereas another might try signatures by identities that match the contents of the From header field before trying other signatures.  Verifiers MUST NOT attribute ultimate meaning to the order of multiple DOSETA&#8209;Signature Header fields. In particular, there is reason to believe that some relays will reorder the Header fields in potentially arbitrary ways. </p>

<dl>
<dt>NOTE: </dt>
<dd style="margin-left: 8">Verifiers might use the order as a clue to signing order in the absence of any other information. However, other clues as to the semantics of multiple signatures (such as correlating the signing host with Received Header fields) might also be considered.</dd>
</dl>
<p id="rfc.section.4.6.1.p.2">A verifier SHOULD NOT treat a message that has one or more bad signatures and no good signatures differently from a message with no signature at all; such treatment is a matter of local policy and is beyond the scope of this document.</p>
<p id="rfc.section.4.6.1.p.3">When a signature successfully verifies, a verifier will either stop processing or attempt to verify any other signatures, at the discretion of the implementation. A verifier MAY limit the number of signatures it tries to avoid denial-of-service attacks. </p>

<dl>
<dt>NOTE: </dt>
<dd style="margin-left: 8">An attacker could send messages with large numbers of faulty signatures, each of which would require a DNS lookup and corresponding CPU time to verify the message. This could be an attack on the domain that receives the message, by slowing down the verifier by requiring it to do a large number of DNS lookups and/or signature verifications. It could also be an attack against the domains listed in the signatures, essentially by enlisting innocent verifiers in launching an attack against the DNS servers of the actual victim.</dd>
</dl>
<p id="rfc.section.4.6.1.p.4">In the following description, text reading "return status (explanation)" (where "status" is one of "PERMFAIL" or "TEMPFAIL") means that the verifier MUST immediately cease processing that signature. The verifier SHOULD proceed to the next signature, if any is present, and completely ignore the bad signature. If the status is "PERMFAIL", the signature failed and SHOULD NOT be reconsidered. If the status is "TEMPFAIL", the signature could not be verified at this time but might be tried again later. A verifier MAY either defer the message for later processing, perhaps by queueing it locally or issuing a 451/4.7.5 SMTP reply, or try another signature; if no good signature is found and any of the signatures resulted in a TEMPFAIL status, the verifier MAY save the message for later processing. The "(explanation)" is not normative text; it is provided solely for clarification.</p>
<p id="rfc.section.4.6.1.p.5">Verifiers SHOULD ignore any DOSETA&#8209;Signature Header fields where the signature does not validate. Verifiers that are prepared to validate multiple signature Header fields SHOULD proceed to the next signature header field, if it exists. However, verifiers MAY make note of the fact that an invalid signature was present for consideration at a later step. </p>

<dl>
<dt>NOTE:  </dt>
<dd style="margin-left: 8">The rationale of this requirement is to permit messages that have invalid signatures but also a valid signature to work. For example, a mailing list exploder might opt to leave the original submitter signature in place even though the exploder knows that it is modifying the message in some way that will break that signature, and the exploder inserts its own signature. In this case, the message ought to succeed even in the presence of the known-broken signature.</dd>
</dl>
<p id="rfc.section.4.6.1.p.6">For each signature to be validated, the following steps need to be performed in such a manner as to produce a result that is semantically equivalent to performing them in the indicated order.</p>
<h1 id="rfc.section.4.6.2">
<a href="#rfc.section.4.6.2">4.6.2.</a> <a href="#validatesig" id="validatesig">Validate the Signature Header Field</a>
</h1>
<p id="rfc.section.4.6.2.p.1">Implementers MUST meticulously validate the format and values in the DOSETA&#8209;Signature header field; any inconsistency or unexpected values MUST cause the header field to be completely ignored and the verifier to return PERMFAIL (signature syntax error). Being "liberal in what you accept" is definitely a bad strategy in this security context. Note however that this does not include the existence of unknown tags in a DOSETA&#8209;Signature header field, which are explicitly permitted.  </p>
<p id="rfc.section.4.6.2.p.2">If any tag listed as "required" in <a href="#signeddatastruct">Section 4.2</a> is omitted from the DOSETA&#8209;Signature header field, the verifier MUST ignore the DOSETA&#8209;Signature header field and return PERMFAIL (signature missing required tag). </p>

<dl>
<dt>NOTE:  </dt>
<dd style="margin-left: 8">The tags listed as required in <a href="#signeddatastruct">Section 4.2</a> are "v=", "a=", "b=", "bh=", "d=", "h=", and "s=". Should there be a conflict between this note and <a href="#signeddatastruct">Section 4.2</a>, is normative.</dd>
</dl>
<p id="rfc.section.4.6.2.p.3">If the DOSETA&#8209;Signature header field does not contain the "i" parameter, the verifier MUST behave as though the value of that tag were "@d", where "d" is the value from the "d=" tag.</p>
<p id="rfc.section.4.6.2.p.4">Verifiers MUST confirm that the domain specified in the "d=" tag is the same as or a parent domain of the domain part of the "i" parameter. If not, the DOSETA&#8209;Signature header field MUST be ignored and the verifier SHOULD return PERMFAIL (domain mismatch).</p>
<p id="rfc.section.4.6.2.p.5">If the "h" parameter does not include the From header field, the verifier MUST ignore the DOSETA&#8209;Signature header field and return PERMFAIL (From field not signed).</p>
<p id="rfc.section.4.6.2.p.6">Verifiers MAY ignore the DOSETA&#8209;Signature header field and return PERMFAIL (signature expired) if it contains an "x" parameter and the signature has expired.</p>
<p id="rfc.section.4.6.2.p.7">Verifiers MAY ignore the DOSETA&#8209;Signature header field if the domain used by the signer in the "d" parameter is not associated with a valid signing entity. For example, signatures with "d=" values such as "com" and "co.uk" might be ignored. The list of unacceptable domains SHOULD be configurable.</p>
<p id="rfc.section.4.6.2.p.8">Verifiers MAY ignore the DOSETA&#8209;Signature header field and return PERMFAIL (unacceptable signature header) for any other reason, for example, if the signature does not sign Header fields that the verifier views to be essential. As a case in point, if MIME Header fields are not signed, certain attacks might be possible that the verifier would prefer to avoid.</p>
<h1 id="rfc.section.4.6.3">
<a href="#rfc.section.4.6.3">4.6.3.</a> Get the Public Key</h1>
<p id="rfc.section.4.6.3.p.1">The public key for a signature is needed to complete the verification process. The process of retrieving the public key depends on the query type as defined by the "q" parameter in the DOSETA&#8209;Signature header field.  Obviously, a public key need only be retrieved if the process of extracting the signature information is completely successful. Details of key management and representation are described in <a href="#keymgmt">Section 3.4</a>. The verifier MUST validate the key record and MUST ignore any public key records that are malformed.</p>
<p></p>

<dl>
<dt>NOTE:</dt>
<dd style="margin-left: 8">The use of wildcard TXT records in the DNS will produce a response to a DOSETA query that is unlikely to be valid DOSETA key record. This problem applies to many other types of queries, and client software that processes DNS responses needs to take this problem into account.</dd>
</dl>

<p> </p>
<p id="rfc.section.4.6.3.p.3">When validating a message, a verifier MUST perform the following steps in a manner that is semantically the same as performing them in the following order -- in some cases the implementation might parallelize or reorder these steps, as long as the semantics remain unchanged: </p>

<ol>
<li>Retrieve the public key as described in <a href="#keymgmt">Section 3.4</a> using the algorithm in the "q=" tag, the domain from the "d" parameter, and the selector from the "s" parameter.</li>
<li>If the query for the public key fails to respond, the verifier MAY defer acceptance of this data and return TEMPFAIL - key unavailable. (If verification is occurring during the incoming SMTP session, this MAY be achieved with a 451/4.7.5 SMTP reply code.) Alternatively, the verifier MAY store the message in the local queue for later trial or ignore the signature. Note that storing a message in the local queue is subject to denial-of- service attacks.</li>
<li>If the query for the public key fails because the corresponding key record does not exist, the verifier MUST immediately return PERMFAIL (no key for signature).</li>
<li>If the query for the public key returns multiple key records, the verifier might choose one of the key records or might cycle through the key records performing the remainder of these steps on each record at the discretion of the implementer. The order of the key records is unspecified. If the verifier chooses to cycle through the key records, then the "return ..." wording in the remainder of this section means "try the next key record, if any; if none, return to try another signature in the usual way".</li>
<li>If the result returned from the query does not adhere to the format defined in this specification, the verifier MUST ignore the key record and return PERMFAIL (key syntax error). Verifiers are urged to validate the syntax of key records carefully to avoid attempted attacks.  </li>
<li>If the "h" parameter exists in the public key record and the hash algorithm implied by the a= tag in the DOSETA&#8209;Signature header field is not included in the contents of the "h" parameter, the verifier MUST ignore the key record and return PERMFAIL (inappropriate hash algorithm).</li>
<li>If the public key data (the "p" parameter) is empty, then this key has been revoked and the verifier MUST treat this as a failed signature check and return PERMFAIL (key revoked). There is no defined semantic difference between a key that has been revoked and a key record that has been removed.</li>
<li>If the public key data is not suitable for use with the algorithm and key types defined by the "a=" and "k" parameters in the DOSETA&#8209;Signature header field, the verifier MUST immediately return PERMFAIL (inappropriate key algorithm).</li>
</ol>
<h1 id="rfc.section.4.6.4">
<a href="#rfc.section.4.6.4">4.6.4.</a> Compute the Verification</h1>
<p id="rfc.section.4.6.4.p.1">Given a signer and a public key, verifying a signature consists of actions semantically equivalent to the following steps. </p>

<ol>
<li>Based on the algorithm defined in the "c" parameter, the Content length specified in the "l" parameter, and the header field names in the "h" parameter, prepare a canonicalized version of the Content as is described in <a href="#sigcalc">Section 4.4</a> (note that this version does not actually need to be instantiated). When matching header field names in the "h" parameter against the actual message header field, comparisons MUST be case-insensitive.</li>
<li>Based on the algorithm indicated in the "a" parameter, compute the message hashes from the canonical copy as described in <a href="#sigcalc">Section 4.4</a>
</li>
<li>Verify that the hash of the canonicalized Content computed in the previous step matches the hash value conveyed in the "bh" parameter. If the hash does not match, the verifier SHOULD ignore the signature and return PERMFAIL (Content hash did not verify).</li>
<li>Using the signature conveyed in the "b" parameter, verify the signature against the header hash using the mechanism appropriate for the public key algorithm described in the "a" parameter. If the signature does not validate, the verifier SHOULD ignore the signature and return PERMFAIL (signature did not verify).</li>
<li>Otherwise, the signature has correctly verified.</li>
</ol>

<p> </p>

<dl>
<dt>NOTE:  </dt>
<dd style="margin-left: 8">Implementations might wish to initiate the public-key query in parallel with calculating the hash as the public key is not needed until the final decryption is calculated.  Implementations might also verify the signature on the message header before validating that the message hash listed in the "bh" parameter in the DOSETA&#8209;Signature header field matches that of the actual Content; however, if the Content hash does not match, the entire signature MUST be considered to have failed.</dd>
</dl>

<p> </p>
<h1 id="rfc.section.4.6.5">
<a href="#rfc.section.4.6.5">4.6.5.</a> Communicate Verification Results</h1>
<p id="rfc.section.4.6.5.p.1">Verifiers wishing to communicate the results of verification to other parts of the data handling system can do so in whatever manner they see fit. For example, implementations might choose to add a Header field to the data before passing it on. Any such header field SHOULD be inserted before any existing DOSETA&#8209;Signature or preexisting verification status Header fields in the header field block.  The Authentication-Results: header field (<a href="#RFC5451">[RFC5451]</a>) MAY be used for this purpose. </p>

<ul class="empty"><li>Patterns intended to search for results Header fields to visibly mark authenticated data for end users SHOULD verify that the header field was added by the appropriate verifying domain In particular, filters SHOULD NOT be influenced by bogus results header fields added by attackers. To circumvent this attack, verifiers SHOULD delete existing results Header fields after verification and before adding a new header field.</li></ul>
<h1 id="rfc.section.4.6.6">
<a href="#rfc.section.4.6.6">4.6.6.</a> Interpret Results/Apply Local Policy</h1>
<p id="rfc.section.4.6.6.p.1">It is beyond the scope of this specification to describe what actions an Assessment phase will take, but data with a verified DOSETA signature presents an opportunity to an Assessor that unsigned data does not. Specifically, signed data creates a predictable identifier by which other decisions can reliably be managed, such as trust and reputation. Conversely, unsigned data typically lacks a reliable identifier that can be used to assign trust and reputation. It is usually reasonable to treat unsigned data as lacking any trust and having no positive reputation.</p>
<p id="rfc.section.4.6.6.p.2">In general, verifiers SHOULD NOT reject data solely on the basis of a lack of signature or an unverifiable signature; such rejection would cause severe interoperability problems.  However, if the verifier does opt to reject such data</p>
<p id="rfc.section.4.6.6.p.3">Temporary failures such as inability to access the key server or other external service are the only conditions that SHOULD use a temporary failure code. In particular, cryptographic signature verification failures MUST NOT return temporary failure replies.</p>
<p id="rfc.section.4.6.6.p.4">Once the signature has been verified, that information MUST be conveyed to the Assessor (such as an explicit allow/whitelist and reputation system) and/or to the end user. If the DDI is not the same as the address in the From: header field, the data system SHOULD take pains to ensure that the actual DDI is clear to the reader.</p>
<p id="rfc.section.4.6.6.p.5">The verifier MAY treat unsigned Header fields with extreme skepticism, including marking them as untrusted or even deleting them.</p>
<p id="rfc.section.4.6.6.p.6">While the symptoms of a failed verification are obvious -- the signature doesn't verify -- establishing the exact cause can be more difficult. If a selector cannot be found, is that because the selector has been removed, or was the value changed somehow in transit? If the signature line is missing, is that because it was never there, or was it removed by an overzealous filter? For diagnostic purposes, the exact nature of a verification failure SHOULD be made available to the policy module and possibly recorded in the system logs. If the data cannot be verified, then it SHOULD be rendered the same as all unverified data regardless of whether or not it looks like it was signed.</p>
<h1 id="rfc.section.4.7">
<a href="#rfc.section.4.7">4.7.</a> Requirements for Tailoring the Signing Service</h1>
<p id="rfc.section.4.7.p.1">This generic template requires additional details, to define a specific service:</p>

<ul class="empty"><li><dl>
<dt>Association: </dt>
<dd style="margin-left: 8">Specify the means by which the signature field is associated with the data it signs. This identifies the specific signing service and the mechanics of attaching the signature. For example, DKIM uses the DKIM&#8209;Signature email header field. If the header field is encoded differently than defined for the DOSETA generic service, such as in XML or JSON, then that also needs to be specified, including the algorithm for mapping between the common encoding provided here and the new encoding.</dd>
<dt>Semantics:  </dt>
<dd style="margin-left: 8">Define the meaning(s) of a signature that is intended by the signer. Note that exactly the same algorithms might be used for very different semantics. One might merely affix an identifier to some data, in a verifiable fashion, while the same set of mechanisms might separately be defined as authenticating the validity of that data. A single service can support multiple semantics for a signature. These SHOULD be specified using the "cl=" claims mechanism defined in <a href="#signeddatastruct">Section 4.2</a> and <a href="#dosetaclaims">Section 6</a> with values listed in <a href="#ianaclaims">Section 7.1.2</a> </dd>
<dt>Structural Mapping:  </dt>
<dd style="margin-left: 8">The mappings between the template's generic service and data of a particular service needs to be defined. For example, with DKIM the DOSETA Header maps to the email header and DOSETA Content maps to the email body.</dd>
<dt>Required Fields:  </dt>
<dd style="margin-left: 8">Specify the header fields that MUST, SHOULD or MAY be included in the signature calculation.</dd>
<dt>Required Algorithms:  </dt>
<dd style="margin-left: 8">Specify the hashing and signing algorithms that MUST, SHOULD or MAY be supported by participants in the service.</dd>
</dl></li></ul>

<p> </p>
<h1 id="rfc.section.5">
<a href="#rfc.section.5">5.</a> <a href="#multisig" id="multisig">Semantics of Multiple Signatures</a>
</h1>
<h1 id="rfc.section.5.1">
<a href="#rfc.section.5.1">5.1.</a> Example Scenarios</h1>
<p id="rfc.section.5.1.p.1">There are many reasons why a message might have multiple signatures. For example, a given signer might sign multiple times, perhaps with different hashing or signing algorithms during a transition phase. </p>

<dl>
<dt>EXAMPLE: </dt>
<dd style="margin-left: 8">Suppose SHA-256 is in the future found to be insufficiently strong, and DOSETA usage transitions to SHA-1024. A signer might immediately sign using the newer algorithm, but continue to sign using the older algorithm for interoperability with verifiers that had not yet upgraded. The signer would do this by adding two DOSETA&#8209;Signature Header fields, one using each algorithm. Older verifiers that did not recognize SHA-1024 as an acceptable algorithm would skip that signature and use the older algorithm; newer verifiers could use either signature at their option, and all other things being equal might not even attempt to verify the other signature.</dd>
</dl>
<p id="rfc.section.5.1.p.2">Similarly, a signer might sign a message including all headers and no "l" parameter (to satisfy strict verifiers) and a second time with a limited set of headers and an "l" parameter (in anticipation of possible message modifications in route to other verifiers). Verifiers could then choose which signature they preferred. </p>

<dl>
<dt>EXAMPLE: </dt>
<dd style="margin-left: 8">A verifier might receive data with two signatures, one covering more of the data than the other. If the signature covering more of the data verified, then the verifier could make one set of policy decisions; if that signature failed but the signature covering less of the data verified, the verifier might make a different set of policy decisions.</dd>
</dl>
<p id="rfc.section.5.1.p.3">Of course, a message might also have multiple signatures because it passed through multiple signers. A common case is expected to be that of a signed message that passes through a mailing list that also signs all messages. Assuming both of those signatures verify, a recipient might choose to accept the message if either of those signatures were known to come from trusted sources. </p>

<dl>
<dt>EXAMPLE: </dt>
<dd style="margin-left: 8">Recipients might choose to whitelist mailing lists to which they have subscribed and that have acceptable anti- abuse policies so as to accept messages sent to that list even from unknown authors. They might also subscribe to less trusted mailing lists (for example, those without anti-abuse protection) and be willing to accept all messages from specific authors, but insist on doing additional abuse scanning for other messages.</dd>
</dl>
<p id="rfc.section.5.1.p.4">Another related example of multiple signers might be forwarding services, such as those commonly associated with academic alumni sites. </p>

<dl>
<dt>EXAMPLE: </dt>
<dd style="margin-left: 8">A recipient might have an address at members.example.org, a site that has anti-abuse protection that is somewhat less effective than the recipient would prefer. Such a recipient might have specific authors whose messages would be trusted absolutely, but messages from unknown authors that had passed the forwarder's scrutiny would have only medium trust.</dd>
</dl>
<h1 id="rfc.section.5.2">
<a href="#rfc.section.5.2">5.2.</a> Interpretation</h1>
<p id="rfc.section.5.2.p.1">A signer that is adding a signature to a message merely creates a new DOSETA&#8209;Signature header, using the usual semantics of the h= option. A signer MAY sign previously existing DOSETA&#8209;Signature Header fields using the method described in <a href="#fields2sign">Section 4.5.3</a> to sign trace Header fields. </p>

<dl>
<dt>NOTE:  </dt>
<dd style="margin-left: 8">Signers need to be cognizant that signing DOSETA&#8209;Signature Header fields might result in verification failures due to modifications by intermediaries, such as their reordering DOSETA&#8209;Signature header fields. For this reason, signing existing DOSETA&#8209;Signature Header fields is unadvised, albeit legal.</dd>
<dt>NOTE: </dt>
<dd style="margin-left: 8">If a header field with multiple instances is signed, those header fields are always signed from the "bottom" up (from last to first). Thus, it is not possible to sign only specific instances of header fields. For example, if the message being signed already contains three DOSETA&#8209;Signature header fields (from the bottom, up) A, B, and C, it is possible to sign all of them, A and B only, or A only, but not C only, B only, B and C only, or A and C only.</dd>
</dl>
<p id="rfc.section.5.2.p.2">A signer MAY add more than one DOSETA&#8209;Signature header field using different parameters. For example, during a transition period a signer might want to produce signatures using two different hash algorithms.</p>
<p id="rfc.section.5.2.p.3">Signers SHOULD NOT remove any DOSETA&#8209;Signature Header fields from messages they are signing, even if they know that the signatures cannot be verified.</p>
<p id="rfc.section.5.2.p.4">When evaluating a message with multiple signatures, a verifier SHOULD evaluate signatures independently and on their own merits. For example, a verifier that by policy chooses not to accept signatures with deprecated cryptographic algorithms would consider such signatures invalid. Verifiers MAY process signatures in any order of their choice; for example, some verifiers might choose to process signatures corresponding to the From field in the message header before other signatures.  See <a href="#extractsig">Section 4.6.1</a> for more information about signature choices. </p>

<dl>
<dt>NOTE:  </dt>
<dd style="margin-left: 8">Verifier attempts to correlate valid signatures with invalid signatures in an attempt to guess why a signature failed are ill-advised. In particular, there is no general way that a verifier can determine that an invalid signature was ever valid.</dd>
</dl>
<p id="rfc.section.5.2.p.5">Verifiers SHOULD ignore failed signatures as though they were not present in the message. Verifiers SHOULD continue to check signatures until a signature successfully verifies to the satisfaction of the verifier. To limit potential denial-of-service attacks, verifiers MAY limit the total number of signatures they will attempt to verify.</p>
<h1 id="rfc.section.6">
<a href="#rfc.section.6">6.</a> <a href="#dosetaclaims" id="dosetaclaims">DOSETA Claims Registry Definition</a>
</h1>
<p id="rfc.section.6.p.1">A registry entry MUST contain: <a href="#ianaclaims">Section 7.1.2</a></p>

<ul class="empty"><li><dl>
<dt>Label:  </dt>
<dd style="margin-left: 8">Specifies a textual name for claim, to be used in the "cl=" tag.</dd>
<dt>Description:  </dt>
<dd style="margin-left: 8">Explains the semantics of the claim being asserted.</dd>
</dl></li></ul>

<p> The registry entries are contained in the IANA DOSETA Claims Registry, defined in </p>
<h1 id="rfc.section.7">
<a href="#rfc.section.7">7.</a> Considerations</h1>
<h1 id="rfc.section.7.1">
<a href="#rfc.section.7.1">7.1.</a> <a href="#iana" id="iana">IANA Considerations</a>
</h1>
<h1 id="rfc.section.7.1.1">
<a href="#rfc.section.7.1.1">7.1.1.</a> DKIM Registries</h1>
<p id="rfc.section.7.1.1.p.1">DOSETA relies on IANA registration data bases specified by DKIM <a href="#DKIMSign">[DKIMSign]</a>. Services that incorporate DOSETA might need to define new registries or add to existing ones.</p>
<h1 id="rfc.section.7.1.2">
<a href="#rfc.section.7.1.2">7.1.2.</a> <a href="#ianaclaims" id="ianaclaims">Claims Registry</a>
</h1>
<p id="rfc.section.7.1.2.p.1">Per <a href="#RFC2434">[RFC2434]</a>, IANA is requested to establish a DOSETA Claims Registry, for assertions (claims) that are meant by the presence of the DOSETA-based signature that contains the claims. See <a href="#dosetaclaims">Section 6</a> for the definition of the columns in the registry table.</p>
<div id="#rfc.table.1"></div>
<div id="#underscope"></div>
<table cellpadding="3" cellspacing="0" class="tt full left">
<caption>DOSETA Claim Registry                 (with initial values)</caption>
<thead><tr>
<th class="left">LABEL</th>
<th class="left">CLAIM DESCRIPTION</th>
</tr></thead>
<tbody>
<tr>
<td class="left">handled</td>
<td class="left">The signer claims they have had a role in processing the object. (This claim is approximately equivalent to the semantics of DKIM.)</td>
</tr>
<tr>
<td class="left">validauth</td>
<td class="left">If there is a standardized field listing the purported author of the data, the signer claims that the value in that field is valid.</td>
</tr>
<tr>
<td class="left">validdata</td>
<td class="left">The signer claims that all of the data in the object valid.</td>
</tr>
<tr>
<td class="left">validfields</td>
<td class="left">The signer claims that the portions of the object that are covered by the signature hash are valid.</td>
</tr>
</tbody>
</table>
<h1 id="rfc.section.7.2">
<a href="#rfc.section.7.2">7.2.</a> <a href="#security" id="security">Security Considerations</a>
</h1>
<p id="rfc.section.7.2.p.1">Any mechanism that attempts to prevent or detect abuse is subject to intensive attack. DOSETA needs to be carefully scrutinized to identify potential attack vectors and the vulnerability to each. See also <a href="#RFC4686">[RFC4686]</a>.</p>
<p id="rfc.section.7.2.p.2">DOSETA core technology derives from DKIM <a href="#DKIMSign">[DKIMSign]</a>. The Security Considerations of that specification applies equally to DOSETA.</p>
<p id="rfc.section.7.2.p.3">The DOSETA "cl=" claims list provides a list of claimed meanings for a DOSETA signature. An opportunity for security problems comes from failing to distinguish between a signer "claim" and claim validity. Whether to trust claims made by a signer requires a level of assessment beyond DOSETA. </p>
<h1 id="rfc.references">
<a href="#rfc.references">8.</a> References</h1>
<h1 id="rfc.references.1">
<a href="#rfc.references.1">8.1.</a> Normative References</h1>
<table><tbody>
<tr>
<td class="reference"><b id="FIPS-180-2-2002">[FIPS-180-2-2002]</b></td>
<td class="top">
<a>U.S. Department of Commerce, </a>, "<a>Secure Hash Standard</a>", FIPS PUB 180-2, August 2002.</td>
</tr>
<tr>
<td class="reference"><b id="ITU-X660-1997">[ITU-X660-1997]</b></td>
<td class="top">
<a>Information Technology - ASN.1 encoding rules: Specification of Basic Encoding Rules (BER), Canonical Encoding Rules (CER) and Distinguished Encoding Rules (DER)</a>", 1997.</td>, "</tr>
<tr>
<td class="reference"><b id="RFC1034">[RFC1034]</b></td>
<td class="top">
<a>Mockapetris, P.</a>, "<a href="http://tools.ietf.org/html/rfc1034">DOMAIN NAMES - CONCEPTS AND FACILITIES</a>", RFC 1034, November 1987.</td>
</tr>
<tr>
<td class="reference"><b id="RFC2045">[RFC2045]</b></td>
<td class="top">
<a href="mailto:ned@innosoft.com" title="Innosoft International, Inc.">Freed, N.</a> and <a href="mailto:nsb@nsb.fv.com" title="First Virtual Holdings">N.S. Borenstein</a>, "<a href="http://tools.ietf.org/html/rfc2045">Multipurpose Internet Mail Extensions (MIME) Part One: Format of Internet Message Bodies</a>", RFC 2045, November 1996.</td>
</tr>
<tr>
<td class="reference"><b id="RFC2049">[RFC2049]</b></td>
<td class="top">
<a href="mailto:ned@innosoft.com" title="Innosoft International, Inc.">Freed, N.</a> and <a href="mailto:nsb@nsb.fv.com" title="First Virtual Holdings">N.S. Borenstein</a>, "<a href="http://tools.ietf.org/html/rfc2049">Multipurpose Internet Mail Extensions (MIME) Part Five: Conformance Criteria and Examples</a>", RFC 2049, November 1996.</td>
</tr>
<tr>
<td class="reference"><b id="RFC2119">[RFC2119]</b></td>
<td class="top">
<a href="mailto:sob@harvard.edu" title="Harvard University">Bradner, S.</a>, "<a href="http://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>", BCP 14, RFC 2119, March 1997.</td>
</tr>
<tr>
<td class="reference"><b id="RFC2434">[RFC2434]</b></td>
<td class="top">
<a title="IBM">Narten, T.</a> and <a title="Maxware">H. Alvestrand</a>, "<a href="http://tools.ietf.org/html/rfc2434">Guidelines for Writing an IANA Considerations Section in RFCs</a>", RFC 2434, October 1998.</td>
</tr>
<tr>
<td class="reference"><b id="RFC3447">[RFC3447]</b></td>
<td class="top">
<a>Jonsson, J.</a> and <a>B. Kaliski</a>, "<a href="http://tools.ietf.org/html/rfc3447">Public-Key Cryptography Standards (PKCS) #1: RSA Cryptography Specifications Version 2.1</a>", RFC 3447, February 2003.</td>
</tr>
<tr>
<td class="reference"><b id="RFC5321">[RFC5321]</b></td>
<td class="top">
<a>Klensin, J.</a>, "<a href="http://tools.ietf.org/html/rfc5321">Simple Mail Transfer Protocol</a>", RFC 5321, October 2008.</td>
</tr>
<tr>
<td class="reference"><b id="RFC5322">[RFC5322]</b></td>
<td class="top">
<a>Resnick, P.</a>, "<a href="http://tools.ietf.org/html/rfc5322">Internet Message Format</a>", RFC 5322, October 2008.</td>
</tr>
<tr>
<td class="reference"><b id="RFC5234">[RFC5234]</b></td>
<td class="top">
<a href="mailto:dcrocker@bbiw.net" title="Brandenburg InternetWorking">Crocker, D.</a> and <a href="mailto:paul.overell@thus.net" title="THUS plc.">P. Overell</a>, "<a href="http://tools.ietf.org/html/rfc4234">Augmented BNF for Syntax Specifications: ABNF</a>", RFC 4234, January 2008.</td>
</tr>
<tr>
<td class="reference"><b id="RFC5890">[RFC5890]</b></td>
<td class="top">
<a>Klensin, J.</a>, "<a href="http://tools.ietf.org/html/rfc5890">Internationalizing Domain Names in Applications (IDNA): Definitions and Document Framework</a>", RFC 5890, August 2010.</td>
</tr>
</tbody></table>
<h1 id="rfc.references.2">
<a href="#rfc.references.2">8.2.</a> Informative References</h1>
<table><tbody>
<tr>
<td class="reference"><b id="mimeauth">[mimeauth]</b></td>
<td class="top">
<a href="mailto:dcrocker@bbiw.net" title="Brandenburg InternetWorking">Crocker, D.</a> and <a href="mailto:msk@cloudmark.com" title="Cloudmark">M. Kucherawy</a>, "<a>MIME Content Authentication using DOSETA (MIMEAUTH) </a>", I-D draft-crocker-doseta-mimeauth, 2011.</td>
</tr>
<tr>
<td class="reference"><b id="RFC1847">[RFC1847]</b></td>
<td class="top">
<a href="mailto:galvin@tis.com" title="Trusted Information Systems">Galvin, J.</a>, <a href="mailto:sandy@tis.com" title="Trusted Information Systems">Murphy, S.</a>, <a href="mailto:crocker@cybercash.com" title="CyberCash, Inc.">Crocker, S.</a> and <a href="mailto:ned@innosoft.com" title="Innosoft International, Inc.">N. Freed</a>, "<a href="http://tools.ietf.org/html/rfc1847">Security Multiparts for MIME: Multipart/Signed and Multipart/Encrypted</a>", RFC 1847, October 1995.</td>
</tr>
<tr>
<td class="reference"><b id="RFC2047">[RFC2047]</b></td>
<td class="top">
<a href="mailto:moore@cs.utk.edu" title="University of Tennessee">Moore, K.</a>, "<a href="http://tools.ietf.org/html/rfc2047">MIME (Multipurpose Internet Mail Extensions) Part Three: Message Header Extensions for Non-ASCII Content</a>", RFC 2047, November 1996.</td>
</tr>
<tr>
<td class="reference"><b id="RFC4880">[RFC4880]</b></td>
<td class="top">
<a href="mailto:jon@pgp.com" title="Network Associates, Inc.">Callas, J.</a>, <a href="mailto:lutz@iks-jena.de" title="IKS GmbH">Donnerhacke, L.</a>, <a href="mailto:hal@pgp.com" title="Network Associates, Inc.">Finney, H.</a> and <a href="mailto:rodney@unitran.com" title="EIS Corporation">R. Thayer</a>, "<a href="http://tools.ietf.org/html/rfc4880">OpenPGP Message Format</a>", RFC 4880, November 2007.</td>
</tr>
<tr>
<td class="reference"><b id="RFC3766">[RFC3766]</b></td>
<td class="top">
<a>Orman, H.</a> and <a>P. Hoffman</a>, "<a href="http://tools.ietf.org/html/rfc3766">Determining Strengths For Public Keys Used For Exchanging Symmetric Keys</a>", BCP 86, RFC 3766, April 2004.</td>
</tr>
<tr>
<td class="reference"><b id="RFC4033">[RFC4033]</b></td>
<td class="top">
<a>Arends, R.</a>, <a>Austein, R.</a>, <a>Larson, M.</a>, <a>Massey, D.</a> and <a>S. Rose</a>, "<a href="http://tools.ietf.org/html/rfc4033">DNS Security Introduction and Requirements</a>", RFC 4033, March 2005.</td>
</tr>
<tr>
<td class="reference"><b id="RFC4409">[RFC4409]</b></td>
<td class="top">
<a title="QUALCOMM">Gellens, R.</a> and <a>J. Klensin</a>, "<a href="http://tools.ietf.org/html/rfc4409">Message Submission for Mail</a>", RFC 4409, April 2006.</td>
</tr>
<tr>
<td class="reference"><b id="RFC4686">[RFC4686]</b></td>
<td class="top">
<a>Fenton, J.</a>, "<a href="http://tools.ietf.org/html/rfc4686">Analysis of Threats Motivating DomainKeys Identified Mail (DKIM)</a>", RFC 4686, September 2006.</td>
</tr>
<tr>
<td class="reference"><b id="RFC4870">[RFC4870]</b></td>
<td class="top">
<a>Delany, M.</a>, "<a href="http://tools.ietf.org/html/rfc4870">Domain-Based Email Authentication Using Public Keys Advertised in the DNS (DomainKeys)</a>", RFC 4870, May 2007.</td>
</tr>
<tr>
<td class="reference"><b id="DKIMSign">[DKIMSign]</b></td>
<td class="top">
<a>Allman, E.</a>, <a>Callas, J.</a>, <a>Delany, M.</a>, <a>Libbey, M.</a>, <a>Fenton, J.</a> and <a>M. Thomas</a>, "<a href="http://tools.ietf.org/html/rfc4871">DomainKeys Identified Mail (DKIM) Signatures</a>", RFC 4871, May 2007.</td>
</tr>
<tr>
<td class="reference"><b id="RFC5451">[RFC5451]</b></td>
<td class="top">
<a>Kucherawy, M.</a>, "<a href="http://tools.ietf.org/html/rfc5451">Message Header Field for Indicating Message Authentication Status</a>", RFC 5451, April 2009.</td>
</tr>
<tr>
<td class="reference"><b id="RFC5672">[RFC5672]</b></td>
<td class="top">
<a href="mailto:dcrocker@bbiw.net" title="Brandenburg InternetWorking">Crocker, D.</a>, "<a href="http://tools.ietf.org/html/rfc5672">RFC 4871 DomainKeys Identified Mail (DKIM) Signatures: Update</a>", RFC 5672, August 2009.</td>
</tr>
<tr>
<td class="reference"><b id="UTF8">[UTF8]</b></td>
<td class="top">
<a title="Alis Technologies">Yergeau, F.</a>, "<a href="http://tools.ietf.org/html/rfc3629">UTF-8, a transformation format of ISO 10646</a>", RFC 3629, November 2003.</td>
</tr>
</tbody></table>
<h1 id="rfc.appendix.Appendix A">
<a href="#rfc.appendix.Appendix%20A">Appendix A.</a> <a href="#createpkey" id="createpkey">Creating a Public Key</a>
</h1>
<div id="#rfc.figure.42"></div>
<pre>$ openssl genrsa -out rsa.private 1024</pre>
<p id="rfc.section.Appendix A.p.1">The default signature is an RSA signed SHA256 digest of the complete email. For ease of explanation, the openssl command is used to describe the mechanism by which keys and signatures are managed. One way to generate a 1024-bit, unencrypted private key suitable for DOSETA is to use openssl like this: </p>
<div id="#rfc.figure.43"></div>
<p></p>

<p>The "genrsa" step results in the file rsa.private containing the key information similar to this:</p>
<pre>-----BEGIN RSA PRIVATE KEY-----
MIICXwIBAAKBgQDwIRP/UC3SBsEmGqZ9ZJW3/DkMoGeLnQg1fWn7/zYtIxN2SnFC
jxOCKG9v3b4jYfcTNh5ijSsq631uBItLa7od+v/RtdC2UzJ1lWT947qR+Rcac2gb
to/NMqJ0fzfVjH4OuKhitdY9tf6mcwGjaNBcWToIMmPSPDdQPNUYckcQ2QIDAQAB
AoGBALmn+XwWk7akvkUlqb+dOxyLB9i5VBVfje89Teolwc9YJT36BGN/l4e0l6QX
/1//6DWUTB3KI6wFcm7TWJcxbS0tcKZX7FsJvUz1SbQnkS54DJck1EZO/BLa5ckJ
gAYIaqlA9C0ZwM6i58lLlPadX/rtHb7pWzeNcZHjKrjM461ZAkEA+itss2nRlmyO
n1/5yDyCluST4dQfO8kAB3toSEVc7DeFeDhnC1mZdjASZNvdHS4gbLIA1hUGEF9m
3hKsGUMMPwJBAPW5v/U+AWTADFCS22t72NUurgzeAbzb1HWMqO4y4+9Hpjk5wvL/
eVYizyuce3/fGke7aRYw/ADKygMJdW8H/OcCQQDz5OQb4j2QDpPZc0Nc4QlbvMsj
7p7otWRO5xRa6SzXqqV3+F0VpqvDmshEBkoCydaYwc2o6WQ5EBmExeV8124XAkEA
qZzGsIxVP+sEVRWZmW6KNFSdVUpk3qzK0Tz/WjQMe5z0UunY9Ax9/4PVhp/j61bf
eAYXunajbBSOLlx4D+TunwJBANkPI5S9iylsbLs6NkaMHV6k5ioHBBmgCak95JGX
GMot/L2x0IYyMLAz6oLWh2hm7zwtb0CgOrPo1ke44hFYnfc=
-----END RSA PRIVATE KEY-----</pre>
<div id="#rfc.figure.44"></div>
<p></p>

<p>To extract the public-key component from the private key, use openssl like this:</p>
<pre>$ openssl rsa -in rsa.private -out rsa.public -pubout -outform PEM</pre>
<div id="#rfc.figure.45"></div>
<p></p>

<p>This results in the file rsa.public containing the key information similar to this:</p>
<pre>-----BEGIN PUBLIC KEY-----
MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDwIRP/UC3SBsEmGqZ9ZJW3/DkM
oGeLnQg1fWn7/zYtIxN2SnFCjxOCKG9v3b4jYfcTNh5ijSsq631uBItLa7od+v/R
tdC2UzJ1lWT947qR+Rcac2gbto/NMqJ0fzfVjH4OuKhitdY9tf6mcwGjaNBcWToI
MmPSPDdQPNUYckcQ2QIDAQAB
-----END PUBLIC KEY-----</pre>
<div id="#rfc.figure.46"></div>
<p>This public-key data (without the BEGIN and END tags) is placed in the DNS:</p>
<pre>
brisbane IN  TXT  
        ("v=DKIM1; p=MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQ"
         "KBgQDwIRP/UC3SBsEmGqZ9ZJW3/DkMoGeLnQg1fWn7/zYt"
         "IxN2SnFCjxOCKG9v3b4jYfcTNh5ijSsq631uBItLa7od+v"
         "/RtdC2UzJ1lWT947qR+Rcac2gbto/NMqJ0fzfVjH4OuKhi"
         "tdY9tf6mcwGjaNBcWToIMmPSPDdQPNUYckcQ2QIDAQAB")</pre>
<h1 id="rfc.appendix.Appendix B">
<a href="#rfc.appendix.Appendix%20B">Appendix B.</a> Acknowledgements</h1>
<p id="rfc.section.Appendix B.p.1">DOSETA is derived from DKIM <a href="#DKIMSign">[DKIMSign]</a>. DKIM is an evolution of DomainKeys <a href="#RFC4870">[RFC4870]</a>, which was developed by Mark Delany, then of Yahoo!. In particular, the key management service, based on the DNS, and the user-INvisible tagging scheme was developed by him.</p>
<h1 id="rfc.appendix.Appendix C">
<a href="#rfc.appendix.Appendix%20C">Appendix C.</a> Example -- DKIM Using DOSETA</h1>
<p id="rfc.section.Appendix C.p.1">This example re-specifies DKIM in terms of DOSETA, while retaining bit-level compatibility with the existing DKIM specification <a href="#DKIMSign">[DKIMSign]</a>.</p>

<dl>
<dt>NOTE: </dt>
<dd style="margin-left: 8">This section is merely an example. Any use of normative language in this section is strictly for completness of the example and has no normative effect on the DOSETA specification.</dd>
</dl>
<h1 id="rfc.appendix.Appendix C.1">
<a href="#rfc.appendix.Appendix%20C.1">Appendix C.1.</a> Signing and Verification Protocol</h1>
<p id="rfc.section.Appendix C.1.p.1">The DOSETA template specifies TEMPLATE information that is required to tailor the signing service:</p>

<ul class="empty"><li><dl>
<dt>Association: </dt>
<dd style="margin-left: 8">The DOSETA&#8209;Signature data are stored in a DKIM&#8209;Signature header field that is part of the header of the message being signed. This contains all of the signature and key-fetching data, per <a href="#signeddatastruct">Section 4.2</a>.</dd>
<dt>Semantics:  </dt>
<dd style="margin-left: 8">A DKIM signature means that the owner of the signing domain is taking "some" responsibility for the message. Hence, the payload, or output, of DKIM is:<ul>
<li>A validated domain name, specifically the d= parameter in the DKIM&#8209;Signature header field</li>
<li>An indication that its use has been validated</li>
</ul>
<p> The nature and extent of a DKIM signer's responsibility can vary widely and is beyond the scope of this specification.</p>
</dd>
<dt>Structural Mapping:  </dt>
<dd style="margin-left: 8">DKIM maps the DOSETA Header processing to an email header and the DOSETA Content to an email body, per <a href="#RFC5322">[RFC5322]</a>
</dd>
<dt>Required Support</dt>
<dd style="margin-left: 8"><dl>
<dt>Field Hash: </dt>
<dd style="margin-left: 8">The basic rule for choosing fields to include is to select those fields that constitute the "core" of the message content. Hence, any replay attack will have to include these in order to have the signature succeed; but with these included, the core of the message is valid, even if sent on to new recipients. </dd>
<dt></dt>
<dd style="margin-left: 8">Common examples of fields with addresses and fields with textual content related to the body are: From (MUST be included), Reply-To, Subject, Date, To, Cc, Resent-Date, Resent-From, Resent-To, Resent-Cc, In-Reply-To, References, List-Id, List-Help, List-Unsubscribe, List-Subscribe, List-Post, List-Owner, List-Archive.</dd>
<dt>Required Algorithms: </dt>
<dd style="margin-left: 8">Use DOSETA defaults.</dd>
</dl></dd>
</dl></li></ul>

<p> </p>
<h1 id="rfc.appendix.Appendix C.2">
<a href="#rfc.appendix.Appendix%20C.2">Appendix C.2.</a> Extensions to DOSETA Template</h1>
<p id="rfc.section.Appendix C.2.p.1">This section contains specifications that are added to the basic DOSETA H/C Signing Template.</p>
<h1 id="rfc.appendix.Appendix C.2.1">
<a href="#rfc.appendix.Appendix%20C.2.1">Appendix C.2.1.</a> <a href="#dksigneddatastruct" id="dksigneddatastruct">Signature Data Structure</a>
</h1>
<div id="#rfc.figure.47"></div>
<p id="rfc.section.Appendix C.2.1.p.1">These are DKIM-specific tags: </p>

<p>ABNF:</p>
<pre>sig-i-tag       = %x69 [FWS] "=" [FWS] 
                  [ local-part ] "@" domain-name</pre>
<div id="#rfc.figure.48"></div>
<p>ABNF:</p>
<pre>sig-l-tag    = %x6c [FWS] "=" [FWS]
               1*76DIGIT</pre>
<div id="#rfc.figure.49"></div>
<p>ABNF:</p>
<pre>
sig-z-tag      = %x7A [FWS] "=" [FWS] 
                 sig-z-tag-copy
                 *( "|" [FWS] sig-z-tag-copy )
sig-z-tag-copy = hdr-name [FWS] ":" 
                 qp-hdr-value</pre>
<div id="#rfc.figure.50"></div>
<ul class="empty"><li><dl>
<dt>i= </dt>
<dd style="margin-left: 8">The Agent or User Identifier (AUID) on behalf of which the SDID is taking responsibility (DOSETA-quoted-printable; OPTIONAL, default is an empty &lt;local-part&gt; followed by an "@" followed by the domain from the "d=" tag).</dd>
<dt></dt>
<dd style="margin-left: 8">The syntax is a standard email address where the &lt;local-part&gt; MAY be omitted. The domain part of the address MUST be the same as, or a subdomain of, the value of the "d=" tag.</dd>
<dt></dt>
<dd style="margin-left: 8">Internationalized domain names MUST be converted using the steps listed in Section 4 of <a href="#RFC5890">[RFC5890]</a> using the "ToASCII" function.</dd>
<dt></dt>
<dd style="margin-left: 8">
<ul class="empty"><li></ul>
<p> </p>
</dd>
<dt></dt>
<dd style="margin-left: 8">The AUID is specified as having the same syntax as an email address, but is not required to have the same semantics. Notably, the domain name is not required to be registered in the DNS -- so it might not resolve in a query -- and the &lt;local-part&gt; MAY be drawn from a namespace unrelated to any mailbox. The details of the structure and semantics for the namespace are determined by the Signer. Any knowledge or use of those details by verifiers or assessors is outside the scope of the DOSETA Signing specification. The Signer MAY choose to use the same namespace for its AUIDs as its users' email addresses or MAY choose other means of representing its users. However, the signer SHOULD use the same AUID for each message intended to be evaluated as being within the same sphere of responsibility, if it wishes to offer receivers the option of using the AUID as a stable identifier that is finer grained than the SDID. <dl>
<dt>NOTE: </dt>
<dd style="margin-left: 8">The &lt;local-part&gt; of the "i=" tag is optional because in some cases a signer might not be able to establish a verified individual identity.  In such cases, the signer might wish to assert that although it is willing to go as far as signing for the domain, it is unable or unwilling to commit to an individual user name within their domain.  It can do so by including the domain part but not the &lt;local-part&gt; of the identity.</dd>
<dt>NOTE:  </dt>
<dd style="margin-left: 8">Absent public standards for the semantics of an AUID, an assessment based on AUID requires a non-standardized basis.</dd>
<dt>NOTE: </dt>
<dd style="margin-left: 8">This specification does not require the value of the "i=" tag to match the identity in any Header field.  This is considered to be an assessment-time policy issue. Constraints between the value of the "i=" tag and other identities in other Header fields might seek to apply basic authentication into the semantics of trust associated with a role such as content author. Trust is a broad and complex topic and trust mechanisms are subject to highly creative attacks. The real-world efficacy of any but the most basic bindings between the "i=" value and other identities is not well established, nor is its vulnerability to subversion by an attacker. Hence reliance on the use of these options needs to be strictly limited. In particular, it is not at all clear to what extent a typical end-user recipient can rely on any assurances that might be made by successful use of the "i=" options.</dd>
</dl>
</dd>
<dt>l=  </dt>
<dd style="margin-left: 8">Content length count (plain-text unsigned decimal integer; OPTIONAL, default is entire Content). This tag informs the verifier of the number of octets in the Content of the data after canonicalization included in the cryptographic hash, starting from 0 immediately following the CRLF preceding the Content. This value MUST NOT be larger than the actual number of octets in the canonicalized Content. <ul class="empty"><li></ul>
<p> </p>
<dl>
<dt>NOTE: </dt>
<dd style="margin-left: 8">Use of the "l=" tag might allow display of fraudulent content without appropriate warning to end users.  The "l=" tag is intended for increasing signature robustness when sending to intermediaries that append data to Content, such as mailing lists that both modify their content and do not sign their messages. However, using the "l=" tag enables attacks in which an intermediary with malicious intent modifies a message to include content that solely benefits the attacker. It is possible for the appended content to completely replace the original content in the end recipient's eyes and to defeat duplicate message detection algorithms. Examples are described in Security Considerations <a href="#security">Section 7.2</a>. To avoid this attack, signers need be extremely wary of using this tag, and verifiers might wish to ignore the tag or remove text that appears after the specified content length.</dd>
<dt>NOTE: </dt>
<dd style="margin-left: 8">The value of the "l=" tag is constrained to 76 decimal digits.  This constraint is not intended to predict the size of future data or to require implementations to use an integer representation large enough to represent the maximum possible value, but is intended to remind the implementer to check the length of this and all other tags during verification and to test for integer overflow when decoding the value.  Implementers might need to limit the actual value expressed to a value smaller than 10^76, for example, to allow a message to fit within the available storage space.</dd>
</dl>
<p> </p>
</dd>
<dt>z=  </dt>
<dd style="margin-left: 8">Copied Header fields (DOSETA-quoted-printable, but see description; OPTIONAL, default is null). A vertical-bar-separated list of selected Header fields present when the message was signed, including both the field name and value. It is not required to include all Header fields present at the time of signing. This field need not contain the same Header fields listed in the "h=" tag. The Header field text itself MUST encode the vertical bar ("|", %x7C) character.  That is, vertical bars in the "z=" text are meta-characters, and any actual vertical bar characters in a copied header field MUST be encoded. Note that all whitespace MUST be encoded, including whitespace between the colon and the header field value. After encoding, FWS MAY be added at arbitrary locations in order to avoid excessively long lines; such whitespace is NOT part of the value of the header field, and MUST be removed before decoding.</dd>
<dt></dt>
<dd style="margin-left: 8">The Header fields referenced by the "h=" tag refer to the fields in the <a href="#RFC5322">[RFC5322]</a> Header, not to any copied fields in the "z=" tag. Copied header field values are for diagnostic use.</dd>
<dt></dt>
<dd style="margin-left: 8">Header fields with characters requiring conversion (perhaps from legacy MTAs that are not <a href="#RFC5322">[RFC5322]</a> compliant) SHOULD be converted as described in MIME Part Three <a href="#RFC2047">[RFC2047]</a>.</dd>
<dt></dt>
<dd style="margin-left: 8"><ul class="empty"><li></ul></dd>
</dl></li></ul>

<p> </p>

<p>EXAMPLE of a signature header field spread across multiple continuation lines:</p>
<pre>DKIM-Signature: v=1; a=rsa-sha256; d=example.net; 
  s=brisbane;   c=simple; q=dns/txt; i=@eng.example.net;
  t=1117574938; x=1118006938;
  h=from:to:subject:date;
  z=From:foo@eng.example.net|To:joe@example.com|
   Subject:demo=20run|
   Date:July=205,=202005=203:44:08=20PM=20-0700;
  bh=MTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTI=;
  b=dzdVyOfAKCdLXdJOc9G2q8LoXSlEniSbav+yuU4zGeeruD00lszZVoG4ZHRNiYzR</pre>
<h1 id="rfc.appendix.Appendix C.2.1.1">
<a href="#rfc.appendix.Appendix%20C.2.1.1">Appendix C.2.1.1.</a> <a href="#textlength" id="textlength">Content Length Limits</a>
</h1>
<p id="rfc.section.Appendix C.2.1.1.p.1">A text length count MAY be specified to limit the signature calculation to an initial prefix of an ASCII text data portion, measured in octets. If the Content length count is not specified, the entire Content is signed. </p>
<p id="rfc.section.Appendix C.2.1.1.p.2">This capability is provided because it is very common for intermediate data handling services to add trailers to text (for example, instructions how to get off a mailing list). Until such data is signed by the intermediate handler, the text length count can be a useful tool for the verifier since it can, as a matter of policy, accept messages having valid signatures that do not cover the additional data.</p>
<p></p>

<dl>
<dt>NOTE: </dt>
<dd style="margin-left: 8">Using text length limits enables an attack in which an attacker modifies a message to include content that solely benefits the attacker. It is possible for the appended content to completely replace the original content in the end recipient's eyes and to defeat duplicate message detection algorithms. To avoid this attack, signers need to be wary of using this tag, and verifiers might wish to ignore the tag or remove text that appears after the specified content length, perhaps based on other criteria.</dd>
</dl>
<p id="rfc.section.Appendix C.2.1.1.p.4">The text length count allows the signer of text to permit data to be appended to the end of the text of a signed message. The text length count MUST be calculated following the canonicalization algorithm; for example, any whitespace ignored by a canonicalization algorithm is not included as part of the Content length count. Signers of MIME messages that include a Content length count SHOULD be sure that the length extends to the closing MIME boundary string. </p>

<dl>
<dt>NOTE:  </dt>
<dd style="margin-left: 8">A creator wishing to ensure that the only acceptable modifications are to add to a MIME postlude would use a text length count encompassing the entire final MIME boundary string, including the final "--CRLF". A signer wishing to allow additional MIME parts but not modification of existing parts would use a Content length count extending through the final MIME boundary string, omitting the final "--CRLF". Note that this only works for some MIME types, such as, multipart/mixed but not multipart/signed.</dd>
</dl>
<p id="rfc.section.Appendix C.2.1.1.p.5">A text length count of zero means that the text is completely unsigned.</p>
<p id="rfc.section.Appendix C.2.1.1.p.6">Creators wishing to ensure that no modification of any sort can occur will specify the "simple" canonicalization algorithm for all data portions and will and omit the text length counts.</p>
<h1 id="rfc.appendix.Appendix C.2.1.2">
<a href="#rfc.appendix.Appendix%20C.2.1.2">Appendix C.2.1.2.</a> Signature Verification</h1>
<p id="rfc.section.Appendix C.2.1.2.p.1">A Content length specified in the "l=" tag of the signature limits the number of bytes of the Content passed to the verification algorithm. All data beyond that limit is not validated by DOSETA. Hence, verifiers might treat a message that contains bytes beyond the indicated Content length with suspicion, such as by truncating the message at the indicated Content length, declaring the signature invalid (for example, by returning PERMFAIL (unsigned content)), or conveying the partial verification to the policy module. </p>

<dl>
<dt>NOTE: </dt>
<dd style="margin-left: 8">Verifiers that truncate the Content at the indicated Content length might pass on a malformed MIME message if the signer used the "N-4" trick (omitting the final "--CRLF") described in the informative note in <a href="#textlength">Appendix Appendix C.2.1.1</a>. Such verifiers might wish to check for this case and include a trailing "--CRLF" to avoid breaking the MIME structure. A simple way to achieve this might be to append "--CRLF" to any "multipart" message with a Content length; if the MIME structure is already correctly formed, this will appear in the postlude and will not be displayed to the end user.</dd>
</dl>
<h1 id="rfc.appendix.Appendix C.2.2">
<a href="#rfc.appendix.Appendix%20C.2.2">Appendix C.2.2.</a> <a href="#dkkeydata" id="dkkeydata">Stored Key Data</a>
</h1>
<div id="#rfc.figure.51"></div>
<p id="rfc.section.Appendix C.2.2.p.1">This section defines additions to the DOSETA Library, concerning stored key data. </p>

<p>ABNF:</p>
<pre>key-g-tag       = %x67 [FWS] "=" [FWS] key-g-tag-lpart
                     key-g-tag-lpart = [dot-atom-text] 
                                       ["*" [dot-atom-text] ]</pre>
<div id="#rfc.figure.52"></div>
<p>ABNF:</p>
<pre>
key-h-tag       = %x68 [FWS] "=" [FWS] 
                  key-h-tag-alg
                  0*( [FWS] ":" [FWS] 
                  key-h-tag-alg )
key-h-tag-alg   = "sha1" / "sha256" / 
                  x-key-h-tag-alg
x-key-h-tag-alg = hyphenated-word   
                       ; for future extension</pre>
<div id="#rfc.figure.53"></div>
<p>ABNF:</p>
<pre>
key-s-tag        = %x73 [FWS] "=" [FWS] 
                   key-s-tag-type
                   0*( [FWS] ":" [FWS] 
                   key-s-tag-type )
key-s-tag-type   = "email" / "*" / 
                   x-key-s-tag-type
x-key-s-tag-type = hyphenated-word   
                        ; for future extension</pre>
<div id="#rfc.figure.54"></div>
<p>ABNF:</p>
<pre>key-t-tag        = %x74 [FWS] "=" [FWS] 
                   key-t-tag-flag
                   0*( [FWS] ":" [FWS] 
                   key-t-tag-flag )
key-t-tag-flag   = "y" / "s" / 
                   x-key-t-tag-flag
x-key-t-tag-flag = hyphenated-word   
                        ; for future extension</pre>
<ul class="empty"><li><dl>
<dt>g=  </dt>
<dd style="margin-left: 8">Granularity of the key (plain-text; OPTIONAL, default is "*"). This value MUST match the Local-part of the "i=" tag of the DKIM- Signature header field (or its default value of the empty string if "i=" is not specified), with a single, optional "*" character matching a sequence of zero or more arbitrary characters ("wildcarding"). An email with a signing address that does not match the value of this tag constitutes a failed verification. The intent of this tag is to constrain which signing address can legitimately use this selector, for example, when delegating a key to a third party that should only be used for special purposes. Wildcarding allows matching for addresses such as "user+*" or "*-offer". An empty "g=" value never matches any addresses. <ul class="empty"><li></ul>
<p> </p>
</dd>
<dt>h=  </dt>
<dd style="margin-left: 8">Acceptable hash algorithms (plain-text; OPTIONAL, defaults to allowing all algorithms). A colon-separated list of hash algorithms that might be used. Signers and Verifiers MUST support the "sha256" hash algorithm. Verifiers MUST also support the "sha1" hash algorithm. </dd>
<dt></dt>
<dd style="margin-left: 8">
<ul class="empty"><li></ul>
<p> </p>
</dd>
<dt>s=  </dt>
<dd style="margin-left: 8">Service Type (plain-text; OPTIONAL; default is "*"). A colon-separated list of service types to which this record applies. Verifiers for a given service type MUST ignore this record if the appropriate type is not listed. </dd>
<dt></dt>
<dd style="margin-left: 8">
<dl>
<dt>* </dt>
<dd style="margin-left: 8">matches all service types</dd>
<dt>email </dt>
<dd style="margin-left: 8">electronic mail (not necessarily limited to SMTP)</dd>
</dl>
<p> This tag is intended to constrain the use of keys for other purposes, if use of DOSETA is defined by other services in the future.</p>
</dd>
<dt></dt>
<dd style="margin-left: 8">
<ul class="empty"><li></ul>
<p> </p>
</dd>
<dt>t=  </dt>
<dd style="margin-left: 8">Flags, represented as a colon-separated list of names (plain-text; OPTIONAL, default is no flags set). <dl>
<dt>y  </dt>
<dd style="margin-left: 8">This domain is testing DOSETA. Verifiers MUST NOT treat data from signers in testing mode differently from unsigned data, even if the signature fails to verify. Verifiers MAY wish to track testing mode results to assist the signer.</dd>
<dt>s  </dt>
<dd style="margin-left: 8">Any DOSETA&#8209;Signature Header fields using the "i=" tag MUST have the same domain value on the right-hand side of the "@" in the "i=" tag and the value of the "d=" tag. That is, the "i=" domain MUST NOT be a subdomain of "d=".  Use of this flag is RECOMMENDED unless subdomaining is required.</dd>
</dl>
<p> </p>
</dd>
<dt></dt>
<dd style="margin-left: 8">
<ul class="empty"><li></ul>
<p> </p>
</dd>
</dl></li></ul>

<p> </p>
<h1 id="rfc.authors"><a href="#rfc.authors">Authors' Addresses</a></h1>
<div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">D. Crocker</span> 
	  <span class="n hidden">
		<span class="family-name">Crocker</span>
	  </span>
	</span>
	<span class="org vcardline">Brandenburg InternetWorking</span>
	<span class="adr">
	  <span>675 Spruce Dr.</span>

	  <span class="vcardline">
		<span class="locality">Sunnyvale</span>,  
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline">USA</span>
	</span>
	<span class="vcardline">Phone: +1.408.246.8253</span>

<span class="vcardline">EMail: <a href="mailto:dcrocker@bbiw.net">dcrocker@bbiw.net</a></span>

<span class="vcardline">URI: <a href="http://bbiw.net">http://bbiw.net</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">M. Kucherawy</span> 
	  <span class="n hidden">
		<span class="family-name">Kucherawy</span>
	  </span>
	</span>
	<span class="org vcardline">Cloudmark</span>
	<span class="adr">
	  <span>128 King St., 2nd Floor</span>

	  <span class="vcardline">
		<span class="locality">San Francisco</span>,  
		<span class="region">CA</span> 
		<span class="code">94107</span>
	  </span>
	  <span class="country-name vcardline">USA</span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:msk@cloudmark.com">msk@cloudmark.com</a></span>

  </address>
</div>

</body>
</html>