SWSP =   CR / LF / WSP   ; streaming white space


hyphenated-word =  ALPHA [ *(ALPHA / DIGIT / "-") (ALPHA / DIGIT) ]
base64string =     1*(ALPHA / DIGIT / "+" / "/" / "=" / SWSP)
selector =   sub-domain *( "." sub-domain )

tag-list  =  tag-spec 0*( ";" tag-spec ) [ ";" ]
tag-spec  =  [FWS] tag-name [FWS] "=" [FWS] tag-value [FWS]
tag-name  =  ALPHA 0*ALNUMPUNC
tag-value =  0*VALCHAR    ; SWSP prohibited at beginning and end
VALCHAR   =  %9 / %d32 - %d58 / %d60 - %d126
                             ; HTAB and SP to TILDE except SEMICOLON
ALNUMPUNC =  ALPHA / DIGIT / "_"

Tag=value pairs that represent the default value MAY be included to
v=   Version (MUST be included).  This tag defines the version of
       this specification that applies to the signature record.  It MUST
       have the value 0.2.

       ABNF:


sig-v-tag   = %x76 [FWS] "=" [FWS] "0.2"
a=   The algorithm used to generate the signature (plain-text;
       REQUIRED).  Verifiers MUST support "rsa-sha1" and "rsa-sha256";
       signers SHOULD sign using "rsa-sha256".  See Section 3.3 for a
       description of algorithms.

       ABNF:


sig-a-tag       = %x61 [FWS] "=" [FWS] sig-a-tag-alg
sig-a-tag-alg   = "rsa-sha1" / "rsa-sha256" / x-sig-a-tag-alg
x-sig-a-tag-alg = hyphenated-word   ; for later extension

b=   The signature data (base64; REQUIRED).  Whitespace is ignored in
       this value and MUST be ignored when re-assembling tthe original
       signature.  In particular, the signing process can safely insert
       FWS in this value in arbitrary places to conform to line-length
       limits.  See Signer Actions (Section 5) for how the signature is
       computed.

       ABNF:


sig-b-tag       = %x62 [FWS] "=" [FWS] sig-b-tag-data
sig-b-tag-data  = base64string

bh= The hash of the body part of the message (base64; REQUIRED).
       Whitespace is ignored in this value and MUST be ignored when re-
       assembling the original signature.  In particular, the signing
       process can safely insert FWS in this value in arbitrary places
       to conform to line-length limits.  See Section 3.7 for how the
       body hash is computed.

c=   Message canonicalization (plain-text; OPTIONAL, default is
       "simple/simple").  This tag informs the verifier of the type of
       canonicalization used to prepare the message for signing.  It
       consists of two names separated by a "slash" (%d47) character,
       corresponding to the header and body canonicalization algorithms
       respectively.  These algorithms are described in Section 3.4.  If
       only one algorithm is named, that algorithm is used for the
       header and "simple" is used for the body.  For example,
       "c=relaxed" is treated the same as "c=relaxed/simple".

       ABNF:
sig-c-tag       = %x63 [FWS] "=" [FWS] sig-c-tag-alg
                     ["/" sig-c-tag-alg]
sig-c-tag-alg   = "simple" / "relaxed" / x-sig-c-tag-alg
x-sig-c-tag-alg = hyphenated-word    ; for later extension

d=   The domain of the signing entity (plain-text; REQUIRED).  This
       is the domain that will be queried for the public key.  This
       domain MUST be the same as or a parent domain of the "i=" tag
       (the signing identity, as described below).  When presented with
       a signature that does not meet this requirement, verifiers MUST
       consider the signature invalid.

       ABNF:


sig-d-tag       = %x64 [FWS] "=" [FWS] Domain

h=   Signed header fields (plain-text, but see description;
       REQUIRED).  A colon-separated list of header field names that
       identify the header fields presented to the signing algorithm.
       The field MUST contain the complete list of header fields in the
       order presented to the signing algorithm.  The field MAY contain
       names of header fields that do not exist when signed; nonexistent
       header fields do not contribute to the signature computation
       (that is, they are treated as the null input, includiing the
       header field name, the separating colon, the header field value,
       and any CRLF terminator).  The field MUST NOT include the DKIM-
       Signature header field that is being created or verified.
       Folding white space (FWS) MAY be included on either side of the
       colon separator.  Header field names MUST be compared against
       actual header field names in a case insensitive manner.  This
       list MUST NOT be empty.  See Section 5.4 for a discussion of
       choosing header fields to sign.

       ABNF:


sig-h-tag       = %x68 [FWS] "=" [FWS] hdr-name
                     0*( *FWS ":" *FWS hdr-name )
hdr-name        = field-name

           INFORMATIVE EXPLANATION:  By "signing" header fields that do
           not actually exist, a signer can prevent insertion of those
           header fields before verification.  However, since a sender
           cannot possibly know what header fields might be created in
           the future, and that some MUAs might present header fields
           that are embedded inside a message (e.g., as a message/rfc822
           content type), the security of this solution is not total.
           INFORMATIVE EXPLANATION:  The exclusion of the header field
           name and colon as well as the header field value for non-
           existent header fields prevents an attacker from inserting an
           actual header field with a null value.

i=   Identity of the user or agent (e.g., a mailing list manager) on
       behalf of which this message is signed (quoted-printable;
       OPTIONAL, default is an empty local-part followed by an "@"
       followed by the domain from the "d=" tag).  The syntax is a
       standard email address where the local-part MAY be omitted.  The
       domain part of the address MUST be the same as or a subdomain of
       the value of the "d=" tag.

       ABNF:


sig-i-tag =   %x69 [FWS] "=" [FWS] [ Local-part ] "@" Domain

           INFORMATIVE NOTE:  The local-part of the "i=" tag is optional
           because in some cases a signer may not be able to establish a
           verified individual identity.  In such cases, the signer may
           wish to assert that although it is willing to go as far as
           signing for the domain, it is unable or unwilling to commit
           to an individual user name within their domain.  It can do so
           by including the domain part but not the local-part of the
           identity.

           INFORMATIVE DISCUSSION:  This document does not require the
           value of the "i="  tag to match the identity in any message
           header field fields.  This is considered to be a verifier
           policy issue.  Constraints between the value of the "i=" tag
           and other identities in other header fields seek to apply
           basic authentication into the semantics of trust associated
           with a role such as content author.  Trust is a broad and
           complex topic and trust mechanisms are subject to highly
           creative attacks.  The real-world efficacy of any but the
           most basic bindings between the "i=" value and other
           identities is not well established, nor is its vulnerability
           to subversion by an attacker.  Hence reliance on the use of
           these options should be strictly limited.  In particular it
           is not at all clear to what extent a typical end-user
           recipient can rely on any assurances that might be made by
           successful use of the "i=" options.
l=   Body count (plain-text decimal integer; OPTIONAL, default is
       entire body).  This tag informs the verifier of the number of
       bytes in the body of the email after canonicalization included in
       the cryptographic hash, starting from 0 immediately following the
       CRLF preceding the body.

           INFORMATIVE IMPLEMENTATION WARNING:  Use of the l= tag might
           allow display of fraudulent content without appropriate
           warning to end users.  The l= tag is intended for increasing
           signature robustness when sending to mailing lists that both
           modify their content and do not sign their messages.
           However, using the l= tag enables man-in-the-middle attacks
           in which an intermediary with malicious intent modifies a
           message to include content that solely benefits the attacker.
           It is possible for the appended content to completely replace
           the original content in the end recipient's eyes and to
           defeat duplicate message detection algorithms.  Examples are
           described in Security Considerations (Section 8).

           To avoid this attack, signers should be extremely wary of
           using this tag, and verifiers might wish to ignore the tag or
           remove text that appears after the specified content length.

       ABNF:


sig-l-tag    = %x6c [FWS] "=" [FWS] 1*DIGIT

q=   A colon-separated list of query methods used to retrieve the
       public key (plain-text; OPTIONAL, default is "dns/txt").  Each
       query method is of the form "type[/options]", where the syntax
       and semantics of the options depends on the type and specified
       options.  If there are multiple query mechanisms listed, the
       choice of query mechanism MUST NOT change the interpretation of
       the signature.  Implementations MUST use the recognized query
       mechanisms in the order presented.

       Currently the only valid value is "dns/txt" which defines the DNS
       TXT record lookup algorithm described elsewhere in this document.
       The only option defined for the "dns" query type is "txt", which
       MUST be included.  Verifiers and signers MUST support "dns/txt".

       ABNF:
sig-q-tag        = %x71 [FWS] "=" [FWS] sig-q-tag-method
                      *([FWS] ":" [FWS] sig-q-tag-method)
sig-q-tag-method = sig-q-tag-type ["/" sig-q-tag-args]
sig-q-tag-type   = "dns" / x-sig-q-tag-type
x-sig-q-tag-type = hyphenated-word  ; for future extension
x-sig-q-tag-args = qp-hdr-value

s=   The selector subdividing the namespace for the "d=" (domain) tag
       (plain-text; REQUIRED).

       ABNF:


sig-s-tag    = %x73 [FWS] "=" [FWS] subdomain *( "." sub-domain )

t=   Signature Timestamp (pplain-text; RECOMMENDED, default is an
       unknown creation time).  The time that this signature was
       created.  The format is the number of seconds since 00:00:00 on
       January 1, 1970 in the UTC time zone.  The value is expressed as
       an unsigned integer in decimal ASCII.  This value is not
       constrained to fit into a 31- or 32-bit integer.  Implementations
       SHOULD be prepared to handle values up to at least 10^12 (until
       approximately AD 200,000; this fits into 40 bits).  To avoid
       denial of service attacks, implementations MAY consider any value
       longer than 12 digits to be infinite.

       ABNF:


sig-t-tag    = %x74 [FWS] "=" [FWS] 1*12DIGIT

x=   Signature Expiration (plain-text; RECOMMENDED, default is no
       expiration).  The format is the same as in the "t=" tag,
       represented as an absolute date, not as a time delta from the
       signing timestamp.  The value is expressed as an unsigned integer
       in decimal ASCII, with the same contraints on the value in the
       "t=" tag.  Signatures MAY be considered invalid if the
       verification time at the verifier is past the expiration date.
       The verification time should be the time that the message was
       first received at the administrative domain of the verifier if
       that time is reliably available; otherwise the current time
       should be used.  The value of the "x=" tag MUST be greater than
       the value of the "t=" tag if both are present.

           INFORMATIVE NOTE:  The x= tag is not intended as an anti-
           replay defense.
       ABNF:


sig-x-tag    = %x78 [FWS] "=" [FWS] 1*12DIGIT

z=   Copied header fields (plain-text, but see description; OPTIONAL,
       default is null).  A vertical-bar-separated list of selected
       header field names and copies of header field values present when
       the message was signed.  It is not required to include all header
       fields present at the time of signing.  This field need not
       contain the same header fields listed in the "h=" tag.  Copied
       header field values MUST immediately follow the header field name
       with a colon separator (no white space permitted).  Header field
       values MUST be represented as Quoted-Printable [RFC2045] with
       vertical bars, colons, semicolons, and white space encoded in
       addition to the usual requirements.

       Verifiers MUST NOT use the header field names or copied values
       for checking the signature in any way.  Copied header field
       values are for diagnostic use onnly.

       Header fields with characters requiring conversion (perhaps from
       legacy MTAs which are not [RFC2822] compliant) SHOULD be
       converted as described in MIME Part Three [RFC2047].

       ABNF:
sig-z-tag      = %x7A [FWS] "=" [FWS] sig-z-tag-copy
                    *( [FWS] "|" sig-z-tag-copy )
sig-z-tag-copy = hdr-name ":" [FWS] qp-hdr-value
qp-hdr-value   = <quoted-printable text with WS, "|", ":",
                    and ";" encoded>
                             ; needs to be updated with real definition
                             ; (could be messy)

      INFORMATIVE EXAMPLE of a signature header field spread across
      multiple continuation lines:

c=simple; q=dns; i=@eng.example.net; t=1117574938; x=1118006938;
h=from:to:subject:date;
z=From:foo@eng.example.net|To:joe@example.com|
        Subject:demo=20run|Date:July=205,=202005=203:44:08=20PM=20-0700
b=dzdVyOfAKCdLXdJOc9G2q8LoXSlEniSbav+yuU4zGeeruD00lszZ
               VoG4ZHRNiYzR
public_key = dkim_find_key(q_val, d_val, i_val, s_val)

v=   Version of the DKIM key record (plain-text; RECOMMENDED, default
       is "DKIM1").  If specified, this tag MUST be set to "DKIM1"
       (without the quotes).  This tag MUST be the first tag in the
       response.  Responses beginning with a "v=" tag with any other
       value MUST be discarded.

       ABNF:
key-v-tag    = %x76 [FWS] "=" [FWS] "DKIM1"

g=   granularity of the key (plain-text; OPTIONAL, default is "*").
       This value MUST match the local part of the signing address, with
       a "*" character acting as a wildcard.  The intent of this tag is
       to constrain which signing address can legitimately use this
       selector.  An email with a signing address that does not match
       the value of this tag constitutes a failed verification.
       Wildcarding allows matching for addresses such as "user+*".  An
       empty "g=" value never matches any addresses.

       ABNF:


key-g-tag       = %x67 [FWS] "=" [FWS] key-g-tag-lpart
key-g-tag-lpart = [dot-atom] ["*"] [dot-atom]

           [[NON-NORMATIVE DISCUSSION POINT:  "*" is legal in a dot-
           atom.  This should probably use a different character for
           wildcarding.  Unfortunately, the options are non-mnemonic
           (e.g., "@", "(", ":").  Alternatively we could insist on
           escaping a "*" intended as a literal "*" in the address.]]

h=   Acceptable hash algorithms (plain-text; OPTIONAL, defaults to
       allowing all algorithms).  A colon-separated list of hash
       algorithms that might be used.  Signers and Verifiers MUST
       support the "sha1" hash algorithm.

       ABNF:


key-h-tag       = %x68 [FWS] "=" [FWS] key-h-tag-alg
                     0*( [FWS] ":" [FWS] key-h-tag-alg )
key-h-tag-alg   = "sha1" / "sha256" / x-key-h-tag-alg
x-key-h-tag-alg = hyphenated-word   ; for future extension

k=   Key type (plain-text; OPTIONAL, default is "rsa").  Signers and
       verifiers MUST support the "rsa" key type.  The "rsa" key type
       indicates that an RSA public key, as defined in [RFC3447],
       sections 3.1 and A.1.1, is being used in the p= tag.  (Note:  the
p= tag further encodes the value using the base64 algorithm.)

key-k-tag        = %x76 [FWS] "=" [FWS] key-k-tag-type
key-k-tag-type   = "rsa" / x-key-k-tag-type
x-key-k-tag-type = hyphenated-word   ; for future extension

           [[NON-NORMATIVE DISCUSSION NOTE:  In some cases it can be
           hard to separate h= and k=; for example DSA implies that
           SHA-1 will be used.  This might be an actual change to the
           spec depending on how we decide to fix this.]]

n=   Notes that might be of interest to a human (quoted-printable;
       OPTIONAL, default is empty).  No interpretation is made by any
       program.  This tag should be used sparingly in any key server
       mechanism that has space limitations (notably DNS).

       ABNF:


key-n-tag    = %x6e [FWS] "=" [FWS] qp-section

p=   Public-key data (base64; REQUIRED).  An empty value means that
       this public key has been revoked.  The syntax and semantics of
       this tag value before being encoded in base64 is defined by the
k= tag.

key-p-tag    = %x70 [FWS] "=" [FWS] base64string

s=   Service Type (plain-text; OPTIONAL; default is "*").  A colon-
       separated list of service types to which this record applies.
       Verifiers for a given service type MUST ignore this record if the
       appropriate type is not listed.  Currently defined service types
       are:

       *   matches all service types

       email   electronic mail (not necessarily limited to SMTP)

       This tag is intended to permit senders to constrain the use of
       delegated keys, e.g., where a company is willing to delegate the
       right to send mail in their name to an outsourcer, but not to
       send IM or make VoIP calls.  (This of course presumes that these
       keys are used in other services in the future.)
       ABNF:


key-s-tag        = %x73 [FWS] "=" [FWS] key-s-tag-type
                       0*( [FWS] ":" [FWS] key-s-tag-type
key-s-tag-type   = "email" / "*" / x-key-s-tag-type
x-key-s-tag-type = hyphenated-word   ; for future extension

t=   Flags, represented as a colon-separated list of names (plain-
       text; OPTIONAL, default is no flags set).  The defined flags are:

       y   This domain is testing DKIM.  Verifiers MUST NOT treat
           messages from signers in testing mode differently from
           unsigned email, even should the signature fail to verify.
           Verifiers MAY wish to track testing modee results to assist
           the signer.

       ABNF:


key-t-tag        = %x74 [FWS] "=" [FWS] key-t-tag-flag
                      0*( [FWS] ":" [FWS] key-t-tag-flag )
key-t-tag-flag   = "y" / x-key-t-tag-flag
x-key-t-tag-flag = hyphenated-word   ; for future extension

       Unrecognized flags MUST be ignored.


body-hash = hash-alg(canon_body)
header-hash = hash-alg(canon_header || DKIM-SIG)
signature = crypt-alg(header-hash, key)

width=578 height=370>
c=simple; q=dns; i=joe@football.example.com;
h=Received : From : To : Subject : Date : Message-ID;
b=dzdVyOfAKCdLXdJOc9G2q8LoXSlEniSbav+yuU4zGeeruD00lszZ
           VoG4ZHRNiYzR;
c=simple; q=dns; i=joe@football.example.com;
h=Received : From : To : Subject : Date : Message-ID;
b=dzdVyOfAKCdLXdJOc9G2q8LoXSlEniSbav+yuU4zGeeruD00lszZ
             VoG4ZHRNiYzR
