<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="en"><head><title>Common Interface to Cryptographic Modules (CICM) Logical Model</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="description" content="Common Interface to Cryptographic Modules (CICM) Logical Model">
<meta name="generator" content="xml2rfc v1.35 (http://xml.resource.org/)">
<meta name="viewport" content="width=600;" />
<style type='text/css'><!--
        body {
                font-family: verdana, charcoal, helvetica, arial, sans-serif;
                font-size: 85%;
		max-width: 60em; 
		color: #000; background-color: #FFF;
                margin: 2em;
        }
        h1, h2, h3, h4, h5, h6 {
                font-family: helvetica, monaco, "MS Sans Serif", arial, sans-serif;
                font-weight: bold; font-style: normal;
        }
        h1 { color: #900; background-color: transparent; text-align: right; }
        h3 { color: #333; background-color: transparent; }

        td.RFCbug {
                font-size: x-small; text-decoration: none;
                width: 30px; height: 30px; padding-top: 2px;
                text-align: justify; vertical-align: middle;
                background-color: #000;
        }
        td.RFCbug span.RFC {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: bold; color: #666;
        }
        td.RFCbug span.hotText {
                font-family: charcoal, monaco, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: normal; text-align: center; color: #FFF;
        }

        table.TOCbug { width: 30px; height: 15px; }
        td.TOCbug {
                text-align: center; width: 30px; height: 15px;
                color: #FFF; background-color: #900;
        }
        td.TOCbug a {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, sans-serif;
                font-weight: bold; font-size: x-small; text-decoration: none;
                color: #FFF; background-color: transparent;
        }

        td.header {
                font-family: arial, helvetica, sans-serif; font-size: x-small;
                vertical-align: top; width: 33%;
                color: #FFF; background-color: #666;
        }
        td.author { font-weight: bold; font-size: x-small; margin-left: 4em; }
        td.author-text { font-size: x-small; }

        /* info code from SantaKlauss at http://www.madaboutstyle.com/tooltip2.html */
        a.info {
                /* This is the key. */
                position: relative;
                z-index: 24;
                text-decoration: none;
        }
        a.info:hover {
                z-index: 25;
                color: #FFF; background-color: #900;
        }
        a.info span { display: none; }
        a.info:hover span.info {
                /* The span will display just on :hover state. */
                display: block;
                position: absolute;
                font-size: smaller;
                top: 2em; left: -5em; width: 15em;
                padding: 2px; border: 1px solid #333;
                color: #900; background-color: #EEE;
                text-align: left;
        }

        a { font-weight: bold; }
        a:link    { color: #900; background-color: transparent; }
        a:visited { color: #633; background-color: transparent; }
        a:active  { color: #633; background-color: transparent; }

        p { margin-left: 2em; margin-right: 2em; }
        p.copyright { font-size: x-small; }
        p.toc { font-size: 85%;
		max-width: 60em; 
		font-weight: bold; margin-left: 3em; }
        table.toc { margin: 0 0 0 3em; padding: 0; border: 0; vertical-align: text-top; }
        td.toc { font-size: 85%;
		max-width: 60em; 
		font-weight: bold; vertical-align: text-top; }

        ol.text { margin-left: 2em; margin-right: 2em; }
        ul.text { margin-left: 2em; margin-right: 2em; }
        li      { margin-left: 3em; }

        /* RFC-2629 <spanx>s and <artwork>s. */
        em     { font-style: italic; }
        strong { font-weight: bold; }
        dfn    { font-weight: bold; font-style: normal; }
        cite   { font-weight: normal; font-style: normal; }
        tt     { color: #036; }
        tt, pre, pre dfn, pre em, pre cite, pre span {
                font-family: "Courier New", Courier, monospace; font-size: small;
        }
        pre {
                text-align: left; padding: 4px;
                color: #000; background-color: #CCC;
        }
        pre dfn  { color: #900; }
        pre em   { color: #66F; background-color: #FFC; font-weight: normal; }
        pre .key { color: #33C; font-weight: bold; }
        pre .id  { color: #900; }
        pre .str { color: #000; background-color: #CFF; }
        pre .val { color: #066; }
        pre .rep { color: #909; }
        pre .oth { color: #000; background-color: #FCF; }
        pre .err { background-color: #FCC; }

        /* RFC-2629 <texttable>s. */
        table.all, table.full, table.headers, table.none {
                font-size: 85%;
		max-width: 60em; 
		text-align: center; border-width: 2px;
                vertical-align: top; border-collapse: collapse;
        }
        table.all, table.full { border-style: solid; border-color: black; }
        table.headers, table.none { border-style: none; }
        th {
                font-weight: bold; border-color: black;
                border-width: 2px 2px 3px 2px;
        }
        table.all th, table.full th { border-style: solid; }
        table.headers th { border-style: none none solid none; }
        table.none th { border-style: none; }
        table.all td {
                border-style: solid; border-color: #333;
                border-width: 1px 2px;
        }
        table.full td, table.headers td, table.none td { border-style: none; }

        hr { height: 1px; }
        hr.insert {
                width: 80%; border-style: none; border-width: 0;
                color: #CCC; background-color: #CCC;
        }
--></style>
</head>
<body>
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<table summary="layout" width="66%" border="0" cellpadding="0" cellspacing="0"><tr><td><table summary="layout" width="100%" border="0" cellpadding="2" cellspacing="1">
<tr><td class="header">Internet Engineering Task Force</td><td class="header">D. Lanz</td></tr>
<tr><td class="header">Internet-Draft</td><td class="header">L. Novikov</td></tr>
<tr><td class="header">Intended status: Informational</td><td class="header">MITRE</td></tr>
<tr><td class="header">Expires: July 15, 2011</td><td class="header">January 11, 2011</td></tr>
</table></td></tr></table>
<h1><br />Common Interface to Cryptographic Modules (CICM) Logical Model<br />draft-lanz-cicm-lm-00</h1>

<h3>Abstract</h3>

<p>This document defines an abstract model for high assurance
    cryptographic modules. It defines the relevant terminology
    and high-level descriptions of the types of services and
    operations offered by such modules. The goal is to provide a
    common vocabulary for discussing the programming of high assurance
    modules.
</p>
<p>Comments are solicited and should be addressed to the mailing
    list at cicm@ietf.org.
</p>
<h3>Status of this Memo</h3>
<p>
This Internet-Draft is submitted  in full
conformance with the provisions of BCP&nbsp;78 and BCP&nbsp;79.</p>
<p>
Internet-Drafts are working documents of the Internet Engineering
Task Force (IETF).  Note that other groups may also distribute
working documents as Internet-Drafts.  The list of current
Internet-Drafts is at http://datatracker.ietf.org/drafts/current/.</p>
<p>
Internet-Drafts are draft documents valid for a maximum of six months
and may be updated, replaced, or obsoleted by other documents at any time.
It is inappropriate to use Internet-Drafts as reference material or to cite
them other than as &ldquo;work in progress.&rdquo;</p>
<p>
This Internet-Draft will expire on July 15, 2011.</p>

<h3>Copyright Notice</h3>
<p>
Copyright (c) 2011 IETF Trust and the persons identified as the
document authors.  All rights reserved.</p>
<p>
This document is subject to BCP 78 and the IETF Trust's Legal
Provisions Relating to IETF Documents
(http://trustee.ietf.org/license-info) in effect on the date of
publication of this document.  Please review these documents
carefully, as they describe your rights and restrictions with respect
to this document. Code Components extracted from this document must
include Simplified BSD License text as described in Section 4.e of
the Trust Legal Provisions and are provided without warranty as
described in the Simplified BSD License.</p>
<a name="toc"></a><br /><hr />
<h3>Table of Contents</h3>
<p class="toc">
<a href="#anchor1">1.</a>&nbsp;
Introduction<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor2">1.1.</a>&nbsp;
Background<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor3">1.2.</a>&nbsp;
Language Independent<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor4">1.3.</a>&nbsp;
Audience<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor5">1.4.</a>&nbsp;
Scope of the Specification<br />
<a href="#anchor6">2.</a>&nbsp;
Use Cases<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor7">2.1.</a>&nbsp;
Data-in-Transit<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor8">2.2.</a>&nbsp;
Data-at-Rest<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor9">2.3.</a>&nbsp;
Single Security Domain<br />
<a href="#anchor10">3.</a>&nbsp;
Module Management<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#mm-auth">3.1.</a>&nbsp;
Managing Module Authentication<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor14">3.2.</a>&nbsp;
Managing Software Packages<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#mm-logs">3.3.</a>&nbsp;
Managing Logs<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor15">3.4.</a>&nbsp;
Managing Tests<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor16">3.5.</a>&nbsp;
Managing Module Events<br />
<a href="#anchor17">4.</a>&nbsp;
Key Management<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor18">4.1.</a>&nbsp;
Creating and Establishing Keys<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor21">4.2.</a>&nbsp;
Exporting Keys<br />
<a href="#cm">5.</a>&nbsp;
Channel Management<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor26">5.1.</a>&nbsp;
Creating Channels<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor33">5.2.</a>&nbsp;
Managing Channels<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor34">5.3.</a>&nbsp;
Using Channels<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor35">5.4.</a>&nbsp;
Grouping Channels<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor36">5.5.</a>&nbsp;
Receiving Notification of Channel Events<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor37">5.6.</a>&nbsp;
Destroying Channels<br />
<a href="#anchor38">6.</a>&nbsp;
IANA Considerations<br />
<a href="#anchor39">7.</a>&nbsp;
Security Considerations<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor40">7.1.</a>&nbsp;
Unauthorized Usage<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor41">7.2.</a>&nbsp;
Inappropriate Usage<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor42">7.3.</a>&nbsp;
Confidentiality and Data Integrity<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor43">7.4.</a>&nbsp;
Bypass<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor44">7.5.</a>&nbsp;
Entity Authentication<br />
<a href="#rfc.references1">8.</a>&nbsp;
Informative References<br />
<a href="#terms">Appendix&nbsp;A.</a>&nbsp;
Terms<br />
<a href="#rfc.authors">&#167;</a>&nbsp;
Authors' Addresses<br />
</p>
<br clear="all" />

<a name="anchor1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1"></a><h3>1.&nbsp;
Introduction</h3>

<a name="anchor2"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1.1"></a><h3>1.1.&nbsp;
Background</h3>

<p>Sensitive data is increasingly under attack,
			whether in transit or at rest. The computer security community has
			responded to these threats by using cryptography to secure
			sensitive data. To counter the growing number and types of threats
			against systems processing sensitive data, module vendors have
			engineered a diverse set of cryptographic modules.
</p>
<p>Systems that require cryptographic protection may use
			various cryptographic services including data encryption, signature
			generation, hashing, and keystream generation. Cryptographic
			modules providing these services and the key material they hold
			must be managed. All of these services have proprietary interfaces
			that differ significantly among module types, leading to the
			following problems:
</p>
<p></p>
<ul class="text">
<li>Replacement of one module type for another and reuse of
				module-dependent software are inhibited as applications require
				extensive modifications to adapt to new module types and their
				proprietary interfaces.
</li>
<li>Developers of systems that host cryptographic modules must
				accommodate different cryptographic module interfaces for
				different types of cryptographic modules.
</li>
<li>Test tools and procedures developed for one module usually
				will not work with other modules.
</li>
<li>Security evaluators must learn multiple module developers'
				interfaces, increasing evaluation time and expense.
</li>
</ul>

<p>To address these problems, this document outlines a logical model
      for the Common Interface to Cryptographic	Modules (CICM) specification
      which offers module developers a set of standard programming interfaces
      for the set of operations supported by high	assurance
      cryptographic modules. Although many Application
			Programming Interfaces (APIs) intended for commercial cryptography
			are available, the CICM specification was designed for high
			assurance environments, but may be used in other environments as
			well.
</p>
<p>Modules do not require changes to support the use of CICM. A
			module-specific abstraction layer between the library implementing
			CICM interfaces and the module performs the needed translations
			between the CICM model of a module and the model presented by a
			specific module. This abstraction component may be provided by the
			module developer, a module embedder/integrator, or another
			interested party. This arrangement is analogous to manufacturers of
			computer peripheral devices providing platform or operating
			system-specific drivers for their peripheral devices.
</p>
<p>The benefits of using standard interfaces to access
      cryptographic services include:
</p>
<p></p>
<ul class="text">
<li>Provide a common, logical model of cryptographic modules that
			  is straightforward to learn and easy to use.
</li>
<li>Enable the replacement of one cryptographic module for
			  another without significant modifications to the client programs
			  that interact and use the cryptographic module, assuming certain
			  compatibility characteristics between the modules exist.
</li>
<li>Accommodate binding to multiple programming languages.
</li>
<li>Enforce the correct use of the API; in particular, interfaces
			  must be used in the intended order, imposable at compile time or
			  recognizable via static analysis.
</li>
<li>Support high assurance evaluation by enabling evaluators to
			  quickly validate that a particular implementation uses only the
			  required functions in the manner they were intended.
</li>
</ul>

<a name="anchor3"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1.2"></a><h3>1.2.&nbsp;
Language Independent</h3>

<p>CICM is defined using Interface Definition Language (IDL)
      <a class='info' href='#IDL'>[IDL]<span> (</span><span class='info'>International Standards Organization, &ldquo;Information technology — Open Distributed Processing — Interface Definition Language,&rdquo; March&nbsp;1999.</span><span>)</span></a>, a specification language that describes
      a software interface in a language-neutral way. The specification
        currently does not specify normative bindings for specific
        programming languages, although bindings for common languages can
        be generated from the IDL provided with the specification. However,
        normative bindings for one or more popular programming languages
        will be made available in a future release of the
        specification.
</p>
<p>The use of IDL
      in CICM is not intended to either prescribe or preclude a particular
      communications protocol such as General Inter-ORB Protocol (GIOP) <a class='info' href='#CORBA'>[CORBA]<span> (</span><span class='info'>Object Management Group, &ldquo;Common Object Request Broker Architecture (CORBA) Specification, Version 3.1,&rdquo; January&nbsp;2008.</span><span>)</span></a>
      between programs in different address	spaces or on different devices.
</p>
<a name="anchor4"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1.3"></a><h3>1.3.&nbsp;
Audience</h3>

<p>The CICM specification is written for computer
			programmers, software engineers, and technical architects with a
			background in data security and cryptography. Knowledge of
			object-oriented programming concepts is useful when reading IDL
			definitions. Software engineers may use the specification when
			developing software that integrates with cryptographic modules.
			Technical architects may use the specification when designing
			systems that incorporate cryptographic modules to secure data
			within the system or between systems.
</p>
<p>Although the specification is targeted to software developers
			who will access module services using a compliant implementation,
			it also addresses module developers and others who implement
			library and other support software.
</p>
<a name="anchor5"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1.4"></a><h3>1.4.&nbsp;
Scope of the Specification</h3>

<p>The CICM model should provide a common
			way to access the following services offered by cryptographic
			modules:
			</p>
<ul class="text">
<li>Cryptographic module management: Includes retrieving
			  information about a specific module, managing access control,
			  managing module events, and loading and managing software
			  packages on modules.
</li>
<li>Key management: Includes the generation, storage, protection,
			  and removal of key material, and support for message exchanges
			  used in key agreement and key transfer protocols.
</li>
<li>Channel management: A channel defines a specific
			  cryptographic transform and encapsulates all attributes
			  associated with that transform. Channel management includes
			  channel instantiation, channel control throughout its lifetime,
			  providing data to a channel for transformation, and extracting
			  transformed data from a channel.
</li>
</ul>

<p>The following elements are not addressed:
			</p>
<ul class="text">
<li>Hardware interfaces, protocols, or design
</li>
<li>Details of specific protocols (The
			  model provides a means to move protocol messages into and
			  out of a module, but does not dictate low level protocol.)
</li>
<li>Internal structure of certain types of data elements (e.g.,
			  software packages imported into a module, test results extracted
			  from a module)
</li>
<li>Policy enforcement (The model provides a means to
			  convey policy elements to the module, but policy enforcement is
			  considered a module responsibility.)
</li>
<li>Organization of the information stored and processed within a
			  module
</li>
<li>Separation of commands/data for multiple security domains
			  that access a single CICM library instance (e.g., Multiple Levels
			  of Security).
</li>
</ul>

<a name="anchor6"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2"></a><h3>2.&nbsp;
Use Cases</h3>

<p>A significant characteristic that differentiates
			CICM from other cryptographic interfaces such as
      Cryptoki <a class='info' href='#PKCS-11'>[PKCS&#8209;11]<span> (</span><span class='info'>RSA Laboratories, &ldquo;PKCS #11 v2.30: Cryptographic Token Interface Standard,&rdquo; April&nbsp;2009.</span><span>)</span></a>,
      GSS-API <a class='info' href='#RFC5554'>[RFC5554]<span> (</span><span class='info'>Williams, N., &ldquo;Clarifications and Extensions to the Generic Security Service Application Program Interface (GSS-API) for the Use of Channel Bindings,&rdquo; May&nbsp;2009.</span><span>)</span></a>, and
      <a class='info' href='#JCA'>[JCA]<span> (</span><span class='info'>Oracle, &ldquo;Java Cryptography Architecture,&rdquo; August&nbsp;2002.</span><span>)</span></a> is its ability to support
			cryptographic modules that separate two security domains. The use
			cases that follow capture this fundamental element of the CICM
			model. These use cases can be divided into two basic
			types:
			</p>
<ul class="text">
<li>Cryptographic transformation of data initiated in one
			  security domain with the result made available in another
			  security domain
</li>
<li>Cryptographic transformation of data within a single security
			  domain: Cryptographic hash or digital signature operations may be
			  initiated in the same security domain where the result is
			  received. Other single domain use cases include data
			  encryption/decryption for storage and keystream/random data
			  generation.
</li>
</ul>

<p>The data-in-transit and data-at-rest use cases illustrated below
			incorporate multiple security domains, while the final use case
			depicts a transformation within a single domain.
</p>
<a name="anchor7"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2.1"></a><h3>2.1.&nbsp;
Data-in-Transit</h3>

<p>The figure below shows a hardware device
				with an embedded cryptographic module providing encryption and
				decryption services between a secure and non-secure network. The
				secure side protocol logic subsystems access cryptographic services
				using CICM. In this use case, the High Assurance IP Encryptor
				(HAIPE) device uses CICM to enable the internal protocol logic
				of the device to access cryptographic services; the network to
				which the HAIPE device is connected does not interface to the
				protocol encryptor using CICM.
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
                  High Assurance IP Encryptor
        +----------------------------.-----------------+
        |    HAIPE              Cryptographic  HAIPE   |
Secure &lt;-&gt; Protocol &lt;-&gt; CICM &lt;-&gt;  Module &lt;-&gt; Protocol &lt;-&gt; Non-Secure
Network |    Logic                   .         Logic   |   Network
        +----------------------------.-----------------+
                                     .
                               Security Domain
                                  Boundary
</pre></div>
<p>Figure 1. First Data-in-Transit Use Case, HAIPE
</p>
<p>The following figure depicts the same use case in its end-to-end
				configuration.
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
                                      Security Domain
                                         Boundary
                                            .
             +------------------------------.--------+
             |   HAIPE                      .        |
( Secure  ) &lt;-&gt; Protocol &lt;-&gt; CICM &lt;-&gt; Cryptographic &lt;---+
( Network )  |   Logic                    Module     |  |
             +------------------------------.--------+  |
                                                        |
          +-------------&gt; ( Non-Secure ) &lt;--------------+
          |               (  Network   )
          |
          |  +--------.------------------------------+
          |  |        .                     HAIPE    |
          +---&gt; Cryptographic &lt;-&gt; CICM &lt;-&gt; Protocol &lt;-&gt; ( Secure  )
             |      Module                  Logic    |  ( Network )
             +--------.------------------------------+
                      .
                Security Domain
                   Boundary
</pre></div>
<p>Figure 2. HAIPE Use Case in End-to-End Configuration
</p>
<p>A second data-in-transit use case shows a tactical secure radio
				with an embedded cryptographic module providing encryption and
				decryption services between a local host and a radio frequency
				environment. The functional blocks that make up the tactical secure
				radio are logically identical to those in the first example.
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
                     Tactical Secure Radio
      +----------------------------.---------------------+
Host &lt;-&gt; Information &lt;-&gt; CICM &lt;-&gt; Module &lt;-&gt;   Waveform &lt;-&gt; RF
      |  Processing                .          Processing |
      +----------------------------.---------------------+
                                   .
                             Security Domain
                                Boundary
</pre></div>
<p>Figure 3. Second Data-in-Transit Use Case, Tactical Secure Radio
</p>
<a name="anchor8"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2.2"></a><h3>2.2.&nbsp;
Data-at-Rest</h3>

<p>The figure below shows a cryptographic module
				providing encryption services for data stored on a disk and
				decryption services for data read from a disk. A file system driver
				accesses cryptographic services using CICM.
				This use case could apply to a laptop computer that contains
				encrypted data; it would prevent access to sensitive data from a
				lost or stolen laptop.
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
                    Host                         .
      +---------------------------------+        .
User &lt;-&gt;   Word    &lt;-&gt;  File  &lt;-&gt; CICM &lt;-&gt; Cryptographic &lt;-&gt; Disk
      |  Processor     System           |      Module
      +---------------------------------+        .
                                                 .
                                           Security Domain
                                              Boundary
</pre></div>
<p>Figure 4. Data-at-Rest Use Case
</p>
<a name="anchor9"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2.3"></a><h3>2.3.&nbsp;
Single Security Domain</h3>

<p>The following figure shows a cryptographic transform within a single security domain (it assumes
				that the transform does not change the classification of the data).
				The plaintext is conveyed to the module, transformed by an
				encryption algorithm, and results in ciphertext. This information
				is then returned to the same domain from which the plaintext
				originated. Other natural examples of a single domain use case
				include signing, which results in a digital signature; hashing,
				which results in a hash value; and keystream generation, which
				results in keystream data.
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
      1. Query              2. Load
User &lt;---------&gt; Database &lt;---------&gt; Disk
                 Back end
                    |
                    +---------------&gt; Cryptographic
                       3. Decrypt         Module
</pre></div>
<p>Figure 5. Single Security Domain Use Case
</p>
<a name="anchor10"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3"></a><h3>3.&nbsp;
Module Management</h3>

<p>The fundamental element of the CICM model is the MODULE --
    an abstraction which refers to the cryptographic module and its capabilities.
    A single CICM library may provide access to multiple modules.
</p>
<p>Each module contains references to information about the module,
    including the module  manufacturer, serial number, and version numbers.
    Modules also defines attributes called MANAGERS that provide
    access to the services made available by the module.
</p>
<a name="mm-auth"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.1"></a><h3>3.1.&nbsp;
Managing Module Authentication</h3>

<p>Modules may require a host
      or user to authenticate to the module before the module will enter
      an operational state, allowing it to accept commands and perform
      cryptographic transformations. In some cases, a specialized,
      removable hardware component will perform or participate in the
      authentication. This hardware component is termed a
       HARDWARE ACCESS TOKEN in CICM nomenclature, although other
      communities may use different terminology. Most implementations
      that use hardware access tokens will transfer key material between
      the token and module, independent of CICM. In cases where access
      tokens are not supported, a user may provide authentication
      credentials to the module via CICM. In still other cases,
      support for multi-factor authentication will require a token and a
      user login. Note that the user and token holder may be different
      entities.
</p>
<p>CICM provides interfaces that can be used separately or in
      combination with one another as appropriate for the system using
      them and for the authentication mechanisms offered by the module
      that is used by the system. Methods to manage module/token
      associations are available for systems where hardware access tokens
      are supported. Login methods and related user management methods
      are supported for systems that require user login.
</p>
<a name="anchor11"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.1.1"></a><h3>3.1.1.&nbsp;
Managing Hardware Access Tokens</h3>

<p>The TOKEN MANAGER defines
        methods that support associating a token with a module,
        disassociating a token from a module, and disassociating a module
        from a token. The manager also supports retrieving a list of token
        associations on a module and module associations on a token.
</p>
<a name="anchor12"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.1.2"></a><h3>3.1.2.&nbsp;
Managing Users</h3>

<p>The USER MANAGER defines methods that
        support adding users to and removing users from a module user
        database, and associating a user with a module-defined ROLE. The
        manager also supports listing the user database, and the roles
        defined and supported by the module.
</p>
<a name="anchor13"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.1.3"></a><h3>3.1.3.&nbsp;
Logging in to a Module from a Host</h3>

<p>The LOGIN MANAGER
        defines methods that enable a user configured on a module to login
        to and logout from a module.
</p>
<a name="anchor14"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.2"></a><h3>3.2.&nbsp;
Managing Software Packages</h3>

<p>The PACKAGE MANAGER defines
      methods that support importing and managing the executable images
      that reside on a cryptographic module. These methods enable module
      software/firmware PACKAGES to be imported and other software
      package management operations to be performed, including retrieving
      a list of packages, and activating or deleting a specific
      package.
</p>
<p>The package manager enables packages to be imported into a
      module in segments rather as an atomic unit. This supports modules
      that must make special provisions to import executable images due
      to internal storage space limitations.
</p>
<a name="mm-logs"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.3"></a><h3>3.3.&nbsp;
Managing Logs</h3>

<p>Modules generate log entries as they operate.
      The LOG MANAGER defines methods that support retrieving individual
      log entries or extracting an entire log from a module.
      Additionally, clients may clear individual log entries or the
      entire module log.
</p>
<a name="anchor15"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.4"></a><h3>3.4.&nbsp;
Managing Tests</h3>

<p>Modules may incorporate built-in tests to
      validate that module functionality is operating as designed. Some
      tests may be externally initiated. The TEST MANAGER defines methods
      that support host-initiated module tests.
</p>
<a name="anchor16"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.5"></a><h3>3.5.&nbsp;
Managing Module Events</h3>

<p>The MODULE EVENT MANAGER defines methods
      that support registering/unregistering module-generated event
      notifications received by a client program. Clients can register
      custom-developed CALLBACK procedures, called
       LISTENERS, for specific module events. When the condition
      associated with a specific listener presents itself, the registered
      listener is called.
</p>
<p>Examples of events for which listeners may be registered
      include:
      </p>
<ul class="text">
<li>Hardware access token has been inserted or removed.
</li>
<li>Module is ready to receive traffic.
</li>
<li>Alarm condition is raised.
</li>
<li>Hardware zeroization condition raised.
</li>
<li>Continuous module/engine health test failed.
</li>
<li>Usable lifespan of key expired.
</li>
<li>Change in module power state.
</li>
</ul>

<a name="anchor17"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4"></a><h3>4.&nbsp;
Key Management</h3>

<p>Cryptographic modules use key material
    under their protection as one input to perform a cryptographic
    transformation. Keys
    </p>
<ul class="text">
<li>can originate at a Key Infrastructure Component that has a trust
      relationship with the module
</li>
<li>may be agreed upon between the module and another entity
</li>
<li>may be generated on the module itself
</li>
<li>may be derived from information presented to the module by a
      client program.
</li>
</ul>

<p>Once established on a module, they may be subject
      to client-initiated management operations or may be used as part
      of a cryptographic channel to effect cryptographic
      transformations.
</p>
<p>CICM treats SYMMETRIC KEYS and
    ASYMMETRIC KEYSETS separately. An asymmetric keyset may comprise an asymmetric
    key pair, the public and private key components of a keypair, the
    digital certificate corresponding to the keyset public key, one or
    more verification certificates in the certificate chain of trust,
    and related public domain parameters.
</p>
<p>The ASYMMETRIC KEY MANAGER and SYMMETRIC KEY MANAGER attributes allow for
    access to asymmetric keysets and symmetric keys, respectively.
</p>
<a name="anchor18"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.1"></a><h3>4.1.&nbsp;
Creating and Establishing Keys</h3>

<p>Keys may be moved into a
      module in one of several scenarios. Each scenario is described in
      detail below.
</p>
<a name="anchor19"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.1.1"></a><h3>4.1.1.&nbsp;
No Host Interaction Key Fill</h3>

<p>Specialized hardware devices
        designed to transfer key from a key infrastructure component to a
        specific cryptographic module may fill key into a module without
        host involvement and thus no API interaction. In some cases, this
        process does not support transferring key metadata with a key. This
        requires host and API interaction to apply metadata to the key
        inside the module upon completion of the fill.
</p>
<a name="anchor20"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.1.2"></a><h3>4.1.2.&nbsp;
Client Program-Initiated</h3>

<p>In some cases, key fill devices
        require host interaction to initiate a key fill. In such cases,
        the target key storage location or key tagging information can be specified
        prior to the initiation of the fill.
</p>
<p>Keys may be imported directly or derived using
        a text-based secret provided by the user of the client program.
        Keys also may be generated on the module. Each case
        results in a persistent key.
</p>
<p>A key also is implicitly established each time a channel is
        created using an asymmetric keyset and upon renegotiation. Keys
        resulting from channel-based key agreement are ephemeral; they are
        not generally managed outside of a channel. Ephemeral keys also may
        be destroyed when a channel is destroyed.
</p>
<a name="km-keyproto"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.1.3"></a><h3>4.1.3.&nbsp;
Module/Key Infrastructure Initiated</h3>

<p>A facility to operate a
        key agreement protocol with an infrastructure component is
        supported. This facility also enables key material or key
        revocation information to be authenticated by one of the module's
        trust anchors, and then loaded into the module.
</p>
<a name="anchor21"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.2"></a><h3>4.2.&nbsp;
Exporting Keys</h3>

<p>Methods to export key material out of a
      module are supported. A module may require wrapping the key
      material prior to export or may disallow this operation.
</p>
<a name="anchor22"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.2.1"></a><h3>4.2.1.&nbsp;
Locating and Retrieving Information about a Key</h3>

<p>A method to
        locate a specific key on a module based upon identification
        information associated with the key is supported. In addition, the
        entire key database may be listed.
</p>
<a name="anchor23"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.2.2"></a><h3>4.2.2.&nbsp;
Applying Metadata to Keys</h3>

<p>Key metadata may be retrieved and
        set for individual keys. Metadata elements include the key
        identifier, alias, and classification. Untagged keys that are
        imported via a fill device may require certain metadata to be
        applied after the conclusion of the load.
</p>
<a name="anchor24"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.2.3"></a><h3>4.2.3.&nbsp;
Performing Operations on Keys</h3>

<p>A number of management
        operations on keys are supported. Keys may be wrapped
        (cryptographically protected) in preparation for export, or
        unwrapped after import. All key material on the module can be
        zeroized either on a key-by-key basis or as a whole. There are
        also operations to perform key conversions and updates.
</p>
<a name="anchor25"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.2.4"></a><h3>4.2.4.&nbsp;
Enabling Remote Management</h3>

<p>CICM supports various key management-related protocol messages
        including remote key functions (e.g., remote zeroize or rekey),
        infrastructure-initiated key revocation, and trust anchor
        management.
</p>
<a name="cm"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5"></a><h3>5.&nbsp;
Channel Management</h3>

<p>The CHANNEL is the fundamental
    construct under which one or more related cryptographic transforms
    are performed, and within which all details and attributes
    associated with the transform are encapsulated, including the path
    through the module. Most channels accept data from a port in the
    local security domain, transform the data, and output the result on
    a port in another security domain. A channel also may perform
    transformations within a single security domain, or may accept data
    for transformation in one domain and output the result in another.
    The channel type determines which ports must be specified when a
    channel is created.
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
               Security Domain         Security Domain
                  Boundary                Boundary
                     .                       .
            +--------.--------+     +--------.--------+
 Client  --(a) Cryptographic (b)---(c) Cryptographic (d) -- Client
Program X   |      Module     |     |      Module     |    Program Y
            +--------.--------+     +--------.--------+
                     .                       .

            X local    X remote     Y remote    Y local
            port (a)   port (b)     port (c)   port (d)
</pre></div>
<p>Figure 6. Local and Remote Port
      Nomenclature for Channels that Operate in Two Security
      Domains
</p>
<p>Three classes of objects are fundamental to the creation and use
    of CICM channels. A
     CONTROLLER is used to configure and control a channel. A
     STREAM enables data to be sent to a module to be
    transformed, and transformed data to be received using a controller
    as a foundation. A
     CONDUIT is the sum of a controller and a stream. Thus, the
    term
     "channel" is only an abstraction representing the logical
    path through the module on which cryptographic transformations are
    performed.
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
+----------------------------------------+
|                  Channel               |
|                                        |
|  +-----------------------+             |
|  |             +--------------------+  |
|  | Controller  | Conduit |   Stream |  |
|  +-----------------------+          |  |
|                +--------------------+  |
+----------------------------------------+
</pre></div>
<p>Figure 7. Relationship Between Channel,
      Conduit, Controller, and Stream
</p>
<p>This division of responsibility makes channels very flexible.
    One client program can be responsible for creating and managing
    channels with a controller, and another can send data over this
    pre-configured channel for transformation using a stream. In some
    environments, data to be transformed never enters the host to pass
    through the API. Instead, it is clocked directly through the
    module. In this situation, a controller is configured, but no
    stream is configured since it would never be used. In other cases,
    a client program is required to configure the channel and pass data
    through the channel it configured. In this case, the client program
    configures a conduit, which incorporates a controller and a
    stream.
</p>
<p>Both controllers and conduits accept symmetric keys, requiring
    that the client program configuring the channel and its remote peer
    share the same secret key. Alternatively, all peers may hold their
    own respective asymmetric keysets, requiring a key negotiation
    which, upon successful completion, results in each peer holding an
    ephemeral symmetric key. CICM supports a NEGOTIATOR for this purpose.
    A successful negotiation results in a negotiated
    controller or conduit.
</p>
<p>CICM supports the following channel types:
    </p>
<ul class="text">
<li>Encryption/decryption, including selective bypass
</li>
<li>Signature generation/verification
</li>
<li>Message Authentication Code (MAC)
      generation/verification
</li>
<li>Cryptographic hashing
</li>
<li>Keystream generation
</li>
<li>Random/pseudo-random data generation
</li>
<li>Key wrap
</li>
<li>Full bypass.
</li>
</ul>

<p>CICM also supports hybrid channel types. A channel that
    simultaneously supports encryption and signature, resulting in both
    ciphertext and a final signature value, is a hybrid channel.
</p>
<p>Each of the types above differs in the way it is configured, its
    configuration options, and how it handles the cryptographic
    transformation of data. Consider the following examples portraying
    the diversity of the channel types:
    </p>
<ul class="text">
<li>The encryption channel accepts plaintext to be transformed,
      and can return the resulting ciphertext directly to the caller or
      route it a different security domain
</li>
<li>The random data generation channel requires no data for
      transformation, but emits a random stream
</li>
<li>The signature channel accepts an indeterminate amount of
      data, and returns an algorithm-specific fixed-sized value
</li>
<li>The hashing channel does not accept a cryptographic key as a
      parameter, as most of the other channel types do (keyed hashes
      are supported by MAC channels)
</li>
<li>The decryption channel accepts a state vector input
      parameter, but does not allow a state vector to be
      generated.
</li>
</ul>

<p>This diversity results from the fundamental characteristics of
    the cryptographic primitives that are being abstracted. The
    CHANNEL MANAGER defines the methods that support creating conduits,
    controllers, streams, and negotiators for each of the channel
    services listed above.
</p>
<a name="anchor26"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.1"></a><h3>5.1.&nbsp;
Creating Channels</h3>

<p>Creating a channel requires an awareness
      of the options available:
      </p>
<ul class="text">
<li>The type of cryptographic operation desired (encryption,
        hashing, keystream generation, etc.)
</li>
<li>How the channel will be used (control-only, send/receive data
        only, or both control and send/receive data)
</li>
<li>The type of key that will be used for channels that require a
        symmetric key or an asymmetric keyset (hybrid channels accept two
        keys).
</li>
</ul>

<p>Selecting among these options enables the client program
      developer to determine what channel interface to use.
</p>
<p>In cases where an asymmetric keyset is used, channels are created
      as a result of a key agreement protocol negotiation with a remote peer.
      To ensure that it is the expected peer, a human user at the client may
      validate information extracted from the peer's certificate.
      If the module uses a trusted display, the module communicates
      the peer information directly to the
      display. Based upon user input at the display, host-independent
      negotiation is continued or aborted. If no trusted display is
      available, the client program requests information about the remote
      peer, displays it at the host for user confirmation, and provides
      positive confirmation via the API that the peer is valid, allowing
      the negotiation to continue.
</p>
<a name="anchor27"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.1.1"></a><h3>5.1.1.&nbsp;
Encryption and Decryption</h3>

<p>CICM defines interfaces to
        support encryption and decryption between two security domains or
        within a single security domain. Additional variants are defined
        including hybrid channels that can concurrently compute integrity
        values. Another set of variants provides methods to perform
        encryption/decryption with selective bypass.
</p>
<p>If an asymmetric keyset is used to create a channel, a
        negotiation process is initiated, which results in a negotiated
        channel. Negotiated versions of hybrid channels also are available.
        For those negotiator versions that combine encryption with
        integrity value generation, negotiation applies only to the
        encryption key specified when the channel is negotiated, not the
        signature or MAC key.
</p>
<p>Channel-based multiple key wrap/unwrap support is provided via a
        special channels for that purpose.
</p>
<p>CICM also supports encryption/decryption channels that operate
        in coprocessor mode . These channels accept their input and return their
        output as part of the same method call. Where relevant, the
        integrity value or verification status (verified/not verified) is
        returned when the final block of the input has been presented for
        transformation.
</p>
<p>Duplex channel configurations that use the same key to perform
        encrypt and decrypt transformations also are supported. Negotiated
        versions of the duplex channel also are available.
</p>
<a name="anchor28"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.1.2"></a><h3>5.1.2.&nbsp;
Bypass</h3>

<p>Bypass channels capable of defining a path through a
        module and then bypassing data from one security domain to a
        different domain are supported. Selective bypass also is supported
        on encryption and decryption channels.
</p>
<a name="anchor29"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.1.3"></a><h3>5.1.3.&nbsp;
Integrity</h3>

<p>Interfaces to compute and validate integrity
        values using asymmetric key-derived digital signatures or symmetric
        key-derived MACs are available. A variant on the sign and verify
        interfaces accepts a previously generated hash value in place of a
        message.
</p>
<a name="anchor30"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.1.4"></a><h3>5.1.4.&nbsp;
Hashing</h3>

<p>A channel to calculate a fixed-length cryptographic
        hash from an input message is available. Keyed hashes are supported
        by MAC channels.
</p>
<a name="anchor31"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.1.5"></a><h3>5.1.5.&nbsp;
Keystream Generation</h3>

<p>Channels are supported to read keystream from a module.
</p>
<a name="anchor32"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.1.6"></a><h3>5.1.6.&nbsp;
Random Data</h3>

<p>Separate interfaces are defined to retrieve
        random or pseudorandom data from a module.
</p>
<a name="anchor33"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.2"></a><h3>5.2.&nbsp;
Managing Channels</h3>

<p>Only conduits and controllers (not
      streams) can manage channels. Negotiators can manage the
      negotiation aspects of a channel.
</p>
<p>The management operations that can be performed on a channel are
      specific to each channel type, but the following general operations
      are supported:
      </p>
<ul class="text">
<li>Generating, extracting, and setting state vectors
</li>
<li>Resynchronization
</li>
<li>Initiating a key rollover
</li>
<li>Initiating a key update.
</li>
</ul>

<p>Negotiators support the following general operations:
      </p>
<ul class="text">
<li>Renegotiation
</li>
<li>Changing classification level/acknowledging change of
        classification level.
</li>
</ul>

<p>Managing state vectors is an important channel management
      capability. CICM provides a method to explicitly generate a state
      vector for those algorithms/modes that require a random
       initialization vector (IV), although modules may
      alternatively generate an IV as a byproduct of channel creation.
      CICM also provides a method to set the state vector on a channel.
      This may be used to:
      </p>
<ul class="text">
<li>Set the decrypt channel to the IV generated/used on the
        encrypt side of a channel.
</li>
<li>Provide a vector on a block-by-block basis for appropriate
        algorithms/modes or at each time epoch (e.g., time-of-day
        encryption). In addition, a method is available to take a special
        state vector called a
         synchronization vector to assist in resynchronizing a
        channel.
</li>
</ul>

<a name="anchor34"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.3"></a><h3>5.3.&nbsp;
Using Channels</h3>

<p>Only conduits and streams (not controllers)
      can send data for transformation and receive cryptographically
      transformed data on a channel.
</p>
<p>The data operations that can be performed on a channel or stream
      are specific to each channel type, but the following general
      operations are supported:
      </p>
<ul class="text">
<li>Sending data on a channel to initiate a cryptographic
        transformation:
        
<ul class="text">
<li>Blocking send: Call does not return until data has been
        sent or the operation times out.
</li>
<li>Non-blocking send: Call queues data for sending and returns
        immediately to the caller.
</li>
<li>Poll: Determines status of non-blocking send
        operation.
</li>
</ul>
</li>
<li>Receiving transformed data from a channel:
        
<ul class="text">
<li>Blocking read: Blocks until data becomes available or the
        operation times out.
</li>
<li>Non-blocking read: Call queues a buffer to receive data and
        returns immediately.
</li>
<li>Poll: Determines status of non-blocking read
        operation.
</li>
<li>Notification via callback that data has become available
        using a channel event listener.
</li>
</ul>
</li>
</ul>

<p>Although it is possible for multiple client programs to use
      the same stream, the model provides no facilities to
      coordinate the parties participating in the communication.
</p>
<p>Certain channel services support receiving an "answer" from a
      channel. For example, signature and hashing channels accept
      variable amounts of data for transformation before returning a
      final, constant-sized "answer" (a signature or a hash) to the
      caller. HYBRID CHANNELS require sending/receiving data and
      receiving a final "answer" after a discrete unit of data has been
      transformed.
</p>
<p>The figure below depicts the use of a hybrid channel. Plaintext
      is sent through CICM for transformation. The module
      performs encrypt and sign transformations on the plaintext data.
      Ciphertext resulting from the encrypt transform emits from the
      module in a different security domain than the one in which it
      originated. When it is finished presenting data for transformation,
      the client program requests the signature that results from the
      transaction.
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>                          .
        Plaintext         .       Ciphertext
  Host  ---------&gt;  Cryptographic ----------&gt;
        &lt;---------      Module
         Signature        .
                          .
                    Security Domain
                       Boundary

</pre></div>
<p>Figure 8. Hybrid Sign-Encrypt Channel Operations
</p>
<p>Each type of channel supports a specific set of channel data
      operations. Channel types and the data operations they support are
      listed below:
      </p>
<ul class="text">
<li>Encrypt, selective bypass with encryption, and full bypass
        write channels: Write data in the local security domain for
        transformation and output in another security domain.
</li>
<li>Decrypt, selective bypass with decryption, and full bypass
        read channels: Read transformed data from one security domain
        into the local security domain.
</li>
<li>Coprocessor channels: Data is presented for transformation
        and the result received within the same security domain.
</li>
<li>Duplex channels: Read/write exchange between two security
        domains.
</li>
<li>Keystream and random data generation: Transformation within
        module results in data stream that emits in the local
        domain.
</li>
</ul>

<a name="anchor35"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.4"></a><h3>5.4.&nbsp;
Grouping Channels</h3>

<p>Controllers and conduits can be grouped
      to enable certain characteristics to be shared. One characteristic
      may be the state vector associated with the channels. This supports
      environments where two or more channels with related security rules
      supporting a single operation are used within a system. Whenever a
      shared characteristic is changed on a controller or conduit in a
      group, the effect of this change is applied to all
      controllers/conduits in the group.
</p>
<a name="anchor36"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.5"></a><h3>5.5.&nbsp;
Receiving Notification of Channel Events</h3>

<p>The CICM model
      defines methods that support managing module event notifications.
      Similar support is available at the granularity of an individual
      conduit/controller. Conduits and controllers define methods that
      support registering/unregistering channel-specific module-generated
      event notifications captured by a client program. Clients can
      register custom-developed callback procedures called
       listeners for specific channel events. When the condition
      associated with a specific listener presents itself, the registered
      listener is called.
</p>
<p>Examples of channel events for which listeners may be registered
      include:
      </p>
<ul class="text">
<li>Data is available.
</li>
<li>Synchronization with peer has been lost.
</li>
<li>Remote peer no longer available.
</li>
<li>General channel error encountered.
</li>
</ul>

<a name="anchor37"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.6"></a><h3>5.6.&nbsp;
Destroying Channels</h3>

<p>Conduits and controllers may be
      destroyed when their services are no longer needed. A channel is
      destroyed without regard for users who may have pending operations
      on the channel. Any ephemeral keys associated with the channel also
      may be destroyed. A stream ceases to function when its associated
      controller is destroyed. A destroyed channel is removed from any
      channel groups to which it belongs without effect upon other
      controllers/conduits in the group.
</p>
<a name="anchor38"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6"></a><h3>6.&nbsp;
IANA Considerations</h3>

<p>[RFC Editor: Please remove this section prior to publication.]
</p>
<p>This document has no IANA actions.
</p>
<a name="anchor39"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7"></a><h3>7.&nbsp;
Security Considerations</h3>

<a name="anchor40"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.1"></a><h3>7.1.&nbsp;
Unauthorized Usage</h3>

<p>Cryptographic modules are typically protected assets and most have built-in
    mechanisms for preventing unauthorized usage. <a class='info' href='#mm-auth'>Section&nbsp;3.1<span> (</span><span class='info'>Managing Module Authentication</span><span>)</span></a> discusses
    several mechanisms for preventing unauthorized usage including using hardware access tokens
    and user login. Specific implementations may also consider the use of access control
    lists.
</p>
<a name="anchor41"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.2"></a><h3>7.2.&nbsp;
Inappropriate Usage</h3>

<p>The log manager described in <a class='info' href='#mm-logs'>Section&nbsp;3.3<span> (</span><span class='info'>Managing Logs</span><span>)</span></a> may be used by some modules to
    report certain types of usage which may act as a type of audit log thereby providing
    information about inappropriate usage.
</p>
<a name="anchor42"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.3"></a><h3>7.3.&nbsp;
Confidentiality and Data Integrity</h3>

<p>Many of CICM's channel types provide confidentiality services such as encryption and decryption as well
    as data integrity services such as hashing, MACing, signing, and verifying.
</p>
<p>Hybrid channels provide a combination of confidentiality and data integrity service.
</p>
<a name="anchor43"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.4"></a><h3>7.4.&nbsp;
Bypass</h3>

<p>There are four broad categories of bypass that are supported: reading and writing full bypass; encrypting
    and decrypting with selective bypass. These services must be used with caution in order to avoid
    accidental or malicious bypass of protected data.
</p>
<a name="anchor44"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.5"></a><h3>7.5.&nbsp;
Entity Authentication</h3>

<p>As described in <a class='info' href='#cm'>Section&nbsp;5<span> (</span><span class='info'>Channel Management</span><span>)</span></a>, a negotiator is the primary mechanism
    for establishing that the peer entity is the one desired.
</p>
<p>Similarly, the mechanism described in <a class='info' href='#km-keyproto'>Section&nbsp;4.1.3<span> (</span><span class='info'>Module/Key Infrastructure Initiated</span><span>)</span></a> ensures
    that the infrastructure component that is attempting to send data to the module
    is trusted.
</p>
<a name="rfc.references1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>8.&nbsp;Informative References</h3>
<table width="99%" border="0">
<tr><td class="author-text" valign="top"><a name="CNSSI-4009">[CNSSI-4009]</a></td>
<td class="author-text">Committee on National Security Systems (U.S. Government), &ldquo;National Information Assurance (IA) Glossary,&rdquo; CNSS Instruction&nbsp;No. 4009, revised June&nbsp;2006.</td></tr>
<tr><td class="author-text" valign="top"><a name="CORBA">[CORBA]</a></td>
<td class="author-text">Object Management Group, &ldquo;Common Object Request Broker Architecture (CORBA) Specification, Version 3.1,&rdquo; January&nbsp;2008.</td></tr>
<tr><td class="author-text" valign="top"><a name="FIPS-140-2">[FIPS-140-2]</a></td>
<td class="author-text">Federal Information Processing
					Standards Publication (FIPS PUB) 140-2, &ldquo;Security Requirements for Cryptographic Modules,&rdquo; May&nbsp;2001.</td></tr>
<tr><td class="author-text" valign="top"><a name="GCS-API">[GCS-API]</a></td>
<td class="author-text">The OpenGroup, &ldquo;Generic Cryptographic Service API,&rdquo; June&nbsp;1996.</td></tr>
<tr><td class="author-text" valign="top"><a name="IDL">[IDL]</a></td>
<td class="author-text">International Standards Organization, &ldquo;Information technology — Open Distributed Processing — Interface Definition Language,&rdquo; ISO/IEC&nbsp;14750:1999(E), March&nbsp;1999.</td></tr>
<tr><td class="author-text" valign="top"><a name="JCA">[JCA]</a></td>
<td class="author-text">Oracle, &ldquo;Java Cryptography Architecture,&rdquo; August&nbsp;2002.</td></tr>
<tr><td class="author-text" valign="top"><a name="PKCS-11">[PKCS-11]</a></td>
<td class="author-text">RSA Laboratories, &ldquo;PKCS #11 v2.30: Cryptographic Token Interface Standard,&rdquo; April&nbsp;2009.</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4949">[RFC4949]</a></td>
<td class="author-text">Shirey, R., &ldquo;<a href="http://tools.ietf.org/html/rfc4949">Internet Security Glossary, Version 2</a>,&rdquo; RFC&nbsp;4949, August&nbsp;2007 (<a href="http://www.rfc-editor.org/rfc/rfc4949.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC5554">[RFC5554]</a></td>
<td class="author-text">Williams, N., &ldquo;<a href="http://tools.ietf.org/html/rfc5554">Clarifications and Extensions to the Generic Security Service Application Program Interface (GSS-API) for the Use of Channel Bindings</a>,&rdquo; RFC&nbsp;5554, May&nbsp;2009 (<a href="http://www.rfc-editor.org/rfc/rfc5554.txt">TXT</a>).</td></tr>
</table>

<a name="terms"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.A"></a><h3>Appendix A.&nbsp;
Terms</h3>

<p>This section contains a list of terms and their corresponding definitions as used in this model.
    Following the formatting convention in <a class='info' href='#RFC4949'>[RFC4949]<span> (</span><span class='info'>Shirey, R., &ldquo;Internet Security Glossary, Version 2,&rdquo; August&nbsp;2007.</span><span>)</span></a>, each term is preceded by a dollar sign ($)
    and a space to facilitate automated searching.
</p>
<p>$ alarm</p>
<blockquote class="text">
<p>Output signal that denotes that the module has entered an alarm state. An alarm condition may prohibit a module from performing cryptographic operations.
</p>
</blockquote>

<p>$ asymmetric key</p>
<blockquote class="text">
<p>Pair of related keys, a public key known to everyone and a private key known only to the owning entity. See symmetric key and asymmetric keyset.
</p>
</blockquote>

<p>$ asymmetric keyset</p>
<blockquote class="text">
<p>May comprise one more of the following components: an asymmetric key pair, the public and private key components of a keypair, the digital certificate corresponding to the keyset public key, one or more verification certificates in the certificate chain of trust, and related public domain parameters. See also asymmetric key.
</p>
</blockquote>

<p>$ asynchronous notification</p>
<blockquote class="text">
<p>Delivery of an indication of a condition or event where, from the point of view of the recipient (the client program), the delivery occurs asynchronously via a callback. See also event and event notification.
</p>
</blockquote>

<p>$ attribute</p>
<blockquote class="text">
<p>State associated with an instance of an interface.
</p>
</blockquote>

<p>$ authentication</p>
<blockquote class="text">
<p>Security measure designed to establish the validity of a transmission, message, or originator, or a means of verifying an individual's authorization to receive specific categories of information (<a class='info' href='#CNSSI-4009'>[CNSSI&#8209;4009]<span> (</span><span class='info'>Committee on National Security Systems (U.S. Government), &ldquo;National Information Assurance (IA) Glossary,&rdquo; revised June&nbsp;2006.</span><span>)</span></a>).
</p>
</blockquote>

<p>$ authorization</p>
<blockquote class="text">
<p>Access privileges granted to a user, program, or process (<a class='info' href='#CNSSI-4009'>[CNSSI&#8209;4009]<span> (</span><span class='info'>Committee on National Security Systems (U.S. Government), &ldquo;National Information Assurance (IA) Glossary,&rdquo; revised June&nbsp;2006.</span><span>)</span></a>).
</p>
</blockquote>

<p>$ blocking</p>
<blockquote class="text">
<p>A call to a method is blocking if the method does not return program control to the caller until either the operation has completed or an error is recognized. See also non-blocking.
</p>
</blockquote>

<p>$ buffer</p>
<blockquote class="text">
<p>Collection of binary data.
</p>
</blockquote>

<p>$ bypass</p>
<blockquote class="text">
<p>In cryptography, this is an operation whereby all of the data is passed from one security domain through the cryptographic module to the other security domain without having a cryptographic transformation applied to it. See also selective bypass.
</p>
</blockquote>

<p>$ callback</p>
<blockquote class="text">
<p>Procedure provided by the client program that is to be invoked when an appropriate condition or event is recognized. See also asynchronous notification.
</p>
</blockquote>

<p>$ certificate</p>
<blockquote class="text">
<p>Digitally signed document that binds a public key with an identity. The certificate contains, at a minimum, the identity of the issuing Certification Authority, the user identification information, and the user's public key (<a class='info' href='#CNSSI-4009'>[CNSSI&#8209;4009]<span> (</span><span class='info'>Committee on National Security Systems (U.S. Government), &ldquo;National Information Assurance (IA) Glossary,&rdquo; revised June&nbsp;2006.</span><span>)</span></a>).
</p>
</blockquote>

<p>$ certificate revocation list (CRL)</p>
<blockquote class="text">
<p>List of certificate serial numbers corresponding to certificates that have been revoked or are no longer valid.
</p>
</blockquote>

<p>$ channel</p>
<blockquote class="text">
<p>Abstraction under which one or more cryptographic transforms are performed and within which all details associated with the transform are encapsulated, including the path through the module. See also conduit, controller, and stream.
</p>
</blockquote>

<p>$ channel type</p>
<blockquote class="text">
<p>Cryptographic transform to be applied on a channel.
</p>
</blockquote>

<p>$ client program</p>
<blockquote class="text">
<p>Program linked to a CICM library running as a single process on a host computer system that accesses cryptographic services and/or to manages a cryptographic module.
</p>
</blockquote>

<p>$ conduit</p>
<blockquote class="text">
<p>Abstraction that encapsulates channel control and data flow. See also channel, controller, and stream.
</p>
</blockquote>

<p>$ controller</p>
<blockquote class="text">
<p>Abstraction used to configure and control a channel. See also channel, conduit, and stream.
</p>
</blockquote>

<p>$ coprocessor mode</p>
<blockquote class="text">
<p>Mode of operation in which cryptographic transformations are performed within a single security domain. For example, in coprocessor mode, a client program provides plaintext to a module, the plaintext is transformed, and the resulting ciphertext is returned to the same client program.
</p>
</blockquote>

<p>$ cryptographic module</p>
<blockquote class="text">
<p>Abstraction of hardware, firmware, or software components that makes cryptographic services available to client programs via one or more channels.
</p>
</blockquote>

<p>$ cryptographic synchronization</p>
<blockquote class="text">
<p>Process by which a receiving decrypting cryptographic logic attains the same internal state as the transmitting encrypting logic.
</p>
</blockquote>

<p>$ cryptographic transform</p>
<blockquote class="text">
<p>The specific cryptographic process that is to be applied to a stream of data or is used to generate keystream or random data, often (but not always) based upon a cryptographic key. Transforms include encryption, decryption, signing, keystream generation, hashing, and random data generation.
</p>
</blockquote>

<p>$ driver</p>
<blockquote class="text">
<p>Conceptual component residing on a host that enables the exchange of commands and data between the client program and a module. Module-specific abstraction layer that serves as a translation mechanism between the individual functions defined in the CICM library and the commands specific to a given cryptographic module. This component also provides a conduit for data between a host and a module.
</p>
</blockquote>

<p>$ ephemeral symmetric key</p>
<blockquote class="text">
<p>Symmetric cryptographic key generated as part of a key negotiation process. Ephemeral keys may be destroyed when the channel or session utilizing the ephemeral key completes. Ephemeral keys are not visible if a client program lists the keys on a module. See also static key.
</p>
</blockquote>

<p>$ event</p>
<blockquote class="text">
<p>Situation occurring on a module or a channel for which a client program may be notified.
</p>
</blockquote>

<p>$ event notification</p>
<blockquote class="text">
<p>Call from the host runtime system to a client program announcing that a specific situation has occurred. See callback and asynchronous notification.
</p>
</blockquote>

<p>$ grade</p>
<blockquote class="text">
<p>Negotiated classification level of a channel.
</p>
</blockquote>

<p>$ hardware access token</p>
<blockquote class="text">
<p>Removable device used to provide locking and unlocking features for the cryptographic capabilities of a cryptographic module.
</p>
</blockquote>

<p>$ host</p>
<blockquote class="text">
<p>Computer system upon which a client program linked to a CICM library executes.
</p>
</blockquote>

<p>$ hybrid channel</p>
<blockquote class="text">
<p>Channel that simultaneously supports two fundamental cryptographic services; for example, an encryption with signature channel transforms data, resulting in both ciphertext and a final signature value.
</p>
</blockquote>

<p>$ iterator</p>
<blockquote class="text">
<p>Software construct that enables a software program to walk through a list of related items.
</p>
</blockquote>

<p>$ key</p>
<blockquote class="text">
<p>See symmetric key and asymmetric key.
</p>
</blockquote>

<p>$ key agreement protocol</p>
<blockquote class="text">
<p>Protocol that allows two or more participants to negotiate an ephemeral symmetric key without disclosing the resulting key material to non-participants. The protocol is conducted in such a way that all participants influence the outcome.
</p>
</blockquote>

<p>$ key encryption key</p>
<blockquote class="text">
<p>Key that encrypts or decrypts another key for transmission or storage.
</p>
</blockquote>

<p>$ key fill device</p>
<blockquote class="text">
<p>Devices that read-in, transfer, and store key material.
</p>
</blockquote>

<p>$ key fill interface</p>
<blockquote class="text">
<p>Set of protocols, electrical connections, and physical characteristics that comprise the connecting link between a key fill device and a cryptographic module. CICM enables a key fill interface to be configured and actions to be initiated on a key fill device via the key fill interface.
</p>
</blockquote>

<p>$ key infrastructure</p>
<blockquote class="text">
<p>Set of hardware, software, people, policies, and procedures needed to create, manage, store, distribute, and revoke key material.
</p>
</blockquote>

<p>$ key rollover</p>
<blockquote class="text">
<p>Process of moving from one key to another in a pre-defined sequence of keys; may also be referred to as "key supersession."
</p>
</blockquote>

<p>$ key tag</p>
<blockquote class="text">
<p>Identification information associated with certain types of electronic key (<a class='info' href='#CNSSI-4009'>[CNSSI&#8209;4009]<span> (</span><span class='info'>Committee on National Security Systems (U.S. Government), &ldquo;National Information Assurance (IA) Glossary,&rdquo; revised June&nbsp;2006.</span><span>)</span></a>).
</p>
</blockquote>

<p>$ key unwrap</p>
<blockquote class="text">
<p>Process whereby an encrypted cryptographic key is decrypted using a cryptographic module and a different key.
</p>
</blockquote>

<p>$ key update</p>
<blockquote class="text">
<p>Deterministic one-way transformation of a symmetric key (and its current update count) to a new key.
</p>
</blockquote>

<p>$ key wrap</p>
<blockquote class="text">
<p>Process whereby a cryptographic key is encrypted by a cryptographic module using a separate key in a manner sufficient to protect the key at the level of its classification.
</p>
</blockquote>

<p>$ keystream</p>
<blockquote class="text">
<p>Sequence of symbols produced by a cryptographic module using a cryptographic key to combine with plain text to produce cipher text, control transmission security processes, or produce key (<a class='info' href='#CNSSI-4009'>[CNSSI&#8209;4009]<span> (</span><span class='info'>Committee on National Security Systems (U.S. Government), &ldquo;National Information Assurance (IA) Glossary,&rdquo; revised June&nbsp;2006.</span><span>)</span></a>).
</p>
</blockquote>

<p>$ listener</p>
<blockquote class="text">
<p>Method registered by the client program that will be called upon the occurrence of a specific module event.
</p>
</blockquote>

<p>$ local port</p>
<blockquote class="text">
<p>Port on module in same security domain in which client program is located to which commands are presented and through which data is sent/received. See also remote port.
</p>
</blockquote>

<p>$ manager</p>
<blockquote class="text">
<p>Specialized attributes that encapsulate different classes of module, key and channel management functionality.
</p>
</blockquote>

<p>$ message authentication code (MAC)</p>
<blockquote class="text">
<p>Data associated with an authenticated message allowing a receiver to verify the integrity of the message (<a class='info' href='#CNSSI-4009'>[CNSSI&#8209;4009]<span> (</span><span class='info'>Committee on National Security Systems (U.S. Government), &ldquo;National Information Assurance (IA) Glossary,&rdquo; revised June&nbsp;2006.</span><span>)</span></a>).
</p>
</blockquote>

<p>$ method</p>
<blockquote class="text">
<p>Single CICM library function that performs a specific task.
</p>
</blockquote>

<p>$ namespace</p>
<blockquote class="text">
<p>An abstract container that holds related interfaces.
</p>
</blockquote>

<p>$ non-blocking</p>
<blockquote class="text">
<p>A method is non-blocking if it initiates an operation and then returns control to the caller, usually before the outcome of the operation has been determined. See also blocking.
</p>
</blockquote>

<p>$ opaque data object</p>
<blockquote class="text">
<p>Binary object accepted by or returned from a method call whose structure is imposed by some entity unrelated to the CICM specification.
</p>
</blockquote>

<p>$ package</p>
<blockquote class="text">
<p>Software, FPGA image, policy database, configuration parameters, or other types of executable or interpretable code that may be imported into and removed from a module.
</p>
</blockquote>

<p>$ persistent key</p>
<blockquote class="text">
<p>See static key.
</p>
</blockquote>

<p>$ policy</p>
<blockquote class="text">
<p>Precise specification of the security rules under which a cryptographic module will operate.
</p>
</blockquote>

<p>$ port</p>
<blockquote class="text">
<p>Identifier that designates a logical interface through which data moves into and out of a cryptographic module. See also local port and remote port.
</p>
</blockquote>

<p>$ remote port</p>
<blockquote class="text">
<p>Port in non-local security domain from which transformed data is received. See also local port.
</p>
</blockquote>

<p>$ role</p>
<blockquote class="text">
<p>A designation to which users are assigned that identifies a job type defined in terms of the privileges of that user.
</p>
</blockquote>

<p>$ security domain</p>
<blockquote class="text">
<p>System or group of systems operating under a common security policy. Communication between domains is controlled in a well-defined manner.
</p>
</blockquote>

<p>$ selective bypass</p>
<blockquote class="text">
<p>Portion of the traffic through a channel that is not to be cryptographically transformed. Also commonly referred to as "header bypass."
</p>
</blockquote>

<p>$ static key</p>
<blockquote class="text">
<p>Cryptographic key imported into or established on a module that will remain on the module until it is explicitly removed. See also ephemeral key.
</p>
</blockquote>

<p>$ stream</p>
<blockquote class="text">
<p>An abstraction representing an entity utilizing an existing controller to enable data to be sent to a module to be transformed and transformed data to be received using a controller as a foundation.
</p>
</blockquote>

<p>$ symmetric key</p>
<blockquote class="text">
<p>Usually a sequence of random or pseudorandom bits used initially to set up and periodically change the operations performed in crypto-equipment for the purpose of encrypting or decrypting electronic signals (<a class='info' href='#CNSSI-4009'>[CNSSI&#8209;4009]<span> (</span><span class='info'>Committee on National Security Systems (U.S. Government), &ldquo;National Information Assurance (IA) Glossary,&rdquo; revised June&nbsp;2006.</span><span>)</span></a>). See asymmetric key.
</p>
</blockquote>

<p>$ system</p>
<blockquote class="text">
<p>Hardware and software components, including the cryptographic module, that meet a specific set of security-related requirements.
</p>
</blockquote>

<p>$ tamper</p>
<blockquote class="text">
<p>Output signal from module that denotes it has detected a tamper event.
</p>
</blockquote>

<p>$ token</p>
<blockquote class="text">
<p>See hardware access token.
</p>
</blockquote>

<p>$ trusted display</p>
<blockquote class="text">
<p>Hardware component independent of a host to enter or display information to be directly sent to/received from a cryptographic module.
</p>
</blockquote>

<p>$ zeroize</p>
<blockquote class="text">
<p>Input signal instructing the module to clear its memory of any sensitive cryptographic material. CICM supports both a module zeroize (destroying all key material on module) and zeroizing an individual key. 
</p>
</blockquote>

<a name="rfc.authors"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>Authors' Addresses</h3>
<table width="99%" border="0" cellpadding="0" cellspacing="0">
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Daniel J. Lanz</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">The MITRE Corporation</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:dlanz@mitre.org">dlanz@mitre.org</a></td></tr>
<tr cellpadding="3"><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Lev Novikov</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">The MITRE Corporation</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:lnovikov@mitre.org">lnovikov@mitre.org</a></td></tr>
</table>
</body></html>
