<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="en"><head><title>IP Fast Reroute Using Not-via Addresses</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="description" content="IP Fast Reroute Using Not-via Addresses">
<meta name="generator" content="xml2rfc v1.35 (http://xml.resource.org/)">
<meta name="viewport" content="width=600;" />
<style type='text/css'><!--
        body {
                font-family: verdana, charcoal, helvetica, arial, sans-serif;
                font-size: 85%;
		max-width: 40em; 
		color: #000; background-color: #FFF;
                margin: 2em;
        }
        h1, h2, h3, h4, h5, h6 {
                font-family: helvetica, monaco, "MS Sans Serif", arial, sans-serif;
                font-weight: bold; font-style: normal;
        }
        h1 { color: #900; background-color: transparent; text-align: right; }
        h3 { color: #333; background-color: transparent; }

        td.RFCbug {
                font-size: x-small; text-decoration: none;
                width: 30px; height: 30px; padding-top: 2px;
                text-align: justify; vertical-align: middle;
                background-color: #000;
        }
        td.RFCbug span.RFC {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: bold; color: #666;
        }
        td.RFCbug span.hotText {
                font-family: charcoal, monaco, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: normal; text-align: center; color: #FFF;
        }

        table.TOCbug { width: 30px; height: 15px; }
        td.TOCbug {
                text-align: center; width: 30px; height: 15px;
                color: #FFF; background-color: #900;
        }
        td.TOCbug a {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, sans-serif;
                font-weight: bold; font-size: x-small; text-decoration: none;
                color: #FFF; background-color: transparent;
        }

        td.header {
                font-family: arial, helvetica, sans-serif; font-size: x-small;
                vertical-align: top; width: 33%;
                color: #FFF; background-color: #666;
        }
        td.author { font-weight: bold; font-size: x-small; margin-left: 4em; }
        td.author-text { font-size: x-small; }

        /* info code from SantaKlauss at http://www.madaboutstyle.com/tooltip2.html */
        a.info {
                /* This is the key. */
                position: relative;
                z-index: 24;
                text-decoration: none;
        }
        a.info:hover {
                z-index: 25;
                color: #FFF; background-color: #900;
        }
        a.info span { display: none; }
        a.info:hover span.info {
                /* The span will display just on :hover state. */
                display: block;
                position: absolute;
                font-size: smaller;
                top: 2em; left: -5em; width: 15em;
                padding: 2px; border: 1px solid #333;
                color: #900; background-color: #EEE;
                text-align: left;
        }

        a { font-weight: bold; }
        a:link    { color: #900; background-color: transparent; }
        a:visited { color: #633; background-color: transparent; }
        a:active  { color: #633; background-color: transparent; }

        p { margin-left: 2em; margin-right: 2em; }
        p.copyright { font-size: x-small; }
        p.toc { font-size: 85%;
		max-width: 40em; 
		font-weight: bold; margin-left: 3em; }
        table.toc { margin: 0 0 0 3em; padding: 0; border: 0; vertical-align: text-top; }
        td.toc { font-size: 85%;
		max-width: 40em; 
		font-weight: bold; vertical-align: text-top; }

        ol.text { margin-left: 2em; margin-right: 2em; }
        ul.text { margin-left: 2em; margin-right: 2em; }
        li      { margin-left: 3em; }

        /* RFC-2629 <spanx>s and <artwork>s. */
        em     { font-style: italic; }
        strong { font-weight: bold; }
        dfn    { font-weight: bold; font-style: normal; }
        cite   { font-weight: normal; font-style: normal; }
        tt     { color: #036; }
        tt, pre, pre dfn, pre em, pre cite, pre span {
                font-family: "Courier New", Courier, monospace; font-size: small;
        }
        pre {
                text-align: left; padding: 4px;
                color: #000; background-color: #CCC;
        }
        pre dfn  { color: #900; }
        pre em   { color: #66F; background-color: #FFC; font-weight: normal; }
        pre .key { color: #33C; font-weight: bold; }
        pre .id  { color: #900; }
        pre .str { color: #000; background-color: #CFF; }
        pre .val { color: #066; }
        pre .rep { color: #909; }
        pre .oth { color: #000; background-color: #FCF; }
        pre .err { background-color: #FCC; }

        /* RFC-2629 <texttable>s. */
        table.all, table.full, table.headers, table.none {
                font-size: 85%;
		max-width: 40em; 
		text-align: center; border-width: 2px;
                vertical-align: top; border-collapse: collapse;
        }
        table.all, table.full { border-style: solid; border-color: black; }
        table.headers, table.none { border-style: none; }
        th {
                font-weight: bold; border-color: black;
                border-width: 2px 2px 3px 2px;
        }
        table.all th, table.full th { border-style: solid; }
        table.headers th { border-style: none none solid none; }
        table.none th { border-style: none; }
        table.all td {
                border-style: solid; border-color: #333;
                border-width: 1px 2px;
        }
        table.full td, table.headers td, table.none td { border-style: none; }

        hr { height: 1px; }
        hr.insert {
                width: 80%; border-style: none; border-width: 0;
                color: #CCC; background-color: #CCC;
        }
--></style>
</head>
<body>
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<table summary="layout" width="66%" border="0" cellpadding="0" cellspacing="0"><tr><td><table summary="layout" width="100%" border="0" cellpadding="2" cellspacing="1">
<tr><td class="header">Network Working Group</td><td class="header">M. Shand</td></tr>
<tr><td class="header">Internet-Draft</td><td class="header">S. Bryant</td></tr>
<tr><td class="header">Intended status: Experimental</td><td class="header">S. Previdi</td></tr>
<tr><td class="header">Expires: January 11, 2010</td><td class="header">Cisco Systems</td></tr>
<tr><td class="header">&nbsp;</td><td class="header">July 10, 2009</td></tr>
</table></td></tr></table>
<h1><br />IP Fast Reroute Using Not-via Addresses<br />draft-ietf-rtgwg-ipfrr-notvia-addresses-04</h1>

<h3>Status of this Memo</h3>
<p>
This Internet-Draft is submitted to IETF in full
conformance with the provisions of BCP&nbsp;78 and BCP&nbsp;79.</p>
<p>
Internet-Drafts are working documents of the Internet Engineering
Task Force (IETF), its areas, and its working groups.
Note that other groups may also distribute working documents as
Internet-Drafts.</p>
<p>
Internet-Drafts are draft documents valid for a maximum of six months
and may be updated, replaced, or obsoleted by other documents at any time.
It is inappropriate to use Internet-Drafts as reference material or to cite
them other than as &ldquo;work in progress.&rdquo;</p>
<p>
The list of current Internet-Drafts can be accessed at
<a href='http://www.ietf.org/ietf/1id-abstracts.txt'>http://www.ietf.org/ietf/1id-abstracts.txt</a>.</p>
<p>
The list of Internet-Draft Shadow Directories can be accessed at
<a href='http://www.ietf.org/shadow.html'>http://www.ietf.org/shadow.html</a>.</p>
<p>
This Internet-Draft will expire on January 11, 2010.</p>

<h3>Copyright Notice</h3>
<p>
Copyright (c) 2009 IETF Trust and the persons identified as the
document authors.  All rights reserved.</p>
<p>
This document is subject to BCP 78 and the IETF Trust's Legal
Provisions Relating to IETF Documents in effect on the date of
publication of this document (http://trustee.ietf.org/license-info).
Please review these documents carefully, as they describe your
rights and restrictions with respect to this document.</p>

<h3>Abstract</h3>

<p>This draft describes a mechanism that provides fast reroute in an IP
      network through encapsulation to "not-via" addresses. A single level of
      encapsulation is used. The mechanism protects unicast, multicast and LDP
      traffic against link, router and shared risk group failure, regardless
      of network topology and metrics.
</p>
<h3>Requirements Language</h3>

<p>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
      "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
      document are to be interpreted as described in <a class='info' href='#RFC2119'>RFC2119<span> (</span><span class='info'>Bradner, S., &ldquo;Key words for use in RFCs to Indicate Requirement Levels,&rdquo; March&nbsp;1997.</span><span>)</span></a> [RFC2119].
</p><a name="toc"></a><br /><hr />
<h3>Table of Contents</h3>
<p class="toc">
<a href="#anchor1">1.</a>&nbsp;
Introduction<br />
<a href="#anchor2">2.</a>&nbsp;
Overview of Not-via Repairs<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor3">2.1.</a>&nbsp;
Use of Equal Cost Multi-Path<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor4">2.2.</a>&nbsp;
Use of LFA repairs<br />
<a href="#anchor5">3.</a>&nbsp;
Not-via Repair Path Computation <br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor6">3.1.</a>&nbsp;
Computing not-via repairs in routing vector protocols<br />
<a href="#anchor7">4.</a>&nbsp;
Operation of Repairs<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor8">4.1.</a>&nbsp;
Node Failure<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor9">4.2.</a>&nbsp;
Link Failure<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#LPUNFsec">4.2.1.</a>&nbsp;
Loop Prevention Under Node Failure<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor10">4.3.</a>&nbsp;
Multi-homed Prefixes<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor11">4.4.</a>&nbsp;
Installation of Repair Paths <br />
<a href="#anchor12">5.</a>&nbsp;
Compound Failures<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor13">5.1.</a>&nbsp;
Shared Risk Link Groups<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor14">5.1.1.</a>&nbsp;
Use of LFAs with SRLGs <br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor15">5.2.</a>&nbsp;
Local Area Networks<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor16">5.2.1.</a>&nbsp;
Simple LAN Repair<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor17">5.2.2.</a>&nbsp;
LAN Component Repair<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor18">5.2.3.</a>&nbsp;
LAN Repair Using Diagnostics <br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#MIFsec">5.3.</a>&nbsp;
Multiple Independent Failures <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor19">5.3.1.</a>&nbsp;
Looping Repairs<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor20">5.3.2.</a>&nbsp;
Outline Solution<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor21">5.3.3.</a>&nbsp;
Looping Repairs<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor22">5.3.3.1.</a>&nbsp;
Dropping Looping Packets<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor23">5.3.3.2.</a>&nbsp;
Computing non-looping Repairs of Repairs<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor24">5.3.3.3.</a>&nbsp;
N-level Mutual Loops<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor25">5.3.4.</a>&nbsp;
Mixing LFAs and Not-via<br />
<a href="#anchor26">6.</a>&nbsp;
Optimizing not-via computations using LFAs<br />
<a href="#anchor27">7.</a>&nbsp;
Multicast<br />
<a href="#anchor28">8.</a>&nbsp;
Fast Reroute in an MPLS LDP Network.  <br />
<a href="#anchor29">9.</a>&nbsp;
Encapsulation<br />
<a href="#anchor30">10.</a>&nbsp;
Routing Extensions<br />
<a href="#anchor31">11.</a>&nbsp;
Incremental Deployment<br />
<a href="#anchor32">12.</a>&nbsp;
IANA Considerations<br />
<a href="#anchor33">13.</a>&nbsp;
Security Considerations<br />
<a href="#anchor34">14.</a>&nbsp;
Acknowledgements<br />
<a href="#rfc.references1">15.</a>&nbsp;
References<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#rfc.references1">15.1.</a>&nbsp;
Normative References<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#rfc.references2">15.2.</a>&nbsp;
Informative References<br />
<a href="#rfc.authors">&#167;</a>&nbsp;
Authors' Addresses<br />
</p>
<br clear="all" />

<a name="anchor1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1"></a><h3>1.&nbsp;
Introduction</h3>

<p>
</p>
<p>When a link or a router fails, only the neighbors of the failure are
      initially aware that the failure has occurred. In a network operating IP
      fast reroute <a class='info' href='#I-D.ietf-rtgwg-ipfrr-framework'>[I&#8209;D.ietf&#8209;rtgwg&#8209;ipfrr&#8209;framework]<span> (</span><span class='info'>Shand, M. and S. Bryant, &ldquo;IP Fast Reroute Framework,&rdquo; October&nbsp;2009.</span><span>)</span></a>, the
      routers that are the neighbors of the failure repair the failure. These
      repairing routers have to steer packets to their destinations despite
      the fact that most other routers in the network are unaware of the
      nature and location of the failure.
</p>
<p>A common limitation in most IPFRR mechanisms is an inability to
      indicate the identity of the failure and to explicitly steer the
      repaired packet round the failure. The extent to which this limitation
      affects the repair coverage is topology dependent. The mechanism
      proposed here is to encapsulate the packet to an address that explicitly
      identifies the network component that the repair must avoid. This
      produces a repair mechanism, which, provided the network is not
      partitioned by the failure, will always achieve a repair.
</p>
<a name="anchor2"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2"></a><h3>2.&nbsp;
Overview of Not-via Repairs</h3>

<p>
</p>
<p>When a link or a router fails, only the neighbors of the failure are
      initially aware that the failure has occurred. In a network operating IP
      fast reroute <a class='info' href='#I-D.ietf-rtgwg-ipfrr-framework'>[I&#8209;D.ietf&#8209;rtgwg&#8209;ipfrr&#8209;framework]<span> (</span><span class='info'>Shand, M. and S. Bryant, &ldquo;IP Fast Reroute Framework,&rdquo; October&nbsp;2009.</span><span>)</span></a>, the
      routers that are the neighbors of the failure repair the failure. These
      repairing routers have to steer packets to their destinations despite
      the fact that most other routers in the network are unaware of the
      nature and location of the failure.
</p>
<p>A common limitation in most IPFRR mechanisms is an inability to
      indicate the identity of the failure and to explicitly steer the
      repaired packet round the failure. The extent to which this limitation
      affects the repair coverage is topology dependent. The mechanism
      proposed here is to encapsulate the packet to an address that explicitly
      identifies the network component that the repair must avoid. This
      produces a repair mechanism, which, provided the network is not
      partitioned by the failure, will always achieve a repair.
</p>
<p>
</p><br /><hr class="insert" />
<a name="fig-repair"></a>

<p>
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>              A
              |                Bp is the address to use to get
              |                  a packet to B not-via P
              |
   S----------P----------B. . . . . . . . . .D
    \         |        Bp^
     \        |          |
      \       |          |
       \      C          |
        \                |
         ----------------+
           Repair to Bp
</pre></div>
<p>
</p><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;1: Not-via repair of router failure&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>
</p>
<p>
</p>
<p>Assume that S has a packet for some destination D that it would
      normally send via P and B, and that S suspects that P has failed. S
      encapsulates the packet to Bp. The path from S to Bp is the shortest
      path from S to B not going via P. If the network contains a path from S
      to B that does not transit router P, i.e. the network is not partitioned
      by the failure of P, then the packet will be successfully delivered to
      B. When the packet addressed to Bp arrives at B, B removes the
      encapsulation and forwards the repaired packet towards its final
      destination.
</p>
<p>Note that if the path from B to the final destination includes one or
      more nodes that are included in the repair path, a packet may back track
      after the encapsulation is removed. However, because the decapsulating
      router is always closer to the packet destination than the encapsulating
      router, the packet will not loop.
</p>
<p>For complete protection, all of P's neighbors will require a not-via
      address that allows traffic to be directed to them without traversing P.
      This is shown in <a class='info' href='#fig-notvia-P'>Figure&nbsp;2<span> (</span><span class='info'>The set of Not-via P Addresses  </span><span>)</span></a>.
</p><br /><hr class="insert" />
<a name="fig-notvia-P"></a>

<p>
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>              A
              |Ap
              |
    Sp      Pa|Pb
   S----------P----------B
            Ps|Pc      Bp
              |
            Cp|
              C
</pre></div>
<p>
</p><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;2: The set of Not-via P Addresses  &nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>
</p>
<a name="anchor3"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2.1"></a><h3>2.1.&nbsp;
Use of Equal Cost Multi-Path</h3>

<p>
</p>
<p>A router can use an equal cost multi-path (ECMP) repair in place of
        a not-via repair.
</p>
<p>A router computing a not-via repair path MAY subject the repair to
        ECMP.
</p>
<a name="anchor4"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2.2"></a><h3>2.2.&nbsp;
Use of LFA repairs</h3>

<p>
</p>
<p>The not-via approach provides complete repair coverage and
        therefore may be used as the sole repair mechanism. There are,
        however, advantages in using not-via in combination with loop free
        alternates (LFA) and or downstream paths as documented in <a class='info' href='#RFC5286'>[RFC5286]<span> (</span><span class='info'>Atlas, A. and A. Zinin, &ldquo;Basic Specification for IP Fast Reroute: Loop-Free Alternates,&rdquo; September&nbsp;2008.</span><span>)</span></a>.
</p>
<p>LFAs are computed on a per destination basis and in general, only a
        subset of the destinations requiring repair will have a suitable LFA
        repair. In this case, those destinations which are repairable by LFAs
        are so repaired and the remainder of the destinations are repaired
        using the not-via encapsulation. This has the advantage of reducing
        the volume of traffic that requires encapsulation. On the other hand,
        the path taken by an LFA repair may be less optimal than that of the
        equivalent not-via repair for traffic destined to nodes close to the
        far end of the failure, but may be more optimal for some other
        traffic. The description in this document assumes that LFAs will be
        used where available, but the distribution of repairs between the two
        mechanisms is a local implementation choice.
</p>
<a name="anchor5"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3"></a><h3>3.&nbsp;
Not-via Repair Path Computation </h3>

<p>
</p>
<p>The not-via repair mechanism requires that all routers on the path
      from S to B (<a class='info' href='#fig-repair'>Figure&nbsp;1<span> (</span><span class='info'>Not-via repair of router failure</span><span>)</span></a>) have a route to Bp. They
      can calculate this by failing node P, running an SPF, and finding the
      shortest route to B.
</p>
<p>A router has no simple way of knowing whether it is on the shortest
      path for any particular repair. It is therefore necessary for every
      router to calculate the path it would use in the event of any possible
      router failure. Each router therefore "fails" every router in the
      network, one at a time, and calculates its own best route to each of the
      neighbors of that router. In other words, with reference to <a class='info' href='#fig-repair'>Figure&nbsp;1<span> (</span><span class='info'>Not-via repair of router failure</span><span>)</span></a>, some router X will consider each router in
      turn to be P, fail P, and then calculate its own route to each of the
      not-via P addresses advertised by the neighbors of P. i.e. X calculates
      its route to Sp, Ap, Bp, and Cp, in each case, not via P.
</p>
<p>To calculate the repair paths a router has to calculate n-1 SPFs
      where n is the number of routers in the network. This is expensive to
      compute. However, the problem is amenable to a solution in which each
      router (X) proceeds as follows. X first calculates the base topology
      with all routers functional and determines its normal path to all
      not-via addresses. This can be performed as part of the normal SPF
      computation. For each router P in the topology, X then performs the
      following actions:-
</p>
<p></p>
<ol class="text">
<li>Removes router P from the topology.
</li>
<li>Performs an incremental SPF <a class='info' href='#ISPF'>[ISPF]<span> (</span><span class='info'>McQuillan, J., Richer, I., and E. Rosen, &ldquo;ARPANET Routing Algorithm Improvements&quot;,&rdquo; 1978.</span><span>)</span></a> on the
          modified topology. The iSPF process involves detaching the sub-tree
          affected by the removal of router P, and then re-attaching the
          detached nodes. However, it is not necessary to run the iSPF to
          completion. It is sufficient to run the iSPF up to the point where
          all of the nodes advertising not-via P addresses have been
          re-attached to the SPT, and then terminate it.
</li>
<li>Reverts to the base topology.
</li>
</ol><p>This algorithm is significantly less expensive than a set of
      full SPFs. Thus, although a router has to calculate the repair paths for
      n-1 failures, the computational effort is much less than n-1 SPFs.
</p>
<p>Experiments on a selection of real world network topologies with
      between 40 and 400 nodes suggest that the worst-case computational
      complexity using the above optimizations is equivalent to performing
      between 5 and 13 full SPFs. Further optimizations are described in
      section 6.
</p>
<a name="anchor6"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.1"></a><h3>3.1.&nbsp;
Computing not-via repairs in routing vector protocols</h3>

<p>
</p>
<p>While this document focuses on link state routing protocols, it is
        equally possible to compute not-via repairs in distance vector (e.g.
        RIP) or path vector (e.g. BGP) routing protocols. This can be achieved
        with very little protocol modification by advertising the not-via
        address in the normal way, but ensuring that the information about a
        not-via address Ps is not propagated through the node S. In the case
        of link protection this simply means that the advertisement from P to
        S is suppressed, with the result that S and all other nodes compute a
        route to Ps which doesn't traverse S, as required.
</p>
<p>In the case of node protection, where P is the protected node, and
        N is some neighbor, the advertisement of Np must be suppressed not
        only across the link N-&gt;P, but also across any link to P. The
        simplest way of achieving this is for P itself to perform the
        suppression of any address of the form Xp.
</p>
<a name="anchor7"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4"></a><h3>4.&nbsp;
Operation of Repairs</h3>

<p>This section explains the basic operation of the not-via repair of
      node and link failure.
</p>
<a name="anchor8"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.1"></a><h3>4.1.&nbsp;
Node Failure</h3>

<p>
</p>
<p>When router P fails (<a class='info' href='#fig-notvia-P'>Figure&nbsp;2<span> (</span><span class='info'>The set of Not-via P Addresses  </span><span>)</span></a>) S
        encapsulates any packet that it would send to B via P to Bp, and then
        sends the encapsulated packet on the shortest path to Bp. S follows
        the same procedure for routers A and C in <a class='info' href='#fig-notvia-P'>Figure&nbsp;2<span> (</span><span class='info'>The set of Not-via P Addresses  </span><span>)</span></a>. The packet is decapsulated at the
        repair target (A, B or C) and then forwarded normally to its
        destination. The repair target can be determined as part of the normal
        SPF by recording the "next-next-hop" for each destination in addition
        to the normal next-hop.
</p>
<p>Notice that with this technique only one level of encapsulation is
        needed, and that it is possible to repair ANY failure regardless of
        link metrics and any asymmetry that may be present in the network. The
        only exception to this is where the failure was a single point of
        failure that partitioned the network, in which case ANY repair is
        clearly impossible.
</p>
<a name="anchor9"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.2"></a><h3>4.2.&nbsp;
Link Failure</h3>

<p>The normal mode of operation of the network would be to assume
        router failure. However, where some destinations are only reachable
        through the failed router, it is desirable that an attempt be made to
        repair to those destinations by assuming that only a link failure has
        occurred.
</p>
<p>To perform a link repair, S encapsulates to Ps (i.e. it instructs
        the network to deliver the packet to P not-via S). All of the
        neighbors of S will have calculated a path to Ps in case S itself had
        failed. S could therefore give the packet to any of its neighbors
        (except, of course, P). However, S should preferably send the
        encapsulated packet on the shortest available path to P. This path is
        calculated by running an SPF with the link SP failed. Note that this
        may again be an incremental calculation, which can terminate when
        address Ps has been reattached.
</p>
<a name="LPUNFsec"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.2.1"></a><h3>4.2.1.&nbsp;
Loop Prevention Under Node Failure</h3>

<p>It is necessary to consider the behavior of IPFRR solutions when
          a link repair is attempted in the presence of node failure. In its
          simplest form the not-via IPFRR solution prevents the formation of
          loops forming as a result of mutual repair, by never providing a
          repair path for a not-via address. The repair of packets with
          not-via addresses is considered in more detail in <a class='info' href='#MIFsec'>Section&nbsp;5.3<span> (</span><span class='info'>Multiple Independent Failures </span><span>)</span></a>. Referring to <a class='info' href='#fig-notvia-P'>Figure&nbsp;2<span> (</span><span class='info'>The set of Not-via P Addresses  </span><span>)</span></a>, if A was the neighbor of P that was
          on the link repair path from S to P, and P itself had failed, the
          repaired packet from S would arrive at A encapsulated to Ps. A would
          have detected that the AP link had failed and would normally attempt
          to repair the packet. However, no repair path is provided for any
          not-via address, and so A would be forced to drop the packet, thus
          preventing the formation of loop.
</p>
<a name="anchor10"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.3"></a><h3>4.3.&nbsp;
Multi-homed Prefixes</h3>

<p>
</p>
<p>A multi-homed Prefix (MHP) is a prefix that is reachable via more
        than one router in the network. Some of these may be repairable using
        LFAs as described in <a class='info' href='#RFC5286'>[RFC5286]<span> (</span><span class='info'>Atlas, A. and A. Zinin, &ldquo;Basic Specification for IP Fast Reroute: Loop-Free Alternates,&rdquo; September&nbsp;2008.</span><span>)</span></a>. Only those
        without such a repair need be considered here.
</p>
<p>When IPFRR router S (<a class='info' href='#fig-MHP'>Figure&nbsp;3<span> (</span><span class='info'>Multi-homed Prefixes</span><span>)</span></a>) discovers that
        P has failed, it needs to send packets addressed to the MHP X, which
        is normally reachable through P, to an alternate router, which is
        still able to reach X.
</p><br /><hr class="insert" />
<a name="fig-MHP"></a>

<p>
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>   X                          X                          X
   |                          |                          |
   |                          |                          |
   |                Sp        |Pb                        |
   Z...............S----------P----------B...............Y
                            Ps|Pc      Bp
                              |
                            Cp|
                              C</pre></div>
<p>
</p><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;3: Multi-homed Prefixes&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>
</p>
<p>S should choose the closest router that can reach X during the
        failure as the alternate router. S determines which router to use as
        the alternate while running the SPF with P failed. This is
        accomplished by the normal process of re-attaching a leaf node to the
        core topology (this is sometimes known as a "partial SPF").
</p>
<p>First, consider the case where the shortest alternate path to X is
        via Z. S can reach Z without using the failed router P. However, S
        cannot just send the packet towards Z, because the other routers in
        the network will not be aware of the failure of P, and may loop the
        packet back to S. S therefore encapsulates the packet to Z (using a
        normal address for Z). When Z receives the encapsulated packet it
        removes the encapsulation and forwards the packet to X.
</p>
<p>Now consider the case where the shortest alternate path to X is via
        Y, which S reaches via P and B. To reach Y, S must first repair the
        packet to B using the normal not-via repair mechanism. To do this S
        encapsulates the packet for X to Bp. When B receives the packet it
        removes the encapsulation and discovers that the packet is intended
        for MHP X. The situation now reverts to the previous case, in which
        the shortest alternate path does not require traversal of the failure.
        B therefore follows the algorithm above and encapsulates the packet to
        Y (using a normal address for Y). Y removes the encapsulation and
        forwards the packet to X.
</p>
<p>It may be that the cost of reaching X using local delivery from the
        alternate router (i.e. Z or Y) is greater than the cost of reaching X
        via P. Under those circumstances, the alternate router would normally
        forward to X via P, which would cause the IPFRR repair to loop. To
        prevent the repair from looping the alternate router must locally
        deliver a packet received via a repair encapsulation. This may be
        specified by using a special address with the above semantics. Note
        that only one such address is required per node. Notice that using the
        not-via approach, only one level of encapsulation was needed to repair
        MHPs to the alternate router.
</p>
<a name="anchor11"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.4"></a><h3>4.4.&nbsp;
Installation of Repair Paths </h3>

<p>
</p>
<p>The following algorithm is used by node S (<a class='info' href='#fig-MHP'>Figure&nbsp;3<span> (</span><span class='info'>Multi-homed Prefixes</span><span>)</span></a>) to pre- calculate and install repair paths
        in the FIB, ready for immediate use in the event of a failure. It is
        assumed that the not-via repair paths have already been calculated as
        described above.
</p>
<p>For each neighbor P, consider all destinations which are reachable
        via P in the current topology:-
</p>
<p></p>
<ol class="text">
<li>For all destinations with an ECMP or LFA repair (as described
            in <a class='info' href='#RFC5286'>[RFC5286]<span> (</span><span class='info'>Atlas, A. and A. Zinin, &ldquo;Basic Specification for IP Fast Reroute: Loop-Free Alternates,&rdquo; September&nbsp;2008.</span><span>)</span></a>) install that repair.
</li>
<li>For each destination (DR) that remains, identify in the current
            topology the next-next-hop (H) (i.e. the neighbor of P that P will
            use to send the packet to DR). This can be determined during the
            normal SPF run by recording the additional information. If S has a
            path to the not-via address Hp (H not via P), install a not-via
            repair to Hp for the destination DR.
</li>
<li>Identify all remaining destinations (M) which can still be
            reached when node P fails. These will be multi-homed prefixes that
            are not repairable by LFA, for which the normal attachment node is
            P, or a router for which P is a single point of failure, and have
            an alternative attachment point that is reachable after P has
            failed. One way of determining these destinations would be to run
            an SPF rooted at S with node P removed, but an implementation may
            record alternative attachment points during the normal SPF run. In
            either case, the next best point of attachment can also be
            determined for use in step (4) below.
</li>
<li>For each multi-homed prefix (M) identified in step (3):-
<blockquote class="text"><dl>
<dt>A.</dt>
<dd>Identify the new attachment node (as shown in <a class='info' href='#fig-MHP'>Figure&nbsp;3<span> (</span><span class='info'>Multi-homed Prefixes</span><span>)</span></a>). This may be:-
<blockquote class="text"><dl>
<dt>a.</dt>
<dd>Y, where the next hop towards Y is P, or
</dd>
<dt>b.</dt>
<dd>Z, where the next hop towards Z is not P.
</dd>
</dl></blockquote>If the attachment node is Z, install the repair for M
                as a tunnel to Z' (where Z' is the address of Z that is used
                to force local forwarding).
</dd>
<dt>B.</dt>
<dd>For the subset of prefixes (M) that remain (having
                attachment point Y), install the repair path previously
                installed for destination Y.
</dd>
</dl></blockquote>For each destination (DS) that remains, install a not-via
            repair to Ps (P not via S). Note, these are destinations for which
            node P is a single point of failure, and can only be repaired by
            assuming that the apparent failure of node P was simply a failure
            of the S-P link. Note that, if available, a downstream path to P
            may be used for such a repair. This cannot generate a persistent
            loop in the event of the failure of node P, but if one neighbor of
            P uses a not-via repair and another uses a downstream path, it is
            possible for a packet sent on the downstream path to be returned
            to the sending node inside a not-via encapsulation. Since packets
            destined to not-via addresses are not repaired, the packet will be
            dropped after executing a single turn loop.
</li>
</ol>

<a name="anchor12"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5"></a><h3>5.&nbsp;
Compound Failures</h3>

<p>The following types of failures involve more than one component:
</p>
<p></p>
<ol class="text">
<li>Shared Risk Link Groups
</li>
<li>Local Area Networks
</li>
<li>Multiple Independent Failures
</li>
</ol><p>The considerations that apply in each of the above situations
      are described in the following sections.
</p>
<a name="anchor13"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.1"></a><h3>5.1.&nbsp;
Shared Risk Link Groups</h3>

<p>A Shared Risk Link Group (SRLG) is a set of links whose failure can
        be caused by a single action such as a conduit cut or line card
        failure. When repairing the failure of a link that is a member of an
        SRLG, it must be assumed that all the other links that are also
        members of the SRLG have also failed. Consequently, any repair path
        must be computed to avoid not just the adjacent link, but also all the
        links which are members of the same SRLG.
</p>
<p>In <a class='info' href='#fig-SRLG1'>Figure&nbsp;4<span> (</span><span class='info'>Shared Risk Link Group  </span><span>)</span></a> below, the links S-P and A-B
        are both members of SRLG "a". The semantics of the not-via address Ps
        changes from simply "P not-via the link S-P" to be "P not-via the link
        S-P or any other link with which S-P shares an SRLG" In <a class='info' href='#fig-SRLG1'>Figure&nbsp;4<span> (</span><span class='info'>Shared Risk Link Group  </span><span>)</span></a> this is the links that are members of SRLG
        "a". I.e. links S-P and A-B. Since the information about SRLG
        membership of all links is available in the Link State Database, all
        nodes computing routes to the not-via address Ps can infer these
        semantics, and perform the computation by failing all the links in the
        SRLG when running the iSPF.
</p>
<p>Note that it is not necessary for S to consider repairs to any
        other nodes attached to members of the SRLG (such as B). It is
        sufficient for S to repair to the other end of the adjacent link (P in
        this case).
</p><br /><hr class="insert" />
<a name="fig-SRLG1"></a>

<p>
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>                a   Ps
           S----------P---------D
           |          |
           |    a     |
           A----------B
           |          |
           |          |
           C----------E</pre></div>
<p>
</p><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;4: Shared Risk Link Group  &nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>In some cases, it may be that the links comprising the SRLG occur
        in series on the path from S to the destination D, as shown in <a class='info' href='#fig-SRLG2'>Figure&nbsp;5<span> (</span><span class='info'>Shared Risk Link Group members in series</span><span>)</span></a>. In this case, multiple consecutive repairs
        may be necessary. S will first repair to Ps, then P will repair to Dp.
        In both cases, because the links concerned are members of SRLG "a" the
        paths are computed to avoid all members of SRLG "a".
</p><br /><hr class="insert" />
<a name="fig-SRLG2"></a>

<p>
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>                a   Ps    a   Dp
           S----------P---------D
           |          |         |
           |    a     |         |
           A----------B         |
           |          |         |
           |          |         |
           C----------E---------F</pre></div>
<p>
</p><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;5: Shared Risk Link Group members in series&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>
</p>
<p>While the use of multiple repairs in series introduces some
        additional overhead, these semantics avoid the potential combinatorial
        explosion of not-via addresses that could otherwise occur.
</p>
<p>Note that although multiple repairs are used, only a single level
        of encapsulation is required. This is because the first repair packet
        is decapsulated before the packet is re-encapsulated using the not-
        via address corresponding to the far side of the next link which is a
        member of the same SRLG. In some cases the de-capsulation and re-
        encapsulation takes place (at least notionally) at a single node,
        while in other cases, these functions may be performed by different
        nodes. This scenario is illustrated in <a class='info' href='#fig-SRLG3'>Figure&nbsp;6<span> (</span><span class='info'>Shared Risk Link Group members in series </span><span>)</span></a> below.
</p><br /><hr class="insert" />
<a name="fig-SRLG3"></a>

<p>
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>                a   Ps              a  Dg
           S----------P---------G--------D
           |          |         |        |
           |    a     |         |        |
           A----------B         |        |
           |          |         |        |
           |          |         |        |
           C----------E---------F--------H
</pre></div>
<p>
</p><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;6: Shared Risk Link Group members in series &nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>
</p>
<p>In this case, S first encapsulates to Ps, and node P decapsulates
        the packet and forwards it "native" to G using its normal FIB entry
        for destination D. G then repairs the packet to Dg.
</p>
<p>It can be shown that such multiple repairs can never form a loop
        because each repair causes the packet to move closer to its
        destination.
</p>
<p>It is often the case that a single link may be a member of multiple
        SRLGs, and those SRLGs may not be isomorphic. This is illustrated in
        <a class='info' href='#fig-SRLG4'>Figure&nbsp;7<span> (</span><span class='info'>Multiple Shared Risk Link Groups </span><span>)</span></a> below.
</p><br /><hr class="insert" />
<a name="fig-SRLG4"></a>

<p>
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>                ab  Ps              a  Dg
           S----------P---------G--------D
           |          |         |        |
           |    a     |         |        |
           A----------B         |        |
           |          |         |        |
           |    b     |         |   b    |
           C----------E---------F--------H
           |          |
           |          |
           J----------K</pre></div>
<p>
</p><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;7: Multiple Shared Risk Link Groups &nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>The link SP is a member of SRLGs "a" and "b". When a failure of the
        link SP is detected, it must be assumed that BOTH SRLGs have failed.
        Therefore the not-via path to Ps must be computed by failing all links
        which are members of SRLG "a" or SRLG "b". I.e. the semantics of Ps is
        now "P not-via any links which are members of any of the SRLGs of
        which link SP is a member". This is illustrated in <a class='info' href='#fig-SRLG5'>Figure&nbsp;8<span> (</span><span class='info'>Topology used for repair computation for link S-P</span><span>)</span></a> below.
</p><br /><hr class="insert" />
<a name="fig-SRLG5"></a>

<p>
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>                ab  Ps              a  Dg
           S----/-----P---------G---/----D
           |          |         |        |
           |    a     |         |        |
           A----/-----B         |        |
           |          |         |        |
           |    b     |         |   b    |
           C----/-----E---------F---/----H
           |          |
           |          |
           J----------K</pre></div>
<p>
</p><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;8: Topology used for repair computation for link S-P&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>In this case, the repair path to Ps will be S-A-C-J-K-E-B-P. It may
        appear that there is no path to D because GD is a member of SRLG "a"
        and FH is a member of SRLG "b". This is true if BOTH SRLGs "a" and "b"
        have in fact failed. But that would be an instance of multiple
        uncorrelated failures which are out of scope for this design. In
        practice it is likely that there is only a single failure, i.e. either
        SRLG "a" or SRLG "b" has failed, but not both. These two possibilities
        are indistinguishable from the point of view of the repairing router S
        and so it must repair on the assumption that both are unavailable.
        However, each link repair is considered independently. The repair to
        Ps delivers the packet to P which then forwards the packet to G. When
        the packet arrives at G, if SRLG "a" has failed it will be repaired
        around the path G-F-H-D. This is illustrated in <a class='info' href='#fig-SRLG6'>Figure&nbsp;9<span> (</span><span class='info'>Topology used for repair computation for link G-D  </span><span>)</span></a> below. If, on the other hand, SRLG "b" has
        failed, link GD will still be available. In this case the packet will
        be delivered as normal across the link GD.
</p><br /><hr class="insert" />
<a name="fig-SRLG6"></a>

<p>
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>                ab  Ps              a  Dg
           S----/-----P---------G---/----D
           |          |         |        |
           |    a     |         |        |
           A----/-----B         |        |
           |          |         |        |
           |    b     |         |   b    |
           C----------E---------F--------H
           |          |
           |          |
           J----------K</pre></div>
<p>
</p><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;9: Topology used for repair computation for link G-D  &nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>
</p>
<p>A repair strategy that assumes the worst-case failure for each link
        can often result in longer repair paths than necessary. In cases where
        only a single link fails, rather than the full SRLG, this strategy may
        occasionally fail to identify a repair even though a viable repair
        path exists in the network. The use of sub-optimal repair paths is an
        inevitable consequence of this compromise approach. The failure to
        identify any repair is a serious deficiency, but is a rare occurrence
        in a robustly designed network. This problem can be addressed
        by:-</p>
<ol class="text">
<li>Reporting that the link in question is irreparable, so that the
            network designer can take appropriate action.
</li>
<li>Modifying the design of the network to avoid this
            possibility.
</li>
<li>Using some form of SRLG diagnostic (for example, by running BFD
            over alternate repair paths) to determine which SRLG member(s) has
            actually failed and using this information to select an
            appropriate pre-computed repair path. However, aside from the
            complexity of performing the diagnostics, this requires multiple
            not-via addresses per interface, which has poor scaling
            properties.
</li>
<li>Using the machanism described in <a class='info' href='#MIFsec'>Section&nbsp;5.3<span> (</span><span class='info'>Multiple Independent Failures </span><span>)</span></a>
</li>
</ol>

<a name="anchor14"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.1.1"></a><h3>5.1.1.&nbsp;
Use of LFAs with SRLGs </h3>

<p>Section 4.1 above describes the repair of links which are members
          of one or more SRLGs. LFAs can be used for the repair of such links
          provided that any other link with which S-P shares an SRLG is
          avoided when computing the LFA. This is described for the simple
          case of "local-SRLGs" in <a class='info' href='#RFC5286'>[RFC5286]<span> (</span><span class='info'>Atlas, A. and A. Zinin, &ldquo;Basic Specification for IP Fast Reroute: Loop-Free Alternates,&rdquo; September&nbsp;2008.</span><span>)</span></a>.
</p>
<p>
</p>
<a name="anchor15"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.2"></a><h3>5.2.&nbsp;
Local Area Networks</h3>

<p>LANs are a special type of SRLG and are solved using the SRLG
        mechanisms outlined above. With all SRLGs there is a trade-off between
        the sophistication of the fault detection and the size of the SRLG.
        Protecting against link failure of the LAN link(s) is relatively
        straightforward, but as with all fast reroute mechanisms, the problem
        becomes more complex when it is desired to protect against the
        possibility of failure of the nodes attached to the LAN as well as the
        LAN itself.
</p><br /><hr class="insert" />
<a name="fig-LAN1"></a>

<p>
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>                        +--------------Q------C
                        |
                        |
                        |
      A--------S-------(N)-------------P------B
                        |
                        |
                        |
                        +--------------R------D</pre></div>
<p>
</p><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;10: Local Area Networks &nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>
</p>
<p>Consider the LAN shown in <a class='info' href='#fig-LAN1'>Figure&nbsp;10<span> (</span><span class='info'>Local Area Networks </span><span>)</span></a>. For
        connectivity purposes, we consider that the LAN is represented by the
        pseudonode (N). To provide IPFRR protection, S must run a connectivity
        check to each of its protected LAN adjacencies P, Q, and R, using, for
        example BFD <a class='info' href='#I-D.ietf-bfd-base'>[I&#8209;D.ietf&#8209;bfd&#8209;base]<span> (</span><span class='info'>Katz, D. and D. Ward, &ldquo;Bidirectional Forwarding Detection,&rdquo; January&nbsp;2010.</span><span>)</span></a>.
</p>
<p>When S discovers that it has lost connectivity to P, it is unsure
        whether the failure is:
</p>
<p></p>
<ul class="text">
<li>its own interface to the LAN,
</li>
<li>the LAN itself,
</li>
<li>the LAN interface of P,
</li>
<li>the node P.
</li>
</ul>

<a name="anchor16"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.2.1"></a><h3>5.2.1.&nbsp;
Simple LAN Repair</h3>

<p>A simple approach to LAN repair is to consider the LAN and all of
          its connected routers as a single SRLG. Thus, the address P not via
          the LAN (Pl) would require P to be reached not-via any router
          connected to the LAN. This is shown in <a class='info' href='#fig-LAN2'>Figure&nbsp;11<span> (</span><span class='info'>Local Area Networks - LAN SRLG</span><span>)</span></a>.
</p><br /><hr class="insert" />
<a name="fig-LAN2"></a>

<p>
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>                                    Ql       Cl
                        +-------------Q--------C
                        |              Qc
                        |
       As       Sl      |           Pl       Bl
      A--------S-------(N)------------P--------B
             Sa         |              Pb
                        |
                        |           Rl       Dl
                        +-------------R--------D
                                       Rd
</pre></div>
<p>
</p><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;11: Local Area Networks - LAN SRLG&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>
</p>
<p>In this case, when S detected that P had failed it would send
          traffic reached via P and B to B not-via the LAN or any router
          attached to the LAN (i.e. to Bl). Any destination only reachable
          through P would be addressed to P not-via the LAN or any router
          attached to the LAN (except of course P).
</p>
<p>Whilst this approach is simple, it assumes that a large portion
          of the network adjacent to the failure has also failed. This will
          result in the use of sub-optimal repair paths and in some cases the
          inability to identify a viable repair.
</p>
<p>
</p>
<a name="anchor17"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.2.2"></a><h3>5.2.2.&nbsp;
LAN Component Repair</h3>

<p>
</p>
<p>In this approach, possible failures are considered at a finer
          granularity, but without the use of diagnostics to identify the
          specific component that has failed. Because S is unable to diagnose
          the failure it must repair traffic sent through P and B, to B not-
          via P,N (i.e. not via P and not via N), on the conservative
          assumption that both the entire LAN and P have failed. Destinations
          for which P is a single point of failure must as usual be sent to P
          using an address that avoids the interface by which P is reached
          from S, i.e. to P not-via N. Similarly for routers Q and R.
</p>
<p>Notice that each router that is connected to a LAN must, as
          usual, advertise one not-via address for each neighbor. In addition,
          each router on the LAN must advertise an extra address not via the
          pseudonode (N).
</p>
<p>Notice also that each neighbor of a router connected to a LAN
          must advertise two not-via addresses, the usual one not via the
          neighbor and an additional one, not via either the neighbor or the
          pseudonode. The required set of LAN address assignments is shown in
          <a class='info' href='#fig-LAN3'>Figure&nbsp;12<span> (</span><span class='info'>Local Area Networks</span><span>)</span></a> below. Each router on the LAN, and
          each of its neighbors, is advertising exactly one address more than
          it would otherwise have advertised if this degree of connectivity
          had been achieved using point-to-point links.
</p><br /><hr class="insert" />
<a name="fig-LAN3"></a>

<p>
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>                                  Qs Qp Qc    Cqn
                        +--------------Q---------C
                        |         Qr Qn        Cq
                        |
       Asn   Sa Sp Sq   |         Ps Pq Pb    Bpn
      A--------S-------(N)-------------P---------B
       As       Sr Sn   |         Pr Pn        Bp
                        |
                        |         Rs Rp Pd    Drn
                        +--------------R---------D
                                  Rq Rn        Dr</pre></div>
<p>
</p><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;12: Local Area Networks&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<a name="anchor18"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.2.3"></a><h3>5.2.3.&nbsp;
LAN Repair Using Diagnostics </h3>

<p>A more specific LAN repair can be undertaken by using
          diagnostics. In order to explicitly diagnose the failed network
          component, S correlates the connectivity reports from P and one or
          more of the other routers on the LAN, in this case, Q and R. If it
          lost connectivity to P alone, it could deduce that the LAN was still
          functioning and that the fault lay with either P, or the interface
          connecting P to the LAN. It would then repair to B not via P (and P
          not-via N for destinations for which P is a single point of failure)
          in the usual way. If S lost connectivity to more than one router on
          the LAN, it could conclude that the fault lay only with the LAN, and
          could repair to P, Q and R not-via N, again in the usual way.
</p>
<a name="MIFsec"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.3"></a><h3>5.3.&nbsp;
Multiple Independent Failures </h3>

<p>IPFRR repair of multiple simultaneous failures which
        are not members of a known SRLG is complicated by the problem that the
        use of multiple concurrent repairs may result in looping repair paths.
        As described in <a class='info' href='#LPUNFsec'>Section&nbsp;4.2.1<span> (</span><span class='info'>Loop Prevention Under Node Failure</span><span>)</span></a>, the simplest method
        of preventing such loops, is to ensure that packets addressed to a
        not-via address are not repaired but instead are dropped. It is
        possible that a network may experience multiple simultaneous failures.
        This may be due to simple statistical effects, but the more likely
        cause is unanticipated SRLGs. When multiple failures which are not
        part of an anticipated group are detected, repairs are abandoned and
        the network reverts to normal convergence. Although safe, this
        approach is somewhat draconian, since there are many circumstances
        were multiple repairs do not induce loops.
</p>
<p>This section describes the properties of multiple unrelated
        failures and proposes some methods that may be used to address this
        problem.
</p>
<a name="anchor19"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.3.1"></a><h3>5.3.1.&nbsp;
Looping Repairs</h3>

<p>Let us assume that the repair mechanism is based on solely on
          not-via repairs. LFA or downstream routes may be incorporated, and
          will be dealt with later.
</p><br /><hr class="insert" />
<a name="GenMF"></a>

<p>
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>           A------//------B------------D
          /                \
         /                  \
        F                    G
         \                  /
          \                /
           X------//------Y



</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;13: The General Case of Multiple Failures&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>
</p>
<p>The essential case is as illustrated in <a class='info' href='#GenMF'>Figure&nbsp;13<span> (</span><span class='info'>The General Case of Multiple Failures</span><span>)</span></a>. Note that depending on the repair case under
          consideration, there may be paths present in <a class='info' href='#GenMF'>Figure&nbsp;13<span> (</span><span class='info'>The General Case of Multiple Failures</span><span>)</span></a>, that are in addition to those shown in the
          figure. For example there may be paths between A and B, and/or
          between X and Y. These paths are omitted for graphical clarity.
</p>
<p>There are three cases to consider:
</p>
<p></p>
<blockquote class="text">
<p>1) Consider the general case of a pair of protected links A-B
              and X-Y as shown in the network fragment shown <a class='info' href='#GenMF'>Figure&nbsp;13<span> (</span><span class='info'>The General Case of Multiple Failures</span><span>)</span></a>. If the repair path for A-B does not
              traverse X-Y and the repair path for X-Y does not traverse A-B,
              this case is completely safe and will not cause looping or
              packet loss.
</p>
<p>A more common variation of this case is shown in <a class='info' href='#ConCatMF'>Figure&nbsp;14<span> (</span><span class='info'>Concatenated Repairs</span><span>)</span></a>, which shows two failures in different
              parts of the network in which a packet from A to D traverses two
              concatenated repairs.
</p>
<p>
</p>
<p><br /><hr class="insert" />
<a name="ConCatMF"></a>

<p>
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>    A------//------B------------X------//------Y------D
    |              |            |              |
    |              |            |              |
    M--------------+            N--------------+

</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;14: Concatenated Repairs&nbsp;</b></font><br /></td></tr></table><hr class="insert" />


<p>
</p>
<p>2) In <a class='info' href='#GenMF'>Figure&nbsp;13<span> (</span><span class='info'>The General Case of Multiple Failures</span><span>)</span></a>, the repair for A-B
              traverses X-Y, but the repair for X-Y does not traverse A-B.
              This case occurs when the not-via path from A to B traverses
              link X-Y, but the not-via path from X to Y traverses some path
              not shown in <a class='info' href='#GenMF'>Figure&nbsp;13<span> (</span><span class='info'>The General Case of Multiple Failures</span><span>)</span></a>. Without the
              multi-failure mechanism described in this section the repaired
              packet for A-B would be dropped when it reached X-Y, since the
              repair of repaired packets would be forbidden. However, if this
              packet were allowed to be repaired, the path to D would be
              complete and no harm would be done, although two levels of
              encapsulation would be required.
</p>
<p>3) The repair for A-B traverses X-Y AND the repair for X-Y
              traverses A-B. In this case unrestricted repair would result in
              looping packets and increasing levels of encapsulation.
</p>
</blockquote><p> The challenge in applying IPFRR to a network that is
          undergoing multiple failures is, therefore, to identify which of
          these cases exist in the network and react accordingly.
</p>
<a name="anchor20"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.3.2"></a><h3>5.3.2.&nbsp;
Outline Solution</h3>

<p>When A is computing the not-via repair path for A-B (i.e. the
          path for packets addressed to Ba, read as "B not-via A") it is aware
          of the list of nodes which this path traverses. This can be recorded
          by a simple addition to the SPF process, and the not-via addresses
          associated with each forward link can be determined. If the path
          were A, F, X, Y, G, B, (<a class='info' href='#GenMF'>Figure&nbsp;13<span> (</span><span class='info'>The General Case of Multiple Failures</span><span>)</span></a>) the list of
          not-via addresses would be: Fa, Xf, Yx, Gy, Bg. Under standard
          not-via operation, A would populate its FIB such that all normal
          addresses normally reachable via A-B would be encapsulated to Ba
          when A-B fails, but traffic addressed to any not-via address
          arriving at A would be dropped. The new procedure modifies this such
          that any traffic for a not-via address normally reachable over A-B
          is also encapsulated to Ba unless the not-via address is one of
          those previously identified as being on the path to Ba, for example
          Yx, in which case the packet is dropped.
</p>
<p>The above procedure allows cases 1 and 2 above to be repaired,
          while preventing the loop which would result from case 3.
</p>
<p>Note that this is accomplished by pre-computing the required FIB
          entries, and does not require any detailed packet inspection. The
          same result could be achieved by checking for multiple levels of
          encapsulation and dropping any attempt to triple encapsulate.
          However, this would require more detailed inspection of the packet,
          and causes difficulties when more than 2 &ldquo;simultaneous&rdquo;
          failures are contemplated.
</p>
<p>So far we have permitted benign repairs to coexist, albeit
          sometimes requiring multiple encapsulation. Note that in many cases
          there will be no performance impact since unless both failures are
          on the same node, the two encapsulations or two decapsulations will
          be performed at different nodes. There is however the issue of the
          MTU impact of multiple encapsulations.
</p>
<p>In the following sub-section we consider the various strategies
          that may be applied to case 3 - mutual repairs that would loop.
</p>
<a name="anchor21"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.3.3"></a><h3>5.3.3.&nbsp;
Looping Repairs</h3>

<p>In case 3, the simplest approach is to simply not install repairs
          for repair paths that might loop. In this case, although the
          potentially looping traffic is dropped, the traffic is not repaired.
          If we assume that a hold-down is applied before reconvergence in
          case the link failure was just a short glitch, and if a loop free
          convergence mechanism further delays convergence, then the traffic
          will be dropped for an extended period. In these circumstances it
          would be better to &ldquo;abandon all hope&rdquo; (AAH)
          [&lt;draft-bryant-francois-shand-ipfrr-aah-00.txt&gt;] and
          immediately invoke normal re-convergence.
</p>
<p>Note that it is not sufficient to expedite the issuance of an LSP
          reporting the failure, since this may be treated as a permitted
          simultaneous failure by the oFIB algorithm. It is therefore
          necessary to explicitly trigger an oFIB AAH.
</p>
<a name="anchor22"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.3.3.1"></a><h3>5.3.3.1.&nbsp;
Dropping Looping Packets</h3>

<p>One approach to case 3 is to allow the repair, and to
            experimentally discover the incompatibility of the repairs if and
            when they occur. With this method we permit the repair in case 3
            and trigger AAH when a packet drop count on the not-via address
            has been incremented. Alternatively, it is possible to wait until
            the LSP describing the change is issued normally (i.e. when X
            announces the failure of X-Y). When the repairing node A, which
            has precomputed that X-Y failures are mutually incompatible with
            its own repairs receives this LSP it can then issue the AAH. This
            has the disadvantage that it doesn&rsquo;t overcome the hold-down
            delay, but it requires no &ldquo;data-driven&rdquo; operation, and
            it still has the required effect of abandoning the oFIB which is
            probably the longer of the delays (although with signalled oFIB
            this should be sub-second).
</p>
<p>Whilst both of the experimental approaches described above are
            feasible, they tend to induce AAH in the presence of otherwise
            feasible repairs, and they are contrary to the philosophy of
            repair pre-determination that has been applied to existing IPFRR
            solutions.
</p>
<a name="anchor23"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.3.3.2"></a><h3>5.3.3.2.&nbsp;
Computing non-looping Repairs of Repairs</h3>

<p>An alternative approach to simply dropping the looping packets,
            or to detecting the loop after it has occurred, is to use
            secondary SRLGs. With a link state routing protocol it is possible
            to precompute the incompatibility of the repairs in advance and to
            compute an alternative SRLG repair path. Although this does
            considerably increase the computational complexity it may be
            possible to compute repair paths that avoid the need to simply
            drop the offending packets.
</p>
<p>This approach requires us to identify the mutually incompatible
            failures, and advertise them as &ldquo;secondary SRLGs&rdquo;.
            When computing the repair paths for the affected not-via addresses
            these links are simultaneously failed. Note that the assumed
            simultaneous failure and resulting repair path only applies to the
            repair path computed for the conflicting not-via addresses, and is
            not used for normal addresses. This implies that although there
            will be a longer repair path when there is more than one failure,
            if there is a single failure the repair path length will be
            "normal".
</p>
<p>Ideally we would wish to only invoke secondary SRLG computation
            when we are sure that the repair paths are mutually incompatible.
            Consider the case of node A in <a class='info' href='#GenMF'>Figure&nbsp;13<span> (</span><span class='info'>The General Case of Multiple Failures</span><span>)</span></a>. A
            first identifies that the repair path for A-B is via F-X-Y-G-B. It
            then explores this path determining the repair path for each link
            in the path. Thus, for example, it performs a check at X by
            running an SPF rooted at X with the X-Y link removed to determine
            whether A-B is indeed on X's repair path for packets addressed to
            Yx.
</p>
<p>Some optimizations are possible in this calculation, which
            appears at first sight to be order hk (where h is the average hop
            length of repair paths and k is the average number of neighbours
            of a router). When A is computing its set of repair paths, it does
            so for all its k neighbours. In each case it identifies a list of
            node pairs traversed by each repair. These lists may often have
            one or more node pairs in common, so the actual number of link
            failures which require investigation is the union of these sets.
            It is then necessary to run an SPF rooted at the first node of
            each pair (the first node because the pairings are ordered
            representing the direction of the path), with the link to the
            second node removed. This SPF, while not an incremental, can be
            terminated as soon as the not-via address is reached. For example,
            when running the SPF rooted at X, with the link X-Y removed, the
            SPF can be terminated when Yx is reached. Once the path has been
            found, the path is checked to determine if it traverses any of
            A&rsquo;s links in the direction away from A. Note that, because
            the node pair XY may exist in the list for more than one of
            A&rsquo;s links (i.e. it lies on more than one repair path), it is
            necessary to identify the correct list, and hence link which has a
            mutually looping repair path. That link of A is then advertised by
            A as a secondary SRLG paired with the link X-Y. Also note that X
            will be running this algorithm as well, and will identify that XY
            is paired with A-B and so advertise it. This could perhaps be used
            as a further check.
</p>
<p>The ordering of the pairs in the lists is important. i.e. X-Y
            and Y-X are dealt with separately. If and only if the repairs are
            mutually incompatible, we need to advertise the pair of links as a
            secondary SRLG, and then ALL nodes compute repair paths around
            both failures using an additional not-via address with the
            semantics not-via A-B AND not-via X-Y.
</p>
<p>A further possibility is that because we are going to the
            trouble of advertising these SRLG sets, we could also advertise
            the new repair path and only get the nodes on that path to perform
            the necessary computation. Note also that once we have reached Q
            space with respect to the two failures we need no longer continue
            the computation, so we only need to notify the nodes on the path
            that are not in Q-space.
</p>
<p>One cause of mutually looping repair paths is the existence of
            nodes with only two links, or sections of the network which are
            only bi-connected. In these cases, repair is clearly impossible
            &ndash; the failure of both links partitions the network. It would
            be advantageous to be able to identify these cases, and inhibit
            the fruitless advertisement of the secondary SRLG information.
            This could be achieved by the node detecting the requirement for a
            secondary SRLG, first running the not-via computation with both
            links removed. If this does not result in a path, it is clear that
            the network would be partitioned by such a failure, and so no
            advertisement is required.
</p>
<a name="anchor24"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.3.3.3"></a><h3>5.3.3.3.&nbsp;
N-level Mutual Loops</h3>

<p>[Editors' Note: This section needs to be reviewed before final
            publication]
</p>
<p>It is tempting to conclude that the mechanism described above
            can be applied to the general case of N failures. If we use the
            approach of assuming that repairs are not mutual, and catching the
            loops and executing AAH when they occur, then we can attempt
            repairs in the case of N failures.
</p>
<p>If we use the approach of avoiding potentially mutual repairs
            and creating secondary SRLG, then we have to explore N levels of
            repair, where N is the number of simultaneous failures we wish to
            repair.
</p>
<a name="anchor25"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.3.4"></a><h3>5.3.4.&nbsp;
Mixing LFAs and Not-via</h3>

<p>So far in this section we have assumed that all repairs use
          not-via tunnels. However, in practise we may wish to use LFAs or
          downstream routes where available. This complicates the issue,
          because their use results in packets which are being repaired, but
          NOT addressed to not-via addresses. If BOTH links are using
          downstream routes there is no possibility of looping, since it is
          impossible to have a pair of nodes which are both downstream of each
          other <a class='info' href='#RFC5286'>[RFC5286]<span> (</span><span class='info'>Atlas, A. and A. Zinin, &ldquo;Basic Specification for IP Fast Reroute: Loop-Free Alternates,&rdquo; September&nbsp;2008.</span><span>)</span></a>.
</p>
<p>Loops can however occur when LFAs are used. An obvious example is
          the well known node repair problem with LFAs <a class='info' href='#RFC5286'>[RFC5286]<span> (</span><span class='info'>Atlas, A. and A. Zinin, &ldquo;Basic Specification for IP Fast Reroute: Loop-Free Alternates,&rdquo; September&nbsp;2008.</span><span>)</span></a>. If one link is using a downstream route,
          while the other is using a not-via tunnel, the potential mechanism
          described above would work provided it were possible to determine
          the nodes on the path of the downstream route. Some methods of
          computing downstream routes do not provide this path information. If
          the path information is however available, the link using a
          downstream route will have a discard FIB entry for the not-via
          address of the other link. The consequence is that potentially
          looping packets will be discarded when they attempt to cross this
          link.
</p>
<p>In the case where the mutual repairs are both using not-via
          repairs, the loop will be broken when the packet arrives at the
          second failure. However packets are unconditionally repaired by
          means of a downstream routes, and thus when the mutual pair consists
          of a downstream route and a not-via repair, the looping packet will
          only be dropped when it gets back to the first failure. i.e. it will
          execute a single turn of the loop before being dropped.
</p>
<p>There is a further complication with downstream routes, since
          although the path may be computed to the far side of the failure,
          the packet may &ldquo;peel off&rdquo; to its destination before
          reaching the far side of the failure. In this case it may traverse
          some other link which has failed and was not accounted for on the
          computed path. If the A-B repair (Figure 1) is a downstream route
          and the X-Y repair is a not-via repair, we can have the situation
          where the X-Y repair packets encapsulated to Yx follow a path which
          attempts to traverse A-B. If the A-B repair path for
          &ldquo;normal&rdquo; addresses is a downstream route, it cannot be
          assumed that the repair path for packets addressed to Yx can be sent
          to the same neighbour. This is because the validity of a downstream
          route must be ascertained in the topology represented by Yx, i.e.
          that with the link X-Y failed. This is not the same topology that
          was used for the normal downstream calculation, and use of the
          normal downstream route for the encapsulated packets may result in
          an undetected loop. If it is computationally feasible to check the
          downstream route in this topology (i.e. for any not-via address Qp
          which traverses A-B we must perform the downstream calculation for
          that not-via address in the topology with link Q-P failed.), then
          the downstream repair for Yx can safely be used. These packets
          cannot re-visit X-Y, since by definition they will avoid that link.
          Alternatively, the packet could be always repaired in a not-via
          tunnel. i.e. even though the normal repair for traffic traversing
          A-B would be to use a downstream route, we could insist that such
          traffic addressed to a not-via address MUST use a tunnel to Ba. Such
          a tunnel would only be installed for an address Qp if it were
          established that it did not traverse Q-P (using the rules described
          above).
</p>
<a name="anchor26"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6"></a><h3>6.&nbsp;
Optimizing not-via computations using LFAs</h3>

<p>If repairing node S has an LFA to the repair endpoint it is not
      necessary for any router to perform the incremental SPF with the link SP
      removed in order to compute the route to the not-via address Ps. This is
      because the correct routes will already have been computed as a result
      of the SPF on the base topology. Node S can signal this condition to all
      other routers by including a bit in its LSP or LSA associated with each
      LFA protected link. Routers computing not-via routes can then omit the
      running of the iSPF for links with this bit set.
</p>
<p>When running the iSPF for a particular link AB, the calculating
      router first checks whether the link AB is present in the existing SPT.
      If the link is not present in the SPT, no further work is required. This
      check is a normal part of the iSPF computation.
</p>
<p>If the link is present in the SPT, this optimization introduces a
      further check to determine whether the link is marked as protected by an
      LFA in the direction in which the link appears in the SPT. If so the
      iSPF need not be performed. For example, if the link appears in the SPT
      in the direction A-&gt;B and A has indicated that the link AB is
      protected by an LFA no further action is required for this link.
</p>
<p>If the receipt of this information is delayed, the correct operation
      of the protocol is not compromised provided that the necessity to
      perform a not-via computation is re-evaluated whenever new information
      arrives.
</p>
<p>This optimization is not particularly beneficial to nodes close to
      the repair since, as has been observed above, the computation for nodes
      on the LFA path is trivial. However, for nodes upstream of the link SP
      for which S-P is in the path to P, there is a significant reduction in
      the computation required.
</p>
<a name="anchor27"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7"></a><h3>7.&nbsp;
Multicast</h3>

<p>Multicast traffic can be repaired in a similar way to unicast. The
      multicast forwarder is able to use the not-via address to which the
      multicast packet was addressed as an indication of the expected receive
      interface and hence to correctly run the required RPF check.
</p>
<p>In some cases, all the destinations, including the repair endpoint,
      are repairable by an LFA. In this case, all unicast traffic may be
      repaired without encapsulation. Multicast traffic still requires
      encapsulation, but for the nodes on the LFA repair path the computation
      of the not-via forwarding entry is unnecessary since, by definition,
      their normal path to the repair endpoint is not via the failure.
</p>
<p>A more complete description of multicast operation is for further
      study.
</p>
<a name="anchor28"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.8"></a><h3>8.&nbsp;
Fast Reroute in an MPLS LDP Network.  </h3>

<p>Not-via addresses are IP addresses and LDP <a class='info' href='#RFC5036'>[RFC5036]<span> (</span><span class='info'>Andersson, L., Minei, I., and B. Thomas, &ldquo;LDP Specification,&rdquo; October&nbsp;2007.</span><span>)</span></a> will distribute labels for them in the usual
      way. The not-via repair mechanism may therefore be used to provide fast
      re-route in an MPLS network by first pushing the label which the repair
      endpoint uses to forward the packet, and then pushing the label
      corresponding to the not-via address needed to effect the repair.
      Referring once again to <a class='info' href='#fig-repair'>Figure&nbsp;1<span> (</span><span class='info'>Not-via repair of router failure</span><span>)</span></a>, if S has a
      packet destined for D that it must reach via P and B, S first pushes B's
      label for D. S then pushes the label that its next hop to Bp needs to
      reach Bp.
</p>
<p>Note that in an MPLS LDP network it is necessary for S to have the
      repair endpoint's label for the destination. When S is effecting a link
      repair it already has this. In the case of a node repair, S either needs
      to set up a directed LDP session with each of its neighbor's neighbors,
      or it needs to use the next-next hop label distribution mechanism
      proposed in <a class='info' href='#I-D.shen-mpls-ldp-nnhop-label'>[I&#8209;D.shen&#8209;mpls&#8209;ldp&#8209;nnhop&#8209;label]<span> (</span><span class='info'>Shen, N., &ldquo;Discovering LDP Next-Nexthop Labels,&rdquo; May&nbsp;2005.</span><span>)</span></a>.
</p>
<a name="anchor29"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.9"></a><h3>9.&nbsp;
Encapsulation</h3>

<p>Any IETF specified IP in IP encapsulation may be used to carry a
      not-via repair. IP in IP <a class='info' href='#RFC2003'>[RFC2003]<span> (</span><span class='info'>Perkins, C., &ldquo;IP Encapsulation within IP,&rdquo; October&nbsp;1996.</span><span>)</span></a>, GRE <a class='info' href='#RFC1701'>[RFC1701]<span> (</span><span class='info'>Hanks, S., Li, T., Farinacci, D., and P. Traina, &ldquo;Generic Routing Encapsulation (GRE),&rdquo; October&nbsp;1994.</span><span>)</span></a> and L2TPv3 <a class='info' href='#RFC3931'>[RFC3931]<span> (</span><span class='info'>Lau, J., Townsley, M., and I. Goyret, &ldquo;Layer Two Tunneling Protocol - Version 3 (L2TPv3),&rdquo; March&nbsp;2005.</span><span>)</span></a>, all
      have the necessary and sufficient properties. The requirement is that
      both the encapsulating router and the router to which the encapsulated
      packet is addressed have a common ability to process the chosen
      encapsulation type. When an MPLS LDP network is being protected, the
      encapsulation would normally be an additional MPLS label. In an MPLS
      enabled IP network an MPLS label may be used in place of an IP in IP
      encapsulation in the case above.
</p>
<a name="anchor30"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.10"></a><h3>10.&nbsp;
Routing Extensions</h3>

<p>IPFRR requires IGP extensions. Each IPFRR router that is directly
      connected to a protected network component must advertise a not-via
      address for that component. This must be advertised in such a way that
      the association between the protected component (link, router or SRLG)
      and the not-via address can be determined by the other routers in the
      network.
</p>
<p>It is necessary that not-via capable routers advertise in the IGP
      that they will calculate not-via routes.
</p>
<p>It is necessary for routers to advertise the type of encapsulation
      that they support (MPLS, GRE, L2TPv3 etc). However, the deployment of
      mixed IP encapsulation types within a network is discouraged.
</p>
<a name="anchor31"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.11"></a><h3>11.&nbsp;
Incremental Deployment</h3>

<p>Incremental deployment is supported by excluding routers that are not
      calculating not-via routes (as indicated by their capability information
      flooded with their link state information) from the base topology used
      for the computation of repair paths. In that way repairs may be steered
      around islands of routers that are not IPFRR capable. Routers that are
      protecting a network component need to have the capability to
      encapsulate and decapsulate packets. However, routers that are on the
      repair path only need to be capable of calculating not-via paths and
      including the not-via addresses in their FIB i.e. these routers do not
      need any changes to their forwarding mechanism.
</p>
<a name="anchor32"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.12"></a><h3>12.&nbsp;
IANA Considerations</h3>

<p>There are no IANA considerations that arise from this draft.
</p>
<a name="anchor33"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.13"></a><h3>13.&nbsp;
Security Considerations</h3>

<p>The repair endpoints present vulnerability in that they might be used
      as a method of disguising the delivery of a packet to a point in the
      network. The primary method of protection should be through the use of a
      private address space for the not-via addresses. These addresses MUST
      NOT be advertised outside the area, and SHOULD be filtered at the
      network entry points. In addition, a mechanism might be developed that
      allowed the use of the mild security available through the use of a key
      <a class='info' href='#RFC1701'>[RFC1701]<span> (</span><span class='info'>Hanks, S., Li, T., Farinacci, D., and P. Traina, &ldquo;Generic Routing Encapsulation (GRE),&rdquo; October&nbsp;1994.</span><span>)</span></a> <a class='info' href='#RFC3931'>[RFC3931]<span> (</span><span class='info'>Lau, J., Townsley, M., and I. Goyret, &ldquo;Layer Two Tunneling Protocol - Version 3 (L2TPv3),&rdquo; March&nbsp;2005.</span><span>)</span></a>. With the
      deployment of such mechanisms, the repair endpoints would not increase
      the security risk beyond that of existing IP tunnel mechanisms. An
      attacker may attempt to overload a router by addressing an excessive
      traffic load to the de-capsulation endpoint. Typically, routers take a
      50% performance penalty in decapsulating a packet. The attacker could
      not be certain that the router would be impacted, and the extremely high
      volume of traffic needed, would easily be detected as an anomaly. If an
      attacker were able to influence the availability of a link, they could
      cause the network to invoke the not-via repair mechanism. A network
      protected by not-via IPFRR is less vulnerable to such an attack than a
      network that undertook a full convergence in response to a link up/down
      event.
</p>
<p>
</p>
<a name="anchor34"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.14"></a><h3>14.&nbsp;
Acknowledgements</h3>

<p>The authors would like to acknowledge contributions made by Alia
      Atlas and John Harper.
</p>
<a name="rfc.references"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.15"></a><h3>15.&nbsp;
References</h3>

<a name="rfc.references1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>15.1.&nbsp;Normative References</h3>
<table width="99%" border="0">
<tr><td class="author-text" valign="top"><a name="RFC2119">[RFC2119]</a></td>
<td class="author-text"><a href="mailto:sob@harvard.edu">Bradner, S.</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>,&rdquo; BCP&nbsp;14, RFC&nbsp;2119, March&nbsp;1997 (<a href="http://www.rfc-editor.org/rfc/rfc2119.txt">TXT</a>, <a href="http://xml.resource.org/public/rfc/html/rfc2119.html">HTML</a>, <a href="http://xml.resource.org/public/rfc/xml/rfc2119.xml">XML</a>).</td></tr>
</table>

<a name="rfc.references2"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>15.2.&nbsp;Informative References</h3>
<table width="99%" border="0">
<tr><td class="author-text" valign="top"><a name="I-D.ietf-bfd-base">[I-D.ietf-bfd-base]</a></td>
<td class="author-text">Katz, D. and D. Ward, &ldquo;<a href="http://www.ietf.org/internet-drafts/draft-ietf-bfd-base-11.txt">Bidirectional Forwarding Detection</a>,&rdquo; draft-ietf-bfd-base-11 (work in progress), January&nbsp;2010 (<a href="http://www.ietf.org/internet-drafts/draft-ietf-bfd-base-11.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="I-D.ietf-rtgwg-ipfrr-framework">[I-D.ietf-rtgwg-ipfrr-framework]</a></td>
<td class="author-text">Shand, M. and S. Bryant, &ldquo;<a href="http://www.ietf.org/internet-drafts/draft-ietf-rtgwg-ipfrr-framework-13.txt">IP Fast Reroute Framework</a>,&rdquo; draft-ietf-rtgwg-ipfrr-framework-13 (work in progress), October&nbsp;2009 (<a href="http://www.ietf.org/internet-drafts/draft-ietf-rtgwg-ipfrr-framework-13.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="I-D.shen-mpls-ldp-nnhop-label">[I-D.shen-mpls-ldp-nnhop-label]</a></td>
<td class="author-text">Shen, N., &ldquo;<a href="http://www.ietf.org/internet-drafts/draft-shen-mpls-ldp-nnhop-label-02.txt">Discovering LDP Next-Nexthop Labels</a>,&rdquo; draft-shen-mpls-ldp-nnhop-label-02 (work in progress), May&nbsp;2005 (<a href="http://www.ietf.org/internet-drafts/draft-shen-mpls-ldp-nnhop-label-02.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="ISPF">[ISPF]</a></td>
<td class="author-text">McQuillan, J., Richer, I., and E. Rosen, &ldquo;ARPANET Routing Algorithm Improvements",&rdquo; BBN Technical Report&nbsp;3803, 1978.</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC1701">[RFC1701]</a></td>
<td class="author-text"><a href="mailto:stan@netsmiths.com">Hanks, S.</a>, <a href="mailto:tli@cisco.com">Li, T.</a>, <a href="mailto:dino@cisco.com">Farinacci, D.</a>, and <a href="mailto:pst@cisco.com">P. Traina</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc1701">Generic Routing Encapsulation (GRE)</a>,&rdquo; RFC&nbsp;1701, October&nbsp;1994 (<a href="http://www.rfc-editor.org/rfc/rfc1701.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC2003">[RFC2003]</a></td>
<td class="author-text"><a href="mailto:perk@watson.ibm.com">Perkins, C.</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc2003">IP Encapsulation within IP</a>,&rdquo; RFC&nbsp;2003, October&nbsp;1996 (<a href="http://www.rfc-editor.org/rfc/rfc2003.txt">TXT</a>, <a href="http://xml.resource.org/public/rfc/html/rfc2003.html">HTML</a>, <a href="http://xml.resource.org/public/rfc/xml/rfc2003.xml">XML</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC3931">[RFC3931]</a></td>
<td class="author-text">Lau, J., Townsley, M., and I. Goyret, &ldquo;<a href="http://tools.ietf.org/html/rfc3931">Layer Two Tunneling Protocol - Version 3 (L2TPv3)</a>,&rdquo; RFC&nbsp;3931, March&nbsp;2005 (<a href="http://www.rfc-editor.org/rfc/rfc3931.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC5036">[RFC5036]</a></td>
<td class="author-text">Andersson, L., Minei, I., and B. Thomas, &ldquo;<a href="http://tools.ietf.org/html/rfc5036">LDP Specification</a>,&rdquo; RFC&nbsp;5036, October&nbsp;2007 (<a href="http://www.rfc-editor.org/rfc/rfc5036.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC5286">[RFC5286]</a></td>
<td class="author-text">Atlas, A. and A. Zinin, &ldquo;<a href="http://tools.ietf.org/html/rfc5286">Basic Specification for IP Fast Reroute: Loop-Free Alternates</a>,&rdquo; RFC&nbsp;5286, September&nbsp;2008 (<a href="http://www.rfc-editor.org/rfc/rfc5286.txt">TXT</a>).</td></tr>
</table>

<a name="rfc.authors"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>Authors' Addresses</h3>
<table width="99%" border="0" cellpadding="0" cellspacing="0">
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Mike Shand</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Cisco Systems</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">250, Longwater Avenue.</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Reading, Berks  RG2 6GB</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">UK</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:mshand@cisco.com">mshand@cisco.com</a></td></tr>
<tr cellpadding="3"><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Stewart Bryant</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Cisco Systems</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">250, Longwater Avenue.</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Reading, Berks  RG2 6GB</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">UK</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:stbryant@cisco.com">stbryant@cisco.com</a></td></tr>
<tr cellpadding="3"><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Stefano Previdi</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Cisco Systems</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Via Del Serafico, 200</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">00142 Rome,   </td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Italy</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:sprevidi@cisco.com">sprevidi@cisco.com</a></td></tr>
</table>
</body></html>
