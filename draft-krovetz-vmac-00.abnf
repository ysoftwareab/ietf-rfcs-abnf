Tag = H_K1(M) xor F_K2(Nonce)

n = bitlength(S) / 64
T = <empty string>
SReversed_i = W_4 || W_3 || ... || W_1
T = T || SReversed_i
n = ceil(numbits / BLOCKLEN)
Y = <empty string>
T = uint2str(index, 8) || uint2str(i, BLOCKLEN-8)
Y = Y || ENCIPHER(K, T)
Y = Y[1...numbits]

index = str2uint(Nonce) mod 2^i
Nonce = Nonce xor uint2str(index, bitlength(Nonce))

Nonce = Nonce || zeros(BLOCKLEN - bitlength(Nonce))

T = ENCIPHER(K, Nonce)
Y = T[index * taglen + 1 ... index * taglen + taglen ]

HashedMessage = VHASH(K, M, taglen)
Pad           = PDF(K, Nonce, taglen)
Tag         = Pad +_64  HashedMessage
Tag         = Pad +_128 HashedMessage
A = L1-HASH(K, M, taglen)
B = L2-HASH(K, A, taglen)
Y = L3-HASH(K, B)
Y = B
L1KEYLEN = 1024
T = KDF(K, 128, L1KEYLEN+128)
K_1 = T[1 ... L1KEYLEN]
K_2 = T[129 ... L1KEYLEN + 128]   // Only used when taglen = 128

t = max(ceil(bitlength(M) / L1KEYLEN), 1)
Y = <empty string>
Y = Y || NH(K_1, M_i)
Y = Y || NH(K_2, M_i)  // Hash twice for 128-bit outputs
Len = uint2str(bitlength(M_t), 64) || zeros(64)
M_t = zeropad(M_t, 128)
Y = Y || (NH(K_1, M_t) +_128 Len)
Y = Y || NH(K_2, M_t)
t = bitlength(M) / 64
Y = zeros(128)
i = 1
Y = Y +_128 ((M_i +_64 K_i) *_128 (M_{i+1} +_64 K_{i+1}))
i = i + 2
Y = zeros(2) || Y[3...128]  // Zero first two bits

T = KDF(K, 192, 128)
k = str2uint(zeros(2) || T[ 3...32] || zeros(2) || T[35... 64] ||
                  zeros(2) || T[67...96] || zeros(2) || T[99...128])

n = bitlength(M) / 128
y = 1
m_i = str2uint(M_i)
y = (k * y + m_i) mod prime(127)
y = (k * y) mod prime(127)
Y = uint2str(y, 128)

i = 0
T    = KDF(K, 224+i, 128)
k_1  = str2uint(T[ 4... 64])
k_2  = str2uint(T[68...128])
i    = i + 1
m_1  = str2uint(M[ 5... 64])
m_2  = str2uint(M[69...128])
y = (m_1 * k_1 + m_2 * k_2) mod prime(61)

Y = uint2str(y, 64)

K  = "abcdefghijklmnop"              // A 128-bit VMAC key
N  = "bcdefghi"                      // A 64-bit nonce

