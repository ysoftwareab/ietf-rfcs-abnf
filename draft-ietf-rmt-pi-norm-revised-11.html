<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="en"><head><title>NACK-Oriented Reliable Multicast
    Protocol</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="description" content="NACK-Oriented Reliable Multicast
    Protocol">
<meta name="generator" content="xml2rfc v1.35 (http://xml.resource.org/)">
<meta name="viewport" content="width=600;" />
<style type='text/css'><!--
        body {
                font-family: verdana, charcoal, helvetica, arial, sans-serif;
                font-size: 85%;
		max-width: 40em; 
		color: #000; background-color: #FFF;
                margin: 2em;
        }
        h1, h2, h3, h4, h5, h6 {
                font-family: helvetica, monaco, "MS Sans Serif", arial, sans-serif;
                font-weight: bold; font-style: normal;
        }
        h1 { color: #900; background-color: transparent; text-align: right; }
        h3 { color: #333; background-color: transparent; }

        td.RFCbug {
                font-size: x-small; text-decoration: none;
                width: 30px; height: 30px; padding-top: 2px;
                text-align: justify; vertical-align: middle;
                background-color: #000;
        }
        td.RFCbug span.RFC {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: bold; color: #666;
        }
        td.RFCbug span.hotText {
                font-family: charcoal, monaco, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: normal; text-align: center; color: #FFF;
        }

        table.TOCbug { width: 30px; height: 15px; }
        td.TOCbug {
                text-align: center; width: 30px; height: 15px;
                color: #FFF; background-color: #900;
        }
        td.TOCbug a {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, sans-serif;
                font-weight: bold; font-size: x-small; text-decoration: none;
                color: #FFF; background-color: transparent;
        }

        td.header {
                font-family: arial, helvetica, sans-serif; font-size: x-small;
                vertical-align: top; width: 33%;
                color: #FFF; background-color: #666;
        }
        td.author { font-weight: bold; font-size: x-small; margin-left: 4em; }
        td.author-text { font-size: x-small; }

        /* info code from SantaKlauss at http://www.madaboutstyle.com/tooltip2.html */
        a.info {
                /* This is the key. */
                position: relative;
                z-index: 24;
                text-decoration: none;
        }
        a.info:hover {
                z-index: 25;
                color: #FFF; background-color: #900;
        }
        a.info span { display: none; }
        a.info:hover span.info {
                /* The span will display just on :hover state. */
                display: block;
                position: absolute;
                font-size: smaller;
                top: 2em; left: -5em; width: 15em;
                padding: 2px; border: 1px solid #333;
                color: #900; background-color: #EEE;
                text-align: left;
        }

        a { font-weight: bold; }
        a:link    { color: #900; background-color: transparent; }
        a:visited { color: #633; background-color: transparent; }
        a:active  { color: #633; background-color: transparent; }

        p { margin-left: 2em; margin-right: 2em; }
        p.copyright { font-size: x-small; }
        p.toc { font-size: 85%;
		max-width: 40em; 
		font-weight: bold; margin-left: 3em; }
        table.toc { margin: 0 0 0 3em; padding: 0; border: 0; vertical-align: text-top; }
        td.toc { font-size: 85%;
		max-width: 40em; 
		font-weight: bold; vertical-align: text-top; }

        ol.text { margin-left: 2em; margin-right: 2em; }
        ul.text { margin-left: 2em; margin-right: 2em; }
        li      { margin-left: 3em; }

        /* RFC-2629 <spanx>s and <artwork>s. */
        em     { font-style: italic; }
        strong { font-weight: bold; }
        dfn    { font-weight: bold; font-style: normal; }
        cite   { font-weight: normal; font-style: normal; }
        tt     { color: #036; }
        tt, pre, pre dfn, pre em, pre cite, pre span {
                font-family: "Courier New", Courier, monospace; font-size: small;
        }
        pre {
                text-align: left; padding: 4px;
                color: #000; background-color: #CCC;
        }
        pre dfn  { color: #900; }
        pre em   { color: #66F; background-color: #FFC; font-weight: normal; }
        pre .key { color: #33C; font-weight: bold; }
        pre .id  { color: #900; }
        pre .str { color: #000; background-color: #CFF; }
        pre .val { color: #066; }
        pre .rep { color: #909; }
        pre .oth { color: #000; background-color: #FCF; }
        pre .err { background-color: #FCC; }

        /* RFC-2629 <texttable>s. */
        table.all, table.full, table.headers, table.none {
                font-size: 85%;
		max-width: 40em; 
		text-align: center; border-width: 2px;
                vertical-align: top; border-collapse: collapse;
        }
        table.all, table.full { border-style: solid; border-color: black; }
        table.headers, table.none { border-style: none; }
        th {
                font-weight: bold; border-color: black;
                border-width: 2px 2px 3px 2px;
        }
        table.all th, table.full th { border-style: solid; }
        table.headers th { border-style: none none solid none; }
        table.none th { border-style: none; }
        table.all td {
                border-style: solid; border-color: #333;
                border-width: 1px 2px;
        }
        table.full td, table.headers td, table.none td { border-style: none; }

        hr { height: 1px; }
        hr.insert {
                width: 80%; border-style: none; border-width: 0;
                color: #CCC; background-color: #CCC;
        }
--></style>
</head>
<body>
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<table summary="layout" width="66%" border="0" cellpadding="0" cellspacing="0"><tr><td><table summary="layout" width="100%" border="0" cellpadding="2" cellspacing="1">
<tr><td class="header">Network Working Group</td><td class="header">B. Adamson</td></tr>
<tr><td class="header">Internet-Draft</td><td class="header">Naval Research Laboratory</td></tr>
<tr><td class="header">Obsoletes: <a href='http://tools.ietf.org/html/rfc3940'>3940</a> (if&nbsp;approved)</td><td class="header">C. Bormann</td></tr>
<tr><td class="header">Intended status: Standards Track</td><td class="header">Universitaet Bremen TZI</td></tr>
<tr><td class="header">Expires: October 26, 2009</td><td class="header">M. Handley</td></tr>
<tr><td class="header">&nbsp;</td><td class="header">University College London</td></tr>
<tr><td class="header">&nbsp;</td><td class="header">J. Macker</td></tr>
<tr><td class="header">&nbsp;</td><td class="header">Naval Research Laboratory</td></tr>
<tr><td class="header">&nbsp;</td><td class="header">April 24, 2009</td></tr>
</table></td></tr></table>
<h1><br />NACK-Oriented Reliable Multicast
    Protocol<br />draft-ietf-rmt-pi-norm-revised-11</h1>

<h3>Status of this Memo</h3>
<p>
This Internet-Draft is submitted to IETF in full
conformance with the provisions of BCP&nbsp;78 and BCP&nbsp;79.
This document may contain material from IETF Documents or IETF
Contributions published or made publicly available before November
10, 2008. The person(s) controlling the copyright in some of this
material may not have granted the IETF Trust the right to allow
modifications of such material outside the IETF Standards Process.
Without obtaining an adequate license from the person(s) controlling
the copyright in such materials, this document may not be modified
outside the IETF Standards Process, and derivative works of it may
not be created outside the IETF Standards Process, except to format
it for publication as an RFC or to translate it into languages other
than English.</p>
<p>
Internet-Drafts are working documents of the Internet Engineering
Task Force (IETF), its areas, and its working groups.
Note that other groups may also distribute working documents as
Internet-Drafts.</p>
<p>
Internet-Drafts are draft documents valid for a maximum of six months
and may be updated, replaced, or obsoleted by other documents at any time.
It is inappropriate to use Internet-Drafts as reference material or to cite
them other than as &ldquo;work in progress.&rdquo;</p>
<p>
The list of current Internet-Drafts can be accessed at
<a href='http://www.ietf.org/ietf/1id-abstracts.txt'>http://www.ietf.org/ietf/1id-abstracts.txt</a>.</p>
<p>
The list of Internet-Draft Shadow Directories can be accessed at
<a href='http://www.ietf.org/shadow.html'>http://www.ietf.org/shadow.html</a>.</p>
<p>
This Internet-Draft will expire on October 26, 2009.</p>

<h3>Copyright Notice</h3>
<p>
Copyright (c) 2009 IETF Trust and the persons identified as the
document authors.  All rights reserved.</p>
<p>
This document is subject to BCP 78 and the IETF Trust's Legal
Provisions Relating to IETF Documents in effect on the date of
publication of this document (http://trustee.ietf.org/license-info).
Please review these documents carefully, as they describe your
rights and restrictions with respect to this document.</p>

<h3>Abstract</h3>

<p>This document describes the messages and procedures of the
      Negative-ACKnowledgment (NACK) Oriented Reliable Multicast (NORM)
      Protocol. This protocol is designed to provide end-to-end reliable
      transport of bulk data objects or streams over generic IP multicast
      routing and forwarding services. NORM uses a selective, negative
      acknowledgment mechanism for transport reliability and offers additional
      protocol mechanisms to allow for operation with minimal <em>a priori</em> coordination among senders and receivers.
      A congestion control scheme is specified to allow the NORM protocol to
      fairly share available network bandwidth with other transport protocols
      such as Transmission Control Protocol (TCP). It is capable of operating
      with both reciprocal multicast routing among senders and receivers and
      with asymmetric connectivity (possibly a unicast return path) between
      the senders and receivers. The protocol offers a number of features to
      allow different types of applications or possibly other higher level
      transport protocols to utilize its service in different ways. The
      protocol leverages the use of FEC-based repair and other IETF Reliable
      Multicast Transport (RMT) building blocks in its design. This document
      obsoletes <a class='info' href='#RFC3940'>RFC 3940<span> (</span><span class='info'>Adamson, B., Bormann, C., Handley, M., and J. Macker, &ldquo;Negative-acknowledgment (NACK)-Oriented Reliable Multicast (NORM) Protocol,&rdquo; November&nbsp;2004.</span><span>)</span></a>.
</p><a name="toc"></a><br /><hr />
<h3>Table of Contents</h3>
<p class="toc">
<a href="#anchor1">1.</a>&nbsp;
Introduction and Applicability<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor2">1.1.</a>&nbsp;
Requirements Language<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor3">1.2.</a>&nbsp;
NORM Data Delivery Service Model<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor4">1.3.</a>&nbsp;
NORM Scalability<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor5">1.4.</a>&nbsp;
Environmental Requirements and Considerations<br />
<a href="#anchor6">2.</a>&nbsp;
Architecture Definition<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#ProtocolOverview">2.1.</a>&nbsp;
Protocol Operation Overview<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor7">2.2.</a>&nbsp;
Protocol Building Blocks<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor8">2.3.</a>&nbsp;
Design Tradeoffs<br />
<a href="#anchor9">3.</a>&nbsp;
Conformance Statement<br />
<a href="#anchor10">4.</a>&nbsp;
Message Formats<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#CommonHeader">4.1.</a>&nbsp;
NORM Common Message Header and Extensions<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor11">4.2.</a>&nbsp;
Sender Messages<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor12">4.2.1.</a>&nbsp;
NORM_DATA Message<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor13">4.2.2.</a>&nbsp;
NORM_INFO Message<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#NORM_CMD">4.2.3.</a>&nbsp;
NORM_CMD Messages<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor21">4.3.</a>&nbsp;
Receiver Messages<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor22">4.3.1.</a>&nbsp;
NORM_NACK Message<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor23">4.3.2.</a>&nbsp;
NORM_ACK Message<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor24">4.4.</a>&nbsp;
General Purpose Messages<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor25">4.4.1.</a>&nbsp;
NORM_REPORT Message<br />
<a href="#ProtocolDetails">5.</a>&nbsp;
Detailed Protocol Operation<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor26">5.1.</a>&nbsp;
Sender Initialization and Transmission<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#SegmentationAlgorithm">5.1.1.</a>&nbsp;
Object Segmentation Algorithm<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor27">5.2.</a>&nbsp;
Receiver Initialization and Reception<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#NackProcedure">5.3.</a>&nbsp;
Receiver NACK Procedure<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor28">5.4.</a>&nbsp;
Sender NACK Processing and Response<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor29">5.4.1.</a>&nbsp;
Sender Repair State Aggregation<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor30">5.4.2.</a>&nbsp;
Sender FEC Repair Transmission Strategy<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor31">5.4.3.</a>&nbsp;
Sender NORM_CMD(SQUELCH) Generation<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor32">5.4.4.</a>&nbsp;
Sender NORM_CMD(REPAIR_ADV) Generation<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor33">5.5.</a>&nbsp;
Additional Protocol Mechanisms<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#GrttCollection">5.5.1.</a>&nbsp;
Greatest Round-trip Time Collection<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#CongestionControl">5.5.2.</a>&nbsp;
NORM Congestion Control Operation<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#PositiveAcknowledgment">5.5.3.</a>&nbsp;
NORM Positive Acknowledgment Procedure<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor37">5.5.4.</a>&nbsp;
Group Size Estimate<br />
<a href="#anchor38">6.</a>&nbsp;
Security Considerations<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#NormIPsec">6.1.</a>&nbsp;
Baseline Secure NORM Operation<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor39">6.1.1.</a>&nbsp;
IPsec Approach<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor40">6.1.2.</a>&nbsp;
IPsec Requirements<br />
<a href="#anchor47">7.</a>&nbsp;
IANA Considerations<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor48">7.1.</a>&nbsp;
Explicit IANA Assignment Guidelines<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor49">7.1.1.</a>&nbsp;
NORM Header Extension Types<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor50">7.1.2.</a>&nbsp;
NORM Stream Control Codes<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor51">7.1.3.</a>&nbsp;
NORM_CMD Message Sub-types<br />
<a href="#anchor52">8.</a>&nbsp;
Suggested Use<br />
<a href="#ProtocolChanges">9.</a>&nbsp;
Changes from RFC3940<br />
<a href="#anchor53">10.</a>&nbsp;
Acknowledgments<br />
<a href="#rfc.references1">11.</a>&nbsp;
References<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#rfc.references1">11.1.</a>&nbsp;
Normative References<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#rfc.references2">11.2.</a>&nbsp;
Informative References<br />
<a href="#rfc.authors">&#167;</a>&nbsp;
Authors' Addresses<br />
</p>
<br clear="all" />

<a name="anchor1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1"></a><h3>1.&nbsp;
Introduction and Applicability</h3>

<p>The Negative-acknowledgment (NACK) Oriented Reliable Multicast (NORM)
      protocol is designed to provide reliable transport of data from one or
      more sender(s) to a group of receivers over an IP multicast network. The
      primary design goals of NORM are to provide efficient, scalable, and
      robust bulk data (e.g., computer files, transmission of persistent data)
      transfer across possibly heterogeneous IP networks and topologies. The
      NORM protocol design provides support for distributed multicast session
      participation with minimal coordination among senders and receivers.
      NORM allows senders and receivers to dynamically join and leave
      multicast sessions at will with minimal overhead for control information
      and timing synchronization among participants. To accommodate this
      capability, NORM protocol message headers contain some common
      information allowing receivers to easily synchronize to senders
      throughout the lifetime of a reliable multicast session. NORM is
      designed to be self-adapting to a wide range of dynamic network
      conditions with little or no pre-configuration. The protocol is
      purposely designed to be tolerant of inaccurate timing estimations or
      lossy conditions that may occur in many networks including mobile and
      wireless. The protocol is also designed to exhibit convergence and
      efficient operation even in situations of heavy packet loss and large
      queuing or transmission delays. This document obsoletes the Experimental
      <a class='info' href='#RFC3940'>RFC 3940<span> (</span><span class='info'>Adamson, B., Bormann, C., Handley, M., and J. Macker, &ldquo;Negative-acknowledgment (NACK)-Oriented Reliable Multicast (NORM) Protocol,&rdquo; November&nbsp;2004.</span><span>)</span></a> specification.
</p>
<p>This document is a product of the IETF RMT working group and follows
      the guidelines provided in the <a class='info' href='#RFC3269'>Author Guidelines
      for Reliable Multicast Transport (RMT) Building Blocks and Protocol
      Instantiation documents<span> (</span><span class='info'>Kermode, R. and L. Vicisano, &ldquo;Author Guidelines for Reliable Multicast Transport (RMT) Building Blocks and Protocol Instantiation documents,&rdquo; April&nbsp;2002.</span><span>)</span></a> [RFC3269].
</p>
<p><strong>Statement of Intent</strong>
</p>
<p>This memo contains the definitions necessary to fully specify a
      Reliable Multicast Transport protocol in accordance with the criteria of
      <a class='info' href='#RFC2357'>IETF Criteria for Evaluating Reliable Multicast
      Transport and Application Protocols<span> (</span><span class='info'>Mankin, A., Romanov, A., Bradner, S., and V. Paxson, &ldquo;IETF Criteria for Evaluating Reliable Multicast Transport and Application Protocols,&rdquo; June&nbsp;1998.</span><span>)</span></a> [RFC2357]. The NORM specification
      described in this document was previously published in the "Experimental
      Category" <a class='info' href='#RFC3940'>[RFC3940]<span> (</span><span class='info'>Adamson, B., Bormann, C., Handley, M., and J. Macker, &ldquo;Negative-acknowledgment (NACK)-Oriented Reliable Multicast (NORM) Protocol,&rdquo; November&nbsp;2004.</span><span>)</span></a>. It was the stated intent of
      the RMT working group to re-submit this specifications as an IETF
      Proposed Standard in due course. This Proposed Standard specification is
      thus based on RFC 3940 and has been updated according to accumulated
      experience and growing protocol maturity since the publication of RFC
      3940. Said experience applies both to this specification itself and to
      congestion control strategies related to the use of this specification.
      The differences between RFC 3940 and this document are listed in <a class='info' href='#ProtocolChanges'>Section&nbsp;9<span> (</span><span class='info'>Changes from RFC3940</span><span>)</span></a>.
</p>
<a name="anchor2"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1.1"></a><h3>1.1.&nbsp;
Requirements Language</h3>

<p>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
        "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
        document are to be interpreted as described in <a class='info' href='#RFC2119'>RFC 2119<span> (</span><span class='info'>Bradner, S., &ldquo;Key words for use in RFCs to Indicate Requirement Levels,&rdquo; March&nbsp;1997.</span><span>)</span></a> [RFC2119].
</p>
<a name="anchor3"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1.2"></a><h3>1.2.&nbsp;
NORM Data Delivery Service Model</h3>

<p>A NORM protocol instance (<em>NormSession</em>)
        is defined within the context of participants communicating
        connectionless (e.g., Internet Protocol (IP) or User Datagram Protocol
        (UDP)) packets over a network using pre-determined addresses and host
        port numbers. Generally, the participants exchange packets using an IP
        multicast group address, but unicast transport may also be established
        or applied as an adjunct to multicast delivery. In the case of
        multicast, the participating <em>NormNodes</em>
        will communicate using a common IP multicast group address and port
        number that has been chosen via means outside the context of the given
        <em>NormSession</em>. Other IETF data format and
        protocol standards exist that may be applied to describe and convey
        the required <em>a priori</em> information for a
        specific <em>NormSession</em> (e.g., <a class='info' href='#RFC4566'>Session Description Protocol (SDP)<span> (</span><span class='info'>Handley, M., Jacobson, V., and C. Perkins, &ldquo;SDP: Session Description Protocol,&rdquo; July&nbsp;2006.</span><span>)</span></a> [RFC4566], <a class='info' href='#RFC2974'>Session Announcement Protocol (SAP)<span> (</span><span class='info'>Handley, M., Perkins, C., and E. Whelan, &ldquo;Session Announcement Protocol,&rdquo; October&nbsp;2000.</span><span>)</span></a> [RFC2974],
        etc.).
</p>
<p>The NORM protocol design is principally driven by the assumption of
        a single sender transmitting bulk data content to a group of
        receivers. However, the protocol MAY operate with multiple senders
        within the context of a single <em>NormSession</em>.
        In initial implementations of this protocol, it is anticipated that
        multiple senders will transmit independent of one another and
        receivers will maintain state as necessary for each sender. However,
        in future versions of NORM, it is possible that some aspects of
        protocol operation (e.g., round-trip time collection) may provide for
        alternate modes allowing more efficient performance for applications
        requiring multiple senders.
</p>
<p>NORM provides for three types of bulk data content objects (<em>NormObjects</em>) to be reliably transported. These
        types include:
</p>
<p></p>
<ol class="text">
<li>static computer memory data content (<tt>NORM_OBJECT_DATA</tt>
            type),
</li>
<li>computer storage files (<tt>NORM_OBJECT_FILE</tt>
            type), and
</li>
<li>non-finite streams of continuous data content (<tt>NORM_OBJECT_STREAM</tt> type).
</li>
</ol>

<p>The distinction between <tt>NORM_OBJECT_DATA</tt>
        and <tt>NORM_OBJECT_FILE</tt> is simply to provide
        a hint to receivers in <em>NormSessions</em>
        serving multiple types of content as to what type of storage should be
        allocated for received content (i.e., memory or file storage). Other
        than that distinction, the two are identical, providing for reliable
        transport of finite (but potentially very large) units of content.
        These static data and file services are anticipated to be useful for
        multicast-based cache applications with the ability to reliably
        provide transmission of large quantities of static data. Other types
        of static data/file delivery services might make use of these
        transport object types, too. The use of the <tt>NORM_OBJECT_STREAM</tt>
        type is at the application's discretion and could be used to carry
        static data or file content also. The NORM reliable stream service
        opens up additional possibilities such as serialized reliable
        messaging or other unbounded, perhaps dynamically produced content.
        The <tt>NORM_OBJECT_STREAM</tt> provides for
        reliable transport analogous to that of the Transmission Control
        Protocol (TCP), although NORM receivers will be able to begin
        receiving stream content at any point in time. The applicability of
        this feature will depend upon the application.
</p>
<p>The NORM protocol also allows for a small amount of out-of-band
        data (sent as <tt>NORM_INFO</tt> messages) to be
        attached to the data content objects transmitted by the sender. This
        readily-available out-of-band data allows multicast receivers to
        quickly and efficiently determine the nature of the corresponding
        data, file, or stream bulk content being transmitted. This allows
        application-level control of the receiver node's participation in the
        current transport activity. This also allows the protocol to be
        flexible with minimal pre-coordination among senders and receivers.
        The <tt>NORM_INFO</tt> content is designed to be
        atomic in that its size MUST fit into the payload portion of a single
        NORM message.
</p>
<p>NORM does NOT provide for global or application-level
        identification of data content within in its message headers. Note the
        <tt>NORM_INFO</tt> out-of-band data mechanism could
        be leveraged by the application for this purpose if desired, or
        identification could alternatively be embedded within the data
        content. NORM does identify transmitted content (<em>NormObjects</em>)
        with transport identifiers that are applicable only while the sender
        is transmitting and/or repairing the given object. These transport
        data content identifiers (<em>NormTransportIds</em>)
        are assigned in a monotonically increasing fashion by each NORM sender
        during the course of a <em>NormSession</em>. Each
        sender maintains its <em>NormTransportId</em>
        assignments independently so that individual <em>NormObjects</em>
        may be uniquely identified during transport with the concatenation of
        the sender session-unique identifier (<em>NormNodeId</em>)
        and the assigned <em>NormTransportId</em>. The
        <em>NormTransportId</em>s are assigned from a
        large, but fixed, numeric space in increasing order and may be
        reassigned during long-lived sessions. The NORM protocol provides
        mechanisms so that the sender application may terminate transmission
        of data content and inform the group of this in an efficient manner.
        Other similar protocol control mechanisms (e.g., session termination,
        receiver synchronization, etc.) are specified so that reliable
        multicast application variants may construct different, complete bulk
        transfer communication models to meet their goals.
</p>
<p>To summarize, the NORM protocol provides reliable transport of
        different types of data content (including potentially mixed types).
        The senders enqueue and transmit bulk content in the form of static
        data or files and/or non-finite, ongoing stream types. NORM senders
        provide for repair transmission of data and/or FEC content in response
        to NACK messages received from the receiver group. Mechanisms for
        out-of-band information and other transport control mechanisms are
        specified for use by applications to form complete reliable multicast
        solutions for different purposes.
</p>
<a name="anchor4"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1.3"></a><h3>1.3.&nbsp;
NORM Scalability</h3>

<p>Group communication scalability requirements lead to adaptation of
        negative acknowledgment (NACK) based protocol schemes when feedback
        for reliability is required <a class='info' href='#RmComparison'>[RmComparison]<span> (</span><span class='info'>Pingali, S., Towsley, D., and J. Kurose, &ldquo;A Comparison of Sender-Initiated and Receiver-Initiated           Reliable Multicast Protocols,&rdquo; October&nbsp;1993.</span><span>)</span></a>. NORM
        is a protocol centered around the use of selective NACKs to request
        repairs of missing data. NORM provides for the use of packet-level
        forward error correction (FEC) techniques for efficient multicast
        repair and optional proactive transmission robustness <a class='info' href='#RFC3453'>[RFC3453]<span> (</span><span class='info'>Luby, M., Vicisano, L., Gemmell, J., Rizzo, L., Handley, M., and J. Crowcroft, &ldquo;The Use of Forward Error Correction (FEC) in Reliable Multicast,&rdquo; December&nbsp;2002.</span><span>)</span></a>. FEC-based repair can be used to greatly
        reduce the quantity of reliable multicast repair requests and repair
        transmissions <a class='info' href='#MdpToolkit'>[MdpToolkit]<span> (</span><span class='info'>Macker,  J. and B. Adamson, &ldquo;The Multicast Dissemination Protocol (MDP) Toolkit,&rdquo; October&nbsp;1999.</span><span>)</span></a> in a NACK-oriented
        protocol. The principal factor in NORM scalability is the volume of
        feedback traffic generated by the receiver set to facilitate
        reliability and congestion control. NORM uses probabilistic
        suppression of redundant feedback based on exponentially distributed
        random backoff timers. The performance of this type of suppression
        relative to other techniques is described in <a class='info' href='#McastFeedback'>[McastFeedback]<span> (</span><span class='info'>Nonnenmacher, J. and E. Biersack, &ldquo;Optimal Multicast Feedback,&rdquo; March/April&nbsp;1998.</span><span>)</span></a>. NORM dynamically measures the group's
        round-trip timing status to set its suppression and other protocol
        timers. This allows NORM to scale well while maintaining reliable data
        delivery transport with low latency relative to the network topology
        over which it is operating.
</p>
<p>Feedback messages can be either multicast to the group at large or
        sent via unicast routing to the sender. In the case of unicast
        feedback, the sender relays the feedback state to the group to
        facilitate feedback suppression. In typical Internet environments, it
        is expected that the NORM protocol will readily scale to group sizes
        on the order of tens of thousands of receivers. A study of the
        quantity of feedback for this type of protocol is described in <a class='info' href='#NormFeedback'>[NormFeedback]<span> (</span><span class='info'>Adamson, B. and J. Macker, &ldquo;Quantitative Prediction of NACK-Oriented Reliable Multicast           (NORM) Feedback,&rdquo; October&nbsp;2002.</span><span>)</span></a>. NORM is able to operate with a smaller
        amount of feedback than a single TCP connection, even with relatively
        large numbers of receivers. Thus, depending upon the network topology,
        it is possible that NORM may scale to larger group sizes. With respect
        to computer resource usage, the NORM protocol does NOT require that
        state be kept on all receivers in the group. NORM senders maintain
        state only for receivers providing explicit congestion control
        feedback. However, NORM receivers must maintain state for each active
        sender. This may constrain the number of simultaneous senders in some
        uses of NORM.
</p>
<a name="anchor5"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1.4"></a><h3>1.4.&nbsp;
Environmental Requirements and Considerations</h3>

<p>All of the environmental requirements and considerations that apply
        to the <a class='info' href='#RFC5401'>Multicast NACK Building Block<span> (</span><span class='info'>Adamson, B., Bormann, C., Handley, M., and J. Macker, &ldquo;Multicast Negative-Acknowledgment (NACK) Building Blocks,&rdquo; November&nbsp;2008.</span><span>)</span></a> [RFC5401],
        <a class='info' href='#RFC5052'>FEC Building Block<span> (</span><span class='info'>Watson, M., Luby, M., and L. Vicisano, &ldquo;Forward Error Correction (FEC) Building Block,&rdquo; August&nbsp;2007.</span><span>)</span></a> [RFC5052], and <a class='info' href='#RFC4654'>TCP-Friendly Multicast Congestion Control (TFMCC)
        Building Block<span> (</span><span class='info'>Widmer, J. and M. Handley, &ldquo;TCP-Friendly Multicast Congestion Control (TFMCC): Protocol Specification,&rdquo; August&nbsp;2006.</span><span>)</span></a> [RFC4654] also apply to the NORM protocol.
</p>
<p>The NORM protocol SHALL be capable of operating in an end-to-end
        fashion with no assistance from intermediate systems beyond basic IP
        multicast group management, routing, and forwarding services. While
        the techniques utilized in NORM are principally applicable to flat,
        end-to-end IP multicast topologies, they could also be applied in the
        sub-levels of hierarchical (e.g., tree-based) multicast distribution
        if so desired. NORM can make use of reciprocal (among senders and
        receivers) multicast communication under the Any-Source Multicast
        (ASM) model defined in <a class='info' href='#RFC1112'>Host Extensions for IP
        Multicasting<span> (</span><span class='info'>Deering, S., &ldquo;Host extensions for IP multicasting,&rdquo; August&nbsp;1989.</span><span>)</span></a> [RFC1112], but SHALL also be capable of scalable operation
        in asymmetric topologies such as <a class='info' href='#RFC4607'>Source-Specific Multicast (SSM)<span> (</span><span class='info'>Holbrook, H. and B. Cain, &ldquo;Source-Specific Multicast for IP,&rdquo; August&nbsp;2006.</span><span>)</span></a> [RFC4607] where there
        may only be unicast routing service from the receivers to the
        sender(s).
</p>
<p>NORM is compatible with IPv4 and IPv6. Additionally, NORM may be
        used with networks employing Network Address Translation (NAT)
        providing the NAT device supports IP multicast and/or can cache UDP
        traffic source port numbers for remapping feedback traffic from
        receivers to the sender(s).
</p>
<a name="anchor6"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2"></a><h3>2.&nbsp;
Architecture Definition</h3>

<p>A <em>NormSession</em> is comprised of
      participants (<em>NormNodes</em>) acting as senders
      and/or receivers. NORM senders transmit data content in the form of
      <em>NormObjects</em> to the session destination
      address and the NORM receivers attempt to reliably receive the
      transmitted content using negative acknowledgments to request repair.
      Each <em>NormNode</em> within a <em>NormSession</em>
      is assumed to have a preselected unique 32-bit identifier (<em>NormNodeId</em>). <em>NormNodes</em>
      MUST have uniquely assigned identifiers within a single <em>NormSession</em> to distinguish between possible
      multiple senders and to distinguish feedback information from different
      receivers. There are two reserved <em>NormNodeId</em>
      values. A value of <tt>0x00000000</tt> is considered
      an invalid <em>NormNodeId</em> value and a value of
      <tt>0xffffffff</tt> is a "wild card" <em>NormNodeId</em>. While the protocol does not preclude
      multiple sender nodes concurrently transmitting within the context of a
      single NORM session (i.e., many- to-many operation), any type of
      interactive coordination among NORM senders is assumed to be controlled
      by the application or higher protocol layer. There are some optional
      mechanisms specified in this document that can be leveraged for such
      application layer coordination.
</p>
<p>As previously noted, NORM allows for reliable transmission of three
      different basic types of data content. The first type is <tt>NORM_OBJECT_DATA</tt>, which is used for static,
      persistent blocks of data content maintained in the sender's application
      memory storage. The second type is <tt>NORM_OBJECT_FILE</tt>,
      which corresponds to data stored in the sender's non-volatile file
      system. The <tt>NORM_OBJECT_DATA</tt> and <tt>NORM_OBJECT_FILE</tt> types both represent <em>NormObjects</em> of finite but potentially very large
      size. The third type of data content is <tt>NORM_OBJECT_STREAM</tt>,
      which corresponds to an ongoing transmission of undefined length. This
      is analogous to the reliable stream service provide by TCP for unicast
      data transport. The format of the stream content is application-defined
      and may be byte or message oriented. The NORM protocol provides for
      "flushing" of the stream to expedite delivery or possibly enforce
      application message boundaries. NORM protocol implementations may offer
      either (or both) in-order delivery of the stream data to the receive
      application or out-of-order (more immediate) delivery of received
      segments of the stream to the receiver application. In either case, NORM
      sender and receiver implementations provide buffering to facilitate
      repair of the stream as it is transported.
</p>
<p>All <em>NormObjects</em> are logically segmented
      into FEC coding blocks and symbols for transmission by the sender. In
      NORM, an FEC encoding symbol directly corresponds to the payload of
      <tt>NORM_DATA</tt> messages or "segment". Note that
      when systematic FEC codes are used, the payload of <tt>NORM_DATA</tt>
      messages sent for the first portion of a FEC encoding block are source
      symbols (actual segments of original user data), while the remaining
      symbols for the block consist of parity symbols generated by FEC
      encoding. These parity symbols are generally sent in response to repair
      requests, but some number may be sent proactively at the end each
      encoding block to increase the robustness of transmission. When
      non-systematic FEC codes are used, all symbols sent consist of FEC
      encoding parity content. In this case, the receiver must receive a
      sufficient number of symbols to reconstruct (via FEC decoding) the
      original user data for the given block.
</p>
<p>Transmitted <em>NormObjects</em> are temporarily
      yet uniquely identified within the <em>NormSession</em>
      context using the given sender's <em>NormNodeId</em>,
      <em>NormInstanceId</em>, and a temporary <em>NormObjectTransportId</em>. Depending upon the
      implementation, individual NORM senders may manage their <em>NormInstanceIds</em> independently, or a common <em>NormInstanceId</em> may be agreed upon for all
      participating nodes within a session if needed as a session identifier.
      NORM <em>NormObjectTransportId</em> data content
      identifiers are sender-assigned and applicable and valid only during a
      <em>NormObject</em>'s actual transport (i.e., for as
      long as the sender is transmitting and providing repair of the indicated
      <em>NormObject</em>). For a long-lived session, the
      <em>NormObjectTransportId</em> field can wrap and
      previously-used identifiers may be re-used. Note that globally unique
      identification of transported data content is not provided by NORM and,
      if required, must be managed by the NORM application. The individual
      segments or symbols of the <em>NormObject</em> are
      further identified with FEC payload identifiers which include coding
      block and symbol identifiers. These are discussed in detail later in
      this document.
</p>
<a name="ProtocolOverview"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2.1"></a><h3>2.1.&nbsp;
Protocol Operation Overview</h3>

<p>A NORM sender primarily generates messages of type <tt>NORM_DATA</tt>. These messages carry original data
        segments or FEC symbols and repair segments/symbols for the bulk
        data/file or stream <em>NormObjects</em> being
        transferred. By default, redundant FEC symbols are sent only in
        response to receiver repair requests (NACKs) and thus normally little
        or no additional transmission overhead is imposed due to FEC encoding.
        However, the NORM implementation MAY be optionally configured to
        proactively transmit some amount of redundant FEC symbols along with
        the original content to potentially enhance performance (e.g.,
        improved delay) at the cost of additional transmission overhead. This
        option may be sensible for certain network conditions and can allow
        for robust, asymmetric multicast (e.g., unidirectional routing,
        satellite, cable) <a class='info' href='#FecHybrid'>[FecHybrid]<span> (</span><span class='info'>Gossink, D. and J. Macker, &ldquo;Reliable Multicast and Integrated Parity Retransmission with           Channel Estimation,&rdquo; 1998.</span><span>)</span></a> with reduced
        receiver feedback, or, in some cases, no feedback.
</p>
<p>A sender message of type <tt>NORM_INFO</tt> is
        also defined and is used to carry OPTIONAL out-of-band context
        information for a given transport object. A single <tt>NORM_INFO</tt> message can be associated with a <em>NormObject</em>. Because of its atomic nature, missing
        <tt>NORM_INFO</tt> messages can be NACKed and
        repaired with a slightly lower delay process than NORM's general
        FEC-encoded data content. <tt>NORM_INFO</tt> may
        serve special purposes for some bulk transfer, reliable multicast
        applications where receivers join the group mid-stream and need to
        ascertain contextual information on the current content being
        transmitted. The NACK process for <tt>NORM_INFO</tt>
        will be described later. When the <tt>NORM_INFO</tt>
        message type is used, its transmission should precede transmission of
        any <tt>NORM_DATA</tt> message for the associated
        <em>NormObject</em>.
</p>
<p>The sender also generates messages of type <tt>NORM_CMD</tt>
        to assist in certain protocol operations such as congestion control,
        end-of-transmission flushing, round trip time estimation, receiver
        synchronization, and optional positive acknowledgment requests or
        application defined commands. The transmission of <tt>NORM_CMD</tt>
        messages from the sender is accomplished by one of three different
        procedures. These procedures are: single, best effort unreliable
        transmission of the command; repeated redundant transmissions of the
        command; and positively-acknowledged commands. The transmission
        technique used for a given command depends upon the function of the
        command. Several core commands are defined for basic protocol
        operation. Additionally, implementations MAY wish to consider
        providing the OPTIONAL application-defined commands that can take
        advantage of the transmission methodologies available for commands.
        This allows for application-level session management mechanisms that
        can make use of information available to the underlying NORM protocol
        engine (e.g., round-trip timing, transmission rate, etc.). A notable
        distinction between <tt>NORM_DATA</tt> message and
        some <tt>NORM_CMD</tt> message transmissions is
        that typically a receiver will need to allocate resources to manage
        reliable reception when <tt>NORM_DATA</tt> messages
        are received. However some <tt>NORM_CMD</tt>
        messages may be completely atomic and no specific state may need to be
        kept. Thus, for session management or other purposes it is possible
        that even participants acting principally as data receivers MAY
        transmit <tt>NORM_CMD</tt> messages. However, it is
        RECOMMENDED that this is not done within the context of the NORM
        multicast session unless congestion control is addressed. For example,
        many receiver nodes transmitting <tt>NORM_CMD</tt>
        messages simultaneously can cause congestion for the
        destination(s).
</p>
<p>All sender transmissions are subject to rate control governed by a
        peak transmission rate set for each participant by the application.
        This can be used to limit the quantity of multicast data transmitted
        by the group. When NORM's congestion control algorithm is enabled the
        rate for senders is automatically adjusted. In some networks, it may
        be desirable to establish minimum and maximum bounds for the rate
        adjustment depending upon the application even when dynamic congestion
        control is enabled. However, in the case of the general Internet,
        congestion control policy SHALL be observed that is compatible with
        coexistent TCP flows.
</p>
<p>NORM receivers generate messages of type <tt>NORM_NACK</tt>
        or <tt>NORM_ACK</tt> in response to transmissions
        of data and commands from a sender. The <tt>NORM_NACK</tt>
        messages are generated to request repair of detected data transmission
        losses. Receivers generally detect losses by tracking the sequence of
        transmission from a sender. Sequencing information is embedded in the
        transmitted data packets and end-of-transmission commands from the
        sender. <tt>NORM_ACK</tt> messages are generated in
        response to certain commands transmitted by the sender. In the general
        (and most scalable) protocol mode, <tt>NORM_ACK</tt>
        messages are sent only in response to congestion control commands from
        the sender. The feedback volume of these congestion control <tt>NORM_ACK</tt> messages is controlled using the same
        timer-based probabilistic suppression techniques as for <tt>NORM_NACK</tt> messages to avoid feedback implosion.
        In order to meet potential application requirements for positive
        acknowledgment from receivers, other <tt>NORM_ACK</tt>
        messages are defined and available for use.
</p>
<a name="anchor7"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2.2"></a><h3>2.2.&nbsp;
Protocol Building Blocks</h3>

<p>The operation of the NORM protocol is based primarily upon the
        concepts presented in the <a class='info' href='#RFC5401'>Multicast NACK
        Building Block<span> (</span><span class='info'>Adamson, B., Bormann, C., Handley, M., and J. Macker, &ldquo;Multicast Negative-Acknowledgment (NACK) Building Blocks,&rdquo; November&nbsp;2008.</span><span>)</span></a> [RFC5401] document. This includes the basic NORM
        architecture and the data transmission, repair, and feedback
        strategies discussed in that document. The reliable multicast building
        block approach, as described in <a class='info' href='#RFC3048'>Reliable
        Multicast Transport Building Blocks for One-to-Many Bulk-Data
        Transfer<span> (</span><span class='info'>Whetten, B., Vicisano, L., Kermode, R., Handley, M., Floyd, S., and M. Luby, &ldquo;Reliable Multicast Transport Building Blocks for One-to-Many Bulk-Data Transfer,&rdquo; January&nbsp;2001.</span><span>)</span></a> [RFC3048], is applied in creating the full NORM protocol
        instantiation. NORM also makes use of the parity-based encoding
        techniques for repair messaging and optional transmission robustness
        as described in <a class='info' href='#RFC3453'>The Use of Forward Error
        Correction (FEC) in Reliable Multicast<span> (</span><span class='info'>Luby, M., Vicisano, L., Gemmell, J., Rizzo, L., Handley, M., and J. Crowcroft, &ldquo;The Use of Forward Error Correction (FEC) in Reliable Multicast,&rdquo; December&nbsp;2002.</span><span>)</span></a> [RFC3453]. NORM uses the FEC
        Payload ID as specified by the <a class='info' href='#RFC5052'>FEC Building
        Block document<span> (</span><span class='info'>Watson, M., Luby, M., and L. Vicisano, &ldquo;Forward Error Correction (FEC) Building Block,&rdquo; August&nbsp;2007.</span><span>)</span></a> [RFC5052]. Additionally, for congestion control, this
        document fully specifies a baseline congestion control mechanism
        (NORM-CC) based on the TCP-Friendly Multicast Congestion Control
        (TFMCC) scheme<a class='info' href='#TfmccPaper'>[TfmccPaper]<span> (</span><span class='info'>Widmer, J. and M. Handley, &ldquo;Extending Equation-Based Congestion Control to Multicast           Applications,&rdquo; August&nbsp;2001.</span><span>)</span></a>, <a class='info' href='#RFC4654'>[RFC4654]<span> (</span><span class='info'>Widmer, J. and M. Handley, &ldquo;TCP-Friendly Multicast Congestion Control (TFMCC): Protocol Specification,&rdquo; August&nbsp;2006.</span><span>)</span></a>.
</p>
<a name="anchor8"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2.3"></a><h3>2.3.&nbsp;
Design Tradeoffs</h3>

<p>While the various features of NORM are designed to provide some
        measure of general purpose utility, it is important to emphasize the
        understanding that "no one size fits all" in the reliable multicast
        transport arena. There are numerous engineering trade-offs involved in
        reliable multicast transport design and this requires an increased
        awareness of application and network architecture considerations.
        Performance requirements affecting design can include: group size,
        heterogeneity (e.g., capacity and/or delay), asymmetric delivery, data
        ordering, delivery delay, group dynamics, mobility, congestion
        control, and transport across low capacity connections. NORM contains
        various parameters to accommodate many of these differing
        requirements. The NORM protocol and its mechanisms MAY be applied in
        multicast applications outside of bulk data transfer, but there is an
        assumed model of bulk transfer transport service that drives the
        trade-offs that determine the scalability and performance described in
        this document.
</p>
<p>The ability of NORM to provide reliable data delivery is also
        governed by any buffer constraints of the sender and receiver
        applications. NORM protocol implementations SHOULD be designed to
        operate with the greatest efficiency and robustness possible within
        application-defined buffer constraints. Buffer requirements for
        reliability, as always, are a function of the delay-bandwidth product
        of the network topology. NORM performs best when allowed more
        buffering resources than typical point-to-point transport protocols.
        This is because NORM feedback suppression is based upon
        randomly-delayed transmissions from the receiver set, rather than
        immediately transmitted feedback. There are definitive trade-offs
        between buffer utilization, group size scalability, and efficiency of
        performance. Large buffer sizes allow the NORM protocol to perform
        most efficiently in large delay-bandwidth topologies and allow for
        longer feedback suppression backoff timeouts. This yields improved
        group size scalability. NORM can operate with reduced buffering but at
        a cost of decreased efficiency (lower relative goodput) and reduced
        group size scalability.
</p>
<a name="anchor9"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3"></a><h3>3.&nbsp;
Conformance Statement</h3>

<p>This RMT Protocol Instantiation document, in conjunction with the
      <a class='info' href='#RFC5401'>Multicast Negative-Acknowledgment (NACK)<span> (</span><span class='info'>Adamson, B., Bormann, C., Handley, M., and J. Macker, &ldquo;Multicast Negative-Acknowledgment (NACK) Building Blocks,&rdquo; November&nbsp;2008.</span><span>)</span></a> [RFC5401]
      and <a class='info' href='#RFC5052'>Forward Error Correction (FEC)<span> (</span><span class='info'>Watson, M., Luby, M., and L. Vicisano, &ldquo;Forward Error Correction (FEC) Building Block,&rdquo; August&nbsp;2007.</span><span>)</span></a> [RFC5052]
      Building Blocks, completely specifies a working reliable multicast
      transport protocol that conforms to the requirements described in <a class='info' href='#RFC2357'>RFC 2357<span> (</span><span class='info'>Mankin, A., Romanov, A., Bradner, S., and V. Paxson, &ldquo;IETF Criteria for Evaluating Reliable Multicast Transport and Application Protocols,&rdquo; June&nbsp;1998.</span><span>)</span></a>.
</p>
<p>This document specifies the following message types and mechanisms
      which are REQUIRED in complying NORM protocol implementations:
</p><table class="full" align="center" border="0" cellpadding="2" cellspacing="2">
<col align="left"><col align="left">
<tr><th align="left">Message Type</th><th align="left">Purpose</th></tr>
<tr>
<td align="left"><tt>NORM_DATA</tt>&nbsp;</td>
<td align="left">Sender message for application data transmission. Implementations
        must support at least one of the <tt>NORM_OBJECT_DATA</tt>,
        <tt>NORM_OBJECT_FILE</tt>, or <tt>NORM_OBJECT_STREAM</tt>
        delivery services. The use of the NORM FEC Object Transmission
        Information header extension is OPTIONAL with <tt>NORM_DATA</tt>
        messages.</td>
</tr>
<tr>
<td align="left"><tt>NORM_CMD(FLUSH)</tt>&nbsp;</td>
<td align="left">Sender command to excite receivers for repair requests in lieu of
        ongoing <tt>NORM_DATA</tt> transmissions. Note the
        use of the <tt>NORM_CMD(FLUSH)</tt> for positive
        acknowledgment of data receipt is OPTIONAL.</td>
</tr>
<tr>
<td align="left"><tt>NORM_CMD(SQUELCH)</tt>&nbsp;</td>
<td align="left">Sender command to advertise its current valid repair window in
        response to invalid requests for repair.</td>
</tr>
<tr>
<td align="left"><tt>NORM_CMD(REPAIR_ADV)</tt>&nbsp;</td>
<td align="left">Sender command to advertise current repair (and congestion control
        state) to group when unicast feedback messages are detected. Used to
        control/suppress excessive receiver feedback in asymmetric multicast
        topologies.</td>
</tr>
<tr>
<td align="left"><tt>NORM_CMD(CC)</tt>&nbsp;</td>
<td align="left">Sender command used in collection of round trip timing and
        congestion control status from group (this may be OPTIONAL if
        alternative congestion control mechanism and round trip timing
        collection is used).</td>
</tr>
<tr>
<td align="left"><tt>NORM_NACK</tt>&nbsp;</td>
<td align="left">Receiver message used to request repair of missing transmitted
        content.</td>
</tr>
<tr>
<td align="left"><tt>NORM_ACK</tt>&nbsp;</td>
<td align="left">Receiver message used to proactively provide feedback for
        congestion control purposes. Also used with the OPTIONAL NORM Positive
        Acknowledgment Process.</td>
</tr>
</table>
<br clear="all" />

<p>This document also describes the following message types and
      associated mechanisms which are OPTIONAL for complying NORM protocol
      implementations:
</p><table class="full" align="center" border="0" cellpadding="2" cellspacing="2">
<col align="left"><col align="left">
<tr><th align="left">Message Type</th><th align="left">Purpose</th></tr>
<tr>
<td align="left"><tt>NORM_INFO</tt>&nbsp;</td>
<td align="left">Sender message for providing ancillary context information
        associated with NORM transport objects. The use of the NORM FEC Object
        Transmission Information header extension is OPTIONAL with <tt>NORM_INFO</tt> messages.</td>
</tr>
<tr>
<td align="left"><tt>NORM_CMD(EOT)</tt>&nbsp;</td>
<td align="left">Sender command to indicate it has reached end-of-transmission and
        will no longer respond to repair requests.</td>
</tr>
<tr>
<td align="left"><tt>NORM_CMD(ACK_REQ)</tt>&nbsp;</td>
<td align="left">Sender command to support application-defined, positively
        acknowledged commands sent outside of the context of the bulk data
        content being transmitted. The NORM Positive Acknowledgment Procedure
        associated with this message type is OPTIONAL.</td>
</tr>
<tr>
<td align="left"><tt>NORM_CMD(APPLICATION)</tt>&nbsp;</td>
<td align="left">Sender command containing application-defined commands sent outside
        of the context of the bulk data content being transmitted.</td>
</tr>
<tr>
<td align="left"><tt>NORM_REPORT</tt>&nbsp;</td>
<td align="left">Optional message type reserved for experimental implementations of
        the NORM protocol.</td>
</tr>
</table>
<br clear="all" />

<a name="anchor10"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4"></a><h3>4.&nbsp;
Message Formats</h3>

<p>As mentioned in <a class='info' href='#ProtocolOverview'>Section&nbsp;2.1<span> (</span><span class='info'>Protocol Operation Overview</span><span>)</span></a>, there are
      two primary classes of NORM messages: sender messages and receiver
      messages. <tt>NORM_CMD</tt>, <tt>NORM_INFO</tt>,
      and <tt>NORM_DATA</tt> message types are generated by
      senders of data content, and <tt>NORM_NACK</tt> and
      <tt>NORM_ACK</tt> messages generated by receivers
      within a <em>NormSession</em>. Sender messages SHOULD
      be governed by congestion control for Internet use. For session
      management or other purposes, receivers may wish to employ <tt>NORM_CMD</tt> message transmissions. The principal
      rationale for distinguishing sender and receiver messages is that
      receivers will typically need to allocate resources to support reliable
      reception from sender(s) and NORM sender messages are subject to
      congestion control. NORM receivers MAY employ the <tt>NORM_CMD</tt>
      message type for application-defined purposes but it is RECOMMENDED that
      congestion control and feedback implosion issues be addressed.
      Additionally, an auxiliary message type of <tt>NORM_REPORT</tt>
      is also provided for experimental purposes. This section describes the
      message formats used by the NORM protocol. These messages and their
      fields are referenced in the detailed functional description of the NORM
      protocol given in <a class='info' href='#ProtocolDetails'>Section&nbsp;5<span> (</span><span class='info'>Detailed Protocol Operation</span><span>)</span></a>. Individual
      NORM messages are designed to be compatible with the MTU limitations of
      encapsulating Internet protocols including IPv4, IPv6, and UDP. The
      current NORM protocol specification assumes UDP encapsulation and
      leverages the transport features of UDP. The NORM messages are
      independent of network addresses and can be used in IPv4 and IPv6
      networks.
</p>
<a name="CommonHeader"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.1"></a><h3>4.1.&nbsp;
NORM Common Message Header and Extensions</h3>

<p>There are some common message fields contained in all NORM message
        types. Additionally, a header extension mechanism is defined to expand
        the functionality of the NORM protocol without revision to this
        document. All NORM protocol messages begin with a common header with
        information fields as follows:
</p><br /><hr class="insert" />
<div style='display: table; width: 0; margin-left: auto; margin-right: auto'><pre> 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|version|  type |    hdr_len    |          sequence             |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                           source_id                           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;NORM Common Message Header Format&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>The "version" field is a 4-bit value indicating the protocol
        version number. NORM implementations SHOULD ignore received messages
        with version numbers different from their own. This number is intended
        to indicate and distinguish upgrades of the protocol which may be
        non-interoperable. The NORM version number for this specification is
        1.
</p>
<p>The message "type" field is a 4-bit value indicating the NORM
        protocol message type. These types are defined as follows:
</p><table class="full" align="center" border="0" cellpadding="2" cellspacing="2">
<col align="left"><col align="left">
<tr><th align="left">Message</th><th align="left">Value</th></tr>
<tr>
<td align="left"><tt>NORM_INFO</tt>&nbsp;</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left"><tt>NORM_DATA</tt>&nbsp;</td>
<td align="left">2</td>
</tr>
<tr>
<td align="left"><tt>NORM_CMD</tt>&nbsp;</td>
<td align="left">3</td>
</tr>
<tr>
<td align="left"><tt>NORM_NACK</tt>&nbsp;</td>
<td align="left">4</td>
</tr>
<tr>
<td align="left"><tt>NORM_ACK</tt>&nbsp;</td>
<td align="left">5</td>
</tr>
<tr>
<td align="left"><tt>NORM_REPORT</tt>&nbsp;</td>
<td align="left">6</td>
</tr>
</table>
<br clear="all" />

<p>The 8-bit "hdr_len" field indicates the number of 32-bit words that
        comprise the given message's header portion. This is used to
        facilitate header extensions that may be applied. The presence of
        header extensions are implied when the "hdr_len" value is greater than
        the base value for the given message "type".
</p>
<p>The "sequence" field is a 16-bit value that is set by the message
        originator. The "sequence" field serves two separate purposes,
        depending upon the message type:</p>
<ol class="text">
<li>NORM senders MUST set the "sequence" field of sender messages
            (<tt>NORM_INFO</tt>, <tt>NORM_DATA</tt>,
            and <tt>NORM_CMD</tt>) so that receivers can
            monitor the "sequence" value to maintain an estimate of packet
            loss that can be used for congestion control purposes (See <a class='info' href='#CongestionControl'>Section&nbsp;5.5.2<span> (</span><span class='info'>NORM Congestion Control Operation</span><span>)</span></a> for a detailed description of
            NORM Congestion Control operation). A monotonically-increasing
            sequence number space MUST be maintained to mark NORM sender
            messages in this way. Note that this "sequence" number is
            explicitly NOT used in NORM as part of its reliability procedures.
            The NORM object and FEC payload identifiers are used to detect
            missing content for reliable transfer purposes.
</li>
<li>NORM receivers SHOULD set the "sequence" field to support
            protection from message replay attacks of <tt>NORM_NACK</tt>
            or <tt>NORM_NACK</tt> messages. Note that,
            depending upon configuration, NORM feedback messages may be sent
            to the session multicast address or unicast address[es] of the
            active NORM sender[s]. Thus, a separate, monotonically-increasing
            sequence number space MUST be maintained for each destination
            address to which the NORM receiver is transmitting feedback
            messages.
</li>
</ol>

<p>Note that these two separate purposes necessitate the maintenance
        of separate sequence spaces to support the functions described here.
        And, in the case of NORM receivers, additional sequence spaces are
        needed when feedback messages are sent to the sender unicast
        address[es] instead of the session address.
</p>
<p>The "source_id" field is a 32-bit value that uniquely identifies
        the node that sent the message within the context of a single <em>NormSession</em>. This value is termed the NORM node
        identifier (<em>NormNodeId</em>) and unique <em>NormNodeId</em> identifiers MUST be assigned within a
        single <em>NormSession</em>. In some cases, use of
        the host IP address or a hash of it can suffice, but alternative
        methodologies for assignment and potential collision resolution of
        node identifiers within a multicast session SHOULD be considered. For
        example, the techniques for managing the 32-bit "synchronization
        source" (SSRC) identifiers defined in the Real-Time Protocol (RTP)
        specification <a class='info' href='#RFC3550'>[RFC3550]<span> (</span><span class='info'>Schulzrinne, H., Casner, S., Frederick, R., and V. Jacobson, &ldquo;RTP: A Transport Protocol for Real-Time Applications,&rdquo; July&nbsp;2003.</span><span>)</span></a> are applicable for use
        with NORM node identifiers. In most deployments of the NORM protocol
        to date, the <em>NormNodeId</em> assignments are
        administratively configured.
</p>
<p><strong>NORM Header Extensions</strong>
</p>
<p>When header extensions are applied, they follow the message type's
        base header and precede any payload portion. There are two formats for
        header extensions, both of which begin with an 8-bit "het" (header
        extension type) field. One format is provided for variable-length
        extensions with "het" values in the range from 0 through 127. The
        other format is for fixed length (one 32-bit word) extensions with
        "het" values in the range from 128 through 255. These formats are
        given here:
</p><br /><hr class="insert" />
<div style='display: table; width: 0; margin-left: auto; margin-right: auto'><pre> 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|   het &lt;=127   |      hel      |                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+                               |
|                    Header Extension Content                   |
|                              ...                              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;NORM Variable Length Header Extension Format&nbsp;</b></font><br /></td></tr></table><hr class="insert" />
<br /><hr class="insert" />
<div style='display: table; width: 0; margin-left: auto; margin-right: auto'><pre> 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|   het &gt;=128   |    reserved   |    Header Extension Content   |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;NORM Fixed Length (32-bit) Header Extension Format&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>The "Header Extension Content" portion of the header extension is
        defined for each extension type. Some header extensions are defined
        within this document for NORM baseline FEC and congestion control
        operations.
</p>
<a name="anchor11"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.2"></a><h3>4.2.&nbsp;
Sender Messages</h3>

<p>NORM sender messages include the <tt>NORM_DATA</tt>
        type, the <tt>NORM_INFO</tt> type, and the <tt>NORM_CMD</tt> type. <tt>NORM_DATA</tt>
        and <tt>NORM_INFO</tt> messages contain application
        data content while <tt>NORM_CMD</tt> messages are
        used for various protocol control functions.
</p>
<a name="anchor12"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.2.1"></a><h3>4.2.1.&nbsp;
NORM_DATA Message</h3>

<p>The <tt>NORM_DATA</tt> message is expected to
          be the predominant type transmitted by NORM senders. These messages
          are used to encapsulate segmented data content for objects of type
          <tt>NORM_OBJECT_DATA</tt>, <tt>NORM_OBJECT_FILE</tt>,
          and <tt>NORM_OBJECT_STREAM</tt>. <tt>NORM_DATA</tt> messages may contain original or
          FEC-encoded application data content.
</p>
<p>The format of <tt>NORM_DATA</tt> messages is
          comprised of three logical portions: 1) a fixed-format <tt>NORM_DATA</tt> header portion, 2) a FEC Payload ID
          portion with a format dependent upon the FEC encoding used, and 3) a
          payload portion containing source or encoded application data
          content. Note for objects of type <tt>NORM_OBJECT_STREAM</tt>,
          the payload portion contains additional fields used to appropriately
          recover stream content. NORM implementations MAY also extend the
          <tt>NORM_DATA</tt> header to include a FEC Object
          Transmission Information (EXT_FTI) header extension. This allows
          NORM receivers to automatically allocate resources and properly
          perform FEC decoding without the need for pre-configuration or
          out-of-band information.
</p><br /><hr class="insert" />
<div style='display: table; width: 0; margin-left: auto; margin-right: auto'><pre> 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|version| type=2|    hdr_len    |          sequence             |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                           source_id                           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|          instance_id          |     grtt      |backoff| gsize |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|     flags     |    fec_id     |     object_transport_id       |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                         fec_payload_id                        |
|                              ...                              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                header_extensions (if applicable)              |
|                              ...                              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|          payload_len*         |       payload_msg_start*      |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                        payload_offset*                        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                          payload_data*                        |
|                              ...                              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;NORM_DATA Message Format&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>*IMPORTANT NOTE: The "payload_len", "payload_msg_start" and
          "payload_offset" fields are present ONLY for objects of type <tt>NORM_OBJECT_STREAM</tt>. These fields, as with the
          entire payload, are subject to any FEC encoding used. Thus, when
          systematic FEC codes are used, these values may be directly
          interpreted for packets containing source symbols only while packets
          containing FEC parity content require decoding before these fields
          can be interpreted.
</p>
<p>The "version", "type", "hdr_len", "sequence", and "source_id"
          fields form the NORM Common Message Header as described in <a class='info' href='#CommonHeader'>Section&nbsp;4.1<span> (</span><span class='info'>NORM Common Message Header and Extensions</span><span>)</span></a>. The value of the <tt>NORM_DATA</tt>
          "type" field is 2. The <tt>NORM_DATA</tt> base
          "hdr_len" value is 4 (i.e. 4 32-bit words) plus the size of the
          "fec_payload_id" field. The "fec_payload_id" field size depends upon
          the FEC encoding type referenced by the "fec_id" field. For example,
          when small block, systematic codes are used, a "fec_id" value of 129
          is indicated and the size of the "fec_payload_id" is two 32-bit
          words. In this case the <tt>NORM_DATA</tt> base
          "hdr_len" value is 6. The cumulative size of any header extensions
          applied is added into the "hdr_len" field.
</p>
<p>The "instance_id" field contains a value generated by the sender
          to uniquely identify its current instance of participation in the
          <em>NormSession</em>. This allows receivers to
          detect when senders have perhaps left and rejoined a session in
          progress. When a sender (identified by its "source_id") is detected
          to have a new "instance_id", the NORM receivers SHOULD drop their
          previous state on the sender and begin reception anew, or at least
          treat this "instance" as a new, separate sender.
</p>
<p>The "grtt" field contains a non-linear quantized representation
          of the sender's current estimate of group round-trip time (GRTT)
          (this is also referred to as <tt>R_max</tt> in
          <a class='info' href='#TfmccPaper'>[TfmccPaper]<span> (</span><span class='info'>Widmer, J. and M. Handley, &ldquo;Extending Equation-Based Congestion Control to Multicast           Applications,&rdquo; August&nbsp;2001.</span><span>)</span></a>). This value is used to control
          timing of the NACK repair process and other aspects of protocol
          operation as described in this document. Normally, the advertised
          "grtt" value will correspond to what the sender has measured based
          on feedback from the group, but, at low transmission rates, the
          advertised "grtt" SHALL be set to <tt>MAX(grttMeasured, NormSegmentSize/senderRate)</tt>
          where the <tt>NormSegmentSize</tt> is sender's
          segment size in bytes and the <tt>senderRate</tt>
          is the sender's current transmission rate in bytes per second. The
          algorithm for encoding and decoding this field is described in the
          <a class='info' href='#RFC5401'>Multicast NACK Building Block<span> (</span><span class='info'>Adamson, B., Bormann, C., Handley, M., and J. Macker, &ldquo;Multicast Negative-Acknowledgment (NACK) Building Blocks,&rdquo; November&nbsp;2008.</span><span>)</span></a> [RFC5401].
</p>
<p>The "backoff" field value is used by receivers to determine the
          maximum backoff timer value used in the timer-based NORM NACK
          feedback suppression. This 4-bit field supports values from 0-15
          which is multiplied by the sender GRTT to determine the maximum
          backoff timeout. The "backoff" field informs the receivers of the
          sender's backoff factor parameter <tt>Ksender</tt>.
          Recommended values and their use are described in the NORM receiver
          NACK procedure description in <a class='info' href='#NackProcedure'>Section&nbsp;5.3<span> (</span><span class='info'>Receiver NACK Procedure</span><span>)</span></a>.
</p>
<p>The "gsize" field contains a representation of the sender's
          current estimate of group size. This 4-bit field can roughly
          represent values from ten to 500 million where the most significant
          bit value of 0 or 1 represents a mantissa of 1 or 5, respectively
          and the three least significant bits incremented by one represent a
          base 10 exponent (order of magnitude). For examples, a field value
          of "0x0" represents 1.0e+01 (10), a value of "0x8" represents
          5.0e+01 (50), a value of "0x1" represents 1.0e+02 (100), and a value
          of "0xf" represents 5.0e+08. For NORM feedback suppression purposes,
          the group size does not need to be represented with a high degree of
          precision. The group size may even be estimated somewhat
          conservatively (i.e., overestimated) to maintain low levels of
          feedback traffic. A default group size estimate of 10,000 ("gsize" =
          0x3) is recommended for general purpose reliable multicast
          applications using the NORM protocol.
</p>
<p>The "flags" field contains a number of different binary flags
          providing information and hints regarding how the receiver should
          handle the identified object. Defined flags in this field
          include:
</p><table class="full" align="center" border="0" cellpadding="2" cellspacing="2">
<col align="left"><col align="left"><col align="left">
<tr><th align="left">Flag</th><th align="left">Value</th><th align="left">Purpose</th></tr>
<tr>
<td align="left"><tt>NORM_FLAG_REPAIR</tt>&nbsp;</td>
<td align="left">0x01</td>
<td align="left">Indicates message is a repair transmission</td>
</tr>
<tr>
<td align="left"><tt>NORM_FLAG_EXPLICIT</tt>&nbsp;</td>
<td align="left">0x02</td>
<td align="left">Indicates a repair segment intended to meet a specific receiver
            erasure, as compared to parity segments provided by the sender for
            general purpose (with respect to an FEC coding block) erasure
            filling.</td>
</tr>
<tr>
<td align="left"><tt>NORM_FLAG_INFO</tt>&nbsp;</td>
<td align="left">0x04</td>
<td align="left">Indicates availability of <tt>NORM_INFO</tt>
            for object.</td>
</tr>
<tr>
<td align="left"><tt>NORM_FLAG_UNRELIABLE</tt>&nbsp;</td>
<td align="left">0x08</td>
<td align="left">Indicates that repair transmissions for the specified object
            will be unavailable (One-shot, best effort transmission).</td>
</tr>
<tr>
<td align="left"><tt>NORM_FLAG_FILE</tt>&nbsp;</td>
<td align="left">0x10</td>
<td align="left">Indicates object is file-based data (hint to use disk storage
            for reception).</td>
</tr>
<tr>
<td align="left"><tt>NORM_FLAG_STREAM</tt>&nbsp;</td>
<td align="left">0x20</td>
<td align="left">Indicates object is of type <tt>NORM_OBJECT_STREAM</tt>.</td>
</tr>
</table>
<br clear="all" />

<p><tt>NORM_FLAG_REPAIR</tt> is set when the
          associated message is a repair transmission. This information can be
          used by receivers to help observe a join policy where it is desired
          that newly joining receivers only begin participating in the NACK
          process upon receipt of new (non-repair) data content. <tt>NORM_FLAG_EXPLICIT</tt> is used to mark repair
          messages sent when the data sender has exhausted its ability to
          provide "fresh" (not previously transmitted) parity segments as
          repair. This flag could possibly be used by intermediate systems
          implementing functionality to control sub-casting of repair content
          to different legs of a reliable multicast topology with disparate
          repair needs. <tt>NORM_FLAG_INFO</tt> is set only
          when optional <tt>NORM_INFO</tt> content is
          actually available for the associated object. Thus, receivers will
          NACK for retransmission of <tt>NORM_INFO</tt>
          only when it is available for a given object. <tt>NORM_FLAG_UNRELIABLE</tt>
          is set when the sender wishes to transmit an object with only "best
          effort" delivery and will not supply repair transmissions for the
          object. NORM receivers SHOULD NOT execute repair requests for
          objects marked with the <tt>NORM_FLAG_UNRELIABLE</tt>
          flag. Note that receivers may inadvertently request repair of such
          objects when all segments (or info content) for those objects are
          not received (i.e., a gap in the "object_transport_id" sequence is
          noted). In this case, the sender should invoke the <tt>NORM_CMD(SQUELCH)</tt> process as described in <a class='info' href='#NORM_CMD'>Section&nbsp;4.2.3<span> (</span><span class='info'>NORM_CMD Messages</span><span>)</span></a>.
</p>
<p><tt>NORM_FLAG_FILE</tt> can be set as a hint
          from the sender that the associated object should be stored in
          non-volatile storage. <tt>NORM_FLAG_STREAM</tt>
          is set when the identified object is of type <tt>NORM_OBJECT_STREAM</tt>.
          The presence of <tt>NORM_FLAG_STREAM</tt>
          overrides that of <tt>NORM_FLAG_FILE</tt> with
          respect to interpretation of object size and the format of <tt>NORM_DATA</tt> messages.
</p>
<p>The "fec_id" field corresponds to the FEC Encoding Identifier
          described in the FEC Building Block document <a class='info' href='#RFC5052'>[RFC5052]<span> (</span><span class='info'>Watson, M., Luby, M., and L. Vicisano, &ldquo;Forward Error Correction (FEC) Building Block,&rdquo; August&nbsp;2007.</span><span>)</span></a>. The "fec_id" value implies the format of
          the "fec_payload_id" field and, coupled with FEC Object Transmission
          Information, the procedures to decode FEC encoded content. Small
          block, systematic codes ("fec_id" = 129) are expected to be used for
          most NORM purposes and the <tt>NORM_OBJECT_STREAM</tt>
          requires systematic FEC codes for most efficient performance.
</p>
<p>The "object_transport_id" field is a monotonically and
          incrementally increasing value assigned by the sender to <em>NormObjects</em> being transmitted. Transmissions
          and repair requests related to that object use the same
          "object_transport_id" value. For sessions of very long or indefinite
          duration, the "object_transport_id" field may be repeated, but it is
          presumed that the 16-bit field size provides an adequate enough
          sequence space to avoid object confusion amongst receivers and
          sources (i.e., receivers SHOULD re-synchronize with a server when
          receiving object sequence identifiers sufficiently out-of-range with
          the current state kept for a given source). During the course of its
          transmission within a NORM session, an object is uniquely identified
          by the concatenation of the sender "source_id" and the given
          "object_transport_id". Note that <tt>NORM_INFO</tt>
          messages associated with the identified object carry the same
          "object_transport_id" value.
</p>
<p>The "fec_payload_id" identifies the attached <tt>NORM_DATA</tt>
          "payload" content. The size and format of the "fec_payload_id" field
          depends upon the FEC type indicated by the "fec_id" field. These
          formats are given in the descriptions of specific FEC schemes such
          as those described in the <a class='info' href='#RFC5445'>FEC Basic
          Schemes<span> (</span><span class='info'>Watson, M., &ldquo;Basic Forward Error Correction (FEC) Schemes,&rdquo; March&nbsp;2009.</span><span>)</span></a> [RFC5445] specification or in other FEC Schemes. As an example,
          the format of the "fec_payload_id" format for Small Block,
          Systematic codes ("fec_id" = 129) from the<a class='info' href='#RFC5445'>FEC Basic Schemes<span> (</span><span class='info'>Watson, M., &ldquo;Basic Forward Error Correction (FEC) Schemes,&rdquo; March&nbsp;2009.</span><span>)</span></a> [RFC5445] specification is given here:
</p><br /><hr class="insert" />
<div style='display: table; width: 0; margin-left: auto; margin-right: auto'><pre> 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                       source_block_number                     |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|        source_block_len       |      encoding_symbol_id       |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Example: FEC Payload Id Format for 'fec_id' = 129&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>In this example FEC payload identifier, the
          "source_block_number", "source_block_len", and "encoding_symbol_id"
          fields correspond to the "Source Block Number", "Source Block
          Length, and "Encoding Symbol ID" fields of the FEC Payload ID format
          for Small Block Systematic FEC Schemes identified by a "fec_id"
          value of 129 as specified by the <a class='info' href='#RFC5445'>FEC Basic
          Schemes<span> (</span><span class='info'>Watson, M., &ldquo;Basic Forward Error Correction (FEC) Schemes,&rdquo; March&nbsp;2009.</span><span>)</span></a> [RFC5445] specification. The "source_block_number" identifies
          the coding block's relative position with a <em>NormObject</em>.
          Note that, for <em>NormObjects</em> of type
          <tt>NORM_OBJECT_STREAM</tt>, the
          "source_block_number" may wrap for very long lived sessions. The
          "source_block_len" indicates the number of user data segments in the
          identified coding block. Given the "source_block_len" information of
          how many symbols of application data are contained in the block, the
          receiver can determine whether the attached segment is data or
          parity content and treat it appropriately. Some applications may
          dynamically "shorten" code blocks when the pending information
          content is not predictable (e.g. real-time message streams). In that
          case, the "source_block_len" value given for an "encoding_symbol_id"
          that contains FEC parity content SHALL take precedence over the
          "source_block_len" value provided for any packets containing source
          symbols. Also, the "source_block_len" value given for an ordinally
          higher "encoding_symbol_id" SHALL take precedence over the
          "source_block_len" given for prior encoding symbols. The reason for
          this is that the sender may only know the maximum source block
          length at the time is transmitting source symbols, but then
          subsequently "shorten" the code and then provide that last source
          symbol and/or encoding symbols with FEC parity content. The
          "encoding_symbol_id" identifies which specific symbol (segment)
          within the coding block the attached payload conveys. Depending upon
          the value of the "encoding_symbol_id" and the associated
          "source_block_len" parameters for the block, the symbol (segment)
          referenced may be a user data or an FEC parity segment. For
          systematic codes, encoding symbols numbered less than the <tt>source_block_len</tt> contain original application
          data while segments greater than or equal to <tt>source_block_len</tt>
          contain parity symbols calculated for the block. The concatenation
          of <tt>object_transport_id::fec_payload_id</tt>
          can be viewed as a unique transport protocol data unit identifier
          for the attached segment with respect to the NORM sender's instance
          within a session.
</p>
<p>Additional FEC Object Transmission Information (FTI) (as
          described in the <a class='info' href='#RFC5052'>FEC Building Block<span> (</span><span class='info'>Watson, M., Luby, M., and L. Vicisano, &ldquo;Forward Error Correction (FEC) Building Block,&rdquo; August&nbsp;2007.</span><span>)</span></a> [RFC5052])
          is required to properly receive and decode NORM transport objects.
          This information MAY be provided as out-of-band session information.
          However, in some cases, it may be useful for the sender to include
          this information "in-band" to facilitate receiver operation with
          minimal pre-configuration. For this purpose, the NORM FEC Object
          Transmission Information Header Extension (EXT_FTI) is defined. This
          header extension MAY be applied to <tt>NORM_DATA</tt>
          and <tt>NORM_INFO</tt> messages to provide this
          necessary information. The format of the EXT_FTI consists of two
          parts, a general part that contains the size of the associated
          transport object and a portion that depends upon the FEC scheme
          being used. The "fec_id" field in <tt>NORM_DATA</tt>
          and <tt>NORM_INFO</tt> messages identifies the
          FEC scheme. The format of the EXT_FTI general part is given
          here.
</p><br /><hr class="insert" />
<div style='display: table; width: 0; margin-left: auto; margin-right: auto'><pre>
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|    het = 64   |    hel = 4    |       object_size (msb)       |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                       object_size (lsb)                       |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                  FEC Scheme specific content ...              |</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;EXT_FTI Header Extension General Portion Format&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>The header extension type "het" field value for the EXT_FTI
          header extension is 64. The header extension length "hel" value
          depends upon the format of the FTI for encoding type identified by
          the "fec_id" field.
</p>
<p>The 48-bit "object_size" field indicates the total length of the
          object (in bytes) for the static object types of <tt>NORM_OBJECT_FILE</tt> and <tt>NORM_OBJECT_DATA</tt>.
          This information is used by receivers to determine storage
          requirements and/or allocate storage for the received object.
          Receivers with insufficient storage capability may wish to forego
          reliable reception (i.e., not NACK for) of the indicated object. In
          the case of objects of type <tt>NORM_OBJECT_STREAM</tt>,
          the "object_size" field is used by the sender to advertise the size
          of its stream buffer to the receiver group. In turn, the receivers
          SHOULD use this information to allocate a stream buffer for
          reception of corresponding size.
</p>
<p>As noted, the format of the extension depends upon the FEC code
          in use, but in general it SHOULD contain any required details on the
          FEC code in use (e.g., FEC Instance ID, etc.). As an example, the
          format of the EXT_FTI for small block systematic codes ("fec_id" =
          129) is given here:
</p><br /><hr class="insert" />
<div style='display: table; width: 0; margin-left: auto; margin-right: auto'><pre> 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|    het = 64   |    hel = 4    |       object_size (msb)       |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                       object_size (lsb)                       |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|       fec_instance_id         |          segment_size         |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|       fec_max_block_len       |         fec_num_parity        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Example: EXT_FTI Header Extension Format for 'fec_id' = 129&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>In this example (for "fec_id" = 129), the "hel" field value is 4.
          The size of the EXT_FTI header extension may be different for other
          FEC schemes.
</p>
<p>The 48-bit "object_size" serves the purpose described
          previously.
</p>
<p>The "fec_instance_id" corresponds to the "FEC Instance ID"
          described in the <a class='info' href='#RFC5052'>FEC Building Block<span> (</span><span class='info'>Watson, M., Luby, M., and L. Vicisano, &ldquo;Forward Error Correction (FEC) Building Block,&rdquo; August&nbsp;2007.</span><span>)</span></a> [RFC5052].
          In this case, the "fec_instance_id" is a value corresponding to the
          particular type of Small Block Systematic Code being used (e.g.,
          Reed-Solomon GF(2^8), Reed-Solomon GF(2^16), etc). The standardized
          assignment of FEC Instance ID values is described in <a class='info' href='#RFC5052'>RFC 5052<span> (</span><span class='info'>Watson, M., Luby, M., and L. Vicisano, &ldquo;Forward Error Correction (FEC) Building Block,&rdquo; August&nbsp;2007.</span><span>)</span></a>.
</p>
<p>The "segment_size" field indicates the sender's current setting
          for maximum message payload content (in bytes). This allows
          receivers to allocate appropriate buffering resources and to
          determine other information in order to properly process received
          data messaging. Typically, FEC parity symbol segments will be of
          this size.
</p>
<p>The "fec_max_block_len" indicates the current maximum number of
          user data segments per FEC coding block to be used by the sender
          during the session. This allows receivers to allocate appropriate
          buffer space for buffering blocks transmitted by the sender.
</p>
<p>The "fec_num_parity" corresponds to the "maximum number of
          encoding symbols that can be generated for any source block" as
          described in for FEC Object Transmission Information for Small Block
          Systematic Codes in the <a class='info' href='#RFC5052'>FEC Building
          Block<span> (</span><span class='info'>Watson, M., Luby, M., and L. Vicisano, &ldquo;Forward Error Correction (FEC) Building Block,&rdquo; August&nbsp;2007.</span><span>)</span></a> [RFC5052]. For example, Reed-Solomon codes may be arbitrarily
          shortened to create different code variations for a given block
          length. In the case of Reed-Solomon (GF(2^8) and GF(2^16)) codes,
          this value indicates the maximum number of parity segments available
          from the sender for the coding blocks. This field MAY be interpreted
          differently for other systematic codes as they are defined.
</p>
<p>The payload portion of <tt>NORM_DATA</tt>
          messages includes source data or FEC encoded application content.
          The content of this payload depends upon the FEC scheme being
          employed, and support for streaming using the <tt>NORM_OBJECT_STREAM</tt>
          type, when applicable, necessitates some additional content in the
          payload.
</p>
<p>The "payload_len", "payload_msg_start", and "payload_offset"
          fields are present ONLY for transport objects of type <tt>NORM_OBJECT_STREAM</tt>. These fields allow senders
          to arbitrarily vary the size of <tt>NORM_DATA</tt>
          payload segments for streams. This allows applications to flush
          transmitted streams as needed to meet unique streaming requirements.
          For objects of types <tt>NORM_OBJECT_FILE</tt>
          and <tt>NORM_OBJECT_DATA</tt>, these fields are
          unnecessary since the receiver can calculate the payload length and
          offset information from the "fec_payload_id" using the REQUIRED
          block partitioning algorithm described in the <a class='info' href='#RFC5052'>FEC Building Block<span> (</span><span class='info'>Watson, M., Luby, M., and L. Vicisano, &ldquo;Forward Error Correction (FEC) Building Block,&rdquo; August&nbsp;2007.</span><span>)</span></a> [RFC5052]. When systematic FEC
          codes (e.g., "fec_id" = 129) are used, the "payload_len",
          "payload_msg_start", and "payload_offset" fields contain actual
          payload_data length, message start index (or stream control code),
          and byte offset values for the associated application stream data
          segment (the remainder of the "payload_data" field content) for
          those <tt>NORM_DATA</tt> messages containing
          source data symbols. In <tt>NORM_DATA</tt>
          messages that contain FEC parity content, these fields do not
          contain values that can be directly interpreted, but instead are
          values computed from FEC encoding the "payload_len",
          "payload_msg_start", and "payload_offset" fields for the source data
          segments of the corresponding coding block. The actual
          "payload_msg_start", "payload_len" and "payload_offset" values of
          missing data content can be determined upon decoding a FEC coding
          block. Note that these fields do NOT contribute to the value of the
          <tt>NORM_DATA</tt> "hdr_len" field. These fields
          are present only when the "flags" portion of the <tt>NORM_DATA</tt> message indicate the transport object
          is of type <tt>NORM_OBJECT_STREAM</tt>.
</p>
<p>The "payload_len" value, when non-zero, indicates the length (in
          bytes) of the source content contained in the associated
          "payload_data" field. However, when the "payload_len" value is equal
          to ZERO, this indicates that the "payload_msg_start" field should be
          alternatively interpreted as a "stream_control_code". The only
          "stream_control_code" value defined is <tt>NORM_STREAM_END = 0</tt>.
          The <tt>NORM_STREAM_END</tt> code indicates that
          the sender is terminating transmission of stream content at the
          corresponding position in the stream and the receiver should not
          expect content (or NACK for any content) following that position in
          the stream. It is expected that additional specifications may extend
          the functionality of the NORM stream transport mode by defining
          additional stream control codes. These control codes are delivered
          to the recipient application reliably, in-order with respect to the
          streamed application data content.
</p>
<p>The "payload_msg_start" field serves one of two exclusive
          purposes. When the "payload_len" value is non-zero, the
          "payload_msg_start" field, when also set to a non-zero value,
          indicates that the associated "payload_data" content contains an
          application-defined message boundary (start-of-message). When such a
          message boundary is indicated, the first byte of an
          application-defined message, with respect to the "payload_data"
          field, will be found at an offset of "payload_msg_start - 1" bytes.
          Thus, if a <tt>NORM_DATA</tt> payload for a
          <tt>NORM_OBJECT_STREAM</tt> contains the start of
          an application message at the first byte of the "payload_data"
          field, the value of the "payload_msg_start" field will be '1'. NORM
          implementations SHOULD provide sender stream applications with a
          capability to mark message boundaries in this manner. Similarly, the
          NORM receiver implementation SHOULD enable the application to
          recover such message boundary information. This enables NORM
          receivers to "synchronize" reliable reception of transmitted message
          stream content in a meaningful way (i.e., meaningful to the
          application) at any time, whether joining a session already in
          progress, or departing the session and returning. Note that if the
          value of the "payload_msg_start" field is ZERO, no message boundary
          is present. The "payload_msg_start" value will always be less than
          or equal to the "payload_len" value except for the special case of
          "payload_len = 0", that indicates the "payload_msg_start" field
          should instead be interpreted as a "stream_control_code"
</p>
<p>The "payload_offset" field indicates the relative byte position
          (from the sender stream transmission start) of the source content
          contained in the "payload_data" field. Note that for long-lived
          streams, the "payload_offset" field may wrap.
</p>
<p>The "payload_data" field contains the original application source
          or parity content for the symbol identified by the "fec_payload_id".
          The length of this field SHALL be limited to a maximum of the
          sender's <em>NormSegmentSize</em> bytes as given
          in the FTI for the object. Note the length of this field for
          messages containing parity content will always be of length <em>NormSegmentSize</em>. When encoding data segments of
          varying sizes, the FEC encoder SHALL assume ZERO value padding for
          data segments with length less than the <em>NormSegmentSize</em>.
          It is RECOMMENDED that a sender's <em>NormSegmentSize</em>
          generally be constant for the duration of a given sender's term of
          participation in the session, but may possibly vary on a per-object
          basis. The <em>NormSegmentSize</em> is expected
          to be configurable by the sender application prior to session
          participation as needed for network topology maximum transmission
          unit (MTU) considerations. For IPv6, MTU discovery may be possibly
          leveraged at session startup to perform this configuration. The
          "payload_data" content may be delivered directly to the application
          for source symbols (when systematic FEC encoding is used) or upon
          decoding of the FEC block. For <tt>NORM_OBJECT_FILE</tt>
          and <tt>NORM_OBJECT_STREAM</tt> objects, the data
          segment length and offset can be calculated using the block
          partitioning algorithm described in the <a class='info' href='#RFC5052'>FEC
          Building Block<span> (</span><span class='info'>Watson, M., Luby, M., and L. Vicisano, &ldquo;Forward Error Correction (FEC) Building Block,&rdquo; August&nbsp;2007.</span><span>)</span></a> [RFC5052]. For <tt>NORM_OBJECT_STREAM</tt>
          objects, the length and offset is obtained from the segment's
          corresponding embedded "payload_len" and "payload_offset"
          fields.
</p>
<a name="anchor13"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.2.2"></a><h3>4.2.2.&nbsp;
NORM_INFO Message</h3>

<p>The <tt>NORM_INFO</tt> message is used to
          convey OPTIONAL, application-defined, out-of-band context
          information for transmitted <em>NormObjects</em>.
          An example <tt>NORM_INFO</tt> use for bulk file
          transfer is to place MIME type information for the associated file,
          data, or stream object into the <tt>NORM_INFO</tt>
          payload. Receivers may use the <tt>NORM_INFO</tt>
          content to make a decision as whether to participate in reliable
          reception of the associated object. Each <em>NormObject</em>
          can have an independent unit of <tt>NORM_INFO</tt>
          associated with it. <tt>NORM_DATA</tt> messages
          contain a flag to indicate the availability of <tt>NORM_INFO</tt>
          for a given <em>NormObject</em>. NORM receivers
          may NACK for retransmission of <tt>NORM_INFO</tt>
          when they have not received it for a given <em>NormObject</em>.
          The size of the <tt>NORM_INFO</tt> content is
          limited to that of a single <em>NormSegmentSize</em>
          for the given sender. This atomic nature allows the <tt>NORM_INFO</tt> to be rapidly and efficiently
          repaired within the NORM reliable transmission process.
</p>
<p>When <tt>NORM_INFO</tt> content is available
          for a <em>NormObject</em>, the NORM_FLAG_INFO
          flag SHALL be set in <tt>NORM_DATA</tt> messages
          for the corresponding "object_transport_id" and the <tt>NORM_INFO</tt> message shall be transmitted as the
          first message for the <em>NormObject</em>.
</p><br /><hr class="insert" />
<div style='display: table; width: 0; margin-left: auto; margin-right: auto'><pre> 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|version| type=1|    hdr_len    |          sequence             |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                           source_id                           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|          instance_id          |     grtt      |backoff| gsize |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|     flags     |     fec_id    |     object_transport_id       |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                header_extensions (if applicable)              |
|                              ...                              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                         payload_data                          |
|                              ...                              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;NORM_INFO Message Format&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>The "version", "type", "hdr_len", "sequence", and "source_id"
          fields form the NORM Common Message Header as described in <a class='info' href='#CommonHeader'>Section&nbsp;4.1<span> (</span><span class='info'>NORM Common Message Header and Extensions</span><span>)</span></a>. The value of "hdr_len" field when no
          header extensions are present is 4.
</p>
<p>The "instance_id", "grtt", "backoff", "gsize", "flags", "fec_id",
          and "object_transport_id" fields carry the same information and
          serve the same purpose as with <tt>NORM_DATA</tt>
          messages. These values allow the receiver to prepare appropriate
          buffering, etc, for further transmissions from the sender when
          <tt>NORM_INFO</tt> is the first message
          received.
</p>
<p>As with <tt>NORM_DATA</tt> messages, the NORM
          FTI Header Extension (EXT_FTI) may be optionally applied to <tt>NORM_INFO</tt> messages. To conserve protocol
          overhead, some NORM implementations may wish to apply the EXT_FTI
          when used to <tt>NORM_INFO</tt> messages only and
          not to <tt>NORM_DATA</tt> messages.
</p>
<p>The <tt>NORM_INFO</tt> "payload_data" field
          contains sender application-defined content which can be used by
          receiver applications for various purposes as described above.
</p>
<a name="NORM_CMD"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.2.3"></a><h3>4.2.3.&nbsp;
NORM_CMD Messages</h3>

<p><tt>NORM_CMD</tt> messages are transmitted by
          senders to perform a number of different protocol functions. This
          includes functions such as round-trip timing collection, congestion
          control functions, synchronization of sender/receiver repair
          "windows", and notification of sender status. A core set of <tt>NORM_CMD</tt> messages is enumerated. Additionally,
          a range of command types remain available for potential
          application-specific use. Some <tt>NORM_CMD</tt>
          types may have dynamic content attached. Any attached content will
          be limited to maximum length of the sender <em>NormSegmentSize</em>
          to retain the atomic nature of commands. All <tt>NORM_CMD</tt>
          messages begin with a common set of fields, after the usual NORM
          message common header. The standard <tt>NORM_CMD</tt>
          fields are:
</p><br /><hr class="insert" />
<div style='display: table; width: 0; margin-left: auto; margin-right: auto'><pre> 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|version| type=3|    hdr_len    |          sequence             |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                           source_id                           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|          instance_id          |     grtt      |backoff| gsize |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|     flavor    |                                               |
+-+-+-+-+-+-+-+-+        NORM_CMD Content                       +
|                              ...                              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;NORM_CMD Standard Fields&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>The "version", "type", "hdr_len", "sequence", and "source_id"
          fields form the NORM Common Message Header as described in <a class='info' href='#CommonHeader'>Section&nbsp;4.1<span> (</span><span class='info'>NORM Common Message Header and Extensions</span><span>)</span></a>. The value of the "hdr_len" field for
          <tt>NORM_CMD</tt> messages without header
          extensions present depends upon the "flavor" field.
</p>
<p>The "instance_id", "grtt", "backoff", and "gsize" fields provide
          the same information and serve the same purpose as with <tt>NORM_DATA</tt> and <tt>NORM_INFO</tt>
          messages. The "flavor" field indicates the type of command to
          follow. The remainder of the <tt>NORM_CMD</tt>
          message is dependent upon the command type ("flavor"). NORM command
          flavors include:
</p><table class="full" align="center" border="0" cellpadding="2" cellspacing="2">
<col align="left"><col align="left"><col align="left">
<tr><th align="left">Command</th><th align="left">Flavor</th><th align="left">Purpose</th></tr>
<tr>
<td align="left"><tt>NORM_CMD(FLUSH)</tt>&nbsp;</td>
<td align="left">1</td>
<td align="left">Used to indicate sender temporary end-of-transmission. (Assists
            in robustly initiating outstanding repair requests from
            receivers). May also be optionally used to collect positive
            acknowledgment of reliable reception from subset of receivers.</td>
</tr>
<tr>
<td align="left"><tt>NORM_CMD(EOT)</tt>&nbsp;</td>
<td align="left">2</td>
<td align="left">Used to indicate sender permanent end-of-transmission.</td>
</tr>
<tr>
<td align="left"><tt>NORM_CMD(SQUELCH)</tt>&nbsp;</td>
<td align="left">3</td>
<td align="left">Used to advertise sender's current repair window in response to
            out-of-range NACKs from receivers.</td>
</tr>
<tr>
<td align="left"><tt>NORM_CMD(CC)</tt>&nbsp;</td>
<td align="left">4</td>
<td align="left">Used for GRTT measurement and collection of congestion control
            feedback.</td>
</tr>
<tr>
<td align="left"><tt>NORM_CMD(REPAIR_ADV)</tt>&nbsp;</td>
<td align="left">5</td>
<td align="left">Used to advertise sender's aggregated repair/feedback state for
            suppression of unicast feedback from receivers.</td>
</tr>
<tr>
<td align="left"><tt>NORM_CMD(ACK_REQ)</tt>&nbsp;</td>
<td align="left">6</td>
<td align="left">Used to request application-defined positive acknowledgment
            from a list of receivers (OPTIONAL).</td>
</tr>
<tr>
<td align="left"><tt>NORM_CMD(APPLICATION)</tt>&nbsp;</td>
<td align="left">7</td>
<td align="left">Used for application-defined purposes which may need to
            temporarily preempt data transmission (OPTIONAL).</td>
</tr>
</table>
<br clear="all" />

<a name="anchor14"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.2.3.1"></a><h3>4.2.3.1.&nbsp;
NORM_CMD(FLUSH) Message</h3>

<p>The <tt>NORM_CMD(FLUSH)</tt> command is sent
            when the sender reaches the end of all data content and pending
            repairs it has queued for transmission. This may indicate a
            temporary or permanent end of data transmission, but the sender is
            still willing to respond to repair requests. This command is
            repeated once per <tt>2*GRTT</tt> to excite the
            receiver set for any outstanding repair requests up to and
            including the transmission point indicated within the <tt>NORM_CMD(FLUSH)</tt> message. The number of
            repeats is equal to <tt>NORM_ROBUST_FACTOR</tt>
            unless a list of receivers from which explicit positive
            acknowledgment is expected ("acking_node_list") is given. In that
            case, the "acking_node_list" is updated as acknowledgments are
            received and the <tt>NORM_CMD(FLUSH)</tt> is
            repeated according to the mechanism described in <a class='info' href='#PositiveAcknowledgment'>Section&nbsp;5.5.3<span> (</span><span class='info'>NORM Positive Acknowledgment Procedure</span><span>)</span></a>. The greater the <tt>NORM_ROBUST_FACTOR</tt>, the greater the
            probability that all applicable receivers will be excited for
            acknowledgment or repair requests (NACKs) AND that the
            corresponding NACKs are delivered to the sender. A default value
            of <tt>NORM_ROBUST_FACTOR</tt> equal to 20 is
            RECOMMENDED. If a <tt>NORM_NACK</tt> message
            interrupts the flush process, the sender SHALL re-initiate the
            flush process after any resulting repair transmissions are
            completed.
</p>
<p>Note that receivers also employ a timeout mechanism to
            self-initiate NACKing (if there are outstanding repair needs) when
            no messages of any type are received from a sender. This
            inactivity timeout is related to the <tt>NORM_CMD(FLUSH)</tt>
            and <tt>NORM_ROBUST_FACTOR</tt> and is
            specified in <a class='info' href='#NackProcedure'>Section&nbsp;5.3<span> (</span><span class='info'>Receiver NACK Procedure</span><span>)</span></a>. Receivers SHALL
            self-initiate the NACK repair process when the inactivity timeout
            has expired for a specific sender and the receiver has pending
            repairs needed from that sender. With a sufficiently large <tt>NORM_ROBUST_FACTOR</tt> value, data content is
            delivered with a high assurance of reliability. The penalty of a
            large <tt>NORM_ROBUST_FACTOR</tt> value is the
            potential transmission of excess <tt>NORM_CMD(FLUSH)</tt>
            messages and a longer inactivity timeout for receivers to
            self-initiate a terminal NACK process.
</p>
<p>For finite-size transport objects such as <tt>NORM_OBJECT_DATA</tt>
            and <tt>NORM_OBJECT_FILE</tt>, the flush
            process (if there are no further pending objects) occurs at the
            end of these objects. Thus, FEC repair information is always
            available for repairs in response to repair requests elicited by
            the flush command. However, for <tt>NORM_OBJECT_STREAM</tt>,
            the flush may occur at any time, including in the middle of an FEC
            coding block if systematic FEC codes are employed. In this case,
            the sender will not yet be able to provide FEC parity content for
            the concurrent coding block and will be limited to explicitly
            repairing the stream with source data content for that block.
            Applications that anticipate frequent flushing of stream content
            SHOULD be judicious in the selection of the FEC coding block size
            (i.e., do not use a very large coding block size if frequent
            flushing occurs). For example, a reliable multicast application
            transmitting an on-going series of intermittent, relatively small
            messages will need to trade-off using the <tt>NORM_OBJECT_DATA</tt>
            paradigm versus the <tt>NORM_OBJECT_STREAM</tt>
            paradigm with an appropriate FEC coding block size. This is
            analogous to application trade-offs for other transport protocols
            such as the selection of different TCP modes of operation such as
            "no delay", etc.
</p><br /><hr class="insert" />
<div style='display: table; width: 0; margin-left: auto; margin-right: auto'><pre> 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|version| type=3|    hdr_len    |          sequence             |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                           source_id                           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|          instance_id          |     grtt      |backoff| gsize |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|   flavor = 1  |    fec_id     |      object_transport_id      |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                         fec_payload_id                        |
|                              ...                              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                acking_node_list (if applicable)               |
|                              ...                              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;NORM_CMD(FLUSH) Message Format&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>The "version", "type", "hdr_len", "sequence", and "source_id"
            fields form the NORM Common Message Header as described in <a class='info' href='#CommonHeader'>Section&nbsp;4.1<span> (</span><span class='info'>NORM Common Message Header and Extensions</span><span>)</span></a>. In addition to the NORM common
            message header and standard <tt>NORM_CMD</tt>
            fields, the <tt>NORM_CMD(FLUSH)</tt> message
            contains fields to identify the current status and logical
            transmit position of the sender.
</p>
<p>The "fec_id" field indicates the FEC type used for the flushing
            "object_transport_id" and implies the size and format of the
            "fec_payload_id" field. Note the "hdr_len" value for the <tt>NORM_CMD(FLUSH)</tt> message is 4 plus the size of
            the "fec_payload_id" field when no header extensions are
            present.
</p>
<p>The "object_transport_id" and "fec_payload_id" fields indicate
            the sender's current logical "transmit position". These fields are
            interpreted in the same manner as in the <tt>NORM_DATA</tt>
            message type. Upon receipt of the <tt>NORM_CMD(FLUSH)</tt>,
            receivers are expected to check their completion state THROUGH
            (including) this transmission position. If receivers have
            outstanding repair needs in this range, they SHALL initiate the
            NORM NACK Repair Process as described in <a class='info' href='#NackProcedure'>Section&nbsp;5.3<span> (</span><span class='info'>Receiver NACK Procedure</span><span>)</span></a>. If receivers have no outstanding
            repair needs, no response to the <tt>NORM_CMD(FLUSH)</tt>
            is generated.
</p>
<p>For <tt>NORM_OBJECT_STREAM</tt> objects
            using systematic FEC codes, receivers MUST request "explicit-only"
            repair of the identified "source_block_number" if the given
            "encoding_symbol_id" is less than the "source_block_len". This
            condition indicates the sender has not yet completed encoding the
            corresponding FEC block and parity content is not yet available.
            An "explicit-only" repair request consists of NACK content for the
            applicable "source_block_number" which does not include any
            requests for parity-based repair. This allows NORM sender
            applications to "flush" an ongoing stream of transmission when
            needed, even if in the middle of an FEC block. Once the sender
            resumes stream transmission and passes the end of the pending
            coding block, subsequent NACKs from receivers SHALL request
            parity-based repair as usual. Note that the use of a systematic
            FEC code is assumed here. It should also be noted that a sender
            has the option of arbitrarily shortening a given code block when
            such an application "flush" occurs. In this case, the receiver
            will request explicit repair, but the sender MAY provide FEC-based
            repair (parity segments) in response. These parity segments MUST
            contain the corrected "source_block_len" for the shortened block
            and that "source_block_len" associated with segments containing
            parity content SHALL override the previously advertised
            "source_block_len". Similarly, the "source_block_len" associated
            with the highest ordinal "encoding_symbol_id" shall take
            precedence over prior symbols when a difference (e.g., due to code
            shortening at the sender) occurs. Normal receiver NACK initiation
            and construction is discussed in detail in <a class='info' href='#NackProcedure'>Section&nbsp;5.3<span> (</span><span class='info'>Receiver NACK Procedure</span><span>)</span></a>.
</p>
<p>The OPTIONAL "acking_node_list" field contains a list of <em>NormNodeIds</em> for receivers from which the
            sender is requesting explicit positive acknowledgment of reception
            up through the transmission point identified by the
            "object_transport_id" and "fec_payload_id" fields. The length of
            the list can be inferred from the length of the received <tt>NORM_CMD(FLUSH)</tt> message. When the
            "acking_node_list" is present, the lightweight positive
            acknowledgment process described in <a class='info' href='#PositiveAcknowledgment'>Section&nbsp;5.5.3<span> (</span><span class='info'>NORM Positive Acknowledgment Procedure</span><span>)</span></a> SHALL be observed.
</p>
<a name="anchor15"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.2.3.2"></a><h3>4.2.3.2.&nbsp;
NORM_CMD(EOT) Message</h3>

<p>The <tt>NORM_CMD(EOT)</tt> command is sent
            when the sender reaches permanent end-of-transmission with respect
            to the <em>NormSession</em> and will not
            respond to further repair requests. This allows receivers to
            gracefully reach closure of operation with this sender (without
            requiring any timeout) and free any resources that are no longer
            needed. The <tt>NORM_CMD(EOT)</tt> command
            SHOULD be sent with the same robust mechanism as used for <tt>NORM_CMD(FLUSH)</tt> commands to provide a high
            assurance of reception by the receiver set.
</p><br /><hr class="insert" />
<div style='display: table; width: 0; margin-left: auto; margin-right: auto'><pre> 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|version| type=3|    hdr_len    |          sequence             |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                           source_id                           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|          instance_id          |     grtt      |backoff| gsize |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|   flavor = 2  |                    reserved                   |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;NORM_CMD(EOT) Message Format&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>The value of the "hdr_len" field for <tt>NORM_CMD(EOT)</tt>
            messages without header extensions present is 4. The "reserved"
            field is reserved for future use and MUST be set to an all ZERO
            value. Receivers MUST ignore the "reserved" field.
</p>
<a name="anchor16"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.2.3.3"></a><h3>4.2.3.3.&nbsp;
NORM_CMD(SQUELCH) Message</h3>

<p>The <tt>NORM_CMD(SQUELCH)</tt> command is
            transmitted in response to outdated or invalid <tt>NORM_NACK</tt> content received by the sender.
            Invalid <tt>NORM_NACK</tt> content consists of
            repair requests for <em>NormObjects</em> for
            which the sender is unable or unwilling to provide repair. This
            includes repair requests for outdated objects, aborted objects, or
            those objects which the sender previously transmitted marked with
            the <tt>NORM_FLAG_UNRELIABLE</tt> flag. This
            command indicates to receivers what content is available for
            repair, thus serving as a description of the sender's current
            "repair window". Receivers SHALL NOT generate repair requests for
            content identified as invalid by a <tt>NORM_CMD(SQUELCH)</tt>.
</p>
<p>The <tt>NORM_CMD(SQUELCH)</tt> command is
            sent once per <tt>2*GRTT</tt> at the most. The
            <tt>NORM_CMD(SQUELCH)</tt> advertises the
            current "repair window" of the sender by identifying the earliest
            (lowest) transmission point for which it will provide repair,
            along with an encoded list of objects from that point forward that
            are no longer valid for repair. This mechanism allows the sender
            application to cancel or abort transmission and/or repair of
            specific previously enqueued objects. The list also contains the
            identifiers for any objects within the repair window that were
            sent with the <tt>NORM_FLAG_UNRELIABLE</tt>
            flag set. In normal conditions, it is expected the <tt>NORM_CMD(SQUELCH)</tt> will be needed
            infrequently, and generally only to provide a reference repair
            window for receivers who have fallen "out-of-sync" with the sender
            due to extremely poor network conditions.
</p>
<p>The starting point of the invalid <em>NormObject</em>
            list begins with the lowest invalid <em>NormTransportId</em>
            greater than the current "repair window" start from the invalid
            NACK(s) that prompted the generation of the squelch. The length of
            the list is limited by the sender's <em>NormSegmentSize</em>.
            This allows the receivers to learn the status of the sender's
            applicable object repair window with minimal transmission of
            <tt>NORM_CMD(SQUELCH)</tt> commands. The format
            of the <tt>NORM_CMD(SQUELCH)</tt> message
            is:
</p><br /><hr class="insert" />
<div style='display: table; width: 0; margin-left: auto; margin-right: auto'><pre> 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|version| type=3|    hdr_len    |          sequence             |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                           source_id                           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|          instance_id          |     grtt      |backoff| gsize |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|  flavor = 3   |     fec_id    |      object_transport_id      |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                         fec_payload_id                        |
|                              ...                              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                        invalid_object_list                    |
|                              ...                              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;NORM_CMD(SQUELCH) Message Format&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>In addition to the NORM common message header and standard
            <tt>NORM_CMD</tt> fields, the <tt>NORM_CMD(SQUELCH)</tt> message contains fields to
            identify the earliest logical transmit position of the sender's
            current repair window and an "invalid_object_list" beginning with
            the index of the logically earliest invalid repair request from
            the offending NACK message which initiated the <tt>NORM_CMD(SQUELCH)</tt> transmission. The value of
            the "hdr_len" field when no extensions are present is 4 plus the
            size of the "fec_payload_id" field that is dependent upon the FEC
            scheme identified by the "fec_id" field.
</p>
<p>The "object_transport_id" and "fec_payload_id" fields are
            concatenated to indicate the beginning of the sender's current
            repair window (i.e., the logically earliest point in its
            transmission history for which the sender can provide repair). The
            "fec_id" field implies the size and format of the "fec_payload_id"
            field. This serves as an advertisement of a "synchronization"
            point for receivers to request repair. Note, that while an
            "encoding_symbol_id" may be included in the "fec_payload_id"
            field, the sender's repair window SHOULD be aligned on FEC coding
            block boundaries and thus the "encoding_symbol_id" SHOULD be
            zero.
</p>
<p>The "invalid_object_list" is a list of 16-bit <em>NormTransportIds</em> that, although they are
            within the range of the sender's current repair window, are no
            longer available for repair from the sender. For example, a sender
            application may dequeue an out-of-date object even though it is
            still within the repair window. The total size of the
            "invalid_object_list" content is can be determined from the
            packet's payload length and is limited to a maximum of the <em>NormSegmentSize</em> of the sender. Thus, for very
            large repair windows, it is possible that a single <tt>NORM_CMD(SQUELCH)</tt> message may not be capable
            of listing the entire set of invalid objects in the repair window.
            In this case, the sender SHALL ensure that the list begins with a
            <em>NormObjectId</em> that is greater than or
            equal to the lowest ordinal invalid <em>NormObjectId</em>
            from the NACK message(s) that prompted the <tt>NORM_CMD(SQUELCH)</tt>
            generation. The <em>NormObjectIds</em> in the
            "invalid_object_list" MUST be ordinally greater than the
            "object_transport_id" marking the beginning of the sender's repair
            window. This insures convergence of the squelch process, even if
            multiple invalid NACK/ squelch iterations are required. This
            explicit description of invalid content within the sender's
            current window allows the sender application (most notably for
            discrete object transport) to arbitrarily invalidate (i.e.,
            dequeue) portions of enqueued content (e.g., certain objects) for
            which it no longer wishes to provide reliable transport.
</p>
<a name="anchor17"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.2.3.4"></a><h3>4.2.3.4.&nbsp;
NORM_CMD(CC) Message</h3>

<p>The <tt>NORM_CMD(CC)</tt> messages contains
            fields to enable sender-to-receiver group greatest round-trip time
            (GRTT) measurement and to excite the group for congestion control
            feedback. A baseline NORM congestion control scheme (NORM-CC),
            based on the TCP-Friendly Multicast Congestion Control (TFMCC)
            scheme of <a class='info' href='#RFC4654'>RFC 4654<span> (</span><span class='info'>Widmer, J. and M. Handley, &ldquo;TCP-Friendly Multicast Congestion Control (TFMCC): Protocol Specification,&rdquo; August&nbsp;2006.</span><span>)</span></a> is
            fully specified in <a class='info' href='#CongestionControl'>Section&nbsp;5.5.2<span> (</span><span class='info'>NORM Congestion Control Operation</span><span>)</span></a> of
            this document. The <tt>NORM_CMD(CC)</tt>
            message is usually transmitted as part of NORM-CC congestion
            control operation. A NORM header extension is defined below to be
            used with the <tt>NORM_CMD(CC)</tt> message to
            support NORM-CC operation. Different header extensions may be
            defined for the <tt>NORM_CMD(CC)</tt> (and/or
            other NORM messages as needed) to support alternative congestion
            control schemes in the future. If NORM is operated in a network
            where resources are explicitly dedicated to the NORM session and
            therefore congestion control operation is disabled, the <tt>NORM_CMD(CC)</tt> message is then used soley for
            GRTT measurement and may optionally be sent less frequently than
            with congestion control operation.
</p><br /><hr class="insert" />
<div style='display: table; width: 0; margin-left: auto; margin-right: auto'><pre> 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|version| type=3|    hdr_len    |            sequence           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                           source_id                           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|          instance_id          |     grtt      |backoff| gsize |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|   flavor = 4  |    reserved   |          cc_sequence          |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                         send_time_sec                         |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                        send_time_usec                         |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|               header extensions (if applicable)               |
|                              ...                              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                  cc_node_list (if applicable)                 |
|                              ...                              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;NORM_CMD(CC) Message Format&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>The NORM common message header and standard <tt>NORM_CMD</tt> fields serve their usual purposes.
            The value of the "hdr_len" field when no header extensions are
            present is 6.
</p>
<p>The "reserved" field is for potential future use and MUST be
            set to ZERO in this version of the NORM protocol and its baseline
            NORM-CC congestion control scheme. It may be possible that
            alternative congestion control schemes may use the <tt>NORM_CMD(CC)</tt> message defined here and
            leverage the "reserved" field for scheme-specific purposes.
</p>
<p>The "cc_sequence" field is a sequence number applied by the
            sender. For NORM-CC operation, it is used to provide functionality
            equivalent to the "feedback round number" (<tt>fb_nr</tt>)
            described in <a class='info' href='#RFC4654'>RFC 4654<span> (</span><span class='info'>Widmer, J. and M. Handley, &ldquo;TCP-Friendly Multicast Congestion Control (TFMCC): Protocol Specification,&rdquo; August&nbsp;2006.</span><span>)</span></a>.
            The most recently received "cc_sequence" value is recorded by
            receivers and can be fed back to the sender in congestion control
            feedback generated by the receivers for that sender. The
            "cc_sequence" number can also be used in NORM implementations to
            assess how recently a receiver has received <tt>NORM_CMD(CC)</tt>
            probes from the sender. This can be useful instrumentation for
            complex or experimental multicast routing environments.
</p>
<p>The "send_time" field is a timestamp indicating the time that
            the <tt>NORM_CMD(CC)</tt> message was
            transmitted. This consists of a 64-bit field containing 32-bits
            with the time in seconds ("send_time_sec") and 32-bits with the
            time in microseconds ("send_time_usec") since some reference time
            the source maintains (usually 00:00:00, 1 January 1970). The byte
            ordering of the fields is "Big Endian" network order. Receivers
            use this timestamp adjusted by the amount of delay from the time
            they received the <tt>NORM_CMD(CC)</tt> message
            to the time of their response as the "grtt_response" portion of
            <tt>NORM_ACK</tt> and <tt>NORM_NACK</tt>
            messages generated. This allows the sender to evaluate round-trip
            times to different receivers for congestion control and other
            (e.g., GRTT determination) purposes.
</p>
<p>To facilitate the baseline NORM-CC scheme described in <a class='info' href='#CongestionControl'>Section&nbsp;5.5.2<span> (</span><span class='info'>NORM Congestion Control Operation</span><span>)</span></a>, a NORM-CC Rate header
            extension (EXT_RATE) is defined to inform the group of the
            sender's current transmission rate. This is used along with the
            loss detection "sequence" field of all NORM sender messages and
            the <tt>NORM_CMD(CC)</tt> GRTT collection
            process to support NORM-CC congestion control operation. The
            format of this header extension is as follows:
</p><div style='display: table; width: 0; margin-left: auto; margin-right: auto'><pre> 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|    het = 128  |    reserved   |           send_rate           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</pre></div>
<p>The "send_rate" field indicates the sender's current
            transmission rate in bytes per second. The 16-bit "send_rate"
            field consists of 12 bits of mantissa in the most significant
            portion and 4 bits of base 10 integer exponent (E) information in
            the least significant portion. The 12-bit mantissa portion of the
            field is scaled such that a base 10 mantissa (M) floating point
            value of 0.0 corresponds to 0 and a value of 10.0 corresponds to
            4096 in the upper 12 bits of the 16-bit "send_rate" field.
            Thus:
</p><div style='display: table; width: 0; margin-left: auto; margin-right: auto'><pre>
send_rate = (((int)(M * 4096.0 / 10.0 + 0.5)) &lt;&lt; 4) | E;</pre></div>
<p>For example, to represent a transmission rate of 256kbps
            (3.2e+04 bytes per second), the lower 4 bits of the 16-bit field
            contain a value of 0x04 to represent the exponent (E) while the
            upper 12 bits contain a value of 0x51f (M) as determined from the
            equation given above:
</p><div style='display: table; width: 0; margin-left: auto; margin-right: auto'><pre>send_rate = (((int)((3.2 * 4096.0 / 10.0) + 0.5)) &lt;&lt; 4) | 4;
          = (0x51f &lt;&lt; 4) | 0x4
          = 0x51f4</pre></div>
<p>To decode the "send_rate" field, the following equation can be
            used:
</p><div style='display: table; width: 0; margin-left: auto; margin-right: auto'><pre>value = (send_rate &gt;&gt; 4) * (10/4096) * power(10, (send_rate &amp; x000f))</pre></div>
<p>Note the maximum transmission rate that can be represented by
            this scheme is approximately 9.99e+15 bytes per second.
</p>
<p>When this extension is present, a "cc_node_list" may be
            attached as the payload of the <tt>NORM_CMD(CC)</tt>
            message. The presence of this header extension also implies that
            NORM receivers should respond according to the procedures
            described in <a class='info' href='#CongestionControl'>Section&nbsp;5.5.2<span> (</span><span class='info'>NORM Congestion Control Operation</span><span>)</span></a>.
</p>
<p>The "cc_node_list" consists of a list of <em>NormNodeIds</em>
            and their associated congestion control status. This includes the
            current limiting receiver (CLR) node, any potential limiting
            receiver (PLR) nodes that have been identified, and some number of
            receivers for which congestion control status is being provided,
            most notably including the receivers' current RTT measurement. The
            maximum length of the "cc_node_list" provides for at least the CLR
            and one other receiver, but may be configurable for more timely
            feedback to the group. The list length can be inferred from the
            length of the <tt>NORM_CMD(CC)</tt>
            message.
</p>
<p>Each item in the "cc_node_list" is in the following format:
</p><div style='display: table; width: 0; margin-left: auto; margin-right: auto'><pre> 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                          cc_node_id                           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|    cc_flags   |     cc_rtt    |            cc_rate            |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</pre></div>
<p>The "cc_node_id" is the <em>NormNodeId</em>
            of the receiver which the item represents.
</p>
<p>The "cc_flags" field contains flags indicating the congestion
            control status of the indicated receiver. The following flags are
            defined:
</p><table class="full" align="center" border="0" cellpadding="2" cellspacing="2">
<col align="left"><col align="left"><col align="left">
<tr><th align="left">Flag</th><th align="left">Value</th><th align="left">Purpose</th></tr>
<tr>
<td align="left"><tt>NORM_FLAG_CC_CLR</tt>&nbsp;</td>
<td align="left">0x01</td>
<td align="left">Receiver is the current limiting receiver (CLR).</td>
</tr>
<tr>
<td align="left"><tt>NORM_FLAG_CC_PLR</tt>&nbsp;</td>
<td align="left">0x02</td>
<td align="left">Receiver is a potential limiting receiver (PLR).</td>
</tr>
<tr>
<td align="left"><tt>NORM_FLAG_CC_RTT</tt>&nbsp;</td>
<td align="left">0x04</td>
<td align="left">Receiver has measured RTT with respect to sender.</td>
</tr>
<tr>
<td align="left"><tt>NORM_FLAG_CC_START</tt>&nbsp;</td>
<td align="left">0x08</td>
<td align="left">Sender/receiver is in "slow start" phase of congestion
              control operation (i.e., The receiver has not yet detected any
              packet loss and the "cc_rate" field is the receiver's actual
              measured receive rate).</td>
</tr>
<tr>
<td align="left"><tt>NORM_FLAG_CC_LEAVE</tt>&nbsp;</td>
<td align="left">0x10</td>
<td align="left">Receiver is imminently leaving the session and its feedback
              should not be considered in congestion control operation.</td>
</tr>
</table>
<br clear="all" />

<p>The "cc_rtt" contains a quantized representation of the RTT as
            measured by the sender with respect to the indicated receiver.
            This field is valid only if the <tt>NORM_FLAG_CC_RTT</tt>
            flag is set in the "cc_flags" field. This one byte field is a
            quantized representation of the RTT using the algorithm described
            in the <a class='info' href='#RFC5401'>Multicast NACK Building
            Block<span> (</span><span class='info'>Adamson, B., Bormann, C., Handley, M., and J. Macker, &ldquo;Multicast Negative-Acknowledgment (NACK) Building Blocks,&rdquo; November&nbsp;2008.</span><span>)</span></a> [RFC5401].
</p>
<p>The "cc_rate" field contains a representation of the receiver's
            current calculated (during steady-state congestion control
            operation) or twice its measured (during the <em>slow start</em>
            phase) congestion control rate. This field is encoded and decoded
            using the same technique as described for the <tt>NORM_CMD(CC)</tt>
            "send_rate" field.
</p>
<a name="anchor18"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.2.3.5"></a><h3>4.2.3.5.&nbsp;
NORM_CMD(REPAIR_ADV) Message</h3>

<p>The <tt>NORM_CMD(REPAIR_ADV)</tt> message is
            used by the sender to "advertise" its aggregated repair state from
            <tt>NORM_NACK</tt> messages accumulated during
            a repair cycle and/or congestion control feedback received. This
            message is sent only when the sender has received <tt>NORM_NACK</tt> and/or <tt>NORM_ACK(CC)</tt>
            (when congestion control is enabled) messages via unicast
            transmission instead of multicast. By relaying this information to
            the receiver set, suppression of feedback can be achieved even
            when receivers are unicasting that feedback instead of
            multicasting it among the group <a class='info' href='#NormFeedback'>[NormFeedback]<span> (</span><span class='info'>Adamson, B. and J. Macker, &ldquo;Quantitative Prediction of NACK-Oriented Reliable Multicast           (NORM) Feedback,&rdquo; October&nbsp;2002.</span><span>)</span></a>.
</p><br /><hr class="insert" />
<div style='display: table; width: 0; margin-left: auto; margin-right: auto'><pre> 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|version| type=3|    hdr_len    |          sequence             |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                           source_id                           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|          instance_id          |     grtt      |backoff| gsize |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|  flavor = 5   |     flags     |            reserved           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|               header extensions (if applicable)               |
|                              ...                              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                       repair_adv_payload                      |
|                              ...                              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;NORM_CMD(REPAIR_ADV) Message Format&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>The "instance_id", "grtt", "backoff", "gsize", and "flavor"
            fields serve the same purpose as in other <tt>NORM_CMD</tt>
            messages. The value of the "hdr_len" field when no extensions are
            present is 4.
</p>
<p>The "flags" field provide information on the <tt>NORM_CMD(REPAIR_ADV)</tt> content. There is
            currently one <tt>NORM_CMD(REPAIR_ADV)</tt>
            flag defined:
</p><div style='display: table; width: 0; margin-left: auto; margin-right: auto'><pre>NORM_REPAIR_ADV_FLAG_LIMIT = 0x01</pre></div>
<p>This flag is set by the sender when it is unable to fit its
            full current repair state into a single <em>NormSegmentSize</em>.
            If this flag is set, receivers should limit their NACK response to
            generating NACK content only up through the maximum ordinal
            transmission position <em>(objectId::fecPayloadId)</em>
            included in the "repair_adv_content".
</p>
<p>When congestion control operation is enabled, a header
            extension may be applied to the <tt>NORM_CMD(REPAIR_ADV)</tt>
            representing the most limiting (in terms of congestion control
            feedback suppression) congestion control response. This allows the
            <tt>NORM_CMD(REPAIR_ADV)</tt> message to
            suppress receiver congestion control responses as well as NACK
            feedback messages. The field is defined as a header extension so
            that alternative congestion control schemes may be used with NORM
            without revision to this document. A NORM-CC Feedback Header
            Extension (EXT_CC) is defined to encapsulate congestion control
            feedback within <tt>NORM_NACK</tt>, <tt>NORM_ACK</tt>, and <tt>NORM_CMD(REPAIR_ADV)</tt>
            messages. If another congestion control technique (e.g., Pragmatic
            General Multicast Congestion Control (PGMCC) <a class='info' href='#PgmccPaper'>[PgmccPaper]<span> (</span><span class='info'>Rizzo, L., &ldquo;pgmcc: A TCP-Friendly Single-Rate Multicast Congestion           Control Scheme,&rdquo; August&nbsp;2000.</span><span>)</span></a>) is used within a NORM implementation,
            an additional header extension MAY need to be defined encapsulate
            any required feedback content. The NORM-CC Feedback Header
            Extension format is:
</p><div style='display: table; width: 0; margin-left: auto; margin-right: auto'><pre> 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|     het = 3   |    hel = 3    |          cc_sequence          |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|    cc_flags   |     cc_rtt    |            cc_loss            |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|            cc_rate            |          cc_reserved          |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</pre></div>
<p>The "cc_sequence" field contains the current greatest
            "cc_sequence" value receivers have received in <tt>NORM_CMD(CC)</tt> messages from the sender. This
            information assists the sender in congestion control operation by
            providing an indicator of how current ("fresh") the receiver's
            round-trip measurement reference time is and whether the receiver
            has been successfully receiving recent congestion control probes.
            For example, if it is apparent the receiver has not been receiving
            recent congestion control probes (and thus possibly other messages
            from the sender), the sender may choose to take congestion
            avoidance measures. For <tt>NORM_CMD(REPAIR_ADV)</tt>
            messages, the sender SHALL set the "cc_sequence" field value to
            the value set in the last <tt>NORM_CMD(CC)</tt>
            message sent.
</p>
<p>The "cc_flags" field contains bits representing the receiver's
            state with respect to congestion control operation. The possible
            values for the "cc_flags" field are those specified for the <tt>NORM_CMD(CC)</tt> message node list item flags.
            These fields are used by receivers in controlling (suppressing as
            necessary) their congestion control feedback. For <tt>NORM_CMD(REPAIR_ADV)</tt> messages, the <tt>NORM_FLAG_CC_RTT</tt> should be set <em>only</em> when <em>all</em>
            feedback messages received by the sender have the flag set.
            Similarly, the <tt>NORM_FLAG_CC_CLR</tt> or
            <tt>NORM_FLAG_CC_PLR</tt> should be set only
            when <em>no</em> feedback has been received
            from non-CLR or non-PLR receivers. And the <tt>NORM_FLAG_CC_LEAVE</tt>
            should be set only when all feedback messages the sender has
            received have this flag set. These heuristics for setting the
            flags in <tt>NORM_CMD(REPAIR_ADV)</tt> ensure
            the most effective suppression of receivers providing unicast
            feedback messages.
</p>
<p>The "cc_rtt" field SHALL be set to a default maximum value and
            the <tt>NORM_FLAG_CC_RTT</tt> flag SHALL be
            cleared when no receiver has yet received RTT measurement
            information. When a receiver has received RTT measurement
            information, it shall set the "cc_rtt" value accordingly and set
            the <tt>NORM_FLAG_CC_RTT</tt> flag in the
            "cc_flags" field. For <tt>NORM_CMD(REPAIR_ADV)</tt>
            messages, the sender SHALL set the "cc_rtt" field value to the
            largest non-CLR/non-PLR RTT it has measured from receivers for the
            current feedback round.
</p>
<p>The "cc_loss" field represents the receiver's current packet
            loss fraction estimate for the indicated source. The loss fraction
            is a value from 0.0 to 1.0 corresponding to a range of zero to 100
            percent packet loss. The 16-bit "cc_loss" value is calculated by
            the following formula:
</p><div style='display: table; width: 0; margin-left: auto; margin-right: auto'><pre>
"cc_loss" = floor(decimal_loss_fraction * 65535.0)</pre></div>
<p>For <tt>NORM_CMD(REPAIR_ADV)</tt> messages,
            the sender SHALL set the "cc_loss" field value to the largest
            non-CLR/non-PLR loss estimate it has received from receivers for
            the current feedback round.
</p>
<p>The "cc_rate" field represents the receivers current local
            congestion control rate. During "slow start", when the receiver
            has detected no loss, this value is set to twice the actual rate
            it has measured from the corresponding sender and the <tt>NORM_FLAG_CC_START</tt> is set in the "cc_flags'
            field. Otherwise, the receiver calculates a congestion control
            rate based on its loss measurement and RTT measurement information
            (even if default) for the "cc_rate" field. For <tt>NORM_CMD(REPAIR_ADV)</tt> messages, the sender
            SHALL set the "cc_loss" field value to the lowest non-CLR/non-PLR
            "cc_rate" report it has received from receivers for the current
            feedback round.
</p>
<p>The "cc_reserved" field is reserved for future NORM protocol
            use. Currently, senders SHALL set this field to ZERO, and
            receivers SHALL ignore the content of this field.
</p>
<p>The "repair_adv_payload" is in exactly the same form as the
            "nack_content" of <tt>NORM_NACK</tt> messages
            and can be processed by receivers for suppression purposes in the
            same manner, with the exception of the condition when the <tt>NORM_REPAIR_ADV_FLAG_LIMIT</tt> is set.
</p>
<a name="anchor19"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.2.3.6"></a><h3>4.2.3.6.&nbsp;
NORM_CMD(ACK_REQ) Message</h3>

<p>The <tt>NORM_CMD(ACK_REQ)</tt> message is
            used by the sender to request acknowledgment from a specified list
            of receivers. This message is used in providing a lightweight
            positive acknowledgment mechanism that is OPTIONAL for use by the
            reliable multicast application. A range of acknowledgment request
            types is provided for use at the application's discretion.
            Provision for application-defined, positively-acknowledged
            commands allows the application to automatically take advantage of
            transmission and round-trip timing information available to the
            NORM protocol. The details of the NORM positive acknowledgment
            process including transmission of the <tt>NORM_CMD(ACK_REQ)</tt>
            messages and the receiver response (<tt>NORM_ACK</tt>)
            are described in <a class='info' href='#PositiveAcknowledgment'>Section&nbsp;5.5.3<span> (</span><span class='info'>NORM Positive Acknowledgment Procedure</span><span>)</span></a>.
            The format of the <tt>NORM_CMD(ACK_REQ)</tt>
            message is:
</p><br /><hr class="insert" />
<div style='display: table; width: 0; margin-left: auto; margin-right: auto'><pre> 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|version| type=3|    hdr_len    |          sequence             |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                           source_id                           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|          instance_id          |     grtt      |backoff| gsize |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|  flavor = 6   |    reserved   |    ack_type   |    ack_id     |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                       acking_node_list                        |
|                              ...                              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;NORM_CMD(ACK_REQ) Message Format&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>The NORM common message header and standard <tt>NORM_CMD</tt> fields serve their usual purposes.
            The value of the "hdr_len" field for <tt>NORM_CMD(ACK_REQ)</tt>
            messages with no header extension present is 4.
</p>
<p>The "ack_type" field indicates the type of acknowledgment being
            requested and thus implies rules for how the receiver will treat
            this request. The following "ack_type" values are defined and are
            also used in <tt>NORM_ACK</tt> messages
            described later:
</p><table class="full" align="center" border="0" cellpadding="2" cellspacing="2">
<col align="left"><col align="left"><col align="left">
<tr><th align="left">ACK Type</th><th align="left">Value</th><th align="left">Purpose</th></tr>
<tr>
<td align="left"><tt>NORM_ACK_CC</tt>&nbsp;</td>
<td align="left">1</td>
<td align="left">Used to identify <tt>NORM_ACK</tt>
              messages sent in response to <tt>NORM_CMD(CC)</tt>
              messages.</td>
</tr>
<tr>
<td align="left"><tt>NORM_ACK_FLUSH</tt>&nbsp;</td>
<td align="left">2</td>
<td align="left">Used to identify <tt>NORM_ACK</tt>
              messages sent in response to <tt>NORM_CMD(FLUSH)</tt>
              messages.</td>
</tr>
<tr>
<td align="left"><tt>NORM_ACK_RESERVED</tt>&nbsp;</td>
<td align="left">3-15</td>
<td align="left">Reserved for possible future NORM protocol use.</td>
</tr>
<tr>
<td align="left"><tt>NORM_ACK_APPLICATION</tt>&nbsp;</td>
<td align="left">16-255</td>
<td align="left">Used at application's discretion.</td>
</tr>
</table>
<br clear="all" />

<p>The <tt>NORM_ACK_CC</tt> value is provided
            for use only in <tt>NORM_ACKs</tt> generated in
            response to the <tt>NORM_CMD(CC)</tt> messages
            used in congestion control operation. Similarly, the <tt>NORM_ACK_FLUSH</tt> is provided for use only in
            <tt>NORM_ACKs</tt> generated in response to
            applicable <tt>NORM_CMD(FLUSH)</tt> messages.
            <tt>NORM_CMD</tt>(ACK_REQ) messages with
            "ack_type" of <tt>NORM_ACK_CC</tt> or <tt>NORM_ACK_FLUSH</tt> SHALL NOT be generated by the
            sender.
</p>
<p>The <tt>NORM_ACK_RESERVED</tt> range of
            "ack_type" values is provided for possible future NORM protocol
            use.
</p>
<p>The <tt>NORM_ACK_APPLICATION</tt> range of
            "ack_type" values is provided so that NORM applications may
            implement application-defined, positively-acknowledged commands
            that are able to leverage internal transmission and round-trip
            timing information available to the NORM protocol
            implementation.
</p>
<p>The "ack_id" provides a sequenced identifier for the given
            <tt>NORM_CMD(ACK_REQ)</tt> message. This
            "ack_id" is returned in <tt>NORM_ACK</tt>
            messages generated by the receivers so that the sender may
            associate the response with its corresponding request.
</p>
<p>The "reserved" field is reserved for possible future protocol
            use and SHALL be set to ZERO by senders and ignored by
            receivers.
</p>
<p>The "acking_node_list" field contains the <em>NormNodeIds</em>
            of the current NORM receivers that are desired to provide positive
            acknowledge (<tt>NORM_ACK</tt>) to this
            request. The packet payload length implies the length of the
            "acking_node_list" and its length is limited to the sender <em>NormSegmentSize</em>. The individual <em>NormNodeId</em> items are listed in network (Big
            Endian) byte order. If a receiver's <em>NormNodeId</em>
            is included in the "acking_node_list", it SHALL schedule
            transmission of a <tt>NORM_ACK</tt> message as
            described in <a class='info' href='#PositiveAcknowledgment'>Section&nbsp;5.5.3<span> (</span><span class='info'>NORM Positive Acknowledgment Procedure</span><span>)</span></a>.
</p>
<a name="anchor20"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.2.3.7"></a><h3>4.2.3.7.&nbsp;
NORM_CMD(APPLICATION) Message</h3>

<p>This command allows the NORM application to robustly transmit
            application-defined commands. The command message preempts any
            ongoing data transmission and is repeated up to <tt>NORM_ROBUST_FACTOR</tt> times at a rate of once
            per <tt>2*GRTT</tt>. This rate of repetition
            allows the application to observe any response (if that is the
            application's purpose for the command) before it is repeated.
            Possible responses may include initiation of data transmission,
            other <tt>NORM_CMD(APPLICATION)</tt> messages,
            or even application-defined, positively-acknowledge commands from
            other <em>NormSession</em> participants. The
            transmission of these commands will preempt data transmission when
            they are scheduled and may be multiplexed with ongoing data
            transmission. This type of robustly transmitted command allows
            NORM applications to define a complete set of session control
            mechanisms with less state than the transfer of FEC encoded
            reliable content requires while taking advantage of NORM
            transmission and round-trip timing information.
</p><br /><hr class="insert" />
<div style='display: table; width: 0; margin-left: auto; margin-right: auto'><pre> 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|version| type=3|    hdr_len    |          sequence             |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                           source_id                           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|          instance_id          |     grtt      |backoff| gsize |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|  flavor = 7   |                    reserved                   |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                   Application-Defined Content                 |
|                              ...                              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;NORM_CMD(APPLICATION) Message Format&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>The NORM common message header and <tt>NORM_CMD</tt>
            fields are interpreted as previously described. The value of the
            <tt>NORM_CMD(APPLICATION)</tt> "hdr_len" field
            when no header extensions are present is 4.
</p>
<p>The "Application-Defined Content" area contains information in
            a format at the discretion of the application. The size of this
            payload SHALL be limited to a maximum of the sender's <em>NormSegmentSize</em> setting. Upon reception, the
            NORM protocol implementation SHALL deliver the content to the
            receiver application. Note that any detection of duplicate
            reception of a <tt>NORM_CMD(APPLICATION)</tt>
            message is the responsibility of the application.
</p>
<a name="anchor21"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.3"></a><h3>4.3.&nbsp;
Receiver Messages</h3>

<p>The NORM message types generated by participating receivers consist
        of the <tt>NORM_NACK</tt> and <tt>NORM_ACK</tt>
        message types. <tt>NORM_NACK</tt> messages are sent
        to request repair of missing data content from sender transmission and
        <tt>NORM_ACK</tt> messages are generated in
        response to certain sender commands including <tt>NORM_CMD(CC)</tt>
        and <tt>NORM_CMD(ACK_REQ)</tt>.
</p>
<a name="anchor22"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.3.1"></a><h3>4.3.1.&nbsp;
NORM_NACK Message</h3>

<p>The principal purpose of <tt>NORM_NACK</tt>
          messages is for receivers to request repair of sender content via
          selective, negative acknowledgment upon detection of incomplete
          data. <tt>NORM_NACK</tt> messages will be
          transmitted according to the rules of <tt>NORM_NACK</tt>
          generation and suppression described in <a class='info' href='#NackProcedure'>Section&nbsp;5.3<span> (</span><span class='info'>Receiver NACK Procedure</span><span>)</span></a>. <tt>NORM_NACK</tt>
          messages also contain additional fields to provide feedback to the
          sender(s) for purposes of round-trip timing collection and
          congestion control.
</p>
<p>The payload of <tt>NORM_NACK</tt> messages
          contains one or more repair requests for different objects or
          portions of those objects. The <tt>NORM_NACK</tt>
          message format is as follows:
</p><br /><hr class="insert" />
<div style='display: table; width: 0; margin-left: auto; margin-right: auto'><pre> 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|version| type=4|    hdr_len    |            sequence           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                           source_id                           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                           server_id                           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|           instance_id         |            reserved           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                       grtt_response_sec                       |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                       grtt_response_usec                      |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|               header extensions (if applicable)               |
|                              ...                              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                          nack_payload                         |
|                              ...                              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;NORM_NACK Message Format&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>The NORM common message header fields serve their usual purposes.
          The value of the "hdr_len" field for <tt>NORM_NACK</tt>
          messages without header extensions present is 6.
</p>
<p>The "server_id" field identifies the NORM sender to which the
          <tt>NORM_NACK</tt> message is destined.
</p>
<p>The "instance_id" field contains the current session identifier
          given by the sender identified by the "server_id" field in its
          sender messages. The sender SHOULD ignore feedback messages which
          contain an invalid "instance_id" value.
</p>
<p>The "grtt_response" fields contain an adjusted version of the
          timestamp from the most recently received <tt>NORM_CMD(CC)</tt>
          message for the indicated NORM sender. The format of the
          "grtt_response" is the same as the "send_time" field of the <tt>NORM_CMD(CC)</tt>. The "grtt_response" value is
          relative to the "send_time" the source provided with a corresponding
          <tt>NORM_CMD(CC)</tt> command. The receiver
          adjusts the source's <tt>NORM_CMD(CC)</tt>
          "send_time" timestamp by adding the time delta from when the
          receiver received the <tt>NORM_CMD(CC)</tt> to
          when the <tt>NORM_NACK</tt> is transmitted in
          response to calculate the value in the "grtt_response" field. This
          is the "receive_to_response_delta" value used in the following
          formula:
</p><div style='display: table; width: 0; margin-left: auto; margin-right: auto'><pre>grtt_response = NORM_CMD(CC) send_time + receive_to_response_delta</pre></div>
<p>The receiver SHALL set the "grtt_response" to a ZERO value, to
          indicate that it has not yet received a <tt>NORM_CMD(CC)</tt>
          message from the indicated sender and that the sender should ignore
          the "grtt_response" in this message.
</p>
<p>For NORM-CC operation, the NORM-CC Feedback Header Extension, as
          described in the <tt>NORM_CMD(REPAIR_ADV}</tt>
          message description, is added to <tt>NORM_NACK</tt>
          messages to provide feedback on the receivers current state with
          respect to congestion control operation. Note that alternative
          header extensions for congestion control feedback may be defined for
          alternative congestion control schemes for NORM use in the
          future.
</p>
<p>The "reserved" field is for potential future NORM use and SHALL
          be set to ZERO for this version of the protocol.
</p>
<p>The "nack_payload" of the <tt>NORM_NACK</tt>
          message specifies the repair needs of the receiver with respect to
          the NORM sender indicated by the "server_id" field. The receiver
          constructs repair requests based on the <tt>NORM_DATA</tt>
          and/or <tt>NORM_INFO</tt> segments it requires
          from the sender in order to complete reliable reception up to the
          sender's transmission position at the moment the receiver initiates
          the NACK Procedure as described in <a class='info' href='#NackProcedure'>Section&nbsp;5.3<span> (</span><span class='info'>Receiver NACK Procedure</span><span>)</span></a>. A single NORM Repair Request
          consists of a list of items, ranges, and/or FEC coding block erasure
          counts for needed <tt>NORM_DATA</tt> and/or
          <tt>NORM_INFO</tt> content. Multiple repair
          requests may be concatenated within the "nack_payload" field of a
          <tt>NORM_NACK</tt> message. Note that a single
          NORM Repair Request can possibly include multiple "items", "ranges",
          or "erasure_counts". In turn, the "nack_payload" field MAY contain
          multiple repair requests. A single NORM Repair Request has the
          following format:
</p><br /><hr class="insert" />
<div style='display: table; width: 0; margin-left: auto; margin-right: auto'><pre> 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|      form     |     flags     |             length            |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                      repair_request_items                     |
|                             ...                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;NORM Repair Request Format&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>The "form" field indicates the type of repair request items given
          in the "repair_request_items" list. Possible values for the "form"
          field include:
</p><table class="full" align="center" border="0" cellpadding="2" cellspacing="2">
<col align="left"><col align="center">
<tr><th align="left">Form</th><th align="center">Value</th></tr>
<tr>
<td align="left"><tt>NORM_NACK_ITEMS</tt>&nbsp;</td>
<td align="center">1</td>
</tr>
<tr>
<td align="left"><tt>NORM_NACK_RANGES</tt>&nbsp;</td>
<td align="center">2</td>
</tr>
<tr>
<td align="left"><tt>NORM_NACK_ERASURES</tt>&nbsp;</td>
<td align="center">3</td>
</tr>
</table>
<br clear="all" />

<p>A "form" value of <tt>NORM_NACK_ITEMS</tt>
          indicates each repair request item in the "repair_request_items"
          list is to be treated as an individual request. A value of <tt>NORM_NACK_RANGES</tt> indicates that the
          "repair_request_items" list consists of <em>pairs</em>
          of repair request items that correspond to inclusive ranges of
          repair needs. And the <tt>NORM_NACK_ERASURES</tt>
          "form" indicates that the repair request items are to be treated
          individually and that the "encoding_symbol_id" portion of the
          "fec_payload_id" field of the repair request item (see below) is to
          be interpreted as an erasure count for the FEC coding block
          identified by the repair request item's "source_block_number".
</p>
<p>The "flags" field is currently used to indicate the level of data
          content for which the repair request items apply (i.e., an
          individual segment, entire FEC coding block, or entire transport
          object). Possible flag values include:
</p><table class="full" align="center" border="0" cellpadding="2" cellspacing="2">
<col align="left"><col align="center"><col align="left">
<tr><th align="left">Flag</th><th align="center">Value</th><th align="left">Purpose</th></tr>
<tr>
<td align="left"><tt>NORM_NACK_SEGMENT</tt>&nbsp;</td>
<td align="center">0x01</td>
<td align="left">Indicates the listed segment(s) or range of segments are
            required as repair.</td>
</tr>
<tr>
<td align="left"><tt>NORM_NACK_BLOCK</tt>&nbsp;</td>
<td align="center">0x02</td>
<td align="left">Indicates the listed block(s) or range of blocks in entirety
            are required as repair.</td>
</tr>
<tr>
<td align="left"><tt>NORM_NACK_INFO</tt>&nbsp;</td>
<td align="center">0x04</td>
<td align="left">Indicates that <tt>NORM_INFO</tt> is
            required as repair for the listed object(s).</td>
</tr>
<tr>
<td align="left"><tt>NORM_NACK_OBJECT</tt>&nbsp;</td>
<td align="center">0x08</td>
<td align="left">Indicates the listed object(s) or range of objects in entirety
            are required as repair.</td>
</tr>
</table>
<br clear="all" />

<p>When the <tt>NORM_NACK_SEGMENT</tt> flag is
          set, the "object_transport_id" and "fec_payload_id" fields are used
          to determine which sets or ranges of individual <tt>NORM_DATA</tt>
          segments are needed to repair content at the receiver. When the
          <tt>NORM_NACK_BLOCK</tt> flag is set, this
          indicates the receiver is completely missing the indicated coding
          block(s) and requires transmissions sufficient to repair the
          indicated block(s) in their entirety. When the <tt>NORM_NACK_INFO</tt>
          flag is set, this indicates the receiver is missing the <tt>NORM_INFO</tt> segment for the indicated
          "object_transport_id". Note the <tt>NORM_NACK_INFO</tt>
          may be set in combination with the <tt>NORM_NACK_BLOCK</tt>
          or <tt>NORM_NACK_SEGMENT</tt> flags, or may be
          set alone. When the <tt>NORM_NACK_OBJECT</tt>
          flag is set, this indicates the receiver is missing the entire
          <em>NormTransportObject</em> referenced by the
          "object_transport_id". This also implicitly requests any available
          <tt>NORM_INFO</tt> for the <em>NormObject</em>,
          if applicable. The "fec_payload_id" field is ignored when the flag
          <tt>NORM_NACK_OBJECT</tt> is set.
</p>
<p>The "length" field value is the length in bytes of the
          "repair_request_items" field.
</p>
<p>The "repair_request_items" field consists of a list of individual
          or range pairs of transport data unit identifiers in the following
          format.
</p><br /><hr class="insert" />
<div style='display: table; width: 0; margin-left: auto; margin-right: auto'><pre> 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|     fec_id    |   reserved    |      object_transport_id      |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                        fec_payload_id                         |
|                              ...                              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;NORM Repair Request Item Format&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>The "fec_id" indicates the FEC type and can be used to determine
          the format of the "fec_payload_id" field. The "reserved" field is
          kept for possible future use and SHALL be set to a ZERO value and
          ignored by NORM nodes processing NACK content.
</p>
<p>The "object_transport_id" corresponds to the <em>NormObject</em>
          for which repair is being requested and the "fec_payload_id"
          identifies the specific FEC coding block and/or segment being
          requested. When the <tt>NORM_NACK_OBJECT</tt>
          flag is set, the value of the "fec_payload_id" field is ignored.
          When the <tt>NORM_NACK_BLOCK</tt> flag is set,
          only the FEC code block identifier portion of the "fec_payload_id"
          is to be interpreted.
</p>
<p>The format of the "fec_payload_id" field depends upon the
          "fec_id" field value.
</p>
<p>When the receiver's repair needs dictate that different forms
          (mixed ranges and/or individual items) or types (mixed specific
          segments and/or blocks or objects in entirety) are required to
          complete reliable transmission, multiple NORM Repair Requests with
          different "form" and or "flags" values can be concatenated within a
          single <tt>NORM_NACK</tt> message. Additionally,
          NORM receivers SHALL construct <tt>NORM_NACK</tt>
          messages with their repair requests in ordinal order with respect to
          "object_transport_id" and "fec_payload_id" values. The
          "nack_payload" size SHALL NOT exceed the <em>NormSegmentSize</em>
          for the sender to which the <tt>NORM_NACK</tt> is
          destined.
</p>
<p><strong>NORM_NACK Content Examples:</strong>
</p>
<p>In these examples, a small block, systematic FEC code ("fec_id" =
          129) is assumed with a user data block length of 32 segments. In
          Example 1, a list of individual <tt>NORM_NACK_ITEMS</tt>
          repair requests is given. In Example 2, a list of <tt>NORM_NACK_RANGES</tt> requests AND a single <tt>NORM_NACK_ITEMS</tt> request are concatenated to
          illustrate the possible content of a <tt>NORM_NACK</tt>
          message. Note that FEC coding block erasure counts could also be
          provided in each case. However, the erasure counts are not really
          necessary since the sender can easily determine the erasure count
          while processing the NACK content. However, the erasure count option
          may be useful for operation with other FEC codes or for intermediate
          system purposes.
</p>
<p style='text-align: center'>Example 1: <tt>NORM_NACK</tt>
            "nack_payload" for: Object 12, Coding Block 3, Segments 2,5,and
            8
</p><div style='display: table; width: 0; margin-left: auto; margin-right: auto'><pre> 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|   form = 1    | flags = 0x01  |       length  = 36            |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|  fec_id = 129 |   reserved    |    object_transport_id = 12   |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                    source_block_number = 3                    |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|    source_block_length = 32   |    encoding_symbol_id = 2     |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|  fec_id = 129 |   reserved    |    object_transport_id = 12   |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                    source_block_number = 3                    |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|    source_block_length = 32   |    encoding_symbol_id = 5     |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|  fec_id = 129 |   reserved    |    object_transport_id = 12   |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                    source_block_number = 3                    |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|    source_block_length = 32   |    encoding_symbol_id = 8     |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</pre></div>
<p style='text-align: center'>Example 2: <tt>NORM_NACK</tt>
            "nack_payload" for: Object 18, Coding Block 6, Segments 5, 6, 7,
            8, 9, 10; and Object 19 <tt>NORM_INFO</tt> and
            Coding Block 1, segment 3
</p><div style='display: table; width: 0; margin-left: auto; margin-right: auto'><pre> 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|   form = 2    | flags = 0x01  |       length  = 24            |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|  fec_id = 129 |   reserved    |    object_transport_id = 18   |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                    source_block_number = 6                    |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|    source_block_length = 32   |    encoding_symbol_id = 5     |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|  fec_id = 129 |   reserved    |    object_transport_id = 18   |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                    source_block_number = 6                    |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|    source_block_length = 32   |    encoding_symbol_id = 10    |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|   form = 1    | flags = 0x05  |       length  = 12            |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|  fec_id = 129 |   reserved    |    object_transport_id = 19   |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                    source_block_number = 1                    |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|    source_block_length = 32   |    encoding_symbol_id = 3     |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</pre></div>
<a name="anchor23"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.3.2"></a><h3>4.3.2.&nbsp;
NORM_ACK Message</h3>

<p>The <tt>NORM_ACK</tt> message is intended to
          be used primarily as part of NORM congestion control operation and
          round-trip timing measurement. As mentioned in the <tt>NORM_CMD(ACK_REQ)</tt> message description, the
          acknowledgment type <tt>NORM_ACK_CC</tt> is
          provided for this purpose. The generation of <tt>NORM_ACK(CC)</tt>
          messages for round-trip timing estimation and congestion-control
          operation is described in <a class='info' href='#GrttCollection'>Section&nbsp;5.5.1<span> (</span><span class='info'>Greatest Round-trip Time Collection</span><span>)</span></a> and
          <a class='info' href='#CongestionControl'>Section&nbsp;5.5.2<span> (</span><span class='info'>NORM Congestion Control Operation</span><span>)</span></a>, respectively. However,
          some multicast applications may benefit from some limited form of
          positive acknowledgment for certain functions. A simple, scalable
          positive acknowledgment scheme is defined in <a class='info' href='#PositiveAcknowledgment'>Section&nbsp;5.5.3<span> (</span><span class='info'>NORM Positive Acknowledgment Procedure</span><span>)</span></a> that can be leveraged by
          protocol implementations when appropriate. The <tt>NORM_CMD(FLUSH)</tt>
          may be used for OPTIONAL collection of positive acknowledgment of
          reliable reception to a certain "watermark" transmission point from
          specific receivers using this mechanism. The <tt>NORM_ACK</tt>
          type <tt>NORM_ACK_FLUSH</tt> is provided for this
          purpose and the format of the "nack_payload" for this acknowledgment
          type is given below. Beyond that, a range of application-defined
          "ack_type" values is provided for use at the NORM application's
          discretion. Implementations making use of application-defined
          positive acknowledgments may also make use the "nack_payload" as
          needed, observing the constraint that the "nack_payload" field size
          be limited to a maximum of the <em>NormSegmentSize</em>
          for the sender to which the <tt>NORM_ACK</tt> is
          destined.
</p><br /><hr class="insert" />
<div style='display: table; width: 0; margin-left: auto; margin-right: auto'><pre> 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|version| type=5|    hdr_len    |          sequence             |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                           source_id                           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                           server_id                           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|           instance_id         |    ack_type  |     ack_id     |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                       grtt_response_sec                       |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                       grtt_response_usec                      |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|               header extensions (if applicable)               |
|                              ...                              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                   ack_payload (if applicable)                 |
|                              ...                              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;NORM_ACK Message Format&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>The NORM common message header fields serve their usual purposes.
          The value of the "hdr_len" field when no header extensions are
          present is 6.
</p>
<p>The "server_id", "instance_id", and "grtt_response" fields serve
          the same purpose as the corresponding fields in <tt>NORM_NACK</tt>
          messages. And header extensions may be applied to support congestion
          control feedback or other functions in the same manner.
</p>
<p>The "ack_type" field indicates the nature of the <tt>NORM_ACK</tt> message. This directly corresponds to
          the "ack_type" field of the <tt>NORM_CMD(ACK_REQ)</tt>
          message to which this acknowledgment applies.
</p>
<p>The "ack_id" field serves as a sequence number so that the sender
          can verify that a <tt>NORM_ACK</tt> message
          received actually applies to a current acknowledgment request. The
          "ack_id" field is not used in the case of the <tt>NORM_ACK_CC</tt>
          and <tt>NORM_ACK_FLUSH</tt> acknowledgment
          types.
</p>
<p>The "ack_payload" format is a function of the "ack_type". The
          <tt>NORM_ACK_CC</tt> message has no attached
          content. Only the <tt>NORM_ACK</tt> header
          applies. In the case of <tt>NORM_ACK_FLUSH</tt>,
          a specific "ack_payload" format is defined:
</p><div style='display: table; width: 0; margin-left: auto; margin-right: auto'><pre> 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|     fec_id    |   reserved    |      object_transport_id      |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                        fec_payload_id                         |
|                              ...                              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</pre></div>
<p>The "object_transport_id" and "fec_payload_id" are used by the
          receiver to acknowledge applicable <tt>NORM_CMD(FLUSH)</tt>
          messages transmitted by the sender identified by the "server_id"
          field.
</p>
<p>The "ack_payload" of <tt>NORM_ACK</tt>
          messages for application-defined "ack_type" values is specific to
          the application but is limited in size to a maximum the <em>NormSegmentSize</em> of the sender referenced by the
          "server_id".
</p>
<a name="anchor24"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.4"></a><h3>4.4.&nbsp;
General Purpose Messages</h3>

<p>Some additional message formats are defined for general purpose in
        NORM multicast sessions whether the participant is acting as a sender
        and/or receiver within the group.
</p>
<a name="anchor25"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.4.1"></a><h3>4.4.1.&nbsp;
NORM_REPORT Message</h3>

<p>This is an OPTIONAL message generated by NORM participants. This
          message may be used for periodic performance reports from receivers
          in experimental NORM implementations. The format of this message is
          currently undefined. Experimental NORM implementations may define
          <tt>NORM_REPORT</tt> formats as needed for test
          purposes. These report messages SHOULD be disabled for
          interoperability testing between different compliant NORM
          implementations.
</p>
<a name="ProtocolDetails"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5"></a><h3>5.&nbsp;
Detailed Protocol Operation</h3>

<p>This section describes the detailed interactions of senders and
      receivers participating in a NORM session. A simple synopsis of protocol
      operation is given here:
</p>
<p></p>
<ol class="text">
<li>The sender periodically transmits <tt>NORM_CMD(CC)</tt>
          messages as needed to initialize and collect round-trip timing and
          congestion control feedback from the receiver set.
</li>
<li>The sender transmits an ordinal set of <em>NormObjects</em>
          segmented in the form of <tt>NORM_DATA</tt>
          messages labeled with <em>NormTransportIds</em>
          and logically identified with FEC encoding block numbers and symbol
          identifiers. <tt>NORM_INFO</tt> messages may
          optionally precede the transmission of data content for NORM
          transport objects.
</li>
<li>As receivers detect missing content from the sender, they
          initiate repair requests with <tt>NORM_NACK</tt>
          messages. Note the receivers track the sender's most recent <em>objectId::fecPayloadId</em> transmit position and
          NACK ONLY for content ordinally prior to that transmit position. The
          receivers schedule random backoff timeouts before generating <tt>NORM_NACK</tt> messages and wait an appropriate
          amount of time before repeating the <tt>NORM_NACK</tt>
          if their repair request is not satisfied.
</li>
<li>The sender aggregates repair requests from the receivers and
          logically "rewinds" its transmit position to send appropriate repair
          messages. The sender sends repairs for the earliest ordinal transmit
          position first and maintains this ordinal repair transmission
          sequence. FEC parity content not previously transmitted for the
          applicable FEC coding block is used for repair transmissions to the
          greatest extent possible. If the sender exhausts its available FEC
          parity content on multiple repair cycles for the same coding block,
          it resorts to an explicit repair strategy (possibly using parity
          content) to complete repairs. (The use of explicit repair is
          expected to be an exception in general protocol operation, but the
          possibility does exist for extreme conditions). The sender
          immediately assumes transmission of new content once it has sent
          pending repairs.
</li>
<li>The sender transmits <tt>NORM_CMD(FLUSH)</tt>
          messages when it reaches the end of enqueued transmit content and
          pending repairs. Receivers respond to the <tt>NORM_CMD(FLUSH)</tt>
          messages with <tt>NORM_NACK</tt> transmissions
          (following the same suppression backoff timeout strategy as for
          data) if they require further repair.
</li>
<li>The sender transmissions are subject to rate control limits
          determined by congestion control mechanisms. In the baseline NORM-CC
          operation, each sender in a <em>NormSession</em>
          maintains its own independent congestion control state. Receivers
          provide congestion control feedback in <tt>NORM_NACK</tt>
          and <tt>NORM_ACK</tt> messages. <tt>NORM_ACK</tt> feedback for congestion control
          purposes is governed using a suppression mechanism similar to that
          for <tt>NORM_NACK</tt> messages.
</li>
</ol>

<p>While this overall concept is relatively simple, there are details to
      each of these aspects that need to be addressed for successful,
      efficient, robust, and scalable NORM protocol operation.
</p>
<a name="anchor26"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.1"></a><h3>5.1.&nbsp;
Sender Initialization and Transmission</h3>

<p>Upon startup, the NORM sender immediately begins sending <tt>NORM_CMD(CC)</tt> messages to collect round trip
        timing and other information from the potential group. If NORM-CC
        congestion control operation is enabled, the NORM-CC Rate header
        extension MUST be included in these messages. Congestion control
        operation SHALL be observed at all times when not operating using
        dedicated resources, like in the general Internet. Even if congestion
        control operation is disabled at the sender, it may be desirable to
        use the <tt>NORM_CMD(CC)</tt> messaging to collect
        feedback from the group using the baseline NORM-CC feedback
        mechanisms. This proactive feedback collection can be used to
        establish a GRTT estimate prior to data transmission and potential
        NACK operation.
</p>
<p>In some cases, applications may wish for the sender to also proceed
        with data transmission immediately. In other cases, the sender may
        wish to defer data transmission until it has received some feedback or
        request from the receiver set indicating that receivers are indeed
        present. Note, in some applications (e.g., web push), this indication
        may come out-of-band with respect to the multicast session via other
        means. As noted, the periodic transmission of <tt>NORM_CMD(CC)</tt>
        messages may precede actual data transmission in order to have an
        initial GRTT estimate.
</p>
<p>With inclusion of the OPTIONAL NORM FEC Object Transmission
        Information Header Extension (EXT_FTI), the NORM protocol sender
        message headers can contain all information necessary to prepare
        receivers for subsequent reliable reception. This includes FEC coding
        parameters, the sender <em>NormSegmentSize</em>,
        and other information. If this header extension is not used, it is
        presumed that receivers have received the FEC Object Transmission
        Information via other means. Additionally, applications may leverage
        the use of <tt>NORM_INFO</tt> messages associated
        with the session data objects in the session to provide
        application-specific context information for the session and data
        being transmitted. These mechanisms allow for operation with minimal
        pre-coordination among the senders and receivers.
</p>
<p>The NORM sender begins segmenting application-enqueued data into
        <tt>NORM_DATA</tt> segments and transmitting it to
        the group. For objects of type <tt>NORM_OBJECT_DATA</tt>
        and <tt>NORM_OBJECT_FILE</tt>, the segmentation
        algorithm described in <a class='info' href='#RFC5052'>FEC Building
        Block<span> (</span><span class='info'>Watson, M., Luby, M., and L. Vicisano, &ldquo;Forward Error Correction (FEC) Building Block,&rdquo; August&nbsp;2007.</span><span>)</span></a> [RFC5052] is RECOMMENDED. For objects of type <tt>NORM_OBJECT_STREAM</tt>,
        segmentation will typically be into uniform FEC coding block sizes,
        with individual segment sizes controlled by the application. In most
        cases, the application and NORM implementation SHOULD strive to
        produce full-sized (<tt>NormSegmentSize</tt>)
        segments when possible. The rate of transmission is controlled via
        congestion control mechanisms or is a fixed rate if desired for closed
        network operations. The receivers participating in the multicast group
        provide feedback to the sender as needed. When the sender reaches the
        end of data it has enqueued for transmission or any pending repairs,
        it transmits a series of <tt>NORM_CMD(FLUSH)</tt>
        messages at a rate of one per <tt>2*GRTT</tt>.
        Receivers may respond to these <tt>NORM_CMD(FLUSH)</tt>
        messages with additional repair requests. A protocol parameter "<tt>NORM_ROBUST_FACTOR</tt>" determines the number of
        flush messages sent. If receivers request repair, the repair is
        provided and flushing occurs again at the end of repair transmission.
        The sender may attach an OPTIONAL "acking_node_list" to <tt>NORM_CMD(FLUSH)</tt> containing the <em>NormNodeIds</em> for receivers from which it expects
        explicit positive acknowledgment of reception. The <tt>NORM_CMD(FLUSH)</tt> message may be also used for this
        optional function any time prior to the end of data enqueued for
        transmission with the <tt>NORM_CMD(FLUSH)</tt>
        messages multiplexed with ongoing data transmissions. The OPTIONAL
        NORM positive acknowledgment procedure is described in <a class='info' href='#PositiveAcknowledgment'>Section&nbsp;5.5.3<span> (</span><span class='info'>NORM Positive Acknowledgment Procedure</span><span>)</span></a>.
</p>
<a name="SegmentationAlgorithm"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.1.1"></a><h3>5.1.1.&nbsp;
Object Segmentation Algorithm</h3>

<p>NORM senders and receivers MUST use a common algorithm for
          logically segmenting transport data into FEC encoding blocks and
          symbols so that appropriate NACKs can be constructed to request
          repair of missing data. NORM FEC coding blocks are comprised of
          multi-byte symbols (segments) that are transmitted in the payload of
          <tt>NORM_DATA</tt> messages. Each <tt>NORM_DATA</tt> message will contain one or more
          source or encoding symbol(s) identified by the "fec_payload_id"
          field and the <em>NormSegmentSize</em> sender
          parameter defines the maximum size (in bytes) of the "payload_data"
          field containing the content (a "segment"). The FEC encoding type
          and associated parameters govern the source block size (number of
          source symbols per coding block, etc.). NORM senders and receivers
          use these FEC parameters, along with the <em>NormSegmentSize</em>
          and transport object size to compute the source block structure for
          transport objects. These parameters are provided in the FEC Object
          Transmission Information for each object. The block partitioning
          algorithm described in the <a class='info' href='#RFC5052'>FEC Building
          Block<span> (</span><span class='info'>Watson, M., Luby, M., and L. Vicisano, &ldquo;Forward Error Correction (FEC) Building Block,&rdquo; August&nbsp;2007.</span><span>)</span></a> [RFC5052] is RECOMMENDED for use to compute a source block
          structure such that all source blocks are as close to being equal
          length as possible. This helps avoid the performance disadvantages
          of "short" FEC blocks. Note this algorithm applies only to the
          statically-sized <tt>NORM_OBJECT_DATA</tt> and
          <tt>NORM_OBJECT_FILE</tt> transport object types
          where the object size is fixed and predetermined. For <tt>NORM_OBJECT_STREAM</tt> objects, the object is
          segmented according to the maximum source block length given in the
          FEC Transmission Information, unless the FEC Payload ID indicates an
          alternative size for a given block.
</p>
<a name="anchor27"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.2"></a><h3>5.2.&nbsp;
Receiver Initialization and Reception</h3>

<p>The NORM protocol is designed such that receivers may join and
        leave the group at will. However, some applications may be constrained
        such that receivers need to be members of the group prior to start of
        data transmission. NORM applications may use different policies to
        constrain the impact of new receivers joining the group in the middle
        of a session. For example, a useful implementation policy is for new
        receivers joining the group to limit or avoid repair requests for
        transport objects already in progress. The NORM sender implementation
        may wish to impose additional constraints to limit the ability of
        receivers to disrupt reliable multicast performance by joining,
        leaving, and rejoining the group often. Different receiver "join
        policies" may be appropriate for different applications and/or
        scenarios. For general purpose operation, a default policy where
        receivers are allowed to request repair only for coding blocks with a
        <em>NormTransportId</em> and FEC coding block
        number greater than or equal to the first non-repair <tt>NORM_DATA</tt> or <tt>NORM_INFO</tt>
        message received upon joining the group is RECOMMENDED. For objects of
        type <tt>NORM_OBJECT_STREAM</tt> it is RECOMMENDED
        that the join policy constrain receivers to start reliable reception
        at the current FEC coding block for which non-repair content is
        received.
</p>
<p>For typical operation, it is expected that NORM receivers will join
        a specified multicast group and/or listen on an specific port number
        for sender transmissions. As the NORM receiver receives <tt>NORM_DATA</tt> messages it will provide content to its
        application as appropriate.
</p>
<a name="NackProcedure"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.3"></a><h3>5.3.&nbsp;
Receiver NACK Procedure</h3>

<p>When the receiver detects it is missing data from a sender's NORM
        transmissions, it initiates its NACKing procedure. The NACKing
        procedure SHALL be initiated ONLY at FEC coding block boundaries,
        <em>NormObject</em> boundaries, upon receipt of a
        <tt>NORM_CMD(FLUSH)</tt> message, or upon an
        "inactivity" timeout when <tt>NORM_DATA</tt> or
        <tt>NORM_INFO</tt> transmissions are no longer
        received from a previously active sender. The RECOMMENDED value of
        such an inactivity timeout is:
</p><div style='display: table; width: 0; margin-left: auto; margin-right: auto'><pre>T_inactivity = NORM_ROBUST_FACTOR * 2 * GRTTSender</pre></div>
<p>where the "<tt>GRTTsender</tt>" value
        corresponds to the GRTT estimate advertised in the "grtt" field of
        NORM sender messages. A minimum "<tt>T_inactivity</tt>"
        value of 1 second is RECOMMENDED. The NORM receiver SHOULD reset this
        inactivity timer and repeat NACK initiation upon timeout for up to
        <tt>NORM_ROBUST_FACTOR</tt> times or more depending
        upon the application's need for persistence by its receivers. It is
        also important that receivers rescale the "<tt>T_inactivity</tt>"
        timeout as the sender's advertised GRTT changes.
</p>
<p>The NACKing procedure begins with a random backoff timeout. The
        duration of the backoff timeout is chosen using the "RandomBackoff"
        algorithm described in the <a class='info' href='#RFC5401'>Multicast NACK
        Building Block<span> (</span><span class='info'>Adamson, B., Bormann, C., Handley, M., and J. Macker, &ldquo;Multicast Negative-Acknowledgment (NACK) Building Blocks,&rdquo; November&nbsp;2008.</span><span>)</span></a> [RFC5401] using (<tt>Ksender*GRTTsender</tt>)
        for the <tt>maxTime</tt> parameter and the sender
        advertised group size (<tt>GSIZEsender</tt>) as the
        <tt>groupSize</tt> parameter. NORM senders provide
        values for <tt>GRTTsender</tt>, <tt>Ksender</tt> and <tt>GSIZEsender</tt>
        via the "grtt", "backoff", and "gsize" fields of transmitted messages.
        The <tt>GRTTsender</tt> value is determined by the
        sender based on feedback it has received from the group while the
        <tt>Ksender</tt> and <tt>GSIZEsender</tt>
        values may determined by application requirements and expectations or
        ancillary information. The backoff factor "<tt>Ksender</tt>"
        MUST be greater than <tt>one</tt> to provide for
        effective feedback suppression. A value of <tt>K = 4</tt>
        is RECOMMENDED for the Any Source Multicast (ASM) model while a value
        of <tt>K = 6</tt> is RECOMMENDED for Single Source
        Multicast (SSM) operation.
</p>
<p>Thus:
</p><div style='display: table; width: 0; margin-left: auto; margin-right: auto'><pre>T_backoff = RandomBackoff(Ksender*GRTTsender, GSIZEsender)</pre></div>
<p>To avoid the possibility of NACK implosion in the case of sender or
        network failure during SSM operation, the receiver SHALL automatically
        suppress its NACK and immediately enter the "holdoff" period described
        below when <tt>T_backoff</tt> is greater than
        <tt>(Ksender-1)*GRTTsender</tt>. Otherwise, the
        backoff period is entered and the receiver MUST accumulate external
        pending repair state from <tt>NORM_NACK</tt>
        messages and <tt>NORM_CMD(REPAIR_ADV)</tt> messages
        received. At the end of the backoff time, the receiver SHALL generate
        a <tt>NORM_NACK</tt> message only if the following
        conditions are met:
</p>
<p></p>
<ol class="text">
<li>The sender's current transmit position (in terms of <em>objectId::fecPayloadId</em>) exceeds the earliest
            repair position of the receiver.
</li>
<li>The repair state accumulated from <tt>NORM_NACK</tt>
            and <tt>NORM_CMD(REPAIR_ADV)</tt> messages do
            not equal or supersede the receiver's repair needs up to the
            sender transmission position at the time the NACK procedure
            (backoff timeout) was initiated.
</li>
</ol>

<p>If these conditions are met, the receiver immediately generates a
        <tt>NORM_NACK</tt> message when the backoff timeout
        expires. Otherwise, the receiver's NACK is considered to be
        "suppressed" and the message is not sent. At this time, the receiver
        begins a "holdoff" period during which it constrains itself to not
        re-initiate the NACKing process. The purpose of this timeout is to
        allow the sender worst-case time to respond to the repair needs before
        the receiver requests repair again. The value of this "holdoff"
        timeout (<tt>T_rcvrHoldoff</tt>) as described in
        <a class='info' href='#RFC5401'>[RFC5401]<span> (</span><span class='info'>Adamson, B., Bormann, C., Handley, M., and J. Macker, &ldquo;Multicast Negative-Acknowledgment (NACK) Building Blocks,&rdquo; November&nbsp;2008.</span><span>)</span></a> is:
</p><div style='display: table; width: 0; margin-left: auto; margin-right: auto'><pre>T_rcvrHoldoff =(Ksender+2)*GRTTsender</pre></div>
<p>The <tt>NORM_NACK</tt> message contains repair
        request content beginning with lowest ordinal repair position of the
        receiver up through the coding block prior to the most recently heard
        ordinal transmission position for the sender. If the size of the
        <tt>NORM_NACK</tt> content exceeds the sender's
        <em>NormSegmentSize</em>, the NACK content is
        truncated so that the receiver only generates a single <tt>NORM_NACK</tt> message per NACK cycle for a given
        sender. In summary, a single NACK message is generated containing the
        receiver's lowest ordinal repair needs.
</p>
<p>For each partially-received FEC coding block requiring repair, the
        receiver SHALL, on its FIRST repair attempt for the block, request the
        parity portion of the FEC coding block beginning with the lowest
        ordinal parity "encoding_symbol_id" (i.e., "encoding_symbol_id" =
        "source_block_len") and request the number of FEC symbols
        corresponding to its data segment erasure count for the block. On
        subsequent repair cycles for the same coding block, the receiver SHALL
        request only those repair symbols from the first set it has not yet
        received up to the remaining erasure count for that applicable coding
        block. Note that the sender may have provided other different,
        additional parity segments for other receivers that could also be used
        to satisfy the local receiver's erasure-filling needs. In the case
        where the erasure count for a partially-received FEC coding block
        exceeds the maximum number of parity symbols available from the sender
        for the block (as indicated by the <tt>NORM_DATA</tt>
        "fec_num_parity" field), the receiver SHALL request all available
        parity segments plus the ordinally highest missing data segments
        required to satisfy its total erasure needs for the block. The goal of
        this strategy is for the overall receiver set to request a lowest
        common denominator set of repair symbols for a given FEC coding block.
        This allows the sender to construct the most efficient repair
        transmission segment set and enables effective NACK suppression among
        the receivers even with uncorrelated packet loss. This approach also
        requires no synchronization among the receiver set in their repair
        requests for the sender.
</p>
<p>For FEC coding blocks or <em>NormObjects</em>
        missed in their entirety, the NORM receiver constructs repair requests
        with <tt>NORM_NACK_BLOCK</tt> or <tt>NORM_NACK_OBJECT</tt> flags set as appropriate. The
        request for retransmission of <tt>NORM_INFO</tt> is
        accomplished by setting the <tt>NORM_NACK_INFO</tt>
        flag in a corresponding repair request.
</p>
<a name="anchor28"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.4"></a><h3>5.4.&nbsp;
Sender NACK Processing and Response</h3>

<p>The principle goal of the sender is to make forward progress in the
        transmission of data its application has enqueued. However, the sender
        must occasionally "rewind" its logical transmission point to satisfy
        the repair needs of receivers who have NACKed. Aggregation of multiple
        NACKs is used to determine an optimal repair strategy when a NACK
        event occurs. Since receivers initiate the NACK process on coding
        block or object boundaries, there is some loose degree of
        synchronization of the repair process even when receivers experience
        uncorrelated data loss.
</p>
<a name="anchor29"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.4.1"></a><h3>5.4.1.&nbsp;
Sender Repair State Aggregation</h3>

<p>When a sender is in its normal state of transmitting new data and
          receives a NACK, it begins a procedure to accumulate NACK repair
          state from <tt>NORM_NACK</tt> messages before
          beginning repair transmissions. Note that this period of aggregating
          repair state does NOT interfere with its ongoing transmission of new
          data.
</p>
<p>As described in <a class='info' href='#RFC5401'>[RFC5401]<span> (</span><span class='info'>Adamson, B., Bormann, C., Handley, M., and J. Macker, &ldquo;Multicast Negative-Acknowledgment (NACK) Building Blocks,&rdquo; November&nbsp;2008.</span><span>)</span></a>, the period of
          time during which the sender aggregates <tt>NORM_NACK</tt>
          messages is equal to:
</p><div style='display: table; width: 0; margin-left: auto; margin-right: auto'><pre>T_sndrAggregate = (Ksender+1)*GRTT</pre></div>
<p>where "<tt>Ksender</tt>" is the same backoff
          scaling value used by the receivers, and <tt>GRTT</tt>
          is the sender's current estimate of the group's greatest round-trip
          time. Note that for NORM unicast sessions the "<tt>T_sndrAggregate</tt>"
          time can be set to ZERO since there is only one receiver. Similarly,
          the "<tt>Ksender</tt>" value should be set to
          ZERO for NORM unicast sessions to minimize repair latency.
</p>
<p>When this period ends, the sender "rewinds" by incorporating the
          accumulated repair state into its pending transmission state and
          begins transmitting repair messages. After pending repair
          transmissions are completed, the sender continues with new
          transmissions of any enqueued data. Also, at this point in time, the
          sender begins a "holdoff" timeout during which time the sender
          constrains itself from initiating a new repair aggregation cycle,
          even if <tt>NORM_NACK</tt> messages arrive. As
          described in <a class='info' href='#RFC5401'>[RFC5401]<span> (</span><span class='info'>Adamson, B., Bormann, C., Handley, M., and J. Macker, &ldquo;Multicast Negative-Acknowledgment (NACK) Building Blocks,&rdquo; November&nbsp;2008.</span><span>)</span></a>, the value of this
          sender "holdoff" period is:
</p><div style='display: table; width: 0; margin-left: auto; margin-right: auto'><pre>T_sndrHoldoff = (1*GRTT)</pre></div>
<p>If additional <tt>NORM_NACK</tt> messages are
          received during this sender "holdoff" period, the sender will
          immediately incorporate these late-arriving messages into its
          pending transmission state ONLY if the NACK content is ordinally
          greater than the sender's current transmission position. This
          "holdoff" time allows worst case time for the sender to propagate
          its current transmission sequence position to the group, thus
          avoiding redundant repair transmissions. After the holdoff timeout
          expires, a new NACK accumulation period can be begun (upon arrival
          of a NACK) in concert with the pending repair and new data
          transmission. Recall that receivers are not to initiate the NACK
          repair process until the sender's logical transmission position
          exceeds the lowest ordinal position of their repair needs. With the
          new NACK aggregation period, the sender repeats the same process of
          incorporating accumulated repair state into its transmission plan
          and subsequently "rewinding" to transmit the lowest ordinal repair
          data when the aggregation period expires. Again, this is conducted
          in concert with ongoing new data and/or pending repair
          transmissions.
</p>
<a name="anchor30"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.4.2"></a><h3>5.4.2.&nbsp;
Sender FEC Repair Transmission Strategy</h3>

<p>The NORM sender should leverage transmission of FEC parity
          content for repair to the greatest extent possible. Recall that the
          receivers use a strategy to request a lowest common denominator of
          explicit repair (including parity content) in the formation of their
          <tt>NORM_NACK</tt> messages. Before falling back
          to explicitly satisfying different receivers' repair needs, the
          sender can make use of the general erasure-filling capability of
          FEC-generated parity segments. The sender can determine the maximum
          erasure filling needs for individual FEC coding blocks from the
          <tt>NORM_NACK</tt> messages received during the
          repair aggregation period. Then, if the sender has a sufficient
          number (less than or equal to the maximum erasure count) of
          previously unsent parity segments available for the applicable
          coding blocks, the sender can transmit these in lieu of the specific
          packets the receiver set has requested. Only after exhausting its
          supply of "fresh" (unsent) parity segments for a given coding block
          should the sender resort to explicit transmission of the receiver
          set's repair needs. In general, if a sufficiently powerful FEC code
          is used, the need for explicit repair will be an exception, and the
          fulfillment of reliable multicast can be accomplished quite
          efficiently. However, the ability to resort to explicit repair
          allows the protocol to be reliable under even very extreme
          circumstances.
</p>
<p><tt>NORM_DATA</tt> messages sent as repair
          transmissions SHALL be flagged with the <tt>NORM_FLAG_REPAIR</tt>
          flag. This allows receivers to obey any policies that limit new
          receivers from joining the reliable transmission when only repair
          transmissions have been received. Additionally, the sender SHOULD
          additionally flag <tt>NORM_DATA</tt>
          transmissions sent as explicit repair with the <tt>NORM_FLAG_EXPLICIT</tt>
          flag.
</p>
<p>Although NORM end system receivers do not make use of the <tt>NORM_FLAG_EXPLICIT</tt> flag, this message
          transmission status could be leveraged by intermediate systems
          wishing to "assist" NORM protocol performance. If such systems are
          properly positioned with respect to reciprocal reverse-path
          multicast routing, they need to sub-cast only a sufficient count of
          non-explicit parity repairs to satisfy a multicast routing
          sub-tree's erasure filling needs for a given FEC coding block. When
          the sender has resorted to explicit repair, then the intermediate
          systems should sub-cast all of the explicit repair packets to those
          portions of the routing tree still requiring repair for a given
          coding block. Note the intermediate systems will be required to
          conduct repair state accumulation for sub-routes in a manner similar
          to the sender's repair state accumulation in order to have
          sufficient information to perform the sub-casting. Additionally, the
          intermediate systems could perform additional <tt>NORM_NACK</tt>
          suppression/aggregation as it conducts this repair state
          accumulation for NORM repair cycles. The detail of this type of
          operation are beyond the scope of this document, but this
          information is provided for possible future consideration.
</p>
<a name="anchor31"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.4.3"></a><h3>5.4.3.&nbsp;
Sender NORM_CMD(SQUELCH) Generation</h3>

<p>If the sender receives a <tt>NORM_NACK</tt>
          message for repair of data it is no longer supporting, the sender
          generates a <tt>NORM_CMD(SQUELCH)</tt> message to
          advertise its repair window and squelch any receivers from
          additional NACKing of invalid data. The transmission rate of <tt>NORM_CMD(SQUELCH)</tt> messages is limited to once
          per <tt>2*GRTT</tt>. The "invalid_object_list"
          (if applicable) of the <tt>NORM_CMD(SQUELCH)</tt>
          message SHALL begin with the lowest "object_transport_id" from the
          invalid <tt>NORM_NACK</tt> messages received
          since the last <tt>NORM_CMD(SQUELCH)</tt>
          transmission. Lower ordinal invalid "object_transport_ids" should be
          included only while the <tt>NORM_CMD(SQUELCH)</tt>
          payload is less than the sender's <em>NormSegmentSize</em>
          parameter.
</p>
<a name="anchor32"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.4.4"></a><h3>5.4.4.&nbsp;
Sender NORM_CMD(REPAIR_ADV) Generation</h3>

<p>When a NORM sender receives <tt>NORM_NACK</tt>
          messages from receivers via unicast transmission, it uses <tt>NORM_CMD(REPAIR_ADV)</tt> messages to advertise its
          accumulated repair state to the receiver set since the receiver set
          is not directly sharing their repair needs via multicast
          communication. A NORM sender implementation MAY use a separate port
          number from the <em>NormSession</em> port number
          as the source port for its transmissions. Thus NORM receivers can
          direct any unicast feedback messages to this sender port number that
          is distinct from the NORM session (or destination) port number.
          Then, the NORM sender implementation can discriminate unicast
          feedback messages from multicast feedback messages when there is a
          mix of multicast and unicast feedback receivers. The <tt>NORM_CMD(REPAIR_ADV)</tt> message is multicast to
          the receiver set by the sender. The payload portion of this message
          has content in the same format as the <tt>NORM_NACK</tt>
          receiver message payload. Receivers are then able to perform
          feedback suppression in the same manner as with <tt>NORM_NACK</tt>
          messages directly received from other receivers. Note the sender
          does not merely retransmit NACK content it receives, but instead
          transmits a representation of its aggregated repair state. The
          transmission of <tt>NORM_CMD(REPAIR_ADV)</tt>
          messages are subject to the sender transmit rate limit and <em>NormSegmentSize</em> limitation. When the <tt>NORM_CMD(REPAIR_ADV)</tt> message is of maximum
          size, receivers SHALL consider the maximum ordinal transmission
          position value embedded in the message as the senders current
          transmission position and implicitly suppress requests for ordinally
          higher repair. For congestion control operation, the sender may also
          need to provide information so that dynamic congestion control
          feedback can be suppressed as needed among receivers. This document
          specifies the NORM-CC Feedback Header Extension that is applied for
          baseline NORM-CC operation. If other congestion control mechanisms
          are used within a NORM implementation, other header extensions may
          be defined. Whatever content format is used for this purpose should
          ensure that maximum possible suppression state is conveyed to the
          receiver set.
</p>
<a name="anchor33"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.5"></a><h3>5.5.&nbsp;
Additional Protocol Mechanisms</h3>

<p>In addition to the principal function of data content transmission
        and repair, there are some other protocol mechanisms that help NORM to
        adapt to network conditions and play fairly with other coexistent
        protocols.
</p>
<a name="GrttCollection"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.5.1"></a><h3>5.5.1.&nbsp;
Greatest Round-trip Time Collection</h3>

<p>For NORM receivers to appropriately scale backoff timeouts and
          the senders to use proper corresponding timeouts, the participants
          must agree on a common timeout basis. Each NORM sender monitors the
          round-trip time of active receivers and determines the group
          greatest round-trip time (GRTT). The sender advertises this GRTT
          estimate in every message it transmits so that receivers have this
          value available for scaling their timers. To measure the current
          GRTT, the sender periodically sends <tt>NORM_CMD(CC)</tt>
          messages that contain a locally generated timestamp. Receivers are
          expected to record this timestamp along with the time the <tt>NORM_CMD(CC)</tt> message is received. Then, when
          the receivers generate feedback messages to the sender, an adjusted
          version of the sender timestamp is embedded in the feedback message
          (<tt>NORM_NACK</tt> or <tt>NORM_ACK</tt>).
          The adjustment adds the amount of time the receiver held the
          timestamp before generating its response. Upon receipt of this
          adjusted timestamp, the sender is able to calculate the round-trip
          time to that receiver.
</p>
<p>The round-trip time for each receiver is fed into an algorithm
          that weights and smoothes the values for a conservative estimate of
          the GRTT. The algorithm and methodology are described in the <a class='info' href='#RFC5401'>Multicast NACK Building Block<span> (</span><span class='info'>Adamson, B., Bormann, C., Handley, M., and J. Macker, &ldquo;Multicast Negative-Acknowledgment (NACK) Building Blocks,&rdquo; November&nbsp;2008.</span><span>)</span></a> [RFC5401] in the section
          entitled "One-to-Many Sender GRTT Measurement". A conservative
          estimate helps guarantee feedback suppression at a small cost in
          overall protocol repair delay. The sender's current estimate of GRTT
          is advertised in the "grtt" field found in all NORM sender messages.
          The advertised GRTT is also limited to a minimum of the nominal
          inter-packet transmission time given the sender's current
          transmission rate and system clock granularity. The reason for this
          additional limit is to keep the receiver somewhat event-driven by
          making sure the sender has had adequate time to generate any
          response to repair requests from receivers given transmit rate
          limitations due to congestion control or configuration.
</p>
<p>When the NORM-CC Rate header extension is present in <tt>NORM_CMD(CC)</tt> messages, the receivers respond to
          <tt>NORM_CMD(CC)</tt> messages as described in
          <a class='info' href='#CongestionControl'>Section&nbsp;5.5.2<span> (</span><span class='info'>NORM Congestion Control Operation</span><span>)</span></a>, "NORM Congestion Control
          Operation". The <tt>NORM_CMD(CC)</tt> messages
          are periodically generated by the sender as described for congestion
          control operation. This provides for proactive, but controlled,
          feedback from the group in the form of <tt>NORM_ACK</tt>
          messages. This provides for GRTT feedback even if no <tt>NORM_NACK</tt> messages are being sent. If operating
          without congestion control in a closed network, the <tt>NORM_CMD(CC)</tt> messages may be sent periodically
          without the NORM-CC Rate header extension. In this case, receivers
          will only provide GRTT measurement feedback when <tt>NORM_NACK</tt> messages are generated since no
          <tt>NORM_ACK</tt> messages are generated. In this
          case, the <tt>NORM_CMD(CC)</tt> messages may be
          sent less frequently, perhaps as little as once per minute, to
          conserve network capacity. Note that the NORM-CC Rate header
          extension may also be used to proactively solicit RTT feedback from
          the receiver group per congestion control operation even though the
          sender may not be conducting congestion control rate adjustment.
          NORM operation without congestion control should be considered only
          in closed networks.
</p>
<a name="CongestionControl"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.5.2"></a><h3>5.5.2.&nbsp;
NORM Congestion Control Operation</h3>

<p>This section describes baseline congestion control operation for
          the NORM protocol (NORM-CC). The supporting NORM message formats and
          approach described here are an adaptation of the equation-based
          TCP-Friendly Multicast Congestion Control (TFMCC) approach<a class='info' href='#RFC4654'>[RFC4654]<span> (</span><span class='info'>Widmer, J. and M. Handley, &ldquo;TCP-Friendly Multicast Congestion Control (TFMCC): Protocol Specification,&rdquo; August&nbsp;2006.</span><span>)</span></a>. This congestion control scheme is REQUIRED
          for operation within the general Internet unless the NORM
          implementation is adapted to use another IETF-sanctioned reliable
          multicast congestion control mechanism. With this TFMCC-based
          approach, the transmissions of NORM senders are controlled in a
          rate-based manner as opposed to window-based congestion control
          algorithms as in TCP. However, it is possible that the NORM protocol
          message set may alternatively be used to support a window-based
          multicast congestion control scheme such as PGMCC. The details of
          that alternative may be described separately or in a future revision
          of this document. In either case (rate-based TFMCC or window-based
          PGMCC), successful control of sender transmission depends upon
          collection of sender-to-receiver packet loss estimates and RTTs to
          identify the congestion control bottleneck path(s) within the
          multicast topology and adjust the sender rate accordingly. The
          receiver with loss and RTT estimates that correspond to the lowest
          resulting calculated transmission rate is identified as the "current
          limiting receiver" (CLR). In the case of a tie (where candidate CLRs
          are within 10% of the same calculated rate), the receiver with the
          largest RTT value SHOULD be designated as the CLR.
</p>
<p>As described in <a class='info' href='#TcpModel'>[TcpModel]<span> (</span><span class='info'>Padhye,  J., Firoiu, V., Towsley, D., and J. Kurose, &ldquo;Modeling TCP Throughput: A Simple Model and its Empirical           Validation,&rdquo; 1998.</span><span>)</span></a>, a steady-state
          sender transmission rate, to be "friendly" with competing TCP flows
          can be calculated as:
</p><div style='display: table; width: 0; margin-left: auto; margin-right: auto'><pre>                                 S
Rsender = ----------------------------------------------------------
         tRTT*(sqrt((2/3)*p) + 12*sqrt((3/8)*p) * p * (1 + 32*(p^2)))</pre></div>
<p>where
</p>
<p><tt>S</tt> = nominal transmitted packet size.
          (In NORM, the "nominal" packet size can be determined by the sender
          as an exponentially weighted moving average (EWMA) of transmitted
          packet sizes to account for variable message sizes).
</p>
<p><tt>tRTT</tt> = RTT estimate of the current
          "current limiting receiver" (CLR).
</p>
<p><tt>p</tt> = loss event fraction of the
          CLR.
</p>
<p>To support congestion control feedback collection and operation,
          the NORM sender periodically transmits <tt>NORM_CMD(CC)</tt>
          command messages. <tt>NORM_CMD(CC)</tt> messages
          are multiplexed with NORM data and repair transmissions and serve
          several purposes:
</p>
<p></p>
<ol class="text">
<li>Stimulate explicit feedback from the general receiver set to
              collect congestion control information.
</li>
<li>Communicate state to the receiver set on the sender's current
              congestion control status including details of the CLR.
</li>
<li>Initiate rapid (immediate) feedback from the CLR in order to
              closely track the dynamics of congestion control for that
              current worst path in the group multicast topology.
</li>
</ol>

<p>The format of the <tt>NORM_CMD(CC)</tt>
          message is described in <a class='info' href='#NORM_CMD'>Section&nbsp;4.2.3<span> (</span><span class='info'>NORM_CMD Messages</span><span>)</span></a> of this
          document. The <tt>NORM_CMD(CC)</tt> message
          contains information to allow measurement of RTTs, to inform the
          group of the congestion control CLR, and to provide feedback of
          individual RTT measurements to the receivers in the group. The
          <tt>NORM_CMD(CC)</tt> also provides for exciting
          feedback from OPTIONAL "potential limiting receiver" (PLR) nodes
          that may be determined administratively or possibly algorithmically
          based on congestion control feedback. PLR nodes are receivers that
          have been identified to have potential for (perhaps soon) becoming
          the CLR and thus immediate, up-to-date feedback is beneficial for
          congestion control performance. The PLR list may be populated with a
          small number of receivers the sender identifies as approaching the
          CLR loss and delay conditions based on feedback from the group.
</p>
<a name="anchor34"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.5.2.1"></a><h3>5.5.2.1.&nbsp;
NORM_CMD(CC) Transmission</h3>

<p>The <tt>NORM_CMD(CC)</tt> message is
            transmitted periodically by the sender along with its normal data
            transmission. Note that the repeated transmission of <tt>NORM_CMD(CC)</tt> messages may be initiated some
            time before transmission of user data content at session startup.
            This may be done to collect some estimation of the current state
            of the multicast topology with respect to group and individual RTT
            and congestion control state.
</p>
<p>A <tt>NORM_CMD(CC)</tt> message is
            immediately transmitted at sender startup. The interval of
            subsequent <tt>NORM_CMD(CC)</tt> message
            transmission is determined as follows:
</p>
<p></p>
<ol class="text">
<li>By default, the interval is set according to the current
                sender GRTT estimate. A startup GRTT of 0.5 seconds is
                recommended when no feedback has yet been received from the
                group.
</li>
<li>Until a CLR has been identified (based on previous receiver
                feedback) or when no data transmission is pending, the <tt>NORM_CMD(CC)</tt> interval is doubled up from
                its current interval to a maximum of once per 30 seconds. This
                results in a low duty cycle for <tt>NORM_CMD(CC)</tt>
                probing when no CLR is identified or there is no pending data
                to transmit.
</li>
<li>When a CLR has been identified (based on receiver feedback)
                and data transmission is pending, the probing interval is set
                to the RTT between the sender and the CLR (<tt>RTT_clr</tt>).
</li>
<li>Additionally, when the data transmission rate is low with
                respect to the <tt>RTT_clr</tt> interval
                used for probing, the implementation should ensure that no
                more than one <tt>NORM_CMD(CC)</tt> message
                is sent per <tt>NORM_DATA</tt> message when
                there is data pending transmission. This ensures that the
                transmission of this control message is not done to the
                exclusion of user data transmission.
</li>
</ol>

<p>The <tt>NORM_CMD(CC)</tt> "cc_sequence"
            field is incremented with each transmission of a <tt>NORM_CMD(CC)</tt> command. The greatest
            "cc_sequence" recently received by receivers is included in their
            feedback to the sender. This allows the sender to determine the
            age of feedback to assist in congestion avoidance.
</p>
<p>The NORM-CC Rate Header Extension is applied to the <tt>NORM_CMD(CC)</tt> message and the sender
            advertises its current transmission rate in the "send_rate" field.
            The rate information is used by receivers to initialize loss
            estimation during congestion control startup or restart.
</p>
<p>The "cc_node_list" contains a list of entries identifying
            receivers and their current congestion control state (status
            "flags", "rtt" and "loss" estimates). The list may be empty if the
            sender has not yet received any feedback from the group. If the
            sender has received feedback, the list will minimally contain an
            entry identifying the CLR. A <tt>NORM_FLAG_CC_CLR</tt>
            flag value is provided for the "cc_flags" field to identify the
            CLR entry. It is RECOMMENDED that the CLR entry be the first in
            the list for implementation efficiency. Additional entries in the
            list are used to provide sender-measured individual RTT estimates
            to receivers in the group. The number of additional entries in
            this list is dependent upon the percentage of control traffic the
            sender application is willing to send with respect to user data
            message transmissions. More entries in the list may allow the
            sender to be more responsive to congestion control dynamics. The
            length of the list may be dynamically determined according to the
            current transmission rate and scheduling of <tt>NORM_CMD(CC)</tt>
            messages. The maximum length of the list corresponds to the
            sender's <em>NormSegmentSize</em> parameter for
            the session. The inclusion of additional entries in the list based
            on receiver feedback are prioritized with following rules:
</p>
<p></p>
<ol class="text">
<li>Receivers that have not yet been provided a RTT measurement
                get first priority. Of these, those with the greatest loss
                fraction receive precedence for list inclusion.
</li>
<li>Secondly, receivers that have previously been provided a
                RTT measurement are included with receivers yielding the
                lowest calculated congestion rate getting precedence.
</li>
</ol>

<p>There are "cc_flag" values in addition to <tt>NORM_FLAG_CC_CLR</tt>
            that are used for other congestion control functions. The <tt>NORM_FLAG_CC_PLR</tt> flag value is used to mark
            additional receivers from that the sender would like to have
            immediate, non-suppressed feedback. These may be receivers that
            the sender algorithmically identified as potential future CLRs or
            that have been pre-configured as potential congestion control
            points in the network. The <tt>NORM_FLAG_CC_RTT</tt>
            indicates the validity of the "cc_rtt" field for the associated
            receiver node. Normally, this flag will be set since the receivers
            in the list will typically be receivers from which the sender has
            received feedback. However, in the case that the NORM sender has
            been pre-configured with a set of PLR nodes, feedback from those
            receivers may not yet have been collected and thus the "cc_rtt"
            field does not contain a valid value when this flag is not set.
            Similarly, a value of ZERO for the "cc_rate" field here should be
            treated as an invalid value and be ignored for the purposes of
            feedback suppression, etc.
</p>
<a name="anchor35"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.5.2.2"></a><h3>5.5.2.2.&nbsp;
NORM_CMD(CC) Feedback Response</h3>

<p>Receivers explicitly respond to <tt>NORM_CMD(CC)</tt>
            messages in the form of a <tt>NORM_ACK(RTT)</tt>
            message. The goal of the congestion control feedback is to
            determine the receivers with the lowest congestion control rates.
            Receivers that are marked as CLR or PLR nodes in the <tt>NORM_CMD(CC)</tt> "cc_node_list" immediately
            provide feedback in the form of a <tt>NORM_ACK</tt>
            to this message. When a <tt>NORM_CMD(CC)</tt>
            is received, non-CLR or non-PLR nodes initiate random feedback
            backoff timeouts similar to that used when the receiver initiates
            a repair cycle (see <a class='info' href='#NackProcedure'>Section&nbsp;5.3<span> (</span><span class='info'>Receiver NACK Procedure</span><span>)</span></a>) in
            response to detection of data loss. The backoff timeout for the
            congestion control response is generated as follows:
</p><div style='display: table; width: 0; margin-left: auto; margin-right: auto'><pre>T_backoff = RandomBackoff(K*GRTTsender, GSIZEsender)</pre></div>
<p>The "<tt>RandomBackoff()</tt>" algorithm
            provides a truncated exponentially distributed random number and
            is described in the <a class='info' href='#RFC5401'>Multicast NACK Building
            Block<span> (</span><span class='info'>Adamson, B., Bormann, C., Handley, M., and J. Macker, &ldquo;Multicast Negative-Acknowledgment (NACK) Building Blocks,&rdquo; November&nbsp;2008.</span><span>)</span></a> [RFC5401]. The same backoff factor <tt>K = Ksender</tt>
            MAY be used as with <tt>NORM_NACK</tt>
            suppression. However, in cases where the application purposefully
            specifies a very small <tt>Ksender</tt> backoff
            factor to minimize the NACK repair process latency (trading off
            group size scalability), it is RECOMMENDED that a larger backoff
            factor for congestion control feedback is maintained, since there
            may often be a larger volume of congestion control feedback than
            NACKs in many cases and some congestion control feedback latency
            may be tolerable where reliable delivery latency is not. As
            previously noted, a backoff factor value of <tt>K = 4</tt>
            is generally recommended for ASM operation and <tt>K = 6</tt> for SSM operation. A receiver SHALL
            cancel the backoff timeout and thus its pending transmission of a
            <tt>NORM_ACK(RTT)</tt> message under the
            following conditions:
</p>
<p></p>
<ol class="text">
<li>The receiver generates another feedback message (<tt>NORM_NACK</tt> or other <tt>NORM_ACK</tt>)
                before the congestion control feedback timeout expires (these
                messages will convey the current congestion control feedback
                information),
</li>
<li>A <tt>NORM_CMD(CC)</tt> or other
                receiver feedback with an ordinally greater "cc_sequence"
                field value is received before the congestion control feedback
                timeout expires (this is similar to the TFMCC feedback round
                number),
</li>
<li>When the <tt>T_backoff</tt> is greater
                than <tt>1*GRTTsender</tt>. This prevents
                NACK implosion in the event of sender or network failure,
</li>
<li>"Suppressing" congestion control feedback is heard from
                another receiver (in a <tt>NORM_ACK</tt> or
                <tt>NORM_NACK</tt>) or via a <tt>NORM_CMD(REPAIR_ADV)</tt> message from the
                sender. The local receiver's feedback is "suppressed" if the
                rate of the competing feedback (<tt>Rfb</tt>)
                is sufficiently close to or less than the local receiver's
                calculated rate (<tt>Rcalc</tt>). The local
                receiver's feedback is canceled when <tt>Rcalc &gt; (0.9 * Rfb)</tt>.
                Also note receivers that have not yet received an RTT
                measurement from the sender are suppressed only by other
                receivers that have not yet measured RTT. Additionally,
                receivers whose RTT estimate has aged considerably (i.e., they
                haven't been included in the <tt>NORM_CMD(CC)</tt>
                "cc_node_list" in a long time) may wish to compete as a
                receiver with no prior RTT measurement after some long term
                expiration period.
</li>
</ol>

<p>When the backoff timer expires, the receiver SHALL generate a
            <tt>NORM_ACK(RTT)</tt> message to provide
            feedback to the sender and group. This message may be multicast to
            the group for most effective suppression in ASM topologies or
            unicast to the sender depending upon how the NORM protocol is
            deployed and configured.
</p>
<p>Whenever any feedback is generated (including this <tt>NORM_ACK(RTT)</tt> message), receivers include an
            adjusted version of the sender timestamp from the most recently
            received <tt>NORM_CMD(CC)</tt> message and the
            "cc_sequence" value from that command in the applicable <tt>NORM_ACK</tt> or <tt>NORM_NACK</tt>
            message fields. For NORM-CC operation, any generated feedback
            message SHALL also contain the NORM-CC Feedback header extension.
            The receiver provides its current "cc_rate" estimate, "cc_loss"
            estimate, "cc_rtt" if known, and any applicable "cc_flags" via
            this header extension.
</p>
<p>During <em>slow start</em> (when the
            receiver has not yet detected loss from the sender), the receiver
            uses a value equal to two times its measured rate from the sender
            in the "cc_rate" field. For steady-state congestion control
            operation, the receiver "cc_rate" value is from the equation-based
            value using its current loss event estimate and
            sender&lt;-&gt;receiver RTT information. (The GRTT is used when
            the receiver has not yet measured its individual RTT).
</p>
<p>The "cc_loss" field value reflects the receiver's current loss
            event estimate with respect to the sender in question.
</p>
<p>When the receiver has a valid individual RTT measurement, it
            SHALL include this value in the "cc_rtt" field. The <tt>NORM_FLAG_CC_RTT</tt> MUST be set when the
            "cc_rtt" field is valid.
</p>
<p>After a congestion control feedback message is generated or
            when the feedback is suppressed, a non-CLR receiver begins a
            "holdoff" timeout period during which it will restrain itself from
            providing congestion control feedback, even if <tt>NORM_CMD(CC)</tt> messages are received from the
            sender (unless the receive becomes marked as a CLR or PLR node).
            The value of this holdoff timeout (<tt>T_ccHoldoff</tt>)
            period is:
</p><div style='display: table; width: 0; margin-left: auto; margin-right: auto'><pre>T_ccHoldoff = (K*GRTT)</pre></div>
<p>Thus, non-CLR receivers are constrained to providing explicit
            congestion control feedback once per <tt>K*GRTT</tt>
            intervals. Note, however, that as the session progresses,
            different receivers will be responding to different <tt>NORM_CMD(CC)</tt> messages and there will be
            relatively continuous feedback of congestion control information
            while the sender is active.
</p>
<a name="anchor36"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.5.2.3"></a><h3>5.5.2.3.&nbsp;
Congestion Control Rate Adjustment</h3>

<p>During steady-state operation, the sender will directly adjust
            its transmission rate to the rate indicated by the feedback from
            its currently selected CLR. As noted in <a class='info' href='#TfmccPaper'>[TfmccPaper]<span> (</span><span class='info'>Widmer, J. and M. Handley, &ldquo;Extending Equation-Based Congestion Control to Multicast           Applications,&rdquo; August&nbsp;2001.</span><span>)</span></a>, the estimation of parameters (loss
            and RTT) for the CLR will generally constrain the rate changes
            possible within acceptable bounds. For rate increases, the sender
            SHALL observe a maximum rate of increase of one packet per RTT at
            all times during steady-state operation.
</p>
<p>The sender processes congestion control feedback from the
            receivers and selects the CLR based on the lowest rate receiver.
            Receiver rates are either determined directly from the <em>slow start</em> "cc_rate" provided by the receiver
            in the NORM-CC Feedback header extension or by performing the
            equation-based calculation using individual RTT and loss estimates
            ("cc_loss") as feedback is received.
</p>
<p>The sender can calculate a current RTT for a receiver (<tt>RTT_rcvrNew</tt>) using the "grtt_response"
            timestamp included in feedback messages. When the "cc_rtt" value
            in a response is not valid, the sender simply uses this <tt>RTT_rcvrNew</tt> value as the receiver's current
            RTT (<tt>RTT_rcvr</tt>). For non-CLR and
            non-PLR receivers, the sender can use the "cc_rtt" value provided
            in the NORM-CC Feedback header extension as the receiver's
            previous RTT measurement (<tt>RTT_rcvrPrev</tt>)
            to smooth according to:
</p><div style='display: table; width: 0; margin-left: auto; margin-right: auto'><pre>RTT_rcvr = 0.5 * RTT_rcvrPrev + 0.5 * RTT_rcvrNew</pre></div>
<p>For CLR receivers where feedback is received more regularly,
            the sender SHOULD maintain a more smoothed RTT estimate upon new
            feedback from the CLR where:
</p><div style='display: table; width: 0; margin-left: auto; margin-right: auto'><pre>RTT_clr = 0.9 * RTT_clr + 0.1 * RTT_clrNew</pre></div>
<p>"<tt>RTT_clrNew</tt>" is the new RTT
            calculated from the timestamp in the feedback message received
            from the CLR. The <tt>RTT_clr</tt> is
            initialized to <tt>RTT_clrNew</tt> on the first
            feedback message received. Note that the same procedure is
            observed by the sender for PLR receivers and that if a PLR is
            "promoted" to CLR status, the smoothed estimate can be
            continued.
</p>
<p>There are some additional periods besides steady-state
            operation that need to be considered in NORM-CC operation. These
            periods are:
</p>
<p></p>
<ol class="text">
<li>during session startup,
</li>
<li>when no feedback is received from the CLR, and
</li>
<li>when the sender has a break in data transmission.
</li>
</ol>

<p>During session startup, the congestion control operation SHALL
            observe a "slow start" procedure to quickly approach its fair
            bandwidth share. An initial sender startup rate is assumed
            where:
</p><div style='display: table; width: 0; margin-left: auto; margin-right: auto'><pre>Rinitial = MIN(NormSegmentSize / GRTT, NormSegmentSize) bytes/second.</pre></div>
<p>The rate is increased only when feedback is received from the
            receiver set. The "slow start" phase proceeds until any receiver
            provides feedback indicating that loss has occurred. Rate increase
            during <em>slow start</em> is applied as:
</p><div style='display: table; width: 0; margin-left: auto; margin-right: auto'><pre>Rnew = Rrecv_min</pre></div>
<p>where <tt>Rrecv_min</tt> is the minimum
            reported receiver rate in the "cc_rate" field of congestion
            control feedback messages received from the group. Note that
            during <em>slow start</em>, receivers use two
            times their measured rate from the sender in the "cc_rate" field
            of their feedback. Rate increase adjustment is limited to once per
            GRTT during slow start.
</p>
<p>If the CLR or any receiver intends to leave the group, it will
            set the <tt>NORM_FLAG_CC_LEAVE</tt> in its
            congestion control feedback message as an indication that the
            sender should not select it as the CLR. When the CLR changes to a
            lower rate receiver, the sender should immediately adjust to the
            new lower rate. The sender is limited to increasing its rate at
            one additional packet per RTT towards any new, higher CLR
            rate.
</p>
<p>The sender should also track the age of the feedback it has
            received from the CLR by comparing its current "cc_sequence" value
            (<tt>Seq_sender</tt>) to the last "cc_sequence"
            value received from the CLR (<tt>Seq_clr</tt>).
            As the age of the CLR feedback increases with no new feedback, the
            sender SHALL begin reducing its rate once per <tt>RTT_clr</tt>
            as a congestion avoidance measure. The following algorithm is used
            to determine the decrease in sender rate (Rsender bytes/sec) as
            the CLR feedback, unexpectedly, excessively ages:
</p><div style='display: table; width: 0; margin-left: auto; margin-right: auto'><pre>Age = Seq_sender - Seq_clr;
if (Age &gt; 4) Rsender = Rsender * 0.5;</pre></div>
<p>This rate reduction is limited to the lower bound on NORM
            transmission rate. After <tt>NORM_ROBUST_FACTOR</tt>
            consecutive <tt>NORM_CMD(CC)</tt> rounds
            without any feedback from the CLR, the sender SHOULD assume the
            CLR has left the group and pick the receiver with the next lowest
            rate as the new CLR. Note this assumes that the sender does not
            have explicit knowledge that the CLR intentionally left the group.
            If no receiver feedback is received, the sender MAY wish to
            withhold further transmissions of <tt>NORM_DATA</tt>
            segments and maintain <tt>NORM_CMD(CC)</tt>
            transmissions only until feedback is detected. After such a CLR
            timeout, the sender will be transmitting with a minimal rate and
            should return to slow start as described here for a break in data
            transmission.
</p>
<p>When the sender has a break in its data transmission, it can
            continue to probe the group with <tt>NORM_CMD(CC)</tt>
            messages to maintain RTT collection from the group. This will
            enable the sender to quickly determine an appropriate CLR upon
            data transmission restart. However, the sender should
            exponentially reduce its target rate to be used for transmission
            restart as time since the break elapses. The target rate SHOULD be
            recalculated once per <tt>RTT_clr</tt> as:
</p><div style='display: table; width: 0; margin-left: auto; margin-right: auto'><pre>Rsender = Rsender * 0.5;</pre></div>
<p>If the minimum NORM rate is reached, the sender should set the
            <tt>NORM_FLAG_START</tt> flag in its <tt>NORM_CMD(CC)</tt> messages upon restart and the
            group should observer <em>slow start</em>
            congestion control procedures until any receiver experiences a new
            loss event.
</p>
<a name="PositiveAcknowledgment"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.5.3"></a><h3>5.5.3.&nbsp;
NORM Positive Acknowledgment Procedure</h3>

<p>NORM provides options for the source application to request
          positive acknowledgment (ACK) of <tt>NORM_CMD(FLUSH)</tt>
          and <tt>NORM_CMD(ACK_REQ)</tt> messages from
          members of the group. There are some specific acknowledgment
          requests defined for the NORM protocol and a range of acknowledgment
          request types that are left to be defined by the application. One
          predefined acknowledgment type is the <tt>NORM_ACK_FLUSH</tt>
          type. This acknowledgment is used to determine if receivers have
          achieved completion of reliable reception up through a specific
          logical transmission point with respect to the sender's sequence of
          transmission. The <tt>NORM_ACK_FLUSH</tt>
          acknowledgment may be used to assist in application flow control
          when the sender has information on a portion of the receiver set.
          Another predefined acknowledgment type is <tt>NORM_ACK(CC)</tt>,
          which is used to explicitly provide congestion control feedback in
          response to <tt>NORM_CMD(CC)</tt> messages
          transmitted by the sender for NORM-CC operation. Note the <tt>NORM_ACK(CC)</tt> response does NOT follow the
          positive acknowledgment procedure described here. The <tt>NORM_CMD(ACK_REQ)</tt> and <tt>NORM_ACK</tt>
          messages contain an "ack_type" field to identify the type of
          acknowledgment requested and provided. A range of "ack_type" values
          is provided for application-defined use. While the application is
          responsible for initiating the acknowledgment request and interprets
          application-defined "ack_type" values, the acknowledgment procedure
          SHOULD be conducted within the protocol implementation to take
          advantage of timing and transmission scheduling information
          available to the NORM transport.
</p>
<p>The NORM positive acknowledgment procedure uses polling by the
          sender to query the receiver group for response. Note this polling
          procedure is not intended to scale to very large receiver groups,
          but could be used in large group setting to query a critical subset
          of the group. Either the <tt>NORM_CMD(ACK_REQ)</tt>,
          or when applicable, the <tt>NORM_CMD(FLUSH)</tt>
          message is used for polling and contains a list of <em>NormNodeIds</em> for receivers that should respond
          to the command. The list of receivers providing acknowledgment is
          determined by the source application with <em>a
          priori</em> knowledge of participating nodes or via some other
          application-level mechanism.
</p>
<p>The ACK process is initiated by the sender that generates <tt>NORM_CMD(FLUSH)</tt> or <tt>NORM_CMD(ACK_REQ)</tt>
          messages in periodic rounds. For <tt>NORM_ACK_FLUSH</tt>
          requests, the <tt>NORM_CMD(FLUSH)</tt> contain a
          "object_transport_id" and "fec_payload_id" denoting the watermark
          transmission point for which acknowledgment is requested. This
          watermark transmission point is echoed in the corresponding fields
          of the <tt>NORM_ACK(FLUSH)</tt> message sent by
          the receiver in response. <tt>NORM_CMD(ACK_REQ)</tt>
          messages contain an "ack_id" field which is similarly echoed in
          response so that the sender may match the response to the
          appropriate request.
</p>
<p>In response to the <tt>NORM_CMD(ACK_REQ)</tt>,
          the listed receivers randomly spread <tt>NORM_ACK</tt>
          messages uniformly in time over a window of (1*GRTT). These <tt>NORM_ACK</tt> messages are typically unicast to the
          sender. (Note that <tt>NORM_ACK(CC)</tt> messages
          SHALL be multicast or unicast in the same manner as <tt>NORM_NACK</tt> messages).
</p>
<p>The ACK process is self-limiting and avoids ACK implosion in
          that:
</p>
<p></p>
<ol class="text">
<li>Only a single <tt>NORM_CMD(ACK_REQ)</tt>
              message is generated once per (2*GRTT), and,
</li>
<li>The size of the "acking_node_list" of <em>NormNodeIds</em>
              from which acknowledgment is requested is limited to a maximum
              of the sender <em>NormSegmentSize</em>
              setting per round of the positive acknowledgment process.
</li>
</ol>

<p>Because the size of the included list is limited to the sender's
          <em>NormSegmentSize</em> setting, multiple <tt>NORM_CMD(ACK_REQ)</tt> rounds may be required to
          achieve responses from all receivers specified. The content of the
          attached <em>NormNodeId</em> list will be
          dynamically updated as this process progresses and <tt>NORM_ACK</tt> responses are received from the
          specified receiver set. As the sender receives valid responses
          (i.e., matching watermark point or "ack_id") from receivers, it
          SHALL eliminate those receivers from the subsequent <tt>NORM_CMD(ACK_REQ)</tt> message "acking_node_list"
          and add in any pending receiver <em>NormNodeIds</em>
          while keeping within the <em>NormSegmentSize</em>
          limitation of the list size. Each receiver is queried a maximum
          number of times (<tt>NORM_ROBUST_FACTOR</tt>, by
          default). Receivers not responding within this number of repeated
          requests are removed from the payload list to make room for other
          potential receivers pending acknowledgment. The transmission of the
          <tt>NORM_CMD(ACK_REQ)</tt> is repeated until no
          further responses are required or until the repeat threshold is
          exceeded for all pending receivers. The transmission of <tt>NORM_CMD(ACK_REQ)</tt> or <tt>NORM_CMD(FLUSH)</tt>
          messages to conduct the positive acknowledgment process is
          multiplexed with ongoing sender data transmissions. However, the
          <tt>NORM_CMD(FLUSH)</tt> positive acknowledgment
          process may be interrupted in response to negative acknowledgment
          repair requests (NACKs) received from receivers during the
          acknowledgment period. The <tt>NORM_CMD(FLUSH)</tt>
          positive acknowledgment process is restarted for receivers pending
          acknowledgment once any the repairs have been transmitted.
</p>
<p>In the case of <tt>NORM_CMD(FLUSH)</tt>
          commands with an attached "acking_node_list", receivers will not ACK
          until they have received complete transmission of all data up to and
          including the given watermark transmission point. All receivers
          SHALL interpret the watermark point provided in the request NACK for
          repairs if needed as for <tt>NORM_CMD(FLUSH)</tt>
          commands with no attached "acking_node_list".
</p>
<a name="anchor37"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.5.4"></a><h3>5.5.4.&nbsp;
Group Size Estimate</h3>

<p>NORM sender messages contain a "gsize" field that is a
          representation of the group size and is used in scaling random
          backoff timer ranges. The use of the group size estimate within the
          NORM protocol does not require a precise estimation and works
          reasonably well if the estimate is within an order of magnitude of
          the actual group size. By default, the NORM sender group size
          estimate may be administratively configured. Also, given the
          expected scalability of the NORM protocol for general use, a default
          value of 10,000 is RECOMMENDED for use as the group size
          estimate.
</p>
<p>It is possible that group size may be algorithmically
          approximated from the volume of congestion control feedback messages
          which follow the exponentially weighted random backoff. However, the
          specification of such an algorithm is currently beyond the scope of
          this document.
</p>
<a name="anchor38"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6"></a><h3>6.&nbsp;
Security Considerations</h3>

<p>The same security considerations that apply to the <a class='info' href='#RFC5401'>Multicast NACK<span> (</span><span class='info'>Adamson, B., Bormann, C., Handley, M., and J. Macker, &ldquo;Multicast Negative-Acknowledgment (NACK) Building Blocks,&rdquo; November&nbsp;2008.</span><span>)</span></a> [RFC5401], <a class='info' href='#RFC4654'>TFMCC<span> (</span><span class='info'>Widmer, J. and M. Handley, &ldquo;TCP-Friendly Multicast Congestion Control (TFMCC): Protocol Specification,&rdquo; August&nbsp;2006.</span><span>)</span></a> [RFC4654], and <a class='info' href='#RFC5052'>FEC<span> (</span><span class='info'>Watson, M., Luby, M., and L. Vicisano, &ldquo;Forward Error Correction (FEC) Building Block,&rdquo; August&nbsp;2007.</span><span>)</span></a> [RFC5052]
      Building Blocks also apply to the NORM protocol. In addition to the
      vulnerabilities that any IP and IP multicast protocol implementation may
      be generally subject to, the NACK-based feedback of NORM may be
      exploited by replay attacks which force the NORM sender to unnecessarily
      transmit repair information. This MAY be addressed by network layer IP
      security implementations that guard against this potential security
      exploitation or alternatively with a security mechanism that uses the
      <tt>EXT_AUTH</tt> header extension for similar
      purposes. Such security mechanisms SHOULD be deployed and used when
      available.
</p>
<p>The NORM protocol is compatible with the use of <a class='info' href='#RFC4301'>IP security (IPsec)<span> (</span><span class='info'>Kent, S. and K. Seo, &ldquo;Security Architecture for the Internet Protocol,&rdquo; December&nbsp;2005.</span><span>)</span></a> [RFC4301] and the IPsec Encapsulating
      Security Payload (ESP) protocol or Authentication Header (AF) extension
      can be used to secure IP packets transmitted by NORM participants. A
      baseline approach to secure NORM operation using IPsec is described
      below. Compliant implementations of this specification are REQUIRED to
      be compatible with IPsec usage as described in <a class='info' href='#NormIPsec'>Section&nbsp;6.1<span> (</span><span class='info'>Baseline Secure NORM Operation</span><span>)</span></a>.
</p>
<p>Additionally, the <tt>EXT_AUTH</tt> header
      extension (HET = 1) is defined for use by security mechanisms to provide
      an alternative form of authentication and/or encryption of NORM
      messages. The format of this header extension and its processing is
      outside the scope of this document and is to be communicated out-of-band
      as part of the session description. It is possible that an EXT_AUTH
      implementation of MAY also provide for encryption of NORM message
      payloads as well as authentication. The use of this approach as compared
      to IPsec can allow for header compression techniques to be applied
      jointly to IP and NORM protocol headers. In cases where security
      analysis deems that encryption of NORM protocol header content is
      beneficial or necessary, the aforementioned use of IPsec ESP may be more
      appropriate. If EXT_AUTH is present, whatever packet authentication
      checks that can be performed immediately upon reception of the packet
      MUST be performed before accepting the packet and performing any
      congestion control-related action on it. Some packet authentication
      schemes impose a delay of several seconds between when a packet is
      received and when the packet can be fully authenticated. Any congestion
      control related action that is appropriate MUST NOT be postponed by any
      such full packet authentication.
</p>
<p>Consideration MUST also be given to the potential for replay-attacks
      that would transplant authenticated packets from one NORM session to
      another to disrupt service. To avoid this potential, unique keys SHOULD
      be assigned on a per-session basis or NORM sender nodes SHOULD be
      configured to use unique "instance_id" identifiers that are managed as
      part of the security association for the sessions.
</p>
<p>It should be noted that NORM implementations can use the "sequence"
      field from the NORM Common Message Header to detect replay attacks. This
      can be accomplished if the NORM sender maintains state on receivers
      which are NACKing. A cache of such receiver state can be used to provide
      protection against NACK replay attacks. NORM receivers MUST also
      maintain similar state for protection against possible replay of other
      receiver messages in ASM operation as well. For example, a receiver
      could be suppressed from providing NACK or congestion control feedback
      by replay of certain receiver messages. For these reasons,
      authentication of NORM messages (e.g., via IPsec) SHOULD be applied for
      protection against similar attacks that use fabricated messages. Also,
      encryption of messages to provide confidentiality of application data
      and protect privacy of users MAY also be applied using IPsec or similar
      mechanisms.
</p>
<p>When applicable security measures are used, automated key management
      mechanisms such as those described in the <a class='info' href='#RFC3547'>Group
      Domain of Interpretation (GDOI)<span> (</span><span class='info'>Baugher, M., Weis, B., Hardjono, T., and H. Harney, &ldquo;The Group Domain of Interpretation,&rdquo; July&nbsp;2003.</span><span>)</span></a> [RFC3547], <a class='info' href='#RFC3830'>Multimedia Internet KEYing (MIKEY)<span> (</span><span class='info'>Arkko, J., Carrara, E., Lindholm, F., Naslund, M., and K. Norrman, &ldquo;MIKEY: Multimedia Internet KEYing,&rdquo; August&nbsp;2004.</span><span>)</span></a> [RFC3830] or <a class='info' href='#RFC4535'>Group Secure Association Key Management Protocol
      (GSAKMP)<span> (</span><span class='info'>Harney, H., Meth, U., Colegrove, A., and G. Gross, &ldquo;GSAKMP: Group Secure Association Key Management Protocol,&rdquo; June&nbsp;2006.</span><span>)</span></a> [RFC4535] specifications SHOULD be applied.
</p>
<p>It is also important to note that while NORM does leverage FEC-based
      repair for scalability, this alone does not guarantee integrity of
      received data. Application-level integrity-checking of received data
      content is highly RECOMMENDED.
</p>
<a name="NormIPsec"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.1"></a><h3>6.1.&nbsp;
Baseline Secure NORM Operation</h3>

<p>This section describes a baseline mode of secure NORM protocol
        operation based on application of the IPsec security protocol. This
        approach is documented here to provide a reference, interoperable
        secure mode of operation. However, additional approaches to NORM
        security, including other forms of IPsec application, MAY be specified
        in the future. For example, the use of the EXT_AUTH header extension
        could enable NORM-specific authentication or security encapsulation
        headers similar to those of IPsec to be specified and inserted into
        the NORM protocol message headers. This would allow header compression
        techniques to be applied to IP and NORM protocol headers when needed
        in a similar fashion to that of <a class='info' href='#RFC3550'>RTP<span> (</span><span class='info'>Schulzrinne, H., Casner, S., Frederick, R., and V. Jacobson, &ldquo;RTP: A Transport Protocol for Real-Time Applications,&rdquo; July&nbsp;2003.</span><span>)</span></a> [RFC3550] and
        as preserved in the specification for <a class='info' href='#RFC3711'>Secure
        Real Time Protocol (SRTP)<span> (</span><span class='info'>Baugher, M., McGrew, D., Naslund, M., Carrara, E., and K. Norrman, &ldquo;The Secure Real-time Transport Protocol (SRTP),&rdquo; March&nbsp;2004.</span><span>)</span></a> [RFC3711].
</p>
<p>The baseline approach described is applicable to NORM operation
        configured for SSM (or SSM-like) operation where there is a single
        sender and the receivers are providing unicast feedback. This form of
        NORM operation allows for IPsec to be used with a manageable number of
        security associations (SA).
</p>
<a name="anchor39"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.1.1"></a><h3>6.1.1.&nbsp;
IPsec Approach</h3>

<p>For NORM one-to-many SSM operation with unicast feedback from
          receivers, each node SHALL be configured with two transport mode
          IPsec security associations and corresponding Security Policy
          Database (SPD) entries. One entry will be used for sender-to-group
          multicast packet authentication and optionally encryption while the
          other entry will be used to provide security for the unicast
          feedback messaging from the receiver(s) to the sender.
</p>
<p>The NORM sender SHALL use an IPsec SA configured for <a class='info' href='#RFC4303'>ESP protocol<span> (</span><span class='info'>Kent, S., &ldquo;IP Encapsulating Security Payload (ESP),&rdquo; December&nbsp;2005.</span><span>)</span></a> [RFC4303] operation with the option for
          data origination authentication enabled. It is also RECOMMENDED that
          this IPsec ESP SA be also configured to provide confidentiality
          protection for IP packets containing NORM protocol messages. This is
          suggested to make the realization of complex replay attacks much
          more difficult. The encryption key for this SA SHALL be preplaced at
          the sender and receiver(s) prior to NORM protocol operation. Use of
          automated key management is RECOMMENDED as a rekey SHALL be required
          prior to expiration of the sequence space for the SA. This is
          necessary so that receivers may use the built-in IPsec replay attack
          protection possible for an IPsec SA with a single source (the NORM
          sender). Thus the receivers SHALL enable replay attack protection
          for this SA used to secure NORM sender traffic. An IPsec SPD entry
          MUST be configured to process outbound packets to the session
          (destination) address and UDP port number of the applicable (<em>NormSession</em>).
</p>
<p>The NORM receiver(s) MUST be configured with the SA and SPD entry
          to properly process the IPsec-secured packets from the sender. The
          NORM receiver(s) SHALL also use a common, second IPsec SA (common
          Security Parameter Index (SPI) and encryption key) configured for
          ESP operation with the option for data origination authentication
          enabled. Similar to the NORM sender, is RECOMMENDED this IPsec ESP
          SA be also configured to provide confidentiality protection for IP
          packets containing NORM protocol messages. The receivers MUST have
          an IPsec SPD entry configured to process outbound NORM/UDP packets
          directed to the NORM sender source address and port number using
          this second SA. As noted for NORM unicast feedback, the sender's
          transmission port number SHOULD be selected to be distinct from the
          multicast session port number to allow discrimination between
          unicast and multicast feedback messages when access to the IP
          destination address is not possible (e.g., a user-space NORM
          implementation). For processing of packets from receivers, the NORM
          sender SHALL be configured with this common, second SA (and the
          corresponding SPD entry needed) in order to properly process
          messages from the receiver.
</p>
<p>Multiple receivers using a common IPsec SA for traffic directed
          to the NORM sender (i.e., many-to-one) typically prevents the use of
          built-in IPsec replay attack protection by the NORM sender with
          current IPsec implementations. Thus the built-in IPsec replay attack
          protection for this second SA at the sender MUST be disabled unless
          the particular IPsec implementation manages its replay protection on
          a per-source basis. So, to support a fully secure mode of operation,
          the NORM sender implementation MUST provide replay attack protection
          based upon the "sequence" field of NORM protocol messages from
          receivers. This can be accomplished with high assurance of security,
          even with the limited size (16-bits) of this field, because
</p>
<p></p>
<ol class="text">
<li>NORM receiver NACK and non-CLR ACK feedback messages are
              sparse.
</li>
<li>The more frequent <tt>NORM_ACK</tt>
              feedback from CLR or PLR nodes are only a small set of receivers
              for which the sender must keep more persistent replay attack
              state.
</li>
<li><tt>NORM_NACK</tt> feedback messages that
              precede the sender's current repair window do not significantly
              impact protocol operation (generation of <tt>NORM_CMD(SQUELCH)</tt>
              is limited) and could be in fact ignored. This means the sender
              can prune any replay attack state for receivers that precede the
              current repair window.
</li>
<li><tt>NORM_ACK</tt> messages correspond to
              either a specific sender "ack_id", the sender "cc_sequence" for
              ACKs sent in response to <tt>NORM_CMD(CC)</tt>,
              or the sender's current repair window in the case of ACKs sent
              in response to <tt>NORM_CMD(FLUSH)</tt>.
              Thus, the sender can prune any replay attack state for receivers
              that precede the current applicable sequence or repair window
              space.
</li>
</ol>

<p>Note that use of ESP confidentiality for secure NORM protocol
          operation makes it more difficult for adversaries to conduct any
          form of replay attacks. Additionally, it should be noted that a NORM
          sender implementation with access to the full ESP protocol header
          could also use the ESP sequence information to make replay attack
          protection even more robust, by maintaining per-source sequence
          state. The design of this baseline security approach for NORM
          intentionally places any more complex processing state or processing
          (e.g. replay attack protection given multiple receivers) at the NORM
          sender since NORM receiver implementations may need to have a more
          light-weight realization in many cases.
</p>
<p>This baseline approach can be used for NORM protocol sessions
          with multiple senders if the SA pairs described are established for
          each sender. For small-sized groups, it is even possible that
          many-to-many (ASM) IPsec configuration could be achieved where each
          participant uses a unique SA (with a unique SPI). This does not
          scale to larger group sizes given the complex set of SA and SPD
          entries each participant would need to maintain.
</p>
<p>It is anticipated in early deployments of this baseline approach
          to NORM security that key management will be conducted out-of-band
          with respect to NORM protocol operation. In the case of one-to-many
          NORM operation, it is possible that receivers may retrieve keying
          information from a central server as needed or otherwise conduct
          group key updates with a similar centralized approach. However, it
          may be possible with some key management schemes for rekey messages
          to be transmitted to the group as a message or transport object
          within the NORM reliable transfer session. Similarly, for group-wise
          communication sessions it is possible that potential group
          participants may request keying and/or rekeying as part of NORM
          communications. Additional specification is necessary to define an
          in-band key management scheme for NORM sessions perhaps using the
          mechanisms of the automated group key management specifications
          cited in this document.
</p>
<a name="anchor40"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.1.2"></a><h3>6.1.2.&nbsp;
IPsec Requirements</h3>

<p>In order to implement this secure mode of NORM protocol
          operation, the following IPsec capabilities are required.
</p>
<a name="anchor41"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.1.2.1"></a><h3>6.1.2.1.&nbsp;
Selectors</h3>

<p>The implementation MUST be able to use the source address,
            destination address, protocol (UDP), and UDP port numbers as
            selectors in the SPD.
</p>
<a name="anchor42"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.1.2.2"></a><h3>6.1.2.2.&nbsp;
Mode</h3>

<p>IPsec in transport mode MUST be supported. The use of <a class='info' href='#RFC4301'>IPsec<span> (</span><span class='info'>Kent, S. and K. Seo, &ldquo;Security Architecture for the Internet Protocol,&rdquo; December&nbsp;2005.</span><span>)</span></a> [RFC4301] processing for secure NORM traffic
            MUST be configured such that unauthenticated packets are not
            received by the NORM protocol implementation.
</p>
<a name="anchor43"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.1.2.3"></a><h3>6.1.2.3.&nbsp;
Key Management</h3>

<p>An automated key management scheme for group key distribution
            and rekeying such as <a class='info' href='#RFC3547'>GDOI<span> (</span><span class='info'>Baugher, M., Weis, B., Hardjono, T., and H. Harney, &ldquo;The Group Domain of Interpretation,&rdquo; July&nbsp;2003.</span><span>)</span></a> [RFC3547], <a class='info' href='#RFC4535'>GSAKMP<span> (</span><span class='info'>Harney, H., Meth, U., Colegrove, A., and G. Gross, &ldquo;GSAKMP: Group Secure Association Key Management Protocol,&rdquo; June&nbsp;2006.</span><span>)</span></a> [RFC4535], or <a class='info' href='#RFC3830'>MIKEY<span> (</span><span class='info'>Arkko, J., Carrara, E., Lindholm, F., Naslund, M., and K. Norrman, &ldquo;MIKEY: Multimedia Internet KEYing,&rdquo; August&nbsp;2004.</span><span>)</span></a> [RFC3830] is RECOMMENDED for use. Relatively
            short-lived NORM sessions MAY be able to use Manual Keying with a
            single, preplaced key, particularly if <a class='info' href='#RFC4303'>Extended Sequence Numbering (ESN)<span> (</span><span class='info'>Kent, S., &ldquo;IP Encapsulating Security Payload (ESP),&rdquo; December&nbsp;2005.</span><span>)</span></a> [RFC4303] is
            available in the IPsec implementation used. It should also be
            noted that it may be possible for key update messages (e.g., the
            GDOI GROUPKEY-PUSH message) to be included as part of the NORM
            application reliable data transmission if appropriate interfaces
            are available between the NORM application and the key management
            daemon.
</p>
<a name="anchor44"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.1.2.4"></a><h3>6.1.2.4.&nbsp;
Security Policy</h3>

<p>Receivers MUST accept protocol messages only from the
            designated, authorized sender(s). It is expected that appropriate
            key management will provide encryption keys only to receivers
            authorized to participate in a designated session. The approach
            outlined here allows receiver sets to be controlled on a
            per-sender basis.
</p>
<a name="anchor45"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.1.2.5"></a><h3>6.1.2.5.&nbsp;
Authentication and Encryption</h3>

<p>Large NORM group sizes will necessitate some form of key
            management that does rely upon shared secrets. The GDOI and GSAKMP
            protocols mentioned here allow for certificate-based
            authentication. It is RECOMMENDED these certificates use IP
            addresses for authentication although it may alternatively
            possible to have authentication associated with pre-assigned
            NormNodeId values. However, it is likely that available group key
            management implementations will not be NORM-specific.
</p>
<a name="anchor46"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.1.2.6"></a><h3>6.1.2.6.&nbsp;
Availability</h3>

<p>The IPsec requirements profile outlined here is commonly
            available on many potential NORM hosts. The principal issue is
            that configuration and operation of IPsec typically requires
            privileged user authorization. Automated key management
            implementations are typically configured with the privileges
            necessary to effect system IPsec configuration needed.
</p>
<a name="anchor47"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7"></a><h3>7.&nbsp;
IANA Considerations</h3>

<p>Values of NORM Header Extension Types, Stream Control Codes, and
      <tt>NORM_CMD</tt> message sub-types are subject to
      IANA registration. They are in the registry named "Reliable Multicast
      Transport (RMT) NORM Protocol Parameters" located at time of publication
      at:
</p>
<p><a href='http:///www.iana.org/assignments/norm-parameters'>http:///www.iana.org/assignments/norm-parameters</a>
</p>
<p>It should be also noted that reliable multicast building block
      components used by this specification also have their respective IANA
      considerations and those documents should be consulted accordingly. In
      particular, the FEC Building Block used by NORM does require IANA
      registration of the FEC codecs used. The registration instructions for
      FEC codecs are provided in <a class='info' href='#RFC5052'>RFC
      5052<span> (</span><span class='info'>Watson, M., Luby, M., and L. Vicisano, &ldquo;Forward Error Correction (FEC) Building Block,&rdquo; August&nbsp;2007.</span><span>)</span></a>.
</p>
<a name="anchor48"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.1"></a><h3>7.1.&nbsp;
Explicit IANA Assignment Guidelines</h3>

<p>This document introduces three namespaces that are registered for
        the NORM Header Extension Types, Stream Control Codes and <tt>NORM_CMD</tt> Message Sub-types. This section
        describes explicit IANA assignment guidelines for each of these.
</p>
<a name="anchor49"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.1.1"></a><h3>7.1.1.&nbsp;
NORM Header Extension Types</h3>

<p>This document defines a namespace for NORM Header Extension Types
          named:
</p>
<p><tt>ietf:rmt:norm:extension</tt>
</p>
<p>The NORM Header Extension Type field is an 8-bit value. The
          values of this field identify extended header content that allows
          the protocol functionality to be expanded to include additional
          features and operating modes. The values that can be assigned within
          the <tt>ietf:rmt:norm:extension</tt> namespace
          are numeric indexes in the range {0, 255}, boundaries included.
          Values in the range {0,127} indicate variable length extended header
          fields while values in the range {128,255} indicate extensions of a
          fixed 4-byte length. This specification registers the following NORM
          Header Extension Types:
</p><table class="full" align="center" border="0" cellpadding="2" cellspacing="2">
<col align="left"><col align="left"><col align="left">
<tr><th align="left">Value</th><th align="left">Name</th><th align="left">Reference</th></tr>
<tr>
<td align="left">1</td>
<td align="left"><tt>EXT_AUTH</tt>&nbsp;</td>
<td align="left">This specification</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><tt>EXT_CC</tt>&nbsp;</td>
<td align="left">This specification</td>
</tr>
<tr>
<td align="left">64</td>
<td align="left"><tt>EXT_FTI</tt>&nbsp;</td>
<td align="left">This specification</td>
</tr>
<tr>
<td align="left">128</td>
<td align="left"><tt>EXT_RATE</tt>&nbsp;</td>
<td align="left">This specification</td>
</tr>
</table>
<br clear="all" />

<p>Requests for assignment of additional NORM Header Extension Type
          values are granted on a "Specification Required" basis as defined by
          <a class='info' href='#RFC5226'>IANA Guidelines<span> (</span><span class='info'>Narten, T. and H. Alvestrand, &ldquo;Guidelines for Writing an IANA Considerations Section in RFCs,&rdquo; May&nbsp;2008.</span><span>)</span></a> [RFC5226]. Any such header
          extension specifications MUST include a description of protocol
          actions to be taken when the extension type is encountered by a
          protocol implementation not supporting that specific option. For
          example, it may be possible for protocol implementations to ignore
          unknown header extensions in many cases.
</p>
<a name="anchor50"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.1.2"></a><h3>7.1.2.&nbsp;
NORM Stream Control Codes</h3>

<p>This document defines a namespace for NORM Stream Control Codes
          named:
</p>
<p><tt>ietf:rmt:norm:streamControlCode</tt>
</p>
<p>NORM Stream Control Codes are 16-bit values that may be inserted
          within a <tt>NORM_OBJECT_STREAM</tt> delivery
          object to convey sequenced, out-of-band (with respect to the stream
          data) control signaling applicable to the referenced stream object.
          These control codes are to be delivered to the application or
          protocol implementation with reliable delivery, in-order with
          respect to the their inserted position within the stream. This
          specification registers the following NORM Stream Control Code:
</p><table class="full" align="center" border="0" cellpadding="2" cellspacing="2">
<col align="left"><col align="left"><col align="left">
<tr><th align="left">Value</th><th align="left">Name</th><th align="left">Reference</th></tr>
<tr>
<td align="left">0</td>
<td align="left"><tt>NORM_STREAM_END</tt>&nbsp;</td>
<td align="left">This specification</td>
</tr>
</table>
<br clear="all" />

<p>Additional NORM Stream Control Code value assignment requests are
          granted on a "Specification Required" basis as defined by <a class='info' href='#RFC5226'>IANA Guidelines<span> (</span><span class='info'>Narten, T. and H. Alvestrand, &ldquo;Guidelines for Writing an IANA Considerations Section in RFCs,&rdquo; May&nbsp;2008.</span><span>)</span></a> [RFC5226]. The full 16-bit space
          outside of the value assigned in this specification are available
          for future assignment. Note that in addition to describing the
          control code's expected interpretation, such specifications MUST
          include a description of protocol actions to be taken when the
          control code is encountered by a protocol implementation not
          supporting that specific option.
</p>
<a name="anchor51"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.1.3"></a><h3>7.1.3.&nbsp;
NORM_CMD Message Sub-types</h3>

<p>This document defines a namespace for <tt>NORM_CMD</tt>
          Message Sub-types named:
</p>
<p><tt>ietf:rmt:norm:command</tt>
</p>
<p>The <tt>NORM_CMD</tt> sub-type field is an
          8-bit value with valid values in the range of 1-255. Note the value
          0 is reserved to indicate an invalid <tt>NORM_CMD</tt>
          message sub-type. The current specification defines a number of
          <tt>NORM_CMD</tt> message sub-types that senders
          can use to signal the receivers in various aspects of NORM protocol
          operation. This specification registers the following <tt>NORM_CMD</tt> Message Sub-types:
</p><table class="full" align="center" border="0" cellpadding="2" cellspacing="2">
<col align="left"><col align="left"><col align="left">
<tr><th align="left">Value</th><th align="left">Name</th><th align="left">Reference</th></tr>
<tr>
<td align="left">0</td>
<td align="left">reserved</td>
<td align="left">This specification</td>
</tr>
<tr>
<td align="left">1</td>
<td align="left"><tt>NORM_CMD(FLUSH)</tt>&nbsp;</td>
<td align="left">This specification</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><tt>NORM_CMD(EOT)</tt>&nbsp;</td>
<td align="left">This specification</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><tt>NORM_CMD(SQUELCH)</tt>&nbsp;</td>
<td align="left">This specification</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"><tt>NORM_CMD(CC)</tt>&nbsp;</td>
<td align="left">This specification</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left"><tt>NORM_CMD(REPAIR_ADV)</tt>&nbsp;</td>
<td align="left">This specification</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left"><tt>NORM_CMD(ACK_REQ)</tt>&nbsp;</td>
<td align="left">This specification</td>
</tr>
<tr>
<td align="left">7</td>
<td align="left"><tt>NORM_CMD(APPLICATION)</tt>&nbsp;</td>
<td align="left">This specification</td>
</tr>
</table>
<br clear="all" />

<p>Future specifications extending NORM may wish to define
          additional <tt>NORM_CMD</tt> messages to enhance
          protocol functionality. <tt>NORM_CMD</tt> message
          sub-type value assignment requests are granted on a "Specification
          Required" basis as defined by <a class='info' href='#RFC5226'>IANA
          Guidelines<span> (</span><span class='info'>Narten, T. and H. Alvestrand, &ldquo;Guidelines for Writing an IANA Considerations Section in RFCs,&rdquo; May&nbsp;2008.</span><span>)</span></a> [RFC5226]. Note that in addition to describing the command
          sub-type's expected interpretation, specifications MUST include a
          description of protocol actions to be taken when the command is
          encountered by a protocol implementation not supporting that
          specific option.
</p>
<p>Note that this specification already provides for an
          "application-defined" <tt>NORM_CMD</tt> message
          sub-type that may be used at the discretion of individual
          applications using NORM for transport. These "application-defined"
          commands may be suitable for many application-specific purposes and
          do not require standards action. In any case, such additional
          messages SHALL be subject to the same congestion control constraints
          as the existing NORM sender message set.
</p>
<a name="anchor52"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.8"></a><h3>8.&nbsp;
Suggested Use</h3>

<p>The present NORM protocol is seen as useful tool for the reliable
      data transfer over generic IP multicast services. It is not the
      intention of the authors to suggest it is suitable for supporting all
      envisioned multicast reliability requirements. NORM provides a simple
      and flexible framework for multicast applications with a degree of
      concern for network traffic implosion and protocol overhead efficiency.
      NORM-like protocols have been successfully demonstrated within the MBone
      for bulk data dissemination applications, including weather satellite
      compressed imagery updates servicing a large group of receivers and a
      generic web content reliable "push" application.
</p>
<p>In addition, this framework approach has some design features making
      it attractive for bulk transfer in asymmetric and wireless internetwork
      applications. NORM is capable of successfully operating independent of
      network structure and in environments with high packet loss, delay, and
      out-of-order delivery. Hybrid proactive/reactive FEC-based repairing
      improve protocol performance in some multicast scenarios. A sender-only
      repair approach often makes additional engineering sense in asymmetric
      networks. NORM's unicast feedback capability may be suitable for use in
      asymmetric networks or in networks where only unidirectional multicast
      routing/delivery service exists. Asymmetric architectures supporting
      multicast delivery are likely to make up an important portion of the
      future Internet structure (e.g., DBS/cable/PSTN hybrids) and efficient,
      reliable bulk data transfer will be an important capability for
      servicing large groups of subscribed receivers.
</p>
<a name="ProtocolChanges"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.9"></a><h3>9.&nbsp;
Changes from RFC3940</h3>

<p>This section lists the changes between the Experimental version of
      this specification, <a class='info' href='#RFC3940'>RFC
      3940<span> (</span><span class='info'>Adamson, B., Bormann, C., Handley, M., and J. Macker, &ldquo;Negative-acknowledgment (NACK)-Oriented Reliable Multicast (NORM) Protocol,&rdquo; November&nbsp;2004.</span><span>)</span></a>, and this version:
</p>
<p></p>
<ol class="text">
<li>Removal of the <tt>NORM_FLAG_MSG_START</tt>
          for <tt>NORM_OBJECT_STREAM</tt>, replacing it
          with the "payload_msg_start" field in the FEC-encoded preamble of
          the <tt>NORM_OBJECT_STREAM NORM_DATA</tt>
          payload,
</li>
<li>Definition of IANA namespace for header extension assignment,
</li>
<li>Removal of file blocking scheme description that is now specified
          in the <a class='info' href='#RFC5052'>FEC Building Block
          document<span> (</span><span class='info'>Watson, M., Luby, M., and L. Vicisano, &ldquo;Forward Error Correction (FEC) Building Block,&rdquo; August&nbsp;2007.</span><span>)</span></a> [RFC5052],
</li>
<li>Removal of restriction of NORM receiver feedback message rate to
          local NORM sender rate (This caused congestion control failures in
          high speed operation. The extremely low feedback rate of the NORM
          protocol as compared to TCP avoids any resultant impact to the
          network as shown in <a class='info' href='#Mdpcc'>[Mdpcc]<span> (</span><span class='info'>Adamson,  B. and J. Macker, &ldquo;A TCP-Friendly, Rate-based Mechanism for NACK-Oriented           Reliable Multicast Congestion Control,&rdquo; November&nbsp;2001.</span><span>)</span></a>),
</li>
<li>Correction of errors in some message format descriptions, and
</li>
<li>Correction of inconsistency in specification of the inactivity
          timeout.
</li>
<li>Addition of IPsec secure mode description with IPsec
          requirements.
</li>
<li>Addition of the EXT_AUTH header extension definition.
</li>
<li>Clarification of interpretation of "Source Block Length" when FEC
          codes are arbitrarily shortened by the sender.
</li>
</ol>

<a name="anchor53"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.10"></a><h3>10.&nbsp;
Acknowledgments</h3>

<p>(and these are not Negative)
</p>
<p>The authors would like to thank Rick Jones, Vincent Roca, Rod Walsh,
      Toni Paila, Michael Luby, and Joerg Widmer for their valuable input and
      comments on this document. The authors would also like to thank the RMT
      working group chairs, Roger Kermode and Lorenzo Vicisano, for their
      support in development of this specification, and Sally Floyd for her
      early input into this document.
</p>
<a name="rfc.references"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.11"></a><h3>11.&nbsp;
References</h3>

<a name="rfc.references1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>11.1.&nbsp;Normative References</h3>
<table width="99%" border="0">
<tr><td class="author-text" valign="top"><a name="RFC1112">[RFC1112]</a></td>
<td class="author-text"><a href="mailto:deering@PESCADERO.STANFORD.EDU">Deering, S.</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc1112">Host extensions for IP multicasting</a>,&rdquo; STD&nbsp;5, RFC&nbsp;1112, August&nbsp;1989 (<a href="http://www.rfc-editor.org/rfc/rfc1112.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC2119">[RFC2119]</a></td>
<td class="author-text"><a href="mailto:sob@harvard.edu">Bradner, S.</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>,&rdquo; BCP&nbsp;14, RFC&nbsp;2119, March&nbsp;1997 (<a href="http://www.rfc-editor.org/rfc/rfc2119.txt">TXT</a>, <a href="http://xml.resource.org/public/rfc/html/rfc2119.html">HTML</a>, <a href="http://xml.resource.org/public/rfc/xml/rfc2119.xml">XML</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4301">[RFC4301]</a></td>
<td class="author-text">Kent, S. and K. Seo, &ldquo;<a href="http://tools.ietf.org/html/rfc4301">Security Architecture for the Internet Protocol</a>,&rdquo; RFC&nbsp;4301, December&nbsp;2005 (<a href="http://www.rfc-editor.org/rfc/rfc4301.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4303">[RFC4303]</a></td>
<td class="author-text">Kent, S., &ldquo;<a href="http://tools.ietf.org/html/rfc4303">IP Encapsulating Security Payload (ESP)</a>,&rdquo; RFC&nbsp;4303, December&nbsp;2005 (<a href="http://www.rfc-editor.org/rfc/rfc4303.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4607">[RFC4607]</a></td>
<td class="author-text">Holbrook, H. and B. Cain, &ldquo;<a href="http://tools.ietf.org/html/rfc4607">Source-Specific Multicast for IP</a>,&rdquo; RFC&nbsp;4607, August&nbsp;2006 (<a href="http://www.rfc-editor.org/rfc/rfc4607.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4654">[RFC4654]</a></td>
<td class="author-text">Widmer, J. and M. Handley, &ldquo;<a href="http://tools.ietf.org/html/rfc4654">TCP-Friendly Multicast Congestion Control (TFMCC): Protocol Specification</a>,&rdquo; RFC&nbsp;4654, August&nbsp;2006 (<a href="http://www.rfc-editor.org/rfc/rfc4654.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC5052">[RFC5052]</a></td>
<td class="author-text">Watson, M., Luby, M., and L. Vicisano, &ldquo;<a href="http://tools.ietf.org/html/rfc5052">Forward Error Correction (FEC) Building Block</a>,&rdquo; RFC&nbsp;5052, August&nbsp;2007 (<a href="http://www.rfc-editor.org/rfc/rfc5052.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC5226">[RFC5226]</a></td>
<td class="author-text">Narten, T. and H. Alvestrand, &ldquo;<a href="http://tools.ietf.org/html/rfc5226">Guidelines for Writing an IANA Considerations Section in RFCs</a>,&rdquo; BCP&nbsp;26, RFC&nbsp;5226, May&nbsp;2008 (<a href="http://www.rfc-editor.org/rfc/rfc5226.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC5401">[RFC5401]</a></td>
<td class="author-text">Adamson, B., Bormann, C., Handley, M., and J. Macker, &ldquo;<a href="http://tools.ietf.org/html/rfc5401">Multicast Negative-Acknowledgment (NACK) Building Blocks</a>,&rdquo; RFC&nbsp;5401, November&nbsp;2008 (<a href="http://www.rfc-editor.org/rfc/rfc5401.txt">TXT</a>).</td></tr>
</table>

<a name="rfc.references2"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>11.2.&nbsp;Informative References</h3>
<table width="99%" border="0">
<tr><td class="author-text" valign="top"><a name="FecHybrid">[FecHybrid]</a></td>
<td class="author-text">Gossink, D. and <a href="mailto:">J. Macker</a>, &ldquo;Reliable Multicast and Integrated Parity Retransmission with
          Channel Estimation,&rdquo; IEEE Globecomm &nbsp;, 1998.</td></tr>
<tr><td class="author-text" valign="top"><a name="McastFeedback">[McastFeedback]</a></td>
<td class="author-text">Nonnenmacher, J. and <a href="mailto:">E. Biersack</a>, &ldquo;Optimal Multicast Feedback,&rdquo; IEEE INFOCOM, &nbsp;p. 964, March/April&nbsp;1998.</td></tr>
<tr><td class="author-text" valign="top"><a name="MdpToolkit">[MdpToolkit]</a></td>
<td class="author-text">Macker,  J. and <a href="mailto:">B. Adamson</a>, &ldquo;The Multicast Dissemination Protocol (MDP) Toolkit,&rdquo; Proc. IEEE MILCOM&nbsp;, October&nbsp;1999.</td></tr>
<tr><td class="author-text" valign="top"><a name="Mdpcc">[Mdpcc]</a></td>
<td class="author-text">Adamson,  B. and <a href="mailto:">J. Macker</a>, &ldquo;A TCP-Friendly, Rate-based Mechanism for NACK-Oriented
          Reliable Multicast Congestion Control,&rdquo; Proc. IEEE GLOBECOMM&nbsp;, November&nbsp;2001.</td></tr>
<tr><td class="author-text" valign="top"><a name="NormFeedback">[NormFeedback]</a></td>
<td class="author-text"><a href="mailto:">Adamson, B.</a> and J. Macker, &ldquo;Quantitative Prediction of NACK-Oriented Reliable Multicast
          (NORM) Feedback,&rdquo; IEEE MILCOM&nbsp;, October&nbsp;2002.</td></tr>
<tr><td class="author-text" valign="top"><a name="PgmccPaper">[PgmccPaper]</a></td>
<td class="author-text">Rizzo, L., &ldquo;pgmcc: A TCP-Friendly Single-Rate Multicast Congestion
          Control Scheme,&rdquo; ACM SIGCOMM&nbsp;, August&nbsp;2000.</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC2357">[RFC2357]</a></td>
<td class="author-text"><a href="mailto:mankin@isi.edu">Mankin, A.</a>, <a href="mailto:allyn@mci.net">Romanov, A.</a>, <a href="mailto:sob@harvard.edu">Bradner, S.</a>, and <a href="mailto:vern@ee.lbl.gov">V. Paxson</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc2357">IETF Criteria for Evaluating Reliable Multicast Transport and Application Protocols</a>,&rdquo; RFC&nbsp;2357, June&nbsp;1998 (<a href="http://www.rfc-editor.org/rfc/rfc2357.txt">TXT</a>, <a href="http://xml.resource.org/public/rfc/html/rfc2357.html">HTML</a>, <a href="http://xml.resource.org/public/rfc/xml/rfc2357.xml">XML</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC2974">[RFC2974]</a></td>
<td class="author-text">Handley, M., Perkins, C., and E. Whelan, &ldquo;<a href="http://tools.ietf.org/html/rfc2974">Session Announcement Protocol</a>,&rdquo; RFC&nbsp;2974, October&nbsp;2000 (<a href="http://www.rfc-editor.org/rfc/rfc2974.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC3048">[RFC3048]</a></td>
<td class="author-text">Whetten, B., Vicisano, L., Kermode, R., Handley, M., Floyd, S., and M. Luby, &ldquo;<a href="http://tools.ietf.org/html/rfc3048">Reliable Multicast Transport Building Blocks for One-to-Many Bulk-Data Transfer</a>,&rdquo; RFC&nbsp;3048, January&nbsp;2001 (<a href="http://www.rfc-editor.org/rfc/rfc3048.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC3269">[RFC3269]</a></td>
<td class="author-text">Kermode, R. and L. Vicisano, &ldquo;<a href="http://tools.ietf.org/html/rfc3269">Author Guidelines for Reliable Multicast Transport (RMT) Building Blocks and Protocol Instantiation documents</a>,&rdquo; RFC&nbsp;3269, April&nbsp;2002 (<a href="http://www.rfc-editor.org/rfc/rfc3269.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC3453">[RFC3453]</a></td>
<td class="author-text">Luby, M., Vicisano, L., Gemmell, J., Rizzo, L., Handley, M., and J. Crowcroft, &ldquo;<a href="http://tools.ietf.org/html/rfc3453">The Use of Forward Error Correction (FEC) in Reliable Multicast</a>,&rdquo; RFC&nbsp;3453, December&nbsp;2002 (<a href="http://www.rfc-editor.org/rfc/rfc3453.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC3547">[RFC3547]</a></td>
<td class="author-text">Baugher, M., Weis, B., Hardjono, T., and H. Harney, &ldquo;<a href="http://tools.ietf.org/html/rfc3547">The Group Domain of Interpretation</a>,&rdquo; RFC&nbsp;3547, July&nbsp;2003 (<a href="http://www.rfc-editor.org/rfc/rfc3547.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC3550">[RFC3550]</a></td>
<td class="author-text">Schulzrinne, H., Casner, S., Frederick, R., and V. Jacobson, &ldquo;<a href="http://tools.ietf.org/html/rfc3550">RTP: A Transport Protocol for Real-Time Applications</a>,&rdquo; STD&nbsp;64, RFC&nbsp;3550, July&nbsp;2003 (<a href="http://www.rfc-editor.org/rfc/rfc3550.txt">TXT</a>, <a href="http://www.rfc-editor.org/rfc/rfc3550.ps">PS</a>, <a href="http://www.rfc-editor.org/rfc/rfc3550.pdf">PDF</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC3711">[RFC3711]</a></td>
<td class="author-text">Baugher, M., McGrew, D., Naslund, M., Carrara, E., and K. Norrman, &ldquo;<a href="http://tools.ietf.org/html/rfc3711">The Secure Real-time Transport Protocol (SRTP)</a>,&rdquo; RFC&nbsp;3711, March&nbsp;2004 (<a href="http://www.rfc-editor.org/rfc/rfc3711.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC3830">[RFC3830]</a></td>
<td class="author-text">Arkko, J., Carrara, E., Lindholm, F., Naslund, M., and K. Norrman, &ldquo;<a href="http://tools.ietf.org/html/rfc3830">MIKEY: Multimedia Internet KEYing</a>,&rdquo; RFC&nbsp;3830, August&nbsp;2004 (<a href="http://www.rfc-editor.org/rfc/rfc3830.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC3940">[RFC3940]</a></td>
<td class="author-text">Adamson, B., Bormann, C., Handley, M., and J. Macker, &ldquo;<a href="http://tools.ietf.org/html/rfc3940">Negative-acknowledgment (NACK)-Oriented Reliable Multicast (NORM) Protocol</a>,&rdquo; RFC&nbsp;3940, November&nbsp;2004 (<a href="http://www.rfc-editor.org/rfc/rfc3940.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4535">[RFC4535]</a></td>
<td class="author-text">Harney, H., Meth, U., Colegrove, A., and G. Gross, &ldquo;<a href="http://tools.ietf.org/html/rfc4535">GSAKMP: Group Secure Association Key Management Protocol</a>,&rdquo; RFC&nbsp;4535, June&nbsp;2006 (<a href="http://www.rfc-editor.org/rfc/rfc4535.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4566">[RFC4566]</a></td>
<td class="author-text">Handley, M., Jacobson, V., and C. Perkins, &ldquo;<a href="http://tools.ietf.org/html/rfc4566">SDP: Session Description Protocol</a>,&rdquo; RFC&nbsp;4566, July&nbsp;2006 (<a href="http://www.rfc-editor.org/rfc/rfc4566.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC5445">[RFC5445]</a></td>
<td class="author-text">Watson, M., &ldquo;<a href="http://tools.ietf.org/html/rfc5445">Basic Forward Error Correction (FEC) Schemes</a>,&rdquo; RFC&nbsp;5445, March&nbsp;2009 (<a href="http://www.rfc-editor.org/rfc/rfc5445.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RmComparison">[RmComparison]</a></td>
<td class="author-text">Pingali, S., <a href="mailto:">Towsley, D.</a>, and <a href="mailto:">J. Kurose</a>, &ldquo;A Comparison of Sender-Initiated and Receiver-Initiated
          Reliable Multicast Protocols,&rdquo; Proc. INFOCOMM,&nbsp;San Francisco CA, October&nbsp;1993.</td></tr>
<tr><td class="author-text" valign="top"><a name="TcpModel">[TcpModel]</a></td>
<td class="author-text">Padhye,  J., Firoiu, V., Towsley, D., and J. Kurose, &ldquo;Modeling TCP Throughput: A Simple Model and its Empirical
          Validation,&rdquo; ACM SIGCOMM&nbsp;, 1998.</td></tr>
<tr><td class="author-text" valign="top"><a name="TfmccPaper">[TfmccPaper]</a></td>
<td class="author-text">Widmer, J. and <a href="mailto:">M. Handley</a>, &ldquo;Extending Equation-Based Congestion Control to Multicast
          Applications,&rdquo; ACM SIGCOMM&nbsp;, August&nbsp;2001.</td></tr>
</table>

<a name="rfc.authors"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>Authors' Addresses</h3>
<table width="99%" border="0" cellpadding="0" cellspacing="0">
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Brian Adamson</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Naval Research Laboratory</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Washington, DC  20375</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">USA</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:adamson@itd.nrl.navy.mil">adamson@itd.nrl.navy.mil</a></td></tr>
<tr cellpadding="3"><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Carsten Bormann</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Universitaet Bremen TZI</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Postfach 330440</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">D-28334 Bremen</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Germany</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:cabo@tzi.org">cabo@tzi.org</a></td></tr>
<tr cellpadding="3"><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Mark Handley</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">University College London</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Gower Street</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">London  WC1E 6BT</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">UK</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:M.Handley@cs.ucl.ac.uk">M.Handley@cs.ucl.ac.uk</a></td></tr>
<tr cellpadding="3"><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Joe Macker</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Naval Research Laboratory</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Washington, DC  20375</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">USA</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:macker@itd.nrl.navy.mil">macker@itd.nrl.navy.mil</a></td></tr>
</table>
</body></html>
