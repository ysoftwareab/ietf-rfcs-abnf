<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" 
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html lang="en" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head profile="http://www.w3.org/2006/03/hcard%20http://dublincore.org/documents/2008/08/04/dc-html/">
  <meta http-equiv="Content-Type" content="text/html; charset=us-ascii" />

  <title>A Quick Crash Detection Method for IKE</title>

  <style type="text/css" title="Xml2Rfc (sans serif)">
  /*<![CDATA[*/
	  a {
	  text-decoration: none;
	  }
	  a.smpl {
	  color: black;
	  }
	  a:hover {
	  text-decoration: underline;
	  }
	  a:active {
	  text-decoration: underline;
	  }
	  address {
	  margin-top: 1em;
	  margin-left: 2em;
	  font-style: normal;
	  }
	  body {
	  color: black;
	  font-family: verdana, helvetica, arial, sans-serif;
	  font-size: 10pt;
	  
	  }
	  cite {
	  font-style: normal;
	  }
	  dd {
	  margin-right: 2em;
	  }
	  dl {
	  margin-left: 2em;
	  }
	
	  ul.empty {
	  list-style-type: none;
	  }
	  ul.empty li {
	  margin-top: .5em;
	  }
	  dl p {
	  margin-left: 0em;
	  }
	  dt {
	  margin-top: .5em;
	  }
	  h1 {
	  font-size: 14pt;
	  line-height: 21pt;
	  page-break-after: avoid;
	  }
	  h1.np {
	  page-break-before: always;
	  }
	  h1 a {
	  color: #333333;
	  }
	  h2 {
	  font-size: 12pt;
	  line-height: 15pt;
	  page-break-after: avoid;
	  }
	  h3, h4, h5, h6 {
	  font-size: 10pt;
	  page-break-after: avoid;
	  }
	  h2 a, h3 a, h4 a, h5 a, h6 a {
	  color: black;
	  }
	  img {
	  margin-left: 3em;
	  }
	  li {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  ol {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  ol p {
	  margin-left: 0em;
	  }
	  p {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  pre {
	  margin-left: 3em;
	  background-color: lightyellow;
	  padding: .25em;
	  }
	  pre.text2 {
	  border-style: dotted;
	  border-width: 1px;
	  background-color: #f0f0f0;
	  width: 69em;
	  }
	  pre.inline {
	  background-color: white;
	  padding: 0em;
	  }
	  pre.text {
	  border-style: dotted;
	  border-width: 1px;
	  background-color: #f8f8f8;
	  width: 69em;
	  }
	  pre.drawing {
	  border-style: solid;
	  border-width: 1px;
	  background-color: #f8f8f8;
	  padding: 2em;
	  }
	  table {
	  margin-left: 2em;
	  }
	  table.tt {
	  vertical-align: top;
	  }
	  table.full {
	  border-style: outset;
	  border-width: 1px;
	  }
	  table.headers {
	  border-style: outset;
	  border-width: 1px;
	  }
	  table.tt td {
	  vertical-align: top;
	  }
	  table.full td {
	  border-style: inset;
	  border-width: 1px;
	  }
	  table.tt th {
	  vertical-align: top;
	  }
	  table.full th {
	  border-style: inset;
	  border-width: 1px;
	  }
	  table.headers th {
	  border-style: none none inset none;
	  border-width: 1px;
	  }
	  table.left {
	  margin-right: auto;
	  }
	  table.right {
	  margin-left: auto;
	  }
	  table.center {
	  margin-left: auto;
	  margin-right: auto;
	  }
	  caption {
	  caption-side: bottom;
	  font-weight: bold;
	  font-size: 9pt;
	  margin-top: .5em;
	  }
	
	  table.header {
	  border-spacing: 1px;
	  width: 95%;
	  font-size: 10pt;
	  color: white;
	  }
	  td.top {
	  vertical-align: top;
	  }
	  td.topnowrap {
	  vertical-align: top;
	  white-space: nowrap; 
	  }
	  table.header td {
	  background-color: gray;
	  width: 50%;
	  }
	  table.header a {
	  color: white;
	  }
	  td.reference {
	  vertical-align: top;
	  white-space: nowrap;
	  padding-right: 1em;
	  }
	  thead {
	  display:table-header-group;
	  }
	  ul.toc, ul.toc ul {
	  list-style: none;
	  margin-left: 1.5em;
	  margin-right: 0em;
	  padding-left: 0em;
	  }
	  ul.toc li {
	  line-height: 150%;
	  font-weight: bold;
	  font-size: 10pt;
	  margin-left: 0em;
	  margin-right: 0em;
	  }
	  ul.toc li li {
	  line-height: normal;
	  font-weight: normal;
	  font-size: 9pt;
	  margin-left: 0em;
	  margin-right: 0em;
	  }
	  li.excluded {
	  font-size: 0pt;
	  }
	  ul p {
	  margin-left: 0em;
	  }
	
	  .comment {
	  background-color: yellow;
	  }
	  .center {
	  text-align: center;
	  }
	  .error {
	  color: red;
	  font-style: italic;
	  font-weight: bold;
	  }
	  .figure {
	  font-weight: bold;
	  text-align: center;
	  font-size: 9pt;
	  }
	  .filename {
	  color: #333333;
	  font-weight: bold;
	  font-size: 12pt;
	  line-height: 21pt;
	  text-align: center;
	  }
	  .fn {
	  font-weight: bold;
	  }
	  .hidden {
	  display: none;
	  }
	  .left {
	  text-align: left;
	  }
	  .right {
	  text-align: right;
	  }
	  .title {
	  color: #990000;
	  font-size: 18pt;
	  line-height: 18pt;
	  font-weight: bold;
	  text-align: center;
	  margin-top: 36pt;
	  }
	  .vcardline {
	  display: block;
	  }
	  .warning {
	  font-size: 14pt;
	  background-color: yellow;
	  }
	
	
	  @media print {
	  .noprint {
		display: none;
	  }
	
	  a {
		color: black;
		text-decoration: none;
	  }
	
	  table.header {
		width: 90%;
	  }
	
	  td.header {
		width: 50%;
		color: black;
		background-color: white;
		vertical-align: top;
		font-size: 12pt;
	  }
	
	  ul.toc a::after {
		content: leader('.') target-counter(attr(href), page);
	  }
	
	  ul.ind li li a {
		content: target-counter(attr(href), page);
	  }
	
	  .print2col {
		column-count: 2;
		-moz-column-count: 2;
		column-fill: auto;
	  }
	  }
	
	  @page {
	  @top-left {
		   content: "Internet-Draft"; 
	  } 
	  @top-right {
		   content: "December 2010"; 
	  } 
	  @top-center {
		   content: "Abbreviated Title";3
	  } 
	  @bottom-left {
		   content: "Doe"; 
	  } 
	  @bottom-center {
		   content: "Expires June 2011"; 
	  } 
	  @bottom-right {
		   content: "[Page " counter(page) "]"; 
	  } 
	  }
	
	  @page:first { 
		@top-left {
		  content: normal;
		}
		@top-right {
		  content: normal;
		}
		@top-center {
		  content: normal;
		}
	  }
  /*]]>*/
  </style>

  <link href="#rfc.toc" rel="Contents">
<link href="#rfc.section.1" rel="Chapter" title="1 Introduction">
<link href="#rfc.section.1.1" rel="Chapter" title="1.1 Conventions Used in This Document">
<link href="#rfc.section.2" rel="Chapter" title="2 RFC 5996 Crash Recovery">
<link href="#rfc.section.3" rel="Chapter" title="3 Protocol Outline">
<link href="#rfc.section.4" rel="Chapter" title="4 Formats and Exchanges">
<link href="#rfc.section.4.1" rel="Chapter" title="4.1 Notification Format">
<link href="#rfc.section.4.2" rel="Chapter" title="4.2 Passing a Token in the AUTH Exchange">
<link href="#rfc.section.4.3" rel="Chapter" title="4.3 Replacing Tokens After Rekey or Resumption">
<link href="#rfc.section.4.4" rel="Chapter" title="4.4 Replacing the Token for an Existing SA">
<link href="#rfc.section.4.5" rel="Chapter" title="4.5 Presenting the Token in an Unprotected Message">
<link href="#rfc.section.5" rel="Chapter" title="5 Token Generation and Verification">
<link href="#rfc.section.5.1" rel="Chapter" title="5.1 A Stateless Method of Token Generation">
<link href="#rfc.section.5.2" rel="Chapter" title="5.2 A Stateless Method with IP addresses">
<link href="#rfc.section.5.3" rel="Chapter" title="5.3 Token Lifetime">
<link href="#rfc.section.6" rel="Chapter" title="6 Backup Gateways">
<link href="#rfc.section.7" rel="Chapter" title="7 Interaction with Session Resumption">
<link href="#rfc.section.8" rel="Chapter" title="8 Operational Considerations">
<link href="#rfc.section.8.1" rel="Chapter" title="8.1 Who should implement this specification">
<link href="#rfc.section.8.2" rel="Chapter" title="8.2 Response to unknown child SPI">
<link href="#rfc.section.9" rel="Chapter" title="9 Security Considerations">
<link href="#rfc.section.9.1" rel="Chapter" title="9.1 QCD Token Generation and Handling">
<link href="#rfc.section.9.2" rel="Chapter" title="9.2 QCD Token Transmission">
<link href="#rfc.section.9.3" rel="Chapter" title="9.3 QCD Token Enumeration">
<link href="#rfc.section.10" rel="Chapter" title="10 IANA Considerations">
<link href="#rfc.section.11" rel="Chapter" title="11 Acknowledgements">
<link href="#rfc.section.12" rel="Chapter" title="12 Change Log">
<link href="#rfc.section.12.1" rel="Chapter" title="12.1 Changes from draft-ietf-ipsecme-failure-detection-05">
<link href="#rfc.section.12.2" rel="Chapter" title="12.2 Changes from draft-ietf-ipsecme-failure-detection-04">
<link href="#rfc.section.12.3" rel="Chapter" title="12.3 Changes from draft-ietf-ipsecme-failure-detection-03">
<link href="#rfc.section.12.4" rel="Chapter" title="12.4 Changes from draft-ietf-ipsecme-failure-detection-02">
<link href="#rfc.section.12.5" rel="Chapter" title="12.5 Changes from draft-ietf-ipsecme-failure-detection-01">
<link href="#rfc.section.12.6" rel="Chapter" title="12.6 Changes from draft-ietf-ipsecme-failure-detection-00">
<link href="#rfc.section.12.7" rel="Chapter" title="12.7 Changes from draft-nir-ike-qcd-07">
<link href="#rfc.section.12.8" rel="Chapter" title="12.8 Changes from draft-nir-ike-qcd-03 and -04">
<link href="#rfc.section.12.9" rel="Chapter" title="12.9 Changes from draft-nir-ike-qcd-02">
<link href="#rfc.section.12.10" rel="Chapter" title="12.10 Changes from draft-nir-ike-qcd-01">
<link href="#rfc.section.12.11" rel="Chapter" title="12.11 Changes from draft-nir-ike-qcd-00">
<link href="#rfc.section.12.12" rel="Chapter" title="12.12 Changes from draft-nir-qcr-00">
<link href="#rfc.references" rel="Chapter" title="13 References">
<link href="#rfc.references.1" rel="Chapter" title="13.1 Normative References">
<link href="#rfc.references.2" rel="Chapter" title="13.2 Informative References">
<link href="#rfc.appendix.Appendix%20A" rel="Chapter" title="Appendix A The Path Not Taken">
<link href="#rfc.appendix.Appendix%20A.1" rel="Chapter" title="Appendix A.1 Initiating a new IKE SA">
<link href="#rfc.appendix.Appendix%20A.2" rel="Chapter" title="Appendix A.2 SIR">
<link href="#rfc.appendix.Appendix%20A.3" rel="Chapter" title="Appendix A.3 Birth Certificates">
<link href="#rfc.appendix.Appendix%20A.4" rel="Chapter" title="Appendix A.4 Reducing Liveness Check Length">
<link href="#rfc.authors" rel="Chapter">


  <meta name="generator" content=
  "http://greenbytes.de/tech/webdav/rfc2629.xslt, Revision 1.539, 2011-01-02 17:13:00, XSLT vendor: SAXON 6.5.5 from Michael Kay http://saxon.sf.net/" />
  <link rel="schema.dct" href="http://purl.org/dc/terms/" />
  <meta name="dct.creator" content="Doe, J." />
  <meta name="dct.identifier" content="urn:ietf:id:draft-sample-input-00" />
  <meta name="dct.issued" scheme="ISO8601" content="2010-12" />
  
  <meta name="dct.abstract" content="This document describes an extension to the IKEv2 protocol that allows for faster detection of Security Association (SA) desynchronization using a saved token." />
  <meta name="description" content="This document describes an extension to the IKEv2 protocol that allows for faster detection of Security Association (SA) desynchronization using a saved token." />
  <meta name="keywords" content="Internet-Draft" />

</head>

<body>

  <table class="header">
    <tbody>
    
    	<tr>
<td class="left">IPsecME Working Group</td>
<td class="right">Y. Nir, Ed.</td>
</tr>
<tr>
<td class="left">Internet-Draft</td>
<td class="right">Check Point</td>
</tr>
<tr>
<td class="left">Intended status: Standards Track</td>
<td class="right">D. Wierbowski</td>
</tr>
<tr>
<td class="left">Expires: September 29, 2011</td>
<td class="right">IBM</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">F. Detienne</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">P. Sethi</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">Cisco</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">March 28, 2011</td>
</tr>

    	
    </tbody>
  </table>

  <p class="title">A Quick Crash Detection Method for IKE<br />
  <span class="filename">draft-ietf-ipsecme-failure-detection-07</span></p>
  
  <h1 id="rfc.abstract"><a href="#rfc.abstract">Abstract</a></h1>
<p>This document describes an extension to the IKEv2 protocol that allows for faster detection of Security Association (SA) desynchronization using a saved token.</p>
<p>When an IPsec tunnel between two IKEv2 peers is disconnected due to a restart of one peer, it can take as much as several minutes for the other peer to discover that the reboot has occurred, thus delaying recovery. In this text we propose an extension to the protocol, that allows for recovery immediately following the restart.</p>
<h1 id="rfc.status"><a href="#rfc.status">Status of this Memo</a></h1>
<p>This Internet-Draft is submitted in full conformance with the provisions of BCP 78 and BCP 79.</p>
<p>Internet-Drafts are working documents of the Internet Engineering Task Force (IETF).  Note that other groups may also distribute working documents as Internet-Drafts.  The list of current Internet- Drafts is at http://datatracker.ietf.org/drafts/current/.</p>
<p>Internet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other documents at any time.  It is inappropriate to use Internet-Drafts as reference material or to cite them other than as "work in progress."</p>
<p>This Internet-Draft will expire on September 29, 2011.</p>
<h1 id="rfc.copyrightnotice"><a href="#rfc.copyrightnotice">Copyright Notice</a></h1>
<p>Copyright (c) 2011 IETF Trust and the persons identified as the document authors.  All rights reserved.</p>
<p>This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document.  Please review these documents carefully, as they describe your rights and restrictions with respect to this document.  Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.</p>

  
  <hr class="noprint" />
  <h1 class="np" id="rfc.toc"><a href="#rfc.toc">Table of Contents</a></h1>
  <ul class="toc">

  	<li>1.   <a href="#rfc.section.1">Introduction</a>
</li>
<li>1.1.   <a href="#rfc.section.1.1">Conventions Used in This Document</a>
</li>
<li>2.   <a href="#rfc.section.2">RFC 5996 Crash Recovery</a>
</li>
<li>3.   <a href="#rfc.section.3">Protocol Outline</a>
</li>
<li>4.   <a href="#rfc.section.4">Formats and Exchanges</a>
</li>
<li>4.1.   <a href="#rfc.section.4.1">Notification Format</a>
</li>
<li>4.2.   <a href="#rfc.section.4.2">Passing a Token in the AUTH Exchange</a>
</li>
<li>4.3.   <a href="#rfc.section.4.3">Replacing Tokens After Rekey or Resumption</a>
</li>
<li>4.4.   <a href="#rfc.section.4.4">Replacing the Token for an Existing SA</a>
</li>
<li>4.5.   <a href="#rfc.section.4.5">Presenting the Token in an Unprotected Message</a>
</li>
<li>5.   <a href="#rfc.section.5">Token Generation and Verification</a>
</li>
<li>5.1.   <a href="#rfc.section.5.1">A Stateless Method of Token Generation</a>
</li>
<li>5.2.   <a href="#rfc.section.5.2">A Stateless Method with IP addresses</a>
</li>
<li>5.3.   <a href="#rfc.section.5.3">Token Lifetime</a>
</li>
<li>6.   <a href="#rfc.section.6">Backup Gateways</a>
</li>
<li>7.   <a href="#rfc.section.7">Interaction with Session Resumption</a>
</li>
<li>8.   <a href="#rfc.section.8">Operational Considerations</a>
</li>
<li>8.1.   <a href="#rfc.section.8.1">Who should implement this specification</a>
</li>
<li>8.2.   <a href="#rfc.section.8.2">Response to unknown child SPI</a>
</li>
<li>9.   <a href="#rfc.section.9">Security Considerations</a>
</li>
<li>9.1.   <a href="#rfc.section.9.1">QCD Token Generation and Handling</a>
</li>
<li>9.2.   <a href="#rfc.section.9.2">QCD Token Transmission</a>
</li>
<li>9.3.   <a href="#rfc.section.9.3">QCD Token Enumeration</a>
</li>
<li>10.   <a href="#rfc.section.10">IANA Considerations</a>
</li>
<li>11.   <a href="#rfc.section.11">Acknowledgements</a>
</li>
<li>12.   <a href="#rfc.section.12">Change Log</a>
</li>
<li>12.1.   <a href="#rfc.section.12.1">Changes from draft-ietf-ipsecme-failure-detection-05</a>
</li>
<li>12.2.   <a href="#rfc.section.12.2">Changes from draft-ietf-ipsecme-failure-detection-04</a>
</li>
<li>12.3.   <a href="#rfc.section.12.3">Changes from draft-ietf-ipsecme-failure-detection-03</a>
</li>
<li>12.4.   <a href="#rfc.section.12.4">Changes from draft-ietf-ipsecme-failure-detection-02</a>
</li>
<li>12.5.   <a href="#rfc.section.12.5">Changes from draft-ietf-ipsecme-failure-detection-01</a>
</li>
<li>12.6.   <a href="#rfc.section.12.6">Changes from draft-ietf-ipsecme-failure-detection-00</a>
</li>
<li>12.7.   <a href="#rfc.section.12.7">Changes from draft-nir-ike-qcd-07</a>
</li>
<li>12.8.   <a href="#rfc.section.12.8">Changes from draft-nir-ike-qcd-03 and -04</a>
</li>
<li>12.9.   <a href="#rfc.section.12.9">Changes from draft-nir-ike-qcd-02</a>
</li>
<li>12.10.   <a href="#rfc.section.12.10">Changes from draft-nir-ike-qcd-01</a>
</li>
<li>12.11.   <a href="#rfc.section.12.11">Changes from draft-nir-ike-qcd-00</a>
</li>
<li>12.12.   <a href="#rfc.section.12.12">Changes from draft-nir-qcr-00</a>
</li>
<li>13.   <a href="#rfc.references">References</a>
</li>
<li>13.1.   <a href="#rfc.references.1">Normative References</a>
</li>
<li>13.2.   <a href="#rfc.references.2">Informative References</a>
</li>
<li>Appendix A.   <a href="#rfc.appendix.Appendix%20A">The Path Not Taken</a>
</li>
<li>Appendix A.1.   <a href="#rfc.appendix.Appendix%20A.1">Initiating a new IKE SA</a>
</li>
<li>Appendix A.2.   <a href="#rfc.appendix.Appendix%20A.2">SIR</a>
</li>
<li>Appendix A.3.   <a href="#rfc.appendix.Appendix%20A.3">Birth Certificates</a>
</li>
<li>Appendix A.4.   <a href="#rfc.appendix.Appendix%20A.4">Reducing Liveness Check Length</a>
</li>
<li><a href="#rfc.authors">Authors' Addresses</a>
</li>


  </ul>

  <h1 id="rfc.section.1">
<a href="#rfc.section.1">1.</a> <a href="#introduction" id="introduction">Introduction</a>
</h1>
<p id="rfc.section.1.p.1">IKEv2, as described in <a href="#RFC5996">[RFC5996]</a> and its predecessor RFC 4306, has a method for recovering from a reboot of one peer. As long as traffic flows in both directions, the rebooted peer should re-establish the tunnels immediately. However, in many cases the rebooted peer is a VPN gateway that protects only servers, so all traffic is inbound.  In other cases, the non-rebooted peer has a dynamic IP address, so the rebooted peer cannot initiate IKE because its current IP address is unknown. In such cases, the rebooted peer will not be able to re-establish the tunnels. <a href="#SCR">Section 2</a> describes how recovery works under RFC 5996, and explains why it may take several minutes.</p>
<p id="rfc.section.1.p.2">The method proposed here, is to send an octet string, called a "QCD token" in the IKE_AUTH exchange that establishes the tunnel. That token can be stored on the peer as part of the IKE SA. After a reboot, the rebooted implementation can re-generate the token, and send it to the peer, so as to delete the IKE SA. Deleting the IKE SA results in a quick establishment of new IPsec tunnels. This is described in <a href="#outline">Section 3</a>.</p>
<h1 id="rfc.section.1.1">
<a href="#rfc.section.1.1">1.1.</a> <a href="#mustshouldmay" id="mustshouldmay">Conventions Used in This Document</a>
</h1>
<p id="rfc.section.1.1.p.1">The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in <a href="#RFC2119">[RFC2119]</a>.</p>
<p id="rfc.section.1.1.p.2">The term "token" refers to an octet string that an implementation can generate using only the properties of a protected IKE message (such as IKE SPIs) as input. A conforming implementation MUST be able to generate the same token from the same input even after rebooting.</p>
<p id="rfc.section.1.1.p.3">The term "token maker" refers to an implementation that generates a token and sends it to the peer as specified in this document.</p>
<p id="rfc.section.1.1.p.4">The term "token taker" refers to an implementation that stores such a token or a digest thereof, in order to verify that a new token it receives is identical to the old token it has stored.</p>
<p id="rfc.section.1.1.p.5">The term "non-volatile storage" in this document refers to a data storage module, that persists across restarts of the token maker. Examples of such a storage module include an internal disk, an internal flash memory module, an external disk and an external database. A small non-volatile storage module is required for a token maker, but a larger one can be used to enhance performance, as described in <a href="#operation_esp">Section 8.2</a>.</p>
<h1 id="rfc.section.2">
<a href="#rfc.section.2">2.</a> <a href="#SCR" id="SCR">RFC 5996 Crash Recovery</a>
</h1>
<p id="rfc.section.2.p.1">When one peer loses state or reboots, the other peer does not get any notification, so unidirectional IPsec traffic can still flow. The rebooted peer will not be able to decrypt it, however, and the only remedy is to send an unprotected INVALID_SPI notification as described in section 3.10.1 of <a href="#RFC5996">[RFC5996]</a>.  That section also describes the processing of such a notification:</p>
<div id="#rfc.figure.1"></div>
<pre>
      "If this Informational Message is sent outside the
  context of an IKE_SA, it should be used by the recipient
  only as a "hint" that something might be wrong (because it
  could easily be forged)."
        </pre>
<p id="rfc.section.2.p.2">Since the INVALID_SPI can only be used as a hint, the non-rebooted peer has to determine whether the IPsec SA, and indeed the parent IKE SA are still valid.  The method of doing this is described in section 2.4 of <a href="#RFC5996">[RFC5996]</a>. This method, called "liveness check" involves sending a protected empty INFORMATIONAL message, and awaiting a response. This procedure is sometimes referred to as "Dead Peer Detection" or DPD.</p>
<p id="rfc.section.2.p.3">Section 2.4 does not mandate how many times the liveness check message should be retransmitted, or for how long, but does recommend the following:</p>
<div id="#rfc.figure.2"></div>
<pre>
                                                            "It is
 suggested that messages be retransmitted at least a dozen times over
 a period of at least several minutes before giving up on an SA..."
        </pre>
<p id="rfc.section.2.p.4">Those "at least several minutes" are a time during part of which both peers are active, but IPsec cannot be used.</p>
<p id="rfc.section.2.p.5">Especially in the case of a reboot (rather than fail-over or administrative clearing of state), the peer does not recover immediately. Reboot, depending on the system, may take from a few seconds to a few minutes. This means that at first the peer just goes silent, i.e., does not send or respond to any messages. IKEv2 implementations can detect this situation and follow the rules given in section 2.4:</p>
<div id="#rfc.figure.3"></div>
<pre>
         If there has only been outgoing traffic on all of
  the SAs associated with an IKE SA, it is essential to confirm
  liveness of the other endpoint to avoid black holes.  If no
  cryptographically protected messages have been received on an IKE 
  SA or any of its Child SAs recently, the system needs to perform a
  liveness check in order to prevent sending messages to a dead peer.
   </pre>
<p><a href="#RFC5996">[RFC5996]</a> does not mandate any time limits, but it is possible that the peer will start liveness checks even before the other end is sending INVALID_SPI notification, as it detected that the other end is not sending any packets anymore while it is still rebooting or recovering from the situation.</p>
<p id="rfc.section.2.p.7">This means that the several minutes recovery period is overlaping the actual recover time of the other peer, i.e., if the security gateway requires several minutes to boot up from the crash then the other peers have already finished their liveness checks before the crashing peer even has a chance to send INVALID_SPI notifications.</p>
<p id="rfc.section.2.p.8">There are cases where the peer loses state and is able to recover immediately; in those cases it might take several minutes to recreate the IPsec SAs.</p>
<p id="rfc.section.2.p.9">Note that the IKEv2 specification specifically gives no guidance for the number of retries or the length of timeouts, as these do not affect interoperability. This means that implementations are allowed to use the hints provided by the INVALID_SPI messages to shorten those timeouts (i.e., different environment and situation requiring different rules).</p>
<p id="rfc.section.2.p.10">Some existing IKEv2 implementations already do that (i.e., both shorten timeouts or limit number of retries) based on these kind of hints and also start liveness checks quickly after the other end goes silent. However, see <a href="#shortwait">Appendix Appendix A.4</a> for a discussion of why this may not be enough.</p>
<h1 id="rfc.section.3">
<a href="#rfc.section.3">3.</a> <a href="#outline" id="outline">Protocol Outline</a>
</h1>
<p id="rfc.section.3.p.1">Supporting implementations will send a notification, called a "QCD token", as described in <a href="#format_notif">Section 4.1</a> in the first IKE_AUTH exchange messages. These are the first IKE_AUTH request and final IKE_AUTH response that contain the AUTH payloads.  The generation of these tokens is a local matter for implementations, but considerations are described in <a href="#tokengen">Section 5</a>. Implementations that send such a token will be called "token makers".</p>
<p id="rfc.section.3.p.2">A supporting implementation receiving such a token MUST store it (or a digest thereof) along with the IKE SA. Implementations that support this part of the protocol will be called "token takers". <a href="#operation_who">Section 8.1</a> has considerations for which implementations need to be token takers, and which should be token makers.  Implementations that are not token takers will silently ignore QCD tokens.</p>
<p id="rfc.section.3.p.3">When a token maker receives a protected IKE request message with unknown IKE SPIs, it SHOULD generate a new token that is identical to the previous token, and send it to the requesting peer in an unprotected IKE message as described in <a href="#format_info">Section 4.5</a>.</p>
<p id="rfc.section.3.p.4">When a token taker receives the QCD token in an unprotected notification, it MUST verify that the TOKEN_SECRET_DATA matches the token stored with the matching IKE SA. If the verification fails, or if the IKE SPIs in the message do not match any existing IKE SA, it SHOULD log the event. If it succeeds, it MUST silently delete the IKE SA associated with the IKE_SPI fields, and all dependent child SAs. This event MAY also be logged. The token taker MUST accept such tokens from any IP address and port combination, so as to allow different kinds of high-availability configurations of the token maker.</p>
<p id="rfc.section.3.p.5">A supporting token taker MAY immediately create new SAs using an Initial exchange, or it may wait for subsequent traffic to trigger the creation of new SAs.</p>
<p id="rfc.section.3.p.6">See <a href="#int_resume">Section 7</a> for a short discussion about this extensions's interaction with IKEv2 Session Resumption (<a href="#RFC5723">[RFC5723]</a>).</p>
<h1 id="rfc.section.4">
<a href="#rfc.section.4">4.</a> <a href="#format" id="format">Formats and Exchanges</a>
</h1>
<h1 id="rfc.section.4.1">
<a href="#rfc.section.4.1">4.1.</a> <a href="#format_notif" id="format_notif">Notification Format</a>
</h1>
<p id="rfc.section.4.1.p.1">The notification payload called "QCD token" is formatted as follows:</p>
<div id="#rfc.figure.4"></div>
<pre>
                         1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    ! Next Payload  !C!  RESERVED   !         Payload Length        !
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    !  Protocol ID  !   SPI Size    ! QCD Token Notify Message Type !
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    !                                                               !
    ~                       TOKEN_SECRET_DATA                       ~
    !                                                               !
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
          </pre>
<p></p>

<ul>
<li>Protocol ID (1 octet) MUST be 1, as this message is related to an IKE SA.</li>
<li>SPI Size (1 octet) MUST be zero, in conformance with section 3.10 of <a href="#RFC5996">[RFC5996]</a>.</li>
<li>QCD Token Notify Message Type (2 octets) - MUST be xxxxx, the value assigned for QCD token notifications. TBA by IANA.</li>
<li>TOKEN_SECRET_DATA (variable) contains a generated token as described in <a href="#tokengen">Section 5</a>.</li>
</ul>
<h1 id="rfc.section.4.2">
<a href="#rfc.section.4.2">4.2.</a> <a href="#format_auth" id="format_auth">Passing a Token in the AUTH Exchange</a>
</h1>
<p id="rfc.section.4.2.p.1">For brevity, only the EAP version of an AUTH exchange will be presented here. The non-EAP version is very similar. The figures below are based on appendix C.3 of <a href="#RFC5996">[RFC5996]</a>.</p>
<div id="#rfc.figure.5"></div>
<pre>
 first request       --&gt; IDi,
                         [N(INITIAL_CONTACT)],
                         [[N(HTTP_CERT_LOOKUP_SUPPORTED)], CERTREQ+],
                         [IDr],
                         [N(QCD_TOKEN)]
                         [CP(CFG_REQUEST)],
                         [N(IPCOMP_SUPPORTED)+],
                         [N(USE_TRANSPORT_MODE)],
                         [N(ESP_TFC_PADDING_NOT_SUPPORTED)],
                         [N(NON_FIRST_FRAGMENTS_ALSO)],
                         SA, TSi, TSr,
                         [V+]

 first response      &lt;-- IDr, [CERT+], AUTH,
                         EAP,
                         [V+]

                   / --&gt; EAP
 repeat 1..N times |
                   \ &lt;-- EAP

 last request        --&gt; AUTH

 last response       &lt;-- AUTH,
                         [N(QCD_TOKEN)]
                         [CP(CFG_REPLY)],
                         [N(IPCOMP_SUPPORTED)],
                         [N(USE_TRANSPORT_MODE)],
                         [N(ESP_TFC_PADDING_NOT_SUPPORTED)],
                         [N(NON_FIRST_FRAGMENTS_ALSO)],
                         SA, TSi, TSr,
                         [N(ADDITIONAL_TS_POSSIBLE)],
                         [V+]
          </pre>
<p id="rfc.section.4.2.p.2">Note that the QCD_TOKEN notification is marked as optional because it is not required by this specification that every implementation be both token maker and token taker.  If only one peer sends the QCD token, then a reboot of the other peer will not be recoverable by this method. This may be acceptable if traffic typically originates from the other peer.</p>
<p id="rfc.section.4.2.p.3">In any case, the lack of a QCD_TOKEN notification MUST NOT be taken as an indication that the peer does not support this standard. Conversely, if a peer does not understand this notification, it will simply ignore it. Therefore a peer may  send this notification freely, even if it does not know whether the other side supports it.</p>
<p id="rfc.section.4.2.p.4">The QCD_TOKEN notification is related to the IKE SA and should follow the AUTH payload and precede the Configuration payload and all payloads related to the child SA.</p>
<h1 id="rfc.section.4.3">
<a href="#rfc.section.4.3">4.3.</a> <a href="#format_rekey" id="format_rekey">Replacing Tokens After Rekey or Resumption</a>
</h1>
<p id="rfc.section.4.3.p.1">After rekeying an IKE SA, the IKE SPIs are replaced, so the new SA also needs to have a token.  If only the responder in the rekey exchange is the token maker, this can be done within the CREATE_CHILD_SA exchange. If the initiator is a token maker, then we need an extra informational exchange.</p>
<p id="rfc.section.4.3.p.2">The following figure shows the CREATE_CHILD_SA exchange for rekeying the IKE SA. Only the responder sends a QCD token.</p>
<div id="#rfc.figure.6"></div>
<pre>
   request             --&gt; SA, Ni, [KEi]

   response            &lt;-- SA, Nr, [KEr], N(QCD_TOKEN)            
          </pre>
<p id="rfc.section.4.3.p.3">If the initiator is also a token maker, it SHOULD initiate an INFORMATIONAL exchange immediately after the CREATE_CHILD_SA exchange as follows:</p>
<div id="#rfc.figure.7"></div>
<pre>
   request             --&gt; N(QCD_TOKEN)

   response            &lt;--             
          </pre>
<p id="rfc.section.4.3.p.4">For session resumption, as specified in <a href="#RFC5723">[RFC5723]</a>, the situation is similar. The responder, which is necessarily the peer that has crashed, SHOULD send a new ticket within the protected payload of the IKE_SESSION_RESUME exchange. If the Initiator is also a token maker, it needs to send a QCD_TOKEN in a separate INFORMATIONAL exchange.</p>
<p id="rfc.section.4.3.p.5">The INFORMATIONAL exchange described in this section can also be used if QCD tokens need to be replaced due to a key rollover. However, since token takers are required to verify at least 4 QCD tokens, this is only necessary if secret QCD keys are rolled over more than four times as often as IKE SAs are rekeyed. See <a href="#tg1">Section 5.1</a> for an example method that uses secret keys which may require rollover.</p>
<h1 id="rfc.section.4.4">
<a href="#rfc.section.4.4">4.4.</a> <a href="#format_mob" id="format_mob">Replacing the Token for an Existing SA</a>
</h1>
<p id="rfc.section.4.4.p.1">With some token generation methods, such as that described in <a href="#tg2">Section 5.2</a>, a QCD token may sometimes become invalid, although the IKE SA is still perfectly valid.</p>
<p id="rfc.section.4.4.p.2">In such a case, the token maker MUST send the new token in a protected message under that IKE SA. That exchange could be a simple INFORMATIONAL, such as in the last figure in the previous section, or else it can be part of a MOBIKE INFORMATIONAL exchange such as in the following figure taken from section 2.2 of <a href="#RFC4555">[RFC4555]</a> and modified by adding a QCD_TOKEN notification:</p>
<div id="#rfc.figure.8"></div>
<pre>
  (IP_I2:4500 -&gt; IP_R1:4500)
  HDR, SK { N(UPDATE_SA_ADDRESSES),
            N(NAT_DETECTION_SOURCE_IP),
            N(NAT_DETECTION_DESTINATION_IP) }  --&gt;

                        &lt;-- (IP_R1:4500 -&gt; IP_I2:4500)
                            HDR, SK { N(NAT_DETECTION_SOURCE_IP),
                                 N(NAT_DETECTION_DESTINATION_IP) }

                        &lt;-- (IP_R1:4500 -&gt; IP_I2:4500)
                            HDR, SK { N(COOKIE2), [N(QCD_TOKEN)] }

  (IP_I2:4500 -&gt; IP_R1:4500)
  HDR, SK { N(COOKIE2), [N(QCD_TOKEN)] }  --&gt;
          </pre>
<p id="rfc.section.4.4.p.3">A token taker MUST accept such gratuitous QCD_TOKEN notifications as long as they are carried in protected exchanges. A token maker SHOULD NOT generate them unless it is no longer able to generate the old QCD_TOKEN.</p>
<h1 id="rfc.section.4.5">
<a href="#rfc.section.4.5">4.5.</a> <a href="#format_info" id="format_info">Presenting the Token in an Unprotected Message</a>
</h1>
<p id="rfc.section.4.5.p.1">This QCD_TOKEN notification is unprotected, and is sent as a response to a protected IKE request, which uses an IKE SA that is unknown.</p>
<div id="#rfc.figure.9"></div>
<pre>
         message             --&gt; N(INVALID_IKE_SPI), N(QCD_TOKEN)+
          </pre>
<p id="rfc.section.4.5.p.2">If child SPIs are persistently mapped to IKE SPIs as described in <a href="#operation_esp">Section 8.2</a>, a token taker may get the following unprotected message in response to an ESP or AH packet.</p>
<div id="#rfc.figure.10"></div>
<pre>
         message             --&gt; N(INVALID_SPI), N(QCD_TOKEN)+
          </pre>
<p id="rfc.section.4.5.p.3">The QCD_TOKEN and INVALID_IKE_SPI notifications are sent together to support both implementations that conform to this specification and implementations that don't.  Similar to the description in section 2.21 of <a href="#RFC5996">[RFC5996]</a>, the IKE SPI and message ID fields in the packet headers are taken from the protected IKE request.</p>
<p id="rfc.section.4.5.p.4">To support a periodic rollover of the secret used for token generation, the token taker MUST support at least four QCD_TOKEN notifications in a single packet. The token is considered verified if any of the QCD_TOKEN notifications matches. The token maker MAY generate up to four QCD_TOKEN notifications, based on several generations of keys.</p>
<p id="rfc.section.4.5.p.5">If the QCD_TOKEN verifies OK, the receiver MUST silently discard the IKE SA and all associated child SAs. If the QCD_TOKEN cannot be validated, a response MUST NOT be sent, and the event may be logged. <a href="#tokengen">Section 5</a> defines token verification.</p>
<h1 id="rfc.section.5">
<a href="#rfc.section.5">5.</a> <a href="#tokengen" id="tokengen">Token Generation and Verification</a>
</h1>
<p id="rfc.section.5.p.1">No token generation method is mandated by this document. Two methods are documented in the following sub-sections, but they only serve as examples.</p>
<p id="rfc.section.5.p.2">The following lists the requirements for a token generation mechanism:</p>

<ul>
<li>Tokens MUST be at least 16 octets long, and no more than 128 octets long, to facilitate storage and transmission. Tokens SHOULD be indistinguishable from random data.</li>
<li>It should not be possible for an external attacker to guess the QCD token generated by an implementation. Cryptographic mechanisms such as PRNG and hash functions are RECOMMENDED.</li>
<li>The token maker MUST be able to re-generate or retrieve the token based on the IKE SPIs even after it reboots.</li>
<li>The method of token generation MUST be such that a collision of QCD tokens between different pairs of IKE SPI will be highly unlikely.</li>
</ul>
<h1 id="rfc.section.5.1">
<a href="#rfc.section.5.1">5.1.</a> <a href="#tg1" id="tg1">A Stateless Method of Token Generation</a>
</h1>
<p id="rfc.section.5.1.p.1">The following describes a stateless method of generating a token. In this case, 'stateless' means not maintaining any per-tunnel state, although there is a small amount of non-volatile storage required.</p>

<ul>
<li>At installation or immediately after the first boot of the token maker, 32 random octets are generated using a secure random number generator or a PRNG.</li>
<li>Those 32 bytes, called the "QCD_SECRET", are stored in non-volatile storage on the machine, and kept indefinitely.</li>
<li>If key rollover is required by policy, the implementation MAY periodically generate a new QCD_SECRET and keep up to 3 previous generations. When sending an unprotected QCD_TOKEN, as many as 4 notification payloads may be sent, each from a different QCD_SECRET.</li>
<li>The TOKEN_SECRET_DATA is calculated as follows:</li>
</ul>
<div id="#rfc.figure.11"></div>
<pre>
            
         TOKEN_SECRET_DATA = HASH(QCD_SECRET | SPI-I | SPI-R)

          </pre>
<h1 id="rfc.section.5.2">
<a href="#rfc.section.5.2">5.2.</a> <a href="#tg2" id="tg2">A Stateless Method with IP addresses</a>
</h1>
<p id="rfc.section.5.2.p.1">This method is similar to the one in the previous section, except that the IP address of the token taker is also added to the block being hashed. This has the disadvantage that the token needs to be replaced (as described in <a href="#format_mob">Section 4.4</a>) whenever the token taker changes its address.</p>
<p id="rfc.section.5.2.p.2">See <a href="#sec_trans">Section 9.2</a> for a discussion of a use-case for this method.  When using this method, the TOKEN_SECRET_DATA field is calculated as follows:</p>
<div id="#rfc.figure.12"></div>
<pre>
            
      TOKEN_SECRET_DATA = HASH(QCD_SECRET | SPI-I | SPI-R | IPaddr-T)

          </pre>
<p id="rfc.section.5.2.p.3">The IPaddr-T field specifies the IP address of the token taker. Secret rollover considerations are similar to those in the previous section.</p>
<p id="rfc.section.5.2.p.4">Note that with a multi-homed token taker, the QCD token matches just one of the token taker IP addresses. Usually this is not a problem, as packets sent to the token maker come out the same IP address. If for some reason this changes, then the token maker can replace the token as described in section 4.4.</p>
<p id="rfc.section.5.2.p.5">There is a corner case where the token taker begins using a different IP address (because of multi-homing, roaming or normal network operations) and the token maker loses state before replacing the token. In that case, it will send a correct QCD token, but the token taker will still have the old token. In that case the extension will not work, and the peers will revert to RFC 5996 recovery.</p>
<h1 id="rfc.section.5.3">
<a href="#rfc.section.5.3">5.3.</a> <a href="#toklifetime" id="toklifetime">Token Lifetime</a>
</h1>
<p id="rfc.section.5.3.p.1">The token is associated with a single IKE SA, and SHOULD be deleted by the token taker when the SA is deleted or expires. More formally, the token is associated with the pair (SPI-I, SPI-R).</p>
<h1 id="rfc.section.6">
<a href="#rfc.section.6">6.</a> <a href="#backupgw" id="backupgw">Backup Gateways</a>
</h1>
<p id="rfc.section.6.p.1">Making crash detection and recovery quick is a worthy goal, but since rebooting a gateway takes a non-zero amount of time, many implementations choose to have a stand-by gateway ready to take over as soon as the primary gateway fails for any reason.  <a href="#cluster">[cluster]</a> describes considerations for such clusters of gateways with synchronized state, but the rest of this section is relevant even when there is no synchronized state.</p>
<p id="rfc.section.6.p.2">If such a configuration is available, it is RECOMMENDED that the stand-by gateway be able to generate the same token as the active gateway. if the method described in <a href="#tg1">Section 5.1</a> is used, this means that the QCD_SECRET field is identical in both gateways. This has the effect of having the crash recovery available immediately.</p>
<p id="rfc.section.6.p.3">Note that this refers to "high availability" configurations, where only one gateway is active at any given moment. This is different from "load sharing" configurations where more than one gateway is active at the same time. For load sharing configurations, please see <a href="#sec_trans">Section 9.2</a> for security considerations.</p>
<h1 id="rfc.section.7">
<a href="#rfc.section.7">7.</a> <a href="#int_resume" id="int_resume">Interaction with Session Resumption</a>
</h1>
<p id="rfc.section.7.p.1">Session resumption, specified in <a href="#RFC5723">[RFC5723]</a>, allows the setting up of a new IKE SA to consume less computing resources. This is particularly useful in the case of a remote access gateway that has many tunnels. A failure of such a gateway requires all these many remote access clients to establish an IKE SA either with the rebooted gateway or with a backup. This tunnel re-establishment occurs within a short period of time, creating a burden on the remote access gateway. Session resumption addresses this problem by having the clients store an encrypted derivative of the IKE SA for quick re-establishment.</p>
<p id="rfc.section.7.p.2">What Session Resumption does not help is the problem of detecting that the peer gateway has failed.  A failed gateway may go undetected for an arbitrarily long time, because IPsec does not have packet acknowledgement, and applications cannot signal the IPsec layer that the tunnel "does not work".  Section 2.4 of RFC 5996 does not specify how long an implementation needs to wait before beginning a liveness check, and only says "not recently" (see full quote in Section 2). In practice some mobile devices wait a very long time before beginning liveness check, in order to extend battery life by allowing parts of the device to remain in low-power modes.</p>
<p id="rfc.section.7.p.3">QCD tokens provide a way to detect the failure of the peer in the case where liveness check has not yet ended (or begun).</p>
<p id="rfc.section.7.p.4">A remote access client conforming to both specifications will store QCD tokens, as well as the Session Resumption ticket, if provided by the gateway. A remote access gateway conforming to both specifications will generate a QCD token for the client. When the gateway reboots, the client will discover this in either of two ways:</p>

<ol>
<li>The client does regular liveness checks, or else the time for some other IKE exchange has come. Since the gateway is still down, the IKE exchange times out after several minutes. In this case QCD does not help.</li>
<li>Either the primary gateway or a backup gateway (see <a href="#backupgw">Section 6</a>) is ready and sends a QCD token to the client. In that case the client will quickly re-establish the IPsec tunnel, either with the rebooted primary gateway or the backup gateway as described in this document.  </li>
</ol>
<p id="rfc.section.7.p.5">The full combined protocol looks like this:</p>
<div id="#rfc.figure.13"></div>
<pre>
     Initiator                Responder
     -----------              -----------
    HDR, SAi1, KEi, Ni  --&gt;

                        &lt;--    HDR, SAr1, KEr, Nr, [CERTREQ]

    HDR, SK {IDi, [CERT,] 
    [CERTREQ,] [IDr,]
    AUTH, N(QCD_TOKEN)
    SAi2, TSi, TSr, 
    N(TICKET_REQUEST)}  --&gt;
                        &lt;--    HDR, SK {IDr, [CERT,] AUTH, 
                               N(QCD_TOKEN), SAr2, TSi, TSr, 
                               N(TICKET_LT_OPAQUE) } 

             ---- Reboot -----

    HDR, {}             --&gt;
                        &lt;--  HDR, N(QCD_TOKEN)
                        
    HDR, [N(COOKIE),]
    Ni, N(TICKET_OPAQUE)
    [,N+]               --&gt;
                        &lt;--  HDR, Nr [,N+]
                            
          </pre>
<h1 id="rfc.section.8">
<a href="#rfc.section.8">8.</a> <a href="#operation" id="operation">Operational Considerations</a>
</h1>
<h1 id="rfc.section.8.1">
<a href="#rfc.section.8.1">8.1.</a> <a href="#operation_who" id="operation_who">Who should implement this specification</a>
</h1>
<p id="rfc.section.8.1.p.1">Throughout this document, we have referred to reboot time alternatingly as the time that the implementation crashes and the time when it is ready to process IPsec packets and IKE exchanges. Depending on the hardware and software platforms and the cause of the reboot, rebooting may take anywhere from a few seconds to several minutes. If the implementation is down for a long time, the benefit of this protocol extension is reduced. For this reason critical systems should implement backup gateways as described in <a href="#backupgw">Section 6</a>.</p>
<p id="rfc.section.8.1.p.2">Implementing the "token maker" side of QCD makes sense for IKE implementation where protected connections originate from the peer, such as inter-domain VPNs and remote access gateways.  Implementing the "token taker" side of QCD makes sense for IKE implementations where protected connections originate, such as inter-domain VPNs and remote access clients.</p>
<p id="rfc.section.8.1.p.3">To clarify the this discussion: </p>

<ul>
<li>For remote-access clients it makes sense to implement the token taker role.</li>
<li>For remote-access gateways it makes sense to implement the token maker role.</li>
<li>For inter-domain VPN gateways it makes sense to implement both roles, because it can't be known in advance where the traffic originates.</li>
<li>It is perfectly valid to implement both roles in any case, for example when using a single library or a single gateway to perform several roles.</li>
</ul>
<p id="rfc.section.8.1.p.4">In order to limit the effects of DoS attacks, a token taker SHOULD limit the rate of QCD_TOKENs verified from a particular source. </p>
<p id="rfc.section.8.1.p.5">If excessive amounts of IKE requests protected with unknown IKE SPIs arrive at a token maker, the IKE module SHOULD revert to the behavior described in section 2.21 of <a href="#RFC5996">[RFC5996]</a> and either send an INVALID_IKE_SPI notification, or ignore it entirely.</p>
<p><a href="#sec_trans">Section 9.2</a> requires that token makers never send a QCD token in the clear for a valid IKE SA, and describes some configurations where this could occur.  Implementations that may be installed in such configurations SHOULD automatically detect this and disable this extension in unsafe configurations, and MUST allow the user to control whether the extension is enabled or disabled.</p>
<h1 id="rfc.section.8.2">
<a href="#rfc.section.8.2">8.2.</a> <a href="#operation_esp" id="operation_esp">Response to unknown child SPI</a>
</h1>
<p id="rfc.section.8.2.p.1">After a reboot, it is more likely that an implementation receives IPsec packets than IKE packets. In that case, the rebooted implementation will send an INVALID_SPI notification, triggering a liveness check.  The token will only be sent in a response to the liveness check, thus requiring an extra round-trip.</p>
<p id="rfc.section.8.2.p.2">To avoid this, an implementation that has access to enough non-volatile storage MAY store a mapping of child SPIs to owning IKE SPIs, or to generated tokens. If such a mapping is available and persistent across reboots, the rebooted implementation SHOULD respond to the IPsec packet with an INVALID_SPI notification, along with the appropriate QCD_Token notifications. A token taker SHOULD verify the QCD token that arrives with an INVALID_SPI notification the same as if it arrived with the IKE SPIs of the parent IKE SA.</p>
<p id="rfc.section.8.2.p.3">However, a persistent storage module might not be updated in a timely manner, and could be populated with tokens relating to IKE SPIs that have already been rekeyed. A token taker MUST NOT take an invalid QCD Token sent along with an INVALID_SPI notification as evidence that the peer is either malfunctioning or attacking, but it SHOULD limit the rate at which such notifications are processed.</p>
<h1 id="rfc.section.9">
<a href="#rfc.section.9">9.</a> <a href="#security" id="security">Security Considerations</a>
</h1>
<p id="rfc.section.9.p.1">The extension described in this document must not reduce the security of IKEv2 or IPsec.  Specifically, an eavesdropper must not learn any non-public information about the peers.</p>
<p id="rfc.section.9.p.2">The proposed mechanism should be secure against attacks by a passive MITM (eavesdropper).  Such an attacker must not be able to disrupt an existing IKE session, either by resetting the session or by introducing significant delays. This requirement is especially significant, because this document introduces a new way to reset an IKE SA.</p>
<p id="rfc.section.9.p.3">The mechanism need not be similarly secure against an active MITM, since this type of attacker is already able to disrupt IKE sessions.</p>
<h1 id="rfc.section.9.1">
<a href="#rfc.section.9.1">9.1.</a> <a href="#sec_handling" id="sec_handling">QCD Token Generation and Handling</a>
</h1>
<p id="rfc.section.9.1.p.1">Tokens MUST be hard to guess. This is critical, because if an attacker can guess the token associated with an IKE SA, they can tear down the IKE SA and associated tunnels at will. When the token is delivered in the IKE_AUTH exchange, it is encrypted. When it is sent again in an unprotected notification, it is not, but that is the last time this token is ever used.</p>
<p id="rfc.section.9.1.p.2">An aggregation of some tokens generated by one maker together with the related IKE SPIs MUST NOT give an attacker the ability to guess other tokens. Specifically, if one taker does not properly secure the QCD tokens and an attacker gains access to them, this attacker MUST NOT be able to guess other tokens generated by the same maker. This is the reason that the QCD_SECRET in <a href="#tg1">Section 5.1</a> needs to be sufficiently long.</p>
<p id="rfc.section.9.1.p.3">The token taker MUST store the token in a secure manner. No attacker should be able to gain access to a stored token.</p>
<p id="rfc.section.9.1.p.4">The QCD_SECRET MUST be protected from access by other parties. Anyone gaining access to this value will be able to delete all the IKE SAs for this token maker.</p>
<p id="rfc.section.9.1.p.5">The QCD token is sent by the rebooted peer in an unprotected message. A message like that is subject to modification, deletion and replay by an attacker. However, these attacks will not compromise the security of either side. Modification is meaningless because a modified token is simply an invalid token. Deletion will only cause the protocol not to work, resulting in a delay in tunnel re-establishment as described in <a href="#SCR">Section 2</a>. Replay is also meaningless, because the IKE SA has been deleted after the first transmission.</p>
<h1 id="rfc.section.9.2">
<a href="#rfc.section.9.2">9.2.</a> <a href="#sec_trans" id="sec_trans">QCD Token Transmission</a>
</h1>
<p id="rfc.section.9.2.p.1">A token maker MUST NOT send a valid QCD token in an unprotected message for an existing IKE SA.</p>
<p id="rfc.section.9.2.p.2">This requirement is obvious and easy in the case of a single gateway. However, some implementations use a load balancer to divide the load between several physical gateways.  It MUST NOT be possible even in such a configuration to trick one gateway into sending a valid QCD token for an IKE SA which is valid on another gateway.  This is true whether the attempt to trick the gateway uses the token taker's IP address or a different IP address.</p>
<p id="rfc.section.9.2.p.3">IPsec Failure Detection is not applicable to deployments where the QCD secret is shared by multiple gateways and the gateways cannot assess whether the token can be legitimately sent in the clear while another gateway may actually still own the SA's. Load balancer configurations typically fall in this category.  In order for a load balancing configuration of IPsec gateways to support this specification, all members MUST be able to tell whether a particular IKE SA is active anywhere in the cluster.  One way to do this is to synchronize a list of active IKE SPIs among all the cluster members.</p>
<p id="rfc.section.9.2.p.4">Because it includes the token taker's IP address in the token generation, the method in <a href="#tg2">Section 5.2</a> can (under certain conditions) prevent revealing the QCD token for an existing pair of IKE SPIs to an attacker who is using a different IP address, even in a load-sharing cluster without state synchronization. That method does not prevent revealing the QCD token to an active attacker who is spoofing the token taker's IP address. Such an attacker may attempt to direct messages to a cluster member other than the member responsible for the IKE SA in an attempt to trick that gateway into sending a QCD token for a valid IKE SA. That method should not be used unless the load balancer guarantees that IKE packets from the same source IP address always go to the same cluster member.</p>
<h1 id="rfc.section.9.3">
<a href="#rfc.section.9.3">9.3.</a> <a href="#sec_enum" id="sec_enum">QCD Token Enumeration</a>
</h1>
<p id="rfc.section.9.3.p.1">An attacker may try to attack QCD if the generation algorithm described in <a href="#tg1">Section 5.1</a> is used. The attacker will send several fake IKE requests to the gateway under attack, receiving and recording the QCD Tokens in the responses. This will allow the attacker to create a dictionary of IKE SPIs to QCD Tokens, which can later be used to tear down any IKE SA.</p>
<p id="rfc.section.9.3.p.2">Three factors mitigate this threat:</p>

<ul>
<li>The space of all possible IKE SPI pairs is huge: 2^128, so making such a dictionary is impractical. Even if we assume that one implementation always generates predictable IKE SPIs, the space is still at least 2^64 entries, so making the dictionary is extremely hard. To ensure this, token makers MUST generate unpredictable IKE SPIs by using a cryptographically strong pseudo-random number generator.</li>
<li>Throttling the amount of QCD_TOKEN notifications sent out, as discussed in <a href="#operation_who">Section 8.1</a>, especially when not soon after a crash will limit the attacker's ability to construct a dictionary.</li>
<li>The methods in <a href="#tg1">Section 5.1</a> and <a href="#tg2">Section 5.2</a> allow for a periodic change of the QCD_SECRET. Any such change invalidates the entire dictionary.</li>
</ul>
<h1 id="rfc.section.10">
<a href="#rfc.section.10">10.</a> <a href="#iana" id="iana">IANA Considerations</a>
</h1>
<p id="rfc.section.10.p.1">IANA is requested to assign a notify message type from the status types range (16406-40959) of the "IKEv2 Notify Message Types" registry with name "QUICK_CRASH_DETECTION".</p>
<h1 id="rfc.section.11">
<a href="#rfc.section.11">11.</a> <a href="#ack" id="ack">Acknowledgements</a>
</h1>
<p id="rfc.section.11.p.1">We would like to thank Hannes Tschofenig and Yaron Sheffer for their comments about Session Resumption.</p>
<p id="rfc.section.11.p.2">Others who have contributed valuable comments are, in alphabetical order, Lakshminath Dondeti, Paul Hoffman, Tero Kivinen, Scott C Moonen, Magnus Nystrom, and Keith Welter.</p>
<h1 id="rfc.section.12">
<a href="#rfc.section.12">12.</a> <a href="#history" id="history">Change Log</a>
</h1>
<p id="rfc.section.12.p.1">This section lists all changes in this document</p>
<p id="rfc.section.12.p.2">NOTE TO RFC EDITOR : Please remove this section in the final RFC</p>
<h1 id="rfc.section.12.1">
<a href="#rfc.section.12.1">12.1.</a> <a href="#history12" id="history12">Changes from draft-ietf-ipsecme-failure-detection-05</a>
</h1>
<p></p>

<ul><li>Some clarifications suggested by Magnus Nystrom.</li></ul>
<h1 id="rfc.section.12.2">
<a href="#rfc.section.12.2">12.2.</a> <a href="#history11" id="history11">Changes from draft-ietf-ipsecme-failure-detection-04</a>
</h1>
<p></p>

<ul><li>Some more rephrasing of section 9.2 based on suggestions by Tero Kivinen and Dave Wierbowski.</li></ul>
<h1 id="rfc.section.12.3">
<a href="#rfc.section.12.3">12.3.</a> <a href="#history10" id="history10">Changes from draft-ietf-ipsecme-failure-detection-03</a>
</h1>
<p></p>

<ul>
<li>Merged section 9.4 into section 9.2.</li>
<li>Multiple typos discovered by Scott Moonen, Keith Welter and Yaron.</li>
</ul>
<h1 id="rfc.section.12.4">
<a href="#rfc.section.12.4">12.4.</a> <a href="#history09" id="history09">Changes from draft-ietf-ipsecme-failure-detection-02</a>
</h1>
<p></p>

<ul>
<li>Moved section 7 to Appendix A. Also changed some wording.</li>
<li>Fixed some language in the "interaction with session resumption" section to say that although liveness check MUST be done, there are no time limits to how long an implementation takes before starting liveness check, or ending it.</li>
</ul>
<h1 id="rfc.section.12.5">
<a href="#rfc.section.12.5">12.5.</a> <a href="#history08" id="history08">Changes from draft-ietf-ipsecme-failure-detection-01</a>
</h1>
<p></p>

<ul>
<li>Fixed the language requiring random IKE SPIs.</li>
<li>Some better explanation of the reasons to choose the methods in <a href="#tg2">Section 5.2</a> and the method in <a href="#tg1">Section 5.1</a>, to close issue #193.</li>
<li>Added text to the beginning of <a href="#security">Section 9</a> to accomodate issue #194.  </li>
</ul>
<h1 id="rfc.section.12.6">
<a href="#rfc.section.12.6">12.6.</a> <a href="#history07" id="history07">Changes from draft-ietf-ipsecme-failure-detection-00</a>
</h1>
<p></p>

<ul>
<li>Nits pointed out by Scott and Yaron.</li>
<li>Pratima and Frederic are back on board.</li>
<li>Changed IKEv2bis draft reference to RFC 5996.</li>
<li>Resolved issues #189, #190, #191, and #192:<ul>
<li>Renamed section 4.5 and removed the requirement to send an acknowledgement for the unprotected message.</li>
<li>Moved the QCD token from the last to the first IKE_AUTH request.</li>
<li>Added a MUST to <a href="#sec_enum">Section 9.3</a> to require that IKE SPIs be randomly generated.</li>
<li>Changed the language in <a href="#operation_who">Section 8.1</a>, to not use RFC 2119 terminology.</li>
<li>Moved the section describing why one would want the method dependant on IP addresses (in <a href="#tg2">Section 5.2</a> from operational considerations to security considerations.</li>
</ul>
</li>
</ul>
<h1 id="rfc.section.12.7">
<a href="#rfc.section.12.7">12.7.</a> <a href="#history06" id="history06">Changes from draft-nir-ike-qcd-07</a>
</h1>
<p></p>

<ul>
<li>First WG version.</li>
<li>Addressed Scott C Moonen's concern about collisions of QCD tokens.</li>
<li>Updated references to point to IKEv2bis instead of RFC 4306 and 4718. Also converted draft reference for resumption to RFC 5723.</li>
<li>Added Dave Wiebrowski as author, and removed Pratima and Frederic.</li>
</ul>
<h1 id="rfc.section.12.8">
<a href="#rfc.section.12.8">12.8.</a> <a href="#history05" id="history05">Changes from draft-nir-ike-qcd-03 and -04</a>
</h1>
<p id="rfc.section.12.8.p.1">Mostly editorial changes and cleaning up.</p>
<h1 id="rfc.section.12.9">
<a href="#rfc.section.12.9">12.9.</a> <a href="#history04" id="history04">Changes from draft-nir-ike-qcd-02</a>
</h1>
<p></p>

<ul>
<li>Described QCD token enumeration, following a question by Lakshminath Dondeti.</li>
<li>Added the ability to replace the QCD token for an existing IKE SA.</li>
<li>Added tokens dependent on peer IP address and their interaction with MOBIKE.</li>
</ul>
<h1 id="rfc.section.12.10">
<a href="#rfc.section.12.10">12.10.</a> <a href="#history03" id="history03">Changes from draft-nir-ike-qcd-01</a>
</h1>
<p></p>

<ul>
<li>Removed stateless method.</li>
<li>Added discussion of rekeying and resumption.</li>
<li>Added discussion of non-synchronized load-balanced clusters of gateways in the security considerations.</li>
<li>Other wording fixes.</li>
</ul>
<h1 id="rfc.section.12.11">
<a href="#rfc.section.12.11">12.11.</a> <a href="#history02" id="history02">Changes from draft-nir-ike-qcd-00</a>
</h1>
<p></p>

<ul>
<li>Merged proposal with draft-detienne-ikev2-recovery</li>
<li>Changed the protocol so that the rebooted peer generates the token. This has the effect, that the need for persistent storage is eliminated.</li>
<li>Added discussion of birth certificates.</li>
</ul>
<h1 id="rfc.section.12.12">
<a href="#rfc.section.12.12">12.12.</a> <a href="#history01" id="history01">Changes from draft-nir-qcr-00</a>
</h1>
<p></p>

<ul>
<li>Changed name to reflect that this relates to IKE. Also changed from quick crash recovery to quick crash detection to avoid confusion with IFARE.</li>
<li>Added more operational considerations. </li>
<li>Added interaction with IFARE.</li>
<li>Added discussion of backup gateways.</li>
</ul>
<h1 id="rfc.references">
<a href="#rfc.references">13.</a> References</h1>
<h1 id="rfc.references.1">
<a href="#rfc.references.1">13.1.</a> Normative References</h1>
<table><tbody>
<tr>
<td class="reference"><b id="1">[1]</b></td>
<td class="top">
<a href="mailto:sob@harvard.edu" title="Harvard University">Bradner, S.</a>, "<a href="http://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>", BCP 14, RFC 2119, March 1997.</td>
</tr>
<tr>
<td class="reference"><b id="2">[2]</b></td>
<td class="top">
<a title="Microsoft">Kaufman, C</a>, <a title="VPN Consortium">Hoffman, P</a>, <a title="Check Point">Nir, Y</a> and <a title="Nokia">P Eronen</a>, "<a href="http://tools.ietf.org/html/rfc5996">Internet Key Exchange Protocol: IKEv2</a>", RFC 5996, September 2010.</td>
</tr>
<tr>
<td class="reference"><b id="3">[3]</b></td>
<td class="top">
<a title="Nokia">Eronen, P.</a>, "<a href="http://tools.ietf.org/html/rfc4555">IKEv2 Mobility and Multihoming Protocol (MOBIKE)</a>", RFC 4555, June 2006.</td>
</tr>
</tbody></table>
<h1 id="rfc.references.2">
<a href="#rfc.references.2">13.2.</a> Informative References</h1>
<table><tbody>
<tr>
<td class="reference"><b id="1">[1]</b></td>
<td class="top">
<a title="Check Point">Sheffer, Y.</a> and <a title="Nokia Siemens Networks">H. Tschofenig</a>, "<a href="http://tools.ietf.org/html/rfc5723">IKEv2 Session Resumption</a>", RFC 5723, January 2010.</td>
</tr>
<tr>
<td class="reference"><b id="2">[2]</b></td>
<td class="top">
<a title="Cisco">Detienne, F.</a>, <a title="Cisco">Sethi, P.</a> and <a title="Check Point">Y. Nir</a>, "<a href="http://tools.ietf.org/html/draft-detienne-ikev2-recovery">Safe IKE Recovery</a>", Internet-Draft draft-detienne-ikev2-recovery, January 2010.</td>
</tr>
<tr>
<td class="reference"><b id="3">[3]</b></td>
<td class="top">
<a title="Check Point">Nir, Y.</a>, "<a href="http://tools.ietf.org/html/draft-ietf-ipsecme-ipsec-ha">IPsec Cluster Problem Statement</a>", Internet-Draft draft-ietf-ipsecme-ipsec-ha, July 2010.</td>
</tr>
</tbody></table>
<h1 id="rfc.appendix.Appendix A">
<a href="#rfc.appendix.Appendix%20A">Appendix A.</a> <a href="#whynot" id="whynot">The Path Not Taken</a>
</h1>
<h1 id="rfc.appendix.Appendix A.1">
<a href="#rfc.appendix.Appendix%20A.1">Appendix A.1.</a> <a href="#newikesa" id="newikesa">Initiating a new IKE SA</a>
</h1>
<p id="rfc.section.Appendix A.1.p.1">Instead of sending a QCD token, we could have the rebooted implementation start an Initial exchange with the peer, including the INITIAL_CONTACT notification. This would have the same effect, instructing the peer to erase the old IKE SA, as well as establishing a new IKE SA with fewer rounds.</p>
<p id="rfc.section.Appendix A.1.p.2">The disadvantage here, is that in IKEv2 an authentication exchange MUST have a piggy-backed Child SA set up. Since our use case is such that the rebooted implementation does not have traffic flowing to the peer, there are no good selectors for such a Child SA.</p>
<p id="rfc.section.Appendix A.1.p.3">Additionally, when authentication is asymmetric, such as when EAP is used, it is not possible for the rebooted implementation to initiate IKE.</p>
<h1 id="rfc.appendix.Appendix A.2">
<a href="#rfc.appendix.Appendix%20A.2">Appendix A.2.</a> <a href="#sir" id="sir">SIR</a>
</h1>
<p id="rfc.section.Appendix A.2.p.1">Another proposal that was considered for this work item is the SIR extension, which is described in <a href="#recovery">[recovery]</a>. Under that proposal, the non-rebooted peer sends a non-protected query to the possibly rebooted peer, asking whether the IKE SA exists. The peer replies with either a positive or negative response, and the absence of a positive response, along with the existence of a negative response is taken as proof that the IKE SA has really been lost.</p>
<p id="rfc.section.Appendix A.2.p.2">The working group preferred the QCD proposal to this one.</p>
<h1 id="rfc.appendix.Appendix A.3">
<a href="#rfc.appendix.Appendix%20A.3">Appendix A.3.</a> <a href="#bcerts" id="bcerts">Birth Certificates</a>
</h1>
<p id="rfc.section.Appendix A.3.p.1">Birth Certificates is a method of crash detection that has never been formally defined. Bill Sommerfeld suggested this idea in a mail to the IPsec mailing list on August 7, 2000, in a thread discussing methods of crash detection:</p>
<div id="#rfc.figure.14"></div>
<pre>
    If we have the system sign a "birth certificate" when it 
    reboots (including a reboot time or boot sequence number), 
    we could include that with a "bad spi" ICMP error and in 
    the negotiation of the IKE SA.
          </pre>
<p id="rfc.section.Appendix A.3.p.2">We believe that this method would have some problems. First, it requires Alice to store the certificate, so as to be able to compare the public keys. That requires more storage than does a QCD token. Additionally, the public-key operations needed to verify the self-signed certificates are more expensive for Alice.</p>
<p id="rfc.section.Appendix A.3.p.3">We believe that a symmetric-key operation such as proposed here is more light-weight and simple than that implied by the Birth Certificate idea.</p>
<h1 id="rfc.appendix.Appendix A.4">
<a href="#rfc.appendix.Appendix%20A.4">Appendix A.4.</a> <a href="#shortwait" id="shortwait">Reducing Liveness Check Length</a>
</h1>
<p id="rfc.section.Appendix A.4.p.1">Some implementations require fewer retransmissions over a shorter period of time for cases of liveness check started because of an INVALID_SPI or INVALID_IKE_SPI notification.</p>
<p id="rfc.section.Appendix A.4.p.2">We believe that the default retransmission policy should represent a good balance between the need for a timely discovery of a dead peer, and a low probability of false detection.  We expect the policy to be set to take the shortest time such that this probability achieves a certain target.  Therefore, we believe that reducing the elapsed time and retransmission count may create an unacceptably high probability of false detection, and this can be triggered by a single INVALID_IKE_SPI notification.</p>
<p id="rfc.section.Appendix A.4.p.3">Additionally, even if the retransmission policy is reduced to, say, one minute, it is still a very noticeable delay from a human perspective, from the time that the gateway has come up (i.e., is able to respond with an INVALID_SPI or INVALID_IKE_SPI notification) and until the tunnels are active, or from the time the backup gateway has taken over until the tunnels are active.  The use of QCD tokens can reduce this delay.</p>
<h1 id="rfc.authors"><a href="#rfc.authors">Authors' Addresses</a></h1>
<div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Yoav Nir</span> editor
	  <span class="n hidden">
		<span class="family-name">Nir</span>
	  </span>
	</span>
	<span class="org vcardline">Check Point Software Technologies Ltd.</span>
	<span class="adr">
	  <span>5 Hasolelim st.</span>

	  <span class="vcardline">
		<span class="locality">Tel Aviv</span>,  
		<span class="region"></span>
		<span class="code">67897</span>
	  </span>
	  <span class="country-name vcardline">Israel</span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:ynir@checkpoint.com">ynir@checkpoint.com</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">David Wierbowski</span> 
	  <span class="n hidden">
		<span class="family-name">Wierbowski</span>
	  </span>
	</span>
	<span class="org vcardline">International Business Machines</span>
	<span class="adr">
	  <span>1701 North Street</span>

	  <span class="vcardline">
		<span class="locality">Endicott</span>,  
		<span class="region">New York</span> 
		<span class="code">13760</span>
	  </span>
	  <span class="country-name vcardline">United States</span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:wierbows@us.ibm.com">wierbows@us.ibm.com</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Frederic Detienne</span> 
	  <span class="n hidden">
		<span class="family-name">Detienne</span>
	  </span>
	</span>
	<span class="org vcardline">Cisco Systems, Inc.</span>
	<span class="adr">
	  <span>De Kleetlaan, 7</span>

	  <span class="vcardline">
		<span class="locality">Diegem</span>,  
		<span class="region"></span>
		<span class="code">B-1831</span>
	  </span>
	  <span class="country-name vcardline">Belgium</span>
	</span>
	<span class="vcardline">Phone: +32 2 704 5681</span>

<span class="vcardline">EMail: <a href="mailto:fd@cisco.com">fd@cisco.com</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Pratima Sethi</span> 
	  <span class="n hidden">
		<span class="family-name">Sethi</span>
	  </span>
	</span>
	<span class="org vcardline">Cisco Systems, Inc.</span>
	<span class="adr">
	  <span>O'Shaugnessy Road, 11</span>

	  <span class="vcardline">
		<span class="locality">Bangalore</span>,  
		<span class="region">Karnataka</span> 
		<span class="code">560027</span>
	  </span>
	  <span class="country-name vcardline">India</span>
	</span>
	<span class="vcardline">Phone: +91 80 4154 1654</span>

<span class="vcardline">EMail: <a href="mailto:psethi@cisco.com">psethi@cisco.com</a></span>

  </address>
</div>

</body>
</html>