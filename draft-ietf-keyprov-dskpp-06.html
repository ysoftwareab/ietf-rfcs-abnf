<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="en"><head><title>Dynamic Symmetric Key Provisioning Protocol
    (DSKPP)</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="description" content="Dynamic Symmetric Key Provisioning Protocol
    (DSKPP)">
<meta name="generator" content="xml2rfc v1.35 (http://xml.resource.org/)">
<meta name="viewport" content="width=600;" />
<style type='text/css'><!--
        body {
                font-family: verdana, charcoal, helvetica, arial, sans-serif;
                font-size: 85%;
		max-width: 40em; 
		color: #000; background-color: #FFF;
                margin: 2em;
        }
        h1, h2, h3, h4, h5, h6 {
                font-family: helvetica, monaco, "MS Sans Serif", arial, sans-serif;
                font-weight: bold; font-style: normal;
        }
        h1 { color: #900; background-color: transparent; text-align: right; }
        h3 { color: #333; background-color: transparent; }

        td.RFCbug {
                font-size: x-small; text-decoration: none;
                width: 30px; height: 30px; padding-top: 2px;
                text-align: justify; vertical-align: middle;
                background-color: #000;
        }
        td.RFCbug span.RFC {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: bold; color: #666;
        }
        td.RFCbug span.hotText {
                font-family: charcoal, monaco, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: normal; text-align: center; color: #FFF;
        }

        table.TOCbug { width: 30px; height: 15px; }
        td.TOCbug {
                text-align: center; width: 30px; height: 15px;
                color: #FFF; background-color: #900;
        }
        td.TOCbug a {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, sans-serif;
                font-weight: bold; font-size: x-small; text-decoration: none;
                color: #FFF; background-color: transparent;
        }

        td.header {
                font-family: arial, helvetica, sans-serif; font-size: x-small;
                vertical-align: top; width: 33%;
                color: #FFF; background-color: #666;
        }
        td.author { font-weight: bold; font-size: x-small; margin-left: 4em; }
        td.author-text { font-size: x-small; }

        /* info code from SantaKlauss at http://www.madaboutstyle.com/tooltip2.html */
        a.info {
                /* This is the key. */
                position: relative;
                z-index: 24;
                text-decoration: none;
        }
        a.info:hover {
                z-index: 25;
                color: #FFF; background-color: #900;
        }
        a.info span { display: none; }
        a.info:hover span.info {
                /* The span will display just on :hover state. */
                display: block;
                position: absolute;
                font-size: smaller;
                top: 2em; left: -5em; width: 15em;
                padding: 2px; border: 1px solid #333;
                color: #900; background-color: #EEE;
                text-align: left;
        }

        a { font-weight: bold; }
        a:link    { color: #900; background-color: transparent; }
        a:visited { color: #633; background-color: transparent; }
        a:active  { color: #633; background-color: transparent; }

        p { margin-left: 2em; margin-right: 2em; }
        p.copyright { font-size: x-small; }
        p.toc { font-size: 85%;
		max-width: 40em; 
		font-weight: bold; margin-left: 3em; }
        table.toc { margin: 0 0 0 3em; padding: 0; border: 0; vertical-align: text-top; }
        td.toc { font-size: 85%;
		max-width: 40em; 
		font-weight: bold; vertical-align: text-top; }

        ol.text { margin-left: 2em; margin-right: 2em; }
        ul.text { margin-left: 2em; margin-right: 2em; }
        li      { margin-left: 3em; }

        /* RFC-2629 <spanx>s and <artwork>s. */
        em     { font-style: italic; }
        strong { font-weight: bold; }
        dfn    { font-weight: bold; font-style: normal; }
        cite   { font-weight: normal; font-style: normal; }
        tt     { color: #036; }
        tt, pre, pre dfn, pre em, pre cite, pre span {
                font-family: "Courier New", Courier, monospace; font-size: small;
        }
        pre {
                text-align: left; padding: 4px;
                color: #000; background-color: #CCC;
        }
        pre dfn  { color: #900; }
        pre em   { color: #66F; background-color: #FFC; font-weight: normal; }
        pre .key { color: #33C; font-weight: bold; }
        pre .id  { color: #900; }
        pre .str { color: #000; background-color: #CFF; }
        pre .val { color: #066; }
        pre .rep { color: #909; }
        pre .oth { color: #000; background-color: #FCF; }
        pre .err { background-color: #FCC; }

        /* RFC-2629 <texttable>s. */
        table.all, table.full, table.headers, table.none {
                font-size: 85%;
		max-width: 40em; 
		text-align: center; border-width: 2px;
                vertical-align: top; border-collapse: collapse;
        }
        table.all, table.full { border-style: solid; border-color: black; }
        table.headers, table.none { border-style: none; }
        th {
                font-weight: bold; border-color: black;
                border-width: 2px 2px 3px 2px;
        }
        table.all th, table.full th { border-style: solid; }
        table.headers th { border-style: none none solid none; }
        table.none th { border-style: none; }
        table.all td {
                border-style: solid; border-color: #333;
                border-width: 1px 2px;
        }
        table.full td, table.headers td, table.none td { border-style: none; }

        hr { height: 1px; }
        hr.insert {
                width: 80%; border-style: none; border-width: 0;
                color: #CCC; background-color: #CCC;
        }
--></style>
</head>
<body>
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<table summary="layout" width="66%" border="0" cellpadding="0" cellspacing="0"><tr><td><table summary="layout" width="100%" border="0" cellpadding="2" cellspacing="1">
<tr><td class="header">KEYPROV Working Group</td><td class="header">A. Doherty</td></tr>
<tr><td class="header">Internet-Draft</td><td class="header">RSA, The Security Division of EMC</td></tr>
<tr><td class="header">Intended status: Standards Track</td><td class="header">M. Pei</td></tr>
<tr><td class="header">Expires: May 8, 2009</td><td class="header">Verisign, Inc.</td></tr>
<tr><td class="header">&nbsp;</td><td class="header">S. Machani</td></tr>
<tr><td class="header">&nbsp;</td><td class="header">Diversinet Corp.</td></tr>
<tr><td class="header">&nbsp;</td><td class="header">M. Nystrom</td></tr>
<tr><td class="header">&nbsp;</td><td class="header">RSA, The Security Division of EMC</td></tr>
<tr><td class="header">&nbsp;</td><td class="header">November 04, 2008</td></tr>
</table></td></tr></table>
<h1><br />Dynamic Symmetric Key Provisioning Protocol
    (DSKPP)<br />draft-ietf-keyprov-dskpp-06.txt</h1>

<h3>Status of this Memo</h3>
<p>
By submitting this Internet-Draft,
each author represents that any applicable patent or other IPR claims of which
he or she is aware have been or will be disclosed,
and any of which he or she becomes aware will be disclosed,
in accordance with Section&nbsp;6 of BCP&nbsp;79.</p>
<p>
Internet-Drafts are working documents of the Internet Engineering
Task Force (IETF), its areas, and its working groups.
Note that other groups may also distribute working documents as
Internet-Drafts.</p>
<p>
Internet-Drafts are draft documents valid for a maximum of six months
and may be updated, replaced, or obsoleted by other documents at any time.
It is inappropriate to use Internet-Drafts as reference material or to cite
them other than as &ldquo;work in progress.&rdquo;</p>
<p>
The list of current Internet-Drafts can be accessed at
<a href='http://www.ietf.org/ietf/1id-abstracts.txt'>http://www.ietf.org/ietf/1id-abstracts.txt</a>.</p>
<p>
The list of Internet-Draft Shadow Directories can be accessed at
<a href='http://www.ietf.org/shadow.html'>http://www.ietf.org/shadow.html</a>.</p>
<p>
This Internet-Draft will expire on May 8, 2009.</p>

<h3>Abstract</h3>

<p>DSKPP is a client-server protocol for initialization (and
      configuration) of symmetric keys to locally and remotely accessible
      cryptographic modules. The protocol can be run with or without
      private-key capabilities in the cryptographic modules, and with or
      without an established public-key infrastructure.
</p>
<p>Two variations of the protocol support multiple usage scenarios. With
      the four-pass variant, keys are mutually generated by the provisioning
      server and cryptographic module; provisioned keys are not transferred
      over-the-wire or over-the-air. The two-pass variant enables secure and
      efficient download and installation of pre-generated symmetric keys to a
      cryptographic module.
</p>
<p>This document builds on information contained in <a class='info' href='#RFC4758'>[RFC4758]<span> (</span><span class='info'>RSA, The Security Division of EMC, &ldquo;Cryptographic Token Key Initialization Protocol           (CT-KIP),&rdquo; November&nbsp;2006.</span><span>)</span></a>, adding specific enhancements in response to
      implementation experience and liaison requests.
</p><a name="toc"></a><br /><hr />
<h3>Table of Contents</h3>
<p class="toc">
<a href="#Section-Introduction">1.</a>&nbsp;
Introduction<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor1">1.1.</a>&nbsp;
Usage Scenarios<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#UC1">1.1.1.</a>&nbsp;
Single Key Request<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor2">1.1.2.</a>&nbsp;
Multiple Key Requests<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor3">1.1.3.</a>&nbsp;
User Authentication<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor4">1.1.4.</a>&nbsp;
Provisioning Time-Out Policy<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor5">1.1.5.</a>&nbsp;
Key Renewal<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor6">1.1.6.</a>&nbsp;
Pre-Loaded Key Replacement<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor7">1.1.7.</a>&nbsp;
Pre-Shared Manufacturing Key<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor8">1.1.8.</a>&nbsp;
End-to-End Protection of Key Material<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor9">1.2.</a>&nbsp;
Protocol Entities<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor10">1.3.</a>&nbsp;
Initiating DSKPP<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor11">1.4.</a>&nbsp;
Determining Which Protocol Variant to Use<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor12">1.4.1.</a>&nbsp;
Criteria for Using the Four-Pass Protocol<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor13">1.4.2.</a>&nbsp;
Criteria for Using the Two-Pass Protocol<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor14">1.5.</a>&nbsp;
Presentation Syntax<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor15">1.5.1.</a>&nbsp;
Versions<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor16">1.5.2.</a>&nbsp;
Namespaces<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor17">1.5.3.</a>&nbsp;
Identifiers<br />
<a href="#terms">2.</a>&nbsp;
Terminology<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor18">2.1.</a>&nbsp;
Key Words<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#Subsection-Definitions">2.2.</a>&nbsp;
Definitions<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor19">2.3.</a>&nbsp;
Notation<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor20">2.4.</a>&nbsp;
Abbreviations<br />
<a href="#Section-Protocol">3.</a>&nbsp;
DSKPP Protocol Details<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#Subsection-Protocol-Variations">3.1.</a>&nbsp;
Protocol Initiation<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#Subsection-Initiation-Server">3.1.1.</a>&nbsp;
Server Initiation<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#Subsection-Initiation-Client">3.1.2.</a>&nbsp;
Client Initiation<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor21">3.2.</a>&nbsp;
Protocol Variations<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#Subsection-Four-Pass">3.2.1.</a>&nbsp;
Four-Pass Protocol Interaction<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#Subsection-Two-Pass">3.2.2.</a>&nbsp;
Two-Pass Protocol Interaction<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#Subsection-Cyptographic-Primatives">3.3.</a>&nbsp;
Cryptographic Construction<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#DSKPP-PRF">3.3.1.</a>&nbsp;
The DSKPP One-Way Pseudorandom Function, DSKPP-PRF<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#Subsection-FourPassUsage">3.4.</a>&nbsp;
Four-Pass Protocol Usage<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#Subsection-4PassFlow">3.4.1.</a>&nbsp;
Message Flow<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor24">3.4.2.</a>&nbsp;
Generation of Symmetric Keys for Cryptographic Modules<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#Subsection-Enc">3.4.3.</a>&nbsp;
Encryption of Pseudorandom Nonces Sent from the DSKPP Client<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor25">3.4.4.</a>&nbsp;
MAC Calculations<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#Subsecton-TwoPass">3.5.</a>&nbsp;
Two-Pass Protocol Usage<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#Subsection-2PassFlow">3.5.1.</a>&nbsp;
Message Flow<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#Section-Profiles">3.5.2.</a>&nbsp;
Key Protection Profiles<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#Subsection-MAC">3.5.3.</a>&nbsp;
MAC Calculations<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#Subsection-DeviceID">3.6.</a>&nbsp;
Device Identification<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#Section-ClientAuthN">3.7.</a>&nbsp;
User Authentication<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#Section-AuthCode">3.7.1.</a>&nbsp;
Authentication Data<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor31">3.7.2.</a>&nbsp;
Authentication Code Format<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#Subsection-ADMAC">3.7.3.</a>&nbsp;
Authentication Data Calculation<br />
<a href="#anchor35">4.</a>&nbsp;
DSKPP Message Formats<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor36">4.1.</a>&nbsp;
General XML Schema Requirements<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#Section-Trigger">4.2.</a>&nbsp;
Components of the &lt;KeyProvTrigger&gt; Message<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor37">4.3.</a>&nbsp;
Components of the &lt;KeyProvClientHello&gt; Request<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor38">4.3.1.</a>&nbsp;
The DeviceIdentifierDataType Type<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor39">4.3.2.</a>&nbsp;
The ProtocolVariantsType Type<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor40">4.3.3.</a>&nbsp;
The KeyPackagesFormatType Type<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#Section-AuthNData">4.3.4.</a>&nbsp;
The AuthenticationDataType Type<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor41">4.4.</a>&nbsp;
Components of the &lt;KeyProvServerHello&gt; Response (Used Only in Four-Pass DSKPP)<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor42">4.5.</a>&nbsp;
Components of a &lt;KeyProvClientNonce&gt; Request (Used Only in Four-Pass DSKPP)<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor43">4.6.</a>&nbsp;
Components of a &lt;KeyProvServerFinished&gt; Response<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#Subsection-StatusCodes">4.7.</a>&nbsp;
The StatusCode Type<br />
<a href="#Section-ProtocolExts">5.</a>&nbsp;
Protocol Extensions<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor44">5.1.</a>&nbsp;
The ClientInfoType Type<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor45">5.2.</a>&nbsp;
The ServerInfoType Type<br />
<a href="#Section-Bindings">6.</a>&nbsp;
Protocol Bindings<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor46">6.1.</a>&nbsp;
General Requirements<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor47">6.2.</a>&nbsp;
HTTP/1.1 Binding for DSKPP<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor48">6.2.1.</a>&nbsp;
Introduction<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#Subsection-ContentType">6.2.2.</a>&nbsp;
Identification of DSKPP Messages<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor49">6.2.3.</a>&nbsp;
HTTP Headers<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor50">6.2.4.</a>&nbsp;
HTTP Operations<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor51">6.2.5.</a>&nbsp;
HTTP Status Codes<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor52">6.2.6.</a>&nbsp;
HTTP Authentication<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#Section-InitDSKPP">6.2.7.</a>&nbsp;
Initialization of DSKPP<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor53">6.2.8.</a>&nbsp;
Example Messages<br />
<a href="#Section-Schema">7.</a>&nbsp;
DSKPP Schema<br />
<a href="#anchor54">8.</a>&nbsp;
Conformance Requirements<br />
<a href="#Section-Security">9.</a>&nbsp;
Security Considerations<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor55">9.1.</a>&nbsp;
General<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor56">9.2.</a>&nbsp;
Active Attacks<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor57">9.2.1.</a>&nbsp;
Introduction<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#Subsection-Messages">9.2.2.</a>&nbsp;
Message Modifications<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor58">9.2.3.</a>&nbsp;
Message Deletion<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor59">9.2.4.</a>&nbsp;
Message Insertion<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor60">9.2.5.</a>&nbsp;
Message Replay<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor61">9.2.6.</a>&nbsp;
Message Reordering<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#Subsection-MITM">9.2.7.</a>&nbsp;
Man-in-the-Middle<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#Subsection-Passive">9.3.</a>&nbsp;
Passive Attacks<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor62">9.4.</a>&nbsp;
Cryptographic Attacks<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#Subsection-Interactions">9.5.</a>&nbsp;
Attacks on the Interaction between DSKPP and User Authentication<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor63">9.6.</a>&nbsp;
Miscellaneous Considerations<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor64">9.6.1.</a>&nbsp;
Client Contributions to K_TOKEN Entropy<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor65">9.6.2.</a>&nbsp;
Key Confirmation<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#Subsection-ServerAuth">9.6.3.</a>&nbsp;
Server Authentication<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#Subsection-UserAuthN">9.6.4.</a>&nbsp;
User Authentication<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor66">9.6.5.</a>&nbsp;
Key Protection in Two-Pass DSKPP<br />
<a href="#anchor67">10.</a>&nbsp;
Internationalization Considerations<br />
<a href="#anchor68">11.</a>&nbsp;
IANA Considerations<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor69">11.1.</a>&nbsp;
URN Sub-Namespace Registration<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor70">11.2.</a>&nbsp;
XML Schema Registration<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor71">11.3.</a>&nbsp;
MIME Media Type Registration<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor72">11.4.</a>&nbsp;
Status Code Registry<br />
<a href="#Section-IPR">12.</a>&nbsp;
Intellectual Property Considerations<br />
<a href="#anchor73">13.</a>&nbsp;
Contributors<br />
<a href="#Section-Acknowledgements">14.</a>&nbsp;
Acknowledgements<br />
<a href="#rfc.references1">15.</a>&nbsp;
References<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#rfc.references1">15.1.</a>&nbsp;
Normative references<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#rfc.references2">15.2.</a>&nbsp;
Informative references<br />
<a href="#Section-Examples">Appendix&nbsp;A.</a>&nbsp;
Examples<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor76">A.1.</a>&nbsp;
Trigger Message<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor77">A.2.</a>&nbsp;
Four-Pass Protocol<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor78">A.2.1.</a>&nbsp;
&lt;KeyProvClientHello&gt; Without a Preceding Trigger<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor79">A.2.2.</a>&nbsp;
&lt;KeyProvClientHello&gt; Assuming a Preceding Trigger<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor80">A.2.3.</a>&nbsp;
&lt;KeyProvServerHello&gt; Without a Preceding Trigger<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor81">A.2.4.</a>&nbsp;
&lt;KeyProvServerHello&gt; Assuming a Preceding Trigger<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor82">A.2.5.</a>&nbsp;
&lt;KeyProvClientNonce&gt; Using Default Encryption<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor83">A.2.6.</a>&nbsp;
&lt;KeyProvServerFinished&gt; Using Default Encryption<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor84">A.3.</a>&nbsp;
Two-Pass Protocol<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#Example-TwoPass-1">A.3.1.</a>&nbsp;
Example Using the Key Transport Profile<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor85">A.3.2.</a>&nbsp;
Example Using the Key Wrap Profile<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor86">A.3.3.</a>&nbsp;
Example Using the Passphrase-Based Key Wrap Profile<br />
<a href="#Section-Integration">Appendix&nbsp;B.</a>&nbsp;
Integration with PKCS #11<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor87">B.1.</a>&nbsp;
The 4-pass Variant<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor88">B.2.</a>&nbsp;
The 2-pass Variant<br />
<a href="#Section-PRFRealizations">Appendix&nbsp;C.</a>&nbsp;
Example of DSKPP-PRF Realizations<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor89">C.1.</a>&nbsp;
Introduction<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor90">C.2.</a>&nbsp;
DSKPP-PRF-AES<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor91">C.2.1.</a>&nbsp;
Identification<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor92">C.2.2.</a>&nbsp;
Definition<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor93">C.2.3.</a>&nbsp;
Example<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor94">C.3.</a>&nbsp;
DSKPP-PRF-SHA256<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor95">C.3.1.</a>&nbsp;
Identification<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor96">C.3.2.</a>&nbsp;
Definition<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor97">C.3.3.</a>&nbsp;
Example<br />
<a href="#rfc.authors">&#167;</a>&nbsp;
Authors' Addresses<br />
<a href="#rfc.copyright">&#167;</a>&nbsp;
Intellectual Property and Copyright Statements<br />
</p>
<br clear="all" />

<a name="Section-Introduction"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1"></a><h3>1.&nbsp;
Introduction</h3>

<p>While the range of problems for which symmetric key cryptography is
      the solution of choice is somewhat smaller than for public key
      cryptography, the problems it does solve, it solves exceedingly well. In
      particular, symmetric key algorithms are considerably faster than public
      key equivalents and allow for smaller key and signature sizes.
</p>
<p>Despite the clear advantages of employing symmetric keys as long term
      credentials or access keys in certain circumstances, it has generally
      been assumed that any protocol in which ease of key management is
      required will employ public key cryptography. In particular it is
      assumed that only private components of public keypairs will be employed
      as long term secrets and that symmetric cryptography will only play a
      supporting role.
</p>
<p>This document describes the Dynamic Symmetric Key Provisioning
      Protocol (DSKPP), which provides a mechanism for provisioning symmetric
      keys that provides the same degree of flexibility and convenience in use
      as equivalent infrastructures for public keys.
</p>
<p>DSKPP enables provisioning of symmetric keys to a symmetric key
      cryptographic module that provides data authentication and encryption
      services to software (or firmware) applications hosted on a wide range
      of hardware devices, such as personal computers, handheld mobile phones,
      one-time password tokens, USB flash drives, tape drives, etc.
</p>
<p>DSKPP provides an open and interoperable mechanism for initializing
      and configuring symmetric keys to cryptographic modules that are
      accessible over the Internet. The description is based on the
      information contained in <a class='info' href='#RFC4758'>[RFC4758]<span> (</span><span class='info'>RSA, The Security Division of EMC, &ldquo;Cryptographic Token Key Initialization Protocol           (CT-KIP),&rdquo; November&nbsp;2006.</span><span>)</span></a>, and contains
      specific enhancements, such as User Authentication and support for the
      <a class='info' href='#PSKC'>[PSKC]<span> (</span><span class='info'>, &ldquo;Portable Symmetric Key Container,&rdquo; 2008.</span><span>)</span></a> format for transmission of keying
      material.
</p>
<p>DSKPP has two principal protocol variations. The four pass protocol
      variation permits a symmetric key to be established that includes
      randomness contributed by both the client and the server. The two pass
      protocol requires only one round trip instead of two and permits a
      server specified key to be established.
</p>
<a name="anchor1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1.1"></a><h3>1.1.&nbsp;
Usage Scenarios</h3>

<p>DSKPP is expected to be used to provision symmetric keys to
        cryptographic modules in a number of different scenarios, each with
        its own special requirements.
</p>
<a name="UC1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1.1.1"></a><h3>1.1.1.&nbsp;
Single Key Request</h3>

<p>The usual scenario is that a cryptographic module makes a request
          for a symmetric key from a provisioning server that is located on
          the local network or somewhere on the Internet. Depending upon the
          deployment scenario, the provisioning server may generate a new key
          on-the-fly or use a pre-generated key, e.g., one provided by a
          legacy back-end issuance server. The provisioning server assigns a
          unique key ID to the symmetric key and provisions it to the
          cryptographic module.
</p>
<a name="anchor2"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1.1.2"></a><h3>1.1.2.&nbsp;
Multiple Key Requests</h3>

<p>A cryptographic module makes multiple requests for symmetric keys
          from the same provisioning server. The symmetric keys need not be of
          the same type, i.e., the keys may be used with different symmetric
          key cryptographic algorithms, including one-time password
          authentication algorithms, and the AES encryption algorithm.
</p>
<a name="anchor3"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1.1.3"></a><h3>1.1.3.&nbsp;
User Authentication</h3>

<p>In some deployment scenarios, a key issuer may rely on a third
          party provisioning service. In this case, the issuer directs
          provisioning requests from the cryptographic module to the
          provisioning service. As such, it is the responsibility of the
          issuer to authenticate the user through some out-of-band means
          before granting him rights to acquire keys. Once the issuer has
          granted those rights, the issuer provides an authentication code to
          the user and makes it available to the provisioning service, so that
          the user can prove that he is authorized to acquire keys.
</p>
<a name="anchor4"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1.1.4"></a><h3>1.1.4.&nbsp;
Provisioning Time-Out Policy</h3>

<p>An issuer may provide a time-limited authentication code to a
          user during registration, which the user will input into the
          cryptographic module to authenticate themselves with the
          provisioning server. The server will allow a key to be provisioned
          to the cryptographic module hosted by the user's device when user
          authentication is required only if the user inputs a valid
          authentication code within the fixed time period established by the
          issuer.
</p>
<a name="anchor5"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1.1.5"></a><h3>1.1.5.&nbsp;
Key Renewal</h3>

<p>A cryptographic module requests renewal of the symmetric key
          material attached to a key ID, as opposed to keeping the key value
          constant and refreshing the metadata. Such a need may occur in the
          case when a user wants to upgrade her device that houses the
          cryptographic module or when a key has expired. When a user uses the
          same cryptographic module to, for example, perform strong
          authentication at multiple Web login sites, keeping the same key ID
          removes the need for the user to register a new key ID at each
          site.
</p>
<a name="anchor6"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1.1.6"></a><h3>1.1.6.&nbsp;
Pre-Loaded Key Replacement</h3>

<p>This scenario represents a special case of symmetric key renewal
          in which a local administrator can authenticate the user
          procedurally before initiating the provisioning process. It also
          allows for a device issuer to pre-load a key onto a cryptographic
          module with a restriction that the key is replaced with a new key
          prior to use of the cryptographic module. Another variation of this
          scenario is the organization who recycles devices. In this case, a
          key issuer would provision a new symmetric key to a cryptographic
          module hosted on a device that was previously owned by another
          user.
</p>
<p>Note that this usage scenario is essentially the same as the
          previous scenario wherein the same key ID is used for renewal.
</p>
<a name="anchor7"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1.1.7"></a><h3>1.1.7.&nbsp;
Pre-Shared Manufacturing Key</h3>

<p>A cryptographic module is loaded onto a smart card after the card
          is issued to a user. The symmetric key for the cryptographic module
          will then be provisioned using a secure channel mechanism present in
          many smart card platforms. This allows a direct secure channel to be
          established between the smart card chip and the provisioning server.
          For example, the card commands (i.e., Application Protocol Data
          Units, or APDUs) are encrypted with a pre-issued card manufacturer's
          key and sent directly to the smart card chip, allowing secure
          post-issuance in-the-field provisioning. This secure flow can pass
          Transport Layer Security (TLS) and other transport security
          boundaries.
</p>
<p>Note that two pre-conditions for this usage scenario are for the
          protocol to be tunneled and the provisioning server to know the
          correct pre-established manufacturer's key.
</p>
<a name="anchor8"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1.1.8"></a><h3>1.1.8.&nbsp;
End-to-End Protection of Key Material</h3>

<p>In this scenario, transport layer security does not provide
          end-to-end protection of keying material transported from the
          provisioning server to the cryptographic module. For example, TLS
          may terminate at an application hosted on a PC rather than at the
          cryptographic module (i.e., the endpoint) located on a data storage
          device. Mutually authenticated key agreement provides end-to-end
          protection, which TLS cannot provide.
</p>
<a name="anchor9"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1.2"></a><h3>1.2.&nbsp;
Protocol Entities</h3>

<p>A DSKPP provisioning transaction has three entities:
</p>
<p></p>
<blockquote class="text"><dl>
<dt>Server: </dt>
<dd>The DSKPP provisioning server.<br />

</dd>
<dt>Cryptographic Module:</dt>
<dd>The cryptographic module to
            which the symmetric keys are to be provisioned.<br />

</dd>
<dt>Client:</dt>
<dd>The DSKPP client which manages communication
            between the cryptographic module and the provisioning server.
</dd>
</dl></blockquote>

<p>While it is highly desirable for the entire communication between
        the DSKPP client and server to be protected by means of a transport
        providing confidentiality and integrity protection such as HTTP over
        Transport Layer Security (TLS), such protection is not sufficient to
        protect the exchange of the symmetric key data between the server and
        the cryptographic module and the DSKPP protocol is designed to permit
        implementations that satisfy this requirement.
</p>
<p>The server only communicates to the client. As far as the server is
        concerned, the client and cryptographic module may be considered to be
        a single entity.
</p>
<p>From a client-side security perspective, however, the client and
        the cryptographic module are separate logical entities and may in some
        implementations be separate physical entities as well.
</p>
<p>A high-level object model that describes the client-side entities
        and how they relate to each other is shown in <a class='info' href='#Objects'>Figure&nbsp;1<span> (</span><span class='info'>Object Model</span><span>)</span></a>. Conceptually, each entity is represented by
        the definitions found in <a class='info' href='#Subsection-Definitions'>Section&nbsp;2.2<span> (</span><span class='info'>Definitions</span><span>)</span></a>.
</p><br /><hr class="insert" />
<a name="Objects"></a>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>-----------          -------------
| User    |          | Device    |
|---------|*  owns  *|-----------|
| UserID  |---------&gt;| DeviceID  |
| ...     |          | ...       |
-----------          -------------
                          | 1
                          |
                          | contains
                          |
                          | *
                          V
              --------------------------
              |Cryptographic Module    |
              |------------------------|
              |Crypto Module ID        |
              |Security Attribute List |
              |...                     |
              --------------------------
                         | 1
                         |
                         | contains
                         |
                         | *
                         V
                -----------------------
                |Key Package          |
                |---------------------|
                |Key ID               |
                |Key Type             |
                |...                  |
                -----------------------
</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;1: Object Model&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>It is assumed that a device will host an application layered above
        the cryptographic module, and this application will manage
        communication between the DSKPP client and cryptographic module. The
        manner in which the communicating application will transfer DSKPP
        protocol elements to and from the cryptographic module is transparent
        to the DSKPP server. One method for this transfer is described in
        <a class='info' href='#CT-KIP-P11'>[CT&#8209;KIP&#8209;P11]<span> (</span><span class='info'>RSA Laboratories, &ldquo;PKCS #11 Mechanisms for the Cryptographic Token Key           Initialization Protocol,&rdquo; December&nbsp;2005.</span><span>)</span></a>.
</p>
<a name="anchor10"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1.3"></a><h3>1.3.&nbsp;
Initiating DSKPP</h3>

<p>To initiate DSKPP:<br />
<br />
</p>
<blockquote class="text"><dl>
<dt>1.</dt>
<dd>A server may first send a DSKPP trigger message to a client
            application (e.g., in response to a user browsing to a Web site
            that requires a symmetric key for authentication), although this
            step is optional.
</dd>
<dt>2.</dt>
<dd>A client application calls on the DSKPP client to send a
            symmetric key request to a DSKPP server, thus beginning a DSKPP
            protocol run.
</dd>
</dl></blockquote>

<p>One of the following actions may be used to contact a DSKPP
        server:<br />
<br />
</p>
<blockquote class="text"><dl>
<dt>1.</dt>
<dd>A user may indicate how the DSKPP client is to contact a
            certain DSKPP server during a browsing session.
</dd>
<dt>2.</dt>
<dd>A DSKPP client may be pre-configured to contact a certain DSKPP
            server.
</dd>
<dt>3.</dt>
<dd>A user may be informed out-of-band about the location of the
            DSKPP server.<br />

</dd>
</dl></blockquote><p>Once the location of the DSKPP server is known, the DSKPP
        client and the DSKPP server engage in a 4-pass or 2-pass protocol.
</p>
<a name="anchor11"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1.4"></a><h3>1.4.&nbsp;
Determining Which Protocol Variant to Use</h3>

<p>The four-pass and two-pass protocols are appropriate in different
        deployment scenarios, as described in the sub-sections below. The
        biggest differentiator between the two is that the two-pass protocol
        supports transport of an existing key to a cryptographic module, while
        the four-pass involves key generation on-the-fly via key agreement. In
        either case, both protocol variants support algorithm agility through
        negotiation of encryption mechanisms and key types at the beginning of
        each protocol run.
</p>
<a name="anchor12"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1.4.1"></a><h3>1.4.1.&nbsp;
Criteria for Using the Four-Pass Protocol</h3>

<p>The four-pass protocol is needed under one or more of the
          following conditions:<br />
<br />
</p>
<ul class="text">
<li>Policy requires that both parties engaged in the protocol
              jointly contribute entropy to the key. Enforcing this policy
              mitigates the risk of exposing a key during the provisioning
              process as the key is generated through mutual agreement without
              being transferred over-the-air or over-the-wire. It also
              mitigates risk of exposure after the key is provisioned, as the
              key will be not be vulnerable to a single point of attack in the
              system.
</li>
<li>A cryptographic module does not have private-key
              capabilities.
</li>
<li>The cryptographic module is hosted by a device that was
              neither pre-issued with a manufacturer's key or other form of
              pre-shared key (as might be the case with a smart card or SIM
              card) nor has a keypad that can be used for entering a
              passphrase (such as present on a mobile phone).
</li>
</ul>

<a name="anchor13"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1.4.2"></a><h3>1.4.2.&nbsp;
Criteria for Using the Two-Pass Protocol</h3>

<p>The two-pass protocol is needed under one or more of the
          following conditions:<br />
<br />
</p>
<ul class="text">
<li>Pre-existing (i.e., legacy) keys must be provisioned via
              transport to the cryptographic module.
</li>
<li>The cryptographic module is hosted on a device that was
              pre-issued with a manufacturer's key (such as may exist on a
              smart card), or other form of pre-shared key (such as may exist
              on a SIM-card), and is capable of performing private-key
              operations.
</li>
<li>The cryptographic module is hosted by a device that has a
              built-in keypad with which a user may enter a passphrase, useful
              for deriving a key wrapping key for distribution of keying
              material.
</li>
</ul>

<a name="anchor14"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1.5"></a><h3>1.5.&nbsp;
Presentation Syntax</h3>

<p>This documents presents DSKPP message formats and data elements
        using XML syntax. The main goal in using this syntax is to document
        DSKPP. Application of the syntax beyond this goal is OPTIONAL (i.e.,
        an implementation that does not use XML and instead uses ASN.1 could
        claim compliance with this specification).
</p>
<a name="anchor15"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1.5.1"></a><h3>1.5.1.&nbsp;
Versions</h3>

<p>There is a provision made in the syntax for an explicit version
          number. Only version "1.0" is currently specified.
</p>
<a name="anchor16"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1.5.2"></a><h3>1.5.2.&nbsp;
Namespaces</h3>

<p>The XML namespace <a class='info' href='#XMLNS'>[XMLNS]<span> (</span><span class='info'>W3C, &ldquo;Namespaces in XML,&rdquo; January&nbsp;1999.</span><span>)</span></a> URN that MUST be
          used by implementations of this syntax is:
</p>
<p>xmlns:dskpp="urn:ietf:params:xml:ns:keyprov:dskpp:1.0"
</p>
<p>References to qualified elements in the DSKPP schema defined
          herein use the prefix "dskpp".
</p>
<p>This document relies on qualified elements already defined in the
          Portable Symmetric Key Container <a class='info' href='#PSKC'>[PSKC]<span> (</span><span class='info'>, &ldquo;Portable Symmetric Key Container,&rdquo; 2008.</span><span>)</span></a>
          namespace, which is represented by the prefix "pskc" and declared
          as:
</p>
<p>xmlns:pskc="urn:ietf:params:xml:ns:keyprov:pskc:1.0"
</p>
<p>Finally, the DSKPP syntax presented in this document relies on
          algorithm identifiers defined in the XML Signature <a class='info' href='#XMLDSIG'>[XMLDSIG]<span> (</span><span class='info'>W3C, &ldquo;XML Signature Syntax and Processing,&rdquo; February&nbsp;2002.</span><span>)</span></a> namespace:
</p>
<p>xmlns:ds="http://www.w3.org/2000/09/xmldsig#"
</p>
<p>References to algorithm identifiers in the XML Signature
          namespace are represented by the prefix "ds".
</p>
<a name="anchor17"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1.5.3"></a><h3>1.5.3.&nbsp;
Identifiers</h3>

<p>This document uses Uniform Resource Identifiers <a class='info' href='#RFC2396'>[RFC2396]<span> (</span><span class='info'>Berners-Lee, T., Fielding, R., and L. Masinter, &ldquo;Uniform Resource Identifiers (URI): Generic Syntax,&rdquo; August&nbsp;1998.</span><span>)</span></a> to identify resources, algorithms, and
          semantics.
</p>
<a name="terms"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2"></a><h3>2.&nbsp;
Terminology</h3>

<a name="anchor18"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2.1"></a><h3>2.1.&nbsp;
Key Words</h3>

<p>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
        "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
        document are to be interpreted as described in <a class='info' href='#RFC2119'>[RFC2119]<span> (</span><span class='info'>, &ldquo;Key words for use in RFCs to Indicate Requirement           Levels,&rdquo; March&nbsp;1997.</span><span>)</span></a>.
</p>
<a name="Subsection-Definitions"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2.2"></a><h3>2.2.&nbsp;
Definitions</h3>

<p>The definitions provided below are defined as used in this
        document. The same terms may be defined differently in other
        documents.
</p>
<p></p>
<blockquote class="text"><dl>
<dt>Authentication Code (AC):</dt>
<dd>Client Authentication Code
            comprised of a string of numeric characters known to the device
            and the server and containing an identifier and a password<br />

</dd>
<dt>Authentication Data (AD):</dt>
<dd>Client Authentication Data
            that may be derived from the Authentication Code (AC)<br />

</dd>
<dt>Cryptographic Module:</dt>
<dd>A component of an application,
            which enables symmetric key cryptographic functionality<br />

</dd>
<dt>CryptoModule ID:</dt>
<dd>A unique identifier for an instance
            of the cryptographic module<br />

</dd>
<dt>Device:</dt>
<dd>A physical piece of hardware, or a software
            framework, that hosts symmetric key cryptographic modules<br />

</dd>
<dt>Device ID (DeviceID):</dt>
<dd>A unique identifier for the
            device<br />

</dd>
<dt>DSKPP Client:</dt>
<dd>Manages communication between the
            symmetric key cryptographic module and the DSKPP server<br />

</dd>
<dt>DSKPP Server:</dt>
<dd>The symmetric key provisioning server
            that participates in the DSKPP protocol run<br />

</dd>
<dt>DSKPP Server ID (ServerID):</dt>
<dd>The unique identifier of
            a DSKPP server<br />

</dd>
<dt>Issuer:</dt>
<dd>See "Key Issuer"<br />

</dd>
<dt>Key Issuer:</dt>
<dd>An organization that issues symmetric
            keys to end-users<br />

</dd>
<dt>Key Package (KP):</dt>
<dd>An object that encapsulates a
            symmetric key and its configuration data<br />

</dd>
<dt>Key Package Header (KPH):</dt>
<dd>Information about the Key
            Package, useful for two-pass DSKPP, e.g., the passing the ServerID
            and the Key Protection Method<br />

</dd>
<dt>Key ID (KeyID):</dt>
<dd>A unique identifier for the
            symmetric key<br />

</dd>
<dt>Key Protection Method (KPM):</dt>
<dd>The key transport
            method used during two-pass DSKPP<br />

</dd>
<dt>Key Protection Method List (KPML):</dt>
<dd>The list of key
            protection methods supported by a cryptographic module<br />

</dd>
<dt>Key Provisioning Server:</dt>
<dd>A lifecycle management
            system that provides a key issuer with the ability to provision
            keys to cryptographic modules hosted on end-users' devices<br />

</dd>
<dt>Key Transport:</dt>
<dd>A key establishment procedure whereby
            the DSKPP server selects and encrypts the keying material and then
            sends the material to the DSKPP client <a class='info' href='#NIST-SP800-57'>[NIST&#8209;SP800&#8209;57]<span> (</span><span class='info'>National Institute of Standards and             Technology, &ldquo;Recommendation for Key Management - Part I: General           (Revised),&rdquo; March&nbsp;2007.</span><span>)</span></a><br />

</dd>
<dt>Key Transport Key:</dt>
<dd>The private key that resides on
            the cryptographic module. This key is paired with the DSKPP
            client's public key, which the DSKPP server uses to encrypt keying
            material during key transport <a class='info' href='#NIST-SP800-57'>[NIST&#8209;SP800&#8209;57]<span> (</span><span class='info'>National Institute of Standards and             Technology, &ldquo;Recommendation for Key Management - Part I: General           (Revised),&rdquo; March&nbsp;2007.</span><span>)</span></a><br />

</dd>
<dt>Key Type:</dt>
<dd>The type of symmetric key cryptographic
            methods for which the key will be used (e.g., OATH HOTP or RSA
            SecurID authentication, AES encryption, etc.)<br />

</dd>
<dt>Key Wrapping:</dt>
<dd>A method of encrypting keys for key
            transport <a class='info' href='#NIST-SP800-57'>[NIST&#8209;SP800&#8209;57]<span> (</span><span class='info'>National Institute of Standards and             Technology, &ldquo;Recommendation for Key Management - Part I: General           (Revised),&rdquo; March&nbsp;2007.</span><span>)</span></a><br />

</dd>
<dt>Key Wrapping Key:</dt>
<dd>A symmetric key encrypting key
            used for key wrapping <a class='info' href='#NIST-SP800-57'>[NIST&#8209;SP800&#8209;57]<span> (</span><span class='info'>National Institute of Standards and             Technology, &ldquo;Recommendation for Key Management - Part I: General           (Revised),&rdquo; March&nbsp;2007.</span><span>)</span></a><br />

</dd>
<dt>Keying Material:</dt>
<dd>The data necessary (e.g., keys and
            key configuration data) necessary to establish and maintain
            cryptographic keying relationships <a class='info' href='#NIST-SP800-57'>[NIST&#8209;SP800&#8209;57]<span> (</span><span class='info'>National Institute of Standards and             Technology, &ldquo;Recommendation for Key Management - Part I: General           (Revised),&rdquo; March&nbsp;2007.</span><span>)</span></a><br />

</dd>
<dt>Manufacturer's Key</dt>
<dd>A unique master key pre-issued to
            a hardware device, e.g., a smart card, during the manufacturing
            process. If present, this key may be used by a cryptographic
            module to derive secret keys<br />

</dd>
<dt>Provisioning Service:</dt>
<dd>See "Key Provisioning
            Server"<br />

</dd>
<dt>Security Attribute List (SAL):</dt>
<dd>A payload that
            contains the DSKPP version, DSKPP variation (four- or two-pass),
            key package formats, key types, and cryptographic algorithms that
            the cryptographic module is capable of supporting<br />

</dd>
<dt>Security Context (SC):</dt>
<dd>A payload that contains the
            DSKPP version, DSKPP variation (four- or two-pass), key package
            format, key type, and cryptographic algorithms relevant to the
            current protocol run<br />

</dd>
<dt>User:</dt>
<dd>The person or client to whom devices are
            issued<br />

</dd>
<dt>User ID:</dt>
<dd>A unique identifier for the user or
            client<br />

</dd>
</dl></blockquote>

<a name="anchor19"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2.3"></a><h3>2.3.&nbsp;
Notation</h3>

<p></p>
<blockquote class="text"><dl>
<dt>||</dt>
<dd>String concatenation<br />

</dd>
<dt>[x]</dt>
<dd>Optional element x<br />

</dd>
<dt>A ^ B</dt>
<dd>Exclusive-OR operation on strings A and B
            (where A and B are of equal length)<br />

</dd>
<dt>&lt;XMLElement&gt;</dt>
<dd>A typographical convention used
            in the body of the text<br />

</dd>
<dt>DSKPP-PRF(k,s,dsLen)</dt>
<dd>A keyed pseudo-random function
            (see <a class='info' href='#DSKPP-PRF'>Section&nbsp;3.3.1<span> (</span><span class='info'>The DSKPP One-Way Pseudorandom Function, DSKPP-PRF</span><span>)</span></a>)<br />

</dd>
<dt>E(k,m)</dt>
<dd>Encryption of m with the key k<br />

</dd>
<dt>K</dt>
<dd>Key used to encrypt R_C (either K_SERVER or
            K_SHARED), or in MAC or DSKPP_PRF computations<br />

</dd>
<dt>K_AC</dt>
<dd>Secret key that is derived from the
            Authentication Code and used for user authentication
            purposes<br />

</dd>
<dt>K_MAC</dt>
<dd>Secret key derived during a DSKPP exchange for
            use with key confirmation<br />

</dd>
<dt>K_MAC'</dt>
<dd>A second secret key used for server
            authentication<br />

</dd>
<dt>K_PROV</dt>
<dd>A provisioning master key from which two keys
            are derived: K_TOKEN and K_MAC<br />

</dd>
<dt>K_SERVER</dt>
<dd>Public key of the DSKPP server; used for
            encrypting R_C in the four-pass protocol variant<br />

</dd>
<dt>K_SHARED</dt>
<dd>Secret key that is pre-shared between the
            DSKPP client and the DSKPP server; used for encrypting R_C in the
            four-pass protocol variant<br />

</dd>
<dt>K_TOKEN</dt>
<dd>Secret key that is established in a
            cryptographic module using DSKPP<br />

</dd>
<dt>R</dt>
<dd>Pseudorandom value chosen by the DSKPP client and
            used for MAC computations<br />

</dd>
<dt>R_C</dt>
<dd>Pseudorandom value chosen by the DSKPP client
            and used as input to the generation of K_TOKEN<br />

</dd>
<dt>R_S</dt>
<dd>Pseudorandom value chosen by the DSKPP server
            and used as input to the generation of K_TOKEN<br />

</dd>
<dt>R_TRIGGER</dt>
<dd>Pseudorandom value chosen by the DSKPP
            server and used as input in a trigger message.<br />

</dd>
<dt>URL_S</dt>
<dd>DSKPP server address, as a URL<br />

</dd>
</dl></blockquote>

<a name="anchor20"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2.4"></a><h3>2.4.&nbsp;
Abbreviations</h3>

<p></p>
<blockquote class="text"><dl>
<dt>AC</dt>
<dd>Authentication Code
</dd>
<dt>AD</dt>
<dd>Authentication Data
</dd>
<dt>DSKPP</dt>
<dd>Dynamic Symmetric Key Provisioning
            Protocol
</dd>
<dt>HTTP</dt>
<dd>Hypertext Transfer Protocol
</dd>
<dt>KP</dt>
<dd>Key Package
</dd>
<dt>KPH</dt>
<dd>Key Package Header
</dd>
<dt>KPM</dt>
<dd>Key Protection Method
</dd>
<dt>KPML</dt>
<dd>Key Protection Method List
</dd>
<dt>MAC</dt>
<dd>Message Authentication Code
</dd>
<dt>PC</dt>
<dd>Personal Computer
</dd>
<dt>PDU</dt>
<dd>Protocol Data Unit
</dd>
<dt>PKCS</dt>
<dd>Public-Key Cryptography Standards
</dd>
<dt>PRF</dt>
<dd>Pseudo-Random Function
</dd>
<dt>PSKC</dt>
<dd>Portable Symmetric Key Container
</dd>
<dt>SAL</dt>
<dd>Security Attribute List (see <a class='info' href='#Subsection-Definitions'>Section&nbsp;2.2<span> (</span><span class='info'>Definitions</span><span>)</span></a>)
</dd>
<dt>SC</dt>
<dd>Security Context (see <a class='info' href='#Subsection-Definitions'>Section&nbsp;2.2<span> (</span><span class='info'>Definitions</span><span>)</span></a>)
</dd>
<dt>TLS</dt>
<dd>Transport Layer Security
</dd>
<dt>URL</dt>
<dd>Uniform Resource Locator
</dd>
<dt>USB</dt>
<dd>Universal Serial Bus
</dd>
<dt>XML</dt>
<dd>eXtensible Markup Language
</dd>
</dl></blockquote>

<a name="Section-Protocol"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3"></a><h3>3.&nbsp;
DSKPP Protocol Details</h3>

<p>DSKPP enables symmetric key provisioning between a DSKPP server and
      DSKPP client.
</p>
<a name="Subsection-Protocol-Variations"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.1"></a><h3>3.1.&nbsp;
Protocol Initiation</h3>

<p>The DSKPP protocol has two- and four-pass variations, either of
        which may be initiated by either the client or the server making four
        possible successful protocol interactions. In every case the first
        message sent from the client to the server is
        &lt;KeyProvClientHello&gt; and the last message is
        &lt;KeyProvServerFinished&gt; and is sent from the server to the
        client.
</p>
<a name="Subsection-Initiation-Server"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.1.1"></a><h3>3.1.1.&nbsp;
Server Initiation</h3>

<p>The DSKPP protocol may be initiated by the server by means of a
          &lt;KeyProvTrigger&gt; message to which the client responds with a
          &lt;KeyProvClientHello&gt; message as shown in <a class='info' href='#Figure-Overview-server'>Figure&nbsp;2<span> (</span><span class='info'>Server Initiated DSKPP (start)</span><span>)</span></a>. The trigger message always
          contains a nonce to allow the server to couple the trigger with a
          later &lt;KeyProvClientHello&gt; request.
</p><br /><hr class="insert" />
<a name="Figure-Overview-server"></a>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>+---------------+                            +---------------+
|               |                            |               |
|  DSKPP Client |                            |  DSKPP Server |
|               |                            |               |
+---------------+                            +---------------+
        |                                            |
        |   &lt;--------- &lt;KeyProvTrigger&gt; ---------    |
        |                                            |
        |   ------- &lt;KeyProvClientHello&gt; -------&gt;    |
       ...                                          ...
</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;2: Server Initiated DSKPP (start)&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<a name="Subsection-Initiation-Client"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.1.2"></a><h3>3.1.2.&nbsp;
Client Initiation</h3>

<p>The DSKPP protocol may be initiated by the client by means of the
          &lt;KeyProvClientHello&gt; message <a class='info' href='#Figure-Overview-client'>Figure&nbsp;3<span> (</span><span class='info'>Client Initiated DSKPP (start)</span><span>)</span></a> message.
</p><br /><hr class="insert" />
<a name="Figure-Overview-client"></a>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>+---------------+                            +---------------+
|               |                            |               |
|  DSKPP Client |                            |  DSKPP Server |
|               |                            |               |
+---------------+                            +---------------+
        |                                            |
        |   ------- &lt;KeyProvClientHello&gt; -------&gt;    |
       ...                                          ...
</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;3: Client Initiated DSKPP (start)&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<a name="anchor21"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.2"></a><h3>3.2.&nbsp;
Protocol Variations</h3>

<p>Once contact has been initiated, the client and server MAY engage
        in either a two-pass or four-pass protocol depending on the protocol
        options specified in the &lt;KeyProvClientHello&gt; message and the
        server configuration.
</p>
<a name="Subsection-Four-Pass"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.2.1"></a><h3>3.2.1.&nbsp;
Four-Pass Protocol Interaction</h3>

<p>In the four-pass version of the protocol the server responds to
          the &lt;KeyProvClientHello&gt; message with
          &lt;KeyProvServerHello&gt;. The client then responds with
          &lt;KeyProvClientNonce&gt; and the server with
          &lt;KeyProvServerFinished&gt; as shown in <a class='info' href='#Figure-Overview-four'>Figure&nbsp;4<span> (</span><span class='info'>Four Pass DSKPP protocol (with OPTIONAL preceding trigger)</span><span>)</span></a>.
</p><br /><hr class="insert" />
<a name="Figure-Overview-four"></a>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>+---------------+                            +---------------+
|               |                            |               |
|  DSKPP Client |                            |  DSKPP Server |
|               |                            |               |
+---------------+                            +---------------+
        |                                            |
        | [ &lt;--------- &lt;KeyProvTrigger&gt; --------- ]  |
        |                                            |
        |   ------- &lt;KeyProvClientHello&gt; -------&gt;    |
        |                                            |
        |   &lt;------ &lt;KeyProvServerHello&gt; --------    |
        |                                            |
        |   ------- &lt;KeyProvClientNonce&gt; -------&gt;    |
        |                                            |
        |   &lt;---- &lt;KeyProvServerFinished&gt; -------    |
        |                                            |
</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;4: Four Pass DSKPP protocol (with OPTIONAL preceding trigger)&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p></p>
<blockquote class="text"><dl>
<dt>[&lt;KeyProvTrigger&gt; Message]:</dt>
<dd>The
              &lt;KeyProvTrigger&gt; message is used to initiate a request
              from the server. The trigger message always contains a nonce to
              allow the server to couple the trigger with a later
              &lt;KeyProvClientHello&gt; request.<br />

</dd>
<dt>&lt;KeyProvClientHello&gt;:</dt>
<dd>The
              &lt;KeyProvClientHello&gt; request is sent by a DSKPP client to
              initiate contact with the DSKPP server, indicating which
              protocol versions and variations (four-pass or two-pass), key
              types, encryption and MAC algorithms that it supports. In
              addition, the request may include client authentication data
              that the DSKPP server uses to verify proof-of-possession of the
              device. <br />

</dd>
<dt>Server Processing of &lt;KeyProvClientHello&gt;:</dt>
<dd>Upon
              receiving a &lt;KeyProvClientHello&gt; request, the DSKPP server
              uses the &lt;KeyProvServerHello&gt; response to specify which
              protocol version and variation, key type, encryption algorithm,
              and MAC algorithm that will be used by the DSKPP server and
              DSKPP client during the protocol run. The decision of which
              variation, key type, and cryptographic algorithms to pick is
              policy- and implementation-dependent and therefore outside the
              scope of this document. <br />

</dd>
<dt>&lt;KeyProvServerHello&gt;:</dt>
<dd>The
              &lt;KeyProvServerHello&gt; response is only used in the four
              pass protocol, it includes the DSKPP server's random nonce, R_S.
              The response also consists of information about either a shared
              secret key, or its own public key, that the DSKPP client uses
              when sending its protected random nonce, R_C, in the
              &lt;KeyProvClientNonce&gt; request (see below).<br />
Optionally, the DSKPP server may provide a MAC
              that the DSKPP client may use for server authentication.<br />
<br />

</dd>
<dt>Client Processing of &lt;KeyProvServerHello&gt;:</dt>
<dd>On
              receipt of &lt;KeyProvServerHello&gt;, the client encrypts the
              random client nonce R_c under the (provided) server key
              K.<br />

</dd>
<dt>&lt;KeyProvClientNonce&gt;:</dt>
<dd>The
              &lt;KeyProvClientNonce&gt; request is only used in the four pass
              protocol, it is used to exchange protected data, i.e., the
              protected random nonce R_C. In addition, the request may include
              user authentication data that the DSKPP server uses to verify
              proof-of-possession of the device.<br />

</dd>
<dt>&lt;KeyProvServerFinished&gt;:</dt>
<dd>The
              &lt;KeyProvServerFinished&gt; response is a confirmation message
              that includes a key package that holds configuration data, but
              no keying material.<br />
Optionally, the
              DSKPP server may provide a MAC that the DSKPP client may use for
              server authentication.
</dd>
</dl></blockquote>

<a name="Subsection-Two-Pass"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.2.2"></a><h3>3.2.2.&nbsp;
Two-Pass Protocol Interaction</h3>

<p>In the two-pass version of the protocol the server responds to
          the &lt;KeyProvClientHello&gt; message with a
          &lt;KeyProvServerFinished&gt; message <a class='info' href='#Figure-Overview-two'>Figure&nbsp;5<span> (</span><span class='info'>Two Pass DSKPP protocol (with OPTIONAL preceding trigger)</span><span>)</span></a>
</p><br /><hr class="insert" />
<a name="Figure-Overview-two"></a>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>+---------------+                            +---------------+
|               |                            |               |
|  DSKPP Client |                            |  DSKPP Server |
|               |                            |               |
+---------------+                            +---------------+
        |                                            |
        | [ &lt;--------- &lt;KeyProvTrigger&gt; --------- ]  |
        |                                            |
        |   ------- &lt;KeyProvClientHello&gt; -------&gt;    |
        |                                            |
        |   &lt;---- &lt;KeyProvServerFinished&gt; -------    |
        |                                            |
</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;5: Two Pass DSKPP protocol (with OPTIONAL preceding trigger)&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p></p>
<blockquote class="text"><dl>
<dt>[&lt;KeyProvTrigger&gt; Message]:</dt>
<dd>The
              &lt;KeyProvTrigger&gt; message is used to initiate a request
              from the server. The trigger message always contains a nonce to
              allow the server to couple the trigger with a later
              &lt;KeyProvClientHello&gt; request.<br />

</dd>
<dt>&lt;KeyProvClientHello&gt;:</dt>
<dd>The
              &lt;KeyProvClientHello&gt; request is sent by a DSKPP client to
              initiate contact with the DSKPP server, indicating which
              protocol versions and variations (four-pass or two-pass), key
              types, encryption and MAC algorithms that it supports. In
              addition, the request may include client authentication data
              that the DSKPP server uses to verify proof-of-possession of the
              device. <br />

</dd>
<dt>&lt;KeyProvServerFinished&gt;:</dt>
<dd>The
              &lt;KeyProvServerFinished&gt; response is a confirmation message
              that includes a key package that holds configuration data and
              contain protected keying material.<br />
Optionally, the DSKPP server may provide a MAC
              that the DSKPP client may use for server authentication.
</dd>
</dl></blockquote>

<a name="Subsection-Cyptographic-Primatives"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.3"></a><h3>3.3.&nbsp;
Cryptographic Construction</h3>

<a name="DSKPP-PRF"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.3.1"></a><h3>3.3.1.&nbsp;
The DSKPP One-Way Pseudorandom Function, DSKPP-PRF</h3>

<a name="anchor22"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.3.1.1"></a><h3>3.3.1.1.&nbsp;
Introduction</h3>

<p>Regardless of the protocol variation employed, there is a
            requirement for a cryptographic primitive that provides a
            deterministic transformation of a secret key k and a varying
            length octet string s to a bitstring of specified length
            dsLen.
</p>
<p>This primitive must meet the same requirements as for a keyed
            hash function: It MUST take an arbitrary length input, and
            generate an output that is one-way and collision-free (for a
            definition of these terms, see, e.g., <a class='info' href='#FAQ'>[FAQ]<span> (</span><span class='info'>RSA Laboratories, &ldquo;Frequently Asked Questions About Today's Cryptography,&rdquo; 2000.</span><span>)</span></a>).
            Further, its output MUST be unpredictable even if other outputs
            for the same key are known.
</p>
<p>From the point of view of this specification, DSKPP-PRF is a
            "black-box" function that, given the inputs, generates a
            pseudorandom value and MAY be realized by any appropriate and
            competent cryptographic technique. <a class='info' href='#Section-PRFRealizations'>Appendix&nbsp;C<span> (</span><span class='info'>Example of DSKPP-PRF Realizations</span><span>)</span></a> contains two example
            realizations of DSKPP-PRF.
</p>
<a name="anchor23"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.3.1.2"></a><h3>3.3.1.2.&nbsp;
Declaration</h3>

<p>DSKPP-PRF (k, s, dsLen)
</p>
<p>Input:
</p>
<p></p>
<blockquote class="text"><dl>
<dt>k</dt>
<dd>secret key in octet string format
</dd>
<dt>s</dt>
<dd>octet string of varying length consisting of
                variable data distinguishing the particular string being
                derived
</dd>
<dt>dsLen</dt>
<dd>desired length of the output
</dd>
</dl></blockquote>

<p>Output:
</p>
<p></p>
<blockquote class="text"><dl>
<dt>DS</dt>
<dd>pseudorandom string, dsLen-octets long
</dd>
</dl></blockquote>

<p>For the purposes of this document, the secret key k MUST be at
            least 16 octets long.
</p>
<a name="Subsection-FourPassUsage"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.4"></a><h3>3.4.&nbsp;
Four-Pass Protocol Usage</h3>

<p>This section describes the message flow and methods that comprise
        the four-pass protocol variant.
</p>
<a name="Subsection-4PassFlow"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.4.1"></a><h3>3.4.1.&nbsp;
Message Flow</h3>

<p>The four-pass protocol flow consists of two message
          exchanges:
</p>
<p></p>
<blockquote class="text"><dl>
<dt>1:</dt>
<dd>Pass 1 = &lt;KeyProvClientHello&gt;, Pass 2 =
              &lt;KeyProvServerHello&gt;
</dd>
<dt>2:</dt>
<dd>Pass 3 = &lt;KeyProvClientNonce&gt;, Pass 4 =
              &lt;KeyProvServerFinished&gt;
</dd>
</dl></blockquote>

<p>The first pair of messages negotiate cryptographic algorithms and
          exchange nonces. The second pair of messages establishes a symmetric
          key using mutually authenticated key agreement.
</p>
<p>The DSKPP server MUST ensure that a generated key is associated
          with the correct cryptographic module, and if applicable, the
          correct user. To do this, the DSKPP server MAY couple an initial
          user authentication to the DSKPP execution using one of the
          mechanisms described in <a class='info' href='#Section-ClientAuthN'>Section&nbsp;3.7<span> (</span><span class='info'>User Authentication</span><span>)</span></a>.
</p>
<p>The purpose and content of each message are described below,
          including the optional &lt;KeyProvTrigger&gt;.
</p>
<p>
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>        DSKPP Client                         DSKPP Server
        ------------                         ------------
                             [&lt;---] R_TRIGGER, [DeviceID],
                                         [KeyID], [URL_S]
</pre></div>
<p>The DSKPP server optionally sends a &lt;KeyProvTrigger&gt;
          message to the DSKPP client. The trigger message MUST contain a
          nonce, R_TRIGGER, to allow the server to couple the trigger with a
          later &lt;KeyProvClientHello&gt; request. &lt;KeyProvTrigger&gt; MAY
          include a DeviceID to allow the client to select the device with
          which it will communicate (for more information about device
          identification, refer to <a class='info' href='#Subsection-DeviceID'>Section&nbsp;3.6<span> (</span><span class='info'>Device Identification</span><span>)</span></a>). In the case of key renewal,
          &lt;KeyProvTrigger&gt; MAY include the identifier for the key,
          KeyID, that is being replaced. Finally, the trigger MAY contain a
          URL for the DSKPP client to use when contacting the DSKPP
          server.
</p>
<p>
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>        DSKPP Client                         DSKPP Server
        ------------                         ------------
        SAL, [R_TRIGGER],
        [DeviceID], [KeyID]     ---&gt;
</pre></div>
<p>The DSKPP client sends a &lt;KeyProvClientHello&gt; message to
          the DSKPP server. This message MUST contain a Security Attribute
          List (SAL), identifying which DSKPP versions, protocol variations
          (in this case "four-pass"), key package formats, key types,
          encryption and MAC algorithms that the client supports. In addition,
          if a trigger message preceded &lt;KeyProvClientHello&gt;, then it
          passes the parameters received in &lt;KeyProvTrigger&gt; back to the
          DSKPP Server. In particular, it MUST include R_TRIGGER so that the
          DSKPP server can associate the client with the trigger message, and
          SHOULD include DeviceID and KeyID.
</p>
<p>
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>        DSKPP Client                         DSKPP Server
        ------------                         ------------
                                &lt;---  SC, R_S, [K], [MAC]
</pre></div>
<p>The DSKPP server responds to the DSKPP client with a
          &lt;KeyProvServerHello&gt; message, whose Status attribute is set to
          a return code for &lt;KeyProvClientHello&gt;. If Status is not
          "Continue", only the Status and Version attributes will be present,
          and the DSKPP client MUST abort the protocol. If Status is set to
          "Continue", then the message MUST include a Security Context (SC).
          The DSKPP client will use the SC to select the DSKPP version and
          variation (e.g., four-pass), type of key to generate, and
          cryptographic algorithms that it will use for the remainder of the
          protocol run. &lt;KeyProvServerHello&gt; MUST also include the
          server's random nonce, R_S, whose length may depend on the selected
          key type. In addition, the &lt;KeyProvServerHello&gt; message MAY
          provide K, which represents its own public key (K_SERVER) or
          information about a shared secret key (K_SHARED) to use for
          encrypting the cryptographic module's random nonce (see description
          of &lt;KeyProvClientNonce&gt; below). Optionally,
          &lt;KeyProvServerHello&gt; MAY include a MAC that the DSKPP client
          can use for server authentication in the case of key renewal (<a class='info' href='#Subsection-4passAuthZ'>Section&nbsp;3.4.4.1<span> (</span><span class='info'>Server Authentication in the Case of Key Renewal</span><span>)</span></a> describes how to calculate
          the MAC).
</p>
<p>
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>        DSKPP Client                         DSKPP Server
        ------------                         ------------
        E(K,R_C), [AD]          ---&gt;
</pre></div>
<p>Based on the Security Context (SC) provided in the
          &lt;KeyProvServerHello&gt; message, the cryptographic module
          generates a random nonce, R_C. The length of the nonce R_C will
          depend on the selected key type. The cryptographic module encrypts
          R_C using the selected encryption algorithm and with a key, K, that
          is either the DSKPP server's public key, K_SERVER, or a shared
          secret key, K_SHARED, as indicated by the DSKPP server.
</p>
<p>Note: If K is equivalent to K_SERVER, then the cryptographic
          module SHOULD verify the server's certificate before using it to
          encrypt R_C in accordance with <a class='info' href='#RFC5280'>[RFC5280]<span> (</span><span class='info'>Cooper, D., Santesson, S., Farrell, S., Boeyen, S., Housley, R., and W. Polk, &ldquo;Internet X.509 Public Key Infrastructure Certificate and           Certificate Revocation List (CRL) Profile,&rdquo; May&nbsp;2008.</span><span>)</span></a>.
</p>
<p>Note: If successful execution of the protocol will result in the
          replacement of an existing key with a newly generated one, the DSKPP
          client MUST verify the MAC provided in the
          &lt;KeyProvServerHello&gt; message. The DSKPP client MUST terminate
          the DSKPP session if the MAC does not verify, and MUST delete any
          nonces, keys, and/or secrets associated with the failed run.
</p>
<p>The DSKPP client MUST send the encrypted random nonce to the
          DSKPP server in a &lt;KeyProvClientNonce&gt; message, and MAY
          include client Authentication Data (AD), such as a MAC derived from
          an authentication code and R_C (refer to <a class='info' href='#Section-AuthCode'>Section&nbsp;3.7.1<span> (</span><span class='info'>Authentication Data</span><span>)</span></a>). Finally, the cryptographic
          module calculates and stores a symmetric key, K_TOKEN, of the key
          type specified in the SC received in &lt;KeyProvServerHello&gt;
          (refer to <a class='info' href='#Subsection-KeyGen'>Section&nbsp;3.4.2.2<span> (</span><span class='info'>Computing the Symmetric Key</span><span>)</span></a>.&lt;KeyProvServerFinished&gt; for
          a description of how K_TOKEN is generated).
</p>
<p>
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>        DSKPP Client                         DSKPP Server
        ------------                         ------------
                                 &lt;---             KP, MAC
</pre></div>
<p>If Authentication Data (AD) was received in the
          &lt;KeyProvClientNonce&gt; message, then the DSKPP server MUST
          authenticate the user in accordance with <a class='info' href='#Section-AuthCode'>Section&nbsp;3.7.1<span> (</span><span class='info'>Authentication Data</span><span>)</span></a>. If authentication fails, then
          DSKPP server MUST abort. Otherwise, the DSKPP server decrypts R_C,
          calculates K_TOKEN from the combination of the two random nonces R_S
          and R_C, the encryption key K, and possibly some other data (refer
          to <a class='info' href='#Subsection-KeyGen'>Section&nbsp;3.4.2.2<span> (</span><span class='info'>Computing the Symmetric Key</span><span>)</span></a> for a description of how
          K_TOKEN is generated). The server then associates K_TOKEN with the
          cryptographic module in a server-side data store. The intent is that
          the data store later on will be used by some service that needs to
          verify or decrypt data produced by the cryptographic module and the
          key.
</p>
<p>Once the association has been made, the DSKPP server sends a
          confirmation message to the DSKPP client called
          &lt;KeyProvServerFinished&gt;. The confirmation message MUST include
          a Key Package (KP) that holds an identifier for the generated key
          (but not the key itself) and additional configuration information,
          e.g., the identity of the DSKPP server. The default symmetric key
          package format is based on the Portable Symmetric Key Container
          (PSKC) defined in <a class='info' href='#PSKC'>[PSKC]<span> (</span><span class='info'>, &ldquo;Portable Symmetric Key Container,&rdquo; 2008.</span><span>)</span></a>. Alternative formats
          MAY include <a class='info' href='#SKPC-ASN.1'>[SKPC&#8209;ASN.1]<span> (</span><span class='info'>, &ldquo;Symmetric Key Package Content Type,&rdquo; 2007.</span><span>)</span></a>, PKCS#12 <a class='info' href='#PKCS-12'>[PKCS&#8209;12]<span> (</span><span class='info'>, &ldquo;Personal Information Exchange Syntax Standard,&rdquo; 2005.</span><span>)</span></a>, or PKCS#5 XML <a class='info' href='#PKCS-5-XML'>[PKCS&#8209;5&#8209;XML]<span> (</span><span class='info'>RSA Laboratories, &ldquo;XML Schema for PKCS #5 Version 2.0,&rdquo; October&nbsp;2006.</span><span>)</span></a> format. In addition to a Key Package,
          &lt;KeyProvServerFinished&gt; MUST also include a MAC that the DSKPP
          client will use to authenticate the message before committing
          K_TOKEN
</p>
<p>After receiving a &lt;KeyProvServerFinished&gt; message with
          Status = "Success", the DSKPP client MUST verify the MAC. The DSKPP
          client MUST terminate the DSKPP session if the MAC does not verify,
          and MUST, in this case, also delete any nonces, keys, and/or secrets
          associated with the failed run of the protocol. If
          &lt;KeyProvServerFinished&gt; has Status = "Success" and the MAC was
          verified, then the DSKPP client MUST associate the provided key
          package with the generated key K_TOKEN, and store this data
          permanently. After this operation, it MUST NOT be possible to
          overwrite the key unless knowledge of an authorizing key is proven
          through a MAC on a later &lt;KeyProvServerHello&gt; (and
          &lt;KeyProvServerFinished&gt;) message.
</p>
<a name="anchor24"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.4.2"></a><h3>3.4.2.&nbsp;
Generation of Symmetric Keys for Cryptographic Modules</h3>

<p>With 4-pass DSKPP, the symmetric key that is the target of
          provisioning, is generated on-the-fly without being transferred
          between the DSKPP client and DSKPP server. A sample data flow
          depicting how this works followed by computational information are
          provided in the subsections below.
</p>
<a name="Subsection-FourPassDataFlow"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.4.2.1"></a><h3>3.4.2.1.&nbsp;
Data Flow</h3>

<p>A sample data flow showing key generation during the 4-pass
            protocol is shown in <a class='info' href='#keygen'>Figure&nbsp;6<span> (</span><span class='info'>Principal data flow for DSKPP key generation             - using public server key</span><span>)</span></a>.
</p><br /><hr class="insert" />
<a name="keygen"></a>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>+----------------------+    +-------+     +----------------------+
|    +------------+    |    |       |     |                      |
|    | Server key |    |    |       |     |                      |
| +&lt;-|  Public    |------&gt;-------------&gt;-------------+---------+ |
| |  |  Private   |    |    |       |     |          |         | |
| |  +------------+    |    |       |     |          |         | |
| |        |           |    |       |     |          |         | |
| V        V           |    |       |     |          V         V |
| |   +---------+      |    |       |     |        +---------+ | |
| |   | Decrypt |&lt;-------&lt;-------------&lt;-----------| Encrypt | | |
| |   +---------+      |    |       |     |        +---------+ | |
| |      |  +--------+ |    |       |     |            ^       | |
| |      |  | Server | |    |       |     |            |       | |
| |      |  | Random |---&gt;-------------&gt;------+  +----------+  | |
| |      |  +--------+ |    |       |     |   |  | Client   |  | |
| |      |      |      |    |       |     |   |  | Random   |  | |
| |      |      |      |    |       |     |   |  +----------+  | |
| |      |      |      |    |       |     |   |        |       | |
| |      V      V      |    |       |     |   V        V       | |
| |   +------------+   |    |       |     | +------------+     | |
| +--&gt;|  DSKPP PRF |   |    |       |     | |  DSKPP PRF |&lt;----+ |
|     +------------+   |    |       |     | +------------+       |
|           |          |    |       |     |       |              |
|           V          |    |       |     |       V              |
|       +-------+      |    |       |     |   +-------+          |
|       |  Key  |      |    |       |     |   |  Key  |          |
|       +-------+      |    |       |     |   +-------+          |
|       +-------+      |    |       |     |   +-------+          |
|       |Key Id |--------&gt;-------------&gt;------|Key Id |          |
|       +-------+      |    |       |     |   +-------+          |
+----------------------+    +-------+     +----------------------+
      DSKPP Server         DSKPP Client         DSKPP Client
                            (PC Host)      (cryptographic module)
</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;6: Principal data flow for DSKPP key generation             - using public server key&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>Note: Conceptually, although R_C is one pseudorandom string, it
            may be viewed as consisting of two components, R_C1 and R_C2,
            where R_C1 is generated during the protocol run, and R_C2 can be
            pre-generated and loaded on the cryptographic module before the
            device is issued to the user. In that case, the latter string,
            R_C2, SHOULD be unique for each cryptographic module.
</p>
<p>The inclusion of the two random nonces R_S and R_C in the key
            generation provides assurance to both sides (the cryptographic
            module and the DSKPP server) that they have contributed to the
            key's randomness and that the key is unique. The inclusion of the
            encryption key K ensures that no man-in-the-middle may be present,
            or else the cryptographic module will end up with a key different
            from the one stored by the legitimate DSKPP server.
</p>
<p>Note: A man-in-the-middle (in the form of corrupt client
            software or a mistakenly contacted server) may present his own
            public key to the cryptographic module. This will enable the
            attacker to learn the client's version of K_TOKEN. However, the
            attacker is not able to persuade the legitimate server to derive
            the same value for K_TOKEN, since K_TOKEN is a function of the
            public key involved, and the attacker's public key must be
            different than the correct server's (or else the attacker would
            not be able to decrypt the information received from the client).
            Therefore, once the attacker is no longer "in the middle," the
            client and server will detect that they are "out of sync" when
            they try to use their keys. In the case of encrypting R_C with
            K_SERVER, it is therefore important to verify that K_SERVER really
            is the legitimate server's key. One way to do this is to
            independently validate a newly generated K_TOKEN against some
            validation service at the server (e.g. using a connection
            independent from the one used for the key generation).
</p>
<a name="Subsection-KeyGen"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.4.2.2"></a><h3>3.4.2.2.&nbsp;
Computing the Symmetric Key</h3>

<p>In DSKPP, K_TOKEN and K_MAC are derived from provisioning key,
            K_PROV, which is generated using the DSKPP-PRF function as follows
            (refer to <a class='info' href='#DSKPP-PRF'>Section&nbsp;3.3.1<span> (</span><span class='info'>The DSKPP One-Way Pseudorandom Function, DSKPP-PRF</span><span>)</span></a>):
</p>
<p>K_PROV = DSKPP-PRF(k,s,dsLen), where<br />
<br />
</p>
<blockquote class="text">
<p>k = R_C (i.e., the secret random value chosen by the DSKPP
                client)<br />
<br />

</p>
<p>s = "Key generation" || K || R_S (where K is the key used
                to encrypt R_C and R_S is the random value chosen by the DSKPP
                server)<br />
<br />

</p>
<p>dsLen = (desired length of K_PROV whose first half
                constitutes K_MAC and second half constitutes K_TOKEN)
</p>
</blockquote>

<p>Then K_TOKEN and K_MAC derived from K_PROV, where<br />
<br />
</p>
<blockquote class="text">
<p>K_PROV = K_MAC || K_TOKEN
</p>
</blockquote>

<p>When computing K_PROV, the derived keys, K_MAC and K_TOKEN, MAY
            be subject to an algorithm-dependent transform before being
            adopted as a key of the selected type. One example of this is the
            need for parity in DES keys.
</p>
<a name="Subsection-Enc"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.4.3"></a><h3>3.4.3.&nbsp;
Encryption of Pseudorandom Nonces Sent from the DSKPP Client</h3>

<p>DSKPP client random nonce(s) are either encrypted with the public
          key provided by the DSKPP server or by a shared secret key. For
          example, in the case of a public RSA key, an RSA encryption scheme
          from PKCS #1 <a class='info' href='#PKCS-1'>[PKCS&#8209;1]<span> (</span><span class='info'>RSA Laboratories, &ldquo;RSA Cryptography Standard,&rdquo; June&nbsp;2002.</span><span>)</span></a> MAY be used.
</p>
<p>In the case of a shared secret key, to avoid dependence on other
          algorithms, the DSKPP client MAY use the DSKPP-PRF function
          described herein with the shared secret key K_SHARED as input
          parameter k (in this case, K_SHARED SHOULD be used solely for this
          purpose), the concatenation of the (ASCII) string "Encryption" and
          the server's nonce R_S as input parameter s, and dsLen set to the
          length of R_C:
</p>
<p>dsLen = len(R_C)
</p>
<p>DS = DSKPP-PRF(K_SHARED, "Encryption" || R_S, dsLen)
</p>
<p>This will produce a pseudorandom string DS of length equal to
          R_C. Encryption of R_C MAY then be achieved by XOR-ing DS with
          R_C:
</p>
<p>E(DS, R_C) = DS ^ R_C
</p>
<p>The DSKPP server will then perform the reverse operation to
          extract R_C from E(DS, R_C).
</p>
<a name="anchor25"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.4.4"></a><h3>3.4.4.&nbsp;
MAC Calculations</h3>

<a name="Subsection-4passAuthZ"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.4.4.1"></a><h3>3.4.4.1.&nbsp;
Server Authentication in the Case of Key Renewal</h3>

<p>A MAC MUST be present in the &lt;KeyProvServerHello&gt; message
            if the DSKPP run will result in the replacement of an existing key
            with a new one, as proof that the DSKPP server is authenticated to
            perform the action. When the MAC value is used for server
            authentication, the value MAY be computed by using the DSKPP-PRF
            function of <a class='info' href='#DSKPP-PRF'>Section&nbsp;3.3.1<span> (</span><span class='info'>The DSKPP One-Way Pseudorandom Function, DSKPP-PRF</span><span>)</span></a>, in which case the
            input parameter k MUST be set to the existing MAC key K_MAC'
            (i.e., the value of the MAC key that existed before this protocol
            run); and input parameter s MUST be set to the concatenation of
            the (ASCII) string "MAC 1 computation", R (if sent by the client),
            and R_S. Note that the implementation MAY specify K_MAC' to be the
            value of the K_TOKEN that is being replaced, or a version of K_MAC
            from the previous protocol run.
</p>
<p>The input parameter dsLen MUST be set to the length of R_S:
</p>
<p>dsLen = len(R_S)
</p>
<p>MAC = DSKPP-PRF (K_MAC', "MAC 1 computation" || [R ||] R_S,
            dsLen)
</p>
<p>The MAC algorithm MUST be the same as the algorithm used for
            key confirmation purposes.
</p>
<a name="anchor26"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.4.4.2"></a><h3>3.4.4.2.&nbsp;
Key Confirmation</h3>

<p>To avoid a false "Commit" message causing the cryptographic
            module to end up in an initialized state in which the server does
            not recognize the stored key, &lt;KeyProvServerFinished&gt;
            messages MUST be authenticated with a MAC, calculated as
            follows:
</p>
<p>msg_hash = SHA-256(msg_1, ..., msg_n)
</p>
<p>dsLen = len(msg_hash)
</p>
<p>MAC = DSKPP-PRF (K_MAC, "MAC 2 computation" || msg_hash,
            dsLen)
</p>
<p>where
</p>
<p></p>
<blockquote class="text"><dl>
<dt>MAC</dt>
<dd>The MAC MUST be calculated using the already
                established MAC algorithm and MUST be computed on the (ASCII)
                string "MAC 2 computation" and msg_hash using the existing the
                MAC key K_MAC.<br />

</dd>
<dt>K_MAC</dt>
<dd>The key derived from K_PROV, as described
                in <a class='info' href='#Subsection-KeyGen'>Section&nbsp;3.4.2.2<span> (</span><span class='info'>Computing the Symmetric Key</span><span>)</span></a>. <br />

</dd>
<dt>msg_hash</dt>
<dd>The message hash, defined below, of
                messages msg_1, ..., msg_n.
</dd>
</dl></blockquote>

<p>If DSKPP-PRF (defined in <a class='info' href='#DSKPP-PRF'>Section&nbsp;3.3.1<span> (</span><span class='info'>The DSKPP One-Way Pseudorandom Function, DSKPP-PRF</span><span>)</span></a>) is
            used as the MAC algorithm, then the input parameter s MUST consist
            of the concatenation of the (ASCII) string "MAC 2 computation" and
            msg_hash, and the parameter dsLen MUST be set to the length of
            msg_hash.
</p>
<a name="Subsection-MsgHashAlg"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.4.4.3"></a><h3>3.4.4.3.&nbsp;
Message Hash Algorithm</h3>

<p>To compute a message hash for a MAC, given a sequence of DSKPP
            messages msg_1, ..., msg_n, the following operations MUST be
            carried out:<br />
<br />
</p>
<blockquote class="text"><dl>
<dt>a.</dt>
<dd>The sequence of messages contains all DSKPP Request and
                Response messages up to but not including this message.
</dd>
<dt>b.</dt>
<dd>Re-transmitted messages are removed from the sequence of
                messages.Note: The resulting sequence
                of messages MUST be an alternating sequence of DSKPP Request
                and DSKPP Response messages<br />

</dd>
<dt>c.</dt>
<dd>The contents of each message is concatenated
                together.
</dd>
<dt>d.</dt>
<dd>The resulting string is hashed using SHA-256 in accordance
                with <a class='info' href='#FIPS180-SHA'>[FIPS180&#8209;SHA]<span> (</span><span class='info'>National Institute of Standards and             Technology, &ldquo;Secure Hash Standard,&rdquo; February&nbsp;2004.</span><span>)</span></a>.
</dd>
</dl></blockquote>

<a name="Subsecton-TwoPass"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.5"></a><h3>3.5.&nbsp;
Two-Pass Protocol Usage</h3>

<p>This section describes the message flow and methods that comprise
        the two-pass protocol variant. Two-pass DSKPP is essentially a
        transport of keying material from the DSKPP server to the DSKPP
        client. The keying material is contained in a package that is
        formatted in such a way that ensures that the symmetric key that is
        being established, K_TOKEN, is not exposed to any other entity than
        the DSKPP server and the cryptographic module itself. To ensure the
        keying material is adequately protected for all two-pass usage
        scenarios, the key package format MUST support the following key
        protection methods, as defined in <a class='info' href='#Section-Profiles'>Section&nbsp;3.5.2<span> (</span><span class='info'>Key Protection Profiles</span><span>)</span></a>:
</p>
<p></p>
<blockquote class="text"><dl>
<dt>Key Transport</dt>
<dd>This profile is intended for
            PKI-capable devices. Key transport is carried out using the public
            key of the DSKPP client, whose private key part resides in the
            cryptographic module as the key transport key.
</dd>
<dt>Key Wrap</dt>
<dd>This profile is ideal for pre-keyed
            devices, e.g., SIM cards. Key wrap is carried out using a key
            wrapping key, which is known in advance by both the cryptographic
            module and the DSKPP server.
</dd>
<dt>Passphrase-Based Key Wrap</dt>
<dd>This profile is a
            variation of the Key Wrap Profile. It is applicable to constrained
            devices with keypads, e.g., mobile phones. Key wrap is carried out
            using a passphrase-derived key wrapping key, known in advance by
            both the cryptographic module and DSKPP server.
</dd>
</dl></blockquote>

<p>Key package formats that satisfy this criteria are <a class='info' href='#PSKC'>[PSKC]<span> (</span><span class='info'>, &ldquo;Portable Symmetric Key Container,&rdquo; 2008.</span><span>)</span></a>, <a class='info' href='#SKPC-ASN.1'>[SKPC&#8209;ASN.1]<span> (</span><span class='info'>, &ldquo;Symmetric Key Package Content Type,&rdquo; 2007.</span><span>)</span></a>, PKCS#12
        <a class='info' href='#PKCS-12'>[PKCS&#8209;12]<span> (</span><span class='info'>, &ldquo;Personal Information Exchange Syntax Standard,&rdquo; 2005.</span><span>)</span></a>, and PKCS#5 XML <a class='info' href='#PKCS-5-XML'>[PKCS&#8209;5&#8209;XML]<span> (</span><span class='info'>RSA Laboratories, &ldquo;XML Schema for PKCS #5 Version 2.0,&rdquo; October&nbsp;2006.</span><span>)</span></a>.
</p>
<a name="Subsection-2PassFlow"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.5.1"></a><h3>3.5.1.&nbsp;
Message Flow</h3>

<p>The two-pass protocol flow consists of one exchange:
</p>
<p></p>
<blockquote class="text"><dl>
<dt>1:</dt>
<dd>Pass 1 = &lt;KeyProvClientHello&gt;, Pass 2 =
              &lt;KeyProvServerFinished&gt;
</dd>
</dl></blockquote>

<p>The client's initial &lt;KeyProvClientHello&gt; message is
          directly followed by a &lt;KeyProvServerFinished&gt; message (unlike
          the four-pass variant, there is no exchange of the
          &lt;KeyProvServerHello&gt; and &lt;KeyProvClientNonce&gt; messages).
          However, as the two-pass variation of DSKPP consists of one round
          trip to the server, the client is still able to include its random
          nonce, R_C, algorithm preferences and supported key types in the
          &lt;KeyProvClientHello&gt; message. Note that by including R_C in
          &lt;KeyProvClientHello&gt;, the DSKPP client is able to ensure the
          server is alive before "committing" the key.
</p>
<p>The DSKPP server MUST ensure that a generated key is associated
          with the correct cryptographic module, and if applicable, the
          correct user. To ensure that the key K_TOKEN ends up associated with
          the correct cryptographic module and user, the DSKPP server MAY
          couple an initial user authentication to the DSKPP execution as
          described in <a class='info' href='#Section-ClientAuthN'>Section&nbsp;3.7<span> (</span><span class='info'>User Authentication</span><span>)</span></a>.
</p>
<p>The purpose and content of each message are described below,
          including the optional &lt;KeyProvTrigger&gt;.
</p>
<p>
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>        DSKPP Client                         DSKPP Server
        ------------                         ------------
                             [&lt;---] R_TRIGGER, [DeviceID],
                                         [KeyID], [URL_S]
</pre></div>
<p>The DSKPP server optionally sends a &lt;KeyProvTrigger&gt;
          message to the DSKPP client. The trigger message MUST contain a
          nonce, R_TRIGGER, to allow the server to couple the trigger with a
          later &lt;KeyProvClientHello&gt; request. &lt;KeyProvTrigger&gt; MAY
          include a DeviceID to allow the client to select the device with
          which it will communicate (for more information about device
          identification, refer to <a class='info' href='#Subsection-DeviceID'>Section&nbsp;3.6<span> (</span><span class='info'>Device Identification</span><span>)</span></a>). In the case of key renewal,
          &lt;KeyProvTrigger&gt; SHOULD include the identifier for the key,
          KeyID, that is being replaced. Finally, the trigger MAY contain a
          URL for the DSKPP client to use when contacting the DSKPP
          server.
</p>
<p>
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>        DSKPP Client                         DSKPP Server
        ------------                         ------------
        R_C, SAL, KPML, [AD],
        [R_TRIGGER],
        [DeviceID], [KeyID]     ---&gt;
</pre></div>
<p>The DSKPP client sends a &lt;KeyProvClientHello&gt; message to
          the DSKPP server. &lt;KeyProvClientHello&gt; MUST include client
          nonce, R_C, and a Security Attribute List (SAL), identifying which
          DSKPP versions, protocol variations (in this case "two-pass"), key
          package formats, key types, encryption and MAC algorithms that the
          client supports. Unlike 4-pass DSKPP, the 2-pass DSKPP client uses
          the &lt;KeyProvClientHello&gt; message to declare the list of Key
          Protection Method List (KPML) it supports, providing required
          payload information in accordance with <a class='info' href='#Section-Profiles'>Section&nbsp;3.5.2<span> (</span><span class='info'>Key Protection Profiles</span><span>)</span></a>. Optionally, the message MAY
          include client Authentication Data (AD), such as a MAC derived from
          an authentication code and R_C (refer to <a class='info' href='#Section-AuthCode'>Section&nbsp;3.7.1<span> (</span><span class='info'>Authentication Data</span><span>)</span></a>). In addition, if a trigger
          message preceded &lt;KeyProvClientHello&gt;, then it passes the
          parameters received in &lt;KeyProvTrigger&gt; back to the DSKPP
          Server. In particular, it MUST include R_TRIGGER so that the DSKPP
          server can associate the client with the trigger message, and SHOULD
          include DeviceID and KeyID.
</p>
<p>
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>        DSKPP Client                         DSKPP Server
        ------------                         ------------
                               &lt;---  KPH, KP, E(K,K_PROV),
                                                  MAC, AD
</pre></div>
<p>If Authentication Data (AD) was received, then the DSKPP server
          MUST authenticate the user in accordance with <a class='info' href='#Section-AuthCode'>Section&nbsp;3.7.1<span> (</span><span class='info'>Authentication Data</span><span>)</span></a>. If authentication fails, then
          DSKPP server MUST abort. Otherwise, the DSKPP server generates a key
          K_PROV from which two keys, K_TOKEN and K_MAC, are derived.
          (Alternatively, the key K_PROV may have been pre-generated as
          described in <a class='info' href='#UC1'>Section&nbsp;1.1.1<span> (</span><span class='info'>Single Key Request</span><span>)</span></a>.) The DSKPP server selects a
          Key Protection Method (KPM) and applies it to K_PROV in accordance
          with <a class='info' href='#Section-Profiles'>Section&nbsp;3.5.2<span> (</span><span class='info'>Key Protection Profiles</span><span>)</span></a>. The server then
          associates K_TOKEN with the cryptographic module in a server-side
          data store. The intent is that the data store later will be used by
          some service that needs to verify or decrypt data produced by the
          cryptographic module and the key.
</p>
<p>Once the association has been made, the DSKPP server sends a
          confirmation message to the DSKPP client called
          &lt;KeyProvServerFinished&gt;. For two-pass DSKPP, the confirmation
          message MUST include a Key Package Header (KPH) that contains the
          DSKPP Server's ID and KPM. The ServerID is used for authentication
          purposes, and the KPM informs the DSKPP client of the security
          context in which it will operate. In addition to the KPH, the
          confirmation message MUST include the Key Package (KP) that holds
          the KeyID, K_PROV from which K_TOKEN and K_MAC are derived, and
          additional configuration information. The default symmetric key
          package format is based on the Portable Symmetric Key Container
          (PSKC) defined in <a class='info' href='#PSKC'>[PSKC]<span> (</span><span class='info'>, &ldquo;Portable Symmetric Key Container,&rdquo; 2008.</span><span>)</span></a>. Alternative formats
          MAY include <a class='info' href='#SKPC-ASN.1'>[SKPC&#8209;ASN.1]<span> (</span><span class='info'>, &ldquo;Symmetric Key Package Content Type,&rdquo; 2007.</span><span>)</span></a>, PKCS#12 <a class='info' href='#PKCS-12'>[PKCS&#8209;12]<span> (</span><span class='info'>, &ldquo;Personal Information Exchange Syntax Standard,&rdquo; 2005.</span><span>)</span></a>, or PKCS#5 XML <a class='info' href='#PKCS-5-XML'>[PKCS&#8209;5&#8209;XML]<span> (</span><span class='info'>RSA Laboratories, &ldquo;XML Schema for PKCS #5 Version 2.0,&rdquo; October&nbsp;2006.</span><span>)</span></a>. Finally, &lt;KeyProvServerFinished&gt;
          MUST include two MACs (MAC and AD) whose values are calculated with
          contribution from the client nonce, R_C, provided in the
          &lt;ClientHello&gt; message. The MAC values will allow the
          cryptographic module to perform key confirmation and server
          authentication before "committing" the key (see <a class='info' href='#Subsection-MAC'>Section&nbsp;3.5.3<span> (</span><span class='info'>MAC Calculations</span><span>)</span></a> for more information).
</p>
<p>After receiving a &lt;KeyProvServerFinished&gt; message with
          Status = "Success", the DSKPP client MUST verify both MAC values
          (MAC and AD). The DSKPP client MUST terminate the DSKPP protocol run
          if either MAC does not verify, and MUST, in this case, also delete
          any nonces, keys, and/or secrets associated with the failed run of
          the protocol. If &lt;KeyProvServerFinished&gt; has Status =
          "Success" and the MACs were verified, then the DSKPP client MUST
          extract the key data from the provided key package, and store data
          locally. After this operation, it MUST NOT be possible to overwrite
          the key unless knowledge of an authorizing key is proven through a
          MAC on a later &lt;KeyProvServerFinished&gt; message.
</p>
<a name="Section-Profiles"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.5.2"></a><h3>3.5.2.&nbsp;
Key Protection Profiles</h3>

<p>This section introduces three profiles of two-pass DSKPP for key
          protection. Further profiles MAY be defined by external entities or
          through the IETF process.
</p>
<a name="anchor27"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.5.2.1"></a><h3>3.5.2.1.&nbsp;
Key Transport Profile</h3>

<p>This profile establishes a symmetric key, K_TOKEN, in the
            cryptographic module using key transport and key derivation. Key
            transport is carried out using a public key whose private key part
            resides in the cryptographic module as the key transport key. A
            provisioning master key, K_PROV, MUST be transported from the
            DSKPP server to the client. From K_PROV, two keys are derived: the
            symmetric key to be established, K_TOKEN, and a key used to
            compute MACs, K_MAC.
</p>
<p>This profile MUST be identified with the following URN:
            urn:ietf:params:xml:schema:keyprov:dskpp#transport
</p>
<p>In the two-pass version of DSKPP, the client MUST send a
            payload with the Key Transport Profile. This payload MUST be of
            type &lt;ds:KeyInfoType&gt; (<a class='info' href='#XMLDSIG'>[XMLDSIG]<span> (</span><span class='info'>W3C, &ldquo;XML Signature Syntax and Processing,&rdquo; February&nbsp;2002.</span><span>)</span></a>), and
            only those choices of &lt;ds:KeyInfoType&gt; that identify a
            public key are allowed (i.e., &lt;ds:KeyName&gt;,
            &lt;ds:KeyValue&gt;, &lt;ds:X509Data&gt;, or &lt;ds:PGPData&gt;).
            The &lt;ds:X509Certificate&gt; option of the &lt;ds:X509Data&gt;
            alternative is RECOMMENDED when the public key corresponding to
            the private key on the cryptographic module has been
            certified.
</p>
<p>The server payload associated with this key protection method
            MUST be of type &lt;xenc:EncryptedKeyType&gt; (<a class='info' href='#XMLENC'>[XMLENC]<span> (</span><span class='info'>W3C, &ldquo;XML Encryption Syntax and Processing,&rdquo; December&nbsp;2002.</span><span>)</span></a>), and only those encryption methods
            utilizing a public key that are supported by the DSKPP client (as
            indicated in the &lt;SupportedEncryptionAlgorithms&gt; element of
            the &lt;KeyProvClientHello&gt; message in the case of 2-pass
            DSKPP) are allowed as values for the
            &lt;xenc:EncryptionMethod&gt;. Further, in the case of 2-pass
            DSKPP, &lt;ds:KeyInfo&gt; MUST contain the same value (i.e.
            identify the same public key) as the &lt;Payload&gt; of the
            corresponding supported key protection method in the
            &lt;KeyProvClientHello&gt; message that triggered the response.
            &lt;xenc:CarriedKeyName&gt; MAY be present, but MUST, when
            present, contain the same value as the &lt;KeyID&gt; element of
            the &lt;KeyProvServerFinished&gt; message. The Type attribute of
            the &lt;xenc:EncryptedKeyType&gt; MUST be present and MUST
            identify the type of the wrapped key. The type MUST be one of the
            types supported by the DSKPP client (as reported in the
            &lt;SupportedKeyTypes&gt; of the preceding
            &lt;KeyProvClientHello&gt; message in the case of 2-pass DSKPP).
            The transported key, K_PROV, MUST consist of two parts of equal
            length. The first half constitutes K_MAC and the second half
            constitutes K_TOKEN. The length of K_TOKEN (and hence also the
            length of K_MAC) is determined by the type of K_TOKEN.
</p>
<p>DSKPP servers and cryptographic modules supporting this profile
            MUST support the http://www.w3.org/2001/04/xmlenc#rsa-1_5 key
            wrapping mechanism defined in <a class='info' href='#XMLENC'>[XMLENC]<span> (</span><span class='info'>W3C, &ldquo;XML Encryption Syntax and Processing,&rdquo; December&nbsp;2002.</span><span>)</span></a>.
</p>
<p>When this profile is used, the MacAlgorithm attribute of the
            &lt;Mac&gt; element of the &lt;KeyProvServerFinished&gt; message
            MUST be present and MUST identify the selected MAC algorithm. The
            selected MAC algorithm MUST be one of the MAC algorithms supported
            by the DSKPP client (as indicated in the
            &lt;SupportedMacAlgorithms&gt; element of the
            &lt;KeyProvClientHello&gt; message in the case of 2-pass DSKPP).
            The MAC MUST be calculated as described in <a class='info' href='#Subsection-MAC'>Section&nbsp;3.5.3<span> (</span><span class='info'>MAC Calculations</span><span>)</span></a> for two-pass DSKPP.
</p>
<p>In addition, DSKPP servers MUST include the
            AuthenticationDataType element in their
            &lt;KeyProvServerFinished&gt; messages whenever a successful
            protocol run will result in an existing K_TOKEN being
            replaced.
</p>
<a name="anchor28"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.5.2.2"></a><h3>3.5.2.2.&nbsp;
Key Wrap Profile</h3>

<p>This profile establishes a symmetric key, K_TOKEN, in the
            cryptographic module through key wrap and key derivation. Key wrap
            is carried out using a symmetric key wrapping key, known in
            advance by both the cryptographic module and the DSKPP server. A
            provisioning master key, K_PROV, MUST be transported from the
            DSKPP server to the client. From K_PROV, two keys are derived: the
            symmetric key to be established, K_TOKEN, and a key used to
            compute MACs, K_MAC.
</p>
<p>This profile MUST be identified with the following URI:
            urn:ietf:params:xml:schema:keyprov:dskpp#wrap
</p>
<p>In the 2-pass version of DSKPP, the client MUST send a payload
            with the Key Wrap Profile. This payload MUST be of type
            &lt;ds:KeyInfoType&gt; (<a class='info' href='#XMLDSIG'>[XMLDSIG]<span> (</span><span class='info'>W3C, &ldquo;XML Signature Syntax and Processing,&rdquo; February&nbsp;2002.</span><span>)</span></a>), and only
            those choices of &lt;ds:KeyInfoType&gt; that identify a symmetric
            key are allowed (i.e., &lt;ds:KeyName&gt; and
            &lt;ds:KeyValue&gt;). The &lt;ds:KeyName&gt; alternative is
            RECOMMENDED.
</p>
<p>The server payload associated with this key protection method
            MUST be of type &lt;xenc:EncryptedKeyType&gt; (<a class='info' href='#XMLENC'>[XMLENC]<span> (</span><span class='info'>W3C, &ldquo;XML Encryption Syntax and Processing,&rdquo; December&nbsp;2002.</span><span>)</span></a>), and only those encryption methods
            utilizing a symmetric key that are supported by the DSKPP client
            (as indicated in the &lt;SupportedEncryptionAlgorithms&gt; element
            of the &lt;KeyProvClientHello&gt; message in the case of 2-pass
            DSKPP) are allowed as values for the
            &lt;xenc:EncryptionMethod&gt;. Further, in the case of 2-pass
            DSKPP, &lt;ds:KeyInfo&gt; MUST contain the same value (i.e.
            identify the same symmetric key) as the &lt;Payload&gt; of the
            corresponding supported key protection method in the
            &lt;KeyProvClientHello&gt; message that triggered the response.
            &lt;xenc:CarriedKeyName&gt; MAY be present, and MUST, when
            present, contain the same value as the &lt;KeyID&gt; element of
            the &lt;KeyProvServerFinished&gt; message. The Type attribute of
            the &lt;xenc:EncryptedKeyType&gt; MUST be present and MUST
            identify the type of the wrapped key. The type MUST be one of the
            types supported by the DSKPP client (as reported in the
            &lt;SupportedKeyTypes&gt; of the preceding
            &lt;KeyProvClientHello&gt; message in the case of 2-pass DSKPP).
            The wrapped key, K_PROV, MUST consist of two parts of equal
            length. The first half constitutes K_MAC and the second half
            constitutes K_TOKEN. The length of K_TOKEN (and hence also the
            length of K_MAC) is determined by the type of K_TOKEN.
</p>
<p>DSKPP servers and cryptographic modules supporting this profile
            MUST support the http://www.w3.org/2001/04/xmlenc#kw-aes128 key
            wrapping mechanism defined in <a class='info' href='#XMLENC'>[XMLENC]<span> (</span><span class='info'>W3C, &ldquo;XML Encryption Syntax and Processing,&rdquo; December&nbsp;2002.</span><span>)</span></a>.
</p>
<p>When this profile is used, the MacAlgorithm attribute of the
            &lt;Mac&gt; element of the &lt;KeyProvServerFinished&gt; message
            MUST be present and MUST identify the selected MAC algorithm. The
            selected MAC algorithm MUST be one of the MAC algorithms supported
            by the DSKPP client (as indicated in the
            &lt;SupportedMacAlgorithms&gt; element of the
            &lt;KeyProvClientHello&gt; message in the case of 2-pass DSKPP).
            The MAC MUST be calculated as described in <a class='info' href='#Subsection-MAC'>Section&nbsp;3.5.3<span> (</span><span class='info'>MAC Calculations</span><span>)</span></a>.
</p>
<p>In addition, DSKPP servers MUST include the
            AuthenticationDataType element in their
            &lt;KeyProvServerFinished&gt; messages whenever a successful
            protocol run will result in an existing K_TOKEN being
            replaced.
</p>
<a name="anchor29"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.5.2.3"></a><h3>3.5.2.3.&nbsp;
Passphrase-Based Key Wrap Profile</h3>

<p>This profile is a variation of the key wrap profile. It
            establishes a symmetric key, K_TOKEN, in the cryptographic module
            through key wrap and key derivation. Key wrap is carried out using
            a passphrase-derived key wrapping key. The passphrase is known in
            advance by both the user of the device and the DSKPP server. To
            preserve the property of not exposing K_TOKEN to any other entity
            than the DSKPP server and the cryptographic module itself, the
            method SHOULD be employed only when the device contains facilities
            (e.g. a keypad) for direct entry of the passphrase. A provisioning
            master key, K_PROV, MUST be transported from the DSKPP server to
            the client. From K_PROV, two keys are derived: the symmetric key
            to be established, K_TOKEN, and a key used to compute MACs,
            K_MAC.
</p>
<p>This profile MUST be identified with the following URI:
            urn:ietf:params:xml:schema:keyprov:dskpp#passphrase-wrap
</p>
<p>In the 2-pass version of DSKPP, the client MUST send a payload
            with the Passphrase-Based Key Wrap Profile. This payload MUST be
            of type &lt;ds:KeyInfoType&gt; (<a class='info' href='#XMLDSIG'>[XMLDSIG]<span> (</span><span class='info'>W3C, &ldquo;XML Signature Syntax and Processing,&rdquo; February&nbsp;2002.</span><span>)</span></a>).
            The &lt;ds:KeyName&gt; option MUST be used and the key name MUST
            identify the passphrase that will be used by the server to
            generate the key wrapping key. As an example, the identifier could
            be a user identifier or a registration identifier issued by the
            server to the user during a session preceding the DSKPP protocol
            run.
</p>
<p>The server payload associated with this key protection method
            MUST be of type &lt;xenc:EncryptedKeyType&gt; (<a class='info' href='#XMLENC'>[XMLENC]<span> (</span><span class='info'>W3C, &ldquo;XML Encryption Syntax and Processing,&rdquo; December&nbsp;2002.</span><span>)</span></a>), and only those encryption methods
            utilizing a passphrase to derive the key wrapping key that are
            supported by the DSKPP client (as indicated in the
            &lt;SupportedEncryptionAlgorithms&gt; element of the
            &lt;KeyProvClientHello&gt; message in the case of 2-pass DSKPP)
            are allowed as values for the &lt;xenc:EncryptionMethod&gt;.
            Further, in the case of 2-pass DSKPP, &lt;ds:KeyInfo&gt; MUST
            contain the same value (i.e. identify the same passphrase) as the
            &lt;Payload&gt; of the corresponding supported key protection
            method in the &lt;KeyProvClientHello&gt; message that triggered
            the response. &lt;xenc:CarriedKeyName&gt; MAY be present, and
            MUST, when present, contain the same value as the &lt;KeyID&gt;
            element of the &lt;KeyProvServerFinished&gt; message. The Type
            attribute of the &lt;xenc:EncryptedKeyType&gt; MUST be present and
            MUST identify the type of the wrapped key. The type MUST be one of
            the types supported by the DSKPP client (as reported in the
            &lt;SupportedKeyTypes&gt; of the preceding
            &lt;KeyProvClientHello&gt; message in the case of 2-pass DSKPP).
            The wrapped key, K_PROV, MUST consist of two parts of equal
            length. The first half constitutes K_MAC and the second half
            constitutes K_TOKEN. The length of K_TOKEN (and hence also the
            length of K_MAC) is determined by the type of K_TOKEN.
</p>
<p>DSKPP servers and cryptographic modules supporting this profile
            MUST support the PBES2 password based encryption scheme defined in
            <a class='info' href='#PKCS-5'>[PKCS&#8209;5]<span> (</span><span class='info'>RSA Laboratories, &ldquo;Password-Based Cryptography Standard,&rdquo; March&nbsp;1999.</span><span>)</span></a> (and identified as
            http://www.rsasecurity.com/rsalabs/pkcs/schemas/pkcs-5#pbes2 in
            <a class='info' href='#PKCS-5-XML'>[PKCS&#8209;5&#8209;XML]<span> (</span><span class='info'>RSA Laboratories, &ldquo;XML Schema for PKCS #5 Version 2.0,&rdquo; October&nbsp;2006.</span><span>)</span></a>), the PBKDF2 passphrase-based
            key derivation function also defined in <a class='info' href='#PKCS-5'>[PKCS&#8209;5]<span> (</span><span class='info'>RSA Laboratories, &ldquo;Password-Based Cryptography Standard,&rdquo; March&nbsp;1999.</span><span>)</span></a> (and identified as
            http://www.rsasecurity.com/rsalabs/pkcs/schemas/pkcs-5#pbkdf2 in
            <a class='info' href='#PKCS-5-XML'>[PKCS&#8209;5&#8209;XML]<span> (</span><span class='info'>RSA Laboratories, &ldquo;XML Schema for PKCS #5 Version 2.0,&rdquo; October&nbsp;2006.</span><span>)</span></a>), and the
            http://www.w3.org/2001/04/xmlenc#kw-aes128 key wrapping mechanism
            defined in <a class='info' href='#XMLENC'>[XMLENC]<span> (</span><span class='info'>W3C, &ldquo;XML Encryption Syntax and Processing,&rdquo; December&nbsp;2002.</span><span>)</span></a>.
</p>
<p>When this profile is used, the MacAlgorithm attribute of the
            &lt;Mac&gt; element of the &lt;KeyProvServerFinished&gt; message
            MUST be present and MUST identify the selected MAC algorithm. The
            selected MAC algorithm MUST be one of the MAC algorithms supported
            by the DSKPP client (as indicated in the
            &lt;SupportedMacAlgorithms&gt; element of the
            &lt;KeyProvClientHello&gt; message in the case of 2-pass DSKPP).
            The MAC MUST be calculated as described in <a class='info' href='#Subsection-MAC'>Section&nbsp;3.5.3<span> (</span><span class='info'>MAC Calculations</span><span>)</span></a>.
</p>
<p>In addition, DSKPP servers MUST include the
            AuthenticationDataType element in their
            &lt;KeyProvServerFinished&gt; messages whenever a successful
            protocol run will result in an existing K_TOKEN being
            replaced.
</p>
<a name="Subsection-MAC"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.5.3"></a><h3>3.5.3.&nbsp;
MAC Calculations</h3>

<a name="anchor30"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.5.3.1"></a><h3>3.5.3.1.&nbsp;
Key Confirmation</h3>

<p>The MAC value in the &lt;KeyProvServerFinished&gt; message MUST
            be calculated as follows:
</p>
<p>msg_hash = SHA-256(msg_1, ..., msg_n)
</p>
<p>dsLen = len(msg_hash)
</p>
<p>MAC = DSKPP-PRF (K_MAC, "MAC 1 computation" || msg_hash ||
            ServerID, dsLen)
</p>
<p>where
</p>
<p></p>
<blockquote class="text"><dl>
<dt>MAC</dt>
<dd>The MAC MUST be calculated using the already
                established MAC algorithm and MUST be computed on the (ASCII)
                string "MAC 1 computation", msg_hash, and ServerID using the
                existing the MAC key K_MAC.<br />

</dd>
<dt>K_MAC</dt>
<dd>The key, along with K_TOKEN, that is
                derived from K_PROV which the DSKPP server MUST provide to the
                cryptographic module.<br />

</dd>
<dt>msg_hash</dt>
<dd>The message hash, defined in <a class='info' href='#Subsection-MsgHashAlg'>Section&nbsp;3.4.4.3<span> (</span><span class='info'>Message Hash Algorithm</span><span>)</span></a>, of messages msg_1,
                ..., msg_n.<br />

</dd>
<dt>ServerID</dt>
<dd>The identifier that the DSKPP server
                MUST include in the &lt;KeyPackage&gt; element of
                &lt;KeyProvServerFinished&gt;.
</dd>
</dl></blockquote>

<p>If DSKPP-PRF (defined in <a class='info' href='#DSKPP-PRF'>Section&nbsp;3.3.1<span> (</span><span class='info'>The DSKPP One-Way Pseudorandom Function, DSKPP-PRF</span><span>)</span></a>) is
            used as the MAC algorithm, then the input parameter s MUST consist
            of the concatenation of the (ASCII) string "MAC 1 computation",
            msg_hash, and ServerID, and the parameter dsLen MUST be set to the
            length of msg_hash.
</p>
<a name="Subsecton-TwoPass-ServerAuth"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.5.3.2"></a><h3>3.5.3.2.&nbsp;
Server Authentication in the Case of Key Renewal</h3>

<p>A second MAC MUST be present in the
            &lt;KeyProvServerFinished&gt; message as proof that the DSKPP
            server is authorized to replace a key on the cryptographic module.
            In 2-pass DSKPP, servers provide the second MAC in the
            AuthenticationDataType element of &lt;KeyProvServerFinished&gt;.
            The MAC value in the AuthenticationDataType element MUST be
            computed on the (ASCII) string "MAC 2 computation", the server
            identifier ServerID, and R, using a pre-existing MAC key K_MAC'
            (the MAC key that existed before this protocol run). Note that the
            implementation may specify K_MAC' to be the value of the K_TOKEN
            that is being replaced, or a version of K_MAC from the previous
            protocol run.
</p>
<p>If DSKPP-PRF is used as the MAC algorithm, then the input
            parameter s MUST consist of the concatenation of the (ASCII)
            string "MAC 2 computation" ServerID, and R. The parameter dsLen
            MUST be set to at least 16 (i.e. the length of the MAC MUST be at
            least 16 octets):
</p>
<p>dsLen &gt;= 16
</p>
<p>MAC = DSKPP-PRF (K_MAC', "MAC 2 computation" || ServerID || R,
            dsLen)
</p>
<p>The MAC algorithm MUST be the same as the algorithm used for
            key confirmation purposes.
</p>
<a name="Subsection-DeviceID"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.6"></a><h3>3.6.&nbsp;
Device Identification</h3>

<p>The DSKPP server MAY be pre-configured with a unique device
        identifier corresponding to a particular cryptographic module. The
        DSKPP server MAY then include this identifier in the DSKPP
        initialization trigger, in which case the DSKPP client MUST include it
        in its message(s) to the DSKPP server for authentication. Note that it
        is also legitimate for a DSKPP client to initiate the DSKPP protocol
        run without having received an initialization message from a server,
        but in this case any provided device identifier MUST NOT be accepted
        by the DSKPP server unless the server has access to a unique key for
        the identified device and that key will be used in the protocol.
</p>
<a name="Section-ClientAuthN"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.7"></a><h3>3.7.&nbsp;
User Authentication</h3>

<p>The DSKPP server MUST ensure that a generated key is associated
        with the correct cryptographic module, and if applicable, the correct
        user. If the user has not been authenticated by some out-of-band
        means, then the user SHOULD be authenticated within the DSKPP. When
        relying on DSKPP for user authentication, the DSKPP server SHOULD
        explicitly rely on client-provided Authentication Data (AD) to verify
        that a legitimate user is behind the wheel. For a further discussion
        of this, and threats related to man-in-the-middle attacks in this
        context, see <a class='info' href='#Subsection-UserAuthN'>Section&nbsp;9.6.4<span> (</span><span class='info'>User Authentication</span><span>)</span></a>.
</p>
<a name="Section-AuthCode"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.7.1"></a><h3>3.7.1.&nbsp;
Authentication Data</h3>

<p>As described in the message flows above (see <a class='info' href='#Subsection-4PassFlow'>Section&nbsp;3.4.1<span> (</span><span class='info'>Message Flow</span><span>)</span></a> and <a class='info' href='#Subsection-2PassFlow'>Section&nbsp;3.5.1<span> (</span><span class='info'>Message Flow</span><span>)</span></a>), the DSKPP client MAY include
          Authentication Data (AD) in its request(s). Note that AD MAY be
          omitted if client certificate authentication has been provided by
          the transport channel such as TLS. Nonetheless, when AD is provided,
          the DSKPP server MUST verify the data before continuing with the
          protocol run.
</p>
<p>The data element that holds AD MUST include a Client ID and a
          value derived from an Authentication Code (AC). The Client ID
          represents a key request made by the user to the Provisioning
          Server. AC is a one-time use value that is a (potentially low
          entropy) shared secret between a user and the Provisioning Server.
          This secret is made available to the client before the DSKPP message
          exchange. Below are examples of how the DSKPP client may obtain the
          AC:
</p>
<p></p>
<blockquote class="text"><dl>
<dt>a.</dt>
<dd>A key issuer may deliver an AC to the user or device in
              response to a key request, which the user enters into an
              application hosted on their device. For example, a user runs an
              application that is resident on their device, e.g., a mobile
              phone. The application cannot proceed without a new symmetric
              key. The user is redirected to an issuer's Web site from where
              the user requests a key. The issuer's Web application processes
              the request, and returns an AC, which then appears on the user's
              display. The user then invokes a symmetric key-based application
              hosted on the device, which asks the user to input the AC using
              a keypad. The application invokes the DSKPP client, providing it
              with the AC.
</dd>
<dt>b.</dt>
<dd>The provisioning server may send a trigger message,
              &lt;KeyProvTrigger&gt;, to the DSKPP client, which sets the
              value of the trigger nonce, R_TRIGGER, to AC. When this method
              is used, a transport providing confidentiality and integrity
              MUST be used to deliver the DSKPP initialization trigger from
              the DSKPP server to the DSKPP client, e.g., HTTPS.
</dd>
</dl></blockquote>

<p>A description of the AC and how it is used to derive AD is
          contained in the sub-sections below.
</p>
<a name="anchor31"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.7.2"></a><h3>3.7.2.&nbsp;
Authentication Code Format</h3>

<p>AC is encoded in Type-Length-Value (TLV) format. The format
          consists of a minimum of two TLVs and a variable number of
          additional TLVs, depending on implementation. See <a class='info' href='#TLV'>Figure&nbsp;7<span> (</span><span class='info'>TLV Format</span><span>)</span></a> for TLV field layout.
</p>
<p>A 1 byte type field identifies the specific TLV, and a 1 byte
          length, in hexadecimal, indicates the length of the value field
          contained in the TLV. A TLV MUST start on a 4 byte boundary. Pad
          bytes MUST be placed at the end of the previous TLV in order to
          align the next TLV. These pad bytes are not counted in the length
          field of the TLV.
</p><br /><hr class="insert" />
<a name="TLV"></a>

<p>
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>    0                   1                   2
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |      Type     |     Length    |    Value[0]   |  ...Value[Length-1]
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</pre></div>
<p>
</p><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;7: TLV Format&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>The TLV fields are defined as follows:
</p>
<p></p>
<blockquote class="text"><dl>
<dt>Type (1 byte)</dt>
<dd>The integer value identifying the
              type of information contained in the value field.<br />

</dd>
<dt>Length (1 byte)</dt>
<dd>The length, in hexadecimal, of the
              value field to follow.<br />

</dd>
<dt>Value (variable length)</dt>
<dd>A variable-length
              hexadecimal value containing the instance-specific information
              for this TLV.<br />

</dd>
</dl></blockquote><a class='info' href='#TLVtypes'>Figure&nbsp;8<span> (</span><span class='info'>TLV Summary</span><span>)</span></a><p> summarizes the TLVs defined
          in this document. Optional TLVs are allowed for vendor-specific
          extensions with the constraint that the high bit MUST be set to
          indicate a vendor-specific type. Other TLVs are left for later
          revisions of this protocol.
</p><br /><hr class="insert" />
<a name="TLVtypes"></a>

<p>
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>+------+------------+-------------------------------------------+
| Type | TLV Name   | Conformance | Example Usage               |
+------+------------+-------------------------------------------+
|  1   | Client ID  | Mandatory   | { "AC00000A" }              |
+------+------------+-------------+-----------------------------+
|  2   | Password   | Mandatory   | { "3582" }                  |
+------+------------+-------------+-----------------------------+
|  3   | Checksum   | Optional    | { 0x5F8D }                  |
+------+------------+-------------+-----------------------------+
</pre></div>
<p>
</p><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;8: TLV Summary&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<a name="anchor32"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.7.2.1"></a><h3>3.7.2.1.&nbsp;
Client ID (MANDATORY)</h3>

<p>The Client ID is a mandatory TLV that represents the
            user&rsquo;s key request. A summary of the Client ID TLV format is
            given in <a class='info' href='#TLV-ClientID'>Figure&nbsp;9<span> (</span><span class='info'>ClientID TLV Format</span><span>)</span></a>. The fields are
            transmitted from left to right.
</p><br /><hr class="insert" />
<a name="TLV-ClientID"></a>

<p>
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre> 0                   1                   2
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
| Type = 0x1    |     Length    | clientID ...                  |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</pre></div>
<p>
</p><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;9: ClientID TLV Format&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>clientID is an ASCII string that identifies the key request.
            The clientID MUST be HEX encoded.
</p>
<p>For example, suppose clientID is set to "AC00000A", the
            hexadecimal equivalent is 0x4143303030303041, resulting in a TLV
            of {0x1, 0x8, 0x4143303030303041}.
</p>
<a name="anchor33"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.7.2.2"></a><h3>3.7.2.2.&nbsp;
Password (MANDATORY)</h3>

<p>The Password is a mandatory TLV the contains a one-time use
            shared secret known by the user and the Provisioning Server. A
            summary of the Password TLV format is given in <a class='info' href='#TLV-Password'>Figure&nbsp;10<span> (</span><span class='info'>Password TLV Format</span><span>)</span></a>. The fields are transmitted from
            left to right.
</p><br /><hr class="insert" />
<a name="TLV-Password"></a>

<p>
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre> 0                   1                   2
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
| Type = 0x2    |     Length    | password ...                  |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</pre></div>
<p>
</p><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;10: Password TLV Format&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>Password is a unique value that SHOULD be a random string to
            make AC more difficult to guess. The string MUST be UTF-8 encoded
            in accordance with <a class='info' href='#RFC3629'>[RFC3629]<span> (</span><span class='info'>, &ldquo;UTF-8, a transformation format of ISO10646,&rdquo; November&nbsp;2003.</span><span>)</span></a>.
</p>
<p>For example, suppose password is set to "3582", then the TLV
            would be {0x2, 0x4, UTF-8("3582")}.
</p>
<a name="anchor34"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.7.2.3"></a><h3>3.7.2.3.&nbsp;
Checksum (OPTIONAL)</h3>

<p>The Checksum is an OPTIONAL TLV, which is generated by the
            issuing server and sent to the user as part of the AC. A summary
            of the Checksum TLV format is given in <a class='info' href='#TLV-Checksum'>Figure&nbsp;11<span> (</span><span class='info'>Checksum TLV Format</span><span>)</span></a>. The fields are transmitted from
            left to right.
</p><br /><hr class="insert" />
<a name="TLV-Checksum"></a>

<p>
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre> 0                   1                   2
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
| Type = 0x3    |     Length    | checksum                      |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</pre></div>
<p>
</p><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;11: Checksum TLV Format&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>If included, the checksum MUST be computed using the CRC16
            algorithm <a class='info' href='#ISO3309'>[ISO3309]<span> (</span><span class='info'>, &ldquo;ISO Information Processing Systems - Data Communication -           High-Level Data Link Control Procedure - Frame Structure,&rdquo; October&nbsp;1984.</span><span>)</span></a>. When the user enters the
            AC, the typed password is verified with the checksum to ensure it
            is correctly entered by the user.
</p>
<p>For example, suppose the Password is set to "3582", then the
            CRC16 calculation would generate a checksum of 0x5F8D, resulting
            in TLV {0x3, 0x2, 0x5F8D}.
</p>
<a name="Subsection-ADMAC"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.7.3"></a><h3>3.7.3.&nbsp;
Authentication Data Calculation</h3>

<p>The Authentication Data consists of a Client ID (extracted from
          the AC) and a value, which is derived from AC as follows (refer to
          <a class='info' href='#DSKPP-PRF'>Section&nbsp;3.3.1<span> (</span><span class='info'>The DSKPP One-Way Pseudorandom Function, DSKPP-PRF</span><span>)</span></a> for a description of DSKPP-PRF in
          general and <a class='info' href='#Section-PRFRealizations'>Appendix&nbsp;C<span> (</span><span class='info'>Example of DSKPP-PRF Realizations</span><span>)</span></a> for a
          description of DSKPP-PRF-AES):
</p>
<p>MAC = DSKPP-PRF(K_AC, AC-&gt;clientID||URL_S||R_C||[R_S], 16)
</p>
<p>In four-pass DSKPP, the cryptographic module uses R_C, R_S, and
          URL_S to calculate the MAC, where URL_S is the URL the DSKPP client
          uses when contacting the DSKPP server. In two-pass DSKPP, the
          cryptographic module does not have access to R_S, therefore only R_C
          is used in combination with URL_S to produce the MAC. In either
          case, K_AC MUST be derived from AC&gt;password as follows <a class='info' href='#PKCS-5'>[PKCS&#8209;5]<span> (</span><span class='info'>RSA Laboratories, &ldquo;Password-Based Cryptography Standard,&rdquo; March&nbsp;1999.</span><span>)</span></a>:
</p>
<p>K_AC = PBKDF2(AC-&gt;password, R_C || K, iter_count, 16)
</p>
<p>One of the following values for K MUST be used:<br />
<br />
</p>
<blockquote class="text"><dl>
<dt>a.</dt>
<dd>In four-pass: 
<ul class="text">
<li>The public key of the DSKPP server (K_SERVER), or (in the
                  pre-shared key variant) the pre-shared key between the
                  client and the server (K_SHARED)
</li>
</ul>
</dd>
<dt>b.</dt>
<dd>In two-pass:
<ul class="text">
<li>The public key of the DSKPP client, or the public key of
                  the device when a device certificate is available
</li>
<li>The pre-shared key between the client and the server
                  (K_SHARED)
</li>
<li>A passphrase-derived key
</li>
</ul>
</dd>
</dl></blockquote><br />
<br />
<p>The iteration count, iter_count,
          MUST be set to at least 100,000 except for case (b) and (c), above,
          in which case it MUST be set to 1.
</p>
<a name="anchor35"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4"></a><h3>4.&nbsp;
DSKPP Message Formats</h3>

<p>The message formats from the DSKPP XML schema, found in <a class='info' href='#Section-Schema'>Section&nbsp;7<span> (</span><span class='info'>DSKPP Schema</span><span>)</span></a>, are explained in this section. Examples
      can be found in <a class='info' href='#Section-Examples'>Appendix&nbsp;A<span> (</span><span class='info'>Examples</span><span>)</span></a>. The XML format
      for DSKPP messages has been designed to be extensible. However, it is
      possible that the use of extensions will harm interoperability;
      therefore, any use of extensions SHOULD be carefully considered. For
      example, if a particular implementation relies on the presence of a
      proprietary extension, then it may not be able to interoperate with
      independent implementations that have no knowledge of this
      extension.
</p>
<a name="anchor36"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.1"></a><h3>4.1.&nbsp;
General XML Schema Requirements</h3>

<p>Some DSKPP elements rely on the parties being able to compare
        received values with stored values. Unless otherwise noted, all
        elements in this document that have the XML Schema "xs:string" type,
        or a type derived from it, MUST be compared using an exact binary
        comparison. In particular, DSKPP implementations MUST NOT depend on
        case-insensitive string comparisons, normalization or trimming of
        white space, or conversion of locale-specific formats such as
        numbers.
</p>
<p>Implementations that compare values that are represented using
        different character encodings MUST use a comparison method that
        returns the same result as converting both values to the Unicode
        character encoding, Normalization Form C <a class='info' href='#UNICODE'>[UNICODE]<span> (</span><span class='info'>Davis, M. and M. Duerst, &ldquo;Unicode Normalization Forms,&rdquo; March&nbsp;2001.</span><span>)</span></a>, and then performing an exact binary
        comparison.
</p>
<p>No collation or sorting order for attributes or element values is
        defined. Therefore, DSKPP implementations MUST NOT depend on specific
        sorting orders for values.
</p>
<a name="Section-Trigger"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.2"></a><h3>4.2.&nbsp;
Components of the &lt;KeyProvTrigger&gt; Message</h3>

<p>The DSKPP server MAY initialize the DSKPP protocol by sending a
        &lt;KeyProvTrigger&gt; message. This message MAY, e.g., be sent in
        response to a user requesting key initialization in a browsing
        session.
</p>
<p>
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>&lt;xs:element name="KeyProvTrigger" type="dskpp:KeyProvTriggerType"&gt;
&lt;/xs:element&gt;
&lt;xs:complexType name="KeyProvTriggerType"&gt;
  &lt;xs:sequence&gt;
    &lt;xs:choice&gt;
      &lt;xs:element name="InitializationTrigger"
        type="dskpp:InitializationTriggerType" /&gt;
      &lt;xs:any namespace="##other" processContents="strict" /&gt;
    &lt;/xs:choice&gt;
  &lt;/xs:sequence&gt;
  &lt;xs:attribute name="Version" type="dskpp:VersionType" /&gt;
&lt;/xs:complexType&gt;

&lt;xs:complexType name="InitializationTriggerType"&gt;
  &lt;xs:sequence&gt;
    &lt;xs:element minOccurs="0" name="DeviceIdentifierData"
      type="dskpp:DeviceIdentifierDataType" /&gt;
    &lt;xs:element minOccurs="0" name="KeyID" type="xs:base64Binary" /&gt;
    &lt;xs:element minOccurs="0" name="TokenPlatformInfo"
      type="dskpp:TokenPlatformInfoType" /&gt;
    &lt;xs:element name="TriggerNonce" type="dskpp:NonceType" /&gt;
    &lt;xs:element minOccurs="0" name="ServerUrl" type="xs:anyURI" /&gt;
    &lt;xs:any minOccurs="0" namespace="##other"
      processContents="strict" /&gt;
  &lt;/xs:sequence&gt;
&lt;/xs:complexType&gt;
</pre></div>
<p>
</p>
<p>The &lt;KeyProvTrigger&gt; element is intended for the DSKPP client
        and MAY inform the DSKPP client about the identifier for the device
        that houses the cryptographic module to be initialized, and optionally
        of the identifier for the key on that module. The latter would apply
        to key renewal. The trigger always contains a nonce to allow the DSKPP
        server to couple the trigger with a later DSKPP
        &lt;KeyProvClientHello&gt; request. Finally, the trigger MAY contain a
        URL to use when contacting the DSKPP server. The &lt;xs:any&gt;
        elements are for future extensibility. Any provided
        &lt;DeviceIdentifierData&gt; or &lt;KeyID&gt; values MUST be used by
        the DSKPP client in the subsequent &lt;KeyProvClientHello&gt; request.
        The OPTIONAL &lt;TokenPlatformInfo&gt; element informs the DSKPP
        client about the characteristics of the intended cryptographic module
        platform, and applies in the public-key variant of DSKPP in situations
        when the client potentially needs to decide which one of several
        modules to initialize.
</p>
<a name="anchor37"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.3"></a><h3>4.3.&nbsp;
Components of the &lt;KeyProvClientHello&gt; Request</h3>

<p>This message is the initial message sent from the DSKPP client to
        the DSKPP server in both variations of the DSKPP.
</p>
<p>
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>&lt;xs:element name="KeyProvClientHello"
  type="dskpp:KeyProvClientHelloPDU"&gt;
&lt;/xs:element&gt;

&lt;xs:complexType name="KeyProvClientHelloPDU"&gt;
  &lt;xs:complexContent mixed="false"&gt;
    &lt;xs:extension base="dskpp:AbstractRequestType"&gt;
      &lt;xs:sequence&gt;
        &lt;xs:element minOccurs="0" name="DeviceIdentifierData"
          type="dskpp:DeviceIdentifierDataType" /&gt;
        &lt;xs:element minOccurs="0" name="KeyID"
          type="xs:base64Binary" /&gt;
        &lt;xs:element minOccurs="0" name="ClientNonce"
          type="dskpp:NonceType" /&gt;
        &lt;xs:element minOccurs="0" name="TriggerNonce"
          type="dskpp:NonceType" /&gt;
        &lt;xs:element name="SupportedKeyTypes"
          type="dskpp:AlgorithmsType" /&gt;
        &lt;xs:element name="SupportedEncryptionAlgorithms"
          type="dskpp:AlgorithmsType" /&gt;
        &lt;xs:element name="SupportedMacAlgorithms"
          type="dskpp:AlgorithmsType" /&gt;
        &lt;xs:element minOccurs="0" name="SupportedProtocolVariants"
          type="dskpp:ProtocolVariantsType" /&gt;
        &lt;xs:element minOccurs="0" name="SupportedKeyPackages"
          type="dskpp:KeyPackagesFormatType" /&gt;
        &lt;xs:element minOccurs="0" name="AuthenticationData"
          type="dskpp:AuthenticationDataType" /&gt;
        &lt;xs:element minOccurs="0" name="Extensions"
          type="dskpp:ExtensionsType" /&gt;
      &lt;/xs:sequence&gt;
    &lt;/xs:extension&gt;
  &lt;/xs:complexContent&gt;
&lt;/xs:complexType&gt;
</pre></div>
<p>
</p>
<p>The components of this message have the following meaning:
</p>
<p></p>
<ul class="text">
<li>Version: (attribute inherited from the AbstractRequestType
            type) The highest version of this protocol the client supports.
            Only version one ("1.0") is currently specified.
</li>
<li>&lt;DeviceIdentifierData&gt;: An identifier for the
            cryptographic module as defined in <a class='info' href='#Section-ClientAuthN'>Section&nbsp;3.7<span> (</span><span class='info'>User Authentication</span><span>)</span></a> above. The identifier MUST
            only be present if such shared secrets exist or if the identifier
            was provided by the server in a &lt;KeyProvTrigger&gt; element
            (see <a class='info' href='#Section-InitDSKPP'>Section&nbsp;6.2.7<span> (</span><span class='info'>Initialization of DSKPP</span><span>)</span></a>). In the latter
            case, it MUST have the same value as the identifier provided in
            that element.
</li>
<li>&lt;KeyID&gt;: An identifier for the key that will be
            overwritten if the protocol run is successful. The identifier MUST
            only be present if the key exists or if the identifier was
            provided by the server in a &lt;KeyProvTrigger&gt; element, in
            which case, it MUST have the same value as the identifier provided
            in that element (see <a class='info' href='#Section-Trigger'>a<span> (</span><span class='info'>Components of the &lt;KeyProvTrigger&gt; Message</span><span>)</span></a> and
            <a class='info' href='#Section-InitDSKPP'>Section&nbsp;6.2.7<span> (</span><span class='info'>Initialization of DSKPP</span><span>)</span></a>).
</li>
<li>&lt;ClientNonce&gt;: This is the nonce R, which, when present,
            MUST be used by the server when calculating MAC values (see
            below). It is RECOMMENDED that clients include this element
            whenever the &lt;KeyID&gt; element is present.
</li>
<li>&lt;TriggerNonce&gt;: This OPTIONAL element MUST be present if
            and only if the DSKPP run was initialized with a
            &lt;KeyProvTrigger&gt; message (see <a class='info' href='#Section-InitDSKPP'>Section&nbsp;6.2.7<span> (</span><span class='info'>Initialization of DSKPP</span><span>)</span></a>), and MUST, in that case, have
            the same value as the &lt;TriggerNonce&gt; child of that message.
            A server using nonces in this way MUST verify that the nonce is
            valid and that any device or key identifier values provided in the
            &lt;KeyProvTrigger&gt; message match the corresponding identifier
            values in the &lt;KeyProvClientHello&gt; message.
</li>
<li>&lt;SupportedKeyTypes&gt;: A sequence of container elements
            that in turn contain URLs indicating the key types for which the
            cryptographic module is willing to generate keys through
            DSKPP.
</li>
<li>&lt;SupportedEncryptionAlgorithms&gt;: A sequence of container
            elements that in turn contain URLs indicating the encryption
            algorithms supported by the cryptographic module for the purposes
            of DSKPP. The DSKPP client MAY indicate the same algorithm both as
            a supported key type and as an encryption algorithm.
</li>
<li>&lt;SupportedMacAlgorithms&gt;: A sequence of container
            elements that in turn contain URLs indicating the MAC algorithms
            supported by the cryptographic module for the purposes of DSKPP.
            The DSKPP client MAY indicate the same algorithm both as an
            encryption algorithm and as a MAC algorithm (e.g.,
            http://www.ietf.org/keyprov/dskpp#dskpp-prf-aes-128, which is
            defined in <a class='info' href='#Section-PRFRealizations'>Appendix&nbsp;C<span> (</span><span class='info'>Example of DSKPP-PRF Realizations</span><span>)</span></a>).
</li>
<li>&lt;SupportedProtocolVariants&gt;: This OPTIONAL element is
            used by the DSKPP client to indicate support for four-pass or
            two-pass DSKPP. If two-pass support is specified, then
            &lt;KeyProvClientNonce&gt; MUST be set to nonce R in the
            &lt;KeyProvClientHello&gt; message unless &lt;TriggerNonce&gt; is
            already present.
</li>
<li>&lt;SupportedKeyPackages&gt;: This OPTIONAL element is a
            sequence of container elements that in turn contain URLs
            indicating the key package formats supported by the DSKPP client.
            If this element is not provided, then the DSKPP server MUST
            proceed with "http://www.ietf.org/keyprov/pskc#KeyContainer" (see
            <a class='info' href='#PSKC'>[PSKC]<span> (</span><span class='info'>, &ldquo;Portable Symmetric Key Container,&rdquo; 2008.</span><span>)</span></a>).
</li>
<li>&lt;AuthenticationData&gt;: This OPTIONAL element contains data
            that the DSKPP client uses to authenticate the user or device to
            the DSKPP server. The element is set as specified in <a class='info' href='#Section-ClientAuthN'>Section&nbsp;3.7<span> (</span><span class='info'>User Authentication</span><span>)</span></a>.
</li>
<li>&lt;Extensions&gt;: A sequence of OPTIONAL extensions. One
            extension is defined for this message in this version of DSKPP:
            the ClientInfoType (see <a class='info' href='#Section-ProtocolExts'>Section&nbsp;5<span> (</span><span class='info'>Protocol Extensions</span><span>)</span></a>).
</li>
</ul>

<p>Some of the core elements of the message are described below.
</p>
<a name="anchor38"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.3.1"></a><h3>4.3.1.&nbsp;
The DeviceIdentifierDataType Type</h3>

<p>The DeviceIdentifierDataType type is used to uniquely identify
          the device that houses the cryptographic module, e.g., a mobile
          phone. The device identifier allows the DSKPP server to find, e.g.,
          a pre-shared key transport key for 2-pass DSKPP and/or the correct
          shared secret for MAC'ing purposes. The default
          DeviceIdentifierDataType is defined in <a class='info' href='#PSKC'>[PSKC]<span> (</span><span class='info'>, &ldquo;Portable Symmetric Key Container,&rdquo; 2008.</span><span>)</span></a>.
</p>
<p>
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>&lt;xs:complexType name="DeviceIdentifierDataType"&gt;
  &lt;xs:choice&gt;
    &lt;xs:element name="DeviceId" type="pskc:DeviceIdType" /&gt;
    &lt;xs:any namespace="##other" processContents="strict" /&gt;
  &lt;/xs:choice&gt;
&lt;/xs:complexType&gt;
</pre></div>
<p>
</p>
<a name="anchor39"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.3.2"></a><h3>4.3.2.&nbsp;
The ProtocolVariantsType Type</h3>

<p>The ProtocolVariantsType is a complex type that is a sequence of
          elements, each describing a DSKPP protocol variant. The DSKPP client
          MAY use the ProtocolVariantsType to identify which protocol variants
          it supports, i.e., by providing &lt;SupportProtocolVariants&gt;
          within a &lt;KeyProvClientHello&gt; message.
</p>
<p>Selecting the &lt;FourPass&gt; element signals client support for
          4-pass DSKPP as described in <a class='info' href='#Subsection-4PassFlow'>Section&nbsp;3.4.1<span> (</span><span class='info'>Message Flow</span><span>)</span></a>.
</p>
<p>Selecting the &lt;TwoPass&gt; element signals client support for
          the 2-pass version of DSKPP as described in <a class='info' href='#Subsection-2PassFlow'>Section&nbsp;3.5.1<span> (</span><span class='info'>Message Flow</span><span>)</span></a>. The &lt;TwoPass&gt; element
          is of type KeyProtectionDataType, which carries information that
          informs the server of supported two-pass key protection methods as
          described in <a class='info' href='#Section-Profiles'>Section&nbsp;3.5.2<span> (</span><span class='info'>Key Protection Profiles</span><span>)</span></a>, and provides
          OPTIONAL payload data to the DSKPP server. The payload is sent in an
          opportunistic fashion, and MAY be discarded by the DSKPP server if
          the server does not support the key protection method with which the
          payload is associated.
</p>
<p>If the DSKPP client does not include
          &lt;SupportedProtocolVariants&gt; in the &lt;KeyProvClientHello&gt;
          message, then the DSKPP server MUST proceed by using the 4-pass
          DSKPP variant. If the DSKPP server does not support 4-pass DSKPP,
          then the server MUST use the two-pass protocol variant. If it cannot
          support the two-pass protocol variant, then the protocol run MUST
          fail.
</p>
<p>
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>   &lt;xs:complexType name="ProtocolVariantsType"&gt;
     &lt;xs:sequence&gt;
       &lt;xs:element name="FourPass" minOccurs="0" /&gt;
       &lt;xs:element name="TwoPass" type="dskpp:KeyProtectionDataType"
           minOccurs="0"/&gt;
     &lt;/xs:sequence&gt;
   &lt;/xs:complexType&gt;

   &lt;xs:complexType name="KeyProtectionDataType"&gt;
     &lt;xs:sequence maxOccurs="unbounded"&gt;
         &lt;xs:element name="SupportedKeyProtectionMethod" type="xs:anyURI"/&gt;
         &lt;xs:element name="Payload" type="dskpp:PayloadType" minOccurs="0"/&gt;
     &lt;/xs:sequence&gt;
   &lt;/xs:complexType&gt;
</pre></div>
<p>
</p>
<p>The elements of this type have the following meaning:
</p>
<p></p>
<ul class="text">
<li>&lt;SupportedKeyProtectionMethod&gt;: A two-pass key
              protection method supported by the DSKPP client. Multiple
              supported methods MAY be present, in which case they MUST be
              listed in order of precedence.
</li>
<li>&lt;Payload&gt;: An OPTIONAL payload associated with each
              supported key protection method.
</li>
</ul>

<p>A DSKPP client that indicates support for two-pass DSKPP MUST
          also include the nonce R in its &lt;KeyProvClientHello&gt; message
          (this will enable the client to verify that the DSKPP server it is
          communicating with is alive).
</p>
<a name="anchor40"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.3.3"></a><h3>4.3.3.&nbsp;
The KeyPackagesFormatType Type</h3>

<p>The OPTIONAL KeyPackagesFormatType type is a list of type-value
          pairs that a DSKPP client or server MAY use to define key package
          formats it supports. Key package formats are identified through
          URLs, e.g., the PSKC KeyContainer URL
          "http://www.ietf.org/keyprov/pskc#KeyContainer" (see <a class='info' href='#PSKC'>[PSKC]<span> (</span><span class='info'>, &ldquo;Portable Symmetric Key Container,&rdquo; 2008.</span><span>)</span></a>).
</p>
<p>
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>&lt;xs:complexType name="KeyPackagesFormatType"&gt;
  &lt;xs:sequence maxOccurs="unbounded"&gt;
    &lt;xs:element name="KeyPackageFormat"
    type="dskpp:KeyPackageFormatType"/&gt;
  &lt;/xs:sequence&gt;

&lt;/xs:complexType&gt;
&lt;xs:simpleType name="KeyPackageFormatType"&gt;
  &lt;xs:restriction base="xs:anyURI" /&gt;
&lt;/xs:simpleType&gt;
</pre></div>
<p>
</p>
<a name="Section-AuthNData"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.3.4"></a><h3>4.3.4.&nbsp;
The AuthenticationDataType Type</h3>

<p>The OPTIONAL AuthenticationDataType type is used by DSKPP clients
          to carry authentication values in DSKPP messages as described in
          <a class='info' href='#Section-ClientAuthN'>Section&nbsp;3.7<span> (</span><span class='info'>User Authentication</span><span>)</span></a>.
</p>
<p>
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>&lt;xs:complexType name="AuthenticationDataType"&gt;
  &lt;xs:sequence&gt;
    &lt;xs:element name="ClientID"
      type="dskpp:IdentifierType" /&gt;
    &lt;xs:element name="AuthenticationCodeMac"
      type="dskpp:AuthenticationMacType" /&gt;
  &lt;/xs:sequence&gt;
&lt;/xs:complexType&gt;

&lt;xs:complexType name="AuthenticationMacType"&gt;
  &lt;xs:sequence&gt;
    &lt;xs:element minOccurs="0" name="Nonce" type="dskpp:NonceType" /&gt;
    &lt;xs:element minOccurs="0" name="IterationCount" type="xs:int" /&gt;
    &lt;xs:element name="Mac" type="dskpp:MacType" /&gt;
  &lt;/xs:sequence&gt;
&lt;/xs:complexType&gt;
</pre></div>
<p>
</p>
<p>The elements of the AuthenticationDataType type have the
          following meaning:
</p>
<p></p>
<ul class="text">
<li>&lt;ClientID&gt;: A requester's identifier of maximum length
              128. The value MAY be a user ID, a device ID, or a keyID
              associated with the requester's authentication value.
</li>
<li>&lt;AuthenticationCodeMac&gt;: An authentication MAC and
              additional information (e.g., MAC algorithm), derived as
              described in <a class='info' href='#Subsection-ADMAC'>Section&nbsp;3.7.3<span> (</span><span class='info'>Authentication Data Calculation</span><span>)</span></a>.
</li>
</ul>

<a name="anchor41"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.4"></a><h3>4.4.&nbsp;
Components of the &lt;KeyProvServerHello&gt; Response (Used Only in Four-Pass DSKPP)</h3>

<p>In a four-pass exchange, this message is the first message sent
        from the DSKPP server to the DSKPP client (assuming a trigger message
        has not been sent to initiate the protocol, in which case, this
        message is the second message sent from the DSKPP server to the DSKPP
        client). It is sent upon reception of a &lt;KeyProvClientHello&gt;
        message.
</p>
<p>
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>&lt;xs:element name="KeyProvServerHello"
  type="dskpp:KeyProvServerHelloPDU"&gt;
&lt;/xs:element&gt;
&lt;xs:complexType name="KeyProvServerHelloPDU"&gt;
  &lt;xs:complexContent mixed="false"&gt;
    &lt;xs:extension base="dskpp:AbstractResponseType"&gt;
      &lt;xs:sequence minOccurs="0"&gt;
        &lt;xs:element name="KeyType" type="dskpp:AlgorithmType" /&gt;
        &lt;xs:element name="EncryptionAlgorithm"
          type="dskpp:AlgorithmType" /&gt;
        &lt;xs:element name="MacAlgorithm" type="dskpp:AlgorithmType" /&gt;
        &lt;xs:element name="EncryptionKey" type="ds:KeyInfoType" /&gt;
        &lt;xs:element name="KeyPackageFormat"
          type="dskpp:KeyPackageFormatType" /&gt;
        &lt;xs:element name="Payload" type="dskpp:PayloadType" /&gt;
        &lt;xs:element minOccurs="0" name="Extensions"
          type="dskpp:ExtensionsType" /&gt;
        &lt;xs:element minOccurs="0" name="Mac" type="dskpp:MacType" /&gt;
      &lt;/xs:sequence&gt;
    &lt;/xs:extension&gt;
  &lt;/xs:complexContent&gt;
&lt;/xs:complexType&gt;
</pre></div>
<p>
</p>
<p>The components of this message have the following meaning:
</p>
<p></p>
<ul class="text">
<li>Version: (attribute inherited from the AbstractResponseType
            type) The version selected by the DSKPP server. MAY be lower than
            the version indicated by the DSKPP client, in which case, local
            policy at the client MUST determine whether or not to continue the
            session.
</li>
<li>SessionID: (attribute inherited from the AbstractResponseType
            type) An identifier for this session. The SessionID has a maximum
            length of 128.
</li>
<li>Status: (attribute inherited from the AbstractResponseType
            type) Return code for the &lt;KeyProvClientHello&gt;. If Status is
            not "Continue", only the Status and Version attributes will be
            present; otherwise, all the other element MUST be present as
            well.
</li>
<li>&lt;KeyType&gt;: The type of the key to be generated.
</li>
<li>&lt;EncryptionAlgorithm&gt;: The encryption algorithm to use
            when protecting R_C.
</li>
<li>&lt;MacAlgorithm&gt;: The MAC algorithm to be used by the DSKPP
            server.
</li>
<li>&lt;EncryptionKey&gt;: Information about the key to use when
            encrypting R_C. It will either be the server's public key (the
            &lt;ds:KeyValue&gt; alternative of ds:KeyInfoType) or an
            identifier for a shared secret key (the &lt;ds:KeyName&gt;
            alternative of ds:KeyInfoType).
</li>
<li>&lt;KeyPackageFormat&gt;: The key package format type to be
            used by the DSKPP server. The default setting relies on the
            KeyPackageType element defined in
            "urn:ietf:params:xml:schema:keyprov:pskc" <a class='info' href='#PSKC'>[PSKC]<span> (</span><span class='info'>, &ldquo;Portable Symmetric Key Container,&rdquo; 2008.</span><span>)</span></a>.
</li>
<li>&lt;Payload&gt;: The actual payload. For this version of the
            protocol, only one payload is defined: the pseudorandom string
            R_S.
</li>
<li>&lt;Extensions&gt;: A list of server extensions. Two extensions
            are defined for this message in this version of DSKPP: the
            ClientInfoType and the ServerInfoType (see <a class='info' href='#Section-ProtocolExts'>Section&nbsp;5<span> (</span><span class='info'>Protocol Extensions</span><span>)</span></a>).
</li>
<li>&lt;Mac&gt;: The MAC MUST be present if the DSKPP run will
            result in the replacement of an existing symmetric key with a new
            one (i.e., if the &lt;KeyID&gt; element was present in the
            &lt;ClientHello message). In this case, the DSKPP server MUST
            prove to the cryptographic module that it is authorized to replace
            it.
</li>
</ul>

<a name="anchor42"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.5"></a><h3>4.5.&nbsp;
Components of a &lt;KeyProvClientNonce&gt; Request (Used Only in Four-Pass DSKPP)</h3>

<p>In a four-pass DSKPP exchange, this message contains the nonce R_C
        that was chosen by the cryptographic module, and encrypted by the
        negotiated encryption key and encryption algorithm.
</p>
<p>
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>&lt;xs:element name="KeyProvClientNonce"
  type="dskpp:KeyProvClientNoncePDU"&gt;
&lt;/xs:element&gt;
&lt;xs:complexType name="KeyProvClientNoncePDU"&gt;
  &lt;xs:complexContent mixed="false"&gt;
    &lt;xs:extension base="dskpp:AbstractRequestType"&gt;
      &lt;xs:sequence&gt;
        &lt;xs:element name="EncryptedNonce" type="xs:base64Binary" /&gt;
        &lt;xs:element minOccurs="0" name="AuthenticationData"
          type="dskpp:AuthenticationDataType" /&gt;
        &lt;xs:element minOccurs="0" name="Extensions"
          type="dskpp:ExtensionsType" /&gt;
      &lt;/xs:sequence&gt;
      &lt;xs:attribute name="SessionID" type="dskpp:IdentifierType"
        use="required" /&gt;
    &lt;/xs:extension&gt;
  &lt;/xs:complexContent&gt;
&lt;/xs:complexType&gt;
</pre></div>
<p>
</p>
<p>The components of this message have the following meaning:
</p>
<p></p>
<ul class="text">
<li>Version: (inherited from the AbstractRequestType type) MUST be
            the same version as in the &lt;KeyProvServerHello&gt; message.
</li>
<li>&lt;SessionID&gt;: (attribute inherited from the
            AbstractResponseType type) MUST have the same value as the
            SessionID attribute in the received &lt;KeyProvServerHello&gt;
            message. SessionID has maximum length of 128.
</li>
<li>&lt;EncryptedNonce&gt;: The nonce generated and encrypted by
            the cryptographic module. The encryption MUST be made using the
            selected encryption algorithm and identified key, and as specified
            in <a class='info' href='#DSKPP-PRF'>Section&nbsp;3.3.1<span> (</span><span class='info'>The DSKPP One-Way Pseudorandom Function, DSKPP-PRF</span><span>)</span></a>.
</li>
<li>&lt;AuthenticationData&gt;: The authentication data value MUST
            be set as specified in <a class='info' href='#Section-ClientAuthN'>Section&nbsp;3.7<span> (</span><span class='info'>User Authentication</span><span>)</span></a>
            and <a class='info' href='#Section-AuthNData'>Section&nbsp;4.3.4<span> (</span><span class='info'>The AuthenticationDataType Type</span><span>)</span></a>.
</li>
<li>&lt;Extensions&gt;: A list of OPTIONAL extensions. Two
            extensions are defined for this message in this version of DSKPP:
            the ClientInfoType and the ServerInfoType (see <a class='info' href='#Section-ProtocolExts'>Section&nbsp;5<span> (</span><span class='info'>Protocol Extensions</span><span>)</span></a>).
</li>
</ul>

<a name="anchor43"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.6"></a><h3>4.6.&nbsp;
Components of a &lt;KeyProvServerFinished&gt; Response</h3>

<p>This message is the last message of the DSKPP protocol run. In a
        4-pass exchange, the DSKPP server sends this message in response to a
        &lt;KeyProvClientNonce&gt; message, whereas in a 2-pass exchange, the
        DSKPP server sends this message in response to a
        &lt;KeyProvClientHello&gt; message.
</p>
<p>
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>&lt;xs:element name="KeyProvServerFinished"
  type="dskpp:KeyProvServerFinishedPDU"&gt;
&lt;/xs:element&gt;
&lt;xs:complexType name="KeyProvServerFinishedPDU"&gt;
  &lt;xs:complexContent mixed="false"&gt;
    &lt;xs:extension base="dskpp:AbstractResponseType"&gt;
      &lt;xs:sequence minOccurs="0"&gt;
        &lt;xs:element name="KeyPackage"
          type="dskpp:KeyPackageType" /&gt;
        &lt;xs:element minOccurs="0" name="Extensions"
          type="dskpp:ExtensionsType" /&gt;
        &lt;xs:element name="Mac" type="dskpp:MacType" /&gt;
        &lt;xs:element minOccurs="0" name="AuthenticationData"
          type="dskpp:AuthenticationMacType" /&gt;
      &lt;/xs:sequence&gt;
    &lt;/xs:extension&gt;
  &lt;/xs:complexContent&gt;
&lt;/xs:complexType&gt;
</pre></div>
<p>
</p>
<p>The components of this message have the following meaning:
</p>
<p></p>
<ul class="text">
<li>Version: (inherited from the AbstractResponseType type) The
            DSKPP version used in this session.
</li>
<li>SessionID: (inherited from the AbstractResponseType type) The
            previously established identifier for this session. The SessionID
            is of maximum length 128.
</li>
<li>Status: (inherited from the AbstractResponseType type) Return
            code for the &lt;KeyProvServerFinished&gt; message. If Status is
            not "Success", only the Status, SessionID, and Version attributes
            will be present (the presence of the SessionID attribute is
            dependent on the type of reported error); otherwise, all the other
            elements MUST be present as well. In this latter case, the
            &lt;KeyProvServerFinished&gt; message can be seen as a "Commit"
            message, instructing the cryptographic module to store the
            generated key and associate the given key identifier with this
            key.
</li>
<li>&lt;KeyPackage&gt;: The key package containing keying material
            in accordance with four- and two-pass DSKPP usage (see <a class='info' href='#Subsection-FourPassUsage'>Section&nbsp;3.4<span> (</span><span class='info'>Four-Pass Protocol Usage</span><span>)</span></a> and <a class='info' href='#Subsecton-TwoPass'>Section&nbsp;3.5<span> (</span><span class='info'>Two-Pass Protocol Usage</span><span>)</span></a>). The default package format is
            based on the KeyContainerType type from PSKC, as defined in <a class='info' href='#PSKC'>[PSKC]<span> (</span><span class='info'>, &ldquo;Portable Symmetric Key Container,&rdquo; 2008.</span><span>)</span></a>.
</li>
<li>&lt;Extensions&gt;: A list of extensions chosen by the DSKPP
            server. For this message, this version of DSKPP defines one
            extension, the ClientInfoType (see <a class='info' href='#Section-ProtocolExts'>Section&nbsp;5<span> (</span><span class='info'>Protocol Extensions</span><span>)</span></a>).
</li>
<li>&lt;Mac&gt;: To avoid a false "Commit" message causing the
            cryptographic module to end up in an initialized state for which
            the server does not know the stored key,
            &lt;KeyProvServerFinished&gt; messages MUST always be
            authenticated with a MAC. The MAC MUST be made using the already
            established MAC algorithm.
</li>
<li>&lt;AuthenticationData&gt;: This OPTIONAL element contains a
            MAC value that the DSKPP server provides in a two-pass message
            exchange as proof that the server is authorized to replace a key
            on the cryptographic module. The MAC MUST be calculated as
            specified in <a class='info' href='#Subsecton-TwoPass-ServerAuth'>Section&nbsp;3.5.3.2<span> (</span><span class='info'>Server Authentication in the Case of Key Renewal</span><span>)</span></a>.
</li>
</ul>

<a name="Subsection-StatusCodes"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.7"></a><h3>4.7.&nbsp;
The StatusCode Type</h3>

<p>The StatusCode type enumerates all possible return codes:
</p>
<p>
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>&lt;xs:simpleType name="StatusCode"&gt;
  &lt;xs:restriction base="xs:string"&gt;
    &lt;xs:enumeration value="Continue" /&gt;
    &lt;xs:enumeration value="Success" /&gt;
    &lt;xs:enumeration value="Abort" /&gt;
    &lt;xs:enumeration value="AccessDenied" /&gt;
    &lt;xs:enumeration value="MalformedRequest" /&gt;
    &lt;xs:enumeration value="UnknownRequest" /&gt;
    &lt;xs:enumeration value="UnknownCriticalExtension" /&gt;
    &lt;xs:enumeration value="UnsupportedVersion" /&gt;
    &lt;xs:enumeration value="NoSupportedKeyTypes" /&gt;
    &lt;xs:enumeration value="NoSupportedEncryptionAlgorithms" /&gt;
    &lt;xs:enumeration value="NoSupportedMacAlgorithms" /&gt;
    &lt;xs:enumeration value="NoProtocolVariants" /&gt;
    &lt;xs:enumeration value="NoSupportedKeyPackages" /&gt;
    &lt;xs:enumeration value="AuthenticationDataMissing" /&gt;
    &lt;xs:enumeration value="AuthenticationDataInvalid" /&gt;
    &lt;xs:enumeration value="InitializationFailed" /&gt;
  &lt;/xs:restriction&gt;
&lt;/xs:simpleType&gt;
</pre></div>
<p>
</p>
<p>Upon transmission or receipt of a message for which the Status
        attribute's value is not "Success" or "Continue", the default
        behavior, unless explicitly stated otherwise below, is that both the
        DSKPP server and the DSKPP client MUST immediately terminate the DSKPP
        protocol run. DSKPP servers and DSKPP clients MUST delete any secret
        values generated as a result of failed runs of the DSKPP protocol.
        Session identifiers MAY be retained from successful or failed protocol
        runs for replay detection purposes, but such retained identifiers MUST
        NOT be reused for subsequent runs of the protocol.
</p>
<p>When possible, the DSKPP client SHOULD present an appropriate error
        message to the user.
</p>
<p>These status codes are valid in all DSKPP Response messages unless
        explicitly stated otherwise:
</p>
<p></p>
<ul class="text">
<li>"Continue" indicates that the DSKPP server is ready for a
            subsequent request from the DSKPP client. It cannot be sent in the
            server's final message.
</li>
<li>"Success" indicates successful completion of the DSKPP session.
            It can only be sent in the server's final message.
</li>
<li>"Abort" indicates that the DSKPP server rejected the DSKPP
            client's request for unspecified reasons.
</li>
<li>"AccessDenied" indicates that the DSKPP client is not
            authorized to contact this DSKPP server.
</li>
<li>"MalformedRequest" indicates that the DSKPP server failed to
            parse the DSKPP client's request.
</li>
<li>"UnknownRequest" indicates that the DSKPP client made a request
            that is unknown to the DSKPP server.
</li>
<li>"UnknownCriticalExtension" indicates that a critical DSKPP
            extension (see below) used by the DSKPP client was not supported
            or recognized by the DSKPP server.
</li>
<li>"UnsupportedVersion" indicates that the DSKPP client used a
            DSKPP protocol version not supported by the DSKPP server. This
            error is only valid in the DSKPP server's first response
            message.
</li>
<li>"NoSupportedKeyTypes" indicates that the DSKPP client only
            suggested key types that are not supported by the DSKPP server.
            This error is only valid in the DSKPP server's first response
            message.
</li>
<li>"NoSupportedEncryptionAlgorithms" indicates that the DSKPP
            client only suggested encryption algorithms that are not supported
            by the DSKPP server. This error is only valid in the DSKPP
            server's first response message.
</li>
<li>"NoSupportedMacAlgorithms" indicates that the DSKPP client only
            suggested MAC algorithms that are not supported by the DSKPP
            server. This error is only valid in the DSKPP server's first
            response message.
</li>
<li>"NoProtocolVariants" indicates that the DSKPP client only
            suggested a protocol variation (either 2-pass or 4-pass) that is
            not supported by the DSKPP server. This error is only valid in the
            DSKPP server's first response message.
</li>
<li>"NoSupportedKeyPackages" indicates that the DSKPP client only
            suggested key package formats that are not supported by the DSKPP
            server. This error is only valid in the DSKPP server's first
            response message.
</li>
<li>"AuthenticationDataMissing" indicates that the DSKPP client
            didn't provide authentication data that the DSKPP server
            required.
</li>
<li>"AuthenticationDataInvalid" indicates that the DSKPP client
            supplied user authentication data that the DSKPP server failed to
            validate.
</li>
<li>"InitializationFailed" indicates that the DSKPP server could
            not generate a valid key given the provided data. When this status
            code is received, the DSKPP client SHOULD try to restart DSKPP, as
            it is possible that a new run will succeed.
</li>
<li>"ProvisioningPeriodExpired" indicates that the provisioning
            period set by the DSKPP server has expired. When the status code
            is received, the DSKPP client SHOULD report the reason for key
            initialization failure to the user and the user MUST register with
            the DSKPP server to initialize a new key.
</li>
</ul>

<a name="Section-ProtocolExts"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5"></a><h3>5.&nbsp;
Protocol Extensions</h3>

<a name="anchor44"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.1"></a><h3>5.1.&nbsp;
The ClientInfoType Type</h3>

<p>Present in a &lt;KeyProvClientHello&gt; or a
        &lt;KeyProvClientNonce&gt; message, the OPTIONAL ClientInfoType
        extension contains DSKPP client-specific information that is custom to
        an implementation. DSKPP servers MUST support this extension. DSKPP
        servers MUST NOT attempt to interpret the data it carries and, if
        received, MUST include it unmodified in the current protocol run's
        next server response. Servers need not retain the ClientInfoType's
        data after that response has been generated.
</p>
<a name="anchor45"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.2"></a><h3>5.2.&nbsp;
The ServerInfoType Type</h3>

<p>When present, the OPTIONAL ServerInfoType extension contains DSKPP
        server-specific information that is custom to an implementation. This
        extension is only valid in &lt;KeyProvServerHello&gt; messages for
        which Status = "Continue". DSKPP clients MUST support this extension.
        DSKPP clients MUST NOT attempt to interpret the data it carries and,
        if received, MUST include it unmodified in the current protocol run's
        next client request (i.e., the &lt;KeyProvClientNonce&gt; message).
        DSKPP clients need not retain the ServerInfoType's data after that
        request has been generated. This extension MAY be used, e.g., for
        state management in the DSKPP server.
</p>
<a name="Section-Bindings"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6"></a><h3>6.&nbsp;
Protocol Bindings</h3>

<a name="anchor46"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.1"></a><h3>6.1.&nbsp;
General Requirements</h3>

<p>DSKPP assumes a reliable transport.
</p>
<a name="anchor47"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.2"></a><h3>6.2.&nbsp;
HTTP/1.1 Binding for DSKPP</h3>

<a name="anchor48"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.2.1"></a><h3>6.2.1.&nbsp;
Introduction</h3>

<p>This section presents a binding of the previous messages to
          HTTP/1.1 <a class='info' href='#RFC2616'>[RFC2616]<span> (</span><span class='info'>Fielding, R., Gettys, J., Mogul, J., Frystyk, H., Masinter, L., Leach, P., and T. Berners-Lee, &ldquo;Hypertext Transfer Protocol -- HTTP/1.1,&rdquo; June&nbsp;1999.</span><span>)</span></a>. Note that the HTTP client
          normally will be different from the DSKPP client, i.e., the HTTP
          client will only exist to "proxy" DSKPP messages from the DSKPP
          client to the DSKPP server. Likewise, on the HTTP server side, the
          DSKPP server MAY receive DSKPP PDUs from a "front-end" HTTP server.
          The DSKPP server will be identified by a specific URL, which may be
          pre-configured, or provided to the client during initialization.
</p>
<a name="Subsection-ContentType"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.2.2"></a><h3>6.2.2.&nbsp;
Identification of DSKPP Messages</h3>

<p>The MIME-type for all DSKPP messages MUST be
</p>
<p>application/vnd.ietf.keyprov.dskpp+xml
</p>
<a name="anchor49"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.2.3"></a><h3>6.2.3.&nbsp;
HTTP Headers</h3>

<p>In order to avoid caching of responses carrying DSKPP messages by
          proxies, the following holds:
</p>
<p></p>
<ul class="text">
<li>When using HTTP/1.1, requesters SHOULD:
<ul class="text">
<li>Include a Cache-Control header field set to "no-cache,
                  no-store".
</li>
<li>Include a Pragma header field set to "no-cache".<br />
<br />

</li>
</ul>
</li>
<li>When using HTTP/1.1, responders SHOULD:
<ul class="text">
<li>Include a Cache-Control header field set to "no-cache,
                  no-must-revalidate, private".
</li>
<li>Include a Pragma header field set to "no-cache".
</li>
<li>NOT include a Validator, such as a Last-Modified or ETag
                  header.
</li>
</ul>
</li>
</ul>

<p>To handle content negotiation, HTTP requests MAY include an HTTP
          Accept header field. This header field SHOULD have the value
          application/vnd.ietf.keyprov.dskpp+xml as defined in <a class='info' href='#Subsection-ContentType'>Section&nbsp;6.2.2<span> (</span><span class='info'>Identification of DSKPP Messages</span><span>)</span></a>. The Accept header MAY
          include additional content types defined by future versions of this
          protocol.
</p>
<p>There are no other restrictions on HTTP headers, besides the
          requirement to set the Content-Type header value according to <a class='info' href='#Subsection-ContentType'>Section&nbsp;6.2.2<span> (</span><span class='info'>Identification of DSKPP Messages</span><span>)</span></a>.
</p>
<a name="anchor50"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.2.4"></a><h3>6.2.4.&nbsp;
HTTP Operations</h3>

<p>Persistent connections as defined in HTTP/1.1 are OPTIONAL. DSKPP
          requests are mapped to HTTP requests with the POST method. DSKPP
          responses are mapped to HTTP responses.
</p>
<p>For the 4-pass DSKPP, messages within the protocol run are bound
          together. In particular, &lt;KeyProvServerHello&gt; is bound to the
          preceding &lt;KeyProvClientHello&gt; by being transmitted in the
          corresponding HTTP response. &lt;KeyProvServerHello&gt; MUST have a
          SessionID attribute, and the SessionID attribute of the subsequent
          &lt;KeyProvClientNonce&gt; message MUST be identical.
          &lt;KeyProvServerFinished&gt; is then once again bound to the rest
          through HTTP (and possibly through a SessionID).
</p>
<a name="anchor51"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.2.5"></a><h3>6.2.5.&nbsp;
HTTP Status Codes</h3>

<p>A DSKPP HTTP responder that refuses to perform a message exchange
          with a DSKPP HTTP requester SHOULD return a 403 (Forbidden)
          response. In this case, the content of the HTTP body is not
          significant. In the case of an HTTP error while processing a DSKPP
          request, the HTTP server MUST return a 500 (Internal Server Error)
          response. This type of error SHOULD be returned for HTTP-related
          errors detected before control is passed to the DSKPP processor, or
          when the DSKPP processor reports an internal error (for example, the
          DSKPP XML namespace is incorrect, or the DSKPP schema cannot be
          located). If a request is received that is not a DSKPP client
          message, the DSKPP responder MUST return a 400 (Bad request)
          response.
</p>
<p>In these cases (i.e., when the HTTP response code is 4xx or 5xx),
          the content of the HTTP body is not significant.
</p>
<p>Redirection status codes (3xx) apply as usual.
</p>
<p>Whenever the HTTP POST is successfully invoked, the DSKPP HTTP
          responder MUST use the 200 status code and provide a suitable DSKPP
          message (possibly with DSKPP error information included) in the HTTP
          body.
</p>
<a name="anchor52"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.2.6"></a><h3>6.2.6.&nbsp;
HTTP Authentication</h3>

<p>No support for HTTP/1.1 authentication is assumed.
</p>
<a name="Section-InitDSKPP"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.2.7"></a><h3>6.2.7.&nbsp;
Initialization of DSKPP</h3>

<p>If a user requests key initialization in a browsing session, and
          if that request has an appropriate Accept header (e.g., to a
          specific DSKPP server URL), the DSKPP server MAY respond by sending
          a DSKPP initialization message in an HTTP response with Content-Type
          set according to <a class='info' href='#Subsection-ContentType'>Section&nbsp;6.2.2<span> (</span><span class='info'>Identification of DSKPP Messages</span><span>)</span></a> and
          response code set to 200 (OK). The initialization message MAY carry
          data in its body, such as the URL for the DSKPP client to use when
          contacting the DSKPP server. If the message does carry data, the
          data MUST be a valid instance of a &lt;KeyProvTrigger&gt;
          element.
</p>
<p>Note that if the user's request was directed to some other
          resource, the DSKPP server MUST NOT respond by combining the DSKPP
          content type with response code 200. In that case, the DSKPP server
          SHOULD respond by sending a DSKPP initialization message in an HTTP
          response with Content-Type set according to <a class='info' href='#Subsection-ContentType'>Section&nbsp;6.2.2<span> (</span><span class='info'>Identification of DSKPP Messages</span><span>)</span></a> and response code set to 406
          (Not Acceptable).
</p>
<a name="anchor53"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.2.8"></a><h3>6.2.8.&nbsp;
Example Messages</h3>

<p></p>
<blockquote class="text"><dl>
<dt>a.</dt>
<dd>Initialization from DSKPP server:
</dd>
</dl></blockquote>
<blockquote class="text">
<p><p>HTTP/1.1 200 OK<br />
<br />
Cache-Control: no-store<br />
Content-Type:
              application/vnd.ietf.keyprov.dskpp+xml<br />
Content-Length: &lt;some value&gt;<br />
<br />
DSKPP initialization data in XML form...
</p>
</blockquote>

<p></p>
<blockquote class="text"><dl>
<dt>b.</dt>
<dd>Initial request from DSKPP client:
</dd>
</dl></blockquote>
<blockquote class="text">
<p><p>POST http://example.com/cgi-bin/DSKPP-server HTTP/1.1<br />
<br />
Cache-Control: no-cache, no-store<br />
Pragma: no-cache<br />
Host:
              www.example.com<br />
Content-Type:
              application/vnd.ietf.keyprov.dskpp+xml<br />
Content-Length: &lt;some value&gt;<br />
<br />
DSKPP data in XML form (supported version,
              supported algorithms...)
</p>
</blockquote>

<p></p>
<blockquote class="text"><dl>
<dt>c.</dt>
<dd>Initial response from DSKPP server:
</dd>
</dl></blockquote>
<blockquote class="text">
<p><p>HTTP/1.1 200 OK<br />
<br />
Cache-Control: no-cache, no-must-revalidate,
              private<br />
Pragma: no-cache<br />
Content-Type:
              application/vnd.ietf.keyprov.dskpp+xml<br />
Content-Length: &lt;some value&gt;<br />
<br />
DSKPP data in XML form (server random nonce,
              server public key, ...)
</p>
</blockquote>

<a name="Section-Schema"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7"></a><h3>7.&nbsp;
DSKPP Schema</h3>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
   &lt;?xml version="1.0" encoding="utf-8"?&gt;

   &lt;xs:schema
      xmlns:xs="http://www.w3.org/2001/XMLSchema"
      xmlns:dskpp="urn:ietf:params:xml:ns:keyprov:dskpp:1.0"
      xmlns:pskc="urn:ietf:params:xml:ns:keyprov:pskc:1.0"
      xmlns:ds="http://www.w3.org/2000/09/xmldsig#"
      targetNamespace="urn:ietf:params:xml:ns:keyprov:dskpp:1.0"
      elementFormDefault="qualified" attributeFormDefault="unqualified"
         version="1.0"&gt;
      &lt;xs:import namespace="http://www.w3.org/2000/09/xmldsig#"
         schemaLocation=
         "http://www.w3.org/TR/2002/REC-xmldsig-core-20020212/xmldsig-core-schema.xsd"/&gt;
      &lt;xs:import namespace="urn:ietf:params:xml:ns:keyprov:pskc:1.0"
         schemaLocation="keyprov-pskc-1.0.xsd"/&gt;
      &lt;xs:complexType name="AbstractRequestType" abstract="true"&gt;
         &lt;xs:annotation&gt;
            &lt;xs:documentation&gt; Basic types &lt;/xs:documentation&gt;
         &lt;/xs:annotation&gt;
         &lt;xs:attribute name="Version" type="dskpp:VersionType"
            use="required"/&gt;
      &lt;/xs:complexType&gt;

      &lt;xs:complexType name="AbstractResponseType" abstract="true"&gt;
         &lt;xs:annotation&gt;
            &lt;xs:documentation&gt; Basic types &lt;/xs:documentation&gt;
         &lt;/xs:annotation&gt;
         &lt;xs:attribute name="Version" type="dskpp:VersionType"
            use="required"/&gt;
         &lt;xs:attribute name="SessionID" type="dskpp:IdentifierType" /&gt;
         &lt;xs:attribute name="Status" type="dskpp:StatusCode" use="required"/&gt;
      &lt;/xs:complexType&gt;

      &lt;xs:simpleType name="VersionType"&gt;
         &lt;xs:restriction base="xs:string"&gt;
            &lt;xs:pattern value="\d{1,2}\.\d{1,3}" /&gt;
         &lt;/xs:restriction&gt;
      &lt;/xs:simpleType&gt;

      &lt;xs:simpleType name="IdentifierType"&gt;
         &lt;xs:restriction base="xs:string"&gt;
            &lt;xs:maxLength value="128" /&gt;
         &lt;/xs:restriction&gt;
      &lt;/xs:simpleType&gt;

      &lt;xs:simpleType name="StatusCode"&gt;
         &lt;xs:restriction base="xs:string"&gt;
            &lt;xs:enumeration value="Continue" /&gt;
            &lt;xs:enumeration value="Success" /&gt;
            &lt;xs:enumeration value="Abort" /&gt;
            &lt;xs:enumeration value="AccessDenied" /&gt;
            &lt;xs:enumeration value="MalformedRequest" /&gt;
            &lt;xs:enumeration value="UnknownRequest" /&gt;
            &lt;xs:enumeration value="UnknownCriticalExtension" /&gt;
            &lt;xs:enumeration value="UnsupportedVersion" /&gt;
            &lt;xs:enumeration value="NoSupportedKeyTypes" /&gt;
            &lt;xs:enumeration value="NoSupportedEncryptionAlgorithms" /&gt;
            &lt;xs:enumeration value="NoSupportedMacAlgorithms" /&gt;
            &lt;xs:enumeration value="NoProtocolVariants" /&gt;
            &lt;xs:enumeration value="NoSupportedKeyPackages" /&gt;
            &lt;xs:enumeration value="AuthenticationDataMissing" /&gt;
            &lt;xs:enumeration value="AuthenticationDataInvalid" /&gt;
            &lt;xs:enumeration value="InitializationFailed" /&gt;
         &lt;/xs:restriction&gt;
      &lt;/xs:simpleType&gt;

      &lt;xs:complexType name="DeviceIdentifierDataType"&gt;
         &lt;xs:choice&gt;
            &lt;xs:element name="DeviceId" type="pskc:DeviceIdType" /&gt;
            &lt;xs:any namespace="##other" processContents="strict" /&gt;
         &lt;/xs:choice&gt;
      &lt;/xs:complexType&gt;

      &lt;xs:simpleType name="PlatformType"&gt;
         &lt;xs:restriction base="xs:string"&gt;
            &lt;xs:enumeration value="Hardware" /&gt;
            &lt;xs:enumeration value="Software" /&gt;
            &lt;xs:enumeration value="Unspecified" /&gt;
         &lt;/xs:restriction&gt;
      &lt;/xs:simpleType&gt;

      &lt;xs:complexType name="TokenPlatformInfoType"&gt;
         &lt;xs:attribute name="KeyLocation" type="dskpp:PlatformType"/&gt;
         &lt;xs:attribute name="AlgorithmLocation" type="dskpp:PlatformType"/&gt;
      &lt;/xs:complexType&gt;

      &lt;xs:simpleType name="NonceType"&gt;
         &lt;xs:restriction base="xs:base64Binary"&gt;
            &lt;xs:minLength value="16" /&gt;
         &lt;/xs:restriction&gt;
      &lt;/xs:simpleType&gt;

      &lt;xs:complexType name="AlgorithmsType"&gt;
         &lt;xs:sequence maxOccurs="unbounded"&gt;
            &lt;xs:element name="Algorithm" type="dskpp:AlgorithmType" /&gt;
         &lt;/xs:sequence&gt;
      &lt;/xs:complexType&gt;

      &lt;xs:simpleType name="AlgorithmType"&gt;
         &lt;xs:restriction base="xs:anyURI" /&gt;
      &lt;/xs:simpleType&gt;

      &lt;xs:complexType name="ProtocolVariantsType"&gt;
         &lt;xs:sequence&gt;
            &lt;xs:element name="FourPass" minOccurs="0" /&gt;
            &lt;xs:element name="TwoPass" type="dskpp:KeyProtectionDataType"
               minOccurs="0"/&gt;
         &lt;/xs:sequence&gt;
      &lt;/xs:complexType&gt;

      &lt;xs:complexType name="KeyProtectionDataType"&gt;
         &lt;xs:annotation&gt;
            &lt;xs:documentation xml:lang="en"&gt;
               This element is only valid for two-pass DSKPP.
            &lt;/xs:documentation&gt;
         &lt;/xs:annotation&gt;
         &lt;xs:sequence maxOccurs="unbounded"&gt;
            &lt;xs:element name="SupportedKeyProtectionMethod" type="xs:anyURI"/&gt;
            &lt;xs:element name="Payload" type="dskpp:PayloadType" minOccurs="0"/&gt;
         &lt;/xs:sequence&gt;
      &lt;/xs:complexType&gt;

      &lt;xs:complexType name="PayloadType"&gt;
         &lt;xs:choice&gt;
            &lt;xs:element name="Nonce" type="dskpp:NonceType" /&gt;
            &lt;xs:any namespace="##other" processContents="strict" /&gt;
         &lt;/xs:choice&gt;
      &lt;/xs:complexType&gt;

      &lt;xs:complexType name="KeyPackagesFormatType"&gt;
         &lt;xs:sequence maxOccurs="unbounded"&gt;
            &lt;xs:element name="KeyPackageFormat"
               type="dskpp:KeyPackageFormatType"/&gt;
         &lt;/xs:sequence&gt;
      &lt;/xs:complexType&gt;

      &lt;xs:simpleType name="KeyPackageFormatType"&gt;
         &lt;xs:restriction base="xs:anyURI" /&gt;
      &lt;/xs:simpleType&gt;

      &lt;xs:complexType name="AuthenticationDataType"&gt;
         &lt;xs:annotation&gt;
            &lt;xs:documentation xml:lang="en"&gt;
               Authentication data contains a MAC.
            &lt;/xs:documentation&gt;
         &lt;/xs:annotation&gt;
         &lt;xs:sequence&gt;
            &lt;xs:element name="ClientID"
               type="dskpp:IdentifierType" /&gt;
            &lt;xs:choice&gt;
               &lt;xs:element name="AuthenticationCodeMac"
                  type="dskpp:AuthenticationMacType"
               &lt;xs:any namespace="##other" processContents="strict" /&gt;
            &lt;/xs:choice&gt;
         &lt;/xs:sequence&gt;
      &lt;/xs:complexType&gt;

      &lt;xs:complexType name="AuthenticationMacType"&gt;
         &lt;xs:sequence&gt;
            &lt;xs:element minOccurs="0" name="Nonce" type="dskpp:NonceType" /&gt;
            &lt;xs:element minOccurs="0" name="IterationCount" type="xs:int" /&gt;
            &lt;xs:element name="Mac" type="dskpp:MacType" /&gt;
         &lt;/xs:sequence&gt;
      &lt;/xs:complexType&gt;

      &lt;xs:complexType name="MacType"&gt;
         &lt;xs:simpleContent&gt;
            &lt;xs:extension base="xs:base64Binary"&gt;
               &lt;xs:attribute name="MacAlgorithm" type="xs:anyURI" /&gt;
            &lt;/xs:extension&gt;
         &lt;/xs:simpleContent&gt;
      &lt;/xs:complexType&gt;

      &lt;xs:complexType name="KeyPackageType"&gt;
         &lt;xs:sequence&gt;
            &lt;xs:element minOccurs="0" name="ServerID" type="xs:anyURI" /&gt;
            &lt;xs:element minOccurs="0" name="KeyProtectionMethod"
               type="xs:anyURI" /&gt;
            &lt;xs:choice&gt;
               &lt;xs:element name="KeyPackage" type="pskc:KeyContainerType" /&gt;
               &lt;xs:any namespace="##other" processContents="strict" /&gt;
            &lt;/xs:choice&gt;
         &lt;/xs:sequence&gt;
      &lt;/xs:complexType&gt;

      &lt;xs:complexType name="InitializationTriggerType"&gt;
         &lt;xs:sequence&gt;
            &lt;xs:element minOccurs="0" name="DeviceIdentifierData"
               type="dskpp:DeviceIdentifierDataType" /&gt;
            &lt;xs:element minOccurs="0" name="KeyID" type="xs:base64Binary" /&gt;
            &lt;xs:element minOccurs="0" name="TokenPlatformInfo"
               type="dskpp:TokenPlatformInfoType" /&gt;
            &lt;xs:element name="TriggerNonce" type="dskpp:NonceType" /&gt;
            &lt;xs:element minOccurs="0" name="ServerUrl" type="xs:anyURI" /&gt;
            &lt;xs:any minOccurs="0" namespace="##other"
               processContents="strict" /&gt;
         &lt;/xs:sequence&gt;
      &lt;/xs:complexType&gt;

      &lt;xs:complexType name="ExtensionsType"&gt;
         &lt;xs:annotation&gt;
            &lt;xs:documentation&gt; Extension types &lt;/xs:documentation&gt;
         &lt;/xs:annotation&gt;
         &lt;xs:sequence maxOccurs="unbounded"&gt;
            &lt;xs:element name="Extension" type="dskpp:AbstractExtensionType" /&gt;
         &lt;/xs:sequence&gt;
      &lt;/xs:complexType&gt;

      &lt;xs:complexType name="AbstractExtensionType" abstract="true"&gt;
         &lt;xs:attribute name="Critical" type="xs:boolean" /&gt;
      &lt;/xs:complexType&gt;

      &lt;xs:complexType name="ClientInfoType"&gt;
         &lt;xs:complexContent mixed="false"&gt;
            &lt;xs:extension base="dskpp:AbstractExtensionType"&gt;
               &lt;xs:sequence&gt;
                  &lt;xs:element name="Data" type="xs:base64Binary" /&gt;
               &lt;/xs:sequence&gt;
            &lt;/xs:extension&gt;
         &lt;/xs:complexContent&gt;
      &lt;/xs:complexType&gt;

      &lt;xs:complexType name="ServerInfoType"&gt;
         &lt;xs:complexContent mixed="false"&gt;
            &lt;xs:extension base="dskpp:AbstractExtensionType"&gt;
               &lt;xs:sequence&gt;
                  &lt;xs:element name="Data" type="xs:base64Binary" /&gt;
               &lt;/xs:sequence&gt;
            &lt;/xs:extension&gt;
         &lt;/xs:complexContent&gt;
      &lt;/xs:complexType&gt;

      &lt;xs:element name="KeyProvTrigger" type="dskpp:KeyProvTriggerType"&gt;
         &lt;xs:annotation&gt;
            &lt;xs:documentation&gt; DSKPP PDUs &lt;/xs:documentation&gt;
         &lt;/xs:annotation&gt;
      &lt;/xs:element&gt;
      &lt;xs:complexType name="KeyProvTriggerType"&gt;
         &lt;xs:annotation&gt;
         &lt;xs:documentation xml:lang="en"&gt;
            Message used to trigger the device to initiate a
            DSKPP protocol run.
         &lt;/xs:documentation&gt;
         &lt;/xs:annotation&gt;
         &lt;xs:sequence&gt;
            &lt;xs:choice&gt;
               &lt;xs:element name="InitializationTrigger"
                  type="dskpp:InitializationTriggerType" /&gt;
               &lt;xs:any namespace="##other" processContents="strict" /&gt;
            &lt;/xs:choice&gt;
         &lt;/xs:sequence&gt;
         &lt;xs:attribute name="Version" type="dskpp:VersionType" /&gt;
      &lt;/xs:complexType&gt;

      &lt;xs:element name="KeyProvClientHello"
         type="dskpp:KeyProvClientHelloPDU"&gt;
         &lt;xs:annotation&gt;
            &lt;xs:documentation&gt; KeyProvClientHello PDU &lt;/xs:documentation&gt;
         &lt;/xs:annotation&gt;
      &lt;/xs:element&gt;
      &lt;xs:complexType name="KeyProvClientHelloPDU"&gt;
         &lt;xs:annotation&gt;
            &lt;xs:documentation xml:lang="en"&gt;
               Message sent from DSKPP client to DSKPP server to initiate a
               DSKPP session.
            &lt;/xs:documentation&gt;
         &lt;/xs:annotation&gt;
         &lt;xs:complexContent mixed="false"&gt;
            &lt;xs:extension base="dskpp:AbstractRequestType"&gt;
               &lt;xs:sequence&gt;
                  &lt;xs:element minOccurs="0" name="DeviceIdentifierData"
                     type="dskpp:DeviceIdentifierDataType" /&gt;
                  &lt;xs:element minOccurs="0" name="KeyID"
                     type="xs:base64Binary" /&gt;
                  &lt;xs:element minOccurs="0" name="ClientNonce"
                     type="dskpp:NonceType" /&gt;
                  &lt;xs:element minOccurs="0" name="TriggerNonce"
                     type="dskpp:NonceType" /&gt;
                  &lt;xs:element name="SupportedKeyTypes"
                     type="dskpp:AlgorithmsType" /&gt;
                  &lt;xs:element name="SupportedEncryptionAlgorithms"
                     type="dskpp:AlgorithmsType" /&gt;
                  &lt;xs:element name="SupportedMacAlgorithms"
                     type="dskpp:AlgorithmsType" /&gt;
                  &lt;xs:element minOccurs="0" name="SupportedProtocolVariants"
                     type="dskpp:ProtocolVariantsType" /&gt;
                  &lt;xs:element minOccurs="0" name="SupportedKeyPackages"
                     type="dskpp:KeyPackagesFormatType" /&gt;
                  &lt;xs:element minOccurs="0" name="AuthenticationData"
                     type="dskpp:AuthenticationDataType" /&gt;
                  &lt;xs:element minOccurs="0" name="Extensions"
                     type="dskpp:ExtensionsType" /&gt;
               &lt;/xs:sequence&gt;
            &lt;/xs:extension&gt;
         &lt;/xs:complexContent&gt;
      &lt;/xs:complexType&gt;

      &lt;xs:element name="KeyProvServerHello"
         type="dskpp:KeyProvServerHelloPDU"&gt;
         &lt;xs:annotation&gt;
            &lt;xs:documentation&gt; KeyProvServerHello PDU &lt;/xs:documentation&gt;
         &lt;/xs:annotation&gt;
      &lt;/xs:element&gt;
      &lt;xs:complexType name="KeyProvServerHelloPDU"&gt;
         &lt;xs:annotation&gt;
            &lt;xs:documentation xml:lang="en"&gt;
               Response message sent from DSKPP server to DSKPP client
               in four-pass DSKPP.
            &lt;/xs:documentation&gt;
         &lt;/xs:annotation&gt;
         &lt;xs:complexContent mixed="false"&gt;
            &lt;xs:extension base="dskpp:AbstractResponseType"&gt;
               &lt;xs:sequence minOccurs="0"&gt;
                  &lt;xs:element name="KeyType" type="dskpp:AlgorithmType" /&gt;
                  &lt;xs:element name="EncryptionAlgorithm"
                     type="dskpp:AlgorithmType" /&gt;
                  &lt;xs:element name="MacAlgorithm" type="dskpp:AlgorithmType" /&gt;
                  &lt;xs:element name="EncryptionKey" type="ds:KeyInfoType" /&gt;
                  &lt;xs:element name="KeyPackageFormat"
                     type="dskpp:KeyPackageFormatType" /&gt;
                  &lt;xs:element name="Payload" type="dskpp:PayloadType" /&gt;
                  &lt;xs:element minOccurs="0" name="Extensions"
                     type="dskpp:ExtensionsType" /&gt;
                  &lt;xs:element minOccurs="0" name="Mac" type="dskpp:MacType" /&gt;
               &lt;/xs:sequence&gt;
            &lt;/xs:extension&gt;
         &lt;/xs:complexContent&gt;
      &lt;/xs:complexType&gt;

      &lt;xs:element name="KeyProvClientNonce"
         type="dskpp:KeyProvClientNoncePDU"&gt;
         &lt;xs:annotation&gt;
            &lt;xs:documentation&gt; KeyProvClientNonce PDU &lt;/xs:documentation&gt;
         &lt;/xs:annotation&gt;
      &lt;/xs:element&gt;
      &lt;xs:complexType name="KeyProvClientNoncePDU"&gt;
         &lt;xs:annotation&gt;
            &lt;xs:documentation xml:lang="en"&gt;
               Response message sent from DSKPP client to
               DSKPP server in a four-pass DSKPP session.
            &lt;/xs:documentation&gt;
         &lt;/xs:annotation&gt;
         &lt;xs:complexContent mixed="false"&gt;
            &lt;xs:extension base="dskpp:AbstractRequestType"&gt;
               &lt;xs:sequence&gt;
                  &lt;xs:element name="EncryptedNonce" type="xs:base64Binary" /&gt;
                  &lt;xs:element minOccurs="0" name="AuthenticationData"
                     type="dskpp:AuthenticationDataType" /&gt;
                  &lt;xs:element minOccurs="0" name="Extensions"
                     type="dskpp:ExtensionsType" /&gt;
               &lt;/xs:sequence&gt;
               &lt;xs:attribute name="SessionID" type="dskpp:IdentifierType"
                  use="required" /&gt;
            &lt;/xs:extension&gt;
         &lt;/xs:complexContent&gt;
      &lt;/xs:complexType&gt;

      &lt;xs:element name="KeyProvServerFinished"
         type="dskpp:KeyProvServerFinishedPDU"&gt;
         &lt;xs:annotation&gt;
            &lt;xs:documentation&gt; KeyProvServerFinished PDU &lt;/xs:documentation&gt;
         &lt;/xs:annotation&gt;
      &lt;/xs:element&gt;
      &lt;xs:complexType name="KeyProvServerFinishedPDU"&gt;
         &lt;xs:annotation&gt;
            &lt;xs:documentation xml:lang="en"&gt;
               Final message sent from DSKPP server to DSKPP client in a DSKPP
               session. A MAC value serves for key confirmation, and optional
               AuthenticationData serves for server authentication.
            &lt;/xs:documentation&gt;
         &lt;/xs:annotation&gt;
         &lt;xs:complexContent mixed="false"&gt;
            &lt;xs:extension base="dskpp:AbstractResponseType"&gt;
               &lt;xs:sequence minOccurs="0"&gt;
                  &lt;xs:element name="KeyPackage"
                     type="dskpp:KeyPackageType" /&gt;
                  &lt;xs:element minOccurs="0" name="Extensions"
                     type="dskpp:ExtensionsType" /&gt;
                  &lt;xs:element name="Mac" type="dskpp:MacType" /&gt;
                  &lt;xs:element minOccurs="0" name="AuthenticationData"
                     type="dskpp:AuthenticationMacType" /&gt;
               &lt;/xs:sequence&gt;
            &lt;/xs:extension&gt;
         &lt;/xs:complexContent&gt;
      &lt;/xs:complexType&gt;
    &lt;/xs:schema&gt;

</pre></div>
<p>
</p>
<a name="anchor54"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.8"></a><h3>8.&nbsp;
Conformance Requirements</h3>

<p>In order to assure that all implementations of DSKPP can
      interoperate, the DSKPP server:
</p>
<p></p>
<blockquote class="text"><dl>
<dt>a.</dt>
<dd>MUST implement the four-pass variation of the protocol (<a class='info' href='#Subsection-FourPassUsage'>Section&nbsp;3.4<span> (</span><span class='info'>Four-Pass Protocol Usage</span><span>)</span></a>)<br />

</dd>
<dt>b.</dt>
<dd>MUST implement the two-pass variation of the protocol (<a class='info' href='#Subsecton-TwoPass'>Section&nbsp;3.5<span> (</span><span class='info'>Two-Pass Protocol Usage</span><span>)</span></a>)<br />

</dd>
<dt>c.</dt>
<dd>MUST support user authentication (<a class='info' href='#Section-ClientAuthN'>Section&nbsp;3.7<span> (</span><span class='info'>User Authentication</span><span>)</span></a>)<br />

</dd>
<dt>d.</dt>
<dd>MUST support the following Key Derivation Functions:
<ul class="text">
<li>DSKPP-PRF-AES DSKPP-PRF realization (<a class='info' href='#Section-PRFRealizations'>Appendix&nbsp;C<span> (</span><span class='info'>Example of DSKPP-PRF Realizations</span><span>)</span></a>)
</li>
<li>DSKPP-PRF-SHA256 DSKPP-PRF realization (<a class='info' href='#Section-PRFRealizations'>Appendix&nbsp;C<span> (</span><span class='info'>Example of DSKPP-PRF Realizations</span><span>)</span></a>)<br />
<br />

</li>
</ul>
</dd>
<dt>e.</dt>
<dd>MUST support the following Encryption mechanisms for protection
          of the client nonce in the four-pass protocol:
<ul class="text">
<li>Mechanism described in <a class='info' href='#Subsection-Enc'>Section&nbsp;3.4.3<span> (</span><span class='info'>Encryption of Pseudorandom Nonces Sent from the DSKPP Client</span><span>)</span></a><br />
<br />

</li>
</ul>
</dd>
<dt>f.</dt>
<dd>MUST support the following Encryption algorithms for symmetric
          key operations, e.g., key wrap:
<ul class="text">
<li>AES-CBC-128 <a class='info' href='#FIPS197-AES'>[FIPS197&#8209;AES]<span> (</span><span class='info'>National Institute of Standards and             Technology, &ldquo;Specification for the Advanced Encryption Standard           (AES),&rdquo; November&nbsp;2001.</span><span>)</span></a><br />
<br />

</li>
</ul>
</dd>
<dt>g.</dt>
<dd>MUST support the following Encryption algorithms for asymmetric
          key operations, e.g., key transport:
<ul class="text">
<li>RSA Encryption Scheme <a class='info' href='#PKCS-1'>[PKCS&#8209;1]<span> (</span><span class='info'>RSA Laboratories, &ldquo;RSA Cryptography Standard,&rdquo; June&nbsp;2002.</span><span>)</span></a><br />
<br />

</li>
</ul>
</dd>
<dt>h.</dt>
<dd>MUST support the following Integrity/KDF MAC functions:
<ul class="text">
<li>HMAC-SHA256 <a class='info' href='#FIPS180-SHA'>[FIPS180&#8209;SHA]<span> (</span><span class='info'>National Institute of Standards and             Technology, &ldquo;Secure Hash Standard,&rdquo; February&nbsp;2004.</span><span>)</span></a>
</li>
<li>AES-CMAC-128 <a class='info' href='#FIPS197-AES'>[FIPS197&#8209;AES]<span> (</span><span class='info'>National Institute of Standards and             Technology, &ldquo;Specification for the Advanced Encryption Standard           (AES),&rdquo; November&nbsp;2001.</span><span>)</span></a><br />
<br />

</li>
</ul>
</dd>
<dt>i.</dt>
<dd>MUST support the PSKC key package <a class='info' href='#PSKC'>[PSKC]<span> (</span><span class='info'>, &ldquo;Portable Symmetric Key Container,&rdquo; 2008.</span><span>)</span></a>;
          all three PSKC key protection profiles (Key Transport, Key Wrap, and
          Passphrase-Based Key Wrap) MUST be implemented<br />

</dd>
<dt>j.</dt>
<dd>MAY support the ASN.1 key package as defined in <a class='info' href='#SKPC-ASN.1'>[SKPC&#8209;ASN.1]<span> (</span><span class='info'>, &ldquo;Symmetric Key Package Content Type,&rdquo; 2007.</span><span>)</span></a>
</dd>
</dl></blockquote>

<p>DSKPP clients MUST support either the two-pass or the four-pass
      variant of the protocol. DSKPP clients MUST fulfill all requirements
      listed in item (c) - (j).
</p>
<p>Of course, DSKPP is a security protocol, and one of its major
      functions is to allow only authorized parties to successfully initialize
      a cryptographic module with a new symmetric key. Therefore, a particular
      implementation may be configured with any of a number of restrictions
      concerning algorithms and trusted authorities that will prevent
      universal interoperability.
</p>
<a name="Section-Security"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.9"></a><h3>9.&nbsp;
Security Considerations</h3>

<a name="anchor55"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.9.1"></a><h3>9.1.&nbsp;
General</h3>

<p>DSKPP is designed to protect generated keying material from
        exposure. No other entities than the DSKPP server and the
        cryptographic module will have access to a generated K_TOKEN if the
        cryptographic algorithms used are of sufficient strength and, on the
        DSKPP client side, generation and encryption of R_C and generation of
        K_TOKEN take place as specified in the cryptographic module. This
        applies even if malicious software is present in the DSKPP client.
        However, as discussed in the following sub-sections, DSKPP does not
        protect against certain other threats resulting from man-in-the-middle
        attacks and other forms of attacks. DSKPP SHOULD, therefore, be run
        over a transport providing confidentiality and integrity, such as HTTP
        over Transport Layer Security (TLS) with a suitable ciphersuite, when
        such threats are a concern. Note that TLS ciphersuites with anonymous
        key exchanges are not suitable in those situations.
</p>
<a name="anchor56"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.9.2"></a><h3>9.2.&nbsp;
Active Attacks</h3>

<a name="anchor57"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.9.2.1"></a><h3>9.2.1.&nbsp;
Introduction</h3>

<p>An active attacker MAY attempt to modify, delete, insert, replay,
          or reorder messages for a variety of purposes including service
          denial and compromise of generated keying material. <a class='info' href='#Subsection-Messages'>Section&nbsp;9.2.2<span> (</span><span class='info'>Message Modifications</span><span>)</span></a> through <a class='info' href='#Subsection-MITM'>Section&nbsp;9.2.7<span> (</span><span class='info'>Man-in-the-Middle</span><span>)</span></a>.
</p>
<a name="Subsection-Messages"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.9.2.2"></a><h3>9.2.2.&nbsp;
Message Modifications</h3>

<p>Modifications to a &lt;KeyProvTrigger&gt; message will either
          cause denial-of-service (modifications of any of the identifiers or
          the nonce) or will cause the DSKPP client to contact the wrong DSKPP
          server. The latter is in effect a man-in-the-middle attack and is
          discussed further in <a class='info' href='#Subsection-MITM'>Section&nbsp;9.2.7<span> (</span><span class='info'>Man-in-the-Middle</span><span>)</span></a>.
</p>
<p>An attacker may modify a &lt;KeyProvClientHello&gt; message. This
          means that the attacker could indicate a different key or device
          than the one intended by the DSKPP client, and could also suggest
          other cryptographic algorithms than the ones preferred by the DSKPP
          client, e.g., cryptographically weaker ones. The attacker could also
          suggest earlier versions of the DSKPP protocol, in case these
          versions have been shown to have vulnerabilities. These
          modifications could lead to an attacker succeeding in initializing
          or modifying another cryptographic module than the one intended
          (i.e., the server assigning the generated key to the wrong module),
          or gaining access to a generated key through the use of weak
          cryptographic algorithms or protocol versions. DSKPP implementations
          MAY protect against the latter by having strict policies about what
          versions and algorithms they support and accept. The former threat
          (assignment of a generated key to the wrong module) is not possible
          when the shared-key variant of DSKPP is employed (assuming existing
          shared keys are unique per cryptographic module), but is possible in
          the public-key variation. Therefore, DSKPP servers MUST NOT accept
          unilaterally provided device identifiers in the public-key
          variation. This is also indicated in the protocol description. In
          the shared-key variation, however, an attacker may be able to
          provide the wrong identifier (possibly also leading to the incorrect
          user being associated with the generated key) if the attacker has
          real-time access to the cryptographic module with the identified
          key. In other words, the generated key is associated with the
          correct cryptographic module but the module is associated with the
          incorrect user. See further <a class='info' href='#Subsection-Interactions'>Section&nbsp;9.5<span> (</span><span class='info'>Attacks on the Interaction between DSKPP and User Authentication</span><span>)</span></a> for a discussion of this
          threat and possible countermeasures.
</p>
<p>An attacker may also modify a &lt;KeyProvServerHello&gt; message.
          This means that the attacker could indicate different key types,
          algorithms, or protocol versions than the legitimate server would,
          e.g., cryptographically weaker ones. The attacker may also provide a
          different nonce than the one sent by the legitimate server. Clients
          MAY protect against the former through strict adherence to policies
          regarding permissible algorithms and protocol versions. The latter
          (wrong nonce) will not constitute a security problem, as a generated
          key will not match the key generated on the legitimate server. Also,
          whenever the DSKPP run would result in the replacement of an
          existing key, the &lt;Mac&gt; element protects against modifications
          of R_S.
</p>
<p>Modifications of &lt;KeyProvClientNonce&gt; messages are also
          possible. If an attacker modifies the SessionID attribute, then, in
          effect, a switch to another session will occur at the server,
          assuming the new SessionID is valid at that time on the server. It
          still will not allow the attacker to learn a generated K_TOKEN since
          R_C has been wrapped for the legitimate server. Modifications of the
          &lt;EncryptedNonce&gt; element, e.g., replacing it with a value for
          which the attacker knows an underlying R'C, will not result in the
          client changing its pre-DSKPP state, since the server will be unable
          to provide a valid MAC in its final message to the client. The
          server MAY, however, end up storing K'TOKEN rather than K_TOKEN. If
          the cryptographic module has been associated with a particular user,
          then this could constitute a security problem. For a further
          discussion about this threat, and a possible countermeasure, see
          <a class='info' href='#Subsection-Interactions'>Section&nbsp;9.5<span> (</span><span class='info'>Attacks on the Interaction between DSKPP and User Authentication</span><span>)</span></a> below. Note that use
          of TLS does not protect against this attack if the attacker has
          access to the DSKPP client (e.g., through malicious software,
          "Trojans").
</p>
<p>Finally, attackers may also modify the
          &lt;KeyProvServerFinished&gt; message. Replacing the &lt;Mac&gt;
          element will only result in denial-of-service. Replacement of any
          other element may cause the DSKPP client to associate, e.g., the
          wrong service with the generated key. DSKPP SHOULD be run over a
          transport providing confidentiality and integrity when this is a
          concern.
</p>
<a name="anchor58"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.9.2.3"></a><h3>9.2.3.&nbsp;
Message Deletion</h3>

<p>Message deletion will not cause any other harm than
          denial-of-service, since a cryptographic module MUST NOT change its
          state (i.e., "commit" to a generated key) until it receives the
          final message from the DSKPP server and successfully has processed
          that message, including validation of its MAC. A deleted
          &lt;KeyProvServerFinished&gt; message will not cause the server to
          end up in an inconsistent state vis-a-vis the cryptographic module
          if the server implements the suggestions in <a class='info' href='#Subsection-Interactions'>Section&nbsp;9.5<span> (</span><span class='info'>Attacks on the Interaction between DSKPP and User Authentication</span><span>)</span></a>.
</p>
<a name="anchor59"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.9.2.4"></a><h3>9.2.4.&nbsp;
Message Insertion</h3>

<p>An active attacker may initiate a DSKPP run at any time, and
          suggest any device identifier. DSKPP server implementations MAY
          receive some protection against inadvertently initializing a key or
          inadvertently replacing an existing key or assigning a key to a
          cryptographic module by initializing the DSKPP run by use of the
          &lt;KeyProvTrigger&gt;. The &lt;TriggerNonce&gt; element allows the
          server to associate a DSKPP protocol run with, e.g., an earlier
          user-authenticated session. The security of this method, therefore,
          depends on the ability to protect the &lt;TriggerNonce&gt; element
          in the DSKPP initialization message. If an eavesdropper is able to
          capture this message, he may race the legitimate user for a key
          initialization. DSKPP over a transport providing confidentiality and
          integrity, coupled with the recommendations in <a class='info' href='#Subsection-Interactions'>Section&nbsp;9.5<span> (</span><span class='info'>Attacks on the Interaction between DSKPP and User Authentication</span><span>)</span></a>, is RECOMMENDED when this
          is a concern.
</p>
<p>Insertion of other messages into an existing protocol run is seen
          as equivalent to modification of legitimately sent messages.
</p>
<a name="anchor60"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.9.2.5"></a><h3>9.2.5.&nbsp;
Message Replay</h3>

<p>During 4-pass DSKPP, attempts to replay a previously recorded
          DSKPP message will be detected, as the use of nonces ensures that
          both parties are live. For example, a DSKPP client knows that a
          server it is communicating with is "live" since the server MUST
          create a MAC on information sent by the client.
</p>
<p>The same is true for 2-pass DSKPP thanks to the requirement that
          the client sends R in the &lt;KeyProvClientHello&gt; message and
          that the server includes R in the MAC computation.
</p>
<a name="anchor61"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.9.2.6"></a><h3>9.2.6.&nbsp;
Message Reordering</h3>

<p>An attacker may attempt to re-order 4-pass DSKPP messages but
          this will be detected, as each message is of a unique type. Note:
          Message re-ordering attacks cannot occur in 2-pass DSKPP since each
          party sends at most one message each.
</p>
<a name="Subsection-MITM"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.9.2.7"></a><h3>9.2.7.&nbsp;
Man-in-the-Middle</h3>

<p>In addition to other active attacks, an attacker posing as a man
          in the middle may be able to provide his own public key to the DSKPP
          client. This threat and countermeasures to it are discussed in <a class='info' href='#Subsection-FourPassDataFlow'>Section&nbsp;3.4.2.1<span> (</span><span class='info'>Data Flow</span><span>)</span></a>. An attacker posing as
          a man-in-the-middle may also be acting as a proxy and, hence, may
          not interfere with DSKPP runs but still learn valuable information;
          see <a class='info' href='#Subsection-Passive'>Section&nbsp;9.3<span> (</span><span class='info'>Passive Attacks</span><span>)</span></a>.
</p>
<a name="Subsection-Passive"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.9.3"></a><h3>9.3.&nbsp;
Passive Attacks</h3>

<p>Passive attackers may eavesdrop on DSKPP runs to learn information
        that later on may be used to impersonate users, mount active attacks,
        etc.
</p>
<p>If DSKPP is not run over a transport providing confidentiality, a
        passive attacker may learn:</p>
<ul class="text">
<li>What cryptographic modules a particular user is in possession
            of;
</li>
<li>The identifiers of keys on those cryptographic modules and
            other attributes pertaining to those keys, e.g., the lifetime of
            the keys;
</li>
<li>DSKPP versions and cryptographic algorithms supported by a
            particular DSKPP client or server; and
</li>
<li>Any value present in an &lt;extension&gt; that is part of
            &lt;KeyProvClientHello&gt;
</li>
</ul>

<p>Whenever the above is a concern, DSKPP SHOULD be run over a
        transport providing confidentiality. If man-in-the-middle attacks for
        the purposes described above are a concern, the transport SHOULD also
        offer server-side authentication.
</p>
<a name="anchor62"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.9.4"></a><h3>9.4.&nbsp;
Cryptographic Attacks</h3>

<p>An attacker with unlimited access to an initialized cryptographic
        module may use the module as an "oracle" to pre-compute values that
        later on may be used to impersonate the DSKPP server. <a class='info' href='#Subsection-Enc'>Section&nbsp;3.4.3<span> (</span><span class='info'>Encryption of Pseudorandom Nonces Sent from the DSKPP Client</span><span>)</span></a> and <a class='info' href='#Section-Protocol'>Section&nbsp;3<span> (</span><span class='info'>DSKPP Protocol Details</span><span>)</span></a> contain discussions of this threat
        and steps RECOMMENDED to protect against it.
</p>
<p>Implementers SHOULD also be aware that cryptographic algorithms
        become weaker with time. As new cryptographic techniques are developed
        and computing performance improves, the work factor to break a
        particular cryptographic algorithm will reduce. Therefore,
        cryptographic algorithm implementations SHOULD be modular allowing new
        algorithms to be readily inserted. That is, implementers SHOULD be
        prepared to regularly update the algorithms in their
        implementations.
</p>
<a name="Subsection-Interactions"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.9.5"></a><h3>9.5.&nbsp;
Attacks on the Interaction between DSKPP and User Authentication</h3>

<p>If keys generated in DSKPP will be associated with a particular
        user at the DSKPP server (or a server trusted by, and communicating
        with the DSKPP server), then in order to protect against threats where
        an attacker replaces a client-provided encrypted R_C with his own R'C
        (regardless of whether the public-key variation or the shared-secret
        variation of DSKPP is employed to encrypt the client nonce), the
        server SHOULD not commit to associate a generated K_TOKEN with the
        given cryptographic module until the user simultaneously has proven
        both possession of the device that hosts the cryptographic module
        containing K_TOKEN and some out-of-band provided authenticating
        information (e.g., a temporary password). For example, if the
        cryptographic module is a one-time password token, the user could be
        required to authenticate with both a one-time password generated by
        the cryptographic module and an out-of-band provided temporary PIN in
        order to have the server "commit" to the generated OTP value for the
        given user. Preferably, the user SHOULD perform this operation from
        another host than the one used to initialize keys on the cryptographic
        module, in order to minimize the risk of malicious software on the
        client interfering with the process.
</p>
<p>Note: This scenario, wherein the attacker replaces a
        client-provided R_C with his own R'C, does not apply to 2-pass DSKPP
        as the client does not provide any entropy to K_TOKEN. The attack as
        such (and its countermeasures) still applies to 2-pass DSKPP, however,
        as it essentially is a man-in-the-middle attack.
</p>
<p>Another threat arises when an attacker is able to trick a user to
        authenticate to the attacker rather than to the legitimate service
        before the DSKPP protocol run. If successful, the attacker will then
        be able to impersonate the user towards the legitimate service, and
        subsequently receive a valid DSKPP trigger. If the public-key variant
        of DSKPP is used, this may result in the attacker being able to (after
        a successful DSKPP protocol run) impersonate the user. Ordinary
        precautions MUST, therefore, be in place to ensure that users
        authenticate only to legitimate services.
</p>
<a name="anchor63"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.9.6"></a><h3>9.6.&nbsp;
Miscellaneous Considerations</h3>

<a name="anchor64"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.9.6.1"></a><h3>9.6.1.&nbsp;
Client Contributions to K_TOKEN Entropy</h3>

<p>In 4-pass DSKPP, both the client and the server provide
          randomizing material to K_TOKEN, in a manner that allows both
          parties to verify that they did contribute to the resulting key. In
          the 2-pass DSKPP version defined herein, only the server contributes
          to the entropy of K_TOKEN. This means that a broken or compromised
          (pseudo-)random number generator in the server may cause more damage
          than it would in the 4-pass variation. Server implementations SHOULD
          therefore take extreme care to ensure that this situation does not
          occur.
</p>
<a name="anchor65"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.9.6.2"></a><h3>9.6.2.&nbsp;
Key Confirmation</h3>

<p>4-pass DSKPP servers provide key confirmation through the MAC on
          R_C in the &lt;KeyProvServerFinished&gt; message. In the 2-pass
          DSKPP variation described herein, key confirmation is provided by
          the MAC including R, using K_MAC.
</p>
<a name="Subsection-ServerAuth"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.9.6.3"></a><h3>9.6.3.&nbsp;
Server Authentication</h3>

<p>DSKPP servers MUST authenticate themselves whenever a successful
          DSKPP 2-pass protocol run would result in an existing K_TOKEN being
          replaced by a K_TOKEN', or else a denial-of-service attack where an
          unauthorized DSKPP server replaces a K_TOKEN with another key would
          be possible. In 2-pass DSKPP, servers authenticate by including the
          AuthenticationDataType extension containing a MAC as described in
          <a class='info' href='#Subsecton-TwoPass'>Section&nbsp;3.5<span> (</span><span class='info'>Two-Pass Protocol Usage</span><span>)</span></a> for two-pass DSKPP.
</p>
<a name="Subsection-UserAuthN"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.9.6.4"></a><h3>9.6.4.&nbsp;
User Authentication</h3>

<p>A DSKPP server MUST authenticate a client to ensure that K_TOKEN
          is delivered to the intended device. The following measures SHOULD
          be considered:
</p>
<p></p>
<ul class="text">
<li>When an Authentication Code is used for client
              authentication, a password dictionary attack on the
              authentication data is possible.
</li>
<li>The length of the Authentication Code when used over a
              non-secure channel SHOULD be longer than what is used over a
              secure channel. When a device, e.g., some mobile phones with
              small screens, cannot handle a long Authentication Code in a
              user-friendly manner, DSKPP SHOULD rely on a secure channel for
              communication.
</li>
<li>In the case that a non-secure channel has to be used, the
              Authentication Code SHOULD be sent to the server MAC'd as
              specified in <a class='info' href='#Section-ClientAuthN'>Section&nbsp;3.7<span> (</span><span class='info'>User Authentication</span><span>)</span></a>. The
              Authentication Code and nonce value MUST be strong enough to
              prevent offline brute-force recovery of the Authentication Code
              from the HMAC data. Given that the nonce value is sent in
              plaintext format over a non-secure transport, the cryptographic
              strength of the Authentication Data depends more on the quality
              of the Authentication Code.
</li>
<li>When the Authentication Code is sent from the DSKPP server to
              the device in a DSKPP initialization trigger message, an
              eavesdropper may be able to capture this message and race the
              legitimate user for a key initialization. To prevent this, the
              transport layer used to send the DSKPP trigger MUST provide
              confidentiality and integrity e.g. secure browser session.
</li>
</ul>

<a name="anchor66"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.9.6.5"></a><h3>9.6.5.&nbsp;
Key Protection in Two-Pass DSKPP</h3>

<p>Three key protection profiles are defined for the different
          usages of 2-pass DSKPP, which MUST be supported by a key package
          format, such as <a class='info' href='#PSKC'>[PSKC]<span> (</span><span class='info'>, &ldquo;Portable Symmetric Key Container,&rdquo; 2008.</span><span>)</span></a> and <a class='info' href='#SKPC-ASN.1'>[SKPC&#8209;ASN.1]<span> (</span><span class='info'>, &ldquo;Symmetric Key Package Content Type,&rdquo; 2007.</span><span>)</span></a>. Therefore, key protection in the
          two-pass DSKPP is dependent upon the security of the key package
          format selected for a protocol run. Some considerations for the
          Passphrase profile follow.
</p>
<p>The passphrase-based key wrap profile SHOULD depend upon the
          PBKDF2 function from <a class='info' href='#PKCS-5'>[PKCS&#8209;5]<span> (</span><span class='info'>RSA Laboratories, &ldquo;Password-Based Cryptography Standard,&rdquo; March&nbsp;1999.</span><span>)</span></a> to generate an
          encryption key from a passphrase and salt string. It is important to
          note that passphrase-based encryption is generally limited in the
          security that it provides despite the use of salt and iteration
          count in PBKDF2 to increase the complexity of attack.
          Implementations SHOULD therefore take additional measures to
          strengthen the security of the passphrase-based key wrap profile.
          The following measures SHOULD be considered where applicable:
</p>
<p></p>
<ul class="text">
<li>The passphrase SHOULD be selected well, and usage guidelines
              such as the ones in <a class='info' href='#NIST-PWD'>[NIST&#8209;PWD]<span> (</span><span class='info'>National Institute of Standards and             Technology, &ldquo;Password Usage,&rdquo; May&nbsp;1985.</span><span>)</span></a> SHOULD be
              taken into account.
</li>
<li>A different passphrase SHOULD be used for every key
              initialization wherever possible (the use of a global passphrase
              for a batch of cryptographic modules SHOULD be avoided, for
              example). One way to achieve this is to use randomly-generated
              passphrases.
</li>
<li>The passphrase SHOULD be protected well if stored on the
              server and/or on the cryptographic module and SHOULD be
              delivered to the device's user using secure methods.
</li>
<li>User per-authentication SHOULD be implemented to ensure that
              K_TOKEN is not delivered to a rogue recipient.
</li>
<li>The iteration count in PBKDF2 SHOULD be high to impose more
              work for an attacker using brute-force methods (see <a class='info' href='#PKCS-5'>[PKCS&#8209;5]<span> (</span><span class='info'>RSA Laboratories, &ldquo;Password-Based Cryptography Standard,&rdquo; March&nbsp;1999.</span><span>)</span></a> for recommendations). However, it MUST
              be noted that the higher the count, the more work is required on
              the legitimate cryptographic module to decrypt the newly
              delivered K_TOKEN. Servers MAY use relatively low iteration
              counts to accommodate devices with limited processing power such
              as some PDA and cell phones when other security measures are
              implemented and the security of the passphrase-based key wrap
              method is not weakened.
</li>
<li>Transport level security (e.g. TLS) SHOULD be used where
              possible to protect a two-pass protocol run. Transport level
              security provides a second layer of protection for the newly
              generated K_TOKEN.
</li>
</ul>

<a name="anchor67"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.10"></a><h3>10.&nbsp;
Internationalization Considerations</h3>

<p>The DSKPP protocol is mostly meant for machine-to-machine
      communications; as such, most of its elements are tokens not meant for
      direct human consumption. If these tokens are presented to the end user,
      some localization may need to occur. DSKPP exchanges information using
      XML. All XML processors are required to understand UTF-8 and UTF-16
      encoding, and therefore all DSKPP clients and servers MUST understand
      UTF-8 and UTF-16 encoded XML. Additionally, DSKPP servers and clients
      MUST NOT encode XML with encodings other than UTF-8 or UTF-16.
</p>
<a name="anchor68"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.11"></a><h3>11.&nbsp;
IANA Considerations</h3>

<p>This document requires several IANA registrations, detailed
      below.
</p>
<a name="anchor69"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.11.1"></a><h3>11.1.&nbsp;
URN Sub-Namespace Registration</h3>

<p>This section registers a new XML namespace,
        "urn:ietf:params:xml:ns:keyprov:dskpp:1.0" per the guidelines in <a class='info' href='#RFC3688'>[RFC3688]<span> (</span><span class='info'>Mealling, M., &ldquo;The IETF XML Registry,&rdquo; January&nbsp;2004.</span><span>)</span></a>:
</p>
<p></p>
<blockquote class="text"><dl>
<dt>URI:</dt>
<dd>urn:ietf:params:xml:ns:keyprov:dskpp:1.0
</dd>
<dt>Registrant Contact:</dt>
<dd>IETF, KEYPROV Working Group
            (keyprov@ietf.org), Andrea Doherty (andrea.doherty@rsa.com)
</dd>
<dt>XML:</dt>
<dd>
</dd>
</dl></blockquote>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>   BEGIN
      &lt;?xml version="1.0"?&gt;
      &lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
         "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"&gt;
      &lt;html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en"&gt;
      &lt;head&gt;
         &lt;title&gt;DSKPP Messsages&lt;/title&gt;
      &lt;/head&gt;
      &lt;body&gt;
         &lt;h1&gt;Namespace for DSKPP Messages&lt;/h1&gt;
         &lt;h2&gt;urn:ietf:params:xml:ns:keyprov:dskpp:1.0&lt;/h2&gt;
         [NOTE TO IANA/RFC-EDITOR: Please replace XXXX below
         with the RFC number for this specification.]
         &lt;p&gt;See RFCXXXX&lt;/p&gt;
      &lt;/body&gt;
      &lt;/html&gt;
   END
</pre></div>
<a name="anchor70"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.11.2"></a><h3>11.2.&nbsp;
XML Schema Registration</h3>

<p>This section registers an XML schema as per the guidelines in <a class='info' href='#RFC3688'>[RFC3688]<span> (</span><span class='info'>Mealling, M., &ldquo;The IETF XML Registry,&rdquo; January&nbsp;2004.</span><span>)</span></a>.
</p>
<p></p>
<blockquote class="text"><dl>
<dt>URI:</dt>
<dd>urn:ietf:params:xml:ns:keyprov:dskpp:1.0
</dd>
<dt>Registrant Contact:</dt>
<dd>IETF, KEYPROV Working Group
            (keyprov@ietf.org), Andrea Doherty (andrea.doherty@rsa.com)
</dd>
<dt>Schema</dt>
<dd>The XML for this schema can be found as the
            entirety of <a class='info' href='#Section-Schema'>Section&nbsp;7<span> (</span><span class='info'>DSKPP Schema</span><span>)</span></a> of this
            document.
</dd>
</dl></blockquote>

<a name="anchor71"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.11.3"></a><h3>11.3.&nbsp;
MIME Media Type Registration</h3>

<p>This section registers the "application/dskpp+xml" MIME type:
</p>
<p></p>
<blockquote class="text"><dl>
<dt>To:</dt>
<dd>ietf-types@iana.org
</dd>
<dt>Subject:</dt>
<dd>Registration of MIME media type
            application/dskpp+xml
</dd>
<dt>MIME media type name:</dt>
<dd>application
</dd>
<dt>MIME subtype name:</dt>
<dd>dskpp+xml
</dd>
<dt>Required parameters:</dt>
<dd>(none)
</dd>
<dt>Optional parameters:</dt>
<dd>charsetIndicates the character encoding of enclosed XML.
            Default is UTF-8.
</dd>
<dt>Encoding considerations:</dt>
<dd>Uses XML, which can employ
            8-bit characters, depending on the character encoding used. See
            <a class='info' href='#RFC3203'>[RFC3203]<span> (</span><span class='info'>Murata, M., St. Laurent, S., and D. Kohn, &ldquo;XML Media Types,&rdquo; January&nbsp;2001.</span><span>)</span></a>, Section 3.2.
</dd>
<dt>Security considerations:</dt>
<dd>This content type is
            designed to carry protocol data related to key management.
            Security mechanisms are built into the protocol to ensure that
            various threats are dealt with.
</dd>
<dt>Interoperability considerations:</dt>
<dd>This content type
            provides a basis for a protocol.
</dd>
<dt>Published specification:</dt>
<dd>RFC XXXX [NOTE TO
            IANA/RFC-EDITOR: Please replace XXXX with the RFC number for this
            specification.]
</dd>
<dt>Applications which use this media type:</dt>
<dd>Protocol for
            key exchange.
</dd>
<dt>Additional information:</dt>
<dd>Magic Number(s): (none)<br />
File extension(s): .xmls<br />
Macintosh File Type Code(s): (none)
</dd>
<dt>Person &amp; email address to contact for further information:</dt>
<dd>Andrea Doherty (andrea.doherty@rsa.com)
</dd>
<dt>Intended usage:</dt>
<dd>LIMITED USE
</dd>
<dt>Author/Change controller:</dt>
<dd>The IETF
</dd>
<dt>Other information:</dt>
<dd>This media type is a
            specialization of application/xml <a class='info' href='#RFC3203'>[RFC3203]<span> (</span><span class='info'>Murata, M., St. Laurent, S., and D. Kohn, &ldquo;XML Media Types,&rdquo; January&nbsp;2001.</span><span>)</span></a>,
            and many of the considerations described there also apply to
            application/dskpp+xml.
</dd>
</dl></blockquote>

<a name="anchor72"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.11.4"></a><h3>11.4.&nbsp;
Status Code Registry</h3>

<p>This section registers status codes included in each DSKPP response
        message. The status codes are defined in the schema in the
        &lt;StatusCode&gt; type definition as described in the XML schema in
        <a class='info' href='#Section-Schema'>Section&nbsp;7<span> (</span><span class='info'>DSKPP Schema</span><span>)</span></a>. The following summarizes the
        registry:
</p>
<p></p>
<blockquote class="text"><dl>
<dt>Related Registry:</dt>
<dd>KEYPROV
            DSKPP Registries, Status codes for DSKPP<br />
<br />

</dd>
<dt>Defining RFC:</dt>
<dd>RFC XXXX
            [NOTE TO IANA/RFC-EDITOR: Please replace XXXX with the RFC number
            for this specification.]<br />
<br />

</dd>
<dt>Registration/Assignment Procedures:</dt>
<dd>Following the policies outlined in <a class='info' href='#RFC3575'>[RFC3575]<span> (</span><span class='info'>Aboba, B., &ldquo;IANA Considerations for RADIUS,&rdquo; July&nbsp;2003.</span><span>)</span></a>, the IANA policy for assigning new values
            for the status codes for DSKPP MUST be "Specification Required"
            and their meanings MUST be documented in an RFC or in some other
            permanent and readily available reference, in sufficient detail
            that interoperability between independent implementations is
            possible. No mechanism to mark entries as "deprecated" is
            envisioned. It is possible to delete or update entries from the
            registry.<br />
<br />

</dd>
<dt>Registrant Contact:</dt>
<dd>IETF,
            KEYPROV working group (keyprov@ietf.org),<br />
Andrea Doherty (andrea.doherty@rsa.com)
</dd>
</dl></blockquote>

<p>This section pre-registers the initial status codes, as described
        above in <a class='info' href='#Subsection-StatusCodes'>Section&nbsp;4.7<span> (</span><span class='info'>The StatusCode Type</span><span>)</span></a>, including
        their textual description. The list in <a class='info' href='#Subsection-StatusCodes'>Section&nbsp;4.7<span> (</span><span class='info'>The StatusCode Type</span><span>)</span></a>, starts with the StatusCode
        "Continue" and ends with the StatusCode "InitializationFailed".
</p>
<a name="Section-IPR"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.12"></a><h3>12.&nbsp;
Intellectual Property Considerations</h3>

<p>RSA and RSA Security are registered trademarks or trademarks of RSA
      Security Inc. in the United States and/or other countries. The names of
      other products and services mentioned may be the trademarks of their
      respective owners.
</p>
<a name="anchor73"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.13"></a><h3>13.&nbsp;
Contributors</h3>

<p>This work is based on information contained in <a class='info' href='#RFC4758'>[RFC4758]<span> (</span><span class='info'>RSA, The Security Division of EMC, &ldquo;Cryptographic Token Key Initialization Protocol           (CT-KIP),&rdquo; November&nbsp;2006.</span><span>)</span></a>, authored by Magnus Nystrom, with enhancements
      (esp. Client Authentication, and support for multiple key package
      formats) from an individual Internet-Draft co-authored by Mingliang Pei
      and Salah Machani.
</p>
<p>We would like to thank Shuh Chang for contributing the DSKPP object
      model, and Philip Hoyer for his work in aligning DSKPP and PSKC
      schemas.
</p>
<p>We would also like to thank Hannes Tschofenig for his draft reviews,
      feedback, and text contributions.
</p>
<a name="Section-Acknowledgements"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.14"></a><h3>14.&nbsp;
Acknowledgements</h3>

<p>We would like to thank the following for review of previous DSKPP
      document versions:<br />
<br />
</p>
<ul class="text">
<li>Dr. Ulrike Meyer (Review June 2007)<br />

</li>
<li>Niklas Neumann (Review June 2007)<br />

</li>
<li>Shuh Chang (Review June 2007)<br />

</li>
<li>Hannes Tschofenig (Review June 2007 and again in August
          2007)<br />

</li>
<li>Sean Turner (Reviews August 2007 and again in July 2008)<br />

</li>
<li>John Linn (Review August 2007)<br />

</li>
<li>Philip Hoyer (Review September 2007)<br />

</li>
<li>Thomas Roessler (Review November 2007)<br />

</li>
<li>Lakshminath Dondeti (Comments December 2007)<br />

</li>
<li>Pasi Eronen (Comments December 2007)<br />

</li>
<li>Phillip Hallam-Baker (Review November 2008)
</li>
</ul>

<p>We would also like to thank the following for their input to selected
      design aspects of the DSKPP protocol:<br />
<br />
</p>
<ul class="text">
<li>Anders Rundgren (Key Package Format and Client Authentication
          Data)<br />

</li>
<li>Thomas Roessler (HTTP Binding)<br />

</li>
<li>Hannes Tschofenig (HTTP Binding)<br />

</li>
<li>Phillip Hallam-Baker (Registry for Algorithms)
</li>
</ul>

<p>Finally, we would like to thank Robert Griffin for opening
      communication channels for us with the IEEE P1619.3 Key Management
      Group, and facilitating our groups in staying informed of potential
      areas (esp. key provisioning and global key identifiers of
      collaboration) of collaboration.
</p>
<a name="rfc.references"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.15"></a><h3>15.&nbsp;
References</h3>

<a name="rfc.references1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>15.1.&nbsp;Normative references</h3>
<table width="99%" border="0">
<tr><td class="author-text" valign="top"><a name="FIPS180-SHA">[FIPS180-SHA]</a></td>
<td class="author-text">National Institute of Standards and
            Technology, &ldquo;<a href="http://csrc.nist.gov/publications/fips/fips180-2/fips180-2withchangenotice.pdf">Secure Hash Standard</a>,&rdquo; FIPS&nbsp;180-2, February&nbsp;2004.</td></tr>
<tr><td class="author-text" valign="top"><a name="FIPS197-AES">[FIPS197-AES]</a></td>
<td class="author-text">National Institute of Standards and
            Technology, &ldquo;<a href="http://csrc.nist.gov/publications/fips/fips197/fips-197.pdf">Specification for the Advanced Encryption Standard
          (AES)</a>,&rdquo; FIPS&nbsp;197, November&nbsp;2001.</td></tr>
<tr><td class="author-text" valign="top"><a name="PKCS-1">[PKCS-1]</a></td>
<td class="author-text">RSA Laboratories, &ldquo;<a href="http://www.rsasecurity.com/rsalabs/pkcs/">RSA Cryptography Standard</a>,&rdquo; PKCS&nbsp;#1 Version 2.1, June&nbsp;2002.</td></tr>
<tr><td class="author-text" valign="top"><a name="PKCS-5">[PKCS-5]</a></td>
<td class="author-text">RSA Laboratories, &ldquo;<a href="http://www.rsasecurity.com/rsalabs/pkcs/">Password-Based Cryptography Standard</a>,&rdquo; PKCS&nbsp;#5 Version 2.0, March&nbsp;1999.</td></tr>
<tr><td class="author-text" valign="top"><a name="PKCS-5-XML">[PKCS-5-XML]</a></td>
<td class="author-text">RSA Laboratories, &ldquo;<a href="http://www.rsasecurity.com/rsalabs/pkcs/">XML Schema for PKCS #5 Version 2.0</a>,&rdquo; PKCS&nbsp;#5 Version 2.0 Amd.1 (FINAL DRAFT), October&nbsp;2006.</td></tr>
<tr><td class="author-text" valign="top"><a name="PSKC">[PSKC]</a></td>
<td class="author-text">&ldquo;<a href="org/internet-drafts/draft-hoyer-keyprov-portable-symmetric-key-container-03.txt">Portable Symmetric Key Container</a>,&rdquo; 2008.</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC2104">[RFC2104]</a></td>
<td class="author-text">Krawzcyk, H., <a href="mailto:">Bellare, M.</a>, and <a href="mailto:">R. Canetti</a>, &ldquo;<a href="http://www.ietf.org/rfc/rfc2104.txt">HMAC: Keyed-Hashing for Message Authentication</a>,&rdquo; RFC&nbsp;2104, February&nbsp;1997.</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC2119">[RFC2119]</a></td>
<td class="author-text">&ldquo;<a href="http://www.ietf.org/rfc/rfc2119.txt">Key words for use in RFCs to Indicate Requirement
          Levels</a>,&rdquo; BCP&nbsp;14, RFC&nbsp;2119, March&nbsp;1997.</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC3629">[RFC3629]</a></td>
<td class="author-text">&ldquo;<a href="http://www.ietf.org/rfc/rfc3629.txt">UTF-8, a transformation format of ISO10646</a>,&rdquo; STD&nbsp;63, RFC&nbsp;3629, November&nbsp;2003.</td></tr>
<tr><td class="author-text" valign="top"><a name="UNICODE">[UNICODE]</a></td>
<td class="author-text">Davis, M. and <a href="mailto:">M. Duerst</a>, &ldquo;<a href="http://www.unicode.org/unicode/reports/tr15/tr15-21.html">Unicode Normalization Forms</a>,&rdquo; March&nbsp;2001.</td></tr>
<tr><td class="author-text" valign="top"><a name="XMLDSIG">[XMLDSIG]</a></td>
<td class="author-text">W3C, &ldquo;<a href="http://www.w3.org/TR/2002/REC-xmldsig-core-20020212/">XML Signature Syntax and Processing</a>,&rdquo; W3C&nbsp;Recommendation, February&nbsp;2002.</td></tr>
<tr><td class="author-text" valign="top"><a name="XMLENC">[XMLENC]</a></td>
<td class="author-text">W3C, &ldquo;<a href="http://www.w3.org/TR/2002/REC-xmldsig-core-20020212/">XML Encryption Syntax and Processing</a>,&rdquo; W3C&nbsp;Recommendation, December&nbsp;2002.</td></tr>
</table>

<a name="rfc.references2"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>15.2.&nbsp;Informative references</h3>
<table width="99%" border="0">
<tr><td class="author-text" valign="top"><a name="CT-KIP-P11">[CT-KIP-P11]</a></td>
<td class="author-text">RSA Laboratories, &ldquo;<a href="http://www.rsasecurity.com/rsalabs/pkcs/">PKCS #11 Mechanisms for the Cryptographic Token Key
          Initialization Protocol</a>,&rdquo; PKCS&nbsp;#11 Version 2.20 Amd.2, December&nbsp;2005.</td></tr>
<tr><td class="author-text" valign="top"><a name="FAQ">[FAQ]</a></td>
<td class="author-text">RSA Laboratories, &ldquo;Frequently Asked Questions About Today's Cryptography,&rdquo; &nbsp;Version 4.1, 2000.</td></tr>
<tr><td class="author-text" valign="top"><a name="ISO3309">[ISO3309]</a></td>
<td class="author-text">&ldquo;ISO Information Processing Systems - Data Communication -
          High-Level Data Link Control Procedure - Frame Structure,&rdquo; IS&nbsp;3309, 3rd Edition, October&nbsp;1984.</td></tr>
<tr><td class="author-text" valign="top"><a name="NIST-PWD">[NIST-PWD]</a></td>
<td class="author-text">National Institute of Standards and
            Technology, &ldquo;<a href="http://www.itl.nist.gov/fipspubs/fip112.htm">Password Usage</a>,&rdquo; FIPS&nbsp;112, May&nbsp;1985.</td></tr>
<tr><td class="author-text" valign="top"><a name="NIST-SP800-38B">[NIST-SP800-38B]</a></td>
<td class="author-text">International Organization for
            Standardization, &ldquo;<a href="http://csrc.nist.gov/publications/nistpubs/800-38B/SP_800-38B.pdf">Recommendations for Block Cipher Modes of Operation: The CMAC
          Mode for Authentication</a>,&rdquo; NIST&nbsp;SP800-38B, May&nbsp;2005.</td></tr>
<tr><td class="author-text" valign="top"><a name="NIST-SP800-57">[NIST-SP800-57]</a></td>
<td class="author-text">National Institute of Standards and
            Technology, &ldquo;<a href="http://csrc.nist.gov/publications/nistpubs/800-57/sp800-57-Part1-revised2_Mar08-2007.pdf">Recommendation for Key Management - Part I: General
          (Revised)</a>,&rdquo; NIST&nbsp;800-57, March&nbsp;2007.</td></tr>
<tr><td class="author-text" valign="top"><a name="PKCS-11">[PKCS-11]</a></td>
<td class="author-text">RSA Laboratories, &ldquo;<a href="http://www.rsasecurity.com/rsalabs/pkcs/">Cryptographic Token Interface Standard</a>,&rdquo; PKCS&nbsp;#11 Version 2.20, June&nbsp;2004.</td></tr>
<tr><td class="author-text" valign="top"><a name="PKCS-12">[PKCS-12]</a></td>
<td class="author-text">&ldquo;<a href="ftp://ftp.rsasecurity.com/pub/pkcs/pkcs-12/pkcs-12v1.pdf">Personal Information Exchange Syntax Standard</a>,&rdquo; PKCS&nbsp;#12 Version 1.0, 2005.</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC2396">[RFC2396]</a></td>
<td class="author-text">Berners-Lee, T., <a href="mailto:">Fielding, R.</a>, and <a href="mailto:">L. Masinter</a>, &ldquo;<a href="http://www.ietf.org/rfc/rfc2396.txt">Uniform Resource Identifiers (URI): Generic Syntax</a>,&rdquo; RFC&nbsp;2396, August&nbsp;1998.</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC2616">[RFC2616]</a></td>
<td class="author-text">Fielding, R., <a href="mailto:">Gettys, J.</a>, <a href="mailto:">Mogul, J.</a>, <a href="mailto:">Frystyk, H.</a>, <a href="mailto:">Masinter, L.</a>, <a href="mailto:">Leach, P.</a>, and <a href="mailto:">T. Berners-Lee</a>, &ldquo;<a href="http://www.ietf.org/rfc/rfc2616.txt">Hypertext Transfer Protocol -- HTTP/1.1</a>,&rdquo; RFC&nbsp;2616, June&nbsp;1999.</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC3203">[RFC3203]</a></td>
<td class="author-text">Murata, M., <a href="mailto:">St. Laurent, S.</a>, and <a href="mailto:">D. Kohn</a>, &ldquo;<a href="http://www.ietf.org/rfc/rfc3203.txt">XML Media Types</a>,&rdquo; RFC&nbsp;3203, January&nbsp;2001.</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC3575">[RFC3575]</a></td>
<td class="author-text">Aboba, B., &ldquo;<a href="http://www.ietf.org/rfc/rfc3575.txt">IANA Considerations for RADIUS</a>,&rdquo; RFC&nbsp;3575, July&nbsp;2003.</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC3688">[RFC3688]</a></td>
<td class="author-text">Mealling, M., &ldquo;<a href="http://www.ietf.org/rfc/rfc3688.txt">The IETF XML Registry</a>,&rdquo; RFC&nbsp;3688, BCP&nbsp;81, January&nbsp;2004.</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4758">[RFC4758]</a></td>
<td class="author-text">RSA, The Security Division of EMC, &ldquo;<a href="http://www.ietf.org/rfc/rfc4758.txt">Cryptographic Token Key Initialization Protocol
          (CT-KIP)</a>,&rdquo; November&nbsp;2006.</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC5280">[RFC5280]</a></td>
<td class="author-text"><a href="mailto:">Cooper, D.</a>, <a href="mailto:">Santesson, S.</a>, <a href="mailto:">Farrell, S.</a>, <a href="mailto:">Boeyen, S.</a>, Housley, R., and <a href="mailto:">W. Polk</a>, &ldquo;<a href="http://www.ietf.org/rfc/rfc5280.txt">Internet X.509 Public Key Infrastructure Certificate and
          Certificate Revocation List (CRL) Profile</a>,&rdquo; RFC&nbsp;5280, May&nbsp;2008.</td></tr>
<tr><td class="author-text" valign="top"><a name="SKPC-ASN.1">[SKPC-ASN.1]</a></td>
<td class="author-text">&ldquo;<a href="http://www.ietf.org/internet-drafts/draft-ietf-keyprov-symmetrickeyformat-01.txt">Symmetric Key Package Content Type</a>,&rdquo; 2007.</td></tr>
<tr><td class="author-text" valign="top"><a name="XMLNS">[XMLNS]</a></td>
<td class="author-text">W3C, &ldquo;<a href="http://www.w3.org/TR/1999/REC-xml-names-19990114 ">Namespaces in XML</a>,&rdquo; W3C&nbsp;Recommendation, January&nbsp;1999.</td></tr>
</table>

<a name="Section-Examples"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.A"></a><h3>Appendix A.&nbsp;
Examples</h3>

<p>This appendix contains example messages that illustrate parameters,
      encoding, and semantics in four-and two- pass DSKPP exchanges. The
      examples are written using XML, and are syntactically correct. MAC and
      cipher values are fictitious however.
</p>
<a name="anchor76"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.A.1"></a><h3>A.1.&nbsp;
Trigger Message</h3>

<p>
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;dskpp:KeyProvTrigger Version="1.0"
  xmlns:dskpp="urn:ietf:params:xml:ns:keyprov:dskpp:1.0"
  xmlns:pskc="urn:ietf:params:xml:ns:keyprov:pskc:1.0"&gt;
  &lt;dskpp:InitializationTrigger&gt;
    &lt;dskpp:DeviceIdentifierData&gt;
      &lt;dskpp:DeviceId&gt;
        &lt;pskc:Manufacturer&gt;ManufacturerABC&lt;/pskc:Manufacturer&gt;
        &lt;pskc:SerialNo&gt;XL0000000001234&lt;/pskc:SerialNo&gt;
        &lt;pskc:Model&gt;U2&lt;/pskc:Model&gt;
      &lt;/dskpp:DeviceId&gt;
    &lt;/dskpp:DeviceIdentifierData&gt;
    &lt;dskpp:KeyID&gt;SE9UUDAwMDAwMDAx&lt;/dskpp:KeyID&gt;
    &lt;dskpp:TokenPlatformInfo KeyLocation="Hardware"
      AlgorithmLocation="Software"/&gt;
    &lt;dskpp:TriggerNonce&gt;112dsdfwf312asder394jw==&lt;/dskpp:TriggerNonce&gt;
    &lt;dskpp:ServerUrl&gt;https://www.somekeyprovservice.com/
      &lt;/dskpp:ServerUrl&gt;
  &lt;/dskpp:InitializationTrigger&gt;
&lt;/dskpp:KeyProvTrigger&gt;
</pre></div>
<p>
</p>
<a name="anchor77"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.A.2"></a><h3>A.2.&nbsp;
Four-Pass Protocol</h3>

<a name="anchor78"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.A.2.1"></a><h3>A.2.1.&nbsp;
&lt;KeyProvClientHello&gt; Without a Preceding Trigger</h3>

<p>
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;dskpp:KeyProvClientHello Version="1.0"
  xmlns:dskpp="urn:ietf:params:xml:ns:keyprov:dskpp:1.0"
  xmlns:pskc="urn:ietf:params:xml:ns:keyprov:pskc:1.0"
  xmlns:ds="http://www.w3.org/2000/09/xmldsig#"&gt;
  &lt;dskpp:DeviceIdentifierData&gt;
    &lt;dskpp:DeviceId&gt;
      &lt;pskc:Manufacturer&gt;ManufacturerABC&lt;/pskc:Manufacturer&gt;
      &lt;pskc:SerialNo&gt;XL0000000001234&lt;/pskc:SerialNo&gt;
      &lt;pskc:Model&gt;U2&lt;/pskc:Model&gt;
    &lt;/dskpp:DeviceId&gt;
  &lt;/dskpp:DeviceIdentifierData&gt;
  &lt;dskpp:SupportedKeyTypes&gt;
    &lt;dskpp:Algorithm&gt;http://www.ietf.org/keyprov/pskc#hotp
      &lt;/dskpp:Algorithm&gt;
    &lt;dskpp:Algorithm&gt;http://www.rsa.com/rsalabs/otps/schemas/2005/09/
      otps-wst#SecurID-AES&lt;/dskpp:Algorithm&gt;
  &lt;/dskpp:SupportedKeyTypes&gt;
  &lt;dskpp:SupportedEncryptionAlgorithms&gt;
    &lt;dskpp:Algorithm&gt;http://www.w3.org/2001/05/xmlenc#rsa_1_5
      &lt;/dskpp:Algorithm&gt;
    &lt;dskpp:Algorithm&gt;http://www.ietf.org/keyprov/dskpp#dskpp-prf-aes-128
      &lt;/dskpp:Algorithm&gt;
  &lt;/dskpp:SupportedEncryptionAlgorithms&gt;
  &lt;dskpp:SupportedMacAlgorithms&gt;
    &lt;dskpp:Algorithm&gt;http://www.ietf.org/keyprov/dskpp#dskpp-prf-aes-128
      &lt;/dskpp:Algorithm&gt;
  &lt;/dskpp:SupportedMacAlgorithms&gt;
  &lt;dskpp:SupportedProtocolVariants&gt;&lt;dskpp:FourPass/&gt;
    &lt;/dskpp:SupportedProtocolVariants&gt;
  &lt;dskpp:SupportedKeyPackages&gt;
    &lt;dskpp:KeyPackageFormat&gt;
      http://www.ietf.org/keyprov/pskc#KeyContainer
    &lt;/dskpp:KeyPackageFormat&gt;
  &lt;/dskpp:SupportedKeyPackages&gt;
&lt;/dskpp:KeyProvClientHello&gt;
</pre></div>
<p>
</p>
<a name="anchor79"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.A.2.2"></a><h3>A.2.2.&nbsp;
&lt;KeyProvClientHello&gt; Assuming a Preceding Trigger</h3>

<p>
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>   &lt;?xml version="1.0" encoding="UTF-8"?&gt;
   &lt;dskpp:KeyProvClientHello Version="1.0"
     xmlns:dskpp="urn:ietf:params:xml:ns:keyprov:dskpp:1.0"
     xmlns:pskc="urn:ietf:params:xml:ns:keyprov:pskc:1.0"
     xmlns:ds="http://www.w3.org/2000/09/xmldsig#"&gt;
     &lt;dskpp:DeviceIdentifierData&gt;
       &lt;dskpp:DeviceId&gt;
         &lt;pskc:Manufacturer&gt;ManufacturerABC&lt;/pskc:Manufacturer&gt;
         &lt;pskc:SerialNo&gt;XL0000000001234&lt;/pskc:SerialNo&gt;
         &lt;pskc:Model&gt;U2&lt;/pskc:Model&gt;
       &lt;/dskpp:DeviceId&gt;
     &lt;/dskpp:DeviceIdentifierData&gt;
     &lt;dskpp:KeyID&gt;SE9UUDAwMDAwMDAx&lt;/dskpp:KeyID&gt;
     &lt;dskpp:TriggerNonce&gt;112dsdfwf312asder394jw==&lt;/dskpp:TriggerNonce&gt;
     &lt;dskpp:SupportedKeyTypes&gt;
       &lt;dskpp:Algorithm&gt;http://www.ietf.org/keyprov/pskc#hotp&lt;/dskpp:Algorithm&gt;
       &lt;dskpp:Algorithm&gt;http://www.rsa.com/rsalabs/otps/schemas/2005/09/
         otps-wst#SecurID-AES&lt;/dskpp:Algorithm&gt;
     &lt;/dskpp:SupportedKeyTypes&gt;
     &lt;dskpp:SupportedEncryptionAlgorithms&gt;
       &lt;dskpp:Algorithm&gt;http://www.w3.org/2001/05/xmlenc#rsa_1_5
       &lt;/dskpp:Algorithm&gt;
     &lt;dskpp:Algorithm&gt;http://www.ietf.org/keyprov/dskpp#dskpp-prf-aes-128
       &lt;/dskpp:Algorithm&gt;
     &lt;/dskpp:SupportedEncryptionAlgorithms&gt;
     &lt;dskpp:SupportedMacAlgorithms&gt;
       &lt;dskpp:Algorithm&gt;http://www.ietf.org/keyprov/dskpp#dskpp-prf-aes-128
         &lt;/dskpp:Algorithm&gt;
     &lt;/dskpp:SupportedMacAlgorithms&gt;
     &lt;dskpp:SupportedProtocolVariants&gt;&lt;dskpp:FourPass/&gt;
       &lt;/dskpp:SupportedProtocolVariants&gt;
     &lt;dskpp:SupportedKeyPackages&gt;
       &lt;dskpp:KeyPackageFormat&gt;
         http://www.ietf.org/keyprov/pskc#KeyContainer
       &lt;/dskpp:KeyPackageFormat&gt;
     &lt;/dskpp:SupportedKeyPackages&gt;
   &lt;/dskpp:KeyProvClientHello&gt;
</pre></div>
<p>
</p>
<a name="anchor80"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.A.2.3"></a><h3>A.2.3.&nbsp;
&lt;KeyProvServerHello&gt; Without a Preceding Trigger</h3>

<p>
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>   &lt;?xml version="1.0" encoding="UTF-8"?&gt;
   &lt;dskpp:KeyProvServerHello Version="1.0" SessionID="4114" Status="Continue"
     xmlns:dskpp="urn:ietf:params:xml:ns:keyprov:dskpp:1.0"
     xmlns:pskc="urn:ietf:params:xml:ns:keyprov:pskc:1.0"
     xmlns:ds="http://www.w3.org/2000/09/xmldsig#"&gt;
     &lt;dskpp:KeyType&gt;
       http://www.rsa.com/rsalabs/otps/schemas/2005/09/otps-wst#SecurID-AES
     &lt;/dskpp:KeyType&gt;
     &lt;dskpp:EncryptionAlgorithm&gt;
       http://www.ietf.org/keyprov/dskpp#dskpp-prf-aes-128
     &lt;/dskpp:EncryptionAlgorithm&gt;
     &lt;dskpp:MacAlgorithm&gt;
       http://www.ietf.org/keyprov/dskpp#dskpp-prf-aes-128
     &lt;/dskpp:MacAlgorithm&gt;
     &lt;dskpp:EncryptionKey&gt;
       &lt;ds:KeyName&gt;KEY-1&lt;/ds:KeyName&gt;
     &lt;/dskpp:EncryptionKey&gt;
     &lt;dskpp:KeyPackageFormat&gt;
       http://www.ietf.org/keyprov/pskc#KeyContainer
     &lt;/dskpp:KeyPackageFormat&gt;
     &lt;dskpp:Payload&gt;
       &lt;dskpp:Nonce&gt;qw2ewasde312asder394jw==&lt;/dskpp:Nonce&gt;
     &lt;/dskpp:Payload&gt;
   &lt;/dskpp:KeyProvServerHello&gt;
</pre></div>
<p>
</p>
<a name="anchor81"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.A.2.4"></a><h3>A.2.4.&nbsp;
&lt;KeyProvServerHello&gt; Assuming a Preceding Trigger</h3>

<p>
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;dskpp:KeyProvServerHello Version="1.0" SessionID="4114"
  Status="Continue"
  xmlns:dskpp="urn:ietf:params:xml:ns:keyprov:dskpp:1.0"
  xmlns:pskc="urn:ietf:params:xml:ns:keyprov:pskc:1.0"
  xmlns:ds="http://www.w3.org/2000/09/xmldsig#"&gt;
  &lt;dskpp:KeyType&gt;
    urn:ietf:params:xml:schema:keyprov:otpalg#SecurID-AES
  &lt;/dskpp:KeyType&gt;
  &lt;dskpp:EncryptionAlgorithm&gt;
    http://www.ietf.org/keyprov/dskpp#dskpp-prf-aes-128
  &lt;/dskpp:EncryptionAlgorithm&gt;
  &lt;dskpp:MacAlgorithm&gt;
    http://www.ietf.org/keyprov/dskpp#dskpp-prf-aes-128
  &lt;/dskpp:MacAlgorithm&gt;
  &lt;dskpp:EncryptionKey&gt;
    &lt;ds:KeyName&gt;KEY-1&lt;/ds:KeyName&gt;
  &lt;/dskpp:EncryptionKey&gt;
  &lt;dskpp:KeyPackageFormat&gt;
    http://www.ietf.org/keyprov/pskc#KeyContainer
  &lt;/dskpp:KeyPackageFormat&gt;
  &lt;dskpp:Payload&gt;
    &lt;dskpp:Nonce&gt;qw2ewasde312asder394jw==&lt;/dskpp:Nonce&gt;
  &lt;/dskpp:Payload&gt;
  &lt;dskpp:Mac
    MacAlgorithm="http://www.ietf.org/keyprov/dskpp#dskpp-prf-aes-128"&gt;
    cXcycmFuZG9tMzEyYXNkZXIzOTRqdw==
  &lt;/dskpp:Mac&gt;
&lt;/dskpp:KeyProvServerHello&gt;
</pre></div>
<p>
</p>
<a name="anchor82"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.A.2.5"></a><h3>A.2.5.&nbsp;
&lt;KeyProvClientNonce&gt; Using Default Encryption</h3>

<p>This message contains the nonce chosen by the cryptographic
          module, R_C, encrypted by the specified encryption key and
          encryption algorithm.
</p>
<p>
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;dskpp:KeyProvClientNonce Version="1.0" SessionID="4114"
  xmlns:dskpp="urn:ietf:params:xml:ns:keyprov:dskpp:1.0"&gt;
  &lt;dskpp:EncryptedNonce&gt;VXENc+Um/9/NvmYKiHDLaErK0gk=
    &lt;/dskpp:EncryptedNonce&gt;
  &lt;dskpp:AuthenticationData&gt;
    &lt;dskpp:ClientID&gt;31300257&lt;/dskpp:ClientID&gt;
    &lt;dskpp:AuthenticationCodeMac&gt;
      &lt;dskpp:IterationCount&gt;512&lt;/dskpp:IterationCount&gt;
      &lt;dskpp:Mac&gt;4bRJf9xXd3KchKoTenHJiw==&lt;/dskpp:Mac&gt;
    &lt;/dskpp:AuthenticationCodeMac&gt;
  &lt;/dskpp:AuthenticationData&gt;
&lt;/dskpp:KeyProvClientNonce&gt;
</pre></div>
<p>
</p>
<a name="anchor83"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.A.2.6"></a><h3>A.2.6.&nbsp;
&lt;KeyProvServerFinished&gt; Using Default Encryption</h3>

<p>
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>   &lt;?xml version="1.0" encoding="UTF-8"?&gt;
   &lt;dskpp:KeyProvServerFinished Version="1.0" SessionID="4114" Status="Success"
     xmlns:dskpp="urn:ietf:params:xml:ns:keyprov:dskpp:1.0"
     xmlns:pskc="urn:ietf:params:xml:ns:keyprov:pskc:1.0"&gt;
     &lt;dskpp:KeyPackage&gt;
       &lt;dskpp:KeyPackage Version="1.0"&gt;
         &lt;pskc:MACAlgorithm&gt;http://www.w3.org/2000/09/xmldsig#hmac-sha1
         &lt;/pskc:MACAlgorithm&gt;
         &lt;pskc:Device&gt;
           &lt;pskc:Key
             KeyAlgorithm="http://www.rsa.com/rsalabs/otps/schemas/2005/09/
               otps-wst#SecurID-AES"
             KeyId="XL0000000001234"&gt;
             &lt;pskc:Issuer&gt;CredentialIssuer&lt;/pskc:Issuer&gt;
             &lt;pskc:Usage OTP="true"&gt;
               &lt;pskc:ResponseFormat Format="DECIMAL" Length="6"/&gt;
             &lt;/pskc:Usage&gt;
             &lt;pskc:FriendlyName&gt;MyFirstToken&lt;/pskc:FriendlyName&gt;
             &lt;pskc:Data&gt;
               &lt;pskc:Time&gt;
                 &lt;pskc:PlainValue&gt;0&lt;/pskc:PlainValue&gt;
               &lt;/pskc:Time&gt;
             &lt;/pskc:Data&gt;
             &lt;pskc:ExpiryDate&gt;2012-12-31T00:00:00&lt;/pskc:ExpiryDate&gt;
           &lt;/pskc:Key&gt;
         &lt;/pskc:Device&gt;
       &lt;/dskpp:KeyPackage&gt;
     &lt;/dskpp:KeyPackage&gt;
     &lt;dskpp:Mac
       MacAlgorithm="http://www.ietf.org/keyprov/dskpp#dskpp-prf-aes-128"&gt;
       miidfasde312asder394jw==
     &lt;/dskpp:Mac&gt;
   &lt;/dskpp:KeyProvServerFinished&gt;
</pre></div>
<p>
</p>
<a name="anchor84"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.A.3"></a><h3>A.3.&nbsp;
Two-Pass Protocol</h3>

<a name="Example-TwoPass-1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.A.3.1"></a><h3>A.3.1.&nbsp;
Example Using the Key Transport Profile</h3>

<p>The client indicates support all the Key Transport, Key Wrap, and
          Passphrase-Based Key Wrap profiles:
</p>
<p>
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>   &lt;?xml version="1.0" encoding="UTF-8"?&gt;
   &lt;dskpp:KeyProvClientHello Version="1.0"
     xmlns:dskpp="urn:ietf:params:xml:ns:keyprov:dskpp:1.0"
     xmlns:pskc="urn:ietf:params:xml:ns:keyprov:pskc:1.0"
     xmlns:ds="http://www.w3.org/2000/09/xmldsig#"&gt;
     &lt;dskpp:DeviceIdentifierData&gt;
       &lt;dskpp:DeviceId&gt;
         &lt;pskc:Manufacturer&gt;ManufacturerABC&lt;/pskc:Manufacturer&gt;
         &lt;pskc:SerialNo&gt;XL0000000001234&lt;/pskc:SerialNo&gt;
         &lt;pskc:Model&gt;U2&lt;/pskc:Model&gt;
       &lt;/dskpp:DeviceId&gt;
     &lt;/dskpp:DeviceIdentifierData&gt;
     &lt;dskpp:ClientNonce&gt;xwQzwEl0CjPAiQeDxwRJdQ==&lt;/dskpp:ClientNonce&gt;
     &lt;dskpp:SupportedKeyTypes&gt;
       &lt;dskpp:Algorithm&gt;http://www.ietf.org/keyprov/pskc#hotp
         &lt;/dskpp:Algorithm&gt;
       &lt;dskpp:Algorithm&gt;
         http://www.rsa.com/rsalabs/otps/schemas/2005/09/otps-wst#SecurID-AES
       &lt;/dskpp:Algorithm&gt;
     &lt;/dskpp:SupportedKeyTypes&gt;
     &lt;dskpp:SupportedEncryptionAlgorithms&gt;
       &lt;dskpp:Algorithm&gt;http://www.w3.org/2001/05/xmlenc#rsa_1_5
         &lt;/dskpp:Algorithm&gt;
       &lt;dskpp:Algorithm&gt;http://www.w3.org/2001/04/xmlenc#kw-aes128
         &lt;/dskpp:Algorithm&gt;
       &lt;dskpp:Algorithm&gt;http://www.ietf.org/keyprov/dskpp#dskpp-prf-aes-128
         &lt;/dskpp:Algorithm&gt;
     &lt;/dskpp:SupportedEncryptionAlgorithms&gt;
     &lt;dskpp:SupportedMacAlgorithms&gt;
       &lt;dskpp:Algorithm&gt;http://www.ietf.org/keyprov/dskpp#dskpp-prf-aes-128
         &lt;/dskpp:Algorithm&gt;
     &lt;/dskpp:SupportedMacAlgorithms&gt;
     &lt;dskpp:SupportedProtocolVariants&gt;
       &lt;dskpp:TwoPass&gt;
         &lt;dskpp:SupportedKeyProtectionMethod&gt;
           urn:ietf:params:xml:schema:keyprov:dskpp#wrap
         &lt;/dskpp:SupportedKeyProtectionMethod&gt;
         &lt;dskpp:Payload&gt;
             &lt;ds:KeyInfo xsi:type="ds:KeyInfoType"&gt;
                 &lt;ds:KeyName&gt;Key_001&lt;/ds:KeyName&gt;
             &lt;/ds:KeyInfo&gt;
         &lt;/dskpp:Payload&gt;
         &lt;dskpp:SupportedKeyProtectionMethod&gt;
           urn:ietf:params:xml:schema:keyprov:dskpp#transport
         &lt;/dskpp:SupportedKeyProtectionMethod&gt;
         &lt;dskpp:SupportedKeyProtectionMethod&gt;
           urn:ietf:params:xml:schema:keyprov:dskpp#passphrase-wrap
         &lt;/dskpp:SupportedKeyProtectionMethod&gt;
         &lt;dskpp:Payload&gt;
            &lt;ds:KeyInfo xsi:type="ds:KeyInfoType"&gt;
                &lt;ds:X509Data&gt;
                    &lt;ds:X509Certificate&gt;miib&lt;/ds:X509Certificate&gt;
                &lt;/ds:X509Data&gt;
            &lt;/ds:KeyInfo&gt;
         &lt;/dskpp:Payload&gt;
       &lt;/dskpp:TwoPass&gt;
     &lt;/dskpp:SupportedProtocolVariants&gt;
     &lt;dskpp:SupportedKeyPackages&gt;
       &lt;dskpp:KeyPackageFormat&gt;
         http://www.ietf.org/keyprov/pskc#KeyContainer
       &lt;/dskpp:KeyPackageFormat&gt;
     &lt;/dskpp:SupportedKeyPackages&gt;
     &lt;dskpp:AuthenticationData&gt;
       &lt;dskpp:ClientID&gt;31300257&lt;/dskpp:ClientID&gt;
       &lt;dskpp:AuthenticationCodeMac&gt;
         &lt;dskpp:IterationCount&gt;512&lt;/dskpp:IterationCount&gt;
         &lt;dskpp:Mac&gt;4bRJf9xXd3KchKoTenHJiw==&lt;/dskpp:Mac&gt;
       &lt;/dskpp:AuthenticationCodeMac&gt;
     &lt;/dskpp:AuthenticationData&gt;
   &lt;/dskpp:KeyProvClientHello&gt;
</pre></div>
<p>
</p>
<p>In this example, the server responds to the previous request
          using the key transport profile.
</p>
<p>
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>   &lt;?xml version="1.0" encoding="UTF-8"?&gt;
   &lt;dskpp:KeyProvServerFinished Version="1.0" SessionID="4114"
     Status="Success"
     xmlns:dskpp="urn:ietf:params:xml:ns:keyprov:dskpp:1.0"
     xmlns:pskc="urn:ietf:params:xml:ns:keyprov:pskc:1.0"
     xmlns:ds="http://www.w3.org/2000/09/xmldsig#"
     xmlns:xenc="http://www.w3.org/2001/04/xmlenc#"&gt;
     &lt;dskpp:KeyPackage&gt;
       &lt;dskpp:ServerID&gt;https://www.somedskppservice.com/&lt;/dskpp:ServerID&gt;
         &lt;dskpp:KeyProtectionMethod&gt;
           urn:ietf:params:xml:schema:keyprov:dskpp#transport
         &lt;/dskpp:KeyProtectionMethod&gt;
       &lt;dskpp:KeyPackage Version="1.0"&gt;
         &lt;pskc:EncryptionKey&gt;
           &lt;ds:X509Data&gt;
             &lt;ds:X509Certificate&gt;miib&lt;/ds:X509Certificate&gt;
           &lt;/ds:X509Data&gt;
         &lt;/pskc:EncryptionKey&gt;
         &lt;pskc:Device&gt;
           &lt;pskc:DeviceInfo&gt;
             &lt;pskc:Manufacturer&gt;ACME&lt;/pskc:Manufacturer&gt;
             &lt;pskc:SerialNo&gt;0755225266&lt;/pskc:SerialNo&gt;
           &lt;/pskc:DeviceInfo&gt;
           &lt;pskc:Key KeyAlgorithm="http://www.ietf.org/keyprov/pskc#hotp"
             KeyId="0755225266"&gt;
             &lt;pskc:Issuer&gt;AnIssuer&lt;/pskc:Issuer&gt;
             &lt;pskc:Usage OTP="true"&gt;
               &lt;pskc:ResponseFormat Length="8" Format="DECIMAL"/&gt;
             &lt;/pskc:Usage&gt;
             &lt;pskc:Data&gt;
               &lt;pskc:Secret&gt;
                 &lt;pskc:EncryptedValue Id="ED"&gt;
                   &lt;xenc:EncryptionMethod
                     Algorithm="http://www.w3.org/2001/04/xmlenc#rsa_1_5"/&gt;
                   &lt;xenc:CipherData&gt;
                     &lt;xenc:CipherValue&gt;rf4dx3rvEPO0vKtKL14NbeVu8nk=
                     &lt;/xenc:CipherValue&gt;
                   &lt;/xenc:CipherData&gt;
                 &lt;/pskc:EncryptedValue&gt;
               &lt;/pskc:Secret&gt;
               &lt;pskc:Counter&gt;
                 &lt;pskc:PlainValue&gt;0&lt;/pskc:PlainValue&gt;
               &lt;/pskc:Counter&gt;
             &lt;/pskc:Data&gt;
           &lt;/pskc:Key&gt;
         &lt;/pskc:Device&gt;
       &lt;/dskpp:KeyPackage&gt;
     &lt;/dskpp:KeyPackage&gt;
     &lt;dskpp:Mac
       MacAlgorithm="http://www.ietf.org/keyprov/dskpp#dskpp-prf-aes-128"&gt;
       miidfasde312asder394jw==
     &lt;/dskpp:Mac&gt;
     &lt;dskpp:AuthenticationData&gt;
       &lt;dskpp:Mac&gt;4bRJf9xXd3KchKoTenHJiw==&lt;/dskpp:Mac&gt;
     &lt;/dskpp:AuthenticationData&gt;
   &lt;/dskpp:KeyProvServerFinished&gt;
</pre></div>
<p>
</p>
<a name="anchor85"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.A.3.2"></a><h3>A.3.2.&nbsp;
Example Using the Key Wrap Profile</h3>

<p>The client sends a request that specifies a shared key to protect
          the K_TOKEN, and the server responds using the Key Wrap Profile.
          Authentication data in this example is based on an authentication
          code rather than a device certificate.
</p>
<p>
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>   &lt;?xml version="1.0" encoding="UTF-8"?&gt;
   &lt;dskpp:KeyProvClientHello Version="1.0"
     xmlns:dskpp="urn:ietf:params:xml:ns:keyprov:dskpp:1.0"
     xmlns:pskc="urn:ietf:params:xml:ns:keyprov:pskc:1.0"
     xmlns:ds="http://www.w3.org/2000/09/xmldsig#"
     xmlns:pkcs-5=
       "http://www.rsasecurity.com/rsalabs/pkcs/schemas/pkcs-5v2-0#"&gt;
     &lt;dskpp:DeviceIdentifierData&gt;
       &lt;dskpp:DeviceId&gt;
         &lt;pskc:Manufacturer&gt;ManufacturerABC&lt;/pskc:Manufacturer&gt;
         &lt;pskc:SerialNo&gt;XL0000000001234&lt;/pskc:SerialNo&gt;
         &lt;pskc:Model&gt;U2&lt;/pskc:Model&gt;
       &lt;/dskpp:DeviceId&gt;
     &lt;/dskpp:DeviceIdentifierData&gt;
     &lt;dskpp:ClientNonce&gt;xwQzwEl0CjPAiQeDxwRJdQ==&lt;/dskpp:ClientNonce&gt;
     &lt;dskpp:SupportedKeyTypes&gt;
       &lt;dskpp:Algorithm&gt;http://www.ietf.org/keyprov/pskc#hotp
         &lt;/dskpp:Algorithm&gt;
       &lt;dskpp:Algorithm&gt;http://www.rsa.com/rsalabs/otps/schemas/2005/09/
         otps-wst#SecurID-AES&lt;/dskpp:Algorithm&gt;
     &lt;/dskpp:SupportedKeyTypes&gt;
     &lt;dskpp:SupportedEncryptionAlgorithms&gt;
       &lt;dskpp:Algorithm&gt;http://www.w3.org/2001/05/xmlenc#rsa_1_5
         &lt;/dskpp:Algorithm&gt;
       &lt;dskpp:Algorithm&gt;http://www.w3.org/2001/04/xmlenc#kw-aes128
         &lt;/dskpp:Algorithm&gt;
       &lt;dskpp:Algorithm&gt;http://www.rsasecurity.com/rsalabs/pkcs/schemas/
         pkcs-5#pbes2&lt;/dskpp:Algorithm&gt;
       &lt;dskpp:Algorithm&gt;http://www.ietf.org/keyprov/dskpp#dskpp-prf-aes-128
         &lt;/dskpp:Algorithm&gt;
     &lt;/dskpp:SupportedEncryptionAlgorithms&gt;
     &lt;dskpp:SupportedMacAlgorithms&gt;
       &lt;dskpp:Algorithm&gt;http://www.ietf.org/keyprov/dskpp#dskpp-prf-aes-128
         &lt;/dskpp:Algorithm&gt;
     &lt;/dskpp:SupportedMacAlgorithms&gt;
     &lt;dskpp:SupportedProtocolVariants&gt;
       &lt;dskpp:TwoPass&gt;
         &lt;dskpp:SupportedKeyProtectionMethod&gt;
           urn:ietf:params:xml:schema:keyprov:dskpp#wrap
         &lt;/dskpp:SupportedKeyProtectionMethod&gt;
         &lt;dskpp:Payload&gt;
           &lt;ds:KeyInfo xsi:type="ds:KeyInfoType"&gt;
             &lt;ds:KeyName&gt;Key_001&lt;/ds:KeyName&gt;
           &lt;/ds:KeyInfo&gt;
         &lt;/dskpp:Payload&gt;
       &lt;/dskpp:TwoPass&gt;
     &lt;/dskpp:SupportedProtocolVariants&gt;
     &lt;dskpp:SupportedKeyPackages&gt;
       &lt;dskpp:KeyPackageFormat&gt;
         http://www.ietf.org/keyprov/pskc#KeyContainer
       &lt;/dskpp:KeyPackageFormat&gt;
     &lt;/dskpp:SupportedKeyPackages&gt;
     &lt;dskpp:AuthenticationData&gt;
       &lt;dskpp:ClientID&gt;31300257&lt;/dskpp:ClientID&gt;
       &lt;dskpp:AuthenticationCodeMac&gt;
         &lt;dskpp:IterationCount&gt;512&lt;/dskpp:IterationCount&gt;
         &lt;dskpp:Mac&gt;4bRJf9xXd3KchKoTenHJiw==&lt;/dskpp:Mac&gt;
       &lt;/dskpp:AuthenticationCodeMac&gt;
     &lt;/dskpp:AuthenticationData&gt;
   &lt;/dskpp:KeyProvClientHello&gt;
</pre></div>
<p>
</p>
<p>In this example, the server responds to the previous request
          using the key wrap profile.
</p>
<p>
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>   &lt;?xml version="1.0" encoding="UTF-8"?&gt;

   &lt;dskpp:KeyProvServerFinished Version="1.0" Status="Success"
     xmlns:dskpp="urn:ietf:params:xml:ns:keyprov:dskpp:1.0"
     xmlns:pskc="urn:ietf:params:xml:ns:keyprov:pskc:1.0"
     xmlns:ds="http://www.w3.org/2000/09/xmldsig#"
     xmlns:xenc="http://www.w3.org/2001/04/xmlenc#"&gt;
     &lt;dskpp:KeyPackage&gt;
       &lt;dskpp:ServerID&gt;https://www.somedskppservice.com/&lt;/dskpp:ServerID&gt;
       &lt;dskpp:KeyProtectionMethod&gt;
         urn:ietf:params:xml:schema:keyprov:dskpp#wrap
       &lt;/dskpp:KeyProtectionMethod&gt;
       &lt;dskpp:KeyPackage Version="1.0"&gt;
        &lt;pskc:EncryptionKey&gt;
          &lt;ds:KeyName&gt;PRE_SHARED_KEY&lt;/ds:KeyName&gt;
        &lt;/pskc:EncryptionKey&gt;
        &lt;pskc:MACAlgorithm&gt;http://www.w3.org/2000/09/xmldsig#hmac-sha1
        &lt;/pskc:MACAlgorithm&gt;
        &lt;pskc:Device&gt;
          &lt;pskc:Key KeyAlgorithm="http://www.ietf.org/keyprov/pskc#hotp"
            KeyId="312345678"&gt;
            &lt;pskc:Issuer&gt;CredentialIssuer&lt;/pskc:Issuer&gt;
            &lt;pskc:Usage OTP="true"&gt;
              &lt;pskc:ResponseFormat Format="DECIMAL" Length="6"/&gt;
            &lt;/pskc:Usage&gt;
            &lt;pskc:FriendlyName&gt;MyFirstToken&lt;/pskc:FriendlyName&gt;
              &lt;pskc:Data&gt;
                &lt;pskc:Secret&gt;
                  &lt;pskc:EncryptedValue&gt;
                    &lt;xenc:EncryptionMethod
                      Algorithm="http://www.w3.org/2001/04/xmlenc#aes256-cbc"/&gt;
                    &lt;xenc:CipherData&gt;
                      &lt;xenc:CipherValue&gt;
                        kyzrWTJuhJKQHhZtf2CWbKC5H3LdfAPvKzHHQ8SdxyE=
                      &lt;/xenc:CipherValue&gt;
                    &lt;/xenc:CipherData&gt;
                  &lt;/pskc:EncryptedValue&gt;
                  &lt;pskc:ValueMAC&gt;cwJI898rRpGBytTqCAsegaQqPZA=
                  &lt;/pskc:ValueMAC&gt;
                &lt;/pskc:Secret&gt;
                &lt;pskc:Counter&gt;
                  &lt;pskc:PlainValue&gt;1/pskc:PlainValue&gt;
                &lt;/pskc:Counter&gt;
              &lt;/pskc:Data&gt;
              &lt;pskc:ExpiryDate&gt;2012-12-31T00:00:00&lt;/pskc:ExpiryDate&gt;
            &lt;/pskc:Key&gt;
          &lt;/pskc:Device&gt;
       &lt;/dskpp:KeyPackage&gt;
     &lt;/dskpp:KeyPackage&gt;
     &lt;dskpp:Mac
       MacAlgorithm="http://www.ietf.org/keyprov/dskpp#dskpp-prf-aes-128"&gt;
       miidfasde312asder394jw==
     &lt;/dskpp:Mac&gt;
     &lt;dskpp:AuthenticationData&gt;
       &lt;dskpp:Mac&gt;4bRJf9xXd3KchKoTenHJiw==&lt;/dskpp:Mac&gt;
     &lt;/dskpp:AuthenticationData&gt;
   &lt;/dskpp:KeyProvServerFinished&gt;
</pre></div>
<p>
</p>
<a name="anchor86"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.A.3.3"></a><h3>A.3.3.&nbsp;
Example Using the Passphrase-Based Key Wrap Profile</h3>

<p>The client sends a request similar to that in <a class='info' href='#Example-TwoPass-1'>Appendix&nbsp;A.3.1<span> (</span><span class='info'>Example Using the Key Transport Profile</span><span>)</span></a> with authentication data based on
          an authentication code, and the server responds using the
          Passphrase-Based Key Wrap Profile. The authentication data is set in
          clear text when it is sent over a secure transport channel such as
          TLS.
</p>
<p>
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>   &lt;?xml version="1.0" encoding="UTF-8"?&gt;
   &lt;dskpp:KeyProvClientHello Version="1.0"
     xmlns:dskpp="urn:ietf:params:xml:ns:keyprov:dskpp:1.0"
     xmlns:pskc="urn:ietf:params:xml:ns:keyprov:pskc:1.0"
     xmlns:ds="http://www.w3.org/2000/09/xmldsig#"
     xmlns:pkcs-5=
       "http://www.rsasecurity.com/rsalabs/pkcs/schemas/pkcs-5v2-0#"&gt;
     &lt;dskpp:DeviceIdentifierData&gt;
       &lt;dskpp:DeviceId&gt;
         &lt;pskc:Manufacturer&gt;ManufacturerABC&lt;/pskc:Manufacturer&gt;
         &lt;pskc:SerialNo&gt;XL0000000001234&lt;/pskc:SerialNo&gt;
         &lt;pskc:Model&gt;U2&lt;/pskc:Model&gt;
       &lt;/dskpp:DeviceId&gt;
     &lt;/dskpp:DeviceIdentifierData&gt;
     &lt;dskpp:ClientNonce&gt;xwQzwEl0CjPAiQeDxwRJdQ==&lt;/dskpp:ClientNonce&gt;
     &lt;dskpp:SupportedKeyTypes&gt;
       &lt;dskpp:Algorithm&gt;http://www.ietf.org/keyprov/pskc#hotp
         &lt;/dskpp:Algorithm&gt;
       &lt;dskpp:Algorithm&gt;
         http://www.rsa.com/rsalabs/otps/schemas/2005/09/otps-wst#SecurID-AES
       &lt;/dskpp:Algorithm&gt;
     &lt;/dskpp:SupportedKeyTypes&gt;
     &lt;dskpp:SupportedEncryptionAlgorithms&gt;
       &lt;dskpp:Algorithm&gt;http://www.w3.org/2001/05/xmlenc#rsa_1_5
         &lt;/dskpp:Algorithm&gt;
       &lt;dskpp:Algorithm&gt;http://www.w3.org/2001/04/xmlenc#kw-aes128
         &lt;/dskpp:Algorithm&gt;
       &lt;dskpp:Algorithm&gt;
         http://www.rsasecurity.com/rsalabs/pkcs/schemas/pkcs-5#pbes2
       &lt;/dskpp:Algorithm&gt;
       &lt;dskpp:Algorithm&gt;
         http://www.ietf.org/keyprov/dskpp#dskpp-prf-aes-128
       &lt;/dskpp:Algorithm&gt;
     &lt;/dskpp:SupportedEncryptionAlgorithms&gt;
     &lt;dskpp:SupportedMacAlgorithms&gt;
       &lt;dskpp:Algorithm&gt;
         http://www.ietf.org/keyprov/dskpp#dskpp-prf-aes-128
       &lt;/dskpp:Algorithm&gt;
     &lt;/dskpp:SupportedMacAlgorithms&gt;
     &lt;dskpp:SupportedProtocolVariants&gt;
       &lt;dskpp:TwoPass&gt;
         &lt;dskpp:SupportedKeyProtectionMethod&gt;
           urn:ietf:params:xml:schema:keyprov:dskpp#wrap
         &lt;/dskpp:SupportedKeyProtectionMethod&gt;
         &lt;dskpp:Payload&gt;
           &lt;ds:KeyInfo xsi:type="ds:KeyInfoType"&gt;
             &lt;ds:KeyName&gt;Key_001&lt;/ds:KeyName&gt;
           &lt;/ds:KeyInfo&gt;
         &lt;/dskpp:Payload&gt;
         &lt;dskpp:SupportedKeyProtectionMethod&gt;
           urn:ietf:params:xml:schema:keyprov:dskpp#passphrase-wrap
         &lt;/dskpp:SupportedKeyProtectionMethod&gt;
       &lt;/dskpp:TwoPass&gt;
     &lt;/dskpp:SupportedProtocolVariants&gt;
     &lt;dskpp:SupportedKeyPackages&gt;
       &lt;dskpp:KeyPackageFormat&gt;
         http://www.ietf.org/keyprov/pskc#KeyContainer
       &lt;/dskpp:KeyPackageFormat&gt;
     &lt;/dskpp:SupportedKeyPackages&gt;
     &lt;dskpp:AuthenticationData&gt;
       &lt;dskpp:ClientID&gt;31300257&lt;/dskpp:ClientID&gt;
       &lt;dskpp:AuthenticationCodeMac&gt;
         &lt;dskpp:IterationCount&gt;512&lt;/dskpp:IterationCount&gt;
         &lt;dskpp:Mac&gt;4bRJf9xXd3KchKoTenHJiw==&lt;/dskpp:Mac&gt;
       &lt;/dskpp:AuthenticationCodeMac&gt;
     &lt;/dskpp:AuthenticationData&gt;
   &lt;/dskpp:KeyProvClientHello&gt;
</pre></div>
<p>
</p>
<p>In this example, the server responds to the previous request
          using the Passphrase-Based Key Wrap Profile.
</p>
<p>(preamble)
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;dskpp:KeyProvServerFinished Version="1.0" SessionID="4114" Status="Success" xmlns:dskpp="urn:ietf:params:xml:ns:keyprov:dskpp:1.0" xmlns:pskc="urn:ietf:params:xml:ns:keyprov:pskc:1.0" xmlns:pkcs-5="http://www.rsasecurity.com/rsalabs/pkcs/schemas/pkcs-5v2-0#" xmlns:ds="http://www.w3.org/2000/09/xmldsig#" xmlns:xenc="http://www.w3.org/2001/04/xmlenc#" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:ietf:params:xml:ns:keyprov:dskpp:1.0 keyprov-dskpp-1.0-local.xsd http://www.rsasecurity.com/rsalabs/pkcs/schemas/pkcs-5v2-0# pkcs-5v2-0a1.xsd"&gt;
  &lt;dskpp:KeyPackage&gt;
    &lt;dskpp:ServerID&gt;https://www.somedskppservice.com/&lt;/dskpp:ServerID&gt;
    &lt;dskpp:KeyProtectionMethod&gt;
       urn:ietf:params:xml:schema:keyprov:protocol#passphrase-wrap
    &lt;/dskpp:KeyProtectionMethod&gt;
    &lt;dskpp:KeyPackage Version="1.0"&gt;
      &lt;pskc:EncryptionKey&gt;
        &lt;pskc:DerivedKey&gt;
          &lt;pskc:CarriedKeyName&gt;Passphrase1&lt;/pskc:CarriedKeyName&gt;
          &lt;pskc:KeyDerivationMethod Algorithm="http://www.rsasecurity.com/rsalabs/pkcs/schemas/pkcs-5#pbkdf2"&gt;
            &lt;pkcs-5:PBKDF2-params&gt;
              &lt;Salt&gt;
                &lt;Specified&gt;P1ciQdGbrI0=&lt;/Specified&gt;
              &lt;/Salt&gt;
              &lt;IterationCount&gt;2000&lt;/IterationCount&gt;
              &lt;KeyLength&gt;16&lt;/KeyLength&gt;
              &lt;PRF/&gt;
            &lt;/pkcs-5:PBKDF2-params&gt;
          &lt;/pskc:KeyDerivationMethod&gt;
          &lt;xenc:ReferenceList&gt;
            &lt;xenc:DataReference URI="#ED"/&gt;
          &lt;/xenc:ReferenceList&gt;
       &lt;/pskc:DerivedKey&gt;
      &lt;/pskc:EncryptionKey&gt;
      &lt;pskc:Device&gt;
        &lt;pskc:DeviceInfo&gt;
          &lt;pskc:Manufacturer&gt;Manufacturer&lt;/pskc:Manufacturer&gt;
          &lt;pskc:SerialNo&gt;0755225266&lt;/pskc:SerialNo&gt;
        &lt;/pskc:DeviceInfo&gt;
        &lt;pskc:Key KeyAlgorithm="http://www.ietf.org/keyprov/pskc#hotp" KeyId="0755225266"&gt;
          &lt;pskc:Issuer&gt;AnIssuer&lt;/pskc:Issuer&gt;
          &lt;pskc:Usage OTP="true"&gt;
            &lt;pskc:ResponseFormat Length="6" Format="DECIMAL"/&gt;
          &lt;/pskc:Usage&gt;
          &lt;pskc:Data&gt;
            &lt;pskc:Secret&gt;
              &lt;pskc:EncryptedValue&gt;
                &lt;xenc:EncryptionMethod Algorithm="http://www.rsasecurity.com/rsalabs/pkcs/schemas/pkcs-5#pbes2"&gt;
                  &lt;pskc:EncryptionScheme Algorithm="http://www.w3.org/2001/04/xmlenc#aes128-cbc"/&gt;
                &lt;/xenc:EncryptionMethod&gt;
                &lt;xenc:CipherData&gt;
                  &lt;xenc:CipherValue&gt;rf4dx3rvEPO0vKtKL14NbeVu8nk=
                    &lt;/xenc:CipherValue&gt;
                &lt;/xenc:CipherData&gt;
              &lt;/pskc:EncryptedValue&gt;
            &lt;/pskc:Secret&gt;
            &lt;pskc:Counter&gt;
              &lt;pskc:PlainValue&gt;0&lt;/pskc:PlainValue&gt;
            &lt;/pskc:Counter&gt;
          &lt;/pskc:Data&gt;
        &lt;/pskc:Key&gt;
      &lt;/pskc:Device&gt;
    &lt;/dskpp:KeyPackage&gt;
  &lt;/dskpp:KeyPackage&gt;
  &lt;dskpp:Mac MacAlgorithm="http://www.ietf.org/keyprov/dskpp#dskpp-prf-aes"&gt;
     miidfasde312asder394jw==
  &lt;/dskpp:Mac&gt;
  &lt;dskpp:AuthenticationData&gt;
    &lt;dskpp:Mac&gt;4bRJf9xXd3KchKoTenHJiw==&lt;/dskpp:Mac&gt;
  &lt;/dskpp:AuthenticationData&gt;
&lt;/dskpp:KeyProvServerFinished&gt;</pre></div>
<p>(postamble)
</p>
<a name="Section-Integration"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.B"></a><h3>Appendix B.&nbsp;
Integration with PKCS #11</h3>

<p>A DSKPP client that needs to communicate with a connected
      cryptographic module to perform a DSKPP exchange MAY use PKCS #11 <a class='info' href='#PKCS-11'>[PKCS&#8209;11]<span> (</span><span class='info'>RSA Laboratories, &ldquo;Cryptographic Token Interface Standard,&rdquo; June&nbsp;2004.</span><span>)</span></a> as a programming interface.
</p>
<a name="anchor87"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.B.1"></a><h3>B.1.&nbsp;
The 4-pass Variant</h3>

<p>When performing 4-pass DSKPP with a cryptographic module using the
        PKCS #11 programming interface, the procedure described in <a class='info' href='#CT-KIP-P11'>[CT&#8209;KIP&#8209;P11]<span> (</span><span class='info'>RSA Laboratories, &ldquo;PKCS #11 Mechanisms for the Cryptographic Token Key           Initialization Protocol,&rdquo; December&nbsp;2005.</span><span>)</span></a>, Appendix B, is RECOMMENDED.
</p>
<a name="anchor88"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.B.2"></a><h3>B.2.&nbsp;
The 2-pass Variant</h3>

<p>A suggested procedure to perform 2-pass DSKPP with a cryptographic
        module through the PKCS #11 interface using the mechanisms defined in
        <a class='info' href='#CT-KIP-P11'>[CT&#8209;KIP&#8209;P11]<span> (</span><span class='info'>RSA Laboratories, &ldquo;PKCS #11 Mechanisms for the Cryptographic Token Key           Initialization Protocol,&rdquo; December&nbsp;2005.</span><span>)</span></a> is as follows:
</p>
<p></p>
<blockquote class="text"><dl>
<dt>a.</dt>
<dd>On the client side, 
<blockquote class="text"><dl>
<dt>1.</dt>
<dd>The client selects a suitable slot and token (e.g. through
                use of the &lt;DeviceIdentifier&gt; or the
                &lt;PlatformInfo&gt; element of the DSKPP trigger
                message).
</dd>
<dt>2.</dt>
<dd>A nonce R is generated, e.g. by calling C_SeedRandom and
                C_GenerateRandom.
</dd>
<dt>3.</dt>
<dd>The client sends its first message to the server, including
                the nonce R.
</dd>
</dl></blockquote>
</dd>
<dt>b.</dt>
<dd>On the server side, 
<blockquote class="text"><dl>
<dt>1.</dt>
<dd>A generic key K_PROV = K_TOKEN | K_MAC (where '|' denotes
                concatenation) is generated, e.g. by calling C_GenerateKey
                (using key type CKK_GENERIC_SECRET). The template for K_PROV
                MUST allow it to be exported (but only in wrapped form, i.e.
                CKA_SENSITIVE MUST be set to CK_TRUE and CKA_EXTRACTABLE MUST
                also be set to CK_TRUE), and also to be used for further key
                derivation. From K, a token key K_TOKEN of suitable type is
                derived by calling C_DeriveKey using the PKCS #11 mechanism
                CKM_EXTRACT_KEY_FROM_KEY and setting the CK_EXTRACT_PARAMS to
                the first bit of the generic secret key (i.e. set to 0).
                Likewise, a MAC key K_MAC is derived from K_PROV by calling
                C_DeriveKey using the CKM_EXTRACT_KEY_FROM_KEY mechanism, this
                time setting CK_EXTRACT_PARAMS to the length of K_PROV (in
                bits) divided by two.
</dd>
<dt>2.</dt>
<dd>The server wraps K_PROV with either the public key of the
                DSKPP client or device, the pre-shared secret key, or the
                derived shared secret key by using C_WrapKey. If use of the
                DSKPP key wrap algorithm has been negotiated then the
                CKM_KIP_WRAP mechanism MUST be used to wrap K. When calling
                C_WrapKey, the hKey handle in the CK_KIP_PARAMS structure MUST
                be set to NULL_PTR. The pSeed parameter in the CK_KIP_PARAMS
                structure MUST point to the nonce R provided by the DSKPP
                client, and the ulSeedLen parameter MUST indicate the length
                of R. The hWrappingKey parameter in the call to C_WrapKey MUST
                be set to refer to the key wrapping key.
</dd>
<dt>3.</dt>
<dd>Next, the server needs to calculate a MAC using K_MAC. If
                use of the DSKPP MAC algorithm has been negotiated, then the
                MAC is calculated by calling C_SignInit with the CKM_KIP_MAC
                mechanism followed by a call to C_Sign. In the call to
                C_SignInit, K_MAC MUST be the signature key, the hKey
                parameter in the CK_KIP_PARAMS structure MUST be set to
                NULL_PTR, the pSeed parameter of the CT_KIP_PARAMS structure
                MUST be set to NULL_PTR, and the ulSeedLen parameter MUST be
                set to zero. In the call to C_Sign, the pData parameter MUST
                be set to the concatenation of the string ServerID and the
                nonce R, and the ulDataLen parameter MUST be set to the length
                of the concatenated string. The desired length of the MAC MUST
                be specified through the pulSignatureLen parameter and MUST be
                set to the length of R.
</dd>
<dt>4.</dt>
<dd>If the server also needs to authenticate its message (due
                to an existing K_TOKEN being replaced), the server MUST
                calculate a second MAC. Again, if use of the DSKPP MAC
                algorithm has been negotiated, then the MAC is calculated by
                calling C_SignInit with the CKM_KIP_MAC mechanism followed by
                a call to C_Sign. In this call to C_SignInit, the K_MAC'
                existing before this DSKPP protocol run MUST be the signature
                key (the implementation may specify K_MAC' to be the value of
                the K_TOKEN that is being replaced, or a version of K_MAC from
                the previous protocol run), the hKey parameter in the
                CK_KIP_PARAMS structure MUST be set to NULL, the pSeed
                parameter of the CT_KIP_PARAMS structure MUST be set to
                NULL_PTR, and the ulSeedLen parameter MUST be set to zero. In
                the call to C_Sign, the pData parameter MUST be set to the
                concatenation of the string ServerID and the nonce R, and the
                ulDataLen parameter MUST be set to the length of concatenated
                string. The desired length of the MAC MUST be specified
                through the pulSignatureLen parameter and MUST be set to the
                length of R.
</dd>
<dt>5.</dt>
<dd>The server sends its message to the client, including the
                wrapped key K_TOKEN, the MAC and possibly also the
                authenticating MAC.
</dd>
</dl></blockquote>
</dd>
<dt>c.</dt>
<dd>On the client side, 
<blockquote class="text"><dl>
<dt>1.</dt>
<dd>The client calls C_UnwrapKey to receive a handle to K.
                After this, the client calls C_DeriveKey twice: Once to derive
                K_TOKEN and once to derive K_MAC. The client MUST use the same
                mechanism (CKM_EXTRACT_KEY_FROM_KEY) and the same mechanism
                parameters as used by the server above. When calling
                C_UnwrapKey and C_DeriveKey, the pTemplate parameter MUST be
                used to set additional key attributes in accordance with local
                policy and as negotiated and expressed in the protocol. In
                particular, the value of the &lt;KeyID&gt; element in the
                server's response message MAY be used as CKA_ID for K_TOKEN.
                The key K_PROV MUST be destroyed after deriving K_TOKEN and
                K_MAC.
</dd>
<dt>2.</dt>
<dd>The MAC is verified in a reciprocal fashion as it was
                generated by the server. If use of the CKM_KIP_MAC mechanism
                has been negotiated, then in the call to C_VerifyInit, the
                hKey parameter in the CK_KIP_PARAMS structure MUST be set to
                NULL_PTR, the pSeed parameter MUST be set to NULL_PTR, and
                ulSeedLen MUST be set to 0. The hKey parameter of C_VerifyInit
                MUST refer to K_MAC. In the call to C_Verify, pData MUST be
                set to the concatenation of the string ServerID and the nonce
                R, and the ulDataLen parameter MUST be set to the length of
                the concatenated string, pSignature to the MAC value received
                from the server, and ulSignatureLen to the length of the MAC.
                If the MAC does not verify the protocol session ends with a
                failure. The token MUST be constructed to not "commit" to the
                new K_TOKEN or the new K_MAC unless the MAC verifies.
</dd>
<dt>3.</dt>
<dd>If an authenticating MAC was received (REQUIRED if the new
                K_TOKEN will replace an existing key on the token), then it is
                verified in a similar vein but using the K_MAC' associated
                with this server and existing before the protocol run (the
                implementation may specify K_MAC' to be the value of the
                K_TOKEN that is being replaced, or a version of K_MAC from the
                previous protocol run). Again, if the MAC does not verify the
                protocol session ends with a failure, and the token MUST be
                constructed no to "commit" to the new K_TOKEN or the new K_MAC
                unless the MAC verifies.
</dd>
</dl></blockquote>
</dd>
</dl></blockquote>

<a name="Section-PRFRealizations"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.C"></a><h3>Appendix C.&nbsp;
Example of DSKPP-PRF Realizations</h3>

<a name="anchor89"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.C.1"></a><h3>C.1.&nbsp;
Introduction</h3>

<p>This example appendix defines DSKPP-PRF in terms of AES <a class='info' href='#FIPS197-AES'>[FIPS197&#8209;AES]<span> (</span><span class='info'>National Institute of Standards and             Technology, &ldquo;Specification for the Advanced Encryption Standard           (AES),&rdquo; November&nbsp;2001.</span><span>)</span></a> and HMAC <a class='info' href='#RFC2104'>[RFC2104]<span> (</span><span class='info'>Krawzcyk, H., Bellare, M., and R. Canetti, &ldquo;HMAC: Keyed-Hashing for Message Authentication,&rdquo; February&nbsp;1997.</span><span>)</span></a>.
</p>
<a name="anchor90"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.C.2"></a><h3>C.2.&nbsp;
DSKPP-PRF-AES</h3>

<a name="anchor91"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.C.2.1"></a><h3>C.2.1.&nbsp;
Identification</h3>

<p>For cryptographic modules supporting this realization of
          DSKPP-PRF, the following URL MAY be used to identify this algorithm
          in DSKPP:
</p>
<p>http://www.ietf.org/keyprov/dskpp#dskpp-prf-aes-128
</p>
<p>When this URL is used to identify the encryption algorithm, the
          method for encryption of R_C values described in <a class='info' href='#Subsection-Enc'>Section&nbsp;3.4.3<span> (</span><span class='info'>Encryption of Pseudorandom Nonces Sent from the DSKPP Client</span><span>)</span></a> MUST be used.
</p>
<a name="anchor92"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.C.2.2"></a><h3>C.2.2.&nbsp;
Definition</h3>

<p>DSKPP-PRF-AES (k, s, dsLen)
</p>
<p>Input:
</p>
<p></p>
<blockquote class="text"><dl>
<dt>k</dt>
<dd>Encryption key to use
</dd>
<dt>s</dt>
<dd>Octet string consisting of randomizing material.
              The length of the string s is sLen.
</dd>
<dt>dsLen</dt>
<dd>Desired length of the output
</dd>
</dl></blockquote>

<p>Output:
</p>
<p></p>
<blockquote class="text"><dl>
<dt>DS</dt>
<dd>A pseudorandom string, dsLen-octets long
</dd>
</dl></blockquote>

<p>Steps:
</p>
<p></p>
<blockquote class="text"><dl>
<dt>1.</dt>
<dd>Let bLen be the output block size of AES in octets:<br />
bLen = (AES output block length in
              octets)<br />
(normally, bLen = 16)<br />
<br />

</dd>
<dt>2.</dt>
<dd>If dsLen &gt; (2**32 - 1) * bLen, output "derived data too
              long" and stop<br />

</dd>
<dt>3.</dt>
<dd>Let n be the number of bLen-octet blocks in the output data,
              rounding up, and let j be the number of octets in the last
              block:<br />
n = CEILING( dsLen / bLen)<br />
j = dsLen - (n - 1) * bLen<br />
<br />

</dd>
<dt>4.</dt>
<dd>For each block of the pseudorandom string DS, apply the
              function F defined below to the key k, the string s and the
              block index to compute the block:<br />
B1 = F
              (k, s, 1) ,<br />
B2 = F (k, s, 2) ,<br />
...<br />
Bn = F (k, s,
              n)
</dd>
</dl></blockquote>

<p>The function F is defined in terms of the CMAC construction from
          <a class='info' href='#NIST-SP800-38B'>[NIST&#8209;SP800&#8209;38B]<span> (</span><span class='info'>International Organization for             Standardization, &ldquo;Recommendations for Block Cipher Modes of Operation: The CMAC           Mode for Authentication,&rdquo; May&nbsp;2005.</span><span>)</span></a>, using AES as the block
          cipher:<br />
<br />
F (k, s, i) = CMAC-AES (k, INT (i)
          || s)<br />
<br />
where INT (i) is a four-octet encoding
          of the integer i, most significant octet first, and the output
          length of CMAC is set to bLen.<br />
<br />
Concatenate
          the blocks and extract the first dsLen octets to product the desired
          data string DS:<br />
<br />
DS = B1 || B2 || ... ||
          Bn&lt;0..j-1&gt;<br />
<br />
Output the derived data
          DS.
</p>
<a name="anchor93"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.C.2.3"></a><h3>C.2.3.&nbsp;
Example</h3>

<p>If we assume that dsLen = 16, then:
</p>
<p>n = 16 / 16 = 1
</p>
<p>j = 16 - (1 - 1) * 16 = 16
</p>
<p>DS = B1 = F (k, s, 1) = CMAC-AES (k, INT (1) || s)
</p>
<a name="anchor94"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.C.3"></a><h3>C.3.&nbsp;
DSKPP-PRF-SHA256</h3>

<a name="anchor95"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.C.3.1"></a><h3>C.3.1.&nbsp;
Identification</h3>

<p>For cryptographic modules supporting this realization of
          DSKPP-PRF, the following URL MAY be used to identify this algorithm
          in DSKPP:
</p>
<p>http://www.ietf.org/keyprov/dskpp#dskpp-prf-sha256
</p>
<p>When this URL is used to identify the encryption algorithm to
          use, the method for encryption of R_C values described in <a class='info' href='#Subsection-Enc'>Section&nbsp;3.4.3<span> (</span><span class='info'>Encryption of Pseudorandom Nonces Sent from the DSKPP Client</span><span>)</span></a> MUST be used.
</p>
<a name="anchor96"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.C.3.2"></a><h3>C.3.2.&nbsp;
Definition</h3>

<p>DSKPP-PRF-SHA256 (k, s, dsLen)
</p>
<p>Input:
</p>
<p></p>
<blockquote class="text"><dl>
<dt>k</dt>
<dd>Encryption key to use
</dd>
<dt>s</dt>
<dd>Octet string consisting of randomizing material.
              The length of the string s is sLen.
</dd>
<dt>dsLen</dt>
<dd>Desired length of the output
</dd>
</dl></blockquote>

<p>Output:
</p>
<p></p>
<blockquote class="text"><dl>
<dt>DS</dt>
<dd>A pseudorandom string, dsLen-octets long
</dd>
</dl></blockquote>

<p>Steps:
</p>
<p></p>
<blockquote class="text"><dl>
<dt>1.</dt>
<dd>Let bLen be the output size of SHA-256 in octets of <a class='info' href='#FIPS180-SHA'>[FIPS180&#8209;SHA]<span> (</span><span class='info'>National Institute of Standards and             Technology, &ldquo;Secure Hash Standard,&rdquo; February&nbsp;2004.</span><span>)</span></a> (no truncation is done on the HMAC
              output):<br />
bLen = 32<br />
(normally, bLen = 16)<br />
<br />

</dd>
<dt>2.</dt>
<dd>If dsLen &gt; (2**32 - 1) * bLen, output "derived data too
              long" and stop<br />

</dd>
<dt>3.</dt>
<dd>Let n be the number of bLen-octet blocks in the output data,
              rounding up, and let j be the number of octets in the last
              block:<br />
n = CEILING( dsLen / bLen)<br />
j = dsLen - (n - 1) * bLen<br />
<br />

</dd>
<dt>4.</dt>
<dd>For each block of the pseudorandom string DS, apply the
              function F defined below to the key k, the string s and the
              block index to compute the block:<br />
B1 = F
              (k, s, 1),<br />
B2 = F (k, s, 2),<br />
...<br />
Bn = F (k, s,
              n)
</dd>
</dl></blockquote>

<p>The function F is defined in terms of the HMAC construction from
          <a class='info' href='#RFC2104'>[RFC2104]<span> (</span><span class='info'>Krawzcyk, H., Bellare, M., and R. Canetti, &ldquo;HMAC: Keyed-Hashing for Message Authentication,&rdquo; February&nbsp;1997.</span><span>)</span></a>, using SHA-256 as the digest
          algorithm:<br />
<br />
F (k, s, i) = HMAC-SHA256 (k, INT
          (i) || s)<br />
<br />
where INT (i) is a four-octet
          encoding of the integer i, most significant octet first, and the
          output length of HMAC is set to bLen.<br />
<br />
Concatenate the blocks and extract the first dsLen
          octets to product the desired data string DS:<br />
<br />
DS = B1 || B2 || ... || Bn&lt;0..j-1&gt;<br />
<br />
Output the derived data DS.
</p>
<a name="anchor97"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.C.3.3"></a><h3>C.3.3.&nbsp;
Example</h3>

<p>If we assume that sLen = 256 (two 128-octet long values) and
          dsLen = 16, then:
</p>
<p>n = CEILING( 16 / 32 ) = 1
</p>
<p>j = 16 - (1 - 1) * 32 = 16
</p>
<p>B1 = F (k, s, 1) = HMAC-SHA256 (k, INT (1) || s)
</p>
<p>DS = B1&lt;0 ... 15&gt;
</p>
<p>That is, the result will be the first 16 octets of the HMAC
          output.
</p>
<a name="rfc.authors"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>Authors' Addresses</h3>
<table width="99%" border="0" cellpadding="0" cellspacing="0">
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Andrea Doherty</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">RSA, The Security Division of EMC</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">174 Middlesex Tpk.</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Bedford, MA  01730</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">USA</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:andrea.doherty@rsa.com">andrea.doherty@rsa.com</a></td></tr>
<tr cellpadding="3"><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Mingliang Pei</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Verisign, Inc.</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">487 E. Middlefield Road</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Mountain View, CA  94043</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">USA</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:mpei@verisign.com">mpei@verisign.com</a></td></tr>
<tr cellpadding="3"><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Salah Machani</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Diversinet Corp.</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">2225 Sheppard Avenue East, Suite 1801</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Toronto, Ontario  M2J 5C2</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Canada</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:smachani@diversinet.com">smachani@diversinet.com</a></td></tr>
<tr cellpadding="3"><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Magnus Nystrom</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">RSA, The Security Division of EMC</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Arenavagen 29</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Stockholm, Stockholm Ln  121 29</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">SE</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:magnus.nystrom@rsa.com">magnus.nystrom@rsa.com</a></td></tr>
</table>
<a name="rfc.copyright"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>Full Copyright Statement</h3>
<p class='copyright'>
Copyright &copy; The IETF Trust (2008).</p>
<p class='copyright'>
This document is subject to the rights,
licenses and restrictions contained in BCP&nbsp;78,
and except as set forth therein,
the authors retain all their rights.</p>
<p class='copyright'>
This document and the information contained herein are provided
on an &ldquo;AS IS&rdquo; basis and THE CONTRIBUTOR,
THE ORGANIZATION HE/SHE REPRESENTS
OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY, THE IETF TRUST
AND THE INTERNET ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT
THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY
IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR
PURPOSE.</p>
<h3>Intellectual Property</h3>
<p class='copyright'>
The IETF takes no position regarding the validity or scope of any
Intellectual Property Rights or other rights that might be claimed
to pertain to the implementation or use of the technology
described in this document or the extent to which any license
under such rights might or might not be available; nor does it
represent that it has made any independent effort to identify any
such rights.
Information on the procedures with respect to
rights in RFC documents can be found in BCP&nbsp;78 and BCP&nbsp;79.</p>
<p class='copyright'>
Copies of IPR disclosures made to the IETF Secretariat and any
assurances of licenses to be made available,
or the result of an attempt made to obtain a general license or
permission for the use of such proprietary rights by implementers or
users of this specification can be obtained from the IETF on-line IPR
repository at <a href='http://www.ietf.org/ipr'>http://www.ietf.org/ipr</a>.</p>
<p class='copyright'>
The IETF invites any interested party to bring to its attention
any copyrights,
patents or patent applications,
or other
proprietary rights that may cover technology that may be required
to implement this standard.
Please address the information to the IETF at <a href='mailto:ietf-ipr@ietf.org'>ietf-ipr@ietf.org</a>.</p>
</body></html>
