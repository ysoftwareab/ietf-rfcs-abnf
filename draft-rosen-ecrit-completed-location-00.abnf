start =
  findService
  | listServices
  | listServicesByLocation
  | getServiceBoundary
  | findServiceResponse
  | listServicesResponse
  | listServicesByLocationResponse
  | getServiceBoundaryResponse
  | errors
  | redirect

findService =
    element findService {
      requestLocation,
      commonRequestPattern,
      attribute validateLocation {
        xsd:boolean >> a:defaultValue [ "false" ]
      }?,
      attribute requestCompletedLocation {
        xsd:boolean >> a:defaultValue [ "false" ]
      }?,
      attribute serviceBoundary {
        ("reference" | "value") >> a:defaultValue [ "reference" ]
      }?,
      attribute recursive { xsd:boolean >> a:defaultValue [ "false" ] }?
    }
listServices = element listServices { commonRequestPattern }
listServicesByLocation =
    element listServicesByLocation {
      requestLocation,
      commonRequestPattern,
      attribute recursive { xsd:boolean >> a:defaultValue [ "true" ] }?
    }
getServiceBoundary =
    element getServiceBoundary { serviceBoundaryKey, extensionPoint }
findServiceResponse =
    element findServiceResponse {
      mapping+, locationValidation?, responseCompletedLocation?,
      commonResponsePattern, locationUsed
    }
listServicesResponse =
    element listServicesResponse { serviceList, commonResponsePattern }
listServicesByLocationResponse =
    element listServicesByLocationResponse {
      serviceList, commonResponsePattern, locationUsed
    }
getServiceBoundaryResponse =
    element getServiceBoundaryResponse {
      serviceBoundary, commonResponsePattern
    }
commonRequestPattern = service, path?, extensionPoint
commonResponsePattern = warnings*, path, extensionPoint
requestLocation =
    element location {
      attribute id { xsd:token },
      locationInformation
    }+
responseCompletedLocation =
    element location {
      attribute id { xsd:token },
      locationInformation
    }+
locationInformation =
    extensionPoint+,
    attribute profile { xsd:NMTOKEN }?
serviceBoundary = element serviceBoundary { locationInformation }+
serviceBoundaryReference =
    element serviceBoundaryReference {
      source, serviceBoundaryKey, extensionPoint
    }
serviceBoundaryKey = attribute key { xsd:token }
path =
    element path {
      element via { source, extensionPoint }+
    }
locationUsed =
    element locationUsed {
      attribute id { xsd:token }
    }?
expires =
    attribute expires { xsd:dateTime | "NO-CACHE" | "NO-EXPIRATION" }
qnameList = list { xsd:QName* }
mapping =
    element mapping {
      element displayName {
        xsd:string,
        attribute xml:lang { xsd:language }
      }*,
      service,
      (serviceBoundary | serviceBoundaryReference)?,
      element uri { xsd:anyURI }*,
      element serviceNumber {
        xsd:token { pattern = "[0-9*#]+" }
      }?,
      extensionPoint,
      expires,
      attribute lastUpdated { xsd:dateTime },
      source,
      attribute sourceId { xsd:token },
      message
    }
locationValidation =
    element locationValidation {
      element valid { qnameList }?,
      element invalid { qnameList }?,
      element unchecked { qnameList }?,
      extensionPoint
    }
exceptionContainer =
    (badRequest?
     & internalError?
     & serviceSubstitution?
     & defaultMappingReturned?
     & forbidden?
     & notFound?
     & loop?
     & serviceNotImplemented?
     & serverTimeout?
     & serverError?
     & locationInvalid?
     & locationProfileUnrecognized?),
    extensionPoint,
    source
errors = element errors { exceptionContainer }
warnings = element warnings { exceptionContainer }
basicException = message, extensionPoint
badRequest = element badRequest { basicException }
internalError = element internalError { basicException }
serviceSubstitution = element serviceSubstitution { basicException }
defaultMappingReturned =
    element defaultMappingReturned { basicException }
forbidden = element forbidden { basicException }
notFound = element notFound { basicException }
loop = element loop { basicException }
serviceNotImplemented =
    element serviceNotImplemented { basicException }
serverTimeout = element serverTimeout { basicException }
serverError = element serverError { basicException }
locationInvalid = element locationInvalid { basicException }
locationValidationUnavailable =
    element locationValidationUnavailable { basicException }
locationProfileUnrecognized =
    element locationProfileUnrecognized {
      attribute unsupportedProfiles { xsd:NMTOKENS },
      basicException
    }
redirect =
    element redirect {
      attribute target { appUniqueString },
      source,
      message,
      extensionPoint
    }
message =
    (attribute message { xsd:token },
     attribute xml:lang { xsd:language })?
service = element service { xsd:anyURI }?
appUniqueString =
    xsd:token { pattern = "([a-zA-Z0-9\-]+\.)+[a-zA-Z0-9]+" }
source = attribute source { appUniqueString }
serviceList =
    element serviceList {
      list { xsd:anyURI* }
    }
notLost = element * - (ns1:* | ns1:*) { anyElement }

anyElement =
    (element * { anyElement }
     | attribute * { text }
     | text)*

extensionPoint = notLost*
content="text/html;charset=iso-8859-1"/>
