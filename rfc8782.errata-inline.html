<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head profile="http://dublincore.org/documents/2008/08/04/dc-html/">
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
        <meta name="robots" content="index,follow" />

        <link rel="icon" href="./css/images/rfc.png" type="image/png" />
        <link rel="shortcut icon" href="./css/images/rfc.png" type="image/png" />
        <title>rfc8782</title>
    
        <link rel="stylesheet" type="text/css" href="./css/errata-base.css"/>
        <link rel="stylesheet" type="text/css" href="./css/errata-color.css" title="Default: Basic Colors"/>
        <link rel="alternative stylesheet" type="text/css" href="./css/errata-monochrome.css" title="Monochrome"/>
        <link rel="alternative stylesheet" type="text/css" href="./css/errata-printer.css" title="Printer"/>

        <script src="./css/errata.js"></script>
    </head>
    <body>
        <div class='Verified-headnote-styling'>
<span style="font-weight: bold;">This is a purely informative rendering of an RFC that includes verified errata.  This rendering may not be used as a reference.</span>
<br/>
<br/>
The following 'Verified' errata have been incorporated in this document:
 <a href='#btn_6449'>EID 6449</a>
</div>

        <pre>
ï»¿

Internet Engineering Task Force (IETF)                   T. Reddy.K, Ed.
Request for Comments: 8782                                        McAfee
Category: Standards Track                              M. Boucadair, Ed.
ISSN: 2070-1721                                                   Orange
                                                                P. Patil
                                                                   Cisco
                                                            A. Mortensen
                                                    Arbor Networks, Inc.
                                                               N. Teague
                                              Iron Mountain Data Centers
                                                                May 2020

   Distributed Denial-of-Service Open Threat Signaling (DOTS) Signal
                         Channel Specification

Abstract

   This document specifies the Distributed Denial-of-Service Open Threat
   Signaling (DOTS) signal channel, a protocol for signaling the need
   for protection against Distributed Denial-of-Service (DDoS) attacks
   to a server capable of enabling network traffic mitigation on behalf
   of the requesting client.

   A companion document defines the DOTS data channel, a separate
   reliable communication layer for DOTS management and configuration
   purposes.

Status of This Memo

   This is an Internet Standards Track document.

   This document is a product of the Internet Engineering Task Force
   (IETF).  It represents the consensus of the IETF community.  It has
   received public review and has been approved for publication by the
   Internet Engineering Steering Group (IESG).  Further information on
   Internet Standards is available in Section 2 of RFC 7841.

   Information about the current status of this document, any errata,
   and how to provide feedback on it may be obtained at
   https://www.rfc-editor.org/info/rfc8782.

Copyright Notice

   Copyright (c) 2020 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to BCP 78 and the IETF Trust&#x27;s Legal
   Provisions Relating to IETF Documents
   (https://trustee.ietf.org/license-info) in effect on the date of
   publication of this document.  Please review these documents
   carefully, as they describe your rights and restrictions with respect
   to this document.  Code Components extracted from this document must
   include Simplified BSD License text as described in Section 4.e of
   the Trust Legal Provisions and are provided without warranty as
   described in the Simplified BSD License.

Table of Contents

   1.  Introduction
   2.  Terminology
   3.  Design Overview
   4.  DOTS Signal Channel: Messages &amp; Behaviors
     4.1.  DOTS Server(s) Discovery
     4.2.  CoAP URIs
     4.3.  Happy Eyeballs for DOTS Signal Channel
     4.4.  DOTS Mitigation Methods
       4.4.1.  Request Mitigation
       4.4.2.  Retrieve Information Related to a Mitigation
         4.4.2.1.  DOTS Servers Sending Mitigation Status
         4.4.2.2.  DOTS Clients Polling for Mitigation Status
       4.4.3.  Efficacy Update from DOTS Clients
       4.4.4.  Withdraw a Mitigation
     4.5.  DOTS Signal Channel Session Configuration
       4.5.1.  Discover Configuration Parameters
       4.5.2.  Convey DOTS Signal Channel Session Configuration
       4.5.3.  Configuration Freshness and Notifications
       4.5.4.  Delete DOTS Signal Channel Session Configuration
     4.6.  Redirected Signaling
     4.7.  Heartbeat Mechanism
   5.  DOTS Signal Channel YANG Modules
     5.1.  Tree Structure
     5.2.  IANA DOTS Signal Channel YANG Module
     5.3.  IETF DOTS Signal Channel YANG Module
   6.  YANG/JSON Mapping Parameters to CBOR
   7.  (D)TLS Protocol Profile and Performance Considerations
     7.1.  (D)TLS Protocol Profile
     7.2.  (D)TLS 1.3 Considerations
     7.3.  DTLS MTU and Fragmentation
   8.  Mutual Authentication of DOTS Agents &amp; Authorization of DOTS
           Clients
   9.  IANA Considerations
     9.1.  DOTS Signal Channel UDP and TCP Port Number
     9.2.  Well-Known &#x27;dots&#x27; URI
     9.3.  Media Type Registration
     9.4.  CoAP Content-Formats Registration
     9.5.  CBOR Tag Registration
     9.6.  DOTS Signal Channel Protocol Registry
       9.6.1.  DOTS Signal Channel CBOR Key Values Subregistry
         9.6.1.1.  Registration Template
         9.6.1.2.  Initial Subregistry Content
       9.6.2.  Status Codes Subregistry
       9.6.3.  Conflict Status Codes Subregistry
       9.6.4.  Conflict Cause Codes Subregistry
       9.6.5.  Attack Status Codes Subregistry
     9.7.  DOTS Signal Channel YANG Modules
   10. Security Considerations
   11. References
     11.1.  Normative References
     11.2.  Informative References
   Appendix A.  CUID Generation
   Acknowledgements
   Contributors
   Authors&#x27; Addresses

1.  Introduction

   A Distributed Denial-of-Service (DDoS) attack is a distributed
   attempt to make machines or network resources unavailable to their
   intended users.  In most cases, sufficient scale for an effective
   attack can be achieved by compromising enough end hosts and using
   those infected hosts to perpetrate and amplify the attack.  The
   victim in this attack can be an application server, a host, a router,
   a firewall, or an entire network.

   Network applications have finite resources like CPU cycles, the
   number of processes or threads they can create and use, the maximum
   number of simultaneous connections they can handle, the resources
   assigned to the control plane, etc.  When processing network traffic,
   such applications are supposed to use these resources to provide the
   intended functionality in the most efficient manner.  However, a DDoS
   attacker may be able to prevent an application from performing its
   intended task by making the application exhaust its finite resources.

   A TCP DDoS SYN flood [RFC4987], for example, is a memory-exhausting
   attack while an ACK flood is a CPU-exhausting attack.  Attacks on the
   link are carried out by sending enough traffic so that the link
   becomes congested, thereby likely causing packet loss for legitimate
   traffic.  Stateful firewalls can also be attacked by sending traffic
   that causes the firewall to maintain an excessive number of states
   that may jeopardize the firewall&#x27;s operation overall, in addition to
   likely performance impacts.  The firewall then runs out of memory,
   and it can no longer instantiate the states required to process
   legitimate flows.  Other possible DDoS attacks are discussed in
   [RFC4732].

   In many cases, it may not be possible for network administrators to
   determine the cause(s) of an attack.  They may instead just realize
   that certain resources seem to be under attack.  This document
   defines a lightweight protocol that allows a DOTS client to request
   mitigation from one or more DOTS servers for protection against
   detected, suspected, or anticipated attacks.  This protocol enables
   cooperation between DOTS agents to permit a highly automated network
   defense that is robust, reliable, and secure.  Note that &quot;secure&quot;
   means the support of the features defined in Section 2.4 of
   [RFC8612].

   An example of a network diagram that illustrates a deployment of DOTS
   agents is shown in Figure 1.  In this example, a DOTS server is
   operating on the access network.  A DOTS client is located on the LAN
   (Local Area Network), while a DOTS gateway is embedded in the CPE
   (Customer Premises Equipment).

      Network
      Resource         CPE Router        Access Network     __________
    +-----------+   +--------------+    +-------------+    /          \
    |           |___|              |____|             |___ | Internet |
    |DOTS Client|   | DOTS Gateway |    | DOTS Server |    |          |
    |           |   |              |    |             |    |          |
    +-----------+   +--------------+    +-------------+    \__________/

                    Figure 1: Sample DOTS Deployment (1)

   DOTS servers can also be reachable over the Internet, as depicted in
   Figure 2.

      Network                                           DDoS Mitigation
      Resource         CPE Router        __________         Service
    +-----------+   +--------------+    /          \    +-------------+
    |           |___|              |____|          |___ |             |
    |DOTS Client|   | DOTS Gateway |    | Internet |    | DOTS Server |
    |           |   |              |    |          |    |             |
    +-----------+   +--------------+    \__________/    +-------------+

                    Figure 2: Sample DOTS Deployment (2)

   In typical deployments, the DOTS client belongs to a different
   administrative domain than the DOTS server.  For example, the DOTS
   client is embedded in a firewall protecting services owned and
   operated by a customer, while the DOTS server is owned and operated
   by a different administrative entity (service provider, typically)
   providing DDoS mitigation services.  The latter might or might not
   provide connectivity services to the network hosting the DOTS client.

   The DOTS server may (not) be co-located with the DOTS mitigator.  In
   typical deployments, the DOTS server belongs to the same
   administrative domain as the mitigator.  The DOTS client can
   communicate directly with a DOTS server or indirectly via a DOTS
   gateway.

   This document adheres to the DOTS architecture [DOTS-ARCH].  The
   requirements for DOTS signal channel protocol are documented in
   [RFC8612].  This document satisfies all the use cases discussed in
   [DOTS-USE-CASES].

   This document focuses on the DOTS signal channel.  This is a
   companion document of the DOTS data channel specification [RFC8783]
   that defines a configuration and a bulk data exchange mechanism
   supporting the DOTS signal channel.

2.  Terminology

   The key words &quot;MUST&quot;, &quot;MUST NOT&quot;, &quot;REQUIRED&quot;, &quot;SHALL&quot;, &quot;SHALL NOT&quot;,
   &quot;SHOULD&quot;, &quot;SHOULD NOT&quot;, &quot;RECOMMENDED&quot;, &quot;NOT RECOMMENDED&quot;, &quot;MAY&quot;, and
   &quot;OPTIONAL&quot; in this document are to be interpreted as described in BCP
   14 [RFC2119][RFC8174] when, and only when, they appear in all
   capitals, as shown here.

   (D)TLS is used for statements that apply to both Transport Layer
   Security [RFC5246] [RFC8446] and Datagram Transport Layer Security
   [RFC6347].  Specific terms are used for any statement that applies to
   either protocol alone.

   The reader should be familiar with the terms defined in [RFC8612].

   The meaning of the symbols in YANG tree diagrams is defined in
   [RFC8340].

3.  Design Overview

   The DOTS signal channel is built on top of the Constrained
   Application Protocol (CoAP) [RFC7252], a lightweight protocol
   originally designed for constrained devices and networks.  The many
   features of CoAP (expectation of packet loss, support for
   asynchronous Non-confirmable messaging, congestion control, small
   message overhead limiting the need for fragmentation, use of minimal
   resources, and support for (D)TLS) make it a good candidate upon
   which to build the DOTS signaling mechanism.

   DOTS clients and servers behave as CoAP endpoints.  By default, a
   DOTS client (or server) behaves as a CoAP client (or server).
   Nevertheless, a DOTS client (or server) behaves as a CoAP server (or
   client) for specific operations such as DOTS heartbeat operations
   (Section 4.7).

   The DOTS signal channel is layered on existing standards (see
   Figure 3).

                          +---------------------+
                          | DOTS Signal Channel |
                          +---------------------+
                          |         CoAP        |
                          +----------+----------+
                          |   TLS    |   DTLS   |
                          +----------+----------+
                          |   TCP    |   UDP    |
                          +----------+----------+
                          |          IP         |
                          +---------------------+

     Figure 3: Abstract Layering of DOTS Signal Channel over CoAP over
                                   (D)TLS

   In some cases, a DOTS client and server may have a mutual agreement
   to use a specific port number, such as by explicit configuration or
   dynamic discovery [DOTS-SERVER-DISC].  Absent such mutual agreement,
   the DOTS signal channel MUST run over port number 4646 as defined in
   Section 9.1, for both UDP and TCP.  In order to use a distinct port
   number (as opposed to 4646), DOTS clients and servers SHOULD support
   a configurable parameter to supply the port number to use.

      |  Note: The rationale for not using the default port number 5684
      |  ((D)TLS CoAP) is to avoid the discovery of services and
      |  resources discussed in [RFC7252] and allow for differentiated
      |  behaviors in environments where both a DOTS gateway and an
      |  Internet of Things (IoT) gateway (e.g., Figure 3 of [RFC7452])
      |  are co-located.
      |
      |  Particularly, the use of a default port number is meant to
      |  simplify DOTS deployment in scenarios where no explicit IP
      |  address configuration is required.  For example, the use of the
      |  default router as the DOTS server aims to ease DOTS deployment
      |  within LANs (in which CPEs embed a DOTS gateway as illustrated
      |  in Figures 1 and 2) without requiring a sophisticated discovery
      |  method and configuration tasks within the LAN.  It is also
      |  possible to use anycast addresses for DOTS servers to simplify
      |  DOTS client configuration, including service discovery.  In
      |  such an anycast-based scenario, a DOTS client initiating a DOTS
      |  session to the DOTS server anycast address may, for example, be
      |  (1) redirected to the DOTS server unicast address to be used by
      |  the DOTS client following the procedure discussed in
      |  Section 4.6 or (2) relayed to a unicast DOTS server.

   The signal channel uses the &quot;coaps&quot; URI scheme defined in Section 6
   of [RFC7252] and the &quot;coaps+tcp&quot; URI scheme defined in Section 8.2 of
   [RFC8323] to identify DOTS server resources that are accessible using
   CoAP over UDP secured with DTLS and CoAP over TCP secured with TLS,
   respectively.

   The DOTS signal channel can be established between two DOTS agents
   prior to or during an attack.  The DOTS signal channel is initiated
   by the DOTS client.  The DOTS client can then negotiate, configure,
   and retrieve the DOTS signal channel session behavior with its DOTS
   peer (Section 4.5).  Once the signal channel is established, the DOTS
   agents may periodically send heartbeats to keep the channel active
   (Section 4.7).  At any time, the DOTS client may send a mitigation
   request message (Section 4.4) to a DOTS server over the active signal
   channel.  While mitigation is active (because of the higher
   likelihood of packet loss during a DDoS attack), the DOTS server
   periodically sends status messages to the client, including basic
   mitigation feedback details.  Mitigation remains active until the
   DOTS client explicitly terminates mitigation or the mitigation
   lifetime expires.  Also, the DOTS server may rely on the signal
   channel session loss to trigger mitigation for preconfigured
   mitigation requests (if any).

   DOTS signaling can happen with DTLS over UDP and TLS over TCP.
   Likewise, DOTS requests may be sent using IPv4 or IPv6 transfer
   capabilities.  A Happy Eyeballs procedure for the DOTS signal channel
   is specified in Section 4.3.

   A DOTS client is entitled to access only the resources it creates.
   In particular, a DOTS client cannot retrieve data related to
   mitigation requests created by other DOTS clients of the same DOTS
   client domain.

   Messages exchanged between DOTS agents are serialized using Concise
   Binary Object Representation (CBOR) [RFC7049], a binary encoding
   scheme designed for small code and message size.  CBOR-encoded
   payloads are used to carry signal channel-specific payload messages
   that convey request parameters and response information such as
   errors.  In order to allow the reusing of data models across
   protocols, [RFC7951] specifies the JavaScript Object Notation (JSON)
   encoding of YANG-modeled data.  A similar effort for CBOR is defined
   in [CORE-YANG-CBOR].

   DOTS agents determine that a CBOR data structure is a DOTS signal
   channel object from the application context, such as from the port
   number assigned to the DOTS signal channel.  The other method DOTS
   agents use to indicate that a CBOR data structure is a DOTS signal
   channel object is the use of the &quot;application/dots+cbor&quot; content type
   (Section 9.3).

   This document specifies a YANG module for representing DOTS
   mitigation scopes, DOTS signal channel session configuration data,
   and DOTS redirected signaling (Section 5).  All parameters in the
   payload of the DOTS signal channel are mapped to CBOR types as
   specified in Table 5 (Section 6).

   In order to prevent fragmentation, DOTS agents must follow the
   recommendations documented in Section 4.6 of [RFC7252].  Refer to
   Section 7.3 for more details.

   DOTS agents MUST support GET, PUT, and DELETE CoAP methods.  The
   payload included in CoAP responses with 2.xx Response Codes MUST be
   of content type &quot;application/dots+cbor&quot;.  CoAP responses with 4.xx
   and 5.xx error Response Codes MUST include a diagnostic payload
   (Section 5.5.2 of [RFC7252]).  The diagnostic payload may contain
   additional information to aid troubleshooting.

   In deployments where multiple DOTS clients are enabled in a network
   (owned and operated by the same entity), the DOTS server may detect
   conflicting mitigation requests from these clients.  This document
   does not aim to specify a comprehensive list of conditions under
   which a DOTS server will characterize two mitigation requests from
   distinct DOTS clients as conflicting, nor does it recommend a DOTS
   server behavior for processing conflicting mitigation requests.
   Those considerations are implementation and deployment specific.
   Nevertheless, this document specifies the mechanisms to notify DOTS
   clients when conflicts occur, including the conflict cause
   (Section 4.4).

   In deployments where one or more translators (e.g., Traditional NAT
   [RFC3022], CGN [RFC6888], NAT64 [RFC6146], NPTv6 [RFC6296]) are
   enabled between the client&#x27;s network and the DOTS server, any DOTS
   signal channel messages forwarded to a DOTS server MUST NOT include
   internal IP addresses/prefixes and/or port numbers; instead, external
   addresses/prefixes and/or port numbers as assigned by the translator
   MUST be used.  This document does not make any recommendations about
   possible translator discovery mechanisms.  The following are some
   (non-exhaustive) deployment examples that may be considered:

   *  Port Control Protocol (PCP) [RFC6887] or Session Traversal
      Utilities for NAT (STUN) [RFC8489] may be used to retrieve the
      external addresses/prefixes and/or port numbers.  Information
      retrieved by means of PCP or STUN will be used to feed the DOTS
      signal channel messages that will be sent to a DOTS server.

   *  A DOTS gateway may be co-located with the translator.  The DOTS
      gateway will need to update the DOTS messages based upon the local
      translator&#x27;s binding table.

4.  DOTS Signal Channel: Messages &amp; Behaviors

4.1.  DOTS Server(s) Discovery

   This document assumes that DOTS clients are provisioned with the
   reachability information of their DOTS server(s) using any of a
   variety of means (e.g., local configuration or dynamic means such as
   DHCP [DOTS-SERVER-DISC]).  The description of such means is out of
   scope of this document.

   Likewise, it is out of the scope of this document to specify the
   behavior to be followed by a DOTS client in order to send DOTS
   requests when multiple DOTS servers are provisioned (e.g., contact
   all DOTS servers, select one DOTS server among the list).  Such
   behavior is specified in other documents (e.g., [DOTS-MH]).

4.2.  CoAP URIs

   The DOTS server MUST support the use of the path prefix of &quot;/.well-
   known/&quot; as defined in [RFC8615] and the registered name of &quot;dots&quot;.
   Each DOTS operation is denoted by a path suffix that indicates the
   intended operation.  The operation path (Table 1) is appended to the
   path prefix to form the URI used with a CoAP request to perform the
   desired DOTS operation.

         +-----------------------+----------------+-------------+
         | Operation             | Operation Path | Details     |
         +=======================+================+=============+
         | Mitigation            | /mitigate      | Section 4.4 |
         +-----------------------+----------------+-------------+
         | Session configuration | /config        | Section 4.5 |
         +-----------------------+----------------+-------------+
         | Heartbeat             | /hb            | Section 4.7 |
         +-----------------------+----------------+-------------+

                Table 1: Operations and Corresponding URIs

4.3.  Happy Eyeballs for DOTS Signal Channel

   [RFC8612] mentions that DOTS agents will have to support both
   connectionless and connection-oriented protocols.  As such, the DOTS
   signal channel is designed to operate with DTLS over UDP and TLS over
   TCP.  Further, a DOTS client may acquire a list of IPv4 and IPv6
   addresses (Section 4.1), each of which can be used to contact the
   DOTS server using UDP and TCP.  If no list of IPv4 and IPv6 addresses
   to contact the DOTS server is configured (or discovered), the DOTS
   client adds the IPv4/IPv6 addresses of its default router to the
   candidate list to contact the DOTS server.

   The following specifies the procedure to follow to select the address
   family and the transport protocol for sending DOTS signal channel
   messages.

   Such a procedure is needed to avoid experiencing long connection
   delays.  For example, if an IPv4 path to a DOTS server is functional,
   but the DOTS server&#x27;s IPv6 path is nonfunctional, a dual-stack DOTS
   client may experience a significant connection delay compared to an
   IPv4-only DOTS client in the same network conditions.  The other
   problem is that if a middlebox between the DOTS client and DOTS
   server is configured to block UDP traffic, the DOTS client will fail
   to establish a DTLS association with the DOTS server; consequently,
   it will have to fall back to TLS over TCP, thereby incurring
   significant connection delays.

   To overcome these connection setup problems, the DOTS client attempts
   to connect to its DOTS server(s) using both IPv6 and IPv4, and it
   tries both DTLS over UDP and TLS over TCP following a DOTS Happy
   Eyeballs approach.  To some extent, this approach is similar to the
   Happy Eyeballs mechanism defined in [RFC8305].  The connection
   attempts are performed by the DOTS client when it initializes or, in
   general, when it has to select an address family and transport to
   contact its DOTS server.  The results of the Happy Eyeballs procedure
   are used by the DOTS client for sending its subsequent messages to
   the DOTS server.  The differences in behavior with respect to the
   Happy Eyeballs mechanism [RFC8305] are listed below:

   *  The order of preference of the DOTS signal channel address family
      and transport protocol (most preferred first) is the following:
      UDP over IPv6, UDP over IPv4, TCP over IPv6, and finally TCP over
      IPv4.  This order adheres to the address preference order
      specified in [RFC6724] and the DOTS signal channel preference that
      promotes the use of UDP over TCP (to avoid TCP&#x27;s head of line
      blocking).

   *  After successfully establishing a connection, the DOTS client MUST
      cache information regarding the outcome of each connection attempt
      for a specific time period; it uses that information to avoid
      thrashing the network with subsequent attempts.  The cached
      information is flushed when its age exceeds a specific time period
      on the order of few minutes (e.g., 10 min).  Typically, if the
      DOTS client has to reestablish the connection with the same DOTS
      server within a few seconds after the Happy Eyeballs mechanism is
      completed, caching avoids thrashing the network especially in the
      presence of DDoS attack traffic.

   *  If a DOTS signal channel session is established with TLS (but DTLS
      failed), the DOTS client periodically repeats the mechanism to
      discover whether DOTS signal channel messages with DTLS over UDP
      become available from the DOTS server; this is so the DOTS client
      can migrate the DOTS signal channel from TCP to UDP.  Such probing
      SHOULD NOT be done more frequently than every 24 hours and MUST
      NOT be done more frequently than every 5 minutes.

   When connection attempts are made during an attack, the DOTS client
   SHOULD use a &quot;Connection Attempt Delay&quot; [RFC8305] set to 100 ms.

   In Figure 4, the DOTS client proceeds with the connection attempts
   following the rules in [RFC8305].  In this example, it is assumed
   that the IPv6 path is broken and UDP traffic is dropped by a
   middlebox, but this has little impact on the DOTS client because
   there is not a long delay before using IPv4 and TCP.

    +-----------+                                         +-----------+
    |DOTS Client|                                         |DOTS Server|
    +-----------+                                         +-----------+
          |                                                     |
       T0 |--DTLS ClientHello, IPv6 ----&gt;X                      |
       T1 |--DTLS ClientHello, IPv4 ----&gt;X                      |
       T2 |--TCP SYN, IPv6--------------&gt;X                      |
       T3 |--TCP SYN, IPv4-------------------------------------&gt;|
          |&lt;-TCP SYNACK-----------------------------------------|
          |--TCP ACK-------------------------------------------&gt;|
          |&lt;------------Establish TLS Session------------------&gt;|
          |----------------DOTS signal-------------------------&gt;|
          |                                                     |

     Note:
      * Retransmission messages are not shown.
      * T1-T0=T2-T1=T3-T2= Connection Attempt Delay.

                Figure 4: DOTS Happy Eyeballs (Sample Flow)

   A single DOTS signal channel between DOTS agents can be used to
   exchange multiple DOTS signal messages.  To reduce DOTS client and
   DOTS server workload, DOTS clients SHOULD reuse the (D)TLS session.

4.4.  DOTS Mitigation Methods

   The following methods are used by a DOTS client to request, withdraw,
   or retrieve the status of mitigation requests:

   PUT:      DOTS clients use the PUT method to request mitigation from
             a DOTS server (Section 4.4.1).  During active mitigation,
             DOTS clients may use PUT requests to carry mitigation
             efficacy updates to the DOTS server (Section 4.4.3).

   GET:      DOTS clients may use the GET method to subscribe to DOTS
             server status messages or to retrieve the list of its
             mitigations maintained by a DOTS server (Section 4.4.2).

   DELETE:   DOTS clients use the DELETE method to withdraw a request
             for mitigation from a DOTS server (Section 4.4.4).

   Mitigation request and response messages are marked as Non-
   confirmable messages (Section 2.2 of [RFC7252]).

   DOTS agents MUST NOT send more than one UDP datagram per round-trip
   time (RTT) to the peer DOTS agent on average following the data
   transmission guidelines discussed in Section 3.1.3 of [RFC8085].

   Requests marked by the DOTS client as Non-confirmable messages are
   sent at regular intervals until a response is received from the DOTS
   server.  If the DOTS client cannot maintain an RTT estimate, it MUST
   NOT send more than one Non-confirmable request every 3 seconds, and
   SHOULD use an even less aggressive rate whenever possible (case 2 in
   Section 3.1.3 of [RFC8085]).  Mitigation requests MUST NOT be delayed
   because of checks on probing rate (Section 4.7 of [RFC7252]).

   JSON encoding of YANG modeled data [RFC7951] is used to illustrate
   the various methods defined in the following subsections.  Also, the
   examples use the Labels defined in Sections 9.6.2, 9.6.3, 9.6.4, and
   9.6.5.

4.4.1.  Request Mitigation

   When a DOTS client requires mitigation for some reason, the DOTS
   client uses the CoAP PUT method to send a mitigation request to its
   DOTS server(s) (Figures 5 and 6).

   If a DOTS client is entitled to solicit the DOTS service, the DOTS
   server enables mitigation on behalf of the DOTS client by
   communicating the DOTS client&#x27;s request to a mitigator (which may be
   co-located with the DOTS server) and relaying the feedback of the
   thus-selected mitigator to the requesting DOTS client.

     Header: PUT (Code=0.03)
     Uri-Path: &quot;.well-known&quot;
     Uri-Path: &quot;dots&quot;
     Uri-Path: &quot;mitigate&quot;
     Uri-Path: &quot;cuid=dz6pHjaADkaFTbjr0JGBpw&quot;
     Uri-Path: &quot;mid=123&quot;
     Content-Format: &quot;application/dots+cbor&quot;

     {
       ...
     }

              Figure 5: PUT to Convey DOTS Mitigation Requests

   The order of the Uri-Path options is important as it defines the CoAP
   resource.  In particular, &#x27;mid&#x27; MUST follow &#x27;cuid&#x27;.

   The additional Uri-Path parameters to those defined in Section 4.2
   are as follows:

   cuid:  Stands for Client Unique Identifier.  A globally unique
         identifier that is meant to prevent collisions among DOTS
         clients, especially those from the same domain.  It MUST be
         generated by DOTS clients.

         For the reasons discussed in Appendix A, implementations SHOULD
         set &#x27;cuid&#x27; using the following procedure: first, the DOTS
         client inputs one of the following into the SHA-256 [RFC6234]
         cryptographic hash: the DER-encoded ASN.1 representation of the
         Subject Public Key Info (SPKI) of its X.509 certificate
         [RFC5280], its raw public key [RFC7250], the &quot;Pre-Shared Key
         (PSK) identity&quot; it uses in the TLS 1.2 ClientKeyExchange
         message, or the &quot;identity&quot; it uses in the &quot;pre_shared_key&quot; TLS
         1.3 extension.  Then, the output of the cryptographic hash
         algorithm is truncated to 16 bytes; truncation is done by
         stripping off the final 16 bytes.  The truncated output is
         base64url encoded (Section 5 of [RFC4648]) with the trailing
         &quot;=&quot; removed from the encoding, and the resulting value used as
         the &#x27;cuid&#x27;.

         The &#x27;cuid&#x27; is intended to be stable when communicating with a
         given DOTS server, i.e., the &#x27;cuid&#x27; used by a DOTS client
         SHOULD NOT change over time.  Distinct &#x27;cuid&#x27; values MAY be
         used by a single DOTS client per DOTS server.

         If a DOTS client has to change its &#x27;cuid&#x27; for some reason, it
         MUST NOT do so when mitigations are still active for the old
         &#x27;cuid&#x27;.  The &#x27;cuid&#x27; SHOULD be 22 characters to avoid DOTS
         signal message fragmentation over UDP.  Furthermore, if that
         DOTS client created aliases and filtering entries at the DOTS
         server by means of the DOTS data channel, it MUST delete all
         the entries bound to the old &#x27;cuid&#x27; and reinstall them using
         the new &#x27;cuid&#x27;.

         DOTS servers MUST return 4.09 (Conflict) error code to a DOTS
         peer to notify that the &#x27;cuid&#x27; is already in use by another
         DOTS client.  Upon receipt of that error code, a new &#x27;cuid&#x27;
         MUST be generated by the DOTS peer (e.g., using [RFC4122]).

         Client-domain DOTS gateways MUST handle &#x27;cuid&#x27; collision
         directly and it is RECOMMENDED that &#x27;cuid&#x27; collision is handled
         directly by server-domain DOTS gateways.

         DOTS gateways MAY rewrite the &#x27;cuid&#x27; used by peer DOTS clients.
         Triggers for such rewriting are out of scope.

         This is a mandatory Uri-Path parameter.

   mid:  Identifier for the mitigation request represented with an
         integer.  This identifier MUST be unique for each mitigation
         request bound to the DOTS client, i.e., the &#x27;mid&#x27; parameter
         value in the mitigation request needs to be unique (per &#x27;cuid&#x27;
         and DOTS server) relative to the &#x27;mid&#x27; parameter values of
         active mitigation requests conveyed from the DOTS client to the
         DOTS server.

         In order to handle out-of-order delivery of mitigation
         requests, &#x27;mid&#x27; values MUST increase monotonically.

         If the &#x27;mid&#x27; value has reached 3/4 of (2^(32) - 1) (i.e.,
         3221225471) and no attack is detected, the DOTS client MUST
         reset &#x27;mid&#x27; to 0 to handle &#x27;mid&#x27; rollover.  If the DOTS client
         maintains mitigation requests with preconfigured scopes, it
         MUST recreate them with the &#x27;mid&#x27; restarting at 0.

         This identifier MUST be generated by the DOTS client.

         This is a mandatory Uri-Path parameter.

   &#x27;cuid&#x27; and &#x27;mid&#x27; MUST NOT appear in the PUT request message body
   (Figure 6).  The schema in Figure 6 uses the types defined in
   Section 6.  Note that this figure (and other similar figures
   depicting a schema) are non-normative sketches of the structure of
   the message.

     {
       &quot;ietf-dots-signal-channel:mitigation-scope&quot;: {
         &quot;scope&quot;: [
           {
             &quot;target-prefix&quot;: [
                &quot;string&quot;
              ],
             &quot;target-port-range&quot;: [
                {
                  &quot;lower-port&quot;: number,
                  &quot;upper-port&quot;: number
                }
              ],
              &quot;target-protocol&quot;: [
                number
              ],
              &quot;target-fqdn&quot;: [
                &quot;string&quot;
              ],
              &quot;target-uri&quot;: [
                &quot;string&quot;
              ],
              &quot;alias-name&quot;: [
                &quot;string&quot;
              ],
             &quot;lifetime&quot;: number,
             &quot;trigger-mitigation&quot;: true|false
           }
         ]
       }
     }

       Figure 6: PUT to Convey DOTS Mitigation Requests (Message Body
                                  Schema)

   The parameters in the CBOR body (Figure 6) of the PUT request are
   described below:

   target-prefix:  A list of prefixes identifying resources under
      attack.  Prefixes are represented using Classless Inter-Domain
      Routing (CIDR) notation [RFC4632].

      As a reminder, the prefix length must be less than or equal to 32
      (or 128) for IPv4 (or IPv6).

      The prefix list MUST NOT include broadcast, loopback, or multicast
      addresses.  These addresses are considered to be invalid values.
      In addition, the DOTS server MUST validate that target prefixes
      are within the scope of the DOTS client domain.  Other validation
      checks may be supported by DOTS servers.

      This is an optional attribute.

   target-port-range:  A list of port numbers bound to resources under
      attack.

      A port range is defined by two bounds, a lower port number
      (&#x27;lower-port&#x27;) and an upper port number (&#x27;upper-port&#x27;).  When only
      &#x27;lower-port&#x27; is present, it represents a single port number.

      For TCP, UDP, Stream Control Transmission Protocol (SCTP)
      [RFC4960], or Datagram Congestion Control Protocol (DCCP)
      [RFC4340], a range of ports can be, for example, 0-1023,
      1024-65535, or 1024-49151.

      This is an optional attribute.

   target-protocol:  A list of protocols involved in an attack.  Values
      are taken from the IANA protocol registry [IANA-Proto].

      If &#x27;target-protocol&#x27; is not specified, then the request applies to
      any protocol.

      This is an optional attribute.

   target-fqdn:  A list of Fully Qualified Domain Names (FQDNs)
      identifying resources under attack [RFC8499].

      How a name is passed to an underlying name resolution library is
      implementation and deployment specific.  Nevertheless, once the
      name is resolved into one or multiple IP addresses, DOTS servers
      MUST apply the same validation checks as those for &#x27;target-
      prefix&#x27;.

      The use of FQDNs may be suboptimal because:

      *  It induces both an extra load and increased delays on the DOTS
         server to handle and manage DNS resolution requests.

      *  It does not guarantee that the DOTS server will resolve a name
         to the same IP addresses that the DOTS client does.

      This is an optional attribute.

   target-uri:  A list of URIs [RFC3986] identifying resources under
      attack.

      The same validation checks used for &#x27;target-fqdn&#x27; MUST be followed
      by DOTS servers to validate a target URI.

      This is an optional attribute.

   alias-name:  A list of aliases of resources for which the mitigation
      is requested.  Aliases can be created using the DOTS data channel
      (Section 6.1 of [RFC8783]), direct configuration, or other means.

      An alias is used in subsequent signal channel exchanges to refer
      more efficiently to the resources under attack.

      This is an optional attribute.

   lifetime:  Lifetime of the mitigation request in seconds.  The
      RECOMMENDED lifetime of a mitigation request is 3600 seconds: this
      value was chosen to be long enough so that refreshing is not
      typically a burden on the DOTS client, while still making the
      request expire in a timely manner when the client has unexpectedly
      quit.  DOTS clients MUST include this parameter in their
      mitigation requests.  Upon the expiry of this lifetime, and if the
      request is not refreshed, the mitigation request is removed.  The
      request can be refreshed by sending the same request again.

      A lifetime of &#x27;0&#x27; in a mitigation request is an invalid value.

      A lifetime of negative one (-1) indicates indefinite lifetime for
      the mitigation request.  The DOTS server MAY refuse an indefinite
      lifetime, for policy reasons; the granted lifetime value is
      returned in the response.  DOTS clients MUST be prepared to not be
      granted mitigations with indefinite lifetimes.

      The DOTS server MUST always indicate the actual lifetime in the
      response and the remaining lifetime in status messages sent to the
      DOTS client.

      This is a mandatory attribute.

   trigger-mitigation:  If the parameter value is set to &#x27;false&#x27;, DDoS
      mitigation will not be triggered for the mitigation request unless
      the DOTS signal channel session is lost.

      If the DOTS client ceases to respond to heartbeat messages, the
      DOTS server can detect that the DOTS signal channel session is
      lost.  More details are discussed in Section 4.7.

      The default value of the parameter is &#x27;true&#x27; (that is, the
      mitigation starts immediately).  If &#x27;trigger-mitigation&#x27; is not
      present in a request, this is equivalent to receiving a request
      with &#x27;trigger-mitigation&#x27; set to &#x27;true&#x27;.

      This is an optional attribute.

   In deployments where server-domain DOTS gateways are enabled,
   identity information about the origin source client domain (&#x27;cdid&#x27;)
   SHOULD be propagated to the DOTS server.  That information is meant
   to assist the DOTS server in enforcing some policies such as grouping
   DOTS clients that belong to the same DOTS domain, limiting the number
   of DOTS requests, and identifying the mitigation scope.  These
   policies can be enforced per client, per client domain, or both.
   Also, the identity information may be used for auditing and debugging
   purposes.

   Figure 7 shows an example of a request relayed by a server-domain
   DOTS gateway.

     Header: PUT (Code=0.03)
     Uri-Path: &quot;.well-known&quot;
     Uri-Path: &quot;dots&quot;
     Uri-Path: &quot;mitigate&quot;
     Uri-Path: &quot;cdid=7eeaf349529eb55ed50113&quot;
     Uri-Path: &quot;cuid=dz6pHjaADkaFTbjr0JGBpw&quot;
     Uri-Path: &quot;mid=123&quot;
     Content-Format: &quot;application/dots+cbor&quot;

     {
       ...
     }

       Figure 7: PUT for DOTS Mitigation Request as Relayed by a DOTS
                                  Gateway

   A server-domain DOTS gateway SHOULD add the following Uri-Path
   parameter:

   cdid:  Stands for Client Domain Identifier.  The &#x27;cdid&#x27; is conveyed
         by a server-domain DOTS gateway to propagate the source domain
         identity from the gateway&#x27;s client-facing side to the gateway&#x27;s
         server-facing side, and from the gateway&#x27;s server-facing side
         to the DOTS server. &#x27;cdid&#x27; may be used by the final DOTS server
         for policy enforcement purposes (e.g., enforce a quota on
         filtering rules).  These policies are deployment specific.

         Server-domain DOTS gateways SHOULD support a configuration
         option to instruct whether &#x27;cdid&#x27; parameter is to be inserted.

         In order to accommodate deployments that require enforcing per-
         client policies, per-client domain policies, or a combination
         thereof, server-domain DOTS gateways instructed to insert the
         &#x27;cdid&#x27; parameter MUST supply the SPKI hash of the DOTS client
         X.509 certificate, the DOTS client raw public key, or the hash
         of the &quot;PSK identity&quot; in the &#x27;cdid&#x27;, following the same rules
         for generating the hash conveyed in &#x27;cuid&#x27;, which is then used
         by the ultimate DOTS server to determine the corresponding
         client&#x27;s domain.  The &#x27;cdid&#x27; generated by a server-domain
         gateway is likely to be the same as the &#x27;cuid&#x27; except the case
         in which the DOTS message was relayed by a client-domain DOTS
         gateway or the &#x27;cuid&#x27; was generated from a rogue DOTS client.

         If a DOTS client is provisioned, for example, with distinct
         certificates as a function of the peer server-domain DOTS
         gateway, distinct &#x27;cdid&#x27; values may be supplied by a server-
         domain DOTS gateway.  The ultimate DOTS server MUST treat those
         &#x27;cdid&#x27; values as equivalent.

         The &#x27;cdid&#x27; attribute MUST NOT be generated and included by DOTS
         clients.

         DOTS servers MUST ignore &#x27;cdid&#x27; attributes that are directly
         supplied by source DOTS clients or client-domain DOTS gateways.
         This implies that first server-domain DOTS gateways MUST strip
         &#x27;cdid&#x27; attributes supplied by DOTS clients.  DOTS servers
         SHOULD support a configuration parameter to identify DOTS
         gateways that are trusted to supply &#x27;cdid&#x27; attributes.

         Only single-valued &#x27;cdid&#x27; are defined in this document.  That
         is, only the first on-path server-domain DOTS gateway can
         insert a &#x27;cdid&#x27; value.  This specification does not allow
         multiple server-domain DOTS gateways, whenever involved in the
         path, to insert a &#x27;cdid&#x27; value for each server-domain gateway.

         This is an optional Uri-Path.  When present, &#x27;cdid&#x27; MUST be
         positioned before &#x27;cuid&#x27;.

   A DOTS gateway SHOULD add the CoAP Hop-Limit option [RFC8768].

   Because of the complexity of handling partial failure cases, this
   specification does not allow the inclusion of multiple mitigation
   requests in the same PUT request.  Concretely, a DOTS client MUST NOT
   include multiple entries in the &#x27;scope&#x27; array of the same PUT
   request.

   FQDN and URI mitigation scopes may be thought of as a form of scope
   alias, in which the addresses associated with the domain name or URI
   (as resolved by the DOTS server) represent the scope of the
   mitigation.  Particularly, the IP addresses to which the host
   subcomponent of authority component of a URI resolves represent the
   &#x27;target-prefix&#x27;, the URI scheme represents the &#x27;target-protocol&#x27;, the
   port subcomponent of authority component of a URI represents the
   &#x27;target-port-range&#x27;.  If the optional port information is not present
   in the authority component, the default port defined for the URI
   scheme represents the &#x27;target-port&#x27;.

   In the PUT request, at least one of the attributes &#x27;target-prefix&#x27;,
   &#x27;target-fqdn&#x27;,&#x27;target-uri&#x27;, or &#x27;alias-name&#x27; MUST be present.

   Attributes and Uri-Path parameters with empty values MUST NOT be
   present in a request as an empty value will render the entire request
   invalid.

   Figure 8 shows a PUT request example to signal that servers
   2001:db8:6401::1 and 2001:db8:6401::2 are receiving attack traffic on
   TCP port numbers 80, 8080, and 443.  The presence of &#x27;cdid&#x27; indicates
   that a server-domain DOTS gateway has modified the initial PUT
   request sent by the DOTS client.  Note that &#x27;cdid&#x27; MUST NOT appear in
   the PUT request message body.

     Header: PUT (Code=0.03)
     Uri-Path: &quot;.well-known&quot;
     Uri-Path: &quot;dots&quot;
     Uri-Path: &quot;mitigate&quot;
     Uri-Path: &quot;cdid=7eeaf349529eb55ed50113&quot;
     Uri-Path: &quot;cuid=dz6pHjaADkaFTbjr0JGBpw&quot;
     Uri-Path: &quot;mid=123&quot;
     Content-Format: &quot;application/dots+cbor&quot;

     {
       &quot;ietf-dots-signal-channel:mitigation-scope&quot;: {
         &quot;scope&quot;: [
           {
             &quot;target-prefix&quot;: [
                &quot;2001:db8:6401::1/128&quot;,
                &quot;2001:db8:6401::2/128&quot;
              ],
             &quot;target-port-range&quot;: [
               {
                 &quot;lower-port&quot;: 80
               },
               {
                 &quot;lower-port&quot;: 443
               },
               {
                  &quot;lower-port&quot;: 8080
               }
              ],
              &quot;target-protocol&quot;: [
                6
              ],
             &quot;lifetime&quot;: 3600
           }
         ]
       }
     }

           Figure 8: PUT for DOTS Mitigation Request (An Example)

   The corresponding CBOR encoding format for the payload is shown in
   Figure 9.

      A1                                      # map(1)
         01                                   # unsigned(1)
         A1                                   # map(1)
            02                                # unsigned(2)
            81                                # array(1)
               A4                             # map(4)
                  06                          # unsigned(6)
                  82                          # array(2)
                     74                       # text(20)
                        323030313A6462383A363430313A3A312F313238
                     74                       # text(20)
                        323030313A6462383A363430313A3A322F313238
                  07                          # unsigned(7)
                  83                          # array(3)
                     A1                       # map(1)
                        08                    # unsigned(8)
                        18 50                 # unsigned(80)
                     A1                       # map(1)
                        08                    # unsigned(8)
                        19 01BB               # unsigned(443)
                     A1                       # map(1)
                        08                    # unsigned(8)
                        19 1F90               # unsigned(8080)
                  0A                          # unsigned(10)
                  81                          # array(1)
                     06                       # unsigned(6)
                  0E                          # unsigned(14)
                  19 0E10                     # unsigned(3600)

              Figure 9: PUT for DOTS Mitigation Request (CBOR)

   In both DOTS signal and data channel sessions, the DOTS client MUST
   authenticate itself to the DOTS server (Section 8).  The DOTS server
   MAY use the algorithm presented in Section 7 of [RFC7589] to derive
   the DOTS client identity or username from the client certificate.
   The DOTS client identity allows the DOTS server to accept mitigation
   requests with scopes that the DOTS client is authorized to manage.

   The DOTS server couples the DOTS signal and data channel sessions
   using the DOTS client identity and optionally the &#x27;cdid&#x27; parameter
   value, so the DOTS server can validate whether the aliases conveyed
   in the mitigation request were indeed created by the same DOTS client
   using the DOTS data channel session.  If the aliases were not created
   by the DOTS client, the DOTS server MUST return 4.00 (Bad Request) in
   the response.

   The DOTS server couples the DOTS signal channel sessions using the
   DOTS client identity and optionally the &#x27;cdid&#x27; parameter value, and
   the DOTS server uses &#x27;mid&#x27; and &#x27;cuid&#x27; Uri-Path parameter values to
   detect duplicate mitigation requests.  If the mitigation request
   contains the &#x27;alias-name&#x27; and other parameters identifying the target
   resources (such as &#x27;target-prefix&#x27;, &#x27;target-port-range&#x27;, &#x27;target-
   fqdn&#x27;, or &#x27;target-uri&#x27;), the DOTS server appends the parameter values
   in &#x27;alias-name&#x27; with the corresponding parameter values in &#x27;target-
   prefix&#x27;, &#x27;target-port-range&#x27;, &#x27;target-fqdn&#x27;, or &#x27;target-uri&#x27;.

   The DOTS server indicates the result of processing the PUT request
   using CoAP Response Codes.  CoAP 2.xx codes are success.  CoAP 4.xx
   codes are some sort of invalid requests (client errors).  COAP 5.xx
   codes are returned if the DOTS server is in an error state or is
   currently unavailable to provide mitigation in response to the
   mitigation request from the DOTS client.

   Figure 10 shows an example response to a PUT request that is
   successfully processed by a DOTS server (i.e., CoAP 2.xx Response
   Codes).  This version of the specification forbids &#x27;cuid&#x27; and &#x27;cdid&#x27;
   (if used) to be returned in a response message body.

   {
     &quot;ietf-dots-signal-channel:mitigation-scope&quot;: {
        &quot;scope&quot;: [
           {
             &quot;mid&quot;: 123,
             &quot;lifetime&quot;: 3600
           }
         ]
      }
   }

                       Figure 10: 2.xx Response Body

   If the request is missing a mandatory attribute, does not include
   &#x27;cuid&#x27; or &#x27;mid&#x27; Uri-Path options, includes multiple &#x27;scope&#x27;
   parameters, or contains invalid or unknown parameters, the DOTS
   server MUST reply with 4.00 (Bad Request).  DOTS agents can safely
   ignore comprehension-optional parameters they don&#x27;t understand
   (Section 9.6.1.1).

   A DOTS server that receives a mitigation request with a &#x27;lifetime&#x27;
   set to &#x27;0&#x27; MUST reply with a 4.00 (Bad Request).

   If the DOTS server does not find the &#x27;mid&#x27; parameter value conveyed
   in the PUT request in its configuration data, it MAY accept the
   mitigation request by sending back a 2.01 (Created) response to the
   DOTS client; the DOTS server will consequently try to mitigate the
   attack.  A DOTS server could reject mitigation requests when it is
   near capacity or needs to rate-limit a particular client, for
   example.

   The relative order of two mitigation requests with the same &#x27;trigger-
   mitigation&#x27; type from a DOTS client is determined by comparing their
   respective &#x27;mid&#x27; values.  If two mitigation requests with the same
   &#x27;trigger-mitigation&#x27; type have overlapping mitigation scopes, the
   mitigation request with the highest numeric &#x27;mid&#x27; value will override
   the other mitigation request.  Two mitigation requests from a DOTS
   client have overlapping scopes if there is a common IP address, IP
   prefix, FQDN, URI, or alias.  To avoid maintaining a long list of
   overlapping mitigation requests (i.e., requests with the same
   &#x27;trigger-mitigation&#x27; type and overlapping scopes) from a DOTS client
   and to avoid error-prone provisioning of mitigation requests from a
   DOTS client, the overlapped lower numeric &#x27;mid&#x27; MUST be automatically
   deleted and no longer available at the DOTS server.  For example, if
   the DOTS server receives a mitigation request that overlaps with an
   existing mitigation with a higher numeric &#x27;mid&#x27;, the DOTS server
   rejects the request by returning 4.09 (Conflict) to the DOTS client.
   The response includes enough information for a DOTS client to
   recognize the source of the conflict as described below in the
   &#x27;conflict-information&#x27; subtree with only the relevant nodes listed:

   conflict-information:  Indicates that a mitigation request is
      conflicting with another mitigation request.  This optional
      attribute has the following structure:

      conflict-cause:  Indicates the cause of the conflict.  The
         following values are defined:

         1:  Overlapping targets. &#x27;conflict-scope&#x27; provides more details
             about the conflicting target clauses.

      conflict-scope:  Characterizes the exact conflict scope.  It may
         include a list of IP addresses, a list of prefixes, a list of
         port numbers, a list of target protocols, a list of FQDNs, a
         list of URIs, a list of aliases, or a &#x27;mid&#x27;.

   If the DOTS server receives a mitigation request that overlaps with
   an active mitigation request, but both have distinct &#x27;trigger-
   mitigation&#x27; types, the DOTS server SHOULD deactivate (absent explicit
   policy/configuration otherwise) the mitigation request with &#x27;trigger-
   mitigation&#x27; set to &#x27;false&#x27;.  Particularly, if the mitigation request
   with &#x27;trigger-mitigation&#x27; set to &#x27;false&#x27; is active, the DOTS server
   withdraws the mitigation request (i.e., status code is set to &#x27;7&#x27; as
   defined in Table 3) and transitions the status of the mitigation
   request to &#x27;8&#x27;.

   Upon DOTS signal channel session loss with a peer DOTS client, the
   DOTS server SHOULD withdraw (absent explicit policy/configuration
   otherwise) any active mitigation requests that overlap with
   mitigation requests having &#x27;trigger-mitigation&#x27; set to &#x27;false&#x27; from
   that DOTS client, as the loss of the session implicitly activates
   these preconfigured mitigation requests, and they take precedence.
   Note that the active-but-terminating period is not observed for
   mitigations withdrawn at the initiative of the DOTS server.

   DOTS clients may adopt various strategies for setting the scopes of
   immediate and preconfigured mitigation requests to avoid potential
   conflicts.  For example, a DOTS client may tweak preconfigured scopes
   so that the scope of any overlapping immediate mitigation request
   will be a subset of the preconfigured scopes.  Also, if an immediate
   mitigation request overlaps with any of the preconfigured scopes, the
   DOTS client sets the scope of the overlapping immediate mitigation
   request to be a subset of the preconfigured scopes, so as to get a
   broad mitigation when the DOTS signal channel collapses and to
   maximize the chance of recovery.

   If the request conflicts with an existing mitigation request from a
   different DOTS client, the DOTS server may return 2.01 (Created) or
   4.09 (Conflict) to the requesting DOTS client.  If the DOTS server
   decides to maintain the new mitigation request, the DOTS server
   returns 2.01 (Created) to the requesting DOTS client.  If the DOTS
   server decides to reject the new mitigation request, the DOTS server
   returns 4.09 (Conflict) to the requesting DOTS client.  For both 2.01
   (Created) and 4.09 (Conflict) responses, the response includes enough
   information for a DOTS client to recognize the source of the conflict
   as described below:

   conflict-information:  Indicates that a mitigation request is
      conflicting with another mitigation request(s) from other DOTS
      client(s).  This optional attribute has the following structure:

      conflict-status:  Indicates the status of a conflicting mitigation
         request.  The following values are defined:

         1:  DOTS server has detected conflicting mitigation requests
             from different DOTS clients.  This mitigation request is
             currently inactive until the conflicts are resolved.
             Another mitigation request is active.

         2:  DOTS server has detected conflicting mitigation requests
             from different DOTS clients.  This mitigation request is
             currently active.

         3:  DOTS server has detected conflicting mitigation requests
             from different DOTS clients.  All conflicting mitigation
             requests are inactive.

      conflict-cause:  Indicates the cause of the conflict.  The
         following values are defined:

         1:  Overlapping targets. &#x27;conflict-scope&#x27; provides more details
             about the conflicting target clauses.

         2:  Conflicts with an existing accept-list.  This code is
             returned when the DDoS mitigation detects source addresses/
             prefixes in the accept-listed ACLs are attacking the
             target.

         3:  CUID Collision.  This code is returned when a DOTS client
             uses a &#x27;cuid&#x27; that is already used by another DOTS client.
             This code is an indication that the request has been
             rejected and a new request with a new &#x27;cuid&#x27; is to be re-
             sent by the DOTS client (see the example shown in
             Figure 11).  Note that &#x27;conflict-status&#x27;, &#x27;conflict-scope&#x27;,
             and &#x27;retry-timer&#x27; MUST NOT be returned in the error
             response.

      conflict-scope:  Characterizes the exact conflict scope.  It may
         include a list of IP addresses, a list of prefixes, a list of
         port numbers, a list of target protocols, a list of FQDNs, a
         list of URIs, a list of aliases, or references to conflicting
         ACLs (by an &#x27;acl-name&#x27;, typically [RFC8783]).

      retry-timer:  Indicates, in seconds, the time after which the DOTS
         client may reissue the same request.  The DOTS server returns
         &#x27;retry-timer&#x27; only to DOTS client(s) for which a mitigation
         request is deactivated.  Any retransmission of the same
         mitigation request before the expiry of this timer is likely to
         be rejected by the DOTS server for the same reasons.

         The &#x27;retry-timer&#x27; SHOULD be equal to the lifetime of the active
         mitigation request resulting in the deactivation of the
         conflicting mitigation request.

         If the DOTS server decides to maintain a state for the
         deactivated mitigation request, the DOTS server updates the
         lifetime of the deactivated mitigation request to &#x27;retry-timer
         + 45 seconds&#x27; (that is, this mitigation request remains
         deactivated for the entire duration of &#x27;retry-timer + 45
         seconds&#x27;) so that the DOTS client can refresh the deactivated
         mitigation request after &#x27;retry-timer&#x27; seconds, but before the
         expiry of the lifetime, and check if the conflict is resolved.

     Header: PUT (Code=0.03)
     Uri-Path: &quot;.well-known&quot;
     Uri-Path: &quot;dots&quot;
     Uri-Path: &quot;mitigate&quot;
     Uri-Path: &quot;cuid=7eeaf349529eb55ed50113&quot;
     Uri-Path: &quot;mid=12&quot;

     (1) Request with a conflicting &#x27;cuid&#x27;

     {
       &quot;ietf-dots-signal-channel:mitigation-scope&quot;: {
          &quot;scope&quot;: [
             {
               &quot;conflict-information&quot;: {
                 &quot;conflict-cause&quot;: &quot;cuid-collision&quot;
                }
             }
           ]
        }
     }

     (2) Message body of the 4.09 (Conflict) response
       from the DOTS server

     Header: PUT (Code=0.03)
     Uri-Path: &quot;.well-known&quot;
     Uri-Path: &quot;dots&quot;
     Uri-Path: &quot;mitigate&quot;
     Uri-Path: &quot;cuid=f30d281ce6b64fc5a0b91e&quot;
     Uri-Path: &quot;mid=12&quot;

     (3) Request with a new &#x27;cuid&#x27;

               Figure 11: Example of Generating a New &#x27;cuid&#x27;

   As an active attack evolves, DOTS clients can adjust the scope of
   requested mitigation as necessary, by refining the scope of resources
   requiring mitigation.  This can be achieved by sending a PUT request
   with a new &#x27;mid&#x27; value that will override the existing one with
   overlapping mitigation scopes.

   For a mitigation request to continue beyond the initial negotiated
   lifetime, the DOTS client has to refresh the current mitigation
   request by sending a new PUT request.  This PUT request MUST use the
   same &#x27;mid&#x27; value, and it MUST repeat all the other parameters as sent
   in the original mitigation request apart from a possible change to
   the &#x27;lifetime&#x27; parameter value.  In such a case, the DOTS server MAY
   update the mitigation request, and a 2.04 (Changed) response is
   returned to indicate a successful update of the mitigation request.
   If this is not the case, the DOTS server MUST reject the request with
   a 4.00 (Bad Request).

4.4.2.  Retrieve Information Related to a Mitigation

   A GET request is used by a DOTS client to retrieve information
   (including status) of DOTS mitigations from a DOTS server.

   &#x27;cuid&#x27; is a mandatory Uri-Path parameter for GET requests.

   Uri-Path parameters with empty values MUST NOT be present in a
   request.

   The same considerations for manipulating the &#x27;cdid&#x27; parameter by
   server-domain DOTS gateways specified in Section 4.4.1 MUST be
   followed for GET requests.

   The &#x27;c&#x27; Uri-Query option is used to control selection of
   configuration and non-configuration data nodes.  Concretely, the &#x27;c&#x27;
   (content) parameter and its permitted values defined in Table 2
   [COMI] can be used to retrieve non-configuration data (attack
   mitigation status), configuration data, or both.  The DOTS server MAY
   support this optional filtering capability.  It can safely ignore it
   if not supported.  If the DOTS client supports the optional filtering
   capability, it SHOULD use &quot;c=n&quot; query (to get back only the
   dynamically changing data) or &quot;c=c&quot; query (to get back the static
   configuration values) when the DDoS attack is active to limit the
   size of the response.

      +-------+-----------------------------------------------------+
      | Value | Description                                         |
      +=======+=====================================================+
      | c     | Return only configuration descendant data nodes     |
      +-------+-----------------------------------------------------+
      | n     | Return only non-configuration descendant data nodes |
      +-------+-----------------------------------------------------+
      | a     | Return all descendant data nodes                    |
      +-------+-----------------------------------------------------+

               Table 2: Permitted Values of the &#x27;c&#x27; Parameter

   The DOTS client can use block-wise transfer [RFC7959] to get the list
   of all its mitigations maintained by a DOTS server, it can send a
   Block2 Option in a GET request with NUM = 0 to aid in limiting the
   size of the response.  If the representation of all the active
   mitigation requests associated with the DOTS client does not fit
   within a single datagram, the DOTS server MUST use the Block2 Option
   with NUM = 0 in the GET response.  The Size2 Option may be conveyed
   in the response to indicate the total size of the resource
   representation.  The DOTS client retrieves the rest of the
   representation by sending additional GET requests with Block2 Options
   containing NUM values greater than zero.  The DOTS client MUST adhere
   to the block size preferences indicated by the DOTS server in the
   response.  If the DOTS server uses the Block2 Option in the GET
   response, and the response is for a dynamically changing resource
   (e.g., &quot;c=n&quot; or &quot;c=a&quot; query), the DOTS server MUST include the ETag
   Option in the response.  The DOTS client MUST include the same ETag
   value in subsequent GET requests to retrieve the rest of the
   representation.

   The following examples illustrate how a DOTS client retrieves active
   mitigation requests from a DOTS server.  In particular:

   *  Figure 12 shows the example of a GET request to retrieve all DOTS
      mitigation requests signaled by a DOTS client.

   *  Figure 13 shows the example of a GET request to retrieve a
      specific DOTS mitigation request signaled by a DOTS client.  The
      configuration data to be reported in the response is formatted in
      the same order as it was processed by the DOTS server in the
      original mitigation request.

   These two examples assume the default of &quot;c=a&quot;; that is, the DOTS
   client asks for all data to be reported by the DOTS server.

     Header: GET (Code=0.01)
     Uri-Path: &quot;.well-known&quot;
     Uri-Path: &quot;dots&quot;
     Uri-Path: &quot;mitigate&quot;
     Uri-Path: &quot;cuid=dz6pHjaADkaFTbjr0JGBpw&quot;
     Observe: 0

          Figure 12: GET to Retrieve All DOTS Mitigation Requests

     Header: GET (Code=0.01)
     Uri-Path: &quot;.well-known&quot;
     Uri-Path: &quot;dots&quot;
     Uri-Path: &quot;mitigate&quot;
     Uri-Path: &quot;cuid=dz6pHjaADkaFTbjr0JGBpw&quot;
     Uri-Path: &quot;mid=12332&quot;
     Observe: 0

       Figure 13: GET to Retrieve a Specific DOTS Mitigation Request

   If the DOTS server does not find the &#x27;mid&#x27; Uri-Path value conveyed in
   the GET request in its configuration data for the requesting DOTS
   client, it MUST respond with a 4.04 (Not Found) error Response Code.
   Likewise, the same error MUST be returned as a response to a request
   to retrieve all mitigation records (i.e., &#x27;mid&#x27; Uri-Path is not
   defined) of a given DOTS client if the DOTS server does not find any
   mitigation record for that DOTS client.  As a reminder, a DOTS client
   is identified by its identity (e.g., client certificate, &#x27;cuid&#x27;) and
   optionally the &#x27;cdid&#x27;.

   Figure 14 shows a response example of all active mitigation requests
   associated with the DOTS client as maintained by the DOTS server.
   The response indicates the mitigation status of each mitigation
   request.

   {
     &quot;ietf-dots-signal-channel:mitigation-scope&quot;: {
       &quot;scope&quot;: [
         {
           &quot;mid&quot;: 12332,
           &quot;mitigation-start&quot;: &quot;1507818434&quot;,
           &quot;target-prefix&quot;: [
                &quot;2001:db8:6401::1/128&quot;,
                &quot;2001:db8:6401::2/128&quot;
           ],
           &quot;target-protocol&quot;: [
             17
           ],
           &quot;lifetime&quot;: 1756,
           &quot;status&quot;: &quot;attack-successfully-mitigated&quot;,
           &quot;bytes-dropped&quot;: &quot;134334555&quot;,
           &quot;bps-dropped&quot;: &quot;43344&quot;,
           &quot;pkts-dropped&quot;: &quot;333334444&quot;,
           &quot;pps-dropped&quot;: &quot;432432&quot;
         },
         {
           &quot;mid&quot;: 12333,
           &quot;mitigation-start&quot;: &quot;1507818393&quot;,
           &quot;target-prefix&quot;: [
                &quot;2001:db8:6401::1/128&quot;,
                &quot;2001:db8:6401::2/128&quot;
           ],
           &quot;target-protocol&quot;: [
             6
           ],
           &quot;lifetime&quot;: 1755,
           &quot;status&quot;: &quot;attack-stopped&quot;,
           &quot;bytes-dropped&quot;: &quot;0&quot;,
           &quot;bps-dropped&quot;: &quot;0&quot;,
           &quot;pkts-dropped&quot;: &quot;0&quot;,
           &quot;pps-dropped&quot;: &quot;0&quot;
         }
       ]
     }
   }

                 Figure 14: Response Body to a GET Request

   The mitigation status parameters are described below:

   mitigation-start:  Mitigation start time is expressed in seconds
      relative to 1970-01-01T00:00Z in UTC time (Section 2.4.1 of
      [RFC7049]).  The CBOR encoding is modified so that the leading tag
      1 (epoch-based date/time) MUST be omitted.

      This is a mandatory attribute when an attack mitigation is active.
      Particularly, &#x27;mitigation-start&#x27; is not returned for a mitigation
      with &#x27;status&#x27; code set to 8.

   lifetime:  The remaining lifetime of the mitigation request, in
      seconds.

      This is a mandatory attribute.

   status:  Status of attack mitigation.  The various possible values of
      &#x27;status&#x27; parameter are explained in Table 3.

      This is a mandatory attribute.

   bytes-dropped:  The total dropped byte count for the mitigation
      request since the attack mitigation was triggered.  The count
      wraps around when it reaches the maximum value of unsigned
      integer64.

      This is an optional attribute.

   bps-dropped:  The average number of dropped bytes per second for the
      mitigation request since the attack mitigation was triggered.
      This average SHOULD be over five-minute intervals (that is,
      measuring bytes into five-minute buckets and then averaging these
      buckets over the time since the mitigation was triggered).

      This is an optional attribute.

   pkts-dropped:  The total number of dropped packet count for the
      mitigation request since the attack mitigation was triggered.  The
      count wraps around when it reaches the maximum value of unsigned
      integer64.

      This is an optional attribute.

   pps-dropped:  The average number of dropped packets per second for
      the mitigation request since the attack mitigation was triggered.
      This average SHOULD be over five-minute intervals (that is,
      measuring packets into five-minute buckets and then averaging
      these buckets over the time since the mitigation was triggered).

      This is an optional attribute.

    +-----------+----------------------------------------------------+
    | Parameter | Description                                        |
    |     Value |                                                    |
    +===========+====================================================+
    |         1 | Attack mitigation setup is in progress (e.g.,      |
    |           | changing the network path to redirect the inbound  |
    |           | traffic to a DOTS mitigator).                      |
    +-----------+----------------------------------------------------+
    |         2 | Attack is being successfully mitigated (e.g.,      |
    |           | traffic is redirected to a DDoS mitigator and      |
    |           | attack traffic is dropped).                        |
    +-----------+----------------------------------------------------+
    |         3 | Attack has stopped and the DOTS client can         |
    |           | withdraw the mitigation request.  This status code |
    |           | will be transmitted for immediate mitigation       |
    |           | requests till the mitigation is withdrawn or the   |
    |           | lifetime expires.  For mitigation requests with    |
    |           | preconfigured scopes (i.e., &#x27;trigger-mitigation&#x27;   |
    |           | set to &#x27;false&#x27;), this status code will be          |
    |           | transmitted four times and then transition to &quot;8&quot;. |
    +-----------+----------------------------------------------------+
    |         4 | Attack has exceeded the mitigation provider        |
    |           | capability.                                        |
    +-----------+----------------------------------------------------+
    |         5 | DOTS client has withdrawn the mitigation request   |
    |           | and the mitigation is active but terminating.      |
    +-----------+----------------------------------------------------+
    |         6 | Attack mitigation is now terminated.               |
    +-----------+----------------------------------------------------+
    |         7 | Attack mitigation is withdrawn (by the DOTS        |
    |           | server).  If a mitigation request with &#x27;trigger-   |
    |           | mitigation&#x27; set to &#x27;false&#x27; is withdrawn because it |
    |           | overlaps with an immediate mitigation request,     |
    |           | this status code will be transmitted four times    |
    |           | and then transition to &quot;8&quot; for the mitigation      |
    |           | request with preconfigured scopes.                 |
    +-----------+----------------------------------------------------+
    |         8 | Attack mitigation will be triggered for the        |
    |           | mitigation request only when the DOTS signal       |
    |           | channel session is lost.                           |
    +-----------+----------------------------------------------------+

                  Table 3: Values of &#x27;status&#x27; Parameter

4.4.2.1.  DOTS Servers Sending Mitigation Status

   The Observe Option defined in [RFC7641] extends the CoAP core
   protocol with a mechanism for a CoAP client to &quot;observe&quot; a resource
   on a CoAP server: the client retrieves a representation of the
   resource and requests this representation be updated by the server as
   long as the client is interested in the resource.  DOTS
   implementations MUST use the Observe Option for both &#x27;mitigate&#x27; and
   &#x27;config&#x27; (Section 4.2).

   A DOTS client conveys the Observe Option set to &#x27;0&#x27; in the GET
   request to receive asynchronous notifications of attack mitigation
   status from the DOTS server.

   Unidirectional mitigation notifications within the bidirectional
   signal channel enables asynchronous notifications between the agents.
   [RFC7641] indicates that (1) a notification can be sent in a
   Confirmable or a Non-confirmable message, and (2) the message type
   used is typically application dependent and may be determined by the
   server for each notification individually.  For the DOTS server
   application, the message type MUST always be set to Non-confirmable
   even if the underlying COAP library elects a notification to be sent
   in a Confirmable message.  This overrides the behavior defined in
   Section 4.5 of [RFC7641] to send a Confirmable message instead of a
   Non-confirmable message at least every 24 hours for the following
   reasons: First, the DOTS signal channel uses a heartbeat mechanism to
   determine if the DOTS client is alive.  Second, Confirmable messages
   are not suitable during an attack.

   Due to the higher likelihood of packet loss during a DDoS attack, the
   DOTS server periodically sends attack mitigation status to the DOTS
   client and also notifies the DOTS client whenever the status of the
   attack mitigation changes.  If the DOTS server cannot maintain an RTT
   estimate, it MUST NOT send more than one asynchronous notification
   every 3 seconds, and SHOULD use an even less aggressive rate whenever
   possible (case 2 in Section 3.1.3 of [RFC8085]).

   When conflicting requests are detected, the DOTS server enforces the
   corresponding policy (e.g., accept all requests, reject all requests,
   accept only one request but reject all the others, etc.).  It is
   assumed that this policy is supplied by the DOTS server administrator
   or that it is a default behavior of the DOTS server implementation.
   Then, the DOTS server sends a notification message(s) to the DOTS
   client(s) at the origin of the conflict (refer to the conflict
   parameters defined in Section 4.4.1).  A conflict notification
   message includes information about the conflict cause, scope, and the
   status of the mitigation request(s).  For example:

   *  A notification message with &#x27;status&#x27; code set to &#x27;7 (Attack
      mitigation is withdrawn)&#x27; and &#x27;conflict-status&#x27; set to &#x27;1&#x27; is sent
      to a DOTS client to indicate that an active mitigation request is
      deactivated because a conflict is detected.

   *  A notification message with &#x27;status&#x27; code set to &#x27;1 (Attack
      mitigation is in progress)&#x27; and &#x27;conflict-status&#x27; set to &#x27;2&#x27; is
      sent to a DOTS client to indicate that this mitigation request is
      in progress, but a conflict is detected.

   Upon receipt of a conflict notification message indicating that a
   mitigation request is deactivated because of a conflict, a DOTS
   client MUST NOT resend the same mitigation request before the expiry
   of &#x27;retry-timer&#x27;.  It is also recommended that DOTS clients support
   the means to alert administrators about mitigation conflicts.

   A DOTS client that is no longer interested in receiving notifications
   from the DOTS server can simply &quot;forget&quot; the observation.  When the
   DOTS server sends the next notification, the DOTS client will not
   recognize the token in the message and, thus, will return a Reset
   message.  This causes the DOTS server to remove the associated entry.
   Alternatively, the DOTS client can explicitly de-register itself by
   issuing a GET request that has the Token field set to the token of
   the observation to be canceled and includes an Observe Option with
   the value set to &#x27;1&#x27; (de-register).  The latter is more deterministic
   and, thus, is RECOMMENDED.

   Figure 15 shows an example of a DOTS client requesting a DOTS server
   to send notifications related to a mitigation request.  Note that for
   mitigations with preconfigured scopes (i.e., &#x27;trigger-mitigation&#x27; set
   to &#x27;false&#x27;), the state will need to transition from 3 (attack-
   stopped) to 8 (attack-mitigation-signal-loss).

   +-----------+                              +-----------+
   |DOTS Client|                              |DOTS Server|
   +-----------+                              +-----------+
         |                                          |
         |  GET /&lt;mid&gt;                              |
         |  Token: 0x4a                             | Registration
         |  Observe: 0                              |
         +-----------------------------------------&gt;|
         |                                          |
         |  2.05 Content                            |
         |  Token: 0x4a                             | Notification of
         |  Observe: 12                             | the current state
         |  status: &quot;attack-mitigation-in-progress&quot; |
         |&lt;-----------------------------------------+
         |                                          |
         |  2.05 Content                            |
         |  Token: 0x4a                             | Notification upon
         |  Observe: 44                             | a state change
         |  status: &quot;attack-successfully-mitigated&quot; |
         |&lt;-----------------------------------------+
         |                                          |
         |  2.05 Content                            |
         |  Token: 0x4a                             | Notification upon
         |  Observe: 60                             | a state change
         |  status: &quot;attack-stopped&quot;                |
         |&lt;-----------------------------------------+
         |                                          |
                            ...

            Figure 15: Notifications of Attack Mitigation Status

4.4.2.2.  DOTS Clients Polling for Mitigation Status

   The DOTS client can send the GET request at frequent intervals
   without the Observe Option to retrieve the configuration data of the
   mitigation request and non-configuration data (i.e., the attack
   status).  DOTS clients MAY be configured with a policy indicating the
   frequency of polling DOTS servers to get the mitigation status.  This
   frequency MUST NOT be more than one UDP datagram per RTT as discussed
   in Section 3.1.3 of [RFC8085].

   If the DOTS server has been able to mitigate the attack and the
   attack has stopped, the DOTS server indicates as such in the status.
   In such case, the DOTS client recalls the mitigation request by
   issuing a DELETE request for this mitigation request (Section 4.4.4).

   A DOTS client SHOULD react to the status of the attack per the
   information sent by the DOTS server rather than performing its own
   detection that the attack has been mitigated.  This ensures that the
   DOTS client does not recall a mitigation request prematurely because
   it is possible that the DOTS client does not sense the DDoS attack on
   its resources, but the DOTS server could be actively mitigating the
   attack because the attack is not completely averted.

4.4.3.  Efficacy Update from DOTS Clients

   While DDoS mitigation is in progress, due to the likelihood of packet
   loss, a DOTS client MAY periodically transmit DOTS mitigation
   efficacy updates to the relevant DOTS server.  A PUT request is used
   to convey the mitigation efficacy update to the DOTS server.  This
   PUT request is treated as a refresh of the current mitigation.

   The PUT request used for the efficacy update MUST include all the
   parameters used in the PUT request to carry the DOTS mitigation
   request (Section 4.4.1) unchanged apart from the &#x27;lifetime&#x27; parameter
   value.  If this is not the case, the DOTS server MUST reject the
   request with a 4.00 (Bad Request).

   The If-Match Option (Section 5.10.8.1 of [RFC7252]) with an empty
   value is used to make the PUT request conditional on the current
   existence of the mitigation request.  If UDP is used as transport,
   CoAP requests may arrive out of order.  For example, the DOTS client
   may send a PUT request to convey an efficacy update to the DOTS
   server followed by a DELETE request to withdraw the mitigation
   request, but the DELETE request arrives at the DOTS server before the
   PUT request.  To handle out-of-order delivery of requests, if an If-
   Match Option is present in the PUT request and the &#x27;mid&#x27; in the
   request matches a mitigation request from that DOTS client, the
   request is processed by the DOTS server.  If no match is found, the
   PUT request is silently ignored by the DOTS server.

   An example of an efficacy update message, which includes an If-Match
   Option with an empty value, is depicted in Figure 16.

      Header: PUT (Code=0.03)
      Uri-Path: &quot;.well-known&quot;
      Uri-Path: &quot;dots&quot;
      Uri-Path: &quot;mitigate&quot;
      Uri-Path: &quot;cuid=dz6pHjaADkaFTbjr0JGBpw&quot;
      Uri-Path: &quot;mid=123&quot;
      If-Match:
      Content-Format: &quot;application/dots+cbor&quot;

      {
       &quot;ietf-dots-signal-channel:mitigation-scope&quot;: {
         &quot;scope&quot;: [
           {
             &quot;target-prefix&quot;: [
                &quot;2001:db8:6401::1/128&quot;,
                &quot;2001:db8:6401::2/128&quot;
              ],
             &quot;target-port-range&quot;: [
               {
                 &quot;lower-port&quot;: 80
               },
               {
                 &quot;lower-port&quot;: 443
               },
               {
                  &quot;lower-port&quot;: 8080
               }
             ],
             &quot;target-protocol&quot;: [
                6
             ],
             &quot;attack-status&quot;: &quot;under-attack&quot;
           }
         ]
       }
      }

                  Figure 16: An Example of Efficacy Update

   The &#x27;attack-status&#x27; parameter is a mandatory attribute when
   performing an efficacy update.  The various possible values contained
   in the &#x27;attack-status&#x27; parameter are described in Table 4.

            +-----------+-------------------------------------+
            | Parameter | Description                         |
            |     Value |                                     |
            +===========+=====================================+
            |         1 | The DOTS client determines that it  |
            |           | is still under attack.              |
            +-----------+-------------------------------------+
            |         2 | The DOTS client determines that the |
            |           | attack is successfully mitigated    |
            |           | (e.g., attack traffic is not seen). |
            +-----------+-------------------------------------+

                Table 4: Values of &#x27;attack-status&#x27; Parameter

   The DOTS server indicates the result of processing a PUT request
   using CoAP Response Codes.  The Response Code 2.04 (Changed) is
   returned if the DOTS server has accepted the mitigation efficacy
   update.  The error Response Code 5.03 (Service Unavailable) is
   returned if the DOTS server has erred or is incapable of performing
   the mitigation.  As specified in [RFC7252], 5.03 uses Max-Age Option
   to indicate the number of seconds after which to retry.

4.4.4.  Withdraw a Mitigation

   DELETE requests are used to withdraw DOTS mitigation requests from
   DOTS servers (Figure 17).

   &#x27;cuid&#x27; and &#x27;mid&#x27; are mandatory Uri-Path parameters for DELETE
   requests.

   The same considerations for manipulating &#x27;cdid&#x27; parameter by DOTS
   gateways, as specified in Section 4.4.1, MUST be followed for DELETE
   requests.  Uri-Path parameters with empty values MUST NOT be present
   in a request.

     Header: DELETE (Code=0.04)
     Uri-Path: &quot;.well-known&quot;
     Uri-Path: &quot;dots&quot;
     Uri-Path: &quot;mitigate&quot;
     Uri-Path: &quot;cuid=dz6pHjaADkaFTbjr0JGBpw&quot;
     Uri-Path: &quot;mid=123&quot;

                   Figure 17: Withdraw a DOTS Mitigation

   If the DELETE request does not include &#x27;cuid&#x27; and &#x27;mid&#x27; parameters,
   the DOTS server MUST reply with a 4.00 (Bad Request).

   Once the request is validated, the DOTS server immediately
   acknowledges a DOTS client&#x27;s request to withdraw the DOTS signal
   using 2.02 (Deleted) Response Code with no response payload.  A 2.02
   (Deleted) Response Code is returned even if the &#x27;mid&#x27; parameter value
   conveyed in the DELETE request does not exist in its configuration
   data before the request.

   If the DOTS server finds the &#x27;mid&#x27; parameter value conveyed in the
   DELETE request in its configuration data for the DOTS client, then to
   protect against route or DNS flapping caused by a DOTS client rapidly
   removing a mitigation, and to dampen the effect of oscillating
   attacks, the DOTS server MAY allow mitigation to continue for a
   limited period after acknowledging a DOTS client&#x27;s withdrawal of a
   mitigation request.  During this period, the DOTS server status
   messages SHOULD indicate that mitigation is active but terminating
   (Section 4.4.2).

   The initial active-but-terminating period SHOULD be sufficiently long
   to absorb latency incurred by route propagation.  The active-but-
   terminating period SHOULD be set by default to 120 seconds.  If the
   client requests mitigation again before the initial active-but-
   terminating period elapses, the DOTS server MAY exponentially
   increase (the base of the exponent is 2) the active-but-terminating
   period up to a maximum of 300 seconds (5 minutes).

   Once the active-but-terminating period elapses, the DOTS server MUST
   treat the mitigation as terminated, as the DOTS client is no longer
   responsible for the mitigation.

   If a mitigation is triggered due to a signal channel loss, the DOTS
   server relies upon normal triggers to stop that mitigation
   (typically, receipt of a valid DELETE request, expiry of the
   mitigation lifetime, or scrubbing the traffic to the attack target).
   In particular, the DOTS server MUST NOT consider the signal channel
   recovery as a trigger to stop the mitigation.

4.5.  DOTS Signal Channel Session Configuration

   A DOTS client can negotiate, configure, and retrieve the DOTS signal
   channel session behavior with its DOTS peers.  The DOTS signal
   channel can be used, for example, to configure the following:

   a.  Heartbeat interval (heartbeat-interval): DOTS agents regularly
       send heartbeats to each other after mutual authentication is
       successfully completed in order to keep the DOTS signal channel
       open.  Heartbeat messages are exchanged between DOTS agents every
       &#x27;heartbeat-interval&#x27; seconds to detect the current status of the
       DOTS signal channel session.

   b.  Missing heartbeats allowed (missing-hb-allowed): This variable
       indicates the maximum number of consecutive heartbeat messages
       for which a DOTS agent did not receive a response before
       concluding that the session is disconnected or defunct.

   c.  Acceptable probing rate (probing-rate): This parameter indicates
       the average data rate that must not be exceeded by a DOTS agent
       in sending to a peer DOTS agent that does not respond.

   d.  Acceptable signal loss ratio: Maximum retransmissions,
       retransmission timeout value, and other message transmission
       parameters for Confirmable messages over the DOTS signal channel.

   When the DOTS signal channel is established over a reliable transport
   (e.g., TCP), there is no need for the reliability mechanisms provided
   by CoAP over UDP since the underlying TCP connection provides
   retransmissions and deduplication [RFC8323].  As a reminder, CoAP
   over reliable transports does not support Confirmable or Non-
   confirmable message types.  As such, the transmission-related
   parameters (&#x27;missing-hb-allowed&#x27; and acceptable signal loss ratio)
   are negotiated only for DOTS over unreliable transports.

   The same or distinct configuration sets may be used during times when
   a mitigation is active (&#x27;mitigating-config&#x27;) and when no mitigation
   is active (&#x27;idle-config&#x27;).  This is particularly useful for DOTS
   servers that might want to reduce heartbeat frequency or cease
   heartbeat exchanges when an active DOTS client has not requested
   mitigation.  If distinct configurations are used, DOTS agents MUST
   follow the appropriate configuration set as a function of the
   mitigation activity (e.g., if no mitigation request is active (also
   referred to as &#x27;idle&#x27; time), values related to &#x27;idle-config&#x27; must be
   followed).  Additionally, DOTS agents MUST automatically switch to
   the other configuration upon a change in the mitigation activity
   (e.g., if an attack mitigation is launched after an &#x27;idle&#x27; time, the
   DOTS agent switches from values related to &#x27;idle-config&#x27; to values
   related to &#x27;mitigating-config&#x27;).

   CoAP requests and responses are indicated for reliable delivery by
   marking them as Confirmable messages.  DOTS signal channel session
   configuration requests and responses are marked as Confirmable
   messages.  As explained in Section 2.1 of [RFC7252], a Confirmable
   message is retransmitted using a default timeout and exponential
   backoff between retransmissions, until the DOTS server sends an
   Acknowledgement message (ACK) with the same Message ID conveyed from
   the DOTS client.

   Message transmission parameters are defined in Section 4.8 of
   [RFC7252].  The DOTS server can either piggyback the response in the
   Acknowledgement message or, if the DOTS server cannot respond
   immediately to a request carried in a Confirmable message, it simply
   responds with an Empty Acknowledgement message so that the DOTS
   client can stop retransmitting the request.  Empty Acknowledgement
   messages are explained in Section 2.2 of [RFC7252].  When the
   response is ready, the server sends it in a new Confirmable message,
   which, in turn, needs to be acknowledged by the DOTS client (see
   Sections 5.2.1 and 5.2.2 of [RFC7252]).  Requests and responses
   exchanged between DOTS agents during &#x27;idle&#x27; time, except heartbeat
   messages, are marked as Confirmable messages.

      |  Implementation Note: A DOTS client that receives a response in
      |  a Confirmable message may want to clean up the message state
      |  right after sending the ACK.  If that ACK is lost and the DOTS
      |  server retransmits the Confirmable message, the DOTS client may
      |  no longer have any state that would help it correlate this
      |  response: from the DOTS client&#x27;s standpoint, the retransmission
      |  message is unexpected.  The DOTS client will send a Reset
      |  message so it does not receive any more retransmissions.  This
      |  behavior is normal and not an indication of an error (see
      |  Section 5.3.2 of [RFC7252] for more details).

4.5.1.  Discover Configuration Parameters

   A GET request is used to obtain acceptable (e.g., minimum and maximum
   values) and current configuration parameters on the DOTS server for
   DOTS signal channel session configuration.  This procedure occurs
   between a DOTS client and its immediate peer DOTS server.  As such,
   this GET request MUST NOT be relayed by a DOTS gateway.

   Figure 18 shows how to obtain configuration parameters that the DOTS
   server will find acceptable.

     Header: GET (Code=0.01)
     Uri-Path: &quot;.well-known&quot;
     Uri-Path: &quot;dots&quot;
     Uri-Path: &quot;config&quot;

                  Figure 18: GET to Retrieve Configuration

   The DOTS server in the 2.05 (Content) response conveys the current,
   minimum, and maximum attribute values acceptable by the DOTS server
   (Figure 19).

   {
     &quot;ietf-dots-signal-channel:signal-config&quot;: {
       &quot;mitigating-config&quot;: {
         &quot;heartbeat-interval&quot;: {
           &quot;max-value&quot;: number,
           &quot;min-value&quot;: number,
           &quot;current-value&quot;: number
         },
         &quot;missing-hb-allowed&quot;: {
           &quot;max-value&quot;: number,
           &quot;min-value&quot;: number,
           &quot;current-value&quot;: number
         },
         &quot;probing-rate&quot;: {
           &quot;max-value&quot;: number,
           &quot;min-value&quot;: number,
           &quot;current-value&quot;: number
         },
         &quot;max-retransmit&quot;: {
           &quot;max-value&quot;: number,
           &quot;min-value&quot;: number,
           &quot;current-value&quot;: number
         },
         &quot;ack-timeout&quot;: {
           &quot;max-value-decimal&quot;: &quot;string&quot;,
           &quot;min-value-decimal&quot;: &quot;string&quot;,
           &quot;current-value-decimal&quot;: &quot;string&quot;
         },
         &quot;ack-random-factor&quot;: {
           &quot;max-value-decimal&quot;: &quot;string&quot;,
           &quot;min-value-decimal&quot;: &quot;string&quot;,
           &quot;current-value-decimal&quot;: &quot;string&quot;
         }
       },
       &quot;idle-config&quot;: {
         &quot;heartbeat-interval&quot;: {
           &quot;max-value&quot;: number,
           &quot;min-value&quot;: number,
           &quot;current-value&quot;: number
         },
         &quot;missing-hb-allowed&quot;: {
           &quot;max-value&quot;: number,
           &quot;min-value&quot;: number,
           &quot;current-value&quot;: number
         },
         &quot;probing-rate&quot;: {
           &quot;max-value&quot;: number,
           &quot;min-value&quot;: number,
           &quot;current-value&quot;: number
         },
         &quot;max-retransmit&quot;: {
           &quot;max-value&quot;: number,
           &quot;min-value&quot;: number,
           &quot;current-value&quot;: number
         },
         &quot;ack-timeout&quot;: {
           &quot;max-value-decimal&quot;: &quot;string&quot;,
           &quot;min-value-decimal&quot;: &quot;string&quot;,
           &quot;current-value-decimal&quot;: &quot;string&quot;
         },
         &quot;ack-random-factor&quot;: {
           &quot;max-value-decimal&quot;: &quot;string&quot;,
           &quot;min-value-decimal&quot;: &quot;string&quot;,
           &quot;current-value-decimal&quot;: &quot;string&quot;
         }
       }
     }
   }

             Figure 19: GET Configuration Response Body Schema

   The parameters in Figure 19 are described below:

   mitigating-config:  Set of configuration parameters to use when a
      mitigation is active.  The following parameters may be included:

      heartbeat-interval:  Time interval in seconds between two
         consecutive heartbeat messages.

         &#x27;0&#x27; is used to disable the heartbeat mechanism.

         This is an optional attribute.

      missing-hb-allowed:  Maximum number of consecutive heartbeat
         messages for which the DOTS agent did not receive a response
         before concluding that the session is disconnected.

         This is an optional attribute.

      probing-rate:  The average data rate that must not be exceeded by
         a DOTS agent in sending to a peer DOTS agent that does not
         respond (referred to as PROBING_RATE parameter in CoAP).

         This is an optional attribute.

      max-retransmit:  Maximum number of retransmissions for a message
         (referred to as MAX_RETRANSMIT parameter in CoAP).

         This is an optional attribute.

      ack-timeout:  Timeout value in seconds used to calculate the
         initial retransmission timeout value (referred to as
         ACK_TIMEOUT parameter in CoAP).

         This is an optional attribute.

      ack-random-factor:  Random factor used to influence the timing of
         retransmissions (referred to as ACK_RANDOM_FACTOR parameter in
         CoAP).

         This is an optional attribute.

   idle-config:  Set of configuration parameters to use when no
      mitigation is active.  This attribute has the same structure as
      &#x27;mitigating-config&#x27;.

   Figure 20 shows an example of acceptable and current configuration
   parameters on a DOTS server for DOTS signal channel session
   configuration.  The same acceptable configuration is used during
   mitigation and idle times.

   {
     &quot;ietf-dots-signal-channel:signal-config&quot;: {
       &quot;mitigating-config&quot;: {
         &quot;heartbeat-interval&quot;: {
           &quot;max-value&quot;: 240,
           &quot;min-value&quot;: 15,
           &quot;current-value&quot;: 30
         },
         &quot;missing-hb-allowed&quot;: {
           &quot;max-value&quot;: 20,
           &quot;min-value&quot;: 3,
           &quot;current-value&quot;: 15
         },
         &quot;probing-rate&quot;: {
           &quot;max-value&quot;: 20,
           &quot;min-value&quot;: 5,
           &quot;current-value&quot;: 15
         },
         &quot;max-retransmit&quot;: {
           &quot;max-value&quot;: 15,
           &quot;min-value&quot;: 2,
           &quot;current-value&quot;: 3
         },
         &quot;ack-timeout&quot;: {
           &quot;max-value-decimal&quot;: &quot;30.00&quot;,
           &quot;min-value-decimal&quot;: &quot;1.00&quot;,
           &quot;current-value-decimal&quot;: &quot;2.00&quot;
         },
         &quot;ack-random-factor&quot;: {
           &quot;max-value-decimal&quot;: &quot;4.00&quot;,
           &quot;min-value-decimal&quot;: &quot;1.10&quot;,
           &quot;current-value-decimal&quot;: &quot;1.50&quot;
         }
       },
       &quot;idle-config&quot;: {
         &quot;heartbeat-interval&quot;: {
           &quot;max-value&quot;: 240,
           &quot;min-value&quot;: 15,
           &quot;current-value&quot;: 30
         },
         &quot;missing-hb-allowed&quot;: {
           &quot;max-value&quot;: 20,
           &quot;min-value&quot;: 3,
           &quot;current-value&quot;: 15
         },
         &quot;probing-rate&quot;: {
           &quot;max-value&quot;: 20,
           &quot;min-value&quot;: 5,
           &quot;current-value&quot;: 15
         },
         &quot;max-retransmit&quot;: {
           &quot;max-value&quot;: 15,
           &quot;min-value&quot;: 2,
           &quot;current-value&quot;: 3
         },
         &quot;ack-timeout&quot;: {
           &quot;max-value-decimal&quot;: &quot;30.00&quot;,
           &quot;min-value-decimal&quot;: &quot;1.00&quot;,
           &quot;current-value-decimal&quot;: &quot;2.00&quot;
         },
         &quot;ack-random-factor&quot;: {
           &quot;max-value-decimal&quot;: &quot;4.00&quot;,
           &quot;min-value-decimal&quot;: &quot;1.10&quot;,
           &quot;current-value-decimal&quot;: &quot;1.50&quot;
         }
       }
     }
   }

            Figure 20: Example of a Configuration Response Body

4.5.2.  Convey DOTS Signal Channel Session Configuration

   A PUT request (Figures 21 and 22) is used to convey the configuration
   parameters for the signal channel (e.g., heartbeat interval, maximum
   retransmissions).  Message transmission parameters for CoAP are
   defined in Section 4.8 of [RFC7252].  The RECOMMENDED values of
   transmission parameter values are &#x27;ack-timeout&#x27; (2 seconds), &#x27;max-
   retransmit&#x27; (3), and &#x27;ack-random-factor&#x27; (1.5).  In addition to those
   parameters, the RECOMMENDED specific DOTS transmission parameter
   values are &#x27;heartbeat-interval&#x27; (30 seconds) and &#x27;missing-hb-allowed&#x27;
   (15).

      |  Note: &#x27;heartbeat-interval&#x27; should be tweaked to also assist
      |  DOTS messages for NAT traversal (SIG-011 of [RFC8612]).
      |  According to [RFC8085], heartbeat messages must not be sent
      |  more frequently than once every 15 seconds and should use
      |  longer intervals when possible.  Furthermore, [RFC4787]
      |  recommends that NATs use a state timeout of 2 minutes or
      |  longer, but experience shows that sending packets every 15 to
      |  30 seconds is necessary to prevent the majority of middleboxes
      |  from losing state for UDP flows.  From that standpoint, the
      |  RECOMMENDED minimum &#x27;heartbeat-interval&#x27; is 15 seconds and the
      |  RECOMMENDED maximum &#x27;heartbeat-interval&#x27; is 240 seconds.  The
      |  recommended value of 30 seconds is selected to anticipate the
      |  expiry of NAT state.
      |
      |  A &#x27;heartbeat-interval&#x27; of 30 seconds may be considered to be
      |  too chatty in some deployments.  For such deployments, DOTS
      |  agents may negotiate longer &#x27;heartbeat-interval&#x27; values to
      |  prevent any network overload with too frequent heartbeats.
      |
      |  Different heartbeat intervals can be defined for &#x27;mitigating-
      |  config&#x27; and &#x27;idle-config&#x27; to reduce being too chatty during
      |  idle times.  If there is an on-path translator between the DOTS
      |  client (standalone or part of a DOTS gateway) and the DOTS
      |  server, the &#x27;mitigating-config&#x27; &#x27;heartbeat-interval&#x27; has to be
      |  smaller than the translator session timeout.  It is recommended
      |  that the &#x27;idle-config&#x27; &#x27;heartbeat-interval&#x27; also be smaller
      |  than the translator session timeout to prevent translator
      |  traversal issues or that it be disabled entirely.  Means to
      |  discover the lifetime assigned by a translator are out of
      |  scope.
      |
      |  Given that the size of the heartbeat request cannot exceed
      |  (&#x27;heartbeat-interval&#x27; * &#x27;probing-rate&#x27;) bytes, &#x27;probing-rate&#x27;
      |  should be set appropriately to avoid slowing down heartbeat
      |  exchanges.  For example, &#x27;probing-rate&#x27; may be set to 2 *
      |  (&quot;size of encrypted DOTS heartbeat request&quot;/&#x27;heartbeat-
      |  interval&#x27;) or ((&quot;size of encrypted DOTS heartbeat request&quot; +
      |  &quot;average size of an encrypted mitigation request&quot;)/&#x27;heartbeat-
      |  interval&#x27;).  Absent any explicit configuration or inability to
      |  dynamically adjust &#x27;probing-rate&#x27; values (Section 4.8.1 of
      |  [RFC7252]), DOTS agents use 5 bytes/second as a default
      |  &#x27;probing-rate&#x27; value.

   If the DOTS agent wishes to change the default values of message
   transmission parameters, it SHOULD follow the guidance given in
   Section 4.8.1 of [RFC7252].  The DOTS agents MUST use the negotiated
   values for message transmission parameters and default values for
   non-negotiated message transmission parameters.

   The signal channel session configuration is applicable to a single
   DOTS signal channel session between DOTS agents, so the &#x27;cuid&#x27; Uri-
   Path MUST NOT be used.

     Header: PUT (Code=0.03)
     Uri-Path: &quot;.well-known&quot;
     Uri-Path: &quot;dots&quot;
     Uri-Path: &quot;config&quot;
     Uri-Path: &quot;sid=123&quot;
     Content-Format: &quot;application/dots+cbor&quot;

     {
      ...
     }

          Figure 21: PUT to Convey the DOTS Signal Channel Session
                             Configuration Data

   The additional Uri-Path parameter to those defined in Table 1 is as
   follows:

   sid:  Session Identifier is an identifier for the DOTS signal channel
        session configuration data represented as an integer.  This
        identifier MUST be generated by DOTS clients.  &#x27;sid&#x27; values MUST
        increase monotonically (when a new PUT is generated by a DOTS
        client to convey the configuration parameters for the signal
        channel).

        This is a mandatory attribute.

     {
       &quot;ietf-dots-signal-channel:signal-config&quot;: {
         &quot;mitigating-config&quot;: {
           &quot;heartbeat-interval&quot;: {
             &quot;current-value&quot;: number
           },
           &quot;missing-hb-allowed&quot;: {
             &quot;current-value&quot;: number
           },
           &quot;probing-rate&quot;: {
             &quot;current-value&quot;: number
           },
           &quot;max-retransmit&quot;: {
             &quot;current-value&quot;: number
           },
           &quot;ack-timeout&quot;: {
             &quot;current-value-decimal&quot;: &quot;string&quot;
           },
           &quot;ack-random-factor&quot;: {
             &quot;current-value-decimal&quot;: &quot;string&quot;
           }
         },
         &quot;idle-config&quot;: {
           &quot;heartbeat-interval&quot;: {
             &quot;current-value&quot;: number
           },
           &quot;missing-hb-allowed&quot;: {
             &quot;current-value&quot;: number
           },
           &quot;probing-rate&quot;: {
             &quot;current-value&quot;: number
           },
           &quot;max-retransmit&quot;: {
             &quot;current-value&quot;: number
           },
           &quot;ack-timeout&quot;: {
             &quot;current-value-decimal&quot;: &quot;string&quot;
           },
           &quot;ack-random-factor&quot;: {
             &quot;current-value-decimal&quot;: &quot;string&quot;
           }
         }
       }
     }

          Figure 22: PUT to Convey the DOTS Signal Channel Session
                  Configuration Data (Message Body Schema)

   The meaning of the parameters in the CBOR body (Figure 22) is defined
   in Section 4.5.1.

   At least one of the attributes &#x27;heartbeat-interval&#x27;, &#x27;missing-hb-
   allowed&#x27;, &#x27;probing-rate&#x27;, &#x27;max-retransmit&#x27;, &#x27;ack-timeout&#x27;, and &#x27;ack-
   random-factor&#x27; MUST be present in the PUT request.  Note that
   &#x27;heartbeat-interval&#x27;, &#x27;missing-hb-allowed&#x27;, &#x27;probing-rate&#x27;, &#x27;max-
   retransmit&#x27;, &#x27;ack-timeout&#x27;, and &#x27;ack-random-factor&#x27;, if present, do
   not need to be provided for both &#x27;mitigating-config&#x27;, and &#x27;idle-
   config&#x27; in a PUT request.

   The PUT request with a higher numeric &#x27;sid&#x27; value overrides the DOTS
   signal channel session configuration data installed by a PUT request
   with a lower numeric &#x27;sid&#x27; value.  To avoid maintaining a long list
   of &#x27;sid&#x27; requests from a DOTS client, the lower numeric &#x27;sid&#x27; MUST be
   automatically deleted and no longer available at the DOTS server.

   Figure 23 shows a PUT request example to convey the configuration
   parameters for the DOTS signal channel.  In this example, the
   heartbeat mechanism is disabled when no mitigation is active, while
   the heartbeat interval is set to &#x27;30&#x27; when a mitigation is active.

     Header: PUT (Code=0.03)
     Uri-Path: &quot;.well-known&quot;
     Uri-Path: &quot;dots&quot;
     Uri-Path: &quot;config&quot;
     Uri-Path: &quot;sid=123&quot;
     Content-Format: &quot;application/dots+cbor&quot;

     {
       &quot;ietf-dots-signal-channel:signal-config&quot;: {
         &quot;mitigating-config&quot;: {
           &quot;heartbeat-interval&quot;: {
             &quot;current-value&quot;: 30
           },
           &quot;missing-hb-allowed&quot;: {
             &quot;current-value&quot;: 15
           },
           &quot;probing-rate&quot;: {
             &quot;current-value&quot;: 15
           },
           &quot;max-retransmit&quot;: {
             &quot;current-value&quot;: 3
           },
           &quot;ack-timeout&quot;: {
             &quot;current-value-decimal&quot;: &quot;2.00&quot;
           },
           &quot;ack-random-factor&quot;: {
             &quot;current-value-decimal&quot;: &quot;1.50&quot;
           }
         },
         &quot;idle-config&quot;: {
           &quot;heartbeat-interval&quot;: {
             &quot;current-value&quot;: 0
           },
           &quot;max-retransmit&quot;: {
             &quot;current-value&quot;: 3
           },
           &quot;ack-timeout&quot;: {
             &quot;current-value-decimal&quot;: &quot;2.00&quot;
           },
           &quot;ack-random-factor&quot;: {
             &quot;current-value-decimal&quot;: &quot;1.50&quot;
           }
         }
       }
     }

           Figure 23: PUT to Convey the Configuration Parameters

   The DOTS server indicates the result of processing the PUT request
   using CoAP Response Codes:

   *  If the request is missing a mandatory attribute, does not include
      a &#x27;sid&#x27; Uri-Path, or contains one or more invalid or unknown
      parameters, 4.00 (Bad Request) MUST be returned in the response.

   *  If the DOTS server does not find the &#x27;sid&#x27; parameter value
      conveyed in the PUT request in its configuration data and if the
      DOTS server has accepted the configuration parameters, then a
      Response Code 2.01 (Created) MUST be returned in the response.

   *  If the DOTS server finds the &#x27;sid&#x27; parameter value conveyed in the
      PUT request in its configuration data and if the DOTS server has
      accepted the updated configuration parameters, 2.04 (Changed) MUST
      be returned in the response.

   *  If any of the &#x27;heartbeat-interval&#x27;, &#x27;missing-hb-allowed&#x27;,
      &#x27;probing-rate&#x27;, &#x27;max-retransmit&#x27;, &#x27;target-protocol&#x27;, &#x27;ack-
      timeout&#x27;, and &#x27;ack-random-factor&#x27; attribute values are not
      acceptable to the DOTS server, 4.22 (Unprocessable Entity) MUST be
      returned in the response.  Upon receipt of this error code, the
      DOTS client SHOULD retrieve the maximum and minimum attribute
      values acceptable to the DOTS server (Section 4.5.1).

      The DOTS client may retry and send the PUT request with updated
      attribute values acceptable to the DOTS server.

   A DOTS client may issue a GET message with a &#x27;sid&#x27; Uri-Path parameter
   to retrieve the negotiated configuration.  The response does not need
   to include &#x27;sid&#x27; in its message body.

4.5.3.  Configuration Freshness and Notifications

   Max-Age Option (Section 5.10.5 of [RFC7252]) SHOULD be returned by a
   DOTS server to associate a validity time with a configuration it
   sends.  This feature allows the update of the configuration data if a
   change occurs at the DOTS server side.  For example, the new
   configuration may instruct a DOTS client to cease heartbeats or
   reduce heartbeat frequency.

   It is NOT RECOMMENDED to return a Max-Age Option set to 0.

   Returning a Max-Age Option set to 2^(32)-1 is equivalent to
   associating an infinite lifetime with the configuration.

   If a non-zero value of Max-Age Option is received by a DOTS client,
   it MUST issue a GET request with a &#x27;sid&#x27; Uri-Path parameter to
   retrieve the current and acceptable configuration before the expiry
   of the value enclosed in the Max-Age Option.  This request is
   considered by the client and the server to be a means to refresh the
   configuration parameters for the signal channel.  When a DDoS attack
   is active, refresh requests MUST NOT be sent by DOTS clients, and the
   DOTS server MUST NOT terminate the (D)TLS session after the expiry of
   the value returned in Max-Age Option.

   If Max-Age Option is not returned in a response, the DOTS client
   initiates GET requests to refresh the configuration parameters each
   60 seconds (Section 5.10.5 of [RFC7252]).  To prevent such overload,
   it is RECOMMENDED that DOTS servers return a Max-Age Option in GET
   responses.  Considerations related to which value to use and how such
   a value is set are implementation and deployment specific.

   If an Observe Option set to 0 is included in the configuration
   request, the DOTS server sends notifications of any configuration
   change (Section 4.2 of [RFC7641]).

   If a DOTS server detects that a misbehaving DOTS client does not
   contact the DOTS server after the expiry of Max-Age to retrieve the
   signal channel configuration data, it MAY terminate the (D)TLS
   session.  A (D)TLS session is terminated by the receipt of an
   authenticated message that closes the connection (e.g., a fatal alert
   (Section 6 of [RFC8446])).

4.5.4.  Delete DOTS Signal Channel Session Configuration

   A DELETE request is used to delete the installed DOTS signal channel
   session configuration data (Figure 24).

     Header: DELETE (Code=0.04)
     Uri-Path: &quot;.well-known&quot;
     Uri-Path: &quot;dots&quot;
     Uri-Path: &quot;config&quot;
     Uri-Path: &quot;sid=123&quot;

                      Figure 24: Delete Configuration

   The DOTS server resets the DOTS signal channel session configuration
   back to the default values and acknowledges a DOTS client&#x27;s request
   to remove the DOTS signal channel session configuration using 2.02
   (Deleted) Response Code.

   Upon bootstrapping or reboot, a DOTS client MAY send a DELETE request
   to set the configuration parameters to default values.  Such a
   request does not include any &#x27;sid&#x27;.

4.6.  Redirected Signaling

   Redirected DOTS signaling is discussed in detail in Section 3.2.2 of
   [DOTS-ARCH].

   If a DOTS server wants to redirect a DOTS client to an alternative
   DOTS server for a signal session, then the Response Code 5.03
   (Service Unavailable) will be returned in the response to the DOTS
   client.

   The DOTS server can return the error Response Code 5.03 in response
   to a request from the DOTS client or convey the error Response Code
   5.03 in a unidirectional notification response from the DOTS server.

   The DOTS server in the error response conveys the alternate DOTS
   server&#x27;s FQDN, and the alternate DOTS server&#x27;s IP address(es) values
   in the CBOR body (Figure 25).

   {
     &quot;ietf-dots-signal-channel:redirected-signal&quot;: {
       &quot;alt-server&quot;: &quot;string&quot;,
       &quot;alt-server-record&quot;: [
          &quot;string&quot;
       ]
     }
   }

          Figure 25: Redirected Server Error Response Body Schema

   The parameters are described below:

   alt-server:  FQDN of an alternate DOTS server.

      This is a mandatory attribute.

   alt-server-record:  A list of IP addresses of an alternate DOTS
      server.

      This is an optional attribute.

   The DOTS server returns the Time to Live (TTL) of the alternate DOTS
   server in a Max-Age Option.  That is, the time interval that the
   alternate DOTS server may be cached for use by a DOTS client.  A Max-
   Age Option set to 2^(32)-1 is equivalent to receiving an infinite
   TTL.  This value means that the alternate DOTS server is to be used
   until the alternate DOTS server redirects the traffic with another
   5.03 response that conveys an alternate server&#x27;s FQDN.

   A Max-Age Option set to &#x27;0&#x27; may be returned for redirecting
   mitigation requests.  Such a value means that the redirection applies
   only for the mitigation request in progress.  Returning short TTL in
   a Max-Age Option may adversely impact DOTS clients on slow links.
   Returning short values should be avoided under such conditions.

   If the alternate DOTS server TTL has expired, the DOTS client MUST
   use the DOTS server(s) that was provisioned using means discussed in
   Section 4.1.  This fallback mechanism is triggered immediately upon
   expiry of the TTL, except when a DDoS attack is active.

   Requests issued by misbehaving DOTS clients that do not honor the TTL
   conveyed in the Max-Age Option or react to explicit redirect messages
   can be rejected by DOTS servers.

   Figure 26 shows a 5.03 response example to convey the DOTS alternate
   server &#x27;alt-server.example&#x27; together with its IP addresses
   2001:db8:6401::1 and 2001:db8:6401::2.

   {
     &quot;ietf-dots-signal-channel:redirected-signal&quot;: {
       &quot;alt-server&quot;: &quot;alt-server.example&quot;,
       &quot;alt-server-record&quot;: [
          &quot;2001:db8:6401::1&quot;,
          &quot;2001:db8:6401::2&quot;
       ]
     }
   }

        Figure 26: Example of Redirected Server Error Response Body

   When the DOTS client receives a 5.03 response with an alternate
   server included, it considers the current request to have failed, but
   it SHOULD try resending the request to the alternate DOTS server.
   During a DDoS attack, the DNS server may be the target of another
   DDoS attack, the alternate DOTS server&#x27;s IP addresses conveyed in the
   5.03 response help the DOTS client skip the DNS lookup of the
   alternate DOTS server, at the cost of trusting the first DOTS server
   to provide accurate information.  The DOTS client can then try to
   establish a UDP or a TCP session with the alternate DOTS server.  The
   DOTS client MAY implement a method to construct IPv4-embedded IPv6
   addresses [RFC6052]; this is required to handle the scenario where an
   IPv6-only DOTS client communicates with an IPv4-only alternate DOTS
   server.

   If the DOTS client has been redirected to a DOTS server with which it
   has already communicated within the last five (5) minutes, it MUST
   ignore the redirection and try to contact other DOTS servers listed
   in the local configuration or discovered using dynamic means such as
   DHCP or SRV procedures [DOTS-SERVER-DISC].  It is RECOMMENDED that
   DOTS clients support the means to alert administrators about redirect
   loops.

4.7.  Heartbeat Mechanism

   To provide an indication of signal health and to distinguish an
   &#x27;idle&#x27; signal channel from a &#x27;disconnected&#x27; or &#x27;defunct&#x27; session, the
   DOTS agent sends a heartbeat over the signal channel to maintain its
   half of the channel (also, aligned with the &quot;consents&quot; recommendation
   in Section 6 of [RFC8085]).  The DOTS agent similarly expects a
   heartbeat from its peer DOTS agent, and it may consider a session
   terminated in the prolonged absence of a peer agent heartbeat.
   Concretely, while the communication between the DOTS agents is
   otherwise quiescent, the DOTS client will probe the DOTS server to
   ensure it has maintained cryptographic state and vice versa.  Such
   probes can also keep the bindings of firewalls and/or stateful
   translators alive.  This probing reduces the frequency of
   establishing a new handshake when a DOTS signal needs to be conveyed
   to the DOTS server.

      |  Implementation Note: Given that CoAP roles can be multiplexed
      |  over the same session as discussed in [RFC7252] and are already
      |  supported by CoAP implementations, both the DOTS client and
      |  server can send DOTS heartbeat requests.

   The DOTS heartbeat mechanism uses Non-confirmable PUT requests
   (Figure 27) with an expected 2.04 (Changed) Response Code
   (Figure 28).  This procedure occurs between a DOTS agent and its
   immediate peer DOTS agent.  As such, this PUT request MUST NOT be
   relayed by a DOTS gateway.  The PUT request used for DOTS heartbeat
   MUST NOT have a &#x27;cuid&#x27;, &#x27;cdid&#x27;, or &#x27;mid&#x27; Uri-Path.

        Header: PUT (Code=0.03)
        Uri-Path: &quot;.well-known&quot;
        Uri-Path: &quot;dots&quot;
        Uri-Path: &quot;hb&quot;
        Content-Format: &quot;application/dots+cbor&quot;

        {
          &quot;ietf-dots-signal-channel:heartbeat&quot;: {
             &quot;peer-hb-status&quot;: true
           }
        }

           Figure 27: PUT to Check Peer DOTS Agent Is Responding

   The mandatory &#x27;peer-hb-status&#x27; attribute is set to &#x27;true&#x27; (or
   &#x27;false&#x27;) to indicate that a DOTS agent is (or is not) receiving
   heartbeat messages from its peer in the last (2 * &#x27;heartbeat-
   interval&#x27;) period.  Such information can be used by a peer DOTS agent
   to detect or confirm connectivity issues and react accordingly.  For
   example, if a DOTS client receives a 2.04 response for its heartbeat
   messages but no server-initiated heartbeat messages, the DOTS client
   sets &#x27;peer-hb-status&#x27; to &#x27;false&#x27;.  The DOTS server then will need to
   try another strategy for sending the heartbeats (e.g., adjust the
   heartbeat interval or send a server-initiated heartbeat immediately
   after receiving a client-initiated heartbeat message).

        Header: (Code=2.04)

              Figure 28: Response to a DOTS Heartbeat Request

   DOTS servers MAY trigger their heartbeat requests immediately after
   receiving heartbeat probes from peer DOTS clients.  As a reminder, it
   is the responsibility of DOTS clients to ensure that on-path
   translators/firewalls are maintaining a binding so that the same
   external IP address and/or port number is retained for the DOTS
   signal channel session.

   Under normal traffic conditions (i.e., no attack is ongoing), if a
   DOTS agent does not receive any response from the peer DOTS agent for
   &#x27;missing-hb-allowed&#x27; number of consecutive heartbeat messages, it
   concludes that the DOTS signal channel session is disconnected.  The
   DOTS client MUST then try to reestablish the DOTS signal channel
   session, preferably by resuming the (D)TLS session.

      |  Note: If a new DOTS signal channel session cannot be
      |  established, the DOTS client SHOULD NOT retry to establish the
      |  DOTS signal channel session more frequently than every 300
      |  seconds (5 minutes) and MUST NOT retry more frequently than
      |  every 60 seconds (1 minute).  It is recommended that DOTS
      |  clients support the means to alert administrators about the
      |  failure to establish a (D)TLS session.

   In case of a massive DDoS attack that saturates the incoming link(s)
   to the DOTS client, all traffic from the DOTS server to the DOTS
   client will likely be dropped, although the DOTS server receives
   heartbeat requests in addition to DOTS messages sent by the DOTS
   client.  In this scenario, DOTS clients MUST behave differently to
   handle message transmission and DOTS signal channel session
   liveliness during link saturation:

      The DOTS client MUST NOT consider the DOTS signal channel session
      terminated even after a maximum &#x27;missing-hb-allowed&#x27; threshold is
      reached.  The DOTS client SHOULD keep on using the current DOTS
      signal channel session to send heartbeat requests over it, so that
      the DOTS server knows the DOTS client has not disconnected the
      DOTS signal channel session.

      After the maximum &#x27;missing-hb-allowed&#x27; threshold is reached, the
      DOTS client SHOULD try to establish a new DOTS signal channel
      session.  The DOTS client SHOULD send mitigation requests over the
      current DOTS signal channel session and, in parallel, send the
      mitigation requests over the new DOTS signal channel session.
      This may be handled, for example, by resumption of the (D)TLS
      session or using 0-RTT mode in DTLS 1.3 to piggyback the
      mitigation request in the ClientHello message.

      As soon as the link is no longer saturated, if traffic from the
      DOTS server reaches the DOTS client over the current DOTS signal
      channel session, the DOTS client can stop the new DOTS signal
      channel session attempt or if a new DOTS signal channel session is
      successful then disconnect the current DOTS signal channel
      session.

   If the DOTS server receives traffic from the peer DOTS client (e.g.,
   peer DOTS client-initiated heartbeats) but the maximum &#x27;missing-hb-
   allowed&#x27; threshold is reached, the DOTS server MUST NOT consider the
   DOTS signal channel session disconnected.  The DOTS server MUST keep
   on using the current DOTS signal channel session so that the DOTS
   client can send mitigation requests over the current DOTS signal
   channel session.  In this case, the DOTS server can identify that the
   DOTS client is under attack and that the inbound link to the DOTS
   client (domain) is saturated.  Furthermore, if the DOTS server does
   not receive a mitigation request from the DOTS client, it implies
   that the DOTS client has not detected the attack or, if an attack
   mitigation is in progress, it implies that the applied DDoS
   mitigation actions are not yet effectively handling the DDoS attack
   volume.

   If the DOTS server does not receive any traffic from the peer DOTS
   client during the time span required to exhaust the maximum &#x27;missing-
   hb-allowed&#x27; threshold, the DOTS server concludes the session is
   disconnected.  The DOTS server can then trigger preconfigured
   mitigation requests for this DOTS client (if any).

   In DOTS over TCP, the sender of a DOTS heartbeat message has to allow
   up to &#x27;heartbeat-interval&#x27; seconds when waiting for a heartbeat
   reply.  When a failure is detected by a DOTS client, it proceeds with
   the session recovery, following the same approach as the one used for
   unreliable transports.

5.  DOTS Signal Channel YANG Modules

   This document defines a YANG module [RFC7950] for DOTS mitigation
   scope, DOTS signal channel session configuration data, DOTS
   redirection signaling, and DOTS heartbeats.

   This YANG module (ietf-dots-signal-channel) defines the DOTS client
   interaction with the DOTS server as seen by the DOTS client.  A DOTS
   server is allowed to update the non-configurable &#x27;ro&#x27; entities in the
   responses.  This YANG module is not intended to be used via NETCONF/
   RESTCONF for DOTS server management purposes; such a module is out of
   the scope of this document.  It serves only to provide a data model
   and encoding, but not a management data model.

   A companion YANG module is defined to include a collection of types
   defined by IANA: &quot;iana-dots-signal-channel&quot; (Section 5.2).

5.1.  Tree Structure

   This document defines the YANG module &quot;ietf-dots-signal-channel&quot;
   (Section 5.3), which has the following tree structure.  A DOTS signal
   message can be a mitigation, a configuration, a redirect, or a
   heartbeat message.

   module: ietf-dots-signal-channel
     +--rw dots-signal
        +--rw (message-type)?
           +--:(mitigation-scope)
           |  +--rw scope* [cuid mid]
           |     +--rw cdid?                   string
           |     +--rw cuid                    string
           |     +--rw mid                     uint32
           |     +--rw target-prefix*          inet:ip-prefix
           |     +--rw target-port-range*      [lower-port]
           |     |  +--rw lower-port    inet:port-number
           |     |  +--rw upper-port?   inet:port-number
           |     +--rw target-protocol*        uint8
           |     +--rw target-fqdn*            inet:domain-name
           |     +--rw target-uri*             inet:uri
           |     +--rw alias-name*             string
           |     +--rw lifetime?               int32
           |     +--rw trigger-mitigation?     boolean
           |     +--ro mitigation-start?       uint64
           |     +--ro status?                 iana-signal:status
           |     +--ro conflict-information
           |     |  +--ro conflict-status?   iana-signal:conflict-status
           |     |  +--ro conflict-cause?    iana-signal:conflict-cause
           |     |  +--ro retry-timer?       uint32
           |     |  +--ro conflict-scope
           |     |     +--ro target-prefix*       inet:ip-prefix
           |     |     +--ro target-port-range*   [lower-port]
           |     |     |  +--ro lower-port      inet:port-number
           |     |     |  +--ro upper-port?     inet:port-number
           |     |     +--ro target-protocol*     uint8
           |     |     +--ro target-fqdn*         inet:domain-name
           |     |     +--ro target-uri*          inet:uri
           |     |     +--ro alias-name*          string
           |     |     +--ro acl-list* [acl-name]
           |     |     |  +--ro acl-name
           |     |     |  |   -&gt; /ietf-data:dots-data/dots-client/acls/
           |     |     |  |      acl/name
           |     |     |  +--ro acl-type?
           |     |     |      -&gt; /ietf-data:dots-data/dots-client/acls/
           |     |     |         acl/type
           |     |     +--ro mid?                 -&gt; ../../../mid
           |     +--ro bytes-dropped?          yang:zero-based-counter64
           |     +--ro bps-dropped?            yang:gauge64
           |     +--ro pkts-dropped?           yang:zero-based-counter64
           |     +--ro pps-dropped?            yang:gauge64
           |     +--rw attack-status?          iana-signal:attack-status
           +--:(signal-config)
           |  +--rw sid                   uint32
           |  +--rw mitigating-config
           |  |  +--rw heartbeat-interval
           |  |  |  +--ro max-value?       uint16
           |  |  |  +--ro min-value?       uint16
           |  |  |  +--rw current-value?   uint16
           |  |  +--rw missing-hb-allowed
           |  |  |  +--ro max-value?       uint16
           |  |  |  +--ro min-value?       uint16
           |  |  |  +--rw current-value?   uint16
           |  |  +--rw probing-rate
           |  |  |  +--ro max-value?       uint16
           |  |  |  +--ro min-value?       uint16
           |  |  |  +--rw current-value?   uint16
           |  |  +--rw max-retransmit
           |  |  |  +--ro max-value?       uint16
           |  |  |  +--ro min-value?       uint16
           |  |  |  +--rw current-value?   uint16
           |  |  +--rw ack-timeout
           |  |  |  +--ro max-value-decimal?       decimal64
           |  |  |  +--ro min-value-decimal?       decimal64
           |  |  |  +--rw current-value-decimal?   decimal64
           |  |  +--rw ack-random-factor
           |  |     +--ro max-value-decimal?       decimal64
           |  |     +--ro min-value-decimal?       decimal64
           |  |     +--rw current-value-decimal?   decimal64
           |  +--rw idle-config
           |     +--rw heartbeat-interval
           |     |  +--ro max-value?       uint16
           |     |  +--ro min-value?       uint16
           |     |  +--rw current-value?   uint16
           |     +--rw missing-hb-allowed
           |     |  +--ro max-value?       uint16
           |     |  +--ro min-value?       uint16
           |     |  +--rw current-value?   uint16
           |     +--rw probing-rate
           |     |  +--ro max-value?       uint16
           |     |  +--ro min-value?       uint16
           |     |  +--rw current-value?   uint16
           |     +--rw max-retransmit
           |     |  +--ro max-value?       uint16
           |     |  +--ro min-value?       uint16
           |     |  +--rw current-value?   uint16
           |     +--rw ack-timeout
           |     |  +--ro max-value-decimal?       decimal64
           |     |  +--ro min-value-decimal?       decimal64
           |     |  +--rw current-value-decimal?   decimal64
           |     +--rw ack-random-factor
           |        +--ro max-value-decimal?       decimal64
           |        +--ro min-value-decimal?       decimal64
           |        +--rw current-value-decimal?   decimal64
           +--:(redirected-signal)
           |  +--ro alt-server            string
           |  +--ro alt-server-record*    inet:ip-address
           +--:(heartbeat)
              +--rw peer-hb-status              boolean

5.2.  IANA DOTS Signal Channel YANG Module

   &lt;CODE BEGINS&gt; file &quot;iana-dots-signal-channel@2020-05-28.yang&quot;
   module iana-dots-signal-channel {
     yang-version 1.1;
     namespace &quot;urn:ietf:params:xml:ns:yang:iana-dots-signal-channel&quot;;
     prefix iana-signal;

     organization
       &quot;IANA&quot;;
     contact
       &quot;Internet Assigned Numbers Authority

        Postal: ICANN
             12025 Waterfront Drive, Suite 300
             Los Angeles, CA  90094-2536
             United States of America
        Tel:    +1 310 301 5800
        &lt;mailto:iana@iana.org&gt;&quot;;
     description
       &quot;This module contains a collection of YANG data types defined
        by IANA and used for DOTS signal channel protocol.

        Copyright (c) 2020 IETF Trust and the persons identified as
        authors of the code.  All rights reserved.

        Redistribution and use in source and binary forms, with or
        without modification, is permitted pursuant to, and subject
        to the license terms contained in, the Simplified BSD License
        set forth in Section 4.c of the IETF Trust&#x27;s Legal Provisions
        Relating to IETF Documents
        (http://trustee.ietf.org/license-info).

        This version of this YANG module is part of RFC 8782; see
        the RFC itself for full legal notices.&quot;;

     revision 2020-05-28 {
       description
         &quot;Initial revision.&quot;;
       reference
         &quot;RFC 8782: Distributed Denial-of-Service Open Threat
                    Signaling (DOTS) Signal Channel Specification&quot;;
     }

     typedef status {
       type enumeration {
         enum attack-mitigation-in-progress {
           value 1;
           description
             &quot;Attack mitigation setup is in progress (e.g., changing
              the network path to reroute the inbound traffic
              to DOTS mitigator).&quot;;
         }
         enum attack-successfully-mitigated {
           value 2;
           description
             &quot;Attack is being successfully mitigated (e.g., traffic
              is redirected to a DDoS mitigator and attack
              traffic is dropped or blackholed).&quot;;
         }
         enum attack-stopped {
           value 3;
           description
             &quot;Attack has stopped and the DOTS client can
              withdraw the mitigation request.&quot;;
         }
         enum attack-exceeded-capability {
           value 4;
           description
             &quot;Attack has exceeded the mitigation provider
              capability.&quot;;
         }
         enum dots-client-withdrawn-mitigation {
           value 5;
           description
             &quot;DOTS client has withdrawn the mitigation
              request and the mitigation is active but
              terminating.&quot;;
         }
         enum attack-mitigation-terminated {
           value 6;
           description
             &quot;Attack mitigation is now terminated.&quot;;
         }
         enum attack-mitigation-withdrawn {
           value 7;
           description
             &quot;Attack mitigation is withdrawn.&quot;;
         }
         enum attack-mitigation-signal-loss {
           value 8;
           description
             &quot;Attack mitigation will be triggered
              for the mitigation request only when
              the DOTS signal channel session is lost.&quot;;
         }
       }
       description
         &quot;Enumeration for status reported by the DOTS server.&quot;;
     }

     typedef conflict-status {
       type enumeration {
         enum request-inactive-other-active {
           value 1;
           description
             &quot;DOTS Server has detected conflicting mitigation
              requests from different DOTS clients.
              This mitigation request is currently inactive
              until the conflicts are resolved. Another
              mitigation request is active.&quot;;
         }
         enum request-active {
           value 2;
           description
             &quot;DOTS Server has detected conflicting mitigation
              requests from different DOTS clients.
              This mitigation request is currently active.&quot;;
         }
         enum all-requests-inactive {
           value 3;
           description
             &quot;DOTS Server has detected conflicting mitigation
              requests from different DOTS clients.  All
              conflicting mitigation requests are inactive.&quot;;
         }
       }
       description
         &quot;Enumeration for conflict status.&quot;;
     }

     typedef conflict-cause {
       type enumeration {
         enum overlapping-targets {
           value 1;
           description
             &quot;Overlapping targets. conflict-scope provides
              more details about the exact conflict.&quot;;
         }
         enum conflict-with-acceptlist {
           value 2;
           description
             &quot;Conflicts with an existing accept-list.

              This code is returned when the DDoS mitigation
              detects that some of the source addresses/prefixes
              listed in the accept-list ACLs are actually
              attacking the target.&quot;;
         }
         enum cuid-collision {
           value 3;
           description
             &quot;Conflicts with the cuid used by another
              DOTS client.&quot;;
         }
       }
       description
         &quot;Enumeration for conflict causes.&quot;;
     }

     typedef attack-status {
       type enumeration {
         enum under-attack {
           value 1;
           description
             &quot;The DOTS client determines that it is still under
              attack.&quot;;
         }
         enum attack-successfully-mitigated {
           value 2;
           description
             &quot;The DOTS client determines that the attack is
              successfully mitigated.&quot;;
         }
       }
       description
         &quot;Enumeration for attack status codes.&quot;;
     }
   }
   &lt;CODE ENDS&gt;

5.3.  IETF DOTS Signal Channel YANG Module

   This module uses the common YANG types defined in [RFC6991] and types
   defined in [RFC8783].

   &lt;CODE BEGINS&gt; file &quot;ietf-dots-signal-channel@2020-05-28.yang&quot;
   module ietf-dots-signal-channel {
     yang-version 1.1;
     namespace &quot;urn:ietf:params:xml:ns:yang:ietf-dots-signal-channel&quot;;
     prefix signal;

     import ietf-inet-types {
       prefix inet;
       reference
         &quot;Section 4 of RFC 6991&quot;;
     }
     import ietf-yang-types {
       prefix yang;
       reference
         &quot;Section 3 of RFC 6991&quot;;
     }
     import ietf-dots-data-channel {
       prefix ietf-data;
       reference
         &quot;RFC 8783: Distributed Denial-of-Service Open Threat Signaling
                    (DOTS) Data Channel Specification&quot;;
     }
     import iana-dots-signal-channel {
       prefix iana-signal;
     }

     organization
       &quot;IETF DDoS Open Threat Signaling (DOTS) Working Group&quot;;
     contact
       &quot;WG Web:   &lt;https://datatracker.ietf.org/wg/dots/&gt;
        WG List:  &lt;mailto:dots@ietf.org&gt;

        Editor:  Konda, Tirumaleswar Reddy.K
                 &lt;mailto:TirumaleswarReddy_Konda@McAfee.com&gt;

        Editor:  Mohamed Boucadair
                 &lt;mailto:mohamed.boucadair@orange.com&gt;

        Author:  Prashanth Patil
                 &lt;mailto:praspati@cisco.com&gt;

        Author:  Andrew Mortensen
                 &lt;mailto:amortensen@arbor.net&gt;

        Author:  Nik Teague
                 &lt;mailto:nteague@ironmountain.co.uk&gt;&quot;;
     description
       &quot;This module contains YANG definition for the signaling
        messages exchanged between a DOTS client and a DOTS server.

        Copyright (c) 2020 IETF Trust and the persons identified as
        authors of the code.  All rights reserved.

        Redistribution and use in source and binary forms, with or
        without modification, is permitted pursuant to, and subject
        to the license terms contained in, the Simplified BSD License
        set forth in Section 4.c of the IETF Trust&#x27;s Legal Provisions
        Relating to IETF Documents
        (http://trustee.ietf.org/license-info).

        This version of this YANG module is part of RFC 8782; see
        the RFC itself for full legal notices.&quot;;

     revision 2020-05-28 {
       description
         &quot;Initial revision.&quot;;
       reference
         &quot;RFC 8782: Distributed Denial-of-Service Open Threat
                    Signaling (DOTS) Signal Channel Specification&quot;;
     }

     /*
      * Groupings
      */

     grouping mitigation-scope {
       description
         &quot;Specifies the scope of the mitigation request.&quot;;
       list scope {
         key &quot;cuid mid&quot;;
         description
           &quot;The scope of the request.&quot;;
         leaf cdid {
           type string;
           description
             &quot;The cdid should be included by a server-domain
              DOTS gateway to propagate the client domain
              identification information from the
              gateway&#x27;s client-facing side to the gateway&#x27;s
              server-facing side, and from the gateway&#x27;s
              server-facing side to the DOTS server.

              It may be used by the final DOTS server
              for policy enforcement purposes.&quot;;
         }
         leaf cuid {
           type string;
           description
             &quot;A unique identifier that is
              generated by a DOTS client to prevent
              request collisions.  It is expected that the
              cuid will remain consistent throughout the
              lifetime of the DOTS client.&quot;;
         }
         leaf mid {
           type uint32;
           description
             &quot;Mitigation request identifier.

              This identifier must be unique for each mitigation
              request bound to the DOTS client.&quot;;
         }
         uses ietf-data:target;
         leaf-list alias-name {
           type string;
           description
             &quot;An alias name that points to a resource.&quot;;
         }
         leaf lifetime {
           type int32;
           units &quot;seconds&quot;;
           default &quot;3600&quot;;
           description
             &quot;Indicates the lifetime of the mitigation request.

              A lifetime of &#x27;0&#x27; in a mitigation request is an
              invalid value.

              A lifetime of negative one (-1) indicates indefinite
              lifetime for the mitigation request.&quot;;
         }
         leaf trigger-mitigation {
           type boolean;
           default &quot;true&quot;;
           description
             &quot;If set to &#x27;false&#x27;, DDoS mitigation will not be
              triggered unless the DOTS signal channel
              session is lost.&quot;;
         }
         leaf mitigation-start {
           type uint64;
           config false;
           description
             &quot;Mitigation start time is represented in seconds
              relative to 1970-01-01T00:00:00Z in UTC time.&quot;;
         }
         leaf status {
           type iana-signal:status;
           config false;
           description
             &quot;Indicates the status of a mitigation request.
              It must be included in responses only.&quot;;
         }
         container conflict-information {
           config false;
           description
             &quot;Indicates that a conflict is detected.
              Must only be used for responses.&quot;;
           leaf conflict-status {
             type iana-signal:conflict-status;
             description
               &quot;Indicates the conflict status.&quot;;
           }
           leaf conflict-cause {
             type iana-signal:conflict-cause;
             description
               &quot;Indicates the cause of the conflict.&quot;;
           }
           leaf retry-timer {
             type uint32;
             units &quot;seconds&quot;;
             description
               &quot;The DOTS client must not resend the
                same request that has a conflict before the expiry of
                this timer.&quot;;
           }
           container conflict-scope {
             description
               &quot;Provides more information about the conflict scope.&quot;;
             uses ietf-data:target {
               when &quot;/dots-signal/scope/conflict-information/&quot;
                  + &quot;conflict-cause = &#x27;overlapping-targets&#x27;&quot;;
             }
             leaf-list alias-name {
               when &quot;../../conflict-cause = &#x27;overlapping-targets&#x27;&quot;;
               type string;
               description
                 &quot;Conflicting alias-name.&quot;;
             }
             list acl-list {
               when &quot;../../conflict-cause = &#x27;conflict-with-acceptlist&#x27;&quot;;
               key &quot;acl-name&quot;;
               description
                 &quot;List of conflicting ACLs as defined in the DOTS data
                  channel.  These ACLs are uniquely defined by
                  cuid and acl-name.&quot;;
               leaf acl-name {
                 type leafref {
                   path &quot;/ietf-data:dots-data/ietf-data:dots-client/&quot;
                      + &quot;ietf-data:acls/ietf-data:acl/ietf-data:name&quot;;
                 }
                 description
                   &quot;Reference to the conflicting ACL name bound to
                    a DOTS client.&quot;;
               }
               leaf acl-type {
                 type leafref {
                   path &quot;/ietf-data:dots-data/ietf-data:dots-client/&quot;
                      + &quot;ietf-data:acls/ietf-data:acl/ietf-data:type&quot;;
                 }
                 description
                   &quot;Reference to the conflicting ACL type bound to
                    a DOTS client.&quot;;
               }
             }
             leaf mid {
               when &quot;../../conflict-cause = &#x27;overlapping-targets&#x27;&quot;;
               type leafref {
                 path &quot;../../../mid&quot;;
               }
               description
                 &quot;Reference to the conflicting &#x27;mid&#x27; bound to
                  the same DOTS client.&quot;;
             }
           }
         }
         leaf bytes-dropped {
           type yang:zero-based-counter64;
           units &quot;bytes&quot;;
           config false;
           description
             &quot;The total dropped byte count for the mitigation
              request since the attack mitigation was triggered.
              The count wraps around when it reaches the maximum value
              of counter64 for dropped bytes.&quot;;
         }
         leaf bps-dropped {
           type yang:gauge64;
           config false;
           description
             &quot;The average number of dropped bits per second for
              the mitigation request since the attack
              mitigation was triggered.  This should be over
              five-minute intervals (that is, measuring bytes
              into five-minute buckets and then averaging these
              buckets over the time since the mitigation was
              triggered).&quot;;
         }
         leaf pkts-dropped {
           type yang:zero-based-counter64;
           config false;
           description
             &quot;The total number of dropped packet count for the
              mitigation request since the attack mitigation was
              triggered.  The count wraps around when it reaches
              the maximum value of counter64 for dropped packets.&quot;;
         }
         leaf pps-dropped {
           type yang:gauge64;
           config false;
           description
             &quot;The average number of dropped packets per second
              for the mitigation request since the attack
              mitigation was triggered.  This should be over
              five-minute intervals (that is, measuring packets
              into five-minute buckets and then averaging these
              buckets over the time since the mitigation was
              triggered).&quot;;
         }
         leaf attack-status {
           type iana-signal:attack-status;
           description
             &quot;Indicates the status of an attack as seen by the
              DOTS client.&quot;;
         }
       }
     }

     grouping config-parameters {
       description
         &quot;Subset of DOTS signal channel session configuration.&quot;;
       container heartbeat-interval {
         description
           &quot;DOTS agents regularly send heartbeats to each other
            after mutual authentication is successfully
            completed in order to keep the DOTS signal channel
            open.&quot;;
         leaf max-value {
           type uint16;
           units &quot;seconds&quot;;
           config false;
           description
             &quot;Maximum acceptable heartbeat-interval value.&quot;;
         }
         leaf min-value {
           type uint16;
           units &quot;seconds&quot;;
           config false;
           description
             &quot;Minimum acceptable heartbeat-interval value.&quot;;
         }
         leaf current-value {
           type uint16;
           units &quot;seconds&quot;;
           default &quot;30&quot;;
           description
             &quot;Current heartbeat-interval value.

              &#x27;0&#x27; means that heartbeat mechanism is deactivated.&quot;;
         }
       }
       container missing-hb-allowed {
         description
           &quot;Maximum number of missing heartbeats allowed.&quot;;
         leaf max-value {
           type uint16;
           config false;
           description
             &quot;Maximum acceptable missing-hb-allowed value.&quot;;
         }
         leaf min-value {
           type uint16;
           config false;
           description
             &quot;Minimum acceptable missing-hb-allowed value.&quot;;
         }
         leaf current-value {
           type uint16;
           default &quot;15&quot;;
           description
             &quot;Current missing-hb-allowed value.&quot;;
         }
       }
       container probing-rate {
         description
           &quot;The limit for sending Non-confirmable messages with
            no response.&quot;;
         leaf max-value {
           type uint16;
           units &quot;byte/second&quot;;
           config false;
           description
             &quot;Maximum acceptable probing-rate value.&quot;;
         }
         leaf min-value {
           type uint16;
           units &quot;byte/second&quot;;
           config false;
           description
             &quot;Minimum acceptable probing-rate value.&quot;;
         }
         leaf current-value {
           type uint16;
           units &quot;byte/second&quot;;
           default &quot;5&quot;;
           description
             &quot;Current probing-rate value.&quot;;
         }
       }
       container max-retransmit {
         description
           &quot;Maximum number of retransmissions of a Confirmable
            message.&quot;;
         leaf max-value {
           type uint16;
           config false;
           description
             &quot;Maximum acceptable max-retransmit value.&quot;;
         }
         leaf min-value {
           type uint16;
           config false;
           description
             &quot;Minimum acceptable max-retransmit value.&quot;;
         }
         leaf current-value {
           type uint16;
           default &quot;3&quot;;
           description
             &quot;Current max-retransmit value.&quot;;
         }
       }
       container ack-timeout {
         description
           &quot;Initial retransmission timeout value.&quot;;
         leaf max-value-decimal {
           type decimal64 {
             fraction-digits 2;
           }
           units &quot;seconds&quot;;
           config false;
           description
             &quot;Maximum ack-timeout value.&quot;;
         }
         leaf min-value-decimal {
           type decimal64 {
             fraction-digits 2;
           }
           units &quot;seconds&quot;;
           config false;
           description
             &quot;Minimum ack-timeout value.&quot;;
         }
         leaf current-value-decimal {
           type decimal64 {
             fraction-digits 2;
           }
           units &quot;seconds&quot;;
           default &quot;2&quot;;
           description
             &quot;Current ack-timeout value.&quot;;
         }
       }
       container ack-random-factor {
         description
           &quot;Random factor used to influence the timing of
            retransmissions.&quot;;
         leaf max-value-decimal {
           type decimal64 {
             fraction-digits 2;
           }
           config false;
           description
             &quot;Maximum acceptable ack-random-factor value.&quot;;
         }
         leaf min-value-decimal {
           type decimal64 {
             fraction-digits 2;
           }
           config false;
           description
             &quot;Minimum acceptable ack-random-factor value.&quot;;
         }
         leaf current-value-decimal {
           type decimal64 {
             fraction-digits 2;
           }
           default &quot;1.5&quot;;
           description
             &quot;Current ack-random-factor value.&quot;;
         }
       }
     }

     grouping signal-config {
       description
         &quot;DOTS signal channel session configuration.&quot;;
       leaf sid {
         type uint32;
         mandatory true;
         description
           &quot;An identifier for the DOTS signal channel
            session configuration data.&quot;;
       }
       container mitigating-config {
         description
           &quot;Configuration parameters to use when a mitigation
            is active.&quot;;
         uses config-parameters;
       }
       container idle-config {
         description
           &quot;Configuration parameters to use when no mitigation
            is active.&quot;;
         uses config-parameters;
       }
     }

     grouping redirected-signal {
       description
         &quot;Grouping for the redirected signaling.&quot;;
       leaf alt-server {
         type string;
         config false;
         mandatory true;
         description
           &quot;FQDN of an alternate server.&quot;;
       }
       leaf-list alt-server-record {
         type inet:ip-address;
         config false;
         description
           &quot;List of records for the alternate server.&quot;;
       }
     }

     /*
      * Main Container for DOTS Signal Channel
      */

     container dots-signal {
       description
         &quot;Main container for DOTS signal message.

          A DOTS signal message can be a mitigation, a configuration,
          or a redirected signal message.&quot;;
       choice message-type {
         description
           &quot;Can be a mitigation, a configuration, or a redirect
            message.&quot;;
         case mitigation-scope {
           description
             &quot;Mitigation scope of a mitigation message.&quot;;
           uses mitigation-scope;
         }
         case signal-config {
           description
             &quot;Configuration message.&quot;;
           uses signal-config;
         }
         case redirected-signal {
           description
             &quot;Redirected signaling.&quot;;
           uses redirected-signal;
         }
         case heartbeat {
           description
             &quot;DOTS heartbeats.&quot;;
           leaf peer-hb-status {
             type boolean;
             mandatory true;
             description
               &quot;Indicates whether a DOTS agent receives heartbeats
                from its peer.  The value is set to &#x27;true&#x27; if the
                DOTS agent is receiving heartbeat messages
                from its peer.&quot;;
           }
         }
       }
     }
   }
   &lt;CODE ENDS&gt;

6.  YANG/JSON Mapping Parameters to CBOR

   All parameters in the payload of the DOTS signal channel MUST be
   mapped to CBOR types as shown in Table 5 and are assigned an integer
   key to save space.

      Note: Implementers must check that the mapping output provided by
      their YANG-to-CBOR encoding schemes is aligned with the content of
      Table 5.  For example, some CBOR and JSON types for enumerations
      and the 64-bit quantities can differ depending on the encoder
      used.

   The CBOR key values are divided into two types: comprehension-
   required and comprehension-optional.  DOTS agents can safely ignore
   comprehension-optional values they don&#x27;t understand, but they cannot
   successfully process a request if it contains comprehension-required
   values that are not understood.  The 4.00 response SHOULD include a
   diagnostic payload describing the unknown comprehension-required CBOR
   key values.  The initial set of CBOR key values defined in this
   specification are of type comprehension-required.

   +---------------------+--------------+------+-------------+--------+
   | Parameter Name      | YANG Type    | CBOR | CBOR Major  | JSON   |
   |                     |              | Key  | Type &amp;      | Type   |
   |                     |              |      | Information |        |
   +=====================+==============+======+=============+========+
   | ietf-dots-signal-   | container    | 1    | 5 map       | Object |
   | channel:mitigation- |              |      |             |        |
   | scope               |              |      |             |        |
   +---------------------+--------------+------+-------------+--------+
   | scope               | list         | 2    | 4 array     | Array  |
   +---------------------+--------------+------+-------------+--------+
   | cdid                | string       | 3    | 3 text      | String |
   |                     |              |      | string      |        |
   +---------------------+--------------+------+-------------+--------+
   | cuid                | string       | 4    | 3 text      | String |
   |                     |              |      | string      |        |
   +---------------------+--------------+------+-------------+--------+
   | mid                 | uint32       | 5    | 0 unsigned  | Number |
   +---------------------+--------------+------+-------------+--------+
   | target-prefix       | leaf-list    | 6    | 4 array     | Array  |
   |                     +--------------+------+-------------+--------+
   |                     | inet:ip-     |      | 3 text      | String |
   |                     | prefix       |      | string      |        |
   +---------------------+--------------+------+-------------+--------+
   | target-port-range   | list         | 7    | 4 array     | Array  |
   +---------------------+--------------+------+-------------+--------+
   | lower-port          | inet:port-   | 8    | 0 unsigned  | Number |
   |                     | number       |      |             |        |
   +---------------------+--------------+------+-------------+--------+
   | upper-port          | inet:port-   | 9    | 0 unsigned  | Number |
   |                     | number       |      |             |        |
   +---------------------+--------------+------+-------------+--------+
   | target-protocol     | leaf-list    | 10   | 4 array     | Array  |
   |                     +--------------+------+-------------+--------+
   |                     | uint8        |      | 0 unsigned  | Number |
   +---------------------+--------------+------+-------------+--------+
   | target-fqdn         | leaf-list    | 11   | 4 array     | Array  |
   |                     +--------------+------+-------------+--------+
   |                     | inet:domain- |      | 3 text      | String |
   |                     | name         |      | string      |        |
   +---------------------+--------------+------+-------------+--------+
   | target-uri          | leaf-list    | 12   | 4 array     | Array  |
   |                     +--------------+------+-------------+--------+
   |                     | inet:uri     |      | 3 text      | String |
   |                     |              |      | string      |        |
   +---------------------+--------------+------+-------------+--------+
   | alias-name          | leaf-list    | 13   | 4 array     | Array  |
   |                     +--------------+------+-------------+--------+
   |                     | string       |      | 3 text      | String |
   |                     |              |      | string      |        |
   +---------------------+--------------+------+-------------+--------+
   | lifetime            | int32        | 14   | 0 unsigned  | Number |
   |                     |              |      +-------------+--------+
   |                     |              |      | 1 negative  | Number |
   +---------------------+--------------+------+-------------+--------+
   | mitigation-start    | uint64       | 15   | 0 unsigned  | String |
   +---------------------+--------------+------+-------------+--------+
   | status              | enumeration  | 16   | 0 unsigned  | String |
   +---------------------+--------------+------+-------------+--------+
   | conflict-           | container    | 17   | 5 map       | Object |
   | information         |              |      |             |        |
   +---------------------+--------------+------+-------------+--------+
   | conflict-status     | enumeration  | 18   | 0 unsigned  | String |
   +---------------------+--------------+------+-------------+--------+
   | conflict-cause      | enumeration  | 19   | 0 unsigned  | String |
   +---------------------+--------------+------+-------------+--------+
   | retry-timer         | uint32       | 20   | 0 unsigned  | String |
   +---------------------+--------------+------+-------------+--------+
   | conflict-scope      | container    | 21   | 5 map       | Object |
   +---------------------+--------------+------+-------------+--------+
   | acl-list            | list         | 22   | 4 array     | Array  |
   +---------------------+--------------+------+-------------+--------+
   | acl-name            | leafref      | 23   | 3 text      | String |
   |                     |              |      | string      |        |
   +---------------------+--------------+------+-------------+--------+
   | acl-type            | leafref      | 24   | 3 text      | String |
   |                     |              |      | string      |        |
   +---------------------+--------------+------+-------------+--------+
   | bytes-dropped       | yang:zero-   | 25   | 0 unsigned  | String |
   |                     | based-       |      |             |        |
   |                     | counter64    |      |             |        |
   +---------------------+--------------+------+-------------+--------+
   | bps-dropped         | yang:gauge64 | 26   | 0 unsigned  | String |
   +---------------------+--------------+------+-------------+--------+
   | pkts-dropped        | yang:zero-   | 27   | 0 unsigned  | String |
   |                     | based-       |      |             |        |
   |                     | counter64    |      |             |        |
   +---------------------+--------------+------+-------------+--------+
   | pps-dropped         | yang:gauge64 | 28   | 0 unsigned  | String |
   +---------------------+--------------+------+-------------+--------+
   | attack-status       | enumeration  | 29   | 0 unsigned  | String |
   +---------------------+--------------+------+-------------+--------+
   | ietf-dots-signal-   | container    | 30   | 5 map       | Object |
   | channel:signal-     |              |      |             |        |
   | config              |              |      |             |        |
   +---------------------+--------------+------+-------------+--------+
   | sid                 | uint32       | 31   | 0 unsigned  | Number |
   +---------------------+--------------+------+-------------+--------+
   | mitigating-config   | container    | 32   | 5 map       | Object |
   +---------------------+--------------+------+-------------+--------+
   | heartbeat-interval  | container    | 33   | 5 map       | Object |
   +---------------------+--------------+------+-------------+--------+
   | max-value           | uint16       | 34   | 0 unsigned  | Number |
   +---------------------+--------------+------+-------------+--------+
   | min-value           | uint16       | 35   | 0 unsigned  | Number |
   +---------------------+--------------+------+-------------+--------+
   | current-value       | uint16       | 36   | 0 unsigned  | Number |
   +---------------------+--------------+------+-------------+--------+
   | missing-hb-allowed  | container    | 37   | 5 map       | Object |
   +---------------------+--------------+------+-------------+--------+
   | max-retransmit      | container    | 38   | 5 map       | Object |
   +---------------------+--------------+------+-------------+--------+
   | ack-timeout         | container    | 39   | 5 map       | Object |
   +---------------------+--------------+------+-------------+--------+
   | ack-random-factor   | container    | 40   | 5 map       | Object |
   +---------------------+--------------+------+-------------+--------+
   | max-value-decimal   | decimal64    | 41   | 6 tag 4     | String |
   |                     |              |      | [-2,        |        |
   |                     |              |      | integer]    |        |
   +---------------------+--------------+------+-------------+--------+
   | min-value-decimal   | decimal64    | 42   | 6 tag 4     | String |
   |                     |              |      | [-2,        |        |
   |                     |              |      | integer]    |        |
   +---------------------+--------------+------+-------------+--------+
   | current-value-      | decimal64    | 43   | 6 tag 4     | String |
   | decimal             |              |      | [-2,        |        |
   |                     |              |      | integer]    |        |
   +---------------------+--------------+------+-------------+--------+
   | idle-config         | container    | 44   | 5 map       | Object |
   +---------------------+--------------+------+-------------+--------+
   | trigger-mitigation  | boolean      | 45   | 7 bits 20   | False  |
   |                     |              |      +-------------+--------+
   |                     |              |      | 7 bits 21   | True   |
   +---------------------+--------------+------+-------------+--------+
   | ietf-dots-signal-   | container    | 46   | 5 map       | Object |
   | channel:redirected- |              |      |             |        |
   | signal              |              |      |             |        |
   +---------------------+--------------+------+-------------+--------+
   | alt-server          | string       | 47   | 3 text      | String |
   |                     |              |      | string      |        |
   +---------------------+--------------+------+-------------+--------+
   | alt-server-record   | leaf-list    | 48   | 4 array     | Array  |
   |                     +--------------+------+-------------+--------+
   |                     | inet:ip-     |      | 3 text      | String |
   |                     | address      |      | string      |        |
   +---------------------+--------------+------+-------------+--------+
   | ietf-dots-signal-   | container    | 49   | 5 map       | Object |
   | channel:heartbeat   |              |      |             |        |
   +---------------------+--------------+------+-------------+--------+
   | probing-rate        | container    | 50   | 5 map       | Object |
   +---------------------+--------------+------+-------------+--------+
   | peer-hb-status      | boolean      | 51   | 7 bits 20   | False  |
   |                     |              |      +-------------+--------+
   |                     |              |      | 7 bits 21   | True   |
   +---------------------+--------------+------+-------------+--------+

     Table 5: CBOR Key Values Used in DOTS Signal Channel Messages &amp;
                     Their Mappings to JSON and YANG

7.  (D)TLS Protocol Profile and Performance Considerations

7.1.  (D)TLS Protocol Profile

   This section defines the (D)TLS protocol profile of DOTS signal
   channel over (D)TLS and DOTS data channel over TLS.

   There are known attacks on (D)TLS, such as man-in-the-middle and
   protocol downgrade attacks.  These are general attacks on (D)TLS and,
   as such, they are not specific to DOTS over (D)TLS; refer to the
   (D)TLS RFCs for discussion of these security issues.  DOTS agents
   MUST adhere to the (D)TLS implementation recommendations and security
   considerations of [RFC7525] except with respect to (D)TLS version.
   Because DOTS signal channel encryption relying upon (D)TLS is
   virtually a greenfield deployment, DOTS agents MUST implement only
   (D)TLS 1.2 or later.

   When a DOTS client is configured with a domain name of the DOTS
   server, and it connects to its configured DOTS server, the server may
   present it with a PKIX certificate.  In order to ensure proper
   authentication, a DOTS client MUST verify the entire certification
   path per [RFC5280].  Additionally, the DOTS client MUST use [RFC6125]
   validation techniques to compare the domain name with the certificate
   provided.  Certification authorities that issue DOTS server
   certificates SHOULD support the DNS-ID and SRV-ID identifier types.
   DOTS servers SHOULD prefer the use of DNS-ID and SRV-ID over CN-ID
   identifier types in certificate requests (as described in Section 2.3
   of [RFC6125]), and the wildcard character &#x27;*&#x27; SHOULD NOT be included
   in the presented identifier.  DOTS doesn&#x27;t use URI-IDs for server
   identity verification.

   A key challenge to deploying DOTS is the provisioning of DOTS
   clients, including the distribution of keying material to DOTS
   clients to enable the required mutual authentication of DOTS agents.
   Enrollment over Secure Transport (EST) [RFC7030] defines a method of
   certificate enrollment by which domains operating DOTS servers may
   provide DOTS clients with all the necessary cryptographic keying
   material, including a private key and a certificate, to authenticate
   themselves.  One deployment option is to have DOTS clients behave as
   EST clients for certificate enrollment from an EST server provisioned
   by the mitigation provider.  This document does not specify which EST
   or other mechanism the DOTS client uses to achieve initial
   enrollment.

   <span class="Verified-inline-styling" id='inline-6449'>   The Server Name Indication (SNI) extension [RFC6066] defines a <button id="btn_6449" target="expand_6449" onclick='hideFunction("expand_6449")'>Expand</button>
   mechanism for a client to tell a (D)TLS server the name of the server
   it wants to contact.</span id__locate=6449>  This is a useful extension for hosting
<div class="nodeCloseClass" id='expand_6449'><div class='Verified-endnote-styling' id='eid6449'>
<pre>
<b><i><a href='https://www.rfc-editor.org/errata/eid6449'>EID 6449</a> (Verified) is as follows:</i></b>

<b>Section:</b> 7.1

<b>Original Text:</b>

   The Server Name Indication (SNI) extension [RFC6066] i defines a
   mechanism for a client to tell a (D)TLS server the name of the server
   it wants to contact.

<b>Corrected Text:</b>

   The Server Name Indication (SNI) extension [RFC6066] defines a
   mechanism for a client to tell a (D)TLS server the name of the server
   it wants to contact.
</pre>
<b>Notes:</b><br/>
extra &quot;i&quot;
</div>
</div>   environments where multiple virtual servers are reachable over a
   single IP address.  The DOTS client may or may not know if it is
   interacting with a DOTS server in a virtual server hosting
   environment, so the DOTS client SHOULD include the DOTS server FQDN
   in the SNI extension.

   Implementations compliant with this profile MUST implement all of the
   following items:

   *  DTLS record replay detection (Section 3.3 of [RFC6347]) or an
      equivalent mechanism to protect against replay attacks.

   *  DTLS session resumption without server-side state to resume
      session and convey the DOTS signal.

   *  At least one of raw public keys [RFC7250] or PSK handshake
      [RFC4279] with (EC)DHE key exchange.  This reduces the size of the
      ServerHello.  Also, this can be used by DOTS agents that cannot
      obtain certificates.

   Implementations compliant with this profile SHOULD implement all of
   the following items to reduce the delay required to deliver a DOTS
   signal channel message:

   *  TLS False Start [RFC7918], which reduces round-trips by allowing
      the TLS client&#x27;s second flight of messages (ChangeCipherSpec) to
      also contain the DOTS signal.  TLS False Start is formally defined
      for use with TLS, but the same technique is applicable to DTLS as
      well.

   *  Cached Information Extension [RFC7924] which avoids transmitting
      the server&#x27;s certificate and certificate chain if the client has
      cached that information from a previous TLS handshake.

   Compared to UDP, DOTS signal channel over TCP requires an additional
   round-trip time (RTT) of latency to establish a TCP connection.  DOTS
   implementations are encouraged to implement TCP Fast Open [RFC7413]
   to eliminate that RTT.

7.2.  (D)TLS 1.3 Considerations

   TLS 1.3 provides critical latency improvements for connection
   establishment over TLS 1.2.  The DTLS 1.3 protocol [DTLS] is based
   upon the TLS 1.3 protocol and provides equivalent security
   guarantees.  (D)TLS 1.3 provides two basic handshake modes the DOTS
   signal channel can take advantage of:

   *  A full handshake mode in which a DOTS client can send a DOTS
      mitigation request message after one round trip and the DOTS
      server immediately responds with a DOTS mitigation response.  This
      assumes no packet loss is experienced.

   *  0-RTT mode in which the DOTS client can authenticate itself and
      send DOTS mitigation request messages in the first message, thus
      reducing handshake latency. 0-RTT only works if the DOTS client
      has previously communicated with that DOTS server, which is very
      likely with the DOTS signal channel.

   The DOTS client has to establish a (D)TLS session with the DOTS
   server during &#x27;idle&#x27; time and share a PSK.

   During a DDoS attack, the DOTS client can use the (D)TLS session to
   convey the DOTS mitigation request message and, if there is no
   response from the server after multiple retries, the DOTS client can
   resume the (D)TLS session in 0-RTT mode using PSK.

   DOTS servers that support (D)TLS 1.3 MAY allow DOTS clients to send
   early data (0-RTT).  DOTS clients MUST NOT send &quot;CoAP Ping&quot; as early
   data; such messages MUST be rejected by DOTS servers.  Section 8 of
   [RFC8446] discusses some mechanisms to implement in order to limit
   the impact of replay attacks on 0-RTT data.  If the DOTS server
   accepts 0-RTT, it MUST implement one of these mechanisms to prevent
   replay at the TLS layer.  A DOTS server can reject 0-RTT by sending a
   TLS HelloRetryRequest.

   The DOTS signal channel messages sent as early data by the DOTS
   client are idempotent requests.  As a reminder, the Message ID
   (Section 3 of [RFC7252]) is changed each time a new CoAP request is
   sent, and the Token (Section 5.3.1 of [RFC7252]) is randomized in
   each CoAP request.  The DOTS server(s) MUST use the Message ID and
   the Token in the DOTS signal channel message to detect replay of
   early data at the application layer and accept 0-RTT data at most
   once from the same DOTS client.  This anti-replay defense requires
   sharing the Message ID and the Token in the 0-RTT data between DOTS
   servers in the DOTS server domain.  DOTS servers do not rely on
   transport coordinates to identify DOTS peers.  As specified in
   Section 4.4.1, DOTS servers couple the DOTS signal channel sessions
   using the DOTS client identity and optionally the &#x27;cdid&#x27; parameter
   value.  Furthermore, the &#x27;mid&#x27; value is monotonically increased by
   the DOTS client for each mitigation request, thus attackers that
   replay mitigation requests with lower numeric &#x27;mid&#x27; values and
   overlapping scopes with mitigation requests having higher numeric
   &#x27;mid&#x27; values will be rejected systematically by the DOTS server.
   Likewise, the &#x27;sid&#x27; value is monotonically increased by the DOTS
   client for each configuration request (Section 4.5.2); attackers
   replaying configuration requests with lower numeric &#x27;sid&#x27; values will
   be rejected by the DOTS server if it maintains a higher numeric &#x27;sid&#x27;
   value for this DOTS client.

   Owing to the aforementioned protections, all DOTS signal channel
   requests are safe to transmit in TLS 1.3 as early data.  Refer to
   [DOTS-EARLYDATA] for more details.

   A simplified TLS 1.3 handshake with 0-RTT DOTS mitigation request
   message exchange is shown in Figure 29.

       DOTS Client                                    DOTS Server

       ClientHello
       (0-RTT DOTS signal message)
                                 --------&gt;
                                                       ServerHello
                                             {EncryptedExtensions}
                                                        {Finished}
                                 &lt;--------   [DOTS signal message]
       (end_of_early_data)
       {Finished}                --------&gt;
       [DOTS signal message]     &lt;-------&gt;   [DOTS signal message]

   Note that:
       () Indicates messages protected 0-RTT keys
       {} Indicates messages protected using handshake keys
       [] Indicates messages protected using 1-RTT keys

            Figure 29: A Simplified TLS 1.3 Handshake with 0-RTT

7.3.  DTLS MTU and Fragmentation

   To avoid DOTS signal message fragmentation and the subsequent
   decreased probability of message delivery, DOTS agents MUST ensure
   that the DTLS record fits within a single datagram.  As a reminder,
   DTLS handles fragmentation and reassembly only for handshake messages
   and not for the application data (Section 4.1.1 of [RFC6347]).  If
   the path MTU (PMTU) cannot be discovered, DOTS agents MUST assume a
   PMTU of 1280 bytes, as IPv6 requires that every link in the Internet
   have an MTU of 1280 octets or greater as specified in [RFC8200].  If
   IPv4 support on legacy or otherwise unusual networks is a
   consideration and the PMTU is unknown, DOTS implementations MAY
   assume a PMTU of 576 bytes for IPv4 datagrams, as every IPv4 host
   must be capable of receiving a packet whose length is equal to 576
   bytes as discussed in [RFC0791] and [RFC1122].

   The DOTS client must consider the amount of record expansion expected
   by the DTLS processing when calculating the size of the CoAP message
   that fits within the PMTU.  PMTU MUST be greater than or equal to
   [CoAP message size + DTLS 1.2 overhead of 13 octets + authentication
   overhead of the negotiated DTLS cipher suite + block padding]
   (Section 4.1.1.1 of [RFC6347]).  If the total request size exceeds
   the PMTU, then the DOTS client MUST split the DOTS signal into
   separate messages; for example, the list of addresses in the &#x27;target-
   prefix&#x27; parameter could be split into multiple lists and each list
   conveyed in a new PUT request.

      |  Implementation Note: DOTS choice of message size parameters
      |  works well with IPv6 and with most of today&#x27;s IPv4 paths.
      |  However, with IPv4, it is harder to safely make sure that there
      |  is no IP fragmentation.  If the IPv4 PMTU is unknown,
      |  implementations may want to limit themselves to more
      |  conservative IPv4 datagram sizes such as 576 bytes, per
      |  [RFC0791].

8.  Mutual Authentication of DOTS Agents &amp; Authorization of DOTS Clients

   (D)TLS based upon client certificates can be used for mutual
   authentication between DOTS agents.  If, for example, a DOTS gateway
   is involved, DOTS clients and DOTS gateways must perform mutual
   authentication; only authorized DOTS clients are allowed to send DOTS
   signals to a DOTS gateway.  The DOTS gateway and the DOTS server must
   perform mutual authentication; a DOTS server only allows DOTS signal
   channel messages from an authorized DOTS gateway, thereby creating a
   two-link chain of transitive authentication between the DOTS client
   and the DOTS server.

   The DOTS server should support certificate-based client
   authentication.  The DOTS client should respond to the DOTS server&#x27;s
   TLS CertificateRequest message with the PKIX certificate held by the
   DOTS client.  DOTS client certificate validation must be performed
   per [RFC5280], and the DOTS client certificate must conform to the
   [RFC5280] certificate profile.  If a DOTS client does not support TLS
   client certificate authentication, it must support client
   authentication based on pre-shared key or raw public key.

   +---------------------------------------------+
   |       example.com domain       +---------+  |
   |                                | AAA     |  |
   | +---------------+              | Server  |  |
   | | Application   |              +------+--+  |
   | | server        +&lt;---------------+    ^     |
   | | (DOTS client) |                |    |     |
   | +---------------+                |    |     |
   |                                  V    V     |   example.net domain
   |                            +-----+----+--+  |    +---------------+
   | +--------------+           |             |  |    |               |
   | |   Guest      +&lt;----x----&gt;+    DOTS     +&lt;-----&gt;+    DOTS       |
   | | (DOTS client)|           |    gateway  |  |    |    server     |
   | +--------------+           |             |  |    |               |
   |                            +----+--------+  |    +---------------+
   |                                 ^           |
   |                                 |           |
   | +----------------+              |           |
   | | DDoS detector  |              |           |
   | | (DOTS client)  +&lt;-------------+           |
   | +----------------+                          |
   +---------------------------------------------+

   Figure 30: Example of Authentication and Authorization of DOTS Agents

   In the example depicted in Figure 30, the DOTS gateway and DOTS
   clients within the &#x27;example.com&#x27; domain mutually authenticate.  After
   the DOTS gateway validates the identity of a DOTS client, it
   communicates with the AAA server in the &#x27;example.com&#x27; domain to
   determine if the DOTS client is authorized to request DDoS
   mitigation.  If the DOTS client is not authorized, a 4.01
   (Unauthorized) is returned in the response to the DOTS client.  In
   this example, the DOTS gateway only allows the application server and
   DDoS attack detector to request DDoS mitigation, but does not permit
   the user of type &#x27;guest&#x27; to request DDoS mitigation.

   Also, DOTS gateways and servers located in different domains must
   perform mutual authentication (e.g., using certificates).  A DOTS
   server will only allow a DOTS gateway with a certificate for a
   particular domain to request mitigation for that domain.  In
   reference to Figure 30, the DOTS server only allows the DOTS gateway
   to request mitigation for the &#x27;example.com&#x27; domain and not for other
   domains.

9.  IANA Considerations

9.1.  DOTS Signal Channel UDP and TCP Port Number

   IANA has assigned the port number 4646 (the ASCII decimal value for
   &quot;..&quot; (DOTS)) to the DOTS signal channel protocol for both UDP and TCP
   from the &quot;Service Name and Transport Protocol Port Number Registry&quot;
   available at &lt;https://www.iana.org/assignments/service-names-port-
   numbers/&gt;.

      Service Name:  dots-signal
      Port Number:  4646
      Transport Protocol:  TCP
      Description:  Distributed Denial-of-Service Open Threat Signaling
         (DOTS) Signal Channel
      Assignee:  IESG
      Contact:  IETF Chair
      Registration Date:  2020-01-16
      Reference:  [RFC8782]

      Service Name:  dots-signal
      Port Number:  4646
      Transport Protocol:  UDP
      Description:  Distributed Denial-of-Service Open Threat Signaling
         (DOTS) Signal Channel
      Assignee:  IESG
      Contact:  IETF Chair
      Registration Date:  2020-01-16
      Reference:  [RFC8782]

9.2.  Well-Known &#x27;dots&#x27; URI

   IANA has registered the &#x27;dots&#x27; well-known URI (Table 6) in the Well-
   Known URIs registry (&lt;https://www.iana.org/assignments/well-known-
   uris/well-known-uris.xhtml&gt;) as defined by [RFC8615]:

     +------------+------------+-----------+-----------+-------------+
     | URI Suffix | Change     | Reference | Status    | Related     |
     |            | Controller |           |           | information |
     +============+============+===========+===========+=============+
     | dots       | IETF       | [RFC8782] | permanent | None        |
     +------------+------------+-----------+-----------+-------------+

                       Table 6: &#x27;dots&#x27; Well-Known URI

9.3.  Media Type Registration

   IANA has registered the &quot;application/dots+cbor&quot; media type in the
   &quot;Media Types&quot; registry [IANA-MediaTypes] in the manner described in
   [RFC6838], which can be used to indicate that the content is a DOTS
   signal channel object:

   Type name: application

   Subtype name: dots+cbor

   Required parameters: N/A

   Optional parameters: N/A

   Encoding considerations: binary

   Security considerations: See the Security Considerations section of
   [RFC8782].

   Interoperability considerations: N/A

   Published specification: [RFC8782]

   Applications that use this media type: DOTS agents sending DOTS
   messages over CoAP over (D)TLS.

   Fragment identifier considerations: N/A

   Additional information:

      Deprecated alias names for this type: N/A
      Magic number(s): N/A
      File extension(s): N/A
      Macintosh file type code(s): N/A

   Person &amp; email address to contact for further information: IESG,
   iesg@ietf.org

   Intended usage: COMMON

   Restrictions on usage: none

   Author: See Authors&#x27; Addresses section.

   Change controller: IESG

   Provisional registration?  No

9.4.  CoAP Content-Formats Registration

   IANA has registered the CoAP Content-Format ID for the &quot;application/
   dots+cbor&quot; media type in the &quot;CoAP Content-Formats&quot; registry
   [IANA-CoAP-Content-Formats]:

   *  Media Type: application/dots+cbor
   *  Encoding: -
   *  ID: 271
   *  Reference: [RFC8782]

9.5.  CBOR Tag Registration

   This section defines the DOTS CBOR tag as another means for
   applications to declare that a CBOR data structure is a DOTS signal
   channel object.  Its use is optional and is intended for use in cases
   in which this information would not otherwise be known.  The DOTS
   CBOR tag is not required for DOTS signal channel protocol version
   specified in this document.  If present, the DOTS tag MUST prefix a
   DOTS signal channel object.

   IANA has registered the DOTS signal channel CBOR tag in the &quot;CBOR
   Tags&quot; registry [IANA-CBOR-Tags]:

   *  Tag: 271
   *  Data Item: DDoS Open Threat Signaling (DOTS) signal channel object
   *  Semantics: DDoS Open Threat Signaling (DOTS) signal channel
      object, as defined in [RFC8782]
   *  Reference: [RFC8782]

9.6.  DOTS Signal Channel Protocol Registry

   IANA has created a new registry titled the &quot;Distributed Denial-of-
   Service Open Threat Signaling (DOTS) Signal Channel&quot; registry.  The
   following sections define subregistries.

9.6.1.  DOTS Signal Channel CBOR Key Values Subregistry

   IANA has created a new subregistry titled &quot;DOTS Signal Channel CBOR
   Key Values&quot;.

   The structure of this subregistry is provided in Section 9.6.1.1.
   Section 9.6.1.2 provides the registry as initially populated with the
   values in Table 7.

9.6.1.1.  Registration Template

   Parameter name:
      Parameter name as used in the DOTS signal channel.

   CBOR Key Value:
      Key value for the parameter.  The key value MUST be an integer in
      the 1-65535 range.  The key values of the comprehension-required
      range (0x0001 - 0x3FFF) and of the comprehension-optional range
      (0x8000 - 0xBFFF) are assigned by IETF Review (Section 4.8 of
      [RFC8126]).  The key values of the comprehension-optional range
      (0x4000 - 0x7FFF) are assigned by Specification Required
      (Section 4.6 of [RFC8126]) and of the comprehension-optional range
      (0xC000 - 0xFFFF) are reserved for Private Use (Section 4.1 of
      [RFC8126]).

      Registration requests for the 0x4000 - 0x7FFF range are evaluated
      after a three-week review period on the dots-signal-reg-
      review@ietf.org mailing list, on the advice of one or more
      Designated Experts.  However, to allow for the allocation of
      values prior to publication, the Designated Experts may approve
      registration once they are satisfied that such a specification
      will be published.  New registration requests should be sent in
      the form of an email to the review mailing list; the request
      should use an appropriate subject (e.g., &quot;Request to register CBOR
      Key Value for DOTS: example&quot;).  IANA will only accept new
      registrations from the Designated Experts, and it will check that
      review was requested on the mailing list in accordance with these
      procedures.

      Within the review period, the Designated Experts will either
      approve or deny the registration request, communicating this
      decision to the review list and IANA.  Denials should include an
      explanation and, if applicable, suggestions as to how to make the
      request successful.  Registration requests that are undetermined
      for a period longer than 21 days can be brought to the IESG&#x27;s
      attention (using the iesg@ietf.org mailing list) for resolution.

      Criteria that should be applied by the Designated Experts include
      determining whether the proposed registration duplicates existing
      functionality, whether it is likely to be of general applicability
      or whether it is useful only for a single use case, and whether
      the registration description is clear.  IANA must only accept
      registry updates to the 0x4000 - 0x7FFF range from the Designated
      Experts and should direct all requests for registration to the
      review mailing list.  It is suggested that multiple Designated
      Experts be appointed.  In cases where a registration decision
      could be perceived as creating a conflict of interest for a
      particular Expert, that Expert should defer to the judgment of the
      other Experts.

   CBOR Major Type:
      CBOR Major type and optional tag for the parameter.

   Change Controller:
      For Standards Track RFCs, list the &quot;IESG&quot;.  For others, give the
      name of the responsible party.  Other details (e.g., email
      address) may also be included.

   Specification Document(s):
      Reference to the document or documents that specify the parameter,
      preferably including URIs that can be used to retrieve copies of
      the documents.  An indication of the relevant sections may also be
      included but is not required.

9.6.1.2.  Initial Subregistry Content

   +---------------------+------------+-----+----------+---------------+
   | Parameter Name      | CBOR Key   |CBOR | Change   | Specification |
   |                     | Value      |Major|Controller| Document(s)   |
   |                     |            |Type |          |               |
   +=====================+============+=====+==========+===============+
   | Reserved            | 0          |     |          | [RFC8782]     |
   +---------------------+------------+-----+----------+---------------+
   | ietf-dots-signal-   | 1          | 5   | IESG     | [RFC8782]     |
   | channel:mitigation- |            |     |          |               |
   | scope               |            |     |          |               |
   +---------------------+------------+-----+----------+---------------+
   | scope               | 2          | 4   | IESG     | [RFC8782]     |
   +---------------------+------------+-----+----------+---------------+
   | cdid                | 3          | 3   | IESG     | [RFC8782]     |
   +---------------------+------------+-----+----------+---------------+
   | cuid                | 4          | 3   | IESG     | [RFC8782]     |
   +---------------------+------------+-----+----------+---------------+
   | mid                 | 5          | 0   | IESG     | [RFC8782]     |
   +---------------------+------------+-----+----------+---------------+
   | target-prefix       | 6          | 4   | IESG     | [RFC8782]     |
   +---------------------+------------+-----+----------+---------------+
   | target-port-range   | 7          | 4   | IESG     | [RFC8782]     |
   +---------------------+------------+-----+----------+---------------+
   | lower-port          | 8          | 0   | IESG     | [RFC8782]     |
   +---------------------+------------+-----+----------+---------------+
   | upper-port          | 9          | 0   | IESG     | [RFC8782]     |
   +---------------------+------------+-----+----------+---------------+
   | target-protocol     | 10         | 4   | IESG     | [RFC8782]     |
   +---------------------+------------+-----+----------+---------------+
   | target-fqdn         | 11         | 4   | IESG     | [RFC8782]     |
   +---------------------+------------+-----+----------+---------------+
   | target-uri          | 12         | 4   | IESG     | [RFC8782]     |
   +---------------------+------------+-----+----------+---------------+
   | alias-name          | 13         | 4   | IESG     | [RFC8782]     |
   +---------------------+------------+-----+----------+---------------+
   | lifetime            | 14         | 0/1 | IESG     | [RFC8782]     |
   +---------------------+------------+-----+----------+---------------+
   | mitigation-start    | 15         | 0   | IESG     | [RFC8782]     |
   +---------------------+------------+-----+----------+---------------+
   | status              | 16         | 0   | IESG     | [RFC8782]     |
   +---------------------+------------+-----+----------+---------------+
   |conflict-information | 17         | 5   | IESG     | [RFC8782]     |
   +---------------------+------------+-----+----------+---------------+
   | conflict-status     | 18         | 0   | IESG     | [RFC8782]     |
   +---------------------+------------+-----+----------+---------------+
   | conflict-cause      | 19         | 0   | IESG     | [RFC8782]     |
   +---------------------+------------+-----+----------+---------------+
   | retry-timer         | 20         | 0   | IESG     | [RFC8782]     |
   +---------------------+------------+-----+----------+---------------+
   | conflict-scope      | 21         | 5   | IESG     | [RFC8782]     |
   +---------------------+------------+-----+----------+---------------+
   | acl-list            | 22         | 4   | IESG     | [RFC8782]     |
   +---------------------+------------+-----+----------+---------------+
   | acl-name            | 23         | 3   | IESG     | [RFC8782]     |
   +---------------------+------------+-----+----------+---------------+
   | acl-type            | 24         | 3   | IESG     | [RFC8782]     |
   +---------------------+------------+-----+----------+---------------+
   | bytes-dropped       | 25         | 0   | IESG     | [RFC8782]     |
   +---------------------+------------+-----+----------+---------------+
   | bps-dropped         | 26         | 0   | IESG     | [RFC8782]     |
   +---------------------+------------+-----+----------+---------------+
   | pkts-dropped        | 27         | 0   | IESG     | [RFC8782]     |
   +---------------------+------------+-----+----------+---------------+
   | pps-dropped         | 28         | 0   | IESG     | [RFC8782]     |
   +---------------------+------------+-----+----------+---------------+
   | attack-status       | 29         | 0   | IESG     | [RFC8782]     |
   +---------------------+------------+-----+----------+---------------+
   | ietf-dots-signal-   | 30         | 5   | IESG     | [RFC8782]     |
   |channel:signal-config|            |     |          |               |
   +---------------------+------------+-----+----------+---------------+
   | sid                 | 31         | 0   | IESG     | [RFC8782]     |
   +---------------------+------------+-----+----------+---------------+
   | mitigating-config   | 32         | 5   | IESG     | [RFC8782]     |
   +---------------------+------------+-----+----------+---------------+
   | heartbeat-interval  | 33         | 5   | IESG     | [RFC8782]     |
   +---------------------+------------+-----+----------+---------------+
   | min-value           | 34         | 0   | IESG     | [RFC8782]     |
   +---------------------+------------+-----+----------+---------------+
   | max-value           | 35         | 0   | IESG     | [RFC8782]     |
   +---------------------+------------+-----+----------+---------------+
   | current-value       | 36         | 0   | IESG     | [RFC8782]     |
   +---------------------+------------+-----+----------+---------------+
   | missing-hb-allowed  | 37         | 5   | IESG     | [RFC8782]     |
   +---------------------+------------+-----+----------+---------------+
   | max-retransmit      | 38         | 5   | IESG     | [RFC8782]     |
   +---------------------+------------+-----+----------+---------------+
   | ack-timeout         | 39         | 5   | IESG     | [RFC8782]     |
   +---------------------+------------+-----+----------+---------------+
   | ack-random-factor   | 40         | 5   | IESG     | [RFC8782]     |
   +---------------------+------------+-----+----------+---------------+
   | min-value-decimal   | 41         |6tag4| IESG     | [RFC8782]     |
   +---------------------+------------+-----+----------+---------------+
   | max-value-decimal   | 42         |6tag4| IESG     | [RFC8782]     |
   +---------------------+------------+-----+----------+---------------+
   |current-value-decimal| 43         |6tag4| IESG     | [RFC8782]     |
   +---------------------+------------+-----+----------+---------------+
   | idle-config         | 44         | 5   | IESG     | [RFC8782]     |
   +---------------------+------------+-----+----------+---------------+
   | trigger-mitigation  | 45         | 7   | IESG     | [RFC8782]     |
   +---------------------+------------+-----+----------+---------------+
   | ietf-dots-signal-   | 46         | 5   | IESG     | [RFC8782]     |
   | channel:redirected- |            |     |          |               |
   | signal              |            |     |          |               |
   +---------------------+------------+-----+----------+---------------+
   | alt-server          | 47         | 3   | IESG     | [RFC8782]     |
   +---------------------+------------+-----+----------+---------------+
   | alt-server-record   | 48         | 4   | IESG     | [RFC8782]     |
   +---------------------+------------+-----+----------+---------------+
   | ietf-dots-signal-   | 49         | 5   | IESG     | [RFC8782]     |
   | channel:heartbeat   |            |     |          |               |
   +---------------------+------------+-----+----------+---------------+
   | probing-rate        | 50         | 5   | IESG     | [RFC8782]     |
   +---------------------+------------+-----+----------+---------------+
   | peer-hb-status      | 51         | 7   | IESG     | [RFC8782]     |
   +---------------------+------------+-----+----------+---------------+
   | Unassigned          | 52-49151   |     |          |               |
   +---------------------+------------+-----+----------+---------------+
   |Reserved for Private |49152-65535 |     |          | [RFC8782]     |
   | Use                 |            |     |          |               |
   +---------------------+------------+-----+----------+---------------+

       Table 7: Initial DOTS Signal Channel CBOR Key Values Registry

9.6.2.  Status Codes Subregistry

   IANA has created a new subregistry titled &quot;DOTS Signal Channel Status
   Codes&quot;.  Codes in this registry are used as valid values of &#x27;status&#x27;
   parameter.

   The registry is initially populated with the following values:

    +--------------+---------------+----------------------+-----------+
    |         Code | Label         | Description          | Reference |
    +==============+===============+======================+===========+
    |            0 | Reserved      |                      | [RFC8782] |
    +--------------+---------------+----------------------+-----------+
    |            1 | attack-       | Attack mitigation    | [RFC8782] |
    |              | mitigation-   | setup is in progress |           |
    |              | in-progress   | (e.g., changing the  |           |
    |              |               | network path to      |           |
    |              |               | redirect the inbound |           |
    |              |               | traffic to a DOTS    |           |
    |              |               | mitigator).          |           |
    +--------------+---------------+----------------------+-----------+
    |            2 | attack-       | Attack is being      | [RFC8782] |
    |              | successfully- | successfully         |           |
    |              | mitigated     | mitigated (e.g.,     |           |
    |              |               | traffic is           |           |
    |              |               | redirected to a DDoS |           |
    |              |               | mitigator and attack |           |
    |              |               | traffic is dropped). |           |
    +--------------+---------------+----------------------+-----------+
    |            3 | attack-       | Attack has stopped   | [RFC8782] |
    |              | stopped       | and the DOTS client  |           |
    |              |               | can withdraw the     |           |
    |              |               | mitigation request.  |           |
    +--------------+---------------+----------------------+-----------+
    |            4 | attack-       | Attack has exceeded  | [RFC8782] |
    |              | exceeded-     | the mitigation       |           |
    |              | capability    | provider capability. |           |
    +--------------+---------------+----------------------+-----------+
    |            5 | dots-client-  | DOTS client has      | [RFC8782] |
    |              | withdrawn-    | withdrawn the        |           |
    |              | mitigation    | mitigation request   |           |
    |              |               | and the mitigation   |           |
    |              |               | is active but        |           |
    |              |               | terminating.         |           |
    +--------------+---------------+----------------------+-----------+
    |            6 | attack-       | Attack mitigation is | [RFC8782] |
    |              | mitigation-   | now terminated.      |           |
    |              | terminated    |                      |           |
    +--------------+---------------+----------------------+-----------+
    |            7 | attack-       | Attack mitigation is | [RFC8782] |
    |              | mitigation-   | withdrawn.           |           |
    |              | withdrawn     |                      |           |
    +--------------+---------------+----------------------+-----------+
    |            8 | attack-       | Attack mitigation    | [RFC8782] |
    |              | mitigation-   | will be triggered    |           |
    |              | signal-loss   | for the mitigation   |           |
    |              |               | request only when    |           |
    |              |               | the DOTS signal      |           |
    |              |               | channel session is   |           |
    |              |               | lost.                |           |
    +--------------+---------------+----------------------+-----------+
    | 9-2147483647 | Unassigned    |                      |           |
    +--------------+---------------+----------------------+-----------+

             Table 8: Initial DOTS Signal Channel Status Codes

   New codes can be assigned via Standards Action [RFC8126].

9.6.3.  Conflict Status Codes Subregistry

   IANA has created a new subregistry titled &quot;DOTS Signal Channel
   Conflict Status Codes&quot;.  Codes in this registry are used as valid
   values of &#x27;conflict-status&#x27; parameter.

   The registry is initially populated with the following values:

   +--------------+-------------------+--------------------+-----------+
   |         Code | Label             | Description        | Reference |
   +==============+===================+====================+===========+
   |            0 | Reserved          |                    | [RFC8782] |
   +--------------+-------------------+--------------------+-----------+
   |            1 | request-inactive- | DOTS server        | [RFC8782] |
   |              | other-active      | has detected       |           |
   |              |                   | conflicting        |           |
   |              |                   | mitigation         |           |
   |              |                   | requests from      |           |
   |              |                   | different DOTS     |           |
   |              |                   | clients.  This     |           |
   |              |                   | mitigation         |           |
   |              |                   | request is         |           |
   |              |                   | currently          |           |
   |              |                   | inactive until     |           |
   |              |                   | the conflicts      |           |
   |              |                   | are resolved.      |           |
   |              |                   | Another            |           |
   |              |                   | mitigation         |           |
   |              |                   | request is         |           |
   |              |                   | active.            |           |
   +--------------+-------------------+--------------------+-----------+
   |            2 | request-active    | DOTS server        | [RFC8782] |
   |              |                   | has detected       |           |
   |              |                   | conflicting        |           |
   |              |                   | mitigation         |           |
   |              |                   | requests from      |           |
   |              |                   | different DOTS     |           |
   |              |                   | clients.  This     |           |
   |              |                   | mitigation         |           |
   |              |                   | request is         |           |
   |              |                   | currently          |           |
   |              |                   | active.            |           |
   +--------------+-------------------+--------------------+-----------+
   |            3 | all-requests-     | DOTS server        | [RFC8782] |
   |              | inactive          | has detected       |           |
   |              |                   | conflicting        |           |
   |              |                   | mitigation         |           |
   |              |                   | requests from      |           |
   |              |                   | different DOTS     |           |
   |              |                   | clients.  All      |           |
   |              |                   | conflicting        |           |
   |              |                   | mitigation         |           |
   |              |                   | requests are       |           |
   |              |                   | inactive.          |           |
   +--------------+-------------------+--------------------+-----------+
   | 4-2147483647 | Unassigned        |                    |           |
   +--------------+-------------------+--------------------+-----------+

         Table 9: Initial DOTS Signal Channel Conflict Status Codes

   New codes can be assigned via Standards Action [RFC8126].

9.6.4.  Conflict Cause Codes Subregistry

   IANA has created a new subregistry titled &quot;DOTS Signal Channel
   Conflict Cause Codes&quot;.  Codes in this registry are used as valid
   values of &#x27;conflict-cause&#x27; parameter.

   The registry is initially populated with the following values:

    +--------------+---------------------+----------------+-----------+
    |         Code | Label               | Description    | Reference |
    +==============+=====================+================+===========+
    |            0 | Reserved            |                | [RFC8782] |
    +--------------+---------------------+----------------+-----------+
    |            1 | overlapping-targets | Overlapping    | [RFC8782] |
    |              |                     | targets.       |           |
    +--------------+---------------------+----------------+-----------+
    |            2 | conflict-with-      | Conflicts with | [RFC8782] |
    |              | acceptlist          | an existing    |           |
    |              |                     | accept-list.   |           |
    |              |                     | This code is   |           |
    |              |                     | returned when  |           |
    |              |                     | the DDoS       |           |
    |              |                     | mitigation     |           |
    |              |                     | detects source |           |
    |              |                     | addresses/     |           |
    |              |                     | prefixes in    |           |
    |              |                     | the accept-    |           |
    |              |                     | listed ACLs    |           |
    |              |                     | are attacking  |           |
    |              |                     | the target.    |           |
    +--------------+---------------------+----------------+-----------+
    |            3 | cuid-collision      | CUID           | [RFC8782] |
    |              |                     | Collision.     |           |
    |              |                     | This code is   |           |
    |              |                     | returned when  |           |
    |              |                     | a DOTS client  |           |
    |              |                     | uses a &#x27;cuid&#x27;  |           |
    |              |                     | that is        |           |
    |              |                     | already used   |           |
    |              |                     | by another     |           |
    |              |                     | DOTS client.   |           |
    +--------------+---------------------+----------------+-----------+
    | 4-2147483647 | Unassigned          |                |           |
    +--------------+---------------------+----------------+-----------+

         Table 10: Initial DOTS Signal Channel Conflict Cause Codes

   New codes can be assigned via Standards Action [RFC8126].

9.6.5.  Attack Status Codes Subregistry

   IANA has created a new subregistry titled &quot;DOTS Signal Channel Attack
   Status Codes&quot;.  Codes in this registry are used as valid values of
   &#x27;attack-status&#x27; parameter.

   The registry is initially populated with the following values:

   +--------------+----------------------+-----------------+-----------+
   |         Code | Label                | Description     | Reference |
   +==============+======================+=================+===========+
   |            0 | Reserved             |                 | [RFC8782] |
   +--------------+----------------------+-----------------+-----------+
   |            1 | under-attack         | The DOTS        | [RFC8782] |
   |              |                      | client          |           |
   |              |                      | determines      |           |
   |              |                      | that it is      |           |
   |              |                      | still under     |           |
   |              |                      | attack.         |           |
   +--------------+----------------------+-----------------+-----------+
   |            2 | attack-successfully- | The DOTS        | [RFC8782] |
   |              | mitigated            | client          |           |
   |              |                      | determines      |           |
   |              |                      | that the        |           |
   |              |                      | attack is       |           |
   |              |                      | successfully    |           |
   |              |                      | mitigated.      |           |
   +--------------+----------------------+-----------------+-----------+
   | 3-2147483647 | Unassigned           |                 |           |
   +--------------+----------------------+-----------------+-----------+

         Table 11: Initial DOTS Signal Channel Attack Status Codes

   New codes can be assigned via Standards Action [RFC8126].

9.7.  DOTS Signal Channel YANG Modules

   IANA has registered the following URIs in the &quot;ns&quot; subregistry within
   the &quot;IETF XML Registry&quot; [RFC3688]:

      URI:  urn:ietf:params:xml:ns:yang:ietf-dots-signal-channel
      Registrant Contact:  The IESG.
      XML:  N/A; the requested URI is an XML namespace.

      URI:  urn:ietf:params:xml:ns:yang:iana-dots-signal-channel
      Registrant Contact:  IANA.
      XML:  N/A; the requested URI is an XML namespace.

   IANA has registered the following YANG modules in the &quot;YANG Module
   Names&quot; subregistry [RFC7950] within the &quot;YANG Parameters&quot; registry.

      Name:  ietf-dots-signal-channel
      Maintained by IANA:  N
      Namespace:  urn:ietf:params:xml:ns:yang:ietf-dots-signal-channel
      Prefix:  signal
      Reference:  RFC8782

      Name:  iana-dots-signal-channel
      Maintained by IANA:  Y
      Namespace:  urn:ietf:params:xml:ns:yang:iana-dots-signal-channel
      Prefix:  iana-signal
      Reference:  RFC8782

   This document defines the initial version of the IANA-maintained
   iana-dots-signal-channel YANG module.  IANA has added this note:

      Status, conflict status, conflict cause, and attack status values
      must not be directly added to the iana-dots-signal-channel YANG
      module.  They must instead be respectively added to the &quot;DOTS
      Status Codes&quot;, &quot;DOTS Conflict Status Codes&quot;, &quot;DOTS Conflict Cause
      Codes&quot;, and &quot;DOTS Attack Status Codes&quot; registries.

   When a &#x27;status&#x27;, &#x27;conflict-status&#x27;, &#x27;conflict-cause&#x27;, or &#x27;attack-
   status&#x27; value is respectively added to the &quot;DOTS Status Codes&quot;, &quot;DOTS
   Conflict Status Codes&quot;, &quot;DOTS Conflict Cause Codes&quot;, or &quot;DOTS Attack
   Status Codes&quot; registry, a new &quot;enum&quot; statement must be added to the
   iana-dots-signal-channel YANG module.  The following &quot;enum&quot;
   statement, and substatements thereof, should be defined:

   &quot;enum&quot;:        Replicates the label from the registry.

   &quot;value&quot;:       Contains the IANA-assigned value corresponding to the
                  &#x27;status&#x27;, &#x27;conflict-status&#x27;, &#x27;conflict-cause&#x27;, or
                  &#x27;attack-status&#x27;.

   &quot;description&quot;:  Replicates the description from the registry.

   &quot;reference&quot;:   Replicates the reference from the registry and adds
                  the title of the document.

   When the iana-dots-signal-channel YANG module is updated, a new
   &quot;revision&quot; statement must be added in front of the existing revision
   statements.

   IANA added this note to &quot;DOTS Status Codes&quot;, &quot;DOTS Conflict Status
   Codes&quot;, &quot;DOTS Conflict Cause Codes&quot;, and &quot;DOTS Attack Status Codes&quot;
   registries:

      When this registry is modified, the YANG module iana-dots-signal-
      channel must be updated as defined in [RFC8782].

10.  Security Considerations

   High-level DOTS security considerations are documented in [RFC8612]
   and [DOTS-ARCH].

   Authenticated encryption MUST be used for data confidentiality and
   message integrity.  The interaction between the DOTS agents requires
   Datagram Transport Layer Security (DTLS) or Transport Layer Security
   (TLS) with a cipher suite offering confidentiality protection, and
   the guidance given in [RFC7525] MUST be followed to avoid attacks on
   (D)TLS.  The (D)TLS protocol profile used for the DOTS signal channel
   is specified in Section 7.

   If TCP is used between DOTS agents, an attacker may be able to inject
   RST packets, bogus application segments, etc., regardless of whether
   TLS authentication is used.  Because the application data is TLS
   protected, this will not result in the application receiving bogus
   data, but it will constitute a DoS on the connection.  This attack
   can be countered by using TCP Authentication Option (TCP-AO)
   [RFC5925].  Although not widely adopted, if TCP-AO is used, then any
   bogus packets injected by an attacker will be rejected by the TCP-AO
   integrity check and therefore will never reach the TLS layer.

   If the &#x27;cuid&#x27; is guessable, a misbehaving DOTS client from within the
   client&#x27;s domain can use the &#x27;cuid&#x27; of another DOTS client of the
   domain to delete or alter active mitigations.  For this attack vector
   to happen, the misbehaving client needs to pass the security
   validation checks by the DOTS server, and eventually the checks of a
   client-domain DOTS gateway.

   A similar attack can be achieved by a compromised DOTS client that
   can sniff the TLS 1.2 handshake, use the client certificate to
   identify the &#x27;cuid&#x27; used by another DOTS client.  This attack is not
   possible if algorithms such as version 4 Universally Unique
   IDentifiers (UUIDs) in Section 4.4 of [RFC4122] are used to generate
   the &#x27;cuid&#x27; because such UUIDs are not a deterministic function of the
   client certificate.  Likewise, this attack is not possible with TLS
   1.3 because most of the TLS handshake is encrypted and the client
   certificate is not visible to eavesdroppers.

   A compromised DOTS client can collude with a DDoS attacker to send
   mitigation request for a target resource, get the mitigation efficacy
   from the DOTS server, and convey the mitigation efficacy to the DDoS
   attacker to possibly change the DDoS attack strategy.  Obviously,
   signaling an attack by the compromised DOTS client to the DOTS server
   will trigger attack mitigation.  This attack can be prevented by
   monitoring and auditing DOTS clients to detect misbehavior and to
   deter misuse, and by only authorizing the DOTS client to request
   mitigation for specific target resources (e.g., an application server
   is authorized to request mitigation for its IP addresses, but a DDoS
   mitigator can request mitigation for any target resource in the
   network).  Furthermore, DOTS clients are typically co-located on
   network security services (e.g., firewall), and a compromised
   security service potentially can do a lot more damage to the network.

   Rate-limiting DOTS requests, including those with new &#x27;cuid&#x27; values,
   from the same DOTS client defend against DoS attacks that would
   result in varying the &#x27;cuid&#x27; to exhaust DOTS server resources.  Rate-
   limit policies SHOULD be enforced on DOTS gateways (if deployed) and
   DOTS servers.

   In order to prevent leaking internal information outside a client&#x27;s
   domain, DOTS gateways located in the client domain SHOULD NOT reveal
   the identification information that pertains to internal DOTS clients
   (e.g., source IP address, client&#x27;s hostname) unless explicitly
   configured to do so.

   DOTS servers MUST verify that requesting DOTS clients are entitled to
   trigger actions on a given IP prefix.  That is, only actions on IP
   resources that belong to the DOTS client&#x27;s domain MUST be authorized
   by a DOTS server.  The exact mechanism for the DOTS servers to
   validate that the target prefixes are within the scope of the DOTS
   client domain is deployment specific.

   The presence of DOTS gateways may lead to infinite forwarding loops,
   which is undesirable.  To prevent and detect such loops, this
   document uses the Hop-Limit option.

   When FQDNs are used as targets, the DOTS server MUST rely upon DNS
   privacy-enabling protocols (e.g., DNS over TLS [RFC7858] or DNS over
   HTTPS (DoH) [RFC8484]) to prevent eavesdroppers from possibly
   identifying the target resources protected by the DDoS mitigation
   service to ensure the target FQDN resolution is authentic (e.g.,
   DNSSEC [RFC4034]).

   CoAP-specific security considerations are discussed in Section 11 of
   [RFC7252], while CBOR-related security considerations are discussed
   in Section 8 of [RFC7049].

11.  References

11.1.  Normative References

   [RFC0791]  Postel, J., &quot;Internet Protocol&quot;, STD 5, RFC 791,
              DOI 10.17487/RFC0791, September 1981,
              &lt;https://www.rfc-editor.org/info/rfc791&gt;.

   [RFC1122]  Braden, R., Ed., &quot;Requirements for Internet Hosts -
              Communication Layers&quot;, STD 3, RFC 1122,
              DOI 10.17487/RFC1122, October 1989,
              &lt;https://www.rfc-editor.org/info/rfc1122&gt;.

   [RFC2119]  Bradner, S., &quot;Key words for use in RFCs to Indicate
              Requirement Levels&quot;, BCP 14, RFC 2119,
              DOI 10.17487/RFC2119, March 1997,
              &lt;https://www.rfc-editor.org/info/rfc2119&gt;.

   [RFC3688]  Mealling, M., &quot;The IETF XML Registry&quot;, BCP 81, RFC 3688,
              DOI 10.17487/RFC3688, January 2004,
              &lt;https://www.rfc-editor.org/info/rfc3688&gt;.

   [RFC3986]  Berners-Lee, T., Fielding, R., and L. Masinter, &quot;Uniform
              Resource Identifier (URI): Generic Syntax&quot;, STD 66,
              RFC 3986, DOI 10.17487/RFC3986, January 2005,
              &lt;https://www.rfc-editor.org/info/rfc3986&gt;.

   [RFC4279]  Eronen, P., Ed. and H. Tschofenig, Ed., &quot;Pre-Shared Key
              Ciphersuites for Transport Layer Security (TLS)&quot;,
              RFC 4279, DOI 10.17487/RFC4279, December 2005,
              &lt;https://www.rfc-editor.org/info/rfc4279&gt;.

   [RFC4632]  Fuller, V. and T. Li, &quot;Classless Inter-domain Routing
              (CIDR): The Internet Address Assignment and Aggregation
              Plan&quot;, BCP 122, RFC 4632, DOI 10.17487/RFC4632, August
              2006, &lt;https://www.rfc-editor.org/info/rfc4632&gt;.

   [RFC4648]  Josefsson, S., &quot;The Base16, Base32, and Base64 Data
              Encodings&quot;, RFC 4648, DOI 10.17487/RFC4648, October 2006,
              &lt;https://www.rfc-editor.org/info/rfc4648&gt;.

   [RFC5246]  Dierks, T. and E. Rescorla, &quot;The Transport Layer Security
              (TLS) Protocol Version 1.2&quot;, RFC 5246,
              DOI 10.17487/RFC5246, August 2008,
              &lt;https://www.rfc-editor.org/info/rfc5246&gt;.

   [RFC5280]  Cooper, D., Santesson, S., Farrell, S., Boeyen, S.,
              Housley, R., and W. Polk, &quot;Internet X.509 Public Key
              Infrastructure Certificate and Certificate Revocation List
              (CRL) Profile&quot;, RFC 5280, DOI 10.17487/RFC5280, May 2008,
              &lt;https://www.rfc-editor.org/info/rfc5280&gt;.

   [RFC6066]  Eastlake 3rd, D., &quot;Transport Layer Security (TLS)
              Extensions: Extension Definitions&quot;, RFC 6066,
              DOI 10.17487/RFC6066, January 2011,
              &lt;https://www.rfc-editor.org/info/rfc6066&gt;.

   [RFC6125]  Saint-Andre, P. and J. Hodges, &quot;Representation and
              Verification of Domain-Based Application Service Identity
              within Internet Public Key Infrastructure Using X.509
              (PKIX) Certificates in the Context of Transport Layer
              Security (TLS)&quot;, RFC 6125, DOI 10.17487/RFC6125, March
              2011, &lt;https://www.rfc-editor.org/info/rfc6125&gt;.

   [RFC6347]  Rescorla, E. and N. Modadugu, &quot;Datagram Transport Layer
              Security Version 1.2&quot;, RFC 6347, DOI 10.17487/RFC6347,
              January 2012, &lt;https://www.rfc-editor.org/info/rfc6347&gt;.

   [RFC6991]  Schoenwaelder, J., Ed., &quot;Common YANG Data Types&quot;,
              RFC 6991, DOI 10.17487/RFC6991, July 2013,
              &lt;https://www.rfc-editor.org/info/rfc6991&gt;.

   [RFC7049]  Bormann, C. and P. Hoffman, &quot;Concise Binary Object
              Representation (CBOR)&quot;, RFC 7049, DOI 10.17487/RFC7049,
              October 2013, &lt;https://www.rfc-editor.org/info/rfc7049&gt;.

   [RFC7250]  Wouters, P., Ed., Tschofenig, H., Ed., Gilmore, J.,
              Weiler, S., and T. Kivinen, &quot;Using Raw Public Keys in
              Transport Layer Security (TLS) and Datagram Transport
              Layer Security (DTLS)&quot;, RFC 7250, DOI 10.17487/RFC7250,
              June 2014, &lt;https://www.rfc-editor.org/info/rfc7250&gt;.

   [RFC7252]  Shelby, Z., Hartke, K., and C. Bormann, &quot;The Constrained
              Application Protocol (CoAP)&quot;, RFC 7252,
              DOI 10.17487/RFC7252, June 2014,
              &lt;https://www.rfc-editor.org/info/rfc7252&gt;.

   [RFC7525]  Sheffer, Y., Holz, R., and P. Saint-Andre,
              &quot;Recommendations for Secure Use of Transport Layer
              Security (TLS) and Datagram Transport Layer Security
              (DTLS)&quot;, BCP 195, RFC 7525, DOI 10.17487/RFC7525, May
              2015, &lt;https://www.rfc-editor.org/info/rfc7525&gt;.

   [RFC7641]  Hartke, K., &quot;Observing Resources in the Constrained
              Application Protocol (CoAP)&quot;, RFC 7641,
              DOI 10.17487/RFC7641, September 2015,
              &lt;https://www.rfc-editor.org/info/rfc7641&gt;.

   [RFC7918]  Langley, A., Modadugu, N., and B. Moeller, &quot;Transport
              Layer Security (TLS) False Start&quot;, RFC 7918,
              DOI 10.17487/RFC7918, August 2016,
              &lt;https://www.rfc-editor.org/info/rfc7918&gt;.

   [RFC7924]  Santesson, S. and H. Tschofenig, &quot;Transport Layer Security
              (TLS) Cached Information Extension&quot;, RFC 7924,
              DOI 10.17487/RFC7924, July 2016,
              &lt;https://www.rfc-editor.org/info/rfc7924&gt;.

   [RFC7950]  Bjorklund, M., Ed., &quot;The YANG 1.1 Data Modeling Language&quot;,
              RFC 7950, DOI 10.17487/RFC7950, August 2016,
              &lt;https://www.rfc-editor.org/info/rfc7950&gt;.

   [RFC7959]  Bormann, C. and Z. Shelby, Ed., &quot;Block-Wise Transfers in
              the Constrained Application Protocol (CoAP)&quot;, RFC 7959,
              DOI 10.17487/RFC7959, August 2016,
              &lt;https://www.rfc-editor.org/info/rfc7959&gt;.

   [RFC8085]  Eggert, L., Fairhurst, G., and G. Shepherd, &quot;UDP Usage
              Guidelines&quot;, BCP 145, RFC 8085, DOI 10.17487/RFC8085,
              March 2017, &lt;https://www.rfc-editor.org/info/rfc8085&gt;.

   [RFC8126]  Cotton, M., Leiba, B., and T. Narten, &quot;Guidelines for
              Writing an IANA Considerations Section in RFCs&quot;, BCP 26,
              RFC 8126, DOI 10.17487/RFC8126, June 2017,
              &lt;https://www.rfc-editor.org/info/rfc8126&gt;.

   [RFC8174]  Leiba, B., &quot;Ambiguity of Uppercase vs Lowercase in RFC
              2119 Key Words&quot;, BCP 14, RFC 8174, DOI 10.17487/RFC8174,
              May 2017, &lt;https://www.rfc-editor.org/info/rfc8174&gt;.

   [RFC8200]  Deering, S. and R. Hinden, &quot;Internet Protocol, Version 6
              (IPv6) Specification&quot;, STD 86, RFC 8200,
              DOI 10.17487/RFC8200, July 2017,
              &lt;https://www.rfc-editor.org/info/rfc8200&gt;.

   [RFC8305]  Schinazi, D. and T. Pauly, &quot;Happy Eyeballs Version 2:
              Better Connectivity Using Concurrency&quot;, RFC 8305,
              DOI 10.17487/RFC8305, December 2017,
              &lt;https://www.rfc-editor.org/info/rfc8305&gt;.

   [RFC8323]  Bormann, C., Lemay, S., Tschofenig, H., Hartke, K.,
              Silverajan, B., and B. Raymor, Ed., &quot;CoAP (Constrained
              Application Protocol) over TCP, TLS, and WebSockets&quot;,
              RFC 8323, DOI 10.17487/RFC8323, February 2018,
              &lt;https://www.rfc-editor.org/info/rfc8323&gt;.

   [RFC8446]  Rescorla, E., &quot;The Transport Layer Security (TLS) Protocol
              Version 1.3&quot;, RFC 8446, DOI 10.17487/RFC8446, August 2018,
              &lt;https://www.rfc-editor.org/info/rfc8446&gt;.

   [RFC8615]  Nottingham, M., &quot;Well-Known Uniform Resource Identifiers
              (URIs)&quot;, RFC 8615, DOI 10.17487/RFC8615, May 2019,
              &lt;https://www.rfc-editor.org/info/rfc8615&gt;.

   [RFC8768]  Boucadair, M., Reddy.K, T., and J. Shallow, &quot;Constrained
              Application Protocol (CoAP) Hop-Limit Option&quot;, RFC 8768,
              DOI 10.17487/RFC8768, March 2020,
              &lt;https://www.rfc-editor.org/info/rfc8768&gt;.

11.2.  Informative References

   [COMI]     Veillette, M., Stok, P., Pelov, A., Bierman, A., and I.
              Petrov, &quot;CoAP Management Interface&quot;, Work in Progress,
              Internet-Draft, draft-ietf-core-comi-09, 9 March 2020,
              &lt;https://tools.ietf.org/html/draft-ietf-core-comi-09&gt;.

   [CORE-YANG-CBOR]
              Veillette, M., Petrov, I., and A. Pelov, &quot;CBOR Encoding of
              Data Modeled with YANG&quot;, Work in Progress, Internet-Draft,
              draft-ietf-core-yang-cbor-12, 9 March 2020,
              &lt;https://tools.ietf.org/html/draft-ietf-core-yang-cbor-
              12&gt;.

   [DOTS-ARCH]
              Mortensen, A., Reddy.K, T., Andreasen, F., Teague, N., and
              R. Compton, &quot;Distributed-Denial-of-Service Open Threat
              Signaling (DOTS) Architecture&quot;, Work in Progress,
              Internet-Draft, draft-ietf-dots-architecture-18, 6 March
              2020, &lt;https://tools.ietf.org/html/draft-ietf-dots-
              architecture-18&gt;.

   [DOTS-EARLYDATA]
              Boucadair, M. and T. Reddy.K, &quot;Using Early Data in DOTS&quot;,
              Work in Progress, Internet-Draft, draft-boucadair-dots-
              earlydata-00, 29 January 2019,
              &lt;https://tools.ietf.org/html/draft-boucadair-dots-
              earlydata-00&gt;.

   [DOTS-MH]  Boucadair, M., Reddy.K, T., and W. Pan, &quot;Multi-homing
              Deployment Considerations for Distributed-Denial-of-
              Service Open Threat Signaling (DOTS)&quot;, Work in Progress,
              Internet-Draft, draft-ietf-dots-multihoming-03, 22 January
              2020, &lt;https://tools.ietf.org/html/draft-ietf-dots-
              multihoming-03&gt;.

   [DOTS-SERVER-DISC]
              Boucadair, M. and T. Reddy.K, &quot;Distributed-Denial-of-
              Service Open Threat Signaling (DOTS) Agent Discovery&quot;,
              Work in Progress, Internet-Draft, draft-ietf-dots-server-
              discovery-10, 7 February 2020,
              &lt;https://tools.ietf.org/html/draft-ietf-dots-server-
              discovery-10&gt;.

   [DOTS-USE-CASES]
              Dobbins, R., Migault, D., Moskowitz, R., Teague, N., Xia,
              L., and K. Nishizuka, &quot;Use cases for DDoS Open Threat
              Signaling&quot;, Work in Progress, Internet-Draft, draft-ietf-
              dots-use-cases-21, 15 May 2020,
              &lt;https://tools.ietf.org/html/draft-ietf-dots-use-cases-
              21&gt;.

   [DTLS]     Rescorla, E., Tschofenig, H., and N. Modadugu, &quot;The
              Datagram Transport Layer Security (DTLS) Protocol Version
              1.3&quot;, Work in Progress, Internet-Draft, draft-ietf-tls-
              dtls13-37, 9 March 2020,
              &lt;https://tools.ietf.org/html/draft-ietf-tls-dtls13-37&gt;.

   [IANA-CBOR-Tags]
              IANA, &quot;Concise Binary Object Representation (CBOR) Tags&quot;,
              &lt;http://www.iana.org/assignments/cbor-tags/cbor-
              tags.xhtml&gt;.

   [IANA-CoAP-Content-Formats]
              IANA, &quot;CoAP Content-Formats&quot;,
              &lt;http://www.iana.org/assignments/core-parameters/core-
              parameters.xhtml#content-formats&gt;.

   [IANA-MediaTypes]
              IANA, &quot;Media Types&quot;,
              &lt;http://www.iana.org/assignments/media-types&gt;.

   [IANA-Proto]
              IANA, &quot;Protocol Numbers&quot;, 2011,
              &lt;http://www.iana.org/assignments/protocol-numbers&gt;.

   [RFC3022]  Srisuresh, P. and K. Egevang, &quot;Traditional IP Network
              Address Translator (Traditional NAT)&quot;, RFC 3022,
              DOI 10.17487/RFC3022, January 2001,
              &lt;https://www.rfc-editor.org/info/rfc3022&gt;.

   [RFC4034]  Arends, R., Austein, R., Larson, M., Massey, D., and S.
              Rose, &quot;Resource Records for the DNS Security Extensions&quot;,
              RFC 4034, DOI 10.17487/RFC4034, March 2005,
              &lt;https://www.rfc-editor.org/info/rfc4034&gt;.

   [RFC4122]  Leach, P., Mealling, M., and R. Salz, &quot;A Universally
              Unique IDentifier (UUID) URN Namespace&quot;, RFC 4122,
              DOI 10.17487/RFC4122, July 2005,
              &lt;https://www.rfc-editor.org/info/rfc4122&gt;.

   [RFC4340]  Kohler, E., Handley, M., and S. Floyd, &quot;Datagram
              Congestion Control Protocol (DCCP)&quot;, RFC 4340,
              DOI 10.17487/RFC4340, March 2006,
              &lt;https://www.rfc-editor.org/info/rfc4340&gt;.

   [RFC4732]  Handley, M., Ed., Rescorla, E., Ed., and IAB, &quot;Internet
              Denial-of-Service Considerations&quot;, RFC 4732,
              DOI 10.17487/RFC4732, December 2006,
              &lt;https://www.rfc-editor.org/info/rfc4732&gt;.

   [RFC4787]  Audet, F., Ed. and C. Jennings, &quot;Network Address
              Translation (NAT) Behavioral Requirements for Unicast
              UDP&quot;, BCP 127, RFC 4787, DOI 10.17487/RFC4787, January
              2007, &lt;https://www.rfc-editor.org/info/rfc4787&gt;.

   [RFC4960]  Stewart, R., Ed., &quot;Stream Control Transmission Protocol&quot;,
              RFC 4960, DOI 10.17487/RFC4960, September 2007,
              &lt;https://www.rfc-editor.org/info/rfc4960&gt;.

   [RFC4987]  Eddy, W., &quot;TCP SYN Flooding Attacks and Common
              Mitigations&quot;, RFC 4987, DOI 10.17487/RFC4987, August 2007,
              &lt;https://www.rfc-editor.org/info/rfc4987&gt;.

   [RFC5925]  Touch, J., Mankin, A., and R. Bonica, &quot;The TCP
              Authentication Option&quot;, RFC 5925, DOI 10.17487/RFC5925,
              June 2010, &lt;https://www.rfc-editor.org/info/rfc5925&gt;.

   [RFC6052]  Bao, C., Huitema, C., Bagnulo, M., Boucadair, M., and X.
              Li, &quot;IPv6 Addressing of IPv4/IPv6 Translators&quot;, RFC 6052,
              DOI 10.17487/RFC6052, October 2010,
              &lt;https://www.rfc-editor.org/info/rfc6052&gt;.

   [RFC6146]  Bagnulo, M., Matthews, P., and I. van Beijnum, &quot;Stateful
              NAT64: Network Address and Protocol Translation from IPv6
              Clients to IPv4 Servers&quot;, RFC 6146, DOI 10.17487/RFC6146,
              April 2011, &lt;https://www.rfc-editor.org/info/rfc6146&gt;.

   [RFC6234]  Eastlake 3rd, D. and T. Hansen, &quot;US Secure Hash Algorithms
              (SHA and SHA-based HMAC and HKDF)&quot;, RFC 6234,
              DOI 10.17487/RFC6234, May 2011,
              &lt;https://www.rfc-editor.org/info/rfc6234&gt;.

   [RFC6296]  Wasserman, M. and F. Baker, &quot;IPv6-to-IPv6 Network Prefix
              Translation&quot;, RFC 6296, DOI 10.17487/RFC6296, June 2011,
              &lt;https://www.rfc-editor.org/info/rfc6296&gt;.

   [RFC6724]  Thaler, D., Ed., Draves, R., Matsumoto, A., and T. Chown,
              &quot;Default Address Selection for Internet Protocol Version 6
              (IPv6)&quot;, RFC 6724, DOI 10.17487/RFC6724, September 2012,
              &lt;https://www.rfc-editor.org/info/rfc6724&gt;.

   [RFC6838]  Freed, N., Klensin, J., and T. Hansen, &quot;Media Type
              Specifications and Registration Procedures&quot;, BCP 13,
              RFC 6838, DOI 10.17487/RFC6838, January 2013,
              &lt;https://www.rfc-editor.org/info/rfc6838&gt;.

   [RFC6887]  Wing, D., Ed., Cheshire, S., Boucadair, M., Penno, R., and
              P. Selkirk, &quot;Port Control Protocol (PCP)&quot;, RFC 6887,
              DOI 10.17487/RFC6887, April 2013,
              &lt;https://www.rfc-editor.org/info/rfc6887&gt;.

   [RFC6888]  Perreault, S., Ed., Yamagata, I., Miyakawa, S., Nakagawa,
              A., and H. Ashida, &quot;Common Requirements for Carrier-Grade
              NATs (CGNs)&quot;, BCP 127, RFC 6888, DOI 10.17487/RFC6888,
              April 2013, &lt;https://www.rfc-editor.org/info/rfc6888&gt;.

   [RFC7030]  Pritikin, M., Ed., Yee, P., Ed., and D. Harkins, Ed.,
              &quot;Enrollment over Secure Transport&quot;, RFC 7030,
              DOI 10.17487/RFC7030, October 2013,
              &lt;https://www.rfc-editor.org/info/rfc7030&gt;.

   [RFC7413]  Cheng, Y., Chu, J., Radhakrishnan, S., and A. Jain, &quot;TCP
              Fast Open&quot;, RFC 7413, DOI 10.17487/RFC7413, December 2014,
              &lt;https://www.rfc-editor.org/info/rfc7413&gt;.

   [RFC7452]  Tschofenig, H., Arkko, J., Thaler, D., and D. McPherson,
              &quot;Architectural Considerations in Smart Object Networking&quot;,
              RFC 7452, DOI 10.17487/RFC7452, March 2015,
              &lt;https://www.rfc-editor.org/info/rfc7452&gt;.

   [RFC7589]  Badra, M., Luchuk, A., and J. Schoenwaelder, &quot;Using the
              NETCONF Protocol over Transport Layer Security (TLS) with
              Mutual X.509 Authentication&quot;, RFC 7589,
              DOI 10.17487/RFC7589, June 2015,
              &lt;https://www.rfc-editor.org/info/rfc7589&gt;.

   [RFC7858]  Hu, Z., Zhu, L., Heidemann, J., Mankin, A., Wessels, D.,
              and P. Hoffman, &quot;Specification for DNS over Transport
              Layer Security (TLS)&quot;, RFC 7858, DOI 10.17487/RFC7858, May
              2016, &lt;https://www.rfc-editor.org/info/rfc7858&gt;.

   [RFC7951]  Lhotka, L., &quot;JSON Encoding of Data Modeled with YANG&quot;,
              RFC 7951, DOI 10.17487/RFC7951, August 2016,
              &lt;https://www.rfc-editor.org/info/rfc7951&gt;.

   [RFC8340]  Bjorklund, M. and L. Berger, Ed., &quot;YANG Tree Diagrams&quot;,
              BCP 215, RFC 8340, DOI 10.17487/RFC8340, March 2018,
              &lt;https://www.rfc-editor.org/info/rfc8340&gt;.

   [RFC8484]  Hoffman, P. and P. McManus, &quot;DNS Queries over HTTPS
              (DoH)&quot;, RFC 8484, DOI 10.17487/RFC8484, October 2018,
              &lt;https://www.rfc-editor.org/info/rfc8484&gt;.

   [RFC8489]  Petit-Huguenin, M., Salgueiro, G., Rosenberg, J., Wing,
              D., Mahy, R., and P. Matthews, &quot;Session Traversal
              Utilities for NAT (STUN)&quot;, RFC 8489, DOI 10.17487/RFC8489,
              February 2020, &lt;https://www.rfc-editor.org/info/rfc8489&gt;.

   [RFC8499]  Hoffman, P., Sullivan, A., and K. Fujiwara, &quot;DNS
              Terminology&quot;, BCP 219, RFC 8499, DOI 10.17487/RFC8499,
              January 2019, &lt;https://www.rfc-editor.org/info/rfc8499&gt;.

   [RFC8612]  Mortensen, A., Reddy, T., and R. Moskowitz, &quot;DDoS Open
              Threat Signaling (DOTS) Requirements&quot;, RFC 8612,
              DOI 10.17487/RFC8612, May 2019,
              &lt;https://www.rfc-editor.org/info/rfc8612&gt;.

   [RFC8783]  Boucadair, M., Ed. and T. Reddy.K, Ed., &quot;Distributed
              Denial-of-Service Open Threat Signaling (DOTS) Data
              Channel Specification&quot;, RFC 8783, DOI 10.17487/RFC8783,
              May 2020, &lt;https://www.rfc-editor.org/info/rfc8783&gt;.

Appendix A.  CUID Generation

   The document recommends the use of SPKI to generate the &#x27;cuid&#x27;.  This
   design choice is motivated by the following reasons:

   *  SPKI is globally unique.

   *  It is deterministic.

   *  It allows the avoidance of extra cycles that may be induced by
      &#x27;cuid&#x27; collision.

   *  DOTS clients do not need to store the &#x27;cuid&#x27; in a persistent
      storage.

   *  It allows the detection of compromised DOTS clients that do not
      adhere to the &#x27;cuid&#x27; generation algorithm.

Acknowledgements

   Thanks to Christian Jacquenet, Roland Dobbins, Roman Danyliw, Michael
   Richardson, Ehud Doron, Kaname Nishizuka, Dave Dolson, Liang Xia,
   Gilbert Clark, Xialiang Frank, Jim Schaad, Klaus Hartke, Nesredien
   Suleiman, Stephen Farrell, and Yoshifumi Nishida for the discussion
   and comments.

   The authors would like to give special thanks to Kaname Nishizuka and
   Jon Shallow for their efforts in implementing the protocol and
   performing interop testing at IETF Hackathons.

   Thanks to the core WG for the recommendations on Hop-Limit and
   redirect signaling.

   Special thanks to Benjamin Kaduk for the detailed AD review.

   Thanks to Alexey Melnikov, Adam Roach, Suresh Krishnan, Mirja
   KÃ¼hlewind, and Alissa Cooper for the review.

   Thanks to Carsten Bormann for his review of the DOTS heartbeat
   mechanism.

Contributors

   The following individuals have contributed to this document:

   Jon Shallow
   NCC Group

   Email: jon.shallow@nccgroup.trust

   Mike Geller
   Cisco Systems, Inc.
   FL 33309
   United States of America

   Email: mgeller@cisco.com

   Robert Moskowitz
   HTT Consulting
   Oak Park, MI 42837
   United States of America

   Email: rgm@htt-consult.com

   Dan Wing

   Email: dwing-ietf@fuggles.com

Authors&#x27; Addresses

   Tirumaleswar Reddy.K (editor)
   McAfee, Inc.
   Embassy Golf Link Business Park
   Bangalore 560071
   Karnataka
   India

   Email: kondtir@gmail.com

   Mohamed Boucadair (editor)
   Orange
   35000 Rennes
   France

   Email: mohamed.boucadair@orange.com

   Prashanth Patil
   Cisco Systems, Inc.

   Email: praspati@cisco.com

   Andrew Mortensen
   Arbor Networks, Inc.
   2727 S. State Street
   Ann Arbor, MI 48104
   United States of America

   Email: andrew@moretension.com

   Nik Teague
   Iron Mountain Data Centers
   United Kingdom

   Email: nteague@ironmountain.co.uk
        </re>
        
    </body>
</html>
