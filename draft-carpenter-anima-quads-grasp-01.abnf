quadskip-objective = ["411:quadskip", objective-flags, loop-count, value]
objective-flags = ; as in the GRASP specification
loop-count = ; as in the GRASP specification
value = server-PEM
server-PEM = bytes

   The recommended frequency of flooding is once per minute with a valid
   life time of two minutes.  By this means, every autonomic node can
   learn the public key of the server.

   "411:quadski" is a negotiation objective that is used by an autonomic
   node that wishes to enrol securely in the AN, known as a "pledge" to
   align with BRSKI [I-D.ietf-anima-bootstrapping-keyinfra] terminology.
   In fragmentary CDDL, it is defined as follows:

quadski-objective = ["411:quadski", objective-flags, loop-count, value]
objective-flags = ; as in the GRASP specification
loop-count = ; as in the GRASP specification
value = pledge-value / server-value
pledge-value = [encrypted-password, pledge-PEM]
server-value = encrypted-keys
encrypted-password = bytes
pledge-PEM = bytes
encrypted-keys = bytes

   The encrypted-password is a previously agreed domain password (which
   should not be the same as the keying password used in Section 2),
   RSA-encrypted using the public key of the server.

   The pledge-PEM is the PEM encoding of the public RSA key of the
   pledge node.

   The encrypted-keys value is the result of the following process:

   1.  Assume the symmetric cryptography in use is AES/CBC, key length
       32, initialisation vector length 16, padding PKCS7(128).

   2.  Let the key bytes be 'key' and the initialisation vector bytes be
       'iv'.

   3.  Construct the array object [key, iv].

   4.  Encode this object in CBOR.

   5.  Encrypt the resulting CBOR bytes with RSA using the public key of
       the pledge ("pledge-PEM").

   6.  The result is the value of "encrypted-keys".

   The QUADSKI server must have possession of the domain keys
   (Section 2) and the domain password when it starts up, by a method
   not specified here.  It then proceeds as follows:

   1.  Create an RSA key pair, store the private key, and prepare the
       PEM encoding of the public key ("server-PEM").

   2.  Start flooding out the "411:quadskip" objective with the "server-
       PEM" value, using the GRASP M_FLOOD message.
   3.  Start listening for negotiation requests (GRASP M_NEG_REQ) for
       the "411:quadski" objective.

   4.  Whenever it receives such a request, RSA-decrypt the "encrypted-
       password" using its private key.

   5.  If the password matches, recover the pledge's public key from the
       "pledge-PEM".

   6.  Generate the "encrypted-keys" value as described above, and reply
       (GRASP M_NEGOTIATE) with that value.

   7.  Normally, the pledge will reply with GRASP M_END and an O_ACCEPT
       option.

   Error conditions such as a password mismatch will be handled like any
   GRASP error condition, with GRASP M_END and an O_DECLINE option.

   The pledge proceeds as follows:

   1.  Create an RSA key pair, store the private key, and prepare the
       PEM encoding of the public key ("pledge-PEM").

   2.  Wait until it detects the flooded "411:quadskip" option, at which
       point it can recover the QUADSKI server's public key from the
       "server-PEM" value.

   3.  Request the domain password from the user.

   4.  RSA-encrypt the password using the server's public key.

   5.  Use GRASP discovery (M_DISCOVER "411:quadski") to locate the
       QUADSKI server.

   6.  Construct a "411:quadski" objective whose value is [encrypted-
       password, pledge-PEM] as described above.

   7.  Start the negotiation process (M_NEG_REQ).

   8.  When it receives a successful reply (M_NEGOTIATE), RSA-decrypt
       the value using its own private key, decode the result from CBOR,
       and thus recover the QUADS keys [key, iv].

   9.  Close the GRASP session with M_END + O_ACCEPT.

   As noted, this process uses unencrypted GRASP, since there are no
   QUADS keys available until it ends.  Unlike BRSKI
   [I-D.ietf-anima-bootstrapping-keyinfra], it does not rely on any
   limitation to link-local traffic, since it is protected by asymmetric
   cryptography.  However, for this to work on an evolving network where
   nodes may enrol at any time, GRASP must run encrypted for nodes that
   have acquired QUADS keys and simultaneously unencrypted for the
   QUADSKI process.  The simplest way to achieve this is to run two
   GRASP instances as necessary.  In particular, a node that acts as a
   GRASP relay needs to be able to relay encrypted traffic (for enrolled
   nodes) and unencrypted traffic (for nodes needing to run the QUADSKI
   process).  Note that such instances will receive GRASP broadcasts
   that they cannot interpret (encrypted packets reaching an unencrypted
   GRASP instance, and vice versa).  These packets can be harmlessly
   discarded.

