<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="en"><head><title>A Quick Crash Detection Method for IKE</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="description" content="A Quick Crash Detection Method for IKE">
<meta name="keywords" content="Internet-Draft">
<meta name="generator" content="xml2rfc v1.35 (http://xml.resource.org/)">
<meta name="viewport" content="width=600;" />
<style type='text/css'><!--
        body {
                font-family: verdana, charcoal, helvetica, arial, sans-serif;
                font-size: 85%;
		max-width: 40em; 
		color: #000; background-color: #FFF;
                margin: 2em;
        }
        h1, h2, h3, h4, h5, h6 {
                font-family: helvetica, monaco, "MS Sans Serif", arial, sans-serif;
                font-weight: bold; font-style: normal;
        }
        h1 { color: #900; background-color: transparent; text-align: right; }
        h3 { color: #333; background-color: transparent; }

        td.RFCbug {
                font-size: x-small; text-decoration: none;
                width: 30px; height: 30px; padding-top: 2px;
                text-align: justify; vertical-align: middle;
                background-color: #000;
        }
        td.RFCbug span.RFC {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: bold; color: #666;
        }
        td.RFCbug span.hotText {
                font-family: charcoal, monaco, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: normal; text-align: center; color: #FFF;
        }

        table.TOCbug { width: 30px; height: 15px; }
        td.TOCbug {
                text-align: center; width: 30px; height: 15px;
                color: #FFF; background-color: #900;
        }
        td.TOCbug a {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, sans-serif;
                font-weight: bold; font-size: x-small; text-decoration: none;
                color: #FFF; background-color: transparent;
        }

        td.header {
                font-family: arial, helvetica, sans-serif; font-size: x-small;
                vertical-align: top; width: 33%;
                color: #FFF; background-color: #666;
        }
        td.author { font-weight: bold; font-size: x-small; margin-left: 4em; }
        td.author-text { font-size: x-small; }

        /* info code from SantaKlauss at http://www.madaboutstyle.com/tooltip2.html */
        a.info {
                /* This is the key. */
                position: relative;
                z-index: 24;
                text-decoration: none;
        }
        a.info:hover {
                z-index: 25;
                color: #FFF; background-color: #900;
        }
        a.info span { display: none; }
        a.info:hover span.info {
                /* The span will display just on :hover state. */
                display: block;
                position: absolute;
                font-size: smaller;
                top: 2em; left: -5em; width: 15em;
                padding: 2px; border: 1px solid #333;
                color: #900; background-color: #EEE;
                text-align: left;
        }

        a { font-weight: bold; }
        a:link    { color: #900; background-color: transparent; }
        a:visited { color: #633; background-color: transparent; }
        a:active  { color: #633; background-color: transparent; }

        p { margin-left: 2em; margin-right: 2em; }
        p.copyright { font-size: x-small; }
        p.toc { font-size: 85%;
		max-width: 40em; 
		font-weight: bold; margin-left: 3em; }
        table.toc { margin: 0 0 0 3em; padding: 0; border: 0; vertical-align: text-top; }
        td.toc { font-size: 85%;
		max-width: 40em; 
		font-weight: bold; vertical-align: text-top; }

        ol.text { margin-left: 2em; margin-right: 2em; }
        ul.text { margin-left: 2em; margin-right: 2em; }
        li      { margin-left: 3em; }

        /* RFC-2629 <spanx>s and <artwork>s. */
        em     { font-style: italic; }
        strong { font-weight: bold; }
        dfn    { font-weight: bold; font-style: normal; }
        cite   { font-weight: normal; font-style: normal; }
        tt     { color: #036; }
        tt, pre, pre dfn, pre em, pre cite, pre span {
                font-family: "Courier New", Courier, monospace; font-size: small;
        }
        pre {
                text-align: left; padding: 4px;
                color: #000; background-color: #CCC;
        }
        pre dfn  { color: #900; }
        pre em   { color: #66F; background-color: #FFC; font-weight: normal; }
        pre .key { color: #33C; font-weight: bold; }
        pre .id  { color: #900; }
        pre .str { color: #000; background-color: #CFF; }
        pre .val { color: #066; }
        pre .rep { color: #909; }
        pre .oth { color: #000; background-color: #FCF; }
        pre .err { background-color: #FCC; }

        /* RFC-2629 <texttable>s. */
        table.all, table.full, table.headers, table.none {
                font-size: 85%;
		max-width: 40em; 
		text-align: center; border-width: 2px;
                vertical-align: top; border-collapse: collapse;
        }
        table.all, table.full { border-style: solid; border-color: black; }
        table.headers, table.none { border-style: none; }
        th {
                font-weight: bold; border-color: black;
                border-width: 2px 2px 3px 2px;
        }
        table.all th, table.full th { border-style: solid; }
        table.headers th { border-style: none none solid none; }
        table.none th { border-style: none; }
        table.all td {
                border-style: solid; border-color: #333;
                border-width: 1px 2px;
        }
        table.full td, table.headers td, table.none td { border-style: none; }

        hr { height: 1px; }
        hr.insert {
                width: 80%; border-style: none; border-width: 0;
                color: #CCC; background-color: #CCC;
        }
--></style>
</head>
<body>
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<table summary="layout" width="66%" border="0" cellpadding="0" cellspacing="0"><tr><td><table summary="layout" width="100%" border="0" cellpadding="2" cellspacing="1">
<tr><td class="header">Network Working Group</td><td class="header">Y. Nir</td></tr>
<tr><td class="header">Internet-Draft</td><td class="header">Check Point</td></tr>
<tr><td class="header">Intended status: Standards Track</td><td class="header">April 02, 2008</td></tr>
<tr><td class="header">Expires: October 4, 2008</td><td class="header">&nbsp;</td></tr>
</table></td></tr></table>
<h1><br />A Quick Crash Detection Method for IKE<br />draft-nir-ike-qcd-00.txt</h1>

<h3>Status of this Memo</h3>
<p>
By submitting this Internet-Draft,
each author represents that any applicable patent or other IPR claims of which
he or she is aware have been or will be disclosed,
and any of which he or she becomes aware will be disclosed,
in accordance with Section&nbsp;6 of BCP&nbsp;79.</p>
<p>
Internet-Drafts are working documents of the Internet Engineering
Task Force (IETF), its areas, and its working groups.
Note that other groups may also distribute working documents as
Internet-Drafts.</p>
<p>
Internet-Drafts are draft documents valid for a maximum of six months
and may be updated, replaced, or obsoleted by other documents at any time.
It is inappropriate to use Internet-Drafts as reference material or to cite
them other than as &ldquo;work in progress.&rdquo;</p>
<p>
The list of current Internet-Drafts can be accessed at
<a href='http://www.ietf.org/ietf/1id-abstracts.txt'>http://www.ietf.org/ietf/1id-abstracts.txt</a>.</p>
<p>
The list of Internet-Draft Shadow Directories can be accessed at
<a href='http://www.ietf.org/shadow.html'>http://www.ietf.org/shadow.html</a>.</p>
<p>
This Internet-Draft will expire on October 4, 2008.</p>

<h3>Abstract</h3>

<p> This document describes an extension to the IKEv2 protocol that allows for faster crash 
        recovery using a saved token.
</p>
<p> When an IPsec tunnel between two IKEv2 implementations is disconnected due to a restart
        of one peer, it can take as much as several minutes for the other peer to discover that the
        reboot has occurred, thus delaying recovery. In this text we propose an extension to the 
        protocol, that allows for recovery within a few seconds of the reboot.
</p><a name="toc"></a><br /><hr />
<h3>Table of Contents</h3>
<p class="toc">
<a href="#introduction">1.</a>&nbsp;
Introduction<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#mustshouldmay">1.1.</a>&nbsp;
Conventions Used in This Document<br />
<a href="#SCR">2.</a>&nbsp;
RFC 4306 Crash Recovery<br />
<a href="#outline">3.</a>&nbsp;
Protocol Outline<br />
<a href="#format">4.</a>&nbsp;
Formats and Exchanges<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#format_notif">4.1.</a>&nbsp;
Notification Format<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#format_auth">4.2.</a>&nbsp;
Authentication Exchange<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#format_info">4.3.</a>&nbsp;
Informational Exchange<br />
<a href="#tokengen">5.</a>&nbsp;
Token Generation and Verification<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tg1">5.1.</a>&nbsp;
A Stateful Method of Token Generation<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tg2">5.2.</a>&nbsp;
A Stateless Method of Token Generation<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#toklifetime">5.3.</a>&nbsp;
Token Lifetime<br />
<a href="#backupgw">6.</a>&nbsp;
Backup Gateways<br />
<a href="#whynot">7.</a>&nbsp;
Alternative Solutions<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#saveikesa">7.1.</a>&nbsp;
Why not Save the Entire IKE SA<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#newikesa">7.2.</a>&nbsp;
Initiating a new IKE SA<br />
<a href="#int_resume">8.</a>&nbsp;
Interaction with IFARE<br />
<a href="#operation">9.</a>&nbsp;
Operational Considerations<br />
<a href="#security">10.</a>&nbsp;
Security Considerations<br />
<a href="#iana">11.</a>&nbsp;
IANA Considerations<br />
<a href="#ack">12.</a>&nbsp;
Acknowledgements<br />
<a href="#history">13.</a>&nbsp;
Change Log<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#history01">13.1.</a>&nbsp;
Changes from draft-nir-qcr-00<br />
<a href="#rfc.references1">14.</a>&nbsp;
References<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#rfc.references1">14.1.</a>&nbsp;
Normative References<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#rfc.references2">14.2.</a>&nbsp;
Informative References<br />
<a href="#rfc.authors">&#167;</a>&nbsp;
Author's Address<br />
<a href="#rfc.copyright">&#167;</a>&nbsp;
Intellectual Property and Copyright Statements<br />
</p>
<br clear="all" />

<a name="introduction"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1"></a><h3>1.&nbsp;
Introduction</h3>

<p> IKEv2, as described in <a class='info' href='#RFC4306'>[RFC4306]<span> (</span><span class='info'>Kaufman, C., &ldquo;Internet Key Exchange (IKEv2) Protocol,&rdquo; December&nbsp;2005.</span><span>)</span></a> has a method for recovering from a reboot
        of one peer. As long as traffic flows in both directions, the rebooted peer should 
        re-establish the tunnels immediately. However, in many cases the rebooted peer is a VPN
        gateway that protects only servers, or else the non-rebooted peer has a dynamic IP address. 
        In such cases, the rebooted peer will not re-establish the tunnels.
</p>
<p> <a class='info' href='#SCR'>Section&nbsp;2<span> (</span><span class='info'>RFC 4306 Crash Recovery</span><span>)</span></a> describes the current procedure, and explains why crash recovery can
        take up to several minutes. The method proposed here, is to send a token in the IKE_AUTH
        exchange that establishes the tunnel. That token can be maintained on the peer in some kind 
        of persistent storage such as a disk or a database, and can be used to delete the IKE SA
        on the non-rebooted peer after a crash. Deleting the IKE SA results is a quick 
        re-establishment of the IPsec tunnel.
</p>
<a name="mustshouldmay"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1.1"></a><h3>1.1.&nbsp;
Conventions Used in This Document</h3>

<p>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT",
          "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described
          in <a class='info' href='#RFC2119'>[RFC2119]<span> (</span><span class='info'>Bradner, S., &ldquo;Key words for use in RFCs to Indicate Requirement Levels,&rdquo; March&nbsp;1997.</span><span>)</span></a>.
</p>
<a name="SCR"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2"></a><h3>2.&nbsp;
RFC 4306 Crash Recovery</h3>

<p> When one peer reboots, the other peer does not get any notification, so IPsec traffic
          can still flow. The rebooted peer will not be able to decrypt it, however, and the only
          remedy is to send an unprotected INVALID_SPI notification as described in section 3.10.1 
          of <a class='info' href='#RFC4306'>[RFC4306]<span> (</span><span class='info'>Kaufman, C., &ldquo;Internet Key Exchange (IKEv2) Protocol,&rdquo; December&nbsp;2005.</span><span>)</span></a>.  That section also describes the processing of such a 
          notification: "If this Informational Message is sent outside the context of an IKE_SA, 
          it should be used by the recipient only as a "hint" that something might be wrong (because 
          it could easily be forged)."
</p>
<p> Since the INVALID_SPI can only be used as a hint, the non-rebooted peer has to determine
          whether the IPsec SA, and indeed the parent IKE SA are still valid.  The method of doing 
          this is described in section 2.4 of <a class='info' href='#RFC4306'>[RFC4306]<span> (</span><span class='info'>Kaufman, C., &ldquo;Internet Key Exchange (IKEv2) Protocol,&rdquo; December&nbsp;2005.</span><span>)</span></a>. This method, called 
          "liveness check" involves sending a protected empty INFORMATIONAL message, and awaiting a 
          response. This procedure is sometimes referred to as "Dead Peer Detection" or DPD.
</p>
<p> Section 2.4 does not mandate how many times the INFORMATIONAL message should be 
          retransmitted, or for how long, but does recommend the following: "It is suggested that
          messages be retransmitted at least a dozen times over a period of at least several minutes
          before giving up on an SA". Clearly, implementations differ, but all will take a significant
          amount of time.
</p>
<a name="outline"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3"></a><h3>3.&nbsp;
Protocol Outline</h3>

<p> Supporting implementations will send a notification, called a "QCD token", as described
          in <a class='info' href='#format_notif'>Section&nbsp;4.1<span> (</span><span class='info'>Notification Format</span><span>)</span></a> in the last packets of the IKE_AUTH exchange.  
          These are the final request and final response that contain the AUTH payloads.  The 
          generation of these tokens is a local matter for implementations, but considerations are 
          described in <a class='info' href='#tokengen'>Section&nbsp;5<span> (</span><span class='info'>Token Generation and Verification</span><span>)</span></a>. Implementations that send such a token will be
          called "token makers".
</p>
<p> A supporting implementation receiving such a token SHOULD store it in such a way, that
          it will survive a reboot. If the implementation is part of a configuration where there is
          a backup gateway as described in <a class='info' href='#backupgw'>Section&nbsp;6<span> (</span><span class='info'>Backup Gateways</span><span>)</span></a> (such configurations are often
          referred to as high-availability), then the persistent storage module SHOULD be accessible to
          all implementations within the configuration. An implementation supporting this part of
          the protocol will be called "token taker".
</p>
<p> When a token taker receives a protected IKE request message with unknown IKE SPIs, it 
          MUST scan its saved token store. If a token matching the IKE SPIs is found, it SHOULD be 
          sent to the requesting peer in an unprotected IKE message as described in 
          <a class='info' href='#format_info'>Section&nbsp;4.3<span> (</span><span class='info'>Informational Exchange</span><span>)</span></a>.
</p>
<p> When a token maker receives the QCD token in an unprotected notification, it MUST verify 
          that the TOKEN_SECRET_DATA field is associated with the IKE SPIs in the IKE_SPI fields 
          of the IKE packet. If the verification fails, it SHOULD log the event. If it succeeds, 
          it MUST delete the IKE SA associated with the IKE_SPI fields, and all dependant child SAs. 
          This event MAY also be logged. The token maker MUST accept such tokens from any address,
          so as to allow different kinds of high-availability configuration of the token taker.
</p>
<p> A supporting implementation MAY immediately create new SAs using an Initial exchange, 
          or it may wait for subsequent traffic to trigger the creation of new SAs.
</p>
<p> There is ongoing work on IKEv2 Session Resumption <a class='info' href='#resumption'>[resumption]<span> (</span><span class='info'>Sheffer, Y., Tschofenig, H., Dondeti, L., and V. Narayanan, &ldquo;IPsec Gateway Failover Protocol,&rdquo; March&nbsp;2008.</span><span>)</span></a>. See 
          <a class='info' href='#int_resume'>Section&nbsp;8<span> (</span><span class='info'>Interaction with IFARE</span><span>)</span></a> for a short discussion about this protocol's interaction with
          session resumption.
</p>
<a name="format"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4"></a><h3>4.&nbsp;
Formats and Exchanges</h3>

<a name="format_notif"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.1"></a><h3>4.1.&nbsp;
Notification Format</h3>

<p> The notification payload called "QCD token" is formatted as follows:</p>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
                           1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      ! Next Payload  !C!  RESERVED   !         Payload Length        !
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      !  Protocol ID  !   SPI Size    ! QCD Token Notify Message Type !
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      !                                                               !
      ~                       TOKEN_SECRET_DATA                       ~
      !                                                               !
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre></div><p>

</p>
<p></p>
<ul class="text">
<li>Protocol ID (1 octet) MUST contain 1, as this message is related to an IKE SA.
</li>
<li>SPI Size (1 octet) MUST be zero, in conformance with <a class='info' href='#RFC4306'>[RFC4306]<span> (</span><span class='info'>Kaufman, C., &ldquo;Internet Key Exchange (IKEv2) Protocol,&rdquo; December&nbsp;2005.</span><span>)</span></a>.
</li>
<li>QCD Token Notify Message Type (2 octets) - Must be xxxxx, the value assigned for QCD
              token notifications. TBA by IANA.
</li>
<li>TOKEN_SECRET_DATA (16-256 octets) contains a generated token as described in 
              <a class='info' href='#tokengen'>Section&nbsp;5<span> (</span><span class='info'>Token Generation and Verification</span><span>)</span></a>.
</li>
</ul>

<a name="format_auth"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.2"></a><h3>4.2.&nbsp;
Authentication Exchange</h3>

<p> For clarity, only the EAP version of an AUTH exchange will be presented here. The 
            non-EAP version is very similar. The figure below is based on appendix A.3 of
            <a class='info' href='#RFC4718'>[RFC4718]<span> (</span><span class='info'>Eronen, P. and P. Hoffman, &ldquo;IKEv2 Clarifications and Implementation Guidelines,&rdquo; October&nbsp;2006.</span><span>)</span></a>.</p>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
   first request       --&gt; IDi,
                           [N(INITIAL_CONTACT)],
                           [[N(HTTP_CERT_LOOKUP_SUPPORTED)], CERTREQ+],
                           [IDr],
                           [CP(CFG_REQUEST)],
                           [N(IPCOMP_SUPPORTED)+],
                           [N(USE_TRANSPORT_MODE)],
                           [N(ESP_TFC_PADDING_NOT_SUPPORTED)],
                           [N(NON_FIRST_FRAGMENTS_ALSO)],
                           SA, TSi, TSr,
                           [V+]

   first response      &lt;-- IDr, [CERT+], AUTH,
                           EAP,
                           [V+]

                     / --&gt; EAP
   repeat 1..N times |
                     \ &lt;-- EAP

   last request        --&gt; AUTH
                           [N(QCD_TOKEN)]

   last response       &lt;-- AUTH,
                           [N(QCD_TOKEN)]
                           [CP(CFG_REPLY)],
                           [N(IPCOMP_SUPPORTED)],
                           [N(USE_TRANSPORT_MODE)],
                           [N(ESP_TFC_PADDING_NOT_SUPPORTED)],
                           [N(NON_FIRST_FRAGMENTS_ALSO)],
                           SA, TSi, TSr,
                           [N(ADDITIONAL_TS_POSSIBLE)],
                           [V+]
</pre></div><p>

</p>
<p> Note that the QCD_TOKEN notification is marked as optional because it is not required
            by this specification that every implementation be both token maker and token taker. 
            If only one peer sends the QCD token, then a reboot of the other peer will not be 
            recoverable by this method. This may be acceptable if traffic typically originates from 
            the other peer.
</p>
<p> In any case, the lack of a QCD_TOKEN notification MUST NOT be taken as an indication
            that the peer does not support this standard. Conversely, if a peer does not understand 
            this notification, it will simply ignore it. Therefore a peer MAY send this notification 
            freely, even if it does not know whether the other side supports it.
</p>
<a name="format_info"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.3"></a><h3>4.3.&nbsp;
Informational Exchange</h3>

<p> This informational exchange is non-protected, and is sent as a response to a protected
            IKE request, which uses an IKE SA that is unknown. </p>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
            request             --&gt; N(QCD_TOKEN)

            response            &lt;--
</pre></div><p>

</p>
<p> The QCD_TOKEN is the only notification in the request. Similar to the description
            in section 2.21 of <a class='info' href='#RFC4306'>[RFC4306]<span> (</span><span class='info'>Kaufman, C., &ldquo;Internet Key Exchange (IKEv2) Protocol,&rdquo; December&nbsp;2005.</span><span>)</span></a>, The IKE SPI and message ID fields in the 
            packet headers are taken from the protected IKE request.
</p>
<p> If the QCD_TOKEN verifies OK, an empty response MUST be sent. If the QCD_TOKEN 
            cannot be validated, a response SHOULD NOT be sent. <a class='info' href='#tokengen'>Section&nbsp;5<span> (</span><span class='info'>Token Generation and Verification</span><span>)</span></a>
            defines token verification.
</p>
<a name="tokengen"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5"></a><h3>5.&nbsp;
Token Generation and Verification</h3>

<p> No token generation method is mandated by this document. Two methods are documented in
          <a class='info' href='#tg1'>Section&nbsp;5.1<span> (</span><span class='info'>A Stateful Method of Token Generation</span><span>)</span></a> and <a class='info' href='#tg2'>Section&nbsp;5.2<span> (</span><span class='info'>A Stateless Method of Token Generation</span><span>)</span></a>, but they only serve as examples.
</p>
<p> The following lists the requirements from a token generation mechanism:</p>
<ul class="text">
<li> Tokens should be at least 16 octets log, and no more than 256 octets long, to 
            facilitate storage.
</li>
<li> It should not be possible for an external attacker to guess the QCD token generated
            by an implementation. Cryptographic mechanisms such as PRNG and hash functions are
            RECOMMENDED.
</li>
<li> The peer that generated the QCD token, should be able to immediately verify it, 
            provided that the IKE SPIs are given, and that the IKE SA has not expired or been
            otherwise deleted.
</li>
</ul>

<a name="tg1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.1"></a><h3>5.1.&nbsp;
A Stateful Method of Token Generation</h3>

<p> This describes a stateful method of generating a token:</p>
<ul class="text">
<li> Before sending the QCD token, 32 random octets are generated using a secure random
              number generator or a PRNG.
</li>
<li> Those 32 bytes are used as the TOKEN_SECRET_DATA field, and stored as part of the
              IKE SA.
</li>
<li> For verification, the IKE implementation simply retrieves the IKE SA, and compares
              the TOKEN_SECRET_DATA field from the notification to the TOKEN_SECRET_DATA field
              stored with the SA.
</li>
</ul>

<a name="tg2"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.2"></a><h3>5.2.&nbsp;
A Stateless Method of Token Generation</h3>

<p> This describes a stateless method of generating a token.</p>
<ul class="text">
<li> At startup, the IKE implementation generates a 32-octet random buffer using a
              cryptographically secure PRNG. This buffer is called the QCD_SECRET.
</li>
<li> For each QCD token, the TOKEN_SECRET_DATA field is generated by calculating a 
              SHA-256 hash over a concatenation of the QCD_SECRET and the IKE SPI as follows:<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>

         TOKEN_SECRET_DATA = HASH(QCD_SECRET | SPI-I | SPI-R)

</pre></div>
</li>
<li> Verification uses the same calculation, and works even if the IKE SA has been
              deleted. Still, if the IKE SA is no longer valid, the notification MUST NOT be
              acknowledged, as this could be used in an attempt to guess the QCD_SECRET.
</li>
</ul>

<a name="toklifetime"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.3"></a><h3>5.3.&nbsp;
Token Lifetime</h3>

<p> The token is associated with a single IKE SA, and SHOULD be deleted when the SA is 
            deleted or expires. More formally, the token is associated with the pair (SPI-I, SPI-R).
</p>
<a name="backupgw"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6"></a><h3>6.&nbsp;
Backup Gateways</h3>

<p> Making crash recovery quick is important, but since rebooting a gateway takes a non-zero
          amount of time, many implementations choose to have a stand-by gateway ready to take over
          as soon as the primary gateway fails for any reason. 
</p>
<p> If such a configuration is available, it is RECOMMENDED that the persistent storage be
          shared between the primary and backup gateway. This has the effect of having the crash
          recovery available immediately. This recommendation is especially useful if the primary
          and backup gateway either share an external IP address or reside on the same LAN. If they
          are geographically remote, this may be less practical.
</p>
<a name="whynot"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7"></a><h3>7.&nbsp;
Alternative Solutions</h3>

<a name="saveikesa"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.1"></a><h3>7.1.&nbsp;
Why not Save the Entire IKE SA</h3>

<p> IKEv2 does not assume the existence of a persistent storage module. If we are adding
          such a module, why not use it to save the entire IKE SA across reboots, nullifying the
          need for a crash recovery procedure?
</p>
<p> There are several reasons why we believe that this is not a good idea:</p>
<ol class="text">
<li> A token is only 16-256 octets, and is much more compact than all the data
            needed to store an IKE SA.
</li>
<li> A token is valid for the life of an IKE SA. An IKE SA state is updated whenever a 
            message is sent, because of the requirement to maintain the sequence of message IDs. 
            It may not be acceptable to update the persistent storage whenever an IKE message is 
            sent.
</li>
<li> A reboot is usually an unpredictable event, and as such, we cannot know how long it
            will last. By the time the machine has rebooted, the peer may have attempted some type
            of protected exchange (liveness check, create-child-SA or delete), timed out, and deleted
            the SA. It is far better to reboot without SAs and with only a token for quick
            recovery.
</li>
</ol>

<a name="newikesa"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.2"></a><h3>7.2.&nbsp;
Initiating a new IKE SA</h3>

<p> Instead of sending a QCD token, we could have the rebooted implementation start an 
          Initial exchange with the peer, including the INITIAL_CONTACT notification. This would
          have the same effect, instructing the peer to erase the old IKE SA, as well as establishing
          a new IKE SA with fewer rounds.
</p>
<p> The disadvantage here, is that in IKEv2 an authentication exchange MUST have
          a piggy-backed Child SA set up. Since our use case is such that the rebooted implementation
          does not have traffic flowing to the peer, there are no good selectors for such a Child
          SA.
</p>
<p> Additionally, when authentication is asymmetric, such as when EAP is used, it is not 
          possible for the rebooted implementation to initiate IKE.
</p>
<a name="int_resume"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.8"></a><h3>8.&nbsp;
Interaction with IFARE</h3>

<p> IFARE, specified in <a class='info' href='#resumption'>[resumption]<span> (</span><span class='info'>Sheffer, Y., Tschofenig, H., Dondeti, L., and V. Narayanan, &ldquo;IPsec Gateway Failover Protocol,&rdquo; March&nbsp;2008.</span><span>)</span></a> proposes to make setting up a new IKE
          SA consume less computing resources. This is particularly useful in the case of a remote
          access gateway that has many tunnels. A failure of such a gateway would require all these
          many remote access clients to establish an IKE SA either with the rebooted gateway or
          with a backup gateway. This tunnel re-establishment should occur within a short period of
          time, creating a burden on the remote access gateway. IFARE addresses this problem by
          having the clients store an encrypted derivative of the IKE SA for quick re-establishment.
</p>
<p> What IFARE does not help, is the problem of detecting that the peer gateway has failed.
          A failed gateway may go undetected for an unbounded amount of time, because IPsec does 
          not have packet acknowledgement. Before establishing a new IKE SA using IFARE, a client
          MUST ascertain that the gateway has indeed failed. This could be done using either a 
          liveness check (as in RFC 4306) or using the QCD tokens described in this document.
</p>
<p> A remote access client conforming to both specifications will generate QCD tokens,
          and store the IFARE state, if provided by the gateway. A remote access gateway conforming 
          to both specifications will store the QCD token sent from the client. When the gateway
          reboots, the client will discover this in either of two ways:</p>
<ol class="text">
<li> The client does regular liveness checks, or else the time for some other IKE exchange
            has come. The IKE times out after several minutes, if the gateway does not finish 
            rebooting in time. In this case QCD does not help.
</li>
<li> Either the primary gateway or a backup gateway (see <a class='info' href='#backupgw'>Section&nbsp;6<span> (</span><span class='info'>Backup Gateways</span><span>)</span></a>) 
            is ready and sends a QCD token to the client. In that case the client will quickly
            re-establish the IPsec tunnel, either with the rebooted primary gateway, the backup
            gateway as described in this document or another gateway as described in <a class='info' href='#resumption'>[resumption]<span> (</span><span class='info'>Sheffer, Y., Tschofenig, H., Dondeti, L., and V. Narayanan, &ldquo;IPsec Gateway Failover Protocol,&rdquo; March&nbsp;2008.</span><span>)</span></a>
            
</li>
</ol>

<p> The full combined protocol looks like this:</p>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
     Initiator                Responder
     -----------              -----------
    HDR, SAi1, KEi, Ni  --&gt;

                        &lt;--    HDR, SAr1, KEr, Nr, [CERTREQ]

    HDR, SK {IDi, [CERT,]
    [CERTREQ,] [IDr,]
    AUTH, N(QCD_TOKEN)
    SAi2, TSi, TSr,
    N(TICKET_REQUEST)}  --&gt;
                        &lt;--    HDR, SK {IDr, [CERT,] AUTH, SAr2, TSi,
                               TSr, N(TICKET_OPAQUE)
                               [,N(TICKET_GATEWAY_LIST)]}

             ---- Reboot -----

    HDR, {}             --&gt;
                        &lt;--  HDR, N(QCD_Token)

    HDR, Ni, N(TICKET_OPAQUE),
    [N+,], SK {IDi, [IDr,]
    SAi2, TSi, TSr,
    [CP(CFG_REQUEST)]}  --&gt;
                        &lt;--  HDR, SK {IDr, Nr, SAr2, [TSi, TSr],
                             [CP(CFG_REPLY)]}


</pre></div><p>

</p>
<a name="operation"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.9"></a><h3>9.&nbsp;
Operational Considerations</h3>

<p> To support "token taker" part of this standard, an implementation needs to have access 
          to a persistent storage module. This could be an internal hard disk, a local or remote 
          database application, or any other method that persists across reboots. This storage 
          module and the data links between the storage module and the IKE module must meet the 
          performance requirements of the IKE module. The storage module MUST support insertion and 
          deletion rates equal to peek IKE SA setup rates and it SHOULD support query rates that are 
          fast enough.
</p>
<p> See <a class='info' href='#security'>Section&nbsp;10<span> (</span><span class='info'>Security Considerations</span><span>)</span></a> for security considerations for this storage mechanism.
</p>
<p> Throughout this document, we have referred to reboot time alternatingly as the time that 
          the implementation crashes and the time when it is ready to process IPsec packets and IKE 
          exchanges. Depending on the hardware and software platforms and the cause of the reboot, 
          rebooting may take anywhere from a few seconds to several minutes. If the implementation
          is down for a long time, the benefit of this protocol extension are reduced. For this reason
          critical systems should implement backup gateways as described in <a class='info' href='#backupgw'>Section&nbsp;6<span> (</span><span class='info'>Backup Gateways</span><span>)</span></a>.
          Note that the lower-case should in the previous sentence is intentional, as we do not specify
          this in the sense of RFC 2119.
</p>
<p> Implementing the "token taker" side of QCD makes sense for IKE implementation where protected
          connections originate from the peer, such as inter-domain VPNs and remote access gateways.
          Implementing the "token maker" side of QCD makes sense for IKE implementations where protected
          connections originate, such as inter-domain VPNs and remote access clients.
</p>
<p> To clarify the requirements: </p>
<ul class="text">
<li> A remote-access client MUST be a token maker and MAY be a token taker.
</li>
<li> A remote-access gateway MAY be a token maker and MUST be a token taker.
</li>
<li> An inter-domain VPN gateway MUST be both token maker and token taker.
</li>
</ul>

<p> In order to limit the effects of DoS attacks, an implementation SHOULD limit the rate
          of queries into the token storage so as not to overload it. If excessive amounts of IKE
          requests protected with unknown IKE SPIs arrive, the IKE module SHOULD revert to the 
          behavior described in section 2.21 of <a class='info' href='#RFC4306'>[RFC4306]<span> (</span><span class='info'>Kaufman, C., &ldquo;Internet Key Exchange (IKEv2) Protocol,&rdquo; December&nbsp;2005.</span><span>)</span></a> and either send an 
          INVALID_IKE_SPI notification, or ignore it entirely.
</p>
<a name="security"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.10"></a><h3>10.&nbsp;
Security Considerations</h3>

<p> Tokens MUST be hard to guess. This is critical, because if an attacker can guess the 
          token associated with the IKE SA, she can tear down the IKE SA and associated tunnels at
          will. When the token is delivered in the IKE_AUTH exchange, it is encrypted. When it is
          sent back in an informational exchange it is not encrypted, but that is the last use
          of that token.
</p>
<p> An aggregation of some tokens generated by one peer together with the related IKE SPIs
          MUST NOT give an attacker the ability to guess other tokens. Specifically, if one peer 
          does not properly secure the QCD tokens and an attacker gains access to them, this
          attacker MUST NOT be able to guess other tokens generated by the same peer. This is the
          reason that the QCD_SECRET in <a class='info' href='#tg2'>Section&nbsp;5.2<span> (</span><span class='info'>A Stateless Method of Token Generation</span><span>)</span></a> needs to be long.
</p>
<p> The persistent storage MUST be protected from access by other parties. Anyone gaining
          access to the contents of the storage will be able to delete all the IKE SAs described
          in it.
</p>
<p> The tokens associated with expired and deleted IKE SAs MUST be deleted from the storage,
          so that a future compromise of the storage does not reveal enough tokens to facilitate
          an attack against the QCD tokens.
</p>
<p> The QCD token is sent by the rebooted peer in an unprotected message. A message like 
          that is subject to modification, deletion and replay by an attacker. However, these 
          attacks will not compromise the security of either side. Modification is meaningless
          because a modified token is simply an invalid token. Deletion will only cause the 
          protocol not to work, resulting in a delay in tunnel re-establishment as described in
          <a class='info' href='#SCR'>Section&nbsp;2<span> (</span><span class='info'>RFC 4306 Crash Recovery</span><span>)</span></a>. Replay is also meaningless, because the IKE SA has been deleted
          after the first transmission.
</p>
<a name="iana"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.11"></a><h3>11.&nbsp;
IANA Considerations</h3>

<p> IANA is requested to assign a notify message type from the error types range
          (43-8191) of the "IKEv2 Notify Message Types" registry with name 
          "QUICK_CRASH_DETECTION".
</p>
<a name="ack"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.12"></a><h3>12.&nbsp;
Acknowledgements</h3>

<p> We would like to thank Hannes Tschofenig and Yaron Sheffer for their comments about
          IFARE.
</p>
<a name="history"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.13"></a><h3>13.&nbsp;
Change Log</h3>

<p> This section lists all changes in this document
</p>
<p> NOTE TO RFC EDITOR : Please remove this section in the final RFC
</p>
<a name="history01"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.13.1"></a><h3>13.1.&nbsp;
Changes from draft-nir-qcr-00</h3>

<p></p>
<ul class="text">
<li> Changed name to reflect that this relates to IKE. Also changed from quick crash 
              recovery to quick crash detection to avoid confusion with IFARE.
</li>
<li> Added more operational considerations. 
</li>
<li> Added interaction with IFARE.
</li>
<li> Added discussion of backup gateways.
</li>
</ul>

<a name="rfc.references"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.14"></a><h3>14.&nbsp;
References</h3>

<a name="rfc.references1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>14.1.&nbsp;Normative References</h3>
<table width="99%" border="0">
<tr><td class="author-text" valign="top"><a name="RFC2119">[RFC2119]</a></td>
<td class="author-text"><a href="mailto:sob@harvard.edu">Bradner, S.</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>,&rdquo; BCP&nbsp;14, RFC&nbsp;2119, March&nbsp;1997 (<a href="ftp://ftp.isi.edu/in-notes/rfc2119.txt">TXT</a>, <a href="http://xml.resource.org/public/rfc/html/rfc2119.html">HTML</a>, <a href="http://xml.resource.org/public/rfc/xml/rfc2119.xml">XML</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4306">[RFC4306]</a></td>
<td class="author-text">Kaufman, C., &ldquo;<a href="http://tools.ietf.org/html/rfc4306">Internet Key Exchange (IKEv2) Protocol</a>,&rdquo; RFC&nbsp;4306, December&nbsp;2005 (<a href="http://www.ietf.org/rfc/rfc4306.txt">TXT</a>, <a href="http://xml.resource.org/public/rfc/html/rfc4306.html">HTML</a>, <a href="http://xml.resource.org/public/rfc/xml/rfc4306.xml">XML</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4718">[RFC4718]</a></td>
<td class="author-text">Eronen, P. and P. Hoffman, &ldquo;<a href="http://tools.ietf.org/html/rfc4718">IKEv2 Clarifications and Implementation Guidelines</a>,&rdquo; RFC&nbsp;4718, October&nbsp;2006 (<a href="http://www.ietf.org/rfc/rfc4718.txt">TXT</a>, <a href="http://xml.resource.org/public/rfc/html/rfc4718.html">HTML</a>, <a href="http://xml.resource.org/public/rfc/xml/rfc4718.xml">XML</a>).</td></tr>
</table>

<a name="rfc.references2"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>14.2.&nbsp;Informative References</h3>
<table width="99%" border="0">
<tr><td class="author-text" valign="top"><a name="resumption">[resumption]</a></td>
<td class="author-text">Sheffer, Y., Tschofenig, H., Dondeti, L., and V. Narayanan, &ldquo;<a href="http://www.ietf.org/internet-drafts/draft-sheffer-ipsec-failover-03.txt">IPsec Gateway Failover Protocol</a>,&rdquo; draft-sheffer-ipsec-failover-03 (work in progress), March&nbsp;2008 (<a href="http://www.ietf.org/internet-drafts/draft-sheffer-ipsec-failover-03.txt">TXT</a>).</td></tr>
</table>

<a name="rfc.authors"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>Author's Address</h3>
<table width="99%" border="0" cellpadding="0" cellspacing="0">
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Yoav Nir</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Check Point Software Technologies Ltd.</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">5 Hasolelim st.</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Tel Aviv  67897</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Israel</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:ynir@checkpoint.com">ynir@checkpoint.com</a></td></tr>
</table>
<a name="rfc.copyright"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>Full Copyright Statement</h3>
<p class='copyright'>
Copyright &copy; The IETF Trust (2008).</p>
<p class='copyright'>
This document is subject to the rights,
licenses and restrictions contained in BCP&nbsp;78,
and except as set forth therein,
the authors retain all their rights.</p>
<p class='copyright'>
This document and the information contained herein are provided
on an &ldquo;AS IS&rdquo; basis and THE CONTRIBUTOR,
THE ORGANIZATION HE/SHE REPRESENTS
OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY, THE IETF TRUST
AND THE INTERNET ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT
THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY
IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR
PURPOSE.</p>
<h3>Intellectual Property</h3>
<p class='copyright'>
The IETF takes no position regarding the validity or scope of any
Intellectual Property Rights or other rights that might be claimed
to pertain to the implementation or use of the technology
described in this document or the extent to which any license
under such rights might or might not be available; nor does it
represent that it has made any independent effort to identify any
such rights.
Information on the procedures with respect to
rights in RFC documents can be found in BCP&nbsp;78 and BCP&nbsp;79.</p>
<p class='copyright'>
Copies of IPR disclosures made to the IETF Secretariat and any
assurances of licenses to be made available,
or the result of an attempt made to obtain a general license or
permission for the use of such proprietary rights by implementers or
users of this specification can be obtained from the IETF on-line IPR
repository at <a href='http://www.ietf.org/ipr'>http://www.ietf.org/ipr</a>.</p>
<p class='copyright'>
The IETF invites any interested party to bring to its attention
any copyrights,
patents or patent applications,
or other
proprietary rights that may cover technology that may be required
to implement this standard.
Please address the information to the IETF at <a href='mailto:ietf-ipr@ietf.org'>ietf-ipr@ietf.org</a>.</p>
</body></html>
