<!DOCTYPE html>
<html lang="en" class="Internet-Draft">
<head>
<meta charset="utf-8">
<meta content="Common,Latin" name="scripts">
<meta content="initial-scale=1.0" name="viewport">
<title>Segment Routed Time Sensitive Networking</title>
<meta content="Yaakov (J) Stein" name="author">
<meta content="
       Routers perform two distinct user-plane functionalities,
namely forwarding (where the packet should be sent) and scheduling (when the packet should be sent).
One forwarding paradigm is segment routing,
in which forwarding instructions are encoded in the packet in a stack data structure,
rather than programmed into the routers.
Time Sensitive Networking and Deterministic Networking provide several mechanisms for scheduling
under the assumption that routers are time synchronized.
The most effective mechanisms for delay minimization involve per-flow resource allocation. 
       SRTSN is a unified approach to forwarding and scheduling that uses a single stack data structure.
Each stack entry consists of a forwarding portion (e.g., IP addresses or suffixes)
and a scheduling portion (deadline by which the packet must exit the router).
SRTSN thus fully implements network programming for time sensitive flows, 
by prescribing to each router both to-where and by-when each packet should be sent. 
    " name="description">
<meta content="xml2rfc 3.9.1" name="generator">
<meta content="draft-stein-srtsn-01" name="ietf.draft">
<!-- Generator version information:
  xml2rfc 3.9.1
    Python 3.6.12
    appdirs 1.4.4
    ConfigArgParse 1.5.1
    google-i18n-address 2.5.0
    html5lib 1.1
    intervaltree 3.1.0
    Jinja2 2.11.3
    kitchen 1.2.6
    lxml 4.6.3
    pycountry 20.7.3
    pyflakes 2.3.1
    PyYAML 5.4.1
    requests 2.26.0
    setuptools 57.4.0
    six 1.16.0
-->
<link href="/tmp/draft-stein-srtsn-01-459vqjms.xml" rel="alternate" type="application/rfc+xml">
<link href="#copyright" rel="license">
<style type="text/css">/*

  NOTE: Changes at the bottom of this file overrides some earlier settings.

  Once the style has stabilized and has been adopted as an official RFC style,
  this can be consolidated so that style settings occur only in one place, but
  for now the contents of this file consists first of the initial CSS work as
  provided to the RFC Formatter (xml2rfc) work, followed by itemized and
  commented changes found necssary during the development of the v3
  formatters.

*/

/* fonts */
@import url('https://fonts.googleapis.com/css?family=Noto+Sans'); /* Sans-serif */
@import url('https://fonts.googleapis.com/css?family=Noto+Serif'); /* Serif (print) */
@import url('https://fonts.googleapis.com/css?family=Roboto+Mono'); /* Monospace */

@viewport {
  zoom: 1.0;
  width: extend-to-zoom;
}
@-ms-viewport {
  width: extend-to-zoom;
  zoom: 1.0;
}
/* general and mobile first */
html {
}
body {
  max-width: 90%;
  margin: 1.5em auto;
  color: #222;
  background-color: #fff;
  font-size: 14px;
  font-family: 'Noto Sans', Arial, Helvetica, sans-serif;
  line-height: 1.6;
  scroll-behavior: smooth;
}
.ears {
  display: none;
}

/* headings */
#title, h1, h2, h3, h4, h5, h6 {
  margin: 1em 0 0.5em;
  font-weight: bold;
  line-height: 1.3;
}
#title {
  clear: both;
  border-bottom: 1px solid #ddd;
  margin: 0 0 0.5em 0;
  padding: 1em 0 0.5em;
}
.author {
  padding-bottom: 4px;
}
h1 {
  font-size: 26px;
  margin: 1em 0;
}
h2 {
  font-size: 22px;
  margin-top: -20px;  /* provide offset for in-page anchors */
  padding-top: 33px;
}
h3 {
  font-size: 18px;
  margin-top: -36px;  /* provide offset for in-page anchors */
  padding-top: 42px;
}
h4 {
  font-size: 16px;
  margin-top: -36px;  /* provide offset for in-page anchors */
  padding-top: 42px;
}
h5, h6 {
  font-size: 14px;
}
#n-copyright-notice {
  border-bottom: 1px solid #ddd;
  padding-bottom: 1em;
  margin-bottom: 1em;
}
/* general structure */
p {
  padding: 0;
  margin: 0 0 1em 0;
  text-align: left;
}
div, span {
  position: relative;
}
div {
  margin: 0;
}
.alignRight.art-text {
  background-color: #f9f9f9;
  border: 1px solid #eee;
  border-radius: 3px;
  padding: 1em 1em 0;
  margin-bottom: 1.5em;
}
.alignRight.art-text pre {
  padding: 0;
}
.alignRight {
  margin: 1em 0;
}
.alignRight > *:first-child {
  border: none;
  margin: 0;
  float: right;
  clear: both;
}
.alignRight > *:nth-child(2) {
  clear: both;
  display: block;
  border: none;
}
svg {
  display: block;
}
.alignCenter.art-text {
  background-color: #f9f9f9;
  border: 1px solid #eee;
  border-radius: 3px;
  padding: 1em 1em 0;
  margin-bottom: 1.5em;
}
.alignCenter.art-text pre {
  padding: 0;
}
.alignCenter {
  margin: 1em 0;
}
.alignCenter > *:first-child {
  border: none;
  /* this isn't optimal, but it's an existence proof.  PrinceXML doesn't
     support flexbox yet.
  */
  display: table;
  margin: 0 auto;
}

/* lists */
ol, ul {
  padding: 0;
  margin: 0 0 1em 2em;
}
ol ol, ul ul, ol ul, ul ol {
  margin-left: 1em;
}
li {
  margin: 0 0 0.25em 0;
}
.ulCompact li {
  margin: 0;
}
ul.empty, .ulEmpty {
  list-style-type: none;
}
ul.empty li, .ulEmpty li {
  margin-top: 0.5em;
}
ul.ulBare, li.ulBare {
  margin-left: 0em !important;
}
ul.compact, .ulCompact,
ol.compact, .olCompact {
  line-height: 100%;
  margin: 0 0 0 2em;
}

/* definition lists */
dl {
}
dl > dt {
  float: left;
  margin-right: 1em;
}
/* 
dl.nohang > dt {
  float: none;
}
*/
dl > dd {
  margin-bottom: .8em;
  min-height: 1.3em;
}
dl.compact > dd, .dlCompact > dd {
  margin-bottom: 0em;
}
dl > dd > dl {
  margin-top: 0.5em;
  margin-bottom: 0em;
}

/* links */
a {
  text-decoration: none;
}
a[href] {
  color: #22e; /* Arlen: WCAG 2019 */
}
a[href]:hover {
  background-color: #f2f2f2;
}
figcaption a[href],
a[href].selfRef {
  color: #222;
}
/* XXX probably not this:
a.selfRef:hover {
  background-color: transparent;
  cursor: default;
} */

/* Figures */
tt, code, pre, code {
  background-color: #f9f9f9;
  font-family: 'Roboto Mono', monospace;
}
pre {
  border: 1px solid #eee;
  margin: 0;
  padding: 1em;
}
img {
  max-width: 100%;
}
figure {
  margin: 0;
}
figure blockquote {
  margin: 0.8em 0.4em 0.4em;
}
figcaption {
  font-style: italic;
  margin: 0 0 1em 0;
}
@media screen {
  pre {
    overflow-x: auto;
    max-width: 100%;
    max-width: calc(100% - 22px);
  }
}

/* aside, blockquote */
aside, blockquote {
  margin-left: 0;
  padding: 1.2em 2em;
}
blockquote {
  background-color: #f9f9f9;
  color: #111; /* Arlen: WCAG 2019 */
  border: 1px solid #ddd;
  border-radius: 3px;
  margin: 1em 0;
}
cite {
  display: block;
  text-align: right;
  font-style: italic;
}

/* tables */
table {
  width: 100%;
  margin: 0 0 1em;
  border-collapse: collapse;
  border: 1px solid #eee;
}
th, td {
  text-align: left;
  vertical-align: top;
  padding: 0.5em 0.75em;
}
th {
  text-align: left;
  background-color: #e9e9e9;
}
tr:nth-child(2n+1) > td {
  background-color: #f5f5f5;
}
table caption {
  font-style: italic;
  margin: 0;
  padding: 0;
  text-align: left;
}
table p {
  /* XXX to avoid bottom margin on table row signifiers. If paragraphs should
     be allowed within tables more generally, it would be far better to select on a class. */
  margin: 0;
}

/* pilcrow */
a.pilcrow {
  color: #666; /* Arlen: AHDJ 2019 */
  text-decoration: none;
  visibility: hidden;
  user-select: none;
  -ms-user-select: none;
  -o-user-select:none;
  -moz-user-select: none;
  -khtml-user-select: none;
  -webkit-user-select: none;
  -webkit-touch-callout: none;
}
@media screen {
  aside:hover > a.pilcrow,
  p:hover > a.pilcrow,
  blockquote:hover > a.pilcrow,
  div:hover > a.pilcrow,
  li:hover > a.pilcrow,
  pre:hover > a.pilcrow {
    visibility: visible;
  }
  a.pilcrow:hover {
    background-color: transparent;
  }
}

/* misc */
hr {
  border: 0;
  border-top: 1px solid #eee;
}
.bcp14 {
  font-variant: small-caps;
}

.role {
  font-variant: all-small-caps;
}

/* info block */
#identifiers {
  margin: 0;
  font-size: 0.9em;
}
#identifiers dt {
  width: 3em;
  clear: left;
}
#identifiers dd {
  float: left;
  margin-bottom: 0;
}
#identifiers .authors .author {
  display: inline-block;
  margin-right: 1.5em;
}
#identifiers .authors .org {
  font-style: italic;
}

/* The prepared/rendered info at the very bottom of the page */
.docInfo {
  color: #666; /* Arlen: WCAG 2019 */
  font-size: 0.9em;
  font-style: italic;
  margin-top: 2em;
}
.docInfo .prepared {
  float: left;
}
.docInfo .prepared {
  float: right;
}

/* table of contents */
#toc  {
  padding: 0.75em 0 2em 0;
  margin-bottom: 1em;
}
nav.toc ul {
  margin: 0 0.5em 0 0;
  padding: 0;
  list-style: none;
}
nav.toc li {
  line-height: 1.3em;
  margin: 0.75em 0;
  padding-left: 1.2em;
  text-indent: -1.2em;
}
/* references */
.references dt {
  text-align: right;
  font-weight: bold;
  min-width: 7em;
}
.references dd {
  margin-left: 8em;
  overflow: auto;
}

.refInstance {
  margin-bottom: 1.25em;
}

.references .ascii {
  margin-bottom: 0.25em;
}

/* index */
.index ul {
  margin: 0 0 0 1em;
  padding: 0;
  list-style: none;
}
.index ul ul {
  margin: 0;
}
.index li {
  margin: 0;
  text-indent: -2em;
  padding-left: 2em;
  padding-bottom: 5px;
}
.indexIndex {
  margin: 0.5em 0 1em;
}
.index a {
  font-weight: 700;
}
/* make the index two-column on all but the smallest screens */
@media (min-width: 600px) {
  .index ul {
    -moz-column-count: 2;
    -moz-column-gap: 20px;
  }
  .index ul ul {
    -moz-column-count: 1;
    -moz-column-gap: 0;
  }
}

/* authors */
address.vcard {
  font-style: normal;
  margin: 1em 0;
}

address.vcard .nameRole {
  font-weight: 700;
  margin-left: 0;
}
address.vcard .label {
  font-family: "Noto Sans",Arial,Helvetica,sans-serif;
  margin: 0.5em 0;
}
address.vcard .type {
  display: none;
}
.alternative-contact {
  margin: 1.5em 0 1em;
}
hr.addr {
  border-top: 1px dashed;
  margin: 0;
  color: #ddd;
  max-width: calc(100% - 16px);
}

/* temporary notes */
.rfcEditorRemove::before {
  position: absolute;
  top: 0.2em;
  right: 0.2em;
  padding: 0.2em;
  content: "The RFC Editor will remove this note";
  color: #9e2a00; /* Arlen: WCAG 2019 */
  background-color: #ffd; /* Arlen: WCAG 2019 */
}
.rfcEditorRemove {
  position: relative;
  padding-top: 1.8em;
  background-color: #ffd; /* Arlen: WCAG 2019 */
  border-radius: 3px;
}
.cref {
  background-color: #ffd; /* Arlen: WCAG 2019 */
  padding: 2px 4px;
}
.crefSource {
  font-style: italic;
}
/* alternative layout for smaller screens */
@media screen and (max-width: 1023px) {
  body {
    padding-top: 2em;
  }
  #title {
    padding: 1em 0;
  }
  h1 {
    font-size: 24px;
  }
  h2 {
    font-size: 20px;
    margin-top: -18px;  /* provide offset for in-page anchors */
    padding-top: 38px;
  }
  #identifiers dd {
    max-width: 60%;
  }
  #toc {
    position: fixed;
    z-index: 2;
    top: 0;
    right: 0;
    padding: 0;
    margin: 0;
    background-color: inherit;
    border-bottom: 1px solid #ccc;
  }
  #toc h2 {
    margin: -1px 0 0 0;
    padding: 4px 0 4px 6px;
    padding-right: 1em;
    min-width: 190px;
    font-size: 1.1em;
    text-align: right;
    background-color: #444;
    color: white;
    cursor: pointer;
  }
  #toc h2::before { /* css hamburger */
    float: right;
    position: relative;
    width: 1em;
    height: 1px;
    left: -164px;
    margin: 6px 0 0 0;
    background: white none repeat scroll 0 0;
    box-shadow: 0 4px 0 0 white, 0 8px 0 0 white;
    content: "";
  }
  #toc nav {
    display: none;
    padding: 0.5em 1em 1em;
    overflow: auto;
    height: calc(100vh - 48px);
    border-left: 1px solid #ddd;
  }
}

/* alternative layout for wide screens */
@media screen and (min-width: 1024px) {
  body {
    max-width: 724px;
    margin: 42px auto;
    padding-left: 1.5em;
    padding-right: 29em;
  }
  #toc {
    position: fixed;
    top: 42px;
    right: 42px;
    width: 25%;
    margin: 0;
    padding: 0 1em;
    z-index: 1;
  }
  #toc h2 {
    border-top: none;
    border-bottom: 1px solid #ddd;
    font-size: 1em;
    font-weight: normal;
    margin: 0;
    padding: 0.25em 1em 1em 0;
  }
  #toc nav {
    display: block;
    height: calc(90vh - 84px);
    bottom: 0;
    padding: 0.5em 0 0;
    overflow: auto;
  }
  img { /* future proofing */
    max-width: 100%;
    height: auto;
  }
}

/* pagination */
@media print {
  body {

    width: 100%;
  }
  p {
    orphans: 3;
    widows: 3;
  }
  #n-copyright-notice {
    border-bottom: none;
  }
  #toc, #n-introduction {
    page-break-before: always;
  }
  #toc {
    border-top: none;
    padding-top: 0;
  }
  figure, pre {
    page-break-inside: avoid;
  }
  figure {
    overflow: scroll;
  }
  h1, h2, h3, h4, h5, h6 {
    page-break-after: avoid;
  }
  h2+*, h3+*, h4+*, h5+*, h6+* {
    page-break-before: avoid;
  }
  pre {
    white-space: pre-wrap;
    word-wrap: break-word;
    font-size: 10pt;
  }
  table {
    border: 1px solid #ddd;
  }
  td {
    border-top: 1px solid #ddd;
  }
}

/* This is commented out here, as the string-set: doesn't
   pass W3C validation currently */
/*
.ears thead .left {
  string-set: ears-top-left content();
}

.ears thead .center {
  string-set: ears-top-center content();
}

.ears thead .right {
  string-set: ears-top-right content();
}

.ears tfoot .left {
  string-set: ears-bottom-left content();
}

.ears tfoot .center {
  string-set: ears-bottom-center content();
}

.ears tfoot .right {
  string-set: ears-bottom-right content();
}
*/

@page :first {
  padding-top: 0;
  @top-left {
    content: normal;
    border: none;
  }
  @top-center {
    content: normal;
    border: none;
  }
  @top-right {
    content: normal;
    border: none;
  }
}

@page {
  size: A4;
  margin-bottom: 45mm;
  padding-top: 20px;
  /* The follwing is commented out here, but set appropriately by in code, as
     the content depends on the document */
  /*
  @top-left {
    content: 'Internet-Draft';
    vertical-align: bottom;
    border-bottom: solid 1px #ccc;
  }
  @top-left {
    content: string(ears-top-left);
    vertical-align: bottom;
    border-bottom: solid 1px #ccc;
  }
  @top-center {
    content: string(ears-top-center);
    vertical-align: bottom;
    border-bottom: solid 1px #ccc;
  }
  @top-right {
    content: string(ears-top-right);
    vertical-align: bottom;
    border-bottom: solid 1px #ccc;
  }
  @bottom-left {
    content: string(ears-bottom-left);
    vertical-align: top;
    border-top: solid 1px #ccc;
  }
  @bottom-center {
    content: string(ears-bottom-center);
    vertical-align: top;
    border-top: solid 1px #ccc;
  }
  @bottom-right {
      content: '[Page ' counter(page) ']';
      vertical-align: top;
      border-top: solid 1px #ccc;
  }
  */

}

/* Changes introduced to fix issues found during implementation */
/* Make sure links are clickable even if overlapped by following H* */
a {
  z-index: 2;
}
/* Separate body from document info even without intervening H1 */
section {
  clear: both;
}


/* Top align author divs, to avoid names without organization dropping level with org names */
.author {
  vertical-align: top;
}

/* Leave room in document info to show Internet-Draft on one line */
#identifiers dt {
  width: 8em;
}

/* Don't waste quite as much whitespace between label and value in doc info */
#identifiers dd {
  margin-left: 1em;
}

/* Give floating toc a background color (needed when it's a div inside section */
#toc {
  background-color: white;
}

/* Make the collapsed ToC header render white on gray also when it's a link */
@media screen and (max-width: 1023px) {
  #toc h2 a,
  #toc h2 a:link,
  #toc h2 a:focus,
  #toc h2 a:hover,
  #toc a.toplink,
  #toc a.toplink:hover {
    color: white;
    background-color: #444;
    text-decoration: none;
  }
}

/* Give the bottom of the ToC some whitespace */
@media screen and (min-width: 1024px) {
  #toc {
    padding: 0 0 1em 1em;
  }
}

/* Style section numbers with more space between number and title */
.section-number {
  padding-right: 0.5em;
}

/* prevent monospace from becoming overly large */
tt, code, pre, code {
  font-size: 95%;
}

/* Fix the height/width aspect for ascii art*/
pre.sourcecode,
.art-text pre {
  line-height: 1.12;
}


/* Add styling for a link in the ToC that points to the top of the document */
a.toplink {
  float: right;
  margin-right: 0.5em;
}

/* Fix the dl styling to match the RFC 7992 attributes */
dl > dt,
dl.dlParallel > dt {
  float: left;
  margin-right: 1em;
}
dl.dlNewline > dt {
  float: none;
}

/* Provide styling for table cell text alignment */
table td.text-left,
table th.text-left {
  text-align: left;
}
table td.text-center,
table th.text-center {
  text-align: center;
}
table td.text-right,
table th.text-right {
  text-align: right;
}

/* Make the alternative author contact informatio look less like just another
   author, and group it closer with the primary author contact information */
.alternative-contact {
  margin: 0.5em 0 0.25em 0;
}
address .non-ascii {
  margin: 0 0 0 2em;
}

/* With it being possible to set tables with alignment
  left, center, and right, { width: 100%; } does not make sense */
table {
  width: auto;
}

/* Avoid reference text that sits in a block with very wide left margin,
   because of a long floating dt label.*/
.references dd {
  overflow: visible;
}

/* Control caption placement */
caption {
  caption-side: bottom;
}

/* Limit the width of the author address vcard, so names in right-to-left
   script don't end up on the other side of the page. */

address.vcard {
  max-width: 30em;
  margin-right: auto;
}

/* For address alignment dependent on LTR or RTL scripts */
address div.left {
  text-align: left;
}
address div.right {
  text-align: right;
}

/* Provide table alignment support.  We can't use the alignX classes above
   since they do unwanted things with caption and other styling. */
table.right {
 margin-left: auto;
 margin-right: 0;
}
table.center {
 margin-left: auto;
 margin-right: auto;
}
table.left {
 margin-left: 0;
 margin-right: auto;
}

/* Give the table caption label the same styling as the figcaption */
caption a[href] {
  color: #222;
}

@media print {
  .toplink {
    display: none;
  }

  /* avoid overwriting the top border line with the ToC header */
  #toc {
    padding-top: 1px;
  }

  /* Avoid page breaks inside dl and author address entries */
  .vcard {
    page-break-inside: avoid;
  }

}
/* Tweak the bcp14 keyword presentation */
.bcp14 {
  font-variant: small-caps;
  font-weight: bold;
  font-size: 0.9em;
}
/* Tweak the invisible space above H* in order not to overlay links in text above */
 h2 {
  margin-top: -18px;  /* provide offset for in-page anchors */
  padding-top: 31px;
 }
 h3 {
  margin-top: -18px;  /* provide offset for in-page anchors */
  padding-top: 24px;
 }
 h4 {
  margin-top: -18px;  /* provide offset for in-page anchors */
  padding-top: 24px;
 }
/* Float artwork pilcrow to the right */
@media screen {
  .artwork a.pilcrow {
    display: block;
    line-height: 0.7;
    margin-top: 0.15em;
  }
}
/* Make pilcrows on dd visible */
@media screen {
  dd:hover > a.pilcrow {
    visibility: visible;
  }
}
/* Make the placement of figcaption match that of a table's caption
   by removing the figure's added bottom margin */
.alignLeft.art-text,
.alignCenter.art-text,
.alignRight.art-text {
   margin-bottom: 0;
}
.alignLeft,
.alignCenter,
.alignRight {
  margin: 1em 0 0 0;
}
/* In print, the pilcrow won't show on hover, so prevent it from taking up space,
   possibly even requiring a new line */
@media print {
  a.pilcrow {
    display: none;
  }
}
/* Styling for the external metadata */
div#external-metadata {
  background-color: #eee;
  padding: 0.5em;
  margin-bottom: 0.5em;
  display: none;
}
div#internal-metadata {
  padding: 0.5em;                       /* to match the external-metadata padding */
}
/* Styling for title RFC Number */
h1#rfcnum {
  clear: both;
  margin: 0 0 -1em;
  padding: 1em 0 0 0;
}
/* Make .olPercent look the same as <ol><li> */
dl.olPercent > dd {
  margin-bottom: 0.25em;
  min-height: initial;
}
/* Give aside some styling to set it apart */
aside {
  border-left: 1px solid #ddd;
  margin: 1em 0 1em 2em;
  padding: 0.2em 2em;
}
aside > dl,
aside > ol,
aside > ul,
aside > table,
aside > p {
  margin-bottom: 0.5em;
}
/* Additional page break settings */
@media print {
  figcaption, table caption {
    page-break-before: avoid;
  }
}
/* Font size adjustments for print */
@media print {
  body  { font-size: 10pt;      line-height: normal; max-width: 96%; }
  h1    { font-size: 1.72em;    padding-top: 1.5em; } /* 1*1.2*1.2*1.2 */
  h2    { font-size: 1.44em;    padding-top: 1.5em; } /* 1*1.2*1.2 */
  h3    { font-size: 1.2em;     padding-top: 1.5em; } /* 1*1.2 */
  h4    { font-size: 1em;       padding-top: 1.5em; }
  h5, h6 { font-size: 1em;      margin: initial; padding: 0.5em 0 0.3em; }
}
/* Sourcecode margin in print, when there's no pilcrow */
@media print {
  .artwork,
  .sourcecode {
    margin-bottom: 1em;
  }
}
/* Avoid narrow tables forcing too narrow table captions, which may render badly */
table {
  min-width: 20em;
}
/* ol type a */
ol.type-a { list-style-type: lower-alpha; }
ol.type-A { list-style-type: upper-alpha; }
ol.type-i { list-style-type: lower-roman; }
ol.type-I { list-style-type: lower-roman; }
/* Apply the print table and row borders in general, on request from the RPC,
and increase the contrast between border and odd row background sligthtly */
table {
  border: 1px solid #ddd;
}
td {
  border-top: 1px solid #ddd;
}
tr:nth-child(2n+1) > td {
  background-color: #f8f8f8;
}
/* Use style rules to govern display of the TOC. */
@media screen and (max-width: 1023px) {
  #toc nav { display: none; }
  #toc.active nav { display: block; }
}
/* Add support for keepWithNext */
.keepWithNext {
  break-after: avoid-page;
  break-after: avoid-page;
}
/* Add support for keepWithPrevious */
.keepWithPrevious {
  break-before: avoid-page;
}
/* Change the approach to avoiding breaks inside artwork etc. */
figure, pre, table, .artwork, .sourcecode  {
  break-before: avoid-page;
  break-after: auto;
}
/* Avoid breaks between <dt> and <dd> */
dl {
  break-before: auto;
  break-inside: auto;
}
dt {
  break-before: auto;
  break-after: avoid-page;
}
dd {
  break-before: avoid-page;
  break-after: auto;
  orphans: 3;
  widows: 3
}
span.break, dd.break {
  margin-bottom: 0;
  min-height: 0;
  break-before: auto;
  break-inside: auto;
  break-after: auto;
}
/* Undo break-before ToC */
@media print {
  #toc {
    break-before: auto;
  }
}
/* Text in compact lists should not get extra bottim margin space,
   since that would makes the list not compact */
ul.compact p, .ulCompact p,
ol.compact p, .olCompact p {
 margin: 0;
}
/* But the list as a whole needs the extra space at the end */
section ul.compact,
section .ulCompact,
section ol.compact,
section .olCompact {
  margin-bottom: 1em;                    /* same as p not within ul.compact etc. */
}
/* The tt and code background above interferes with for instance table cell
   backgrounds.  Changed to something a bit more selective. */
tt, code {
  background-color: transparent;
}
p tt, p code, li tt, li code {
  background-color: #f8f8f8;
}
/* Tweak the pre margin -- 0px doesn't come out well */
pre {
   margin-top: 0.5px;
}
/* Tweak the comact list text */
ul.compact, .ulCompact,
ol.compact, .olCompact,
dl.compact, .dlCompact {
  line-height: normal;
}
/* Don't add top margin for nested lists */
li > ul, li > ol, li > dl,
dd > ul, dd > ol, dd > dl,
dl > dd > dl {
  margin-top: initial;
}
/* Elements that should not be rendered on the same line as a <dt> */
/* This should match the element list in writer.text.TextWriter.render_dl() */
dd > div.artwork:first-child,
dd > aside:first-child,
dd > figure:first-child,
dd > ol:first-child,
dd > div:first-child > pre.sourcecode,
dd > table:first-child,
dd > ul:first-child {
  clear: left;
}
/* fix for weird browser behaviour when <dd/> is empty */
dt+dd:empty::before{
  content: "\00a0";
}
/* Make paragraph spacing inside <li> smaller than in body text, to fit better within the list */
li > p {
  margin-bottom: 0.5em
}
/* Don't let p margin spill out from inside list items */
li > p:last-of-type {
  margin-bottom: 0;
}
</style>
<link href="rfc-local.css" rel="stylesheet" type="text/css">
<script type="application/javascript">async function addMetadata(){try{const e=document.styleSheets[0].cssRules;for(let t=0;t<e.length;t++)if(/#identifiers/.exec(e[t].selectorText)){const a=e[t].cssText.replace("#identifiers","#external-updates");document.styleSheets[0].insertRule(a,document.styleSheets[0].cssRules.length)}}catch(e){console.log(e)}const e=document.getElementById("external-metadata");if(e)try{var t,a="",o=function(e){const t=document.getElementsByTagName("meta");for(let a=0;a<t.length;a++)if(t[a].getAttribute("name")===e)return t[a].getAttribute("content");return""}("rfc.number");if(o){t="https://www.rfc-editor.org/rfc/rfc"+o+".json";try{const e=await fetch(t);a=await e.json()}catch(e){t=document.URL.indexOf("html")>=0?document.URL.replace(/html$/,"json"):document.URL+".json";const o=await fetch(t);a=await o.json()}}if(!a)return;e.style.display="block";const s="",d="https://datatracker.ietf.org/doc",n="https://datatracker.ietf.org/ipr/search",c="https://www.rfc-editor.org/info",l=a.doc_id.toLowerCase(),i=a.doc_id.slice(0,3).toLowerCase(),f=a.doc_id.slice(3).replace(/^0+/,""),u={status:"Status",obsoletes:"Obsoletes",obsoleted_by:"Obsoleted By",updates:"Updates",updated_by:"Updated By",see_also:"See Also",errata_url:"Errata"};let h="<dl style='overflow:hidden' id='external-updates'>";["status","obsoletes","obsoleted_by","updates","updated_by","see_also","errata_url"].forEach(e=>{if("status"==e){a[e]=a[e].toLowerCase();var t=a[e].split(" "),o=t.length,w="",p=1;for(let e=0;e<o;e++)p<o?w=w+r(t[e])+" ":w+=r(t[e]),p++;a[e]=w}else if("obsoletes"==e||"obsoleted_by"==e||"updates"==e||"updated_by"==e){var g,m="",b=1;g=a[e].length;for(let t=0;t<g;t++)a[e][t]&&(a[e][t]=String(a[e][t]).toLowerCase(),m=b<g?m+"<a href='"+s+"/rfc/".concat(a[e][t])+"'>"+a[e][t].slice(3)+"</a>, ":m+"<a href='"+s+"/rfc/".concat(a[e][t])+"'>"+a[e][t].slice(3)+"</a>",b++);a[e]=m}else if("see_also"==e){var y,L="",C=1;y=a[e].length;for(let t=0;t<y;t++)if(a[e][t]){a[e][t]=String(a[e][t]);var _=a[e][t].slice(0,3),v=a[e][t].slice(3).replace(/^0+/,"");L=C<y?"RFC"!=_?L+"<a href='"+s+"/info/"+_.toLowerCase().concat(v.toLowerCase())+"'>"+_+" "+v+"</a>, ":L+"<a href='"+s+"/info/"+_.toLowerCase().concat(v.toLowerCase())+"'>"+v+"</a>, ":"RFC"!=_?L+"<a href='"+s+"/info/"+_.toLowerCase().concat(v.toLowerCase())+"'>"+_+" "+v+"</a>":L+"<a href='"+s+"/info/"+_.toLowerCase().concat(v.toLowerCase())+"'>"+v+"</a>",C++}a[e]=L}else if("errata_url"==e){var R="";R=a[e]?R+"<a href='"+a[e]+"'>Errata exist</a> | <a href='"+d+"/"+l+"'>Datatracker</a>| <a href='"+n+"/?"+i+"="+f+"&submit="+i+"'>IPR</a> | <a href='"+c+"/"+l+"'>Info page</a>":"<a href='"+d+"/"+l+"'>Datatracker</a> | <a href='"+n+"/?"+i+"="+f+"&submit="+i+"'>IPR</a> | <a href='"+c+"/"+l+"'>Info page</a>",a[e]=R}""!=a[e]?"Errata"==u[e]?h+=`<dt>More info:</dt><dd>${a[e]}</dd>`:h+=`<dt>${u[e]}:</dt><dd>${a[e]}</dd>`:"Errata"==u[e]&&(h+=`<dt>More info:</dt><dd>${a[e]}</dd>`)}),h+="</dl>",e.innerHTML=h}catch(e){console.log(e)}else console.log("Could not locate metadata <div> element");function r(e){return e.charAt(0).toUpperCase()+e.slice(1)}}window.removeEventListener("load",addMetadata),window.addEventListener("load",addMetadata);</script>
</head>
<body>
<script src="metadata.min.js"></script>
<table class="ears">
<thead><tr>
<td class="left">Internet-Draft</td>
<td class="center">srtsn</td>
<td class="right">August 2021</td>
</tr></thead>
<tfoot><tr>
<td class="left">Stein</td>
<td class="center">Expires 2 March 2022</td>
<td class="right">[Page]</td>
</tr></tfoot>
</table>
<div id="external-metadata" class="document-information"></div>
<div id="internal-metadata" class="document-information">
<dl id="identifiers">
<dt class="label-workgroup">Workgroup:</dt>
<dd class="workgroup">DetNet Working Group</dd>
<dt class="label-internet-draft">Internet-Draft:</dt>
<dd class="internet-draft">draft-stein-srtsn-01</dd>
<dt class="label-published">Published:</dt>
<dd class="published">
<time datetime="2021-08-29" class="published">29 August 2021</time>
    </dd>
<dt class="label-intended-status">Intended Status:</dt>
<dd class="intended-status">Informational</dd>
<dt class="label-expires">Expires:</dt>
<dd class="expires"><time datetime="2022-03-02">2 March 2022</time></dd>
<dt class="label-authors">Author:</dt>
<dd class="authors">
<div class="author">
      <div class="author-name">Y(J). Stein</div>
<div class="org">RAD</div>
</div>
</dd>
</dl>
</div>
<h1 id="title">Segment Routed Time Sensitive Networking</h1>
<section id="section-abstract">
      <h2 id="abstract"><a href="#abstract" class="selfRef">Abstract</a></h2>
<p id="section-abstract-1">Routers perform two distinct user-plane functionalities,
namely forwarding (where the packet should be sent) and scheduling (when the packet should be sent).
One forwarding paradigm is segment routing,
in which forwarding instructions are encoded in the packet in a stack data structure,
rather than programmed into the routers.
Time Sensitive Networking and Deterministic Networking provide several mechanisms for scheduling
under the assumption that routers are time synchronized.
The most effective mechanisms for delay minimization involve per-flow resource allocation.<a href="#section-abstract-1" class="pilcrow">¶</a></p>
<p id="section-abstract-2">SRTSN is a unified approach to forwarding and scheduling that uses a single stack data structure.
Each stack entry consists of a forwarding portion (e.g., IP addresses or suffixes)
and a scheduling portion (deadline by which the packet must exit the router).
SRTSN thus fully implements network programming for time sensitive flows, 
by prescribing to each router both to-where and by-when each packet should be sent.<a href="#section-abstract-2" class="pilcrow">¶</a></p>
</section>
<div id="status-of-memo">
<section id="section-boilerplate.1">
        <h2 id="name-status-of-this-memo">
<a href="#name-status-of-this-memo" class="section-name selfRef">Status of This Memo</a>
        </h2>
<p id="section-boilerplate.1-1">
        This Internet-Draft is submitted in full conformance with the
        provisions of BCP 78 and BCP 79.<a href="#section-boilerplate.1-1" class="pilcrow">¶</a></p>
<p id="section-boilerplate.1-2">
        Internet-Drafts are working documents of the Internet Engineering Task
        Force (IETF). Note that other groups may also distribute working
        documents as Internet-Drafts. The list of current Internet-Drafts is
        at <span><a href="https://datatracker.ietf.org/drafts/current/">https://datatracker.ietf.org/drafts/current/</a></span>.<a href="#section-boilerplate.1-2" class="pilcrow">¶</a></p>
<p id="section-boilerplate.1-3">
        Internet-Drafts are draft documents valid for a maximum of six months
        and may be updated, replaced, or obsoleted by other documents at any
        time. It is inappropriate to use Internet-Drafts as reference
        material or to cite them other than as "work in progress."<a href="#section-boilerplate.1-3" class="pilcrow">¶</a></p>
<p id="section-boilerplate.1-4">
        This Internet-Draft will expire on 2 March 2022.<a href="#section-boilerplate.1-4" class="pilcrow">¶</a></p>
</section>
</div>
<div id="copyright">
<section id="section-boilerplate.2">
        <h2 id="name-copyright-notice">
<a href="#name-copyright-notice" class="section-name selfRef">Copyright Notice</a>
        </h2>
<p id="section-boilerplate.2-1">
            Copyright (c) 2021 IETF Trust and the persons identified as the
            document authors. All rights reserved.<a href="#section-boilerplate.2-1" class="pilcrow">¶</a></p>
<p id="section-boilerplate.2-2">
            This document is subject to BCP 78 and the IETF Trust's Legal
            Provisions Relating to IETF Documents
            (<span><a href="https://trustee.ietf.org/license-info">https://trustee.ietf.org/license-info</a></span>) in effect on the date of
            publication of this document. Please review these documents
            carefully, as they describe your rights and restrictions with
            respect to this document. Code Components extracted from this
            document must include Simplified BSD License text as described in
            Section 4.e of the Trust Legal Provisions and are provided without
            warranty as described in the Simplified BSD License.<a href="#section-boilerplate.2-2" class="pilcrow">¶</a></p>
</section>
</div>
<div id="toc">
<section id="section-toc.1">
        <a href="#" onclick="scroll(0,0)" class="toplink">▲</a><h2 id="name-table-of-contents">
<a href="#name-table-of-contents" class="section-name selfRef">Table of Contents</a>
        </h2>
<nav class="toc"><ul class="toc ulBare ulEmpty compact">
<li class="toc ulBare ulEmpty compact" id="section-toc.1-1.1">
            <p id="section-toc.1-1.1.1" class="keepWithNext"><a href="#section-1" class="xref">1</a>.  <a href="#name-introduction" class="xref">Introduction</a></p>
</li>
          <li class="toc ulBare ulEmpty compact" id="section-toc.1-1.2">
            <p id="section-toc.1-1.2.1" class="keepWithNext"><a href="#section-2" class="xref">2</a>.  <a href="#name-forwarding-and-scheduling" class="xref">Forwarding and Scheduling</a></p>
</li>
          <li class="toc ulBare ulEmpty compact" id="section-toc.1-1.3">
            <p id="section-toc.1-1.3.1" class="keepWithNext"><a href="#section-3" class="xref">3</a>.  <a href="#name-stack-based-methods-for-lat" class="xref">Stack-based Methods for Latency Control</a></p>
</li>
          <li class="toc ulBare ulEmpty compact" id="section-toc.1-1.4">
            <p id="section-toc.1-1.4.1"><a href="#section-4" class="xref">4</a>.  <a href="#name-the-time-sensitive-router" class="xref">The Time Sensitive Router</a></p>
</li>
          <li class="toc ulBare ulEmpty compact" id="section-toc.1-1.5">
            <p id="section-toc.1-1.5.1"><a href="#section-5" class="xref">5</a>.  <a href="#name-segment-routed-time-sensiti" class="xref">Segment Routed Time Sensitive Networking</a></p>
</li>
          <li class="toc ulBare ulEmpty compact" id="section-toc.1-1.6">
            <p id="section-toc.1-1.6.1"><a href="#section-6" class="xref">6</a>.  <a href="#name-stack-entry-format" class="xref">Stack Entry Format</a></p>
</li>
          <li class="toc ulBare ulEmpty compact" id="section-toc.1-1.7">
            <p id="section-toc.1-1.7.1"><a href="#section-7" class="xref">7</a>.  <a href="#name-stack-size" class="xref">Stack Size</a></p>
</li>
          <li class="toc ulBare ulEmpty compact" id="section-toc.1-1.8">
            <p id="section-toc.1-1.8.1"><a href="#section-8" class="xref">8</a>.  <a href="#name-control-plane" class="xref">Control Plane</a></p>
</li>
          <li class="toc ulBare ulEmpty compact" id="section-toc.1-1.9">
            <p id="section-toc.1-1.9.1"><a href="#section-9" class="xref">9</a>.  <a href="#name-security-considerations" class="xref">Security Considerations</a></p>
</li>
          <li class="toc ulBare ulEmpty compact" id="section-toc.1-1.10">
            <p id="section-toc.1-1.10.1"><a href="#section-10" class="xref">10</a>. <a href="#name-iana-considerations" class="xref">IANA Considerations</a></p>
</li>
          <li class="toc ulBare ulEmpty compact" id="section-toc.1-1.11">
            <p id="section-toc.1-1.11.1"><a href="#section-11" class="xref">11</a>. <a href="#name-informative-references" class="xref">Informative References</a></p>
</li>
          <li class="toc ulBare ulEmpty compact" id="section-toc.1-1.12">
            <p id="section-toc.1-1.12.1"><a href="#appendix-A" class="xref"></a><a href="#name-authors-address" class="xref">Author's Address</a></p>
</li>
        </ul>
</nav>
</section>
</div>
<section id="section-1">
      <h2 id="name-introduction">
<a href="#section-1" class="section-number selfRef">1. </a><a href="#name-introduction" class="section-name selfRef">Introduction</a>
      </h2>
<p id="section-1-1">Packet Switched Networks (PSNs) use statistical multiplexing to fully exploit link data rate.
On the other hand, statistical multiplexing in general leads to end-to-end propagation latencies
significantly higher than the minimum physically possible,
due to packets needing to reside in queues waiting for their turn to be transmitted.<a href="#section-1-1" class="pilcrow">¶</a></p>
<p id="section-1-2">Recently Time Sensitive Networking (TSN) and Deterministic Networking (DetNet) technologies
have been developed to reduce this queueing latency for time sensitive packets <span>[<a href="#RFC8557" class="xref">RFC8557</a>]</span>.
Novel TSN mechanisms are predicated on the time synchronization of all forwarding elements
(Ethernet switches, MPLS Label Switched Routers, SDN whitebox switches, or IP routers, to be called here simply routers).
Once routers agree on time to high accuracy,
it is theoretically possible to arrange for time sensitive packets to experience "green waves",
that is, never to wait in queues.
For example, scheduling timeslots for particular flows eliminates packet interference,
but eliminates the statistical multiplexing advantage of PSNs.
In addition, the scheduling calculation and programming of the network to follow this calculation
doesn't scale well to large networks.<a href="#section-1-2" class="pilcrow">¶</a></p>
<p id="section-1-3">Segment Routing (SR) technologies provide a scalable method of network programming,
but until now has not been applied to scheduling.
The SR instructions are contained within a packet in the form of a first-in first-out stack
dictating the forwarding decisions of successive routers.
Segment routing may be used to choose a path
sufficiently short to be capable of providing sufficiently low end-to-end latency
but does not influence the queueing of individual packets in each router along that path.<a href="#section-1-3" class="pilcrow">¶</a></p>
</section>
<section id="section-2">
      <h2 id="name-forwarding-and-scheduling">
<a href="#section-2" class="section-number selfRef">2. </a><a href="#name-forwarding-and-scheduling" class="section-name selfRef">Forwarding and Scheduling</a>
      </h2>
<p id="section-2-1">Routers (recall that by routers we mean any packet forwarding device)
perform two distinct functions on incoming packets, namely forwarding and scheduling.
By forwarding we mean obtaining the incoming packet, inspecting the packet's headers,
deciding on an output port, and for QoS routing a specific output queue belonging to this output port,
based on the header information and a forwarding information base,
optionally editing the packet
(e.g., decrementing the TTL field or performing a stack operation on a MPLS label),
and placing the packet into the selected output queue.<a href="#section-2-1" class="pilcrow">¶</a></p>
<p id="section-2-2">Scheduling consists of selecting which output queue
and which packet from that output queue will be the next packet
to be physically transmitted over the output port.
In simple terms one can think of forwarding and scheduling
as "which output port" and "which packet" decisions, respectively;
that is, forwarding decides to which output port to send each packet,
and scheduling decides which packet to send next.<a href="#section-2-2" class="pilcrow">¶</a></p>
<p id="section-2-3">Segment routing (as well as connection-oriented mechanisms) slightly simplify the meaning of forwarding
to deciding "where" to send the incoming packet,
while TSN slightly simplifies the meaning of scheduling to deciding "when" to send the outgoing packet.<a href="#section-2-3" class="pilcrow">¶</a></p>
<p id="section-2-4">Routers optionally perform a third user plane operation, namely per output port and/or per flow traffic conditioning.
By conditioning we mean policing (discarding packets based on a token bucket algorithm), shaping (delaying packets), (W)RED, etc.
Since we will only be interested in per-packet per router behavior we will neglect conditioning,
which is either per router (not distinguishing between packets) or per flow (the same for all routers along the path).<a href="#section-2-4" class="pilcrow">¶</a></p>
<p id="section-2-5">As aforementioned, forwarding decisions always select an output port,
but when there are QoS criteria additionally select an output queue belonging to that port.
The use of multiple queues per output port is to aid the scheduling,
which then becomes a matter of selecting an output queue
and always taking the packet at the end of the queue (the packet that has waited the longest).
For example, the simplest nontrivial scheduling algorithm is "strict priority".
In strict priority packets are assigned to queues according to their priority
(as indicated by Priority Code Point or DiffServ Code Point field).
The strict priority scheduler always first checks the queue with highest priority;
if there is a packet waiting there it is selected for transmission,
if not the next highest priority queue is examined and so on.
Undesirably strict priority may never reach packets in low priority queues (Best Effort packets),
so alternative algorithms, e.g., Weighted Fair Queueing, are used to select from priority queues more fairly.<a href="#section-2-5" class="pilcrow">¶</a></p>
<p id="section-2-6">TSN is required for networks transporting time sensitive traffic,
that is, packets that are required to be delivered to their final destination by a given time.
In the following we will call the time a packet is sent by the end user application
(or the time it enters a specific network) the "birth time",
the required delivery time to the end-user application (or the time it exists a specific network)
the "final deadline" and the difference between these two times
(i.e., the maximally allowed end-to-end propagation time though the network) the "delay budget".<a href="#section-2-6" class="pilcrow">¶</a></p>
<p id="section-2-7">Unlike strict priority or WFQ algorithms,
TSN scheduling algorithms may directly utilize the current time of day.
For example, in the TSN scheduling algorithm known as time-aware scheduling (gating),
each output queue is controlled by a timed gate.
At every time only certain output queues have their gates "open" and can have their packets scheduled,
while packets are not scheduled from queues with "closed" gates.
By appropriately timing the opening and closing of gates of all routers throughout the network,
packets in time sensitive flows may be able to traverse their end-to-end path
without ever needlessly waiting in output queues.
In fact, time-aware gating may be able to provide a guaranteed upper bound for end-to-end delay.<a href="#section-2-7" class="pilcrow">¶</a></p>
<p id="section-2-8">However, time-aware scheduling suffers from two major disadvantages.
First, opening the gates of only certain queues for a given time duration,
results in this time duration being reserved
even if there are very few or even no packets in the corresponding queues.
This is precisely the undesirable characteristic of Time Division Multiplexing networks
that led to their replacement by Packet Switched Networks.
Minimizing time durations increases efficiency,
but at the cost of obliging a time sensitive packet that just missed its gate to wait until the next gate opening,
endangering its conforming to the delay budget.<a href="#section-2-8" class="pilcrow">¶</a></p>
<p id="section-2-9">In order to avoid such problems, one needs to know a priori the birth times of all time sensitive packets,
the lengths of all links between routers, and the loading of all routers.
Based on this input one can calculate optimal gating schedules for all routers in the network
and distribute this information to all the routers.
This calculation is computationally expensive and updating all the routers is communicationally expensive.
Moreover, admitting a new time-sensitive flow requires recalculation
of all the gating schedules and updating all the routers.
This recalculation and communications load is practical only for small networks and a relatively small numbers of flows.<a href="#section-2-9" class="pilcrow">¶</a></p>
</section>
<section id="section-3">
      <h2 id="name-stack-based-methods-for-lat">
<a href="#section-3" class="section-number selfRef">3. </a><a href="#name-stack-based-methods-for-lat" class="section-name selfRef">Stack-based Methods for Latency Control</a>
      </h2>
<p id="section-3-1">One can envision mechanisms for reducing end-to-end propagation latency in a network with time-synchronized routers
that do not suffer from the disadvantages of time sensitive scheduling.
One such mechanism would be to insert the packet's birth time
(time created by end-user application or time entering the network)
into the packet's headers.
Each router along the way could use this birth time by prioritizing packets with earlier birth times,
a policy known as Longest in System (LIS).
These times are directly comparable, due to our assuming the synchronization of all routers in the network.
This mechanism may indeed lower the propagation delay,
but at each router the decision is sub-optimal since a packet that has been in the network longer
but that has a longer application delay budget will be sent before a later packet with a tighter delay budget.<a href="#section-3-1" class="pilcrow">¶</a></p>
<p id="section-3-2">An improved mechanism would insert into the packet headers the desired final deadline,
i.e., the birth time plus the delay budget.
Each router along the way could use this final destination time by prioritizing packets with earlier deadlines,
a policy known as Earliest Deadline First (EDF).
This mechanism may indeed lower the propagation delay, but at each router the decision is sub-optimal
since a packet that has been in the network longer but is close to its destination will be transmitted
before a later packet which still has a long way to travel.<a href="#section-3-2" class="pilcrow">¶</a></p>
<p id="section-3-3">A better solution to the problem involves precalculating individual "local" deadlines for each router,
and each router prioritizing packets according to its own local deadline.
As an example, a packet sent at time 10:11:12.000 with delay budget of 32 milliseconds
(i.e., final deadline time of 10:11:12.032) and that needs to traverse three routers
might have in its packet headers three local deadlines, 10:11:12:010, 10:11:12.020, and 10:11:12.030.
The first router employs EDF using the first local deadline,
the second router similarly using the second local deadline,
and the ultimate router using the last local deadline.<a href="#section-3-3" class="pilcrow">¶</a></p>
<p id="section-3-4">The most efficient data structure for inserting local deadlines into the headers is a "stack",
similar to that used in Segment Routing to carry forwarding instructions.
The number of deadline values in the stack equals the number of routers the packet needs to traverse in the network,
and each deadline value corresponds to a specific router.
The Top-of-Stack (ToS) corresponds to the first router's deadline
while the Bottom-of-Stack (BoS) refers to the last's.
All local deadlines in the stack are later or equal to the current time (upon which all routers agree),
and times closer to the ToS are always earlier or equal to times closer to the BoS.<a href="#section-3-4" class="pilcrow">¶</a></p>
<p id="section-3-5">The stack may be dynamic (as is the forwarding instruction stack in SR-MPLS)
or static with an index (as is the forwarding instruction stack in SRv6).<a href="#section-3-5" class="pilcrow">¶</a></p>
<p id="section-3-6">For private networks it is possible for the stack to be inserted
by the user equipment that is the source of the packet,
in which case the top of stack local deadline corresponds to the first router to be encountered by the packet.
However, in such a case the user equipment must also be time synchronized
for its time values to be directly compatible.
In an improved strategy the stack is inserted into the packet by the ingress router,
and thus its deadlines are in concert with time in the network.
In such case the first deadline will not explicitly appear in the stack
and the initial ToS corresponds to the second router in the network to be traversed by the packet.
In either case each router in turn pops from the stack the ToS local deadline
and uses that local deadline in its scheduling (e.g., employing EDF).<a href="#section-3-6" class="pilcrow">¶</a></p>
<p id="section-3-7">Since the ingress router inserts the deadline stack into the packet headers,
no other router needs to be aware of the requirements of the time sensitive flows.
Hence admitting a new flow only requires updating the information base of the ingress router.
In an efficient implementation the ingress router's information base
has deadline offset vectors for each time sensitive flow.
Upon receipt of a packet from user equipment,
the ingress router first determines if the packet belongs to a time sensitive flow.
If so, it adds the current time to the deadline offset vector
belonging to the flow and inserts it as a stack into the packet headers.<a href="#section-3-7" class="pilcrow">¶</a></p>
<p id="section-3-8">An explicit example is depicted in <a href="#Ex1" class="xref">Figure 1</a>.
Here packets of a specific time sensitive flow are required to be received by the remote user equipment
within 200 microseconds of being transmitted by the source user equipment.
The packets traverse a wireless link with delay 2 microseconds to reach the router R1 (the ingress router).
They then travel to router R2 over an optical fiber experiencing a propagation delay of 18 microseconds,
from there to router R3 experiencing an additional 38 microseconds of fiber delay,
from there to router R4 (the egress router) experiencing 16 microseconds of fiber delay.
Finally, they travel over a final wireless link taking again 2 microseconds.<a href="#section-3-8" class="pilcrow">¶</a></p>
<span id="name-example-with-propagation-la"></span><div id="Ex1">
<figure id="figure-1">
        <div class="artwork art-text alignLeft" id="section-3-9.1">
<pre>
 +----+  2  +----+  18   +----+  38   +----+  16   +----+  2  +----+
 | UE |-----| R1 |-------| R2 |-------| R3 |-------| R4 |-----| UE |
 +----+     +----+       +----+       +----+       +----+     +----+
</pre>
</div>
<figcaption><a href="#figure-1" class="selfRef">Figure 1</a>:
<a href="#name-example-with-propagation-la" class="selfRef">Example with propagation latencies</a>
        </figcaption></figure>
</div>
<p id="section-3-10">We conclude that the total constant physical propagation time is 2+18+38+16+2=76 microseconds.
Moreover, assume that we know that in each router
there is an additional constant time of 1 microsecond to receive the packet at the line rate
and 5 microseconds to process the packet, that is, 6 microseconds per router or 24 microseconds for all four routers.
We have thus reached the conclusion that the minimal time to traverse the network is 76+24=100 microseconds<a href="#section-3-10" class="pilcrow">¶</a></p>
<p id="section-3-11">Since our delay budget is 200 microseconds,
we have spare time of 200-100=100 microseconds for the packets to wait in output queues.
If we have no further information, we can divide this spare 100 microseconds equally among the 4 routers,
i.e., 25 microseconds per router.
Thus, the packet arrives at the first router after 2 microseconds,
is received and processed after 2+6=8 microseconds,
and is assigned a local deadline to exit the first router of 8+25=33 microseconds.
The worst case times of arrival and transmission at each point along the path are depicted in <a href="#Ex2" class="xref">Figure 2</a>.
Note that in general it may be optimal to divide the spare time in unequal fashion.<a href="#section-3-11" class="pilcrow">¶</a></p>
<span id="name-example-with-worst-case-tim"></span><div id="Ex2">
<figure id="figure-2">
        <div class="artwork art-text alignLeft" id="section-3-12.1">
<pre>
 +----+  2  +----+  18   +----+  38   +----+  16   +----+  2  +----+
 | UE |-----| R1 |-------| R2 |-------| R3 |-------| R4 |-----| UE |
 +----+     +----+       +----+       +----+       +----+     +----+
       |   |      |     |      |     |      |     |      |   |
       |   |      |     |      |     |      |     |      |   |
       0   2     33    51     82    120    151   167    198 200
</pre>
</div>
<figcaption><a href="#figure-2" class="selfRef">Figure 2</a>:
<a href="#name-example-with-worst-case-tim" class="selfRef">Example with worst case times</a>
        </figcaption></figure>
</div>
<p id="section-3-13">Assuming that the packet left router 1 the full 33 microseconds after its transmission,
it will arrive at router 2 after an additional 18 microseconds, that is, after 51 microseconds.
After the mandatory 6 microseconds of reception and processing and the 25 microseconds allocated for queueing,
we reach the local deadline to exit router 2 by 82 microseconds.
Similarly, the local deadline to exit router 3 is 151 microseconds,
and the deadline to exit router 4 is 198 microseconds.
After the final 2 microseconds consumed by the wireless link
the packet will arrive at its destination after 200 microseconds as required<a href="#section-3-13" class="pilcrow">¶</a></p>
<p id="section-3-14">Based on these worst case times the ingress router can now build the deadline offset vector (33, 82, 151, 198)
referenced to the time the packet left the source user equipment,
or referenced to the time the packet arrives at the ingress router of (31, 80, 149, 196).<a href="#section-3-14" class="pilcrow">¶</a></p>
<p id="section-3-15">Now assume that a packet was transmitted at time T and hence arrives at the ingress router at time T + 2 microseconds.
The ingress router R1, observing the deadline offset vector referenced to this time,
knows that the packet must be released no more than 31 microseconds later, i.e., by T + 33 microseconds.
It furthermore inserts a local deadline stack [T+82, T+151, T+198] into the packet headers.<a href="#section-3-15" class="pilcrow">¶</a></p>
<p id="section-3-16">The second router R2 receives the packet with the local deadline stack,
pops the ToS revealing that it must ensure that the packet exits by T + 82 microseconds.
It properly prioritizes and sends the packet with the new stack [T+151, T+198].
Router R3 pops deadline T+151, and sends the packet with local deadline stack containing a single entry [T+198].
The final router pops this final local deadline and ensures that the packet is transmitted before that time
The local deadline stacks are depicted in <a href="#Ex3" class="xref">Figure 3</a>.<a href="#section-3-16" class="pilcrow">¶</a></p>
<span id="name-example-with-local-deadline"></span><div id="Ex3">
<figure id="figure-3">
        <div class="artwork art-text alignLeft" id="section-3-17.1">
<pre>
 +----+  2  +----+  18   +----+  38   +----+  16   +----+  2  +----+
 | UE |-----| R1 |-------| R2 |-------| R3 |-------| R4 |-----| UE |
 +----+     +----+   |   +----+   |   +----+   |   +----+     +----+
       |   |      |  |  |      |  |  |      |  |  |      |   |
       |   |      |  |  |      |  |  |      |  |  |      |   |
       0   2     33  | 51     82  | 120    151 | 167    198 200
                     |            |            |
                     V            V            V
                   +---+        +---+        +---+
                   | 82|        |151|        |198|
                   |---|        |---|        +---+
                   |151|        |198|
                   |---|        +---+
                   |198|
                   +---+
</pre>
</div>
<figcaption><a href="#figure-3" class="selfRef">Figure 3</a>:
<a href="#name-example-with-local-deadline" class="selfRef">Example with local deadline stacks</a>
        </figcaption></figure>
</div>
<p id="section-3-18">The precise mechanism just described is by no means the only way to compute local deadlines.
Furthermore, combining time-aware scheduling solely at the ingress router,
with EDF at all the other routers, can provide "green waves" with provable upper bounds to delay.
However, optimizing such a scheme at scale may still be challenging. 
A randomized algorithm for setting up such a case is described in <span>[<a href="#AndrewsZhang" class="xref">AndrewsZhang</a>]</span>.<a href="#section-3-18" class="pilcrow">¶</a></p>
</section>
<section id="section-4">
      <h2 id="name-the-time-sensitive-router">
<a href="#section-4" class="section-number selfRef">4. </a><a href="#name-the-time-sensitive-router" class="section-name selfRef">The Time Sensitive Router</a>
      </h2>
<p id="section-4-1">While a stack is the ideal data structure to hold the local deadlines in the packet,
different data structures are used to hold the time sensitive packets (or their descriptors) in the routers.
The standard data structure used in routers is the queue which, being a first in first out memory,
is suitable for a policy of first-to-arrive first-to-exit, and not for EDF or other stack-based time sensitive mechanisms.
More suitable data structures are sorted lists, search trees, and priority heaps.
While such data structures are novel in this context, efficient hardware implementations exist.<a href="#section-4-1" class="pilcrow">¶</a></p>
<p id="section-4-2">If all the time sensitive flows are of the same priority,
then a single such data structure may be used for all time sensitive flows.
If there are time sensitive flows of differing priorities,
then a separate such data structure is required for each level of priority corresponding to a time sensitive flow,
while the conventional queue data structure may be used for priority levels corresponding to flows that are not time sensitive.<a href="#section-4-2" class="pilcrow">¶</a></p>
<p id="section-4-3">For example, assume two different priorities of time sensitive flows
and a lower priority for Best Effort traffic that is not time sensitive.
If applying strict priority the scheduler would first check if the data structure for the highest priority contains any packets.
If yes, it transmits the packet with the earliest local deadline.
If not, it checks the data structure for the second priority.
If it contains any packets it transmits the packet with the earliest deadline.
If not, it checks the Best Effort queue.
If this queue is nonempty it transmits the next packet in the queue, 
i.e., the packet that has waited in this queue the longest.<a href="#section-4-3" class="pilcrow">¶</a></p>
<p id="section-4-4">Separate prioritization and EDF is not necessarily the optimal strategy.
An alternative (which we call Liberal EDF, or LEDF) would be for the scheduler 
to define a worst case (i.e., maximal) packet transmission time MAXTT
(for example, the time taken for a 1500 byte packet to be transmitted at the output port's line rate).
Instead of checking whether the data structure for the highest priority contains any packets at all,
LEDF checks whether its earliest packet's local deadline is earlier than MAXTT from the current time.
If it is, it is transmitted; if it is not the next priority is checked, 
knowing that even were a maximal size packet to be transmitted
the scheduler will still be able to return to the higher priority packet before its local deadline.<a href="#section-4-4" class="pilcrow">¶</a></p>
</section>
<section id="section-5">
      <h2 id="name-segment-routed-time-sensiti">
<a href="#section-5" class="section-number selfRef">5. </a><a href="#name-segment-routed-time-sensiti" class="section-name selfRef">Segment Routed Time Sensitive Networking</a>
      </h2>
<p id="section-5-1">Since Segment Routing and the TSN mechanism just described both utilize stack data structures
it is advantageous to combine their information into a single unified SRTSN stack.
Each entry in this stack contain two subentries, the forwarding instruction 
(e.g., the address of the next router or the label specifying the next link)
and a scheduling instruction (the local deadline).<a href="#section-5-1" class="pilcrow">¶</a></p>
<p id="section-5-2">Each SRTSN stack entry fully prescribes the forwarding and scheduling behavior of the corresponding router,
both to-where and by-when the packet should be sent.
The insertion of a stack into packets thus fully implements network programming for time sensitive flows.<a href="#section-5-2" class="pilcrow">¶</a></p>
<p id="section-5-3">For example, <a href="#Ex4" class="xref">Figure 4</a> depicts the previous example but with the unified SRTSN stacks.
Ingress router R1 inserts a SRTSN stack with three entries into the packet received.
In this example the forwarding sub-entry contains the identifier or address of the next router,
except for the Bottom of Stack entry that contains a special BoS code (e.g., identifier zero).
The ToS entry thus contains the address of router R3 and the time by which the packet must exit router R2, namely T + 82 microseconds.
Router R2 pops this ToS leaving a SRTSN stack with 2 entries.
Router R3 pops the new ToS instructing it to forward the packet to router R4 by time T + 151 microseconds,
leaving a stack with a single entry.
Router R4 pops the ToS and sees that it has reached bottom of stack.
It then forwards the packet according to the usual rules of the network (for example, according to the IP address in the IP header)
by local deadline T + 198 microseconds.<a href="#section-5-3" class="pilcrow">¶</a></p>
<span id="name-example-with-combined-srtsn"></span><div id="Ex4">
<figure id="figure-4">
        <div class="artwork art-text alignLeft" id="section-5-4.1">
<pre>
 +----+  2  +----+  18   +----+  38   +----+  16   +----+  2  +----+
 | UE |-----| R1 |-------| R2 |-------| R3 |-------| R4 |-----| UE |
 +----+     +----+   |   +----+   |   +----+   |   +----+     +----+
       |   |      |  |  |      |  |  |      |  |  |      |   |
       |   |      |  |  |      |  |  |      |  |  |      |   |
       0   2     33  | 51     82  | 120    151 | 167    198 200
                     |            |            |
                     V            V            V
                 +-------+    +-------+    +-------+
                 |R2;  82|    |R3; 151|    |BoS;198|
                 |-------|    |-------|    +-------+
                 |R3; 151|    |BoS;198|
                 |-------|    +-------+
                 |BoS;198|
                 +-------+
</pre>
</div>
<figcaption><a href="#figure-4" class="selfRef">Figure 4</a>:
<a href="#name-example-with-combined-srtsn" class="selfRef">Example with combined SRTSN stacks</a>
        </figcaption></figure>
</div>
</section>
<section id="section-6">
      <h2 id="name-stack-entry-format">
<a href="#section-6" class="section-number selfRef">6. </a><a href="#name-stack-entry-format" class="section-name selfRef">Stack Entry Format</a>
      </h2>
<p id="section-6-1">A number of different time formats are in common use in networking applications and can be used to encode the local deadlines.
The longest commonly utilized format is 80-bit PTP-80 timestamp 
defined in IEEE 1588v2 Precision Time Protocol <span>[<a href="#IEEE1588" class="xref">IEEE1588</a>]</span>.
There are two common 64-bit time representations: the NTP-64 timestamp defined in <span>[<a href="#RFC5905" class="xref">RFC5905</a>]</span>
(32 bits for whole seconds and 32 bits for fractional seconds);
and the PTP-64 timestamp (32 bits for whole seconds and 32 bits for nanoseconds).
Finally, there is the NTP-32 timestamp (16 bits of whole seconds and 16 bits of fractional seconds)
that is often insufficient due to its low resolution (15 microseconds).<a href="#section-6-1" class="pilcrow">¶</a></p>
<p id="section-6-2">However, we needn't be constrained by these common formats, since our wraparound requirements are minimal.
As long as we have no ambiguity in times during the flight of a packet, which is usually much less than a second, 
the timestamp is acceptable.
Thus, we can readily use a nonstandard 32-bit timestamp format with say 12 bits of seconds (wraparound over 1 hour) 
and 20 bits for microseconds,
or say 8 bits for whole seconds (wraparound over 4 minutes) and 24 bits of tenths of microseconds.<a href="#section-6-2" class="pilcrow">¶</a></p>
<p id="section-6-3">For the forwarding sub-entry we could adopt like SR-MPLS standard 32-bit MPLS labels (which contain a 20-bit label and BoS bit),
and thus SRTSN stack entries could be 64-bits in size comprising a 32-bit MPLS label 
and the aforementioned nonstandard 32-bit timestamp.
Alternatively, an SR-TSN stack entry could be 96 bits in length comprising a 32-bit MPLS label 
and either of the standardized 64-bit timestamps.<a href="#section-6-3" class="pilcrow">¶</a></p>
<p id="section-6-4">For IPv4 networks one could employ a 32-bit IPv4 address in place of the MPLS label.
Thus, using the nonstandard 32-bit timestamp the entire stack entry could be 64 bits.
For dynamic stack implementations a BoS bit would have to be included.<a href="#section-6-4" class="pilcrow">¶</a></p>
<p id="section-6-5">SRv6 uses 128-bit IPv6 addresses (in addition to a 64-bit header and possibly options),
and so 160-bit or 192-bit unified entries are directly derivable.
However, when the routers involved are in the same network, 
address suffixes suffice to uniquely determine the next router.<a href="#section-6-5" class="pilcrow">¶</a></p>
</section>
<section id="section-7">
      <h2 id="name-stack-size">
<a href="#section-7" class="section-number selfRef">7. </a><a href="#name-stack-size" class="section-name selfRef">Stack Size</a>
      </h2>
<p id="section-7-1"> We can now address the question of the total overhead added by the SRTSN stack.
Were each stack entry to comprise a 128-bit IPv6 address and a 64-bit timestamp
then each stack entry would consume 24 bytes! 
In such a case a 10-hop stack would be larger than an average IPv4 packet.<a href="#section-7-1" class="pilcrow">¶</a></p>
<p id="section-7-2"> But we needn't be so wasteful!
Our deadline wraparound requirements are minimal as a timestamp is unambiguous 
when the wraparound duration exceeds twice the maximum time path time.
In a single network the forwarding sub-entry may consist of a router address suffix, 
or even an index uniquely identifying each router. 
In fact, it is easy to see that each entry need only be
  ceil( log2(Nrouters) ) + ceil( log2(2 max-path-time / time-resolution) ) + 1  bits
in duration.<a href="#section-7-2" class="pilcrow">¶</a></p>
<p id="section-7-3">
For small networks this translates to about 16 bits per entry and for medium sized ones 32 bits per entry.
So, an entire 4-hop stack may still occupy about as much as a single IPv6 address!<a href="#section-7-3" class="pilcrow">¶</a></p>
</section>
<section id="section-8">
      <h2 id="name-control-plane">
<a href="#section-8" class="section-number selfRef">8. </a><a href="#name-control-plane" class="section-name selfRef">Control Plane</a>
      </h2>
<p id="section-8-1">In the above discussion we assumed that the ingress router knows the deadline offset vector
for each time sensitive flow. 
This vector may be calculated by a centralized management system and sent to the ingress router,
or may be calculated by the ingress router itself.<a href="#section-8-1" class="pilcrow">¶</a></p>
<p id="section-8-2">In the former case there is central SRTSN orchestrator, which may be based on a Network Management System, 
or on an SDN controller, or on a Path Computation Element server.
The SRTSN orchestrator needs to be know the propagation delays for all the links in the network,
which may be determined using time domain reflectometry, or via one-way delay measurement OAM,
or retrieved from a network planning system.
The orchestrator may additionally know basic parameters of the routers, including minimal residence time, 
data rate of the ports, etc. 
When a time sensitive path needs to be set up,
the SRTSN orchestrator is given the source and destination and the delay budget.
It first determines feasibility by finding the end-to-end delay of the shortest path 
(shortest being defined in terms of latency, not hop count).
It then selects a path (usually, but not necessarily, the shortest one) and calculates the deadline offset vector.
The forwarding instructions and offset vector (as well as any other required flow-based information,
such as data rate or drop precedence) are then sent to the ingress router.
As in segment routing, no other router in the network needs to be informed.<a href="#section-8-2" class="pilcrow">¶</a></p>
<p id="section-8-3">In the latter case the ingress router is given the destination and the delay budget.
It sends a setup message to the destination as in RSVP-TE, 
however, in this case arrival and departure timestamps are recorded for every router along the way.
The egress router returns the router addresses and timestamps.
This process may be repeated several times and minimum gating applied to approximate 
the link propagation times.
Assuming that the path's delay does not exceed the delay budget,  
the path and deadline offset vector may then be determined.<a href="#section-8-3" class="pilcrow">¶</a></p>
<p id="section-8-4">The method of <span>[<a href="#AndrewsZhang" class="xref">AndrewsZhang</a>]</span> uses randomization in order to avoid the need 
for centralized coordination of flows entering the network at different ingress routers.
However, this advantage comes at the expense of much higher achievable delay budgets.<a href="#section-8-4" class="pilcrow">¶</a></p>
</section>
<section id="section-9">
      <h2 id="name-security-considerations">
<a href="#section-9" class="section-number selfRef">9. </a><a href="#name-security-considerations" class="section-name selfRef">Security Considerations</a>
      </h2>
<p id="section-9-1">SRTSN concentrates the entire network programming semantics into a single stack,
and thus tampering with this stack would have devastating consequences.
Since each stack entry must be readable by its corresponding router,
protecting the stack would necessitate key distribution between the ingress router
and every router along the path.<a href="#section-9-1" class="pilcrow">¶</a></p>
<p id="section-9-2">A simpler mechanism would be for the ingress router to sign the stack with a public key 
known to all routers in the network, and to append this signature to the stack.
If the signature is not present or is incorrect the packet should be discarded.<a href="#section-9-2" class="pilcrow">¶</a></p>
</section>
<div id="iana-considerations">
<section id="section-10">
      <h2 id="name-iana-considerations">
<a href="#section-10" class="section-number selfRef">10. </a><a href="#name-iana-considerations" class="section-name selfRef">IANA Considerations</a>
      </h2>
<p id="section-10-1">This document requires no IANA actions.<a href="#section-10-1" class="pilcrow">¶</a></p>
</section>
</div>
<section id="section-11">
      <h2 id="name-informative-references">
<a href="#section-11" class="section-number selfRef">11. </a><a href="#name-informative-references" class="section-name selfRef">Informative References</a>
      </h2>
<dl class="references">
<dt id="RFC5905">[RFC5905]</dt>
      <dd>
<span class="refAuthor">Mills, D.</span>, <span class="refAuthor">Martin, J., Ed.</span>, <span class="refAuthor">Burbank, J.</span>, and <span class="refAuthor">W. Kasch</span>, <span class="refTitle">"Network Time Protocol Version 4: Protocol and Algorithms Specification"</span>, <span class="seriesInfo">RFC 5905</span>, <span class="seriesInfo">DOI 10.17487/RFC5905</span>, <time datetime="2010-06" class="refDate">June 2010</time>, <span>&lt;<a href="https://www.rfc-editor.org/rfc/rfc5905">https://www.rfc-editor.org/rfc/rfc5905</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC8557">[RFC8557]</dt>
      <dd>
<span class="refAuthor">Finn, N.</span> and <span class="refAuthor">P. Thubert</span>, <span class="refTitle">"Deterministic Networking Problem Statement"</span>, <span class="seriesInfo">RFC 8557</span>, <span class="seriesInfo">DOI 10.17487/RFC8557</span>, <time datetime="2019-05" class="refDate">May 2019</time>, <span>&lt;<a href="https://www.rfc-editor.org/rfc/rfc8557">https://www.rfc-editor.org/rfc/rfc8557</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="IEEE1588">[IEEE1588]</dt>
      <dd>
<span class="refAuthor">IEEE</span>, <span class="refTitle">"Standard for a Precision Clock Synchronization Protocol for Networked Measurement and Control Systems"</span>, <span class="seriesInfo">IEEE 1588-2008</span>, <span class="seriesInfo">DOI 10.1109/IEEESTD.2008.4579760</span>, <time datetime="2008" class="refDate">2008</time>, <span>&lt;<a href="https://doi.org/10.1109/IEEESTD.2008.4579760">https://doi.org/10.1109/IEEESTD.2008.4579760</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="AndrewsZhang">[AndrewsZhang]</dt>
    <dd>
<span class="refAuthor">Andrews, M.</span> and <span class="refAuthor">L. Zhang</span>, <span class="refTitle">"Minimizing end-to-end delay in high-speed networks with a simple coordinated schedule"</span>, <span class="seriesInfo">Journal of Algorithms 52 57-81</span>, <time datetime="2003" class="refDate">2003</time>. </dd>
<dd class="break"></dd>
</dl>
</section>
<div id="authors-addresses">
<section id="appendix-A">
      <h2 id="name-authors-address">
<a href="#name-authors-address" class="section-name selfRef">Author's Address</a>
      </h2>
<address class="vcard">
        <div dir="auto" class="left"><span class="fn nameRole">Yaakov (J) Stein</span></div>
<div dir="auto" class="left"><span class="org">RAD</span></div>
<div class="email">
<span>Email:</span>
<a href="mailto:yaakovjstein@gmail.com" class="email">yaakovjstein@gmail.com</a>
</div>
</address>
</section>
</div>
<script>const toc = document.getElementById("toc");
toc.querySelector("h2").addEventListener("click", e => {
  toc.classList.toggle("active");
});
toc.querySelector("nav").addEventListener("click", e => {
  toc.classList.remove("active");
});
</script>
</body>
</html>
