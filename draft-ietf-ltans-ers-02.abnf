h1 = H(d1) where d1 is the only data object in data group 1
h3 = H(d3) where d3 is the only data object in data group 3
h12 = H( binary sorted and concatenated (h1, h2abc))
h123 = H( binary sorted and concatenated (h12, h3))
h2a = H(first data object of data object group 2)
h2b = H(second data object of data object group 2)
h2c = H(third data object of data object group 2)

h2abc = H( binary sorted and concatenated (h2a, h2b, h2c))


   The hash-tree can be reduced to lists of hash values, necessary to
   have a proof of existence for a single data object:

   1. Generate hash value h of the data object, using hash algorithm H
      of the hash-tree.
   2. Select all hash values, which have the same father node as h. 
      Generate the first list of hash values by arranging these hashes,
      in binary ascending order. Repeat this step for the father node
      of these hashes until the root hash is reached. The father nodes
      are not saved in the hash lists - they are computable.

   3. Generate a reduced hash-tree by building the sequence of these
      hash value lists. Then add the time-stamp and the hash algorithm
      to get an Archive Time-Stamp.


rht1 = SEQ( SEQ (h12, h1), SEQ (h3))
  
rht2 = SEQ( SEQ (h2b, h2c, h2a), SEQ (h1), SEQ (h3))

h2a = H(first data object of data object group 2)
   ...
h2c = H(third data object of data object group 2)
h2abc = H( binary sorted and concatenated (h2a', h2b', h2c'))


   If the Time-Stamp of an Archive Time-Stamp becomes invalid, the
   simple time-stamp renewal should be done. Only if the hash algorithm
   used within the hash-tree becomes weak, Hash-Tree Renewal must be
   done. In case of centralized Archive Time-Stamping, Archive 
   Time-Stamps might be generated a long-time before other Archive
   Time-Stamps become invalid to be on the secure side. Nevertheless 
   ArchiveTimeStamps, which are not necessary for verification,
   should not be added to ArchiveTimeStampChain or 
   ArchiveTimeStampSequence.





