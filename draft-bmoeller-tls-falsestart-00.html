<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="en"><head><title>Transport Layer Security (TLS) False Start</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="description" content="Transport Layer Security (TLS) False Start">
<meta name="generator" content="xml2rfc v1.35 (http://xml.resource.org/)">
<meta name="viewport" content="width=600;" />
<style type='text/css'><!--
        body {
                font-family: verdana, charcoal, helvetica, arial, sans-serif;
                font-size: 85%;
		max-width: 60em; 
		color: #000; background-color: #FFF;
                margin: 2em;
        }
        h1, h2, h3, h4, h5, h6 {
                font-family: helvetica, monaco, "MS Sans Serif", arial, sans-serif;
                font-weight: bold; font-style: normal;
        }
        h1 { color: #900; background-color: transparent; text-align: right; }
        h3 { color: #333; background-color: transparent; }

        td.RFCbug {
                font-size: x-small; text-decoration: none;
                width: 30px; height: 30px; padding-top: 2px;
                text-align: justify; vertical-align: middle;
                background-color: #000;
        }
        td.RFCbug span.RFC {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: bold; color: #666;
        }
        td.RFCbug span.hotText {
                font-family: charcoal, monaco, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: normal; text-align: center; color: #FFF;
        }

        table.TOCbug { width: 30px; height: 15px; }
        td.TOCbug {
                text-align: center; width: 30px; height: 15px;
                color: #FFF; background-color: #900;
        }
        td.TOCbug a {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, sans-serif;
                font-weight: bold; font-size: x-small; text-decoration: none;
                color: #FFF; background-color: transparent;
        }

        td.header {
                font-family: arial, helvetica, sans-serif; font-size: x-small;
                vertical-align: top; width: 33%;
                color: #FFF; background-color: #666;
        }
        td.author { font-weight: bold; font-size: x-small; margin-left: 4em; }
        td.author-text { font-size: x-small; }

        /* info code from SantaKlauss at http://www.madaboutstyle.com/tooltip2.html */
        a.info {
                /* This is the key. */
                position: relative;
                z-index: 24;
                text-decoration: none;
        }
        a.info:hover {
                z-index: 25;
                color: #FFF; background-color: #900;
        }
        a.info span { display: none; }
        a.info:hover span.info {
                /* The span will display just on :hover state. */
                display: block;
                position: absolute;
                font-size: smaller;
                top: 2em; left: -5em; width: 15em;
                padding: 2px; border: 1px solid #333;
                color: #900; background-color: #EEE;
                text-align: left;
        }

        a { font-weight: bold; }
        a:link    { color: #900; background-color: transparent; }
        a:visited { color: #633; background-color: transparent; }
        a:active  { color: #633; background-color: transparent; }

        p { margin-left: 2em; margin-right: 2em; }
        p.copyright { font-size: x-small; }
        p.toc { font-size: 85%;
		max-width: 60em; 
		font-weight: bold; margin-left: 3em; }
        table.toc { margin: 0 0 0 3em; padding: 0; border: 0; vertical-align: text-top; }
        td.toc { font-size: 85%;
		max-width: 60em; 
		font-weight: bold; vertical-align: text-top; }

        ol.text { margin-left: 2em; margin-right: 2em; }
        ul.text { margin-left: 2em; margin-right: 2em; }
        li      { margin-left: 3em; }

        /* RFC-2629 <spanx>s and <artwork>s. */
        em     { font-style: italic; }
        strong { font-weight: bold; }
        dfn    { font-weight: bold; font-style: normal; }
        cite   { font-weight: normal; font-style: normal; }
        tt     { color: #036; }
        tt, pre, pre dfn, pre em, pre cite, pre span {
                font-family: "Courier New", Courier, monospace; font-size: small;
        }
        pre {
                text-align: left; padding: 4px;
                color: #000; background-color: #CCC;
        }
        pre dfn  { color: #900; }
        pre em   { color: #66F; background-color: #FFC; font-weight: normal; }
        pre .key { color: #33C; font-weight: bold; }
        pre .id  { color: #900; }
        pre .str { color: #000; background-color: #CFF; }
        pre .val { color: #066; }
        pre .rep { color: #909; }
        pre .oth { color: #000; background-color: #FCF; }
        pre .err { background-color: #FCC; }

        /* RFC-2629 <texttable>s. */
        table.all, table.full, table.headers, table.none {
                font-size: 85%;
		max-width: 60em; 
		text-align: center; border-width: 2px;
                vertical-align: top; border-collapse: collapse;
        }
        table.all, table.full { border-style: solid; border-color: black; }
        table.headers, table.none { border-style: none; }
        th {
                font-weight: bold; border-color: black;
                border-width: 2px 2px 3px 2px;
        }
        table.all th, table.full th { border-style: solid; }
        table.headers th { border-style: none none solid none; }
        table.none th { border-style: none; }
        table.all td {
                border-style: solid; border-color: #333;
                border-width: 1px 2px;
        }
        table.full td, table.headers td, table.none td { border-style: none; }

        hr { height: 1px; }
        hr.insert {
                width: 80%; border-style: none; border-width: 0;
                color: #CCC; background-color: #CCC;
        }
--></style>
</head>
<body>
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<table summary="layout" width="66%" border="0" cellpadding="0" cellspacing="0"><tr><td><table summary="layout" width="100%" border="0" cellpadding="2" cellspacing="1">
<tr><td class="header">TLS Working Group</td><td class="header">A. Langley</td></tr>
<tr><td class="header">Internet-Draft</td><td class="header">N. Modadugu</td></tr>
<tr><td class="header">Intended status: Informational</td><td class="header">B. Moeller</td></tr>
<tr><td class="header">Expires: December 4, 2010</td><td class="header">Google</td></tr>
<tr><td class="header">&nbsp;</td><td class="header">June 2, 2010</td></tr>
</table></td></tr></table>
<h1><br />Transport Layer Security (TLS) False Start<br />draft-bmoeller-tls-falsestart-00</h1>

<h3>Abstract</h3>

<p>
        This document specifies an optional behavior of TLS implementations, dubbed False Start.
        It affects only protocol timing, not on-the-wire protocol data,
        and can be implemented unilaterally.
        The TLS False Start feature leads to a latency reduction of one round trip for certain
        handshakes.
      
</p>
<h3>Status of this Memo</h3>
<p>
This Internet-Draft is submitted  in full
conformance with the provisions of BCP&nbsp;78 and BCP&nbsp;79.</p>
<p>
Internet-Drafts are working documents of the Internet Engineering
Task Force (IETF).  Note that other groups may also distribute
working documents as Internet-Drafts.  The list of current
Internet-Drafts is at http://datatracker.ietf.org/drafts/current/.</p>
<p>
Internet-Drafts are draft documents valid for a maximum of six months
and may be updated, replaced, or obsoleted by other documents at any time.
It is inappropriate to use Internet-Drafts as reference material or to cite
them other than as &ldquo;work in progress.&rdquo;</p>
<p>
This Internet-Draft will expire on December 4, 2010.</p>

<h3>Copyright Notice</h3>
<p>
Copyright (c) 2010 IETF Trust and the persons identified as the
document authors.  All rights reserved.</p>
<p>
This document is subject to BCP 78 and the IETF Trust's Legal
Provisions Relating to IETF Documents
(http://trustee.ietf.org/license-info) in effect on the date of
publication of this document.  Please review these documents
carefully, as they describe your rights and restrictions with respect
to this document. Code Components extracted from this document must
include Simplified BSD License text as described in Section 4.e of
the Trust Legal Provisions and are provided without warranty as
described in the Simplified BSD License.</p>
<a name="toc"></a><br /><hr />
<h3>Table of Contents</h3>
<p class="toc">
<a href="#anchor1">1.</a>&nbsp;
Requirements Notation<br />
<a href="#anchor2">2.</a>&nbsp;
Introduction<br />
<a href="#sec.compatibility">3.</a>&nbsp;
False Start Compatibility<br />
<a href="#sec.client-requirements">4.</a>&nbsp;
Client-side False Start<br />
<a href="#sec.server-requirements">5.</a>&nbsp;
Server-side False Start<br />
<a href="#sec.security">6.</a>&nbsp;
Security Considerations<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec.security.symmetric">6.1.</a>&nbsp;
Symmetric Cipher<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec.security.keyexchange">6.2.</a>&nbsp;
Key Exchange and Client Certificate Type<br />
<a href="#anchor3">7.</a>&nbsp;
Contributors<br />
<a href="#anchor4">8.</a>&nbsp;
Acknowledgments<br />
<a href="#anchor5">9.</a>&nbsp;
IANA Considerations<br />
<a href="#rfc.references1">10.</a>&nbsp;
References<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#rfc.references1">10.1.</a>&nbsp;
Normative References<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#rfc.references2">10.2.</a>&nbsp;
Informative References<br />
<a href="#app.implementation">Appendix&nbsp;A.</a>&nbsp;
Implementation Notes<br />
<a href="#rfc.authors">&#167;</a>&nbsp;
Authors' Addresses<br />
</p>
<br clear="all" />

<a name="anchor1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1"></a><h3>1.&nbsp;
Requirements Notation</h3>

<p>
        The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT",
        "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in
        <a class='info' href='#RFC2119'>RFC 2119<span> (</span><span class='info'>Bradner, S., &ldquo;Key words for use in RFCs to Indicate Requirement Levels,&rdquo; March&nbsp;1997.</span><span>)</span></a> [RFC2119].
      
</p>
<a name="anchor2"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2"></a><h3>2.&nbsp;
Introduction</h3>

<p>
        A full TLS handshake as specified in <a class='info' href='#RFC5246'>[RFC5246]<span> (</span><span class='info'>Dierks, T. and E. Rescorla, &ldquo;The Transport Layer Security (TLS) Protocol Version 1.2,&rdquo; August&nbsp;2008.</span><span>)</span></a> requires two full protocol
        rounds (four flights) before the handshake is complete and the protocol parties may begin to
        send application data.
        Thus, using TLS can add a latency penalty of two network round-trip times for application
        protocols in which the client sends data first, such as <a class='info' href='#RFC2616'>HTTP<span> (</span><span class='info'>Fielding, R., Gettys, J., Mogul, J., Frystyk, H., Masinter, L., Leach, P., and T. Berners-Lee, &ldquo;Hypertext Transfer Protocol -- HTTP/1.1,&rdquo; June&nbsp;1999.</span><span>)</span></a> [RFC2616].
        An abbreviated handshake (resuming an earlier TLS session) is complete after three flights,
        thus adding just one round-trip time if the client sends application data first.
      
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
   Client                                               Server

   ClientHello                  --------&gt;
                                                   ServerHello
                                                  Certificate*
                                            ServerKeyExchange*
                                           CertificateRequest*
                                &lt;--------      ServerHelloDone
   Certificate*
   ClientKeyExchange
   CertificateVerify*
   [ChangeCipherSpec]
   Finished                     --------&gt;
                                            [ChangeCipherSpec]
                                &lt;--------             Finished
   Application Data             &lt;-------&gt;     Application Data

     Figure 1 [RFC5246].  Message flow for a full handshake
</pre></div>
<p>
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
   Client                                                Server

   ClientHello                   --------&gt;
                                                    ServerHello
                                             [ChangeCipherSpec]
                                 &lt;--------             Finished
   [ChangeCipherSpec]
   Finished                      --------&gt;
   Application Data              &lt;-------&gt;     Application Data

  Figure 2 [RFC5246].  Message flow for an abbreviated handshake
</pre></div>
<p>
        This document describes a technique that alleviates the latency burden imposed by TLS: the TLS
        False Start.  If certain conditions are met, application data can be sent when the handshake
        is only partially complete -- i.e., when the sender has sent its own
        <tt>ChangeCipherSpec</tt> and <tt>Finished</tt>
        messages (thus having updated its TLS Record Protocol write state as negotiated in the
        handshake), but has yet to receive the other side's
        <tt>ChangeCipherSpec</tt> and <tt>Finished</tt>
        messages.
        (By section 7.4.9 of <a class='info' href='#RFC5246'>[RFC5246]<span> (</span><span class='info'>Dierks, T. and E. Rescorla, &ldquo;The Transport Layer Security (TLS) Protocol Version 1.2,&rdquo; August&nbsp;2008.</span><span>)</span></a>, each party would have to delay
        sending application data until it has received and validated the other side's
        <tt>Finished</tt> message.)
        This achieves an improvement of one round-trip time
        </p>
<ul class="text">
<li>
            for full handshakes if the client sends application data first,
          
</li>
<li>
            for abbreviated handshakes if the server sends application data first.
          
</li>
</ul><p>
        Accordingly, the latency penalty for using TLS with HTTP can be kept at one round-trip time
        regardless of whether a full handshake or an abbreviated handshake takes place.
      
</p>
<p>
        In a False Start, when a party sends application data before it has received and verified
        the other party's <tt>Finished</tt> message, there are two possible
        outcomes:
        </p>
<ul class="text">
<li>
            The handshake completes successfully:
            
            Once both <tt>Finished</tt> messages have been received and verified,
            this retroactively validates the handshake.  In this case, the transcript of protocol
            data carried over the transport underlying TLS will look as usual, apart from the
            different timing.
          
</li>
<li>
            The handshake fails:
            
            If a party does not receive the other side's <tt>Finished</tt>
            message, or if the <tt>Finished</tt> message's contents are not
            correct, the handshake never gets validated.  This means that an attacker may have
            removed, changed, or injected handshake messages.  In this case, data has been sent over
            the underlying transport that would not have been sent without the False Start.
          
</li>
</ul><p>
        The latter scenario makes it necessary to restrict when a False Start is allowed,
        as described in this document.
        <a class='info' href='#sec.compatibility'>Section&nbsp;3<span> (</span><span class='info'>False Start Compatibility</span><span>)</span></a> considers basic requirements for using False Start.
        <a class='info' href='#sec.client-requirements'>Section&nbsp;4<span> (</span><span class='info'>Client-side False Start</span><span>)</span></a> and <a class='info' href='#sec.server-requirements'>Section&nbsp;5<span> (</span><span class='info'>Server-side False Start</span><span>)</span></a>
        specify the behavior for clients and servers, respectively, referring to important
        security considerations in <a class='info' href='#sec.security'>Section&nbsp;6<span> (</span><span class='info'>Security Considerations</span><span>)</span></a>.
      
</p>
<a name="sec.compatibility"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3"></a><h3>3.&nbsp;
False Start Compatibility</h3>

<p>
        TLS False Start as described in detail in the subsequent sections,
        if implemented, is an optional feature.
      
</p>
<p>
        A TLS implementation (not necessarily offering the False Start option itself)
        is defined to be "False Start compatible" if it tolerates
        receiving TLS records on the transport connection early, before the protocol
        has reached the state to process these.
        To successfully use False Start in a TLS connection, the other side has to be False Start
        compatible.  Out-of-band knowledge that the peer is False Start compatible may be available,
        e.g. if this is mandated by specific application profile standards.
        As discussed in <a class='info' href='#app.implementation'>Appendix&nbsp;A<span> (</span><span class='info'>Implementation Notes</span><span>)</span></a>,
        the requirement for False Start compatibility does not pose a hindrance in practice.
      
</p>
<a name="sec.client-requirements"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4"></a><h3>4.&nbsp;
Client-side False Start</h3>

<p>
        This section specifies a change to the behavior of TLS client implementations
        in full TLS handshakes.
      
</p>
<p>
        When the client has sent its
        <tt>ChangeCipherSpec</tt> and <tt>Finished</tt>
        messages, its default behavior following <a class='info' href='#RFC5246'>[RFC5246]<span> (</span><span class='info'>Dierks, T. and E. Rescorla, &ldquo;The Transport Layer Security (TLS) Protocol Version 1.2,&rdquo; August&nbsp;2008.</span><span>)</span></a>
        is not to send application data until it has received the server's
        <tt>ChangeCipherSpec</tt> and <tt>Finished</tt>
        messages, which completes the handshake.
        With the False Start protocol modification, the client MAY send application data earlier
        (under the new Cipher Spec) if each of the following conditions is satisfied:
        </p>
<ul class="text">
<li>
            The application layer has requested the TLS False Start option.
          
</li>
<li>
            The symmetric cipher defined by the cipher suite negotiated in this handshake has been
            whitelisted for use with False Start according to the Security Considerations in
            <a class='info' href='#sec.security.symmetric'>Section&nbsp;6.1<span> (</span><span class='info'>Symmetric Cipher</span><span>)</span></a>.
          
</li>
<li>
            The key exchange method defined by the cipher suite negotiated in this handshake,
            has been whitelisted for use with False Start according to
            the Security Considerations in <a class='info' href='#sec.security.keyexchange'>Section&nbsp;6.2<span> (</span><span class='info'>Key Exchange and Client Certificate Type</span><span>)</span></a>.
          
</li>
<li>
            In the case of a handshake with client authentication,
            the client certificate type has been whitelisted for use with False Start according to
            the Security Considerations in <a class='info' href='#sec.security.keyexchange'>Section&nbsp;6.2<span> (</span><span class='info'>Key Exchange and Client Certificate Type</span><span>)</span></a>.
          
</li>
</ul><p>
        The rules for receiving application data from the server remain unchanged.
      
</p>
<p>
        Note that the TLS client cannot infer the presence of an authenticated
        server until all handshake messages have been received.
        With False Start, unlike with the default handshake behavior,
        applications are able to send data before this point has been reached:
        from an application point of view,
        being able to send data does not imply that an authenticated peer is present.
        Accordingly, it is
        recommended that TLS implementations allow the application layer to query whether the
        handshake has completed.
      
</p>
<a name="sec.server-requirements"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5"></a><h3>5.&nbsp;
Server-side False Start</h3>

<p>
        This section specifies a change to the behavior of TLS server implementations
        in abbreviated TLS handshakes.
      
</p>
<p>
        When the server has sent its
        <tt>ChangeCipherSpec</tt> and <tt>Finished</tt>
        messages, its default behavior following <a class='info' href='#RFC5246'>[RFC5246]<span> (</span><span class='info'>Dierks, T. and E. Rescorla, &ldquo;The Transport Layer Security (TLS) Protocol Version 1.2,&rdquo; August&nbsp;2008.</span><span>)</span></a>
        is not to send application data until it has received the client's
        <tt>ChangeCipherSpec</tt> and <tt>Finished</tt>
        messages, which completes the handshake.
        With the False Start protocol modification, the server MAY send application data earlier
        (under the new Cipher Spec) if each of the following conditions is satisfied:
        </p>
<ul class="text">
<li>
            The application layer has requested the TLS False Start option.
          
</li>
<li>
            The symmetric cipher defined by the cipher suite of the session being resumed has been
            whitelisted for use with False Start according to the Security Considerations
            in <a class='info' href='#sec.security.symmetric'>Section&nbsp;6.1<span> (</span><span class='info'>Symmetric Cipher</span><span>)</span></a>.
          
</li>
</ul><p>
        The rules for receiving application data from the client remain unchanged.
      
</p>
<p>
        Note that the TLS server cannot infer the presence of an authenticated
        client until all handshake messages have been received.
        With False Start, unlike with the default handshake behavior,
        applications are able to send data before this point has been reached:
        from an application point of view,
        being able to send data does not imply that an authenticated peer is present.
        Accordingly, it is
        recommended that TLS implementations allow the application layer to query whether the
        handshake has completed.
      
</p>
<a name="sec.security"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6"></a><h3>6.&nbsp;
Security Considerations</h3>

<p>
        In a TLS handshake, the <tt>Finished</tt> messages serve to validate
        the entire handshake.  These messages are based on a hash of the handshake so far
        processed by a PRF keyed with the new master secret (serving as a MAC),
        and are also sent under the new Cipher Spec with its keyed MAC,
        where the MAC key again is derived from the master secret.
        The protocol design relies on the assumption that
        any server and/or client authentication done during the
        handshake carries over to this.  While an attacker could, for example, have changed the
        cipher suite list sent by the client to the server and thus influenced cipher suite
        selection (presumably towards a less secure choice) or could have made other modifications
        to handshake messages in transmission, the attacker would not be able to round off the
        modified handshake with a valid <tt>Finished</tt> message:
        every TLS cipher suite is presumed to key the PRF appropriately
        to ensure unforgeability.  Once the handshake has been validated by verifying
        the <tt>Finished</tt> messages, this confirms that the
        handshake has not been tampered with, thus bootstrapping secure encryption
        (using algorithms as negotiated) from secure authentication.
      
</p>
<p>
        Using False Start interferes with this approach of bootstrapping secure encryption from
        secure authentication, as application data may have already been sent before
        <tt>Finished</tt> validation confirms that the handshake has not been
        tampered with -- so there is generally no hope to be sure that communication with the
        expected peer is indeed taking place during the False Start.
        Instead, the security goal is to ensure that if anyone at all can decrypt the application
        data sent in a False Start, this must be the legitimate peer: while an attacker could be
        influencing the handshake (restricting cipher suite selection, modifying key exchange
        messages, etc.), the attacker should not be able to benefit from this.
        The TLS protocol already relies on such a security property for authentication --
        with False Start, the same is needed for encryption.
        This motivates the following rules.
      
</p>
<a name="sec.security.symmetric"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.1"></a><h3>6.1.&nbsp;
Symmetric Cipher</h3>

<p>
          Clients and servers MUST NOT use the False Start protocol modification in a handshake
          unless the cipher suite uses a symmetric cipher that is considered cryptographically strong.
        
</p>
<p>
          Implementations may have their own classification of ciphers (and may additionally allow
          the application layer to provide a classification), but generally symmetric ciphers with
          an effective key length of 128 bits or more can be considered strong.
          In <a class='info' href='#RFC5246'>[RFC5246]<span> (</span><span class='info'>Dierks, T. and E. Rescorla, &ldquo;The Transport Layer Security (TLS) Protocol Version 1.2,&rdquo; August&nbsp;2008.</span><span>)</span></a>, this allows all cipher suites except those
          using the NULL or 3DES_EDE_CBC ciphers (specifically, it allows the cipher suites using
          RC4_128, AES_128_CBC, or AES_256_CBC).  Implementations that support additional cipher
          suites have to be careful to whitelist only suitable symmetric ciphers; if in doubt, False
          Start should not be used with a given symmetric cipher.
        
</p>
<p>
          While an attacker can change handshake messages to force a downgrade to a less secure
          symmetric cipher than otherwise would have been chosen, this rule ensures that in such
          a downgrade attack no application data will be sent under an insecure symmetric cipher.
          With respect to server-side False Start, if a client has negotiated a TLS session using
          weak symmetric cryptography, this rule prevents attackers from seeing the server
          encrypt more data under this session than normally (if an attacker makes up a
          <tt>ClientHello</tt> message asking to resume such a session,
          no False Start will happen).
        
</p>
<a name="sec.security.keyexchange"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.2"></a><h3>6.2.&nbsp;
Key Exchange and Client Certificate Type</h3>

<p>
          Clients MUST NOT use the False Start protocol modification in a handshake unless the
          cipher suite uses a key exchange method that has been whitelisted for this use.
          Furthermore, when using client authentication, clients MUST NOT use the False Start
          protocol modification unless the client certificate type has been whitelisted for this
          use.
        
</p>
<p>
          Implementations may have their own whitelists of key exchange methods and client
          certificate types (and may additionally allow the application layer to specify
          whitelists).  Generally, out of the options from <a class='info' href='#RFC5246'>[RFC5246]<span> (</span><span class='info'>Dierks, T. and E. Rescorla, &ldquo;The Transport Layer Security (TLS) Protocol Version 1.2,&rdquo; August&nbsp;2008.</span><span>)</span></a>
          and <a class='info' href='#RFC4492'>[RFC4492]<span> (</span><span class='info'>Blake-Wilson, S., Bolyard, N., Gupta, V., Hawk, C., and B. Moeller, &ldquo;Elliptic Curve Cryptography (ECC) Cipher Suites for Transport Layer Security (TLS),&rdquo; May&nbsp;2006.</span><span>)</span></a>, the following whitelists are recommended:
          </p>
<ul class="text">
<li>
              Key exchange methods: DHE_RSA, ECDHE_RSA, DHE_DSS, ECDHE_ECDSA
            
</li>
<li>
              Client certificate types:
              rsa_sign, dss_sign, ecdsa_sign (or no client authentication)
            
</li>
</ul><p>
          However, if an implementation that supports only key exchange methods from 
          <a class='info' href='#RFC5246'>[RFC5246]<span> (</span><span class='info'>Dierks, T. and E. Rescorla, &ldquo;The Transport Layer Security (TLS) Protocol Version 1.2,&rdquo; August&nbsp;2008.</span><span>)</span></a> and <a class='info' href='#RFC4492'>[RFC4492]<span> (</span><span class='info'>Blake-Wilson, S., Bolyard, N., Gupta, V., Hawk, C., and B. Moeller, &ldquo;Elliptic Curve Cryptography (ECC) Cipher Suites for Transport Layer Security (TLS),&rdquo; May&nbsp;2006.</span><span>)</span></a>
          does not support any of the above key exchange methods,
          all of its supported key exchange methods can be whitelisted for False Start use.
          Care is required with any additional key exchange methods or client certificate
          types, as these may not have similar properties.
        
</p>
<p>
          The recommended whitelists are such that
          if cryptographic algorithms suitable for forward secrecy would
          possibly be negotiated, no False Start will take place if the current handshake
          fails to provide forward secrecy.
          (Forward secrecy can be achieved using ephemeral Diffie-Hellman or ephemeral
          Elliptic-Curve Diffie-Hellman;
          there is no forward secrecy when a using key exchange method of
          RSA, RSA_PSK, DH_DSS, DH_RSA, ECDH_ECDSA, or ECDH_RSA,
          or a client certificate type of
          rsa_fixed_dh, dss_fixed_dh, rsa_fixed_ecdh, or ecdsa_fixed_ecdh.)
          As usual, the benefits of forward secrecy may need to be balanced against efficiency,
          and accordingly even implementations that support the above key exchange methods
          might whitelist further key exchange methods and client certificate types from
          <a class='info' href='#RFC5246'>[RFC5246]<span> (</span><span class='info'>Dierks, T. and E. Rescorla, &ldquo;The Transport Layer Security (TLS) Protocol Version 1.2,&rdquo; August&nbsp;2008.</span><span>)</span></a> and <a class='info' href='#RFC4492'>[RFC4492]<span> (</span><span class='info'>Blake-Wilson, S., Bolyard, N., Gupta, V., Hawk, C., and B. Moeller, &ldquo;Elliptic Curve Cryptography (ECC) Cipher Suites for Transport Layer Security (TLS),&rdquo; May&nbsp;2006.</span><span>)</span></a>.
        
</p>
<a name="anchor3"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7"></a><h3>7.&nbsp;
Contributors</h3>

<p>
        Wan-Teh Chang and Ben Laurie have contributed to this document.
      
</p>
<a name="anchor4"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.8"></a><h3>8.&nbsp;
Acknowledgments</h3>

<p>
        The authors wish to thank Eric Rescorla for his comments on an earlier draft.
      
</p>
<a name="anchor5"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.9"></a><h3>9.&nbsp;
IANA Considerations</h3>

<p>
        None.
      
</p>
<a name="rfc.references"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.10"></a><h3>10.&nbsp;
References</h3>

<a name="rfc.references1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>10.1.&nbsp;Normative References</h3>
<table width="99%" border="0">
<tr><td class="author-text" valign="top"><a name="RFC2119">[RFC2119]</a></td>
<td class="author-text"><a href="mailto:sob@harvard.edu">Bradner, S.</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>,&rdquo; BCP&nbsp;14, RFC&nbsp;2119, March&nbsp;1997 (<a href="http://www.rfc-editor.org/rfc/rfc2119.txt">TXT</a>, <a href="http://xml.resource.org/public/rfc/html/rfc2119.html">HTML</a>, <a href="http://xml.resource.org/public/rfc/xml/rfc2119.xml">XML</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4492">[RFC4492]</a></td>
<td class="author-text">Blake-Wilson, S., Bolyard, N., Gupta, V., Hawk, C., and B. Moeller, &ldquo;<a href="http://tools.ietf.org/html/rfc4492">Elliptic Curve Cryptography (ECC) Cipher Suites for Transport Layer Security (TLS)</a>,&rdquo; RFC&nbsp;4492, May&nbsp;2006 (<a href="http://www.rfc-editor.org/rfc/rfc4492.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC5246">[RFC5246]</a></td>
<td class="author-text">Dierks, T. and E. Rescorla, &ldquo;<a href="http://tools.ietf.org/html/rfc5246">The Transport Layer Security (TLS) Protocol Version 1.2</a>,&rdquo; RFC&nbsp;5246, August&nbsp;2008 (<a href="http://www.rfc-editor.org/rfc/rfc5246.txt">TXT</a>).</td></tr>
</table>

<a name="rfc.references2"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>10.2.&nbsp;Informative References</h3>
<table width="99%" border="0">
<tr><td class="author-text" valign="top"><a name="RFC2616">[RFC2616]</a></td>
<td class="author-text"><a href="mailto:fielding@ics.uci.edu">Fielding, R.</a>, <a href="mailto:jg@w3.org">Gettys, J.</a>, <a href="mailto:mogul@wrl.dec.com">Mogul, J.</a>, <a href="mailto:frystyk@w3.org">Frystyk, H.</a>, <a href="mailto:masinter@parc.xerox.com">Masinter, L.</a>, <a href="mailto:paulle@microsoft.com">Leach, P.</a>, and <a href="mailto:timbl@w3.org">T. Berners-Lee</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc2616">Hypertext Transfer Protocol -- HTTP/1.1</a>,&rdquo; RFC&nbsp;2616, June&nbsp;1999 (<a href="http://www.rfc-editor.org/rfc/rfc2616.txt">TXT</a>, <a href="http://www.rfc-editor.org/rfc/rfc2616.ps">PS</a>, <a href="http://www.rfc-editor.org/rfc/rfc2616.pdf">PDF</a>, <a href="http://xml.resource.org/public/rfc/html/rfc2616.html">HTML</a>, <a href="http://xml.resource.org/public/rfc/xml/rfc2616.xml">XML</a>).</td></tr>
</table>

<a name="app.implementation"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.A"></a><h3>Appendix A.&nbsp;
Implementation Notes</h3>

<p>
        TLS False Start is a modification to the TLS protocol, and some implementations that
        conform to <a class='info' href='#RFC5246'>[RFC5246]<span> (</span><span class='info'>Dierks, T. and E. Rescorla, &ldquo;The Transport Layer Security (TLS) Protocol Version 1.2,&rdquo; August&nbsp;2008.</span><span>)</span></a> may have problems interacting with
        implementations that use the False Start modification.
        If the peer uses a False Start, application data records may be received
        directly following the peer's <tt>Finished</tt> message,
        before the TLS implementation has sent its own <tt>Finished</tt> message.
        False Start compatibility as defined in <a class='info' href='#sec.compatibility'>Section&nbsp;3<span> (</span><span class='info'>False Start Compatibility</span><span>)</span></a>
        ensures that these records with application data will simply
        remain buffered for later processing.
      
</p>
<p>
        A False Start compatible TLS implementation does not
        have to be aware of the False Start concept, and is certainly not expected to detect whether
        a False Start handshake is currently taking place: thanks to transport layer buffering,
        typical implementations will be False Start compatible without having been
        designed for it.
      
</p>
<p>
        At the time of writing, the authors are not aware of any deployed TLS implementation
        that is not False Start compatible
        (with one single host still pending investigation).
        However, if an implementation uses a strategy of receiving as many bytes as available
        from the underlying transport during the handshake
        (expecting to find only handshake messages),
        achieving False Start compatibility would likely require special care.
      
</p>
<a name="rfc.authors"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>Authors' Addresses</h3>
<table width="99%" border="0" cellpadding="0" cellspacing="0">
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Adam Langley</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Google Inc.</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">1600 Amphitheatre Parkway</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Mountain View, CA  94043</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">USA</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:agl@google.com">agl@google.com</a></td></tr>
<tr cellpadding="3"><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Nagendra Modadugu</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Google Inc.</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">1600 Amphitheatre Parkway</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Mountain View, CA  94043</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">USA</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:nagendra@cs.stanford.edu">nagendra@cs.stanford.edu</a></td></tr>
<tr cellpadding="3"><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Bodo Moeller</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Google Switzerland GmbH</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Brandschenkestrasse 110</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Zurich  8002</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Switzerland</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:bmoeller@acm.org">bmoeller@acm.org</a></td></tr>
</table>
</body></html>
