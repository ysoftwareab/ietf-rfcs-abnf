Network Working Group                                         Lou Berger
Internet Draft                                           LabN Consulting
Expiration Date: October 1999
                                                             Der-Hwa Gan
                                                  Juniper Networks, Inc.

                                                          George Swallow
                                                     Cisco Systems, Inc.

                                                              April 1999


                   RSVP Refresh Reduction Extensions


                draft-berger-rsvp-refresh-reduct-01.txt

Status of this Memo

   This document is an Internet-Draft and is in full conformance with
   all provisions of Section 10 of RFC2026.  Internet-Drafts are working
   documents of the Internet Engineering Task Force (IETF), its areas,
   and its working groups.  Note that other groups may also distribute
   working documents as Internet-Drafts.

   Internet-Drafts are draft documents valid for a maximum of six months
   and may be updated, replaced, or obsoleted by other documents at any
   time.  It is inappropriate to use Internet-Drafts as reference
   material or to cite them other than as "work in progress."

   To view the current status of any Internet-Draft, please check the
   "1id-abstracts.txt" listing contained in an Internet-Drafts Shadow
   Directory, see http://www.ietf.org/shadow.html.

Abstract

   This document describes a number of mechanisms that reduce the
   refresh overhead of RSVP.  The extensions can be used to reduce
   processing requirements of refresh messages, eliminate the state
   synchronization latency incurred when an RSVP message is lost and,
   when desired, suppress the generation of refresh messages.  An
   extension to support detection of when an RSVP neighbor resets its
   state is also defined.  These extension present no backwards
   compatibility issues.







Berger, et al.                                                  [Page 1]

Internet Draft   draft-berger-rsvp-refresh-reduct-01.txt      April 1999


Contents

 1      Introduction and Background  ...............................   3
 2      RSVP Aggregate Message  ....................................   4
 2.1    Aggregate Header  ..........................................   4
 2.2    Message Formats  ...........................................   5
 2.3    Sending RSVP Aggregate Messages  ...........................   6
 2.4    Receiving RSVP Aggregate Messages  .........................   7
 2.5    Forwarding RSVP Aggregate Messages  ........................   7
 2.6    Aggregate-Capable Bit  .....................................   7
 3      MESSAGE_ID Extension  ......................................   8
 3.1    MESSAGE_ID Object  .........................................   9
 3.2    Ack Message Format  ........................................  10
 3.3    MESSAGE_ID Object Usage  ...................................  11
 3.4    MESSAGE_ID ACK Object Usage  ...............................  13
 3.5    Multicast Considerations  ..................................  13
 3.5.1  Reference RSVP/Routing Interface  ..........................  15
 3.6    Compatibility  .............................................  15
 4      Hello Extension  ...........................................  16
 4.1    Hello Message Format  ......................................  17
 4.2    HELLO Object  ..............................................  17
 4.3    Hello Message Usage  .......................................  18
 4.4    Multi-Link Considerations  .................................  19
 4.5    Compatibility  .............................................  19
 5      Acknowledgments  ...........................................  20
 6      Security Considerations  ...................................  20
 7      References  ................................................  20
 8      Authors' Addresses  ........................................  20







Berger, et al.                                                  [Page 2]

Internet Draft   draft-berger-rsvp-refresh-reduct-01.txt      April 1999


1. Introduction and Background

   The extensions described in this document were motivated by MPLS
   traffic engineering requirements as described in [Awduche].  These
   extensions may be generally useful and may be supported independent
   of other MPLS related RSVP extensions or LSP tunnels.

   The resource requirements (in terms of cpu processing and memory) for
   running RSVP on a router increases proportionally with the number of
   sessions.  Supporting a large number of sessions can present scaling
   problems.

   This document describes mechanisms to help alleviate one set of scal-
   ing issues.  RSVP Path and Resv messages must be periodically
   refreshed to maintain state.  The approach described effectively
   reduces the volume of messages which must be periodically sent and
   received.

   The described mechanisms also address issues of latency and reliabil-
   ity of RSVP Signaling.  The latency and reliability problem occurs
   when a non-refresh RSVP message is lost in transmission.  Standard
   RSVP [RFC2205] maintains state via the generation of RSVP refresh
   messages.  In the face of transmission loss of RSVP messages, the
   end-to-end latency of RSVP signaling is tied to the refresh interval
   of the node(s) experiencing the loss.  When end-to-end signaling is
   limited by the refresh interval, the establishment or change of a
   reservation may be beyond the range of what is acceptable for some
   applications.

   One way to address the refresh volume problem is to increase the
   refresh timer R.  Increasing the value of R provides linear improve-
   ment on transmission overhead, but at the cost of increasing refresh
   timeout.

   One way to address the latency and reliability of RSVP Signaling is
   to decrease the refresh timer R.  Decreasing the value of R provides
   increased probability that state will be installed in the face of
   message loss, but at the cost of increasing refresh message rate and
   associated processing requirements.

   The extensions defined in this document address both the refresh vol-
   ume and the reliability issues with mechanisms other than adjusting
   refresh rate.  An aggregate message is defined to reduce overall mes-
   sage handing load.  A Message_ID object is defined to reduce refresh
   message processing by allowing the receiver to more readily identify
   an unchanged message.  A Message_ACK object is defined which can be
   used to detect message loss and, when used in combination with the
   Message_ID object, can be used to suppress refresh messages



Berger, et al.                                                  [Page 3]

Internet Draft   draft-berger-rsvp-refresh-reduct-01.txt      April 1999


   altogether.  Finally, a hello protocol is defined to allow detection
   of the loss of a neighbor node or a reset of it's RSVP state informa-
   tion.


2. RSVP Aggregate Message

   An RSVP aggregate message consists of an aggregate header followed by
   a body consisting of a variable number of standard RSVP messages.
   The following subsections define the formats of the aggregate header
   and the rules for including standard RSVP messages as part of the
   message.


2.1. Aggregate Header


       0                   1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      | Vers  | Flags |   Msg type    |         RSVP checksum         |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |   Send_TTL    |  (Reserved)   |         RSVP length           |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

   The format of the aggregate header is identical to the format of the
   RSVP common header [RFC2205].  The fields in the header are as fol-
   lows:

      Vers: 4 bits

         Protocol version number.  This is version 1.

      Flags: 4 bits

         0x01: Aggregate capable

           If set, indicates to RSVP neighbors that this node is willing
           and capable of receiving aggregate messages.  This bit is
           meaningful only between adjacent RSVP neighbors.

         0x02-0x08: Reserved

      Msg type: 8 bits

         12 = Aggregate





Berger, et al.                                                  [Page 4]

Internet Draft   draft-berger-rsvp-refresh-reduct-01.txt      April 1999


      RSVP checksum: 16 bits

         The one's complement of the one's complement sum of the entire
         message, with the checksum field replaced by zero for the pur-
         pose of computing the checksum.  An all-zero value means that
         no checksum was transmitted.  Because individual sub-messages
         carry their own checksum as well as the INTEGRITY object for
         authentication, this field MAY be set to zero.

      Send_TTL: 8 bits

         The IP TTL value with which the message was sent.  This is used
         by RSVP to detect a non-RSVP hop by comparing the IP TTL that
         an Aggregate message sent to the TTL in the received message.

      RSVP length: 16 bits

         The total length of this RSVP aggregate message in bytes,
         including the aggregate header and the sub-messages that fol-
         low.


2.2. Message Formats

   An RSVP aggregate message must contain at least one sub-message.  A
   sub-message is one of the RSVP Path, PathTear, PathErr, Resv,
   ResvTear, ResvErr, ResvConf, Ack or Hello messages.

   Empty RSVP aggregate messages should not be sent.  It is illegal to
   include another RSVP aggregate message as a sub-message.

       0                   1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      | Vers  | Flags |    12         |         RSVP checksum         |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |   Send_TTL    |  (Reserved)   |         RSVP length           |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                                                               |
      //                   First sub-message                         //
      |                                                               |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                                                               |
      //                   More sub-messages..                       //
      |                                                               |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+





Berger, et al.                                                  [Page 5]

Internet Draft   draft-berger-rsvp-refresh-reduct-01.txt      April 1999


2.3. Sending RSVP Aggregate Messages

   RSVP Aggregate messages are sent hop by hop between RSVP-capable
   neighbors as "raw" IP datagrams with protocol number 46.  Raw IP
   datagrams are also intended to be used between an end system and the
   first/last hop router, although it is also possible to encapsulate
   RSVP messages as UDP datagrams for end-system communication that can-
   not perform raw network I/O.

   RSVP Aggregate messages MUST not be used if the next hop RSVP neigh-
   bor does not support RSVP Aggregate messages.  Methods for discover-
   ing such information include: (1) manual configuration and (2)
   observing the Aggregate-capable bit (see the description that fol-
   lows) in the received RSVP messages.

   Support for RSVP Aggregate messages is optional.  While message
   aggregation helps in scaling RSVP, and in reducing processing over-
   head and bandwidth consumption, a node is not required to transmit
   every standard RSVP message in an Aggregate message.  A node MUST
   always be ready to receive standard RSVP messages.

   The IP source address is local to the system that originated the
   Aggregate message.  The IP destination address is the next hop node
   for which the sub-messages are intended.  These addresses need not be
   identical to those used if the sub-messages were sent as standard
   RSVP messages.

   For example, the IP source address of Path and PathTear messages is
   the address of the sender it describes, while the IP destination
   address is the DestAddress for the session.  These end-to-end
   addresses are overridden by hop-by-hop addresses while encapsulated
   in an Aggregate message.  These addresses can easily be restored from
   the SENDER_TEMPLATE and SESSION objects within Path and PathTear mes-
   sages.  For Path and PathTear messages, the next hop node can be
   identified either via a received ACK or from a received corresponding
   Resv message.  Path and PathTear messages for multicast sessions MUST
   NOT be sent in Aggregate messages.

   RSVP Aggregate messages SHOULD NOT be sent with the Router Alert IP
   option in their IP headers.  This is because Aggregate messages are
   addressed directly to RSVP neighbors.

   Each RSVP Aggregate message MUST occupy exactly one IP datagram.  If
   it exceeds the MTU, the datagram is fragmented by IP and reassembled
   at the recipient node.  A single RSVP Aggregate message MUST NOT
   exceed the maximum IP datagram size, which is approximately 64K
   bytes.




Berger, et al.                                                  [Page 6]

Internet Draft   draft-berger-rsvp-refresh-reduct-01.txt      April 1999


2.4. Receiving RSVP Aggregate Messages

   If the local system does not recognize or does not wish to accept an
   Aggregate message, the received messages shall be discarded without
   further analysis.

   The receiver next compares the IP TTL with which an Aggregate message
   is sent to the TTL with which it is received.  If a non-RSVP hop is
   detected, the number of non-RSVP hops is recorded.  It is used later
   in processing of sub-messages.

   Next, the receiver verifies the version number and checksum of the
   RSVP aggregate message and discards the message if any mismatch is
   found.

   The receiver then starts decapsulating individual sub-messages.  Each
   sub-message has its own complete message length and authentication
   information.  Each sub-message is processed per standard RSVP.


2.5. Forwarding RSVP Aggregate Messages

   When an RSVP router receives an Aggregate messages which is not
   addressed to one of it's IP addresses, it SHALL forward the message.
   Non-RSVP routers will treat RSVP Aggregate messages as any other IP
   datagram.

   When individual sub-messages are being forwarded, they MAY be encap-
   sulated in another aggregate message before sending to the next hop
   neighbor.  The Send_TTL field in the sub-messages should be decre-
   mented properly before transmission.


2.6. Aggregate-Capable Bit



   To support message aggregation, an additional capability bit is added
   to the common RSVP header, which is defined in [RFC2205].

       0                   1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |  Vers | Flags |   Msg Type    |         RSVP Checksum         |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |   Send_TTL    |  (Reserved)   |         RSVP Length           |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+




Berger, et al.                                                  [Page 7]

Internet Draft   draft-berger-rsvp-refresh-reduct-01.txt      April 1999


      Flags: 4 bits

         0x01: Aggregate capable

           If set, indicates to RSVP neighbors that this node is willing
           and capable of receiving aggregate messages.  This bit is
           meaningful only between adjacent RSVP neighbors.


3. MESSAGE_ID Extension

   Two new objects are defined as part of the MESSAGE_ID extension.  The
   two object types are the MESSAGE_ID object and the MESSAGE_ID ACK
   object.  The objects are used to support acknowledgments and, when
   used in conjunction with the Hello Extension described in Section 4,
   to indicate when refresh messages are not needed after an acknowledg-
   ment.  When refreshes are normally generated, the MESSAGE_ID object
   can also be used to simply provide a shorthand indication of when a
   message represents new state.  Such information can be used on the
   receiving node to reduce refresh processing requirements.

   Message identification and acknowledgment is done on a hop-by-hop
   basis.  Acknowledgment is handled independent of SESSION or message
   type.  Both types of MESSAGE_ID objects contain a message identifier.
   The identifier MUST be unique on a per source IP address basis across
   messages sent by an RSVP node and received by a particular node.  No
   more than one MESSAGE_ID object may be included in an RSVP message.
   Each message containing an MESSAGE_ID object may be acknowledged via
   a MESSAGE_ID ACK object.  MESSAGE_ID ACK objects may be sent piggy-
   backed in unrelated RSVP messages or in RSVP ACK messages

   Either type of MESSAGE_ID object may be included in an aggregate sub-
   message.  When included, the object is treated as if it were con-
   tained in a standard, unaggregated, RSVP message.  Only one MES-
   SAGE_ID object MAY be included in a (sub)message and it MUST follow
   any present MESSAGE_ID ACK objects.  When no MESSAGE_ID ACK objects
   are present, the MESSAGE_ID object MUST immediately follow the
   INTEGRITY object.  When no INTEGRITY object is present, the MES-
   SAGE_ID object MUST immediately follow the (sub)message header.

   When present, one or more MESSAGE_ID ACK objects MUST immediately
   follow the INTEGRITY object.  When no INTEGRITY object is present,
   the MESSAGE_ID ACK objects MUST immediately follow the the (sub)mes-
   sage header.  An MESSAGE_ID ACK object may only be included in a mes-
   sage when the message's IP destination address matches the unicast
   address of the node that generated the message(s) being acknowledged.





Berger, et al.                                                  [Page 8]

Internet Draft   draft-berger-rsvp-refresh-reduct-01.txt      April 1999


3.1. MESSAGE_ID Object


   MESSAGE_ID Class = 166 (Value to be assigned by IANA of form
   10bbbbbb)

   MESSAGE_ID object

      Class = MESSAGE_ID Class, C_Type = 1

       0                   1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |     Flags     |                  Message ID                   |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

         Flags: 8 bits

            0x80 = ACK_Desired flag

             Indicates that the sender is willing to accept a message
             acknowledgment.  Acknowledgments MUST be silently ignored
             when they are sent in response to messages whose
             ACK_Desired flag is not set.  This flag MUST be set when
             the Last_Refresh flag is set.

            0x40 = Last_Refresh flag

             Used in Resv and Path refresh messages to indicate that the
             sender will not be sending further refreshes.  When set,
             the ACK_Desired flag MUST also be set.  This flag MUST NOT
             be set when the HELLO messages are not being exchanged with
             the neighboring RSVP node.

         Message ID: 24 bits

            a 24-bit identifier.  When combined with the message
            generator's IP address, uniquely identifies a message.













Berger, et al.                                                  [Page 9]

Internet Draft   draft-berger-rsvp-refresh-reduct-01.txt      April 1999


   MESSAGE_ID ACK object

      Class = MESSAGE_ID Class, C_Type = 2

       0                   1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |   Reserved    |                  Message ID                   |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
         Reserved

            This field is reserved.  It MUST be set to zero on transmis-
            sion and MUST be ignored on receipt.

          Message ID: 24 bits

            a 24-bit identifier.  When combined with the message
            generator's IP address, uniquely identifies a message.


3.2. Ack Message Format

   Ack messages carry one or more MESSAGE_ID ACK objects.  They MUST NOT
   contain any MESSAGE_ID objects.  Ack messages are sent hop-by-hop
   between RSVP nodes.  The IP destination address of an Ack message is
   the unicast address of the node that generated the message(s) being
   acknowledged.  For Path, PathTear, Resv, and RervErr messages this is
   taken from the RSVP_HOP Object.  For PathErr and ResvErr messages
   this is taken from the message's source address.  The IP source
   address is an address of the node that sends the Ack message.

   The Ack message format is as follows:

     <ACK Message> ::= <Common Header> [ <INTEGRITY> ]
                           <MESSAGE_ID ACK>
                           [ <MESSAGE_ID ACK> ... ]

   For Ack messages, the Msg Type field of the Common Header MUST be set
   to 13 (Value to be assigned by IANA).












Berger, et al.                                                 [Page 10]

Internet Draft   draft-berger-rsvp-refresh-reduct-01.txt      April 1999


3.3. MESSAGE_ID Object Usage

   The MESSAGE_ID object may be included in any RSVP message other than
   the Ack message.  The MESSAGE_ID object is always generated and pro-
   cessed hop-by-hop.  The IP address of the object generator is repre-
   sented in a per RSVP message type specific fashion.  For Path and
   PathTear messages the generator's IP address is contained in the
   RSVP_HOP.  For Resv, ResvTear, PathErr, ResvErr, ResvConf and Aggre-
   gate messages the generator's IP address is the source address in the
   IP header.

   The Message ID field contains a generator selected value.  This
   value, when combined with the generator's IP address, identifies a
   particular RSVP message and the specific state information it repre-
   sents.  When a node is sending a refresh message with a MESSAGE_ID
   object, it SHOULD use the same Message ID value that was used in the
   RSVP message that first advertised the state being refreshed.  When a
   node is sending a message that represents new or changed state, the
   Message ID value MUST have a value that is not otherwise in use.  A
   value is considered to be in use when it has been used in the most
   recent advertisement or refresh of any state using the associated IP
   address.  Care must also be taken to avoid reuse of a previously used
   value during times of network loss.  At such times, the use of new
   values may not be noticed by receivers.  There is no requirement for
   Message ID values to be increasing or ordered.

   The ACK_Desired flag is set when the MESSAGE_ID object generator is
   capable of accepting MESSAGE_ID ACK objects.  Such information can be
   used to ensure reliable delivery of error and confirm messages and to
   support fast refreshes in the face of network loss.  Nodes setting
   the ACK_Desired flag SHOULD retransmit unacknowledged messages at a
   faster interval than the standard refresh time until the message is
   acknowledged or a "fast" retry limit is reached.  Note that nodes
   setting the ACK_Desired flag for unicast sessions, do not need to
   track the identify of the next hop since all that is expected is an
   ACK, not an ACK from a specific next hop.  Issues relate to multicast
   sessions are covered in a later section.

   The Last_Refresh flag may be set in Path and Resv messages when the
   MESSAGE_ID object generator is exchanging Hello messages, described
   in Section 4, with the next hop RSVP node.  When a refresh message
   with the Last_Refresh flag set is generated, normal refresh genera-
   tion MUST continue until the message containing the Last_Refresh flag
   is acknowledged.  Although, messages removing state advertised in
   such messages MUST be retransmit until acknowledged or a maximum
   retry limit is reached in order to cover certain packet loss condi-
   tions.  Messages removing state include PathTear and ResvTear.




Berger, et al.                                                 [Page 11]

Internet Draft   draft-berger-rsvp-refresh-reduct-01.txt      April 1999


   When sending MESSAGE_ID objects with the Last_Refresh flag set, spe-
   cial care must be taken to properly advertise state.  Specifically,
   refresh processing MUST continue per standard RSVP processing until
   after a acknowledgment is received.  Suppression of refresh process-
   ing MAY ONLY occur after an acknowledgment is received for a MES-
   SAGE_ID object with the Last_Refresh flag set.  Note that the
   Last_Refresh flag MAY ONLY be set when the RSVP next hop is exchang-
   ing Hello messages with the message generator.

   When a Path message for a new session arrives, the RSVP next hop may
   not always be known.  When the RSVP next hop is not known, the
   Last_Refresh flag MUST NOT be set.  Once the next hop of a unicast
   session is identified, only then may the Last_Refresh flag be set.
   (Issues relate to multicast sessions are covered in a later section.)
   There are several ways to identify the RSVP next hop of a new unicast
   session.  Some are more conservative than other, e.g., waiting for a
   Resv message versus checking if the other end of a PPP link supports
   Hello messages.  Since there are no interoperability issues, the spe-
   cific mechanism used to identify the RSVP next hop of a new session
   is a specific implementation choice.  In most implementations, it is
   expected that an advertiser of Path state will do standard refresh
   processing until either an ACK is received for a Path message adver-
   tising a new session, or a corresponding Resv message is received.

   Nodes receiving messages containing MESSAGE_ID objects SHOULD use the
   information in the objects to aid in determining if a message repre-
   sents new state or a state refresh.  Note that state is only
   refreshed in Path and Resv messages.  If a Path or Resv message con-
   tains the same Message_ID value that was used in the most recently
   received message for the same session and, for Path messages,
   SENDER_TEMPLATE then the receiver SHOULD treat the message as a state
   refresh.  If the Message ID value differs from the most recently
   received value, the receiver MUST fully processes the message.

   Nodes receiving a message containing a MESSAGE_ID object with the
   ACK_Desired flag set, SHOULD respond with a MESSAGE_ID ACK object.
   If a node supports the Hello extension it MUST also check the
   Last_Refresh flag of received Resv and Path messages.  If the flag is
   set, the receiver MUST NOT timeout state associated with associated
   message.  The receiver MUST also be prepared to properly process
   refresh messages.  Messages containing a MESSAGE_ID ACK object with
   the Last_Refresh flag set MUST NOT be acknowledged when either the
   receiving node doesn't support the Hello extension or Hello messages
   aren't being exchanged with the message generator.







Berger, et al.                                                 [Page 12]

Internet Draft   draft-berger-rsvp-refresh-reduct-01.txt      April 1999


3.4. MESSAGE_ID ACK Object Usage

   The MESSAGE_ID ACK object is used to acknowledge receipt of messages
   containing MESSAGE_ID objects that were sent with the ACK_Desired
   flag set.  The Message ID field of a MESSAGE_ID ACK object MUST have
   the same value as was received.  A MESSAGE_ID ACK object MUST NOT be
   generated in response to a received MESSAGE_ID object when the
   ACK_Desired flag is not set.

   A MESSAGE_ID ACK object MAY be sent in any RSVP message that has an
   IP destination address matching the generator of the associated MES-
   SAGE_ID object.  The MESSAGE_ID ACK object will not typically be
   included in the non hop-by-hop Path, PathTear and ResvConf messages.
   When no appropriate message is available, one or more MESSAGE_ID ACK
   objects SHOULD be sent in an Ack message.  Implementations SHOULD
   include MESSAGE_ID ACK objects in standard RSVP messages when possi-
   ble.

   Upon receiving a MESSAGE_ID ACK object for a message generated with a
   MESSAGE_ID object with the Last_Refresh flag set, normal refresh gen-
   eration SHOULD be suppressed for the associated state.  As previously
   mentioned, special care must be taken to properly advertise state
   when sending MESSAGE_ID objects with the Last_Refresh flag set, see
   section 3.3.


3.5. Multicast Considerations

   Path and PathTear messages may be sent to IP multicast destination
   addresses.  When the destination is a multicast address, it is possi-
   ble that a single message containing a single MESSAGE_ID object will
   be received by multiple RSVP next hops.  When the ACK_Desired flag is
   set in this case, acknowledgment processing is more complex.  There
   are a number of issues to be addressed including ACK implosion, num-
   ber acknowledgments to be expected and handling of new receivers.

   ACK implosion occurs when each receiver responds to the MESSAGE_ID
   object at approximately the same time.  This can lead to a poten-
   tially large number of MESSAGE_ID ACK objects being simultaneously
   delivered to the message generator.  To address this case, the
   receiver MUST wait a random interval prior to acknowledging a MES-
   SAGE_ID object received in a message destined to a multicast address.
   The random interval SHOULD be between zero (0) and a configured maxi-
   mum time.  The configured maximum SHOULD be set in proportion to the
   refresh and "fast" retransmission interval.

   A more fundamental issue is the number of acknowledgments that the
   upstream node, i.e., the message generator, should expect.  The



Berger, et al.                                                 [Page 13]

Internet Draft   draft-berger-rsvp-refresh-reduct-01.txt      April 1999


   number of acknowledgments that should be expected is the same as the
   number of RSVP next hops.  In the router-to-router case, the number
   of next hops can usually be obtained from routing.  When hosts are
   either the upstream node or the next hops, the number of next hops
   will typically not be readily available.  Another case where the num-
   ber of RSVP next hops will typically not be known is when there are
   non-RSVP routers between the message generator and the RSVP next
   hops.

   When the number of next hops is not known, the message generator
   SHOULD only expect a single response and MUST NOT set the
   Last_Refresh flag in MESSAGE_ID objects.  The result of this behavior
   will be special retransmission handling until the message is deliv-
   ered to at least one next hop, then followed by standard RSVP
   refreshes.  Standard refresh messages will synchronize state with any
   next hops that don't receive the original message.

   Another issue is handling new receivers.  It is possible that after
   sending a Path message and handling of expected number of acknowledg-
   ments that a new receiver joins the group.  In this case a new Path
   message must be sent to the new receiver.  When normal refresh pro-
   cessing is occurring, there is no issue.  When normal refresh pro-
   cessing is suppressed, a Path message must still be generated.  In
   the router-to-router case, the identification of new next hops can
   usually be obtained from routing.  When hosts are either the upstream
   node or the next hops, the identification of new next hops will typi-
   cally not be possible.  Another case where the identification of new
   RSVP next hops will typically not be possible is when there are non-
   RSVP routers between the message generator and the RSVP next hops.

   When identification of new next hops is not possible, the message
   generator SHOULD only expect a single response and MUST NOT set the
   Last_Refresh flag in MESSAGE_ID objects.  The result of this behavior
   will be special retransmission handling until the message is deliv-
   ered to at least one next hop, then followed by standard RSVP
   refreshes.  Standard refresh messages will synchronize state with any
   next hops that don't receive the original message either due to loss
   or not yet being a group member.

   There is one additional minor issue with multiple next hops.  The
   issue is handling a combination of standard-refresh and non-refresh
   next hops, i.e., Hello messages are being exchanged with some neigh-
   boring nodes but not with others.  When this case occurs, refreshes
   MUST be generated per standard RSVP and the Last_Refresh flag MUST
   NOT be set.






Berger, et al.                                                 [Page 14]

Internet Draft   draft-berger-rsvp-refresh-reduct-01.txt      April 1999


3.5.1. Reference RSVP/Routing Interface

   When using the MESSAGE_ID extension with multicast sessions it is
   preferable for RSVP to obtain the number of next hops from routing
   and to be notified when that number changes.  The interface between
   routing and RSVP is purely an implementation issue.  Since RSVP
   [RFC2205] describes a reference routing interface, we present a ver-
   sion of the RSVP/routing interface updated to provide number of next
   hop information.  See [RFC2205] for previously defined parameters and
   function description.

       o    Route Query
            Mcast_Route_Query( [ SrcAddress, ] DestAddress,
                                Notify_flag )
                                -> [ IncInterface, ] OutInterface_list,
                                   NHops_list

       o    Route Change Notification
            Mcast_Route_Change( ) -> [ SrcAddress, ] DestAddress,
                              [ IncInterface, ] OutInterface_list,
                              NHops_list

       NHops_list provides the number of multicast group members
       reachable via each OutInterface_list entry.


3.6. Compatibility

   There are no backward compatibility issues raised by the MESSAGE_ID
   Class.  The MESSAGE_ID Class has an assigned value whose form is
   10bbbbbb.  Per RSVP [RFC2205], classes with values of this form must
   be ignored and not forwarded by nodes not supporting the class.  When
   the receiver of a MESSAGE_ID object does not support the class, the
   object will be silently ignored.  The generator of the MESSAGE_ID
   object will not see any acknowledgments and therefore refresh mes-
   sages per standard RSVP.  Lastly, since the MESSAGE_ID ACK object can
   only be issued in response to the MESSAGE_ID object, there are no
   possible issues with this object or Ack messages.

   Implementations supporting Path and Resv state refresh suppression
   via the MESSAGE_ID object's Last_Refresh flag MUST also support the
   Hello extension.  Such implementations SHOULD initiate Hello process-
   ing and MUST be able to respond to Hello messages.








Berger, et al.                                                 [Page 15]

Internet Draft   draft-berger-rsvp-refresh-reduct-01.txt      April 1999


4. Hello Extension

   The RSVP Hello extension enables RSVP nodes to detect a loss of a
   neighboring node's state information.  In standard RSVP, such detec-
   tion occurs as a consequence of RSVP's soft state model.  When
   refresh message generation is suppressed via the previously discussed
   Last_Refresh flag processing, the Hello extension is needed to
   address this failure case.  The Hello extensions is not intended to
   provide a link failure detection mechanism, particularly in the case
   of multiple parallel unnumbered links.

   The Hello extension is specifically designed so that one side can use
   the mechanism while the other side does not.  Neighbor RSVP state
   tracking may be initiated at any time.  This includes when neighbors
   first learn about each other, or just when neighbors are sharing Resv
   or Path state.  As previously stated, all implementations supporting
   state refresh suppression are required to also support the Hello
   Extension.

   The Hello extension is composed of a Hello message, a HELLO REQUEST
   object and a HELLO ACK object.  Hello processing between two neigh-
   bors supports independent selection of, typically configured, failure
   detection intervals.  Each neighbor can autonomously issue HELLO
   REQUEST objects.  Each request is answered by an acknowledgment.
   Hello Messages also contain enough information so that one neighbor
   can suppress issuing hello requests and still perform neighbor fail-
   ure detection.  A Hello message may be included as a sub-message
   within an aggregate message.

   Neighbor state tracking is accomplished by collecting and storing a
   neighbor's state "instance" value.  If a change in value is seen,
   then the neighbor is presumed to have reset it's RSVP state.  When a
   neighbor's value is seen to change or when communication is lost with
   a neighbor, then the instance value advertised to that neighbor is
   also changed.  The HELLO objects provide a mechanism for polling for
   and providing an RSVP state instance value.  A poll request also
   includes the sender's instance value.  This allows the receiver of a
   poll to optionally treat the poll as an implicit poll response.  This
   optional handling is an optimization that can reduce the total number
   of polls and responses processed by a pair of neighbors.  In all
   cases, when both sides support the optimization the result will be
   only one set of polls and responses per failure detection interval.
   Depending on selected intervals, the same benefit can occur even when
   only one neighbor supports the optimization.







Berger, et al.                                                 [Page 16]

Internet Draft   draft-berger-rsvp-refresh-reduct-01.txt      April 1999


4.1. Hello Message Format

   Hello Messages are always sent between two RSVP neighbors.  The IP
   source address is the IP address of the sending node.  The IP desti-
   nation address is the IP address of the neighbor node.

   The Hello message format is as follows:

     <Hello Message> ::= <Common Header> [ <INTEGRITY> ]
                             <HELLO>

   For Hello messages, the Msg Type field of the Common Header MUST be
   set to 14 (Value to be assigned by IANA).


4.2. HELLO Object


   HELLO Class =  22 (Value to be assigned by IANA of form 0bbbbbbb)

   HELLO REQUEST object

      Class = HELLO Class, C_Type = 1

       0                   1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                            Instance                           |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

   HELLO ACK object
      Class = HELLO Class, C_Type = 2

       0                   1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                            Instance                           |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

         Instance: 32 bits

         a 32 bit value that represents the sender's RSVP agent's state.
         The advertiser maintains a per neighbor representation/value.
         This value MUST change when the agent is reset, when the node
         reboots, or when a failure of the neighboring node is detected
         and otherwise remains the same.  This field MUST NOT be set to
         zero (0).




Berger, et al.                                                 [Page 17]

Internet Draft   draft-berger-rsvp-refresh-reduct-01.txt      April 1999


4.3. Hello Message Usage

   A Hello message containing a HELLO REQUEST object MUST be generated
   for each neighbor who's state is being tracked.  When generating a
   message containing a HELLO REQUEST object, the sender fills in the
   Instance field with a value representing it's per neighbor RSVP agent
   state.  This value MUST NOT change while the agent is maintaining any
   RSVP state with the corresponding neighbor.  The generation of a mes-
   sage SHOULD be skipped when a HELLO REQUEST object was received from
   the destination node within the failure detection interval.

   On receipt of a message containing a HELLO REQUEST object, the
   receiver MUST generate a Hello message containing a HELLO ACK object.
   The receiver SHOULD also verify that the neighbor has not reset.
   This is done by comparing the sender's Instance field value with the
   previously received value.  If the value differs, than the neighbor
   has reset and all state associated with the neighbor MUST be
   "expired" and cleaned up per standard RSVP processing.  Additionally,
   all Path state advertised to the neighbor MUST be refreshed.  If any
   state is removed or needs to be refreshed as a result of detecting a
   change in a received Instance field value, then the value advertised
   in the HELLO ACK object MUST be be different from the previously
   advertised value.  This new value MUST continue to be advertised to
   the corresponding neighbor until a reset or reboot occurs, or until
   another neighbor reset is detected.

   On receipt of a message containing a HELLO ACK object, the receiver
   MUST verify that the neighbor has not reset.  This is done by compar-
   ing the sender's Instance field value with the previously received
   value.  If the value differs, than the neighbor has reset and all
   state associated with the neighbor MUST be "expired" and cleaned up
   per standard RSVP processing.  Additionally, all Path state adver-
   tised to the neighbor MUST be refreshed.  If any state is removed or
   needs to be refreshed as a result of detecting a change in a received
   Instance field value, then a new HELLO message MUST be immediately
   issued with a value different then the one advertised in the previous
   HELLO message.  This new value MUST continue to be advertised to the
   corresponding neighbor until a reset or reboot occurs, or until
   another neighbor reset is detected.

   If no Instance value is received, via either REQUEST or ACK objects,
   from a neighbor within a configured number of failure detection
   intervals, then a node MUST treat the neighbor as if it has reset.
   Specifically, all state associated with the neighbor MUST be
   "expired" and cleaned up per standard RSVP processing, and all Path
   state advertised to the neighbor MUST be refreshed.  If any state is
   removed or needs to be refreshed as a result of this case, then a new
   HELLO message MUST be immediately issued with a value different then



Berger, et al.                                                 [Page 18]

Internet Draft   draft-berger-rsvp-refresh-reduct-01.txt      April 1999


   the one advertised in the previous HELLO message.  This new value
   MUST continue to be advertised to the corresponding neighbor until a
   reset or reboot occurs, or until another neighbor reset is detected.


4.4. Multi-Link Considerations

   As previously noted, the Hello extension is targeted at detecting
   node failures not per link failures.  When there is only one link
   between neighboring nodes or when all links between a pair of nodes
   fail, the distinction between node and link failures is not really
   meaningful and handling of such failures has already been covered.
   When there are multiple links shared between neighbors, there are
   special considerations.  When the links between neighbors are num-
   bered, then Hellos MUST be run on each link and the previously
   described mechanisms apply.

   When the links are unnumbered, link failure detection MUST be pro-
   vided by some means other than Hellos.  Each node SHOULD use a single
   Hello exchange with the neighbor.  When a node removes state due to a
   link failure, the node MUST advertise the removal of the state, via
   appropriate Tear messages, over a non-failed link.  The case where
   all links have failed, is the same as the no received value case men-
   tioned in the previous section.


4.5. Compatibility

   The Hello extension is fully backwards compatible.  The Hello class
   is assigned a class value of the form 0bbbbbbb.  Depending on the
   implementation, implementations that don't support the extension will
   either silently discard Hello messages or will respond with an
   "Unknown Object Class" error.  In either case the sender will fail to
   see an acknowledgment for the issued Hello.  When a Hello sender does
   not receive an acknowledgment, it MUST NOT send MESSAGE_ID objects
   with the Last_Refresh flag set.  This restriction will preclude
   neighbors from getting out of RSVP state synchronization.

   Implementations supporting the Hello extension MUST also support the
   MESSAGE_ID extension and refresh suppression.











Berger, et al.                                                 [Page 19]

Internet Draft   draft-berger-rsvp-refresh-reduct-01.txt      April 1999


5. Acknowledgments

   This document represents ideas and comments from the MPLS-TE design
   team.  Thanks to Yoram Bernet, Fred Baker, Andreas Terzis and David
   Mankins for the good feedback.


6. Security Considerations

   No new security issues are raised in this document.  See [RFC2205]
   for a general discussion on RSVP security issues.

7. References

[Awduche] Awduche, D. et al. Requirements for Traffic Engineering
          over MPLS,  Internet Draft,
          draft-awduche-mpls-traffic-eng-00.txt, April 1998.

[RFC2119] Bradner, S., "Key words for use in RFCs to Indicate
          Requirement Levels," RFC 2119.

[RFC2205] Braden, R. Ed. et al, "Resource ReserVation Protocol
           -- Version 1 Functional Specification", RFC 2205,
           September 1997.

8. Authors' Addresses


   Lou Berger
   LabN Consulting
   Voice:  +1 301 468 9228
   Email:  lberger@tidalwave.net

   Der-Hwa Gan
   Juniper Networks, Inc.
   385 Ravendale Drive
   Mountain View, CA 94043
   Voice:  +1 650 526 8074
   Email:  dhg@juniper.net

   George Swallow
   Cisco Systems, Inc.
   250 Apollo Drive
   Chelmsford, MA 01824
   Voice:  +1 978 244 8143
   Email:  swallow@cisco.com





Berger, et al.                                                 [Page 20]
