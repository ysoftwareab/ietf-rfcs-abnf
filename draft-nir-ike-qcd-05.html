<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="en"><head><title>A Quick Crash Detection Method for IKE</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="description" content="A Quick Crash Detection Method for IKE">
<meta name="keywords" content="Internet-Draft">
<meta name="generator" content="xml2rfc v1.35 (http://xml.resource.org/)">
<meta name="viewport" content="width=600;" />
<style type='text/css'><!--
        body {
                font-family: verdana, charcoal, helvetica, arial, sans-serif;
                font-size: 85%;
		max-width: 40em; 
		color: #000; background-color: #FFF;
                margin: 2em;
        }
        h1, h2, h3, h4, h5, h6 {
                font-family: helvetica, monaco, "MS Sans Serif", arial, sans-serif;
                font-weight: bold; font-style: normal;
        }
        h1 { color: #900; background-color: transparent; text-align: right; }
        h3 { color: #333; background-color: transparent; }

        td.RFCbug {
                font-size: x-small; text-decoration: none;
                width: 30px; height: 30px; padding-top: 2px;
                text-align: justify; vertical-align: middle;
                background-color: #000;
        }
        td.RFCbug span.RFC {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: bold; color: #666;
        }
        td.RFCbug span.hotText {
                font-family: charcoal, monaco, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: normal; text-align: center; color: #FFF;
        }

        table.TOCbug { width: 30px; height: 15px; }
        td.TOCbug {
                text-align: center; width: 30px; height: 15px;
                color: #FFF; background-color: #900;
        }
        td.TOCbug a {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, sans-serif;
                font-weight: bold; font-size: x-small; text-decoration: none;
                color: #FFF; background-color: transparent;
        }

        td.header {
                font-family: arial, helvetica, sans-serif; font-size: x-small;
                vertical-align: top; width: 33%;
                color: #FFF; background-color: #666;
        }
        td.author { font-weight: bold; font-size: x-small; margin-left: 4em; }
        td.author-text { font-size: x-small; }

        /* info code from SantaKlauss at http://www.madaboutstyle.com/tooltip2.html */
        a.info {
                /* This is the key. */
                position: relative;
                z-index: 24;
                text-decoration: none;
        }
        a.info:hover {
                z-index: 25;
                color: #FFF; background-color: #900;
        }
        a.info span { display: none; }
        a.info:hover span.info {
                /* The span will display just on :hover state. */
                display: block;
                position: absolute;
                font-size: smaller;
                top: 2em; left: -5em; width: 15em;
                padding: 2px; border: 1px solid #333;
                color: #900; background-color: #EEE;
                text-align: left;
        }

        a { font-weight: bold; }
        a:link    { color: #900; background-color: transparent; }
        a:visited { color: #633; background-color: transparent; }
        a:active  { color: #633; background-color: transparent; }

        p { margin-left: 2em; margin-right: 2em; }
        p.copyright { font-size: x-small; }
        p.toc { font-size: 85%;
		max-width: 40em; 
		font-weight: bold; margin-left: 3em; }
        table.toc { margin: 0 0 0 3em; padding: 0; border: 0; vertical-align: text-top; }
        td.toc { font-size: 85%;
		max-width: 40em; 
		font-weight: bold; vertical-align: text-top; }

        ol.text { margin-left: 2em; margin-right: 2em; }
        ul.text { margin-left: 2em; margin-right: 2em; }
        li      { margin-left: 3em; }

        /* RFC-2629 <spanx>s and <artwork>s. */
        em     { font-style: italic; }
        strong { font-weight: bold; }
        dfn    { font-weight: bold; font-style: normal; }
        cite   { font-weight: normal; font-style: normal; }
        tt     { color: #036; }
        tt, pre, pre dfn, pre em, pre cite, pre span {
                font-family: "Courier New", Courier, monospace; font-size: small;
        }
        pre {
                text-align: left; padding: 4px;
                color: #000; background-color: #CCC;
        }
        pre dfn  { color: #900; }
        pre em   { color: #66F; background-color: #FFC; font-weight: normal; }
        pre .key { color: #33C; font-weight: bold; }
        pre .id  { color: #900; }
        pre .str { color: #000; background-color: #CFF; }
        pre .val { color: #066; }
        pre .rep { color: #909; }
        pre .oth { color: #000; background-color: #FCF; }
        pre .err { background-color: #FCC; }

        /* RFC-2629 <texttable>s. */
        table.all, table.full, table.headers, table.none {
                font-size: 85%;
		max-width: 40em; 
		text-align: center; border-width: 2px;
                vertical-align: top; border-collapse: collapse;
        }
        table.all, table.full { border-style: solid; border-color: black; }
        table.headers, table.none { border-style: none; }
        th {
                font-weight: bold; border-color: black;
                border-width: 2px 2px 3px 2px;
        }
        table.all th, table.full th { border-style: solid; }
        table.headers th { border-style: none none solid none; }
        table.none th { border-style: none; }
        table.all td {
                border-style: solid; border-color: #333;
                border-width: 1px 2px;
        }
        table.full td, table.headers td, table.none td { border-style: none; }

        hr { height: 1px; }
        hr.insert {
                width: 80%; border-style: none; border-width: 0;
                color: #CCC; background-color: #CCC;
        }
--></style>
</head>
<body>
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<table summary="layout" width="66%" border="0" cellpadding="0" cellspacing="0"><tr><td><table summary="layout" width="100%" border="0" cellpadding="2" cellspacing="1">
<tr><td class="header">Network Working Group</td><td class="header">Y. Nir</td></tr>
<tr><td class="header">Internet-Draft</td><td class="header">Check Point</td></tr>
<tr><td class="header">Intended status: Standards Track</td><td class="header">F. Detienne</td></tr>
<tr><td class="header">Expires: January 13, 2010</td><td class="header">P. Sethi</td></tr>
<tr><td class="header">&nbsp;</td><td class="header">Cisco</td></tr>
<tr><td class="header">&nbsp;</td><td class="header">July 12, 2009</td></tr>
</table></td></tr></table>
<h1><br />A Quick Crash Detection Method for IKE<br />draft-nir-ike-qcd-05</h1>

<h3>Status of this Memo</h3>
<p>
This Internet-Draft is submitted to IETF in full
conformance with the provisions of BCP&nbsp;78 and BCP&nbsp;79.</p>
<p>
Internet-Drafts are working documents of the Internet Engineering
Task Force (IETF), its areas, and its working groups.
Note that other groups may also distribute working documents as
Internet-Drafts.</p>
<p>
Internet-Drafts are draft documents valid for a maximum of six months
and may be updated, replaced, or obsoleted by other documents at any time.
It is inappropriate to use Internet-Drafts as reference material or to cite
them other than as &ldquo;work in progress.&rdquo;</p>
<p>
The list of current Internet-Drafts can be accessed at
<a href='http://www.ietf.org/ietf/1id-abstracts.txt'>http://www.ietf.org/ietf/1id-abstracts.txt</a>.</p>
<p>
The list of Internet-Draft Shadow Directories can be accessed at
<a href='http://www.ietf.org/shadow.html'>http://www.ietf.org/shadow.html</a>.</p>
<p>
This Internet-Draft will expire on January 13, 2010.</p>

<h3>Copyright Notice</h3>
<p>
Copyright (c) 2009 IETF Trust and the persons identified as the
document authors.  All rights reserved.</p>
<p>
This document is subject to BCP 78 and the IETF Trust's Legal
Provisions Relating to IETF Documents in effect on the date of
publication of this document (http://trustee.ietf.org/license-info).
Please review these documents carefully, as they describe your
rights and restrictions with respect to this document.</p>

<h3>Abstract</h3>

<p> This document describes an extension to the IKEv2 protocol that allows for faster 
        detection of SA desynchronization using a saved token.
</p>
<p> When an IPsec tunnel between two IKEv2 peers is disconnected due to a restart of one peer,
        it can take as much as several minutes for the other peer to discover that the reboot has 
        occurred, thus delaying recovery. In this text we propose an extension to the protocol, 
        that allows for recovery immediately following the restart.
</p><a name="toc"></a><br /><hr />
<h3>Table of Contents</h3>
<p class="toc">
<a href="#introduction">1.</a>&nbsp;
Introduction<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#mustshouldmay">1.1.</a>&nbsp;
Conventions Used in This Document<br />
<a href="#SCR">2.</a>&nbsp;
RFC 4306 Crash Recovery<br />
<a href="#outline">3.</a>&nbsp;
Protocol Outline<br />
<a href="#format">4.</a>&nbsp;
Formats and Exchanges<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#format_notif">4.1.</a>&nbsp;
Notification Format<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#format_auth">4.2.</a>&nbsp;
Passing a Token in the AUTH Exchange<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#format_rekey">4.3.</a>&nbsp;
Replacing Tokens After Rekey or Resumption<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#format_mob">4.4.</a>&nbsp;
Replacing the Token for an Existing SA<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#format_info">4.5.</a>&nbsp;
Presenting the Token in an INFORMATIONAL Exchange<br />
<a href="#tokengen">5.</a>&nbsp;
Token Generation and Verification<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tg1">5.1.</a>&nbsp;
A Stateless Method of Token Generation<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tg2">5.2.</a>&nbsp;
A Stateless Method with IP addresses<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#toklifetime">5.3.</a>&nbsp;
Token Lifetime<br />
<a href="#backupgw">6.</a>&nbsp;
Backup Gateways<br />
<a href="#whynot">7.</a>&nbsp;
Alternative Solutions<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#newikesa">7.1.</a>&nbsp;
Initiating a new IKE SA<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#bcerts">7.2.</a>&nbsp;
Birth Certificates<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#shortwait">7.3.</a>&nbsp;
Reducing Liveness Check Length<br />
<a href="#int_resume">8.</a>&nbsp;
Interaction with Session Resumption<br />
<a href="#operation">9.</a>&nbsp;
Operational Considerations<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#operation_who">9.1.</a>&nbsp;
Who should implement this specification<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#operation_esp">9.2.</a>&nbsp;
Response to unknown child SPI<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#operation_with_ip">9.3.</a>&nbsp;
Using Tokens that Depend on IP Addresses<br />
<a href="#security">10.</a>&nbsp;
Security Considerations<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec_handling">10.1.</a>&nbsp;
QCD Token Generation and Handling<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec_trans">10.2.</a>&nbsp;
QCD Token Transmission<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec_enum">10.3.</a>&nbsp;
QCD Token Enumeration<br />
<a href="#iana">11.</a>&nbsp;
IANA Considerations<br />
<a href="#ack">12.</a>&nbsp;
Acknowledgements<br />
<a href="#history">13.</a>&nbsp;
Change Log<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#history05">13.1.</a>&nbsp;
Changes from draft-nir-ike-qcd-03 and -04<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#history04">13.2.</a>&nbsp;
Changes from draft-nir-ike-qcd-02<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#history03">13.3.</a>&nbsp;
Changes from draft-nir-ike-qcd-01<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#history02">13.4.</a>&nbsp;
Changes from draft-nir-ike-qcd-00<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#history01">13.5.</a>&nbsp;
Changes from draft-nir-qcr-00<br />
<a href="#rfc.references1">14.</a>&nbsp;
References<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#rfc.references1">14.1.</a>&nbsp;
Normative References<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#rfc.references2">14.2.</a>&nbsp;
Informative References<br />
<a href="#rfc.authors">&#167;</a>&nbsp;
Authors' Addresses<br />
</p>
<br clear="all" />

<a name="introduction"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1"></a><h3>1.&nbsp;
Introduction</h3>

<p> IKEv2, as described in <a class='info' href='#RFC4306'>[RFC4306]<span> (</span><span class='info'>Kaufman, C., &ldquo;Internet Key Exchange (IKEv2) Protocol,&rdquo; December&nbsp;2005.</span><span>)</span></a> has a method for recovering from a reboot
        of one peer. As long as traffic flows in both directions, the rebooted peer should 
        re-establish the tunnels immediately. However, in many cases the rebooted peer is a VPN
        gateway that protects only servers, or else the non-rebooted peer has a dynamic IP address. 
        In such cases, the rebooted peer will not be able to re-establish the tunnels. 
        <a class='info' href='#SCR'>Section&nbsp;2<span> (</span><span class='info'>RFC 4306 Crash Recovery</span><span>)</span></a> describes how recovery works under RFC 4306, and explains why it may
        take several minutes.
</p>
<p> The method proposed here, is to send an octet string, called a "QCD token" in the 
        IKE_AUTH exchange that establishes the tunnel. That token can be stored on the peer as part 
        of the IKE SA. After a reboot, the rebooted implementation can re-generate the token, and 
        send it to the peer, so as to delete the IKE SA. Deleting the IKE SA results is a quick 
        establishment of new IPsec tunnels. This is described in <a class='info' href='#outline'>Section&nbsp;3<span> (</span><span class='info'>Protocol Outline</span><span>)</span></a>.
</p>
<a name="mustshouldmay"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1.1"></a><h3>1.1.&nbsp;
Conventions Used in This Document</h3>

<p>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT",
          "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described
          in <a class='info' href='#RFC2119'>[RFC2119]<span> (</span><span class='info'>Bradner, S., &ldquo;Key words for use in RFCs to Indicate Requirement Levels,&rdquo; March&nbsp;1997.</span><span>)</span></a>.
</p>
<p> The term "token" refers to an octet string that an implementation can generate using 
          only the properties of a protected IKE message (such as IKE SPIs) as input. A conforming 
          implementation MUST be able to generate the same token from the same input even after 
          rebooting.
</p>
<p> The term "token maker" refers to an implementation that generates a token and sends it
          to the peer as specified in this document.
</p>
<p> The term "token taker" refers to an implementation that stores such a token or a digest
          thereof, in order to verify that a new token it receives is identical to the old token it
          has stored.
</p>
<p> The term "non-volatile storage" in this document refers to a data storage module, that
          persists across restarts of the token maker. Examples of such a storage module include an
          internal disk, an internal flash memory module, an external disk and an external 
          database. A small non-volatile storage module is required for a token maker, but a larger
          one can be used to enhance performance, as described in <a class='info' href='#operation_esp'>Section&nbsp;9.2<span> (</span><span class='info'>Response to unknown child SPI</span><span>)</span></a>.
</p>
<a name="SCR"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2"></a><h3>2.&nbsp;
RFC 4306 Crash Recovery</h3>

<p> When one peer loses state or reboots, the other peer does not get any notification, so 
          unidirectional IPsec traffic can still flow. The rebooted peer will not be able to 
          decrypt it, however, and the only remedy is to send an unprotected INVALID_SPI 
          notification as described in section 3.10.1 of <a class='info' href='#RFC4306'>[RFC4306]<span> (</span><span class='info'>Kaufman, C., &ldquo;Internet Key Exchange (IKEv2) Protocol,&rdquo; December&nbsp;2005.</span><span>)</span></a>.  That section 
          also describes the processing of such a notification:
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
      "If this Informational Message is sent outside the
  context of an IKE_SA, it should be used by the recipient
  only as a "hint" that something might be wrong (because it
  could easily be forged)."
</pre></div>
<p> Since the INVALID_SPI can only be used as a hint, the non-rebooted peer has to determine
          whether the IPsec SA, and indeed the parent IKE SA are still valid.  The method of doing 
          this is described in section 2.4 of <a class='info' href='#RFC4306'>[RFC4306]<span> (</span><span class='info'>Kaufman, C., &ldquo;Internet Key Exchange (IKEv2) Protocol,&rdquo; December&nbsp;2005.</span><span>)</span></a>. This method, called 
          "liveness check" involves sending a protected empty INFORMATIONAL message, and awaiting a 
          response. This procedure is sometimes referred to as "Dead Peer Detection" or DPD.
</p>
<p> Section 2.4 does not mandate how many times the liveness check message should be 
          retransmitted, or for how long, but does recommend the following:
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
                                                            "It is
 suggested that messages be retransmitted at least a dozen times over
 a period of at least several minutes before giving up on an SA..."
</pre></div>
<p> Those "at least several minutes" are a time during which both peers are active, but 
          IPsec cannot be used.
</p>
<a name="outline"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3"></a><h3>3.&nbsp;
Protocol Outline</h3>

<p> Supporting implementations will send a notification, called a "QCD token", as described
          in <a class='info' href='#format_notif'>Section&nbsp;4.1<span> (</span><span class='info'>Notification Format</span><span>)</span></a> in the last IKE_AUTH exchange messages. These are the 
          final IKE_AUTH request and final IKE_AUTH response that contain the AUTH payloads.  The 
          generation of these tokens is a local matter for implementations, but considerations are 
          described in <a class='info' href='#tokengen'>Section&nbsp;5<span> (</span><span class='info'>Token Generation and Verification</span><span>)</span></a>. Implementations that send such a token will be
          called "token makers".
</p>
<p> A supporting implementation receiving such a token MUST store it (or a digest thereof)
          as part of the IKE SA. Implementations that support this part of the protocol will be 
          called "token takers". <a class='info' href='#operation_who'>Section&nbsp;9.1<span> (</span><span class='info'>Who should implement this specification</span><span>)</span></a> has considerations for which 
          implementations need to be token takers, and which should be token makers. Implementation 
          that are not token takers will silently ignore QCD tokens.
</p>
<p> When a token maker receives a protected IKE request message with unknown IKE SPIs, it 
          MUST generate a new token that is identical to the previous token, and send it to the 
          requesting peer in an unprotected IKE message as described in <a class='info' href='#format_info'>Section&nbsp;4.5<span> (</span><span class='info'>Presenting the Token in an INFORMATIONAL Exchange</span><span>)</span></a>.
</p>
<p> When a token taker receives the QCD token in an unprotected notification, it MUST verify 
          that the TOKEN_SECRET_DATA matches the token stored in the matching IKE SA. If the 
          verification fails, or if the IKE SPIs in the message do not match any existing IKE SA,
          it SHOULD log the event. If it succeeds, it MUST silently delete the IKE SA associated 
          with the IKE_SPI fields, and all dependant child SAs. This event MAY also be logged. The 
          token taker MUST accept such tokens from any IP address and port combination, so as to 
          allow different kinds of high-availability configurations of the token maker.
</p>
<p> A supporting token taker MAY immediately create new SAs using an Initial exchange, 
          or it may wait for subsequent traffic to trigger the creation of new SAs.
</p>
<p> There is ongoing work on IKEv2 Session Resumption (<a class='info' href='#resumption'>[resumption]<span> (</span><span class='info'>Sheffer, Y. and H. Tschofenig, &ldquo;IKEv2 Session Resumption,&rdquo; June&nbsp;2009.</span><span>)</span></a>). See 
          <a class='info' href='#int_resume'>Section&nbsp;8<span> (</span><span class='info'>Interaction with Session Resumption</span><span>)</span></a> for a short discussion about this extensions's interaction 
          with session resumption.
</p>
<a name="format"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4"></a><h3>4.&nbsp;
Formats and Exchanges</h3>

<a name="format_notif"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.1"></a><h3>4.1.&nbsp;
Notification Format</h3>

<p> The notification payload called "QCD token" is formatted as follows:
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
                         1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    ! Next Payload  !C!  RESERVED   !         Payload Length        !
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    !  Protocol ID  !   SPI Size    ! QCD Token Notify Message Type !
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    !                                                               !
    ~                       TOKEN_SECRET_DATA                       ~
    !                                                               !
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre></div>
<p></p>
<ul class="text">
<li>Protocol ID (1 octet) MUST be 1, as this message is related to an IKE SA.
</li>
<li>SPI Size (1 octet) MUST be zero, in conformance with section 3.10 of 
              <a class='info' href='#RFC4306'>[RFC4306]<span> (</span><span class='info'>Kaufman, C., &ldquo;Internet Key Exchange (IKEv2) Protocol,&rdquo; December&nbsp;2005.</span><span>)</span></a>.
</li>
<li>QCD Token Notify Message Type (2 octets) - MUST be xxxxx, the value assigned for QCD
              token notifications. TBA by IANA.
</li>
<li>TOKEN_SECRET_DATA (16-128 octets) contains a generated token as described in 
              <a class='info' href='#tokengen'>Section&nbsp;5<span> (</span><span class='info'>Token Generation and Verification</span><span>)</span></a>.
</li>
</ul>

<a name="format_auth"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.2"></a><h3>4.2.&nbsp;
Passing a Token in the AUTH Exchange</h3>

<p> For brevity, only the EAP version of an AUTH exchange will be presented here. The 
            non-EAP version is very similar. The figures below are based on appendix A.3 of
            <a class='info' href='#RFC4718'>[RFC4718]<span> (</span><span class='info'>Eronen, P. and P. Hoffman, &ldquo;IKEv2 Clarifications and Implementation Guidelines,&rdquo; October&nbsp;2006.</span><span>)</span></a>.
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
 first request       --&gt; IDi,
                         [N(INITIAL_CONTACT)],
                         [[N(HTTP_CERT_LOOKUP_SUPPORTED)], CERTREQ+],
                         [IDr],
                         [CP(CFG_REQUEST)],
                         [N(IPCOMP_SUPPORTED)+],
                         [N(USE_TRANSPORT_MODE)],
                         [N(ESP_TFC_PADDING_NOT_SUPPORTED)],
                         [N(NON_FIRST_FRAGMENTS_ALSO)],
                         SA, TSi, TSr,
                         [V+]

 first response      &lt;-- IDr, [CERT+], AUTH,
                         EAP,
                         [V+]

                   / --&gt; EAP
 repeat 1..N times |
                   \ &lt;-- EAP

 last request        --&gt; AUTH
                         [N(QCD_TOKEN)]

 last response       &lt;-- AUTH,
                         [N(QCD_TOKEN)]
                         [CP(CFG_REPLY)],
                         [N(IPCOMP_SUPPORTED)],
                         [N(USE_TRANSPORT_MODE)],
                         [N(ESP_TFC_PADDING_NOT_SUPPORTED)],
                         [N(NON_FIRST_FRAGMENTS_ALSO)],
                         SA, TSi, TSr,
                         [N(ADDITIONAL_TS_POSSIBLE)],
                         [V+]
</pre></div>
<p> Note that the QCD_TOKEN notification is marked as optional because it is not required
            by this specification that every implementation be both token maker and token taker. 
            If only one peer sends the QCD token, then a reboot of the other peer will not be 
            recoverable by this method. This may be acceptable if traffic typically originates from 
            the other peer.
</p>
<p> In any case, the lack of a QCD_TOKEN notification MUST NOT be taken as an indication
            that the peer does not support this standard. Conversely, if a peer does not understand 
            this notification, it will simply ignore it. Therefore a peer MAY send this notification 
            freely, even if it does not know whether the other side supports it.
</p>
<p> The QCD_TOKEN notification is related to the IKE SA and MUST follow the AUTH payload
            and precede the Configuration payload and all payloads related to the child SA.
</p>
<a name="format_rekey"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.3"></a><h3>4.3.&nbsp;
Replacing Tokens After Rekey or Resumption</h3>

<p> After rekeying an IKE SA, the IKE SPIs are replaced, so the new SA also needs to have
            a token.  If only the responder in the rekey exchange is the token maker, this can be
            done within the CREATE_CHILD_SA exchange. If the initiator is a token maker, then we 
            need an extra informational exchange.
</p>
<p> The following figure shows the CREATE_CHILD_SA exchange for rekeying the IKE SA. Only
            the responder sends a QCD token.
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
   request             --&gt; SA, Ni, [KEi]

   response            &lt;-- SA, Nr, [KEr], N(QCD_TOKEN)
</pre></div>
<p> If the initiator is also a token maker, it SHOULD soon initiate an INFORMATIONAL
            exchange as follows:
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
   request             --&gt; N(QCD_TOKEN)

   response            &lt;--
</pre></div>
<p> For session resumption, as specified in <a class='info' href='#resumption'>[resumption]<span> (</span><span class='info'>Sheffer, Y. and H. Tschofenig, &ldquo;IKEv2 Session Resumption,&rdquo; June&nbsp;2009.</span><span>)</span></a>, the situation is 
            similar. The responder, which is necessarily the peer that has crashed, SHOULD send a 
            new ticket within the protected payload of the IKE_SESSION_RESUME exchange. If the 
            Initiator is also a token maker, it needs to send a QCD_TOKEN in a separate 
            INFORMATIONAL exchange.
</p>
<p> The INFORMATIONAL exchange described in this section can also be used if QCD tokens
            need to be replaced due to a key rollover. However, since token takers are required to
            verify at least 4 QCD tokens, this is only necessary if secret QCD keys are rolled over
            more than four times as often as IKE SAs are rekeyed.
</p>
<a name="format_mob"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.4"></a><h3>4.4.&nbsp;
Replacing the Token for an Existing SA</h3>

<p> With some token generation methods, such as that described in <a class='info' href='#tg2'>Section&nbsp;5.2<span> (</span><span class='info'>A Stateless Method with IP addresses</span><span>)</span></a>,
            a QCD token may sometimes become invalid, although the IKE SA is still perfectly valid.
</p>
<p> In such a case, the token maker MUST send the new token in a protected message under
            that IKE SA. That exchange could be a simple INFORMATIONAL, such as in the last figure 
            in the previous section, or else it can be part of a MOBIKE INFORMATIONAL exchange such
            as in the following figure taken from section 2.2 of <a class='info' href='#RFC4555'>[RFC4555]<span> (</span><span class='info'>Eronen, P., &ldquo;IKEv2 Mobility and Multihoming Protocol (MOBIKE),&rdquo; June&nbsp;2006.</span><span>)</span></a> and
            modified by adding a QCD_TOKEN notification:
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
  (IP_I2:4500 -&gt; IP_R1:4500)
  HDR, SK { N(UPDATE_SA_ADDRESSES),
            N(NAT_DETECTION_SOURCE_IP),
            N(NAT_DETECTION_DESTINATION_IP) }  --&gt;

                        &lt;-- (IP_R1:4500 -&gt; IP_I2:4500)
                            HDR, SK { N(NAT_DETECTION_SOURCE_IP),
                                 N(NAT_DETECTION_DESTINATION_IP) }

                        &lt;-- (IP_R1:4500 -&gt; IP_I2:4500)
                            HDR, SK { N(COOKIE2), [N(QCD_TOKEN)] }

  (IP_I2:4500 -&gt; IP_R1:4500)
  HDR, SK { N(COOKIE2), [N(QCD_TOKEN)] }  --&gt;
</pre></div>
<p> A token taker MUST accept such gratuitous QCD_TOKEN notifications as long as they are
            carried in protected exchanges. A token maker SHOULD NOT generate them unless it is
            no longer able to generate the old QCD_TOKEN.
</p>
<a name="format_info"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.5"></a><h3>4.5.&nbsp;
Presenting the Token in an INFORMATIONAL Exchange</h3>

<p> This QCD_TOKEN notification is unprotected, and is sent as a response to a protected
            IKE request, which uses an IKE SA that is unknown.
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
         request             --&gt; N(INVALID_IKE_SPI), N(QCD_TOKEN)+
</pre></div>
<p> If child SPIs are persistently mapped to IKE SPIs as described in 
            <a class='info' href='#operation_esp'>Section&nbsp;9.2<span> (</span><span class='info'>Response to unknown child SPI</span><span>)</span></a>, a token taker may get the following unprotected message 
            in response to an ESP or AH packet.
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
         request             --&gt; N(INVALID_SPI), N(QCD_TOKEN)+
</pre></div>
<p> The QCD_TOKEN and INVALID_IKE_SPI notifications are sent together to support both 
            implementations that conform to this specification and implementations that don't. 
            Similar to the description in section 2.21 of <a class='info' href='#RFC4306'>[RFC4306]<span> (</span><span class='info'>Kaufman, C., &ldquo;Internet Key Exchange (IKEv2) Protocol,&rdquo; December&nbsp;2005.</span><span>)</span></a>, The IKE SPI and 
            message ID fields in the packet headers are taken from the protected IKE request.
</p>
<p> To support a periodic rollover of the secret used for token generation, the token 
            taker MUST support at least four QCD_TOKEN notifications in a single packet. The token
            is considered verified if any of the QCD_TOKEN notifications matches. The token maker 
            MAY generate up to four QCD_TOKEN notifications, based on several generations of keys.
</p>
<p> If the QCD_TOKEN verifies OK, an empty response MUST be sent. If the QCD_TOKEN 
            cannot be validated, a response MUST NOT be sent. <a class='info' href='#tokengen'>Section&nbsp;5<span> (</span><span class='info'>Token Generation and Verification</span><span>)</span></a>
            defines token verification.
</p>
<a name="tokengen"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5"></a><h3>5.&nbsp;
Token Generation and Verification</h3>

<p> No token generation method is mandated by this document. Two method are documented in
          the following sub-sections, but they only serve as examples.
</p>
<p> The following lists the requirements from a token generation mechanism:</p>
<ul class="text">
<li> Tokens MUST be at least 16 octets long, and no more than 128 octets long, to 
            facilitate storage and transmission. Tokens SHOULD be indistinguishable from random data.
</li>
<li> It should not be possible for an external attacker to guess the QCD token generated
            by an implementation. Cryptographic mechanisms such as PRNG and hash functions are
            RECOMMENDED.
</li>
<li> The token maker, MUST be able to re-generate or retrieve the token based on the 
            IKE SPIs even after it reboots.
</li>
</ul>

<a name="tg1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.1"></a><h3>5.1.&nbsp;
A Stateless Method of Token Generation</h3>

<p> This describes a stateless method of generating a token:</p>
<ul class="text">
<li> At installation or immediately after the first boot of the token maker, 32 random 
              octets are generated using a secure random number generator or a PRNG.
</li>
<li> Those 32 bytes, called the "QCD_SECRET", are stored in non-volatile storage on 
              the machine, and kept indefinitely.
</li>
<li> If key rollover is required by policy, the implementation MAY periodically generate
              a new QCD_SECRET and keep up to 3 previous generations. When sending an unprotected 
              QCD_TOKEN, as many as 4 notification payloads may be sent, each from a different
              QCD_SECRET.
</li>
<li> The TOKEN_SECRET_DATA is calculated as follows:
</li>
</ul>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>

         TOKEN_SECRET_DATA = HASH(QCD_SECRET | SPI-I | SPI-R)

</pre></div>
<a name="tg2"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.2"></a><h3>5.2.&nbsp;
A Stateless Method with IP addresses</h3>

<p> This method is similar to the one in the previous section, except that the IP 
            address of the token taker is also added to the block being hashed. This has the 
            disadvantage that the token needs to be replaced (as described in 
            <a class='info' href='#format_mob'>Section&nbsp;4.4<span> (</span><span class='info'>Replacing the Token for an Existing SA</span><span>)</span></a>) whenever the token taker changes its address.
</p>
<p> The reason to use this method is described in <a class='info' href='#operation_with_ip'>Section&nbsp;9.3<span> (</span><span class='info'>Using Tokens that Depend on IP Addresses</span><span>)</span></a>.
            When using this method, the TOKEN_SECRET_DATA field is calculated as follows:
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>

      TOKEN_SECRET_DATA = HASH(QCD_SECRET | SPI-I | SPI-R | IPaddr-T)

</pre></div>
<p> The IPaddr-T field specifies the IP address of the token taker. Secret rollover 
            considerations are similar to those in the previous section.
</p>
<a name="toklifetime"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.3"></a><h3>5.3.&nbsp;
Token Lifetime</h3>

<p> The token is associated with a single IKE SA, and SHOULD be deleted by the token taker
            when the SA is deleted or expires. More formally, the token is associated with the pair 
            (SPI-I, SPI-R).
</p>
<a name="backupgw"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6"></a><h3>6.&nbsp;
Backup Gateways</h3>

<p> Making crash detection and recovery quick is a worthy goal, but since rebooting a 
          gateway takes a non-zero amount of time, many implementations choose to have a stand-by 
          gateway ready to take over as soon as the primary gateway fails for any reason. 
</p>
<p> If such a configuration is available, it is RECOMMENDED that the stand-by gateway be
          able to generate the same token as the active gateway. if the method described in 
          <a class='info' href='#tg1'>Section&nbsp;5.1<span> (</span><span class='info'>A Stateless Method of Token Generation</span><span>)</span></a> is used, this means that the QCD_SECRET field is identical in both 
          gateways. This has the effect of having the crash recovery available immediately.
</p>
<p> Note that this refers to "high availability" configurations, where only one gateway is
          active at any given moment. This is different from "load sharing" configurations where
          more than one gateway is active at the same time. This is also different from high 
          availability configurations where the SAs are synchronized. For load sharing 
          configurations, please see <a class='info' href='#sec_trans'>Section&nbsp;10.2<span> (</span><span class='info'>QCD Token Transmission</span><span>)</span></a> for security considerations.
</p>
<a name="whynot"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7"></a><h3>7.&nbsp;
Alternative Solutions</h3>

<a name="newikesa"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.1"></a><h3>7.1.&nbsp;
Initiating a new IKE SA</h3>

<p> Instead of sending a QCD token, we could have the rebooted implementation start an 
          Initial exchange with the peer, including the INITIAL_CONTACT notification. This would
          have the same effect, instructing the peer to erase the old IKE SA, as well as establishing
          a new IKE SA with fewer rounds.
</p>
<p> The disadvantage here, is that in IKEv2 an authentication exchange MUST have
          a piggy-backed Child SA set up. Since our use case is such that the rebooted implementation
          does not have traffic flowing to the peer, there are no good selectors for such a Child
          SA.
</p>
<p> Additionally, when authentication is asymmetric, such as when EAP is used, it is not 
          possible for the rebooted implementation to initiate IKE.
</p>
<a name="bcerts"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.2"></a><h3>7.2.&nbsp;
Birth Certificates</h3>

<p> Birth Certificates is a method of crash detection that has never been formally
            defined. Bill Sommerfeld suggested this idea in a mail to the IPsec mailing list on 
            August 7, 2000, in a thread discussing methods of crash detection:
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
    If we have the system sign a "birth certificate" when it
    reboots (including a reboot time or boot sequence number),
    we could include that with a "bad spi" ICMP error and in
    the negotiation of the IKE SA.
</pre></div>
<p> We believe that this method would have some problems. First, it requires Alice to
            store the certificate, so as to be able to compare the public keys. That requires more
            storage than does a QCD token. Additionally, the public-key operations needed to verify 
            the self-signed certificates are more expensive for Alice.
</p>
<p> We believe that a symmetric-key operation such as proposed here is more light-weight
            and simple than that implied by the Birth Certificate idea.
</p>
<a name="shortwait"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.3"></a><h3>7.3.&nbsp;
Reducing Liveness Check Length</h3>

<p> Some have suggested that the RFC 4306 procedure described in <a class='info' href='#SCR'>Section&nbsp;2<span> (</span><span class='info'>RFC 4306 Crash Recovery</span><span>)</span></a> can
            be tweaked by requiring fewer retransmissions over a shorter period of time for cases
            of liveness check started because of an INVALID_SPI or INVALID_IKE_SPI notification.
</p>
<p> We believe that the default retransmission policy should represent a good balance 
            between the need for a timely discovery of a dead peer, and a low probability of false 
            detection. We expect the policy to be set to take the shortest time such that this 
            probability achieves a certain target. Therefore, reducing elapsed time and 
            retransmission count will create an unacceptably high probability of false detection,
            and this can be triggered by a single INVALID_IKE_SPI notification.
</p>
<p> Additionally, even if the retransmission policy is reduced to, say, one minute, it
            is still a very noticeable delay from a human perspective, from the time that the 
            gateway has come up until the tunnels are active, or from the time the backup 
            gateway has taken over until the tunnels are active.
</p>
<a name="int_resume"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.8"></a><h3>8.&nbsp;
Interaction with Session Resumption</h3>

<p> Session Resumption, specified in <a class='info' href='#resumption'>[resumption]<span> (</span><span class='info'>Sheffer, Y. and H. Tschofenig, &ldquo;IKEv2 Session Resumption,&rdquo; June&nbsp;2009.</span><span>)</span></a> proposes to make setting 
          up a new IKE SA consume less computing resources. This is particularly useful in the case 
          of a remote access gateway that has many tunnels. A failure of such a gateway would 
          require all these many remote access clients to establish an IKE SA either with the 
          rebooted gateway or with a backup gateway. This tunnel re-establishment should occur 
          within a short period of time, creating a burden on the remote access gateway. Session
          Resumption addresses this problem by having the clients store an encrypted derivative of 
          the IKE SA for quick re-establishment.
</p>
<p> What Session Resumption does not help, is the problem of detecting that the peer 
          gateway has failed. A failed gateway may go undetected for as long as the lifetime of a 
          child SA, because IPsec does not have packet acknowledgement, and applications cannot
          signal the IPsec layer that the tunnel "does not work". Before establishing a new 
          IKE SA using Session Resumption, a client should ascertain that the gateway has indeed 
          failed. This could be done using either a liveness check (as in RFC 4306) or using the 
          QCD tokens described in this document.
</p>
<p> A remote access client conforming to both specifications will store QCD tokens, as well
          as the Session Resumption ticket, if provided by the gateway. A remote access gateway 
          conforming to both specifications will generate a QCD token for the client. When the 
          gateway reboots, the client will discover this in either of two ways:</p>
<ol class="text">
<li> The client does regular liveness checks, or else the time for some other IKE exchange
            has come. Since the gateway is still down, the IKE exchange times out after several 
            minutes. In this case QCD does not help.
</li>
<li> Either the primary gateway or a backup gateway (see <a class='info' href='#backupgw'>Section&nbsp;6<span> (</span><span class='info'>Backup Gateways</span><span>)</span></a>) 
            is ready and sends a QCD token to the client. In that case the client will quickly
            re-establish the IPsec tunnel, either with the rebooted primary gateway or the backup
            gateway as described in this document.
            
</li>
</ol>

<p> The full combined protocol looks like this:
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
     Initiator                Responder
     -----------              -----------
    HDR, SAi1, KEi, Ni  --&gt;

                        &lt;--    HDR, SAr1, KEr, Nr, [CERTREQ]

    HDR, SK {IDi, [CERT,]
    [CERTREQ,] [IDr,]
    AUTH, N(QCD_TOKEN)
    SAi2, TSi, TSr,
    N(TICKET_REQUEST)}  --&gt;
                        &lt;--    HDR, SK {IDr, [CERT,] AUTH,
                               N(QCD_TOKEN), SAr2, TSi, TSr,
                               N(TICKET_LT_OPAQUE) }

             ---- Reboot -----

    HDR, {}             --&gt;
                        &lt;--  HDR, N(QCD_TOKEN)

    HDR, [N(COOKIE),]
    Ni, N(TICKET_OPAQUE)
    [,N+]               --&gt;
                        &lt;--  HDR, Nr [,N+]

</pre></div>
<a name="operation"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.9"></a><h3>9.&nbsp;
Operational Considerations</h3>

<a name="operation_who"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.9.1"></a><h3>9.1.&nbsp;
Who should implement this specification</h3>

<p> Throughout this document, we have referred to reboot time alternatingly as the time that 
          the implementation crashes and the time when it is ready to process IPsec packets and IKE 
          exchanges. Depending on the hardware and software platforms and the cause of the reboot, 
          rebooting may take anywhere from a few seconds to several minutes. If the implementation
          is down for a long time, the benefit of this protocol extension is reduced. For this reason
          critical systems should implement backup gateways as described in 
          <a class='info' href='#backupgw'>Section&nbsp;6<span> (</span><span class='info'>Backup Gateways</span><span>)</span></a>.
</p>
<p> Implementing the "token maker" side of QCD makes sense for IKE implementation where protected
          connections originate from the peer, such as inter-domain VPNs and remote access gateways.
          Implementing the "token taker" side of QCD makes sense for IKE implementations where protected
          connections originate, such as inter-domain VPNs and remote access clients.
</p>
<p> To clarify the requirements: </p>
<ul class="text">
<li> A remote-access client MUST be a token taker and MAY be a token maker.
</li>
<li> A remote-access gateway MAY be a token taker and MUST be a token maker.
</li>
<li> An inter-domain VPN gateway MUST be both token maker and token taker.
</li>
</ul>

<p> In order to limit the effects of DoS attacks, a token taker SHOULD limit the rate
          of QCD_TOKENs verified from a particular source. 
</p>
<p> If excessive amounts of IKE requests protected with unknown IKE SPIs arrive at a token
          maker, the IKE module SHOULD revert to the behavior described in section 2.21 of 
          <a class='info' href='#RFC4306'>[RFC4306]<span> (</span><span class='info'>Kaufman, C., &ldquo;Internet Key Exchange (IKEv2) Protocol,&rdquo; December&nbsp;2005.</span><span>)</span></a> and either send an INVALID_IKE_SPI notification, or ignore it 
          entirely.
</p>
<a name="operation_esp"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.9.2"></a><h3>9.2.&nbsp;
Response to unknown child SPI</h3>

<p> After a reboot, it is more likely that an implementation receives IPsec packets than 
          IKE packets. In that case, the rebooted implementation will send an INVALID_SPI
          notification, triggering a liveness check.  The token will only be sent in a response to
          the liveness check, thus requiring an extra round-trip.
</p>
<p> To avoid this, an implementation that has access to non-volatile storage MAY store a 
          mapping of child SPIs to owning IKE SPIs, or to generated tokens. If such a mapping is 
          available and persistent across reboots, the rebooted implementation SHOULD respond to 
          the IPsec packet with an INVALID_SPI notification, along with the appropriate QCD_Token 
          notifications. A token taker SHOULD verify the QCD token that arrives with an INVALID_SPI 
          notification the same as if it arrived with the IKE SPIs of the parent IKE SA.
</p>
<p> However, a persistent storage module might not be updated in a timely manner, and 
          could be populated with tokens relating to IKE SPIs that have already been rekeyed. A 
          token taker MUST NOT take an invalid QCD Token sent along with an INVALID_SPI 
          notification as evidence that the peer is either malfunctioning or attacking, but it 
          SHOULD limit the rate at which such notifications are processed.
</p>
<a name="operation_with_ip"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.9.3"></a><h3>9.3.&nbsp;
Using Tokens that Depend on IP Addresses</h3>

<p> This section describes the rationale for token generation methods such as the one 
          described in <a class='info' href='#tg2'>Section&nbsp;5.2<span> (</span><span class='info'>A Stateless Method with IP addresses</span><span>)</span></a>. Note that this section merely provides a possible
          rationale, and does not specify or recommend any kind of configuration.
</p>
<p> Some configurations of security gateway use a load-sharing cluster of hosts, all 
          sharing the same IP addresses, where the SAs (IKE and child) are not synchronized between 
          the cluster members. In such a configuration, a single member does not know about all the 
          IKE SAs that are active for the configuration. A load balancer (usually a networking 
          switch) sends IKE and IPsec packets to the several members based on source IP address.
</p>
<p> In such a configuration, an attacker can send a forged protected IKE packet with the
          IKE SPIs of an existing IKE SA, but from a different IP address. This packet will likely
          be processed by a different cluster member from the one that owns the IKE SA. Since no 
          IKE SA state is stored on this member, it will send a QCD token to the attacker. If the
          QCD token does not depend on IP address, this token can immediately be used to tell the
          token taker to tear down the IKE SA using an unprotected QCD_TOKEN notification.
</p>
<p> To thwart this possible attack, such configurations should use a method that considers
          the taker's IP address, such as the method described in <a class='info' href='#tg2'>Section&nbsp;5.2<span> (</span><span class='info'>A Stateless Method with IP addresses</span><span>)</span></a>.
</p>
<a name="security"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.10"></a><h3>10.&nbsp;
Security Considerations</h3>

<a name="sec_handling"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.10.1"></a><h3>10.1.&nbsp;
QCD Token Generation and Handling</h3>

<p> Tokens MUST be hard to guess. This is critical, because if an attacker can guess the 
          token associated with an IKE SA, she can tear down the IKE SA and associated tunnels at
          will. When the token is delivered in the IKE_AUTH exchange, it is encrypted. When it is
          sent again in an unprotected notification, it is not, but that is the last time this
          token is ever used.
</p>
<p> An aggregation of some tokens generated by one maker together with the related IKE SPIs
          MUST NOT give an attacker the ability to guess other tokens. Specifically, if one taker 
          does not properly secure the QCD tokens and an attacker gains access to them, this
          attacker MUST NOT be able to guess other tokens generated by the same maker. This is the
          reason that the QCD_SECRET in <a class='info' href='#tg1'>Section&nbsp;5.1<span> (</span><span class='info'>A Stateless Method of Token Generation</span><span>)</span></a> needs to be sufficiently long.
</p>
<p> The token taker MUST store the token in a secure manner. No attacker should be able to
          gain access to a stored token.
</p>
<p> The QCD_SECRET MUST be protected from access by other parties. Anyone gaining
          access to this value will be able to delete all the IKE SAs for this token maker.
</p>
<p> The QCD token is sent by the rebooted peer in an unprotected message. A message like 
          that is subject to modification, deletion and replay by an attacker. However, these 
          attacks will not compromise the security of either side. Modification is meaningless
          because a modified token is simply an invalid token. Deletion will only cause the 
          protocol not to work, resulting in a delay in tunnel re-establishment as described in
          <a class='info' href='#SCR'>Section&nbsp;2<span> (</span><span class='info'>RFC 4306 Crash Recovery</span><span>)</span></a>. Replay is also meaningless, because the IKE SA has been deleted
          after the first transmission.
</p>
<a name="sec_trans"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.10.2"></a><h3>10.2.&nbsp;
QCD Token Transmission</h3>

<p> A token maker MUST NOT send a QCD token in an unprotected message for an existing IKE
          SA. This implies that a conforming QCD token maker MUST be able to tell whether a 
          particular pair of IKE SPIs represent a valid IKE SA.
</p>
<p> This requirement is obvious and easy in the case of a single gateway. However, some 
          implementations use a load balancer to divide the load between several physical gateways.
          It MUST NOT be possible even in such a configuration to trick one gateway into sending 
          a QCD token for an IKE SA which is valid on another gateway.
</p>
<p> This document does not specify how a load sharing sharing configuration of IPsec 
          gateways would work, but in order to support this specification, all members MUST be able
          to tell whether a particular IKE SA is active anywhere in the cluster. One way to do it
          is to synchronize a list of active IKE SPIs among all the cluster members.
</p>
<a name="sec_enum"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.10.3"></a><h3>10.3.&nbsp;
QCD Token Enumeration</h3>

<p> An attacker may try to attack QCD if the generation algorithm described in 
          <a class='info' href='#tg1'>Section&nbsp;5.1<span> (</span><span class='info'>A Stateless Method of Token Generation</span><span>)</span></a> is used. The attacker will send several fake IKE requests to the
          gateway under attack, receiving and recording the QCD Tokens in the responses. This will
          allow the attacker to create a dictionary of IKE SPIs to QCD Tokens, which can later be
          used to tear down any IKE SA.
</p>
<p> Three factors mitigate this threat:</p>
<ul class="text">
<li> The space of all possible IKE SPI pairs is huge: 2^128, so making such a dictionary
            is impractical. Even if we assume that one implementation is faulty and always
            generates predictable IKE SPIs, the space is still at least 2^64 entries, so making the
            dictionary is extremely hard.
</li>
<li> Throttling the amount of QCD_TOKEN notifications sent out, as discussed in 
            <a class='info' href='#operation_who'>Section&nbsp;9.1<span> (</span><span class='info'>Who should implement this specification</span><span>)</span></a>, especially when not soon after a crash will limit the 
            attacker's ability to construct a dictionary.
</li>
<li> The methods in <a class='info' href='#tg1'>Section&nbsp;5.1<span> (</span><span class='info'>A Stateless Method of Token Generation</span><span>)</span></a> and <a class='info' href='#tg2'>Section&nbsp;5.2<span> (</span><span class='info'>A Stateless Method with IP addresses</span><span>)</span></a> allow for a periodic 
            change of the QCD_SECRET. Any such change invalidates the entire dictionary.
</li>
</ul>

<a name="iana"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.11"></a><h3>11.&nbsp;
IANA Considerations</h3>

<p> IANA is requested to assign a notify message type from the status types range
          (16406-40959) of the "IKEv2 Notify Message Types" registry with name 
          "QUICK_CRASH_DETECTION".
</p>
<a name="ack"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.12"></a><h3>12.&nbsp;
Acknowledgements</h3>

<p> We would like to thank Hannes Tschofenig and Yaron Sheffer for their comments about
          Session Resumption.
</p>
<a name="history"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.13"></a><h3>13.&nbsp;
Change Log</h3>

<p> This section lists all changes in this document
</p>
<p> NOTE TO RFC EDITOR : Please remove this section in the final RFC
</p>
<a name="history05"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.13.1"></a><h3>13.1.&nbsp;
Changes from draft-nir-ike-qcd-03 and -04</h3>

<p>Mostly editorial changes and cleaning up.
</p>
<a name="history04"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.13.2"></a><h3>13.2.&nbsp;
Changes from draft-nir-ike-qcd-02</h3>

<p></p>
<ul class="text">
<li> Described QCD token enumeration, following a question by Lakshminath Dondeti.
</li>
<li> Added the ability to replace the QCD token for an existing IKE SA.
</li>
<li> Added tokens dependant on peer IP address and their interaction with MOBIKE.
</li>
</ul>

<a name="history03"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.13.3"></a><h3>13.3.&nbsp;
Changes from draft-nir-ike-qcd-01</h3>

<p></p>
<ul class="text">
<li> Removed stateless method.
</li>
<li> Added discussion of rekeying and resumption.
</li>
<li> Added discussion of non-synchronized load-balanced clusters of gateways in the 
              security considerations.
</li>
<li> Other wording fixes.
</li>
</ul>

<a name="history02"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.13.4"></a><h3>13.4.&nbsp;
Changes from draft-nir-ike-qcd-00</h3>

<p></p>
<ul class="text">
<li> Merged proposal with draft-detienne-ikev2-recovery <a class='info' href='#recovery'>[recovery]<span> (</span><span class='info'>Detienne, F., Sethi, P., and Y. Nir, &ldquo;Safe IKE Recovery,&rdquo; August&nbsp;2008.</span><span>)</span></a>
</li>
<li> Changed the protocol so that the rebooted peer generates the token. This has the
              effect, that the need for persistent storage is eliminated.
</li>
<li> Added discussion of birth certificates.
</li>
</ul>

<a name="history01"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.13.5"></a><h3>13.5.&nbsp;
Changes from draft-nir-qcr-00</h3>

<p></p>
<ul class="text">
<li> Changed name to reflect that this relates to IKE. Also changed from quick crash 
              recovery to quick crash detection to avoid confusion with IFARE.
</li>
<li> Added more operational considerations. 
</li>
<li> Added interaction with IFARE.
</li>
<li> Added discussion of backup gateways.
</li>
</ul>

<a name="rfc.references"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.14"></a><h3>14.&nbsp;
References</h3>

<a name="rfc.references1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>14.1.&nbsp;Normative References</h3>
<table width="99%" border="0">
<tr><td class="author-text" valign="top"><a name="RFC2119">[RFC2119]</a></td>
<td class="author-text"><a href="mailto:sob@harvard.edu">Bradner, S.</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>,&rdquo; BCP&nbsp;14, RFC&nbsp;2119, March&nbsp;1997 (<a href="ftp://ftp.isi.edu/in-notes/rfc2119.txt">TXT</a>, <a href="http://xml.resource.org/public/rfc/html/rfc2119.html">HTML</a>, <a href="http://xml.resource.org/public/rfc/xml/rfc2119.xml">XML</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4306">[RFC4306]</a></td>
<td class="author-text">Kaufman, C., &ldquo;<a href="http://tools.ietf.org/html/rfc4306">Internet Key Exchange (IKEv2) Protocol</a>,&rdquo; RFC&nbsp;4306, December&nbsp;2005 (<a href="http://www.ietf.org/rfc/rfc4306.txt">TXT</a>, <a href="http://xml.resource.org/public/rfc/html/rfc4306.html">HTML</a>, <a href="http://xml.resource.org/public/rfc/xml/rfc4306.xml">XML</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4555">[RFC4555]</a></td>
<td class="author-text">Eronen, P., &ldquo;<a href="http://tools.ietf.org/html/rfc4555">IKEv2 Mobility and Multihoming Protocol (MOBIKE)</a>,&rdquo; RFC&nbsp;4555, June&nbsp;2006 (<a href="http://www.ietf.org/rfc/rfc4555.txt">TXT</a>, <a href="http://xml.resource.org/public/rfc/html/rfc4555.html">HTML</a>, <a href="http://xml.resource.org/public/rfc/xml/rfc4555.xml">XML</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4718">[RFC4718]</a></td>
<td class="author-text">Eronen, P. and P. Hoffman, &ldquo;<a href="http://tools.ietf.org/html/rfc4718">IKEv2 Clarifications and Implementation Guidelines</a>,&rdquo; RFC&nbsp;4718, October&nbsp;2006 (<a href="http://www.ietf.org/rfc/rfc4718.txt">TXT</a>, <a href="http://xml.resource.org/public/rfc/html/rfc4718.html">HTML</a>, <a href="http://xml.resource.org/public/rfc/xml/rfc4718.xml">XML</a>).</td></tr>
</table>

<a name="rfc.references2"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>14.2.&nbsp;Informative References</h3>
<table width="99%" border="0">
<tr><td class="author-text" valign="top"><a name="recovery">[recovery]</a></td>
<td class="author-text">Detienne, F., Sethi, P., and Y. Nir, &ldquo;<a href="http://www.ietf.org/internet-drafts/draft-detienne-ikev2-recovery.txt">Safe IKE Recovery</a>,&rdquo; draft-detienne-ikev2-recovery (work in progress), August&nbsp;2008 (<a href="http://tools.ietf.org/id/draft-detienne-ikev2-recovery">TXT</a>, <a href="http://tools.ietf.org/html/draft-detienne-ikev2-recovery">HTML</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="resumption">[resumption]</a></td>
<td class="author-text">Sheffer, Y. and H. Tschofenig, &ldquo;<a href="http://www.ietf.org/internet-drafts/draft-ietf-ipsecme-ikev2-resumption.txt">IKEv2 Session Resumption</a>,&rdquo; draft-ietf-ipsecme-ikev2-resumption (work in progress), June&nbsp;2009 (<a href="http://tools.ietf.org/id/draft-ietf-ipsecme-ikev2-resumption">TXT</a>, <a href="http://tools.ietf.org/html/draft-ietf-ipsecme-ikev2-resumption">HTML</a>).</td></tr>
</table>

<a name="rfc.authors"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>Authors' Addresses</h3>
<table width="99%" border="0" cellpadding="0" cellspacing="0">
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Yoav Nir</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Check Point Software Technologies Ltd.</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">5 Hasolelim st.</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Tel Aviv  67897</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Israel</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:ynir@checkpoint.com">ynir@checkpoint.com</a></td></tr>
<tr cellpadding="3"><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Frederic Detienne</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Cisco Systems, Inc.</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">De Kleetlaan, 7</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Diegem  B-1831</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Belgium</td></tr>
<tr><td class="author" align="right">Phone:&nbsp;</td>
<td class="author-text">+32 2 704 5681</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:fd@cisco.com">fd@cisco.com</a></td></tr>
<tr cellpadding="3"><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Pratima Sethi</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Cisco Systems, Inc.</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">O'Shaugnessy Road, 11</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Bangalore, Karnataka  560027</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">India</td></tr>
<tr><td class="author" align="right">Phone:&nbsp;</td>
<td class="author-text">+91 80 4154 1654</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:psethi@cisco.com">psethi@cisco.com</a></td></tr>
</table>
</body></html>
