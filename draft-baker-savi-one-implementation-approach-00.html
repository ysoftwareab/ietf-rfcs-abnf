<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="en"><head><title>An implementation approach to Source
    Address Validation</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="description" content="An implementation approach to Source
    Address Validation">
<meta name="generator" content="xml2rfc v1.35 (http://xml.resource.org/)">
<meta name="viewport" content="width=600;" />
<style type='text/css'><!--
        body {
                font-family: verdana, charcoal, helvetica, arial, sans-serif;
                font-size: 85%;
		max-width: 60em; 
		color: #000; background-color: #FFF;
                margin: 2em;
        }
        h1, h2, h3, h4, h5, h6 {
                font-family: helvetica, monaco, "MS Sans Serif", arial, sans-serif;
                font-weight: bold; font-style: normal;
        }
        h1 { color: #900; background-color: transparent; text-align: right; }
        h3 { color: #333; background-color: transparent; }

        td.RFCbug {
                font-size: x-small; text-decoration: none;
                width: 30px; height: 30px; padding-top: 2px;
                text-align: justify; vertical-align: middle;
                background-color: #000;
        }
        td.RFCbug span.RFC {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: bold; color: #666;
        }
        td.RFCbug span.hotText {
                font-family: charcoal, monaco, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: normal; text-align: center; color: #FFF;
        }

        table.TOCbug { width: 30px; height: 15px; }
        td.TOCbug {
                text-align: center; width: 30px; height: 15px;
                color: #FFF; background-color: #900;
        }
        td.TOCbug a {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, sans-serif;
                font-weight: bold; font-size: x-small; text-decoration: none;
                color: #FFF; background-color: transparent;
        }

        td.header {
                font-family: arial, helvetica, sans-serif; font-size: x-small;
                vertical-align: top; width: 33%;
                color: #FFF; background-color: #666;
        }
        td.author { font-weight: bold; font-size: x-small; margin-left: 4em; }
        td.author-text { font-size: x-small; }

        /* info code from SantaKlauss at http://www.madaboutstyle.com/tooltip2.html */
        a.info {
                /* This is the key. */
                position: relative;
                z-index: 24;
                text-decoration: none;
        }
        a.info:hover {
                z-index: 25;
                color: #FFF; background-color: #900;
        }
        a.info span { display: none; }
        a.info:hover span.info {
                /* The span will display just on :hover state. */
                display: block;
                position: absolute;
                font-size: smaller;
                top: 2em; left: -5em; width: 15em;
                padding: 2px; border: 1px solid #333;
                color: #900; background-color: #EEE;
                text-align: left;
        }

        a { font-weight: bold; }
        a:link    { color: #900; background-color: transparent; }
        a:visited { color: #633; background-color: transparent; }
        a:active  { color: #633; background-color: transparent; }

        p { margin-left: 2em; margin-right: 2em; }
        p.copyright { font-size: x-small; }
        p.toc { font-size: 85%;
		max-width: 60em; 
		font-weight: bold; margin-left: 3em; }
        table.toc { margin: 0 0 0 3em; padding: 0; border: 0; vertical-align: text-top; }
        td.toc { font-size: 85%;
		max-width: 60em; 
		font-weight: bold; vertical-align: text-top; }

        ol.text { margin-left: 2em; margin-right: 2em; }
        ul.text { margin-left: 2em; margin-right: 2em; }
        li      { margin-left: 3em; }

        /* RFC-2629 <spanx>s and <artwork>s. */
        em     { font-style: italic; }
        strong { font-weight: bold; }
        dfn    { font-weight: bold; font-style: normal; }
        cite   { font-weight: normal; font-style: normal; }
        tt     { color: #036; }
        tt, pre, pre dfn, pre em, pre cite, pre span {
                font-family: "Courier New", Courier, monospace; font-size: small;
        }
        pre {
                text-align: left; padding: 4px;
                color: #000; background-color: #CCC;
        }
        pre dfn  { color: #900; }
        pre em   { color: #66F; background-color: #FFC; font-weight: normal; }
        pre .key { color: #33C; font-weight: bold; }
        pre .id  { color: #900; }
        pre .str { color: #000; background-color: #CFF; }
        pre .val { color: #066; }
        pre .rep { color: #909; }
        pre .oth { color: #000; background-color: #FCF; }
        pre .err { background-color: #FCC; }

        /* RFC-2629 <texttable>s. */
        table.all, table.full, table.headers, table.none {
                font-size: 85%;
		max-width: 60em; 
		text-align: center; border-width: 2px;
                vertical-align: top; border-collapse: collapse;
        }
        table.all, table.full { border-style: solid; border-color: black; }
        table.headers, table.none { border-style: none; }
        th {
                font-weight: bold; border-color: black;
                border-width: 2px 2px 3px 2px;
        }
        table.all th, table.full th { border-style: solid; }
        table.headers th { border-style: none none solid none; }
        table.none th { border-style: none; }
        table.all td {
                border-style: solid; border-color: #333;
                border-width: 1px 2px;
        }
        table.full td, table.headers td, table.none td { border-style: none; }

        hr { height: 1px; }
        hr.insert {
                width: 80%; border-style: none; border-width: 0;
                color: #CCC; background-color: #CCC;
        }
--></style>
</head>
<body>
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<table summary="layout" width="66%" border="0" cellpadding="0" cellspacing="0"><tr><td><table summary="layout" width="100%" border="0" cellpadding="2" cellspacing="1">
<tr><td class="header">SAVI</td><td class="header">F. Baker</td></tr>
<tr><td class="header">Internet-Draft</td><td class="header">Cisco Systems</td></tr>
<tr><td class="header">Intended status: Informational</td><td class="header">May 11, 2010</td></tr>
<tr><td class="header">Expires: November 12, 2010</td><td class="header">&nbsp;</td></tr>
</table></td></tr></table>
<h1><br />An implementation approach to Source
    Address Validation<br />draft-baker-savi-one-implementation-approach-00</h1>

<h3>Abstract</h3>

<p>This note is intended to flesh out a comment made on a mailing list.
      It describes one of many possible implementation approaches to SAVI
      systems, and is intended as much as anything to be an existence proof
      that there is at least one that would work.
</p>
<h3>Requirements</h3>

<p>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
      "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
      document are to be interpreted as described in <a class='info' href='#RFC2119'>[RFC2119]<span> (</span><span class='info'>Bradner, S., &ldquo;Key words for use in RFCs to Indicate Requirement Levels,&rdquo; March&nbsp;1997.</span><span>)</span></a>.
</p>
<h3>Status of this Memo</h3>
<p>
This Internet-Draft is submitted  in full
conformance with the provisions of BCP&nbsp;78 and BCP&nbsp;79.</p>
<p>
Internet-Drafts are working documents of the Internet Engineering
Task Force (IETF).  Note that other groups may also distribute
working documents as Internet-Drafts.  The list of current
Internet-Drafts is at http://datatracker.ietf.org/drafts/current/.</p>
<p>
Internet-Drafts are draft documents valid for a maximum of six months
and may be updated, replaced, or obsoleted by other documents at any time.
It is inappropriate to use Internet-Drafts as reference material or to cite
them other than as &ldquo;work in progress.&rdquo;</p>
<p>
This Internet-Draft will expire on November 12, 2010.</p>

<h3>Copyright Notice</h3>
<p>
Copyright (c) 2010 IETF Trust and the persons identified as the
document authors.  All rights reserved.</p>
<p>
This document is subject to BCP 78 and the IETF Trust's Legal
Provisions Relating to IETF Documents
(http://trustee.ietf.org/license-info) in effect on the date of
publication of this document.  Please review these documents
carefully, as they describe your rights and restrictions with respect
to this document. Code Components extracted from this document must
include Simplified BSD License text as described in Section 4.e of
the Trust Legal Provisions and are provided without warranty as
described in the Simplified BSD License.</p>
<a name="toc"></a><br /><hr />
<h3>Table of Contents</h3>
<p class="toc">
<a href="#anchor1">1.</a>&nbsp;
Introduction<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor2">1.1.</a>&nbsp;
The purpose of SAVI<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#model">1.2.</a>&nbsp;
Conceptual SAVI Switch Model<br />
<a href="#approach">2.</a>&nbsp;
Solutions for identifying valid bindings<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#proposal">2.1.</a>&nbsp;
An implementation proposal<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#DHCP">2.2.</a>&nbsp;
Implementation in a DHCP configuration<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#send">2.3.</a>&nbsp;
Implementation using Secure Neighbor Discovery<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#nd">2.4.</a>&nbsp;
Implementation using Neighbor Discovery<br />
<a href="#extreme">3.</a>&nbsp;
Extreme Cases<br />
<a href="#IANA">4.</a>&nbsp;
IANA Considerations<br />
<a href="#Security">5.</a>&nbsp;
Security Considerations<br />
<a href="#Acknowledgements">6.</a>&nbsp;
Acknowledgements<br />
<a href="#rfc.references1">7.</a>&nbsp;
References<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#rfc.references1">7.1.</a>&nbsp;
Normative References<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#rfc.references2">7.2.</a>&nbsp;
Informative References<br />
<a href="#rfc.authors">&#167;</a>&nbsp;
Author's Address<br />
</p>
<br clear="all" />

<a name="anchor1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1"></a><h3>1.&nbsp;
Introduction</h3>

<p>This note is intended to flesh out a comment made on a mailing list.
      It describes one of many possible implementation approaches to SAVI
      systems, and is intended as much as anything to be an existence proof
      that there is at least one that would work. The comment was: </p>
<blockquote class="text">
<p>Let me give you one potential implementation. Consider a switch
          that for whatever reason is discarding datagrams from a given port
          because they use an IPv6 source address that is not in its tables.
          For various reasons, it very likely has a counter, on the switch or
          VLAN if not on the port itself. It could also maintain a register or
          FIFO to capture the source IPv6 and MAC addresses this happened on.
          Without putting the logic for generating the request into the data
          path, it becomes quite possible for a control plane process to
          monitor that register and initiate DHCP queries to verify the
          address and obtain the state from DHCP server. This could be done at
          a controlled rate per port, to prevent what amounts to a DOS
          multiplier in which a source address "scan" results in a DHCP query
          assault on the server.
</p>
<p>In the event that a switch restarts, that logic obviously happens
          across the board. It can result in a burst comparable in size to the
          number of ports on the switch in a short interval, but that is not a
          continuing behavior.
</p>
</blockquote>

<a name="anchor2"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1.1"></a><h3>1.1.&nbsp;
The purpose of SAVI</h3>

<p>Any discussion of an algorithm must start from a statement of what
        problem it intends to solve. The purpose of this algorithm is to
        ensure that, within the subnet in which it is implemented, any IPv6
        source address used by a given Ethernet client is valid. It is valid
        if it has been allocated in accordance with the algorithms in use for
        the class of address on the subnet, and as a result is in use by
        exactly one system. Ideally, the system also responds to it.
</p>
<a name="model"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1.2"></a><h3>1.2.&nbsp;
Conceptual SAVI Switch Model</h3>

<p>As shown in <a class='info' href='#switch'>Figure&nbsp;1<span> (</span><span class='info'>Ethernet Switch Data Plane</span><span>)</span></a>, a switch is a system
        with Ethernet ports and uses <a class='info' href='#IEEE.802-1D.1993'>[IEEE.802&#8209;1D.1993]<span> (</span><span class='info'>Institute of Electrical and Electronics Engineers, &ldquo;Information technology - Telecommunications and information exchange between systems - Local area networks - Media access control (MAC) bridges,&rdquo; July&nbsp;1993.</span><span>)</span></a>
        Ethernet switching among those ports. Those ports may support
        individual Ethernet clients (which may themselves be hosts or IP
        routers, which require different handling by the switch, as routers
        originate Ethernet datagrams with many IPv6 source addresses while
        hosts use only their own), or may be trunks between switches; in the
        latter case, a protocol such as IEEE Spanning Tree is run to prevent
        bad things from happening. "Trunks between switches" differ in scale.
        It is common to have a small (four or eight) port switch on a desktop
        to facilitate wiring. A virtual host may appear to be a small virtual
        switch with some number virtual clients attached to it. Large switches
        are often deployed in tandem to manage failure rates, and may connect
        hundreds to thousands of clients. The connection between two switches
        is always a trunk. In smaller cases it is rational to have the larger
        switch bind associations to the combination of a port and a MAC
        address, while in larger switches must depend on each other for source
        address validation services for scalability.
</p>
<p>There are two general kinds of filters in a typical switch: the
        "Port Filter" and the "Forwarding Logic". A Port Filter applies policy
        to the datagrams received on a port, usually to discard or only permit
        selected datagrams. The Forwarding Logic identifies the set of ports
        to which an Ethernet Frame from a given port will be forwarded. In the
        forwarding logic, the specified set of ports may be null, a single
        port, a larger set of ports, or all of them except the port the
        datagram was received on. Background processes in a switch may be
        attached to a virtual port, so that traffic to or from the CPU is not
        a special case in its algorithms.
</p>
<p>Any given implementation will of course vary in its internal
        structure and characteristics. The port filter might literally use a
        separate memory system per port, or might be the same database used
        for forwarding applied in a different way, or might use some other
        solution. The intention here is not to attempt to specify the
        implementation, but to identify a conceptual framework in which
        varying implementations can be described.
</p><br /><hr class="insert" />
<a name="switch"></a>
<div style='display: table; width: 0; margin-left: auto; margin-right: auto'><pre>
          +-------------------+
          |     Switch        |
          |                   |
          |         +------+  |
+----+    +----+    | Port |  |
|Host|----|Port|----|Filter|  |
+----+    +----+    +------+  |
          |            |      |
+-----+   +----+  +----------+|
|Else-|---|Port|--|Forwarding||
|Where|   +----+  |  Logic   ||
+-----+   |       +----------+|
          +-------------------+
</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;1: Ethernet Switch Data Plane&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>The Port Filter is primarily in view in the SAVI model. A SAVI
        implementation configures the Port Filter to </p>
<ol class="text">
<li>Identify <a class='info' href='#RFC2460'>IPv6<span> (</span><span class='info'>Deering, S. and R. Hinden, &ldquo;Internet Protocol, Version 6 (IPv6) Specification,&rdquo; December&nbsp;1998.</span><span>)</span></a> [RFC2460] datagrams,
</li>
<li>Isolate their binding values, which are generally some subset
            of their port, MAC Address, and IPv6 Source Address,
</li>
<li>Accept IPv6 datagrams matching one of a list of specified
            bindings, and
</li>
<li>Discard all other IPv6 datagrams.
</li>
</ol>

<p>The discussion in SAVI has primarily related to the binding
        relationships among interfaces and addresses that are </p>
<ul class="text">
<li>Statically configured,
</li>
<li>Derived from <a class='info' href='#RFC4862'>Stateless Address
            Autoconfiguration<span> (</span><span class='info'>Thomson, S., Narten, T., and T. Jinmei, &ldquo;IPv6 Stateless Address Autoconfiguration,&rdquo; September&nbsp;2007.</span><span>)</span></a> [RFC4862]<a class='info' href='#RFC4941'>[RFC4941]<span> (</span><span class='info'>Narten, T., Draves, R., and S. Krishnan, &ldquo;Privacy Extensions for Stateless Address Autoconfiguration in IPv6,&rdquo; September&nbsp;2007.</span><span>)</span></a>, or
</li>
<li>Assigned via <a class='info' href='#RFC3315'>DHCPv6<span> (</span><span class='info'>Droms, R., Bound, J., Volz, B., Lemon, T., Perkins, C., and M. Carney, &ldquo;Dynamic Host Configuration Protocol for IPv6 (DHCPv6),&rdquo; July&nbsp;2003.</span><span>)</span></a> [RFC3315].
</li>
</ul>

<a name="approach"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2"></a><h3>2.&nbsp;
Solutions for identifying valid bindings</h3>

<p>Several proposals have been put forward as means to identify valid
      switch bindings. The major ones depend on either </p>
<ul class="text">
<li>An external reference, such as a <a class='info' href='#RFC3315'>DHCPv6<span> (</span><span class='info'>Droms, R., Bound, J., Volz, B., Lemon, T., Perkins, C., and M. Carney, &ldquo;Dynamic Host Configuration Protocol for IPv6 (DHCPv6),&rdquo; July&nbsp;2003.</span><span>)</span></a> [RFC3315] server, assigning valid bindings as
          specified in <a class='info' href='#I-D.ietf-savi-dhcp'>[I&#8209;D.ietf&#8209;savi&#8209;dhcp]<span> (</span><span class='info'>Bi, J., Wu, J., Yao, G., and F. Baker, &ldquo;SAVI Solution for DHCP,&rdquo; April&nbsp;2010.</span><span>)</span></a>, or
</li>
<li>Individual clients using <a class='info' href='#RFC4862'>Stateless
          Address Autoconfiguration<span> (</span><span class='info'>Thomson, S., Narten, T., and T. Jinmei, &ldquo;IPv6 Stateless Address Autoconfiguration,&rdquo; September&nbsp;2007.</span><span>)</span></a> [RFC4862]<a class='info' href='#RFC4941'>[RFC4941]<span> (</span><span class='info'>Narten, T., Draves, R., and S. Krishnan, &ldquo;Privacy Extensions for Stateless Address Autoconfiguration in IPv6,&rdquo; September&nbsp;2007.</span><span>)</span></a>
          correctly, as specified in <a class='info' href='#I-D.bi-savi-stateless'>[I&#8209;D.bi&#8209;savi&#8209;stateless]<span> (</span><span class='info'>Bi, J., Yao, G., Wu, J., and F. Baker, &ldquo;SAVI Solution for Stateless Address,&rdquo; April&nbsp;2010.</span><span>)</span></a>.
</li>
</ul>

<p>A simpler approach was suggested in <a class='info' href='#I-D.ietf-savi-fcfs'>[I&#8209;D.ietf&#8209;savi&#8209;fcfs]<span> (</span><span class='info'>Nordmark, E., Bagnulo, M., and E. Levy-Abegnoli, &ldquo;FCFS-SAVI: First-Come First-Serve Source-Address Validation for Locally Assigned Addresses,&rdquo; October&nbsp;2009.</span><span>)</span></a>, in which the first user of an
      address is deemed to be its "owner" for the foreseeable future. This
      suffers two security defects: the use of an address does not imply that
      the address has been allocated by any given algorithm (it may indeed
      have been statically assigned or be generated at a high rate during an
      attack), and does not imply that there are no others that validly lay
      claim to it.
</p>
<p>We in short come down to the relative merits of using either the
      control plane to detect and make inferences from control plane (DHCP or
      SLAAC DAD) behavior and behavior in the data plane that simply learns
      addresses as their are used, comparable to their learning and use in
      IEEE 802.1D.
</p>
<a name="proposal"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2.1"></a><h3>2.1.&nbsp;
An implementation proposal</h3>

<p>It is reasonable to expect that the forwarding logic, which is
        often implemented in hardware or microcode, does not attempt to manage
        its tables in real time. Instead, it has some defined interface -
        perhaps a register or queue - to a control plane process. In normal
        operation, the forwarding and filtering tables require no
        modification; the port filter and forwarding logic refer to them, and
        the datagram is handled accordingly. However, in exception cases, the
        datagram or relevant information from it is queued to the control
        plane for further analysis.
</p><br /><hr class="insert" />
<a name="interface"></a>
<div style='display: table; width: 0; margin-left: auto; margin-right: auto'><pre>
          +-----------------------------------+
          |     Switch                        |
          |                                   |
          |         +------+      +----------+|
+----+    +----+    | Port |      |  Table   ||
|Host|----|Port|----|Filter|--||--|Management||
+----+    +----+    +------+      |  Process ||
          |            |          +----------+|
+-----+   +----+  +----------+                |
|Else-|---|Port|--|Forwarding|                |
|Where|   +----+  |  Logic   |                |
+-----+   |       +----------+                |
          +-----------------------------------+
</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;2: Switch Data and Control Planes&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>As shown in <a class='info' href='#interface'>Figure&nbsp;2<span> (</span><span class='info'>Switch Data and Control Planes</span><span>)</span></a>, I suggest that this
        might be extended to include information about failures of
        SAVI-relevant port filter entries. If the SAVI Port Filter terms all
        fail to match (e.g., the logic in <a class='info' href='#model'>Section&nbsp;1.2<span> (</span><span class='info'>Conceptual SAVI Switch Model</span><span>)</span></a>
        determines that case 4 applies), the datagram is discarded, but a
        request is queued to the Table Management Process to determine whether
        a new SAVI term needs to be added to the relevant Port Filter. The
        process executes an appropriate procedure, and in the event of an
        affirmative outcome updates the Port Filter to accept the new binding.
        When the client retransmits the datagram, it passes through.
</p>
<a name="DHCP"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2.2"></a><h3>2.2.&nbsp;
Implementation in a DHCP configuration</h3>

<p>In a network using <a class='info' href='#RFC3315'>DHCPv6<span> (</span><span class='info'>Droms, R., Bound, J., Volz, B., Lemon, T., Perkins, C., and M. Carney, &ldquo;Dynamic Host Configuration Protocol for IPv6 (DHCPv6),&rdquo; July&nbsp;2003.</span><span>)</span></a> [RFC3315], we have
        the luxury of an authoritative information source. Correct
        implementation depends only on deriving information from it. This
        requires two components: </p>
<ol class="text">
<li>The forwarding logic MUST be configured to identify DHCP
            datagrams and send copies to the Table Management Process. If the
            switch observes a datagram from the DHCP server authorizing a
            binding between a port, a MAC Address, and an IPv6 Source Address,
            the binding is stored in the Port Filter for the relevant
            port.
</li>
<li>When a client is observed using an IPv6 source address that
            fails the binding test, the Table Management Process MAY construct
            a DHCPv6 Request that appears to be from the client enquiring
            about the address. The DHCP server will likely respond to the
            datagram; if it responds in the affirmative, the action in bullet
            1 will record the authorization.
</li>
</ol>

<p>The switch MAY also apply a policy to detect and mitigate attacks,
        such as rate limiting the number of new source addresses used on a
        port per unit time.
</p>
<a name="send"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2.3"></a><h3>2.3.&nbsp;
Implementation using Secure Neighbor Discovery</h3>

<p>In a network using <a class='info' href='#RFC3971'>SEcure Neighbor
        Discovery<span> (</span><span class='info'>Arkko, J., Kempf, J., Zill, B., and P. Nikander, &ldquo;SEcure Neighbor Discovery (SEND),&rdquo; March&nbsp;2005.</span><span>)</span></a> [RFC3971], we have the luxury of an authoritative exchange.
        Correct implementation depends on deriving information from it. This
        requires two components: </p>
<ol class="text">
<li>The forwarding logic MUST be configured to identify SeND
            messages and send copies to the Table Management Process. If the
            switch observes a SeND Response demonstrating the necessary
            credentials to authorize a binding between a port, a MAC Address,
            and an IPv6 Source Address, the binding is stored in the Port
            Filter for the relevant port.
</li>
<li>When a client is observed using an IPv6 source address that
            fails the binding test, the Table Management Process MAY construct
            a Secure Neighbor Solicitation for the address. The relevant
            client will likely respond to the datagram; the action in bullet 1
            will record the authorization.
</li>
</ol>

<p>The switch MAY also apply a policy to detect and mitigate attacks,
        such as rate limiting the number of new source addresses used on a
        port per unit time.
</p>
<a name="nd"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2.4"></a><h3>2.4.&nbsp;
Implementation using Neighbor Discovery</h3>

<p>In a network in which there is no authoritative information source,
        correct implementation depends on observing the correct implementation
        of <a class='info' href='#RFC4861'>Neighbor Discovery<span> (</span><span class='info'>Narten, T., Nordmark, E., Simpson, W., and H. Soliman, &ldquo;Neighbor Discovery for IP version 6 (IPv6),&rdquo; September&nbsp;2007.</span><span>)</span></a> [RFC4861] and <a class='info' href='#RFC4862'>Address Autoconfiguration<span> (</span><span class='info'>Thomson, S., Narten, T., and T. Jinmei, &ldquo;IPv6 Stateless Address Autoconfiguration,&rdquo; September&nbsp;2007.</span><span>)</span></a> [RFC4862].
</p>
<p>When a client is observed using an IPv6 source address that fails
        the binding test, the Table Management Process SHOULD initiate a
        multicast Neighbor Solicitation to find the client using its source
        address. One of three things will happen: </p>
<ol class="text">
<li>There will be no Neighbor Advertisement in response,
</li>
<li>There will be one or more Neighbor Advertisement responses, at
            least one of which is from some other client, or
</li>
<li>There will be exactly one Neighbor Advertisement response, from
            the indicated client.
</li>
</ol>

<p>The first case is characteristic of some attack scenarios (the
        source is simply generating addresses and using them), and of the
        Duplicate Address Detection phase of Address Autoconfiguration. It is
        an address that should not be seen at this point as a source address.
        The second case is also characteristic of some attack scenarios; a
        program is directly spoofing the address of another system. In these
        cases, the Table Manager MUST NOT configure the binding into the Port
        Filter authorizing the use by this client. The third case, on the
        other hand, is exactly what any client correctly implementing <a class='info' href='#RFC4861'>[RFC4861]<span> (</span><span class='info'>Narten, T., Nordmark, E., Simpson, W., and H. Soliman, &ldquo;Neighbor Discovery for IP version 6 (IPv6),&rdquo; September&nbsp;2007.</span><span>)</span></a> would expect to see in Neighbor Discovery.
        The switch stores the binding indicated by the response - which may be
        from the indicated client or a different one.
</p>
<p>The switch MAY also apply a policy that would detect and mitigate
        other attacks, such as rate limiting the number of new source
        addresses validated on a port per unit time.
</p>
<a name="extreme"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3"></a><h3>3.&nbsp;
Extreme Cases</h3>

<p>Discussion on the list has suggested a variety of solutions to
      extreme cases, notably saving tables in nonvolatile memory to handle
      extreme failures. In my opinion, this is ill-advised and
      unnecessary.
</p>
<p>DHCP-assigned addresses, which have a lifetime, and SLAAC-assigned
      addresses (especially private ones, but also addresses derived from the
      MAC Address), which are flushed when an interface is disconnected, are
      examples of ephemeral information in a network. The storage of ephemeral
      information in permanent storage, such as nonvolatile memory, has the
      effect of making a switch that has rebooted attempt to enforce rules
      that may no longer apply; if they do still apply, their validity derives
      from the assent of the authority. Verification with the authority is
      therefore always sufficient to validate an address.
</p>
<p>Such actions are also unnecessary. In the event of the reboot of a
      switch in a large Ethernet, all of its clients will follow SLAAC
      procedures or issue DHCP requests to obtain their addresses, or the port
      failure will be masked from them by desktop switches and they will
      continue using preexisting addresses. For a short interval, both client
      address management and switch address validation as described in <a class='info' href='#proposal'>Section&nbsp;2.1<span> (</span><span class='info'>An implementation proposal</span><span>)</span></a> can result in a high rate of control plane
      traffic. However, it is limited in two ways: it is only carried out on
      behalf of the clients of the switch, which are a finite number, and each
      such transaction requires at most a limited interval. When the reboot
      has completed and the initial burst passed, matters will return to their
      normal state.
</p>
<p>Since non-volatile memory has a cost and is unnecessary, storage of
      ephemeral information in non-volatile memory is ill-advised.
</p>
<a name="IANA"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4"></a><h3>4.&nbsp;
IANA Considerations</h3>

<p>This memo asks the IANA for no new parameters.
</p>
<p>Note to RFC Editor: This section will have served its purpose if it
      correctly tells IANA that no new assignments or registries are required,
      or if those assignments or registries are created during the RFC
      publication process. From the author"s perspective, it may therefore be
      removed upon publication as an RFC at the RFC Editor"s discretion.
</p>
<a name="Security"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5"></a><h3>5.&nbsp;
Security Considerations</h3>

<p>Several comments about security have been made in this document, but
      it has not been subjected to a thorough security analysis.
</p>
<p>As noted in <a class='info' href='#approach'>Section&nbsp;2<span> (</span><span class='info'>Solutions for identifying valid bindings</span><span>)</span></a>, the data-plane-only
      approach suggested in <a class='info' href='#I-D.ietf-savi-fcfs'>[I&#8209;D.ietf&#8209;savi&#8209;fcfs]<span> (</span><span class='info'>Nordmark, E., Bagnulo, M., and E. Levy-Abegnoli, &ldquo;FCFS-SAVI: First-Come First-Serve Source-Address Validation for Locally Assigned Addresses,&rdquo; October&nbsp;2009.</span><span>)</span></a>, in
      which the first user of an address is deemed to be its "owner" for the
      foreseeable future, suffers two security defects: the use of an address
      does not imply that the address has been allocated in accordance with
      SLAAC, and does not imply that there are no others that validly lay
      claim to it.
</p>
<p>The Neighbor Discovery model discussed in <a class='info' href='#nd'>Section&nbsp;2.4<span> (</span><span class='info'>Implementation using Neighbor Discovery</span><span>)</span></a>
      is not secure. That is why SeND exists. However, it can detect cases in
      which an address has no active users or multiple users, which serves the
      present purpose.
</p>
<p>The approach suggested in <a class='info' href='#proposal'>Section&nbsp;2.1<span> (</span><span class='info'>An implementation proposal</span><span>)</span></a> is based on
      the supposition that the client has followed whatever rules apply in the
      network for allocating addresses. The fact cannot, however, be proven;
      the only thing that can be proven is that the result is consistent with
      it having done so.
</p>
<a name="Acknowledgements"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6"></a><h3>6.&nbsp;
Acknowledgements</h3>

<p>This note was requested by the working group chairs. It has been
      reviewed by Joel Halpern, to whom <a class='info' href='#extreme'>Section&nbsp;3<span> (</span><span class='info'>Extreme Cases</span><span>)</span></a>
      responds.
</p>
<a name="rfc.references"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7"></a><h3>7.&nbsp;
References</h3>

<a name="rfc.references1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>7.1.&nbsp;Normative References</h3>
<table width="99%" border="0">
<tr><td class="author-text" valign="top"><a name="IEEE.802-1D.1993">[IEEE.802-1D.1993]</a></td>
<td class="author-text">Institute of Electrical and Electronics Engineers, &ldquo;Information technology - Telecommunications and information exchange between systems - Local area networks - Media access control (MAC) bridges,&rdquo; IEEE&nbsp;Standard 802.1D, July&nbsp;1993.</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC2119">[RFC2119]</a></td>
<td class="author-text"><a href="mailto:sob@harvard.edu">Bradner, S.</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>,&rdquo; BCP&nbsp;14, RFC&nbsp;2119, March&nbsp;1997 (<a href="http://www.rfc-editor.org/rfc/rfc2119.txt">TXT</a>, <a href="http://xml.resource.org/public/rfc/html/rfc2119.html">HTML</a>, <a href="http://xml.resource.org/public/rfc/xml/rfc2119.xml">XML</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC2460">[RFC2460]</a></td>
<td class="author-text"><a href="mailto:deering@cisco.com">Deering, S.</a> and <a href="mailto:hinden@iprg.nokia.com">R. Hinden</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc2460">Internet Protocol, Version 6 (IPv6) Specification</a>,&rdquo; RFC&nbsp;2460, December&nbsp;1998 (<a href="http://www.rfc-editor.org/rfc/rfc2460.txt">TXT</a>, <a href="http://xml.resource.org/public/rfc/html/rfc2460.html">HTML</a>, <a href="http://xml.resource.org/public/rfc/xml/rfc2460.xml">XML</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC3315">[RFC3315]</a></td>
<td class="author-text">Droms, R., Bound, J., Volz, B., Lemon, T., Perkins, C., and M. Carney, &ldquo;<a href="http://tools.ietf.org/html/rfc3315">Dynamic Host Configuration Protocol for IPv6 (DHCPv6)</a>,&rdquo; RFC&nbsp;3315, July&nbsp;2003 (<a href="http://www.rfc-editor.org/rfc/rfc3315.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC3971">[RFC3971]</a></td>
<td class="author-text">Arkko, J., Kempf, J., Zill, B., and P. Nikander, &ldquo;<a href="http://tools.ietf.org/html/rfc3971">SEcure Neighbor Discovery (SEND)</a>,&rdquo; RFC&nbsp;3971, March&nbsp;2005 (<a href="http://www.rfc-editor.org/rfc/rfc3971.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4861">[RFC4861]</a></td>
<td class="author-text">Narten, T., Nordmark, E., Simpson, W., and H. Soliman, &ldquo;<a href="http://tools.ietf.org/html/rfc4861">Neighbor Discovery for IP version 6 (IPv6)</a>,&rdquo; RFC&nbsp;4861, September&nbsp;2007 (<a href="http://www.rfc-editor.org/rfc/rfc4861.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4862">[RFC4862]</a></td>
<td class="author-text">Thomson, S., Narten, T., and T. Jinmei, &ldquo;<a href="http://tools.ietf.org/html/rfc4862">IPv6 Stateless Address Autoconfiguration</a>,&rdquo; RFC&nbsp;4862, September&nbsp;2007 (<a href="http://www.rfc-editor.org/rfc/rfc4862.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4941">[RFC4941]</a></td>
<td class="author-text">Narten, T., Draves, R., and S. Krishnan, &ldquo;<a href="http://tools.ietf.org/html/rfc4941">Privacy Extensions for Stateless Address Autoconfiguration in IPv6</a>,&rdquo; RFC&nbsp;4941, September&nbsp;2007 (<a href="http://www.rfc-editor.org/rfc/rfc4941.txt">TXT</a>).</td></tr>
</table>

<a name="rfc.references2"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>7.2.&nbsp;Informative References</h3>
<table width="99%" border="0">
<tr><td class="author-text" valign="top"><a name="I-D.bi-savi-stateless">[I-D.bi-savi-stateless]</a></td>
<td class="author-text">Bi, J., Yao, G., Wu, J., and F. Baker, &ldquo;<a href="http://www.ietf.org/internet-drafts/draft-bi-savi-stateless-00.txt">SAVI Solution for Stateless Address</a>,&rdquo; draft-bi-savi-stateless-00 (work in progress), April&nbsp;2010 (<a href="http://www.ietf.org/internet-drafts/draft-bi-savi-stateless-00.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="I-D.ietf-savi-dhcp">[I-D.ietf-savi-dhcp]</a></td>
<td class="author-text">Bi, J., Wu, J., Yao, G., and F. Baker, &ldquo;<a href="http://www.ietf.org/internet-drafts/draft-ietf-savi-dhcp-02.txt">SAVI Solution for DHCP</a>,&rdquo; draft-ietf-savi-dhcp-02 (work in progress), April&nbsp;2010 (<a href="http://www.ietf.org/internet-drafts/draft-ietf-savi-dhcp-02.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="I-D.ietf-savi-fcfs">[I-D.ietf-savi-fcfs]</a></td>
<td class="author-text">Nordmark, E., Bagnulo, M., and E. Levy-Abegnoli, &ldquo;<a href="http://www.ietf.org/internet-drafts/draft-ietf-savi-fcfs-02.txt">FCFS-SAVI: First-Come First-Serve Source-Address Validation for Locally Assigned Addresses</a>,&rdquo; draft-ietf-savi-fcfs-02 (work in progress), October&nbsp;2009 (<a href="http://www.ietf.org/internet-drafts/draft-ietf-savi-fcfs-02.txt">TXT</a>).</td></tr>
</table>

<a name="rfc.authors"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>Author's Address</h3>
<table width="99%" border="0" cellpadding="0" cellspacing="0">
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Fred Baker</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Cisco Systems</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Santa Barbara, California  93117</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">USA</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:fred@cisco.com">fred@cisco.com</a></td></tr>
</table>
</body></html>
