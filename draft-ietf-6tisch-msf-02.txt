



6TiSCH                                                     T. Chang, Ed.
Internet-Draft                                                M. Vucinic
Intended status: Standards Track                                   Inria
Expires: September 12, 2019                                X. Vilajosana
                                         Universitat Oberta de Catalunya
                                                            S. Duquennoy
                                                               RISE SICS
                                                         D. Dujovne, Ed.
                                              Universidad Diego Portales
                                                          March 11, 2019


                6TiSCH Minimal Scheduling Function (MSF)
                        draft-ietf-6tisch-msf-02

Abstract

   This specification defines the 6TiSCH Minimal Scheduling Function
   (MSF).  This Scheduling Function describes both the behavior of a
   node when joining the network, and how the communication schedule is
   managed in a distributed fashion.  MSF builds upon the 6TiSCH
   Operation Sublayer Protocol (6P) and the Minimal Security Framework
   for 6TiSCH.

Requirements Language

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and
   "OPTIONAL" in this document are to be interpreted as described in
   [RFC2119].

Status of This Memo

   This Internet-Draft is submitted in full conformance with the
   provisions of BCP 78 and BCP 79.

   Internet-Drafts are working documents of the Internet Engineering
   Task Force (IETF).  Note that other groups may also distribute
   working documents as Internet-Drafts.  The list of current Internet-
   Drafts is at https://datatracker.ietf.org/drafts/current/.

   Internet-Drafts are draft documents valid for a maximum of six months
   and may be updated, replaced, or obsoleted by other documents at any
   time.  It is inappropriate to use Internet-Drafts as reference
   material or to cite them other than as "work in progress."

   This Internet-Draft will expire on September 12, 2019.




Chang, et al.          Expires September 12, 2019               [Page 1]

Internet-Draft  6TiSCH Minimal Scheduling Function (MSF)      March 2019


Copyright Notice

   Copyright (c) 2019 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to BCP 78 and the IETF Trust's Legal
   Provisions Relating to IETF Documents
   (https://trustee.ietf.org/license-info) in effect on the date of
   publication of this document.  Please review these documents
   carefully, as they describe your rights and restrictions with respect
   to this document.  Code Components extracted from this document must
   include Simplified BSD License text as described in Section 4.e of
   the Trust Legal Provisions and are provided without warranty as
   described in the Simplified BSD License.

Table of Contents

   1.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   3
   2.  Interface to the Minimal 6TiSCH Configuration . . . . . . . .   4
   3.  Autonomous Cells  . . . . . . . . . . . . . . . . . . . . . .   5
   4.  Node Behavior at Boot . . . . . . . . . . . . . . . . . . . .   6
     4.1.  Start State . . . . . . . . . . . . . . . . . . . . . . .   7
     4.2.  Step 1 - Choosing Frequency . . . . . . . . . . . . . . .   7
     4.3.  Step 2 - Receiving EBs  . . . . . . . . . . . . . . . . .   7
     4.4.  Step 3 - Setting up Autonomous Cells during Join Process    7
     4.5.  Step 4 - Installing Autonomous Cells for each neighbor in
           neighbor table  . . . . . . . . . . . . . . . . . . . . .   8
     4.6.  Step 5 - Acquiring a RPL rank . . . . . . . . . . . . . .   8
     4.7.  Step 6 - Send EBs and DIOs  . . . . . . . . . . . . . . .   8
     4.8.  Step 7 - Neighbor Polling . . . . . . . . . . . . . . . .   8
     4.9.  End State . . . . . . . . . . . . . . . . . . . . . . . .   9
   5.  Rules for Adding/Deleting Cells . . . . . . . . . . . . . . .   9
     5.1.  Adapting to Traffic . . . . . . . . . . . . . . . . . . .   9
     5.2.  Switching Parent  . . . . . . . . . . . . . . . . . . . .  11
     5.3.  Handling Schedule Collisions  . . . . . . . . . . . . . .  12
   6.  6P SIGNAL command . . . . . . . . . . . . . . . . . . . . . .  13
   7.  Scheduling Function Identifier  . . . . . . . . . . . . . . .  13
   8.  Rules for CellList  . . . . . . . . . . . . . . . . . . . . .  13
   9.  6P Timeout Value  . . . . . . . . . . . . . . . . . . . . . .  14
   10. Rule for Ordering Cells . . . . . . . . . . . . . . . . . . .  14
   11. Meaning of the Metadata Field . . . . . . . . . . . . . . . .  14
   12. 6P Error Handling . . . . . . . . . . . . . . . . . . . . . .  14
   13. Schedule Inconsistency Handling . . . . . . . . . . . . . . .  15
   14. MSF Constants . . . . . . . . . . . . . . . . . . . . . . . .  15
   15. MSF Statistics  . . . . . . . . . . . . . . . . . . . . . . .  16
   16. Security Considerations . . . . . . . . . . . . . . . . . . .  16
   17. IANA Considerations . . . . . . . . . . . . . . . . . . . . .  17
     17.1.  MSF Scheduling Function Identifiers  . . . . . . . . . .  17



Chang, et al.          Expires September 12, 2019               [Page 2]

Internet-Draft  6TiSCH Minimal Scheduling Function (MSF)      March 2019


   18. References  . . . . . . . . . . . . . . . . . . . . . . . . .  17
     18.1.  Normative References . . . . . . . . . . . . . . . . . .  17
     18.2.  Informative References . . . . . . . . . . . . . . . . .  18
   Appendix A.  Contributors . . . . . . . . . . . . . . . . . . . .  18
   Appendix B.  Example of Implementation of SAX hash function . . .  19
   Appendix C.  Implementation Status and Performance Evaluation . .  20
   Appendix D.  [TEMPORARY] Changelog  . . . . . . . . . . . . . . .  21
   Appendix E.  [TEMPORARY] Pending Elements . . . . . . . . . . . .  21
     E.1.  Introduction  . . . . . . . . . . . . . . . . . . . . . .  21
     E.2.  Performance Related . . . . . . . . . . . . . . . . . . .  21
       E.2.1.  Handling the case when bandwidth allocation exceeds
               available capacity  . . . . . . . . . . . . . . . . .  21
       E.2.2.  Adapting 6P Timeout . . . . . . . . . . . . . . . . .  22
     E.3.  editorial . . . . . . . . . . . . . . . . . . . . . . . .  22
       E.3.1.  Rules for broadcast frames is out of scope of MSF . .  22
   Authors' Addresses  . . . . . . . . . . . . . . . . . . . . . . .  22

1.  Introduction

   The 6TiSCH Minimal Scheduling Function (MSF), defined in this
   specification, is a 6TiSCH Scheduling Function (SF).  The role of an
   SF is entirely defined in [RFC8480]: it complements [RFC8480] by
   providing the rules of when to add/delete cells in the communication
   schedule.  The SF defined in this document follows that definition,
   and satisfies all the requirements for an SF listed in Section 4.2 of
   [RFC8480].

   MSF builds on top of the following specifications: the Minimal IPv6
   over the TSCH Mode of IEEE 802.15.4e (6TiSCH) Configuration
   [RFC8180], the 6TiSCH Operation Sublayer Protocol (6P) [RFC8480], and
   the Minimal Security Framework for 6TiSCH
   [I-D.ietf-6tisch-minimal-security].

   MSF defines both the behavior of a node when joining the network, and
   how the communication schedule is managed in a distributed fashion.
   When a node running MSF boots up, it joins the network by following
   the 7 steps described in Section 4.  The end state of the join
   process is that the node is synchronized to the network, has mutually
   authenticated to the network, has identified a preferred routing
   parent, has scheduled one default managed unicast cell (defined in
   Section 5.1) to/from its preferred routing parent.  After the join
   process, the node can continuously add/delete/relocate cells, as
   described in Section 5.  It does so for 3 reasons: to match the link-
   layer resources to the traffic, to handle changing parent, to handle
   a schedule collision.

   MSF is designed to operate in a wide range of application domains.
   It is optimized for applications with regular upstream traffic (from



Chang, et al.          Expires September 12, 2019               [Page 3]

Internet-Draft  6TiSCH Minimal Scheduling Function (MSF)      March 2019


   the nodes to the root).  Appendix C contains a performance evaluation
   of MSF.

   This specification follows the recommended structure of an SF
   specification in Appendix A of [RFC8480], with the following
   adaptations:

   o  We have reordered part of the sections, in particular to have the
      section on the node behavior at boot Section 4 appear early in
      this specification.
   o  We added sections on the interface to the minimal 6TiSCH
      configuration Section 2, the use of the SIGNAL command Section 6,
      the MSF constants Section 14, the MSF statistics Section 15, the
      performance of MSF Appendix C.
   o  This specification does not include an examples section.

2.  Interface to the Minimal 6TiSCH Configuration

   A node implementing MSF SHOULD implement the Minimal 6TiSCH
   Configuration [RFC8180], which defines the "minimal cell", a single
   shared cell providing minimal connectivity between the nodes in the
   network.  The MSF implementation provided in this specification is
   based on the implementation of the Minimal 6TiSCH Configuration.  An
   implementor with full-awareness of the Minimal 6TiSCH Configuration
   implications MAY implement MSF without it.

   MSF uses the minimal cell to exchange the following packets:

   1.  Enhanced Beacons (EBs), defined by [IEEE802154-2015].  These are
       broadcast frames.
   2.  DODAG Information Objects (DIOs), defined by [RFC6550], with
       broadcast type.  Unicast type DIOs SHOULD NOT be sent on minimal
       cell.

   Because the minimal cell is SHARED, the back-off algorithm defined in
   [IEEE802154-2015] is used to resolve collisions.  To ensure there is
   enough bandwidth available on the minimal cell, a node implementing
   MSF SHOULD enforce the following rules for broadcast frames:

   1.  send EBs on a portion of the minimal cells not exceeding
       1/(3(N+1)), where N is the number of neighbors of the node.
   2.  send any other broadcast packets on a portion of the minimal
       cells not exceeding 1/(3(N+1)), where N is the number of
       neighbors of the node.  For example, the broadcast DIO and DIS,
       IPv6 Neighbor Discovery (ND)[RFC4861] and any other application
       layer broadcast packets.





Chang, et al.          Expires September 12, 2019               [Page 4]

Internet-Draft  6TiSCH Minimal Scheduling Function (MSF)      March 2019


   The RECOMMENDED behavior for sending EBs is to have a node send EBs
   with a probability of 1/(3(N+1)).  The RECOMMENDED behavior for
   sending DIOs is to use a Trickle timer with rate-limiting.  There is
   no recommendation behavior for sending any other broadcast.  However,
   the traffic portion of all broadcast packets on minimal cell, except
   EBs, MUST not exceed 1/(3(N+1)).

   Section 4.3 describes how to evaluate the number of neighbors during
   the joining process.  After the joining process, how to evaluate the
   number of neighbors is implementation-specific.

   As detailed in Section 2.2 of [RFC8480], MSF MUST schedule cells from
   Slotframe 1, while Slotframe 0 is used for traffic defined in the
   Minimal 6TiSCH Configuration.  The length of Slotframe 0 and
   Slotframe 1 SHOULD be the same value.  The default of
   SLOTFRAME_LENGTH is RECOMMENDED for both Slotframe 0 and Slotframe 1,
   although any value can be advertised in the EBs.

3.  Autonomous Cells

   MSF nodes MUST initialize Slotframe 1 with a set of default cells for
   unicast communication with their neighbors.  These cells are referred
   to as 'autonomous cells', because they are maintained autonomously by
   each node.  To distinguish from the autonomous cells, the cell
   scheduled by 6P transaction is defined as 'managed cells'.  How to
   schedule managed cells is detailed in Section 5.  For autonomous
   cells, each node has:

   o  One cell at a [slotOffset,channelOffset] computed as a hash of the
      node's EUI64 (detailed next).  The cell options for this cell are
      TX=1, RX=1, SHARED=0.
   o  One cell at a [slotOffset,channelOffset] computed as a hash of the
      EUI64 of the Join Proxy or each neighbor in the IPv6 neighbor
      table (detailed in Section 4.4 and Section 4.5).  The cell options
      for this cell are TX=1, RX=1, SHARED=1.

   To compute a [slotOffset,channelOffset] from an EUI64 address, nodes
   MUST use the hash function SAX [SAX-DASFAA].  The coordinates are
   computed to distribute the cells across all 16 channel offsets, and
   all but the first time offsets of Slotframe 1.  The first time offset
   is skipped to avoid colliding with the minimal cell in Slotframe 0.
   The slot coordinates derived from a given EUI64 address are computed
   as follows:

   o  slotOffset(MAC) = 1 + hash(EUI64, length(Slotframe_1) - 1)
   o  channelOffset(MAC) = hash(EUI64, 16)





Chang, et al.          Expires September 12, 2019               [Page 5]

Internet-Draft  6TiSCH Minimal Scheduling Function (MSF)      March 2019


   For interoperability purpose, an example how the hash function is
   implemented is detailed in Appendix B.

   Because of hash collisions, there are cases where the autonomous
   SHARED and non-SHARED cells are scheduled at the same time offset
   and/or channel offset.  Hash collisions among a set of cells at a
   given time offset is resolved at run-time as follows:

   o  The SHARED cell with the most packets in the outgoing queue takes
      precedence.
   o  If all SHARED cells have empty outgoing queues, the non-SHARED
      cell takes precedence.

   Both SHARED and non-SHARED autonomous cells are scheduled to transmit
   unicast packets.  The autonomous SHARED cells can only be used to
   transmit packets to the neighbor whose EUI64 address is used in hash
   function to create this cell.  The autonomous non-SHARED cells can be
   used to transmit packet to any neighbors.  The traffic on the
   autonomous cells are scheduled as:

   o  The Join Request MUST be sent on a SHARED cell, the 6P Request
      packet MAY be sent on a SHARED cell.
   o  The Join Response MUST be sent on a non-SHARED cell, the 6P
      Response packet MAY send on a non-SHARED cell.

   Throughout the network lifetime, nodes MUST maintain the autonomous
   cells as follows:

   o  The non-SHARED cell MUST always remain scheduled.
   o  Whenever a new IPv6 neighbor is discovered, add a SHARED cell for
      it.
   o  Whenever an IPv6 neighbor is removed, remove the SHARED cell that
      was assigned to it.
   o  6P CLEAR MUST NOT erase autonomous cells.

4.  Node Behavior at Boot

   This section details the behavior the node SHOULD follow from the
   moment it is switched on, until it has successfully joined the
   network.  Section 4.1 details the start state; Section 4.9 details
   the end state.  The other sections detail the 7 steps of the joining
   process.  We use the term "pledge" and "joined node", as defined in
   [I-D.ietf-6tisch-minimal-security].








Chang, et al.          Expires September 12, 2019               [Page 6]

Internet-Draft  6TiSCH Minimal Scheduling Function (MSF)      March 2019


4.1.  Start State

   A node implementing MSF MUST implement the Minimal Security Framework
   for 6TiSCH [I-D.ietf-6tisch-minimal-security].  As a corollary, this
   means that a pledge, before being switched on, is pre-configured with
   the Pre-Shared Key (PSK) for joining, as well as any other
   configuration detailed in [I-D.ietf-6tisch-minimal-security].

4.2.  Step 1 - Choosing Frequency

   When switched on, the pledge SHOULD randomly choose a frequency among
   the available frequencies, and start listening for EBs on that
   frequency.

4.3.  Step 2 - Receiving EBs

   Upon receiving the first EB, the pledge SHOULD continue listening for
   additional EBs to learn:

   1.  the number of neighbors N in its vicinity
   2.  which neighbor to choose as a Join Proxy (JP) for the joining
       process

   While the exact behavior is implementation-specific, the RECOMMENDED
   behavior is to follow [RFC8180], and listen until EBs sent by
   NUM_NEIGHBOURS_TO_WAIT nodes (defined in [RFC8180]) have been
   received.

   During this step, the pledge MAY synchronize to any EB it receives
   from the network it wishes to join.  How to decide whether an EB
   originates from a node from the network it wishes to join is
   implementation-specific, but MAY involve filtering EBs by the PAN ID
   field it contains, the presence and contents of the IE defined in
   [I-D.richardson-6tisch-join-enhanced-beacon], or the key used to
   authenticate it.

   The decision of which neighbor to use as a JP is implementation-
   specific, and discussed in [I-D.ietf-6tisch-minimal-security].

4.4.  Step 3 - Setting up Autonomous Cells during Join Process

   After selected the JP, nodes MUST set up their autonomous SHARED
   cells, as described in Section 3.  A Join Request is sent then by
   pledge to its JP.  The JP forwards the request/response between the
   JRC and the JP, possibly over multiple hops.  When JP received the
   Join Response from JRC, it sends a Join Response to the pledge, where
   the pledge learns the keying material used in the network, as well as
   other configurations, and becomes a "joined node".  The Join Request



Chang, et al.          Expires September 12, 2019               [Page 7]

Internet-Draft  6TiSCH Minimal Scheduling Function (MSF)      March 2019


   and Response traffics are happened on the autonomous cells, which are
   scheduled as following:

   o  The Joining Request packet MUST be sent on the autonomous SHARED
      cell to the JP by the pledge.  A retransmition with backoff
      mechanism will be sent later if collision happens.
   o  The Joining Response packet MUST be sent on the autonomous non-
      SHARED cell to the pledge by the JP.  A retransmition will be sent
      immediately at next autonomous non-SHARED cell if collision
      happens.

   After joined, nodes MUST set up their autonomous non-SHARED cell, as
   described in Section 3.  The root node MUST set up its autonomous
   non-SHARED cell when it is configured as root.

4.5.  Step 4 - Installing Autonomous Cells for each neighbor in neighbor
      table

   Because it has learnt the link-layer keying material used in the
   network, the joined node can now decrypt any packets sent by its
   neighbors.  Once a new neighbor is added to the neighbor table, a new
   autonomous SHARED cell MUST be added to that neighbor.  The
   autonomous SHARED cell MUST be removed if the corresponding neighbor
   is removed from the neighbor table.  How to decide the neighbors to
   keep in neighbor table is implementation-specific.

4.6.  Step 5 - Acquiring a RPL rank

   Per [RFC6550], the joined node receives DIOs, computes its own rank,
   and selects a preferred parent.

4.7.  Step 6 - Send EBs and DIOs

   The node SHOULD start sending EBs and DIOs on the minimal cell, while
   following the transmit rules for broadcast frames from Section 2.

4.8.  Step 7 - Neighbor Polling

   The node SHOULD send some form of keep-alive messages to all its
   neighbors it has managed unicast cell with.  The Keep-Alive (KA)
   mechanism is detailed in [RFC7554].  It uses the keep-alive messages
   to its preferred parent to stay synchronized.  It MAY use the keep-
   alive messages to other neighbors to have statistics on link quality.
   It MAY use the keep-alive messages to its children to ensure the
   child is still reachable.  The RECOMMENDED period for sending keep-
   alive messages is KA_PERIOD.





Chang, et al.          Expires September 12, 2019               [Page 8]

Internet-Draft  6TiSCH Minimal Scheduling Function (MSF)      March 2019


   If the keep-alive message to a child fails at the link layer (i.e.
   the maximum number of link-layer retries is reached), the node SHOULD
   declare the child as unreachable.  This can happen for example when
   the child node is switched off.

   When a neighbor is declared unreachable, the node MUST remove all
   managed unicast cells with that neighbor from its own schedule.  In
   addition, it MAY issue a 6P CLEAR to that neighbor (which can fail at
   the link-layer).  The node MAY be removed from the neighbor table.
   If so, the autonomous SHARED cell will be removed following the
   procedure described in Section 3.

4.9.  End State

   For a new node, the end state of the joining process is:

   o  it is synchronized to the network
   o  it is using the link-layer keying material it learned through the
      secure joining process
   o  it has identified its preferred routing parent
   o  it has one autonomous non-SHARED cell and a set of autonomous
      SHARED cells to/from its neighbors
   o  it is periodically sending DIOs, potentially serving as a router
      for other nodes' traffic
   o  it is periodically sending EBs, potentially serving as a JP for
      new joining nodes

5.  Rules for Adding/Deleting Cells

   Once a node has joined the 6TiSCH network, it adds/deletes/relocates
   cells with its preferred parent for three reasons:

   o  to match the link-layer resources to the traffic between the node
      and its preferred parent (Section 5.1)
   o  to handle switching preferred parent (Section 5.2)
   o  to handle a schedule collision (Section 5.3)

5.1.  Adapting to Traffic

   A node implementing MSF MUST implement the behavior described in this
   section.

   In order to handle transient traffic bursts, MSF uses the
   [IEEE802154-2015] frame pending bit (page 152, Section 7.2.1.3).  By
   setting the bit, a node can transmit a series of packets to a given
   neighbor in consecutive time offsets.  The next paragraphs define how
   to handle longer-term fluctuations in traffic, using 6P.




Chang, et al.          Expires September 12, 2019               [Page 9]

Internet-Draft  6TiSCH Minimal Scheduling Function (MSF)      March 2019


   The goal of MSF is to manage the communication schedule in the 6TiSCH
   schedule in a distributed manner.  For a node, this translates into
   monitoring the current usage of the cells it has to its preferred
   parent:

   o  If the node determines that the number of link-layer frames it is
      attempting to exchange with its preferred parent per unit of time
      is larger than the capacity offered by the TSCH managed unicast
      cells it has scheduled with it, the node triggers a 6P Transaction
      with its preferred parent to add dedicated cells to the TSCH
      schedule of both nodes.
   o  If the traffic is lower than the capacity, the node triggers a 6P
      Transaction with its preferred parent to delete dedicated cells
      from the TSCH schedule of both nodes.

   From the join process, the node already has a set of autonomous
   cells, as defined in Section 3.  The autonomous cells MUST NOT be
   removed by 6P, so that there always exists an autonomous cell between
   a node and its preferred parent, even if no frames are being
   exchanged between them.  Autonomous cells are used indistinguishably
   together with dedicated cells, for broadcast or unicast traffic with
   the target neighbor.  The procedure to remove autonomous cells is
   described in Section 3.

   Adding/removing/relocating cells involves exchanging frames that
   contain 6P commands.  All 6P frames MUST be sent on the autonomous
   cell or managed cell if the node has.

   The node MUST maintain the following counters for its preferred
   parent:

   NumCellsElapsed :  Counts the number of managed unicast cells that
       have elapsed since the counter was initialized.  This counter is
       initialized at 0.  Each time the TSCH state machine indicates
       that the current cell is a managed unicast cell to the preferred
       parent, NumCellsElapsed is incremented by exactly 1, regardless
       of whether the cell is used to transmit/receive a frame.
   NumCellsUsed:  Counts the number of managed unicast cells that have
       been used.  This counter is initialized at 0.  NumCellsUsed is
       incremented by exactly 1 when, during a unicast cell to the
       preferred parent, either of the following happens:

       *  The node sends a frame to its preferred parent.  The counter
          increments regardless of whether a link-layer acknowledgment
          was received or not.
       *  The node receives a frame from its preferred parent.  The
          frame MUST be able to decrypt with the key assigned during
          joining process.



Chang, et al.          Expires September 12, 2019              [Page 10]

Internet-Draft  6TiSCH Minimal Scheduling Function (MSF)      March 2019


   Implementors MAY choose to create the same counters for each
   neighbor, and add them as additional statistics in the neighbor
   table.

   The counters are used as follows:

   1.  Both NumCellsElapsed and NumCellsUsed are initialized to 0 when
       the node boots.
   2.  After End State defined in Section 4.9, if there is no managed
       unicast cell to the preferred parent, trigger 6P to add a signle
       cell to it.
   3.  When the value of NumCellsElapsed reaches MAX_NUMCELLS:

       *  If NumCellsUsed > LIM_NUMCELLSUSED_HIGH, trigger 6P to add a
          single cell to the preferred parent
       *  If NumCellsUsed < LIM_NUMCELLSUSED_LOW, trigger 6P to remove a
          single cell to the preferred parent
       *  Reset both NumCellsElapsed and NumCellsUsed to 0 and go to
          step 2.

   To have the counters working, at least one unicast cell need to be
   maintained all the time and never be removed.

   The reason why the counter only counts the managed unicast cell, NOT
   including the autonomous SHARED cell is to avoid the effects of
   collision.  If the autonomous SHARED cell is counted as well,
   NumCellsUsed > LIM_NUMCELLSUSED_HIGH could be caused by the collision
   on the cell.  A 6P add request on the autonomous SHARED cell will
   make the collision even worse.

   Both NumCellsElapsed and NumCellsUsed counters can be used to cell
   with cell option TX=1 or RX=1.  With the rules defined above, the
   cell to add or remove can be transmitting cell or receiving cell
   according to which type of cell the two counters are used for.

   Similar to Join Request and Response, the 6P Request is scheduled to
   send on the autonomous SHARED cell to the node's parent.  The 6P
   Response is scheduled to send back on the autonomous non-SHARED cell
   to the node.

5.2.  Switching Parent

   A node implementing MSF SHOULD implement the behavior described in
   this section.

   Part of its normal operation, the RPL routing protocol can have a
   node switch preferred parents.  The procedure for switching from the
   old preferred parent to the new preferred parent is:



Chang, et al.          Expires September 12, 2019              [Page 11]

Internet-Draft  6TiSCH Minimal Scheduling Function (MSF)      March 2019


   1.  if the new parent is not in the neighbor table, the autonomous
       SHARED cell MUST be added as defined in Section 3
   2.  the node counts the number of managed unicast cell cells it has
       per slotframe to the old preferred parent
   3.  the node triggers one or more 6P ADD commands to schedule the
       same number of unicast cells to the new preferred parent
   4.  when that successfully completes, the node issues a 6P CLEAR
       command to its old preferred parent

5.3.  Handling Schedule Collisions

   A node implementing MSF SHOULD implement the behavior described in
   this section.  The "MUST" statements in this section hence only apply
   if the node implements schedule collision handling.

   Since scheduling is entirely distributed, there is a non-zero
   probability that two pairs of nearby neighbor nodes schedule a
   managed unicast cell at the same [slotOffset,channelOffset] location
   in the TSCH schedule.  In that case, data exchanged by the two pairs
   may collide on that cell.  We call this case a "schedule collision".

   The node MUST maintain the following counters for each managed
   unicast cell to its preferred parent:

   NumTx:  Counts the number of transmission attempts on that cell.
       Each time the node attempts to transmit a frame on that cell,
       NumTx is incremented by exactly 1.
   NumTxAck:  Counts the number of successful transmission attempts on
       that cell.  Each time the node receives an acknowledgment for a
       transmission attempt, NumTxAck is incremented by exactly 1.

   Implementors MAY choose to maintain the same counters for each
   managed unicast cell in the schedule.

   Since both NumTx and NumTxAck are initialized to 0, we necessarily
   have NumTxAck <= NumTx.  We call Packet Delivery Ratio (PDR) the
   ratio NumTxAck/NumTx; and represent it as a percentage.  A cell with
   PDR=50% means that half of the frames transmitted are not
   acknowledged (and need to be retransmitted).

   Each time the node switches preferred parent (or during the join
   process when the node selects a preferred parent for the first time),
   both NumTx and NumTxAck MUST be reset to 0.  They increment over
   time, as the schedule is executed and the node sends frames to its
   preferred parent.  When NumTx reaches 256, both NumTx and NumTxAck
   MUST be divided by 2.  That is, for example, from NumTx=256 and
   NumTxAck=128, they become NumTx=128 and NumTxAck=64.  This operation




Chang, et al.          Expires September 12, 2019              [Page 12]

Internet-Draft  6TiSCH Minimal Scheduling Function (MSF)      March 2019


   does not change the value of the PDR, but allows the counters to keep
   incrementing.

   The key for detecting a schedule collision is that, if a node has
   several cells to the same preferred parent, all cells should exhibit
   the same PDR.  A cell which exhibits a PDR significantly lower than
   the others indicates than there are collisions on that cell.

   Every HOUSEKEEPINGCOLLISION_PERIOD, the node executes the following
   steps:

   1.  It computes, for each managed unicast cell with its preferred
       parent (not for the autonomous cell), that cell's PDR.
   2.  Any cell that hasn't yet had NumTx divided by 2 since it was last
       reset is skipped in steps 3 and 4.  This avoids triggering cell
       relocation when the values of NumTx and NumTxAck are not
       statistically significant yet.
   3.  It identifies the cell with the highest PDR.
   4.  For each other cell, it compares its PDR against that of the cell
       with the highest PDR.  If it's less than RELOCATE_PDRTHRES, it
       triggers the relocation of that cell using a 6P RELOCATE command.

6.  6P SIGNAL command

   The 6P SIGNAL command is not used by MSF.

7.  Scheduling Function Identifier

   The Scheduling Function Identifier (SFID) of MSF is
   IANA_6TISCH_SFID_MSF.

8.  Rules for CellList

   MSF uses 2-step 6P Transactions exclusively.  6P Transactions are
   only initiated by a node towards it preferred parent.  As a result,
   the cells to put in the CellList of a 6P ADD command, and in the
   candidate CellList of a RELOCATE command, are chosen by the node
   initiating the 6P Transaction.  In both cases, the same rules apply:

   o  The CellList SHOULD contain 5 or more cells.
   o  Each cell in the CellList MUST have a different slotOffset value.
   o  For each cell in the CellList, the node MUST NOT have any
      scheduled cell on the same slotOffset.
   o  The slotOffset value of any cell in the CellList MUST NOT be the
      same as the slotOffset of the minimal cell (slotOffset=0).
   o  The slotOffset of a cell in the CellList SHOULD be randomly and
      uniformly chosen among all the slotOffset values that satisfy the
      restrictions above.



Chang, et al.          Expires September 12, 2019              [Page 13]

Internet-Draft  6TiSCH Minimal Scheduling Function (MSF)      March 2019


   o  The channelOffset of a cell in the CellList SHOULD be randomly and
      uniformly chosen in [0..numFrequencies], where numFrequencies
      represents the number of frequencies a node can communicate on.

9.  6P Timeout Value

   The 6P Timeout is not a constant value.  It is calculated as
   (1/(C+1))*(1/PDR)*SIXP_TIMEOUT_SEC_FACTOR, where:

   o  C represents the number of cells per second scheduled to that
      neighbor
   o  PDR represents the average PDR of those cells
   o  SIXP_TIMEOUT_SEC_FACTOR is a security factor, a constant

10.  Rule for Ordering Cells

   Cells are ordered slotOffset first, channelOffset second.

   The following sequence is correctly ordered (each element represents
   the [slottOffset,channelOffset] of a cell in the schedule):

   [1,3],[1,4],[2,0],[5,3],[6,0],[6,3],[7,9]

11.  Meaning of the Metadata Field

   The Metadata field is not used by MSF.

12.  6P Error Handling

   Section 6.2.4 of [RFC8480] lists the 6P Return Codes.  Figure 1 lists
   the same error codes, and the behavior a node implementing MSF SHOULD
   follow.



















Chang, et al.          Expires September 12, 2019              [Page 14]

Internet-Draft  6TiSCH Minimal Scheduling Function (MSF)      March 2019


          +-----------------+----------------------+
          | Code            | RECOMMENDED behavior |
          +-----------------+----------------------+
          | RC_SUCCESS      | nothing              |
          | RC_EOL          | nothing              |
          | RC_ERR          | quarantine           |
          | RC_RESET        | quarantine           |
          | RC_ERR_VERSION  | quarantine           |
          | RC_ERR_SFID     | quarantine           |
          | RC_ERR_SEQNUM   | clear                |
          | RC_ERR_CELLLIST | clear                |
          | RC_ERR_BUSY     | waitretry            |
          | RC_ERR_LOCKED   | waitretry            |
          +-----------------+----------------------+

          Figure 1: Recommended behavior for each 6P Error Code.

   The meaning of each behavior from Figure 1 is:

   nothing:  Indicates that this Return Code is not an error.  No error
       handling behavior is triggered.
   clear:  Abort the 6P Transaction.  Issue a 6P CLEAR command to that
       neighbor (this command may fail at the link layer).  Remove all
       cells scheduled with that neighbor from the local schedule.  Keep
       that node in the neighbor and routing tables.
   quarantine:  Same behavior as for "clear".  In addition, remove the
       node from the neighbor and routing tables.  Place the node's
       identifier in a quarantine list for QUARANTINE_DURATION.  When in
       quarantine, drop all frames received from that node.
   waitretry:  Abort the 6P Transaction.  Wait for a duration randomly
       and uniformly chosen in [WAITDURATION_MIN,WAITDURATION_MAX].
       Retry the same transaction.

13.  Schedule Inconsistency Handling

   The behavior when schedule inconsistency is detected is explained in
   Figure 1, for 6P Return Code RC_ERR_SEQNUM.

14.  MSF Constants

   Figure 2 lists MSF Constants and their RECOMMENDED values.










Chang, et al.          Expires September 12, 2019              [Page 15]

Internet-Draft  6TiSCH Minimal Scheduling Function (MSF)      March 2019


           +------------------------------+-------------------+
           | Name                         | RECOMMENDED value |
           +------------------------------+-------------------+
           | KA_PERIOD                    |       10 s        |
           | LIM_NUMCELLSUSED_HIGH        |       75 %        |
           | LIM_NUMCELLSUSED_LOW         |       25 %        |
           | HOUSEKEEPINGCOLLISION_PERIOD |        1 min      |
           | RELOCATE_PDRTHRES            |       50 %        |
           | SIXP_TIMEOUT_SEC_FACTOR      |        3 x        |
           | SLOTFRAME_LENGTH             |      101 slots    |
           | QUARANTINE_DURATION          |        5 min      |
           | WAITDURATION_MIN             |       30 s        |
           | WAITDURATION_MAX             |       60 s        |
           +------------------------------+-------------------+

           Figure 2: MSF Constants and their RECOMMENDED values.

15.  MSF Statistics

   Figure 3 lists MSF Statistics and their RECOMMENDED width.

                   +-----------------+-------------------+
                   | Name            | RECOMMENDED width |
                   +-----------------+-------------------+
                   | NumCellsElapsed |      1 byte       |
                   | NumCellsUsed    |      1 byte       |
                   | NumTx           |      1 byte       |
                   | NumTxAck        |      1 byte       |
                   +-----------------+-------------------+

           Figure 3: MSF Statistics and their RECOMMENDED width.

16.  Security Considerations

   MSF defines a series of "rules" for the node to follow.  It triggers
   several actions, that are carried out by the protocols defined in the
   following specifications: the Minimal IPv6 over the TSCH Mode of IEEE
   802.15.4e (6TiSCH) Configuration [RFC8180], the 6TiSCH Operation
   Sublayer Protocol (6P) [RFC8480], and the Minimal Security Framework
   for 6TiSCH [I-D.ietf-6tisch-minimal-security].  In particular, MSF
   does not define a new protocol or packet format.

   MSF relies entirely on the security mechanisms defined in the
   specifications listed above.







Chang, et al.          Expires September 12, 2019              [Page 16]

Internet-Draft  6TiSCH Minimal Scheduling Function (MSF)      March 2019


17.  IANA Considerations

17.1.  MSF Scheduling Function Identifiers

   This document adds the following number to the "6P Scheduling
   Function Identifiers" sub-registry, part of the "IPv6 over the TSCH
   mode of IEEE 802.15.4e (6TiSCH) parameters" registry, as defined by
   [RFC8480]:

   +----------------------+-----------------------------+-------------+
   |  SFID                | Name                        | Reference   |
   +----------------------+-----------------------------+-------------+
   | IANA_6TISCH_SFID_MSF | Minimal Scheduling Function | RFCXXXX     |
   |                      | (MSF)                       | (NOTE:this) |
   +----------------------+-----------------------------+-------------+

                      Figure 4: IETF IE Subtype '6P'.

18.  References

18.1.  Normative References

   [I-D.ietf-6tisch-minimal-security]
              Vucinic, M., Simon, J., Pister, K., and M. Richardson,
              "Minimal Security Framework for 6TiSCH", draft-ietf-
              6tisch-minimal-security-09 (work in progress), November
              2018.

   [I-D.richardson-6tisch-join-enhanced-beacon]
              Dujovne, D. and M. Richardson, "IEEE802.15.4 Informational
              Element encapsulation of 6tisch Join Information", draft-
              richardson-6tisch-join-enhanced-beacon-03 (work in
              progress), January 2018.

   [IEEE802154-2015]
              IEEE standard for Information Technology, "IEEE Std
              802.15.4-2015 Standard for Low-Rate Wireless Personal Area
              Networks (WPANs)", December 2015.

   [RFC2119]  Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", BCP 14, RFC 2119,
              DOI 10.17487/RFC2119, March 1997,
              <https://www.rfc-editor.org/info/rfc2119>.

   [RFC4861]  Narten, T., Nordmark, E., Simpson, W., and H. Soliman,
              "Neighbor Discovery for IP version 6 (IPv6)", RFC 4861,
              DOI 10.17487/RFC4861, September 2007,
              <https://www.rfc-editor.org/info/rfc4861>.



Chang, et al.          Expires September 12, 2019              [Page 17]

Internet-Draft  6TiSCH Minimal Scheduling Function (MSF)      March 2019


   [RFC6550]  Winter, T., Ed., Thubert, P., Ed., Brandt, A., Hui, J.,
              Kelsey, R., Levis, P., Pister, K., Struik, R., Vasseur,
              JP., and R. Alexander, "RPL: IPv6 Routing Protocol for
              Low-Power and Lossy Networks", RFC 6550,
              DOI 10.17487/RFC6550, March 2012,
              <https://www.rfc-editor.org/info/rfc6550>.

   [RFC7554]  Watteyne, T., Ed., Palattella, M., and L. Grieco, "Using
              IEEE 802.15.4e Time-Slotted Channel Hopping (TSCH) in the
              Internet of Things (IoT): Problem Statement", RFC 7554,
              DOI 10.17487/RFC7554, May 2015,
              <https://www.rfc-editor.org/info/rfc7554>.

   [RFC8180]  Vilajosana, X., Ed., Pister, K., and T. Watteyne, "Minimal
              IPv6 over the TSCH Mode of IEEE 802.15.4e (6TiSCH)
              Configuration", BCP 210, RFC 8180, DOI 10.17487/RFC8180,
              May 2017, <https://www.rfc-editor.org/info/rfc8180>.

   [RFC8480]  Wang, Q., Ed., Vilajosana, X., and T. Watteyne, "6TiSCH
              Operation Sublayer (6top) Protocol (6P)", RFC 8480,
              DOI 10.17487/RFC8480, November 2018,
              <https://www.rfc-editor.org/info/rfc8480>.

18.2.  Informative References

   [OpenWSN]  Watteyne, T., Vilajosana, X., Kerkez, B., Chraim, F.,
              Weekly, K., Wang, Q., Glaser, S., and K. Pister, "OpenWSN:
              a Standards-Based Low-Power Wireless Development
              Environment", Transactions on Emerging Telecommunications
              Technologies , August 2012.

   [RFC6982]  Sheffer, Y. and A. Farrel, "Improving Awareness of Running
              Code: The Implementation Status Section", RFC 6982,
              DOI 10.17487/RFC6982, July 2013,
              <https://www.rfc-editor.org/info/rfc6982>.

   [SAX-DASFAA]
              Ramakrishna, M. and J. Zobel, "Performance in Practice of
              String Hashing Functions", DASFAA , 1997.

Appendix A.  Contributors

   Beshr Al Nahas (Chalmers University, beshr@chalmers.se) and Olaf
   Landsiedel (Chalmers University, olafl@chalmers.se) contributed to
   the design and evaluation of autonomous unicast cells.






Chang, et al.          Expires September 12, 2019              [Page 18]

Internet-Draft  6TiSCH Minimal Scheduling Function (MSF)      March 2019


Appendix B.  Example of Implementation of SAX hash function

   For the consideration of interoperability, this section provides an
   example of implemention SAX hash function [SAX-DASFAA].  The input
   parameters of the function are:

   o  T, which is the hashing table length
   o  c, which is the characters of string s, to be hashed

   In MSF, the T is replaced by the length slotframe 1.  String s is
   replaced by the mote EUI64 address.  The characters of the string c0,
   c1, ..., c7 are the 8 bytes of EUI64 address.

   The SAX hash function requires shift operation which is defined as
   follow:

   o  L_shift(v,b), which refers to left shift variable v by b bits
   o  R_shift(v,b), which refers to right shift variable v by b bits

   The steps to calculate the hash value of SAX hash function are:

   1.  initialize variable h to h0 and variable i to 0, where h is the
       intermediate hash value and i is the index of the bytes of EUI64
       address
   2.  sum the value of L_shift(h,l_bit), R_shift(h,r_bit) and ci
   3.  calculate the result of exclusive or bewteen the sum value in
       Step 2 and h
   4.  modulo the result of Step 3 by T
   5.  assign the result of Step 4 to h
   6.  increase i by 1
   7.  repeat Step2 to Step 6 until i reaches to 8
   8.  assign the result of Step 5 to h

   The value of variable h the hash value of SAX hash function.

   For interoperability purpose, the values of h0, l_bit and r_bit in
   Step 1 and 2 are configured as:

   o  h0 = 0
   o  l_bit = 0
   o  r_bit = 1

   The appropriate values of l_bit and r_bit could vary depending on the
   the set of motes' EUI64 address.  How to find those values is out of
   the scope of this specification.






Chang, et al.          Expires September 12, 2019              [Page 19]

Internet-Draft  6TiSCH Minimal Scheduling Function (MSF)      March 2019


Appendix C.  Implementation Status and Performance Evaluation

   This section records the status of known implementations of the
   protocol defined by this specification at the time of posting of this
   Internet-Draft, and is based on a proposal described in [RFC6982].
   The description of implementations in this section is intended to
   assist the IETF in its decision processes in progressing drafts to
   RFCs.  Please note that the listing of any individual implementation
   here does not imply endorsement by the IETF.  Furthermore, no effort
   has been spent to verify the information presented here that was
   supplied by IETF contributors.  This is not intended as, and must not
   be construed to be, a catalog of available implementations or their
   features.  Readers are advised to note that other implementations may
   exist.

   According to [RFC6982], "this will allow reviewers and working groups
   to assign due consideration to documents that have the benefit of
   running code, which may serve as evidence of valuable experimentation
   and feedback that have made the implemented protocols more mature.
   It is up to the individual working groups to use this information as
   they see fit".

   OpenWSN  MSF is being implemented in the OpenWSN project [OpenWSN]
      under a BSD open-source license.  The code is open-source and
      available in two parts:

      *  the firmware, running on embedded hardware: https://github.com/
         openwsn-berkeley/openwsn-fw
      *  the software, running on the PC that acts as the LBR of the
         network: https://github.com/openwsn-berkeley/openvisualizer

      At the time of writing, OpenWSN implements MSF as specified in
      this document.  The code is tested on the OpenTestbed deployed at
      Inria in Paris.  The testbed consist of 40 OpenMote-B nodes.  The
      experiment is run for 3 hours.  With the first 12 minutes of the
      experiment, all nodes synchronize and securely join the network.
      Once joined, each node sends a DAO every 1 min to the DAG root.
      We use the DAO's sequence number to compute end-to-end
      reliability.  After 3 hours, the nodes have generated 7114 DAOs,
      with an overall end-end reliability of 99.47%.
      The OpenWSN implementation is work-in-progress, and we expect the
      final release to yield 100% end-to-end reliability.
   6TiSCH simulator  The 6TiSCH simulator is a Python-based high-level
      simulator on which MSF is being implemented.  More information at
      https://bitbucket.org/6tisch/simulator/.






Chang, et al.          Expires September 12, 2019              [Page 20]

Internet-Draft  6TiSCH Minimal Scheduling Function (MSF)      March 2019


Appendix D.  [TEMPORARY] Changelog

   o  draft-ietf-6tisch-msf-02

      *  Resolve the issues in Pending Elements section.  Using
         autonomous SHARED and non-SHARED cells.  Overall revised the
         specification.
   o  draft-ietf-6tisch-msf-01

      *  Added a section on pending elements.
   o  draft-ietf-6tisch-msf-00

      *  Re-publication after WG adoption.  No changes.
   o  draft-chang-6tisch-msf-02

      *  Added autonomous cell.
   o  draft-chang-6tisch-msf-01

      *  When neighbor is unreachable, sending a CLEAR command was a
         MUST, now a MAY.
      *  Fixing 6P Timeout calculation.
      *  Clearer text for "Handling Schedule Collisions" section.
      *  Typos.
      *  Input from Yasuyuki Tanaka's review (https://www.ietf.org/mail-
         archive/web/6tisch/current/msg05723.html).
   o  draft-chang-6tisch-msf-00

      *  Initial submission.

Appendix E.  [TEMPORARY] Pending Elements

E.1.  Introduction

   This section contains lessons learnt and suggestions from simulating
   and experimenting with draft-ietf-6tisch-msf-00.  This section is
   temporary and will be removed once these suggestions are integrated
   or abandonned.

E.2.  Performance Related

E.2.1.  Handling the case when bandwidth allocation exceeds available
        capacity

   When node A initializes a 6top ADD transaction to node B, but node B
   does NOT have enough bandwidth to allocate.  What can node B do to
   indicate this case in its 6top response, and how should node A handle
   the packet after receiving the response?  Related discussion:
   https://www.ietf.org/mail-archive/web/6tisch/current/msg06095.html



Chang, et al.          Expires September 12, 2019              [Page 21]

Internet-Draft  6TiSCH Minimal Scheduling Function (MSF)      March 2019


   [TOD BE DISCUSSED.  According to 6top RFC8480, SUCCESS return code
   will be in the 6top response with an empty cellList possibly.  For
   this case, I don't have a prefect solution.  One solution I am using
   is marking the node B as 'no_resource', then updating it's routing
   table and filtering out the neighbor marked as 'no_resource'.
   However, this is a layer-violation design.]

E.2.2.  Adapting 6P Timeout

   After 6P TIMEOUT, the next 6P transaction should be configured using
   a larger TIMEOUT.  Issues link: https://github.com/twatteyne/draft-
   ietf-6tisch-msf/issues/19

   [TOD BE DISCUSSED.  I am not sure this is an issue or not with
   current version.  Need to discuss with Malisa and Simon.]

E.3.  editorial

E.3.1.  Rules for broadcast frames is out of scope of MSF

   In Section 2, the rules for broadcast frames on the minimal cell seem
   to be an implementation-specific optimization.  And it is beyond of
   the scope of this draft.  This idea is about how to use the minimal
   cell efficiently; it's not directly related to how to use cells
   scheduled by MSF.  Related discussion:
   https://mailarchive.ietf.org/arch/
   msg/6tisch/9jcaTddi6vLO5zHqTDNk6yqrNao

   [TOD BE DISCUSSED.  I agree with this comment.  Should we remove
   those text or keep them in the draft but mentioned those rules are
   not a MUST but a RECOMMENDED?]

Authors' Addresses

   Tengfei Chang (editor)
   Inria
   2 rue Simone Iff
   Paris  75012
   France

   Email: tengfei.chang@inria.fr










Chang, et al.          Expires September 12, 2019              [Page 22]

Internet-Draft  6TiSCH Minimal Scheduling Function (MSF)      March 2019


   Malisa Vucinic
   Inria
   2 rue Simone Iff
   Paris  75012
   France

   Email: malisa.vucinic@inria.fr


   Xavier Vilajosana
   Universitat Oberta de Catalunya
   156 Rambla Poblenou
   Barcelona, Catalonia  08018
   Spain

   Email: xvilajosana@uoc.edu


   Simon Duquennoy
   RISE SICS
   Isafjordsgatan 22
   164 29 Kista
   Sweden

   Email: simon.duquennoy@ri.se


   Diego Dujovne (editor)
   Universidad Diego Portales
   Escuela de Informatica y Telecomunicaciones
   Av. Ejercito 441
   Santiago, Region Metropolitana
   Chile

   Phone: +56 (2) 676-8121
   Email: diego.dujovne@mail.udp.cl















Chang, et al.          Expires September 12, 2019              [Page 23]