server_identity = server_public_key
client_identity = client_public_key

envelope_nonce = random(Nn)
masking_key = Expand(randomized_pwd, "MaskingKey", Nh)
auth_key = Expand(randomized_pwd, concat(envelope_nonce, "AuthKey"), Nh)
export_key = Expand(randomized_pwd, concat(envelope_nonce, "ExportKey"), Nh)
seed = Expand(randomized_pwd, concat(envelope_nonce, "PrivateKey"), Nseed)
cleartext_creds =
    CreateCleartextCredentials(server_public_key, client_public_key,
                               server_identity, client_identity)
auth_tag = MAC(auth_key, concat(envelope_nonce, cleartext_creds))

auth_key = Expand(randomized_pwd, concat(envelope.nonce, "AuthKey"), Nh)
export_key = Expand(randomized_pwd, concat(envelope.nonce, "ExportKey", Nh)
seed = Expand(randomized_pwd, concat(envelope.nonce, "PrivateKey"), Nseed)
cleartext_creds = CreateCleartextCredentials(server_public_key,
                      client_public_key, server_identity, client_identity)
expected_tag = MAC(auth_key, concat(envelope.nonce, cleartext_creds))
response = CreateRegistrationResponse(request,
                                          server_public_key,
                                          credential_identifier,
                                          oprf_seed)

                           response
                 <-------------------------

blinded_message = SerializeElement(blinded_element)
seed = Expand(oprf_seed, concat(credential_identifier, "OprfKey"), Nseed)
blinded_element = DeserializeElement(request.blinded_message)
evaluated_element = Evaluate(oprf_key, blinded_element)
evaluated_message = SerializeElement(evaluated_element)

evaluated_element = DeserializeElement(response.evaluated_message)
oprf_output = Finalize(password, blind, evaluated_element)

stretched_oprf_output = Stretch(oprf_output, params)
randomized_pwd = Extract("", concat(oprf_output, stretched_oprf_output))

ke1 = ClientInit(password)

                            ke1
                 ------------------------->

ke2 = ServerInit(server_identity, server_private_key,
                       server_public_key, record,
                       credential_identifier, oprf_seed, ke1)

                            ke2
                 <-------------------------

       (ke3,
       session_key,
       export_key) = ClientFinish(client_identity, password,
                                 server_identity, ke2)

                            ke3
                 ------------------------->

session_key = ServerFinish(ke3)

ake_1 = Start(request)
response = CreateCredentialResponse(ke1.request, server_public_key, record,
    credential_identifier, oprf_seed)
ake_2 = Response(server_identity, server_private_key,
    client_identity, record.client_public_key, ke1, response)
blinded_message = SerializeElement(blinded_element)
seed = Expand(oprf_seed, concat(credential_identifier, "OprfKey"), Nok)
blinded_element = DeserializeElement(request.blinded_message)
evaluated_element = Evaluate(oprf_key, blinded_element)
evaluated_message = SerializeElement(evaluated_element)

masking_nonce = random(Nn)
credential_response_pad = Expand(record.masking_key,
                                   concat(masking_nonce, "CredentialResponsePad"),
                                   Npk + Ne)
masked_response = xor(credential_response_pad,
                        concat(server_public_key, record.envelope))
evaluated_element = DeserializeElement(response.evaluated_message)

oprf_output = Finalize(password, blind, evaluated_element)
stretched_oprf_output = Stretch(oprf_output, params)
randomized_pwd = Extract("", concat(oprf_output, stretched_oprf_output))

masking_key = Expand(randomized_pwd, "MaskingKey", Nh)
credential_response_pad = Expand(masking_key,
                                   concat(response.masking_nonce, "CredentialResponsePad"),
                                   Npk + Ne)
preamble = concat("RFCXXXX",
                     I2OSP(len(context), 2), context,
                     I2OSP(len(client_identity), 2), client_identity,
                     ke1,
                     I2OSP(len(server_identity), 2), server_identity,
                     ke2.credential_response,
                     ke2.AuthResponse.server_nonce, ke2.AuthResponse.server_keyshare)
prk = Extract("", ikm)
handshake_secret = Derive-Secret(prk, "HandshakeSecret", Hash(preamble))
session_key = Derive-Secret(prk, "SessionKey", Hash(preamble))
Km2 = Derive-Secret(handshake_secret, "ServerMAC", "")
Km3 = Derive-Secret(handshake_secret, "ClientMAC", "")
client_nonce = random(Nn)
dh1 = SerializeElement(state.client_secret * ke2.server_keyshare)
dh2 = SerializeElement(state.client_secret * server_public_key)
dh3 = SerializeElement(client_private_key  * ke2.server_keyshare)
ikm = concat(dh1, dh2, dh3)

preamble = Preamble(client_identity, state.ke1, server_identity, ke2.inner_ke2)
expected_server_mac = MAC(Km2, Hash(preamble))
client_mac = MAC(Km3, Hash(concat(preamble, expected_server_mac))
server_nonce = random(Nn)
preamble = Preamble(client_identity, ke1, server_identity, ike2)

dh1 = SerializeElement(server_private_keyshare * ke1.client_keyshare)
dh2 = SerializeElement(server_private_key * ke1.client_keyshare)
dh3 = SerializeElement(server_private_keyshare * client_public_key)
ikm = concat(dh1, dh2, dh3)

server_mac = MAC(Km2, Hash(preamble))
expected_client_mac = MAC(Km3, Hash(concat(preamble, server_mac))
client_identity = client_public_key and server_identity =
preamble = concat("HMQV",
                  I2OSP(len(client_identity), 2), client_identity,
                  KE1,
                  I2OSP(len(server_identity), 2), server_identity,
                  KE2.credential_response,
                  KE2.AuthResponse.server_nonce, KE2.AuthResponse.server_keyshare)

   Second, the IKM derivation would change.  Assuming HMQV is
   instantiated with a cyclic group of prime order p with bit length L,
   clients would compute IKM as follows:

   u' = (eskU + u \* skU) mod p
IKM = (epkS \* pkS^s)^u'

IKM = (epkU \* pkU^u)^s'

hashInput = concat(I2OSP(len(epkU), 2), epkU,
                      I2OSP(len(info), 2), info,
                      I2OSP(len("client"), 2), "client")
u = Hash(hashInput) mod L

hashInput = concat(I2OSP(len(epkS), 2), epkS,
                      I2OSP(len(info), 2), info,
                      I2OSP(len("server"), 2), "server")
s = Hash(hashInput) mod L

