<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="en"><head><title>A Common API for Transparent Hybrid
    Multicast</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="description" content="A Common API for Transparent Hybrid
    Multicast">
<meta name="generator" content="xml2rfc v1.35 (http://xml.resource.org/)">
<meta name="viewport" content="width=600;" />
<style type='text/css'><!--
        body {
                font-family: verdana, charcoal, helvetica, arial, sans-serif;
                font-size: 85%;
		max-width: 60em; 
		color: #000; background-color: #FFF;
                margin: 2em;
        }
        h1, h2, h3, h4, h5, h6 {
                font-family: helvetica, monaco, "MS Sans Serif", arial, sans-serif;
                font-weight: bold; font-style: normal;
        }
        h1 { color: #900; background-color: transparent; text-align: right; }
        h3 { color: #333; background-color: transparent; }

        td.RFCbug {
                font-size: x-small; text-decoration: none;
                width: 30px; height: 30px; padding-top: 2px;
                text-align: justify; vertical-align: middle;
                background-color: #000;
        }
        td.RFCbug span.RFC {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: bold; color: #666;
        }
        td.RFCbug span.hotText {
                font-family: charcoal, monaco, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: normal; text-align: center; color: #FFF;
        }

        table.TOCbug { width: 30px; height: 15px; }
        td.TOCbug {
                text-align: center; width: 30px; height: 15px;
                color: #FFF; background-color: #900;
        }
        td.TOCbug a {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, sans-serif;
                font-weight: bold; font-size: x-small; text-decoration: none;
                color: #FFF; background-color: transparent;
        }

        td.header {
                font-family: arial, helvetica, sans-serif; font-size: x-small;
                vertical-align: top; width: 33%;
                color: #FFF; background-color: #666;
        }
        td.author { font-weight: bold; font-size: x-small; margin-left: 4em; }
        td.author-text { font-size: x-small; }

        /* info code from SantaKlauss at http://www.madaboutstyle.com/tooltip2.html */
        a.info {
                /* This is the key. */
                position: relative;
                z-index: 24;
                text-decoration: none;
        }
        a.info:hover {
                z-index: 25;
                color: #FFF; background-color: #900;
        }
        a.info span { display: none; }
        a.info:hover span.info {
                /* The span will display just on :hover state. */
                display: block;
                position: absolute;
                font-size: smaller;
                top: 2em; left: -5em; width: 15em;
                padding: 2px; border: 1px solid #333;
                color: #900; background-color: #EEE;
                text-align: left;
        }

        a { font-weight: bold; }
        a:link    { color: #900; background-color: transparent; }
        a:visited { color: #633; background-color: transparent; }
        a:active  { color: #633; background-color: transparent; }

        p { margin-left: 2em; margin-right: 2em; }
        p.copyright { font-size: x-small; }
        p.toc { font-size: 85%;
		max-width: 60em; 
		font-weight: bold; margin-left: 3em; }
        table.toc { margin: 0 0 0 3em; padding: 0; border: 0; vertical-align: text-top; }
        td.toc { font-size: 85%;
		max-width: 60em; 
		font-weight: bold; vertical-align: text-top; }

        ol.text { margin-left: 2em; margin-right: 2em; }
        ul.text { margin-left: 2em; margin-right: 2em; }
        li      { margin-left: 3em; }

        /* RFC-2629 <spanx>s and <artwork>s. */
        em     { font-style: italic; }
        strong { font-weight: bold; }
        dfn    { font-weight: bold; font-style: normal; }
        cite   { font-weight: normal; font-style: normal; }
        tt     { color: #036; }
        tt, pre, pre dfn, pre em, pre cite, pre span {
                font-family: "Courier New", Courier, monospace; font-size: small;
        }
        pre {
                text-align: left; padding: 4px;
                color: #000; background-color: #CCC;
        }
        pre dfn  { color: #900; }
        pre em   { color: #66F; background-color: #FFC; font-weight: normal; }
        pre .key { color: #33C; font-weight: bold; }
        pre .id  { color: #900; }
        pre .str { color: #000; background-color: #CFF; }
        pre .val { color: #066; }
        pre .rep { color: #909; }
        pre .oth { color: #000; background-color: #FCF; }
        pre .err { background-color: #FCC; }

        /* RFC-2629 <texttable>s. */
        table.all, table.full, table.headers, table.none {
                font-size: 85%;
		max-width: 60em; 
		text-align: center; border-width: 2px;
                vertical-align: top; border-collapse: collapse;
        }
        table.all, table.full { border-style: solid; border-color: black; }
        table.headers, table.none { border-style: none; }
        th {
                font-weight: bold; border-color: black;
                border-width: 2px 2px 3px 2px;
        }
        table.all th, table.full th { border-style: solid; }
        table.headers th { border-style: none none solid none; }
        table.none th { border-style: none; }
        table.all td {
                border-style: solid; border-color: #333;
                border-width: 1px 2px;
        }
        table.full td, table.headers td, table.none td { border-style: none; }

        hr { height: 1px; }
        hr.insert {
                width: 80%; border-style: none; border-width: 0;
                color: #CCC; background-color: #CCC;
        }
--></style>
</head>
<body>
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<table summary="layout" width="66%" border="0" cellpadding="0" cellspacing="0"><tr><td><table summary="layout" width="100%" border="0" cellpadding="2" cellspacing="1">
<tr><td class="header">SAM Research Group</td><td class="header">M. Waehlisch</td></tr>
<tr><td class="header">Internet-Draft</td><td class="header">link-lab &amp; FU Berlin</td></tr>
<tr><td class="header">Intended status: Informational</td><td class="header">T C. Schmidt</td></tr>
<tr><td class="header">Expires: January 29, 2011</td><td class="header">HAW Hamburg</td></tr>
<tr><td class="header">&nbsp;</td><td class="header">S. Venaas</td></tr>
<tr><td class="header">&nbsp;</td><td class="header">cisco Systems</td></tr>
<tr><td class="header">&nbsp;</td><td class="header">July 28, 2010</td></tr>
</table></td></tr></table>
<h1><br />A Common API for Transparent Hybrid
    Multicast<br />draft-waehlisch-sam-common-api-04</h1>

<h3>Abstract</h3>

<p>Group communication services exist in a large variety of flavors, and
      technical implementations at different protocol layers. Multicast data
      distribution is most efficiently performed on the lowest available
      layer, but a heterogeneous deployment status of multicast technologies
      throughout the Internet requires an adaptive service binding at runtime.
      Today, it is difficult to write an application that runs everywhere and
      at the same time makes use of the most efficient multicast service
      available in the network. Facing robustness requirements, developers are
      frequently forced to using a stable, upper layer protocol controlled by
      the application itself. This document describes a common multicast API
      that is suitable for transparent communication in underlay and overlay,
      and grants access to the different multicast flavors. It proposes an
      abstract naming by multicast URIs and discusses mapping mechanisms
      between different namespaces and distribution technologies.
      Additionally, it describes the application of this API for building
      gateways that interconnect current multicast domains throughout the
      Internet.
</p>
<h3>Status of this Memo</h3>
<p>
This Internet-Draft is submitted  in full
conformance with the provisions of BCP&nbsp;78 and BCP&nbsp;79.</p>
<p>
Internet-Drafts are working documents of the Internet Engineering
Task Force (IETF).  Note that other groups may also distribute
working documents as Internet-Drafts.  The list of current
Internet-Drafts is at http://datatracker.ietf.org/drafts/current/.</p>
<p>
Internet-Drafts are draft documents valid for a maximum of six months
and may be updated, replaced, or obsoleted by other documents at any time.
It is inappropriate to use Internet-Drafts as reference material or to cite
them other than as &ldquo;work in progress.&rdquo;</p>
<p>
This Internet-Draft will expire on January 29, 2011.</p>

<h3>Copyright Notice</h3>
<p>
Copyright (c) 2010 IETF Trust and the persons identified as the
document authors.  All rights reserved.</p>
<p>
This document is subject to BCP 78 and the IETF Trust's Legal
Provisions Relating to IETF Documents
(http://trustee.ietf.org/license-info) in effect on the date of
publication of this document.  Please review these documents
carefully, as they describe your rights and restrictions with respect
to this document. Code Components extracted from this document must
include Simplified BSD License text as described in Section 4.e of
the Trust Legal Provisions and are provided without warranty as
described in the Simplified BSD License.</p>
<a name="toc"></a><br /><hr />
<h3>Table of Contents</h3>
<p class="toc">
<a href="#anchor1">1.</a>&nbsp;
Introduction<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor2">1.1.</a>&nbsp;
Use Cases for the Common API<br />
<a href="#anchor3">2.</a>&nbsp;
Terminology<br />
<a href="#anchor4">3.</a>&nbsp;
Overview<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor5">3.1.</a>&nbsp;
Objectives and Reference Scenarios<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor6">3.2.</a>&nbsp;
Group Communication API &amp; Protocol Stack<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor7">3.3.</a>&nbsp;
Naming and Addressing<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor8">3.4.</a>&nbsp;
Mapping<br />
<a href="#anchor9">4.</a>&nbsp;
Common Multicast API<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor10">4.1.</a>&nbsp;
Abstract Data Types<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec:details-uri">4.1.1.</a>&nbsp;
Multicast URI<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor11">4.1.2.</a>&nbsp;
Interface<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor12">4.2.</a>&nbsp;
Group Management Calls<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor13">4.2.1.</a>&nbsp;
Create<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor14">4.2.2.</a>&nbsp;
Destroy<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor15">4.2.3.</a>&nbsp;
Join<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor16">4.2.4.</a>&nbsp;
Leave<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor17">4.2.5.</a>&nbsp;
Source Register<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor18">4.2.6.</a>&nbsp;
Source Deregister<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor19">4.3.</a>&nbsp;
Send and Receive Calls<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor20">4.3.1.</a>&nbsp;
Send<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor21">4.3.2.</a>&nbsp;
Receive<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor22">4.4.</a>&nbsp;
Socket Options<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor23">4.4.1.</a>&nbsp;
Get Interfaces<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor24">4.4.2.</a>&nbsp;
Add Interface<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor25">4.4.3.</a>&nbsp;
Delete Interface<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor26">4.4.4.</a>&nbsp;
Set TTL<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor27">4.5.</a>&nbsp;
Service Calls<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor28">4.5.1.</a>&nbsp;
Group Set<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor29">4.5.2.</a>&nbsp;
Neighbor Set<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor30">4.5.3.</a>&nbsp;
Children Set<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor31">4.5.4.</a>&nbsp;
Parent Set<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor32">4.5.5.</a>&nbsp;
Designated Host<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor33">4.5.6.</a>&nbsp;
Update Listener<br />
<a href="#anchor34">5.</a>&nbsp;
Functional Details<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec:namespace">5.1.</a>&nbsp;
Namespaces<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor35">5.2.</a>&nbsp;
Mapping<br />
<a href="#IANA">6.</a>&nbsp;
IANA Considerations<br />
<a href="#Security">7.</a>&nbsp;
Security Considerations<br />
<a href="#Acknowledgements">8.</a>&nbsp;
Acknowledgements<br />
<a href="#rfc.references1">9.</a>&nbsp;
Informative References<br />
<a href="#anchor37">Appendix&nbsp;A.</a>&nbsp;
Practical Example of the API<br />
<a href="#anchor38">Appendix&nbsp;B.</a>&nbsp;
Deployment Use Cases for Hybrid Multicast<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor39">B.1.</a>&nbsp;
DVMRP<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor40">B.2.</a>&nbsp;
PIM-SM<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor41">B.3.</a>&nbsp;
PIM-SSM<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor42">B.4.</a>&nbsp;
BIDIR-PIM<br />
<a href="#anchor43">Appendix&nbsp;C.</a>&nbsp;
Change Log<br />
<a href="#rfc.authors">&#167;</a>&nbsp;
Authors' Addresses<br />
</p>
<br clear="all" />

<a name="anchor1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1"></a><h3>1.&nbsp;
Introduction</h3>

<p>Currently, group application programmers need to make the choice of
      the distribution technology that the application will require at
      runtime. There is no common communication interface that abstracts
      multicast transmission and subscriptions from the deployment state at
      runtime. The standard multicast socket options <a class='info' href='#RFC3493'>[RFC3493]<span> (</span><span class='info'>Gilligan, R., Thomson, S., Bound, J., McCann, J., and W. Stevens, &ldquo;Basic Socket Interface Extensions for IPv6,&rdquo; February&nbsp;2003.</span><span>)</span></a>, <a class='info' href='#RFC3678'>[RFC3678]<span> (</span><span class='info'>Thaler, D., Fenner, B., and B. Quinn, &ldquo;Socket Interface Extensions for Multicast Source Filters,&rdquo; January&nbsp;2004.</span><span>)</span></a> are bound to an
      IP version and do not distinguish between naming and addressing of
      multicast identifiers. Group communication, however, is commonly
      implemented in different flavors such as any source (ASM) vs. source
      specific mutlicast (SSM), on different layers (e.g., IP vs. application
      layer multicast), and may be based on different technologies on the same
      tier as with IPv4 vs. IPv6. It is the objective of this document to
      provide a universal access to group services.
</p>
<p>Multicast application development should be decoupled of
      technological deployment throughout the infrastructure. It requires a
      common multicast API that offers calls to transmit and receive multicast
      data independent of the supporting layer and the underlying
      technological details. For inter-technology transmissions, a consistent
      view on multicast states is needed, as well. This document describes an
      abstract group communication API and core functions necessary for
      transparent operations. Specific implementation guidelines with respect
      to operating systems or programming languages are out-of-scope of this
      document.
</p>
<p>In contrast to the standard multicast socket interface, the API
      introduced in this document abstracts naming from addressing. Using a
      multicast address in the current socket API predefines the corresponding
      routing layer. In this specification, the multicast name used for
      joining a group denotes an application layer data stream that is
      identified by a multicast URI, independent of its binding to a specific
      distribution technology. Such a group name can be mapped to variable
      routing identifiers.
</p>
<p>The aim of this common API is twofold: </p>
<ul class="text">
<li>Enable any application programmer to implement group-oriented
          data communication independent of the underlying delivery
          mechanisms. In particular, allow for a late binding of group
          applications to multicast technologies that makes applications
          efficient, but robust with respect to deployment aspects.
</li>
<li>Allow for a flexible namespace support in group addressing, and
          thereby separate naming and addressing/routing schemes from the
          application design. This abstraction does not only decouple programs
          from specific aspects of underlying protocols, but may open
          application design to extend to specifically flavored group
          services.
</li>
</ul>

<p>Multicast technologies may be of various P2P kinds, IPv4 or IPv6
      network layer multicast, or implemented by some other application
      service. Corresponding namespaces may be IP addresses or DNS naming,
      overlay hashes or other application layer group identifiers like
      &lt;sip:*@peanuts.org&gt;, but also names independently defined by the
      applications. Common namespaces are introduced later in this document,
      but follow an open concept suitable for further extensions.
</p>
<p>This document also proposes and discusses mapping mechanisms between
      different namespaces and forwarding technologies. Additionally, the
      multicast API provides internal interfaces to access current multicast
      states at the host. Multiple multicast protocols may run in parallel on
      a single host. These protocols may interact to provide a gateway
      function that bridges data between different domains. The application of
      this API at gateways operating between current multicast instances
      throughout the Internet is described, as well.
</p>
<a name="anchor2"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1.1"></a><h3>1.1.&nbsp;
Use Cases for the Common API</h3>

<p>Four generic use cases can be identified that require an abstract
        common API for multicast services:
</p>
<p></p>
<blockquote class="text"><dl>
<dt>Application Programming Independent of Technologies</dt>
<dd>Application
            programmers are provided with group primitives that remain
            independent of multicast technologies and its deployment in target
            domains. They are thus enabled to develop programs once that run
            in every deployment scenario. The employment of group names in the
            form of abstract meta data types allows applications to remain
            namespace-agnostic in the sense that the resolution of namespaces
            and name-to-address mappings may be delegated to a system service
            at runtime. Thereby, the complexity is minimized as developers
            need not care about how data is distributed in groups, while the
            system service can take advantage of extended information of the
            network environment as acquired at startup.
</dd>
<dt>Global Identification of Groups  </dt>
<dd>Groups can be
            identified independent of technological instantiations and beyond
            deployment domains. Taking advantage of the abstract naming, an
            application is thus enabled to match data received from different
            interface technologies (e.g., IPv4, IPv6, or overlays) to belong
            to the same group. This not only increases flexibility, an
            application may for instance combine heterogeneous multipath
            streams, but simplifies the design and implementation of gateways
            and translators.
</dd>
<dt>Simplified Service Deployment through Generic Gateways</dt>
<dd>The
            API allows for an implementation of abstract gateway functions
            with mappings to specific technologies residing at a system level.
            Such generic gateways may provide a simple bridging service and
            facilitate an inter-domain deployment of multicast.
</dd>
<dt>Mobility-agnostic Group Communication</dt>
<dd>Group naming
            and management as foreseen in the API remain independent of
            locators. Naturally, applications stay unaware of any
            mobility-related address changes. Handover-initiated re-addressing
            is delegated to the mapping services at the system level and may
            be designed to smoothly interact with mobility management
            solutions provided at the network or transport layer. 
</dd>
</dl></blockquote>

<a name="anchor3"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2"></a><h3>2.&nbsp;
Terminology</h3>

<p>This document uses the terminology as defined for the multicast
      protocols <a class='info' href='#RFC2710'>[RFC2710]<span> (</span><span class='info'>Deering, S., Fenner, W., and B. Haberman, &ldquo;Multicast Listener Discovery (MLD) for IPv6,&rdquo; October&nbsp;1999.</span><span>)</span></a>,<a class='info' href='#RFC3376'>[RFC3376]<span> (</span><span class='info'>Cain, B., Deering, S., Kouvelas, I., Fenner, B., and A. Thyagarajan, &ldquo;Internet Group Management Protocol, Version 3,&rdquo; October&nbsp;2002.</span><span>)</span></a>,<a class='info' href='#RFC3810'>[RFC3810]<span> (</span><span class='info'>Vida, R. and L. Costa, &ldquo;Multicast Listener Discovery Version 2 (MLDv2) for IPv6,&rdquo; June&nbsp;2004.</span><span>)</span></a>,<a class='info' href='#RFC4601'>[RFC4601]<span> (</span><span class='info'>Fenner, B., Handley, M., Holbrook, H., and I. Kouvelas, &ldquo;Protocol Independent Multicast - Sparse Mode (PIM-SM): Protocol Specification (Revised),&rdquo; August&nbsp;2006.</span><span>)</span></a>,<a class='info' href='#RFC4604'>[RFC4604]<span> (</span><span class='info'>Holbrook, H., Cain, B., and B. Haberman, &ldquo;Using Internet Group Management Protocol Version 3 (IGMPv3) and Multicast Listener Discovery Protocol Version 2 (MLDv2) for Source-Specific Multicast,&rdquo; August&nbsp;2006.</span><span>)</span></a>. In addition,
      the following terms will be used.
</p>
<p></p>
<blockquote class="text"><dl>
<dt>Group  Address:</dt>
<dd>A Group Address is a routing
          identifier. It represents a technological specifier and thus
          reflects the distribution technology in use. Multicast packet
          forwarding is based on this ID.
</dd>
<dt>Group Name:</dt>
<dd>A Group Name is an application identifier
          that is used by applications to manage communication in a multicast
          group (e.g., join/leave and send/receive). The Group Name does not
          predefine any distribution technologies, even if it syntactically
          corresponds to an address, but represents a logical identifier.
</dd>
<dt>Multicast Namespace:</dt>
<dd>A Multicast Namespace is a
          collection of designators (i.e., names or addresses) for groups that
          share a common syntax. Typical instances of namespaces are IPv4 or
          IPv6 multicast addresses, overlay group ids, group names defined on
          the application layer (e.g., SIP or Email), or some human readable
          strings.
</dd>
<dt>Multicast Domain:</dt>
<dd>A Multicast Domain hosts nodes and
          routers of a common, single multicast forwarding technology and is
          bound to a single namespace.
</dd>
<dt>Interface</dt>
<dd>An Interface is a forwarding instance of a
          distribution technology on a given node. For example, the IP
          interface 192.168.1.1 at an IPv4 host.
</dd>
<dt>Inter-domain Multicast Gateway:</dt>
<dd>An Inter-domain
          Multicast Gateway (IMG) is an entity that interconnects different
          multicast domains. Its objective is to forward data between these
          domains, e.g., between IP layer and overlay multicast.
</dd>
</dl></blockquote>

<p>
</p>
<a name="anchor4"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3"></a><h3>3.&nbsp;
Overview</h3>

<p>
</p>
<a name="anchor5"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.1"></a><h3>3.1.&nbsp;
Objectives and Reference Scenarios</h3>

<p>The default use case addressed in this document targets at
        applications that participate in a group by using some common
        identifier taken from some common namespace. This group name is
        typically learned at runtime from user interaction like the selection
        of an IPTV channel, from dynamic session negotiations like in the
        Session Initiation Protocol (SIP), but may as well have been
        predefined for an application as a common group name.
        Technology-specific system functions then transparently map the group
        name to group addresses such that</p>
<ul class="text">
<li>programmers are enabled to process group names in their
            programs without the need to consider technological mappings to
            designated deployments in target domains;
</li>
<li>applications are enabled to identify packets that belong to a
            logically named group, independent of the interface technology
            used for sending and receiving packets. The latter shall also hold
            for multicast gateways.
</li>
</ul>

<p>This document refers to a reference scenario that covers the
        following two hybrid deployment cases displayed in <a class='info' href='#fig:reference'>Figure&nbsp;1<span> (</span><span class='info'>Reference scenarios for hybrid multicast, interconnecting group members from isolated homogeneous and heterogeneous domains.</span><span>)</span></a>:
</p>
<p></p>
<ol class="text">
<li>Multicast domains running the same multicast technology but
            remaining isolated, possibly only connected by network layer
            unicast.
</li>
<li>Multicast domains running different multicast technologies, but
            hosting nodes that are members of the same multicast group.
</li>
</ol>
<br /><hr class="insert" />
<a name="fig:reference"></a>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
                                        +-------+         +-------+
                                        | Member|         | Member|
                                        |  Foo  |         |   G   |
                                        +-------+         +-------+
                                              \            /
                                            ***  ***  ***  ***
                                           *   **   **   **   *
                                          *                    *
                                           *   MCast Tec A    *
                                          *                    *
                                           *   **   **   **   *
                                            ***  ***  ***  ***
   +-------+          +-------+                      |
   | Member|          | Member|                  +-------+
   |   G   |          |  Foo  |                  |  IMG  |
   +-------+          +-------+                  +-------+
       |                |                            |
       ***  ***  ***  ***                  ***  ***  ***  ***
      *   **   **   **   *                *   **   **   **   *
     *                    *  +-------+   *                    *
      *   MCast Tec A    * --|  IMG  |--  *   MCast Tec B    *    +-------+
     *                    *  +-------+   *                    * - | Member|
      *   **   **   **   *                *   **   **   **   *    |   G   |
       ***  ***  ***  ***                  ***  ***  ***  ***     +-------+

</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;1: Reference scenarios for hybrid multicast, interconnecting group members from isolated homogeneous and heterogeneous domains.&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>
</p>
<p>It is assumed throughout the document that the domain composition,
        as well as the node attachment to a specific technology remain
        unchanged during a multicast session.
</p>
<a name="anchor6"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.2"></a><h3>3.2.&nbsp;
Group Communication API &amp; Protocol Stack</h3>

<p>The group communication API consists of four parts. Two parts
        combine the essential communication functions, while the remaining two
        offer optional extensions for an enhanced management: </p>
<blockquote class="text"><dl>
<dt>Group Management Calls</dt>
<dd>provide the minimal API to
            instantiate a multicast socket and manage group membership.
</dd>
<dt>Send/Receive Calls</dt>
<dd>provide the minimal API to send
            and receive multicast data in a technology-transparent
            fashion.
</dd>
<dt>Socket Options</dt>
<dd>provide extension calls for an
            explicit configuration of the multicast socket like setting hop
            limits or associated interfaces.
</dd>
<dt>Service Calls</dt>
<dd>provide extension calls that grant
            access to internal multicast states of an interface such as the
            multicast groups under subscription or the multicast forwarding
            information base.
</dd>
</dl></blockquote>

<p>Multicast applications that use the common API require assistance
        by a group communication stack. This protocol stack serves two
        needs:
</p>
<p></p>
<ul class="text">
<li>It provides system-level support to transfer the abstract
            functions of the common API, including namespace support, into
            protocol operations at interfaces.
</li>
<li>It bridges data distribution between different multicast
            technologies.
</li>
</ul>

<p>A general initiation of a multicast communication in this setting
        proceeds as follows:
</p>
<p></p>
<ol class="text">
<li>An application opens an abstract multicast socket.
</li>
<li>The application subscribes/leaves/(de)registers to a group
            using a logical group identifier.
</li>
<li>An intrinsic function of the stack maps the logical group ID
            (Group Name) to a technical group ID (Group Address). This
            function may make use of deployment-specific knowledge such as
            available technologies and group address management in its
            domain.
</li>
<li>Packet distribution proceeds to and from one or several
            multicast-enabled interfaces.
</li>
</ol>

<p>The multicast socket describes a group communication channel
        composed of one or multiple interfaces. A socket may be created
        without explicit interface association by the application, which
        leaves the choice of the underlying forwarding technology to the group
        communication stack. However, an application may also bind the socket
        to one or multiple dedicated interfaces, which predefines the
        forwarding technology and the namespace(s) of the Group
        Address(es).
</p>
<p>Applications are not required to maintain mapping states for Group
        Addresses. The group communication stack accounts for the mapping of
        the Group Name to the Group Address(es) and vice versa. Multicast data
        passed to the application will be augmented by the corresponding Group
        Name. Multiple multicast subscriptions thus can be conducted on a
        single multicast socket without the need for Group Name encoding at
        the application side.
</p>
<p>Hosts may support several multicast protocols. The group
        communication stack discovers available multicast-enabled
        communication interfaces. It provides a minimal hybrid function that
        bridges data between different interfaces and multicast domains.
        Details of service discovery are out-of-scope of this document.
</p>
<p>
</p>
<p>The extended multicast functions can be implemented by a middleware
        as conceptually visualized in <a class='info' href='#fig:middleware'>Figure&nbsp;2<span> (</span><span class='info'>A middleware for offering uniform access to multicast in underlay and overlay</span><span>)</span></a>.
</p>
<p>
</p><br /><hr class="insert" />
<a name="fig:middleware"></a>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>*-------*     *-------*
| App 1 |     | App 2 |
*-------*     *-------*
    |             |
*---------------------*         ---|
|   Middleware        |            |
*---------------------*            |
     |          |                  |
*---------*     |                  |
| Overlay |     |                   \  Group Communication
*---------*     |                   /  Stack
     |          |                  |
     |          |                  |
*---------------------*            |
|   Underlay          |            |
*---------------------*         ---|</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;2: A middleware for offering uniform access to multicast in underlay and overlay&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>
</p>
<p>
</p>
<a name="anchor7"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.3"></a><h3>3.3.&nbsp;
Naming and Addressing</h3>

<p>Applications use Group Names to identify groups. Names can uniquely
        determine a group in a global communication context and hide
        technological deployment for data distribution from the application.
        In contrast, multicast forwarding operates on Group Addresses. Even
        though both identifiers may be identical in symbols, they carry
        different meanings. They may also belong to different namespaces. The
        namespace of a Group Address reflects a routing technology, while the
        namespace of a Group Name represents the context in which the
        application operates.
</p>
<p>URIs <a class='info' href='#RFC3986'>[RFC3986]<span> (</span><span class='info'>Berners-Lee, T., Fielding, R., and L. Masinter, &ldquo;Uniform Resource Identifier (URI): Generic Syntax,&rdquo; January&nbsp;2005.</span><span>)</span></a> are a common way to represent
        namespace-specific identifiers in applications in the form of an
        abstract meta-data type. Throughout this document, any kind of Group
        Name follows a URI notation with the syntax defined in <a class='info' href='#sec:details-uri'>Section&nbsp;4.1.1<span> (</span><span class='info'>Multicast URI</span><span>)</span></a>. Examples are, ip://224.1.2.3:5000
        for a canonical IPv4 ASM group, sip://news@cnn.com for an
        application-specific naming with service instantiator and default port
        selection.
</p>
<p>An implementation of the group communication middleware can provide
        convenience functions that detect the namespace of a Group Name and
        use it to optimize service instantiation. In practice, such a library
        would provide support for high-level data types to the application,
        similar to the current socket API (e.g., InetAddress in Java). Using
        this data type could implicitly determine the namespace. Details of
        automatic namespace identification is out-of-scope of this
        document.
</p>
<a name="anchor8"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.4"></a><h3>3.4.&nbsp;
Mapping</h3>

<p>All group members subscribe to the same Group Name taken from a
        common namespace and thereby identify the group in a
        technology-agnostic way.
</p>
<p>Group Names require a mapping to addresses prior to service
        instantiation at an Interface. Similarly, a mapping is needed at
        gateways to translate between Group Addresses from different
        namespaces. Some namespaces facilitate a canonical transformation to
        default address spaces. For example, ip://224.1.2.3:5000 has an
        obvious correspondence to 224.1.2.3 in the IPv4 multicast address
        space. Note that in this example the multicast URI can be completely
        recovered from any data packet received from this group.
</p>
<p>However, mapping in general can be more complex and need not be
        invertible. Mapping functions can be stateless in some contexts, but
        may require states in others. The application of such functions
        depends on the cardinality of the namespaces, the structure of address
        spaces, and possible address collisions. For example, it is not
        obvious how to map a large identifier space (e.g., IPv6) to a smaller,
        collision-prone set like IPv4.
</p>
<p>Two (or more) Multicast Addresses from different namespaces may
        belong to
</p>
<p></p>
<blockquote class="text"><dl>
<dt>a.</dt>
<dd>the same logical group (i.e., same Multicast Name)
</dd>
<dt>b.</dt>
<dd>different multicast channels (i.e., different technical
            IDs).
</dd>
</dl></blockquote>

<p>This decision can be based on invertible mappings. However, the
        application of such functions depends on the cardinality of the
        namespaces and thus does not hold in general. It is not obvious how to
        map a large identifier space (e.g., IPv6) to a smaller set (e.g.,
        IPv4).
</p>
<p>A mapping can be realized by embedding smaller in larger namespaces
        or selecting an arbitrary, unused ID in the target space. The relation
        between logical and technical ID is maintained by mapping functions
        which can be stateless or stateful. The middleware thus queries the
        mapping service first, and creates a new technical group ID only if
        there is no identifier available for the namespace in use. The Group
        Name is associated with one or more Group Addresses, which belong to
        different namespaces. Depending on the scope of the mapping service,
        it ensures a consistent use of the technical ID in a local or global
        domain.
</p>
<a name="anchor9"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4"></a><h3>4.&nbsp;
Common Multicast API</h3>

<p>
</p>
<a name="anchor10"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.1"></a><h3>4.1.&nbsp;
Abstract Data Types</h3>

<p>
</p>
<a name="sec:details-uri"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.1.1"></a><h3>4.1.1.&nbsp;
Multicast URI</h3>

<p>Multicast Names and Multicast Addresses used in this API follow
          an URI scheme that defines a subset of the generic URI specified in
          <a class='info' href='#RFC3986'>[RFC3986]<span> (</span><span class='info'>Berners-Lee, T., Fielding, R., and L. Masinter, &ldquo;Uniform Resource Identifier (URI): Generic Syntax,&rdquo; January&nbsp;2005.</span><span>)</span></a> and is compliant with the guidelines
          in <a class='info' href='#RFC4395'>[RFC4395]<span> (</span><span class='info'>Hansen, T., Hardie, T., and L. Masinter, &ldquo;Guidelines and Registration Procedures for New URI Schemes,&rdquo; February&nbsp;2006.</span><span>)</span></a>.
</p>
<p>The multicast URI is defined as follows:
</p>
<p></p>
<blockquote class="text">
<p>scheme "://" group "@" instantiation ":" port "/"
              sec-credentials
</p>
</blockquote>

<p>The parts of the URI are defined as follows:
</p>
<p></p>
<blockquote class="text"><dl>
<dt>scheme</dt>
<dd>refers to the specification of the assigned
              identifier <a class='info' href='#RFC3986'>[RFC3986]<span> (</span><span class='info'>Berners-Lee, T., Fielding, R., and L. Masinter, &ldquo;Uniform Resource Identifier (URI): Generic Syntax,&rdquo; January&nbsp;2005.</span><span>)</span></a> which takes the role
              of the namespace.
</dd>
<dt>group</dt>
<dd>identifies the group uniquely within the
              namespace given in scheme.
</dd>
<dt>instantiation</dt>
<dd>identifies the entity that generates
              the instance of the group (e.g., a SIP domain or a source in
              SSM) using the namespace given in scheme.
</dd>
<dt>port</dt>
<dd>identifies a specific application at an
              instance of a group.
</dd>
<dt>sec-credentials</dt>
<dd>used to implement security
              credentials (e.g., to authorize a multicast group access).
</dd>
</dl></blockquote>

<a name="anchor11"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.1.2"></a><h3>4.1.2.&nbsp;
Interface</h3>

<p>The interface denotes the layer and instance on which the
          corresponding call will be effective. In agreement with <a class='info' href='#RFC3493'>[RFC3493]<span> (</span><span class='info'>Gilligan, R., Thomson, S., Bound, J., McCann, J., and W. Stevens, &ldquo;Basic Socket Interface Extensions for IPv6,&rdquo; February&nbsp;2003.</span><span>)</span></a> we identify an interface by an identifier,
          which is a positive integer starting at 1.
</p>
<p>Properties of an interface are stored in the following
          struct:
</p>
<p>
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>    struct if_prop {
      unsigned int if_index; /* 1, 2, ... */
      char        *if_name;  /* "eth0", "eth1:1", "lo", ... */
      char        *if_addr;  /* "1.2.3.4", "abc123" ... */
      char        *if_tech;  /* "ip", "overlay", ... */
    };</pre></div>
<p>
</p>
<p>The following function retrieves all available interfaces from
          the system:
</p>
<p>
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>    struct if_prop *if_prop(void);</pre></div>
<p>
</p>
<p>It extends the functions for Interface Identification in <a class='info' href='#RFC3493'>[RFC3493]<span> (</span><span class='info'>Gilligan, R., Thomson, S., Bound, J., McCann, J., and W. Stevens, &ldquo;Basic Socket Interface Extensions for IPv6,&rdquo; February&nbsp;2003.</span><span>)</span></a> (cf., Section 4).
</p>
<a name="anchor12"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.2"></a><h3>4.2.&nbsp;
Group Management Calls</h3>

<p>
</p>
<a name="anchor13"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.2.1"></a><h3>4.2.1.&nbsp;
Create</h3>

<p>The create call initiates a multicast socket and provides the
          application programmer with a corresponding handle. If no interfaces
          will be assigned based on the call, the default interface will be
          selected and associated with the socket. The call may return an
          error code in the case of failures, e.g., due to a non-operational
          middleware.
</p>
<p>
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>    int createMSocket(uint32_t *if);</pre></div>
<p>
</p>
<p>The if argument denotes a list of interfaces (if_indexes) that
          will be associated with the multicast socket. This parameter is
          optional.
</p>
<p>On success a multicast socket identifier is returned, otherwise
          NULL.
</p>
<a name="anchor14"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.2.2"></a><h3>4.2.2.&nbsp;
Destroy</h3>

<p>The destroy call removes the multicast socket.
</p>
<p>
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>    int destroyMSocket(int s);</pre></div>
<p>
</p>
<p>The s argument identifies the multicast socket for
          destruction.
</p>
<p>On success the value 0 is returned, otherwise -1.
</p>
<a name="anchor15"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.2.3"></a><h3>4.2.3.&nbsp;
Join</h3>

<p>The join call initiates a subscription for the given group.
          Depending on the interfaces that are associated with the socket,
          this may result in an IGMP/MLD report or overlay subscription.
</p>
<p>
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>    int join(int s, const uri group_name);</pre></div>
<p>
</p>
<p>The s argument identifies the multicast socket.
</p>
<p>The group_name argument identifies the group.
</p>
<p>On success the value 0 is returned, otherwise -1.
</p>
<a name="anchor16"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.2.4"></a><h3>4.2.4.&nbsp;
Leave</h3>

<p>The leave call results in an unsubscription for the given Group
          Name.
</p>
<p>
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>    int leave(int s, const uri group_name);</pre></div>
<p>
</p>
<p>The s argument identifies the multicast socket.
</p>
<p>The group_name identifies the group.
</p>
<p>On success the value 0 is returned, otherwise -1.
</p>
<a name="anchor17"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.2.5"></a><h3>4.2.5.&nbsp;
Source Register</h3>

<p>The srcRegister call registers a source for a Group on all active
          interfaces of the socket s. This call may assist group distribution
          in some technologies, the creation of sub-overlays, for example. Not
          all multicast technologies require his call.
</p>
<p>
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>    int srcRegister(int s, const uri group_name,
                    uint_t num_ifs, uint_t *ifs);</pre></div>
<p>
</p>
<p>The s argument identifies the multicast socket.
</p>
<p>The group_name argument identifies the multicast group to which a
          source intends to send data.
</p>
<p>The num_ifs argument holds the number of elements in the ifs
          array. This parameter is optional.
</p>
<p>The ifs argument points to the list of interface indexes for
          which the source registration failed. If num_ifs was 0 on output, a
          NULL pointer is returned. This parameter is optional.
</p>
<p>If source registration succeeded for all interfaces associated
          with the socket, the value 0 is returned, otherwise -1.
</p>
<a name="anchor18"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.2.6"></a><h3>4.2.6.&nbsp;
Source Deregister</h3>

<p>The srcDeregister indicates that a source does no longer intend
          to send data to the multicast group. This call may remain without
          effect in some multicast technologies.
</p>
<p>
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>    int srcDeregister(int s, const uri group_name,
                      uint_t num_ifs, uint_t *ifs);</pre></div>
<p>
</p>
<p>The s argument identifies the multicast socket.
</p>
<p>The group_name argument identifies the multicast group to which a
          source has stopped to send multicast data.
</p>
<p>The num_ifs argument holds the number of elements in the ifs
          array.
</p>
<p>The ifs argument points to the list of interfaces for which the
          source deregistration failed. If num_ifs was 0 on output, a NULL
          pointer is returned.
</p>
<p>If source deregistration succeeded for all interfaces associated
          with the socket, the value 0 is returned, otherwise -1.
</p>
<a name="anchor19"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.3"></a><h3>4.3.&nbsp;
Send and Receive Calls</h3>

<p>
</p>
<a name="anchor20"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.3.1"></a><h3>4.3.1.&nbsp;
Send</h3>

<p>The send call passes multicast data for a Multicast Name from the
          application to the multicast socket.
</p>
<p>
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>    int send(int s, const uri group_name,
             size_t msg_len, const void *buf);</pre></div>
<p>
</p>
<p>The s argument identifies the multicast socket.
</p>
<p>The group_name argument identifies the group to which data will
          be sent.
</p>
<p>The msg_len argument holds the length of the message to be
          sent.
</p>
<p>The buf argument passes the multicast data to the multicast
          socket.
</p>
<p>On success the value 0 is returned, otherwise -1.
</p>
<a name="anchor21"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.3.2"></a><h3>4.3.2.&nbsp;
Receive</h3>

<p>The receive call passes multicast data and the corresponding
          Group Name to the application.
<p>
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>    int receive(int s, const uri group_name,
                size_t msg_len, msg *msg_buf);</pre></div>
<p>
</p>

<p>The s argument identifies the multicast socket.
</p>
<p>The group_name argument identifies the multicast group for which
          data was received.
</p>
<p>The msg_len argument holds the length of the received
          message.
</p>
<p>The msg_buf argument points to the payload of the received
          multicast data.
</p>
<p>On success the value 0 is returned, otherwise -1.
</p>
<a name="anchor22"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.4"></a><h3>4.4.&nbsp;
Socket Options</h3>

<p>The following calls configure an existing multicast socket.
</p>
<a name="anchor23"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.4.1"></a><h3>4.4.1.&nbsp;
Get Interfaces</h3>

<p>The getInterface call returns an array of all available multicast
          communication interfaces associated with the multicast socket.
</p>
<p>
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>    int getInterfaces(int s, uint_t num_ifs, uint_t *ifs);</pre></div>
<p>
</p>
<p>The s argument identifies the multicast socket.
</p>
<p>The num_ifs argument holds the number of interfaces in the ifs
          list.
</p>
<p>The ifs argument points to an array of interface index
          identifiers.
</p>
<p>On success the value 0 or lager is returned, otherwise -1.
</p>
<a name="anchor24"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.4.2"></a><h3>4.4.2.&nbsp;
Add Interface</h3>

<p>The addInterface call adds a distribution channel to the socket.
          This may be an overlay or underlay interface, e.g., IPv6 or DHT.
          Multiple interfaces of the same technology may be associated with
          the socket.
</p>
<p>
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>    int addInterface(int s, uint32_t if);</pre></div>
<p>
</p>
<p>The s and if arguments identify a multicast socket and interface,
          respectively.
</p>
<p>On success the value 0 is returned, otherwise -1.
</p>
<a name="anchor25"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.4.3"></a><h3>4.4.3.&nbsp;
Delete Interface</h3>

<p>The delnterface call removes the interface if from the multicast
          socket.
</p>
<p>
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>    int delInterface(int s, uint32_t if);</pre></div>
<p>
</p>
<p>The s and if arguments identify a multicast socket and interface,
          respectively.
</p>
<p>On success the value 0 is returned, otherwise -1.
</p>
<a name="anchor26"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.4.4"></a><h3>4.4.4.&nbsp;
Set TTL</h3>

<p>The setTTL call configures the maximum hop count for the socket a
          multicast message is allowed to traverse.
</p>
<p>
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>    int setTTL(int s, int h, uint_t num_ifs, uint_t *ifs);</pre></div>
<p>
</p>
<p>The s and h arguments identify a multicast socket and the maximum
          hop count, respectively.
</p>
<p>The num_ifs argument holds the number of interfaces in the ifs
          list. This parameter is optional.
</p>
<p>The ifs argument points to an array of interface index
          identifiers. This parameter is optional.
</p>
<p>On success the value 0 is returned, otherwise -1.
</p>
<a name="anchor27"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.5"></a><h3>4.5.&nbsp;
Service Calls</h3>

<p>
</p>
<a name="anchor28"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.5.1"></a><h3>4.5.1.&nbsp;
Group Set</h3>

<p>The groupSet call returns all multicast groups registered at a
          given interface. This information can be provided by group
          management states or routing protocols. The return values
          distinguish between sender and listener states.
</p>
<p>
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>    int groupSet(uint32_t if, uint_t *num_groups,
                 struct groupSet *groupSet);

    struct groupSet {
      uri group_name; /* registered multicast group */
      int type;       /* 0 = listener state, 1 = sender state,
                         2 = sender &amp; listener state */</pre></div>
<p>
</p>
<p>The if argument identifies the interface for which states are
          maintained.
</p>
<p>The num_groups argument holds the number of groups in the
          groupSet array.
</p>
<p>The groupSet argument points to an array of group states.
</p>
<p>On success the value 0 is returned, otherwise -1.
</p>
<a name="anchor29"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.5.2"></a><h3>4.5.2.&nbsp;
Neighbor Set</h3>

<p>The neighborSet function returns the set of neighboring nodes for
          a given interface as seen by the multicast routing protocol.
</p>
<p>
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>    int neighborSet(uint32_t if, uint_t *num_neighbors,
                    const uri *neighbor_address);</pre></div>
<p>
</p>
<p>The if argument identifies the interface for which neighbors are
          inquired.
</p>
<p>The num_neighbors argument holds the number of addresses in the
          neighbor_address array.
</p>
<p>The neighbor_address argument points to a list of neighboring
          nodes on a successful return.
</p>
<p>On success the value 0 is returned, otherwise -1.
</p>
<a name="anchor30"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.5.3"></a><h3>4.5.3.&nbsp;
Children Set</h3>

<p>The childrenSet function returns the set of child nodes that
          receive multicast data from a specified interface for a given group.
          For a common multicast router, this call retrieves the multicast
          forwarding information base per interface.
</p>
<p>
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>    int childrenSet(uint32_t if, const uri group_name,
                   uint_t *num_children, const uri *child_address);</pre></div>
<p>
</p>
<p>The if argument identifies the interface for which children are
          inquired.
</p>
<p>The group_name argument defines the multicast group for which
          distribution is considered.
</p>
<p>The num_children argument holds the number of addresses in the
          child_address array.
</p>
<p>The child_address argument points to a list of neighboring nodes
          on a successful return.
</p>
<p>On success the value 0 is returned, otherwise -1.
</p>
<a name="anchor31"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.5.4"></a><h3>4.5.4.&nbsp;
Parent Set</h3>

<p>The parentSet function returns the set of neighbors from which
          the current node receives multicast data at a given interface for
          the specified group.
</p>
<p>
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>    int parentSet(uint32_t if, const uri group_name, uint_t *num_parents,
                    const uri *parent_address);</pre></div>
<p>
</p>
<p>The if argument identifies the interface for which parents are
          inquired.
</p>
<p>The group_name argument defines the multicast group for which
          distribution is considered.
</p>
<p>The num_parents argument holds the number of addresses in the
          parent_address array.
</p>
<p>The parent_address argument points to a list of neighboring nodes
          on a successful return.
</p>
<p>On success the value 0 is returned, otherwise -1.
</p>
<a name="anchor32"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.5.5"></a><h3>4.5.5.&nbsp;
Designated Host</h3>

<p>The designatedHost function inquires whether the host has the
          role of a designated forwarder resp. querier, or not. Such an
          information is provided by almost all multicast protocols to prevent
          packet duplication, if multiple multicast instances serve on the
          same subnet.
</p>
<p>
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>    int designatedHost(uint32_t if, const uri *group_name);</pre></div>
<p>
</p>
<p>The if argument identifies the interface for which designated
          forwarding is inquired.
</p>
<p>The group_name argument specifies the group for which the host
          may attain the role of designated forwarder.
</p>
<p>The function returns 1 if the host is a designated forwarder or
          querier, otherwise 0. The return value -1 indicates an error.
</p>
<a name="anchor33"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.5.6"></a><h3>4.5.6.&nbsp;
Update Listener</h3>

<p>The updateListener function is invoked to inform a group service
          about a change of listener states for a group. This is the result of
          receiver new subscriptions or leaves. The group service may call
          groupSet to get updated information.
</p>
<p>
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>    const uri *updateListener();</pre></div>
<p>
</p>
<p>On success the updateListener function points to the Group Name
          that experienced a state change, otherwise NULL is returned.
</p>
<a name="anchor34"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5"></a><h3>5.&nbsp;
Functional Details</h3>

<p>In this section, we describe specific functions of the API and the
      associated system middleware in detail.
</p>
<p>
</p>
<a name="sec:namespace"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.1"></a><h3>5.1.&nbsp;
Namespaces</h3>

<p>Namespace identifiers in URIs are placed in the scheme element and
        characterize syntax and semantic of the group identifier. They enable
        the use of convenience functions and high-level data types while
        processing URIs. When used in names, they may facilitate a default
        mapping and a recovery of names from addresses. They characterize its
        type, when used in addresses.
</p>
<p>Compliant to the URI concept, namespace-schemes can be added.
        Examples of schemes and functions currently foreseen include
</p>
<p></p>
<blockquote class="text"><dl>
<dt>IP</dt>
<dd>This namespace is comprised of regular IP node
            naming, i.e., DNS names and addresses taken from any version of
            the Internet Protocol. A processor dealing with the IP namespace
            is required to determine the syntax (DNS name, IP address version)
            of the group expression.
</dd>
<dt>OLM</dt>
<dd>This namespace covers address strings
            immediately valid in an overlay network. A processor handling
            those strings need not be aware of the address generation
            mechanism, but may pass these values directly to a corresponding
            overlay.
</dd>
<dt>SIP</dt>
<dd>The SIP namespace is an example of an
            application-layer scheme that bears inherent group functions
            (conferencing). SIP conference URIs may be directly exchanged and
            interpreted at the application, and mapped to group addresses on
            the system level to generate a corresponding multicast group.
</dd>
<dt>Opaque</dt>
<dd>This namespace transparently carries strings
            without further syntactical information, meanings or associated
            resolution mechanism.
</dd>
</dl></blockquote><p> 
</p>
<a name="anchor35"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.2"></a><h3>5.2.&nbsp;
Mapping</h3>

<p>Group Name to Group Address, SSM/ASM TODO
</p>
<a name="IANA"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6"></a><h3>6.&nbsp;
IANA Considerations</h3>

<p>This document makes no request of IANA.
</p>
<a name="Security"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7"></a><h3>7.&nbsp;
Security Considerations</h3>

<p>This draft does neither introduce additional messages nor novel
      protocol operations. TODO
</p>
<a name="Acknowledgements"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.8"></a><h3>8.&nbsp;
Acknowledgements</h3>

<p>We would like to thank the HAMcast-team, Dominik Charousset, Gabriel
      Hege, Fabian Holler, Alexander Knauf, Sebastian Meiling, and Sebastian
      Woelke, at the HAW Hamburg for many fruitful discussions and for their
      continuous critical feedback while implementing API and a hybrid
      multicast middleware.
</p>
<p>This work is partially supported by the German Federal Ministry of
      Education and Research within the HAMcast project, which is part of
      G-Lab.
</p>
<a name="rfc.references1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>9.&nbsp;Informative References</h3>
<table width="99%" border="0">
<tr><td class="author-text" valign="top"><a name="I-D.ietf-mboned-auto-multicast">[I-D.ietf-mboned-auto-multicast]</a></td>
<td class="author-text">Thaler, D., Talwar, M., Aggarwal, A., Vicisano, L., and T. Pusateri, &ldquo;<a href="http://www.ietf.org/internet-drafts/draft-ietf-mboned-auto-multicast-10.txt">Automatic IP Multicast Without Explicit Tunnels (AMT)</a>,&rdquo; draft-ietf-mboned-auto-multicast-10 (work in progress), March&nbsp;2010 (<a href="http://www.ietf.org/internet-drafts/draft-ietf-mboned-auto-multicast-10.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC1075">[RFC1075]</a></td>
<td class="author-text">Waitzman, D., Partridge, C., and S. Deering, &ldquo;<a href="http://tools.ietf.org/html/rfc1075">Distance Vector Multicast Routing Protocol</a>,&rdquo; RFC&nbsp;1075, November&nbsp;1988 (<a href="http://www.rfc-editor.org/rfc/rfc1075.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC2119">[RFC2119]</a></td>
<td class="author-text"><a href="mailto:sob@harvard.edu">Bradner, S.</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>,&rdquo; BCP&nbsp;14, RFC&nbsp;2119, March&nbsp;1997 (<a href="http://www.rfc-editor.org/rfc/rfc2119.txt">TXT</a>, <a href="http://xml.resource.org/public/rfc/html/rfc2119.html">HTML</a>, <a href="http://xml.resource.org/public/rfc/xml/rfc2119.xml">XML</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC2710">[RFC2710]</a></td>
<td class="author-text"><a href="mailto:deering@cisco.com">Deering, S.</a>, <a href="mailto:fenner@research.att.com">Fenner, W.</a>, and <a href="mailto:haberman@raleigh.ibm.com">B. Haberman</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc2710">Multicast Listener Discovery (MLD) for IPv6</a>,&rdquo; RFC&nbsp;2710, October&nbsp;1999 (<a href="http://www.rfc-editor.org/rfc/rfc2710.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC3376">[RFC3376]</a></td>
<td class="author-text">Cain, B., Deering, S., Kouvelas, I., Fenner, B., and A. Thyagarajan, &ldquo;<a href="http://tools.ietf.org/html/rfc3376">Internet Group Management Protocol, Version 3</a>,&rdquo; RFC&nbsp;3376, October&nbsp;2002 (<a href="http://www.rfc-editor.org/rfc/rfc3376.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC3493">[RFC3493]</a></td>
<td class="author-text">Gilligan, R., Thomson, S., Bound, J., McCann, J., and W. Stevens, &ldquo;<a href="http://tools.ietf.org/html/rfc3493">Basic Socket Interface Extensions for IPv6</a>,&rdquo; RFC&nbsp;3493, February&nbsp;2003 (<a href="http://www.rfc-editor.org/rfc/rfc3493.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC3678">[RFC3678]</a></td>
<td class="author-text">Thaler, D., Fenner, B., and B. Quinn, &ldquo;<a href="http://tools.ietf.org/html/rfc3678">Socket Interface Extensions for Multicast Source Filters</a>,&rdquo; RFC&nbsp;3678, January&nbsp;2004 (<a href="http://www.rfc-editor.org/rfc/rfc3678.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC3810">[RFC3810]</a></td>
<td class="author-text">Vida, R. and L. Costa, &ldquo;<a href="http://tools.ietf.org/html/rfc3810">Multicast Listener Discovery Version 2 (MLDv2) for IPv6</a>,&rdquo; RFC&nbsp;3810, June&nbsp;2004 (<a href="http://www.rfc-editor.org/rfc/rfc3810.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC3986">[RFC3986]</a></td>
<td class="author-text"><a href="mailto:timbl@w3.org">Berners-Lee, T.</a>, <a href="mailto:fielding@gbiv.com">Fielding, R.</a>, and <a href="mailto:LMM@acm.org">L. Masinter</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc3986">Uniform Resource Identifier (URI): Generic Syntax</a>,&rdquo; STD&nbsp;66, RFC&nbsp;3986, January&nbsp;2005 (<a href="http://www.rfc-editor.org/rfc/rfc3986.txt">TXT</a>, <a href="http://xml.resource.org/public/rfc/html/rfc3986.html">HTML</a>, <a href="http://xml.resource.org/public/rfc/xml/rfc3986.xml">XML</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4395">[RFC4395]</a></td>
<td class="author-text">Hansen, T., Hardie, T., and L. Masinter, &ldquo;<a href="http://tools.ietf.org/html/rfc4395">Guidelines and Registration Procedures for New URI Schemes</a>,&rdquo; BCP&nbsp;35, RFC&nbsp;4395, February&nbsp;2006 (<a href="http://www.rfc-editor.org/rfc/rfc4395.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4601">[RFC4601]</a></td>
<td class="author-text">Fenner, B., Handley, M., Holbrook, H., and I. Kouvelas, &ldquo;<a href="http://tools.ietf.org/html/rfc4601">Protocol Independent Multicast - Sparse Mode (PIM-SM): Protocol Specification (Revised)</a>,&rdquo; RFC&nbsp;4601, August&nbsp;2006 (<a href="http://www.rfc-editor.org/rfc/rfc4601.txt">TXT</a>, <a href="http://www.rfc-editor.org/rfc/rfc4601.pdf">PDF</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4604">[RFC4604]</a></td>
<td class="author-text">Holbrook, H., Cain, B., and B. Haberman, &ldquo;<a href="http://tools.ietf.org/html/rfc4604">Using Internet Group Management Protocol Version 3 (IGMPv3) and Multicast Listener Discovery Protocol Version 2 (MLDv2) for Source-Specific Multicast</a>,&rdquo; RFC&nbsp;4604, August&nbsp;2006 (<a href="http://www.rfc-editor.org/rfc/rfc4604.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC5015">[RFC5015]</a></td>
<td class="author-text">Handley, M., Kouvelas, I., Speakman, T., and L. Vicisano, &ldquo;<a href="http://tools.ietf.org/html/rfc5015">Bidirectional Protocol Independent Multicast (BIDIR-PIM)</a>,&rdquo; RFC&nbsp;5015, October&nbsp;2007 (<a href="http://www.rfc-editor.org/rfc/rfc5015.txt">TXT</a>).</td></tr>
</table>

<a name="anchor37"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.A"></a><h3>Appendix A.&nbsp;
Practical Example of the API</h3>

<p>
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>  -- Application above middleware:

  //Initialize multicast socket;
  //the middleware selects all available interfaces
  MulticastSocket m = new MulticastSocket();

  m.join(URI("ip://224.1.2.3:5000"));
  m.join(URI("ip://[FF02:0:0:0:0:0:0:3]:6000"));
  m.join(URI("sip://news@cnn.com"));

  -- Middleware:

  join(URI mcAddress) {
    //Select interfaces in use
    for all this.interfaces {
      switch (interface.type) {
        case "ipv6":
          //... map logical ID to routing address
          Inet6Address rtAddressIPv6 = new Inet6Address();
          mapNametoAddress(mcAddress,rtAddressIPv6);
          interface.join(rtAddressIPv6);
        case "ipv4":
          //... map logical ID to routing address
          Inet4Address rtAddressIPv4 = new Inet4Address();
          mapNametoAddress(mcAddress,rtAddressIPv4);
          interface.join(rtAddressIPv4);
        case "sip-session":
          //... map logical ID to routing address
          SIPAddress rtAddressSIP = new SIPAddress();
          mapNametoAddress(mcAddress,rtAddressSIP);
          interface.join(rtAddressSIP);
        case "dht":
          //... map logical ID to routing address
          DHTAddress rtAddressDHT = new DHTAddress();
          mapNametoAddress(mcAddress,rtAddressDHT);
          interface.join(rtAddressDHT);
         //...
      }
    }
  }

</pre></div>
<a name="anchor38"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.B"></a><h3>Appendix B.&nbsp;
Deployment Use Cases for Hybrid Multicast</h3>

<p>This section describes the application of the defined API to
      implement an IMG.
</p>
<a name="anchor39"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.B.1"></a><h3>B.1.&nbsp;
DVMRP</h3>

<p>The following procedure describes a transparent mapping of a
        DVMRP-based any source multicast service to another many-to-many
        multicast technology.
</p>
<p>An arbitrary DVMRP <a class='info' href='#RFC1075'>[RFC1075]<span> (</span><span class='info'>Waitzman, D., Partridge, C., and S. Deering, &ldquo;Distance Vector Multicast Routing Protocol,&rdquo; November&nbsp;1988.</span><span>)</span></a> router will not
        be informed about new receivers, but will learn about new sources
        immediately. The concept of DVMRP does not provide any central
        multicast instance. Thus, the IMG can be placed anywhere inside the
        multicast region, but requires a DVMRP neighbor connectivity. The
        group communication stack used by the IMG is enhanced by a DVMRP
        implementation. New sources in the underlay will be advertised based
        on the DVMRP flooding mechanism and received by the IMG. Based on this
        the updateSender() call is triggered. The relay agent initiates a
        corresponding join in the native network and forwards the received
        source data towards the overlay routing protocol. Depending on the
        group states, the data will be distributed to overlay peers.
</p>
<p>DVMRP establishes source specific multicast trees. Therefore, a
        graft message is only visible for DVMRP routers on the path from the
        new receiver subnet to the source, but in general not for an IMG. To
        overcome this problem, data of multicast senders will be flooded in
        the overlay as well as in the underlay. Hence, an IMG has to initiate
        an all-group join to the overlay using the namespace extension of the
        API. Each IMG is initially required to forward the received overlay
        data to the underlay, independent of native multicast receivers.
        Subsequent prunes may limit unwanted data distribution thereafter.
</p>
<a name="anchor40"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.B.2"></a><h3>B.2.&nbsp;
PIM-SM</h3>

<p>The following procedure describes a transparent mapping of a
        PIM-SM-based any source multicast service to another many-to-many
        multicast technology.
</p>
<p>The Protocol Independent Multicast Sparse Mode (PIM-SM) <a class='info' href='#RFC4601'>[RFC4601]<span> (</span><span class='info'>Fenner, B., Handley, M., Holbrook, H., and I. Kouvelas, &ldquo;Protocol Independent Multicast - Sparse Mode (PIM-SM): Protocol Specification (Revised),&rdquo; August&nbsp;2006.</span><span>)</span></a> establishes rendezvous points (RP). These
        entities receive listener and source subscriptions of a domain. To be
        continuously updated, an IMG has to be co-located with a RP. Whenever
        PIM register messages are received, the IMG must signal internally a
        new multicast source using updateSender(). Subsequently, the IMG joins
        the group and a shared tree between the RP and the sources will be
        established, which may change to a source specific tree after a
        sufficient number of data has been delivered. Source traffic will be
        forwarded to the RP based on the IMG join, even if there are no
        further receivers in the native multicast domain. Designated routers
        of a PIM-domain send receiver subscriptions towards the PIM-SM RP. The
        reception of such messages invokes the updateListener() call at the
        IMG, which initiates a join towards the overlay routing protocol.
        Overlay multicast data arriving at the IMG will then transparently be
        forwarded in the underlay network and distributed through the RP
        instance.
</p>
<a name="anchor41"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.B.3"></a><h3>B.3.&nbsp;
PIM-SSM</h3>

<p>The following procedure describes a transparent mapping of a
        PIM-SSM-based source specific multicast service to another one-to-many
        multicast technology.
</p>
<p>PIM Source Specific Multicast (PIM-SSM) is defined as part of
        PIM-SM and admits source specific joins (S,G) according to the source
        specific host group model <a class='info' href='#RFC4604'>[RFC4604]<span> (</span><span class='info'>Holbrook, H., Cain, B., and B. Haberman, &ldquo;Using Internet Group Management Protocol Version 3 (IGMPv3) and Multicast Listener Discovery Protocol Version 2 (MLDv2) for Source-Specific Multicast,&rdquo; August&nbsp;2006.</span><span>)</span></a>. A multicast
        distribution tree can be established without the assistance of a
        rendezvous point.
</p>
<p>Sources are not advertised within a PIM-SSM domain. Consequently,
        an IMG cannot anticipate the local join inside a sender domain and
        deliver a priori the multicast data to the overlay instance. If an IMG
        of a receiver domain initiates a group subscription via the overlay
        routing protocol, relaying multicast data fails, as data are not
        available at the overlay instance. The IMG instance of the receiver
        domain, thus, has to locate the IMG instance of the source domain to
        trigger the corresponding join. In the sense of PIM-SSM, the signaling
        should not be flooded in underlay and overlay.
</p>
<p>One solution could be to intercept the subscription at both, source
        and receiver sites: To monitor multicast receiver subscriptions
        (updateListener()) in the underlay, the IMG is placed on path towards
        the source, e.g., at a domain border router. This router intercepts
        join messages and extracts the unicast source address S, initializing
        an IMG specific join to S via regular unicast. Multicast data arriving
        at the IMG of the sender domain can be distributed via the overlay.
        Discovering the IMG of a multicast sender domain may be implemented
        analogously to AMT <a class='info' href='#I-D.ietf-mboned-auto-multicast'>[I&#8209;D.ietf&#8209;mboned&#8209;auto&#8209;multicast]<span> (</span><span class='info'>Thaler, D., Talwar, M., Aggarwal, A., Vicisano, L., and T. Pusateri, &ldquo;Automatic IP Multicast Without Explicit Tunnels (AMT),&rdquo; March&nbsp;2010.</span><span>)</span></a> by anycast.
        Consequently, the source address S of the group (S,G) should be built
        based on an anycast prefix. The corresponding IMG anycast address for
        a source domain is then derived from the prefix of S.
</p>
<a name="anchor42"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.B.4"></a><h3>B.4.&nbsp;
BIDIR-PIM</h3>

<p>The following procedure describes a transparent mapping of a
        BIDIR-PIM-based any source multicast service to another many-to-many
        multicast technology.
</p>
<p>Bidirectional PIM <a class='info' href='#RFC5015'>[RFC5015]<span> (</span><span class='info'>Handley, M., Kouvelas, I., Speakman, T., and L. Vicisano, &ldquo;Bidirectional Protocol Independent Multicast (BIDIR-PIM),&rdquo; October&nbsp;2007.</span><span>)</span></a> is a variant of
        PIM-SM. In contrast to PIM-SM, the protocol pre-establishes
        bidirectional shared trees per group, connecting multicast sources and
        receivers. The rendezvous points are virtualized in BIDIR-PIM as an
        address to identify on-tree directions (up and down). However, routers
        with the best link towards the (virtualized) rendezvous point address
        are selected as designated forwarders for a link-local domain and
        represent the actual distribution tree. The IMG is to be placed at the
        RP-link, where the rendezvous point address is located. As source data
        in either cases will be transmitted to the rendezvous point address,
        the BIDIR-PIM instance of the IMG receives the data and can internally
        signal new senders towards the stack via updateSender(). The first
        receiver subscription for a new group within a BIDIR-PIM domain needs
        to be transmitted to the RP to establish the first branching point.
        Using the updateListener() invocation, an IMG will thereby be informed
        about group requests from its domain, which are then delegated to the
        overlay.
</p>
<a name="anchor43"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.C"></a><h3>Appendix C.&nbsp;
Change Log</h3>

<p>The following changes have been made from
      draft-waehlisch-sam-common-api-03</p>
<ol class="text">
<li>Use cases added for illustration.
</li>
<li>Service calls added for inquiring on the multicast distribution
          system.
</li>
<li>Namespace examples added.
</li>
<li>Clarifications and editorial improvements.
</li>
</ol><p>The following changes have been made from
      draft-waehlisch-sam-common-api-02</p>
<ol class="text">
<li>Rename init() in createMSocket().
</li>
<li>Added calls srcRegister()/srcDeregister().
</li>
<li>Rephrased API calls in C-style.
</li>
<li>Cleanup code in "Practical Example of the API".
</li>
<li>Partial reorganization of the document.
</li>
<li>Many editorial improvements.
</li>
</ol>

<p>The following changes have been made from
      draft-waehlisch-sam-common-api-01</p>
<ol class="text">
<li>Document restructured to clarify the realm of document overview
          and specific contributions s.a. naming and addressing.
</li>
<li>A clear separation of naming and addressing was drawn. Multicast
          URIs have been introduced.
</li>
<li>Clarified and adapted the API calls.
</li>
<li>Introduced Socket Option calls.
</li>
<li>Deployment use cases moved to an appendix.
</li>
<li>Simple programming example added.
</li>
<li>Many editorial improvements.
</li>
</ol>

<a name="rfc.authors"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>Authors' Addresses</h3>
<table width="99%" border="0" cellpadding="0" cellspacing="0">
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Matthias Waehlisch</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">link-lab &amp; FU Berlin</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Hoenower Str. 35</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Berlin  10318</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Germany</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:mw@link-lab.net">mw@link-lab.net</a></td></tr>
<tr><td class="author" align="right">URI:&nbsp;</td>
<td class="author-text"><a href="http://www.inf.fu-berlin.de/~waehl">http://www.inf.fu-berlin.de/~waehl</a></td></tr>
<tr cellpadding="3"><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Thomas C. Schmidt</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">HAW Hamburg</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Berliner Tor 7</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Hamburg  20099</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Germany</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:schmidt@informatik.haw-hamburg.de">schmidt@informatik.haw-hamburg.de</a></td></tr>
<tr><td class="author" align="right">URI:&nbsp;</td>
<td class="author-text"><a href="http://inet.cpt.haw-hamburg.de/members/schmidt">http://inet.cpt.haw-hamburg.de/members/schmidt</a></td></tr>
<tr cellpadding="3"><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Stig Venaas</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">cisco Systems</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Tasman Drive</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">San Jose, CA  95134</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">USA</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:stig@cisco.com">stig@cisco.com</a></td></tr>
</table>
</body></html>
