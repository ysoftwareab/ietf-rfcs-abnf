start = element-dhcp

element-dhcp = element dhcp {
     element subnet {
       element network { ipv4-address-content },
       element prefix-length {
         xsd:short { minInclusive = "0" maxInclusive = "32" }
       }
       element-range?,
       element leases {
         element-lease*
       }?,
     }*
element-range = element range {
      element low  { ipv4-address-content },
      element high { ipv4-address-content }
element-lease = element lease {
      attribute ip-address { ipv4-address-content },
      element starts  { xsd:dateTime },
      element ends    { xsd:dateTime },
      element mac-address { mac-address-content }
element-servers = element servers {
    element service {
      element name  { xsd:string },
      element port  { xsd:unsignedShort }
      >> dml:unique ["port"]
    }+
element-dhcp = element dhcp {
     element subnet {
       element prefix {
         element network { ipv4-address-content },
         element prefix-length {
           xsd:short { minInclusive = "0" maxInclusive = "32" }
         }
       },
       element-range
       >> dml:key ["concat(prefix/network, '/', prefix/prefix-length)"]
     }+
element-subnet = element subnet {
     element network { ipv4-address-content },
     element prefix-length {
       xsd:short { minInclusive = "0" maxInclusive = "32" }
     },
     element interface-filter {
       element interface {
         xsd:token
         >> dml:keyref ["//int:interface"]
       }+
     }
element-interfaces = element int:interfaces {
     element int:interface {
       element int:ifIndex { xsd:token },
       element int:ifType  { xsd:token }
       >> dml:key ["int:ifIndex"]
     }+
element-leases = element leases {
     element lease {
       attribute ip-address { ipv4-address-content },
       element starts  { xsd:dateTime },
       element ends    { xsd:dateTime },
       element mac-address { mac-address-content }
     }*
     >> dml:infoType ["non-config"]
element-subnet =   element subnet {
     element network { ipv4-address-content },
     element prefix-length {
       xsd:short { minInclusive = "0" maxInclusive = "32" }
     }
     >> dml:manual-validation-rule [xml:lang="en"
            "Subnets may not overlap"]
     >> dml:manual-validation-rule [xml:lang="fr"
            "Les sous-reseaux ne peuvent pas se superposer"]
element-dhcp = element dhcp {
   [
     sch:ns [ prefix="dhcp" uri="http://example.org/ns/dhcp" ]
     sch:pattern [
       sch:rule  [
context = "//dhcp:dhcp"
test = "dhcp:default-lease-time <= dhcp:max-lease-time"
test="dhcp:default-lease-time &;lt;= dhcp:max-lease-time">
value="//dhcp:interface-filter/dhcp:interface"/>
element-range = element range {
     element low  { ipv4-address-content }?,
     element high { ipv4-address-content }?
     >> dml:existence []
     >> compat:documentation
       ["The presence of a range element turns on dynamic addressing " ~
        "for the subnet.  If low and high elements are missing, the "  ~
        "DHCP server serves dynamic addresses for the whole range "    ~
        "except for any router addresses on that subnet."]
element-router-list-option = element router-list {
      element router { ipv4-address-content }+
        >> dml:order ["user-order"]
start = element-config
element-config = element config {
      external "interfaces.rnc" ? &
      external "dhcp.rnc" ?

element-sip-timers = element sip-timers {
     element  t1-timer {
       xsd:positiveInteger
       >> compat:defaultValue [ dml:moduleDefault="true"
          "500" ]  >> dml:units ["ms"]
     }
     ...
revokeLeaseType = element revoke-lease {
   element address { ipv4-address-content }+
   >> dml:infoType ["rpc-request" action="revoke-lease" ]
diagnostics="keyref-fail-en keyref-fail-fr">
value="//dhcp:interface-filter/dhcp:interface"/>
element-controller = element controller {
     # a bunch of sub-elements of controller
     #   ...
     >> dml:infoType [ maxAccess="read write delete" "config"]
     >> compat:documentation ["Can't create a controller"]
start = element-config
element-config = element cfg:config { config-contents }
config-contents = empty

start = element-interfaces

element-interfaces = element interfaces {
   element-interface+
   >> dc:title [ "Example Interfaces schema fragment" ]
element-interface = element interface {
   element ifIndex { xsd:token },
   element ifType  { xsd:token }
   >> dml:key [ "ifIndex"]
   >> dml:version ["1.0"]
start = element-dhcp





element-dhcp = element dhcp {
    global-timer-elements,
    element-subnet*,
    element-shared-network*
    >> dc:title [ "Example schema for DHCP server" ]
    >> dml:version ["1.0"]
    >> dc:type ["Dataset"]
    >> dc:creator [ "Rohan Mahy" ]
    >> dml:organization [ "as an individual" ]
    >> dml:contact [ "mailto:rohan@ekabal.com" ]
    >> dc:created [ "2008-02-13" ]
global-timer-elements = (
   [
     sch:ns [ prefix="dhcp" uri="http://example.org/ns/dhcp" ]
     sch:pattern [
       sch:rule  [
context = "//dhcp:dhcp"
test = "dhcp:default-lease-time <= dhcp:max-lease-time"
element-shared-network = element shared-network {
    attribute name { token },
    element-subnet*
element-subnet = element subnet {
    element-network,
    element-prefix-length,
    element-range?,
    element-dhcp-options?,
    element max-lease-time {
       xsd:unsignedInt
       >> dml:units ["s"]
       >> dml:status ["deprecated"]





    }?,
    element leases {
       element-lease*
       >> dml:infoType ["non-config"]
    }?,
    element-interface-filter?
    >> dml:key ["concat(network, '/', prefix-length)"]
    >> dml:manual-validation-rule [
         "Verify that none of the subnets overlap with other subnets." ]
element-network = element network {
    ipv4-address-content
element-prefix-length = element prefix-length {
    xsd:short { minInclusive = "0" maxInclusive = "32" }
element-range = element range {
    element low  { ipv4-address-content }?,
    element high { ipv4-address-content }?
    >> dml:existence []
    >> dml:manual-validation-rule [
        "Verify the range is within the subnet." ]
element-dhcp-options = element dhcp-options {
    element-router-list-option? &
    element-domain-list-option? &
    element-custom-option*
element-lease = element lease {
    attribute ip-address { ipv4-address-content },
    element starts  { xsd:dateTime },
    element ends    { xsd:dateTime },
    element mac-address { mac-address-content }
    >> dml:key ["@ip-address"]
element-router-list-option = element router-list {
    element router { ipv4-address-content }+
      >> dml:order ["user-order"]
element-domain-list-option = element domain-list {
    element domain { token }+
element-custom-option = element custom {





    attribute option { xsd:unsignedByte },
    (
        element ip-address { ipv4-address-content }
      | element string { string }
    )
    >> dml:key ["@option"]
element-interface-filter = element interface-filter {
   element-interface+
element-interface = element interface {
     token >> dml:keyref ["//int:interface"]
ipv4-address-content = xsd:token { pattern =
   "((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}" ~
   "(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])"
   }
mac-address-content  = xsd:token { pattern =
   "(([0-9a-fA-F]{2}):?){5}[0-9a-fA-F]{2}" }







defaultPhase="std">
test="dhcp:default-lease-time &;lt;= dhcp:max-lease-time">
value="concat(dhcp:network, '/', dhcp:prefix-length)"/>
value="//dhcp:subnet/dhcp:dhcp-options/dhcp:router-list"/>
value="dhcp:router"/>
value="//dhcp:interface-filter/dhcp:interface"/>
start = element-dml

element-dml = element dml {
    dmlVersionAttribute? &
    dml-contents
dmlVersionAttribute = attribute dmlVersion { "1.0" }

dml-contents = (
    dataModelVersion &
    organization* &
    contact-info* &
    list-order* &
    data-category* &
    mustUse-flag* &
    container-existence* &
    manual-validation* &
    units* &
    conformStatus* &
    mustUnderstand*
dataModelVersion = element version { xsd:string }

organization = element organization { string-with-lang }





contact-info = element contact { xsd:anyURI }

unique = element unique { xsd:anyURI }
key = element key { xsd:anyURI }
keyref = element keyref { xsd:anyURI }

data-category = element infoType {
    attribute minAccess { list { access-strings }}?,
    attribute maxAccess { list { access-strings }}?,
    attribute action { xsd:string },
    ("config" | "non-config" | "rpc-request" | "notify")
    >> compat:defaultValue ["config"]
access-strings = ( "read" | "write" | "create" | "delete" | "execute" )

mustUse-flag = element mustUse { xsd:boolean
                >> compat:defaultValue ["false"]
manual-validation = element manual-validation-rule { string-with-lang }

list-order = element order {
   ("any-order" | "user-order")
   >> compat:defaultValue ["any-order"]
container-existence = element existence { empty }

units = element units {
   xsd:string { pattern="[^: \n\r\t]+" }
   # allow familiar units, but no whitespace or absolute URIs here
   |
   xsd:anyURI { pattern="([a-zA-Z][a-zA-Z0-9\-\+\.]*:|\.\./|\./|#).*" }
   # allow absolute URIs, plus relative URIs with ./ or ../
   # prohibit relative URIs that could look like a unit, ex: m/s
string-with-lang = (
    attribute xml:lang { xsd:language },
    xsd:string
conformStatus = element status {
    "active" | "deprecated" | "obsolete"





    >> compat:defaultValue ["active"]
mustUnderstand = element mustUnderstand { list { xsd:NCName } }

dml-netconf-error-app-tag =
    attribute netconf-error-app-tag { xsd:string }

dml-phase-attribute = attribute phase { "fragment" | "std" | "full" }

dml-moduleDefault = attribute moduleDefault {
   xsd:boolean >> compat:defaultValue ["false"]
port-number = xsd:unsignedShort { minInclusive = "1" } | "0"

ip-prefix = ((attribute version { "ipv4" }?, ipv4-prefix)
           | (attribute version { "ipv6" }?, ipv6-prefix))
         & element scope { xsd:token }

ip-version = "unknown" | "ipv4" | "ipv6"

dscp = xsd:unsignedByte { maxInclusive = "63" }






flow-label = xsd:unsignedInt { maxInclusive = "1048576" }

port-number = xsd:unsignedShort { minInclusive = "1" }

ip-address =
     (attribute version { "ipv4" }?,
      ipv4-address)
     | (attribute version { "ipv6" }?,
        ipv6-address)

ipv4-address =
     xsd:token {
pattern =
         "((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\.){3}" ~
         "(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])"
ipv6-address =
   xsd:token {
pattern = "([0-9a-fA-F]{0,4}:){0,7}[0-9a-fA-F]{0,4}"
pattern =
      "(([0-9a-fA-F]+:){7}[0-9a-fA-F]+)|" ~
      "(([0-9a-fA-F]+:)*[0-9a-fA-F]+)?::(([0-9a-fA-F]+:)*[0-9a-fA-F]+)?"
pattern =
       "([0-9a-fA-F]{0,4}:){0,6}((25[0-5]|2[0-4][0-9]|" ~
       "[01]?[0-9]?[0-9]).){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])"
pattern =
       "(([0-9a-fA-F]+:){6}|(([0-9a-fA-F]+:)*[0-9a-fA-F]+)?::" ~
       "([0-9a-fA-F]+:)*)((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9]).)" ~
       "{3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])"
ip-prefix =
     (attribute version { "ipv4" }?,
      ipv4-prefix)
     |
     (attribute version { "ipv6" }?,
        ipv6-prefix)

ipv4-prefix =
     element address { ipv4-address }
     & element length {
         xsd:unsignedByte { maxInclusive = "32" }





       }

ipv6-prefix =
     element address { ipv6-address }
     & element length {
         xsd:unsignedByte { maxInclusive = "128" }
       }

domain-name =
     xsd:token {
maxLength = "255"
pattern =
         "([A-Za-z0-9]([\-A-Za-z0-9]{0,61}[A-Za-z0-9])?.)*" ~
          "[A-Za-z0-9]([\-A-Za-z0-9]{0,61}[A-Za-z0-9])?.?"
host =
     ( attribute content-type { "ipv4" }?,
       ipv4-address)
     |
     ( attribute content-type { "ipv6" }?,
       ipv6-address)
     |
     ( attribute content-type { "dns" }?,
       domain-name)






mac-address = xsd:token {
pattern = "([0-9a-fA-F]{2}:){5}[0-9a-fA-F]{2}"
bridgeid = xsd:token {
pattern = "[0-9a-fA-F]{4}:([0-9a-fA-F]{2}:){5}[0-9a-fA-F]{2}"
vlanid = xsd:unsignedShort {
minInclusive = "1"
maxInclusive = "4094"
ns="http://example.org/ns/dhcp"
xmlns="http://relaxng.org/ns/structure/1.0"
datatypeLibrary="http://www.w3.org/2001/XMLSchema-datatypes">

test="dhcp:default-lease-time &lt;= dhcp:max-lease-time">
