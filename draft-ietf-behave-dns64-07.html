<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="en"><head><title>DNS64: DNS extensions for Network Address
    Translation from IPv6 Clients to IPv4 Servers</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="description" content="DNS64: DNS extensions for Network Address
    Translation from IPv6 Clients to IPv4 Servers">
<meta name="keywords" content="DNS64, IPv6">
<meta name="generator" content="xml2rfc v1.35 (http://xml.resource.org/)">
<meta name="viewport" content="width=600;" />
<style type='text/css'><!--
        body {
                font-family: verdana, charcoal, helvetica, arial, sans-serif;
                font-size: 85%;
		max-width: 40em; 
		color: #000; background-color: #FFF;
                margin: 2em;
        }
        h1, h2, h3, h4, h5, h6 {
                font-family: helvetica, monaco, "MS Sans Serif", arial, sans-serif;
                font-weight: bold; font-style: normal;
        }
        h1 { color: #900; background-color: transparent; text-align: right; }
        h3 { color: #333; background-color: transparent; }

        td.RFCbug {
                font-size: x-small; text-decoration: none;
                width: 30px; height: 30px; padding-top: 2px;
                text-align: justify; vertical-align: middle;
                background-color: #000;
        }
        td.RFCbug span.RFC {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: bold; color: #666;
        }
        td.RFCbug span.hotText {
                font-family: charcoal, monaco, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: normal; text-align: center; color: #FFF;
        }

        table.TOCbug { width: 30px; height: 15px; }
        td.TOCbug {
                text-align: center; width: 30px; height: 15px;
                color: #FFF; background-color: #900;
        }
        td.TOCbug a {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, sans-serif;
                font-weight: bold; font-size: x-small; text-decoration: none;
                color: #FFF; background-color: transparent;
        }

        td.header {
                font-family: arial, helvetica, sans-serif; font-size: x-small;
                vertical-align: top; width: 33%;
                color: #FFF; background-color: #666;
        }
        td.author { font-weight: bold; font-size: x-small; margin-left: 4em; }
        td.author-text { font-size: x-small; }

        /* info code from SantaKlauss at http://www.madaboutstyle.com/tooltip2.html */
        a.info {
                /* This is the key. */
                position: relative;
                z-index: 24;
                text-decoration: none;
        }
        a.info:hover {
                z-index: 25;
                color: #FFF; background-color: #900;
        }
        a.info span { display: none; }
        a.info:hover span.info {
                /* The span will display just on :hover state. */
                display: block;
                position: absolute;
                font-size: smaller;
                top: 2em; left: -5em; width: 15em;
                padding: 2px; border: 1px solid #333;
                color: #900; background-color: #EEE;
                text-align: left;
        }

        a { font-weight: bold; }
        a:link    { color: #900; background-color: transparent; }
        a:visited { color: #633; background-color: transparent; }
        a:active  { color: #633; background-color: transparent; }

        p { margin-left: 2em; margin-right: 2em; }
        p.copyright { font-size: x-small; }
        p.toc { font-size: 85%;
		max-width: 40em; 
		font-weight: bold; margin-left: 3em; }
        table.toc { margin: 0 0 0 3em; padding: 0; border: 0; vertical-align: text-top; }
        td.toc { font-size: 85%;
		max-width: 40em; 
		font-weight: bold; vertical-align: text-top; }

        ol.text { margin-left: 2em; margin-right: 2em; }
        ul.text { margin-left: 2em; margin-right: 2em; }
        li      { margin-left: 3em; }

        /* RFC-2629 <spanx>s and <artwork>s. */
        em     { font-style: italic; }
        strong { font-weight: bold; }
        dfn    { font-weight: bold; font-style: normal; }
        cite   { font-weight: normal; font-style: normal; }
        tt     { color: #036; }
        tt, pre, pre dfn, pre em, pre cite, pre span {
                font-family: "Courier New", Courier, monospace; font-size: small;
        }
        pre {
                text-align: left; padding: 4px;
                color: #000; background-color: #CCC;
        }
        pre dfn  { color: #900; }
        pre em   { color: #66F; background-color: #FFC; font-weight: normal; }
        pre .key { color: #33C; font-weight: bold; }
        pre .id  { color: #900; }
        pre .str { color: #000; background-color: #CFF; }
        pre .val { color: #066; }
        pre .rep { color: #909; }
        pre .oth { color: #000; background-color: #FCF; }
        pre .err { background-color: #FCC; }

        /* RFC-2629 <texttable>s. */
        table.all, table.full, table.headers, table.none {
                font-size: 85%;
		max-width: 40em; 
		text-align: center; border-width: 2px;
                vertical-align: top; border-collapse: collapse;
        }
        table.all, table.full { border-style: solid; border-color: black; }
        table.headers, table.none { border-style: none; }
        th {
                font-weight: bold; border-color: black;
                border-width: 2px 2px 3px 2px;
        }
        table.all th, table.full th { border-style: solid; }
        table.headers th { border-style: none none solid none; }
        table.none th { border-style: none; }
        table.all td {
                border-style: solid; border-color: #333;
                border-width: 1px 2px;
        }
        table.full td, table.headers td, table.none td { border-style: none; }

        hr { height: 1px; }
        hr.insert {
                width: 80%; border-style: none; border-width: 0;
                color: #CCC; background-color: #CCC;
        }
--></style>
</head>
<body>
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<table summary="layout" width="66%" border="0" cellpadding="0" cellspacing="0"><tr><td><table summary="layout" width="100%" border="0" cellpadding="2" cellspacing="1">
<tr><td class="header">BEHAVE WG</td><td class="header">M. Bagnulo</td></tr>
<tr><td class="header">Internet-Draft</td><td class="header">UC3M</td></tr>
<tr><td class="header">Intended status: Standards Track</td><td class="header">A. Sullivan</td></tr>
<tr><td class="header">Expires: September 7, 2010</td><td class="header">Shinkuro</td></tr>
<tr><td class="header">&nbsp;</td><td class="header">P. Matthews</td></tr>
<tr><td class="header">&nbsp;</td><td class="header">Alcatel-Lucent</td></tr>
<tr><td class="header">&nbsp;</td><td class="header">I. van Beijnum</td></tr>
<tr><td class="header">&nbsp;</td><td class="header">IMDEA Networks</td></tr>
<tr><td class="header">&nbsp;</td><td class="header">March 06, 2010</td></tr>
</table></td></tr></table>
<h1><br />DNS64: DNS extensions for Network Address
    Translation from IPv6 Clients to IPv4 Servers<br />draft-ietf-behave-dns64-07</h1>

<h3>Abstract</h3>

<p>DNS64 is a mechanism for synthesizing AAAA records from A
      records. DNS64 is used with an IPv6/IPv4 translator to enable client-server
      communication between an IPv6-only client and an IPv4-only server, without
      requiring any changes to either the IPv6 or the IPv4 node, for the class of
      applications that work through NATs. This document specifies DNS64, and
      provides suggestions on how it should be deployed in conjunction with 
	  IPv6/IPv4 translators.
</p>
<h3>Status of this Memo</h3>
<p>
This Internet-Draft is submitted to IETF in full
conformance with the provisions of BCP&nbsp;78 and BCP&nbsp;79.</p>
<p>
Internet-Drafts are working documents of the Internet Engineering
Task Force (IETF), its areas, and its working groups.
Note that other groups may also distribute working documents as
Internet-Drafts.</p>
<p>
Internet-Drafts are draft documents valid for a maximum of six months
and may be updated, replaced, or obsoleted by other documents at any time.
It is inappropriate to use Internet-Drafts as reference material or to cite
them other than as &ldquo;work in progress.&rdquo;</p>
<p>
The list of current Internet-Drafts can be accessed at
<a href='http://www.ietf.org/ietf/1id-abstracts.txt'>http://www.ietf.org/ietf/1id-abstracts.txt</a>.</p>
<p>
The list of Internet-Draft Shadow Directories can be accessed at
<a href='http://www.ietf.org/shadow.html'>http://www.ietf.org/shadow.html</a>.</p>
<p>
This Internet-Draft will expire on September 7, 2010.</p>

<h3>Copyright Notice</h3>
<p>
Copyright (c) 2010 IETF Trust and the persons identified as the
document authors.  All rights reserved.</p>
<p>
This document is subject to BCP 78 and the IETF Trust's Legal
Provisions Relating to IETF Documents
(http://trustee.ietf.org/license-info) in effect on the date of
publication of this document.  Please review these documents
carefully, as they describe your rights and restrictions with respect
to this document. Code Components extracted from this document must
include Simplified BSD License text as described in Section 4.e of
the Trust Legal Provisions and are provided without warranty as
described in the BSD License.</p>
<a name="toc"></a><br /><hr />
<h3>Table of Contents</h3>
<p class="toc">
<a href="#anchor1">1.</a>&nbsp;
Introduction<br />
<a href="#anchor2">2.</a>&nbsp;
Overview<br />
<a href="#dns64bkgd">3.</a>&nbsp;
Background to DNS64-DNSSEC interaction<br />
<a href="#terms">4.</a>&nbsp;
Terminology<br />
<a href="#normative">5.</a>&nbsp;
DNS64 Normative Specification<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor3">5.1.</a>&nbsp;
Resolving AAAA queries and the answer section<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor4">5.1.1.</a>&nbsp;
The answer when there is AAAA data
                            available<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#aaaa_error">5.1.2.</a>&nbsp;
The answer when there is an error<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor5">5.1.3.</a>&nbsp;
Dealing with timeouts<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#exclusion_set">5.1.4.</a>&nbsp;
Special exclusion set for AAAA records<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#cname_dname">5.1.5.</a>&nbsp;
Dealing with CNAME and DNAME<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor6">5.1.6.</a>&nbsp;
Data for the answer when performing synthesis<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#syntheticans">5.1.7.</a>&nbsp;
Performing the synthesis<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor7">5.1.8.</a>&nbsp;
Querying in parallel<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#address-transform">5.2.</a>&nbsp;
Generation of the IPv6 representations of IPv4 addresses<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor9">5.3.</a>&nbsp;
Handling other Resource Records and the Additional Section<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor10">5.3.1.</a>&nbsp;
PTR Resource Record<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#addl_sec">5.3.2.</a>&nbsp;
Handling the additional section<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor11">5.3.3.</a>&nbsp;
Other Resource Records<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#assembly">5.4.</a>&nbsp;
Assembling a synthesized response to a
                            AAAA query<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#dnssec64rec">5.5.</a>&nbsp;
DNSSEC processing: DNS64 in recursive resolver mode<br />
<a href="#anchor12">6.</a>&nbsp;
Deployment notes<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor13">6.1.</a>&nbsp;
DNS resolvers and DNS64<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#valanddns64">6.2.</a>&nbsp;
DNSSEC validators and DNS64<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor14">6.3.</a>&nbsp;
DNS64 and multihomed and dual-stack hosts<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor15">6.3.1.</a>&nbsp;
IPv6 multihomed hosts<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor16">6.3.2.</a>&nbsp;
Accidental dual-stack DNS64 use<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor17">6.3.3.</a>&nbsp;
Intentional dual-stack DNS64 use<br />
<a href="#examples">7.</a>&nbsp;
Deployment scenarios and examples<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor18">7.1.</a>&nbsp;
Example of An-IPv6-network-to-IPv4-Internet setup with DNS64 in DNS server mode<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor19">7.2.</a>&nbsp;
An example of an-IPv6-network-to-IPv4-Internet setup with DNS64 in stub-resolver mode<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor20">7.3.</a>&nbsp;
Example of IPv6-Internet-to-an-IPv4-network setup DNS64 in DNS server mode<br />
<a href="#anchor21">8.</a>&nbsp;
Security Considerations<br />
<a href="#anchor22">9.</a>&nbsp;
IANA Considerations<br />
<a href="#anchor23">10.</a>&nbsp;
Contributors<br />
<a href="#anchor24">11.</a>&nbsp;
Acknowledgements<br />
<a href="#rfc.references1">12.</a>&nbsp;
References<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#rfc.references1">12.1.</a>&nbsp;
Normative References<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#rfc.references2">12.2.</a>&nbsp;
Informative References<br />
<a href="#always-synth">Appendix&nbsp;A.</a>&nbsp;
Motivations and Implications of synthesizing AAAA Resource Records when real AAAA Resource Records exist<br />
<a href="#rfc.authors">&#167;</a>&nbsp;
Authors' Addresses<br />
</p>
<br clear="all" />

<a name="anchor1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1"></a><h3>1.&nbsp;
Introduction</h3>

<p>This document specifies DNS64, a mechanism that is part of
      the toolbox for IPv6-IPv4 transition and co-existence. DNS64,
      used together with an IPv6/IPv4 translator such as stateful NAT64 <a class='info' href='#I-D.ietf-behave-v6v4-xlate-stateful'>[I&#8209;D.ietf&#8209;behave&#8209;v6v4&#8209;xlate&#8209;stateful]<span> (</span><span class='info'>Bagnulo, M., Matthews, P., and I. Beijnum, &ldquo;Stateful NAT64: Network Address and Protocol Translation from IPv6 Clients to IPv4 Servers,&rdquo; March&nbsp;2010.</span><span>)</span></a>, allows an IPv6-only
      client to initiate communications by name to an IPv4-only
      server.
</p>
<p>DNS64 is a mechanism for synthesizing AAAA resource records
      (RRs) from A RRs.  A synthetic AAAA RR created by the DNS64 from
      an original A RR contains the same owner name of the original A
      RR but it contains an IPv6 address instead of an IPv4 address.
      The IPv6 address is an IPv6 representation of the IPv4 address
      contained in the original A RR. The IPv6 representation of the
      IPv4 address is algorithmically generated from the IPv4 address
      returned in the A RR and a set of parameters configured in the
      DNS64 (typically, an IPv6 prefix used by IPv6 representations of
      IPv4 addresses and optionally other parameters).
</p>
<p>Together with an IPv6/IPv4 translator, these two mechanisms
      allow an IPv6-only client to initiate communications to an
      IPv4-only server using the FQDN of the server.
</p>
<p>These mechanisms are expected to play a critical role in the
      IPv4-IPv6 transition and co-existence. Due to IPv4 address
      depletion, it is likely that in the future, many IPv6-only
      clients will want to connect to IPv4-only servers.  In the
      typical case, the approach only requires the deployment of
      IPv6/IPv4 translators that connect an IPv6-only network to an
      IPv4-only network, along with the deployment of one or more
      DNS64-enabled name servers. However, some advanced features
      require performing the DNS64 function directly in the end-hosts
      themselves.
</p>
<a name="anchor2"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2"></a><h3>2.&nbsp;
Overview</h3>

<p>This section provides a non-normative introduction to the DNS64 mechanism. 
</p>
<p>We assume that we have one or more IPv6/IPv4 translator boxes connecting
      an IPv4 network and an IPv6 network. The IPv6/IPv4 translator
      device provides translation services between the two networks
      enabling communication between IPv4-only hosts and IPv6-only
      hosts. (NOTE: By IPv6-only hosts we mean hosts running IPv6-only
      applications, hosts that can only use IPv6, as well as cases
      where only IPv6 connectivity is available to the client.  By
      IPv4-only servers we mean servers running IPv4-only
      applications, servers that can only use IPv4, as well as
      cases where only IPv4 connectivity is available to the server).
      Each IPv6/IPv4 translator used in conjunction with DNS64 must
      allow communications initiated from the IPv6-only host to the
      IPv4-only host.
</p>
<p>To allow an IPv6 initiator to do a standard AAAA RR DNS
      lookup to learn the address of the responder, DNS64 is used to
      synthesize a AAAA record from an A record containing a real IPv4
      address of the responder, whenever the DNS64 cannot retrieve a
      AAAA record for the queried name.  The DNS64 service appears as
      a regular DNS server or resolver to the IPv6 initiator.  The
      DNS64 receives a AAAA DNS query generated by the IPv6 initiator.
      It first attempts a resolution for the requested AAAA records.
      If there are no AAAA records available for the target node
      (which is the normal case when the target node is an IPv4-only
      node), DNS64 performs a query for A records. For each A record
      discovered, DNS64 creates a synthetic AAAA RR from the
      information retrieved in the A RR.
</p>
<p>The owner name of a synthetic AAAA RR is the same as that of
      the original A RR, but an IPv6 representation of the IPv4
      address contained in the original A RR is included in the AAAA
      RR. The IPv6 representation of the IPv4 address is
      algorithmically generated from the IPv4 address and additional
      parameters configured in the DNS64. Among those parameters
      configured in the DNS64, there is at least one IPv6 prefix. If
      not explicitly mentioned, all prefixes are treated equally and
      the operations described in this document are performed using
      the prefixes available.  So as to be general, we will call any
      of these prefixes Pref64::/n, and describe the operations made
      with the generic prefix Pref64::/n. The IPv6 address
      representing IPv4 addresses included in the AAAA RR synthesized
      by the DNS64 contain Pref64::/n and they also embed the original
      IPv4 address. 
</p>
<p>The same algorithm and the same Pref64::/n prefix(es) 
	    must be configured both in the DNS64 device and the
 		IPv6/IPv4 translator(s), so that both can algorithmically
 		generate the same IPv6 representation for a given IPv4
 		address.  In addition, it is required that IPv6 packets
 		addressed to an IPv6 destination address that contains the Pref64::/n
 		be delivered to an IPv6/IPv4 translator, so they can be
 		translated into IPv4 packets.
</p>
<p>Once the DNS64 has synthesized the AAAA RRs, the synthetic
 		AAAA RRs are passed back to the IPv6 initiator, which will
 		initiate an IPv6 communication with the IPv6 address
 		associated with the IPv4 receiver. The packet will be routed
 		to an IPv6/IPv4 translator which will forward it to the IPv4
 		network.
</p>
<p>In general, the only shared state between the DNS64 and the
		IPv6/IPv4 translator is the Pref64::/n and an optional set of
		static parameters.  The Pref64::/n and the set of static
		parameters must be configured to be the same on both; there is
		no communication between the DNS64 device and IPv6/IPv4
		translator functions.  The mechanism to be used for
		configuring the parameters of the DNS64 is beyond the scope of
		this memo.
</p>
<p>The prefixes to be used as Pref64::/n  and their applicability are discussed in 
			<a class='info' href='#I-D.ietf-behave-address-format'>[I&#8209;D.ietf&#8209;behave&#8209;address&#8209;format]<span> (</span><span class='info'>Bao, C., Huitema, C., Bagnulo, M., Boucadair, M., and X. Li, &ldquo;IPv6 Addressing of IPv4/IPv6 Translators,&rdquo; April&nbsp;2010.</span><span>)</span></a>.
			There are two types of prefixes that can be used as Pref64::/n.
			</p>
<blockquote class="text">
<p>The Pref64::/n can be the Well-Known Prefix 64:FF9B::/96
				 reserved by <a class='info' href='#I-D.ietf-behave-address-format'>[I&#8209;D.ietf&#8209;behave&#8209;address&#8209;format]<span> (</span><span class='info'>Bao, C., Huitema, C., Bagnulo, M., Boucadair, M., and X. Li, &ldquo;IPv6 Addressing of IPv4/IPv6 Translators,&rdquo; April&nbsp;2010.</span><span>)</span></a>
				for the purpose of representing IPv4 addresses in IPv6 address space.
</p>
<p>The Pref64::/n can be a Network-Specific Prefix (NSP). An NSP is 
					an IPv6 prefix assigned by an organization to create IPv6
					representations of IPv4 addresses.
</p>
</blockquote><p>The main difference in the nature of the two types of prefixes is that
			the NSP is a locally assigned prefix that is under control of the organization
			that is providing the translation services, while the Well-Known Prefix is a
			prefix that has a global meaning since it has been assigned for the specific 
			purpose of representing IPv4 addresses in IPv6 address space.
</p>
<p>The DNS64 function can be performed in any of three places.
        The terms below are more formally defined in <a class='info' href='#terms'>Section&nbsp;4<span> (</span><span class='info'>Terminology</span><span>)</span></a>.
</p>
<p>The first option is to locate the DNS64 function in
        authoritative servers for a zone.  In this case, the
        authoritative server provides synthetic AAAA RRs for an
        IPv4-only host in its zone.  This is one type of DNS64 server.
</p>
<p>Another option is to locate the DNS64 function in
          recursive name servers serving end hosts. In this case, when
          an IPv6-only host queries the name server for AAAA RRs for
          an IPv4-only host, the name server can perform the synthesis
          of AAAA RRs and pass them back to the IPv6-only
          initiator. The main advantage of this mode is that current
          IPv6 nodes can use this mechanism without requiring any
          modification.  This mode is called "DNS64 in DNS recursive
          resolver mode" .  This is a second type of DNS64 server, and
          it is also one type of DNS64 resolver.
</p>
<p>The last option is to place the DNS64 function in the end hosts,
          coupled to the local (stub) resolver. In this case, the stub resolver
          will try to obtain (real) AAAA RRs and in case they are not available, the 
          DNS64 function will synthesize AAAA RRs for internal usage. This mode is 
          compatible with some advanced 
          functions like DNSSEC validation in the end host. The main drawback of this
          mode is its deployability, since it requires changes in the end hosts. 
          This mode is called "DNS64 in stub-resolver mode".  This is
          the second type of DNS64 resolver.
</p>
<a name="dns64bkgd"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3"></a><h3>3.&nbsp;
Background to DNS64-DNSSEC interaction</h3>

<p>DNSSEC (<a class='info' href='#RFC4033'>[RFC4033]<span> (</span><span class='info'>Arends, R., Austein, R., Larson, M., Massey, D., and S. Rose, &ldquo;DNS Security Introduction and Requirements,&rdquo; March&nbsp;2005.</span><span>)</span></a>, <a class='info' href='#RFC4034'>[RFC4034]<span> (</span><span class='info'>Arends, R., Austein, R., Larson, M., Massey, D., and S. Rose, &ldquo;Resource Records for the DNS Security Extensions,&rdquo; March&nbsp;2005.</span><span>)</span></a>, <a class='info' href='#RFC4035'>[RFC4035]<span> (</span><span class='info'>Arends, R., Austein, R., Larson, M., Massey, D., and S. Rose, &ldquo;Protocol Modifications for the DNS Security Extensions,&rdquo; March&nbsp;2005.</span><span>)</span></a>) presents a
        special challenge for DNS64, because DNSSEC is designed to
        detect changes to DNS answers, and DNS64 may alter answers
        coming from an authoritative server. 
</p>
<p>A recursive resolver can be security-aware or
        security-oblivious.  Moreover, a security-aware recursive
        resolver can be validating or non-validating, according to
        operator policy. In the cases below, the recursive resolver is
        also performing DNS64, and has a local policy to validate.  We
        call this general case vDNS64, but in all the cases below the
        DNS64 functionality should be assumed needed.
</p>
<p>DNSSEC includes some signaling bits that offer some
        indicators of what the query originator understands.
</p>
<p>If a query arrives at a vDNS64 device with the "DNSSEC OK" (DO) bit set, the query
		originator is signaling that it understands DNSSEC.  The DO
		bit does not indicate that the query originator will validate
		the response.  It only means that the query originator can
		understand responses containing DNSSEC data.  Conversely, if
		the DO bit is clear, that is evidence that the querying agent
		is not aware of DNSSEC.
</p>
<p> If a query arrives at a vDNS64 device with the "Checking Disabled" (CD) bit set, it is an
		indication that the querying agent wants all the validation
		data so it can do checking itself.  By local policy, vDNS64
		could still validate, but it must return all data to the
		querying agent anyway.
</p>
<p>	Here are the possible cases:
        </p>
<ol class="text">
<li>A DNS64 (DNSSEC-aware or DNSSEC-oblivious)
          receives a query with the DO bit clear.  In this case,
          DNSSEC is not a concern, because the querying agent does not
          understand DNSSEC responses.
</li>
<li>A security-oblivious DNS64 receives a query with the
          DO bit set, and the CD bit clear or set.  This is just like
          the case of a non-DNS64 case: the server doesn't support it,
          so the querying agent is out of luck.
</li>
<li>A security-aware and non-validating DNS64
          receives a query with the DO bit set and the CD bit clear.
          Such a resolver is not validating responses, likely due to
          local policy (see <a class='info' href='#RFC4035'>[RFC4035]<span> (</span><span class='info'>Arends, R., Austein, R., Larson, M., Massey, D., and S. Rose, &ldquo;Protocol Modifications for the DNS Security Extensions,&rdquo; March&nbsp;2005.</span><span>)</span></a>, section 4.2).
          For that reason, this case amounts to the same as the
          previous case, and no validation happens.  
</li>
<li>A security-aware and non-validating DNS64 receives a
          query with the DO bit set and the CD bit set.  In this case,
          the resolver is supposed to pass on all the data it gets to
          the query initiator (see section 3.2.2 of <a class='info' href='#RFC4035'>[RFC4035]<span> (</span><span class='info'>Arends, R., Austein, R., Larson, M., Massey, D., and S. Rose, &ldquo;Protocol Modifications for the DNS Security Extensions,&rdquo; March&nbsp;2005.</span><span>)</span></a>).  This case will be problematic with
          DNS64.  If the DNS64 server modifies the record, the client
          will get the data back and try to validate it, and the data
          will be invalid as far as the client is concerned.
</li>
<li>A security-aware and validating DNS64 node receives a
          query with the DO bit clear and CD clear.  In this case, the
          resolver validates the data.  If it fails, it returns RCODE
          2 (Server failure); otherwise, it returns the answer.  This
          is the ideal case for vDNS64.  The resolver validates the
          data, and then synthesizes the new record and passes that to
          the client.  The client, which is presumably not validating
          (else it should have set DO and CD), cannot tell that DNS64
          is involved.
</li>
<li>A security-aware and validating DNS64 node
          receives a query with the DO bit set and CD clear.  
          This ought to work like the previous case, except
          that the resolver should also set the "Authentic Data" (AD) bit on the
          response.
</li>
<li>A security-aware and validating DNS64 node
          receives a query with the DO bit set and CD set.  This is
          effectively the same as the case where a security-aware and
          non-validating recursive resolver receives a similar query,
          and the same thing will happen: the downstream validator
          will mark the data as invalid if DNS64 has performed
          synthesis.
</li>
</ol>

<a name="terms"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4"></a><h3>4.&nbsp;
Terminology</h3>

<p>This section provides definitions for the special terms
          used in the document. 
</p>
<p>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL",
          "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY",
          and "OPTIONAL" in this document are to be interpreted as
          described in <a class='info' href='#RFC2119'>RFC 2119<span> (</span><span class='info'>Bradner, S., &ldquo;Key words for use in RFCs to Indicate Requirement Levels,&rdquo; March&nbsp;1997.</span><span>)</span></a> [RFC2119].
</p>
<p></p>
<blockquote class="text"><dl>
<dt>Authoritative server:</dt>
<dd>A DNS server that can
            answer authoritatively a given DNS question. 
</dd>
<dt>DNS64:</dt>
<dd>A logical function that synthesizes
            DNS resource records (e.g AAAA records containing IPv6
            addresses) from DNS resource records actually contained in
            the DNS (e.g., A records containing IPv4
            addresses).
</dd>
<dt>DNS64 recursor:</dt>
<dd>A recursive resolver that
            provides the DNS64 functionality as part of its operation.
            This is the same thing as "DNS64 in recursive resolver
            mode".
</dd>
<dt>DNS64 resolver:</dt>
<dd>Any resolver (stub resolver
            or recursive resolver) that provides the DNS64 function.
            
</dd>
<dt>DNS64 server:</dt>
<dd>Any server providing the DNS64
            function.
</dd>
<dt>Recursive resolver:</dt>
<dd>A DNS server that
            accepts requests from one resolver, and asks another
            server (of some description) for the answer on behalf of
            the first resolver.
</dd>
<dt>Synthetic RR:</dt>
<dd>A DNS resource record (RR)
            that is not contained in any zone data file, but has been
            synthesized from other RRs. An example is a synthetic AAAA
            record created from an A record.
</dd>
<dt>IPv6/IPv4 translator:</dt>
<dd>A device that
            translates IPv6 packets to IPv4 packets and vice-versa. It
            is only required that the communication initiated from the
            IPv6 side be supported.
</dd>
</dl></blockquote>

<p>For a detailed understanding of this document, the reader
          should also be familiar with DNS terminology from <a class='info' href='#RFC1034'>[RFC1034]<span> (</span><span class='info'>Mockapetris, P., &ldquo;Domain names - concepts and facilities,&rdquo; November&nbsp;1987.</span><span>)</span></a>, <a class='info' href='#RFC1035'>[RFC1035]<span> (</span><span class='info'>Mockapetris, P., &ldquo;Domain names - implementation and specification,&rdquo; November&nbsp;1987.</span><span>)</span></a> and current NAT terminology from <a class='info' href='#RFC4787'>[RFC4787]<span> (</span><span class='info'>Audet, F. and C. Jennings, &ldquo;Network Address Translation (NAT) Behavioral Requirements for Unicast UDP,&rdquo; January&nbsp;2007.</span><span>)</span></a>.  Some parts of this document
          assume familiarity with the terminology of the DNS security
          extensions outlined in <a class='info' href='#RFC4035'>[RFC4035]<span> (</span><span class='info'>Arends, R., Austein, R., Larson, M., Massey, D., and S. Rose, &ldquo;Protocol Modifications for the DNS Security Extensions,&rdquo; March&nbsp;2005.</span><span>)</span></a>.
</p>
<a name="normative"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5"></a><h3>5.&nbsp;
DNS64 Normative Specification</h3>

<p>DNS64 is a logical function that synthesizes AAAA
          records from A records. The DNS64 function may be
          implemented in a stub resolver, in a recursive resolver, or
          in an authoritative name server.
</p>
<p>The implementation SHOULD support mapping of separate IPv4 address
          ranges to separate IPv6 prefixes for AAAA record
          synthesis. This allows handling of special use IPv4
          addresses <a class='info' href='#RFC5735'>[RFC5735]<span> (</span><span class='info'>Cotton, M. and L. Vegoda, &ldquo;Special Use IPv4 Addresses,&rdquo; January&nbsp;2010.</span><span>)</span></a>. Support of multicast address
          handling is out of the scope of this document. A possible approach is specified in
          <a class='info' href='#I-D.venaas-behave-mcast46'>[I&#8209;D.venaas&#8209;behave&#8209;mcast46]<span> (</span><span class='info'>Venaas, S., Asaeda, H., SUZUKI, S., and T. Fujisaki, &ldquo;An IPv4 - IPv6 multicast translator,&rdquo; July&nbsp;2009.</span><span>)</span></a>.
</p>
<p>DNS64 also responds to PTR queries involving 
			addresses containing any of the IPv6 prefixes it uses for synthesis of AAAA RRs.
</p>
<a name="anchor3"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.1"></a><h3>5.1.&nbsp;
Resolving AAAA queries and the answer section</h3>

<p>When the DNS64 receives a query for RRs of type AAAA
            and class IN, it first attempts to retrieve non-synthetic
            RRs of this type and class, either by performing a query
            or, in the case of an authoritative server, by examining
            its own results.  DNS64 operation for classes other than IN
            is undefined, and a DNS64 MUST behave as though no DNS64
            function is configured.
</p>
<a name="anchor4"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.1.1"></a><h3>5.1.1.&nbsp;
The answer when there is AAAA data
                            available</h3>

<p>If the query results in one or more AAAA records in
              the answer section, the result is returned to the
              requesting client as per normal DNS semantics, except in
              the case where any of the AAAA records match a special
              exclusion set of prefixes, considered in <a class='info' href='#exclusion_set'>Section&nbsp;5.1.4<span> (</span><span class='info'>Special exclusion set for AAAA records</span><span>)</span></a>.  If there is (non-excluded)
              AAAA data available, DNS64 SHOULD NOT include synthetic
              AAAA RRs in the response (see <a class='info' href='#always-synth'>Appendix&nbsp;A<span> (</span><span class='info'>Motivations and Implications of synthesizing AAAA Resource Records when real AAAA Resource Records exist</span><span>)</span></a> for an analysis of the
              motivations for and the implications of not complying
              with this recommendation).  By default DNS64
              implementations MUST NOT synthesize AAAA RRs when real
              AAAA RRs exist.
</p>
<a name="aaaa_error"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.1.2"></a><h3>5.1.2.&nbsp;
The answer when there is an error</h3>

<p>If the query results in a response with RCODE other
              than 0 (No error condition), then there are two
              possibilities.  A result with RCODE=3 (Name Error) is
              handled according to normal DNS operation (which is
              normally to return the error to the client).  This stage
              is still prior to any synthesis having happened, so a
              response to be returned to the client does not need any
              special assembly than would usually happen in DNS
              operation.
</p>
<p>Any other RCODE is treated as though the RCODE were 0
              and the answer section were empty.  This is because of
              the large number of different responses from deployed
              name servers when they receive AAAA queries without a
              AAAA record being available.
</p>
<p>It is important to note that, as of this writing,
              some servers respond with RCODE=3 to a AAAA query even
              if there is an A record available for that owner name.
              Those servers are in clear violation of the meaning of
              RCODE 3, and it is expected that they will decline in
              use as IPv6 deployment increases.
</p>
<a name="anchor5"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.1.3"></a><h3>5.1.3.&nbsp;
Dealing with timeouts</h3>

<p>If the query receives no answer before the timeout,
              it is treated as RCODE=2 (Server failure).
</p>
<a name="exclusion_set"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.1.4"></a><h3>5.1.4.&nbsp;
Special exclusion set for AAAA records</h3>

<p> Some IPv6 addresses are not actually usable by
              IPv6-only hosts.  If they are returned to IPv6-only
              querying agents as AAAA records, therefore, the goal of
              decreasing the number of failure modes will not be
              attained.  Examples include AAAA records with addresses
              in the ::ffff:0:0/96 network, and possibly (depending on the
              context) AAAA records with the site's Pref::64/n or the
              Well-Known Prefix (see below for more about the Well-Known 
			  Prefix).  A DNS64 implementation SHOULD
              provide a mechanism to specify IPv6 prefix ranges to be
              treated as though the AAAA containing them were an empty
              answer.  An implementation SHOULD include the ::ffff/96
              network in that range by default.  Failure to provide
              this facility will mean that clients querying the DNS64
              function may not be able to communicate with hosts that
              would be reachable from a dual-stack host.
</p>
<p>When the DNS64 performs its initial AAAA query, if it
              receives an answer with only AAAA records containing
              addresses in the excluded range(s), then it MUST treat the
              answer as though it were an empty answer, and proceed
              accordingly.  If it receives an answer with at least one
              AAAA record containing an address outside any of the
              excluded range(s), then it MAY build an answer section for a
              response including only the AAAA record(s) that do not
              contain any of the addresses inside the excluded ranges.
              That answer section is used in the assembly of a
              response as detailed in <a class='info' href='#assembly'>Section&nbsp;5.4<span> (</span><span class='info'>Assembling a synthesized response to a                             AAAA query</span><span>)</span></a>.
              Alternatively, it MAY treat the answer as though it were
              an empty answer, and proceed accordingly.  It MUST NOT
              return the offending AAAA records as part of a
              response.
</p>
<a name="cname_dname"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.1.5"></a><h3>5.1.5.&nbsp;
Dealing with CNAME and DNAME</h3>

<p>If the response contains a CNAME or a DNAME, then the
              CNAME or DNAME chain is followed until the first
              terminating A or AAAA record is reached.  This may
              require the DNS64 to ask for an A record, in case the
              response to the original AAAA query is a CNAME or DNAME
              without a AAAA record to follow.  The resulting AAAA or
              A record is treated like any other AAAA or A case, as
              appropriate.
</p>
<p>When assembling the answer section, the original
              CNAME or DNAME RR is included as part of the answer, and
              the synthetic AAAA, if appropriate, is included.
</p>
<a name="anchor6"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.1.6"></a><h3>5.1.6.&nbsp;
Data for the answer when performing synthesis</h3>

<p>If the query results in no error but an empty answer
              section in the response, the DNS64 attempts to retrieve
              A records for the name in question, either by performing
              another query or, in the case of an authoritative
              server, by examining its own results. If this new A RR
              query results in an empty answer or in an error, then
              the empty result or error is used as the basis for the
              answer returned to the querying client.  (Transient
              errors may result in retrying the query, depending on
              the mode and operation of the underlying resolver; this
              is just as in <a class='info' href='#aaaa_error'>Section&nbsp;5.1.2<span> (</span><span class='info'>The answer when there is an error</span><span>)</span></a>.)  If instead
              the query results in one or more A RRs, the DNS64
              synthesizes AAAA RRs based on the A RRs according to the
              procedure outlined in <a class='info' href='#syntheticans'>Section&nbsp;5.1.7<span> (</span><span class='info'>Performing the synthesis</span><span>)</span></a>. The DNS64 returns the synthesized AAAA records in
              the answer section, removing the A records that form the
              basis of the synthesis.
</p>
<a name="syntheticans"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.1.7"></a><h3>5.1.7.&nbsp;
Performing the synthesis</h3>

<p>A synthetic AAAA record is created from an A record as
              follows:</p>
<ul class="text">
<li>The NAME field is set to the NAME field from the A record
</li>
<li>The TYPE field is set to 28 (AAAA)
</li>
<li>The CLASS field is set to the original CLASS field,
              1.  Under this specification, DNS64 for any CLASS other
              than 1 is undefined.
</li>
<li>The TTL field is set to the minimum of the TTL of the
              original A RR and the SOA RR for the queried
              domain. (Note that in order to obtain the TTL of the SOA
              RR, the DNS64 does not need to perform a new query, but
              it can remember the TTL from the SOA RR in the negative
              response to the AAAA query.  If the SOA RR was not
              delivered with the negative response to the AAAA query,
              then the DNS64 SHOULD use a default value of 600
              seconds.  It is possible instead to query explicitly for
              the SOA RR and use the result of that query, but this
              will increase query load and time to resolution for
              little additional benefit.)
</li>
<li>The RDLENGTH field is set to 16
</li>
<li>The RDATA field is set to the IPv6 representation of
              the IPv4 address from the RDATA field of the A record.
              The DNS64 SHOULD check each A RR against configured IPv4 address
              ranges and select the corresponding IPv6 prefix to use in
              synthesizing the AAAA RR.  See <a class='info' href='#address-transform'>Section&nbsp;5.2<span> (</span><span class='info'>Generation of the IPv6 representations of IPv4 addresses</span><span>)</span></a> for discussion of the
              algorithms to be used in effecting the transformation.
</li>
</ul>

<a name="anchor7"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.1.8"></a><h3>5.1.8.&nbsp;
Querying in parallel</h3>

<p>The DNS64 MAY perform the query for the AAAA RR and for
              the A RR in parallel, in order to minimize the
              delay. However, this would result in performing
              unnecessary A RR queries in the case where no AAAA RR
              synthesis is required. A possible trade-off would be to
              perform them sequentially but with a very short interval
              between them, so if we obtain a fast reply, we avoid
              doing the additional query. (Note that this discussion
              is relevant only if the DNS64 function needs to perform
              external queries to fetch the RR. If the needed RR
              information is available locally, as in the case of an
              authoritative server, the issue is no longer
              relevant.)
</p>
<a name="address-transform"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.2"></a><h3>5.2.&nbsp;
Generation of the IPv6 representations of IPv4 addresses</h3>

<p>DNS64 supports multiple algorithms for the generation of
            the IPv6 representation of an IPv4 address.  The
            constraints imposed on the generation algorithms are the
            following:
				</p>
<blockquote class="text">
<p>The same algorithm to create an IPv6 address from
                  an IPv4 address MUST be used by both a DNS64 to
                  create the IPv6 address to be returned in the
                  synthetic AAAA RR from the IPv4 address contained in
                  an original A RR, and by a IPv6/IPv4 translator to
                  create the IPv6 address to be included in the
                  source address field of the outgoing IPv6
                  packets from the IPv4 address included in the
                  source address field of the incoming IPv4
                  packet.
</p>
<p>The algorithm MUST be reversible; i.e., it MUST be
                  possible to derive the original IPv4 address from
                  the IPv6 representation. 
</p>
<p>The input for the algorithm MUST be limited to
                  the IPv4 address, the IPv6 prefix (denoted
                  Pref64::/n) used in the IPv6 representations and
                  optionally a set of stable parameters that are
                  configured in the DNS64 and in the NAT64 (such as fixed string to be
                  used as a suffix).
                  </p>
<blockquote class="text">
<p> For each prefix Pref64::/n, n MUST the less
                    than or equal to 96.  If one or more Pref64::/n
                    are configured in the DNS64 through any means
                    (such as manually configured, or other automatic
                    means not specified in this document), the default
                    algorithm MUST use these prefixes (and not use the
                    Well-Known Prefix).  If no prefix is available,
                    the algorithm MUST use the Well-Known Prefix
                    64:FF9B::/96 defined in <a class='info' href='#I-D.ietf-behave-address-format'>[I&#8209;D.ietf&#8209;behave&#8209;address&#8209;format]<span> (</span><span class='info'>Bao, C., Huitema, C., Bagnulo, M., Boucadair, M., and X. Li, &ldquo;IPv6 Addressing of IPv4/IPv6 Translators,&rdquo; April&nbsp;2010.</span><span>)</span></a> to
                    represent the IPv4 unicast address range
</p>
</blockquote>
<a class='info' href='#comment.anchor8'>[anchor8]<span> (</span><span class='info'>Note in document: The value 64:FF9B::/96 is proposed as the value for the Well-Known prefix and needs to be confirmed whenis published as RFC.</span><span>)</span></a><a name='anchor8'></a><a class='info' href='#I-D.ietf-behave-address-format'>[I&#8209;D.ietf&#8209;behave&#8209;address&#8209;format]<span> (</span><span class='info'>Bao, C., Huitema, C., Bagnulo, M., Boucadair, M., and X. Li, &ldquo;IPv6 Addressing of IPv4/IPv6 Translators,&rdquo; April&nbsp;2010.</span><span>)</span></a>
</blockquote>

<p>A DNS64 MUST support the algorithm for
            generating IPv6 representations of IPv4 addresses defined in Section 2 of
            <a class='info' href='#I-D.ietf-behave-address-format'>[I&#8209;D.ietf&#8209;behave&#8209;address&#8209;format]<span> (</span><span class='info'>Bao, C., Huitema, C., Bagnulo, M., Boucadair, M., and X. Li, &ldquo;IPv6 Addressing of IPv4/IPv6 Translators,&rdquo; April&nbsp;2010.</span><span>)</span></a>. Moreover, the aforementioned algorithm MUST be the default algorithm used by the DNS64. While the normative description of the algorithm is provided in 
            <a class='info' href='#I-D.ietf-behave-address-format'>[I&#8209;D.ietf&#8209;behave&#8209;address&#8209;format]<span> (</span><span class='info'>Bao, C., Huitema, C., Bagnulo, M., Boucadair, M., and X. Li, &ldquo;IPv6 Addressing of IPv4/IPv6 Translators,&rdquo; April&nbsp;2010.</span><span>)</span></a>, a sample description of the algorithm and its application to 
            different scenarios is provided in <a class='info' href='#examples'>Section&nbsp;7<span> (</span><span class='info'>Deployment scenarios and examples</span><span>)</span></a> for illustration purposes. 
</p>
<a name="anchor9"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.3"></a><h3>5.3.&nbsp;
Handling other Resource Records and the Additional Section</h3>

<a name="anchor10"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.3.1"></a><h3>5.3.1.&nbsp;
PTR Resource Record</h3>

<p>If a DNS64 server receives a PTR query for a
             record in the IP6.ARPA domain, it MUST strip the IP6.ARPA
             labels from the QNAME, reverse the address portion of the
             QNAME according to the encoding scheme outlined in
             section 2.5 of <a class='info' href='#RFC3596'>[RFC3596]<span> (</span><span class='info'>Thomson, S., Huitema, C., Ksinant, V., and M. Souissi, &ldquo;DNS Extensions to Support IP Version 6,&rdquo; October&nbsp;2003.</span><span>)</span></a>, and examine
             the resulting address to see whether its prefix matches
             any of the locally-configured Pref64::/n.  There are two
             alternatives for a DNS64 server to respond to such
             PTR queries.  A DNS64 server MUST provide one of these, and
             SHOULD NOT provide both at the same time unless different
             IP6.ARPA zones require answers of different sorts:
</p>
<ol class="text">
<li>The first option is for the DNS64 server to
             respond authoritatively for its prefixes.  If the address
             prefix matches any Pref64::/n used in the site, either a
             NSP or the Well-Known Prefix (i.e. 64:FF9B::/96), then
             the DNS64 server MAY answer the query using
             locally-appropriate RDATA.  The DNS64 server MAY use the
             same RDATA for all answers.  Note that the requirement is
             to match any Pref64::/n used at the site, and not merely
             the locally-configured Pref64::/n.  This is because end
             clients could ask for a PTR record matching an address
             received through a different (site-provided) DNS64, and
             if this strategy is in effect, those queries should never
             be sent to the global DNS. The advantage of this strategy
             is that it makes plain to the querying client that the
             prefix is one operated by the (DNS64) site, and that the
             answers the client is getting are generated by DNS64.
             The disadvantage is that any useful reverse-tree
             information that might be in the global DNS is
             unavailable to the clients querying the DNS64.
</li>
<li>The second option is for the DNS64 nameserver to
             synthesize a CNAME mapping the IP6.ARPA namespace to the
             corresponding IN-ADDR.ARPA name.  The rest of the
             response would be the normal DNS processing.  The CNAME
             can be signed on the fly if need be.  The advantage of
             this approach is that any useful information in the
             reverse tree is available to the querying client.  The
             disadvantage is that it adds additional load to the DNS64
             (because CNAMEs have to be synthesized for each PTR query
             that matches the Pref64::/n), and that it may require
             signing on the fly.  In addition, the generated CNAME
             could correspond to an unpopulated in-addr.arpa zone, so
             the CNAME would provide a reference to a non-existent
             record.
</li>
</ol>
<p>If the address prefix does not match any 
             Pref64::/n, then the DNS64 server MUST process the query
             as though it were any other query; i.e. a recursive
             nameserver MUST attempt to resolve the query as though it
             were any other (non-A/AAAA) query, and an authoritative
             server MUST respond authoritatively or with a referral,
             as appropriate.
</p>
<a name="addl_sec"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.3.2"></a><h3>5.3.2.&nbsp;
Handling the additional section</h3>

<p>DNS64 synthesis MUST NOT be performed on any records
             in the additional section of synthesized answers.  The
             DNS64 MUST pass the additional section unchanged.
</p>
<p>It may appear that adding synthetic records to the
             additional section is desirable, because clients
             sometimes use the data in the additional section to
             proceed without having to re-query.  There is in general
             no promise, however, that the additional section will
             contain all the relevant records, so any client that
             depends on the additional section being able to satisfy
             its needs (i.e. without additional queries) is
             necessarily broken.  An IPv6-only client that needs a
             AAAA record, therefore, will send a query for the
             necessary AAAA record if it is unable to find such a
             record in the additional section of an answer it is
             consuming.  For a correctly-functioning client, the
             effect would be no different if the additional section
             were empty.
</p>
<p>The alternative, of removing the A records in the
             additional section and replacing them with synthetic AAAA
             records, may cause a host behind a NAT64 to query
             directly a nameserver that is unaware of the NAT64 in
             question.  The result in this case will be resolution
             failure anyway, only later in the resolution operation.
</p>
<a name="anchor11"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.3.3"></a><h3>5.3.3.&nbsp;
Other Resource Records</h3>

<p>If the DNS64 is in recursive resolver mode, then
              considerations outlined in <a class='info' href='#I-D.ietf-dnsop-default-local-zones'>[I&#8209;D.ietf&#8209;dnsop&#8209;default&#8209;local&#8209;zones]<span> (</span><span class='info'>Andrews, M., &ldquo;Locally-served DNS Zones,&rdquo; April&nbsp;2010.</span><span>)</span></a> may be
              relevant.
</p>
<p>All other RRs MUST be returned unchanged.  This
              includes responses to queries for A RRs.
</p>
<a name="assembly"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.4"></a><h3>5.4.&nbsp;
Assembling a synthesized response to a
                            AAAA query</h3>

<p>A DNS64 uses different pieces of data to build the
              response returned to the querying client.  
</p>
<p>The query that is used as the basis for synthesis
              results either in an error, an answer that can be used
              as a basis for synthesis, or an empty (authoritative)
              answer.  If there is an empty answer, then the DNS64
              responds to the original querying client with the answer
              the DNS64 received to the original (initiator's) query.
              Otherwise, the response is assembled as follows.
</p>
<p>The header fields are set according to the usual
              rules for recursive or authoritative servers, depending
              on the role that the DNS64 is serving.  The question
              section is copied from the original (initiator's) query.
              The answer section is populated according to the rules
              in <a class='info' href='#syntheticans'>Section&nbsp;5.1.7<span> (</span><span class='info'>Performing the synthesis</span><span>)</span></a>.  The authority and
              additional sections are copied from the response to the
              final query that the DNS64 performed, and used as the
              basis for synthesis.
</p>
<a name="dnssec64rec"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.5"></a><h3>5.5.&nbsp;
DNSSEC processing: DNS64 in recursive resolver mode</h3>

<p>We consider the case where a recursive resolver that is
            performing DNS64 also has a local policy to validate the
            answers according to the procedures outlined in <a class='info' href='#RFC4035'>[RFC4035]<span> (</span><span class='info'>Arends, R., Austein, R., Larson, M., Massey, D., and S. Rose, &ldquo;Protocol Modifications for the DNS Security Extensions,&rdquo; March&nbsp;2005.</span><span>)</span></a> Section 5.  We call this general case
            vDNS64.
</p>
<p>The vDNS64 uses the presence of the DO and CD bits to
            make some decisions about what the query originator needs,
            and can react accordingly:
            </p>
<ol class="text">
<li>If CD is not set and DO is not set, vDNS64 SHOULD
              perform validation and do synthesis as needed.  See the
              next item for rules about how to do validation and
              synthesis.  In this case, however, vDNS64 MUST NOT set
              the AD bit in any response.							
              
              
              
</li>
<li>If CD is not set and DO is set, then vDNS64 SHOULD
              perform validation.   Whenever
              vDNS64 performs validation, it MUST validate the
              negative answer for AAAA queries before proceeding to
              query for A records for the same name, in order to be
              sure that there is not a legitimate AAAA record on the
              Internet.  Failing to observe this step would allow an
              attacker to use DNS64 as a mechanism to circumvent
              DNSSEC.  If the negative response validates, and the
              response to the A query validates, then the vDNS64 MAY
              perform synthesis and SHOULD set the AD bit in the
              answer to the client.  This is acceptable, because <a class='info' href='#RFC4035'>[RFC4035]<span> (</span><span class='info'>Arends, R., Austein, R., Larson, M., Massey, D., and S. Rose, &ldquo;Protocol Modifications for the DNS Security Extensions,&rdquo; March&nbsp;2005.</span><span>)</span></a>, section 3.2.3 says that the AD bit
              is set by the name server side of a security-aware
              recursive name server if and only if it considers all
              the RRSets in the Answer and Authority sections to be
              authentic.  In this case, the name server has reason to
              believe the RRSets are all authentic, so it SHOULD set
              the AD bit.  If the data does not validate, the vDNS64
              MUST respond with RCODE=2 (Server failure).
              <br />

              A security-aware end point might take the presence of
              the AD bit as an indication that the data is valid, and
              may pass the DNS (and DNSSEC) data to an application.
              If the application attempts to validate the synthesized
              data, of course, the validation will fail.  One could
              argue therefore that this approach is not desirable,
              but security aware stub resolvers must not place any
              reliance on data received from resolvers and validated
              on their behalf without certain criteria established by
              <a class='info' href='#RFC4035'>[RFC4035]<span> (</span><span class='info'>Arends, R., Austein, R., Larson, M., Massey, D., and S. Rose, &ldquo;Protocol Modifications for the DNS Security Extensions,&rdquo; March&nbsp;2005.</span><span>)</span></a>, section 4.9.3.  An
              application that wants to perform validation on its own
              should use the CD bit.
</li>
<li>If the CD bit is set and DO is set, then vDNS64 MAY
              perform validation, but MUST NOT perform synthesis.  It
              MUST return the data to the query initiator, just like a
              regular recursive resolver, and depend on the client to
              do the validation and the synthesis itself.
              <br />

              The disadvantage to this approach is that an end point
              that is translation-oblivious but security-aware and
              validating will not be able to use the DNS64
              functionality.  In this case, the end point will not
              have the desired benefit of NAT64.  In effect, this
              strategy means that any end point that wishes to do
              validation in a NAT64 context must be upgraded to be
              translation-aware as well.
</li>
</ol>

<a name="anchor12"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6"></a><h3>6.&nbsp;
Deployment notes</h3>

<p>While DNS64 is intended to be part of a strategy for
          aiding IPv6 deployment in an internetworking environment
          with some IPv4-only and IPv6-only networks, it is important
          to realise that it is incompatible with some things that may
          be deployed in an IPv4-only or dual-stack context.
</p>
<a name="anchor13"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.1"></a><h3>6.1.&nbsp;
DNS resolvers and DNS64</h3>

<p>Full-service resolvers that are unaware of the DNS64
            function can be (mis)configured to act as mixed-mode
            iterative and forwarding resolvers.  In a native IPv4
            context, this sort of configuration may appear to work.
            It is impossible to make it work properly without it being
            aware of the DNS64 function, because it will likely at
            some point obtain IPv4-only glue records and attempt to
            use them for resolution.  The result that is returned will
            contain only A records, and without the ability to perform
            the DNS64 function the resolver will be unable to answer
            the necessary AAAA queries.
</p>
<a name="valanddns64"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.2"></a><h3>6.2.&nbsp;
DNSSEC validators and DNS64</h3>

<p>Existing DNSSEC validators (i.e. that are unaware of
            DNS64) might reject all the data that comes from DNS64 as
            having been tampered with (even if it did not set CD when
            querying).  If it is necessary to have validation behind
            the DNS64, then the validator must know how to perform the
            DNS64 function itself.  Alternatively, the validating host
            may establish a trusted connection with a DNS64, and allow
            the DNS64 recursor to do all validation on its behalf.
</p>
<a name="anchor14"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.3"></a><h3>6.3.&nbsp;
DNS64 and multihomed and dual-stack hosts</h3>

<a name="anchor15"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.3.1"></a><h3>6.3.1.&nbsp;
IPv6 multihomed hosts</h3>

<p>Synthetic AAAA records may be constructed on the
              basis of the network context in which they were
              constructed.  If a host sends DNS queries to resolvers
              in multiple networks, it is possible that some of them
              will receive answers from a DNS64 without all of them
              being connected via a NAT64.  For instance, suppose a
              system has two interfaces, i1 and i2.  Whereas i1 is
              connected to the IPv4 Internet via NAT64, i2 has native
              IPv6 connectivity only.  I1 might receive a AAAA answer
              from a DNS64 that is configured for a particular NAT64;
              the IPv6 address contained in that AAAA answer will not
              connect with anything via i2.
</p><div style='display: table; width: 0; margin-left: auto; margin-right: auto'><pre>
+---------------+                 +-------------+
|      i1 (IPv6)+----NAT64--------+IPv4 Internet|
|               |                 +-------------+
| host          |
|               |                 +-------------+
|      i2 (IPv6)+-----------------+IPv6 Internet|
+---------------+                 +-------------+
</pre></div>
<p>This example illustrates why it is generally
              preferable that hosts treat DNS answers from one
              interface as local to that interface.  The answer
              received on one interface will not work on the other
              interface.  Hosts that attempt to use DNS answers
              globally may encounter surprising failures in these
              cases.  For more discussion of this topic, see <a class='info' href='#I-D.savolainen-mif-dns-server-selection'>[I&#8209;D.savolainen&#8209;mif&#8209;dns&#8209;server&#8209;selection]<span> (</span><span class='info'>Savolainen, T., &ldquo;DNS Server Selection on Multi-Homed Hosts,&rdquo; February&nbsp;2010.</span><span>)</span></a>.
</p>
<p>Note that the issue is not that there are two
              interfaces, but that there are two networks involved.
              The same results could be achieved with a single
              interface routed to two different networks.
</p>
<a name="anchor16"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.3.2"></a><h3>6.3.2.&nbsp;
Accidental dual-stack DNS64 use</h3>

<p> Similarly, suppose that i1 has IPv6 connectivity and
              can connect to the IPv4 Internet through NAT64, but i2
              has native IPv4 connectivity.  In this case, i1 could receive
              an IPv6 address from a synthetic AAAA that would better
              be reached via native IPv4.  Again, it is worth
              emphasising that this arises because there are two
              networks involved.
</p><div style='display: table; width: 0; margin-left: auto; margin-right: auto'><pre>
+---------------+                 +-------------+
|      i1 (IPv6)+----NAT64--------+IPv4 Internet|
|               |                 +-------------+
| host          |
|               |                 +-------------+
|      i2 (IPv4)+-----------------+IPv4 Internet|
+---------------+                 +-------------+
</pre></div>
<p>The default configuration of dual-stack hosts is that
              IPv6 is preferred over IPv4 (<a class='info' href='#RFC3484'>[RFC3484]<span> (</span><span class='info'>Draves, R., &ldquo;Default Address Selection for Internet Protocol version 6 (IPv6),&rdquo; February&nbsp;2003.</span><span>)</span></a>).   
              In that arrangement the host will often use the NAT64
              when native IPv4 would be more desirable.  For this reason,
              hosts with IPv4 connectivity to the Internet should
              avoid using DNS64.  This can be partly resolved by ISPs
              when providing DNS resolvers to clients, but that is not
              a guarantee that the NAT64 will never be used when a
              native IPv4 connection should be used.  There is no
              general-purpose mechanism to ensure that native IPv4
              transit will always be preferred, because to a
              DNS64-oblivious host, the DNS64 looks just like an
              ordinary DNS server.  Operators of a NAT64 should expect
              traffic to pass through the NAT64 even when it is not
              necessary.
</p>
<a name="anchor17"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.3.3"></a><h3>6.3.3.&nbsp;
Intentional dual-stack DNS64 use</h3>

<p>Finally, consider the case where the IPv4
              connectivity on i2 is only with a LAN, and not with the
              IPv4 Internet.  The IPv4 Internet is only accessible
              using the NAT64.  In this case, it is critical that the
              DNS64 not synthesize AAAA responses for hosts in the
              LAN, or else that the DNS64 be aware of hosts in the LAN
              and provide context-sensitive answers ("split view" DNS
              answers) for hosts inside the LAN.  As with any split
              view DNS arrangement, operators must be prepared for
              data to leak from one context to another, and for
              failures to occur because nodes accessible from one
              context are not accessible from the other.
</p><div style='display: table; width: 0; margin-left: auto; margin-right: auto'><pre>
+---------------+                 +-------------+
|      i1 (IPv6)+----NAT64--------+IPv4 Internet|
|               |                 +-------------+
| host          |
|               |
|      i2 (IPv4)+---(local LAN only)
+---------------+
</pre></div>
<p>It is important for deployers of DNS64 to realise that, in some
			circumstances, making the DNS64 available to a dual-stack host
			will cause the host to prefer to send packets via NAT64 instead of
			via native IPv4, with the associated loss of performance or
			functionality (or both) entailed by the NAT.  At the same time,
			some hosts are not able to learn about DNS servers provisioned on
			IPv6 addresses, or simply cannot send DNS packets over IPv6.
</p>
<a name="examples"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7"></a><h3>7.&nbsp;
Deployment scenarios and examples</h3>

<p>In this section, we walk through some sample scenarios that are expected to be common deployment cases. 
					It should be noted that this is provided for illustrative purposes and this section is not normative. 
					The normative definition of DNS64 is provided in <a class='info' href='#normative'>Section&nbsp;5<span> (</span><span class='info'>DNS64 Normative Specification</span><span>)</span></a>  and the normative definition
					of the address transformation algorithm is provided in <a class='info' href='#I-D.ietf-behave-address-format'>[I&#8209;D.ietf&#8209;behave&#8209;address&#8209;format]<span> (</span><span class='info'>Bao, C., Huitema, C., Bagnulo, M., Boucadair, M., and X. Li, &ldquo;IPv6 Addressing of IPv4/IPv6 Translators,&rdquo; April&nbsp;2010.</span><span>)</span></a>.
</p>
<p>There are two main different setups where DNS64 is expected 
							to be used (other setups are possible as well, but these two are the main
							ones identified at the time of this writing).
							</p>
<blockquote class="text">
<p>One possible setup that is expected to be common is the case of an end site
							or an ISP that is providing IPv6-only connectivity or connectivity to IPv6-only 
							hosts that wants to allow the communication from these IPv6-only connected 
							hosts to the IPv4 Internet. This case is called An-IPv6-network-to-IPv4-Internet <a class='info' href='#I-D.ietf-behave-v6v4-framework'>[I&#8209;D.ietf&#8209;behave&#8209;v6v4&#8209;framework]<span> (</span><span class='info'>Baker, F., Li, X., Bao, C., and K. Yin, &ldquo;Framework for IPv4/IPv6 Translation,&rdquo; March&nbsp;2010.</span><span>)</span></a>.
							In this case, the IPv6/IPv4 translator is used to connect the end site or the ISP to the IPv4
							Internet and the DNS64 function is provided by the end site or the ISP.
</p>
<p>The other possible setup that is expected is an IPv4 site that wants that 
								its IPv4 servers to be reachable from the IPv6 Internet. This case
								is called IPv6-Internet-to-an-IPv4-network <a class='info' href='#I-D.ietf-behave-v6v4-framework'>[I&#8209;D.ietf&#8209;behave&#8209;v6v4&#8209;framework]<span> (</span><span class='info'>Baker, F., Li, X., Bao, C., and K. Yin, &ldquo;Framework for IPv4/IPv6 Translation,&rdquo; March&nbsp;2010.</span><span>)</span></a>. It should be noted that
								the IPv4 addresses used in the  IPv4 site can be either public or private.
							    In this case, the IPv6/IPv4 translator is used to connect the IPv4 end site to the IPv6
								Internet and the DNS64 function is provided by the IPv4 end
				                site itself.	
</p>
</blockquote>

<p>In this section we illustrate how the DNS64 behaves in the different scenarios
							that are expected to be common. We consider then 3 possible scenarios, namely:
							</p>
<ol class="text">
<li>An-IPv6-network-to-IPv4-Internet setup with DNS64 in DNS server mode
</li>
<li>An-IPv6-network-to-IPv4-Internet setup with DNS64 in stub-resolver mode
</li>
<li>IPv6-Internet-to-an-IPv4-network setup with DNS64 in DNS server mode
</li>
</ol>

<a name="anchor18"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.1"></a><h3>7.1.&nbsp;
Example of An-IPv6-network-to-IPv4-Internet setup with DNS64 in DNS server mode</h3>

<p>In this example, we consider an IPv6 node located in an IPv6-only
			        site that initiates a communication to an IPv4 node located in the IPv4
			        Internet. 
</p>
<p>The scenario for this case is depicted in the following figure:
</p>
<p>
</p><div style='display: table; width: 0; margin-left: auto; margin-right: auto'><pre>
+---------------------+         +---------------+
|IPv6 network         |         |    IPv4       |
|           |  +-------------+  |  Network      |
|           |--| Name server |--|               |
|           |  | with DNS64  |  |  +----+       |
|  +----+   |  +-------------+  |  | H2 |       |
|  | H1 |---|         |         |  +----+       |
|  +----+   |      +-------+    |  192.0.2.1    |
|           |------| NAT64 |----|               |
|           |      +-------+    |               |
|           |         |         |               |
+---------------------+         +---------------+
</pre></div>
<p>
</p>
<p>The figure shows an IPv6 node H1 and an
			        IPv4 node H2 with IPv4 address 192.0.2.1 and FQDN h2.example.com
</p>
<p>A IPv6/IPv4 Translator connects the IPv6 network to the IPv4 Internet. This IPv6/IPv4 Translator has
			        an IPv4 address 203.0.113.1 assigned to its IPv4 interface and it is using the WKP 64:FF9B::/96 to 
					create IPv6 representations of IPv4 addresses, as defined in <a class='info' href='#I-D.ietf-behave-address-format'>[I&#8209;D.ietf&#8209;behave&#8209;address&#8209;format]<span> (</span><span class='info'>Bao, C., Huitema, C., Bagnulo, M., Boucadair, M., and X. Li, &ldquo;IPv6 Addressing of IPv4/IPv6 Translators,&rdquo; April&nbsp;2010.</span><span>)</span></a>.
</p>
<p>The other element involved is the local name server.  The name server
				   is a dual-stack node, so that H1 can
				   contact it via IPv6, while it can contact IPv4-only name servers via
				   IPv4.
</p>
<p>The local name server is configured to represent the whole IPv4 unicast space with 
						using the WKP 64:FF9B::/96. For the purpose of this example, we assume
			        it learns this through manual configuration.
</p>
<p>For this example, assume the typical DNS situation where IPv6 hosts
			        have only stub resolvers, and they are configured with the IP address of a name server that they always have to query and that performs recursive
			        lookups (henceforth called "the recursive nameserver").
</p>
<p>The steps by which H1 establishes communication with H2 are: </p>
<ol class="text">
<li>H1 does a DNS lookup for h2.example.com. H1 does this
			            by sending a DNS query for a AAAA record for H2 to the recursive name
			            server. The recursive name server implements 
				    	DNS64 functionality.
</li>
<li>The recursive name server resolves the query, and discovers that
			            there are no AAAA records for H2.
</li>
<li>The recursive name server queries for A records for H2 and gets back 
			            a single A records containing the IPv4 address 192.0.2.1. The name server then
			            synthesizes a AAAA records. The IPv6 address in the AAAA record
			            contains the prefix assigned to the IPv6/IPv4 Translator in the upper 96 bits then
			            the received IPv4 address i.e. the resulting IPv6 address is 64:FF9B::192.0.2.1
</li>
<li>H1 receives the synthetic AAAA record and sends a packet
			            towards H2. The packet is sent to the destination address 64:FF9B::192.0.2.1.
</li>
<li>The packet is routed to the IPv6 interface of the IPv6/IPv4 translator and the
							subsequent communication flows by means of the IPv6/IPv4 translator mechanisms.
</li>
</ol>

<a name="anchor19"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.2"></a><h3>7.2.&nbsp;
An example of an-IPv6-network-to-IPv4-Internet setup with DNS64 in stub-resolver mode</h3>

<p>This case is depicted in the following figure:
</p>
<p>
</p><div style='display: table; width: 0; margin-left: auto; margin-right: auto'><pre>
+---------------------+         +---------------+
|IPv6 network         |         |    IPv4       |
|           |     +--------+    |  Network      |
|           |-----| Name   |----|               |
| +-----+   |     | server |    |  +----+       |
| | H1  |   |     +--------+    |  | H2 |       |
| |with |---|         |         |  +----+       |
| |DNS64|   |      +-------+    |  192.0.2.1    |
| +----+    |------| NAT64 |----|               |
|           |      +-------+    |               |
|           |         |         |               |
+---------------------+         +---------------+

</pre></div>
<p>
</p>
<p>The figure shows an IPv6 node H1 implementing the DNS64 function and an
					        IPv4 node H2 with IPv4 address 192.0.2.1 and FQDN h2.example.com 
</p>
<p>A IPv6/IPv4 Translator connects the IPv6 network to the IPv4 Internet. This IPv6/IPv4 Translator
					        is using the WKP 64:FF9B::/96 and an
					        IPv4 address T 203.0.113.1 assigned to its IPv4 interface.
</p>
<p>H1 needs to know the prefix assigned to the
					        local IPv6/IPv4 Translator (64:FF9B::/96). For the purpose of this example, we assume
					        it learns this through manual configuration.
</p>
<p>Also shown is a name server. For the purpose of
					        this example, we assume that the name server is a
					        dual-stack node, so that H1 can contact it via IPv6,
					        while it can contact IPv4-only name servers via
					        IPv4.
</p>
<p>For this example, assume the typical situation where IPv6 hosts
					        have only stub resolvers and always query a name
			                server that provides recursive lookups (henceforth
			                called "the recursive name server").
							The recursive name server does not perform the DNS64 
							function. 
							
</p>
<p>The steps by which H1 establishes communication with H2 are: </p>
<ol class="text">
<li>H1 does a DNS lookup for h2.example.com. H1 does this
					            by sending a DNS query for a AAAA record for H2 to the recursive name
					            server.
</li>
<li>The recursive DNS server resolves the query,
			                    and returns the answer to H1.  Because there are
			                    no AAAA records in the global DNS for H2, the
			                    answer is empty.
</li>
<li>The stub resolver at H1 then queries for an A record for H2 and gets back an
					            A record containing the IPv4 address 192.0.2.1. The DNS64 function within H1 then
					            synthesizes a AAAA record. The IPv6 address in the AAAA record
					            contains the prefix assigned to the IPv6/IPv4 translator in the upper 96 bits, then
					            the received IPv4 address  i.e. the resulting IPv6 address is 64:FF9B::192.0.2.1.
</li>
<li>H1 sends a packet
					            towards H2. The packet is sent to the destination address 64:FF9B::192.0.2.1.
</li>
<li>The packet is routed to the IPv6 interface of the IPv6/IPv4 translator and the
									subsequent communication flows using the IPv6/IPv4 translator mechanisms.
</li>
</ol>

<a name="anchor20"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.3"></a><h3>7.3.&nbsp;
Example of IPv6-Internet-to-an-IPv4-network setup DNS64 in DNS server mode</h3>

<p>In this example, we consider an IPv6 node located in the IPv6 Internet
								        that initiates a communication to an IPv4 node located in the IPv4
								        site.
</p>
<p>In some cases, this scenario can be addressed without using any form of DNS64 function. 
											This is so because in principle it is possible to assign a fixed IPv6 address
											to each of the IPv4 nodes. Such an IPv6 address would be constructed using the 
											address transformation algorithm defined in <a class='info' href='#I-D.ietf-behave-address-format'>[I&#8209;D.ietf&#8209;behave&#8209;address&#8209;format]<span> (</span><span class='info'>Bao, C., Huitema, C., Bagnulo, M., Boucadair, M., and X. Li, &ldquo;IPv6 Addressing of IPv4/IPv6 Translators,&rdquo; April&nbsp;2010.</span><span>)</span></a>
											that takes as input the Pref64::/96 and the IPv4 address of the IPv4 node.
											Note that the IPv4 address can be a public or a private address; the latter does 
											not present any additional difficulty, since an NSP must be used as Pref64::/96
											(in this scenario the usage of the Well-Known prefix is not supported as discussed 
											in <a class='info' href='#I-D.ietf-behave-address-format'>[I&#8209;D.ietf&#8209;behave&#8209;address&#8209;format]<span> (</span><span class='info'>Bao, C., Huitema, C., Bagnulo, M., Boucadair, M., and X. Li, &ldquo;IPv6 Addressing of IPv4/IPv6 Translators,&rdquo; April&nbsp;2010.</span><span>)</span></a>). Once these IPv6 addresses 
											have been assigned to represent the IPv4 nodes in the IPv6 Internet, 
											real AAAA RRs containing these addresses
											can be published in the DNS under the site's domain. This is the recommended approach
											to handle this scenario, because
		                                it does not involve synthesizing AAAA
		                                records at the time of query. 
</p>
<p>However, there are some more dynamic scenarios, where synthesizing AAAA RRs in this
											setup may be needed. In particular,
			                                when DNS Update <a class='info' href='#RFC2136'>[RFC2136]<span> (</span><span class='info'>Vixie, P., Thomson, S., Rekhter, Y., and J. Bound, &ldquo;Dynamic Updates in the Domain Name System (DNS UPDATE),&rdquo; April&nbsp;1997.</span><span>)</span></a>
											is used in the IPv4 site to update the A RRs for the IPv4 nodes, there are two options:
											One option is to modify the DNS server that receives the dynamic DNS updates. That would normally 
											be the authoritative server for the zone. So the authoritative zone would have normal AAAA 
											RRs that are synthesized as dynamic updates occur. The other option is modify all the authoritative 
											servers to generate synthetic AAAA records for a zone, possibly based on additional constraints,
											upon the receipt of a DNS query
		                                    for the AAAA RR. The first option --
		                                    in which the AAAA is synthesized
		                                    when the DNS update message is
		                                    received, and the data published
		                                    in the relevant zone -- is
		                                    recommended over the second option
		                                    (i.e. the synthesis upon receipt
		                                    of the AAAA DNS query).  This is
		                                    because it is usually easier to
		                                    solve problems of misconfiguration
		                                    and so on when the DNS responses
		                                    are not being generated dynamically.

											However, it may be the case where 
											the primary server (that receives all the updates) 
											cannot be upgraded for whatever reason, but where 
											a secondary can be upgraded in order to handle the 
											(comparatively small amount) of AAAA queries. In such case, it is possible to use the DNS64 as described next.
											The
		                                    DNS64 behavior that we describe in
		                                    this section covers the case of
		                                    synthesizing the AAAA RR when the
		                                    DNS query arrives. 
		
</p>
<p>The scenario for this case is depicted in the following figure:
</p>
<p>
</p><div style='display: table; width: 0; margin-left: auto; margin-right: auto'><pre>
+-----------+          +----------------------+
|           |          |   IPv4 site          |
|   IPv6    |      +-------+     |   +----+   |
| Internet  |------| NAT64 |-----|---| H2 |   |
|           |      +-------+     |   +----+   |
|           |          |         | 192.0.2.1  |
|           |    +------------+  |            |
|           |----| Name server|--|            |
|           |    | with DNS64 |  |            |
+-----------+    +------------+  |            |
  |                    |         |            |
+----+                 |                      |
| H1 |                 +----------------------+
+----+
</pre></div>
<p>
</p>
<p>The figure shows an IPv6 node H1  and an
								        IPv4 node H2 with IPv4 address X 192.0.2.1 and FQDN h2.example.com.
</p>
<p>A IPv6/IPv4 translator connects the IPv4 network to the IPv6 Internet. This IPv6/IPv4 translator has
								        a NSP 2001:DB8::/96.
</p>
<p>Also shown is the authoritative name server for the local domain with DNS64 functionality. For the
								        purpose of this example, we assume that the name server is a
								        dual-stack node, so that H1 or a recursive resolver 
										acting on the request of H1 can contact it via IPv6, while it can
								        be contacted by
										IPv4-only nodes to receive dynamic DNS updates via IPv4.
</p>
<p>The local name server needs to know the prefix assigned to the
								        local IPv6/IPv4 Translator (2001:DB8::/96). For the purpose of this example, we assume
								        it learns this through manual configuration.
</p>
<p>The steps by which H1 establishes communication with H2 are: </p>
<ol class="text">
<li>H1 does a DNS lookup for h2.example.com. H1 does this
								            by sending a DNS query for a AAAA record for H2. The query is
								 			eventually forwarded to the server in the IPv4 site.
</li>
<li>The local DNS server resolves the query (locally), and discovers that
								            there are no AAAA records for H2.
</li>
<li>The name server verifies that h2.example.com and its A RR are among those that the
												local policy defines as allowed to generate a AAAA RR from.  
												If that is the case, the name server 
								            synthesizes a AAAA record from the A RR and the prefix 2001:DB8::/96. 
											The IPv6 address in the AAAA record
								            is 2001:DB8::192.0.2.1.
</li>
<li>H1 receives the synthetic AAAA record and sends a packet
								            towards H2. The packet is sent to the destination address 2001:DB8::192.0.2.1.
</li>
<li>The packet is routed through the IPv6 Internet to the IPv6 interface of the IPv6/IPv4 translator and the
												communication flows using the IPv6/IPv4 translator mechanisms.
</li>
</ol>

<a name="anchor21"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.8"></a><h3>8.&nbsp;
Security Considerations</h3>

<p>See the discussion on the usage of DNSSEC and DNS64 described
	in <a class='info' href='#dns64bkgd'>Section&nbsp;3<span> (</span><span class='info'>Background to DNS64-DNSSEC interaction</span><span>)</span></a>, <a class='info' href='#dnssec64rec'>Section&nbsp;5.5<span> (</span><span class='info'>DNSSEC processing: DNS64 in recursive resolver mode</span><span>)</span></a>, and
	<a class='info' href='#valanddns64'>Section&nbsp;6.2<span> (</span><span class='info'>DNSSEC validators and DNS64</span><span>)</span></a>.
	
</p>
<a name="anchor22"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.9"></a><h3>9.&nbsp;
IANA Considerations</h3>

<p>This memo makes no request of IANA.
</p>
<a name="anchor23"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.10"></a><h3>10.&nbsp;
Contributors</h3>

<blockquote class="text">
<p>Dave Thaler
</p>
<p>Microsoft
</p>
<p>dthaler@windows.microsoft.com
</p>
</blockquote>
<a name="anchor24"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.11"></a><h3>11.&nbsp;
Acknowledgements</h3>

<p> This draft contains the result of discussions involving
		many people, including the participants of the IETF BEHAVE
		Working Group.  The following IETF participants made specific
		contributions to parts of the text, and their help is
		gratefully acknowledged: Jaap Akkerhuis, Mark Andrews, Jari
		Arkko, Rob Austein, Timothy Baldwin, Fred Baker, Doug Barton,
		Marc Blanchet, Cameron Byrne, Brian Carpenter, Zhen Cao, Hui
		Deng, Francis Dupont, Patrik Faltstrom, Ed Jankiewicz, Peter
		Koch, Suresh Krishnan, Ed Lewis, Xing Li, Bill Manning,
		Matthijs Mekking, Hiroshi Miyata, Simon Perrault, Teemu
		Savolainen, Jyrki Soini, Dave Thaler, Mark Townsley, Rick van
		Rein, Stig Venaas, Magnus Westerlund, Florian Weimer, Dan
		Wing, Xu Xiaohu, Xiangsong Cui. 
</p>
<p>Marcelo Bagnulo and Iljitsch van Beijnum are partly funded by Trilogy, 
	a research project supported by the European Commission under its Seventh 
	Framework Program.
</p>
<a name="rfc.references"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.12"></a><h3>12.&nbsp;
References</h3>

<a name="rfc.references1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>12.1.&nbsp;Normative References</h3>
<table width="99%" border="0">
<tr><td class="author-text" valign="top"><a name="RFC2119">[RFC2119]</a></td>
<td class="author-text"><a href="mailto:sob@harvard.edu">Bradner, S.</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>,&rdquo; BCP&nbsp;14, RFC&nbsp;2119, March&nbsp;1997 (<a href="http://www.rfc-editor.org/rfc/rfc2119.txt">TXT</a>, <a href="http://xml.resource.org/public/rfc/html/rfc2119.html">HTML</a>, <a href="http://xml.resource.org/public/rfc/xml/rfc2119.xml">XML</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC1034">[RFC1034]</a></td>
<td class="author-text">Mockapetris, P., &ldquo;<a href="http://tools.ietf.org/html/rfc1034">Domain names - concepts and facilities</a>,&rdquo; STD&nbsp;13, RFC&nbsp;1034, November&nbsp;1987 (<a href="http://www.rfc-editor.org/rfc/rfc1034.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC1035">[RFC1035]</a></td>
<td class="author-text">Mockapetris, P., &ldquo;<a href="http://tools.ietf.org/html/rfc1035">Domain names - implementation and specification</a>,&rdquo; STD&nbsp;13, RFC&nbsp;1035, November&nbsp;1987 (<a href="http://www.rfc-editor.org/rfc/rfc1035.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4787">[RFC4787]</a></td>
<td class="author-text">Audet, F. and C. Jennings, &ldquo;<a href="http://tools.ietf.org/html/rfc4787">Network Address Translation (NAT) Behavioral Requirements for Unicast UDP</a>,&rdquo; BCP&nbsp;127, RFC&nbsp;4787, January&nbsp;2007 (<a href="http://www.rfc-editor.org/rfc/rfc4787.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="I-D.ietf-behave-address-format">[I-D.ietf-behave-address-format]</a></td>
<td class="author-text">Bao, C., Huitema, C., Bagnulo, M., Boucadair, M., and X. Li, &ldquo;<a href="http://www.ietf.org/internet-drafts/draft-ietf-behave-address-format-07.txt">IPv6 Addressing of IPv4/IPv6 Translators</a>,&rdquo; draft-ietf-behave-address-format-07 (work in progress), April&nbsp;2010 (<a href="http://www.ietf.org/internet-drafts/draft-ietf-behave-address-format-07.txt">TXT</a>).</td></tr>
</table>

<a name="rfc.references2"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>12.2.&nbsp;Informative References</h3>
<table width="99%" border="0">
<tr><td class="author-text" valign="top"><a name="I-D.ietf-behave-v6v4-xlate-stateful">[I-D.ietf-behave-v6v4-xlate-stateful]</a></td>
<td class="author-text">Bagnulo, M., Matthews, P., and I. Beijnum, &ldquo;<a href="http://www.ietf.org/internet-drafts/draft-ietf-behave-v6v4-xlate-stateful-11.txt">Stateful NAT64: Network Address and Protocol Translation from IPv6 Clients to IPv4 Servers</a>,&rdquo; draft-ietf-behave-v6v4-xlate-stateful-11 (work in progress), March&nbsp;2010 (<a href="http://www.ietf.org/internet-drafts/draft-ietf-behave-v6v4-xlate-stateful-11.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC2136">[RFC2136]</a></td>
<td class="author-text"><a href="mailto:paul@vix.com">Vixie, P.</a>, <a href="mailto:set@thumper.bellcore.com">Thomson, S.</a>, <a href="mailto:yakov@cisco.com">Rekhter, Y.</a>, and <a href="mailto:bound@zk3.dec.com">J. Bound</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc2136">Dynamic Updates in the Domain Name System (DNS UPDATE)</a>,&rdquo; RFC&nbsp;2136, April&nbsp;1997 (<a href="http://www.rfc-editor.org/rfc/rfc2136.txt">TXT</a>, <a href="http://xml.resource.org/public/rfc/html/rfc2136.html">HTML</a>, <a href="http://xml.resource.org/public/rfc/xml/rfc2136.xml">XML</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC3484">[RFC3484]</a></td>
<td class="author-text">Draves, R., &ldquo;<a href="http://tools.ietf.org/html/rfc3484">Default Address Selection for Internet Protocol version 6 (IPv6)</a>,&rdquo; RFC&nbsp;3484, February&nbsp;2003 (<a href="http://www.rfc-editor.org/rfc/rfc3484.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC3596">[RFC3596]</a></td>
<td class="author-text">Thomson, S., Huitema, C., Ksinant, V., and M. Souissi, &ldquo;<a href="http://tools.ietf.org/html/rfc3596">DNS Extensions to Support IP Version 6</a>,&rdquo; RFC&nbsp;3596, October&nbsp;2003 (<a href="http://www.rfc-editor.org/rfc/rfc3596.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4033">[RFC4033]</a></td>
<td class="author-text">Arends, R., Austein, R., Larson, M., Massey, D., and S. Rose, &ldquo;<a href="http://tools.ietf.org/html/rfc4033">DNS Security Introduction and Requirements</a>,&rdquo; RFC&nbsp;4033, March&nbsp;2005 (<a href="http://www.rfc-editor.org/rfc/rfc4033.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4034">[RFC4034]</a></td>
<td class="author-text">Arends, R., Austein, R., Larson, M., Massey, D., and S. Rose, &ldquo;<a href="http://tools.ietf.org/html/rfc4034">Resource Records for the DNS Security Extensions</a>,&rdquo; RFC&nbsp;4034, March&nbsp;2005 (<a href="http://www.rfc-editor.org/rfc/rfc4034.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4035">[RFC4035]</a></td>
<td class="author-text">Arends, R., Austein, R., Larson, M., Massey, D., and S. Rose, &ldquo;<a href="http://tools.ietf.org/html/rfc4035">Protocol Modifications for the DNS Security Extensions</a>,&rdquo; RFC&nbsp;4035, March&nbsp;2005 (<a href="http://www.rfc-editor.org/rfc/rfc4035.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC5735">[RFC5735]</a></td>
<td class="author-text">Cotton, M. and L. Vegoda, &ldquo;<a href="http://tools.ietf.org/html/rfc5735">Special Use IPv4 Addresses</a>,&rdquo; BCP&nbsp;153, RFC&nbsp;5735, January&nbsp;2010 (<a href="http://www.rfc-editor.org/rfc/rfc5735.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="I-D.ietf-behave-v6v4-framework">[I-D.ietf-behave-v6v4-framework]</a></td>
<td class="author-text">Baker, F., Li, X., Bao, C., and K. Yin, &ldquo;<a href="http://www.ietf.org/internet-drafts/draft-ietf-behave-v6v4-framework-08.txt">Framework for IPv4/IPv6 Translation</a>,&rdquo; draft-ietf-behave-v6v4-framework-08 (work in progress), March&nbsp;2010 (<a href="http://www.ietf.org/internet-drafts/draft-ietf-behave-v6v4-framework-08.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="I-D.venaas-behave-mcast46">[I-D.venaas-behave-mcast46]</a></td>
<td class="author-text">Venaas, S., Asaeda, H., SUZUKI, S., and T. Fujisaki, &ldquo;<a href="http://www.ietf.org/internet-drafts/draft-venaas-behave-mcast46-01.txt">An IPv4 - IPv6 multicast translator</a>,&rdquo; draft-venaas-behave-mcast46-01 (work in progress), July&nbsp;2009 (<a href="http://www.ietf.org/internet-drafts/draft-venaas-behave-mcast46-01.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="I-D.ietf-dnsop-default-local-zones">[I-D.ietf-dnsop-default-local-zones]</a></td>
<td class="author-text">Andrews, M., &ldquo;<a href="http://www.ietf.org/internet-drafts/draft-ietf-dnsop-default-local-zones-12.txt">Locally-served DNS Zones</a>,&rdquo; draft-ietf-dnsop-default-local-zones-12 (work in progress), April&nbsp;2010 (<a href="http://www.ietf.org/internet-drafts/draft-ietf-dnsop-default-local-zones-12.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="I-D.savolainen-mif-dns-server-selection">[I-D.savolainen-mif-dns-server-selection]</a></td>
<td class="author-text">Savolainen, T., &ldquo;<a href="http://www.ietf.org/internet-drafts/draft-savolainen-mif-dns-server-selection-02.txt">DNS Server Selection on Multi-Homed Hosts</a>,&rdquo; draft-savolainen-mif-dns-server-selection-02 (work in progress), February&nbsp;2010 (<a href="http://www.ietf.org/internet-drafts/draft-savolainen-mif-dns-server-selection-02.txt">TXT</a>).</td></tr>
</table>

<a name="always-synth"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.A"></a><h3>Appendix A.&nbsp;
Motivations and Implications of synthesizing AAAA Resource Records when real AAAA Resource Records exist</h3>

<p>The motivation for synthesizing AAAA RRs when real AAAA RRs exist is to support the following scenario:
			</p>
<blockquote class="text">
<p> An IPv4-only server application (e.g. web server software) is running on a dual-stack host.  
				There may also be dual-stack server applications also running on the same host.  
				That host has fully routable IPv4 and IPv6 addresses and hence the authoritative DNS 
				server has an A and a AAAA record as a result.
</p>
<p> An IPv6-only client (regardless of whether the client application is IPv6-only, the client stack 
				is IPv6-only, or it only has an IPv6 address) wants to access the above server.
</p>
<p> The client issues a DNS query to a DNS64 resolver.
</p>
</blockquote>

<p>If the DNS64 only generates a synthetic AAAA if there's no real AAAA, then the communication will fail.
			Even though there's a real AAAA, the only way for communication to succeed is with the translated address.
			So, in order to support this scenario, the administrator of a DNS64 service may want to enable the synthesis 
			of AAAA RRs even when real AAAA RRs exist.
</p>
<p>The implication of including synthetic AAAA RRs when real AAAA RRs exist is that translated
				connectivity may be preferred over native connectivity in some cases where the DNS64 is operated in DNS server mode.
</p>
<p>	RFC3484 <a class='info' href='#RFC3484'>[RFC3484]<span> (</span><span class='info'>Draves, R., &ldquo;Default Address Selection for Internet Protocol version 6 (IPv6),&rdquo; February&nbsp;2003.</span><span>)</span></a> rules use longest prefix match to
				select the preferred destination address to use.
				So, if the DNS64 resolver returns both the synthetic AAAA RRs and the real AAAA
				RRs, then if the DNS64 is operated by the same domain as the initiating
				host, and a global unicast prefix (called an 
				NSP in <a class='info' href='#I-D.ietf-behave-address-format'>[I&#8209;D.ietf&#8209;behave&#8209;address&#8209;format]<span> (</span><span class='info'>Bao, C., Huitema, C., Bagnulo, M., Boucadair, M., and X. Li, &ldquo;IPv6 Addressing of IPv4/IPv6 Translators,&rdquo; April&nbsp;2010.</span><span>)</span></a>) is used, 
				then a synthetic AAAA RR is likely to be preferred.
			
</p>
<p>	This means that without further configuration:
				</p>
<blockquote class="text">
<p> In the "An IPv6 network to the IPv4 Internet" scenario, the host will
				prefer translated connectivity if an NSP is used. If the Well-Known 
				Prefix defined in <a class='info' href='#I-D.ietf-behave-address-format'>[I&#8209;D.ietf&#8209;behave&#8209;address&#8209;format]<span> (</span><span class='info'>Bao, C., Huitema, C., Bagnulo, M., Boucadair, M., and X. Li, &ldquo;IPv6 Addressing of IPv4/IPv6 Translators,&rdquo; April&nbsp;2010.</span><span>)</span></a>
				is used, it will probably prefer native connectivity.
</p>
<p> In the "IPv6 Internet to an IPv4 network" scenario, it is
				possible to bias the selection towards the real AAAA
				RR if the DNS64 resolver returns the real AAAA first in the DNS reply, when
				an NSP is used (the Well-Known Prefix usage is not supported in
				this case)
</p>
<p> In the "An IPv6 network to IPv4 network" scenario, for 
				local destinations (i.e., target hosts inside the local site), it is
				likely that the NSP and the destination prefix are the
				same, so we can use the order of RR in the DNS reply to bias
				the selection through native connectivity. If the Well-Known Prefix
				is used, the longest prefix match rule will select native
				connectivity.
</p>
</blockquote>

<p>	So this option introduces problems in the following cases:
				</p>
<blockquote class="text">
<p> An IPv6 network to the IPv4 internet with an NSP
</p>
<p> IPv6 to IPv4 in the same network when reaching external
				destinations and an NSP is used.
</p>
</blockquote>

<p>	In any case, the problem can be solved by properly configuring
				the RFC3484 <a class='info' href='#RFC3484'>[RFC3484]<span> (</span><span class='info'>Draves, R., &ldquo;Default Address Selection for Internet Protocol version 6 (IPv6),&rdquo; February&nbsp;2003.</span><span>)</span></a> policy table,
            but this requires effort on the part of the site operator.
</p>
<a name="rfc.authors"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>Authors' Addresses</h3>
<table width="99%" border="0" cellpadding="0" cellspacing="0">
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Marcelo Bagnulo</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">UC3M</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Av. Universidad 30</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Leganes, Madrid  28911</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Spain</td></tr>
<tr><td class="author" align="right">Phone:&nbsp;</td>
<td class="author-text">+34-91-6249500</td></tr>
<tr><td class="author" align="right">Fax:&nbsp;</td>
<td class="author-text"></td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:marcelo@it.uc3m.es">marcelo@it.uc3m.es</a></td></tr>
<tr><td class="author" align="right">URI:&nbsp;</td>
<td class="author-text"><a href="http://www.it.uc3m.es/marcelo">http://www.it.uc3m.es/marcelo</a></td></tr>
<tr cellpadding="3"><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Andrew Sullivan</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Shinkuro</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">4922 Fairmont Avenue, Suite 250</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Bethesda, MD  20814</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">USA</td></tr>
<tr><td class="author" align="right">Phone:&nbsp;</td>
<td class="author-text">+1 301 961 3131</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:ajs@shinkuro.com">ajs@shinkuro.com</a></td></tr>
<tr cellpadding="3"><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Philip Matthews</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Unaffiliated</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">600 March Road</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Ottawa, Ontario  </td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Canada</td></tr>
<tr><td class="author" align="right">Phone:&nbsp;</td>
<td class="author-text">+1 613-592-4343 x224</td></tr>
<tr><td class="author" align="right">Fax:&nbsp;</td>
<td class="author-text"></td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:philip_matthews@magma.ca">philip_matthews@magma.ca</a></td></tr>
<tr><td class="author" align="right">URI:&nbsp;</td>
<td class="author-text"><a href=""></a></td></tr>
<tr cellpadding="3"><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Iljitsch van Beijnum</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">IMDEA Networks</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Av. Universidad 30</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Leganes, Madrid  28911</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Spain</td></tr>
<tr><td class="author" align="right">Phone:&nbsp;</td>
<td class="author-text">+34-91-6246245</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:iljitsch@muada.com">iljitsch@muada.com</a></td></tr>
</table>
</body></html>
