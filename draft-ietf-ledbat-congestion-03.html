<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="en"><head><title>Low Extra Delay Background Transport (LEDBAT)</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="description" content="Low Extra Delay Background Transport (LEDBAT)">
<meta name="generator" content="xml2rfc v1.35 (http://xml.resource.org/)">
<meta name="viewport" content="width=600;" />
<style type='text/css'><!--
        body {
                font-family: verdana, charcoal, helvetica, arial, sans-serif;
                font-size: 85%;
		max-width: 60em; 
		color: #000; background-color: #FFF;
                margin: 2em;
        }
        h1, h2, h3, h4, h5, h6 {
                font-family: helvetica, monaco, "MS Sans Serif", arial, sans-serif;
                font-weight: bold; font-style: normal;
        }
        h1 { color: #900; background-color: transparent; text-align: right; }
        h3 { color: #333; background-color: transparent; }

        td.RFCbug {
                font-size: x-small; text-decoration: none;
                width: 30px; height: 30px; padding-top: 2px;
                text-align: justify; vertical-align: middle;
                background-color: #000;
        }
        td.RFCbug span.RFC {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: bold; color: #666;
        }
        td.RFCbug span.hotText {
                font-family: charcoal, monaco, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: normal; text-align: center; color: #FFF;
        }

        table.TOCbug { width: 30px; height: 15px; }
        td.TOCbug {
                text-align: center; width: 30px; height: 15px;
                color: #FFF; background-color: #900;
        }
        td.TOCbug a {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, sans-serif;
                font-weight: bold; font-size: x-small; text-decoration: none;
                color: #FFF; background-color: transparent;
        }

        td.header {
                font-family: arial, helvetica, sans-serif; font-size: x-small;
                vertical-align: top; width: 33%;
                color: #FFF; background-color: #666;
        }
        td.author { font-weight: bold; font-size: x-small; margin-left: 4em; }
        td.author-text { font-size: x-small; }

        /* info code from SantaKlauss at http://www.madaboutstyle.com/tooltip2.html */
        a.info {
                /* This is the key. */
                position: relative;
                z-index: 24;
                text-decoration: none;
        }
        a.info:hover {
                z-index: 25;
                color: #FFF; background-color: #900;
        }
        a.info span { display: none; }
        a.info:hover span.info {
                /* The span will display just on :hover state. */
                display: block;
                position: absolute;
                font-size: smaller;
                top: 2em; left: -5em; width: 15em;
                padding: 2px; border: 1px solid #333;
                color: #900; background-color: #EEE;
                text-align: left;
        }

        a { font-weight: bold; }
        a:link    { color: #900; background-color: transparent; }
        a:visited { color: #633; background-color: transparent; }
        a:active  { color: #633; background-color: transparent; }

        p { margin-left: 2em; margin-right: 2em; }
        p.copyright { font-size: x-small; }
        p.toc { font-size: 85%;
		max-width: 60em; 
		font-weight: bold; margin-left: 3em; }
        table.toc { margin: 0 0 0 3em; padding: 0; border: 0; vertical-align: text-top; }
        td.toc { font-size: 85%;
		max-width: 60em; 
		font-weight: bold; vertical-align: text-top; }

        ol.text { margin-left: 2em; margin-right: 2em; }
        ul.text { margin-left: 2em; margin-right: 2em; }
        li      { margin-left: 3em; }

        /* RFC-2629 <spanx>s and <artwork>s. */
        em     { font-style: italic; }
        strong { font-weight: bold; }
        dfn    { font-weight: bold; font-style: normal; }
        cite   { font-weight: normal; font-style: normal; }
        tt     { color: #036; }
        tt, pre, pre dfn, pre em, pre cite, pre span {
                font-family: "Courier New", Courier, monospace; font-size: small;
        }
        pre {
                text-align: left; padding: 4px;
                color: #000; background-color: #CCC;
        }
        pre dfn  { color: #900; }
        pre em   { color: #66F; background-color: #FFC; font-weight: normal; }
        pre .key { color: #33C; font-weight: bold; }
        pre .id  { color: #900; }
        pre .str { color: #000; background-color: #CFF; }
        pre .val { color: #066; }
        pre .rep { color: #909; }
        pre .oth { color: #000; background-color: #FCF; }
        pre .err { background-color: #FCC; }

        /* RFC-2629 <texttable>s. */
        table.all, table.full, table.headers, table.none {
                font-size: 85%;
		max-width: 60em; 
		text-align: center; border-width: 2px;
                vertical-align: top; border-collapse: collapse;
        }
        table.all, table.full { border-style: solid; border-color: black; }
        table.headers, table.none { border-style: none; }
        th {
                font-weight: bold; border-color: black;
                border-width: 2px 2px 3px 2px;
        }
        table.all th, table.full th { border-style: solid; }
        table.headers th { border-style: none none solid none; }
        table.none th { border-style: none; }
        table.all td {
                border-style: solid; border-color: #333;
                border-width: 1px 2px;
        }
        table.full td, table.headers td, table.none td { border-style: none; }

        hr { height: 1px; }
        hr.insert {
                width: 80%; border-style: none; border-width: 0;
                color: #CCC; background-color: #CCC;
        }
--></style>
</head>
<body>
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<table summary="layout" width="66%" border="0" cellpadding="0" cellspacing="0"><tr><td><table summary="layout" width="100%" border="0" cellpadding="2" cellspacing="1">
<tr><td class="header">LEDBAT WG</td><td class="header">S. Shalunov</td></tr>
<tr><td class="header">Internet-Draft</td><td class="header">G. Hazel</td></tr>
<tr><td class="header">Intended status: Experimental</td><td class="header">BitTorrent Inc</td></tr>
<tr><td class="header">Expires: April 29, 2011</td><td class="header">J. Iyengar</td></tr>
<tr><td class="header">&nbsp;</td><td class="header">Franklin and Marshall College</td></tr>
<tr><td class="header">&nbsp;</td><td class="header">October 26, 2010</td></tr>
</table></td></tr></table>
<h1><br />Low Extra Delay Background Transport (LEDBAT)<br />draft-ietf-ledbat-congestion-03.txt</h1>

<h3>Abstract</h3>

<p>LEDBAT is an experimental delay-based congestion control algorithm
			  that attempts to utilize the available bandwidth on an end-to-end path
			  while limiting the consequent increase in queueing delay on the path.
			  LEDBAT uses changes in one-way delay measurements
			  to limit congestion induced in the network by the LEDBAT flow.
			  LEDBAT is designed largely for use by background bulk-transfer applications;
			  it is designed to be no more aggressive than TCP congestion control
			  and yields in the presence of competing TCP flows,
			  thus reducing interference with the network performance of the competing flows.
</p>
<h3>Status of this Memo</h3>
<p>
This Internet-Draft is submitted  in full
conformance with the provisions of BCP&nbsp;78 and BCP&nbsp;79.</p>
<p>
Internet-Drafts are working documents of the Internet Engineering
Task Force (IETF).  Note that other groups may also distribute
working documents as Internet-Drafts.  The list of current
Internet-Drafts is at http://datatracker.ietf.org/drafts/current/.</p>
<p>
Internet-Drafts are draft documents valid for a maximum of six months
and may be updated, replaced, or obsoleted by other documents at any time.
It is inappropriate to use Internet-Drafts as reference material or to cite
them other than as &ldquo;work in progress.&rdquo;</p>
<p>
This Internet-Draft will expire on April 29, 2011.</p>

<h3>Copyright Notice</h3>
<p>
Copyright (c) 2010 IETF Trust and the persons identified as the
document authors.  All rights reserved.</p>
<p>
This document is subject to BCP 78 and the IETF Trust's Legal
Provisions Relating to IETF Documents
(http://trustee.ietf.org/license-info) in effect on the date of
publication of this document.  Please review these documents
carefully, as they describe your rights and restrictions with respect
to this document. Code Components extracted from this document must
include Simplified BSD License text as described in Section 4.e of
the Trust Legal Provisions and are provided without warranty as
described in the Simplified BSD License.</p>
<a name="toc"></a><br /><hr />
<h3>Table of Contents</h3>
<p class="toc">
<a href="#anchor1">1.</a>&nbsp;
Requirements notation<br />
<a href="#anchor2">2.</a>&nbsp;
Introduction<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor3">2.1.</a>&nbsp;
Design Goals<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor4">2.2.</a>&nbsp;
Applicability<br />
<a href="#anchor5">3.</a>&nbsp;
LEDBAT Congestion Control<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor6">3.1.</a>&nbsp;
Overview<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor7">3.2.</a>&nbsp;
Preliminaries<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor8">3.3.</a>&nbsp;
Receiver-Side Operation<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor9">3.4.</a>&nbsp;
Sender-Side Operation<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor10">3.4.1.</a>&nbsp;
An Overview<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor11">3.4.2.</a>&nbsp;
The Complete Sender Algorithm<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor12">3.5.</a>&nbsp;
Parameter Values<br />
<a href="#anchor13">4.</a>&nbsp;
Understanding LEDBAT Mechanisms<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor14">4.1.</a>&nbsp;
Delay Estimation<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor15">4.1.1.</a>&nbsp;
Estimating Base Delay<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor16">4.1.2.</a>&nbsp;
Estimating Queueing Delay<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor17">4.2.</a>&nbsp;
Managing the Congestion Window<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor18">4.2.1.</a>&nbsp;
Window Increase: Probing For More Bandwidth<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor19">4.2.2.</a>&nbsp;
Window Decrease: Responding To Congestion<br />
<a href="#anchor20">5.</a>&nbsp;
Choosing Parameter Values<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor21">5.1.</a>&nbsp;
Queuing Delay Target<br />
<a href="#anchor22">6.</a>&nbsp;
Discussion<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor23">6.1.</a>&nbsp;
Framing Considerations<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor24">6.2.</a>&nbsp;
Competing With TCP Flows<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor25">6.3.</a>&nbsp;
Fairness Among LEDBAT Flows<br />
<a href="#anchor26">7.</a>&nbsp;
IANA Considerations<br />
<a href="#anchor27">8.</a>&nbsp;
Security Considerations<br />
<a href="#rfc.references1">9.</a>&nbsp;
Normative References<br />
<a href="#app-additional">Appendix&nbsp;A.</a>&nbsp;
Timestamp errors<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor29">A.1.</a>&nbsp;
Clock offset<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor30">A.2.</a>&nbsp;
Clock skew<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor31">A.2.1.</a>&nbsp;
Deployed clock skew correction mechanism<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor32">A.2.2.</a>&nbsp;
Skew correction with faster virtual clock<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor33">A.2.3.</a>&nbsp;
Skew correction with estimating drift<br />
<a href="#rfc.authors">&#167;</a>&nbsp;
Authors' Addresses<br />
</p>
<br clear="all" />

<a name="anchor1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1"></a><h3>1.&nbsp;
Requirements notation</h3>

<p>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL",
            "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY",
            and "OPTIONAL" in this document are to be interpreted as
            described in <a class='info' href='#RFC2119'>[RFC2119]<span> (</span><span class='info'>Bradner, S., &ldquo;Key words for use in RFCs to Indicate Requirement Levels,&rdquo; March&nbsp;1997.</span><span>)</span></a>.
</p>
<a name="anchor2"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2"></a><h3>2.&nbsp;
Introduction</h3>

<p>
			TCP congestion control <a class='info' href='#RFC2581'>[RFC2581]<span> (</span><span class='info'>Allman, M., Paxson, V., and W. Stevens, &ldquo;TCP Congestion Control,&rdquo; April&nbsp;1999.</span><span>)</span></a>,
			the predominant congestion control mechanism used on the Internet,
			aims to share bandwidth at a bottleneck link equitably
			among flows competing at the bottleneck.
			While TCP works well for many applications,
			applications
			such as software updates or file-sharing applications
			prefer to use bandwidth available in the network
			without interfering with the network performance of 
			other interactive applications.
			Such "background" traffic
			can yield bandwidth to TCP-based "foreground" traffic
			by reacting earlier than TCP to congestion signals.
		  
</p>
<p> LEDBAT is an experimental delay-based congestion control mechanism
			that allows background applications,
			such as peer-to-peer applications,
			that send large amounts of data particularly over links with deep buffers,
			such as residential uplinks, 
			to operate in the background,
			without interfering with performance of interactive applications. 
			LEDBAT uses one-way delay measurements to determine congestion on the data path,
			and keeps latency across the tight link in the end-to-end path low
            while attempting to utilize the available bandwidth on the end-to-end path. 
</p>
<a name="anchor3"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2.1"></a><h3>2.1.&nbsp;
Design Goals</h3>

<p>As a "scavenger" mechanism for the Internet, LEDBAT's design goals are to:
				</p>
<ol class="text">
<li>Keep	delay low when no other traffic is present 
</li>
<li>Add little to the queuing delays induced by TCP traffic
</li>
<li>Quickly yield to traffic sharing the same bottleneck queue that uses standard TCP congestion control 
</li>
<li>Utilize end-to-end available bandwidth 
</li>
<li>Operate well in networks with FIFO queuing with drop-tail discipline
</li>
</ol><p>
			
</p>
<a name="anchor4"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2.2"></a><h3>2.2.&nbsp;
Applicability</h3>

<p> LEDBAT is a "scavenger" congestion control mechanism---a LEDBAT flow attempts to utilize all available bandwidth
				and  yields quickly to a competing TCP flow---and is primarily motivated by background bulk-transfer applications,
				such as peer-to-peer file transfers and software updates.
				It can be used for any application that needs to run in the "background",
				to reduce the application's impact on the network
				and on other interactive network applications.
</p>
<p> LEDBAT can be used with any
				transport protocol
				capable of carrying timestamps and
				acknowledging data frequently---LEDBAT can be easily used with TCP, SCTP, and DCCP.
</p>
<a name="anchor5"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3"></a><h3>3.&nbsp;
LEDBAT Congestion Control</h3>

<a name="anchor6"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.1"></a><h3>3.1.&nbsp;
Overview</h3>

<p> A TCP sender increases its congestion window
			  until a loss occurs,
			  which, 
			  in the absence of any Active Queue Management (AQM) in the network,
			  occurs only
			  when the queue at the
			  bottleneck link
			  on the end-to-end path overflows.
			  Since packet loss at the bottleneck link is often preceded by an increase in the queueing delay at the bottleneck link,
			  LEDBAT congestion control uses this increase in queueing delay as an early signal of congestion,
			  enabling it to respond to congestion earlier than TCP,
			  and enabling it to yield bandwidth to a competing TCP flow.
			
</p>
<p> LEDBAT employs one-way delay measurements
			  to estimate queueing delay.
			  When the estimated queueing delay 
			  is lesser than a pre-determined target,
			  LEDBAT infers that the network is not yet congested,
			  and increases its sending rate to utilize any spare capacity in the network.
			  When the estimated queueing delay
			  becomes greater than a pre-determined target,
			  LEDBAT decreases its sending rate quickly
			  as a response to potential congestion in the network.
</p>
<a name="anchor7"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.2"></a><h3>3.2.&nbsp;
Preliminaries</h3>

<p> For the purposes of explaining LEDBAT, 
			  we assume a transport sender that uses fixed-size
			  segments and a receiver that acknowledges each segment separately.
			  It is straightforward to apply the mechanisms described here 
			  with variable-sized segments
			  and with delayed acknowledgments.
			  A LEDBAT sender uses a congestion window (cwnd)
			  that gates the amount of data that the sender can send into the network in one RTT.
			
</p>
<p>LEDBAT requires that each data segment carries a "timestamp" from the sender,
			  based on which the receiver computes the one-way delay from the sender,
			  and sends this computed value back to the sender.
</p>
<p> In addition to the LEDBAT mechanism described below,
			  we note that a slow start mechanism can be used as specified in <a class='info' href='#RFC2581'>[RFC2581]<span> (</span><span class='info'>Allman, M., Paxson, V., and W. Stevens, &ldquo;TCP Congestion Control,&rdquo; April&nbsp;1999.</span><span>)</span></a>.
			  Since slow start leads to faster increase in the window than 
			  that specified in LEDBAT,
			  conservative congestion control implementations employing LEDBAT
			  may skip slow start altogether
			  and start with an initial window of XXX MSS.
</p>
<a name="anchor8"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.3"></a><h3>3.3.&nbsp;
Receiver-Side Operation</h3>

<p> A LEDBAT receiver operates as follows:
				</p>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
on data_packet:
  remote_timestamp = data_packet.timestamp
  acknowledgement.delay = local_timestamp() - remote_timestamp
  # fill in other fields of acknowledgement
  acknowlegement.send()
</pre></div><p>

</p>
<a name="anchor9"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.4"></a><h3>3.4.&nbsp;
Sender-Side Operation</h3>

<a name="anchor10"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.4.1"></a><h3>3.4.1.&nbsp;
An Overview</h3>

<p>As a first approximation, a LEDAT sender operates as show below.  
			  TARGET is the maximum queueing delay that LEDBAT itself can introduce in the network,
			  and GAIN determines the rate at which the congestion window changes;
			  both constants are specified later.
			
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
on initialization:
  base_delay = +infinity

on acknowledgement:
  current_delay = acknowledgement.delay
  base_delay = min(base_delay, current_delay)
  queuing_delay = current_delay - base_delay
  off_target = TARGET - queuing_delay
  cwnd += GAIN * off_target / cwnd
</pre></div>
<a name="anchor11"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.4.2"></a><h3>3.4.2.&nbsp;
The Complete Sender Algorithm</h3>

<p>The simplified mechanism above ignores noise filtering and base expiration.  
			  The full sender-side algorithm is specified below:
</p>
<p></p>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
on initialization:
  set all NOISE_FILTER delays used by current_delay() to +infinity
  set all BASE_HISTORY delays used by base_delay() to +infinity
  last_rollover = -infinity # More than a minute in the past.

on acknowledgement:
  delay = acknowledgement.delay
  update_base_delay(delay)
  update_current_delay(delay)
  queuing_delay = current_delay() - base_delay()
  off_target = TARGET - queuing_delay + random_input()
  cwnd += GAIN * off_target / cwnd
  # flight_size() is the amount of currently not acked data.
  max_allowed_cwnd = ALLOWED_INCREASE + TETHER*flight_size()
  cwnd = min(cwnd, max_allowed_cwnd)

random_input()
  # random() is a PRNG between 0.0 and 1.0
  # NB: RANDOMNESS_AMOUNT is normally 0
  RANDOMNESS_AMOUNT * TARGET * ((random() - 0.5)*2)

update_current_delay(delay)
  # Maintain a list of NOISE_FILTER last delays observed.
  forget the earliest of NOISE_FILTER current_delays
  add delay to the end of current_delays

current_delay()
  min(the NOISE_FILTER delays stored by update_current_delay)

update_base_delay(delay)
  # Maintain BASE_HISTORY min delays. Each represents a minute.
  if round_to_minute(now) != round_to_minute(last_rollover)
    last_rollover = now
    forget the earliest of base delays
    add delay to the end of base_delays
  else
    last of base_delays = min(last of base_delays, delay)

base_delay()
  min(the BASE_HISTORY min delays stored by update_base_delay)
</pre></div><p>

			
</p>
<a name="anchor12"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.5"></a><h3>3.5.&nbsp;
Parameter Values</h3>

<p>TARGET parameter MUST be set to 100 milliseconds. GAIN
			SHOULD be set to 1 so that max rampup rate is the same as for
			TCP.  BASE_HISTORY SHOULD be
			10; it MUST be no less than 2 and SHOULD NOT be more than
			20.  NOISE_FILTER SHOULD be 1; it MAY be tuned so that it
			is at least 1 and no more than cwnd/2.  ALLOWED_INCREASE
			SHOULD be 1 packet; it MUST be at least 1 packet and
			SHOULD NOT be more than 3 packets. TETHER SHOULD be 1.5;
			it MUST be greater than 1. RANDONMESS_AMOUNT SHOULD be 0;
			it MUST be between 0 and 0.1 inclusively.
</p>
<p>Note that using the same TARGET
			  value across LEDBAT flows is important, since flows
			  using different TARGET values will not share a
			  bottleneck equitably---flows with higher values will 
			  get a  larger share of the bottleneck bandwidth.
</p>
<a name="anchor13"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4"></a><h3>4.&nbsp;
Understanding LEDBAT Mechanisms</h3>

<p>This section describes and
			  provides insight into the delay estimation
			  and window management mechanisms 
			  used in LEDBAT congestion control.
			
</p>
<a name="anchor14"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.1"></a><h3>4.1.&nbsp;
Delay Estimation</h3>

<p>LEDBAT estimates congestion in the network
				based on observed increase in queueing delay in the network.
				To observe an increase in the queueing delay in the network,
				LEDBAT must separate the queueing delay component 
				from the rest of the end-to-end delay.
				This section explains how LEDBAT decomposes the 
				observed changes in end-to-end delay into these two components.
</p>
<p> LEDBAT estimates congestion in the direction of data flow.
			  To avoid measuring queue build-up on the reverse path (or ack path),
			  LEDBAT uses changes in one-way delay estimates.
			  The extant One-Way Active Measurement
			  Protocol (OWAMP) [XXXcite], 
			  can be used for measuring one-way delay,
			  but since LEDBAT is used for sending data, 
			  and since LEDBAT requires only changes in one-way delay to infer congestion,
			  simply adding a timestamp to the data segments
			  and a measurement result field in the ack packets 
			  seems sufficient.
			  Doing so also avoids the pitfall of
			  measurement packets being treated
			  differently from the data packets in the network.
</p>
<a name="anchor15"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.1.1"></a><h3>4.1.1.&nbsp;
Estimating Base Delay</h3>

<p>End-to-end delay
			  can be decomposed into transmission (or serialization) delay,
			  propagation (or speed-of-light) delay,
			  queueing delay,
			  and processing delay.
			  On any given path,
			  barring some noise,
			  all delay components except for queueing delay are constant;
			  over time, we expect only the queueing delay on the path
			  to change as the queue sizes at the links change.
			  Since	queuing delay is always additive to the end-to-end delay, 
			  we estimate the
			  sum of the constant delay components,
			  which we call "base delay",
			  to be the minimum delay observed on the end-to-end path. 
			  Using the minimum observed delay 
			  also allows LEDBAT to eliminate noise in the delay estimation,
			  such as due to spikes in processing delay at a node on the path.
</p>
<p>To respond to true changes in the base delay due to route changes,
			  LEDBAT uses only "recent" measurements---measurements over the last N minutes---in estimating
			  the base delay.
			  To implement an approximate
			  minimum over the last N minutes,
			  a LEDBAT sender stores N+1 separate minima---N for the last N minutes,
			  and one for the running current minute.
			  At the end of the current minute, the window moves---the 
			  earliest minimum is dropped and the latest minimum is added.
			  When the connection is idle for a given minute, 
			  no data is available for the one-way delay and,
			  therefore, no minimum is stored. 
			  When the connection has
			  been idle for N minutes, 
			  the measurement begins anew.
</p>
<p> The duration of the observation window itself is a tradeoff between 
			  robustness of measurement and responsiveness to change:
			  a larger observation window yields a more accurate base delay if the true base delay is unchanged,
			  whereas a smaller observation window results in faster response to true changes in the base delay.
</p>
<a name="anchor16"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.1.2"></a><h3>4.1.2.&nbsp;
Estimating Queueing Delay</h3>

<p>Given that the base delay is constant,
				  the queueing delay is represented by the variable component 
				  of the measured end-to-end delay.
				  We measure queueing delay as simply the
				  difference between an end-to-end delay measurement
				  and the current estimate of base delay.
</p>
<a name="anchor17"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.2"></a><h3>4.2.&nbsp;
Managing the Congestion Window</h3>

<a name="anchor18"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.2.1"></a><h3>4.2.1.&nbsp;
Window Increase: Probing For More Bandwidth</h3>

<p> A LEDBAT sender increases its
				  congestion window most 
				  when the queuing delay estimate is zero. 
				  To be friendly to competing TCP flows,
				  we set this highest rate of window growth
				  to be the same as TCP's.
				  In other words,
				  the LEDBAT window grows by at most twice per round-trip time.
				  Since queuing delay estimate is always non-negative,
				  this growth rate ensures that a LEDBAT flow 
				  never ramps up faster than a competing TCP flow over the same path.
				  
</p>
<a name="anchor19"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.2.2"></a><h3>4.2.2.&nbsp;
Window Decrease: Responding To Congestion</h3>

<p> When the sender's queuing delay estimate is lower
				  than the target, the sending rate should be increased. 
				  When the sender's queueing delay estimate is higher than the target, 
				  the sending rate should be reduced.
				  LEDBAT uses a simple linear controller to detemine sending rate
				  as a function of the delay estimate, where the
				  response is proportional to the difference between the
				  current queueing delay estimate and the target.
				  In limited experiments with Bittorrent nodes, 
				  this controller seems to work well.
</p>
<p> To deal with severe congestion when several
				  packets are dropped in the network,
				  and to provide a fallback against
				  incorrect queuing delay estimates,
				  a LEDBAT sender halves its cwnd
				  when a loss event is detected. 
				  As with NewReno, 
				  LEDBAT reduces its cwnd by half at
				  most once per RTT. 
				  Note that, unlike TCP-like loss-based
				  congestion control, LEDBAT
				  does not induce losses and so it normally does
				  not rely on losses to determine the sending
				  rate. LEDBAT's reaction to loss is thus less
				  important than it is in the case of loss-based congestion
				  control. For LEDBAT, reducing the congestion window on
				  loss is a fallback mechanism in case of severe congestion and
				  in the case of incorrect delay estimates.
</p>
<a name="anchor20"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5"></a><h3>5.&nbsp;
Choosing Parameter Values</h3>

<p> Through this discussion, we hope to encourage informed experimentation with LEDBAT.
</p>
<a name="anchor21"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.1"></a><h3>5.1.&nbsp;
Queuing Delay Target</h3>

<p>Consider the queuing delay on the bottleneck.  This
				delay is the extra delay induced by congestion
				control. One of our design goals is to keep this delay
				low. However, when this delay is zero, the queue is
				empty and so no data is being transmitted and the link
				is thus not saturated. Hence, our design goal is to
				keep the queuing delay low, but non-zero.
</p>
<p>How low do we want the queuing delay to be? Because
				another design goal is to be deployable on networks
				with only simple FIFO queuing and drop-tail
				discipline, we can't rely on explicit signaling for
				the queuing delay.  So we're going to estimate it
				using external measurements. The external measurements
				will have an error at least on the order of best-case
				scheduling delays in the OSes. There's thus a good
				reason to try to make the queuing delay larger than
				this error. There's no reason that would want us to
				push the delay much further up. Thus, we will have a
				delay target that we would want to maintain.
</p>
<a name="anchor22"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6"></a><h3>6.&nbsp;
Discussion</h3>

<a name="anchor23"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.1"></a><h3>6.1.&nbsp;
Framing Considerations</h3>

<p>The actual framing and wire format of the protocol(s)
				using the LEDBAT congestion control mechanism is outside
				of scope of this document, which only describes the
				congestion control part.
</p>
<p>There is an implication of the need to use one-way
				delay from the sender to the receiver in the sender. An
				obvious way to support this is to use a framing that
				timestamps packets at the sender and conveys the measured
				one-way delay back to the sender in ack packets. This is
				the method we'll keep in mind for the purposes of
				exposition. Other methods are possible and valid.
</p>
<p>Another implication is the receipt of frequent ACK
				packets. The exposition below assumes one ACK per data
				packet, but any reasonably small number of data packets
				per ACK will work as long as there is at least one ACK
				every round-trip time.
</p>
<p>The protocols to which this congestion control
				mechanism is applicable, with possible appropriate
				extensions, are TCP, SCTP, DCCP, etc. It is not a goal of
				this document to cover such applications. The mechanism
				can also be used with proprietary transport protocols,
				e.g., those built over UDP for P2P applications.
</p>
<a name="anchor24"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.2"></a><h3>6.2.&nbsp;
Competing With TCP Flows</h3>

<p>Consider competition between a LEDBAT connection and a
			  connection governed by loss-based congestion control (on
			  a FIFO bottleneck with drop-tail discipline).
			  Loss-based connection will need to experience loss to
			  back off.  Loss will only occur after the connection
			  experiences maximum possible delays.  LEDBAT will thus
			  receive congestion indication sooner than the loss-based
			  connection.  If LEDBAT can ramp down faster than the
			  loss-based connection ramps up, LEDBAT will
			  yield. LEDBAT ramps down when queuing delay estimate
			  exceeds the target: the more the excess, the faster the
			  ramp-down.  When the loss-based connection is standard
			  TCP, LEDBAT will yield at precisely the same rate as TCP
			  is ramping up when the queuing delay is double the
			  target.
</p>
<p>LEDBAT is most aggressive when its queuing delay
			  estimate is most wrong and is as low as it can be.
			  Queuing delay estimate is nonnegative, therefore the
			  worst possible case is when somehow the estimate is
			  always returned as zero.  In this case, LEDBAT will ramp
			  up as fast as TCP and halve the rate on loss.  Thus, in
			  case of worst possible failure of estimates, LEDBAT will
			  behave identically to TCP.  This provides an extra
			  safety net.
</p>
<a name="anchor25"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.3"></a><h3>6.3.&nbsp;
Fairness Among LEDBAT Flows</h3>

<p>The design goals of LEDBAT center around the aggregate
			  behavior of LEDBAT flows when they compete with standard
			  TCP. It is also interesting how LEDBAT flows share
			  bottleneck bandwidth when they only compete between
			  themselves.
</p>
<p>LEDBAT as described so far lacks a mechanism
			  specifically designed to equalize utilization between
			  these flows. The observed behavior of existing
			  implementations indicates that a rough equalization, in
			  fact, does occur.
</p>
<p>The delay measurements used as control inputs by LEDBAT
			  contain some amount of noise and errors. The linear
			  controller converts this input noise into the same
			  amount of output noise. The effect that this has is that
			  the uncorrelated component of the noise between flows
			  serves to randomly shuffle some amount of bandwidth
			  between flows. The amount shuffled during each RTT is
			  proportional to the noise divided by the target
			  delay. The random-walk trajectory of bandwidth utilized
			  by each of the flows over time tends to the fair
			  share. The timescales on which the rates become
			  comparable are proportional to the target delay
			  multiplied by the RTT and divided by the noise.
</p>
<p>In complex real-life systems, the main concern is
			  usually the reduction of the amount of noise, which is
			  copious if not eliminated. In some circumstances,
			  however, the measurements might be "too good" -- since
			  the equalization timescale is inversely proportional to
			  noise, perfect measurements would result in lack of
			  convergence.
</p>
<p>Under these circumstances, it may be beneficial to
			  introduce some artificial randomness into the inputs
			  (or, equivalently, outputs) of the controller. Note that
			  most systems should not require this and should be
			  primarily concerned with reducing, not adding,
			  noise.
</p>
<p>With delay-based congestion control systems, there's a
			  concern about the ability of late comers to measure the
			  base delay correctly. Suppose a LEDBAT flow saturates a
			  bottleneck; another LEDBAT flow starts and proceeds to
			  measure the base delay and the current delay and to
			  estimate the queuing delay. If the bottleneck always
			  contains target delay worth of packets, the second flow
			  would see the bottleneck as empty start building a
			  second target delay worth of queue on top of the
			  existing queue. The concern ("late comers' advantage")
			  is that the initial flow would now back off because it
			  sees the real delay and the late comer would use the
			  whole capacity.
</p>
<p>However, once the initial flow yields, the late comer
			  immediately measures the true base delay and the two
			  flows operate from the same (correct) inputs.
</p>
<p>Additionally, in practice this concern is further
			  alleviated by the burstiness of network traffic: all
			  that's needed to measure the base delay is one small
			  gap. These gaps can occur for a variety of reasons: the
			  OS may delay the scheduling of the sending process until
			  a time slice ends, the sending computer might be
			  unusually busy for some number of milliseconds or tens
			  of milliseconds, etc. If such a gap occurs while the
			  late comer is starting, base delay is immediately
			  correctly measured. With small number of flows, this
			  appears to be the main mechanism of regulating the late
			  comers' advantage.
</p>
<a name="anchor26"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7"></a><h3>7.&nbsp;
IANA Considerations</h3>

<p>There are no IANA considerations for this document.
</p>
<a name="anchor27"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.8"></a><h3>8.&nbsp;
Security Considerations</h3>

<p>A network on the path might choose to cause higher
        	delay measurements than the real queuing delay so that
        	LEDBAT backs off even when there's no congestion present.
        	Shaping of traffic into an artificially narrow bottleneck
        	can't be counteracted, but faking timestamp field can and
        	SHOULD.  A protocol using the LEDBAT congestion control
        	SHOULD authenticate the timestamp and delay fields,
        	preferably as part of authenticating most of the rest of
        	the packet, with the exception of volatile header fields.
        	The choice of the authentication mechanism that resists
        	man-in-the-middle attacks is outside of scope of this
        	document.
</p>
<a name="rfc.references1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>9.&nbsp;Normative References</h3>
<table width="99%" border="0">
<tr><td class="author-text" valign="top"><a name="RFC2119">[RFC2119]</a></td>
<td class="author-text"><a href="mailto:sob@harvard.edu">Bradner, S.</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>,&rdquo; BCP&nbsp;14, RFC&nbsp;2119, March&nbsp;1997 (<a href="http://www.rfc-editor.org/rfc/rfc2119.txt">TXT</a>, <a href="http://xml.resource.org/public/rfc/html/rfc2119.html">HTML</a>, <a href="http://xml.resource.org/public/rfc/xml/rfc2119.xml">XML</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC2581">[RFC2581]</a></td>
<td class="author-text"><a href="mailto:mallman@grc.nasa.gov">Allman, M.</a>, <a href="mailto:vern@aciri.org">Paxson, V.</a>, and <a href="mailto:rstevens@kohala.com">W. Stevens</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc2581">TCP Congestion Control</a>,&rdquo; RFC&nbsp;2581, April&nbsp;1999 (<a href="http://www.rfc-editor.org/rfc/rfc2581.txt">TXT</a>).</td></tr>
</table>

<a name="app-additional"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.A"></a><h3>Appendix A.&nbsp;
Timestamp errors</h3>

<p>One-way delay measurement needs to deal with timestamp
			errors. We'll use the same locally linear clock model and
			the same terminology as Network Time Protocol (NTP). This
			model is valid for any differentiable clocks.  NTP uses
			the term "offset" to refer to difference from true time
			and "skew" to refer to difference of clock rate from the
			true rate.  The clock will thus have a fixed offset from
			the true time and a skew.  We'll consider what we need to
			do about the offset and the skew separately.
</p>
<a name="anchor29"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.A.1"></a><h3>A.1.&nbsp;
Clock offset</h3>

<p>First, consider the case of zero skew. The offset of
			  each of the two clocks shows up as a fixed error in
			  one-way delay measurement. The difference of the offsets
			  is the absolute error of the one-way delay estimate. We
			  won't use this estimate directly, however. We'll use the
			  difference between that and a base delay. Because the
			  error (difference of clock offsets) is the same for the
			  current and base delay, it cancels from the queuing
			  delay estimate, which is what we'll use. Clock offset is
			  thus irrelevant to the design.
</p>
<a name="anchor30"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.A.2"></a><h3>A.2.&nbsp;
Clock skew</h3>

<p>Now consider the skew. For a given clock, skew
			  manifests in a linearly changing error in the time
			  estimate.  For a given pair of clocks, the difference in
			  skews is the skew of the one-way delay estimate.  Unlike
			  the offset, this no longer cancels in the computation of
			  the queuing delay estimate.  On the other hand, while
			  the offset could be huge, with some clocks off by
			  minutes or even hours or more, the skew is typically not
			  too bad.  For example, NTP is designed to work with most
			  clocks, yet it gives up when the skew is more than 500
			  parts per million (PPM).  Typical skews of clocks that
			  have never been trained seem to often be around 100-200
			  PPM.  Previously trained clocks could have 10-20 PPM
			  skew due to temperature changes.  A 100-PPM skew means
			  accumulating 6 milliseconds of error per minute.  The
			  expiration of base delay related to route changes mostly
			  takes care of clock skew.  A technique to specifically
			  compute and cancel it is trivially possible and involves
			  tracking base delay skew over a number of minutes and
			  then correcting for it, but usually isn't necessary,
			  unless the target is unusually low, the skew is
			  unusually high, or the base interval is unusually long.
			  It is not further described in this document.
</p>
<p>For cases when the base interval is long or the skew is
			  high or the target is low, a technique to correct for
			  skew can be beneficial. The technique described here or
			  a different mechanism MAY be used by
			  implementations. The technique described is still
			  experimental, but it is actually currently used. The
			  pseudocode in the specification below does not include
			  any of the skew correction algorithms.
</p>
<a name="anchor31"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.A.2.1"></a><h3>A.2.1.&nbsp;
Deployed clock skew correction mechanism</h3>

<p>Clock skew can be in two directions: either the
            sender's clock is faster than the receiver's, or vice
            versa. We refer to the former situation as clock drift "in
            sender's favor" and to the latter as clock drift "in
            receiver's favor".
</p>
<p>When the clock drift is "in sender's favor", nothing
            special needs to be done, because the timestamp
            differences (i.e., the raw delay estimates) will grow
            smaller with time, and thus the base delay will be
            continuously updated with the drift.
</p>
<p>When the clock drift is "in receiver's favor", the raw
            delay estimates will drift up with time, suppressing the
            throughput needlessly. This is the case that can benefit
            from a special mechanism. Assume symmetrical framing
            (i.e., same information about delays transmitted in both
            way). If the sender can detect the receiver reducing its
            base delay, it can infer that this is due to clock drift
            "in receiver's favor". This can be compensated for by
            increasing the sender's base delay by the same
            amount. Since, in our implementation, the receiver sends
            back the raw timestamp estimate, the sender can run the
            same base delay calculation algorithm it runs for itself
            for the receiver as well; when it reduces the inferred
            receiver's delay, it increases its own by the same
            amount.
</p>
<a name="anchor32"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.A.2.2"></a><h3>A.2.2.&nbsp;
Skew correction with faster virtual clock</h3>

<p>This is an alternative skew correction algorithm,
            currently under consideration and not deployed in the
            wild.
</p>
<p>Since having a faster clock on the sender is,
            relatively speaking, a non-problem, one can use two
            different virtual clocks on each LEDBAT implementation:
            use, for example, the default machine clock for situations
            where the instance is acting as a receiver, and use a
            virtual clock, easily computed from the default machine
            clock through a linear transformation, for situations
            where the instance is acting as a sender. Make the virtual
            clock, e.g., 500 PPM faster than the machine clock. Since
            500 PPM is more than the variability of most clocks (plus
            or minus 100 PPM), any sender's clock is very likely to be
            faster than any receiver's clock, thus benefitting from
            the implicit correction of taking the minimum as the base
            delay.
</p>
<p>Note that this approach is not compatible with the one
            described in the preceding section.
</p>
<a name="anchor33"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.A.2.3"></a><h3>A.2.3.&nbsp;
Skew correction with estimating drift</h3>

<p>This is an alternative skew correction algorithm,
            currently under consideration and not deployed in the
            wild.
</p>
<p>The history of base delay minima we already keep for
            each minute provides us with direct means of computing the
            clock skew difference between the two hosts.  Namely, we
            can fit a linear function to the set of base delay
            estimates for each minute. The slope of the function is an
            estimate of the clock skew difference for the given pair
            of sender and receiver. Once the clock skew difference is
            estimated, it can be used to correct the clocks so that
            they advance at nearly the same rate. Namely, the clock
            needs to be corrected by half of the estimated skew
            amount, since the other half will be corrected by the
            other endpoint. Note that the skew differences are then
            maintained for each connection and the virtual clocks used
            with each connection can differ, since they do not attempt
            to estimate the skew with respect to the true time, but
            instead with respect to the other endpoint.
</p>
<a name="anchor34"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.A.2.3.1"></a><h3>A.2.3.1.&nbsp;
Byzantine skew correction</h3>

<p>This is an alternative skew correction algorithm,
            currently under consideration and not deployed in the
            wild.
</p>
<p>When it is known that each host maintains long-lived
            connections to a number of different other hosts, a
            byzantine scheme can be used to estimate the skew with
            respect to the true time. Namely, calculate the skew
            difference for each of the peer hosts as described in the
            preceding section, then take the median of the skew
            differences.
</p>
<p>This inherent clock drift can then be corrected with a
            linear transformation before the clock data is used in the
            algorithm from the preceding section, the currently
            deployed algorithm, or nearly any other skew correction
            algorithm.
</p>
<p>While this scheme is not universally applicable, it
            combines well with other schemes, since it is essentially
            a clock training mechanism. The scheme also acts the
            fastest, since the state is preserved between
            connections.
</p>
<a name="rfc.authors"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>Authors' Addresses</h3>
<table width="99%" border="0" cellpadding="0" cellspacing="0">
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Stanislav Shalunov</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">BitTorrent Inc</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">612 Howard St, Suite 400</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">San Francisco, CA  94105</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">USA</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:shalunov@bittorrent.com">shalunov@bittorrent.com</a></td></tr>
<tr><td class="author" align="right">URI:&nbsp;</td>
<td class="author-text"><a href="http://shlang.com">http://shlang.com</a></td></tr>
<tr cellpadding="3"><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Greg Hazel</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">BitTorrent Inc</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">612 Howard St, Suite 400</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">San Francisco, CA  94105</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">USA</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:greg@bittorrent.com">greg@bittorrent.com</a></td></tr>
<tr cellpadding="3"><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Janardhan Iyengar</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Franklin and Marshall College</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">415 Harrisburg Ave.</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Lancaster, PA  17603</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">USA</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:jiyengar@fandm.edu">jiyengar@fandm.edu</a></td></tr>
</table>
</body></html>
