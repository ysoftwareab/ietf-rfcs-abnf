 Policy Framework Working Group                                 B. Moore
 INTERNET-DRAFT                                              E. Ellesson
 Category: Standards Track                                           IBM
                                                             J. Strassner
                                                            Cisco Systems
                                                             October 1999



                  Policy Framework Core Information Model

                 <draft-ietf-policy-core-info-model-02.txt>
                     Friday, October 22, 1999, 1:22 PM

 Status of this Memo

   This document is an Internet-Draft and is in full conformance with all
   provisions of Section 10 of RFC2026.

   Internet-Drafts are working documents of the Internet Engineering Task
   Force (IETF), its areas, and its working groups.  Note that other
   groups may also distribute working documents as Internet-Drafts.

   Internet-Drafts are draft documents valid for a maximum of six months
   and may be updated, replaced, or obsoleted by other documents at any
   time.  It is inappropriate to use Internet-Drafts as reference
   material or to cite them other than as "work in progress."

   The list of current Internet-Drafts can be accessed at
   http://www.ietf.org/ietf/1id-abstracts.txt

   The list of Internet-Draft Shadow Directories can be accessed at
   http://www.ietf.org/shadow.html

 Copyright Notice

   Copyright (C) The Internet Society (1999).  All Rights Reserved.

 Abstract

   This document presents the object-oriented information model for
   representing policy information currently under development as part of
   the Common Information Model (CIM) activity in the Distributed
   Management Task Force (DMTF).  This CIM model defines two hierarchies
   of object classes:  structural classes representing policy information
   and control of policies, and relationship classes that indicate how
   instances of the structural classes are related to each other. A
   companion document "Policy Framework Core LDAP Schema" [9] defines the
   mapping of this information model to a directory that uses LDAPv3 as
   its access protocol.






 Moore, et al.         Expires: Oct 1999 + 6 months             [Page 1]


 Internet Draft       Policy Core Information Model         October 1999


   Table of Contents

   1. Introduction......................................................4
   2. Modeling Policies.................................................6
      2.1. Policy Scope.................................................8
      2.2. Declarative versus Procedural Model..........................8
   3. Overview of the Policy Core Information Model....................10
   4. Inheritance Hierarchies for the Core Policy Classes and
   Relationships.......................................................13
   5. Details of the Model.............................................15
      5.1. Reusable versus Rule-Specific Conditions and Actions........16
      5.2. Roles and Resource Managers.................................17
      5.3. Naming in the Policy Core Information Model.................18
      5.3.1. Role of the CreationClassName Property in Naming..........18
      5.3.2. Naming Instances of PolicyGroup and PolicyRule............19
      5.3.3. Naming Instances of PolicyCondition and Its Subclasses....20
      5.3.4. Naming Instances of PolicyAction and Its Subclasses.......22
      5.3.5. Naming Instances of PolicyRepository and
      ResourceManagerCollection........................................22
      5.4. CIM Data Types..............................................22
   6. Class Definitions................................................23
      6.1. The Abstract Class "Policy".................................23
      6.1.1. The Property "CommonName (CN)"............................24
      6.1.2. The Multi-valued Property "PolicyKeywords"................24
      6.1.3. The Property "Caption" (Inherited from ManagedElement)....25
      6.1.4. The Property "Description" (Inherited from ManagedElement)25
      6.2. The Class "PolicyGroup".....................................25
      6.2.1. The Propagated Key Property "System.CreationClassName"....26
      6.2.2. The Propagated Key Property "System.Name".................27
      6.2.3. The Key Property "CreationClassName"......................27
      6.2.4. The Key Property "PolicyGroupName"........................27
      6.3. The Class "PolicyRule"......................................27
      6.3.1. The Propagated Key Property "System.CreationClassName"....29
      6.3.2. The Propagated Key Property "System.Name".................29
      6.3.3. The Key Property "CreationClassName"......................30
      6.3.4. The Key Property "PolicyRuleName".........................30
      6.3.5. The Property "Enabled"....................................30
      6.3.6. The Property "ConditionListType"..........................31
      6.3.7. The Property "RuleUsage"..................................31
      6.3.8. The Property "Priority"...................................31
      6.3.9. The Property "Mandatory"..................................31
      6.3.10. The Property "SequencedActions"..........................32
      6.4. The Class "PolicyCondition".................................33
      6.4.1. The Key Property "SystemCreationClassName"................34
      6.4.2. The Key Property "SystemName".............................35
      6.4.3. The Key Property "PolicyRuleCreationClassName"............35
      6.4.4. The Key Property "PolicyRuleName".........................36
      6.4.5. The Key Property "CreationClassName"......................36
      6.4.6. The Key Property "PolicyConditionName"....................36
      6.5. The Class "PolicyTimePeriodCondition".......................37
      6.5.1. The Property "TimePeriod".................................38
      6.5.2. The Property "MonthOfYearMask"............................39


 Moore, et al.         Expires: Oct 1999 + 6 months             [Page 2]


 Internet Draft       Policy Core Information Model         October 1999


      6.5.3. The Property "DayOfMonthMask".............................39
      6.5.4. The Property "DayOfWeekMask"..............................41
      6.5.5. The Property "TimeOfDayMask"..............................41
      6.5.6. The Property "ApplicableTimeZone".........................42
      6.6. The Class "VendorPolicyCondition"...........................43
      6.6.1. The Multi-valued Property "Constraint"....................43
      6.6.2. The Property "ConstraintEncoding".........................44
      6.7. The Class "PolicyAction"....................................44
      6.7.1. The Key Property "SystemCreationClassName"................45
      6.7.2. The Key Property "SystemName".............................45
      6.7.3. The Key Property "PolicyRuleCreationClassName"............46
      6.7.4. The Key Property "PolicyRuleName".........................46
      6.7.5. The Key Property "CreationClassName"......................46
      6.7.6. The Key Property "PolicyActionName".......................47
      6.8. The Class "VendorPolicyAction"..............................47
      6.8.1. The Multi-valued Property "ActionData"....................47
      6.8.2. The Property "ActionEncoding".............................48
      6.9. The Class "PolicyRepository"................................48
      6.9.1. The Key Property "CreationClassName"......................49
      6.9.2. The Key Property "PolicyRepositoryName"...................49
      6.10. The Class "ResourceManagerCollection"......................49
      6.10.1. The Key Property "CreationClassName".....................49
      6.10.2. The Key Property "ResourceManagerCollectionName".........50
      6.10.3. The Multi-valued Property "ResourceManagerType"..........50
   7. Association and Aggregation Definitions..........................50
      7.1. Relationships...............................................50
      7.2. Associations................................................51
      7.3. Aggregations................................................51
      7.4. The Aggregation "PolicyGroupInPolicyGroup"..................51
      7.4.1. The Reference "ContainingGroup"...........................51
      7.4.2. The Reference "ContainedGroup"............................52
      7.5. The Aggregation "PolicyRuleInPolicyGroup"...................52
      7.5.1. The Reference "ContainingGroup"...........................52
      7.5.2. The Reference "ContainedRule".............................52
      7.6. The Aggregation "ConditionInPolicyRule".....................52
      7.6.1. The Reference "ContainingRule"............................53
      7.6.2. The Reference "ContainedCondition"........................53
      7.6.3. The Property "GroupNumber"................................54
      7.6.4. The Property "ConditionNegated"...........................54
      7.7. The Association "ConditionSubject"..........................54
      7.7.1. The Reference "Subject"...................................55
      7.7.2. The Reference "Condition".................................55
      7.8. The Association "ConditionTarget"...........................55
      7.8.1. The Reference "Target"....................................56
      7.8.2. The Reference "Condition".................................56
      7.9. The Aggregation "PolicyRuleValidityPeriod"..................56
      7.9.1. The Reference "ContainingRule"............................57
      7.9.2. The Reference "ContainedPtp"..............................57
      7.10. The Aggregation "ActionInPolicyRule".......................57
      7.10.1. The Reference "ContainingRule"...........................58
      7.10.2. The Reference "ContainedAction"..........................58
      7.10.3. The Property "ActionOrder"...............................58


 Moore, et al.         Expires: Oct 1999 + 6 months             [Page 3]


 Internet Draft       Policy Core Information Model         October 1999


      7.11. The Association "ConditionInPolicyRepository"..............59
      7.11.1. The Reference "ContainingRepository".....................59
      7.11.2. The Reference "ContainedCondition".......................59
      7.12. The Association "ActionInPolicyRepository".................60
      7.12.1. The Reference "ContainingRepository".....................60
      7.12.2. The Reference "ContainedAction"..........................60
      7.13. The Weak Association "PolicyGroupInSystem".................60
      7.13.1. The Reference "ContainingSystem".........................61
      7.13.2. The Reference "ContainedGroup"...........................61
      7.14. The Weak Association "PolicyRuleInSystem"..................61
      7.14.1. The Reference "ContainingSystem".........................61
      7.14.2. The Reference "ContainedRule"............................61
      7.15. The Aggregation "PolicyRepositoryInPolicyRepository".......62
      7.15.1. The Reference "ContainingRepository".....................62
      7.15.2. The Reference "ContainedRepository"......................62
      7.16. The Association "ResourceManagerCollectionPolicyGroup".....62
      7.17. The Association "ResourceManagerCollectionPolicyRule"......63
      7.18. The Aggregation "MemberResourceManager"....................63
      7.19. The Association "ResourceManagerPolicyGroup"...............64
      7.20. The Association "ResourceManagerPolicyRule"................64
      7.21. The Association "ResourceManagerManagedResource"...........64
   8. Intellectual Property............................................64
   9. Acknowledgements.................................................65
   10. Security Considerations.........................................65
   11. References......................................................67
   12. Authors' Addresses..............................................68
   13. Full Copyright Statement........................................68



 1. Introduction

    +-------------------------------------------------------------------+
    |NOTE:  Because of the short time between the most recent DMTF WG   |
    |       meetings and the IETF's Internet-Draft cutoff date, this    |
    |       document has been updated without a corresponding update    |
    |       to the LDAP Core Schema document.  Thus this document,      |
    |       <draft-ietf-policy-core-info-model-02.txt>, is temporarily  |
    |       out of step with <draft-ietf-policy-core-schema-05.txt>.    |
    |       The goal is to get the documents back in sync by publishing |
    |       <draft-ietf-policy-core-schema-06.txt>, after the Internet- |
    |       Draft cutoff, but prior to the Washington IETF.  A URL for  |
    |       retrieving this updated document will be sent to the Policy |
    |       mailing list.                                               |
    +-------------------------------------------------------------------+

   This document presents the object-oriented information model for
   representing policy information currently under development as part of
   the Common Information Model (CIM) activity in the Distributed
   Management Task Force (DMTF).  This CIM model defines two hierarchies
   of object classes: structural classes representing policy information
   and control of policies, and relationship classes that indicate how


 Moore, et al.         Expires: Oct 1999 + 6 months             [Page 4]


 Internet Draft       Policy Core Information Model         October 1999


   instances of the structural classes are related to each other. A
   companion document "Policy Framework Core LDAP Schema" [9] defines the
   mapping of this information model to a directory that uses LDAPv3 as
   its access protocol.

   The policy classes and relationships defined in the CIM model are
   sufficiently generic to allow them to represent policies related to
   anything.  However, it is expected that their initial application in
   the IETF will be for representing policies related to QoS (DiffServ
   and IntServ) and to IPSec.  Policy models for application-specific
   areas such as these may extend the Core Model in several ways.  The
   preferred way is to use the PolicyGroup, PolicyRule, and
   PolicyTimePeriodCondition classes directly, as a foundation for
   representing and communicating policy information.  Then, specific
   subclasses derived from PolicyCondition and PolicyAction can capture
   application-specific definitions of conditions and actions of
   policies.

   Two subclasses, VendorPolicyCondition and VendorPolicyAction, are also
   included in this document, to provide a standard escape mechanism for
   vendor-specific extensions to the Policy Core Information Model.

   This document fits into the overall framework for representing,
   deploying, and managing policies being developed by the Policy
   Framework Working Group.  The initial work to define this framework is
   in reference [1].  More specifically, this document builds on the core
   policy classes first introduced in references [2] and [3].  It also
   draws on the work done for the Directory-enabled Networks (DEN)
   specification, reference [4].  Work on the DEN specification by the
   DEN Ad-Hoc Working Group itself has been completed.  Further work to
   standardize the models contained in it will be the responsibility of
   selected working groups of the CIM effort in the Distributed
   Management Task Force (DMTF).  Standardization of the core policy
   model is the responsibility of the SLA Policy working group.

   This document is organized in the following manner:

   o Section 2 provides a general overview of policies and how they are
      modeled.

   o Section 3 presents a high-level overview of the classes and
      relationships comprising the Policy Core Information Model.

   o The remainder of the document presents the detailed specifications
      for each of the classes and relationships.

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED",  "MAY", and "OPTIONAL" in this
   document are to be interpreted as described in RFC 2119, reference
   [5].




 Moore, et al.         Expires: Oct 1999 + 6 months             [Page 5]


 Internet Draft       Policy Core Information Model         October 1999


 2. Modeling Policies

   The classes comprising the Policy Core Information Model are intended
   to serve as an extensible class hierarchy (through specialization) for
   defining policy objects that enable application developers, network
   administrators, and policy administrators to represent policies of
   different types.

   One way to think of a policy-controlled network is to first model the
   network as a state machine and then use policy to control which state
   a policy-controlled device should be in or is allowed to be in at any
   given time.  Given this approach, policy is applied using a set of
   policy rules.  Each policy rule consists of a set of conditions and a
   set of actions.  Policy rules may be aggregated into policy groups.
   These groups may be nested, to represent a hierarchy of policies.

   The set of conditions associated with a policy rule specifies when the
   policy rule is applicable.  The set of conditions can be expressed as
   either an ORed set of ANDed sets of condition statements or an ANDed
   set of ORed sets of statements.  Individual condition statements can
   also be negated.  These combinations are termed, respectively,
   Disjunctive Normal Form (DNF) and Conjunctive Normal Form (CNF) for
   the conditions.

   If the set of conditions associated with a policy rule evaluates to
   TRUE, then a set of actions that either maintain the current state of
   the object or transition the object to a new state may be executed.
   For the set of actions associated with a policy rule, it is possible
   to specify an order of execution, as well as an indication of whether
   the order is required or merely recommended.  It is also possible to
   indicate that the order in which the actions are executed does not
   matter.

   Policy rules themselves can be prioritized.  One common reason for
   doing this is to express an overall policy that has a general case
   with a few specific exceptions.

   For example, a general QoS policy rule might specify that traffic
   originating from members of the engineering group is to get Bronze
   Service.  A second policy rule might express an exception: traffic
   originating from John, a specific member of the engineering group, is
   to get Gold Service.  Since traffic originating from John satisfies
   the conditions of both policy rules, and since the actions associated
   with the two rules are incompatible, a priority needs to be
   established.  By giving the second rule (the exception) a higher
   priority than the first rule (the general case), a policy
   administrator can get the desired effect: traffic originating from
   John gets Gold Service, and traffic originating from all the other
   members of the engineering group gets Bronze Service.

   Policies can either be used in a stand-alone fashion or aggregated
   into policy groups to perform more elaborate functions. Stand-alone


 Moore, et al.         Expires: Oct 1999 + 6 months             [Page 6]


 Internet Draft       Policy Core Information Model         October 1999


   policies are called policy rules. Policy groups are aggregations of
   policy rules, or aggregations of policy groups, but not both. Policy
   groups can model intricate interactions between objects that have
   complex interdependencies. Examples of this include a sophisticated
   user logon policy that sets up application access, security, and
   reconfigures network connections based on a combination of user
   identity, network location, logon method and time of day. A policy
   group represents a unit of reusability and manageability in that its
   management is handled by an identifiable group of administrators and
   its policy rules apply equally to the scope of the policy group.

   Stand-alone policies are those that can be expressed in a simple
   statement. They can be represented effectively in schemata or MIBs.
   Examples of this are VLAN assignments, simple YES/NO QoS requests, and
   IP address allocations. A specific design goal of this model is to
   support both stand-alone and aggregated policies.

   Policy groups and rules can be classified by their purpose and intent.
   This classification is useful in querying or grouping policy rules.
   It indicates whether the policy is used to motivate when or how an
   action occurs, or to characterize services (that can then be used, for
   example, to bind clients to network services).  Describing each of
   these concepts in more detail,

   o Motivational Policies are solely targeted at whether or how a
     policy's goal is accomplished.  Configuration and Usage Policies
     are specific kinds of Motivational Policies.  Another example is
     the scheduling of file backup based on disk write activity from 8am
     to 3pm, M-F.

   o Configuration Policies define the default (or generic) setup of a
     managed entity (for example, a network service).  Examples of
     Configuration Policies are the setup of a network forwarding
     service or a network-hosted print queue.

   o Installation Policies define what can and cannot be put on a system
     or component, as well as the configuration of the mechanisms that
     perform the install. Installation policies typically represent
     specific administrative permissions, and can also represent
     dependencies between different components (e.g., to complete the
     installation of component A, components B and C must be previously
     successfully installed or uninstalled).

   o Error and Event Policies. For example, if a device fails between
     8am and 9pm, call the system administrator, otherwise call the Help
     Desk.

   o Usage Policies control the selection and configuration of entities
     based on specific "usage" data.  Configuration Policies can be
     modified or simply re-applied by Usage Policies.  Examples of Usage
     Policies include upgrading network forwarding services after a user
     is verified to be a member of a "gold" service group, or


 Moore, et al.         Expires: Oct 1999 + 6 months             [Page 7]


 Internet Draft       Policy Core Information Model         October 1999


     reconfiguring a printer to be able to handle the next job in its
     queue.

   o Security Policies deal with verifying that the client is actually
     who the client purports to be, permitting or denying access to
     resources, selecting and applying appropriate authentication
     mechanisms, and performing accounting and auditing of resources.

   o Service Policies characterize network and other services (not use
     them). For example, all wide-area backbone interfaces shall use a
     specific type of queuing.

     Service policies describe services available in the network. Usage
     policies describe the particular binding of a client of the network
     to services available in the network.

   These categories are represented in the Policy Core Information Model
   by special values defined for the PolicyKeywords property of the
   abstract class Policy.

 2.1. Policy Scope

   Policies represent business goals and objectives.  A translation must
   be made between these goals and objectives and their realization in
   the network. An example of this could be a Service Level Agreement
   (SLA), and its objectives and metrics (Service Level Objectives, or
   SLOs), that are used to specify services that the network will provide
   for a given client [8].  The SLA will usually be written in high-level
   business terminology. SLOs address more specific metrics in support of
   the SLA. These high-level descriptions of network services and metrics
   must be translated into lower-level, but also vendor- and device-
   independent specifications. The Policy Core Information Model classes
   are intended to serve as the foundation for these vendor- and device-
   independent specifications.

   It is envisioned that the definition of policy in this draft is
   generic in nature and is applicable to Quality of Service (QoS), to
   non-QoS networking applications (e.g., DHCP and IPSEC), and to non-
   networking applications (e.g., backup policies, auditing access,
   etc.).

 2.2. Declarative versus Procedural Model

   The Policy Core Information Model is declarative, not procedural.
   Given that standardization efforts in policy should address policy
   definitions at the Role level, the next issue is to decide on a
   language framework to define policies.  There are several design
   considerations and trade-offs to make in this respect.

   1.  On one hand, we would like a policy definition language to be
       reasonably human-friendly for ease of definitions and
       diagnostics.  On the other hand, given the diversity of devices


 Moore, et al.         Expires: Oct 1999 + 6 months             [Page 8]


 Internet Draft       Policy Core Information Model         October 1999


       (in terms of their processing capabilities) which could act as
       policy decision points, we would like to keep the language
       somewhat machine-friendly, i.e., relatively simple to automate
       the parsing and processing in network elements.

  2.  An important decision to make is the semantic style of the
       language, e.g., procedural or declarative.

       o  The procedural approach would model network behavior that is
           to be regulated through policy in terms of states and
           pertinent events.  In this model, policy directives are
           statements that control the state transitions and thereby
           regulate the network behavior.  An example of state is
           installing or removal of packet classification filters  and
           the appropriate configuration actions for traffic
           conditioning.  Examples of events include device boot-up,
           packet arrival, etc.

       o  The declarative approach would simply describe the desired
           network behavior in terms of certain actions that should
           happen when specific conditions hold.  For example, a policy
           directive that states that packets matching a specific traffic
           profile must be conditioned in a certain way is formulated in
           terms of conditions that describe the traffic profile and
           actions that describe the traffic conditioning behavior.  A
           policy rule in this approach is written as "if (policy
           condition) then <policy action>."

       The declarative approach has the benefit of simplicity, and
       facilitates hiding implementation differences, making it a
       suitable candidate for the policy definition language standard.

  3.  It is important to control the complexity of the language
       specification trading off richness in terms of features for ease
       of implementation.  It is important to acknowledge the collective
       lack of experience in the field of networking policies and hence
       avoid the temptation of aiming for "completeness".  We should
       strive to facilitate definition of the common policies that
       customers require today (e.g.  VPN, QoS) and allow migration
       paths towards supporting complex policies as customer needs and
       our understanding of networking policies evolve with experience.
       Specifically, in the context of the declarative style language
       discussed above, it is important to avoid having full blown
       predicate calculus as the language as it would render many
       important problems such as consistency checking and policy
       decision point algorithms intractable.  It is useful to consider
       a reasonably constrained language from these perspectives.







 Moore, et al.         Expires: Oct 1999 + 6 months             [Page 9]


 Internet Draft       Policy Core Information Model         October 1999


 3. Overview of the Policy Core Information Model

   The following diagram provides an overview of the five central classes
   comprising the Policy Core Information Model, their relationships to
   each other, and their relationships to other classes in the overall
   CIM model.  Note that the abstract class Policy and the two extension
   classes VendorPolicyCondition and VendorPolicyAction are not shown.

   NOTE:  For cardinalities, "*" is an abbreviation for "0..n".













































 Moore, et al.         Expires: Oct 1999 + 6 months            [Page 10]


 Internet Draft       Policy Core Information Model         October 1999


   +-------------------------------+   +---------------------+*
   | CIM_ResourceManagerCollection |   |     CIM_Service     <.....
   +-^----------------^--------^---+   +---^-----^-------^---+    .
     .*               .*       .*   (c)    .*    .*      .*       .
     .(a)             .(b)     .............     .(d)    .(e)     .(f)
     .                .    .......................       .        .*
     .                .    .                     .........   +----v----+
     .  ...............    .      +-----------+  .           | CIM_MSE |
     .  .                  .      |CIM_System |  .           +---------+
     .  .      .....       .      +--^-----^--+  .    .....
     .  .      .   .       .        1.    1.     .    .   .
     .  .     *.(g).*      .         .(h)  .(i)  .   *.(j).*
     .  .   +--v---v-------v-+       .     .     .  +-v---v------------+
     .  ....>  PolicyGroup   <........     .     .  | PolicyRepository |
     .     *|                | w *         .     .  |                  |
     .      +------^---------+             .     .  +-----^---------^--+
     .            *.                       .     .   0..1 .    0..1 .
     .             .(k)                    .     .        .(l)      .(m)
     .            *.                       .     .        .         .
     .      +------v------+ w *            .     .        .         .
     .      |             <.................     .        .         .
     .      | PolicyRule  |                      .        .         .
     .      |             <.......................        .         .
     .      |             |                               .         .
     .......>             <........................       .         .
           *|             |*      (n)             .       .         .
            |             |                       .       .         .
            |             |  +----------------+   .       .         .
            |             |  | ManagedElement |   .       .         .
            |             |  +---^---------^--+   .       .         .
            |             |      .*        .*     .       .         .
            |             |      .(o)      .(p)   .       .         .
            |             |      .         .*     .*      .*        .
            |             |      .      +--v------v-------v----+    .
            |             |      .......> PolicyCondition      |    .
            |             |            *+----------------------+    .
            |             |       (q)                ^              .
            |             <..............            I              .
            |             |*            .            I              .
            |             |             .*           ^              .
            |             |        +----v----------------------+    .
            |             |        | PolicyTimePeriodCondition |    .
            |             |        +---------------------------+    .
            |             |       (r)                               .
            |             <.........................                .
            |             |*                       .                .
            |             |                        .*               .
            |             |             +----------v---------+*     .
            |             |             | PolicyAction       <.......
            +-------------+             +--------------------+

   Figure 1.    Overview of the Core Policy Classes and Relationships


 Moore, et al.         Expires: Oct 1999 + 6 months            [Page 11]


 Internet Draft       Policy Core Information Model         October 1999


   In this figure the boxes represent the classes, and the dotted arrows
   represent the relationships.  The following relationships appear:

   (a)     ResourceManagerCollectionPolicyRule

   (b)     ResourceManagerCollectionPolicyGroup

   (c)     MemberResourceManager

   (d)     ResourceManagerPolicyGroup

   (e)     ResourceManagerPolicyRule

   (f)     ResourceManagerManagedResource

   (g)     PolicyGroupInPolicyGroup

   (h)     PolicyGroupInSystem

   (i)     PolicyRuleInSystem

   (j)     PolicyRepositoryInPolicyRepository

   (k)     PolicyRuleInPolicyGroup

   (l)     ConditionInPolicyRepository

   (m)     ActionInPolicyRepository

   (n)     ConditionInPolicyRule

   (o)     ConditionSubject

   (p)     ConditionTarget

   (q)     PolicyRuleValidityPeriod

   (r)     ActionInPolicyRule

   A relationship always connects two classes.  The "two" classes may,
   however, be the same class, as is the case with the
   PolicyGroupInPolicyGroup relationship, which represents the recursive
   containment of PolicyGroups in other PolicyGroups.  The
   PolicyRepositoryInPolicyRepository association is recursive in the
   same way.

   A relationship has associated with it cardinalities for each of the
   related classes.  These cardinalities indicate how many instances of
   each class may be related to an instance of the other class.  For
   example, the PolicyRuleInPolicyGroup relationship has the cardinality
   range "*' (that is, "0..n") for both the PolicyGroup and PolicyRule
   classes.  These ranges are interpreted as follows:


 Moore, et al.         Expires: Oct 1999 + 6 months            [Page 12]


 Internet Draft       Policy Core Information Model         October 1999


   o The "*" written next to PolicyGroup indicates that a PolicyRule may
     be related to no PolicyGroups, to one PolicyGroup, or to more than
     one PolicyGroup via the PolicyGroupInPolicyGroup relationship.  In
     other words, a PolicyRule may be contained in no PolicyGroups, in
     one PolicyGroups, or in more than one PolicyGroup.

   o The "*" written next to PolicyRule indicates that a PolicyGroup may
     be related to no PolicyRules, to one PolicyRule, or to more than
     one PolicyRule via the PolicyGroupInPolicyGroup relationship.  In
     other words, a PolicyGroup may contain no PolicyRules, one
     PolicyRule, or more than one PolicyRule.

   The "w" written next to the PolicyGroupInSystem and PolicyRuleInSystem
   indicates that these are what CIM terms "aggregations with weak
   references", or more briefly, "weak aggregations."   A weak
   aggregation is simply an indication of a naming scope.  Thus these two
   aggregations indicate that an instance of a PolicyGroup or PolicyRule
   is named within the scope of a System object.  A weak aggregation
   implicitly has the cardinality 1..1 at the end opposite the 'w'.

   The relationships shown in Figure 1 are discussed in more detail in
   Section 7.


 4. Inheritance Hierarchies for the Core Policy Classes and Relationships

   The following diagram illustrates the inheritance hierarchy for the
   core policy classes:


























 Moore, et al.         Expires: Oct 1999 + 6 months            [Page 13]


 Internet Draft       Policy Core Information Model         October 1999


     ManagedElement (abstract)
      |
      +--Policy (abstract)
      |  |
      |  +---PolicyGroup
      |  |
      |  +---PolicyRule
      |  |
      |  +---PolicyCondition
      |  |          |
      |  |          +---PolicyTimePeriodCondition
      |  |          |
      |  |          +---VendorPolicyCondition
      |  |
      |  +---PolicyAction
      |             |
      |             +---VendorPolicyAction
      |
      +--System (abstract)
      |  |
      |  +---AdminDomain (abstract)
      |             |
      |             +---PolicyRepository
      |
      +--Collection (abstract)
         |
         +--ResourceManagerCollection

   Figure 2.    Inheritance Hierarchy for the Core Policy Classes

   The System and AdminDomain classes are defined in the current version
   of the CIM model [7], and the ManagedElement and Collection classes
   are currently being defined by the DMTF's User WG.  These classes are
   not discussed in detail in this document.

   In CIM, relationships are also modeled as classes.  For the Policy
   Core Information Model, the inheritance hierarchy for the
   relationships has, with one exception, only a single level:
















 Moore, et al.         Expires: Oct 1999 + 6 months            [Page 14]


 Internet Draft       Policy Core Information Model         October 1999


     [unrooted]
      |
      +---PolicyGroupInPolicyGroup
      |
      +---PolicyRuleInPolicyGroup
      |
      +---PolicyGroupInSystem
      |
      +---PolicyRuleInSystem
      |
      +---ConditionInPolicyRule
      |
      +---ConditionSubject
      |
      +---ConditionTarget
      |
      +---PolicyRuleValidityPeriod
      |
      +---ActionInPolicyRule
      |
      +---ConditionInPolicyRepository
      |
      +---ActionInPolicyRepository
      |
      +---PolicyRepositoryInPolicyRepository
      |
      +---ResourceManagerCollectionPolicyGroup
      |
      +---ResourceManagerCollectionPolicyRule
      |
      +---MemberService
      |   |
      |   +---MemberResourceManager
      |
      +---ResourceManagerPolicyGroup
      |
      +---ResourceManagerPolicyRule
      |
      +---ResourceManagerManagedResource


   Figure 3.    Inheritance Hierarchy for the Core Policy Relationships




 5. Details of the Model

   The following subsections discuss several specific issues related to
   the CIM Core Policy model.




 Moore, et al.         Expires: Oct 1999 + 6 months            [Page 15]


 Internet Draft       Policy Core Information Model         October 1999


 5.1. Reusable versus Rule-Specific Conditions and Actions

   Policy conditions and policy actions can be partitioned into two
   groups:  ones associated with a single policy rule, and ones that are
   reusable, in the sense that they may be associated with more than one
   policy rule.  Conditions and actions in the first group are termed
   "rule-specific" conditions and actions; those in the second group are
   characterized as "reusable".

   It is important to understand that the difference between a rule-
   specific condition or action and a reusable one is based on the intent
   of the policy administrator for the condition or action, rather than
   on the current associations in which the condition or action
   participates.  Thus a reusable condition or action (that is, one that
   a policy administrator has created to be reusable) may at some point
   in time be associated with exactly one policy rule, without thereby
   becoming rule-specific.

   There is no inherent difference between a rule-specific condition or
   action and a reusable one.  There are, however, differences in how
   they are treated in a policy repository.  For example, it's natural to
   make the access permissions for a rule-specific condition or action
   identical to those for the rule itself.  It's also natural for a rule-
   specific condition or action to be removed from the policy repository
   at the same time the rule is.  With reusable conditions and actions,
   on the other hand, access permissions and existence criteria must be
   expressible without reference to a policy rule.

   The preceding paragraph does not contain an exhaustive list of the
   ways in which reusable and rule-specific conditions should be treated
   differently.  Its purpose is merely to justify making a semantic
   distinction between rule-specific and reusable, and then reflecting
   this distinction in the policy repository itself.

   Another issue is highlighted by reusable and rule-specific policy
   conditions and policy actions:  the lack of a capability in CIM for
   expressing complex constraints involving multiple associations.
   Taking PolicyCondition as an example, there are two aggregations to
   look at.  ConditionInPolicyRule has the cardinality [*   ] at both
   ends, and ConditionInPolicyRepository has the cardinality [0..n] at
   the PolicyCondition end, and [0..1] at the PolicyRepository end.

   Globally, these cardinalities are correct.  However, there's more to
   the story, which only becomes clear if we examine the cardinalities
   separately for the two cases of a rule-specific PolicyCondition and a
   reusable one.

   For a rule-specific PolicyCondition, the cardinality of
   ConditionInPolicyRule at the PolicyRule end is [1..1], rather than
   [0..n], since the condition is unique to one policy rule.  And the
   cardinality of ConditionInPolicyRepository at the PolicyRepository end
   is [0..0].


 Moore, et al.         Expires: Oct 1999 + 6 months            [Page 16]


 Internet Draft       Policy Core Information Model         October 1999


   For a reusable PolicyCondition, however, the cardinality of
   ConditionInPolicyRepository at the PolicyRepository end is [1..1], and
   that of the ConditionInPolicyRule at the PolicyRule end is [0..n].
   This last point is important:  a reusable PolicyCondition may be
   associated with 0, 1, or more than 1 PolicyRules, via exactly the same
   association ConditionInPolicyRule that supports manual propagation of
   key values (from a single PolicyRule) in the case of a rule-specific
   PolicyCondition.  But the reusable PolicyCondition gets its key values
   via a different association ConditionInPolicyRepository.

   Currently the only way to document constraints of this type in CIM is
   textually.  People in the DMTF are beginning to think about how CIM
   might be extended to accommodate more formal methods for documenting
   complex constraints.

 5.2. Roles and Resource Managers

   The concept of role is central to the design of the entire Policy
   Framework.  (For more on roles, see reference [11].)  The idea behind
   roles is a simple one.  Rather than configuring, and then later having
   to update the configuration of, hundreds or thousands (or more) of
   resources in a network, a policy administrator assigns each resource
   to one or more roles, and then specifies the policies for each of
   these roles.  The Policy Framework is then responsible for configuring
   each of the resources associated with a role in such a way that it
   behaves according to the policies specified for that role.  When
   network behavior must be changed, the policy administrator can perform
   a single update to the policy for a role, and the Policy Framework
   will insure that the necessary configuration updates are performed on
   all the resources playing that role.

                  +---------------------------+
                  | ResourceManagerCollection |
                  |   RMType = {"FR"}         |
                  +---------------------------+

          +----------------------+       +----------------------+
          | Router 1             |       | Router 2             |
          |                      |       |                      |
          | +-----------------+  |       | +-----------------+  |
          | | ResourceManager |  |       | | ResourceManager |  |
          | |  RMType = {"FR"}|  |       | |  RMType = {"FR"}|  |
          | +-----------------+  |       | +-----------------+  |
          | FR-1a  FR-1b  FR 1-c |       | FR-2a  FR-2b  FR 2-c |
          +----------------------+       +----------------------+

   Figure 4.    The ResourceManagerCollection Object

   Roles are represented in the Core Model by the class
   ResourceManagerCollection.  As Figure 4 illustrates, there is a three-
   level hierarchy:



 Moore, et al.         Expires: Oct 1999 + 6 months            [Page 17]


 Internet Draft       Policy Core Information Model         October 1999


   o A ResourceManagerCollection is an abstraction that represents a set
     of individual resource managers within a policy domain.

   o A resource manager is a component that manages access to and use of
     a set of resources.

   o The resources themselves are under the control of a resource
     manager.

   In Figure 4, the resources in question are individual frame relay
   interfaces.  Each router has a resource manager component that manages
   all of its frame relay interfaces.  Finally, the model contains an
   abstraction representing the collection of all the frame relay
   interfaces in all the routers within the policy domain.  This
   abstraction corresponds to the role "Frame Relay Interface".

   The Core Model contains a number of relationships for navigating among
   the elements shown in Figure 4:

   o Associations between PolicyGroup and PolicyRule on the one hand,
     and ResourceManagerCollection on the other, which tie policies to
     roles.

   o Alternatively, associations between PolicyGroup and PolicyRule on
     the one hand, and ResourceManager on the other, which bypass roles,
     and tie policies directly to individual resource managers.

   o A MemberResourceManager aggregation, which ties a
     ResourceManagerCollection to its constituent resource managers.

   o A ResourceManagerManagedResource association to tie a resource
     manager to the individual resources that it manages.

   Once this set of relationships has been set up, it is possible for the
   policy administrator to influence the behavior of all of these frame
   relay interfaces by updating a single policy object.

 5.3. Naming in the Policy Core Information Model

   While the CommonName property is present in the abstract superclass
   Policy, and is thus available in all of its instantiable subclasses,
   the Policy Core Information Model does not use this property for
   naming instances.  (The directory attribute commonName to which the
   CommonName property maps is, however, available as one of the options
   for instance naming in the Policy Framework LDAP Core Schema [9].)
   The following subsections discuss how naming is handled in each of the
   instantiable classes in the Policy Core Information Model.

 5.3.1. Role of the CreationClassName Property in Naming

   To provide for more flexibility in instance naming, CIM makes use of a
   property called CreationClassName.  The idea of CreationClassName is


 Moore, et al.         Expires: Oct 1999 + 6 months            [Page 18]


 Internet Draft       Policy Core Information Model         October 1999


   to provide another dimension that can be used to avoid naming
   collisions, in the specific case of instances belonging to two
   different subclasses of a common instantiable superclass.  An example
   will illustrate how CreationClassName works.

   Suppose we have instances of two different subclasses of
   PolicyCondition, FrameRelayPolicyCondition and BgpPolicyCondition, and
   that these instances apply to the same context.  If we had only the
   single key property PolicyConditionName available for distinguishing
   the two instances, then a collision would result from naming both of
   the instances with the key value PCName = "PC-1".  Thus policy
   administrators from widely different disciplines would have to
   coordinate their naming of PolicyConditions for this context.

   With CreationClassName, collisions of this type are eliminated,
   without requiring coordination among the policy administrators.  The
   two instances would now be distinguishable because of the fact that
   their CreationClassNames would have different values.  One instance is
   now identified with the two keys

   CreationClassName = "FrameRelayPolicyCondition" + PCName = "PC-1",

   while the other is identified with

   CreationClassName = "BgpPolicyCondition" + PCName = "PC-1".

   Each of the instantiable classes in the Core Model includes the
   CreationClassName property as a key in addition to its own class-
   speific key property.

 5.3.2. Naming Instances of PolicyGroup and PolicyRule

   A policy group always exists in some context.  In the Policy Core
   Information Model, this contextual character of a policy group is
   captured by the weak aggregation PolicyGroupInSystem between a
   PolicyGroup and a System.  When a CIM relationship is specified as
   "weak", this is a statement about naming scopes:  an instance of the
   class at the weak end of the relationship is named within the scope of
   an instance of the class at the other end of the relationship.  This
   is accomplished by propagation of keys from the instance of the
   scoping class to the instance of the weak class.  Thus the weak class
   has, via propagation, all the keys from the scoping class, and it also
   has one or more additional keys (unless the weak class is abstract)
   for distinguishing instances of the weak class named within the scope
   of the same instance of the scoping class.

   A policy rule must also exist in some context.  In the Policy Core
   Information Model, this contextual character of a policy rule is
   captured by the weak association PolicyRuleInSystem between a
   PolicyRule and a System.




 Moore, et al.         Expires: Oct 1999 + 6 months            [Page 19]


 Internet Draft       Policy Core Information Model         October 1999


 5.3.3. Naming Instances of PolicyCondition and Its Subclasses

   As indicated above in Section 5.1, the single class PolicyCondition is
   used to represent both reusable and rule-specific policy conditions.
   The distinction between the two types of policy conditions lies in the
   relationships that different instances of PolicyCondition participate
   in, and in how the different instances are named.  Conceptually, a
   reusable policy condition resides in a policy repository, and is named
   within the scope of that repository.  On the other hand, a rule-
   specific policy condition is, as the name suggests, named within the
   scope of the single policy rule to which it is related.

   Naming scopes are represented in CIM by means of weak associations.
   However, CIM has the restriction that a given class can only
   participate at the weak end of one weak association.  Another way of
   expressing the restriction is to say that all instances of a given
   class must be named within the scope of the same class (or in the
   scope of no class at all, if they are named directly in the global CIM
   name space).  Clearly, then, the CIM naming architecture is not
   capable of expressing what we need it to express:  that a given
   PolicyCondition instance is named EITHER in the scope of a policy rule
   (if it is a rule-specific condition) OR in the scope of a policy
   repository (if it is a reusable one).

   To work around this restriction (which may be removed in a future
   version of CIM), it is necessary to "simulate" weak associations
   between PolicyCondition and PolicyRule and between PolicyCondition and
   PolicyRepository, through a technique we'll call manual key
   propagation.

   Figure 5 illustrates how manual propagation works in the case of
   PolicyCondition; note that only the key properties are shown for each
   of the classes.  In the figure, the line composed of 'I's indicates
   class inheritance, the one composed of 'P's indicates (true) key
   propagation via the weak aggregation PolicyRuleInSystem, and the ones
   composed of 'M's indicate manual key propagation.


















 Moore, et al.         Expires: Oct 1999 + 6 months            [Page 20]


 Internet Draft       Policy Core Information Model         October 1999


       +------------------+
       |      System      |
       +------------------+
       |CreationClassName |
       |Name              |
       +------------------+
                 ^     P
                 I     PPPPPPPPPPPPPPPPPPPPPPPPPP
                 I                              P
       +------------------+       +-------------v------------+
       |    AdminDomain   |       |         PolicyRule       |
       +------------------+       +--------------------------+
       |CreationClassName |       | System.CreationClassName |
       |Name              |       | System.Name              |
       +------------------+       | CreationClassName        |
                 ^                | PolicyRuleName           |
                 I                +--------------------------+
                 I                         M
                 I                         M
       +------------------+                M
       | PolicyRepository |                M
       +------------------+                M
       |CreationClassName |                M
       |Name              |                M
       +------------------+                M
                       M                   M
                       M(*)                M
                       M                   M
                  +----v-------------------v----+
                  |       PolicyCondition       |
                  +-----------------------------+
                  | SystemCreationClassName     |
                  | SystemName                  |
                  | PolicyRuleCreationClassName |
                  | PolicyRuleName              |
                  | CreationClassName           |
                  | PolicyConditionName         |
                  +-----------------------------+


   (*) Note that as part of this manual propagation, the special string
   "No Rule" is assigned to the PolicyRuleCreationClassName and
   PolicyRuleName properties.

   Figure 5.       Manual Key Propagation for Naming PolicyConditions

   Looking at Figure 5, we see that two key properties
   SystemCreationClassName and Name are defined in the System Class, and
   inherited by its subclasses AdminDomain and PolicyRepository.  Since
   PolicyRule is weak to System, these two keys are propagated to it; it
   also has its own keys CreationClassName and PolicyRuleName.  The "dot"
   notation (for example, "System.Name") indicates that


 Moore, et al.         Expires: Oct 1999 + 6 months            [Page 21]


 Internet Draft       Policy Core Information Model         October 1999


   SystemCreationClassName and Name are propagated keys of the class
   PolicyRule.

   The manual propagation of keys from PolicyRule to PolicyCondition
   involves copying the values of PolicyRule's four key properties into
   four similarly named key properties in PolicyCondition.  Note, though,
   that the "dot" notation is absent:  PolicyCondition's second key
   property is "SystemName", not "System.Name".

   The manual propagation of keys from PolicyRepository to
   PolicyCondition works in exactly the same way for the first two key
   properties.  Since, however, PolicyRepository doesn't have
   [PolicyRule]CreationClassName and PolicyRuleName as its third and
   fourth key properties, there are no values to copy into the
   PolicyRuleCreationClassName and PolicyRuleName key properties in
   PolicyCondition.  A special value, "No Rule", is assigned to both of
   these properties in this case, indicating that this instance of
   PolicyCondition is not named within the scope of any particular policy
   rule.  This matches the semantics of a reusable policy condition,
   which exists and is identified independent of any associations it
   might have with specific policy rules.

 5.3.4. Naming Instances of PolicyAction and Its Subclasses

   From the point of view of naming, the PolicyAction class and its
   subclasses work exactly like the PolicyCondition class and its
   subclasses.  See Section 5.3.3 for details.

 5.3.5. Naming Instances of PolicyRepository and
 ResourceManagerCollection

   Instances of these two classes are named directly in the global CIM
   name space, using the CreationClassName property and a class-unique
   key property (PolicyRepositoryName and ResourceManagerCollectionName,
   respectively).



 5.4. CIM Data Types

   The following CIM data types are used in the class definitions that
   follow in Sections 6 and 7:

   o uint8               unsigned 8-bit integer

   o uint16              unsigned 16-bit integer

   o boolean             Boolean

   o string              UCS-2 string.




 Moore, et al.         Expires: Oct 1999 + 6 months            [Page 22]


 Internet Draft       Policy Core Information Model         October 1999


   In addition, the association classes in Section 7 use the following
   type:

   o <classname> ref     strongly typed reference.

   The notation "octetString" is also used as the data type for the two
   properties Constraint (in VendorPolicyCondition) and ActionData (in
   VendorPolicyAction).  See the sections describing these two properties
   for an explanation of what this notation indicates.


 6. Class Definitions

   There are a significant number of differences between CIM and LDAP
   class specifications.  The ones that are relevant to the abbreviated
   class specifications in this document are the following:

   o Instead of LDAP's three class types (abstract, auxiliary,
     structural), CIM has only two:  abstract and instantiable.  The
     type of a CIM class is indicated by the Boolean qualifier ABSTRACT.

   o CIM uses the term "property" for what LDAP terms an "attribute".

   o CIM uses the array notation "[ ]" to indicate that a property is
     multi-valued.  As is the case with LDAP, multi-valued properties in
     CIM are unordered.

   o There is no distinction in a CIM class between mandatory and
     optional properties.  Aside from the key properties (designated for
     naming instances of the class), all properties are optional.

   o CIM classes and properties are identified by name, not by OID.

   o In LDAP, attribute definitions are global, and the same attribute
     may appear in multiple classes.  In CIM, a property is defined
     within the scope of a single class definition.  The property may be
     inherited into subclasses of the class in which it is defined, but
     otherwise it cannot appear in other classes.  One side effect of
     this difference is that CIM property names tend to be much shorter
     than LDAP attribute names, since they are implicitly scoped by the
     name of the class in which they are defined.

   For the complete definition of the CIM specification language, see
   reference [7].

 6.1. The Abstract Class "Policy"

   The abstract class Policy collects several properties that may be
   included in instances of any of the Core Policy classes (or their
   subclasses).




 Moore, et al.         Expires: Oct 1999 + 6 months            [Page 23]


 Internet Draft       Policy Core Information Model         October 1999


   Since the class from which Policy is derived, ManagedElement, is still
   under development in CIM, its definition is not readily available.
   Thus the properties that Policy inherits from ManagedElement are
   repeated here for completeness.

   The class definition is as follows:

     NAME             Policy
     DESCRIPTION      An abstract class with four properties for
                      describing a policy-related instance.
     DERIVED FROM     ManagedElement
     ABSTRACT         TRUE
     PROPERTIES       CommonName (CN)
                      PolicyKeywords[ ]
                             // Caption (inherited)
                             // Description (inherited)

 6.1.1. The Property "CommonName (CN)"

   The CN, or CommonName, property corresponds to the X.500 attribute
   commonName (cn).  In X.500 this property specifies one or more user-
   friendly names (typically only one name) by which an object is
   commonly known, names that conform to the naming conventions of the
   country or culture with which the object is associated.  In the CIM
   model, however, the CommonName property is single-valued.

     NAME             CN
     DESCRIPTION      A user-friendly name of a policy-related object.
     SYNTAX           string

 6.1.2. The Multi-valued Property "PolicyKeywords"

   This property provides a set of one or more keywords that a policy
   administrator may use to assist in characterizing or categorizing a
   policy object.  Keywords are of one of two types:

   o Keywords defined in this document, or in documents that define
     subclasses of the classes defined in this document.  These keywords
     provide a vendor-independent, installation-independent way of
     characterizing policy objects.

   o Installation-dependent keywords for characterizing policy objects.
     Examples include "Engineering", "Billing", and "Review in December
     1999".

   This document defines the following keywords:  "UNKNOWN",
   "CONFIGURATION", "USAGE", "SECURITY", "SERVICE", "MOTIVATIONAL",
   "INSTALLATION", and "EVENT".  These concepts were defined earlier in
   Section 2.





 Moore, et al.         Expires: Oct 1999 + 6 months            [Page 24]


 Internet Draft       Policy Core Information Model         October 1999


   One additional keyword is defined:  "POLICY".  The role of this
   keyword is to identify policy-related instances that would not
   otherwise be identifiable as being related to policy.

   Documents that define subclasses of the Policy Core Information Model
   classes SHOULD define additional keywords to characterize instances of
   these subclasses.  By convention, keywords defined in conjunction with
   class definitions are in uppercase.  Installation-defined keywords can
   be in any case.

   The property definition is as follows:

     NAME             PolicyKeywords
     DESCRIPTION      A set of keywords for characterizing /categorizing
                      policy objects.
     SYNTAX           string

 6.1.3. The Property "Caption" (Inherited from ManagedElement)

   This property provides a one-line description of a policy-related CIM
   object.

     NAME             Caption
     DESCRIPTION      A one-line description of this policy-related
                      object.
     SYNTAX           string

 6.1.4. The Property "Description" (Inherited from ManagedElement)

   This property provides a longer description than that provided by the
   caption property.

     NAME             Description
     DESCRIPTION      A long description of this policy-related object.
     SYNTAX           string

 6.2. The Class "PolicyGroup"

   This class is a generalized aggregation container.  It enables either
   PolicyRules or PolicyGroups, but not both, to be aggregated in a
   single container.  Loops, including the degenerate case of a
   PolicyGroup that contains itself, are not allowed when PolicyGroups
   contain other PolicyGroups.

   PolicyGroups and their nesting capabilities are shown in Figure 6
   below. Note that a PolicyGroup can nest other PolicyGroups, and there
   is no restriction on the depth of the nesting in sibling PolicyGroups.







 Moore, et al.         Expires: Oct 1999 + 6 months            [Page 25]


 Internet Draft       Policy Core Information Model         October 1999


     +---------------------------------------------------+
     |                    PolicyGroup                    |
     |                                                   |
     | +--------------------+       +-----------------+  |
     | |    PolicyGroup A   |       |  PolicyGroup X  |  |
     | |                    |       |                 |  |
     | | +----------------+ |  ooo  |                 |  |
     | | | PolicyGroup A1 | |       |                 |  |
     | | +----------------+ |       |                 |  |
     | +--------------------+       +-----------------+  |
     +---------------------------------------------------+

   Figure 6.    Overview of the PolicyGroup class

   As a simple example, think of the highest level PolicyGroup shown in
   Figure 6 above as a logon policy for US employees of a company. This
   PolicyGroup may be called USEmployeeLogonPolicy, and may aggregate
   several PolicyGroups that provide specialized rules per location.
   Hence, PolicyGroup A in Figure 6 above may define logon rules for
   employees on the West Coast, while another PolicyGroup might define
   logon rules for the Midwest (e.g., PolicyGroup X), and so forth.

   Note also that the depth of each PolicyGroup does not need to be the
   same. Thus, the WestCoast PolicyGroup might have several additional
   layers of PolicyGroups defined for any of several reasons (different
   locales, number of subnets, etc.). The PolicyRules are therefore
   contained at n levels from the USEmployeeLogonPolicyGroup. Compare
   this to the Midwest PolicyGroup (PolicyGroup X), which might directly
   contain PolicyRules.

   The class definition for PolicyGroup is as follows:

     NAME             PolicyGroup
     DESCRIPTION      A container for either a set of related PolicyRules
                      or a set of related PolicyGroups.
     DERIVED FROM     Policy
     ABSTRACT         FALSE
     PROPERTIES       System.CreationClassName[key]
                      System.Name[key]
                          CreationClassName[key]
                      PolicyGroupName[key]

 6.2.1. The Propagated Key Property "System.CreationClassName"

   This property represents the name of the CIM class to which the System
   object providing the naming scope for this instance of PolicyGroup
   belongs.  Reference [7] defines this property as follows:

     [Key, MaxLen (256), Description (
            "CreationClassName indicates the name of the class or the "
            "subclass used in the creation of an instance. When used "
            "with the other key properties of this class, this property "


 Moore, et al.         Expires: Oct 1999 + 6 months            [Page 26]


 Internet Draft       Policy Core Information Model         October 1999


            "allows all instances of this class and its subclasses to "
            "be uniquely identified.") ]
       string CreationClassName;

   Class names in CIM are limited to alphabetic and numeric characters
   plus the underscore.

 6.2.2. The Propagated Key Property "System.Name"

   This property represents the name of the particular System object
   providing the naming scope for this instance of PolicyGroup.
   Reference [7] defines this property as follows:

     [Key, MaxLen (256), Override ("Name"), Description (
            "The inherited Name serves as key of a System instance in "
            "an enterprise environment.") ]
       string Name;

   The value 256 in MaxLen refers to the maximum number of characters in
   a System Name, rather than to the maximum number of bytes.

 6.2.3. The Key Property "CreationClassName"

   This property identifies the class or subclass used in the creation of
   this instance.

     NAME             CreationClassName
     DESCRIPTION      The name of the class or subclass used in the
                      creation of this instance.
     SYNTAX           string[MaxLen 256]
     QUALIFIER        key


 6.2.4. The Key Property "PolicyGroupName"

   This property provides a user-friendly name for a policy group, and is
   normally what will be displayed to the end-user as the instance name.
   It is defined as follows:

     NAME             PolicyGroupName
     DESCRIPTION      The user-friendly name of this policy group.
     SYNTAX           string
     QUALIFIER        key

 6.3. The Class "PolicyRule"

   This class represents the "If Condition then Action" semantics
   associated with a policy.  A PolicyRule condition, in the most general
   sense, is represented as either an ORed set of ANDed conditions
   (Disjunctive Normal Form, or DNF) or an ANDed set of ORed conditions
   (Conjunctive Normal Form, or CNF). Individual conditions may either be
   negated (NOT C) or unnegated (C).  The actions specified by a


 Moore, et al.         Expires: Oct 1999 + 6 months            [Page 27]


 Internet Draft       Policy Core Information Model         October 1999


   PolicyRule are to be performed if and only if the PolicyRule condition
   (whether it is represented in DNF or CNF) evaluates to TRUE.

   The conditions and actions associated with a policy rule are modeled,
   respectively, with subclasses of the classes PolicyCondition and
   PolicyAction.  These condition and action objects are tied to
   instances of PolicyRule by the ConditionInPolicyRule and
   ActionInPolicyRule aggregations.

   As illustrated above in Section 3, a policy rule may also be
   associated with one or more policy time periods, indicating the
   schedule according to which the policy rule is active and inactive.
   In this case it is the PolicyRuleValidityPeriod aggregation that
   provides the linkage.

   A policy rule is illustrated conceptually in Figure 7. below.

     +------------------------------------------------+
     |                    PolicyRule                  |
     |                                                |
     | +--------------------+     +-----------------+ |
     | | PolicyCondition(s) |     | PolicyAction(s) | |
     | +--------------------+     +-----------------+ |
     |                                                |
     |        +------------------------------+        |
     |        | PolicyTimePeriodCondition(s) |        |
     |        +------------------------------+        |
     +------------------------------------------------+

   Figure 7.    Overview of the PolicyRule Class

   The PolicyRule class uses the property ConditionListType, to indicate
   whether the conditions for the rule are in DNF or CNF.  The
   ConditionInPolicyRule aggregation contains two additional properties
   to complete the representation of the rule's conditional expression.
   The first of these properties is an integer to partition the
   referenced conditions into one or more sets, and the second is a
   Boolean to indicate whether a referenced condition is negated.  An
   example shows how ConditionListType and these two additional
   properties provide a unique representation of a set of conditions in
   either DNF or CNF.

   Suppose we have a PolicyRule that aggregates five PolicyConditions C1
   through C5, with the following values in the properties of the five
   ConditionInPolicyRule relationships:









 Moore, et al.         Expires: Oct 1999 + 6 months            [Page 28]


 Internet Draft       Policy Core Information Model         October 1999


    C1:  GroupNumber = 1, ConditionNegated = FALSE
    C2:  GroupNumber = 1, ConditionNegated = TRUE
    C3:  GroupNumber = 1, ConditionNegated = FALSE
    C4:  GroupNumber = 2, ConditionNegated = FALSE
    C5:  GroupNumber = 2, ConditionNegated = FALSE


   If ConditionListType = DNF, then the overall condition for the
   PolicyRule is:

        (C1 AND (NOT C2) AND C3) OR (C4 AND C5)

   On the other hand, if ConditionListType = CNF, then the overall
   condition for the PolicyRule is:

        (C1 OR (NOT C2) OR C3) AND (C4 OR C5)

   In both cases, there is an unambiguous specification of the overall
   condition that is tested to determine whether to perform the actions
   associated with the PolicyRule.

   The class definition is as follows:

     NAME             PolicyRule
     DESCRIPTION      The central class for representing the "If
                      Condition then Action" semantics associated with a
                      policy rule.
     DERIVED FROM     Policy
     ABSTRACT         FALSE
     PROPERTIES       System.CreationClassName[key]
                      System.Name[key]
                      CreationClassName[key]
                      PolicyRuleName[key]
                      Enabled
                      ConditionListType
                      RuleUsage
                      Priority
                      Mandatory
                      SequencedActions

 6.3.1. The Propagated Key Property "System.CreationClassName"

   System.CreationClassName works the same way here as it does for the
   class PolicyGroup.  See Section 6.2.1 for details.

 6.3.2. The Propagated Key Property "System.Name"

   System.Name works the same way here as it does for the class
   PolicyGroup.  See Section 6.2.2 for details.





 Moore, et al.         Expires: Oct 1999 + 6 months            [Page 29]


 Internet Draft       Policy Core Information Model         October 1999


 6.3.3. The Key Property "CreationClassName"

   This property identifies the class or subclass used in the creation of
   this instance.

     NAME             CreationClassName
     DESCRIPTION      The name of the class or subclass used in the
                      creation of this instance.
     SYNTAX           string[MaxLen 256]
     QUALIFIER        key


 6.3.4. The Key Property "PolicyRuleName"

   This property provides a user-friendly name for a policy rule, and is
   normally what will be displayed to the end-user as the instance name.
   It is defined as follows:

     NAME             PolicyRuleName
     DESCRIPTION      The user-friendly name of this policy rule.
     SYNTAX           string
     QUALIFIER        key


 6.3.5. The Property "Enabled"

   This property indicates whether a policy rule is currently enabled,
   from an ADMINISTRATIVE point of view.  Its purpose is to allow a
   policy administrator to enable or disable a policy rule without having
   to add it to, or remove it from, the policy repository.

   The property also supports the value 'enabledForDebug'.  When the
   property has this value, the entity evaluating the policy conditions
   is being told to evaluate the conditions for the policy rule, but not
   to perform the actions if the conditions evaluate to TRUE.  This value
   serves as a debug vehicle when attempting to determine what policies
   would execute in a particular scenario, without taking any actions to
   change state during the debugging.

   The property definition is as follows:

     NAME             Enabled
     DESCRIPTION      An enumeration indicating whether a policy rule is
                      administratively enabled, administratively
                      disabled, or enabled for debug mode.
     SYNTAX           uint16
     VALUES           enabled(1), disabled(2), enabledForDebug(3)
     DEFAULT VALUE    enabled(1)






 Moore, et al.         Expires: Oct 1999 + 6 months            [Page 30]


 Internet Draft       Policy Core Information Model         October 1999


 6.3.6. The Property "ConditionListType"

   This property is used to specify whether the list of policy conditions
   associated with this policy rule is in disjunctive normal form (DNF)
   or conjunctive normal form (CNF).  If this property is not present,
   the list type defaults to DNF.  The property definition is as follows:

     NAME             ConditionListType
     DESCRIPTION      Indicates whether the list of policy conditions
                      associated with this policy rule is in disjunctive
                      normal form (DNF) or conjunctive normal form (CNF).
     SYNTAX           uint16
     VALUES           DNF(1), CNF(2)
     DEFAULT VALUE    DNF(1)

 6.3.7. The Property "RuleUsage"

   This property is a free-form string that recommends how this policy
   should be used. The property definition is as follows:

     NAME             PolicyRuleUsage
     DESCRIPTION      This property is used to provide guidelines on how
                      this policy should be used.
     SYNTAX           string

 6.3.8. The Property "Priority"

   This property provides a non-negative integer for prioritizing policy
   rules relative to each other.  For policy rules that have this
   property, larger integer values indicate higher priority.  Since one
   purpose of this property is to allow specific, ad hoc policy rules to
   temporarily override established policy rules, an instance that has
   this property set has a higher priority than all instances that lack
   it.

   Prioritization among policy rules provides a simple and efficient
   mechanism for resolving policy conflicts.

   The property definition is as follows:

     NAME             Priority
     DESCRIPTION      A non-negative integer for prioritizing this
                      PolicyRule relative to other PolicyRules.  A larger
                      value indicates a higher priority.
     SYNTAX           uint16
     DEFAULT VALUE    0

 6.3.9. The Property "Mandatory"

   This property indicates whether evaluation (and possibly action
   execution) of a PolicyRule is mandatory or not.  Its concept is



 Moore, et al.         Expires: Oct 1999 + 6 months            [Page 31]


 Internet Draft       Policy Core Information Model         October 1999


   similar to the ability to mark packets for delivery or possible
   discard, based on network traffic and device load.

   The evaluation of a PolicyRule MUST be attempted if the Mandatory
   property value is TRUE.  If the Mandatory property value of a
   PolicyRule is FALSE, then the evaluation of the rule is "best effort"
   and MAY be ignored.

   The property definition is as follows:

     NAME             Mandatory
     DESCRIPTION      A flag indicating that the evaluation of the
                      PolicyConditions and execution of PolicyActions (if
                      the condition list evaluates to TRUE) is required.
     SYNTAX           boolean
     DEFAULT VALUE    TRUE


 6.3.10. The Property "SequencedActions"

   This property gives a policy administrator a way of specifying how the
   ordering of the policy actions associated with this PolicyRule is to
   be interpreted.  Three values are supported:

   o mandatory(1):   Do the actions in the indicated order, or don't do
     them at all.

   o recommended(2): Do the actions in the indicated order if you can,
     but if you can't do them in this order, do them in another order if
     you can.

   o dontCare(3):    Do them -- I don't care about the order.

   When error / event reporting is addressed for the Policy Framework,
   suitable codes will be defined for reporting that a set of actions
   could not be performed in an order specified as mandatory (and thus
   were not performed at all), that a set of actions could not be
   performed in a recommended order (and moreover could not be performed
   in any order), or that a set of actions could not be performed in a
   recommended order (but were performed in a different order). The
   property definition is as follows:

     NAME             SequencedActions
     DESCRIPTION      An enumeration indicating how to interpret the
                      action ordering indicated via the
                      ActionInPolicyRule aggregation.
     SYNTAX           uint16
     VALUES           mandatory(1), recommended(2), dontCare(3)
     DEFAULT VALUE    dontCare(3)





 Moore, et al.         Expires: Oct 1999 + 6 months            [Page 32]


 Internet Draft       Policy Core Information Model         October 1999


 6.4. The Class "PolicyCondition"

   The purpose of a policy condition is to determine whether or not the
   set of actions (aggregated in the PolicyRule that the condition
   applies to) should be executed or not. For the purposes of the Policy
   Core Information Model, all that matters about an individual
   PolicyCondition is that it evaluates to TRUE or FALSE.  (The
   individual PolicyConditions associated with a PolicyRule are combined
   to form a compound expression in either DNF or CNF, but this is
   accomplished via the ConditionListType property, discussed above, and
   by the properties of the ConditionInPolicyRule aggregation, introduced
   above and discussed further in Section 7.6 below.)  A logical
   structure WITHIN an individual PolicyCondition may also be introduced,
   but this would have to be done in a subclass of PolicyCondition.

   +---------------------------------------------------------------+
   |                    Policy Conditions in DNF                   |
   | +-------------------------+         +-----------------------+ |
   | |       AND list          |         |      AND list         | |
   | |  +-------------------+  |         |  +-----------------+  | |
   | |  |  PolicyCondition  |  |         |  | PolicyCondition |  | |
   | |  +-------------------+  |         |  +-----------------+  | |
   | |  +-------------------+  |         |  +-----------------+  | |
   | |  |  PolicyCondition  |  |   ...   |  | PolicyCondition |  | |
   | |  +-------------------+  |   ORed  |  +-----------------+  | |
   | |          ...            |         |         ...           | |
   | |         ANDed           |         |        ANDed          | |
   | |  +-------------------+  |         |  +-----------------+  | |
   | |  |  PolicyCondition  |  |         |  | PolicyCondition |  | |
   | |  +-------------------+  |         |  +-----------------+  | |
   | +-------------------------+         +-----------------------+ |
   +---------------------------------------------------------------+


   Figure 8.    Overview of Policy Conditions in DNF

   This figure illustrates that when policy conditions are in DNF, there
   are one or more sets of conditions that are ANDed together to form AND
   lists.  An AND list evaluates to TRUE if and only if all of its
   constituent conditions evaluate to TRUE.  The overall condition then
   evaluates to TRUE if and only if at least one of its constituent AND
   lists evaluates to TRUE.












 Moore, et al.         Expires: Oct 1999 + 6 months            [Page 33]


 Internet Draft       Policy Core Information Model         October 1999


   +---------------------------------------------------------------+
   |                    Policy Conditions in CNF                   |
   | +-------------------------+         +-----------------------+ |
   | |        OR list          |         |       OR list         | |
   | |  +-------------------+  |         |  +-----------------+  | |
   | |  |  PolicyCondition  |  |         |  | PolicyCondition |  | |
   | |  +-------------------+  |         |  +-----------------+  | |
   | |  +-------------------+  |         |  +-----------------+  | |
   | |  |  PolicyCondition  |  |   ...   |  | PolicyCondition |  | |
   | |  +-------------------+  |  ANDed  |  +-----------------+  | |
   | |          ...            |         |         ...           | |
   | |         ORed            |         |         ORed          | |
   | |  +-------------------+  |         |  +-----------------+  | |
   | |  |  PolicyCondition  |  |         |  | PolicyCondition |  | |
   | |  +-------------------+  |         |  +-----------------+  | |
   | +-------------------------+         +-----------------------+ |
   +---------------------------------------------------------------+


   Figure 9.    Overview of Policy Conditions in CNF

   In this figure, the policy conditions are in CNF.  Consequently, there
   are one or more OR lists, each of which evaluates to TRUE if and only
   if at least one of its constituent conditions evaluates to TRUE.  The
   overall condition then evaluates to TRUE if and only if ALL of its
   constituent OR lists evaluate to TRUE.

   The class definition of PolicyCondition is as follows:

     NAME             PolicyCondition
     DESCRIPTION      A class representing a rule-specific or reusable
                      policy condition to be evaluated in conjunction
                      with a policy rule.
     DERIVED FROM     Policy
     ABSTRACT         FALSE
     PROPERTIES       SystemCreationClassName[key]
                      SystemName[key]
                      PolicyRuleCreationClassName[key]
                      PolicyRuleName[key]
                      CreationClassName[key]
                      PolicyConditionName[key]

 6.4.1. The Key Property "SystemCreationClassName"

   This property helps to identify the System object in whose scope this
   instance of PolicyCondition exists.  For a rule-specific policy
   condition, this is the system in whose context the policy rule is
   defined.  For a reusable policy condition, this is the instance of
   PolicyRepository (which is a subclass of System) that holds the policy
   condition.




 Moore, et al.         Expires: Oct 1999 + 6 months            [Page 34]


 Internet Draft       Policy Core Information Model         October 1999


   Note that this property, and the analogous property SystemName, do not
   represent propagated keys from an instance of the class System.  (If
   they did, they would be written with a dot:  System.CreationClassName,
   System.Name.)  Instead, they are properties defined in the context of
   this class, which repeat the values from the instance of System to
   which the instance containing them is related, either directly via the
   ConditionInPolicyRepository aggregation or indirectly via the
   ConditionInPolicyRule aggregation.  See Section 5.3.3 for more on this
   topic.

   This property is defined as follows:

     NAME             SystemCreationClassName
     DESCRIPTION      The name of the class or the subclass used in the
                      creation of the System object in whose scope this
                      policy condition is defined.
     SYNTAX           string
     QUALIFIER        key

 6.4.2. The Key Property "SystemName"

   This property completes the identification of the System object in
   whose scope this instance of PolicyCondition exists.  For a rule-
   specific policy condition, this is the system in whose context the
   policy rule is defined.  For a reusable policy condition, this is the
   instance of PolicyRepository (which is a subclass of System) that
   holds the policy condition.

   This property is defined as follows:

     NAME             SystemName
     DESCRIPTION      The name of the System object in whose scope this
                      policy condition is defined.
     SYNTAX           string
     QUALIFIER        key

 6.4.3. The Key Property "PolicyRuleCreationClassName"

   For a rule-specific policy condition, this property helps to identify
   the policy rule in whose scope this instance of PolicyCondition
   exists.  For a reusable policy condition, this property returns a
   special value, "No Rule", indicating that this instance of
   PolicyCondition is not unique to one policy rule.

   This property is defined as follows:

     NAME             PolicyRuleCreationClassName
     DESCRIPTION      For a rule-specific policy condition, this property
                      identifies the class of the policy rule instance in
                      whose scope this instance of PolicyCondition
                      exists.  For a reusable policy condition, this
                      property returns a special value, "No Rule",


 Moore, et al.         Expires: Oct 1999 + 6 months            [Page 35]


 Internet Draft       Policy Core Information Model         October 1999


                      indicating that this instance of PolicyCondition is
                      not unique to one policy rule.

     SYNTAX           string[MaxLen 256]
     QUALIFIER        key


 6.4.4. The Key Property "PolicyRuleName"

   For a rule-specific policy condition, this property completes the
   identification of the policy rule in whose scope this instance of
   PolicyCondition exists.  For a reusable policy condition, this
   property returns a special value, "No Rule", indicating that this
   instance of PolicyCondition is not unique to one policy rule.

   This property is defined as follows:

     NAME             PolicyRuleName
     DESCRIPTION      For a rule-specific policy condition, the name of
                      the PolicyRule object with which this condition is
                      associated.  For a reusable policy condition, a
                      special value, "No Rule", indicating that this
                      condition is reusable.
     SYNTAX           string
     QUALIFIER        key

 6.4.5. The Key Property "CreationClassName"

   This property identifies the class or subclass used in the creation of
   this instance.

     NAME             CreationClassName
     DESCRIPTION      The name of the class or subclass used in the
                      creation of this instance.
     SYNTAX           string[MaxLen 256]
     QUALIFIER        key


 6.4.6. The Key Property "PolicyConditionName"

   This property provides a user-friendly name for a policy condition,
   and is normally what will be displayed to the end-user as the instance
   name. It is defined as follows:

     NAME             PolicyConditionName
     DESCRIPTION      The user-friendly name of this policy condition.
     SYNTAX           string
     QUALIFIER        key






 Moore, et al.         Expires: Oct 1999 + 6 months            [Page 36]


 Internet Draft       Policy Core Information Model         October 1999


 6.5. The Class "PolicyTimePeriodCondition"

   This class provides a means of representing the time periods during
   which a policy rule is valid, i.e., active.  At all times that fall
   outside these time periods, the policy rule has no effect.  A policy
   rule is treated as valid at all times if it does not specify a
   PolicyTimePeriodCondition.

   In some cases a Policy Consumer may need to perform certain setup /
   cleanup actions when a policy rule becomes active / inactive.  For
   example, sessions that were established while a policy rule was active
   might need to be taken down when the rule becomes inactive.  In other
   cases, however, such sessions might be left up:  in this case, the
   effect of deactivating the policy rule would just be to prevent the
   establishment of new sessions.  Any such setup / cleanup behaviors on
   validity period transitions must be specified in a subclass of
   PolicyRule.  If such behaviors need to be under the control of the
   policy administrator, then a mechanism to allow this control must also
   be specified in the subclass.

   PolicyTimePeriodCondition is defined as a subclass of PolicyCondition.
   This is to allow the inclusion of time-based criteria in the AND/OR
   condition definitions for a PolicyRule.

   Instances of this class may have up to five properties identifying
   time periods at different levels.  The values of all the properties
   present in an instance are ANDed together to determine the validity
   period(s) for the instance.  For example, an instance with an overall
   validity range of January 1, 1999 through December 31, 1999; a month
   mask of "001100000000" (March and April); a day-of-the-week mask of
   "0000010" (Fridays); and a time of day range of 0800 through 1600
   would represent the following time periods:

       Friday, March  5, 1999, from 0800 through 1600;
       Friday, March 12, 1999, from 0800 through 1600;
       Friday, March 19, 1999, from 0800 through 1600;
       Friday, March 26, 1999, from 0800 through 1600;
       Friday, April  2, 1999, from 0800 through 1600;
       Friday, April  9, 1999, from 0800 through 1600;
       Friday, April 16, 1999, from 0800 through 1600;
       Friday, April 23, 1999, from 0800 through 1600;
       Friday, April 30, 1999, from 0800 through 1600.


   Properties not present in an instance of PolicyTimePeriodCondition are
   implicitly treated as having their value "always enabled". Thus, in
   the example above, the day-of-the-month mask is not present, and so
   the validity period for the instance implicitly includes a day-of-the-
   month mask containing 31 1's.  If we apply this "missing property"
   rule to its fullest, we see that there is a second way to indicate
   that a policy rule is always enabled: have it point to an instance of



 Moore, et al.         Expires: Oct 1999 + 6 months            [Page 37]


 Internet Draft       Policy Core Information Model         October 1999


   PolicyTimePeriodCondition whose only properties are its naming
   properties.

   The class definition is as follows.  Note that instances of this class
   are named with the inherited key properties SystemCreationClassName,
   SystemName, PolicyRuleName, and PolicyConditionName.

     NAME             PolicyTimePeriodCondition
     DESCRIPTION      A class that provides the capability of enabling /
                      disabling a policy rule according to a pre-
                      determined schedule.
     DERIVED FROM     PolicyCondition
     ABSTRACT         FALSE
     PROPERTIES       TimePeriod
                      MonthOfYearMask
                      DayOfMonthMask
                      DayOfWeekMask
                      TimeOfDayMask
                      ApplicableTimeZone

 6.5.1. The Property "TimePeriod"

   This property identifies an overall range of calendar dates and times
   over which a policy rule is valid.  It is formatted as a string
   consisting of a start date and time, then a colon (':'), and followed
   by an end date and time.  The first date indicates the beginning of
   the range, while the second date indicates the end.  Thus, the second
   date and time must be later than the first.  Dates are expressed as
   substrings of the form "yyyymmddhhmmss".  For example:

     19990101080000:19990131120000

         January 1, 1999, 0800 through January 31, 1999, noon

   There are three special cases that can also be represented with this
   format:

   o If the date before the ':' is omitted, then the property indicates
     that a policy rule is valid [from now] until the date that appears
     after the ':'.

   o If the date after the ':' is omitted, then the property indicates
     that a policy rule becomes valid on the date that appears before
     the ':', and remains valid from that point on.

   o If both dates are omitted (i.e., if the string contains only the
     ':' character), then the property indicates that a policy rule is
     valid now, and remains valid from now on.

   The property definition is as follows:

     NAME             TimePeriod


 Moore, et al.         Expires: Oct 1999 + 6 months            [Page 38]


 Internet Draft       Policy Core Information Model         October 1999


     DESCRIPTION      The range of calendar dates on which a policy rule
                      is valid.
     SYNTAX           string
     FORMAT           [yyyymmddhhmmss]:[yyyymmddhhmmss]

 6.5.2. The Property "MonthOfYearMask"

   The purpose of this property is to refine the definition of the valid
   time period that is defined by the TimePeriod property, by explicitly
   specifying which months the policy is valid for.  These properties
   work together, with the TimePeriod used to specify the overall time
   period that the policy is valid for, and the MonthOfYearMask used to
   pick out which months of that time period the policy is valid for.

   This property is formatted as a string containing 12 ASCII '0's and
   '1's, where the '1's identify the months (beginning with January) in
   which the policy rule is valid.   The value "000010010000", for
   example, indicates that a policy rule is valid only in the months May
   and August.

   If this property is omitted, then the policy rule is treated as valid
   for all twelve months.  The property definition is as follows:

     NAME             MonthOfYearMask
     DESCRIPTION      A mask identifying the months of the year in which
                      a policy rule is valid.
     SYNTAX           string
     FORMAT           A string of 12 ASCII '0's and '1's.

 6.5.3. The Property "DayOfMonthMask"

   The purpose of this property is to refine the definition of the valid
   time period that is defined by the TimePeriod property, by explicitly
   specifying which days of the month the policy is valid for.  These
   properties work together, with the TimePeriod used to specify the
   overall time period that the policy is valid for, and the
   DayOfMonthMask used to pick out which days of the month in that time
   period the policy is valid for.

   This property is formatted as a string containing 62 ASCII '0's and
   '1's, where the '1's identify the days of the month on which the
   policy rule is valid.  The encoding is analogous to that used for the
   schedDay object in the DISMAN-SCHEDULE-MIB (currently a Proposed
   Standard, published as RFC 2591).  The difference is that the MIB
   object is a bit string (defined with the SMIv2 BITS construct), while
   this property is a string of ASCII '0's and '1's.

   To illustrate how the days of a month are represented, we can quote
   the definition from the DISMAN-SCHEDULE-MIB:





 Moore, et al.         Expires: Oct 1999 + 6 months            [Page 39]


 Internet Draft       Policy Core Information Model         October 1999


   schedDay OBJECT-TYPE
           SYNTAX      BITS {
                           d1(0),   d2(1),   d3(2),   d4(3),   d5(4),
                           d6(5),   d7(6),   d8(7),   d9(8),   d10(9),
                           d11(10), d12(11), d13(12), d14(13), d15(14),
                           d16(15), d17(16), d18(17), d19(18), d20(19),
                           d21(20), d22(21), d23(22), d24(23), d25(24),
                           d26(25), d27(26), d28(27), d29(28), d30(29),
                           d31(30),
                           r1(31),  r2(32),  r3(33),  r4(34),  r5(35),
                           r6(36),  r7(37),  r8(38),  r9(39),  r10(40),
                           r11(41), r12(42), r13(43), r14(44), r15(45),
                           r16(46), r17(47), r18(48), r19(49), r20(50),
                           r21(51), r22(52), r23(53), r24(54), r25(55),
                           r26(56), r27(57), r28(58), r29(59), r30(60),
                           r31(61)
                       }
           MAX-ACCESS  read-create
           STATUS      current
           DESCRIPTION
              "The set of days in a month on which a scheduled action
               should take place. There are two sets of bits one can
               use to define the day within a month:

               Enumerations starting with the letter 'd' indicate a
               day in a month relative to the first day of a month.
               The first day of the month can therefore be specified
               by setting the bit d1(0) and d31(30) means the last
               day of a month with 31 days.

               Enumerations starting with the letter 'r' indicate a
               day in a month in reverse order, relative to the last
               day of a month. The last day in the month can therefore
               be specified by setting the bit r1(31) and r31(61) means
               the first day of a month with 31 days.

               Setting multiple bits will include several days in the set
               of possible days for this schedule. Setting all bits will
               cause the scheduler to ignore the day within a month.
               Setting all bits starting with the letter 'd' or the
               letter 'r' will also cause the scheduler to ignore the
               day within a month."
           DEFVAL { {} }
           ::= { schedEntry 7 }


   Applying this to the DayOfMonthMask property, we see that the value
   "11100000000000000000000000000001110000000000000000000000000000", for
   example, indicates that a policy rule is valid only on the first three
   days of each month and the last three days of each month.  For months
   with fewer than 31 days, the digits corresponding to days that the



 Moore, et al.         Expires: Oct 1999 + 6 months            [Page 40]


 Internet Draft       Policy Core Information Model         October 1999


   months do not have (counting in both directions) are ignored. The
   property definition is as follows:

     NAME             DayOfMonthMask
     DESCRIPTION      A mask identifying the days of the month on which a
                      policy rule is valid.
     SYNTAX           string
     FORMAT           A string of 62 ASCII '0's and '1's.

 6.5.4. The Property "DayOfWeekMask"

   The purpose of this property is to refine the definition of the valid
   time period that is defined by the TimePeriod property by explicitly
   specifying which days of the week the policy is valid for. These
   properties work together, with the TimePeriod used to specify the
   overall time period that the policy is valid for, and the
   DayOfWeekMask used to pick out which days of the week in that time
   period the policy is valid for.

   This property is formatted as a string containing 7 ASCII '0's and
   '1's, where the '1's identify the days of the week (beginning with
   Sunday and going up through Saturday) on which the policy rule is
   valid. The value "0111110", for example, indicates that a policy rule
   is valid Monday through Friday.

   The property definition is as follows:

     NAME             DayOfWeekMask
     DESCRIPTION      A mask identifying the days of the week on which a
                      policy rule is valid.
     SYNTAX           string
     FORMAT           A string of 7 ASCII '0's and '1's.

 6.5.5. The Property "TimeOfDayMask"

   The purpose of this property is to refine the definition of the valid
   time period that is defined by the TimePeriod property by explicitly
   specifying a range of times in a day the policy is valid for. These
   properties work together, with the TimePeriod used to specify the
   overall time period that the policy is valid for, and the
   TimeOfDayMask used to pick out which range of time periods in a given
   day of that time period the policy is valid for.

   This property is formatted as a string containing two times, separated
   by a colon (':').  The first time indicates the beginning of the
   range, while the second time indicates the end.  Times are expressed
   as substrings of the form "hhmmss".

   The second substring always identifies a later time than the first
   substring.  To allow for ranges that span midnight, however, the value
   of the second string may be smaller than the value of the first
   substring.  Thus, "080000:210000" identifies the range from 0800 until


 Moore, et al.         Expires: Oct 1999 + 6 months            [Page 41]


 Internet Draft       Policy Core Information Model         October 1999


   2100, while "210000:080000" identifies the range from 2100 until 0800
   of the following day.

   When a range spans midnight, it by definition includes parts of two
   successive days.  When one of these days is also selected by either
   the MonthOfYearMask, DayOfMonthMask, and/or DayOfWeekMask, but the
   other day is not, then the policy is active only during the portion of
   the range that falls on the selected day.  For example, if the range
   extends from 2100 until 0800, and the day of week mask selects Monday
   and Tuesday, then the policy is active during the following three
   intervals:

       From midnight Sunday until 0800 Monday;
       From 2100 Monday until 0800 Tuesday;
       From 2100 Tuesday until 21:59:59 Tuesday.


   The property definition is as follows:

     NAME             TimeOfDayMask
     DESCRIPTION      The range of times at which a policy rule is valid.
                      If the second time is earlier than the first, then
                      the interval spans midnight.
     SYNTAX           string
     FORMAT           hhmmss:hhmmss

 6.5.6. The Property "ApplicableTimeZone"

   This property is used to explicitly define a time zone for use by the
   TimePeriod and the various Mask properties.  If this property is not
   present, then local time (at the location where the PolicyRule is
   enforced) is assumed.

   This property specifies time in UTC, using an offset indicator. The
   UTC offset indicator is either a 'Z', indicating UTC, or a substring
   of the following form:

     '+' or '-'     direction from UTC:  '+' = east, '-' = west

     hh             hours from UTC (00..13)

     mm             minutes from UTC (00..59)

   For example, the string "+0200" indicates a time zone two hours east
   of UTC, and the string "-0830" indicates a time zone 8.5 hours west of
   UTC.

   The property definition is as follows:

     NAME             ApplicableTimeZone
     DESCRIPTION      The time zone for the PolicyTimePeriodCondition.
     SYNTAX           string


 Moore, et al.         Expires: Oct 1999 + 6 months            [Page 42]


 Internet Draft       Policy Core Information Model         October 1999


     FORMAT           either 'Z' (UTC) or <'+'|'-'><hhmm>

 6.6. The Class "VendorPolicyCondition"

   The purpose of this class is to provide a general escape mechanism for
   representing policy conditions that have not been modeled with
   specific properties. Instead, the two properties Constraint and
   ConstraintEncoding are used to define the content and format of the
   condition, as explained below.

   As its name suggests, this class is intended for vendor-specific
   extensions to the Policy Core Information Model.  Standardized
   extensions are not expected to use this class.

   The class definition is as follows:

     NAME             VendorPolicyCondition
     DESCRIPTION      A class that defines a registered means to describe
                      a policy condition.
     DERIVED FROM     PolicyCondition
     ABSTRACT         FALSE
     PROPERTIES       Constraint[ ]
                      ConstraintEncoding

 6.6.1. The Multi-valued Property "Constraint"

   This property provides a general escape mechanism for representing
   policy conditions that have not been modeled with specific properties.
   The format of the octet strings in the array is left unspecified in
   this definition.  It is determined by the OID value stored in the
   property ConstraintEncoding.  Since ConstraintEncoding is single-
   valued, all the values of Constraint share the same format and
   semantics.

   NOTE:  In version 2.2 of the CIM model [7], there is no direct way to
   represent an array of octet strings.  (A single octet string can be
   represented as an ordered array of uint8's, but this does not work for
   multi-valued properties where each value is an octet string.)  CIM
   has, however, a mechanism that is essentially equivalent to SMI's
   (SNMP's) Textual Convention, for refining the syntax and/or semantics
   of existing data types.  Using this mechanism, a representation of
   octet strings as character strings (specifically, strings consisting
   of an even number of the characters A-F and 0-9) has been defined.  In
   a future version of CIM, though, it is likely that an actual
   octetString data type will be added.

   A policy decision point can readily determine whether it supports the
   values stored in an instance of Constraint by checking the OID value
   from ConstraintEncoding against the set of OIDs it recognizes.  The
   action for the policy decision point to take in case it does not
   recognize the format of this data could itself be modeled as a policy
   rule, governing the behavior of the policy decision point.


 Moore, et al.         Expires: Oct 1999 + 6 months            [Page 43]


 Internet Draft       Policy Core Information Model         October 1999


   The property is defined as follows:

     NAME             Constraint
     DESCRIPTION      Escape mechanism for representing constraints that
                      have not been modeled as specific properties. The
                      format of the values is identified by the OID
                      stored in the property ConstraintEncoding.
     SYNTAX           octetString

 6.6.2. The Property "ConstraintEncoding"

   This property identifies the encoding and semantics of the Constraint
   property values in this instance.  The value of this property is a
   single string, representing a single OID.

   The property is defined as follows:

     NAME             ConstraintEncoding
     DESCRIPTION      An OID encoded as a string, identifying the format
                      and semantics for this instance's Constraint
                      property.
     SYNTAX           string
     QUALIFIER        OID


 6.7. The Class "PolicyAction"

   The purpose of a policy action is to execute one or more operations
   that will affect network traffic and/or systems, devices, etc. in
   order to achieve a desired policy state.  This (new) policy state
   provides one or more (new) behaviors.  A policy action ordinarily
   changes the configuration of one or more elements.

   A PolicyRule contains one or more policy actions.  A policy
   administrator can assign an order to the actions associated with a
   PolicyRule, complete with an indication of whether the indicated order
   is mandatory, recommended, or of no significance.  Ordering of the
   actions associated with a PolicyRule is accomplished via a property in
   the ActionInPolicyRule aggregation.

   The actions associated with a PolicyRule are executed if and only if
   the overall condition(s) of the PolicyRule evaluates to TRUE.

   The class definition of PolicyAction is as follows:

     NAME             PolicyAction
     DESCRIPTION      A class representing a rule-specific or reusable
                      policy action to be performed if the condition for
                      a policy rule evaluates to TRUE.
     DERIVED FROM     Policy
     ABSTRACT         FALSE
     PROPERTIES       SystemCreationClassName[key]


 Moore, et al.         Expires: Oct 1999 + 6 months            [Page 44]


 Internet Draft       Policy Core Information Model         October 1999


                      SystemName[key]
                      PolicyRuleCreationClassName[key]
                      PolicyRuleName[key]
                      CreationClassName[key]
                      PolicyActionName[key]

 6.7.1. The Key Property "SystemCreationClassName"

   This property helps to identify the System object in whose scope this
   instance of PolicyAction exists.  For a rule-specific policy action,
   this is the system in whose context the policy rule is defined.  For a
   reusable policy action, this is the instance of PolicyRepository
   (which is a subclass of System) that holds the policy action.

   Note that this property, and the analogous property SystemName, do not
   represent propagated keys from an instance of the class System.  (If
   they did, they would be written with a dot:  System.CreationClassName,
   System.Name.)  Instead, they are properties defined in the context of
   this class, which repeat the values from the instance of System to
   which the instance containing them is related, either directly via the
   ActionInPolicyRepository aggregation or indirectly via the
   ActionInPolicyRule aggregation.  See Section 5.3.3 for more on this
   topic.

   This property is defined as follows:

     NAME             SystemCreationClassName
     DESCRIPTION      The name of the class or the subclass used in the
                      creation of the System object in whose scope this
                      policy action is defined.
     SYNTAX           string
     QUALIFIER        key

 6.7.2. The Key Property "SystemName"

   This property completes the identification of the System object in
   whose scope this instance of PolicyAction exists.  For a rule-specific
   policy action, this is the system in whose context the policy rule is
   defined.  For a reusable policy action, this is the instance of
   PolicyRepository (which is a subclass of System) that holds the policy
   action.

   This property is defined as follows:

     NAME             SystemName
     DESCRIPTION      The name of the System object in whose scope this
                      policy action is defined.
     SYNTAX           string
     QUALIFIER        key





 Moore, et al.         Expires: Oct 1999 + 6 months            [Page 45]


 Internet Draft       Policy Core Information Model         October 1999


 6.7.3. The Key Property "PolicyRuleCreationClassName"

   For a rule-specific policy action, this property helps to identify the
   policy rule in whose scope this instance of PolicyAction exists.  For
   a reusable policy action, this property returns a special value, "No
   Rule", indicating that this instance of PolicyAction is not unique to
   one policy rule.

   This property is defined as follows:

     NAME             PolicyRuleCreationClassName
     DESCRIPTION      For a rule-specific policy action, this property
                      identifies the class of the policy rule instance in
                      whose scope this instance of PolicyAction exists.
                      For a reusable policy action, this property returns
                      a special value, "No Rule", indicating that this
                      instance of PolicyAction is not unique to one
                      policy rule.

     SYNTAX           string[MaxLen 256]
     QUALIFIER        key


 6.7.4. The Key Property "PolicyRuleName"

   For a rule-specific policy action, this property completes the
   identification of the policy rule in whose scope this instance of
   PolicyCondition exists.  For a reusable policy action, this property
   returns a special value, "No Rule", indicating that this instance of
   PolicyCondition is not unique to one policy rule.

   This property is defined as follows:

     NAME             PolicyRuleName
     DESCRIPTION      For a rule-specific policy action, the name of the
                      PolicyRule object with which this action is
                      associated.  For a reusable policy action, a
                      special value, "No Rule", indicating that this
                      action is reusable.
     SYNTAX           string
     QUALIFIER        key

 6.7.5. The Key Property "CreationClassName"

   This property identifies the class or subclass used in the creation of
   this instance.

     NAME             CreationClassName
     DESCRIPTION      The name of the class or subclass used in the
                      creation of this instance.
     SYNTAX           string[MaxLen 256]
     QUALIFIER        key


 Moore, et al.         Expires: Oct 1999 + 6 months            [Page 46]


 Internet Draft       Policy Core Information Model         October 1999




 6.7.6. The Key Property "PolicyActionName"

   This property provides a user-friendly name for a policy action, and
   is normally what will be displayed to the end-user as the instance
   name.  It is defined as follows:

     NAME             PolicyActionName
     DESCRIPTION      The user-friendly name of this policy action.
     SYNTAX           string
     QUALIFIER        key

 6.8. The Class "VendorPolicyAction"

   The purpose of this class is to provide a general escape mechanism for
   representing policy actions that have not been modeled with specific
   properties. Instead, the two properties ActionData and ActionEncoding
   are used to define the content and format of the action, as explained
   below.

   As its name suggests, this class is intended for vendor-specific
   extensions to the Policy Core Information Model.  Standardized
   extensions are not expected to use this class.

   The class definition is as follows:

     NAME             VendorPolicyAction
     DESCRIPTION      A class that defines a registered means to describe
                      a policy action.
     DERIVED FROM     PolicyAction
     ABSTRACT         FALSE
     PROPERTIES       ActionData[ ]
                      ActionEncoding

 6.8.1. The Multi-valued Property "ActionData"

   This property provides a general escape mechanism for representing
   policy actions that have not been modeled with specific properties.
   The format of the octet strings in the array is left unspecified in
   this definition.  It is determined by the OID value stored in the
   property ActionEncoding.  Since ActionEncoding is single-valued, all
   the values of ActionData share the same format and semantics.

   NOTE:  In version 2.2 of the CIM model [7], there is no direct way to
   represent an array of octet strings.  (A single octet string can be
   represented as an ordered array of uint8's, but this does not work for
   multi-valued properties where each value is an octet string.)  CIM
   has, however, a mechanism that is essentially equivalent to SMI's
   (SNMP's) Textual Convention, for refining the syntax and/or semantics
   of existing data types.  Using this mechanism, a representation of
   octet strings as character strings (specifically, strings consisting


 Moore, et al.         Expires: Oct 1999 + 6 months            [Page 47]


 Internet Draft       Policy Core Information Model         October 1999


   of an even number of the characters A-F and 0-9) has been defined.  In
   a future version of CIM, though, it is likely that an actual
   octetString data type will be added.

   A policy decision point can readily determine whether it supports the
   values stored in an instance of ActionData by checking the OID value
   from ActionEncoding against the set of OIDs it recognizes.  The action
   for the policy decision point to take in case it does not recognize
   the format of this data could itself be modeled as a policy rule,
   governing the behavior of the policy decision point.

   The property is defined as follows:

     NAME             ActionData
     DESCRIPTION      Escape mechanism for representing actions that have
                      not been modeled as specific properties. The format
                      of the values is identified by the OID stored in
                      the property ActionEncoding.
     SYNTAX           uint8


 6.8.2. The Property "ActionEncoding"

   This property identifies the encoding and semantics of the ActionData
   property values in this instance.  The value of this property is a
   single string, representing a single OID.

   The property is defined as follows:

     NAME             ActionEncoding
     DESCRIPTION      An OID encoded as a string, identifying the format
                      and semantics for this instance's ActionData
                      property.
     SYNTAX           string
     QUALIFIER        OID

 6.9. The Class "PolicyRepository"

   The class definition of PolicyRepository is as follows:

     NAME             PolicyRepository
     DESCRIPTION      A class representing an administratively defined
                      container for reusable policy-related information.
                      This class does not introduce any additional
                      properties beyond those in its superclass
                      AdminDomain, other than the key properties
                      necessary to make it instantiable.  It does,
                      however, participate in a number of unique
                      associations.
     DERIVED FROM     AdminDomain
     ABSTRACT         FALSE
     PROPERTIES       CreationClassName[key]


 Moore, et al.         Expires: Oct 1999 + 6 months            [Page 48]


 Internet Draft       Policy Core Information Model         October 1999


                      PolicyRepositoryName[key]

 6.9.1. The Key Property "CreationClassName"

   This property identifies the class or subclass used in the creation of
   this instance.

     NAME             CreationClassName
     DESCRIPTION      The name of the class or subclass used in the
                      creation of this instance.
     SYNTAX           string[MaxLen 256]
     QUALIFIER        key


 6.9.2. The Key Property "PolicyRepositoryName"

   This property provides a user-friendly name for a policy repository,
   and is normally what will be displayed to the end-user as the instance
   name.  It is defined as follows:

     NAME             PolicyRepositoryName
     DESCRIPTION      The user-friendly name of this policy repository.
     SYNTAX           string
     QUALIFIER        key

 6.10. The Class "ResourceManagerCollection"

   This class is an abstraction representing a collection of individual
   resource managers to which a common set of policies are applied.  It
   is the manifestation in the Core Model of the concept of policy role
   discussed in reference [11].

   The class definition of ResourceManagerCollection is as follows:

     NAME             ResourceManagerCollection
     DESCRIPTION      A class representing a collection of resource
                      managers, brought together so that they can be
                      treated as a unit for the purposes of defining and
                      updating policies.
     DERIVED FROM     Collection
     ABSTRACT         FALSE
     PROPERTIES       CreationClassName[key]
                      ResourceManagerCollectionName[key]
                      ResourceManagerType[ ]

 6.10.1. The Key Property "CreationClassName"

   This property identifies the class or subclass used in the creation of
   this instance.

     NAME             CreationClassName



 Moore, et al.         Expires: Oct 1999 + 6 months            [Page 49]


 Internet Draft       Policy Core Information Model         October 1999


     DESCRIPTION      The name of the class or subclass used in the
                      creation of this instance.
     SYNTAX           string[MaxLen 256]
     QUALIFIER        key


 6.10.2. The Key Property "ResourceManagerCollectionName"

   This property provides a user-friendly name for a collection that
   aggregates a number of resource managers; it is normally what will be
   displayed to the end-user as the instance name.  It is defined as
   follows:

     NAME             ResourceManagerCollectionName
     DESCRIPTION      The user-friendly name of this collection.
     SYNTAX           string
     QUALIFIER        key

 6.10.3. The Multi-valued Property "ResourceManagerType"

   This property provides a set of strings for identifying the different
   types of resource managers present in a policy domain.  Each of these
   strings identifies a policy role.

   The property definition is as follows:

     NAME             ResourceManagerType
     DESCRIPTION      A set of strings to identify policy roles.
     SYNTAX           string

   While it isn't part of the Core Policy Model per se, there is also a
   ResourceManagerType property in the class CIM_Service.  (Actually,
   this isn't true yet:  there is, however, a proposal currently before
   the DMTF to add this property to CIM_Service.)  Individual resource
   managers are modeled as instances of CIM_Service, so this property in
   CIM_Service identifies the roles that a resource manager plays.


 7. Association and Aggregation Definitions

   The first three subsections of this section introduce relationships,
   associations, and aggregations as they are used in CIM.  The remaining
   subsections present the class definitions for the associations and
   aggregations that are part of the Policy Core Information Model.

 7.1. Relationships

   Relationships are a central feature of information models.  A
   relationship represents a physical or conceptual connection between
   objects.  CIM and DEN define the general concept of an association
   between two (or more) objects.  Two types of relationships in CIM are
   aggregations (which express whole-part relationships) and


 Moore, et al.         Expires: Oct 1999 + 6 months            [Page 50]


 Internet Draft       Policy Core Information Model         October 1999


   associations, such as those that express dependency.  Both are
   represented as classes, and both are used in this model.

 7.2. Associations

   An association is a class that contains two or more references, where
   each reference identifies another object.  An association is defined
   using a class.  Associations can be defined between classes without
   affecting any of the related classes.  That is, addition of an
   association does not affect the interface of the related classes.

 7.3. Aggregations

   An aggregation is a strong form of an association. An aggregation is
   usually used to represent a "whole-part" relationship. This type of
   relationship defines the containment relationship between a system and
   the components that make up the system.  Aggregation often implies,
   but does not require, that the aggregated objects have mutual
   dependencies.

 7.4. The Aggregation "PolicyGroupInPolicyGroup"

   The PolicyGroupInPolicyGroup aggregation enables policy groups to be
   nested.  This is critical for scalability and manageability, as it
   enables complex policies to be constructed from multiple simpler
   policies for administrative convenience.  For example, a policy group
   representing policies for the US might have nested within it policy
   groups for the Eastern and Western US.

   A PolicyGroup may aggregate other PolicyGroups via this aggregation,
   or it may aggregate PolicyRules via the PolicyRuleInPolicyGroup
   aggregation.  But a single PolicyGroup SHALL NOT do both.

   The class definition for the aggregation is as follows:

     NAME             PolicyGroupInPolicyGroup
     DESCRIPTION      A class representing the aggregation of
                      PolicyGroups by a higher-level PolicyGroup.
     ABSTRACT         FALSE
     PROPERTIES       ContainingGroup[ref PolicyGroup[0..n]]
                      ContainedGroup[ref PolicyGroup[0..n]]

 7.4.1. The Reference "ContainingGroup"

   This property contains the name of a PolicyGroup that contains one or
   more other PolicyGroups.  Note that for any single instance of the
   association class PolicyGroupInPolicyGroup, this property (like all
   Reference properties) is single-valued.  The [0..n] cardinality
   indicates that there may be 0, 1, or more than one PolicyGroups that
   contain any given PolicyGroup.




 Moore, et al.         Expires: Oct 1999 + 6 months            [Page 51]


 Internet Draft       Policy Core Information Model         October 1999


 7.4.2. The Reference "ContainedGroup"

   This property contains the name of a PolicyGroup contained by one or
   more other PolicyGroups.  Note that for any single instance of the
   association class PolicyGroupInPolicyGroup, this property (like all
   Reference properties) is single-valued.  The [0..n] cardinality
   indicates that a given PolicyGroup may contain 0, 1, or more than one
   other PolicyGroups.

 7.5. The Aggregation "PolicyRuleInPolicyGroup"

   A policy group may aggregate one or more policy rules, via the
   PolicyRuleInPolicyGroup aggregation.  Grouping of policy rules into a
   policy group is again for administrative convenience; a policy rule
   may also be used by itself, without belonging to a policy group.

   A PolicyGroup may aggregate PolicyRules via this aggregation, or it
   may aggregate other PolicyGroups via the PolicyGroupInPolicyGroup
   aggregation.  But a single PolicyGroup SHALL NOT do both.

   The class definition for the aggregation is as follows:

     NAME             PolicyRuleInPolicyGroup
     DESCRIPTION      A class representing the aggregation of PolicyRules
                      by a PolicyGroup.
     ABSTRACT         FALSE
     PROPERTIES       ContainingGroup[ref PolicyGroup[0..n]]
                      ContainedRule[ref PolicyRule[0..n]]

 7.5.1. The Reference "ContainingGroup"

   This property contains the name of a PolicyGroup that contains one or
   more PolicyRules.  Note that for any single instance of the
   association class PolicyRuleInPolicyGroup, this property (like all
   Reference properties) is single-valued.  The [0..n] cardinality
   indicates that there may be 0, 1, or more than one PolicyGroups that
   contain any given PolicyRule.

 7.5.2. The Reference "ContainedRule"

   This property contains the name of a PolicyRule contained by one or
   more PolicyGroups.  Note that for any single instance of the
   association class PolicyRuleInPolicyGroup, this property (like all
   Reference properties) is single-valued.  The [0..n] cardinality
   indicates that a given PolicyGroup may contain 0, 1, or more than one
   PolicyRules.

 7.6. The Aggregation "ConditionInPolicyRule"

   A policy rule aggregates zero or more instances of the PolicyCondition
   class, via the ConditionInPolicyRule association.  A policy rule that
   aggregates zero policy conditions is not a valid rule -- it may, for


 Moore, et al.         Expires: Oct 1999 + 6 months            [Page 52]


 Internet Draft       Policy Core Information Model         October 1999


   example, be in the process of being entered into the policy
   repository.  A policy rule has no effect until it is valid.  The
   conditions aggregated by a policy rule are grouped into two levels of
   lists: either an ORed set of ANDed sets of conditions (DNF, the
   default) or an ANDed set of ORed sets of conditions (CNF).  Individual
   conditions in these lists may be negated.  The property
   ConditionListType specifies which of these two grouping schemes
   applies to a particular PolicyRule.

   Since conditions may be defined explicitly in a subclass of
   PolicyRule, the AND/OR mechanism to combine these conditions with
   other (associated) PolicyConditions MUST be specified by the
   PolicyRule's subclass.

   In either case, the conditions are used to determine whether to
   perform the actions associated with the PolicyRule.

   One or more policy time periods may be among the conditions associated
   with a policy rule via the ConditionInPolicyRule association.  In this
   case, the time periods are simply additional conditions to be
   evaluated along with any other conditions specified for the rule.

   The class definition for the aggregation is as follows:

     NAME             ConditionInPolicyRule
     DESCRIPTION      A class representing the aggregation of
                      PolicyConditions by a PolicyRule.
     ABSTRACT         FALSE
     PROPERTIES       ContainingRule[ref PolicyRule[0..n]]
                      ContainedCondition[ref PolicyCondition[0..n]]
                      GroupNumber
                      ConditionNegated

 7.6.1. The Reference "ContainingRule"

   This property contains the name of a PolicyRule that contains one or
   more PolicyConditions.  Note that for any single instance of the
   association class ConditionInPolicyRule, this property (like all
   Reference properties) is single-valued.  The [0..n] cardinality
   indicates that there may be 0, 1, or more than one PolicyRules that
   contain any given PolicyCondition.

 7.6.2. The Reference "ContainedCondition"

   This property contains the name of a PolicyCondition contained by one
   or more PolicyRules.  Note that for any single instance of the
   association class ConditionInPolicyRule, this property (like all
   Reference properties) is single-valued.  The [0..n] cardinality
   indicates that a given PolicyRule may contain 0, 1, or more than one
   PolicyConditions.




 Moore, et al.         Expires: Oct 1999 + 6 months            [Page 53]


 Internet Draft       Policy Core Information Model         October 1999


 7.6.3. The Property "GroupNumber"

   This property contains an integer identifying the group to which the
   condition referenced by the ContainedCondition property is assigned in
   forming the overall conditional expression for the policy rule
   identified by the ContainingRule reference.

   The property is defined as follows:

     NAME             GroupNumber
     DESCRIPTION      Unsigned integer indicating the group to which the
                      condition identified by the ContainedCondition
                      property is to be assigned.
     SYNTAX           uint16


 7.6.4. The Property "ConditionNegated"

   This property is a boolean, indicating whether the condition
   referenced by the ContainedCondition property is negated in forming
   the overall conditional expression for the policy rule identified by
   the ContainingRule reference.

   The property is defined as follows:

     NAME             ConditionNegated
     DESCRIPTION      Indication of whether the condition identified by
                      the ContainedCondition property is negated.  (TRUE
                      indicates that the condition IS negated, FALSE
                      indicates that it IS NOT negated.)
     SYNTAX           boolean


 7.7. The Association "ConditionSubject"

   This association represents a condition that identifies the subject
   requesting a service that has its access controlled by a policy rule.
   A subject might, for example, request access to a particular system,
   or to a particular resource (file, printer, etc.) associated with a
   system.

   In networking cases, a subject is ordinarily identified by the origin
   address information in the packet that causes a policy rule to be
   evaluated.  Thus some component of the Policy Framework must resolve
   the object reference present in this association into a lower-level
   condition against which an origin address can be tested.  The
   component that performs this resolution is typically, but not
   necessarily, the Policy Consumer.

   The resolution itself may be minimal, since in some cases the object
   being referred to will have an address, address range, or subnet as
   one of its properties.  In other cases, though, the object may


 Moore, et al.         Expires: Oct 1999 + 6 months            [Page 54]


 Internet Draft       Policy Core Information Model         October 1999


   identify a subject only by name, in which case other information
   correlating names with network addresses must be used to perform the
   resolution.

   The class definition for the association is as follows:

     NAME             ConditionSubject
     DESCRIPTION      A class indicating that a ManagedElement plays the
                      subject role for a policy condition.
     ABSTRACT         FALSE
     PROPERTIES       Subject[ref ManagedElement[0..n]]
                      Condition[ref PolicyCondition[0..n]]

 7.7.1. The Reference "Subject"

   This property contains the name of a ManagedElement that plays the
   subject role for one or more PolicyConditions.  Note that for any
   single instance of the association class ConditionSubject, this
   property (like all Reference properties) is single-valued.  The [0..n]
   cardinality indicates that a given ManagedElement may play the subject
   role for 0, 1, or more than one PolicyConditions.

 7.7.2. The Reference "Condition"

   This property contains the name of a PolicyCondition related to one or
   more subjects.  Note that for any single instance of the association
   class ConditionSubject, this property (like all Reference properties)
   is single-valued.  The [0..n] cardinality indicates that a given
   PolicyCondition may be associated with 0, 1, or more than one
   ManagedElements that play the subject role for the condition.

 7.8. The Association "ConditionTarget"

   This association represents a condition that identifies the target of
   a requested service whose access is controlled by a policy rule.  A
   target might, for example, be a particular system to which a subject
   is requesting access, or a particular resource (file, printer, etc.)
   associated with a system.

   In networking cases, a target is ordinarily identified by the
   destination address information in the packet that causes a policy
   rule to be evaluated.  Thus some component of the Policy Framework
   must resolve the object reference present in this association into a
   lower-level condition against which a destination address can be
   tested.  The component that performs this resolution is typically, but
   not necessarily, the Policy Consumer.

   The resolution itself may be minimal, since in some cases the object
   being referred to will have an address, address range, or subnet as
   one of its properties.  In other cases, though, the object may
   identify a target only by name, in which case other information



 Moore, et al.         Expires: Oct 1999 + 6 months            [Page 55]


 Internet Draft       Policy Core Information Model         October 1999


   correlating names with network addresses must be used to perform the
   resolution.

   The class definition for the association is as follows:

     NAME             ConditionTarget
     DESCRIPTION      A class indicating that a ManagedElement plays the
                      target role for a policy condition.
     ABSTRACT         FALSE
     PROPERTIES       Target[ref ManagedElement[0..n]]
                      Condition[ref PolicyCondition[0..n]]

 7.8.1. The Reference "Target"

   This property contains the name of a ManagedElement that plays the
   target role for one or more PolicyConditions.  Note that for any
   single instance of the association class ConditionTarget, this
   property (like all Reference properties) is single-valued.  The [0..n]
   cardinality indicates that a given ManagedElement may play the target
   role for 0, 1, or more than one PolicyConditions.

 7.8.2. The Reference "Condition"

   This property contains the name of a PolicyCondition related to one or
   more targets.  Note that for any single instance of the association
   class ConditionTarget, this property (like all Reference properties)
   is single-valued.  The [0..n] cardinality indicates that a given
   PolicyCondition may be associated with 0, 1, or more than one
   ManagedElements that play the target role for the condition.

 7.9. The Aggregation "PolicyRuleValidityPeriod"

   A different relationship between a policy rule and a policy time
   period is represented by the PolicyRuleValidityPeriod association:
   scheduled activation and deactivation of the policy rule. If a policy
   rule is associated with multiple policy time periods via this
   association, then the rule is active if at least one of the time
   periods indicates that it is active.  (In other words, the time
   periods are ORed to determine whether the rule is active.)  A policy
   time period may be aggregated by multiple policy rules.  A rule that
   does not point to a policy time period via this association is, from
   the point of view of scheduling, always active.  It may, however, be
   inactive for other reasons.

   Time periods are a general concept that can be used in other
   applications. However, they are mentioned explicitly here in this
   specification since they are frequently used in policy applications.

   The class definition for the aggregation is as follows:

     NAME             PolicyRuleValidityPeriod



 Moore, et al.         Expires: Oct 1999 + 6 months            [Page 56]


 Internet Draft       Policy Core Information Model         October 1999


     DESCRIPTION      A class representing the aggregation of
                      PolicyTimePeriodConditions by a PolicyRule.
     ABSTRACT         FALSE
     PROPERTIES       ContainingRule[ref PolicyRule[0..n]]
                      ContainedPtp[ref PolicyTimePeriodCondition[0..n]]

 7.9.1. The Reference "ContainingRule"

   This property contains the name of a PolicyRule that contains one or
   more PolicyTimePeriodConditions.  Note that for any single instance of
   the association class PolicyRuleValidityPeriod, this property (like
   all Reference properties) is single-valued.  The [0..n] cardinality
   indicates that there may be 0, 1, or more than one PolicyRules that
   contain any given PolicyTimePeriodCondition.

 7.9.2. The Reference "ContainedPtp"

   This property contains the name of a PolicyTimePeriodCondition
   contained by one or more PolicyRules.  Note that for any single
   instance of the association class PolicyRuleValidityPeriod, this
   property (like all Reference properties) is single-valued.  The [0..n]
   cardinality indicates that a given PolicyRule may contain 0, 1, or
   more than one  PolicyTimePeriodConditions.


 7.10. The Aggregation "ActionInPolicyRule"

   A policy rule may aggregate zero or more policy actions.  A policy
   rule that aggregates zero policy actions is not a valid rule -- it
   may, for example, be in the process of being entered into the policy
   repository.  A policy rule has no effect until it is valid.  The
   actions associated with a PolicyRule may be given a required order, a
   recommended order, or no order at all. For actions represented as
   separate objects, the ActionInPolicyRule aggregation can be used to
   express an order.  For actions defined explicitly in a subclass of
   PolicyRule, the ordering mechanism must be specified in the subclass
   definition.

   This aggregation does not indicate whether a specified action order is
   required, recommended, or of no significance; the property
   SequencedActions in the aggregating instance of PolicyRule provides
   this indication.

   The class definition for the aggregation is as follows:

     NAME             ActionInPolicyRule
     DESCRIPTION      A class representing the aggregation of
                      PolicyActions by a PolicyCondition.
     ABSTRACT         FALSE
     PROPERTIES       ContainingRule[ref PolicyRule[0..n]]
                      ContainedAction[ref PolicyAction[0..n]]
                      ActionOrder


 Moore, et al.         Expires: Oct 1999 + 6 months            [Page 57]


 Internet Draft       Policy Core Information Model         October 1999




 7.10.1. The Reference "ContainingRule"

   This property contains the name of a PolicyRule that contains one or
   more PolicyActions.  Note that for any single instance of the
   association class ActionInPolicyRule, this property (like all
   Reference properties) is single-valued.  The [0..n] cardinality
   indicates that there may be 0, 1, or more than one PolicyRules that
   contain any given PolicyAction.

 7.10.2. The Reference "ContainedAction"

   This property contains the name of a PolicyAction contained by one or
   more PolicyRules.  Note that for any single instance of the
   association class ActionInPolicyRule, this property (like all
   Reference properties) is single-valued.  The [0..n] cardinality
   indicates that a given PolicyRule may contain 0, 1, or more than one
   PolicyActions.

 7.10.3. The Property "ActionOrder"

   This property provides an unsigned integer 'n' that indicates the
   relative position of an action in the sequence of actions associated
   with a policy rule.  When 'n' is a positive integer, it indicates a
   place in the sequence of actions to be performed, with smaller
   integers indicating earlier positions in the sequence.  The special
   value '0' indicates "don't care".  If two or more actions have the
   same non-zero sequence number, they may be performed in any order, but
   they must all be performed at the appropriate place in the overall
   action sequence.

   A series of examples will make ordering of actions clearer:

   o If all actions have the same sequence number, regardless of whether
     it is '0' or non-zero, any order is acceptable.

   o The values

     1:ACTION A
     2:ACTION B
     1:ACTION C
     3:ACTION D

     indicate two acceptable orders:  A,C,B,D or C,A,B,D, since A and C
     can be performed in either order, but only at the '1' position.

   o The values

     0:ACTION A
     2:ACTION B
     3:ACTION C


 Moore, et al.         Expires: Oct 1999 + 6 months            [Page 58]


 Internet Draft       Policy Core Information Model         October 1999


     3:ACTION D

     require that B,C, and D occur either as B,C,D or as B,D,C.  Action
     A may appear at any point relative to B,C, and D.  Thus the
     complete set of acceptable orders is:  A,B,C,D; B,A,C,D; B,C,A,D;
     B,C,D,A; A,B,D,C; B,A,D,C; B,D,A,C; B,D,C,A.

   Note that the non-zero sequence numbers need not start with '1', and
   they need not be consecutive.  All that matters is their relative
   magnitude.

   The property is defined as follows:

     NAME             ActionOrder
     DESCRIPTION      Unsigned integer indicating the relative position
                      of an action in the sequence of actions aggregated
                      by a policy rule.
     SYNTAX           uint16

 7.11. The Association "ConditionInPolicyRepository"

   A reusable policy condition is always related to a single
   PolicyRepository, via the ConditionInPolicyRepository association.
   Since, however, the PolicyCondition class represents both reusable and
   rule-specific policy conditions, an instance of PolicyCondition (one
   that represents a rule-specific condition) may not be related to any
   policy repository via this association.

   The class definition for the association is as follows:

     NAME             ConditionInPolicyRepository
     DESCRIPTION      A class representing the inclusion of a reusable
                      PolicyCondition in a PolicyRepository.
     ABSTRACT         FALSE
     PROPERTIES       ContainingRepository[ref PolicyRepository[0..1]]
                      ContainedCondition[ref PolicyCondition[0..n]]

 7.11.1. The Reference "ContainingRepository"

   This property contains the name of a PolicyRepository containing one
   or more PolicyConditions.  A reusable PolicyCondition is always
   related to exactly one PolicyRepository via the
   ConditionInPolicyRepository association.  The [0..1] cardinality for
   this property covers the two types of PolicyConditions:  0 for a rule-
   specific PolicyCondition, 1 for a reusable one.

 7.11.2. The Reference "ContainedCondition"

   This property contains the name of a PolicyCondition included in a
   PolicyRepository.  Note that for any single instance of the
   association class ConditionInPolicyRepository, this property (like all
   Reference properties) is single-valued.  The [0..n] cardinality


 Moore, et al.         Expires: Oct 1999 + 6 months            [Page 59]


 Internet Draft       Policy Core Information Model         October 1999


   indicates that a given PolicyRepository may contain 0, 1, or more than
   one PolicyConditions.

 7.12. The Association "ActionInPolicyRepository"

   A reusable policy action is always related to a single
   PolicyRepository, via the ActionInPolicyRepository association.
   Since, however, the PolicyAction class represents both reusable and
   rule-specific policy actions, an instance of PolicyAction (one that
   represents a rule-specific action) may not be related to any policy
   repository via this association.

   The class definition for the association is as follows:

     NAME             ActionInPolicyRepository
     DESCRIPTION      A class representing the inclusion of a reusable
                      PolicyAction in a PolicyRepository.
     ABSTRACT         FALSE
     PROPERTIES       ContainingRepository[ref PolicyRepository[0..1]]
                      ContainedAction[ref PolicyAction[0..n]]

 7.12.1. The Reference "ContainingRepository"

   This property contains the name of a PolicyRepository containing one
   or more PolicyActions.  A reusable PolicyAction is always related to
   exactly one PolicyRepository via the ActionInPolicyRepository
   association.  The [0..1] cardinality for this property covers the two
   types of PolicyActions:  0 for a rule-specific PolicyAction, 1 for a
   reusable one.

 7.12.2. The Reference "ContainedAction"

   This property contains the name of a PolicyAction included in a
   PolicyRepository.  Note that for any single instance of the
   association class ActionInPolicyRepository, this property (like all
   Reference properties) is single-valued.  The [0..n] cardinality
   indicates that a given PolicyRepository may contain 0, 1, or more than
   one PolicyActions.

 7.13. The Weak Association "PolicyGroupInSystem"

   A PolicyGroup is named within the scope of a CIM System, via the weak
   association PolicyGroupInSystem.  This relationship is an association
   rather than an aggregation because in CIM a System aggregates
   ManagedSystemElements, while the Core Policy classes (that is, the
   subclasses of the abstract class Policy) are derived from the CIM
   class ManagedElement, not ManagedSystemElement.

   The class definition for the association is as follows:

     NAME             PolicyGroupInSystem



 Moore, et al.         Expires: Oct 1999 + 6 months            [Page 60]


 Internet Draft       Policy Core Information Model         October 1999


     DESCRIPTION      A class representing the weak association of a
                      PolicyGroup with a CIM System.
     ABSTRACT         FALSE
     PROPERTIES       ContainingSystem[ref System]
                      ContainedGroup[ref PolicyGroup[weak]]

 7.13.1. The Reference "ContainingSystem"

   This property contains the name of a CIM System that provides a naming
   scope for one or more PolicyGroups.  Since this is a weak association,
   the cardinality for CIM System is always 1, that is, a PolicyGroup is
   always named within the scope of exactly one CIM System.

 7.13.2. The Reference "ContainedGroup"

   This property contains the name of a PolicyGroup named within the
   context of a CIM System.  Note that for any single instance of the
   association class PolicyGroupInSystem, this property (like all
   Reference properties) is single-valued.  The [0..n] cardinality
   indicates that a given CIM System may have 0, 1, or more than one
   PolicyGroups named within its scope.

 7.14. The Weak Association "PolicyRuleInSystem"

   Regardless of whether it belongs to a PolicyGroup (or to multiple
   PolicyGroups), a PolicyRule is named within the scope of a CIM System,
   via the weak association PolicyRuleInSystem.  This relationship is an
   association rather than an aggregation because in CIM a System
   aggregates ManagedSystemElements, while the Core Policy classes (that
   is, the subclasses of the abstract class Policy) are derived from the
   CIM class ManagedElement, not ManagedSystemElement.

   The class definition for the association is as follows:

     NAME             PolicyRuleInSystem
     DESCRIPTION      A class representing the weak association of a
                      PolicyRule with a CIM System.
     ABSTRACT         FALSE
     PROPERTIES       ContainingSystem[ref System]
                      ContainedRule[ref PolicyRule[weak]]

 7.14.1. The Reference "ContainingSystem"

   This property contains the name of a CIM System that provides a naming
   scope for one or more PolicyRules.  Since this is a weak association,
   the cardinality for CIM System is always 1, that is, a PolicyRule is
   always named within the scope of exactly one CIM System.

 7.14.2. The Reference "ContainedRule"

   This property contains the name of a PolicyRule named within the
   context of a CIM System.  Note that for any single instance of the


 Moore, et al.         Expires: Oct 1999 + 6 months            [Page 61]


 Internet Draft       Policy Core Information Model         October 1999


   association class PolicyRuleInSystem, this property (like all
   Reference properties) is single-valued.  The [0..n] cardinality
   indicates that a given CIM System may have 0, 1, or more than one
   PolicyRules named within its scope.

 7.15. The Aggregation "PolicyRepositoryInPolicyRepository"

   The PolicyRepositoryInPolicyRepository aggregation enables policy
   repositories to be nested.

   The class definition for the aggregation is as follows:

     NAME             PolicyRepositoryInPolicyRepository
     DESCRIPTION      A class representing the aggregation of
                      PolicyRepositories by a higher-level
                      PolicyRepository.
     ABSTRACT         FALSE
     PROPERTIES       ContainingRepository[ref PolicyRepository[0..n]]
                      ContainedRepository[ref PolicyRepository[0..n]]

 7.15.1. The Reference "ContainingRepository"

   This property contains the name of a PolicyRepository that contains
   one or more other PolicyRepositories.  Note that for any single
   instance of the association class PolicyRepositoryInPolicyRepository,
   this property (like all Reference properties) is single-valued.  The
   [0..n] cardinality indicates that there may be 0, 1, or more than one
   PolicyRepositories that contain any given PolicyRepository.

   EDITOR'S NOTE:  This matches the recursive aggregation for
   PolicyGroups, but I could also see an argument for having the
   cardinality at the "containing" end being [0..1], which would make
   this more like DIT containment.  Let's just decide one way or the
   other.

 7.15.2. The Reference "ContainedRepository"

   This property contains the name of a PolicyRepository contained by one
   or more other PolicyRepositories [or simply "by another
   PolicyRepository" -- see the EDITOR'S NOTE in the preceding section].
   Note that for any single instance of the association class
   PolicyRepositoryInPolicyRepository, this property (like all Reference
   properties) is single-valued.  The [0..n] cardinality indicates that a
   given PolicyRepository may contain 0, 1, or more than one other
   PolicyRepositories.

 7.16. The Association "ResourceManagerCollectionPolicyGroup"

   This association relates a set of policies aggregated into a
   PolicyGroup to a ResourceManagerCollection representing one or more
   policy roles.



 Moore, et al.         Expires: Oct 1999 + 6 months            [Page 62]


 Internet Draft       Policy Core Information Model         October 1999


   The class definition for the association is as follows:

     NAME             ResourceManagerCollectionPolicyGroup
     DESCRIPTION      A class representing the applicability of the
                      PolicyRules (or lower-level PolicyGroups) in a
                      PolicyGroup to one or more of the roles represented
                      by a collection of resource managers.
     ABSTRACT         FALSE
     PROPERTIES AffectedRMCollection[ref ResourceManagerCollection[0..n]]
                      ApplicableGroup[ref PolicyGroup[0..n]]

 7.17. The Association "ResourceManagerCollectionPolicyRule"

   This association relates an individual PolicyRule to a
   ResourceManagerCollection representing one or more policy roles.

   The class definition for the association is as follows:

     NAME             ResourceManagerCollectionPolicyRule
     DESCRIPTION      A class representing the applicability of a
                      PolicyRule to one or more of the roles represented
                      by a collection of resource managers.
     ABSTRACT         FALSE
     PROPERTIES AffectedRMCollection[ref ResourceManagerCollection[0..n]]
                      ApplicableRule[ref PolicyRule[0..n]]

 7.18. The Aggregation "MemberResourceManager"

   This aggregation ties individual resource managers (represented as
   instances of the class CIM_Service) to a ResourceManagerCollection
   representing one or more policy roles played by the resource managers.
   A constraint on this aggregation is that the instances of CIM_Service
   referred to via the ResourceManager property must be ones that
   represent resource managers.

   The class definition for the aggregation is as follows:

     NAME             MemberResourceManager
     DESCRIPTION      A class representing the aggregation of individual
                      resource managers by a ResourceManagerCollection.
                      A constraint on this aggregation is that the
                      instances of CIM_Service referred to via the
                      ResourceManager property must be ones that
                      represent resource managers.
     DERIVED FROM     MemberService
     ABSTRACT         FALSE
     PROPERTIES       RMCollection[ref ResourceManagerCollection[0..n]]
                      ResourceManager[ref CIM_Service[0..n]]






 Moore, et al.         Expires: Oct 1999 + 6 months            [Page 63]


 Internet Draft       Policy Core Information Model         October 1999


 7.19. The Association "ResourceManagerPolicyGroup"

   This association relates a set of policies aggregated into a
   PolicyGroup to an individual ResourceManager.

   The class definition for the association is as follows:

     NAME             ResourceManagerPolicyGroup
     DESCRIPTION      A class representing the applicability of the
                      PolicyRules (or lower-level PolicyGroups) in a
                      PolicyGroup to a particular resource manager.
     ABSTRACT         FALSE
     PROPERTIES       AffectedResourceManager[ref CIM_Service[0..n]]
                      ApplicableGroup[ref PolicyGroup[0..n]]

 7.20. The Association "ResourceManagerPolicyRule"

   This association relates an individual PolicyRule to an individual
   ResourceManager

   The class definition for the association is as follows:

     NAME             ResourceManagerPolicyRule
     DESCRIPTION      A class representing the applicability of a
                      PolicyRule to a particular resource manager.
     ABSTRACT         FALSE
     PROPERTIES       AffectedResourceManager[ref CIM_Service[0..n]]
                      ApplicableRule[ref PolicyRule[0..n]]

 7.21. The Association "ResourceManagerManagedResource"

   This association completes the three-level hierarchy in the resource
   manager model by relating a resource manager to the resources that it
   manages.

   The class definition for the association is as follows:

     NAME             ResourceManagerManagedResource
     DESCRIPTION      A class representing the relationship between a
                      resource manager and the resources that it manages.
     ABSTRACT         FALSE
     PROPERTIES       ManagingResourceManager[ref CIM_Service[0..n]]
                      ManagedResource[ref CIM_ManagedSystemElement[0..n]]


 8. Intellectual Property

   The IETF takes no position regarding the validity or scope of any
   intellectual property or other rights that might be claimed to pertain
   to the implementation or use of the technology described in this
   document or the extent to which any license under such rights might or
   might not be available; neither does it represent that it has made any


 Moore, et al.         Expires: Oct 1999 + 6 months            [Page 64]


 Internet Draft       Policy Core Information Model         October 1999


   effort to identify any such rights.  Information on the IETF's
   procedures with respect to rights in standards-track and standards-
   related documentation can be found in BCP-11.

   Copies of claims of rights made available for publication and any
   assurances of licenses to be made available, or the result of an
   attempt made to obtain a general license or permission for the use of
   such proprietary rights by implementers or users of this specification
   can be obtained from the IETF Secretariat.

   The IETF invites any interested party to bring to its attention any
   copyrights, patents or patent applications, or other proprietary
   rights which may cover technology that may be required to practice
   this standard.  Please address the information to the IETF Executive
   Director.


 9. Acknowledgements

   The Policy Core Information Model in this document is closely based on
   the work of the DMTF's Service Level Agreements working group, so
   thanks are due to the members of that working group.


 10. Security Considerations

   o General:   The IETF is concerned with standardizing what happens on
      the wire.  However, many of the security concerns in a policy
      system have to do with things that have nothing to do with what
      happens on the wire, like logging, how data is stored on the
      repository server, etc.  These are out-of-scope for IETF
      standardization.  However, it is necessary to document the
      requirements for a secure policy system, in order to show that the
      overall policy framework is viable.  Our model for documenting
      these requirements is based on prior work in the IETF on DNSSEC and
      SNMPv3.  One of our objectives in the policy work in the IETF is to
      not break the known existing security mechanisms, or to make them
      less effective, regardless of whether or not these security
      mechanisms affect what flows on the wire.

   o Users:  The first step in identifying security requirements for
      policy, is to identify the users of policy.  The users fall into
      three categories:

   o Administrators of Schema: This group requires the most stringent
      authorization and associated security controls.  An improper or
      mal-formed change in the design of the policy schema carries with
      it the danger of rendering the repository inoperable while the
      repository is being repaired or re-built.  During this time, the
      policy enforcement entities would need to continue to enforce
      policies according to their prior configuration. The good news is
      that it is expected that large network operators will change schema


 Moore, et al.         Expires: Oct 1999 + 6 months            [Page 65]


 Internet Draft       Policy Core Information Model         October 1999


      design infrequently, and, when they do, the schema creation changes
      will be tested on an off-line copy of the directory before the
      operational directory is updated.  Typically, a small group of
      schema administrators will be authorized to make these changes in a
      service provider or enterprise environment.  The ability to
      maintain an audit trail is also required here.

   o Administrators of Schema Content: This group requires authorization
      to load values (entries) into a policy repository) schema
      (read/write access).   An audit trail mechanism is also required
      here. The effect of entering improperly formatted or maliciously-
      intended data into a policy repository, could potentially result in
      re-configuring mass numbers of network elements in a way that
      renders them to be inoperable, or of rendering network resources
      inaccessible for an extended period of time,

   o Applications and Policy Consumers:  These entities must be
      authorized for read-only access to the policy repository, so that
      they may acquire policy for the purposes of passing it to their
      respective enforcement entities.

   o Security Disciplines:

        o Audit Trail (Non-repudiation):  In general, standardizing
           mechanisms for non-repudiation is outside the scope of the
           IETF; however, we can certainly document the need for this
           function in systems which maintain and distribute policy.  The
           dependency for support of this function is on the implementers
           of these systems, and not on any specific standards for
           implementation.  The requirement for a policy system is that a
           minimum level of auditing via an auditing facility must be
           provided.  Logging should be enabled.  This working group will
           not specify what this minimal auditing function consists of.

        o Access Control/Authorization:  Access Control List (ACL)
           functionality must be provided. The two administrative sets of
           users documented above will form the basis for two
           administrative use cases which require support.

        o Authentication:  Authentication support on the order of that
           available with  TLS and Kerboros are acceptable for
           authentication.  We advise against using weaker mechanisms,
           such as clear text and HTTP Digest.  Mutual authentication is
           recommended.

        o Integrity/Privacy:  Integrity/privacy support on the order of
           TLS  or IPSEC is acceptable for encryption and data integrity
           on the wire.  If physical or virtual access to the policy
           repository is in question, it may also be necessary to encrypt
           the policy data as it is stored on the file system; however,
           specification of mechanisms for this purpose are outside the
           scope of this working group.  In any case, we recommend that


 Moore, et al.         Expires: Oct 1999 + 6 months            [Page 66]


 Internet Draft       Policy Core Information Model         October 1999


           the physical server be located in a physically secure
           environment.

      In the case of Policy Consumer-to-Policy Target communications, the
      use of IPSEC is recommended for providing confidentiality, data
      origin authentication, integrity and replay prevention.  See
      reference [10].

   o Denial of Service:  We recommend the use of multiple policy
      repositories, such that a denial of service attack on any one
      repository will not make all policy data inaccessible to legitimate
      users.  However, this still leaves a denial of service attack
      exposure.  Our belief is that the use of a policy schema, in a
      centrally administered but physically distributed policy
      repository, does not increase the risk of denial of service
      attacks; however, such attacks are still possible.  If executed
      successfully, such an attack could prevent Policy Consumers from
      accessing a policy repository, and thus prevent them from acquiring
      new policy.  In such a case, the Policy Consumers, and associated
      Policy Targets would continue operating under the policies in force
      before the denial of service attack was launched.  Note that
      exposure of policy systems to denial of service attacks is not any
      greater than the exposure of DNS with DNSSEC in place.


 11. References

 [1]  J. Strassner and E. Ellesson, "Terminology for describing network
      policy and services", draft-strassner-policy-terms-02.txt, June
      1999.

 [2]  Bhattacharya, P., and R. Adams, W. Dixon, R. Pereira, R. Rajan, "An
      LDAP Schema for Configuration and Administration of IPSec based
      Virtual Private Networks (VPNs)", Internet-Draft work in progress,
      October 1998

 [3]  Rajan, R., and J. C. Martin, S. Kamat, M. See, R. Chaudhury, D.
      Verma, G. Powers, R. Yavatkar, "Schema for Differentiated Services
      and Integrated Services in Networks", Internet-Draft work in
      progress, October 1998

 [4]  J. Strassner and S. Judd, "Directory-Enabled Networks", version
      3.0c5 (August 1998).

 [5]  Bradner, S., "Key words for use in RFCs to Indicate Requirement
      Levels", BCP 14, RFC 2119, March 1997.

 [6]  Hovey, R., and S. Bradner, "The Organizations Involved in the IETF
      Standards Process", BCP 11, RFC 2028, October 1996.

 [7]  Distributed Management Task Force, Inc., "Common Information Model
      (CIM) Specification, version 2.2, June 14, 1999.


 Moore, et al.         Expires: Oct 1999 + 6 months            [Page 67]


 Internet Draft       Policy Core Information Model         October 1999


 [8]  J. Strassner, policy architecture BOF presentation, 42nd IETF
      Meeting, Chicago, Illinois, October, 1998

 [9]  J. Strassner and E. Ellesson, B. Moore "Policy Framework LDAP Core
      Schema," draft-ietf-policy-core-schema-05.txt, October 1999.

 [10] R. Yavatkar and D. Pendarakis, R. Guerin, "A Framework for Policy-
      based Admission Control", draft-ietf-rap-framework-03.txt, April
      1999.

 [11] Stevens, M., and W. Weiss, H. Mahon, B. Moore, J. Strassner, G.
      Waters, A. Westerinen, J. Wheeler, "Policy Framework", draft-ietf-
      policy-framework-00.txt, September, 1999.


 12. Authors' Addresses

   John Strassner
       Cisco Systems, Bldg 1
       170 West Tasman Drive
       San Jose, CA 95134
       Phone:   +1 408-527-1069
       Fax:     +1 408-527-1722
       E-mail:  johns@cisco.com

   Ed Ellesson
      IBM Corporation/Tivoli, JDGA/501
      4205 S. Miami Blvd.
      Research Triangle Park, NC 27709
      Phone:   +1 919-254-4115
      Fax:     +1 919-254-6243
      E-mail:  ellesson@raleigh.ibm.com

   Bob Moore
      IBM Corporation, BRQA/502
      4205 S. Miami Blvd.
      Research Triangle Park, NC 27709
      Phone:   +1 919-254-4436
      Fax:     +1 919-254-6243
      E-mail:  remoore@us.ibm.com

 13. Full Copyright Statement

   Copyright (C) The Internet Society (1999).  All Rights Reserved.

   This document and translations of it may be copied and furnished to
   others, and derivative works that comment on or otherwise explain it
   or assist in its implementation may be prepared, copied, published and
   distributed, in whole or in part, without restriction of any kind,
   provided that the above copyright notice and this paragraph are
   included on all such copies and derivative works.  However, this
   document itself may not be modified in any way, such as by removing


 Moore, et al.         Expires: Oct 1999 + 6 months            [Page 68]


 Internet Draft       Policy Core Information Model         October 1999


   the copyright notice or references to the Internet Society or other
   Internet organizations, except as needed for the purpose of developing
   Internet standards in which case the procedures for copyrights defined
   in the Internet Standards process must be followed, or as required to
   translate it into languages other than English.

   The limited permissions granted above are perpetual and will not be
   revoked by the Internet Society or its successors or assigns.

   This document and the information contained herein is provided on an
   "AS IS" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING
   TASK FORCE DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT
   NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION HEREIN
   WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF
   MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.







































 Moore, et al.         Expires: Oct 1999 + 6 months            [Page 69]

