stripe_unit_number = F(X);
stripe_count = number of elements in
     mdla_complex_addr.nflda_stripe_indices;

j = (stripe_unit_number + mdln_first_index) %
     stripe_count;

idx = nflda_stripe_indices[j];

fh_count = number of elements in mdln_fh_list;
lmds_count = number of elements in
fh = mdln_fh_list[idx];
fh = mdln_fh_list[0];
fh = current filehandle passed to LAYOUTGET;
address_list =
     mdla_complex_addr.nflda_multipath_ds_list[idx];

                                   Figure 4

      The client would then select an L-MDS from address_list, and send
      the name-based operation using the filehandle specified in fh.

segment_count = number of elements in
     mdl_dirrdops_layout_segments;

relative_cookie = cookie_arg -
     mdl_dirrdops_layout_segments[k].mdld_first_cookie;

i = floor(relative_cookie /
     mdl_dirrdops_layout_segments[k].mdld_unit_size);

stripe_count = number of elements in
     mdla_complex_addr.nflda_stripe_indices;

j = (stripe_unit_number + mdld_first_index) % stripe_count;

idx = nflda_stripe_indices[j];

mdldf_use_namebased == TRUE) {
fh_count = number of elements in mdln_fh_list;
lmds_count = number of elements in
       mdla_complex_addr.nflda_multipath_ds_list;
fh_count = number of elements in
       mdl_dirrdops_layout_segments[k].mdld_fh_list.
         mdldf_fh_list;
lmds_count = number of elements in
       mdla_complex_addr.nflda_multipath_ds_list;
mdldf_use_namebased == TRUE) {
fh = mdln_fh_list[idx];
fh = mdl_dirrdops_layout_segments[k].mdld_fh_list.
           mdldf_fh_list[idx];
mdldf_use_namebased == TRUE) {
fh = mdln_fh_list[0];
fh = mdl_dirrdops_layout_segments[k].mdld_fh_list.
           mdldf_fh_list[0];
fh = current filehandle passed to LAYOUTGET;
address_list =  mdla_complex_addr.
     nflda_multipath_ds_list[idx];

                                   Figure 5

      The client would then select an L-MDS from address_list, and send
      the directory-reading operation using the filehandle specified in
      fh.  When the client is reading the beginning of the directory,
      cookie_arg is always zero.  Subsequent directory-reading
      operations to read the rest of the directory will use the last
      cookie returned by the L-MDS.  Am MDS returning a metadata layout
      SHOULD return cookies that can be used directly to the I-MDS that
      returned the layout.  However this might not always be possible.
      For example, the directory design of the filesystem of the MDS,
      might not return cookies in ascending order, or any order at all
      for that matter.  Whereas, striping by definition requires an
      ordering.  In such cases, if a directory is restriped while a pNFS
      client is reading its contents from the L-MDSes, it is possible
      that client will be unable to complete reading the directory, and
      as a result an error is returned to process reading the directory.
      To mitigate this, servers that have sent a CB_LAYOUTRECALL on the
      directory SHOULD NOT revoke the layout as long as they detect that
      the client is completing a read of the entire directory.  Once a
      client has received a CB_LAYOUTRECALL, it SHOULD NOT send a
      directory-reading operation to an L-MDS with a cookie argument of
      zero.  If the server has sent a CB_LAYOUTRECALL, the L-MDS SHOULD
      reject requests to read the directory that have a cookie argument
      zero and return the error NFS4ERR_PNFS_NO_LAYOUT.

