<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="en"><head><title>Common Interface to Cryptographic Modules (CICM) Channel Management</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="description" content="Common Interface to Cryptographic Modules (CICM) Channel Management">
<meta name="generator" content="xml2rfc v1.35 (http://xml.resource.org/)">
<meta name="viewport" content="width=600;" />
<style type='text/css'><!--
        body {
                font-family: verdana, charcoal, helvetica, arial, sans-serif;
                font-size: 85%;
		max-width: 60em; 
		color: #000; background-color: #FFF;
                margin: 2em;
        }
        h1, h2, h3, h4, h5, h6 {
                font-family: helvetica, monaco, "MS Sans Serif", arial, sans-serif;
                font-weight: bold; font-style: normal;
        }
        h1 { color: #900; background-color: transparent; text-align: right; }
        h3 { color: #333; background-color: transparent; }

        td.RFCbug {
                font-size: x-small; text-decoration: none;
                width: 30px; height: 30px; padding-top: 2px;
                text-align: justify; vertical-align: middle;
                background-color: #000;
        }
        td.RFCbug span.RFC {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: bold; color: #666;
        }
        td.RFCbug span.hotText {
                font-family: charcoal, monaco, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: normal; text-align: center; color: #FFF;
        }

        table.TOCbug { width: 30px; height: 15px; }
        td.TOCbug {
                text-align: center; width: 30px; height: 15px;
                color: #FFF; background-color: #900;
        }
        td.TOCbug a {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, sans-serif;
                font-weight: bold; font-size: x-small; text-decoration: none;
                color: #FFF; background-color: transparent;
        }

        td.header {
                font-family: arial, helvetica, sans-serif; font-size: x-small;
                vertical-align: top; width: 33%;
                color: #FFF; background-color: #666;
        }
        td.author { font-weight: bold; font-size: x-small; margin-left: 4em; }
        td.author-text { font-size: x-small; }

        /* info code from SantaKlauss at http://www.madaboutstyle.com/tooltip2.html */
        a.info {
                /* This is the key. */
                position: relative;
                z-index: 24;
                text-decoration: none;
        }
        a.info:hover {
                z-index: 25;
                color: #FFF; background-color: #900;
        }
        a.info span { display: none; }
        a.info:hover span.info {
                /* The span will display just on :hover state. */
                display: block;
                position: absolute;
                font-size: smaller;
                top: 2em; left: -5em; width: 15em;
                padding: 2px; border: 1px solid #333;
                color: #900; background-color: #EEE;
                text-align: left;
        }

        a { font-weight: bold; }
        a:link    { color: #900; background-color: transparent; }
        a:visited { color: #633; background-color: transparent; }
        a:active  { color: #633; background-color: transparent; }

        p { margin-left: 2em; margin-right: 2em; }
        p.copyright { font-size: x-small; }
        p.toc { font-size: 85%;
		max-width: 60em; 
		font-weight: bold; margin-left: 3em; }
        table.toc { margin: 0 0 0 3em; padding: 0; border: 0; vertical-align: text-top; }
        td.toc { font-size: 85%;
		max-width: 60em; 
		font-weight: bold; vertical-align: text-top; }

        ol.text { margin-left: 2em; margin-right: 2em; }
        ul.text { margin-left: 2em; margin-right: 2em; }
        li      { margin-left: 3em; }

        /* RFC-2629 <spanx>s and <artwork>s. */
        em     { font-style: italic; }
        strong { font-weight: bold; }
        dfn    { font-weight: bold; font-style: normal; }
        cite   { font-weight: normal; font-style: normal; }
        tt     { color: #036; }
        tt, pre, pre dfn, pre em, pre cite, pre span {
                font-family: "Courier New", Courier, monospace; font-size: small;
        }
        pre {
                text-align: left; padding: 4px;
                color: #000; background-color: #CCC;
        }
        pre dfn  { color: #900; }
        pre em   { color: #66F; background-color: #FFC; font-weight: normal; }
        pre .key { color: #33C; font-weight: bold; }
        pre .id  { color: #900; }
        pre .str { color: #000; background-color: #CFF; }
        pre .val { color: #066; }
        pre .rep { color: #909; }
        pre .oth { color: #000; background-color: #FCF; }
        pre .err { background-color: #FCC; }

        /* RFC-2629 <texttable>s. */
        table.all, table.full, table.headers, table.none {
                font-size: 85%;
		max-width: 60em; 
		text-align: center; border-width: 2px;
                vertical-align: top; border-collapse: collapse;
        }
        table.all, table.full { border-style: solid; border-color: black; }
        table.headers, table.none { border-style: none; }
        th {
                font-weight: bold; border-color: black;
                border-width: 2px 2px 3px 2px;
        }
        table.all th, table.full th { border-style: solid; }
        table.headers th { border-style: none none solid none; }
        table.none th { border-style: none; }
        table.all td {
                border-style: solid; border-color: #333;
                border-width: 1px 2px;
        }
        table.full td, table.headers td, table.none td { border-style: none; }

        hr { height: 1px; }
        hr.insert {
                width: 80%; border-style: none; border-width: 0;
                color: #CCC; background-color: #CCC;
        }
--></style>
</head>
<body>
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<table summary="layout" width="66%" border="0" cellpadding="0" cellspacing="0"><tr><td><table summary="layout" width="100%" border="0" cellpadding="2" cellspacing="1">
<tr><td class="header">Internet Engineering Task Force</td><td class="header">D. Lanz</td></tr>
<tr><td class="header">Internet-Draft</td><td class="header">L. Novikov</td></tr>
<tr><td class="header">Intended status: Informational</td><td class="header">MITRE</td></tr>
<tr><td class="header">Expires: July 12, 2011</td><td class="header">January 8, 2011</td></tr>
</table></td></tr></table>
<h1><br />Common Interface to Cryptographic Modules (CICM) Channel Management<br />draft-lanz-cicm-cm-00</h1>

<h3>Abstract</h3>

<p>[RFC Editor: Please update the RFC references prior to publication.]
</p>
<p>This memo defines a programming interface for the management of
      cryptographic channels as outlined in draft-lanz-cicm-lm-00 and required
      by draft-lanz-cicm-02 including creating and negotiating channels for
      encryption, decryption, bypass, data integrity, or to generate random
      data.
</p>
<p>Comments are solicited and should be addressed to the mailing list at cicm@ietf.org.
</p>
<h3>Status of this Memo</h3>
<p>
This Internet-Draft is submitted  in full
conformance with the provisions of BCP&nbsp;78 and BCP&nbsp;79.</p>
<p>
Internet-Drafts are working documents of the Internet Engineering
Task Force (IETF).  Note that other groups may also distribute
working documents as Internet-Drafts.  The list of current
Internet-Drafts is at http://datatracker.ietf.org/drafts/current/.</p>
<p>
Internet-Drafts are draft documents valid for a maximum of six months
and may be updated, replaced, or obsoleted by other documents at any time.
It is inappropriate to use Internet-Drafts as reference material or to cite
them other than as &ldquo;work in progress.&rdquo;</p>
<p>
This Internet-Draft will expire on July 12, 2011.</p>

<h3>Copyright Notice</h3>
<p>
Copyright (c) 2011 IETF Trust and the persons identified as the
document authors.  All rights reserved.</p>
<p>
This document is subject to BCP 78 and the IETF Trust's Legal
Provisions Relating to IETF Documents
(http://trustee.ietf.org/license-info) in effect on the date of
publication of this document.  Please review these documents
carefully, as they describe your rights and restrictions with respect
to this document. Code Components extracted from this document must
include Simplified BSD License text as described in Section 4.e of
the Trust Legal Provisions and are provided without warranty as
described in the Simplified BSD License.</p>
<a name="toc"></a><br /><hr />
<h3>Table of Contents</h3>
<p class="toc">
<a href="#anchor1">1.</a>&nbsp;
Introduction<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor2">1.1.</a>&nbsp;
Requirements Language<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor3">1.2.</a>&nbsp;
Definition Language<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor4">1.3.</a>&nbsp;
Conformance and Extension Language<br />
<a href="#anchor5">2.</a>&nbsp;
CICM Dependencies<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor6">2.1.</a>&nbsp;
Namespaces<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor7">2.2.</a>&nbsp;
Types<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor8">2.3.</a>&nbsp;
Interfaces<br />
<a href="#anchor9">3.</a>&nbsp;
Channel Namespaces<br />
<a href="#anchor10">4.</a>&nbsp;
Channel Abstractions<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor11">4.1.</a>&nbsp;
Algorithm Types<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor12">4.2.</a>&nbsp;
State Vector<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor13">4.3.</a>&nbsp;
Integrity Buffers<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor14">4.4.</a>&nbsp;
Interface CICM::ChannelManager<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor17">4.5.</a>&nbsp;
Interface CICM::Channel<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor19">4.6.</a>&nbsp;
Interface CICM::Conduit<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor21">4.7.</a>&nbsp;
Interface CICM::Controller<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor24">4.8.</a>&nbsp;
Interface CICM::Stream<br />
<a href="#anchor26">5.</a>&nbsp;
Conduit Abstractions<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor27">5.1.</a>&nbsp;
Interface CICM::AbstractMACConduit<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor31">5.2.</a>&nbsp;
Interface CICM::AbstractSignConduit<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor35">5.3.</a>&nbsp;
Interface CICM::AbstractVerifyConduit<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor38">5.4.</a>&nbsp;
Interface CICM::AbstractMACVerifyConduit<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor42">5.5.</a>&nbsp;
Interface CICM::AbstractSigVerifyConduit<br />
<a href="#anchor46">6.</a>&nbsp;
Stream Abstractions<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor47">6.1.</a>&nbsp;
Interface CICM::WriteStream<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor50">6.2.</a>&nbsp;
Interface CICM::ReadStream<br />
<a href="#anchor53">7.</a>&nbsp;
Controller Abstractions<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor54">7.1.</a>&nbsp;
Interface CICM::MultiDomainController<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor57">7.2.</a>&nbsp;
Interface CICM::SymKeyController<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor61">7.3.</a>&nbsp;
Interface CICM::AsymKeyController<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor64">7.4.</a>&nbsp;
Interface CICM::NegotiatedController<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor68">7.5.</a>&nbsp;
Interface CICM::SetVectorController<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor72">7.6.</a>&nbsp;
Interface CICM::GenVectorController<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor75">7.7.</a>&nbsp;
Interface CICM::ResyncController<br />
<a href="#sec_channel_negotiation">8.</a>&nbsp;
Channel Negotiation<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor78">8.1.</a>&nbsp;
Negotiating Channels and Controllers<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor79">8.2.</a>&nbsp;
Interface CICM::Negotiator<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor81">8.3.</a>&nbsp;
Interface CICM::PeerInfo<br />
<a href="#sec-encrypt">9.</a>&nbsp;
Encryption<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor83">9.1.</a>&nbsp;
Interface CICM::Encrypt::ChannelManager<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor85">9.2.</a>&nbsp;
Interface CICM::Encrypt::Stream<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor88">9.3.</a>&nbsp;
Interface CICM::Encrypt::KeyWrapStream<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor91">9.4.</a>&nbsp;
Interface CICM::Encrypt::Controller<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor93">9.5.</a>&nbsp;
Interface CICM::Encrypt::NegotiatedController<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor95">9.6.</a>&nbsp;
Interface CICM::Encrypt::Conduit<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor97">9.7.</a>&nbsp;
Interface CICM::Encrypt::NegotiatedConduit<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor99">9.8.</a>&nbsp;
Interface CICM::Encrypt::WithMACConduit<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor101">9.9.</a>&nbsp;
Interface CICM::Encrypt::WithMACNegotiatedConduit<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor103">9.10.</a>&nbsp;
Interface CICM::Encrypt::WithSignConduit<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor105">9.11.</a>&nbsp;
Interface CICM::Encrypt::WithSignNegotiatedConduit<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor107">9.12.</a>&nbsp;
Interface CICM::Encrypt::KeyWrapConduit<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor109">9.13.</a>&nbsp;
Interface CICM::Encrypt::ControllerNegotiator<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor112">9.14.</a>&nbsp;
Interface CICM::Encrypt::Negotiator<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor115">9.15.</a>&nbsp;
Interface CICM::Encrypt::WithMACNegotiator<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor118">9.16.</a>&nbsp;
Interface CICM::Encrypt::WithSignNegotiator<br />
<a href="#sec-decrypt">10.</a>&nbsp;
Decryption<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor121">10.1.</a>&nbsp;
Interface CICM::Decrypt::ChannelManager<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor123">10.2.</a>&nbsp;
Interface CICM::Decrypt::Stream<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor126">10.3.</a>&nbsp;
Interface CICM::Decrypt::KeyUnwrapStream<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor129">10.4.</a>&nbsp;
Interface CICM::Decrypt::Controller<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor131">10.5.</a>&nbsp;
Interface CICM::Decrypt::NegotiatedController<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor133">10.6.</a>&nbsp;
Interface CICM::Decrypt::Conduit<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor135">10.7.</a>&nbsp;
Interface CICM::Decrypt::NegotiatedConduit<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor137">10.8.</a>&nbsp;
Interface CICM::Decrypt::WithMACConduit<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor139">10.9.</a>&nbsp;
Interface CICM::Decrypt::WithMACNegotiatedConduit<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor141">10.10.</a>&nbsp;
Interface CICM::Decrypt::WithVerifyConduit<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor143">10.11.</a>&nbsp;
Interface CICM::Decrypt::WithVerifyNegotiatedConduit<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor145">10.12.</a>&nbsp;
Interface CICM::Decrypt::KeyUnwrapConduit<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor147">10.13.</a>&nbsp;
Interface CICM::Decrypt::Negotiator<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor150">10.14.</a>&nbsp;
Interface CICM::Decrypt::ControllerNegotiator<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor153">10.15.</a>&nbsp;
Interface CICM::Decrypt::WithMACNegotiator<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor156">10.16.</a>&nbsp;
Interface CICM::Decrypt::WithVerifyNegotiator<br />
<a href="#sec-duplex">11.</a>&nbsp;
Duplex<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor159">11.1.</a>&nbsp;
Interface CICM::Duplex::ChannelManager<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor161">11.2.</a>&nbsp;
Interface CICM::Duplex::Stream<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor163">11.3.</a>&nbsp;
Interface CICM::Duplex::Controller<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor165">11.4.</a>&nbsp;
Interface CICM::Duplex::NegotiatedController<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor167">11.5.</a>&nbsp;
Interface CICM::Duplex::Conduit<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor169">11.6.</a>&nbsp;
Interface CICM::Duplex::NegotiatedConduit<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor171">11.7.</a>&nbsp;
Interface CICM::Duplex::ControllerNegotiator<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor174">11.8.</a>&nbsp;
Interface CICM::Duplex::Negotiator<br />
<a href="#sec-bypass-write">12.</a>&nbsp;
Bypass (Send)<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor177">12.1.</a>&nbsp;
Interface CICM::BypassWrite::ChannelManager<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor179">12.2.</a>&nbsp;
Interface CICM::BypassWrite::Stream<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor182">12.3.</a>&nbsp;
Interface CICM::BypassWrite::Controller<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor184">12.4.</a>&nbsp;
Interface CICM::BypassWrite::Conduit<br />
<a href="#sec-bypass-read">13.</a>&nbsp;
Bypass (Read)<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor186">13.1.</a>&nbsp;
Interface CICM::BypassRead::ChannelManager<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor188">13.2.</a>&nbsp;
Interface CICM::BypassRead::Stream<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor191">13.3.</a>&nbsp;
Interface CICM::BypassRead::Controller<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor193">13.4.</a>&nbsp;
Interface CICM::BypassRead::Conduit<br />
<a href="#sec-encrypt-bypass">14.</a>&nbsp;
Encryption with Selective Bypass<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor195">14.1.</a>&nbsp;
Interface CICM::EncryptBypass::ChannelManager<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor197">14.2.</a>&nbsp;
Interface CICM::EncryptBypass::Stream<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor199">14.3.</a>&nbsp;
Interface CICM::EncryptBypass::NegotiatedController<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor201">14.4.</a>&nbsp;
Interface CICM::EncryptBypass::Controller<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor203">14.5.</a>&nbsp;
Interface CICM::EncryptBypass::Conduit<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor205">14.6.</a>&nbsp;
Interface CICM::EncryptBypass::NegotiatedConduit<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor207">14.7.</a>&nbsp;
Interface CICM::EncryptBypass::ControllerNegotiator<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor210">14.8.</a>&nbsp;
Interface CICM::EncryptBypass::Negotiator<br />
<a href="#sec-decrypt-bypass">15.</a>&nbsp;
Decryption with Selective Bypass<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor213">15.1.</a>&nbsp;
Interface CICM::DecryptBypass::ChannelManager<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor215">15.2.</a>&nbsp;
Interface CICM::DecryptBypass::Stream<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor217">15.3.</a>&nbsp;
Interface CICM::DecryptBypass::Controller<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor219">15.4.</a>&nbsp;
Interface CICM::DecryptBypass::NegotiatedController<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor221">15.5.</a>&nbsp;
Interface CICM::DecryptBypass::Conduit<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor223">15.6.</a>&nbsp;
Interface CICM::DecryptBypass::NegotiatedConduit<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor225">15.7.</a>&nbsp;
Interface CICM::DecryptBypass::ControllerNegotiator<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor228">15.8.</a>&nbsp;
Interface CICM::DecryptBypass::Negotiator<br />
<a href="#sec-emit">16.</a>&nbsp;
Random, Pseudorandom and Keystream<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor231">16.1.</a>&nbsp;
Interface CICM::Emit::ChannelManager<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor233">16.2.</a>&nbsp;
Interface CICM::Emit::GetStream<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor236">16.3.</a>&nbsp;
Interface CICM::Emit::Controller<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor239">16.4.</a>&nbsp;
Interface CICM::Emit::RandomController<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor241">16.5.</a>&nbsp;
Interface CICM::Emit::RandomConduit<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor243">16.6.</a>&nbsp;
Interface CICM::Emit::PseudoRandomController<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor245">16.7.</a>&nbsp;
Interface CICM::Emit::PseudoRandomConduit<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor247">16.8.</a>&nbsp;
Interface CICM::Emit::KeyStreamGenController<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor249">16.9.</a>&nbsp;
Interface CICM::Emit::KeyStreamGenConduit<br />
<a href="#sec-answer">17.</a>&nbsp;
Data Integrity<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor251">17.1.</a>&nbsp;
Interface CICM::Answer::ChannelManager<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor253">17.2.</a>&nbsp;
Interface CICM::Answer::PutStream<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor256">17.3.</a>&nbsp;
Interface CICM::Answer::HashConduit<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor260">17.4.</a>&nbsp;
Interface CICM::Answer::MACConduit<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor262">17.5.</a>&nbsp;
Interface CICM::Answer::MACVerifyConduit<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor264">17.6.</a>&nbsp;
Interface CICM::Answer::SignConduit<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor266">17.7.</a>&nbsp;
Interface CICM::Answer::SignHashConduit<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor268">17.8.</a>&nbsp;
Interface CICM::Answer::VerifyConduit<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor270">17.9.</a>&nbsp;
Interface CICM::Answer::VerifyHashConduit<br />
<a href="#sec-coprocessor">18.</a>&nbsp;
Single-Domain<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor272">18.1.</a>&nbsp;
Interface CICM::Coprocessor::ChannelManager<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor274">18.2.</a>&nbsp;
Interface CICM::Coprocessor::Stream<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor277">18.3.</a>&nbsp;
Interface CICM::Coprocessor::EncryptConduit<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor280">18.4.</a>&nbsp;
Interface CICM::Coprocessor::EncryptWithMACConduit<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor282">18.5.</a>&nbsp;
Interface CICM::Coprocessor::EncryptWithSignConduit<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor284">18.6.</a>&nbsp;
Interface CICM::Coprocessor::DecryptConduit<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor287">18.7.</a>&nbsp;
Interface CICM::Coprocessor::DecryptWithMACConduit<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor289">18.8.</a>&nbsp;
Interface CICM::Coprocessor::DecryptWithVerifyConduit<br />
<a href="#anchor291">19.</a>&nbsp;
Channel Events<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor292">19.1.</a>&nbsp;
Interface CICM::ChannelEventManager<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor294">19.2.</a>&nbsp;
Interface CICM::ChannelEventListener<br />
<a href="#anchor297">20.</a>&nbsp;
Channel Groups<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor298">20.1.</a>&nbsp;
Interface CICM::ControllerGroup<br />
<a href="#anchor300">21.</a>&nbsp;
IANA Considerations<br />
<a href="#anchor301">22.</a>&nbsp;
Security Considerations<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor302">22.1.</a>&nbsp;
Confidentiality<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor303">22.2.</a>&nbsp;
Bypass<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor304">22.3.</a>&nbsp;
Data Integrity<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor305">22.4.</a>&nbsp;
Peer Entity Authentication<br />
<a href="#rfc.references1">23.</a>&nbsp;
References<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#rfc.references1">23.1.</a>&nbsp;
Normative References<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#rfc.references2">23.2.</a>&nbsp;
Informative References<br />
<a href="#idl-code">Appendix&nbsp;A.</a>&nbsp;
IDL Definitions<br />
<a href="#rfc.authors">&#167;</a>&nbsp;
Authors' Addresses<br />
</p>
<br clear="all" />

<a name="anchor1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1"></a><h3>1.&nbsp;
Introduction</h3>

<p>This document defines the key management functions for the Common Interface to
      Cryptographic Modules (CICM) as defined in <a class='info' href='#CICM'>[CICM]<span> (</span><span class='info'>Lanz, D. and L. Novikov, &ldquo;Common Interface to Cryptographic Modules (CICM)           [RFC Editor: Please update the RFC reference and date prior to publication.],&rdquo; January&nbsp;2011.</span><span>)</span></a>. The underlying logical
      model and terminology is defined in <a class='info' href='#CICM-LM'>[CICM&#8209;LM]<span> (</span><span class='info'>Lanz, D. and L. Novikov, &ldquo;Common Interface to Cryptographic Modules (CICM) Logical Model           [RFC Editor: Please update the RFC reference and date prior to publication.],&rdquo; January&nbsp;2011.</span><span>)</span></a>.
</p>
<a name="anchor2"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1.1"></a><h3>1.1.&nbsp;
Requirements Language</h3>

<p>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL",
        "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY",
        and "OPTIONAL" in this document are to be interpreted as
        described in <a class='info' href='#RFC2119'>[RFC2119]<span> (</span><span class='info'>Bradner, S., &ldquo;Key words for use in RFCs to Indicate Requirement Levels,&rdquo; March&nbsp;1997.</span><span>)</span></a>.
</p>
<a name="anchor3"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1.2"></a><h3>1.2.&nbsp;
Definition Language</h3>

<p>This document uses the Interface Definition Language (IDL) <a class='info' href='#IDL'>[IDL]<span> (</span><span class='info'>International Standards Organization, &ldquo;Information technology — Open Distributed Processing — Interface Definition Language,&rdquo; March&nbsp;1999.</span><span>)</span></a> to
        specify language-neutral interfaces and is not intended to prescribe or preclude a particular
        communications protocol such as General Inter-ORB Protocol (GIOP) <a class='info' href='#CORBA'>[CORBA]<span> (</span><span class='info'>Object Management Group, &ldquo;Common Object Request Broker Architecture (CORBA) Specification, Version 3.1,&rdquo; January&nbsp;2008.</span><span>)</span></a>
        between programs in different address spaces or on different devices. In other words, any specific
        protocol is strictly OPTIONAL. See Definition Language in <a class='info' href='#CICM'>[CICM]<span> (</span><span class='info'>Lanz, D. and L. Novikov, &ldquo;Common Interface to Cryptographic Modules (CICM)           [RFC Editor: Please update the RFC reference and date prior to publication.],&rdquo; January&nbsp;2011.</span><span>)</span></a>
        for more information.
        
</p>
<a name="anchor4"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1.3"></a><h3>1.3.&nbsp;
Conformance and Extension Language</h3>

<p>This document contains definitions for several opaque data parameters whose
        format is not defined by CICM. Instead, implementers are required to create an
        Implementation Conformance Statement which MUST reference a standard format or
        define a module developer-specific format implemented by the module for these
        datatypes. See Conformance and Extensions in <a class='info' href='#CICM'>[CICM]<span> (</span><span class='info'>Lanz, D. and L. Novikov, &ldquo;Common Interface to Cryptographic Modules (CICM)           [RFC Editor: Please update the RFC reference and date prior to publication.],&rdquo; January&nbsp;2011.</span><span>)</span></a> for more details.
</p>
<a name="anchor5"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2"></a><h3>2.&nbsp;
CICM Dependencies</h3>

<p>This document depends on type definitions and interfaces that
      are defined in other CICM documents.
</p>
<a name="anchor6"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2.1"></a><h3>2.1.&nbsp;
Namespaces</h3>

<p>The CICM namespace is defined in <a class='info' href='#CICM'>[CICM]<span> (</span><span class='info'>Lanz, D. and L. Novikov, &ldquo;Common Interface to Cryptographic Modules (CICM)           [RFC Editor: Please update the RFC reference and date prior to publication.],&rdquo; January&nbsp;2011.</span><span>)</span></a>.
</p>
<a name="anchor7"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2.2"></a><h3>2.2.&nbsp;
Types</h3>

<p>The following type definitions are defined in <a class='info' href='#CICM'>[CICM]<span> (</span><span class='info'>Lanz, D. and L. Novikov, &ldquo;Common Interface to Cryptographic Modules (CICM)           [RFC Editor: Please update the RFC reference and date prior to publication.],&rdquo; January&nbsp;2011.</span><span>)</span></a>:
          </p>
<blockquote class="text">
<p>CICM::UInt32
</p>
<p>CICM::CharString
</p>
<p>CICM::Buffer
</p>
<p>CICM::Status (including all return values)
</p>
<p>CICM::LocalPort
</p>
<p>CICM::RemotePort
</p>
<p>CICM::Classification
</p>
</blockquote><p>
        
</p>
<a name="anchor8"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2.3"></a><h3>2.3.&nbsp;
Interfaces</h3>

<p>The interface CICM::Iterator is defined in <a class='info' href='#CICM'>[CICM]<span> (</span><span class='info'>Lanz, D. and L. Novikov, &ldquo;Common Interface to Cryptographic Modules (CICM)           [RFC Editor: Please update the RFC reference and date prior to publication.],&rdquo; January&nbsp;2011.</span><span>)</span></a>; CICM::Key,
        CICM::AsymKey and CICM::SymKey are defined in <a class='info' href='#CICM-KM'>[CICM&#8209;KM]<span> (</span><span class='info'>Lanz, D. and L. Novikov, &ldquo;Common Interface to Cryptographic Modules (CICM) Key Management           [RFC Editor: Please update the RFC reference and date prior to publication.],&rdquo; January&nbsp;2011.</span><span>)</span></a>.
</p>
<a name="anchor9"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3"></a><h3>3.&nbsp;
Channel Namespaces</h3>

<p>Due to the large number of potential configurations, the definitions of the
        channel types and their operations are divided into ten namespaces which group together
        similar or related types of channels.
</p>
<p>The namespaces are:
        </p>
<ol class="text">
<li>CICM::Encrypt (<a class='info' href='#sec-encrypt'>Section&nbsp;9<span> (</span><span class='info'>Encryption</span><span>)</span></a>)
</li>
<li>CICM::Decrypt (<a class='info' href='#sec-decrypt'>Section&nbsp;10<span> (</span><span class='info'>Decryption</span><span>)</span></a>)
</li>
<li>CICM::Duplex (<a class='info' href='#sec-duplex'>Section&nbsp;11<span> (</span><span class='info'>Duplex</span><span>)</span></a>)
</li>
<li>CICM::BypassWrite (<a class='info' href='#sec-bypass-write'>Section&nbsp;12<span> (</span><span class='info'>Bypass (Send)</span><span>)</span></a>)
</li>
<li>CICM::BypassRead (<a class='info' href='#sec-bypass-read'>Section&nbsp;13<span> (</span><span class='info'>Bypass (Read)</span><span>)</span></a>)
</li>
<li>CICM::EncryptBypass (<a class='info' href='#sec-encrypt-bypass'>Section&nbsp;14<span> (</span><span class='info'>Encryption with Selective Bypass</span><span>)</span></a>)
</li>
<li>CICM::DecryptBypass (<a class='info' href='#sec-decrypt-bypass'>Section&nbsp;15<span> (</span><span class='info'>Decryption with Selective Bypass</span><span>)</span></a>)
</li>
<li>CICM::Emit (<a class='info' href='#sec-emit'>Section&nbsp;16<span> (</span><span class='info'>Random, Pseudorandom and Keystream</span><span>)</span></a>)
</li>
<li>CICM::Answer (<a class='info' href='#sec-answer'>Section&nbsp;17<span> (</span><span class='info'>Data Integrity</span><span>)</span></a>)
</li>
<li>CICM::Coprocessor (<a class='info' href='#sec-coprocessor'>Section&nbsp;18<span> (</span><span class='info'>Single-Domain</span><span>)</span></a>)
</li>
</ol><p>
        See <a class='info' href='#CICM-LM'>[CICM&#8209;LM]<span> (</span><span class='info'>Lanz, D. and L. Novikov, &ldquo;Common Interface to Cryptographic Modules (CICM) Logical Model           [RFC Editor: Please update the RFC reference and date prior to publication.],&rdquo; January&nbsp;2011.</span><span>)</span></a> for a high level description of the channel types
        or below for the channel definitions.
</p>
<a name="anchor10"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4"></a><h3>4.&nbsp;
Channel Abstractions</h3>

<a name="anchor11"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.1"></a><h3>4.1.&nbsp;
Algorithm Types</h3>

<p>Type CICM::HashAlgorithmId
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>typedef CICM::CharString HashAlgorithmId;</pre></div>
<p>Unique hash algorithm identifier.
</p>
<p>Type CICM::AsymEncrAlgorithmId
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>typedef CICM::CharString AsymEncrAlgorithmId;</pre></div>
<p>Unique asymmetric encryption algorithm identifier.
</p>
<p>Constant CICM::IMPLICIT_ASYM_ENCR_ALGO
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>const CICM::AsymEncrAlgorithmId
IMPLICIT_ASYM_ENCR_ALGO = "IMPLICIT";</pre></div>
<p>Value that indicates that the encryption algorithm is
          implicit in the key being provided to the module.
</p>
<p>Type CICM::AsymSigAlgorithmId
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>typedef CICM::CharString
AsymSigAlgorithmId;</pre></div>
<p>Unique asymmetric signature algorithm identifier.
</p>
<p>Constant CICM::IMPLICIT_ASYM_SIG_ALGO
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>const CICM::AsymSigAlgorithmId
IMPLICIT_ASYM_SIG_ALGO = "IMPLICIT";</pre></div>
<p>Value that indicates that the signature algorithm is
          implicit in the key being provided to the module.
</p>
<p>Type CICM::KeyWrapAlgorithmId
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>typedef CICM::CharString
KeyWrapAlgorithmId;</pre></div>
<p>Unique key wrap algorithm identifier, incorporating both the
        algorithm and the mode.
</p>
<p>Constant CICM::IMPLICIT_KEY_WRAP_ALGO
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>const CICM::KeyWrapAlgorithmId
IMPLICIT_KEY_WRAP_ALGO = "IMPLICIT";</pre></div>
<p>Value that indicates that the key wrap algorithm is
          implicit in the key being provided to the module.
</p>
<p>Type CICM::SymEncrAlgorithmId
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>typedef CICM::CharString SymEncrAlgorithmId;</pre></div>
<p>Unique symmetric encryption algorithm identifier,
          incorporating both the algorithm and the mode.
</p>
<p>Constant CICM::IMPLICIT_SYM_ENCR_ALGO
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>const CICM::SymEncrAlgorithmId
IMPLICIT_SYM_ENCR_ALGO = "IMPLICIT";</pre></div>
<p>Value that indicates that the encryption algorithm is
          implicit in the key being provided to the module.
</p>
<p>Type CICM::SymMacAlgorithmId
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>typedef CICM::CharString SymMacAlgorithmId;</pre></div>
<p>Unique symmetric MAC algorithm identifier.
</p>
<p>Constant CICM::IMPLICIT_SYM_MAC_ALGO
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>const CICM::SymMacAlgorithmId
IMPLICIT_SYM_MAC_ALGO = "IMPLICIT";</pre></div>
<p>Value that indicates that the MAC algorithm is implicit in
          the key being provided to the module.
</p>
<p>Type CICM::ProtocolId
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>typedef CICM::CharString ProtocolId;</pre></div>
<p>Unique key agreement protocol identifier.
</p>
<p>Constant CICM::IMPLICIT_PROTOCOL_ID
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>const CICM::ProtocolId
IMPLICIT_PROTOCOL_ID = "IMPLICIT";</pre></div>
<p>Value that indicates that the key agreement protocol is
          implicit in the message being provided to the module.
</p>
<a name="anchor12"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.2"></a><h3>4.2.&nbsp;
State Vector</h3>

<p>Type CICM::Vector
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>typedef CICM::Buffer Vector;</pre></div>
<p>State vector, used to represent initialization vectors,
          synchronization vectors, counter values, and time-of-day values.
</p>
<a name="anchor13"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.3"></a><h3>4.3.&nbsp;
Integrity Buffers</h3>

<p>Type CICM::HashBuffer
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>typedef CICM::Buffer HashBuffer;</pre></div>
<p>Cryptographic hash.
</p>
<p>Type CICM::MACBuffer
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>typedef CICM::Buffer MACBuffer;</pre></div>
<p>Message authentication code (MAC).
</p>
<p>Type CICM::SigBuffer
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>typedef CICM::Buffer SigBuffer;</pre></div>
<p>Cryptographic signature.
</p>
<a name="anchor14"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.4"></a><h3>4.4.&nbsp;
Interface CICM::ChannelManager</h3>

<p>Interface CICM::ChannelManager
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>interface ChannelManager :
	CICM::Answer::ChannelManager,
	CICM::BypassRead::ChannelManager,
	CICM::BypassWrite::ChannelManager,
	CICM::Coprocessor::ChannelManager,
	CICM::Decrypt::ChannelManager,
	CICM::DecryptBypass::ChannelManager,
	CICM::Duplex::ChannelManager,
	CICM::Emit::ChannelManager,
	CICM::Encrypt::ChannelManager,
	CICM::EncryptBypass::ChannelManager {</pre></div>
<p>CICM::ChannelManager supports the creation and negotiation of
					cryptographic channels. It is accessed from CICM::CryptoModule via
					the CICM::CryptoModule::channel_manager attribute.
					CICM::ChannelManager enables a variety of different channel types
					to be constructed.
</p>
<p>Note:
						</p>
<blockquote class="text">
<p>Conforming implementations need only implement one or more of
						  the ChannelManager's dependencies thereby limiting which
						  negotiators, controllers, streams, and channels are
						  available. See Conformance and Extensions in <a class='info' href='#CICM'>[CICM]<span> (</span><span class='info'>Lanz, D. and L. Novikov, &ldquo;Common Interface to Cryptographic Modules (CICM)           [RFC Editor: Please update the RFC reference and date prior to publication.],&rdquo; January&nbsp;2011.</span><span>)</span></a> for
              more information.
</p>
</blockquote><p>
					
</p>
<a name="anchor15"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.4.1"></a><h3>4.4.1.&nbsp;
CICM::ChannelManager Inheritance</h3>

<p>CICM::ChannelManager inherits from: CICM::Answer::ChannelManager,
						CICM::BypassRead::ChannelManager,
						CICM::BypassWrite::ChannelManager,
						CICM::Coprocessor::ChannelManager, CICM::Decrypt::ChannelManager,
						CICM::DecryptBypass::ChannelManager, CICM::Duplex::ChannelManager,
						CICM::Emit::ChannelManager, CICM::Encrypt::ChannelManager and
						CICM::EncryptBypass::ChannelManager.
</p>
<a name="anchor16"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.4.2"></a><h3>4.4.2.&nbsp;
CICM::ChannelManager Methods</h3>

<p>Method CICM::ChannelManager::create_controller_group()
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>CICM::Status create_controller_group(
	out CICM::ControllerGroup controller_group_ref
);</pre></div>
<p>Creates a CICM::ControllerGroup to group controllers and
						conduits together.
</p>
<p>Parameters:
							</p>
<blockquote class="text">
<p>[out] controller_group_ref Reference to the created controller group.
</p>
</blockquote><p>
						
</p>
<p>Returns:
							</p>
<blockquote class="text">
<p>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT
</p>
</blockquote><p>
						
</p>
<a name="anchor17"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.5"></a><h3>4.5.&nbsp;
Interface CICM::Channel</h3>

<p>Interface CICM::Channel
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>interface Channel {</pre></div>
<p>Defines the logical path through the module. Interface from
					which all conduit, streams and controllers inherit.
					Channels are created via the CICM::ChannelManager interface.
</p>
<a name="anchor18"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.5.1"></a><h3>4.5.1.&nbsp;
CICM::Channel Attributes</h3>

<p>AttributeCICM::Channel::event_manager
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>readonly attribute CICM::ChannelEventManager event_manager;</pre></div>
<p>Provides access to the event manager.
</p>
<a name="anchor19"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.6"></a><h3>4.6.&nbsp;
Interface CICM::Conduit</h3>

<p>Interface CICM::Conduit
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>interface Conduit :
	CICM::Controller,
	CICM::Stream {</pre></div>
<p>Interface from which all other conduits are inherited. A
					conduit is a combination of a stream and controller.
</p>
<a name="anchor20"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.6.1"></a><h3>4.6.1.&nbsp;
CICM::Conduit Inheritance</h3>

<p>CICM::Conduit inherits from: CICM::Controller and CICM::Stream.
</p>
<a name="anchor21"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.7"></a><h3>4.7.&nbsp;
Interface CICM::Controller</h3>

<p>Interface CICM::Controller
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>interface Controller : CICM::Channel {</pre></div>
<p>Interface from which all other controllers are inherited.
					Controls general characteristics of a cryptographic transformation,
					but does not provide data to be transformed.
</p>
<p>Remarks:
						</p>
<blockquote class="text">
<p>There may be cases in which a client program wishes to
						  delegate responsibility for sending or receiving data from the
						  module to another process while retaining the authority to manage
						  the channel. To support this task, both processes must share a
						  known local port. The client-program responsible for controlling
						  the channel creates a CICM::Controller of the appropriate type
						  after which the corresponding CICM::Stream may be obtained by the
						  second process. A stream is tied to the specific controller that
						  configured the channel by a common port value.
</p>
</blockquote><p>
					
</p>
<a name="anchor22"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.7.1"></a><h3>4.7.1.&nbsp;
CICM::Controller Inheritance</h3>

<p>CICM::Controller inherits from: CICM::Channel.
</p>
<a name="anchor23"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.7.2"></a><h3>4.7.2.&nbsp;
CICM::Controller Methods</h3>

<p>Method CICM::Controller::destroy()
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>CICM::Status destroy();</pre></div>
<p>Destroys the controller.
</p>
<p>Returns:
							</p>
<blockquote class="text">
<p>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT
</p>
</blockquote><p>
						
</p>
<a name="anchor24"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.8"></a><h3>4.8.&nbsp;
Interface CICM::Stream</h3>

<p>Interface CICM::Stream
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>interface Stream : CICM::Channel {};</pre></div>
<p>Interface from which all streams inherit. Streams manage the
					flow of data on a channel, but not its attributes.
</p>
<a name="anchor25"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.8.1"></a><h3>4.8.1.&nbsp;
CICM::Stream Inheritance</h3>

<p>CICM::Stream inherits from: CICM::Channel.
</p>
<a name="anchor26"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5"></a><h3>5.&nbsp;
Conduit Abstractions</h3>

<a name="anchor27"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.1"></a><h3>5.1.&nbsp;
Interface CICM::AbstractMACConduit</h3>

<p>Interface CICM::AbstractMACConduit
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>interface AbstractMACConduit : CICM::Conduit {</pre></div>
<p>Interface from which other MAC conduits are inherited.
</p>
<a name="anchor28"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.1.1"></a><h3>5.1.1.&nbsp;
CICM::AbstractMACConduit Inheritance</h3>

<p>CICM::AbstractMACConduit inherits from: CICM::Conduit.
</p>
<a name="anchor29"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.1.2"></a><h3>5.1.2.&nbsp;
CICM::AbstractMACConduit Attributes</h3>

<p>AttributeCICM::AbstractMACConduit::mac_key
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>readonly attribute CICM::SymKey mac_key;</pre></div>
<p>The key used for computing the MAC.
</p>
<p>AttributeCICM::AbstractMACConduit::mac_algorithm
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>readonly attribute CICM::SymMacAlgorithmId mac_algorithm;</pre></div>
<p>The algorithm used to MAC the data.
</p>
<a name="anchor30"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.1.3"></a><h3>5.1.3.&nbsp;
CICM::AbstractMACConduit Methods</h3>

<p>Method CICM::AbstractMACConduit::end_get_mac()
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>CICM::Status end_get_mac(
	out CICM::MACBuffer mac
);</pre></div>
<p>Direct the module to compute and output the MAC value, and
						reset the channel to accept additional data.
</p>
<p>Parameters:
							</p>
<blockquote class="text">
<p>[out] mac Computed MAC value.
</p>
</blockquote><p>
						
</p>
<p>Returns:
							</p>
<blockquote class="text">
<p>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR,
							  S_CHANNEL_PEER_RESET
</p>
</blockquote><p>
						
</p>
<a name="anchor31"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.2"></a><h3>5.2.&nbsp;
Interface CICM::AbstractSignConduit</h3>

<p>Interface CICM::AbstractSignConduit
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>interface AbstractSignConduit : CICM::Conduit {</pre></div>
<p>Interface from which other sign conduits are inherited.
</p>
<a name="anchor32"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.2.1"></a><h3>5.2.1.&nbsp;
CICM::AbstractSignConduit Inheritance</h3>

<p>CICM::AbstractSignConduit inherits from: CICM::Conduit.
</p>
<a name="anchor33"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.2.2"></a><h3>5.2.2.&nbsp;
CICM::AbstractSignConduit Attributes</h3>

<p>AttributeCICM::AbstractSignConduit::sign_key
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>readonly attribute CICM::AsymKey sign_key;</pre></div>
<p>Key used for signing the data.
</p>
<p>AttributeCICM::AbstractSignConduit::sign_algorithm
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>readonly attribute CICM::AsymSigAlgorithmId sign_algorithm;</pre></div>
<p>Algorithm used to sign the data.
</p>
<a name="anchor34"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.2.3"></a><h3>5.2.3.&nbsp;
CICM::AbstractSignConduit Methods</h3>

<p>Method CICM::AbstractSignConduit::end_get_signature()
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>CICM::Status end_get_signature(
	out CICM::SigBuffer signature
);</pre></div>
<p>Direct the module to compute and output the signature, and
						reset the conduit to accept additional data.
</p>
<p>Parameters:
							</p>
<blockquote class="text">
<p>[out] signature The computed signature.
</p>
</blockquote><p>
						
</p>
<p>Returns:
							</p>
<blockquote class="text">
<p>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR,
							  S_CHANNEL_PEER_RESET
</p>
</blockquote><p>
						
</p>
<a name="anchor35"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.3"></a><h3>5.3.&nbsp;
Interface CICM::AbstractVerifyConduit</h3>

<p>Interface CICM::AbstractVerifyConduit
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>interface AbstractVerifyConduit : CICM::Conduit {</pre></div>
<p>Interface from which other verification conduits are inherited.
</p>
<a name="anchor36"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.3.1"></a><h3>5.3.1.&nbsp;
CICM::AbstractVerifyConduit Inheritance</h3>

<p>CICM::AbstractVerifyConduit inherits from: CICM::Conduit.
</p>
<a name="anchor37"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.3.2"></a><h3>5.3.2.&nbsp;
CICM::AbstractVerifyConduit Types and Constants</h3>

<p>Type CICM::AbstractVerifyConduit::VerifyStatus
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>typedef CICM::UInt32 VerifyStatus;</pre></div>
<p>Verification status (data verifies/does not verify).
</p>
<p>Constant CICM::AbstractVerifyConduit::C_DATA_VERIFIED
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>const CICM::AbstractVerifyConduit::VerifyStatus
	C_DATA_VERIFIED = 0x00006025;</pre></div>
<p>Data verifies.
</p>
<p>Constant CICM::AbstractVerifyConduit::C_DATA_NOT_VERIFIED
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>const CICM::AbstractVerifyConduit::VerifyStatus
C_DATA_NOT_VERIFIED = 0x00006026;</pre></div>
<p>Data does not verify.
</p>
<a name="anchor38"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.4"></a><h3>5.4.&nbsp;
Interface CICM::AbstractMACVerifyConduit</h3>

<p>Interface CICM::AbstractMACVerifyConduit
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>interface AbstractMACVerifyConduit : CICM::AbstractVerifyConduit {</pre></div>
<p>Interface from which other MAC verify conduits are inherited.
</p>
<a name="anchor39"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.4.1"></a><h3>5.4.1.&nbsp;
CICM::AbstractMACVerifyConduit Inheritance</h3>

<p>CICM::AbstractMACVerifyConduit inherits from: CICM::AbstractVerifyConduit.
</p>
<a name="anchor40"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.4.2"></a><h3>5.4.2.&nbsp;
CICM::AbstractMACVerifyConduit Attributes</h3>

<p>AttributeCICM::AbstractMACVerifyConduit::verify_key
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>readonly attribute CICM::SymKey verify_key;</pre></div>
<p>Key used to verify the MAC.
</p>
<p>AttributeCICM::AbstractMACVerifyConduit::verify_algorithm
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>readonly attribute CICM::SymMacAlgorithmId verify_algorithm;</pre></div>
<p>Algorithm used to verify the data.
</p>
<a name="anchor41"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.4.3"></a><h3>5.4.3.&nbsp;
CICM::AbstractMACVerifyConduit Methods</h3>

<p>Method CICM::AbstractMACVerifyConduit::end_get_verified()
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>CICM::Status end_get_verified(
	in  CICM::MACBuffer mac,
	out CICM::AbstractVerifyConduit::VerifyStatus status
);</pre></div>
<p>Direct the module to compute and output the MAC verification
						status, and reset the channel to accept additional data for
						verification.
</p>
<p>Parameters:
							</p>
<blockquote class="text">
<p>[in] mac Message authentication code.
</p>
<p>[out] status Status indicating whether or not the data
								  verifies.
</p>
</blockquote><p>
						
</p>
<p>Returns:
							</p>
<blockquote class="text">
<p>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR,
							  S_CHANNEL_PEER_RESET, S_CHANNEL_DATA_INVALID,
							  S_CHANNEL_DATA_INVALID_LEN
</p>
</blockquote><p>
						
</p>
<a name="anchor42"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.5"></a><h3>5.5.&nbsp;
Interface CICM::AbstractSigVerifyConduit</h3>

<p>Interface  CICM::AbstractSigVerifyConduit
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>interface AbstractSigVerifyConduit : CICM::AbstractVerifyConduit {</pre></div>
<p>Interface from which other signature verification conduits
					are inherited.
</p>
<a name="anchor43"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.5.1"></a><h3>5.5.1.&nbsp;
CICM::AbstractSigVerifyConduit Inheritance</h3>

<p>CICM::AbstractSigVerifyConduit inherits from: CICM::AbstractVerifyConduit.
</p>
<a name="anchor44"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.5.2"></a><h3>5.5.2.&nbsp;
CICM::AbstractSigVerifyConduit Attributes</h3>

<p>AttributeCICM::AbstractSigVerifyConduit::verify_key
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>readonly attribute CICM::AsymKey verify_key;</pre></div>
<p>Key used to verify the signature.
</p>
<p>AttributeCICM::AbstractSigVerifyConduit::verify_algorithm
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>readonly attribute CICM::AsymSigAlgorithmId verify_algorithm;</pre></div>
<p>Algorithm used to verify the data.
</p>
<a name="anchor45"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.5.3"></a><h3>5.5.3.&nbsp;
CICM::AbstractSigVerifyConduit Methods</h3>

<p>Method CICM::AbstractSigVerifyConduit::end_get_verified()
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>CICM::Status end_get_verified(
	in  CICM::SigBuffer signature,
	out CICM::AbstractVerifyConduit::VerifyStatus status
);</pre></div>
<p>Direct the module to compute and output the verification
						status, and reset the channel to accept additional data for
						verification.
</p>
<p>Parameters:
							</p>
<blockquote class="text">
<p>[in] signature Signature.
</p>
<p>[out] status Status indicating whether or not the data
								  verifies.
</p>
</blockquote><p>
						
</p>
<p>Returns:
							</p>
<blockquote class="text">
<p>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR,
							  S_CHANNEL_PEER_RESET, S_CHANNEL_DATA_INVALID,
							  S_CHANNEL_DATA_INVALID_LEN
</p>
</blockquote><p>
						
</p>
<a name="anchor46"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6"></a><h3>6.&nbsp;
Stream Abstractions</h3>

<a name="anchor47"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.1"></a><h3>6.1.&nbsp;
Interface CICM::WriteStream</h3>

<p>Interface CICM::WriteStream
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>interface WriteStream : CICM::Stream {</pre></div>
<p>Interface from which other streams that write data to the
					module inherit.
</p>
<a name="anchor48"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.1.1"></a><h3>6.1.1.&nbsp;
CICM::WriteStream Inheritance</h3>

<p>CICM::WriteStream inherits from: CICM::Stream.
</p>
<a name="anchor49"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.1.2"></a><h3>6.1.2.&nbsp;
CICM::WriteStream Types and Constants</h3>

<p>Type CICM::WriteStream::WriteStatus
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>typedef CICM::UInt32 WriteStatus;</pre></div>
<p>Status of an non-blocking write.
</p>
<p>Constant   CICM::WriteStream::C_WRITE_NOT_READY
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>const CICM::WriteStream::WriteStatus
	C_WRITE_NOT_READY = 0x00006067;</pre></div>
<p>Module is not ready to receive data for writing.
</p>
<p>Constant   CICM::WriteStream::C_WRITE_READY
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>const CICM::WriteStream::WriteStatus
	C_WRITE_READY = 0x00006068;</pre></div>
<p>Module is ready to receive data for writing.
</p>
<a name="anchor50"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.2"></a><h3>6.2.&nbsp;
Interface CICM::ReadStream</h3>

<p>Interface CICM::ReadStream
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>interface ReadStream : CICM::Stream {</pre></div>
<p>Interface from which all other streams that read data from
					the module inherit.
</p>
<a name="anchor51"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.2.1"></a><h3>6.2.1.&nbsp;
CICM::ReadStream Inheritance</h3>

<p>CICM::ReadStream inherits from: CICM::Stream.
</p>
<a name="anchor52"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.2.2"></a><h3>6.2.2.&nbsp;
CICM::ReadStream Types and Constants</h3>

<p>Type CICM::ReadStream::ReadStatus
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>typedef CICM::UInt32 ReadStatus;</pre></div>
<p>Status of a non-blocking read.
</p>
<p>Constant   CICM::ReadStream::C_READ_NOT_READY
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>const CICM::ReadStream::ReadStatus
	C_READ_NOT_READY = 0x0000605E;</pre></div>
<p>Module does not have data ready for reading.
</p>
<p>Constant   CICM::ReadStream::C_READ_READY
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>const CICM::ReadStream::ReadStatus
	C_READ_READY = 0x00006061;</pre></div>
<p>Module has data ready for reading.
</p>
<a name="anchor53"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7"></a><h3>7.&nbsp;
Controller Abstractions</h3>

<a name="anchor54"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.1"></a><h3>7.1.&nbsp;
Interface CICM::MultiDomainController</h3>

<p>Interface CICM::MultiDomainController
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>interface MultiDomainController : CICM::Controller {</pre></div>
<p>Interface from which any other multi-domain-related
					controller or conduit inherits.
</p>
<p>Remarks:
						</p>
<blockquote class="text">
<p>Provides read access to the local and remote port values
						  associated with the controller.
</p>
</blockquote><p>
					
</p>
<a name="anchor55"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.1.1"></a><h3>7.1.1.&nbsp;
CICM::MultiDomainController Inheritance</h3>

<p>CICM::MultiDomainController inherits from: CICM::Controller.
</p>
<a name="anchor56"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.1.2"></a><h3>7.1.2.&nbsp;
CICM::MultiDomainController Attributes</h3>

<p>AttributeCICM::MultiDomainController::local_port
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>readonly attribute CICM::LocalPort local_port;</pre></div>
<p>Local port associated with this controller.
</p>
<p>AttributeCICM::MultiDomainController::remote_port
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>readonly attribute CICM::RemotePort remote_port;</pre></div>
<p>Remote port associated with this controller.
</p>
<a name="anchor57"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.2"></a><h3>7.2.&nbsp;
Interface CICM::SymKeyController</h3>

<p>Interface CICM::SymKeyController
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>interface SymKeyController : CICM::Controller {</pre></div>
<p>Interface from which all controllers using a symmetric key
					inherit.
</p>
<a name="anchor58"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.2.1"></a><h3>7.2.1.&nbsp;
CICM::SymKeyController Inheritance</h3>

<p>CICM::SymKeyController inherits from: CICM::Controller.
</p>
<a name="anchor59"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.2.2"></a><h3>7.2.2.&nbsp;
CICM::SymKeyController Attributes</h3>

<p>Attribute CICM::SymKeyController::key
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>readonly attribute CICM::SymKey key;</pre></div>
<p>The key associated with this controller.
</p>
<a name="anchor60"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.2.3"></a><h3>7.2.3.&nbsp;
CICM::SymKeyController Methods</h3>

<p>Method CICM::SymKeyController::update_key()
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>CICM::Status update_key();</pre></div>
<p>Cryptographically update the key associated with this
						controller using the key's native algorithm.
</p>
<p>Remarks:
							</p>
<blockquote class="text">
<p>To update an arbitrary key, use CICM::SymKey::update.
</p>
</blockquote><p>
						
</p>
<p>Returns:
							</p>
<blockquote class="text">
<p>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR,
							  S_CHANNEL_PEER_RESET
</p>
</blockquote><p>
						
</p>
<p>See also:
							</p>
<blockquote class="text">
<p>CICM::SymKey::update_key_with_algo for the version of this
							method that accepts an algorithm.
</p>
</blockquote><p>
						
</p>
<p>Method CICM::SymKeyController::update_key_with_algo()
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>CICM::Status update_key_with_algo(
	in  CICM::SymEncrAlgorithmId algorithm
);</pre></div>
<p>Cryptographically update the key associated with this
						controller using the specified algorithm.
</p>
<p>Remarks:
							</p>
<blockquote class="text">
<p>To update an arbitrary key, use CICM::SymKey::update.
</p>
</blockquote><p>
						
</p>
<p>Parameters:
							</p>
<blockquote class="text">
<p>[in] algorithm Cryptographic algorithm/mode to use to effect the key
								  update.
</p>
</blockquote><p>
						
</p>
<p>Returns:
							</p>
<blockquote class="text">
<p>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_ALGO_INVALID,
							  S_ALGO_INCOMPATIBLE, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR,
							  S_CHANNEL_PEER_RESET
</p>
</blockquote><p>
						
</p>
<p>See also:
							</p>
<blockquote class="text">
<p>CICM::SymKey::update_key for the version of this method
							that does not require an algorithm to be specified.
</p>
</blockquote><p>
						
</p>
<p>Method CICM::SymKeyController::rollover_key()
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>CICM::Status rollover_key();</pre></div>
<p>Specify that the next pre-placed key be used with this
						controller.
</p>
<p>Remarks:
							</p>
<blockquote class="text">
<p>A call to this method may be required when a key reaches
							the end of its specified or usable lifespan or for other
							reasons that require that a controller move to a new key.
</p>
</blockquote><p>
						
</p>
<p>Returns:
							</p>
<blockquote class="text">
<p>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_NO_NEXT,
							  S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT,
							  S_CHANNEL_ERROR, S_CHANNEL_PEER_RESET
</p>
</blockquote><p>
						
</p>
<p>See also:
							</p>
<blockquote class="text">
<p>CICM::SymKey::rollover_key_with_key for the version of this
							method that accepts a key.
</p>
</blockquote><p>
						
</p>
<p>Method CICM::SymKeyController::rollover_key_with_key()
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>CICM::Status rollover_key_with_key(
	in  CICM::SymKey next_key
);</pre></div>
<p>Specify the next pre-placed key to be used with this
						controller.
</p>
<p>Remarks:
							</p>
<blockquote class="text">
<p>A call to this method may be required when a key reaches
							the end of its specified or usable lifespan or for other
							reasons that require that a controller move to a new key.
</p>
</blockquote><p>
						
</p>
<p>Parameters:
							</p>
<blockquote class="text">
<p>[in] next_key Reference to pre-placed key to use with this
								  controller.
</p>
</blockquote><p>
						
</p>
<p>Returns:
							</p>
<blockquote class="text">
<p>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_USED_INVALID,
							  S_KEY_USED_EXPIRED, S_KEY_USED_CLASSIFICATION,
							  S_KEY_USED_WRAPPED, S_KEY_USED_CONTEXT, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR,
							  S_CHANNEL_PEER_RESET
</p>
</blockquote><p>
						
</p>
<p>See also:
							</p>
<blockquote class="text">
<p>CICM::SymKey::rollover_key for the version of this method for which the key is implicit.
</p>
</blockquote><p>
						
</p>
<a name="anchor61"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.3"></a><h3>7.3.&nbsp;
Interface CICM::AsymKeyController</h3>

<p>Interface CICM::AsymKeyController
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>interface AsymKeyController : CICM::Controller {</pre></div>
<p>Interface from which all controllers using an asymmetric key
					inherit.
</p>
<a name="anchor62"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.3.1"></a><h3>7.3.1.&nbsp;
CICM::AsymKeyController Inheritance</h3>

<p>CICM::AsymKeyController inherits from: CICM::Controller.
</p>
<a name="anchor63"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.3.2"></a><h3>7.3.2.&nbsp;
CICM::AsymKeyController Attributes</h3>

<p>AttributeCICM::AsymKeyController::key
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>readonly attribute CICM::AsymKey key;</pre></div>
<p>Provides read-only access to the key associated with a
						controller.
</p>
<a name="anchor64"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.4"></a><h3>7.4.&nbsp;
Interface CICM::NegotiatedController</h3>

<p>Interface CICM::NegotiatedController
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>interface NegotiatedController :
	CICM::MultiDomainController,
	CICM::AsymKeyController,
	CICM::Negotiator {</pre></div>
<p>Interface from which all other negotiated controllers inherit.
						A controller that uses a negotiated key.
</p>
<a name="anchor65"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.4.1"></a><h3>7.4.1.&nbsp;
CICM::NegotiatedController Inheritance</h3>

<p>CICM::NegotiatedController inherits from:
							CICM::MultiDomainController, CICM::AsymKeyController and
							CICM::Negotiator.
</p>
<a name="anchor66"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.4.2"></a><h3>7.4.2.&nbsp;
CICM::NegotiatedController Attributes</h3>

<p>AttributeCICM::NegotiatedController::negotiated_grade
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>readonly attribute CICM::Classification negotiated_grade;</pre></div>
<p>Returns the grade (classification level) of the channel.
</p>
<a name="anchor67"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.4.3"></a><h3>7.4.3.&nbsp;
CICM::NegotiatedController Methods</h3>

<p>Method CICM::NegotiatedController::renegotiate()
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>CICM::Status renegotiate();</pre></div>
<p>Renegotiates the traffic encryption key with the associated
						peer.
</p>
<p>Remarks:
							</p>
<blockquote class="text">
<p>In cases where the key is no longer usable, e.g. it expired
							or was zeroized, the session MUST be torn down and rebuilt.
							Note that renegotiation MAY NOT need to be explicitly initiated
							in all cases because some modules will automatically initiate a
							renegotiation when sensing a certain condition (e.g., key
							expiration, cumulative traffic volume threshold passed,
							etc.).
</p>
</blockquote><p>
						
</p>
<p>Returns:
							</p>
<blockquote class="text">
<p>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_NEGOTIATION_ABORTED,
							  S_NEGOTIATION_FAILURE, S_NEGOTIATION_IN_PROGRESS,
							  S_NEGOTIATION_TIMEOUT, S_CERT_LOCAL_INVALID,
							  S_CERT_LOCAL_EXPIRED, S_CERT_REMOTE_INVALID,
							  S_CERT_REMOTE_EXPIRED, S_CERT_REMOTE_PATH,
							  S_CHANNEL_ERROR
</p>
</blockquote><p>
						
</p>
<p>Method CICM::NegotiatedController::initiate_grade_change()
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>CICM::Status initiate_grade_change(
	in  CICM::Classification new_grade
);</pre></div>
<p>Requests a change of grade (classification level) for the
						current traffic.
</p>
<p>Parameters:
							</p>
<blockquote class="text">
<p>[in] new_grade
								  New grade for the traffic.
</p>
</blockquote><p>
						
</p>
<p>Returns:
							</p>
<blockquote class="text">
<p>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_NEGOTIATION_ABORTED,
							  S_NEGOTIATION_FAILURE, S_NEGOTIATION_IN_PROGRESS,
							  S_NEGOTIATION_TIMEOUT, S_CERT_LOCAL_INVALID,
							  S_CERT_LOCAL_EXPIRED, S_CERT_REMOTE_INVALID,
							  S_CERT_REMOTE_EXPIRED, S_CERT_REMOTE_PATH, S_CHANNEL_ERROR,
							  S_CHANNEL_PEER_RESET
</p>
</blockquote><p>
						
</p>
<p>Method CICM::NegotiatedController::acknowledge_grade_change()
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>CICM::Status acknowledge_grade_change();</pre></div>
<p>Positively acknowledges the requested change of grade.
</p>
<p>Returns:
							</p>
<blockquote class="text">
<p>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_NEGOTIATION_ABORTED,
							  S_NEGOTIATION_FAILURE, S_NEGOTIATION_IN_PROGRESS,
							  S_NEGOTIATION_TIMEOUT, S_CERT_LOCAL_INVALID,
							  S_CERT_LOCAL_EXPIRED, S_CERT_REMOTE_INVALID,
							  S_CERT_REMOTE_EXPIRED, S_CERT_REMOTE_PATH, S_CHANNEL_ERROR,
							  S_CHANNEL_PEER_RESET
</p>
</blockquote><p>
						
</p>
<a name="anchor68"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.5"></a><h3>7.5.&nbsp;
Interface CICM::SetVectorController</h3>

<p>Interface CICM::SetVectorController
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>interface SetVectorController : CICM::Controller {</pre></div>
<p>Provides access to the state vector associated with a
					controller.
</p>
<a name="anchor69"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.5.1"></a><h3>7.5.1.&nbsp;
CICM::SetVectorController Inheritance</h3>

<p>CICM::SetVectorController inherits from: CICM::Controller.
</p>
<a name="anchor70"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.5.2"></a><h3>7.5.2.&nbsp;
CICM::SetVectorController Attributes</h3>

<p>AttributeCICM::SetVectorController::vec
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>readonly attribute CICM::Vector vec;</pre></div>
<p>State vector associated with this controller.
</p>
<a name="anchor71"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.5.3"></a><h3>7.5.3.&nbsp;
CICM::SetVectorController Methods</h3>

<p>Method CICM::SetVectorController::set_vector()
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>CICM::Status set_vector(
	in  CICM::Vector vec
);</pre></div>
<p>Set channel state vector.
</p>
<p>Remarks:
							</p>
<blockquote class="text">
<p>This state value may be set when a controller is initially
							created (initialization vector). It may also be set on a
							block-by-block basis for appropriate algorithms/modes or for
							each time epoch (e.g., for time-of-day encryption).
</p>
</blockquote><p>
						
</p>
<p>Parameters:
							</p>
<blockquote class="text">
<p>[in] vec State vector.
</p>
</blockquote><p>
						
</p>
<p>Returns:
							</p>
<blockquote class="text">
<p>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_INVALID_VECTOR,
							  S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT
</p>
</blockquote><p>
						
</p>
<p>Method CICM::SetVectorController::set_vector_no_check()
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>CICM::Status set_vector_no_check(
	in  CICM::Vector vec
);</pre></div>
<p>Set channel state vector without a policy check.
</p>
<p>Remarks:
							</p>
<blockquote class="text">
<p>This state value may be set when a controller is initially
							created (initialization vector) or on a per-message basis,
							depending upon how the cryptographic algorithm uses the vector.
							The length and format of the vector are specific to the
							algorithm associated with the channel and system in which the
							channel is being used.
</p>
<p>This version of the set_vector() method may be used on the
							decrypt side, for example, to specify no TOD check in cases
							where TOD rules are not enforced for decryption.
</p>
</blockquote><p>
						
</p>
<p>Parameters:
							</p>
<blockquote class="text">
<p>[in] vec State vector.
</p>
</blockquote><p>
						
</p>
<p>Returns:
							</p>
<blockquote class="text">
<p>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_INVALID_VECTOR,
							  S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT
</p>
</blockquote><p>
						
</p>
<p>Method CICM::SetVectorController::reset_vector()
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>CICM::Status reset_vector();</pre></div>
<p>Reset channel state vector to system-dependent value.
</p>
<p>Remarks:
							</p>
<blockquote class="text">
<p>This can be used by the client program to manage
							time-of-day or counter rollover.
</p>
</blockquote><p>
						
</p>
<p>Returns:
							</p>
<blockquote class="text">
<p>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT
</p>
</blockquote><p>
						
</p>
<a name="anchor72"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.6"></a><h3>7.6.&nbsp;
Interface CICM::GenVectorController</h3>

<p>Interface CICM::GenVectorController
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>interface GenVectorController : CICM::SetVectorController {</pre></div>
<p>Enables an state vector to be generated.
</p>
<a name="anchor73"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.6.1"></a><h3>7.6.1.&nbsp;
CICM::GenVectorController Inheritance</h3>

<p>CICM::GenVectorController inherits from: CICM::SetVectorController.
</p>
<a name="anchor74"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.6.2"></a><h3>7.6.2.&nbsp;
CICM::GenVectorController Methods</h3>

<p>Method CICM::GenVectorController::generate_vector()
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>CICM::Status generate_vector();</pre></div>
<p>Generate a vector for this controller utilizing new random
						state.
</p>
<p>Remarks:
							</p>
<blockquote class="text">
<p>It may not be necessary for a client program to explicitly
							generate a vector. Some cryptographic modules will implicitly
							generate an IV, for example, as a byproduct of channel
							creation. In other cases, an existing vector will be associated
							with a controller by calling the
							CICM::SetVectorController::set_vector method.
</p>
</blockquote><p>
						
</p>
<p>Returns:
							</p>
<blockquote class="text">
<p>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_INSUFFICIENT_ENTROPY
</p>
</blockquote><p>
						
</p>
<p>Method CICM::GenVectorController::generate_vector_existing_state()
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>CICM::Status generate_vector_existing_state();</pre></div>
<p>Generate a vector for this controller utilizing the latest
						unused state.
</p>
<p>Remarks:
							</p>
<blockquote class="text">
<p>It may not be necessary for a client program to explicitly
							generate a vector. Some cryptographic modules will implicitly
							generate an IV, for example, as a byproduct of channel
							creation. In other cases, an existing vector will be associated
							with a controller by calling the
							CICM::SetVectorController::set_vector method.
</p>
</blockquote><p>
						
</p>
<p>Returns:
							</p>
<blockquote class="text">
<p>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_INSUFFICIENT_ENTROPY
</p>
</blockquote><p>
						
</p>
<a name="anchor75"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.7"></a><h3>7.7.&nbsp;
Interface CICM::ResyncController</h3>

<p>Interface CICM::ResyncController
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>interface ResyncController : CICM::Controller {</pre></div>
<p>Provides methods to resynchronize a controller or conduit.
</p>
<a name="anchor76"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.7.1"></a><h3>7.7.1.&nbsp;
CICM::ResyncController Inheritance</h3>

<p>CICM::ResyncController inherits from: CICM::Controller.
</p>
<a name="anchor77"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.7.2"></a><h3>7.7.2.&nbsp;
CICM::ResyncController Methods</h3>

<p>Method CICM::ResyncController::resync()
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>CICM::Status resync();</pre></div>
<p>Resynchronize the channel.
</p>
<p>Remarks:
							</p>
<blockquote class="text">
<p>A client program-initiated resync is required when the host
							is responsible for ensuring cryptographic synchronization is
							maintained because the operating mode used does not enable the
							module to determine that it is out of sync. The action taken by
							the module as the result of a call to this method will differ
							based upon characteristics of the cryptographic algorithm,
							communications path framing, and details of the protocol used
							to achieve cryptographic synchronization between two
							modules.
</p>
</blockquote><p>
						
</p>
<p>Returns:
							</p>
<blockquote class="text">
<p>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR,
							  S_CHANNEL_PEER_RESET
</p>
</blockquote><p>
						
</p>
<p>See also:
							</p>
<blockquote class="text">
<p>CICM::ResyncController::resync_with_sync_vector for the
							version of this method that accepts a synchronization
							vector.
</p>
</blockquote><p>
						
</p>
<p>Method CICM::ResyncController::resync_with_sync_vector()
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>CICM::Status resync_with_sync_vector(
	in  CICM::Vector vec
);</pre></div>
<p>Resynchronize the channel, using the specified
						synchronization vector (required by certain operating modes to
						initiate a resync).
</p>
<p>Remarks:
							</p>
<blockquote class="text">
<p>A client program-initiated resync is required when the host
							is responsible for ensuring cryptographic synchronization is
							maintained because the operating mode used does not enable the
							module to determine that it is out of sync. The action taken by
							the module as the result of a call to this method will differ
							based upon characteristics of the cryptographic algorithm,
							communications path framing, and details of the protocol used
							to achieve cryptographic synchronization among modules.
</p>
</blockquote><p>
						
</p>
<p>Parameters:
							</p>
<blockquote class="text">
<p>[in] vec Synchronization vector to use to resynchronize the
								  channel.
</p>
</blockquote><p>
						
</p>
<p>Returns:
							</p>
<blockquote class="text">
<p>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_INVALID_VECTOR,
							  S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT,
							  S_CHANNEL_ERROR, S_CHANNEL_PEER_RESET
</p>
</blockquote><p>
						
</p>
<p>See also:
							</p>
<blockquote class="text">
<p>CICM::ResyncController::resync for the version of this
							method that does not require a synchronization vector.
</p>
</blockquote><p>
						
</p>
<a name="sec_channel_negotiation"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.8"></a><h3>8.&nbsp;
Channel Negotiation</h3>

<a name="anchor78"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.8.1"></a><h3>8.1.&nbsp;
Negotiating Channels and Controllers</h3>

<p>When creating an
					encryption or decryption channel using an asymmetric keyset, a
					negotiation process must be initiated between the two communicating
					entities, resulting in an ephemeral symmetric key held by each
					entity. The following details the steps in the negotiation process:
					</p>
<ol class="text">
<li>Retrieve a negotiator. The client program uses the
					  CICM::ChannelManager to create the appropriate CICM::Negotiator,
					  thus initiating the negotiation.
</li>
<li>Validate remote peer. Most systems will use a trust anchor to
					  validate that the remote peer is legitimate and will further
					  verify the peer appears on the appropriate access control
					  list(s). In some cases, the above validation will be sufficient.
					  In others, it will be necessary to display information about the
					  remote peer to a human user to receive a positive response from
					  the user that the displayed peer is the expected peer. This
					  validation procedure differs depending upon the display
					  configuration:
					  
<ul class="text">
<li>If the system is configured with a trusted display,
						information about the remote peer is displayed to the trusted
						display and the user is solicited for a response which is
						returned to the module. The trusted display interactions take
						place independent of the API.
</li>
<li>If the system is not configured with a trusted display, the
						client program uses CICM::Negotiator::get_remote_info to
						retrieve information about the remote peer and then displays
						this information to the user (independent of CICM) to allow the
						user to determine if this is the expected remote peer; the
						client program calls CICM::Negotiator::abort_negotiation to
						abort the negotiation if the user rejects the remote peer.
</li>
</ul>
</li>
<li>Complete negotiation. The client program explicitly completes
					  the negotiation using the negotiator's complete() method.
</li>
</ol>

<p>A successful negotation results in a negotiated controller.
</p>
<a name="anchor79"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.8.2"></a><h3>8.2.&nbsp;
Interface CICM::Negotiator</h3>

<p>Interface CICM::Negotiator
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>interface Negotiator {</pre></div>
<p>CICM::Negotiator is an abstraction inherited by controllers
					and CICM::KeyProtocolSender to assist in the management of the
					negotiation process.
</p>
<a name="anchor80"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.8.2.1"></a><h3>8.2.1.&nbsp;
CICM::Negotiator Methods</h3>

<p>Method CICM::Negotiator::get_remote_info()
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>CICM::Status get_remote_info(
	out CICM::PeerInfo peer_info
);</pre></div>
<p>Retrieve remote peer identification information.
               The peer information must be displayed to the
               local user to enable determination to be made as
               to whether negotiation should continue or be aborted.  If
               the decision is made to abort negotiation, the
               CICM::Negotiator::abort_negotiation method MUST be called to
               destroy any protocol session state.
</p>
<p>Parameters:
                </p>
<blockquote class="text">
<p>[out] peer_info
                    Identifying information about the remote peer.
</p>
</blockquote><p>
            
</p>
<p>Returns:
                </p>
<blockquote class="text">
<p>S_OK,  S_GENERAL_ERROR,  S_NON_FUNCTIONAL,
                  S_OPERATION_FAILED,  S_POLICY_VIOLATION,
                  S_MODULE_RESOURCES,  S_HOST_RESOURCES,  S_INVALID_STATE,
                  S_ALARM_STATE,  S_MODULE_NOT_AVAILABLE,  S_TIMEOUT,
                  S_NOT_AUTHENTICATED,  S_NOT_AUTHORIZED,  S_NOT_AVAILABLE,
                  S_TOKEN_NOT_PRESENT,  S_TOKEN_ADMIN_NOT_PRESENT,  S_TRUSTED_DISPLAY,
                  S_NEGOTIATION_ABORTED,  S_NEGOTIATION_FAILURE,
                  S_NEGOTIATION_NOT_IN_PROGRESS,  S_NEGOTIATION_TIMEOUT,
                  S_CERT_LOCAL_INVALID,  S_CERT_LOCAL_EXPIRED,  S_CERT_REMOTE_INVALID,
                  S_CERT_REMOTE_EXPIRED,  S_CERT_REMOTE_PATH,  S_CHANNEL_ERROR,
                  S_CHANNEL_PEER_RESET
</p>
</blockquote><p>
            
</p>
<p>Method CICM::Negotiator::abort_negotiation()
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>CICM::Status abort_negotiation();</pre></div>
<p>Abort negotiation or renegotiation.
               This method must be called in the event the identification
               information for the remote host does not correspond
               to the expected host.
</p>
<p>Returns:
              </p>
<blockquote class="text">
<p>S_OK, S_GENERAL_ERROR, S_NON_FUNCTIONAL, S_OPERATION_FAILED,
                S_POLICY_VIOLATION, S_MODULE_RESOURCES, S_HOST_RESOURCES,
                S_INVALID_STATE, S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
                S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
                S_TOKEN_ADMIN_NOT_PRESENT, S_NEGOTIATION_NOT_IN_PROGRESS,
                S_CHANNEL_ERROR, S_CHANNEL_PEER_RESET
</p>
</blockquote><p>
            
</p>
<a name="anchor81"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.8.3"></a><h3>8.3.&nbsp;
Interface CICM::PeerInfo</h3>

<p>Interface CICM::PeerInfo
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>interface PeerInfo {</pre></div>
<p>Information about a peer entity participating in a key
					negotiation.
</p>
<a name="anchor82"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.8.3.1"></a><h3>8.3.1.&nbsp;
CICM::PeerInfo Attributes</h3>

<p>Attribute CICM::PeerInfo::peer_name
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>readonly attribute CICM::CharString peer_name;</pre></div>
<p>Name/organization of remote entity participating in key
						agreement prototcol.
</p>
<p>AttributeCICM::PeerInfo::classification
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>readonly attribute CICM::Classification classification;</pre></div>
<p>Highest security classification level at which the remote
						entity participating in the key agreement protocol is capable of
						communicating.
</p>
<p>Attribute CICM::PeerInfo::compartment
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>readonly attribute CICM::CharString compartment;</pre></div>
<p>Compartment of remote entity participating in key agreement
						protocol.
</p>
<p>Attribute CICM::PeerInfo::message
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>readonly attribute CICM::CharString message;</pre></div>
<p>Message to be displayed regarding the remote entities'
						participation in key agreement protocol.
</p>
<a name="sec-encrypt"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.9"></a><h3>9.&nbsp;
Encryption</h3>

<p>Namespace CICM::Encrypt
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>module Encrypt {</pre></div>
<p>The CICM::Encrypt namespace contains interfaces that support
				encryption operations between two independent security domains.
</p>
<a name="anchor83"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.9.1"></a><h3>9.1.&nbsp;
Interface CICM::Encrypt::ChannelManager</h3>

<p>Interface  CICM::Encrypt::ChannelManager
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>interface ChannelManager {</pre></div>
<p>CICM::Encrypt::ChannelManager is an abstraction inherited by
					CICM::ChannelManager that supports the creation of encryption
					negotiators, conduits, controllers, and streams. See
					CICM::ChannelManager for additional information.
</p>
<a name="anchor84"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.9.1.1"></a><h3>9.1.1.&nbsp;
CICM::Encrypt::ChannelManager Methods</h3>

<p>Method CICM::Encrypt::ChannelManager::negotiate_encrypt_conduit()
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>CICM::Status negotiate_encrypt_conduit(
	in  CICM::RemotePort remote_port,
	in  CICM::ProtocolId protocol,
	in  CICM::AsymKey key_ref,
	out CICM::Encrypt::Negotiator negotiator_ref
);</pre></div>
<p>Initiate a negotiation to establish a shared key with a peer.
						The channel that results will encrypt a stream of data.
</p>
<p>Parameters:
							</p>
<blockquote class="text">
<p>[in] remote_port
								  Remote port.
</p>
<p>[in] protocol
								  Protocol identifier.
</p>
<p>[in] key_ref
								  Reference to negotiation key.
</p>
<p>[out] negotiator_ref
								  Reference to resulting negotiator.
</p>
</blockquote><p>
						
</p>
<p>Returns:
							</p>
<blockquote class="text">
<p>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_USED_INVALID,
							  S_KEY_USED_EXPIRED, S_KEY_USED_WRAPPED, S_KEY_USED_CONTEXT,
							  S_KEY_USED_COMPONENT_NOT_AVAIL, S_KEY_INVALID, S_KEY_EXPIRED,
							  S_REMOTE_PORT_INVALID, S_REMOTE_PORT_IN_USE,
							  S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT,
							  S_NEGOTIATION_ABORTED, S_NEGOTIATION_FAILURE,
							  S_NEGOTIATION_IN_PROGRESS, S_NEGOTIATION_TIMEOUT,
							  S_CERT_LOCAL_INVALID, S_CERT_LOCAL_EXPIRED,
							  S_CERT_REMOTE_INVALID, S_CERT_REMOTE_EXPIRED,
							  S_CERT_REMOTE_PATH, S_PROTO_INVALID, S_PROTO_INCOMPATIBLE,
							  S_PROTO_UNDETERMINED, S_CHANNEL_ERROR, S_CHANNEL_MAX
</p>
</blockquote><p>
						
</p>
<p>Method CICM::Encrypt::ChannelManager::negotiate_encrypt_with_mac_conduit()
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>CICM::Status negotiate_encrypt_with_mac_conduit(
	in  CICM::RemotePort remote_port,
	in  CICM::ProtocolId protocol,
	in  CICM::SymKey mac_key_ref,
	in  CICM::AsymKey nego_key_ref,
	in  CICM::SymMacAlgorithmId mac_algorithm,
	out CICM::Encrypt::WithMACNegotiator negotiator_ref
);</pre></div>
<p>Initiate a negotiation to establish a shared key with a peer.
						The channel that results will MAC and encrypt a stream of data.
</p>
<p>Remarks:
							</p>
<blockquote class="text">
<p>Negotiation applies only to the negotiation key, not the
							MAC key.
</p>
</blockquote><p>
						
</p>
<p>Parameters:
							</p>
<blockquote class="text">
<p>[in] remote_port
								  Remote port.
</p>
<p>[in] protocol
								  Protocol identifier.
</p>
<p>[in] mac_key_ref
								  Reference to MAC key.
</p>
<p>[in] nego_key_ref
								  Reference to negotiation key.
</p>
<p>[in] mac_algorithm
								  MAC algorithm.
</p>
<p>[out] negotiator_ref
								  Reference to resulting negotiator.
</p>
</blockquote><p>
						
</p>
<p>Returns:
							</p>
<blockquote class="text">
<p>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_USED_INVALID,
							  S_KEY_USED_EXPIRED, S_KEY_USED_WRAPPED, S_KEY_USED_CONTEXT,
							  S_KEY_USED_COMPONENT_NOT_AVAIL, S_KEY_INVALID, S_KEY_EXPIRED,
							  S_REMOTE_PORT_INVALID, S_REMOTE_PORT_IN_USE, S_ALGO_INVALID,
							  S_ALGO_INCOMPATIBLE, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_NEGOTIATION_ABORTED,
							  S_NEGOTIATION_FAILURE, S_NEGOTIATION_IN_PROGRESS,
							  S_NEGOTIATION_TIMEOUT, S_CERT_LOCAL_INVALID,
							  S_CERT_LOCAL_EXPIRED, S_CERT_REMOTE_INVALID,
							  S_CERT_REMOTE_EXPIRED, S_CERT_REMOTE_PATH, S_PROTO_INVALID,
							  S_PROTO_INCOMPATIBLE, S_PROTO_UNDETERMINED, S_CHANNEL_ERROR,
							  S_CHANNEL_MAX
</p>
</blockquote><p>
						
</p>
<p>Method CICM::Encrypt::ChannelManager::negotiate_encrypt_with_sign_conduit()
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>CICM::Status negotiate_encrypt_with_sign_conduit(
	in  CICM::RemotePort remote_port,
	in  CICM::ProtocolId protocol,
	in  CICM::AsymKey sign_key_ref,
	in  CICM::AsymKey nego_key_ref,
	in  CICM::AsymSigAlgorithmId sign_algorithm,
	out CICM::Encrypt::WithSignNegotiator negotiator_ref
);</pre></div>
<p>Initiate a negotiation to establish a shared key with a peer.
						The channel that results will sign and encrypt a stream of
						data.
</p>
<p>Remarks:
							</p>
<blockquote class="text">
<p>Negotiation applies only to the negotiation key, not the
							signature key.
</p>
</blockquote><p>
						
</p>
<p>Parameters:
							</p>
<blockquote class="text">
<p>[in] remote_port
								  Remote port.
</p>
<p>[in] protocol
								  Protocol identifier.
</p>
<p>[in] sign_key_ref
								  Reference to signature key.
</p>
<p>[in] nego_key_ref
								  Reference to negotiation key.
</p>
<p>[in] sign_algorithm
								  Signature algorithm.
</p>
<p>[out] negotiator_ref
								  Reference to resulting negotiator.
</p>
</blockquote><p>
						
</p>
<p>Returns:
							</p>
<blockquote class="text">
<p>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_USED_INVALID,
							  S_KEY_USED_EXPIRED, S_KEY_USED_WRAPPED, S_KEY_USED_CONTEXT,
							  S_KEY_USED_COMPONENT_NOT_AVAIL, S_KEY_INVALID, S_KEY_EXPIRED,
							  S_REMOTE_PORT_INVALID, S_REMOTE_PORT_IN_USE, S_ALGO_INVALID,
							  S_ALGO_INCOMPATIBLE, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_NEGOTIATION_ABORTED,
							  S_NEGOTIATION_FAILURE, S_NEGOTIATION_IN_PROGRESS,
							  S_NEGOTIATION_TIMEOUT, S_CERT_LOCAL_INVALID,
							  S_CERT_LOCAL_EXPIRED, S_CERT_REMOTE_INVALID,
							  S_CERT_REMOTE_EXPIRED, S_CERT_REMOTE_PATH, S_PROTO_INVALID,
							  S_PROTO_INCOMPATIBLE, S_PROTO_UNDETERMINED, S_CHANNEL_ERROR,
							  S_CHANNEL_MAX
</p>
</blockquote><p>
						
</p>
<p>Method CICM::Encrypt::ChannelManager::negotiate_encrypt_controller()
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>CICM::Status negotiate_encrypt_controller(
	in  CICM::LocalPort local_port,
	in  CICM::RemotePort remote_port,
	in  CICM::ProtocolId protocol,
	in  CICM::AsymKey key_ref,
	out CICM::Encrypt::ControllerNegotiator negotiator_ref
);</pre></div>
<p>Initiate a negotiation to establish a shared key with a peer,
						resulting in a controller to manage an encryption channel.
</p>
<p>Parameters:
							</p>
<blockquote class="text">
<p>[in] local_port
								  Local port.
</p>
<p>[in] remote_port
								  Remote port.
</p>
<p>[in] protocol
								  Protocol identifier.
</p>
<p>[in] key_ref
								  Reference to encryption key.
</p>
<p>[out] negotiator_ref
								  Reference to resulting negotiator.
</p>
</blockquote><p>
						
</p>
<p>Returns:
							</p>
<blockquote class="text">
<p>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_USED_INVALID,
							  S_KEY_USED_EXPIRED, S_KEY_USED_WRAPPED, S_KEY_USED_CONTEXT,
							  S_KEY_USED_COMPONENT_NOT_AVAIL, S_KEY_INVALID, S_KEY_EXPIRED,
							  S_LOCAL_PORT_INVALID, S_LOCAL_PORT_INCOMPATIBLE,
							  S_LOCAL_PORT_IN_USE, S_REMOTE_PORT_INVALID,
							  S_REMOTE_PORT_IN_USE, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_NEGOTIATION_ABORTED,
							  S_NEGOTIATION_FAILURE, S_NEGOTIATION_IN_PROGRESS,
							  S_NEGOTIATION_TIMEOUT, S_CERT_LOCAL_INVALID,
							  S_CERT_LOCAL_EXPIRED, S_CERT_REMOTE_INVALID,
							  S_CERT_REMOTE_EXPIRED, S_CERT_REMOTE_PATH, S_PROTO_INVALID,
							  S_PROTO_INCOMPATIBLE, S_PROTO_UNDETERMINED, S_CHANNEL_ERROR,
							  S_CHANNEL_MAX
</p>
</blockquote><p>
						
</p>
<p>Method CICM::Encrypt::ChannelManager::create_encrypt_conduit()
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>CICM::Status create_encrypt_conduit(
	in  CICM::RemotePort remote_port,
	in  CICM::SymKey key_ref,
	in  CICM::SymEncrAlgorithmId algorithm,
	out CICM::Encrypt::Conduit conduit_ref
);</pre></div>
<p>Create conduit to encrypt a stream of data.
</p>
<p>Parameters:
							</p>
<blockquote class="text">
<p>[in] remote_port
								  Remote port.
</p>
<p>[in] key_ref
								  Reference to encryption key.
</p>
<p>[in] algorithm
								  Encryption algorithm/mode.
</p>
<p>[out] conduit_ref
								  Reference to resulting conduit.
</p>
</blockquote><p>
						
</p>
<p>Returns:
							</p>
<blockquote class="text">
<p>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_USED_INVALID,
							  S_KEY_USED_EXPIRED, S_KEY_USED_WRAPPED, S_KEY_USED_CONTEXT,
							  S_KEY_INVALID, S_KEY_EXPIRED, S_REMOTE_PORT_INVALID,
							  S_REMOTE_PORT_IN_USE, S_ALGO_INVALID, S_ALGO_INCOMPATIBLE,
							  S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT,
							  S_CHANNEL_ERROR, S_CHANNEL_MAX
</p>
</blockquote><p>
						
</p>
<p>Method CICM::Encrypt::ChannelManager::create_encrypt_with_mac_conduit()
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>CICM::Status create_encrypt_with_mac_conduit(
	in  CICM::RemotePort remote_port,
	in  CICM::SymKey mac_key_ref,
	in  CICM::SymKey encrypt_key_ref,
	in  CICM::SymMacAlgorithmId mac_algorithm,
	in  CICM::SymEncrAlgorithmId encr_algorithm,
	out CICM::Encrypt::WithMACConduit conduit_ref
);</pre></div>
<p>Create conduit to MAC and encrypt a stream of data.
</p>
<p>Parameters:
							</p>
<blockquote class="text">
<p>[in] remote_port
								  Remote port.
</p>
<p>[in] mac_key_ref
								  Reference to MAC key.
</p>
<p>[in] encrypt_key_ref
								  Reference to encryption key.
</p>
<p>[in] mac_algorithm
								  MAC algorithm.
</p>
<p>[in] encr_algorithm
								  Encryption algorithm/mode.
</p>
<p>[out] conduit_ref
								  Reference to resulting conduit.
</p>
</blockquote><p>
						
</p>
<p>Returns:
							</p>
<blockquote class="text">
<p>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_USED_INVALID,
							  S_KEY_USED_EXPIRED, S_KEY_USED_WRAPPED, S_KEY_USED_CONTEXT,
							  S_KEY_INVALID, S_KEY_EXPIRED, S_REMOTE_PORT_INVALID,
							  S_REMOTE_PORT_IN_USE, S_ALGO_INVALID, S_ALGO_INCOMPATIBLE,
							  S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT,
							  S_CHANNEL_ERROR, S_CHANNEL_MAX
</p>
</blockquote><p>
						
</p>
<p>Method CICM::Encrypt::ChannelManager::create_encrypt_with_sign_conduit()
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>CICM::Status create_encrypt_with_sign_conduit(
	in  CICM::RemotePort remote_port,
	in  CICM::AsymKey sign_key_ref,
	in  CICM::SymKey encrypt_key_ref,
	in  CICM::AsymSigAlgorithmId sign_algorithm,
	in  CICM::SymEncrAlgorithmId encr_algorithm,
	out CICM::Encrypt::WithSignConduit conduit_ref
);</pre></div>
<p>Create conduit to sign and encrypt a stream of data.
</p>
<p>Parameters:
							</p>
<blockquote class="text">
<p>[in] remote_port
								  Remote port.
</p>
<p>[in] sign_key_ref
								  Reference to signature key.
</p>
<p>[in] encrypt_key_ref
								  Reference to encryption key.
</p>
<p>[in] sign_algorithm
								  Signature algorithm.
</p>
<p>[in] encr_algorithm
								  Encryption algorithm/mode.
</p>
<p>[out] conduit_ref
								  Reference to resulting conduit.
</p>
</blockquote><p>
						
</p>
<p>Returns:
							</p>
<blockquote class="text">
<p>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_USED_INVALID,
							  S_KEY_USED_EXPIRED, S_KEY_USED_WRAPPED, S_KEY_USED_CONTEXT,
							  S_KEY_USED_COMPONENT_NOT_AVAIL, S_KEY_INVALID, S_KEY_EXPIRED,
							  S_REMOTE_PORT_INVALID, S_REMOTE_PORT_IN_USE, S_ALGO_INVALID,
							  S_ALGO_INCOMPATIBLE, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR,
							  S_CHANNEL_MAX
</p>
</blockquote><p>
						
</p>
<p>Method CICM::Encrypt::ChannelManager::create_key_wrap_conduit()
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>CICM::Status create_key_wrap_conduit(
	in  CICM::RemotePort remote_port,
	in  CICM::SymKey kek_ref,
	in  CICM::KeyWrapAlgorithmId algorithm,
	out CICM::Encrypt::KeyWrapConduit conduit_ref
);</pre></div>
<p>Create conduit to wrap a key.
</p>
<p>Remarks:
							</p>
<blockquote class="text">
<p>This type of conduit may be used to wrap key material bound
							for a peer cryptographic module. To wrap individual keys
							already in the module, use CICM::Symkey::wrap or
							CICM::Asymkey::wrap.
</p>
</blockquote><p>
						
</p>
<p>Parameters:
							</p>
<blockquote class="text">
<p>[in] remote_port
								  Remote port.
</p>
<p>[in] kek_ref
								  Reference to key encryption key.
</p>
<p>[in] algorithm
								  Key wrapping algorithm/mode.
</p>
<p>[out] conduit_ref
								  Reference to resulting conduit.
</p>
</blockquote><p>
						
</p>
<p>Returns:
							</p>
<blockquote class="text">
<p>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_USED_INVALID,
							  S_KEY_USED_EXPIRED, S_KEY_USED_WRAPPED, S_KEY_USED_CONTEXT,
							  S_KEY_INVALID, S_KEY_EXPIRED, S_REMOTE_PORT_INVALID,
							  S_REMOTE_PORT_IN_USE, S_ALGO_INVALID, S_ALGO_INCOMPATIBLE,
							  S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT,
							  S_CHANNEL_ERROR, S_CHANNEL_MAX
</p>
</blockquote><p>
						
</p>
<p>Method CICM::Encrypt::ChannelManager::create_encrypt_controller()
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>CICM::Status create_encrypt_controller(
	in  CICM::LocalPort local_port,
	in  CICM::RemotePort remote_port,
	in  CICM::SymKey key_ref,
	in  CICM::SymEncrAlgorithmId algorithm,
	out CICM::Encrypt::Controller controller_ref
);</pre></div>
<p>Create controller to configure and control an encryption
						channel.
</p>
<p>Remarks:
							</p>
<blockquote class="text">
<p>In some cases, hosts may depend upon separate processes to
							control and use a channel. This method returns the channel
							controller and MUST be called before the corresponding stream
							is retrieved.
</p>
</blockquote><p>
						
</p>
<p>Parameters:
							</p>
<blockquote class="text">
<p>[in] local_port
								  Local port.
</p>
<p>[in] remote_port
								  Remote port.
</p>
<p>[in] key_ref
								  Reference to encryption key.
</p>
<p>[in] algorithm
								  Encryption algorithm/mode.
</p>
<p>[out] controller_ref
								  Reference to resulting controller.
</p>
</blockquote><p>
						
</p>
<p>Returns:
							</p>
<blockquote class="text">
<p>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_INVALID,
							  S_KEY_EXPIRED, S_LOCAL_PORT_INVALID,
							  S_LOCAL_PORT_INCOMPATIBLE, S_LOCAL_PORT_IN_USE,
							  S_REMOTE_PORT_INVALID, S_REMOTE_PORT_IN_USE, S_ALGO_INVALID,
							  S_ALGO_INCOMPATIBLE, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR,
							  S_CHANNEL_MAX
</p>
</blockquote><p>
						
</p>
<p>Method CICM::Encrypt::ChannelManager::get_encrypt_stream()
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>CICM::Status get_encrypt_stream(
	in  CICM::LocalPort local_port,
	out CICM::Encrypt::Stream stream_ref
);</pre></div>
<p>Create stream associated with previously created controller
						to accept data for transformation.
</p>
<p>Parameters:
							</p>
<blockquote class="text">
<p>[in] local_port
								  Local port.
</p>
<p>[out] stream_ref
								  Reference to resulting stream.
</p>
</blockquote><p>
						
</p>
<p>Returns:
							</p>
<blockquote class="text">
<p>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_INVALID,
							  S_KEY_EXPIRED, S_LOCAL_PORT_INVALID,
							  S_LOCAL_PORT_INCOMPATIBLE, S_LOCAL_PORT_IN_USE,
							  S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT,
							  S_CHANNEL_ERROR, S_CHANNEL_PEER_RESET,
							  S_CHANNEL_NOT_FOUND
</p>
</blockquote><p>
						
</p>
<a name="anchor85"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.9.2"></a><h3>9.2.&nbsp;
Interface CICM::Encrypt::Stream</h3>

<p>Interface CICM::Encrypt::Stream
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>interface Stream : CICM::WriteStream {</pre></div>
<p>CICM::Encrypt::Stream supports encryption operations between
					two independent security domains. The resulting stream is capable
					of accepting data for transformation, but not managing the channel.
					It is created by calling CICM::ChannelManager::get_encrypt_stream.
</p>
<a name="anchor86"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.9.2.1"></a><h3>9.2.1.&nbsp;
CICM::Encrypt::Stream Inheritance</h3>

<p>CICM::Encrypt::Stream inherits from: CICM::WriteStream.
</p>
<a name="anchor87"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.9.2.2"></a><h3>9.2.2.&nbsp;
CICM::Encrypt::Stream Methods</h3>

<p>Method CICM::Encrypt::Stream::encrypt()
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>CICM::Status encrypt(
	in  CICM::Buffer buffer
);</pre></div>
<p>Sends data to the module to be encrypted. The method blocks
						until data is sent.
</p>
<p>Parameters:
							</p>
<blockquote class="text">
<p>[in] buffer
								  Plaintext to encrypt.
</p>
</blockquote><p>
						
</p>
<p>Returns:
							</p>
<blockquote class="text">
<p>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_INVALID,
							  S_KEY_EXPIRED, S_KEY_WRAPPED, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR,
							  S_CHANNEL_PEER_RESET, S_CHANNEL_IO_ERROR,
							  S_CHANNEL_DATA_INVALID, S_CHANNEL_DATA_INVALID_LEN
</p>
</blockquote><p>
						
</p>
<p>Method CICM::Encrypt::Stream::encrypt_non_blocking()
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>CICM::Status encrypt_non_blocking(
	in  CICM::Buffer buffer,
	in  CICM::TransId transaction_id
);</pre></div>
<p>Registers a buffer of data to be sent to the module for
						encryption and then immediately returns control to the caller. The
						length of the data is encapsulated in the buffer parameter. The
						caller may use the CICM::Encrypt::Stream::encrypt_poll method to
						proactively poll the channel to determine the status of the
						operation. The caller is responsible for maintaining any necessary
						metadata associated with the transaction_id parameter. Memory
						responsibilities and calling conventions MUST follow the
						appropriate IDL language mapping conventions.
</p>
<p>Parameters:
							</p>
<blockquote class="text">
<p>[in] buffer
								  Plaintext to encrypt.
</p>
<p>[in] transaction_id
								  Unique transaction id that will be used by the
								  CICM::Encrypt::Stream::encrypt_poll method to determine
								  to which buffer the poll status applies.
</p>
</blockquote><p>
						
</p>
<p>Returns:
							</p>
<blockquote class="text">
<p>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_INVALID,
							  S_KEY_EXPIRED, S_KEY_WRAPPED, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR,
							  S_CHANNEL_PEER_RESET, S_CHANNEL_IO_ERROR,
							  S_CHANNEL_DATA_INVALID, S_CHANNEL_DATA_INVALID_LEN
</p>
</blockquote><p>
						
</p>
<p>Method CICM::Encrypt::Stream::encrypt_poll()
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>CICM::Status encrypt_poll(
	in  CICM::TransId transaction_id,
	out CICM::WriteStream::WriteStatus status
);</pre></div>
<p>Returns the status of the non-blocking encryption operation
						specified by the transaction_id parameter. Memory responsibilities
						and calling conventions shall follow the appropriate IDL language
						mapping conventions.
</p>
<p>Parameters:
							</p>
<blockquote class="text">
<p>[in] transaction_id
								  Unique transaction id previously specified to the
								  CICM::Encrypt::Stream::encrypt_non_blocking method that
								  allows the poll operation to determine to which buffer
								  the poll status applies.
</p>
<p>[out] status
								  Status of the non-blocking operation corresponding to
								  the transaction_id parameter.
</p>
</blockquote><p>
						
</p>
<p>Returns:
							</p>
<blockquote class="text">
<p>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_INVALID,
							  S_KEY_EXPIRED, S_KEY_WRAPPED, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR,
							  S_CHANNEL_PEER_RESET, S_CHANNEL_IO_ERROR
</p>
</blockquote><p>
						
</p>
<a name="anchor88"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.9.3"></a><h3>9.3.&nbsp;
Interface CICM::Encrypt::KeyWrapStream</h3>

<p>Interface  CICM::Encrypt::KeyWrapStream
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>interface KeyWrapStream : CICM::Stream {</pre></div>
<p>CICM::Encrypt::KeyWrapStream is an abstraction that allows
					key material to be presented to a stream for wrapping prior to
					passing into a different security domain.
</p>
<a name="anchor89"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.9.3.1"></a><h3>9.3.1.&nbsp;
CICM::Encrypt::KeyWrapStream Inheritance</h3>

<p>CICM::Encrypt::KeyWrapStream inherits from: CICM::Stream.
</p>
<a name="anchor90"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.9.3.2"></a><h3>9.3.2.&nbsp;
CICM::Encrypt::KeyWrapStream Methods</h3>

<p>Method CICM::Encrypt::KeyWrapStream::wrap_key()
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>CICM::Status wrap_key(
	in CICM::Key key_ref
);</pre></div>
<p>Write the key to be wrapped to the channel stream.
</p>
<p>Remarks:
							</p>
<blockquote class="text">
<p>The method blocks until the key has been written.
</p>
</blockquote><p>
						
</p>
<p>Parameters:
							</p>
<blockquote class="text">
<p>[in] key_ref
								  Reference to key to be wrapped.
</p>
</blockquote><p>
						
</p>
<p>Returns:
							</p>
<blockquote class="text">
<p>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_INVALID,
							  S_KEY_EXPIRED, S_KEY_CLASSIFICATION, S_KEY_WRAPPED,
							  S_KEY_NOT_WRAPPABLE, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR,
							  S_CHANNEL_PEER_RESET, S_CHANNEL_IO_ERROR
</p>
</blockquote><p>
						
</p>
<a name="anchor91"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.9.4"></a><h3>9.4.&nbsp;
Interface CICM::Encrypt::Controller</h3>

<p>Interface CICM::Encrypt::Controller
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>interface Controller :
	CICM::MultiDomainController,
	CICM::SymKeyController,
	CICM::GenVectorController,
	CICM::ResyncController {</pre></div>
<p>CICM::Encrypt::Controller supports encryption operations
					between two independent security domains. The resulting controller
					is capable of managing the channel, but not accepting data for
					transformation. It is created by calling
					CICM::ChannelManager::create_encrypt_controller.
</p>
<a name="anchor92"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.9.4.1"></a><h3>9.4.1.&nbsp;
CICM::Encrypt::Controller Inheritance</h3>

<p>CICM::Encrypt::Controller inherits from:
						CICM::MultiDomainController, CICM::SymKeyController,
						CICM::GenVectorController and CICM::ResyncController.
</p>
<a name="anchor93"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.9.5"></a><h3>9.5.&nbsp;
Interface CICM::Encrypt::NegotiatedController</h3>

<p>Interface  CICM::Encrypt::NegotiatedController
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>interface NegotiatedController :
	CICM::NegotiatedController,
	CICM::GenVectorController,
	CICM::ResyncController {</pre></div>
<p>CICM::Encrypt::NegotiatedController is the negotiated version
					of CICM::Encrypt::Controller. It is the result of a successful
					negotiation by CICM::Encrypt::ControllerNegotiator.
</p>
<a name="anchor94"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.9.5.1"></a><h3>9.5.1.&nbsp;
CICM::Encrypt::NegotiatedController Inheritance</h3>

<p>CICM::Encrypt::NegotiatedController inherits from:
						CICM::NegotiatedController, CICM::GenVectorController and
						CICM::ResyncController.
</p>
<a name="anchor95"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.9.6"></a><h3>9.6.&nbsp;
Interface CICM::Encrypt::Conduit</h3>

<p>Interface CICM::Encrypt::Conduit
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>interface Conduit :
	CICM::Conduit,
	CICM::Encrypt::Controller,
	CICM::Encrypt::Stream {</pre></div>
<p>CICM::Encrypt::Conduit supports encryption operations between
					two independent security domains. The resulting conduit is capable
					of both managing the channel and accepting data for transformation.
					It is created by calling
					CICM::ChannelManager::create_encrypt_conduit.
</p>
<a name="anchor96"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.9.6.1"></a><h3>9.6.1.&nbsp;
CICM::Encrypt::Conduit Inheritance</h3>

<p>CICM::Encrypt::Conduit
						inherits from: CICM::Conduit, CICM::Encrypt::Controller and
						CICM::Encrypt::Stream.
</p>
<a name="anchor97"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.9.7"></a><h3>9.7.&nbsp;
Interface CICM::Encrypt::NegotiatedConduit</h3>

<p>Interface  CICM::Encrypt::NegotiatedConduit
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>interface NegotiatedConduit :
CICM::Conduit,
CICM::Encrypt::NegotiatedController,
CICM::Encrypt::Stream {</pre></div>
<p>CICM::Encrypt::NegotiatedConduit is the negotiated version of
					CICM::Encrypt::Conduit. It is the result of a successful
					negotiation by CICM::Encrypt::Negotiator.
</p>
<a name="anchor98"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.9.7.1"></a><h3>9.7.1.&nbsp;
CICM::Encrypt::NegotiatedConduit Inheritance</h3>

<p>CICM::Encrypt::NegotiatedConduit inherits from:
						CICM::Conduit, CICM::Encrypt::NegotiatedController and
						CICM::Encrypt::Stream.
</p>
<a name="anchor99"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.9.8"></a><h3>9.8.&nbsp;
Interface CICM::Encrypt::WithMACConduit</h3>

<p>Interface CICM::Encrypt::WithMACConduit
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>interface WithMACConduit :
CICM::AbstractMACConduit,
CICM::Encrypt::Conduit {</pre></div>
<p>CICM::Encrypt::WithMACConduit supports encryption operations
					between two independent security domains with the receipt of a MAC
					value in the initiating domain. The resulting conduit is capable of
					both managing the channel and accepting data for transformation. It
					is created by calling
					CICM::ChannelManager::create_encrypt_with_mac_conduit.
</p>
<a name="anchor100"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.9.8.1"></a><h3>9.8.1.&nbsp;
CICM::Encrypt::WithMACConduit Inheritance</h3>

<p>CICM::Encrypt::WithMACConduit inherits from:
						CICM::AbstractMACConduit and CICM::Encrypt::Conduit.
</p>
<a name="anchor101"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.9.9"></a><h3>9.9.&nbsp;
Interface CICM::Encrypt::WithMACNegotiatedConduit</h3>

<p>Interface  CICM::Encrypt::WithMACNegotiatedConduit
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>interface WithMACNegotiatedConduit :
CICM::AbstractMACConduit,
CICM::Encrypt::NegotiatedConduit {</pre></div>
<p>CICM::Encrypt::WithMACNegotiatedConduit is the negotiated
					version of CICM::Encrypt::WithMACConduit. It is the result of a
					successful negotiation by CICM::Encrypt::WithMACNegotiator.
</p>
<a name="anchor102"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.9.9.1"></a><h3>9.9.1.&nbsp;
CICM::Encrypt::WithMACNegotiatedConduit Inheritance</h3>

<p>CICM::Encrypt::WithMACNegotiatedConduit inherits
						from: CICM::AbstractMACConduit and
						CICM::Encrypt::NegotiatedConduit.
</p>
<a name="anchor103"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.9.10"></a><h3>9.10.&nbsp;
Interface CICM::Encrypt::WithSignConduit</h3>

<p>Interface  CICM::Encrypt::WithSignConduit
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>interface WithSignConduit :
CICM::AbstractSignConduit,
CICM::Encrypt::Conduit {</pre></div>
<p>CICM::Encrypt::WithSignConduit supports encryption operations
					between two independent security domains with the receipt of a
					signature value in the initiating domain. The resulting conduit is
					capable of both managing the channel and accepting data for
					transformation. It is created by calling
					CICM::ChannelManager::create_encrypt_with_sign_conduit.
</p>
<a name="anchor104"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.9.10.1"></a><h3>9.10.1.&nbsp;
CICM::Encrypt::WithSignConduit Inheritance</h3>

<p>CICM::Encrypt::WithSignConduit inherits from:
						CICM::AbstractSignConduit and CICM::Encrypt::Conduit.
</p>
<a name="anchor105"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.9.11"></a><h3>9.11.&nbsp;
Interface CICM::Encrypt::WithSignNegotiatedConduit</h3>

<p>Interface  CICM::Encrypt::WithSignNegotiatedConduit
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>interface WithSignNegotiatedConduit :
CICM::AbstractSignConduit,
CICM::Encrypt::NegotiatedConduit {</pre></div>
<p>CICM::Encrypt::WithSignNegotiatedConduit is the negotiated
					version of CICM::Encrypt::WithSignConduit. It is the result of a
					successful negotiation by CICM::Encrypt::WithSignNegotiator.
</p>
<a name="anchor106"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.9.11.1"></a><h3>9.11.1.&nbsp;
CICM::Encrypt::WithSignNegotiatedConduit Inheritance</h3>

<p>CICM::Encrypt::WithSignNegotiatedConduit inherits
						from: CICM::AbstractSignConduit and
						CICM::Encrypt::NegotiatedConduit.
</p>
<a name="anchor107"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.9.12"></a><h3>9.12.&nbsp;
Interface CICM::Encrypt::KeyWrapConduit</h3>

<p>Interface  CICM::Encrypt::KeyWrapConduit
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>interface KeyWrapConduit :
CICM::Encrypt::Controller,
CICM::Encrypt::KeyWrapStream {</pre></div>
<p>CICM::Encrypt::KeyWrapConduit supports key wrapping
					operations between two independent security domains. The resulting
					conduit is capable of both managing the channel and accepting keys
					for transformation. It is created by calling
					CICM::ChannelManager::create_key_wrap_conduit.
</p>
<a name="anchor108"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.9.12.1"></a><h3>9.12.1.&nbsp;
CICM::Encrypt::KeyWrapConduit Inheritance</h3>

<p>CICM::Encrypt::KeyWrapConduit inherits from:
						CICM::Encrypt::Controller and CICM::Encrypt::KeyWrapStream.
</p>
<a name="anchor109"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.9.13"></a><h3>9.13.&nbsp;
Interface CICM::Encrypt::ControllerNegotiator</h3>

<p>Interface  CICM::Encrypt::ControllerNegotiator
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>interface ControllerNegotiator : CICM::Negotiator {</pre></div>
<p>CICM::Encrypt::ControllerNegotiator initiates a negotiation
					to establish a shared key with a remote entity that is used to
					support encryption operations between two independent security
					domains. The result of a successful negotiation is a
					CICM::Encrypt::NegotiatedController which is capable of managing
					the channel, but not accepting data for transformation.
					CICM::Encrypt::ControllerNegotiator is created by calling
					CICM::ChannelManager::negotiate_encrypt_controller.
</p>
<a name="anchor110"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.9.13.1"></a><h3>9.13.1.&nbsp;
CICM::Encrypt::ControllerNegotiator Inheritance</h3>

<p>CICM::Encrypt::ControllerNegotiator inherits from: CICM::Negotiator.
</p>
<a name="anchor111"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.9.13.2"></a><h3>9.13.2.&nbsp;
CICM::Encrypt::ControllerNegotiator Methods</h3>

<p>Method CICM::Encrypt::ControllerNegotiator::complete()
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>CICM::Status complete(
	out CICM::Encrypt::NegotiatedController controller_ref
);</pre></div>
<p>Complete negotiation and retrieve a negotiated negotiated
						encrypt controller.
</p>
<p>Parameters:
							</p>
<blockquote class="text">
<p>[out] controller_ref
								  Reference to resulting controller.
</p>
</blockquote><p>
						
</p>
<p>Returns:
							</p>
<blockquote class="text">
<p>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_NEGOTIATION_ABORTED,
							  S_NEGOTIATION_FAILURE, S_NEGOTIATION_NOT_IN_PROGRESS,
							  S_NEGOTIATION_TIMEOUT, S_CERT_LOCAL_INVALID,
							  S_CERT_LOCAL_EXPIRED, S_CERT_REMOTE_INVALID,
							  S_CERT_REMOTE_EXPIRED, S_CERT_REMOTE_PATH, S_CHANNEL_ERROR,
							  S_CHANNEL_PEER_RESET
</p>
</blockquote><p>
						
</p>
<a name="anchor112"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.9.14"></a><h3>9.14.&nbsp;
Interface CICM::Encrypt::Negotiator</h3>

<p>Interface CICM::Encrypt::Negotiator
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>interface Negotiator : CICM::Negotiator {</pre></div>
<p>CICM::Encrypt::Negotiator initiates a negotiation to
					establish a shared key with a remote entity that is used to support
					encryption operations between two independent security domains. The
					result of a successful negotiation is a
					CICM::Encrypt::NegotiatedConduit which is capable of both managing
					the channel and accepting data for transformation. CICM::Negotiator
					is created by calling
					CICM::Encrypt::ChannelManager::negotiate_encrypt_conduit.
</p>
<a name="anchor113"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.9.14.1"></a><h3>9.14.1.&nbsp;
CICM::Encrypt::Negotiator Inheritance</h3>

<p>CICM::Encrypt::Negotiator inherits from: CICM::Negotiator.
</p>
<a name="anchor114"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.9.14.2"></a><h3>9.14.2.&nbsp;
CICM::Encrypt::Negotiator Methods</h3>

<p>Method CICM::Encrypt::Negotiator::complete()
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>CICM::Status complete(
	out CICM::Encrypt::NegotiatedConduit conduit_ref
);</pre></div>
<p>Complete negotiation and retrieve a negotiated encrypt
						conduit.
</p>
<p>Parameters:
							</p>
<blockquote class="text">
<p>[out] conduit_ref
								  Reference to resulting conduit.
</p>
</blockquote><p>
						
</p>
<p>Returns:
							</p>
<blockquote class="text">
<p>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_NEGOTIATION_ABORTED,
							  S_NEGOTIATION_FAILURE, S_NEGOTIATION_NOT_IN_PROGRESS,
							  S_NEGOTIATION_TIMEOUT, S_CERT_LOCAL_INVALID,
							  S_CERT_LOCAL_EXPIRED, S_CERT_REMOTE_INVALID,
							  S_CERT_REMOTE_EXPIRED, S_CERT_REMOTE_PATH, S_CHANNEL_ERROR,
							  S_CHANNEL_PEER_RESET
</p>
</blockquote><p>
						
</p>
<a name="anchor115"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.9.15"></a><h3>9.15.&nbsp;
Interface CICM::Encrypt::WithMACNegotiator</h3>

<p>Interface  CICM::Encrypt::WithMACNegotiator
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>interface WithMACNegotiator : CICM::Negotiator {</pre></div>
<p>CICM::Encrypt::WithMACNegotiator initiates a negotiation to
					establish a shared key with a remote entity that is used to support
					encryption operations between two independent security domains.
					Additionally, a message authentication code (MAC) is received in the
					initiating domain. The result of a successful negotiation is a
					CICM::Encrypt::WithMACNegotiatedConduit which is capable of both
					managing the channel and accepting data for transformation.
					CICM::Encrypt::WithMACNegotiator is created by calling
					CICM::ChannelManager::negotiate_encrypt_with_mac_conduit.
</p>
<a name="anchor116"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.9.15.1"></a><h3>9.15.1.&nbsp;
CICM::Encrypt::WithMACNegotiator Inheritance</h3>

<p>CICM::Encrypt::WithMACNegotiator inherits from: CICM::Negotiator.
</p>
<a name="anchor117"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.9.15.2"></a><h3>9.15.2.&nbsp;
CICM::Encrypt::WithMACNegotiator Methods</h3>

<p>Method CICM::Encrypt::WithMACNegotiator::complete()
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>CICM::Status complete(
	out CICM::Encrypt::WithMACNegotiatedConduit conduit_ref
);</pre></div>
<p>Complete negotiation and retrieve a negotiated MAC encrypt conduit.
</p>
<p>Parameters:
							</p>
<blockquote class="text">
<p>[out] conduit_ref
								  Reference to resulting conduit.
</p>
</blockquote><p>
						
</p>
<p>Returns:
							</p>
<blockquote class="text">
<p>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_NEGOTIATION_ABORTED,
							  S_NEGOTIATION_FAILURE, S_NEGOTIATION_NOT_IN_PROGRESS,
							  S_NEGOTIATION_TIMEOUT, S_CERT_LOCAL_INVALID,
							  S_CERT_LOCAL_EXPIRED, S_CERT_REMOTE_INVALID,
							  S_CERT_REMOTE_EXPIRED, S_CERT_REMOTE_PATH, S_CHANNEL_ERROR,
							  S_CHANNEL_PEER_RESET
</p>
</blockquote><p>
						
</p>
<a name="anchor118"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.9.16"></a><h3>9.16.&nbsp;
Interface CICM::Encrypt::WithSignNegotiator</h3>

<p>Interface  CICM::Encrypt::WithSignNegotiator
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>interface WithSignNegotiator : CICM::Negotiator {</pre></div>
<p>CICM::Encrypt::WithSignNegotiator initiates a negotiation to
					establish a shared key with a remote entity that is used to support
					encryption operations between two independent security domains.
					Additionally, a signature value is received in the initiating
					domain. The result of a successful negotiation is a
					CICM::Encrypt::WithSignNegotiatedConduit which is capable of both
					managing the channel and accepting data for transformation.
					CICM::Encrypt::WithSignNegotiator is created by calling
					CICM::ChannelManager::negotiate_encrypt_with_sign_conduit.
</p>
<a name="anchor119"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.9.16.1"></a><h3>9.16.1.&nbsp;
CICM::Encrypt::WithSignNegotiator Inheritance</h3>

<p>CICM::Encrypt::WithSignNegotiator inherits from: CICM::Negotiator.
</p>
<a name="anchor120"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.9.16.2"></a><h3>9.16.2.&nbsp;
CICM::Encrypt::WithSignNegotiator Methods</h3>

<p>Method CICM::Encrypt::WithSignNegotiator::complete()
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>CICM::Status complete(
	out CICM::Encrypt::WithSignNegotiatedConduit conduit_ref
);</pre></div>
<p>Complete negotiation and retrieve a negotiated sign encrypt
						conduit.
</p>
<p>Parameters:
							</p>
<blockquote class="text">
<p>[out] conduit_ref
								  Reference to resulting conduit.
</p>
</blockquote><p>
						
</p>
<p>Returns:
							</p>
<blockquote class="text">
<p>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_NEGOTIATION_ABORTED,
							  S_NEGOTIATION_FAILURE, S_NEGOTIATION_NOT_IN_PROGRESS,
							  S_NEGOTIATION_TIMEOUT, S_CERT_LOCAL_INVALID,
							  S_CERT_LOCAL_EXPIRED, S_CERT_REMOTE_INVALID,
							  S_CERT_REMOTE_EXPIRED, S_CERT_REMOTE_PATH, S_CHANNEL_ERROR,
							  S_CHANNEL_PEER_RESET
</p>
</blockquote><p>
						
</p>
<a name="sec-decrypt"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.10"></a><h3>10.&nbsp;
Decryption</h3>

<p>Namespace CICM::Decrypt
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>module Decrypt {</pre></div>
<p>The CICM::Decrypt namespace contains interfaces that support
				decryption operations between two independent security domains.
</p>
<a name="anchor121"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.10.1"></a><h3>10.1.&nbsp;
Interface CICM::Decrypt::ChannelManager</h3>

<p>Interface  CICM::Decrypt::ChannelManager
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>interface ChannelManager {</pre></div>
<p>CICM::Decrypt::ChannelManager is an abstraction inherited by
					CICM::ChannelManager that supports the creation of decryption
					negotiators, conduits, controllers, and streams. See
					CICM::ChannelManager for additional information.
</p>
<a name="anchor122"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.10.1.1"></a><h3>10.1.1.&nbsp;
CICM::Decrypt::ChannelManager Methods</h3>

<p>Method CICM::Decrypt::ChannelManager::negotiate_decrypt_conduit()
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>CICM::Status negotiate_decrypt_conduit(
	in  CICM::RemotePort remote_port,
	in  CICM::ProtocolId protocol,
	in  CICM::AsymKey key_ref,
	out CICM::Decrypt::Negotiator negotiator_ref
);</pre></div>
<p>Creates a negotiator that, upon successful negotiation,
						results in a CICM::Decrypt::NegotiatedConduit.
</p>
<p>Parameters:
							</p>
<blockquote class="text">
<p>[in] remote_port
								  Remote port.
</p>
<p>[in] protocol
								  Protocol identifier.
</p>
<p>[in] key_ref
								  Reference to negotiation key.
</p>
<p>[out] negotiator_ref
								  Reference to resulting negotiator.
</p>
</blockquote><p>
						
</p>
<p>Returns:
							</p>
<blockquote class="text">
<p>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_USED_INVALID,
							  S_KEY_USED_EXPIRED, S_KEY_USED_WRAPPED, S_KEY_USED_CONTEXT,
							  S_KEY_USED_COMPONENT_NOT_AVAIL, S_KEY_INVALID, S_KEY_EXPIRED,
							  S_REMOTE_PORT_INVALID, S_REMOTE_PORT_IN_USE,
							  S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT,
							  S_NEGOTIATION_ABORTED, S_NEGOTIATION_FAILURE,
							  S_NEGOTIATION_IN_PROGRESS, S_NEGOTIATION_TIMEOUT,
							  S_CERT_LOCAL_INVALID, S_CERT_LOCAL_EXPIRED,
							  S_CERT_REMOTE_INVALID, S_CERT_REMOTE_EXPIRED,
							  S_CERT_REMOTE_PATH, S_PROTO_INVALID, S_PROTO_INCOMPATIBLE,
							  S_PROTO_UNDETERMINED, S_CHANNEL_ERROR, S_CHANNEL_MAX
</p>
</blockquote><p>
						
</p>
<p>Method CICM::Decrypt::ChannelManager::negotiate_decrypt_with_mac_conduit()
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>CICM::Status negotiate_decrypt_with_mac_conduit(
	in  CICM::RemotePort remote_port,
	in  CICM::ProtocolId protocol,
	in  CICM::SymKey verify_key_ref,
	in  CICM::AsymKey nego_key_ref,
	in  CICM::SymMacAlgorithmId verify_algorithm,
	out CICM::Decrypt::WithMACNegotiator negotiator_ref
);</pre></div>
<p>Creates a negotiator that, upon successful negotiation,
						results in a CICM::Decrypt::MACNegotiatedConduit.
</p>
<p>Remarks:
							</p>
<blockquote class="text">
<p>Negotiation applies only to the negotiation key, not the
							MAC key.
</p>
</blockquote><p>
						
</p>
<p>Parameters:
							</p>
<blockquote class="text">
<p>[in] remote_port
								  Remote port.
</p>
<p>[in] protocol
								  Protocol identifier.
</p>
<p>[in] verify_key_ref
								  Reference to verification key.
</p>
<p>[in] nego_key_ref
								  Reference to negotiation key.
</p>
<p>[in] verify_algorithm
								  Verification algorithm.
</p>
<p>[out] negotiator_ref
								  Reference to resulting negotiator.
</p>
</blockquote><p>
						
</p>
<p>Returns:
							</p>
<blockquote class="text">
<p>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_USED_INVALID,
							  S_KEY_USED_EXPIRED, S_KEY_USED_WRAPPED, S_KEY_USED_CONTEXT,
							  S_KEY_USED_COMPONENT_NOT_AVAIL, S_KEY_INVALID, S_KEY_EXPIRED,
							  S_REMOTE_PORT_INVALID, S_REMOTE_PORT_IN_USE, S_ALGO_INVALID,
							  S_ALGO_INCOMPATIBLE, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_NEGOTIATION_ABORTED,
							  S_NEGOTIATION_FAILURE, S_NEGOTIATION_IN_PROGRESS,
							  S_NEGOTIATION_TIMEOUT, S_CERT_LOCAL_INVALID,
							  S_CERT_LOCAL_EXPIRED, S_CERT_REMOTE_INVALID,
							  S_CERT_REMOTE_EXPIRED, S_CERT_REMOTE_PATH, S_PROTO_INVALID,
							  S_PROTO_INCOMPATIBLE, S_PROTO_UNDETERMINED, S_CHANNEL_ERROR,
							  S_CHANNEL_MAX
</p>
</blockquote><p>
						
</p>
<p>Method CICM::Decrypt::ChannelManager::negotiate_decrypt_with_verify_conduit()
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>CICM::Status negotiate_decrypt_with_verify_conduit(
	in  CICM::RemotePort remote_port,
	in  CICM::ProtocolId protocol,
	in  CICM::AsymKey verify_key_ref,
	in  CICM::AsymKey nego_key_ref,
	in  CICM::AsymSigAlgorithmId verify_algorithm,
	out CICM::Decrypt::WithVerifyNegotiator negotiator_ref
);</pre></div>
<p>Initiate a negotiation to establish a shared key with a peer.
						The channel that results will decrypt and verify a stream of
						data.
</p>
<p>Remarks:
							</p>
<blockquote class="text">
<p>Negotiation applies only to the negotiation key, not the
							signature verification key.
</p>
</blockquote><p>
						
</p>
<p>Parameters:
							</p>
<blockquote class="text">
<p>[in] remote_port
								  Remote port.
</p>
<p>[in] protocol
								  Protocol identifier.
</p>
<p>[in] verify_key_ref
								  Reference to verification key.
</p>
<p>[in] nego_key_ref
								  Reference to negotiation key.
</p>
<p>[in] verify_algorithm
								  Verification algorithm.
</p>
<p>[out] negotiator_ref
								  Reference to resulting negotiator.
</p>
</blockquote><p>
						
</p>
<p>Returns:
							</p>
<blockquote class="text">
<p>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_USED_INVALID,
							  S_KEY_USED_EXPIRED, S_KEY_USED_WRAPPED, S_KEY_USED_CONTEXT,
							  S_KEY_USED_COMPONENT_NOT_AVAIL, S_KEY_INVALID, S_KEY_EXPIRED,
							  S_REMOTE_PORT_INVALID, S_REMOTE_PORT_IN_USE, S_ALGO_INVALID,
							  S_ALGO_INCOMPATIBLE, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_NEGOTIATION_ABORTED,
							  S_NEGOTIATION_FAILURE, S_NEGOTIATION_IN_PROGRESS,
							  S_NEGOTIATION_TIMEOUT, S_CERT_LOCAL_INVALID,
							  S_CERT_LOCAL_EXPIRED, S_CERT_REMOTE_INVALID,
							  S_CERT_REMOTE_EXPIRED, S_CERT_REMOTE_PATH, S_PROTO_INVALID,
							  S_PROTO_INCOMPATIBLE, S_PROTO_UNDETERMINED, S_CHANNEL_ERROR,
							  S_CHANNEL_MAX
</p>
</blockquote><p>
						
</p>
<p>Method CICM::Decrypt::ChannelManager::negotiate_decrypt_controller()
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>CICM::Status negotiate_decrypt_controller(
	in  CICM::LocalPort local_port,
	in  CICM::RemotePort remote_port,
	in  CICM::ProtocolId protocol,
	in  CICM::AsymKey key_ref,
	out CICM::Decrypt::ControllerNegotiator negotiator_ref
);</pre></div>
<p>Initiate a negotiation to establish a shared key with a peer,
						resulting in a controller to manage a decryption channel.
</p>
<p>Parameters:
							</p>
<blockquote class="text">
<p>[in] local_port
								  Local port.
</p>
<p>[in] remote_port
								  Remote port.
</p>
<p>[in] protocol
								  Protocol identifier.
</p>
<p>[in] key_ref
								  Reference to negotiation key.
</p>
<p>[out] negotiator_ref
								  Reference to resulting negotiator.
</p>
</blockquote><p>
						
</p>
<p>Returns:
							</p>
<blockquote class="text">
<p>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_USED_INVALID,
							  S_KEY_USED_EXPIRED, S_KEY_USED_WRAPPED, S_KEY_USED_CONTEXT,
							  S_KEY_USED_COMPONENT_NOT_AVAIL, S_KEY_INVALID, S_KEY_EXPIRED,
							  S_LOCAL_PORT_INVALID, S_LOCAL_PORT_INCOMPATIBLE,
							  S_LOCAL_PORT_IN_USE, S_REMOTE_PORT_INVALID,
							  S_REMOTE_PORT_IN_USE, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_NEGOTIATION_ABORTED,
							  S_NEGOTIATION_FAILURE, S_NEGOTIATION_IN_PROGRESS,
							  S_NEGOTIATION_TIMEOUT, S_CERT_LOCAL_INVALID,
							  S_CERT_LOCAL_EXPIRED, S_CERT_REMOTE_INVALID,
							  S_CERT_REMOTE_EXPIRED, S_CERT_REMOTE_PATH, S_PROTO_INVALID,
							  S_PROTO_INCOMPATIBLE, S_PROTO_UNDETERMINED, S_CHANNEL_ERROR,
							  S_CHANNEL_MAX
</p>
</blockquote><p>
						
</p>
<p>Method CICM::Decrypt::ChannelManager::create_decrypt_conduit()
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>CICM::Status create_decrypt_conduit(
	in  CICM::RemotePort remote_port,
	in  CICM::SymKey key_ref,
	in  CICM::SymEncrAlgorithmId algorithm,
	out CICM::Decrypt::Conduit conduit_ref
);</pre></div>
<p>Create channel to decrypt a stream of data.
</p>
<p>Parameters:
							</p>
<blockquote class="text">
<p>[in] remote_port
								  Remote port.
</p>
<p>[in] key_ref
								  Reference to decryption key.
</p>
<p>[in] algorithm
								  Decryption algorithm/mode.
</p>
<p>[out] conduit_ref
								  Reference to resulting conduit.
</p>
</blockquote><p>
						
</p>
<p>Returns:
							</p>
<blockquote class="text">
<p>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_USED_INVALID,
							  S_KEY_USED_EXPIRED, S_KEY_INVALID, S_KEY_EXPIRED,
							  S_REMOTE_PORT_INVALID, S_REMOTE_PORT_IN_USE, S_ALGO_INVALID,
							  S_ALGO_INCOMPATIBLE, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR,
							  S_CHANNEL_MAX
</p>
</blockquote><p>
						
</p>
<p>Method CICM::Decrypt::ChannelManager::create_decrypt_with_mac_conduit()
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>CICM::Status create_decrypt_with_mac_conduit(
	in  CICM::RemotePort remote_port,
	in  CICM::SymKey verify_key_ref,
	in  CICM::SymKey decrypt_key_ref,
	in  CICM::SymMacAlgorithmId verify_algorithm,
	in  CICM::SymEncrAlgorithmId decrypt_algorithm,
	out CICM::Decrypt::WithMACConduit conduit_ref
);</pre></div>
<p>Create channel to MAC verify and decrypt a stream of
						data.
</p>
<p>Parameters:
							</p>
<blockquote class="text">
<p>[in] remote_port
								  Remote port.
</p>
<p>[in] verify_key_ref
								  Reference to verification key.
</p>
<p>[in] decrypt_key_ref
								  Reference to decryption key.
</p>
<p>[in] verify_algorithm
								  Verification algorithm.
</p>
<p>[in] decrypt_algorithm
								  Decryption algorithm/mode.
</p>
<p>[out] conduit_ref
								  Reference to resulting conduit.
</p>
</blockquote><p>
						
</p>
<p>Returns:
							</p>
<blockquote class="text">
<p>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_USED_INVALID,
							  S_KEY_USED_EXPIRED, S_KEY_INVALID, S_KEY_EXPIRED,
							  S_REMOTE_PORT_INVALID, S_REMOTE_PORT_IN_USE, S_ALGO_INVALID,
							  S_ALGO_INCOMPATIBLE, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR,
							  S_CHANNEL_MAX
</p>
</blockquote><p>
						
</p>
<p>Method CICM::Decrypt::ChannelManager::create_decrypt_with_verify_conduit()
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>CICM::Status create_decrypt_with_verify_conduit(
	in  CICM::RemotePort remote_port,
	in  CICM::AsymKey verify_key_ref,
	in  CICM::SymKey decrypt_key_ref,
	in  CICM::AsymSigAlgorithmId verify_algorithm,
	in  CICM::SymEncrAlgorithmId decrypt_algorithm,
	out CICM::Decrypt::WithVerifyConduit conduit_ref
);</pre></div>
<p>Create channel to verify and decrypt a stream of data.
</p>
<p>Parameters:
							</p>
<blockquote class="text">
<p>[in] remote_port
								  Remote port.
</p>
<p>[in] verify_key_ref
								  Reference to verification key.
</p>
<p>[in] decrypt_key_ref
								  Reference to decryption key.
</p>
<p>[in] verify_algorithm
								  Verification algorithm.
</p>
<p>[in] decrypt_algorithm
								  Decryption algorithm/mode.
</p>
<p>[out] conduit_ref
								  Reference to resulting conduit.
</p>
</blockquote><p>
						
</p>
<p>Returns:
							</p>
<blockquote class="text">
<p>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_USED_INVALID,
							  S_KEY_USED_EXPIRED, S_KEY_USED_WRAPPED, S_KEY_USED_CONTEXT,
							  S_KEY_INVALID, S_KEY_EXPIRED, S_REMOTE_PORT_INVALID,
							  S_REMOTE_PORT_IN_USE, S_ALGO_INVALID, S_ALGO_INCOMPATIBLE,
							  S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT,
							  S_CHANNEL_ERROR, S_CHANNEL_MAX
</p>
</blockquote><p>
						
</p>
<p>Method CICM::Decrypt::ChannelManager::create_key_unwrap_conduit()
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>CICM::Status create_key_unwrap_conduit(
	in  CICM::RemotePort remote_port,
	in  CICM::SymKey kek_ref,
	in  CICM::KeyWrapAlgorithmId algorithm,
	out CICM::Decrypt::KeyUnwrapConduit conduit_ref
);</pre></div>
<p>Create channel to unwrap a key. This type of channel may be
						used to bulk unwrap key material originating at a key
						infrastructure component or from a peer cryptographic module. Note
						that, to unwrap individual keys already in the module, use
						CICM::Symkey::unwrap or CICM::Asymkey::unwrap.
</p>
<p>Parameters:
							</p>
<blockquote class="text">
<p>[in] remote_port
								  Remote port.
</p>
<p>[in] kek_ref
								  Reference to key encryption key.
</p>
<p>[in] algorithm
								  Key unwrapping algorithm/mode.
</p>
<p>[out] conduit_ref
								  Reference to resulting conduit.
</p>
</blockquote><p>
						
</p>
<p>Returns:
							</p>
<blockquote class="text">
<p>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_USED_INVALID,
							  S_KEY_USED_EXPIRED, S_KEY_INVALID, S_KEY_EXPIRED,
							  S_REMOTE_PORT_INVALID, S_REMOTE_PORT_IN_USE, S_ALGO_INVALID,
							  S_ALGO_INCOMPATIBLE, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR,
							  S_CHANNEL_MAX
</p>
</blockquote><p>
						
</p>
<p>Method CICM::Decrypt::ChannelManager::create_decrypt_controller()
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>CICM::Status create_decrypt_controller(
	in  CICM::LocalPort local_port,
	in  CICM::RemotePort remote_port,
	in  CICM::SymKey key_ref,
	in  CICM::SymEncrAlgorithmId algorithm,
	out CICM::Decrypt::Controller controller_ref
);</pre></div>
<p>Create controller to configure and control an decryption
						channel.
</p>
<p>Remarks:
							</p>
<blockquote class="text">
<p>In some cases, hosts may depend upon separate processes to
							control and use a channel. This method returns the channel
							controller and must be called before the corresponding stream
							is retrieved.
</p>
</blockquote><p>
						
</p>
<p>Parameters:
							</p>
<blockquote class="text">
<p>[in] local_port
								  Local port.
</p>
<p>[in] remote_port
								  Remote port.
</p>
<p>[in] key_ref
								  Reference to decryption key.
</p>
<p>[in] algorithm
								  Decryption algorithm/mode.
</p>
<p>[out] controller_ref
								  Reference to resulting controller.
</p>
</blockquote><p>
						
</p>
<p>Returns:
							</p>
<blockquote class="text">
<p>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_USED_INVALID,
							  S_KEY_USED_EXPIRED, S_KEY_INVALID, S_KEY_EXPIRED,
							  S_LOCAL_PORT_INVALID, S_LOCAL_PORT_INCOMPATIBLE,
							  S_LOCAL_PORT_IN_USE, S_REMOTE_PORT_INVALID,
							  S_REMOTE_PORT_IN_USE, S_ALGO_INVALID, S_ALGO_INCOMPATIBLE,
							  S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT,
							  S_CHANNEL_ERROR, S_CHANNEL_MAX
</p>
</blockquote><p>
						
</p>
<p>Method CICM::Decrypt::ChannelManager::get_decrypt_stream()
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>CICM::Status get_decrypt_stream(
	in  CICM::LocalPort local_port,
	out CICM::Decrypt::Stream stream_ref
);</pre></div>
<p>Create stream associated with previously created controller
						to receive transformed data.
</p>
<p>Parameters:
							</p>
<blockquote class="text">
<p>[in] local_port
								  Local port.
</p>
<p>[out] stream_ref
								  Reference to resulting stream.
</p>
</blockquote><p>
						
</p>
<p>Returns:
							</p>
<blockquote class="text">
<p>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_INVALID,
							  S_KEY_EXPIRED, S_LOCAL_PORT_INVALID,
							  S_LOCAL_PORT_INCOMPATIBLE, S_LOCAL_PORT_IN_USE,
							  S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT,
							  S_CHANNEL_ERROR, S_CHANNEL_PEER_RESET,
							  S_CHANNEL_NOT_FOUND
</p>
</blockquote><p>
						
</p>
<a name="anchor123"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.10.2"></a><h3>10.2.&nbsp;
Interface CICM::Decrypt::Stream</h3>

<p>Interface CICM::Decrypt::Stream
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>interface Stream : CICM::ReadStream {</pre></div>
<p>CICM::Decrypt::Stream supports decryption operations between
					two independent security domains. The resulting stream is capable
					of accepting transformed data, but not managing the channel. It is
					created by calling CICM::ChannelManager::get_decrypt_stream.
</p>
<a name="anchor124"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.10.2.1"></a><h3>10.2.1.&nbsp;
CICM::Decrypt::Stream Inheritance</h3>

<p>CICM::Decrypt::Stream inherits from: CICM::ReadStream.
</p>
<a name="anchor125"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.10.2.2"></a><h3>10.2.2.&nbsp;
CICM::Decrypt::Stream Methods</h3>

<p>Method CICM::Decrypt::Stream::decrypt()
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>CICM::Status decrypt(
	out CICM::Buffer buffer
);</pre></div>
<p>Read plaintext data off of decrypt channel stream. The method
						blocks until data becomes available.
</p>
<p>Parameters:
							</p>
<blockquote class="text">
<p>[out] buffer
								  Plaintext resulting from decryption operation.
</p>
</blockquote><p>
						
</p>
<p>Returns:
							</p>
<blockquote class="text">
<p>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_INVALID,
							  S_KEY_EXPIRED, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR,
							  S_CHANNEL_PEER_RESET, S_CHANNEL_IO_ERROR,
							  S_CHANNEL_BUFFER_LEN, S_INTEGRITY
</p>
</blockquote><p>
						
</p>
<p>Method CICM::Decrypt::Stream::decrypt_non_blocking()
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>CICM::Status decrypt_non_blocking(
	out CICM::Buffer buffer,
	in  CICM::TransId transaction_id
);</pre></div>
<p>Registers a buffer into which plaintext resulting from the
						decryption operation will be copied, and then immediately returns
						control to the caller. The size of the allocated buffer and length
						of the resulting plaintext is encapsulated in the buffer parameter.
						The caller may use the CICM::Decrypt::Stream::decrypt_poll method
						to proactively poll the channel to determine the status of the
						operation. The caller is responsible for maintaining any necessary
						metadata associated with the transaction_id parameter. Memory
						responsibilities and calling conventions shall follow the
						appropriate IDL language mapping conventions.
</p>
<p>Parameters:
							</p>
<blockquote class="text">
<p>[out] buffer
								  Plaintext resulting from decryption operation.
</p>
<p>[in] transaction_id
								  Unique transaction id that will be used by the
								  CICM::Decrypt::Stream::decrypt_poll method to determine
								  to which buffer the poll status applies.
</p>
</blockquote><p>
						
</p>
<p>Returns:
							</p>
<blockquote class="text">
<p>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_INVALID,
							  S_KEY_EXPIRED, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR,
							  S_CHANNEL_PEER_RESET, S_CHANNEL_IO_ERROR,
							  S_CHANNEL_BUFFER_LEN, S_INTEGRITY
</p>
</blockquote><p>
						
</p>
<p>Method CICM::Decrypt::Stream::decrypt_poll()
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>CICM::Status decrypt_poll(
	in  CICM::TransId transaction_id,
	out CICM::ReadStream::ReadStatus status
);</pre></div>
<p>Returns the status of the non-blocking decryption operation
						specified by the transaction_id parameter. Upon completion of the
						operation, the caller must use the metadata associated with the
						transaction_id parameter to determine which buffer has been
						populated. Memory responsibilities and calling conventions shall
						follow the appropriate IDL language mapping conventions.
</p>
<p>Parameters:
							</p>
<blockquote class="text">
<p>[in] transaction_id
								  Unique transaction id previously specified to the
								  CICM::Decrypt::Stream::decrypt_non_blocking method that
								  allows the poll operation to determine to which buffer
								  the poll status applies.
</p>
<p>[out] status
								  Status of the non-blocking operation corresponding to
								  the transaction_id parameter.
</p>
</blockquote><p>
						
</p>
<p>Returns:
							</p>
<blockquote class="text">
<p>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_INVALID,
							  S_KEY_EXPIRED, S_KEY_WRAPPED, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR,
							  S_CHANNEL_PEER_RESET, S_CHANNEL_IO_ERROR
</p>
</blockquote><p>
						
</p>
<a name="anchor126"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.10.3"></a><h3>10.3.&nbsp;
Interface CICM::Decrypt::KeyUnwrapStream</h3>

<p>Interface  CICM::Decrypt::KeyUnwrapStream
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>interface KeyUnwrapStream : CICM::Stream {</pre></div>
<p>CICM::Decrypt::KeyUnwrapStream is an abstraction that allows
					unwrapped key material received from another domain to be
					retrieved.
</p>
<a name="anchor127"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.10.3.1"></a><h3>10.3.1.&nbsp;
CICM::Decrypt::KeyUnwrapStream Inheritance</h3>

<p>CICM::Decrypt::KeyUnwrapStream inherits from:
						CICM::Stream.
</p>
<a name="anchor128"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.10.3.2"></a><h3>10.3.2.&nbsp;
CICM::Decrypt::KeyUnwrapStream Methods</h3>

<p>Method CICM::Decrypt::KeyUnwrapStream::unwrap_sym_key()
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>CICM::Status unwrap_sym_key(
	out CICM::SymKey key_ref
);</pre></div>
<p>Read one unwrapped symmetric key off of channel stream and
						return a reference to the key. The method blocks until a key
						becomes available.
</p>
<p>Parameters:
							</p>
<blockquote class="text">
<p>[in] key_ref
								  Reference to key encryption key.
</p>
</blockquote><p>
						
</p>
<p>Returns:
							</p>
<blockquote class="text">
<p>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_INVALID,
							  S_KEY_EXPIRED, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR,
							  S_CHANNEL_PEER_RESET, S_CHANNEL_IO_ERROR
</p>
</blockquote><p>
						
</p>
<p>Method CICM::Decrypt::KeyUnwrapStream::unwrap_asym_key()
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>CICM::Status unwrap_asym_key(
	out CICM::AsymKey key_ref
);</pre></div>
<p>Read one unwrapped asymmetric key off of channel stream and
						return a reference to the key. The method blocks until a key
						becomes available.
</p>
<p>Parameters:
							</p>
<blockquote class="text">
<p>[in] key_ref
								  Reference to key encryption key.
</p>
</blockquote><p>
						
</p>
<p>Returns:
							</p>
<blockquote class="text">
<p>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_INVALID,
							  S_KEY_EXPIRED, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR,
							  S_CHANNEL_PEER_RESET, S_CHANNEL_IO_ERROR
</p>
</blockquote><p>
						
</p>
<a name="anchor129"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.10.4"></a><h3>10.4.&nbsp;
Interface CICM::Decrypt::Controller</h3>

<p>Interface CICM::Decrypt::Controller
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>interface Controller :
	CICM::MultiDomainController,
	CICM::SymKeyController,
	CICM::SetVectorController,
	CICM::ResyncController {</pre></div>
<p>CICM::Decrypt::Controller supports decryption operations
					between two independent security domains. The resulting controller
					is capable of managing the channel, but not accepting transformed
					data. It is created by calling
					CICM::ChannelManager::create_decrypt_controller.
</p>
<a name="anchor130"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.10.4.1"></a><h3>10.4.1.&nbsp;
CICM::Decrypt::Controller Inheritance</h3>

<p>CICM::Decrypt::Controller inherits from:
						CICM::MultiDomainController, CICM::SymKeyController,
						CICM::SetVectorController and CICM::ResyncController.
</p>
<a name="anchor131"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.10.5"></a><h3>10.5.&nbsp;
Interface CICM::Decrypt::NegotiatedController</h3>

<p>Interface  CICM::Decrypt::NegotiatedController
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>interface NegotiatedController :
	CICM::NegotiatedController,
	CICM::SetVectorController,
	CICM::ResyncController {</pre></div>
<p>CICM::Decrypt::NegotiatedController is the negotiated version
					of CICM::Decrypt::Controller. It is the result of a successful
					negotiation by CICM::Decrypt::ControllerNegotiator.
</p>
<a name="anchor132"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.10.5.1"></a><h3>10.5.1.&nbsp;
CICM::Decrypt::NegotiatedController Inheritance</h3>

<p>CICM::Decrypt::NegotiatedController inherits from:
						CICM::NegotiatedController, CICM::SetVectorController and
						CICM::ResyncController.
</p>
<a name="anchor133"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.10.6"></a><h3>10.6.&nbsp;
Interface CICM::Decrypt::Conduit</h3>

<p>Interface CICM::Decrypt::Conduit
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>interface Conduit :
	CICM::Conduit,
	CICM::Decrypt::Controller,
	CICM::Decrypt::Stream {</pre></div>
<p>CICM::Decrypt::Conduit supports decryption operations between
					two independent security domains. The resulting conduit is capable
					of both managing the channel and accepting transformed data. It is
					created by calling CICM::ChannelManager::create_decrypt_conduit.
</p>
<a name="anchor134"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.10.6.1"></a><h3>10.6.1.&nbsp;
CICM::Decrypt::Conduit Inheritance</h3>

<p>CICM::Decrypt::Conduit
						inherits from: CICM::Conduit, CICM::Decrypt::Controller and
						CICM::Decrypt::Stream.
</p>
<a name="anchor135"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.10.7"></a><h3>10.7.&nbsp;
Interface CICM::Decrypt::NegotiatedConduit</h3>

<p>Interface  CICM::Decrypt::NegotiatedConduit
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>interface NegotiatedConduit :
	CICM::Conduit,
	CICM::Decrypt::NegotiatedController,
	CICM::Decrypt::Stream {</pre></div>
<p>CICM::Decrypt::NegotiatedConduit is the negotiated version of
					CICM::Decrypt::Conduit. It is the result of a successful
					negotiation by CICM::Decrypt::Negotiator.
</p>
<a name="anchor136"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.10.7.1"></a><h3>10.7.1.&nbsp;
CICM::Decrypt::NegotiatedConduit Inheritance</h3>

<p>CICM::Decrypt::NegotiatedConduit inherits from:
						CICM::Conduit, CICM::Decrypt::NegotiatedController and
						CICM::Decrypt::Stream.
</p>
<a name="anchor137"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.10.8"></a><h3>10.8.&nbsp;
Interface CICM::Decrypt::WithMACConduit</h3>

<p>Interface  CICM::Decrypt::WithMACConduit
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>interface WithMACConduit :
	CICM::AbstractMACVerifyConduit,
	CICM::Decrypt::Conduit {</pre></div>
<p>CICM::Decrypt::WithMACConduit supports decryption operations
					between two independent security domains with the receipt of an
					indication as to whether MAC verification succeeded or failed in
					the initiating domain. The resulting conduit is capable of both
					managing the channel and accepting data for transformation. It is
					created by calling
					CICM::ChannelManager::create_decrypt_with_mac_conduit.
</p>
<a name="anchor138"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.10.8.1"></a><h3>10.8.1.&nbsp;
CICM::Decrypt::WithMACConduit Inheritance</h3>

<p>CICM::Decrypt::WithMACConduit inherits from:
						CICM::AbstractMACVerifyConduit and CICM::Decrypt::Conduit.
</p>
<a name="anchor139"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.10.9"></a><h3>10.9.&nbsp;
Interface CICM::Decrypt::WithMACNegotiatedConduit</h3>

<p>Interface  CICM::Decrypt::WithMACNegotiatedConduit
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>interface WithMACNegotiatedConduit :
	CICM::AbstractMACVerifyConduit,
	CICM::Decrypt::NegotiatedConduit {</pre></div>
<p>CICM::Decrypt::WithMACNegotiatedConduit is the negotiated
					version of CICM::Decrypt::WithMACConduit. It is the result of a
					successful negotiation by CICM::Decrypt::WithMACNegotiator.
</p>
<a name="anchor140"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.10.9.1"></a><h3>10.9.1.&nbsp;
CICM::Decrypt::WithMACNegotiatedConduit Inheritance</h3>

<p>CICM::Decrypt::WithMACNegotiatedConduit inherits
						from: CICM::AbstractMACVerifyConduit and
						CICM::Decrypt::NegotiatedConduit.
</p>
<a name="anchor141"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.10.10"></a><h3>10.10.&nbsp;
Interface CICM::Decrypt::WithVerifyConduit</h3>

<p>Interface  CICM::Decrypt::WithVerifyConduit
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>interface WithVerifyConduit :
	CICM::AbstractSigVerifyConduit,
	CICM::Decrypt::Conduit {</pre></div>
<p>CICM::Decrypt::WithVerifyConduit supports decryption
					operations between two independent security domains with the
					receipt of an indication as to whether signature verification
					succeeded or failed in the initiating domain. The resulting conduit
					is capable of both managing the channel and accepting transformed
					data. It is created by calling
					CICM::ChannelManager::create_decrypt_with_verify_conduit.
</p>
<a name="anchor142"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.10.10.1"></a><h3>10.10.1.&nbsp;
CICM::Decrypt::WithVerifyConduit Inheritance</h3>

<p>CICM::Decrypt::WithVerifyConduit inherits from:
						CICM::AbstractSigVerifyConduit and CICM::Decrypt::Conduit.
</p>
<a name="anchor143"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.10.11"></a><h3>10.11.&nbsp;
Interface CICM::Decrypt::WithVerifyNegotiatedConduit</h3>

<p>Interface  CICM::Decrypt::WithVerifyNegotiatedConduit
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>interface WithVerifyNegotiatedConduit :
	CICM::AbstractSigVerifyConduit,
	CICM::Decrypt::NegotiatedConduit {</pre></div>
<p>CICM::Decrypt::WithVerifyNegotiatedConduit is the negotiated
					version of CICM::Decrypt::WithVerifyConduit. It is the result of a
					successful negotiation by CICM::Decrypt::WithVerifyNegotiator.
</p>
<a name="anchor144"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.10.11.1"></a><h3>10.11.1.&nbsp;
CICM::Decrypt::WithVerifyNegotiatedConduit Inheritance</h3>

<p>CICM::Decrypt::WithVerifyNegotiatedConduit inherits
						from: CICM::AbstractSigVerifyConduit and
						CICM::Decrypt::NegotiatedConduit.
</p>
<a name="anchor145"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.10.12"></a><h3>10.12.&nbsp;
Interface CICM::Decrypt::KeyUnwrapConduit</h3>

<p>Interface  CICM::Decrypt::KeyUnwrapConduit
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>interface KeyUnwrapConduit :
	CICM::Decrypt::Controller,
	CICM::Decrypt::KeyUnwrapStream {</pre></div>
<p>CICM::Decrypt::KeyUnwrapConduit supports key unwrapping
					operations between two independent security domains. The resulting
					conduit is capable of both managing the channel and accepting
					transformed keys. It is created by calling
					CICM::ChannelManager::create_key_unwrap_conduit.
</p>
<a name="anchor146"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.10.12.1"></a><h3>10.12.1.&nbsp;
CICM::Decrypt::KeyUnwrapConduit Inheritance</h3>

<p>CICM::Decrypt::KeyUnwrapConduit inherits from:
						CICM::Decrypt::Controller and CICM::Decrypt::KeyUnwrapStream.
</p>
<a name="anchor147"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.10.13"></a><h3>10.13.&nbsp;
Interface CICM::Decrypt::Negotiator</h3>

<p>Interface CICM::Decrypt::Negotiator
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>interface Negotiator : CICM::Negotiator {</pre></div>
<p>CICM::Decrypt::Negotiator initiates a negotiation to
					establish a shared key with a remote entity that is used to support
					encryption operations between two independent security domains. The
					result of a successful negotiation is a
					CICM::Decrypt::NegotiatedConduit which is capable of both managing
					the channel and accepting data for transformation.
					CICM::Decrypt::Negotiator is created by calling
					CICM::ChannelManager::negotiate_decrypt_conduit.
</p>
<a name="anchor148"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.10.13.1"></a><h3>10.13.1.&nbsp;
CICM::Decrypt::Negotiator Inheritance</h3>

<p>CICM::Decrypt::Negotiator inherits from:
						CICM::Negotiator.
</p>
<a name="anchor149"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.10.13.2"></a><h3>10.13.2.&nbsp;
CICM::Decrypt::Negotiator Methods</h3>

<p>Method CICM::Decrypt::Negotiator::complete()
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>CICM::Status complete(
	out CICM::Decrypt::NegotiatedConduit conduit_ref
);</pre></div>
<p>Complete negotiation and retrieve a negotiated decrypt
						conduit.
</p>
<p>Parameters:
							</p>
<blockquote class="text">
<p>[out] conduit_ref
								  Reference to resulting conduit.
</p>
</blockquote><p>
						
</p>
<p>Returns:
							</p>
<blockquote class="text">
<p>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_NEGOTIATION_ABORTED,
							  S_NEGOTIATION_FAILURE, S_NEGOTIATION_NOT_IN_PROGRESS,
							  S_NEGOTIATION_TIMEOUT, S_CERT_LOCAL_INVALID,
							  S_CERT_LOCAL_EXPIRED, S_CERT_REMOTE_INVALID,
							  S_CERT_REMOTE_EXPIRED, S_CERT_REMOTE_PATH, S_CHANNEL_ERROR,
							  S_CHANNEL_PEER_RESET
</p>
</blockquote><p>
						
</p>
<a name="anchor150"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.10.14"></a><h3>10.14.&nbsp;
Interface CICM::Decrypt::ControllerNegotiator</h3>

<p>Interface  CICM::Decrypt::ControllerNegotiator
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>interface ControllerNegotiator : CICM::Negotiator {</pre></div>
<p>CICM::Decrypt::ControllerNegotiator initiates a negotiation
					to establish a shared key with a remote entity that is used to
					support decryption operations between two independent security
					domains. The result of a successful negotiation is a
					CICM::Decrypt::NegotiatedController which is capable of managing
					the channel, but not accepting data for transformation.
					CICM::Decrypt::ControllerNegotiator is created by calling
					CICM::ChannelManager::negotiate_decrypt_controller.
</p>
<a name="anchor151"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.10.14.1"></a><h3>10.14.1.&nbsp;
CICM::Decrypt::ControllerNegotiator Inheritance</h3>

<p>CICM::Decrypt::ControllerNegotiator inherits from:
						CICM::Negotiator.
</p>
<a name="anchor152"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.10.14.2"></a><h3>10.14.2.&nbsp;
CICM::Decrypt::ControllerNegotiator Methods</h3>

<p>Method CICM::Decrypt::ControllerNegotiator::complete()
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>CICM::Status complete(
	out CICM::Decrypt::NegotiatedController controller_ref
);</pre></div>
<p>Complete negotiation and retrieve a negotiated control-only
						decrypt channel.
</p>
<p>Parameters:
							</p>
<blockquote class="text">
<p>[out] controller_ref
								  Reference to resulting controller.
</p>
</blockquote><p>
						
</p>
<p>Returns:
							</p>
<blockquote class="text">
<p>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_NEGOTIATION_ABORTED,
							  S_NEGOTIATION_FAILURE, S_NEGOTIATION_NOT_IN_PROGRESS,
							  S_NEGOTIATION_TIMEOUT, S_CERT_LOCAL_INVALID,
							  S_CERT_LOCAL_EXPIRED, S_CERT_REMOTE_INVALID,
							  S_CERT_REMOTE_EXPIRED, S_CERT_REMOTE_PATH, S_CHANNEL_ERROR,
							  S_CHANNEL_PEER_RESET
</p>
</blockquote><p>
						
</p>
<a name="anchor153"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.10.15"></a><h3>10.15.&nbsp;
Interface CICM::Decrypt::WithMACNegotiator</h3>

<p>Interface  CICM::Decrypt::WithMACNegotiator
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>interface WithMACNegotiator : CICM::Negotiator {</pre></div>
<p>CICM::Decrypt::WithMACNegotiator initiates a negotiation to
					establish a shared key with a remote entity that is used to support
					decryption operations between two independent security domains.
					Additionally, a message authentication code is received in the
					initiating domain. The result of a successful negotiation is a
					CICM::Decrypt::WithMACNegotiatedConduit which is capable of both
					managing the channel and accepting data for transformation.
					CICM::Decrypt::WithMACNegotiator is created by calling
					CICM::ChannelManager::negotiate_decrypt_with_mac_conduit.
</p>
<a name="anchor154"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.10.15.1"></a><h3>10.15.1.&nbsp;
CICM::Decrypt::WithMACNegotiator Inheritance</h3>

<p>CICM::Decrypt::WithMACNegotiator inherits from:
						CICM::Negotiator.
</p>
<a name="anchor155"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.10.15.2"></a><h3>10.15.2.&nbsp;
CICM::Decrypt::WithMACNegotiator Methods</h3>

<p>Method CICM::Decrypt::WithMACNegotiator::complete()
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>CICM::Status complete(
	out CICM::Decrypt::WithMACNegotiatedConduit conduit_ref
);</pre></div>
<p>Complete negotiation and retrieve a negotiated MAC verify
						decrypt conduit.
</p>
<p>Parameters:
							</p>
<blockquote class="text">
<p>[out] conduit_ref
								  Reference to resulting conduit.
</p>
</blockquote><p>
						
</p>
<p>Returns:
							</p>
<blockquote class="text">
<p>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_NEGOTIATION_ABORTED,
							  S_NEGOTIATION_FAILURE, S_NEGOTIATION_NOT_IN_PROGRESS,
							  S_NEGOTIATION_TIMEOUT, S_CERT_LOCAL_INVALID,
							  S_CERT_LOCAL_EXPIRED, S_CERT_REMOTE_INVALID,
							  S_CERT_REMOTE_EXPIRED, S_CERT_REMOTE_PATH, S_CHANNEL_ERROR,
							  S_CHANNEL_PEER_RESET
</p>
</blockquote><p>
						
</p>
<a name="anchor156"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.10.16"></a><h3>10.16.&nbsp;
Interface CICM::Decrypt::WithVerifyNegotiator</h3>

<p>Interface  CICM::Decrypt::WithVerifyNegotiator
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>interface WithVerifyNegotiator : CICM::Negotiator {</pre></div>
<p>CICM::Decrypt::WithVerifyNegotiator initiates a negotiation
					to establish a shared key with a remote entity that is used to
					support decryption operations between two independent security
					domains. Additionally, an indication as to whether verification
					succeeded or failed is received in the initiating domain. The
					result of a successful negotiation is a
					CICM::Decrypt::WithVerifyNegotiatedConduit which is capable of both
					managing the channel and accepting data for transformation.
					CICM::Decrypt::WithVerifyNegotiator is created by calling
					CICM::ChannelManager::negotiate_decrypt_with_verify_conduit.
</p>
<a name="anchor157"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.10.16.1"></a><h3>10.16.1.&nbsp;
CICM::Decrypt::WithVerifyNegotiator Inheritance</h3>

<p>CICM::Decrypt::WithVerifyNegotiator inherits from:
						CICM::Negotiator.
</p>
<a name="anchor158"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.10.16.2"></a><h3>10.16.2.&nbsp;
CICM::Decrypt::WithVerifyNegotiator Methods</h3>

<p>Method CICM::Decrypt::WithVerifyNegotiator::complete()
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>CICM::Status complete(
	out CICM::Decrypt::WithVerifyNegotiatedConduit conduit_ref
);</pre></div>
<p>Complete negotiation and retrieve a negotiated verify and
						decrypt conduit.
</p>
<p>Parameters:
							</p>
<blockquote class="text">
<p>[out] conduit_ref
								  Reference to resulting conduit.
</p>
</blockquote><p>
						
</p>
<p>Returns:
							</p>
<blockquote class="text">
<p>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_NEGOTIATION_ABORTED,
							  S_NEGOTIATION_FAILURE, S_NEGOTIATION_NOT_IN_PROGRESS,
							  S_NEGOTIATION_TIMEOUT, S_CERT_LOCAL_INVALID,
							  S_CERT_LOCAL_EXPIRED, S_CERT_REMOTE_INVALID,
							  S_CERT_REMOTE_EXPIRED, S_CERT_REMOTE_PATH, S_CHANNEL_ERROR,
							  S_CHANNEL_PEER_RESET
</p>
</blockquote><p>
						
</p>
<a name="sec-duplex"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.11"></a><h3>11.&nbsp;
Duplex</h3>

<p>Namespace CICM::Duplex
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>module Duplex {</pre></div>
<p>The CICM::Duplex namespace contains interfaces that support
				encryption/decryption operations between two independent security
				domains.
</p>
<a name="anchor159"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.11.1"></a><h3>11.1.&nbsp;
Interface CICM::Duplex::ChannelManager</h3>

<p>Interface  CICM::Duplex::ChannelManager
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>interface ChannelManager {</pre></div>
<p>CICM::Duplex::ChannelManager is an abstraction inherited by
					CICM::ChannelManager that supports the creation of
					encryption/decryption negotiators, conduits, controllers, and
					streams. See CICM::ChannelManager for additional information.
</p>
<a name="anchor160"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.11.1.1"></a><h3>11.1.1.&nbsp;
CICM::Duplex::ChannelManager Methods</h3>

<p>Method CICM::Duplex::ChannelManager::negotiate_duplex_conduit()
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>CICM::Status negotiate_duplex_conduit(
	in  CICM::RemotePort remote_port,
	in  CICM::ProtocolId protocol,
	in  CICM::AsymKey key_ref,
	out CICM::Duplex::Negotiator negotiator_ref
);</pre></div>
<p>Initiate a negotiation to establish a shared key with a peer,
						resulting in a conduit that results will encrypt/decrypt data.
</p>
<p>Parameters:
							</p>
<blockquote class="text">
<p>[in] remote_port
								  Remote port.
</p>
<p>[in] protocol
								  Protocol identifier.
</p>
<p>[in] key_ref
								  Reference to negotiation key.
</p>
<p>[out] negotiator_ref
								  Reference to resulting negotiator.
</p>
</blockquote><p>
						
</p>
<p>Returns:
							</p>
<blockquote class="text">
<p>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_USED_INVALID,
							  S_KEY_USED_EXPIRED, S_KEY_USED_WRAPPED, S_KEY_USED_CONTEXT,
							  S_KEY_USED_COMPONENT_NOT_AVAIL, S_KEY_INVALID, S_KEY_EXPIRED,
							  S_REMOTE_PORT_INVALID, S_REMOTE_PORT_IN_USE,
							  S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT,
							  S_NEGOTIATION_ABORTED, S_NEGOTIATION_FAILURE,
							  S_NEGOTIATION_IN_PROGRESS, S_NEGOTIATION_TIMEOUT,
							  S_CERT_LOCAL_INVALID, S_CERT_LOCAL_EXPIRED,
							  S_CERT_REMOTE_INVALID, S_CERT_REMOTE_EXPIRED,
							  S_CERT_REMOTE_PATH, S_PROTO_INVALID, S_PROTO_INCOMPATIBLE,
							  S_PROTO_UNDETERMINED, S_CHANNEL_ERROR, S_CHANNEL_MAX
</p>
</blockquote><p>
						
</p>
<p>Method CICM::Duplex::ChannelManager::negotiate_duplex_controller()
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>CICM::Status negotiate_duplex_controller(
	in  CICM::LocalPort local_port,
	in  CICM::RemotePort remote_port,
	in  CICM::ProtocolId protocol,
	in  CICM::AsymKey key_ref,
	out CICM::Duplex::ControllerNegotiator negotiator_ref
);</pre></div>
<p>Initiate a negotiation to establish a shared key with a peer,
						resulting in a controller to manage a duplex channel.
</p>
<p>Parameters:
							</p>
<blockquote class="text">
<p>[in] local_port
								  Local port.
</p>
<p>[in] remote_port
								  Remote port.
</p>
<p>[in] protocol
								  Protocol identifier.
</p>
<p>[in] key_ref
								  Reference to negotiation key.
</p>
<p>[out] negotiator_ref
								  Reference to resulting negotiator.
</p>
</blockquote><p>
						
</p>
<p>Returns:
							</p>
<blockquote class="text">
<p>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_USED_INVALID,
							  S_KEY_USED_EXPIRED, S_KEY_USED_WRAPPED, S_KEY_USED_CONTEXT,
							  S_KEY_USED_COMPONENT_NOT_AVAIL, S_KEY_INVALID, S_KEY_EXPIRED,
							  S_LOCAL_PORT_INVALID, S_LOCAL_PORT_INCOMPATIBLE,
							  S_LOCAL_PORT_IN_USE, S_REMOTE_PORT_INVALID,
							  S_REMOTE_PORT_IN_USE, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_NEGOTIATION_ABORTED,
							  S_NEGOTIATION_FAILURE, S_NEGOTIATION_IN_PROGRESS,
							  S_NEGOTIATION_TIMEOUT, S_CERT_LOCAL_INVALID,
							  S_CERT_LOCAL_EXPIRED, S_CERT_REMOTE_INVALID,
							  S_CERT_REMOTE_EXPIRED, S_CERT_REMOTE_PATH, S_PROTO_INVALID,
							  S_PROTO_INCOMPATIBLE, S_PROTO_UNDETERMINED, S_CHANNEL_ERROR,
							  S_CHANNEL_MAX
</p>
</blockquote><p>
						
</p>
<p>Method CICM::Duplex::ChannelManager::create_duplex_conduit()
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>CICM::Status create_duplex_conduit(
	in  CICM::RemotePort remote_port,
	in  CICM::SymKey key_ref,
	in  CICM::SymEncrAlgorithmId algorithm,
	out CICM::Duplex::Conduit conduit_ref
);</pre></div>
<p>Create duplex channel to encrypt/decrypt a stream of
						data.
</p>
<p>Parameters:
							</p>
<blockquote class="text">
<p>[in] remote_port
								  Remote port.
</p>
<p>[in] key_ref
								  Reference to decryption key.
</p>
<p>[in] algorithm
								  Encryption/decryption algorithm/mode.
</p>
<p>[out] conduit_ref
								  Reference to resulting conduit.
</p>
</blockquote><p>
						
</p>
<p>Returns:
							</p>
<blockquote class="text">
<p>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_USED_INVALID,
							  S_KEY_USED_EXPIRED, S_KEY_USED_WRAPPED, S_KEY_USED_CONTEXT,
							  S_KEY_INVALID, S_KEY_EXPIRED, S_REMOTE_PORT_INVALID,
							  S_REMOTE_PORT_IN_USE, S_ALGO_INVALID, S_ALGO_INCOMPATIBLE,
							  S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT,
							  S_CHANNEL_ERROR, S_CHANNEL_MAX
</p>
</blockquote><p>
						
</p>
<p>Method CICM::Duplex::ChannelManager::create_duplex_controller()
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>CICM::Status create_duplex_controller(
	in  CICM::LocalPort local_port,
	in  CICM::RemotePort remote_port,
	in  CICM::SymKey key_ref,
	in  CICM::SymEncrAlgorithmId algorithm,
	out CICM::Duplex::Controller controller_ref
);</pre></div>
<p>Create controller to configure and control a duplex
						channel.
</p>
<p>Remarks:
							</p>
<blockquote class="text">
<p>In some cases, hosts may depend upon separate processes to
							control and use a channel. This method returns the channel
							controller and must be called before the corresponding stream
							is retrieved.
</p>
</blockquote><p>
						
</p>
<p>Parameters:
							</p>
<blockquote class="text">
<p>[in] local_port
								  Local port.
</p>
<p>[in] remote_port
								  Remote port.
</p>
<p>[in] key_ref
								  Reference to negotiation key.
</p>
<p>[in] algorithm
								  Encryption/decryption algorithm/mode.
</p>
<p>[out] controller_ref
								  Reference to resulting controller.
</p>
</blockquote><p>
						
</p>
<p>Returns:
							</p>
<blockquote class="text">
<p>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_USED_INVALID,
							  S_KEY_USED_EXPIRED, S_KEY_USED_WRAPPED, S_KEY_USED_CONTEXT,
							  S_KEY_INVALID, S_KEY_EXPIRED, S_LOCAL_PORT_INVALID,
							  S_LOCAL_PORT_INCOMPATIBLE, S_LOCAL_PORT_IN_USE,
							  S_REMOTE_PORT_INVALID, S_REMOTE_PORT_IN_USE, S_ALGO_INVALID,
							  S_ALGO_INCOMPATIBLE, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR,
							  S_CHANNEL_MAX
</p>
</blockquote><p>
						
</p>
<p>Method CICM::Duplex::ChannelManager::get_duplex_stream()
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>CICM::Status get_duplex_stream(
	in  CICM::LocalPort local_port,
	out CICM::Duplex::Stream stream_ref
);</pre></div>
<p>Create stream associated with previously created controller
						to accept data for transformation.
</p>
<p>Parameters:
							</p>
<blockquote class="text">
<p>[in] local_port
								  Local port.
</p>
<p>[out] stream_ref
								  Reference to resulting stream.
</p>
</blockquote><p>
						
</p>
<p>Returns:
							</p>
<blockquote class="text">
<p>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_INVALID,
							  S_KEY_EXPIRED, S_LOCAL_PORT_INVALID,
							  S_LOCAL_PORT_INCOMPATIBLE, S_LOCAL_PORT_IN_USE,
							  S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT,
							  S_CHANNEL_ERROR, S_CHANNEL_PEER_RESET,
							  S_CHANNEL_NOT_FOUND
</p>
</blockquote><p>
						
</p>
<a name="anchor161"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.11.2"></a><h3>11.2.&nbsp;
Interface CICM::Duplex::Stream</h3>

<p>Interface CICM::Duplex::Stream
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>interface Stream :
	CICM::Encrypt::Stream,
	CICM::Decrypt::Stream {</pre></div>
<p>CICM::Duplex::Stream supports encryption/decryption
					operations between two independent security domains. The resulting
					stream is capable of accepting data for transformation and
					receiving transformed data, but not managing the channel. It is
					created by calling CICM::ChannelManager::get_duplex_stream.
</p>
<a name="anchor162"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.11.2.1"></a><h3>11.2.1.&nbsp;
CICM::Duplex::Stream Inheritance</h3>

<p>CICM::Duplex::Stream
						inherits from: CICM::Encrypt::Stream and
						CICM::Decrypt::Stream.
</p>
<a name="anchor163"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.11.3"></a><h3>11.3.&nbsp;
Interface CICM::Duplex::Controller</h3>

<p>Interface CICM::Duplex::Controller
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>interface Controller :
	CICM::Encrypt::Controller,
	CICM::Decrypt::Controller {</pre></div>
<p>CICM::Duplex::Controller supports encryption/decryption
					operations between two independent security domains. The resulting
					controller is capable of managing the channel, but not accepting
					data for transformation and receiving transformed data. It is
					created by calling CICM::ChannelManager::create_duplex_controller.
</p>
<a name="anchor164"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.11.3.1"></a><h3>11.3.1.&nbsp;
CICM::Duplex::Controller Inheritance</h3>

<p>CICM::Duplex::Controller inherits from:
						CICM::Encrypt::Controller and CICM::Decrypt::Controller.
</p>
<a name="anchor165"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.11.4"></a><h3>11.4.&nbsp;
Interface CICM::Duplex::NegotiatedController</h3>

<p>Interface  CICM::Duplex::NegotiatedController
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>interface NegotiatedController :
	CICM::Encrypt::NegotiatedController,
	CICM::Decrypt::NegotiatedController {</pre></div>
<p>CICM::Duplex::NegotiatedController is the negotiated version
					of CICM::Duplex::Controller. It is the result of a successful
					negotiation by CICM::Duplex::ControllerNegotiator.
</p>
<a name="anchor166"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.11.4.1"></a><h3>11.4.1.&nbsp;
CICM::Duplex::NegotiatedController Inheritance</h3>

<p>CICM::Duplex::NegotiatedController inherits from:
						CICM::Encrypt::NegotiatedController and
						CICM::Decrypt::NegotiatedController.
</p>
<a name="anchor167"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.11.5"></a><h3>11.5.&nbsp;
Interface CICM::Duplex::Conduit</h3>

<p>Interface CICM::Duplex::Conduit
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>interface Conduit :
	CICM::Conduit,
	CICM::Duplex::Controller,
	CICM::Duplex::Stream {</pre></div>
<p>CICM::Duplex::Conduit supports encryption/decryption
					operations between two independent security domains. The resulting
					conduit is capable of both managing the channel and accepting data
					for transformation and receiving transformed data. It is created by
					calling CICM::ChannelManager::create_duplex_conduit.
</p>
<a name="anchor168"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.11.5.1"></a><h3>11.5.1.&nbsp;
CICM::Duplex::Conduit Inheritance</h3>

<p>CICM::Duplex::Conduit
						inherits from: CICM::Conduit, CICM::Duplex::Controller and
						CICM::Duplex::Stream.
</p>
<a name="anchor169"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.11.6"></a><h3>11.6.&nbsp;
Interface CICM::Duplex::NegotiatedConduit</h3>

<p>Interface  CICM::Duplex::NegotiatedConduit
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>interface NegotiatedConduit :
	CICM::Duplex::NegotiatedController,
	CICM::Duplex::Stream {</pre></div>
<p>CICM::Duplex::NegotiatedConduit is the negotiated version of
					CICM::Duplex::Conduit. It is the result of a successful negotiation
					by CICM::Duplex::Negotiator.
</p>
<a name="anchor170"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.11.6.1"></a><h3>11.6.1.&nbsp;
CICM::Duplex::NegotiatedConduit Inheritance</h3>

<p>CICM::Duplex::NegotiatedConduit inherits from:
						CICM::Duplex::NegotiatedController and CICM::Duplex::Stream.
</p>
<a name="anchor171"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.11.7"></a><h3>11.7.&nbsp;
Interface CICM::Duplex::ControllerNegotiator</h3>

<p>Interface  CICM::Duplex::ControllerNegotiator
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>interface ControllerNegotiator : CICM::Negotiator {</pre></div>
<p>CICM::Duplex::ControllerNegotiator initiates a negotiation to
					establish a shared key with a remote entity that is used to support
					encryption/decryption operations between two independent security
					domains. The result of a successful negotiation is a
					CICM::Duplex::NegotiatedController which is capable of managing the
					channel, but not accepting data for transformation.
					CICM::Duplex::ControllerNegotiator is created by calling
					CICM::ChannelManager::negotiate_duplex_controller.
</p>
<a name="anchor172"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.11.7.1"></a><h3>11.7.1.&nbsp;
CICM::Duplex::ControllerNegotiator Inheritance</h3>

<p>CICM::Duplex::ControllerNegotiator inherits from:
						CICM::Negotiator.
</p>
<a name="anchor173"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.11.7.2"></a><h3>11.7.2.&nbsp;
CICM::Duplex::ControllerNegotiator Methods</h3>

<p>Method CICM::Duplex::ControllerNegotiator::complete()
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>CICM::Status complete(
	out CICM::Duplex::NegotiatedController controller_ref
);</pre></div>
<p>Complete negotiation and retrieve a negotiated control-only
						duplex conduit.
</p>
<p>Parameters:
							</p>
<blockquote class="text">
<p>[out] controller_ref
								  Reference to resulting controller.
</p>
</blockquote><p>
						
</p>
<p>Returns:
							</p>
<blockquote class="text">
<p>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_NEGOTIATION_ABORTED,
							  S_NEGOTIATION_FAILURE, S_NEGOTIATION_NOT_IN_PROGRESS,
							  S_NEGOTIATION_TIMEOUT, S_CERT_LOCAL_INVALID,
							  S_CERT_LOCAL_EXPIRED, S_CERT_REMOTE_INVALID,
							  S_CERT_REMOTE_EXPIRED, S_CERT_REMOTE_PATH, S_CHANNEL_ERROR,
							  S_CHANNEL_PEER_RESET
</p>
</blockquote><p>
						
</p>
<a name="anchor174"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.11.8"></a><h3>11.8.&nbsp;
Interface CICM::Duplex::Negotiator</h3>

<p>Interface CICM::Duplex::Negotiator
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>interface Negotiator : CICM::Negotiator {</pre></div>
<p>CICM::Duplex::Negotiator initiates a negotiation to establish
					a shared key with a remote entity that is used to support
					encryption/decryption operations between two independent security
					domains. The result of a successful negotiation is a
					CICM::Duplex::NegotiatedConduit which is capable of both managing
					the channel and accepting data for transformation.
					CICM::Duplex::Negotiator is created by calling
					CICM::ChannelManager::negotiate_duplex_conduit.
</p>
<a name="anchor175"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.11.8.1"></a><h3>11.8.1.&nbsp;
CICM::Duplex::Negotiator Inheritance</h3>

<p>CICM::Duplex::Negotiator inherits from:
						CICM::Negotiator.
</p>
<a name="anchor176"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.11.8.2"></a><h3>11.8.2.&nbsp;
CICM::Duplex::Negotiator Methods</h3>

<p>Method CICM::Duplex::Negotiator::complete()
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre> CICM::Status complete(
	out CICM::Duplex::NegotiatedConduit conduit_ref
);</pre></div>
<p>Complete negotiation and retrieve a negotiated duplex
						channel.
</p>
<p>Parameters:
							</p>
<blockquote class="text">
<p>[out] conduit_ref
								  Reference to resulting channel.
</p>
</blockquote><p>
						
</p>
<p>Returns:
							</p>
<blockquote class="text">
<p>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_NEGOTIATION_ABORTED,
							  S_NEGOTIATION_FAILURE, S_NEGOTIATION_NOT_IN_PROGRESS,
							  S_NEGOTIATION_TIMEOUT, S_CERT_LOCAL_INVALID,
							  S_CERT_LOCAL_EXPIRED, S_CERT_REMOTE_INVALID,
							  S_CERT_REMOTE_EXPIRED, S_CERT_REMOTE_PATH, S_CHANNEL_ERROR,
							  S_CHANNEL_PEER_RESET
</p>
</blockquote><p>
						
</p>
<a name="sec-bypass-write"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.12"></a><h3>12.&nbsp;
Bypass (Send)</h3>

<p>Namespace CICM::BypassWrite
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>module BypassWrite {</pre></div>
<p>The CICM::BypassWrite namespace contains channels that
				support full bypass write operations between two independent
				security domains.
</p>
<a name="anchor177"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.12.1"></a><h3>12.1.&nbsp;
Interface CICM::BypassWrite::ChannelManager</h3>

<p>Interface  CICM::BypassWrite::ChannelManager
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>interface ChannelManager {</pre></div>
<p>CICM::BypassWrite::ChannelManager is an abstraction inherited
					by CICM::ChannelManager that supports the creation of full bypass
					conduits, controllers, and streams for writing. See
					CICM::ChannelManager for additional information.
</p>
<a name="anchor178"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.12.1.1"></a><h3>12.1.1.&nbsp;
CICM::BypassWrite::ChannelManager Methods</h3>

<p>Method CICM::BypassWrite::ChannelManager::create_bypass_write_conduit()
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>CICM::Status create_bypass_write_conduit(
	in  CICM::RemotePort remote_port,
	out CICM::BypassWrite::Conduit conduit_ref
);</pre></div>
<p>Creates a conduit to write bypass data.
</p>
<p>Parameters:
							</p>
<blockquote class="text">
<p>[in] remote_port
								  Remote port.
</p>
<p>[out] conduit_ref
								  Reference to resulting conduit.
</p>
</blockquote><p>
						
</p>
<p>Returns:
							</p>
<blockquote class="text">
<p>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_INVALID,
							  S_KEY_EXPIRED, S_REMOTE_PORT_INVALID, S_REMOTE_PORT_IN_USE,
							  S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT,
							  S_CHANNEL_ERROR, S_CHANNEL_MAX
</p>
</blockquote><p>
						
</p>
<p>Method CICM::BypassWrite::ChannelManager::create_bypass_write_controller()
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>CICM::Status create_bypass_write_controller(
	in  CICM::LocalPort local_port,
	in  CICM::RemotePort remote_port,
	out CICM::BypassWrite::Controller controller_ref
);</pre></div>
<p>Returns the controller of a channel that writes bypass
						data.
</p>
<p>Remarks:
							</p>
<blockquote class="text">
<p>In some cases, hosts may depend upon separate processes to
							control and use a channel. This method returns the channel
							controller and must be called before the corresponding stream
							is retrieved.
</p>
</blockquote><p>
						
</p>
<p>See also:
							</p>
<blockquote class="text">
<p>CICM::BypassWrite::ChannelManager::get_bypass_write_stream
								for the method that returns the channel stream.
</p>
</blockquote><p>
						
</p>
<p>Parameters:
							</p>
<blockquote class="text">
<p>[in] local_port
								  Local port.
</p>
<p>[in] remote_port
								  Remote port.
</p>
<p>[out] controller_ref
								  Reference to resulting controller.
</p>
</blockquote><p>
						
</p>
<p>Returns:
							</p>
<blockquote class="text">
<p>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_INVALID,
							  S_KEY_EXPIRED, S_LOCAL_PORT_INVALID,
							  S_LOCAL_PORT_INCOMPATIBLE, S_LOCAL_PORT_IN_USE,
							  S_REMOTE_PORT_INVALID, S_REMOTE_PORT_IN_USE,
							  S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT,
							  S_CHANNEL_ERROR, S_CHANNEL_MAX
</p>
</blockquote><p>
						
</p>
<p>Method CICM::BypassWrite::ChannelManager::get_bypass_write_stream()
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>CICM::Status get_bypass_write_stream(
	in  CICM::LocalPort local_port,
	out CICM::BypassWrite::Stream stream_ref
);</pre></div>
<p>Returns the stream corresponding to a pre-existing controller
						on the given local port.
</p>
<p>See also:
							</p>
<blockquote class="text">
<p>CICM::BypassWrite::ChannelManager::create_bypass_write_controller
								for the method that returns the channel controller.
</p>
</blockquote><p>
						
</p>
<p>Parameters:
							</p>
<blockquote class="text">
<p>[in] local_port
								  Local port.
</p>
<p>[out] stream_ref
								  Reference to resulting stream.
</p>
</blockquote><p>
						
</p>
<p>Returns:
							</p>
<blockquote class="text">
<p>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_INVALID,
							  S_KEY_EXPIRED, S_LOCAL_PORT_INVALID,
							  S_LOCAL_PORT_INCOMPATIBLE, S_LOCAL_PORT_IN_USE,
							  S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT,
							  S_CHANNEL_ERROR, S_CHANNEL_PEER_RESET,
							  S_CHANNEL_NOT_FOUND
</p>
</blockquote><p>
						
</p>
<a name="anchor179"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.12.2"></a><h3>12.2.&nbsp;
Interface CICM::BypassWrite::Stream</h3>

<p>Interface CICM::BypassWrite::Stream
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>interface Stream : CICM::WriteStream {</pre></div>
<p>CICM::BypassWrite::Stream supports full bypass between two
					independent security domains. The resulting stream is capable of
					accepting data for bypass, but not managing the channel. It is
					created by calling CICM::ChannelManager::get_bypass_write_stream.
</p>
<a name="anchor180"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.12.2.1"></a><h3>12.2.1.&nbsp;
CICM::BypassWrite::Stream Inheritance</h3>

<p>CICM::BypassWrite::Stream inherits from: CICM::WriteStream.
</p>
<a name="anchor181"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.12.2.2"></a><h3>12.2.2.&nbsp;
CICM::BypassWrite::Stream Methods</h3>

<p>Method CICM::BypassWrite::Stream::write_bypass()
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>CICM::Status write_bypass(
	in  CICM::Buffer buffer
);</pre></div>
<p>Write bypass data to a channel stream. The method blocks
						until the data has been sent.
</p>
<p>Parameters:
							</p>
<blockquote class="text">
<p>[in] buffer
								  Data to bypass.
</p>
</blockquote><p>
						
</p>
<p>Returns:
							</p>
<blockquote class="text">
<p>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_INVALID,
							  S_KEY_EXPIRED, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR,
							  S_CHANNEL_PEER_RESET, S_CHANNEL_IO_ERROR,
							  S_CHANNEL_DATA_INVALID, S_CHANNEL_DATA_INVALID_LEN,
							  S_BYPASS_DATARATE_EXCEEDED,
							  S_BYPASS_DATALIMIT_EXCEEDED
</p>
</blockquote><p>
						
</p>
<p>Method CICM::BypassWrite::Stream::write_bypass_non_blocking()
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>CICM::Status write_bypass_non_blocking(
	in  CICM::Buffer buffer,
	in  CICM::TransId transaction_id
);</pre></div>
<p>Registers a buffer of data to be sent to the module for
						bypass and then immediately returns control to the caller. The
						length of the data is encapsulated in the buffer parameter. The
						caller may use the CICM::BypassWrite::Stream::write_bypass_poll
						method to proactively poll the channel to determine the status of
						the operation. The caller is responsible for maintaining any
						necessary metadata associated with the transaction_id parameter.
						Memory responsibilities and calling conventions shall follow the
						appropriate IDL language mapping conventions.
</p>
<p>Parameters:
							</p>
<blockquote class="text">
<p>[in] buffer
								  Data to bypass.
</p>
<p>[in] transaction_id
								  Unique transaction id that will be used by the
								  CICM::BypassWrite::Stream::write_bypass_poll method to
								  determine to which buffer the poll status applies.
</p>
</blockquote><p>
						
</p>
<p>Returns:
							</p>
<blockquote class="text">
<p>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_INVALID,
							  S_KEY_EXPIRED, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR,
							  S_CHANNEL_PEER_RESET, S_CHANNEL_IO_ERROR,
							  S_CHANNEL_DATA_INVALID, S_CHANNEL_DATA_INVALID_LEN,
							  S_BYPASS_DATARATE_EXCEEDED,
							  S_BYPASS_DATALIMIT_EXCEEDED
</p>
</blockquote><p>
						
</p>
<p>Method CICM::BypassWrite::Stream::write_bypass_poll()
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>CICM::Status write_bypass_poll(
	in  CICM::TransId transaction_id,
	out CICM::WriteStream::WriteStatus status
);</pre></div>
<p>Returns the status of the non-blocking bypass operation
						specified by the transaction_id parameter. Memory responsibilities
						and calling conventions shall follow the appropriate IDL language
						mapping conventions.
</p>
<p>Parameters:
							</p>
<blockquote class="text">
<p>[in] transaction_id
								  Unique transaction id previously specified to the
								  CICM::BypassWrite::Stream::write_bypass_non_blocking
								  method that allows the poll operation to determine to
								  which buffer the poll status applies.
</p>
<p>[out] status
								  Status of the non-blocking operation corresponding to
								  the transaction_id parameter.
</p>
</blockquote><p>
						
</p>
<p>Returns:
							</p>
<blockquote class="text">
<p>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_INVALID,
							  S_KEY_EXPIRED, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR,
							  S_CHANNEL_PEER_RESET, S_CHANNEL_IO_ERROR
</p>
</blockquote><p>
						
</p>
<a name="anchor182"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.12.3"></a><h3>12.3.&nbsp;
Interface CICM::BypassWrite::Controller</h3>

<p>Interface  CICM::BypassWrite::Controller
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>interface Controller : CICM::MultiDomainController {};</pre></div>
<p>CICM::BypassWrite::Controller supports full bypass between
					two independent security domains. The resulting controller is
					capable of managing the channel, but not accepting data for bypass.
					It is created by calling
					CICM::ChannelManager::create_bypass_write_controller.
</p>
<a name="anchor183"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.12.3.1"></a><h3>12.3.1.&nbsp;
CICM::BypassWrite::Controller Inheritance</h3>

<p>CICM::BypassWrite::Controller inherits from: CICM::MultiDomainController.
</p>
<a name="anchor184"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.12.4"></a><h3>12.4.&nbsp;
Interface CICM::BypassWrite::Conduit</h3>

<p>Interface CICM::BypassWrite::Conduit
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>interface Conduit :
	CICM::Conduit,
	CICM::BypassWrite::Controller,
	CICM::BypassWrite::Stream {</pre></div>
<p>CICM::BypassWrite::Conduit supports full bypass between two
					security domains. The resulting conduit is capable of both managing
					the channel and accepting data for bypass. It is created by calling
					CICM::ChannelManager::create_bypass_write_conduit.
</p>
<a name="anchor185"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.12.4.1"></a><h3>12.4.1.&nbsp;
CICM::BypassWrite::Conduit Inheritance</h3>

<p>CICM::BypassWrite::Conduit inherits from:
						CICM::Conduit, CICM::BypassWrite::Controller and
						CICM::BypassWrite::Stream.
</p>
<a name="sec-bypass-read"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.13"></a><h3>13.&nbsp;
Bypass (Read)</h3>

<p>Namespace CICM::BypassRead
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>module BypassRead {</pre></div>
<p>The CICM::BypassRead namespace contains channels that support
				full bypass read operations between two independent security
				domains.
</p>
<a name="anchor186"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.13.1"></a><h3>13.1.&nbsp;
Interface CICM::BypassRead::ChannelManager</h3>

<p>Interface  CICM::BypassRead::ChannelManager
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>interface ChannelManager {</pre></div>
<p>CICM::BypassRead::ChannelManager is an abstraction inherited
					by CICM::ChannelManager that supports the creation of full bypass
					conduits, controllers, and streams for reading. See
					CICM::ChannelManager for additional information.
</p>
<a name="anchor187"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.13.1.1"></a><h3>13.1.1.&nbsp;
CICM::BypassRead::ChannelManager Methods</h3>

<p>Method CICM::BypassRead::ChannelManager::create_bypass_read_conduit()
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>CICM::Status create_bypass_read_conduit(
	in  CICM::RemotePort remote_port,
	out CICM::BypassRead::Conduit conduit_ref
);</pre></div>
<p>Creates a conduit to read bypass data.
</p>
<p>Parameters:
							</p>
<blockquote class="text">
<p>[in] remote_port
								  Remote port.
</p>
<p>[out] conduit_ref
								  Reference to resulting conduit.
</p>
</blockquote><p>
						
</p>
<p>Returns:
							</p>
<blockquote class="text">
<p>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_INVALID,
							  S_KEY_EXPIRED, S_REMOTE_PORT_INVALID, S_REMOTE_PORT_IN_USE,
							  S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT,
							  S_CHANNEL_ERROR, S_CHANNEL_MAX
</p>
</blockquote><p>
						
</p>
<p>Method CICM::BypassRead::ChannelManager::create_bypass_read_controller()
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>CICM::Status create_bypass_read_controller(
	in  CICM::LocalPort local_port,
	in  CICM::RemotePort remote_port,
	out CICM::BypassRead::Controller controller_ref
);</pre></div>
<p>Returns the controller of a channel that reads bypass data.
</p>
<p>Remarks:
							</p>
<blockquote class="text">
<p>In some cases, hosts may depend upon separate processes to
							control and use a channel. This method returns the channel
							controller and must be called before the corresponding stream
							is retrieved.
</p>
</blockquote><p>
						
</p>
<p>See also:
							</p>
<blockquote class="text">
<p>CICM::BypassRead::ChannelManager::get_bypass_read_stream
							for the method that returns the channel stream.
</p>
</blockquote><p>
						
</p>
<p>Parameters:
							</p>
<blockquote class="text">
<p>[in] local_port
								  Local port.
</p>
<p>[in] remote_port
								  Remote port.
</p>
<p>[out] controller_ref
								  Reference to resulting controller.
</p>
</blockquote><p>
						
</p>
<p>Returns:
							</p>
<blockquote class="text">
<p>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_INVALID,
							  S_KEY_EXPIRED, S_LOCAL_PORT_INVALID,
							  S_LOCAL_PORT_INCOMPATIBLE, S_LOCAL_PORT_IN_USE,
							  S_REMOTE_PORT_INVALID, S_REMOTE_PORT_IN_USE,
							  S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT,
							  S_CHANNEL_ERROR, S_CHANNEL_MAX
</p>
</blockquote><p>
						
</p>
<p>Method CICM::BypassRead::ChannelManager::get_bypass_read_stream()
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>CICM::Status get_bypass_read_stream(
	in  CICM::LocalPort local_port,
	out CICM::BypassRead::Stream stream_ref
);</pre></div>
<p>Returns the stream corresponding to a pre-existing controller
						on the given local port.
</p>
<p>See also:
							</p>
<blockquote class="text">
<p>CICM::BypassRead::ChannelManager::get_bypass_read_controller
							for the method that returns the channel controller.
</p>
</blockquote><p>
						
</p>
<p>Parameters:
							</p>
<blockquote class="text">
<p>[in] local_port
								  Local port.
</p>
<p>[out] stream_ref
								  Reference to resulting stream.
</p>
</blockquote><p>
						
</p>
<p>Returns:
							</p>
<blockquote class="text">
<p>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_INVALID,
							  S_KEY_EXPIRED, S_LOCAL_PORT_INVALID,
							  S_LOCAL_PORT_INCOMPATIBLE, S_LOCAL_PORT_IN_USE,
							  S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT,
							  S_CHANNEL_ERROR, S_CHANNEL_PEER_RESET,
							  S_CHANNEL_NOT_FOUND
</p>
</blockquote><p>
						
</p>
<a name="anchor188"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.13.2"></a><h3>13.2.&nbsp;
Interface CICM::BypassRead::Stream</h3>

<p>Interface CICM::BypassRead::Stream
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>interface Stream : CICM::ReadStream {</pre></div>
<p>CICM::BypassRead::Stream supports full bypass between two
					independent security domains. The resulting stream is capable of
					accepting bypassed data, but not managing the channel. It is
					created by calling CICM::ChannelManager::get_bypass_read_stream.
</p>
<a name="anchor189"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.13.2.1"></a><h3>13.2.1.&nbsp;
CICM::BypassRead::Stream Inheritance</h3>

<p>CICM::BypassRead::Stream inherits from: CICM::ReadStream.
</p>
<a name="anchor190"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.13.2.2"></a><h3>13.2.2.&nbsp;
CICM::BypassRead::Stream Methods</h3>

<p>Method CICM::BypassRead::Stream::read_bypass()
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>CICM::Status read_bypass(
	out CICM::Buffer buffer
);</pre></div>
<p>Read bypass data off of channel stream. The method blocks
						until data becomes available.
</p>
<p>Parameters:
							</p>
<blockquote class="text">
<p>[out] buffer
								  Bypassed data read from module.
</p>
</blockquote><p>
						
</p>
<p>Returns:
							</p>
<blockquote class="text">
<p>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_INVALID,
							  S_KEY_EXPIRED, S_KEY_WRAPPED, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR,
							  S_CHANNEL_PEER_RESET, S_CHANNEL_IO_ERROR,
							  S_CHANNEL_BUFFER_LEN
</p>
</blockquote><p>
						
</p>
<p>Method CICM::BypassRead::Stream::read_bypass_non_blocking()
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>CICM::Status read_bypass_non_blocking(
	out CICM::Buffer buffer,
	in  CICM::TransId transaction_id
);</pre></div>
<p>Registers a buffer into which bypass data will be copied, and
						then immediately returns control to the caller. The size of the
						allocated buffer and length of the resulting bypassed data is
						encapsulated in the buffer parameter. The caller may use the
						CICM::BypassRead::Stream::read_bypass_poll method to proactively
						poll the channel to determine the status of the operation. The
						caller is responsible for maintaining any necessary metadata
						associated with the transaction_id parameter. Memory
						responsibilities and calling conventions shall follow the
						appropriate IDL language mapping conventions.
</p>
<p>Parameters:
							</p>
<blockquote class="text">
<p>[out] buffer
								  Bypassed data to read.
</p>
<p>[in] transaction_id
								  Unique transaction id that will be used by the
								  CICM::BypassRead::Stream::read_bypass_poll method to
								  determine to which buffer the poll status applies.
</p>
</blockquote><p>
						
</p>
<p>Returns:
							</p>
<blockquote class="text">
<p>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_INVALID,
							  S_KEY_EXPIRED, S_KEY_WRAPPED, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR,
							  S_CHANNEL_PEER_RESET, S_CHANNEL_IO_ERROR,
							  S_CHANNEL_BUFFER_LEN
</p>
</blockquote><p>
						
</p>
<p>Method CICM::BypassRead::Stream::read_bypass_poll()
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>CICM::Status read_bypass_poll(
	in  CICM::TransId transaction_id,
	out CICM::ReadStream::ReadStatus status
);</pre></div>
<p>Returns the status of the non-blocking bypass operation
						specified by the transaction_id parameter. Upon completion of the
						operation, the caller must use the metadata associated with the
						transaction_id parameter to determine which buffer has been
						populated. Memory responsibilities and calling conventions shall
						follow the appropriate IDL language mapping conventions.
</p>
<p>Parameters:
							</p>
<blockquote class="text">
<p>[in] transaction_id
								  Unique transaction id previously specified to the
								  CICM::BypassRead::Stream::read_bypass_non_blocking method
								  that allows the poll operation to determine to which
								  buffer the poll status applies.
</p>
<p>[out] status
								  Status of the non-blocking operation corresponding to
								  the transaction_id parameter.
</p>
</blockquote><p>
						
</p>
<p>Returns:
							</p>
<blockquote class="text">
<p>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR,
							  S_CHANNEL_PEER_RESET, S_CHANNEL_IO_ERROR
</p>
</blockquote><p>
						
</p>
<a name="anchor191"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.13.3"></a><h3>13.3.&nbsp;
Interface CICM::BypassRead::Controller</h3>

<p>Interface  CICM::BypassRead::Controller
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>interface Controller : CICM::MultiDomainController {};</pre></div>
<p>CICM::BypassRead::Controller supports full bypass between two
					independent security domains. The resulting controller is capable
					of managing the channel, but not accepting bypassed data. It is
					created by calling
					CICM::ChannelManager::create_bypass_read_controller.
</p>
<a name="anchor192"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.13.3.1"></a><h3>13.3.1.&nbsp;
CICM::BypassRead::Controller Inheritance</h3>

<p>CICM::BypassRead::Controller inherits from: CICM::MultiDomainController.
</p>
<a name="anchor193"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.13.4"></a><h3>13.4.&nbsp;
Interface CICM::BypassRead::Conduit</h3>

<p>Interface CICM::BypassRead::Conduit
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>interface Conduit :
	CICM::Conduit,
	CICM::BypassRead::Controller,
	CICM::BypassRead::Stream {</pre></div>
<p>CICM::BypassRead::Conduit supports full bypass between two
					independent security domains. The resulting conduit is capable of
					both managing the channel and accepting bypassed data. It is
					created by calling
					CICM::ChannelManager::create_bypass_read_conduit.
</p>
<a name="anchor194"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.13.4.1"></a><h3>13.4.1.&nbsp;
CICM::BypassRead::Conduit Inheritance</h3>

<p>CICM::BypassRead::Conduit inherits from:
						CICM::Conduit, CICM::BypassRead::Controller and
						CICM::BypassRead::Stream.
</p>
<a name="sec-encrypt-bypass"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.14"></a><h3>14.&nbsp;
Encryption with Selective Bypass</h3>

<p>Namespace CICM::EncryptBypass
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>module EncryptBypass {</pre></div>
<p>The CICM::EncryptBypass namespace contains interfaces that
				support encryption with selective bypass operations between two
				indepenent security domains.
</p>
<a name="anchor195"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.14.1"></a><h3>14.1.&nbsp;
Interface CICM::EncryptBypass::ChannelManager</h3>

<p>Interface CICM::EncryptBypass::ChannelManager
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>interface ChannelManager {</pre></div>
<p>CICM::EncryptBypass::ChannelManager is an abstraction
					inherited by CICM::ChannelManager that supports the creation of
					encryption with selective bypass negotiators, conduits,
					controllers, and streams. See CICM::ChannelManager for additional
					information.
</p>
<p>Remarks:
						</p>
<blockquote class="text">
<p>Note that if a system is using selective bypass channels to
					  perform header bypass, policy may govern that a system performs
					  the bypass function before the encryption function and performs
					  the bypass function only once.
</p>
</blockquote>

<a name="anchor196"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.14.1.1"></a><h3>14.1.1.&nbsp;
CICM::EncryptBypass::ChannelManager Methods</h3>

<p>Method CICM::EncryptBypass::ChannelManager::negotiate_encrypt_bypass_conduit()
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>CICM::Status negotiate_encrypt_bypass_conduit(
	in  CICM::RemotePort remote_port,
	in  CICM::ProtocolId protocol,
	in  CICM::AsymKey key_ref,
	out CICM::EncryptBypass::Negotiator negotiator_ref
);</pre></div>
<p>Initiate a negotiation to establish a shared key with a peer.
						The channel that results will selectively encrypt or bypass a
						stream of data.
</p>
<p>Parameters:
							</p>
<blockquote class="text">
<p>[in] remote_port
								  Remote port.
</p>
<p>[in] protocol
								  Protocol identifier.
</p>
<p>[in] key_ref
								  Reference to negotiation key.
</p>
<p>[out] negotiator_ref
								  Reference to resulting negotiator.
</p>
</blockquote><p>
						
</p>
<p>Returns:
							</p>
<blockquote class="text">
<p>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_USED_INVALID,
							  S_KEY_USED_EXPIRED, S_KEY_USED_WRAPPED, S_KEY_USED_CONTEXT,
							  S_KEY_USED_COMPONENT_NOT_AVAIL, S_KEY_INVALID, S_KEY_EXPIRED,
							  S_REMOTE_PORT_INVALID, S_REMOTE_PORT_IN_USE,
							  S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT,
							  S_NEGOTIATION_ABORTED, S_NEGOTIATION_FAILURE,
							  S_NEGOTIATION_IN_PROGRESS, S_NEGOTIATION_TIMEOUT,
							  S_CERT_LOCAL_INVALID, S_CERT_LOCAL_EXPIRED,
							  S_CERT_REMOTE_INVALID, S_CERT_REMOTE_EXPIRED,
							  S_CERT_REMOTE_PATH, S_PROTO_INVALID, S_PROTO_INCOMPATIBLE,
							  S_PROTO_UNDETERMINED, S_CHANNEL_ERROR, S_CHANNEL_MAX
</p>
</blockquote><p>
						
</p>
<p>Method CICM::EncryptBypass::ChannelManager::negotiate_encrypt_bypass_controller()
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>CICM::Status negotiate_encrypt_bypass_controller(
	in  CICM::LocalPort local_port,
	in  CICM::RemotePort remote_port,
	in  CICM::ProtocolId protocol,
	in  CICM::AsymKey key_ref,
	out CICM::EncryptBypass::ControllerNegotiator negotiator_ref
);</pre></div>
<p>Initiate a negotiation to establish a shared key with a peer,
						resulting in a controller to manage an encrypt with bypass
						channel.
</p>
<p>Parameters:
							</p>
<blockquote class="text">
<p>[in] local_port
								  Remote port.
</p>
<p>[in] remote_port
								  Remote port.
</p>
<p>[in] protocol
								  Protocol identifier.
</p>
<p>[in] key_ref
								  Reference to negotiation key.
</p>
<p>[out] negotiator_ref
								  Reference to resulting negotiator.
</p>
</blockquote><p>
						
</p>
<p>Returns:
							</p>
<blockquote class="text">
<p>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_USED_INVALID,
							  S_KEY_USED_EXPIRED, S_KEY_USED_WRAPPED, S_KEY_USED_CONTEXT,
							  S_KEY_USED_COMPONENT_NOT_AVAIL, S_KEY_INVALID, S_KEY_EXPIRED,
							  S_LOCAL_PORT_INVALID, S_LOCAL_PORT_INCOMPATIBLE,
							  S_LOCAL_PORT_IN_USE, S_REMOTE_PORT_INVALID,
							  S_REMOTE_PORT_IN_USE, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_NEGOTIATION_ABORTED,
							  S_NEGOTIATION_FAILURE, S_NEGOTIATION_IN_PROGRESS,
							  S_NEGOTIATION_TIMEOUT, S_CERT_LOCAL_INVALID,
							  S_CERT_LOCAL_EXPIRED, S_CERT_REMOTE_INVALID,
							  S_CERT_REMOTE_EXPIRED, S_CERT_REMOTE_PATH, S_PROTO_INVALID,
							  S_PROTO_INCOMPATIBLE, S_PROTO_UNDETERMINED, S_CHANNEL_ERROR,
							  S_CHANNEL_MAX
</p>
</blockquote><p>
						
</p>
<p>Method CICM::EncryptBypass::ChannelManager::create_encrypt_bypass_conduit()
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>CICM::Status create_encrypt_bypass_conduit(
	in  CICM::RemotePort remote_port,
	in  CICM::SymKey key_ref,
	in  CICM::SymEncrAlgorithmId algorithm,
	out CICM::EncryptBypass::Conduit conduit_ref
);</pre></div>
<p>Create conduit to selectively encrypt or bypass a stream of  data.
</p>
<p>Parameters:
							</p>
<blockquote class="text">
<p>[in] remote_port
								  Remote port.
</p>
<p>[in] key_ref
								  Reference to encryption key.
</p>
<p>[in] algorithm
								  Encryption algorithm/mode.
</p>
<p>[out] conduit_ref
								  Reference to resulting negotiator.
</p>
</blockquote><p>
						
</p>
<p>Returns:
							</p>
<blockquote class="text">
<p>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_INVALID,
							  S_KEY_EXPIRED, S_REMOTE_PORT_INVALID, S_REMOTE_PORT_IN_USE,
							  S_ALGO_INVALID, S_ALGO_INCOMPATIBLE, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR,
							  S_CHANNEL_MAX
</p>
</blockquote><p>
						
</p>
<p>Method CICM::EncryptBypass::ChannelManager::create_encrypt_bypass_controller()
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>CICM::Status create_encrypt_bypass_controller(
	in  CICM::LocalPort local_port,
	in  CICM::RemotePort remote_port,
	in  CICM::SymKey key_ref,
	in  CICM::SymEncrAlgorithmId algorithm,
	out CICM::EncryptBypass::Controller controller_ref
);</pre></div>
<p>Create controller to configure and control an encrypt with
						bypass channel.
</p>
<p>Remarks:
							</p>
<blockquote class="text">
<p>In some cases, hosts may depend upon separate processes to
							control and use a channel. This method returns the channel
							controller and must be called before the corresponding stream
							is retrieved.
</p>
</blockquote><p>
						
</p>
<p>Parameters:
							</p>
<blockquote class="text">
<p>[in] local_port
								  Local port.
</p>
<p>[in] remote_port
								  Remote port.
</p>
<p>[in] key_ref
								  Reference to encryption key.
</p>
<p>[in] algorithm
								  Encryption algorithm/mode.
</p>
<p>[out] controller_ref
								  Reference to resulting controller.
</p>
</blockquote><p>
						
</p>
<p>Returns:
							</p>
<blockquote class="text">
<p>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_INVALID,
							  S_KEY_EXPIRED, S_LOCAL_PORT_INVALID,
							  S_LOCAL_PORT_INCOMPATIBLE, S_LOCAL_PORT_IN_USE,
							  S_REMOTE_PORT_INVALID, S_REMOTE_PORT_IN_USE, S_ALGO_INVALID,
							  S_ALGO_INCOMPATIBLE, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR,
							  S_CHANNEL_MAX
</p>
</blockquote><p>
						
</p>
<p>Method CICM::EncryptBypass::ChannelManager::get_encrypt_bypass_stream()
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>CICM::Status get_encrypt_bypass_stream(
	in  CICM::LocalPort local_port,
	out CICM::EncryptBypass::Stream stream_ref
);</pre></div>
<p>Create stream associated with previously created controller
						to accept data for transformation.
</p>
<p>Parameters:
							</p>
<blockquote class="text">
<p>[in] local_port
								  Local port.
</p>
<p>[out] stream_ref
								  Reference to resulting stream.
</p>
</blockquote><p>
						
</p>
<p>Returns:
							</p>
<blockquote class="text">
<p>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_INVALID,
							  S_KEY_EXPIRED, S_LOCAL_PORT_INVALID,
							  S_LOCAL_PORT_INCOMPATIBLE, S_LOCAL_PORT_IN_USE,
							  S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT,
							  S_CHANNEL_ERROR, S_CHANNEL_PEER_RESET,
							  S_CHANNEL_NOT_FOUND
</p>
</blockquote><p>
						
</p>
<a name="anchor197"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.14.2"></a><h3>14.2.&nbsp;
Interface CICM::EncryptBypass::Stream</h3>

<p>Interface CICM::EncryptBypass::Stream
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>interface Stream :
	CICM::Encrypt::Stream,
	CICM::BypassWrite::Stream {</pre></div>
<p>CICM::EncryptBypass::Stream supports encryption and selective
					bypass operations between two independent security domains. The
					resulting stream is capable of accepting data for transformation,
					but not managing the channel. It is created by calling
					CICM::ChannelManager::get_encrypt_bypass_stream.
</p>
<a name="anchor198"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.14.2.1"></a><h3>14.2.1.&nbsp;
CICM::EncryptBypass::Stream Inheritance</h3>

<p>CICM::EncryptBypass::Stream inherits from:
						CICM::Encrypt::Stream and CICM::BypassWrite::Stream.
</p>
<a name="anchor199"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.14.3"></a><h3>14.3.&nbsp;
Interface CICM::EncryptBypass::NegotiatedController</h3>

<p>Interface  CICM::EncryptBypass::NegotiatedController
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>interface NegotiatedController : CICM::Encrypt::NegotiatedController {};</pre></div>
<p>CICM::EncryptBypass::NegotiatedController is the negotiated
					version of CICM::EncryptBypass::Controller. It is the result of a
					successful negotiation by
					CICM::EncryptBypass::ControllerNegotiator.
</p>
<a name="anchor200"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.14.3.1"></a><h3>14.3.1.&nbsp;
CICM::EncryptBypass::NegotiatedController Inheritance</h3>

<p>CICM::EncryptBypass::NegotiatedController inherits
						from: CICM::Encrypt::NegotiatedController.
</p>
<a name="anchor201"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.14.4"></a><h3>14.4.&nbsp;
Interface CICM::EncryptBypass::Controller</h3>

<p>Interface  CICM::EncryptBypass::Controller
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>interface Controller : CICM::Encrypt::Controller {};</pre></div>
<p>CICM::EncryptBypass::Controller supports encryption and
					selective bypass operations between two independent security
					domains. The resulting controller is capable of managing the
					channel, but not accepting data for transformation/bypass. It is
					created by calling
					CICM::ChannelManager::create_encrypt_bypass_controller.
</p>
<a name="anchor202"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.14.4.1"></a><h3>14.4.1.&nbsp;
CICM::EncryptBypass::Controller Inheritance</h3>

<p>CICM::EncryptBypass::Controller inherits from:
						CICM::Encrypt::Controller.
</p>
<a name="anchor203"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.14.5"></a><h3>14.5.&nbsp;
Interface CICM::EncryptBypass::Conduit</h3>

<p>Interface  CICM::EncryptBypass::Conduit
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>interface Conduit :
	CICM::Encrypt::Conduit,
	CICM::EncryptBypass::Stream {</pre></div>
<p>CICM::EncryptBypass::Conduit supports encryption and
					selective bypass operations between two independent security
					domains. The resulting conduit is capable of both managing the
					channel and accepting data for transformation/bypass. It is created
					by calling CICM::ChannelManager::create_encrypt_bypass_conduit.
</p>
<a name="anchor204"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.14.5.1"></a><h3>14.5.1.&nbsp;
CICM::EncryptBypass::Conduit Inheritance</h3>

<p>CICM::EncryptBypass::Conduit inherits from:
						CICM::Encrypt::Conduit and CICM::EncryptBypass::Stream.
</p>
<a name="anchor205"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.14.6"></a><h3>14.6.&nbsp;
Interface CICM::EncryptBypass::NegotiatedConduit</h3>

<p>Interface  CICM::EncryptBypass::NegotiatedConduit
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>interface NegotiatedConduit :
	CICM::Encrypt::NegotiatedController,
	CICM::EncryptBypass::Stream {</pre></div>
<p>CICM::EncryptBypass::NegotiatedConduit is the negotiated
					version of CICM::EncryptBypass::Conduit. It is the result of a
					successful negotiation by CICM::EncryptBypass::Negotiator.
</p>
<a name="anchor206"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.14.6.1"></a><h3>14.6.1.&nbsp;
CICM::EncryptBypass::NegotiatedConduit Inheritance</h3>

<p>CICM::EncryptBypass::NegotiatedConduit inherits
						from: CICM::Encrypt::NegotiatedController and
						CICM::EncryptBypass::Stream.
</p>
<a name="anchor207"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.14.7"></a><h3>14.7.&nbsp;
Interface CICM::EncryptBypass::ControllerNegotiator</h3>

<p>Interface  CICM::EncryptBypass::ControllerNegotiator
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>interface ControllerNegotiator : CICM::Negotiator {</pre></div>
<p>CICM::EncryptBypass::ControllerNegotiator initiates a
					negotiation to establish a shared key with a remote entity that is
					used to support encryption and selective bypass operations between
					two independent security domains. The result of a successful
					negotiation is a CICM::EncryptBypass::NegotiatedController which is
					capable of managing the channel, but not accepting data for
					transformation/bypass. CICM::EncryptBypass::ControllerNegotiator is
					created by calling
					CICM::ChannelManager::negotiate_encrypt_bypass_controller.
</p>
<a name="anchor208"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.14.7.1"></a><h3>14.7.1.&nbsp;
CICM::EncryptBypass::ControllerNegotiator Inheritance</h3>

<p>CICM::EncryptBypass::ControllerNegotiator inherits from: CICM::Negotiator.
</p>
<a name="anchor209"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.14.7.2"></a><h3>14.7.2.&nbsp;
CICM::EncryptBypass::ControllerNegotiator Methods</h3>

<p>Method CICM::EncryptBypass::ControllerNegotiator::complete()
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>CICM::Status complete(
	out CICM::EncryptBypass::NegotiatedController controller_ref
);</pre></div>
<p>Complete negotiation and retrieve a negotiated encrypt bypass
						control-only channel.
</p>
<p>Parameters:
							</p>
<blockquote class="text">
<p>[out] controller_ref
								  Reference to resulting controller.
</p>
</blockquote><p>
						
</p>
<p>Returns:
							</p>
<blockquote class="text">
<p>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_NEGOTIATION_ABORTED,
							  S_NEGOTIATION_FAILURE, S_NEGOTIATION_NOT_IN_PROGRESS,
							  S_NEGOTIATION_TIMEOUT, S_CERT_LOCAL_INVALID,
							  S_CERT_LOCAL_EXPIRED, S_CERT_REMOTE_INVALID,
							  S_CERT_REMOTE_EXPIRED, S_CERT_REMOTE_PATH, S_CHANNEL_ERROR,
							  S_CHANNEL_PEER_RESET
</p>
</blockquote><p>
						
</p>
<a name="anchor210"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.14.8"></a><h3>14.8.&nbsp;
Interface CICM::EncryptBypass::Negotiator</h3>

<p>Interface  CICM::EncryptBypass::Negotiator
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>interface Negotiator : CICM::Negotiator {</pre></div>
<p>CICM::EncryptBypass::Negotiator initiates a negotiation to
					establish a shared key with a remote entity that is used to support
					encryption and bypass operations between two independent security
					domains. Additionally, selective bypass is supported on the same
					conduit. The result of a successful negotiation is a
					CICM::EncryptBypass::NegotiatedConduit which is capable of both
					managing the channel and accepting data for transformation/bypass.
					CICM::EncryptBypass::Negotiator is created by calling
					CICM::ChannelManager::negotiate_encrypt_bypass_conduit.
</p>
<a name="anchor211"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.14.8.1"></a><h3>14.8.1.&nbsp;
CICM::EncryptBypass::Negotiator Inheritance</h3>

<p>CICM::EncryptBypass::Negotiator inherits from: CICM::Negotiator.
</p>
<a name="anchor212"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.14.8.2"></a><h3>14.8.2.&nbsp;
CICM::EncryptBypass::Negotiator Methods</h3>

<p>Method CICM::EncryptBypass::Negotiator::complete()
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>CICM::Status complete(
	out CICM::EncryptBypass::NegotiatedConduit conduit_ref
);</pre></div>
<p>Complete negotiation and retrieve a negotiated encrypt bypass
						conduit.
</p>
<p>Parameters:
							</p>
<blockquote class="text">
<p>[out] conduit_ref
								  Reference to resulting conduit.
</p>
</blockquote><p>
						
</p>
<p>Returns:
							</p>
<blockquote class="text">
<p>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_NEGOTIATION_ABORTED,
							  S_NEGOTIATION_FAILURE, S_NEGOTIATION_NOT_IN_PROGRESS,
							  S_NEGOTIATION_TIMEOUT, S_CERT_LOCAL_INVALID,
							  S_CERT_LOCAL_EXPIRED, S_CERT_REMOTE_INVALID,
  							  S_CHANNEL_PEER_RESET
</p>
</blockquote><p>
						
</p>
<a name="sec-decrypt-bypass"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.15"></a><h3>15.&nbsp;
Decryption with Selective Bypass</h3>

<p>Namespace CICM::DecryptBypass
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>module DecryptBypass {</pre></div>
<p>The CICM::DecryptBypass namespace contains interfaces that
				support decryption with selective bypass operations between two
				independent security domains.
</p>
<a name="anchor213"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.15.1"></a><h3>15.1.&nbsp;
Interface CICM::DecryptBypass::ChannelManager</h3>

<p>Interface  CICM::DecryptBypass::ChannelManager
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>interface ChannelManager {</pre></div>
<p>CICM::DecryptBypass::ChannelManager is an abstraction
					inherited by CICM::ChannelManager that supports the creation of
					decryption with selective bypass negotiators, conduits,
					controllers, and streams. See CICM::ChannelManager for additional
					information.
</p>
<p>Remarks:
						</p>
<blockquote class="text">
<p>CICM does not specify the structure of the data that is read
						  from a selective bypass channel which may contain special
						  formatting to indicate which subset of the data was bypassed. The
						  Implementation Conformance Statement (see Conformance and Extensions 
              in <a class='info' href='#CICM'>[CICM]<span> (</span><span class='info'>Lanz, D. and L. Novikov, &ldquo;Common Interface to Cryptographic Modules (CICM)           [RFC Editor: Please update the RFC reference and date prior to publication.],&rdquo; January&nbsp;2011.</span><span>)</span></a>) MUST reference a standard format or define a
						  module developer-specific format implemented by the module for
						  data read from selective bypass channels.
</p>
</blockquote><p>
					
</p>
<a name="anchor214"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.15.1.1"></a><h3>15.1.1.&nbsp;
CICM::DecryptBypass::ChannelManager Methods</h3>

<p>Method CICM::DecryptBypass::ChannelManager::negotiate_decrypt_bypass_conduit()
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>CICM::Status negotiate_decrypt_bypass_conduit(
	in  CICM::RemotePort remote_port,
	in  CICM::ProtocolId protocol,
	in  CICM::AsymKey key_ref,
	out CICM::DecryptBypass::Negotiator negotiator_ref
);</pre></div>
<p>Initiate a negotiation to establish a shared key with a peer.
						The channel that results will selectively decrypt or bypass a
						stream of data.
</p>
<p>Parameters:
							</p>
<blockquote class="text">
<p>[in] remote_port
								  Remote port.
</p>
<p>[in] protocol
								  Protocol identifier.
</p>
<p>[in] key_ref
								  Reference to negotiation key.
</p>
<p>[out] negotiator_ref
								  Reference to resulting negotiator.
</p>
</blockquote><p>
						
</p>
<p>Returns:
							</p>
<blockquote class="text">
<p>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_USED_INVALID,
							  S_KEY_USED_EXPIRED, S_KEY_USED_WRAPPED, S_KEY_USED_CONTEXT,
							  S_KEY_USED_COMPONENT_NOT_AVAIL, S_KEY_INVALID, S_KEY_EXPIRED,
							  S_REMOTE_PORT_INVALID, S_REMOTE_PORT_IN_USE,
							  S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT,
							  S_NEGOTIATION_ABORTED, S_NEGOTIATION_FAILURE,
							  S_NEGOTIATION_IN_PROGRESS, S_NEGOTIATION_TIMEOUT,
							  S_CERT_LOCAL_INVALID, S_CERT_LOCAL_EXPIRED,
							  S_CERT_REMOTE_INVALID, S_CERT_REMOTE_EXPIRED,
							  S_CERT_REMOTE_PATH, S_PROTO_INVALID, S_PROTO_INCOMPATIBLE,
							  S_PROTO_UNDETERMINED, S_CHANNEL_ERROR, S_CHANNEL_MAX
</p>
</blockquote><p>
						
</p>
<p>Method CICM::DecryptBypass::ChannelManager::negotiate_decrypt_bypass_controller()
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>CICM::Status negotiate_decrypt_bypass_controller(
	in  CICM::LocalPort local_port,
	in  CICM::RemotePort remote_port,
	in  CICM::ProtocolId protocol,
	in  CICM::AsymKey key_ref,
	out CICM::DecryptBypass::ControllerNegotiator negotiator_ref
);</pre></div>
<p>Initiate a negotiation to establish a shared key with a peer,
						resulting in a controller to manage a decrypt with bypass
						channel.
</p>
<p>Parameters:
							</p>
<blockquote class="text">
<p>[in] local_port
								  Local port.
</p>
<p>[in] remote_port
								  Remote port.
</p>
<p>[in] protocol
								  Protocol identifier.
</p>
<p>[in] key_ref
								  Reference to negotiation key.
</p>
<p>[out] negotiator_ref
								  Reference to resulting negotiator.
</p>
</blockquote><p>
						
</p>
<p>Returns:
							</p>
<blockquote class="text">
<p>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_USED_INVALID,
							  S_KEY_USED_EXPIRED, S_KEY_USED_WRAPPED, S_KEY_USED_CONTEXT,
							  S_KEY_USED_COMPONENT_NOT_AVAIL, S_KEY_INVALID, S_KEY_EXPIRED,
							  S_LOCAL_PORT_INVALID, S_LOCAL_PORT_INCOMPATIBLE,
							  S_LOCAL_PORT_IN_USE, S_REMOTE_PORT_INVALID,
							  S_REMOTE_PORT_IN_USE, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_NEGOTIATION_ABORTED,
							  S_NEGOTIATION_FAILURE, S_NEGOTIATION_IN_PROGRESS,
							  S_NEGOTIATION_TIMEOUT, S_CERT_LOCAL_INVALID,
							  S_CERT_LOCAL_EXPIRED, S_CERT_REMOTE_INVALID,
							  S_CERT_REMOTE_EXPIRED, S_CERT_REMOTE_PATH, S_PROTO_INVALID,
							  S_PROTO_INCOMPATIBLE, S_PROTO_UNDETERMINED, S_CHANNEL_ERROR,
							  S_CHANNEL_MAX
</p>
</blockquote><p>
						
</p>
<p>Method CICM::DecryptBypass::ChannelManager::create_decrypt_bypass_conduit()
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>CICM::Status create_decrypt_bypass_conduit(
	in  CICM::RemotePort remote_port,
	in  CICM::SymKey key_ref,
	in  CICM::SymEncrAlgorithmId algorithm,
	out CICM::DecryptBypass::Conduit conduit_ref
);</pre></div>
<p>Create conduit to selectively decrypt or bypass a stream of data.
</p>
<p>Remarks:
							</p>
<blockquote class="text">
<p>Both decrypted and bypassed data are read from the same
							stream using the appropriate decrypt() call; the entity reading
							from this stream must distinguish between decrypted and
							bypassed data, if necessary.
</p>
</blockquote><p>
						
</p>
<p>Parameters:
							</p>
<blockquote class="text">
<p>[in] remote_port
								  Remote port.
</p>
<p>[in] key_ref
								  Reference to decryption key.
</p>
<p>[in] algorithm
								  Decryption algorithm/mode.
</p>
<p>[out] conduit_ref
								  Reference to resulting conduit.
</p>
</blockquote><p>
						
</p>
<p>Returns:
							</p>
<blockquote class="text">
<p>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_INVALID,
							  S_KEY_EXPIRED, S_REMOTE_PORT_INVALID, S_REMOTE_PORT_IN_USE,
							  S_ALGO_INVALID, S_ALGO_INCOMPATIBLE, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR,
							  S_CHANNEL_MAX
</p>
</blockquote><p>
						
</p>
<p>Method CICM::DecryptBypass::ChannelManager::create_decrypt_bypass_controller()
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>CICM::Status create_decrypt_bypass_controller(
	in  CICM::LocalPort local_port,
	in  CICM::RemotePort remote_port,
	in  CICM::SymKey key_ref,
	in  CICM::SymEncrAlgorithmId algorithm,
	out CICM::DecryptBypass::Controller controller_ref
);</pre></div>
<p>Create controller to configure and control a decrypt with
						bypass channel.
</p>
<p>Remarks:
							</p>
<blockquote class="text">
<p>In some cases, hosts may depend upon separate processes to
							control and use a channel. This method returns the channel
							controller and must be called before the corresponding stream
							is retrieved.
</p>
</blockquote><p>
						
</p>
<p>Parameters:
							</p>
<blockquote class="text">
<p>[in] local_port
								  Local port.
</p>
<p>[in] remote_port
								  Remote port.
</p>
<p>[in] key_ref
								  Reference to decryption key.
</p>
<p>[in] algorithm
								  Decryption algorithm/mode.
</p>
<p>[out] controller_ref
								  Reference to resulting controller.
</p>
</blockquote><p>
						
</p>
<p>Returns:
							</p>
<blockquote class="text">
<p>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_INVALID,
							  S_KEY_EXPIRED, S_LOCAL_PORT_INVALID,
							  S_LOCAL_PORT_INCOMPATIBLE, S_LOCAL_PORT_IN_USE,
							  S_REMOTE_PORT_INVALID, S_REMOTE_PORT_IN_USE, S_ALGO_INVALID,
							  S_ALGO_INCOMPATIBLE, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR,
							  S_CHANNEL_MAX
</p>
</blockquote><p>
						
</p>
<p>Method CICM::DecryptBypass::ChannelManager::get_decrypt_bypass_stream()
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>CICM::Status get_decrypt_bypass_stream(
	in  CICM::LocalPort local_port,
	out CICM::DecryptBypass::Stream stream_ref
);</pre></div>
<p>Create stream associated with previously created controller
						to receive transformed data.
</p>
<p>Remarks:
							</p>
<blockquote class="text">
<p>Both decrypted and bypassed data are read from the same
							stream using the appropriate decrypt() call; the entity reading
							from this stream must distinguish between decrypted and
							bypassed data, if necessary.
</p>
</blockquote><p>
						
</p>
<p>Parameters:
							</p>
<blockquote class="text">
<p>[in] local_port
								  Local port.
</p>
<p>[out] stream_ref
								  Reference to resulting stream.
</p>
</blockquote><p>
						
</p>
<p>Returns:
							</p>
<blockquote class="text">
<p>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_INVALID,
							  S_KEY_EXPIRED, S_LOCAL_PORT_INVALID,
							  S_LOCAL_PORT_INCOMPATIBLE, S_LOCAL_PORT_IN_USE,
							  S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT,
							  S_CHANNEL_ERROR, S_CHANNEL_PEER_RESET,
							  S_CHANNEL_NOT_FOUND
</p>
</blockquote><p>
						
</p>
<a name="anchor215"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.15.2"></a><h3>15.2.&nbsp;
Interface CICM::DecryptBypass::Stream</h3>

<p>Interface CICM::DecryptBypass::Stream
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>interface Stream : CICM::Decrypt::Stream {};</pre></div>
<p>CICM::DecryptBypass::Stream supports decryption and selective
					bypass operations between two independent security domains. The
					resulting stream is capable of accepting transformed/bypassed data,
					but not managing the channel. It is created by calling
					CICM::ChannelManager::get_decrypt_bypass_stream.
</p>
<p>Remarks:
						</p>
<blockquote class="text">
<p>CICM does not specify the structure of the data that is read
						  from a selective bypass channel which may contain special
						  formatting to indicate which subset of the data was bypassed. The
						  Implementation Conformance Statement (see
							Conformance and Extensions in <a class='info' href='#CICM'>[CICM]<span> (</span><span class='info'>Lanz, D. and L. Novikov, &ldquo;Common Interface to Cryptographic Modules (CICM)           [RFC Editor: Please update the RFC reference and date prior to publication.],&rdquo; January&nbsp;2011.</span><span>)</span></a>) MUST
              reference a standard format or define a
						  module developer-specific format implemented by the module for
						  data read from selective bypass channels.
</p>
</blockquote><p>
					
</p>
<a name="anchor216"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.15.2.1"></a><h3>15.2.1.&nbsp;
CICM::DecryptBypass::Stream Inheritance</h3>

<p>CICM::DecryptBypass::Stream inherits from:
						CICM::Decrypt::Stream.
</p>
<a name="anchor217"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.15.3"></a><h3>15.3.&nbsp;
Interface CICM::DecryptBypass::Controller</h3>

<p>Interface  CICM::DecryptBypass::Controller
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>interface Controller : CICM::Decrypt::Controller {</pre></div>
<p>CICM::DecryptBypass::Controller supports decryption and
					selective bypass operations between two independent security
					domains. The resulting controller is capable of managing the
					channel, but not accepting transformed/bypassed data. It is created
					by calling CICM::ChannelManager::create_decrypt_bypass_controller.
</p>
<a name="anchor218"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.15.3.1"></a><h3>15.3.1.&nbsp;
CICM::DecryptBypass::Controller Inheritance</h3>

<p>CICM::DecryptBypass::Controller inherits from:
						CICM::Decrypt::Controller.
</p>
<a name="anchor219"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.15.4"></a><h3>15.4.&nbsp;
Interface CICM::DecryptBypass::NegotiatedController</h3>

<p>Interface  CICM::DecryptBypass::NegotiatedController
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>interface NegotiatedController : CICM::Decrypt::NegotiatedController {</pre></div>
<p>CICM::DecryptBypass::NegotiatedController is the negotiated
					version of CICM::DecryptBypass::Controller. It is the result of a
					successful negotiation by
					CICM::DecryptBypass::ControllerNegotiator.
</p>
<a name="anchor220"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.15.4.1"></a><h3>15.4.1.&nbsp;
CICM::DecryptBypass::NegotiatedController Inheritance</h3>

<p>CICM::DecryptBypass::NegotiatedController inherits from: CICM::Decrypt::NegotiatedController.
</p>
<a name="anchor221"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.15.5"></a><h3>15.5.&nbsp;
Interface CICM::DecryptBypass::Conduit</h3>

<p>Interface  CICM::DecryptBypass::Conduit
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>interface Conduit :
	CICM::Decrypt::Conduit,
	CICM::DecryptBypass::Controller,
	CICM::DecryptBypass::Stream {</pre></div>
<p>CICM::DecryptBypass::Conduit supports decryption and
					selective bypass operations between two independent security
					domains. The resulting conduit is capable of both managing the
					channel and accepting transformed/bypassed data. It is created by
					calling CICM::ChannelManager::create_decrypt_bypass_conduit.
</p>
<a name="anchor222"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.15.5.1"></a><h3>15.5.1.&nbsp;
CICM::DecryptBypass::Conduit Inheritance</h3>

<p>CICM::DecryptBypass::Conduit inherits from:
						CICM::Decrypt::Conduit, CICM::DecryptBypass::Controller and
						CICM::DecryptBypass::Stream.
</p>
<a name="anchor223"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.15.6"></a><h3>15.6.&nbsp;
Interface CICM::DecryptBypass::NegotiatedConduit</h3>

<p>Interface  CICM::DecryptBypass::NegotiatedConduit
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>interface NegotiatedConduit :
	CICM::Decrypt::NegotiatedConduit,
	CICM::DecryptBypass::NegotiatedController,
	CICM::DecryptBypass::Stream {</pre></div>
<p>CICM::DecryptBypass::NegotiatedConduit is the negotiated
					version of CICM::DecryptBypass::Conduit. It is the result of a
					successful negotiation by CICM::DecryptBypass::Negotiator.
</p>
<a name="anchor224"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.15.6.1"></a><h3>15.6.1.&nbsp;
CICM::DecryptBypass::NegotiatedConduit Inheritance</h3>

<p>CICM::DecryptBypass::NegotiatedConduit inherits
						from: CICM::Decrypt::NegotiatedConduit,
						CICM::DecryptBypass::NegotiatedController and
						CICM::DecryptBypass::Stream.
</p>
<a name="anchor225"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.15.7"></a><h3>15.7.&nbsp;
Interface CICM::DecryptBypass::ControllerNegotiator</h3>

<p>Interface  CICM::DecryptBypass::ControllerNegotiator
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>interface ControllerNegotiator : CICM::Negotiator {</pre></div>
<p>CICM::DecryptBypass::ControllerNegotiator initiates a
					negotiation to establish a shared key with a remote entity that is
					used to support encryption and selective bypass operations between
					two independent security domains. The result of a successful
					negotiation is a CICM::DecryptBypass::NegotiatedController which is
					capable of managing the channel, but not accepting data for
					transformation. CICM::DecryptBypass::ControllerNegotiator is
					created by calling
					CICM::ChannelManager::negotiate_decrypt_bypass_controller.
</p>
<a name="anchor226"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.15.7.1"></a><h3>15.7.1.&nbsp;
CICM::DecryptBypass::ControllerNegotiator Inheritance</h3>

<p>CICM::DecryptBypass::ControllerNegotiator inherits from: CICM::Negotiator.
</p>
<a name="anchor227"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.15.7.2"></a><h3>15.7.2.&nbsp;
CICM::DecryptBypass::ControllerNegotiator Methods</h3>

<p>Method CICM::DecryptBypass::ControllerNegotiator::complete()
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>CICM::Status complete(
	out CICM::DecryptBypass::NegotiatedController controller_ref
);</pre></div>
<p>Complete negotiation and retrieve a negotiated control-only
						decrypt bypass channel.
</p>
<p>Parameters:
							</p>
<blockquote class="text">
<p>[out] controller_ref
								  Reference to resulting controller.
</p>
</blockquote><p>
						
</p>
<p>Returns:
							</p>
<blockquote class="text">
<p>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_NEGOTIATION_ABORTED,
							  S_NEGOTIATION_FAILURE, S_NEGOTIATION_NOT_IN_PROGRESS,
							  S_NEGOTIATION_TIMEOUT, S_CERT_LOCAL_INVALID,
							  S_CERT_LOCAL_EXPIRED, S_CERT_REMOTE_INVALID,
							  S_CERT_REMOTE_EXPIRED, S_CERT_REMOTE_PATH, S_CHANNEL_ERROR,
							  S_CHANNEL_PEER_RESET
</p>
</blockquote><p>
						
</p>
<a name="anchor228"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.15.8"></a><h3>15.8.&nbsp;
Interface CICM::DecryptBypass::Negotiator</h3>

<p>Interface  CICM::DecryptBypass::Negotiator
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>interface Negotiator : CICM::Negotiator {</pre></div>
<p>CICM::DecryptBypass::Negotiator initiates a negotiation to
					establish a shared key with a remote entity that is used to support
					encryption operations between two independent security domains.
					Additionally, selective bypass is supported on the same conduit.
					The result of a successful negotiation is a
					CICM::DecryptBypass::NegotiatedConduit which is capable of both
					managing the channel and accepting data for transformation.
					CICM::DecryptBypass::Negotiator is created by calling
					CICM::ChannelManager::negotiate_decrypt_bypass_conduit.
</p>
<a name="anchor229"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.15.8.1"></a><h3>15.8.1.&nbsp;
CICM::DecryptBypass::Negotiator Inheritance</h3>

<p>CICM::DecryptBypass::Negotiator inherits from: CICM::Negotiator.
</p>
<a name="anchor230"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.15.8.2"></a><h3>15.8.2.&nbsp;
CICM::DecryptBypass::Negotiator Methods</h3>

<p>Method CICM::DecryptBypass::Negotiator::complete()
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>CICM::Status complete(
	out CICM::DecryptBypass::NegotiatedConduit conduit_ref
);</pre></div>
<p>Complete negotiation and retrieve a negotiated decrypt bypass
						conduit.
</p>
<p>Parameters:
							</p>
<blockquote class="text">
<p>[out] conduit_ref
								  Reference to resulting conduit.
</p>
</blockquote><p>
						
</p>
<p>Returns:
							</p>
<blockquote class="text">
<p>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_NEGOTIATION_ABORTED,
							  S_NEGOTIATION_FAILURE, S_NEGOTIATION_NOT_IN_PROGRESS,
							  S_NEGOTIATION_TIMEOUT, S_CERT_LOCAL_INVALID,
							  S_CERT_LOCAL_EXPIRED, S_CERT_REMOTE_INVALID,
							  S_CERT_REMOTE_EXPIRED, S_CERT_REMOTE_PATH, S_CHANNEL_ERROR,
							  S_CHANNEL_PEER_RESET
</p>
</blockquote><p>
						
</p>
<a name="sec-emit"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.16"></a><h3>16.&nbsp;
Random, Pseudorandom and Keystream</h3>

<p>Namespace CICM::Emit
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>module Emit {</pre></div>
<p>The CICM::Emit namespace contains interfaces that generate
				data originating in a cryptographic module such as random,
				pseudorandom, and keystream data.
</p>
<a name="anchor231"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.16.1"></a><h3>16.1.&nbsp;
Interface CICM::Emit::ChannelManager</h3>

<p>Interface CICM::Emit::ChannelManager
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>interface ChannelManager {</pre></div>
<p>CICM::Emit::ChannelManager is an abstraction inherited by
					CICM::ChannelManager that supports the creation of conduits and
					controllers to generate keystream, pseudorandom, and random data.
					See CICM::ChannelManager for additional information.
</p>
<a name="anchor232"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.16.1.1"></a><h3>16.1.1.&nbsp;
CICM::Emit::ChannelManager Methods</h3>

<p>Method CICM::Emit::ChannelManager::create_key_stream_gen_controller()
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>CICM::Status create_key_stream_gen_controller(
	in  CICM::RemotePort remote_port,
	in  CICM::SymKey key_ref,
	in  CICM::SymEncrAlgorithmId algorithm,
	out CICM::Emit::KeyStreamGenController controller_ref
);</pre></div>
<p>Create controller to generate keystream.
</p>
<p>Parameters:
							</p>
<blockquote class="text">
<p>[in] remote_port
								  Remote port.
</p>
<p>[in] key_ref
								  Reference to keystream generation key.
</p>
<p>[in] algorithm
								  Keystream generation algorithm/mode.
</p>
<p>[out] controller_ref
								  Reference to resulting controller.
</p>
</blockquote><p>
						
</p>
<p>Returns:
							</p>
<blockquote class="text">
<p>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_USED_INVALID,
							  S_KEY_USED_EXPIRED, S_KEY_USED_WRAPPED, S_KEY_USED_CONTEXT,
							  S_KEY_INVALID, S_KEY_EXPIRED, S_REMOTE_PORT_INVALID,
							  S_REMOTE_PORT_IN_USE, S_ALGO_INVALID, S_ALGO_INCOMPATIBLE,
							  S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT,
							  S_CHANNEL_ERROR, S_CHANNEL_MAX
</p>
</blockquote><p>
						
</p>
<p>Method CICM::Emit::ChannelManager::create_pseudorandom_controller()
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>CICM::Status create_pseudorandom_controller(
	in  CICM::RemotePort remote_port,
	in  CICM::SymKey seed,
	out CICM::Emit::PseudoRandomController controller_ref
);</pre></div>
<p>Create controller to generate pseudorandom data.
</p>
<p>Parameters:
							</p>
<blockquote class="text">
<p>[in] remote_port
								  Remote port.
</p>
<p>[in] seed
								  Seed material for pseudorandom generator.
</p>
<p>[out] controller_ref
								  Reference to resulting controller.
</p>
</blockquote><p>
						
</p>
<p>Returns:
							</p>
<blockquote class="text">
<p>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_USED_INVALID,
							  S_KEY_USED_EXPIRED, S_KEY_USED_WRAPPED, S_KEY_USED_CONTEXT,
							  S_KEY_INVALID, S_KEY_EXPIRED, S_REMOTE_PORT_INVALID,
							  S_REMOTE_PORT_IN_USE, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR, S_CHANNEL_MAX,
							  S_INSUFFICIENT_ENTROPY
</p>
</blockquote><p>
						
</p>
<p>Method CICM::Emit::ChannelManager::create_random_controller()
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>CICM::Status create_random_controller(
	in  CICM::RemotePort remote_port,
	out CICM::Emit::RandomController controller_ref
);</pre></div>
<p>Create controller to generate random data.
</p>
<p>Parameters:
							</p>
<blockquote class="text">
<p>[in] remote_port
								  Remote port.
</p>
<p>[out] controller_ref
								  Reference to resulting controller.
</p>
</blockquote><p>
						
</p>
<p>Returns:
							</p>
<blockquote class="text">
<p>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_INVALID,
							  S_KEY_EXPIRED, S_REMOTE_PORT_INVALID, S_REMOTE_PORT_IN_USE,
							  S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT,
							  S_CHANNEL_ERROR, S_CHANNEL_MAX, S_INSUFFICIENT_ENTROPY
</p>
</blockquote><p>
						
</p>
<p>Method CICM::Emit::ChannelManager::create_key_stream_gen_conduit()
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>CICM::Status create_key_stream_gen_conduit(
	in  CICM::SymKey key_ref,
	in  CICM::SymEncrAlgorithmId algorithm,
	out CICM::Emit::KeyStreamGenConduit conduit_ref
);</pre></div>
<p>Create conduit to generate keystream.
</p>
<p>Parameters:
							</p>
<blockquote class="text">
<p>[in] key_ref
								  Reference to keystream generation key.
</p>
<p>[in] algorithm
								  Keystream generation algorithm/mode.
</p>
<p>[out] conduit_ref
								  Reference to resulting conduit.
</p>
</blockquote><p>
						
</p>
<p>Returns:
							</p>
<blockquote class="text">
<p>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_USED_INVALID,
							  S_KEY_USED_EXPIRED, S_KEY_USED_WRAPPED, S_KEY_USED_CONTEXT,
							  S_KEY_INVALID, S_KEY_EXPIRED, S_ALGO_INVALID,
							  S_ALGO_INCOMPATIBLE, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR,
							  S_CHANNEL_MAX
</p>
</blockquote><p>
						
</p>
<p>Method CICM::Emit::ChannelManager::create_pseudorandom_conduit()
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>CICM::Status create_pseudorandom_conduit(
	in  CICM::SymKey seed,
	out CICM::Emit::PseudoRandomConduit conduit_ref
);</pre></div>
<p>Create conduit to generate pseudorandom data.
</p>
<p>Parameters:
							</p>
<blockquote class="text">
<p>[in] seed
								  Seed material for pseudorandom generator.
</p>
<p>[out] conduit_ref
								  Reference to resulting conduit.
</p>
</blockquote><p>
						
</p>
<p>Returns:
							</p>
<blockquote class="text">
<p>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_USED_INVALID,
							  S_KEY_USED_EXPIRED, S_KEY_USED_WRAPPED, S_KEY_USED_CONTEXT,
							  S_KEY_INVALID, S_KEY_EXPIRED, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR, S_CHANNEL_MAX,
							  S_INSUFFICIENT_ENTROPY
</p>
</blockquote><p>
						
</p>
<p>Method CICM::Emit::ChannelManager::create_random_conduit()
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>CICM::Status create_random_conduit(
	out CICM::Emit::RandomConduit conduit_ref
);</pre></div>
<p>Create conduit to generate random data.
</p>
<p>Parameters:
							</p>
<blockquote class="text">
<p>[out] conduit_ref
								  Reference to resulting conduit.
</p>
</blockquote><p>
						
</p>
<p>Returns:
							</p>
<blockquote class="text">
<p>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_INVALID,
							  S_KEY_EXPIRED, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR, S_CHANNEL_MAX,
							  S_INSUFFICIENT_ENTROPY
</p>
</blockquote><p>
						
</p>
<a name="anchor233"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.16.2"></a><h3>16.2.&nbsp;
Interface CICM::Emit::GetStream</h3>

<p>Interface CICM::Emit::GetStream
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>interface GetStream : CICM::ReadStream {</pre></div>
<p>CICM::Emit::GetStream is an abstraction inherited by conduits
					in the CICM::Emit namespace that allows data to be read from the
					stream.
</p>
<a name="anchor234"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.16.2.1"></a><h3>16.2.1.&nbsp;
CICM::Emit::GetStream Inheritance</h3>

<p>CICM::Emit::GetStream inherits from: CICM::ReadStream.
</p>
<a name="anchor235"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.16.2.2"></a><h3>16.2.2.&nbsp;
CICM::Emit::GetStream Methods</h3>

<p>Method CICM::Emit::GetStream::get()
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>CICM::Status get(
	in  CICM::UInt32 length,
	out CICM::Buffer buffer
);</pre></div>
<p>Reads a buffer of data from the module. The method blocks
						until data becomes available.
</p>
<p>Parameters:
							</p>
<blockquote class="text">
<p>[in] length
								  Number of bytes to retrieve.
</p>
<p>[out] buffer
								  Buffer of data read from stream.
</p>
</blockquote><p>
						
</p>
<p>Returns:
							</p>
<blockquote class="text">
<p>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_INVALID,
							  S_KEY_EXPIRED, S_KEY_WRAPPED, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR,
							  S_CHANNEL_PEER_RESET, S_CHANNEL_IO_ERROR,
							  S_CHANNEL_BUFFER_LEN, S_INSUFFICIENT_ENTROPY
</p>
</blockquote><p>
						
</p>
<p>Method CICM::Emit::GetStream::get_non_blocking()
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>CICM::Status get_non_blocking(
	in  CICM::UInt32 length,
	out CICM::Buffer buffer,
	in  CICM::TransId transaction_id
);</pre></div>
<p>Registers a buffer into which transformed data will be
						copied, and then control immediately returns to the caller. The
						size of the allocated buffer and length of the resulting
						transformed data is encapsulated in the buffer parameter. The
						caller may use the CICM::Emit::GetStream::get_poll method to
						proactively poll the channel to determine the status of the
						operation. The caller is responsible for maintaining any necessary
						metadata associated with the transaction_id parameter. Memory
						responsibilities and calling conventions shall follow the
						appropriate IDL language mapping conventions.
</p>
<p>Parameters:
							</p>
<blockquote class="text">
<p>[in] length
								  Number of bytes to retrieve.
</p>
<p>[out] buffer
								  Transformed data.
</p>
<p>[in] transaction_id
								  Unique transaction id that will be used by the
								  CICM::Emit::GetStream::get_poll method to determine to
								  which buffer the poll status applies.
</p>
</blockquote><p>
						
</p>
<p>Returns:
							</p>
<blockquote class="text">
<p>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_INVALID,
							  S_KEY_EXPIRED, S_KEY_WRAPPED, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR,
							  S_CHANNEL_PEER_RESET, S_CHANNEL_IO_ERROR,
							  S_CHANNEL_BUFFER_LEN, S_INSUFFICIENT_ENTROPY
</p>
</blockquote><p>
						
</p>
<p>Method CICM::Emit::GetStream::get_poll()
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>CICM::Status get_poll(
	in  CICM::TransId transaction_id,
	out CICM::ReadStream::ReadStatus status
);</pre></div>
<p>Returns the status of the non-blocking get operation
						specified by the transaction_id parameter. Upon completion of the
						operation, the caller must use the metadata associated with the
						transaction_id parameter to determine which buffer has been
						populated. Memory responsibilities and calling conventions shall
						follow the appropriate IDL language mapping conventions.
</p>
<p>Parameters:
							</p>
<blockquote class="text">
<p>[in] transaction_id
								  Unique transaction id previously specified to the
								  CICM::Emit::GetStream::get_non_blocking method that
								  allows the poll operation to determine to which buffer
								  the poll status applies.
</p>
<p>[out] status
								  Status of the non-blocking operation corresponding to
								  the transaction_id parameter.
</p>
</blockquote><p>
						
</p>
<p>Returns:
							</p>
<blockquote class="text">
<p>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_INVALID,
							  S_KEY_EXPIRED, S_KEY_WRAPPED, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR,
							  S_CHANNEL_PEER_RESET, S_CHANNEL_IO_ERROR
</p>
</blockquote><p>
						
</p>
<a name="anchor236"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.16.3"></a><h3>16.3.&nbsp;
Interface CICM::Emit::Controller</h3>

<p>Interface CICM::Emit::Controller
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>interface Controller : CICM::Controller {</pre></div>
<p>CICM::Emit::Controller is an abstraction from which all other
					controllers in the CICM::Emit namespace inherit.
</p>
<a name="anchor237"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.16.3.1"></a><h3>16.3.1.&nbsp;
CICM::Emit::Controller Inheritance</h3>

<p>CICM::Emit::Controller inherits from: CICM::Controller.
</p>
<a name="anchor238"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.16.3.2"></a><h3>16.3.2.&nbsp;
CICM::Emit::Controller Attributes</h3>

<p>AttributeCICM::Emit::Controller::remote_port
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>readonly attribute CICM::RemotePort remote_port;</pre></div>
<p>The remote port associated with this controller.
</p>
<a name="anchor239"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.16.4"></a><h3>16.4.&nbsp;
Interface CICM::Emit::RandomController</h3>

<p>Interface  CICM::Emit::RandomController
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>interface RandomController : CICM::Emit::Controller {};</pre></div>
<p>CICM::Emit::RandomController supports creating a channel to
					read random data from a module. The resulting controller is capable
					of managing the channel, but not reading random data. It is created
					by calling CICM::ChannelManager::create_random_controller.
</p>
<a name="anchor240"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.16.4.1"></a><h3>16.4.1.&nbsp;
CICM::Emit::RandomController Inheritance</h3>

<p>CICM::Emit::RandomController inherits from: CICM::Emit::Controller.
</p>
<a name="anchor241"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.16.5"></a><h3>16.5.&nbsp;
Interface CICM::Emit::RandomConduit</h3>

<p>Interface CICM::Emit::RandomConduit
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>interface RandomConduit :
	CICM::Conduit,
	CICM::Emit::GetStream {</pre></div>
<p>CICM::Emit::RandomConduit supports reading random data from a
					module. The resulting conduit is capable of both managing the
					channel and reading random data. It is created by calling
					CICM::ChannelManager::create_random_conduit.
</p>
<a name="anchor242"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.16.5.1"></a><h3>16.5.1.&nbsp;
CICM::Emit::RandomConduit Inheritance</h3>

<p>CICM::Emit::RandomConduit inherits from:
						CICM::Conduit and CICM::Emit::GetStream.
</p>
<a name="anchor243"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.16.6"></a><h3>16.6.&nbsp;
Interface CICM::Emit::PseudoRandomController</h3>

<p>Interface  CICM::Emit::PseudoRandomController
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>interface PseudoRandomController :
	CICM::SymKeyController,
	CICM::Emit::Controller {</pre></div>
<p>CICM::Emit::PseudoRandomController supports creating a
					channel to read pseudorandom data from a module. The resulting
					controller is capable of managing the channel, but not reading
					pseudorandom data. It is created by calling
					CICM::ChannelManager::create_pseudorandom_controller.
</p>
<a name="anchor244"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.16.6.1"></a><h3>16.6.1.&nbsp;
CICM::Emit::PseudoRandomController Inheritance</h3>

<p>CICM::Emit::PseudoRandomController inherits from:
						CICM::SymKeyController and CICM::Emit::Controller.
</p>
<a name="anchor245"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.16.7"></a><h3>16.7.&nbsp;
Interface CICM::Emit::PseudoRandomConduit</h3>

<p>Interface  CICM::Emit::PseudoRandomConduit
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>interface PseudoRandomConduit :
	CICM::Conduit,
	CICM::SymKeyController,
	CICM::Emit::GetStream {</pre></div>
<p>CICM::Emit::PseudoRandomConduit supports reading pseudorandom
					data from a module. The resulting conduit is capable of both
					managing the channel and reading pseudorandom data. It is created
					by calling CICM::ChannelManager::create_pseudorandom_conduit.
</p>
<a name="anchor246"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.16.7.1"></a><h3>16.7.1.&nbsp;
CICM::Emit::PseudoRandomConduit Inheritance</h3>

<p>CICM::Emit::PseudoRandomConduit inherits from:
						CICM::Conduit, CICM::SymKeyController and
						CICM::Emit::GetStream.
</p>
<a name="anchor247"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.16.8"></a><h3>16.8.&nbsp;
Interface CICM::Emit::KeyStreamGenController</h3>

<p>Interface  CICM::Emit::KeyStreamGenController
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>interface KeyStreamGenController :
	CICM::SymKeyController,
	CICM::GenVectorController,
	CICM::Emit::Controller {</pre></div>
<p>CICM::Emit::KeyStreamGenController supports creating a
					channel to read keystream from a module. The resulting controller
					is capable of managing the channel, but not reading keystream. It
					is created by calling
					CICM::ChannelManager::create_key_stream_gen_controller.
</p>
<a name="anchor248"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.16.8.1"></a><h3>16.8.1.&nbsp;
CICM::Emit::KeyStreamGenController Inheritance</h3>

<p>CICM::Emit::KeyStreamGenController inherits from:
						CICM::SymKeyController, CICM::GenVectorController and
						CICM::Emit::Controller.
</p>
<a name="anchor249"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.16.9"></a><h3>16.9.&nbsp;
Interface CICM::Emit::KeyStreamGenConduit</h3>

<p>Interface  CICM::Emit::KeyStreamGenConduit
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>interface KeyStreamGenConduit :
	CICM::Conduit,
	CICM::SymKeyController,
	CICM::GenVectorController,
	CICM::Emit::GetStream {</pre></div>
<p>CICM::Emit::KeyStreamGenConduit supports reading keystream
					from a module. The resulting conduit is capable of both managing
					the channel and reading keystream. It is created by calling
					CICM::ChannelManager::create_key_stream_gen_conduit.
</p>
<a name="anchor250"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.16.9.1"></a><h3>16.9.1.&nbsp;
CICM::Emit::KeyStreamGenConduit Inheritance</h3>

<p>CICM::Emit::KeyStreamGenConduit inherits from:
						CICM::Conduit, CICM::SymKeyController, CICM::GenVectorController
						and CICM::Emit::GetStream.
</p>
<a name="sec-answer"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.17"></a><h3>17.&nbsp;
Data Integrity</h3>

<p>Namespace CICM::Answer
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>module Answer {</pre></div>
<p>The CICM::Answer namespace contains interfaces that support
				cryptographic operations that return an "answer" such a hash or a
				signature within a single security domain.
</p>
<a name="anchor251"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.17.1"></a><h3>17.1.&nbsp;
Interface CICM::Answer::ChannelManager</h3>

<p>Interface  CICM::Answer::ChannelManager
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>interface ChannelManager {</pre></div>
<p>CICM::Answer::ChannelManager is an abstraction inherited by
					CICM::ChannelManager that supports the creation of conduits to
					sign, MAC, and hash data. See CICM::ChannelManager for additional
					information.
</p>
<a name="anchor252"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.17.1.1"></a><h3>17.1.1.&nbsp;
CICM::Answer::ChannelManager Methods</h3>

<p>Method CICM::Answer::ChannelManager::create_hash_conduit()
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>CICM::Status create_hash_conduit(
	in  CICM::HashAlgorithmId algorithm,
	out CICM::Answer::HashConduit conduit_ref
);</pre></div>
<p>Create conduit to calculate and generate a hash value.
</p>
<p>Parameters:
							</p>
<blockquote class="text">
<p>[in] algorithm
								  Hash algorithm.
</p>
<p>[out] conduit_ref
								  Reference to resulting conduit.
</p>
</blockquote><p>
						
</p>
<p>Returns:
							</p>
<blockquote class="text">
<p>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_ALGO_INVALID,
							  S_ALGO_INCOMPATIBLE, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR,
							  S_CHANNEL_MAX
</p>
</blockquote><p>
						
</p>
<p>Method CICM::Answer::ChannelManager::create_mac_conduit()
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>CICM::Status create_mac_conduit(
	in  CICM::SymKey key_ref,
	in  CICM::SymMacAlgorithmId algorithm,
	out CICM::Answer::MACConduit conduit_ref
);</pre></div>
<p>Create conduit to calculate and generate a MAC.
</p>
<p>Parameters:
							</p>
<blockquote class="text">
<p>[in] key_ref
								  Reference to MAC key.
</p>
<p>[in] algorithm
								  MAC algorithm.
</p>
<p>[out] conduit_ref
								  Reference to resulting conduit.
</p>
</blockquote><p>
						
</p>
<p>Returns:
							</p>
<blockquote class="text">
<p>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_USED_INVALID,
							  S_KEY_USED_EXPIRED, S_KEY_USED_WRAPPED, S_KEY_USED_CONTEXT,
							  S_KEY_INVALID, S_KEY_EXPIRED, S_ALGO_INVALID,
							  S_ALGO_INCOMPATIBLE, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR,
							  S_CHANNEL_MAX
</p>
</blockquote><p>
						
</p>
<p>Method CICM::Answer::ChannelManager::create_mac_verify_conduit()
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>CICM::Status create_mac_verify_conduit(
	in  CICM::SymKey key_ref,
	in  CICM::SymMacAlgorithmId algorithm,
	out CICM::Answer::MACVerifyConduit conduit_ref
);</pre></div>
<p>Create conduit to verify a MAC.
</p>
<p>Parameters:
							</p>
<blockquote class="text">
<p>[in] key_ref
								  Reference to verification key.
</p>
<p>[in] algorithm
								  MAC algorithm.
</p>
<p>[out] conduit_ref
								  Reference to resulting conduit.
</p>
</blockquote><p>
						
</p>
<p>Returns:
							</p>
<blockquote class="text">
<p>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_USED_INVALID,
							  S_KEY_USED_EXPIRED, S_KEY_USED_WRAPPED, S_KEY_USED_CONTEXT,
							  S_KEY_INVALID, S_KEY_EXPIRED, S_ALGO_INVALID,
							  S_ALGO_INCOMPATIBLE, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR,
							  S_CHANNEL_MAX
</p>
</blockquote><p>
						
</p>
<p>Method CICM::Answer::ChannelManager::create_sign_conduit()
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>CICM::Status create_sign_conduit(
	in  CICM::AsymKey key_ref,
	in  CICM::AsymSigAlgorithmId algorithm,
	out CICM::Answer::SignConduit conduit_ref
);</pre></div>
<p>Create conduit to calculate and generate a signature.
</p>
<p>Parameters:
							</p>
<blockquote class="text">
<p>[in] key_ref
								  Reference to signature key.
</p>
<p>[in] algorithm
								  Signature algorithm.
</p>
<p>[out] conduit_ref
								  Reference to resulting conduit.
</p>
</blockquote><p>
						
</p>
<p>Returns:
							</p>
<blockquote class="text">
<p>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_USED_INVALID,
							  S_KEY_USED_EXPIRED, S_KEY_USED_WRAPPED, S_KEY_USED_CONTEXT,
							  S_KEY_USED_COMPONENT_NOT_AVAIL, S_KEY_INVALID, S_KEY_EXPIRED,
							  S_ALGO_INVALID, S_ALGO_INCOMPATIBLE, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR,
							  S_CHANNEL_MAX
</p>
</blockquote><p>
						
</p>
<p>Method CICM::Answer::ChannelManager::create_sign_hash_conduit()
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>CICM::Status create_sign_hash_conduit(
	in  CICM::AsymKey key_ref,
	in  CICM::AsymSigAlgorithmId algorithm,
	out CICM::Answer::SignHashConduit conduit_ref
);</pre></div>
<p>Create conduit to calculate and generate a signature
						accepting a previously generated hash value as input.
</p>
<p>Parameters:
							</p>
<blockquote class="text">
<p>[in] key_ref
								  Reference to signature key.
</p>
<p>[in] algorithm
								  Signature algorithm.
</p>
<p>[out] conduit_ref
								  Reference to resulting conduit.
</p>
</blockquote><p>
						
</p>
<p>Returns:
							</p>
<blockquote class="text">
<p>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_USED_INVALID,
							  S_KEY_USED_EXPIRED, S_KEY_USED_WRAPPED, S_KEY_USED_CONTEXT,
							  S_KEY_USED_COMPONENT_NOT_AVAIL, S_KEY_INVALID, S_KEY_EXPIRED,
							  S_ALGO_INVALID, S_ALGO_INCOMPATIBLE, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR,
							  S_CHANNEL_MAX
</p>
</blockquote><p>
						
</p>
<p>Method CICM::Answer::ChannelManager::create_verify_conduit()
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>CICM::Status create_verify_conduit(
	in  CICM::AsymKey key_ref,
	in  CICM::AsymSigAlgorithmId algorithm,
	out CICM::Answer::VerifyConduit conduit_ref
);</pre></div>
<p>Create conduit to verify a signature.
</p>
<p>Parameters:
							</p>
<blockquote class="text">
<p>[in] key_ref
								  Reference to verification key.
</p>
<p>[in] algorithm
								  Verification algorithm.
</p>
<p>[out] conduit_ref
								  Reference to resulting conduit.
</p>
</blockquote><p>
						
</p>
<p>Returns:
							</p>
<blockquote class="text">
<p>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_USED_INVALID,
							  S_KEY_USED_EXPIRED, S_KEY_USED_WRAPPED, S_KEY_USED_CONTEXT,
							  S_KEY_USED_COMPONENT_NOT_AVAIL, S_KEY_INVALID, S_KEY_EXPIRED,
							  S_ALGO_INVALID, S_ALGO_INCOMPATIBLE, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR,
							  S_CHANNEL_MAX
</p>
</blockquote><p>
						
</p>
<p>Method CICM::Answer::ChannelManager::create_verify_hash_conduit()
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>CICM::Status create_verify_hash_conduit(
	in  CICM::AsymKey key_ref,
	in  CICM::AsymSigAlgorithmId algorithm,
	out CICM::Answer::VerifyHashConduit conduit_ref
);</pre></div>
<p>Create conduit to verify a signature accepting a previously
						generated hash value as input.
</p>
<p>Parameters:
							</p>
<blockquote class="text">
<p>[in] key_ref
								  Reference to verification key.
</p>
<p>[in] algorithm
								  Verification algorithm.
</p>
<p>[out] conduit_ref
								  Reference to resulting conduit.
</p>
</blockquote><p>
						
</p>
<p>Returns:
							</p>
<blockquote class="text">
<p>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_USED_INVALID,
							  S_KEY_USED_EXPIRED, S_KEY_USED_WRAPPED, S_KEY_USED_CONTEXT,
							  S_KEY_USED_COMPONENT_NOT_AVAIL, S_KEY_INVALID, S_KEY_EXPIRED,
							  S_ALGO_INVALID, S_ALGO_INCOMPATIBLE, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR,
							  S_CHANNEL_MAX
</p>
</blockquote><p>
						
</p>
<a name="anchor253"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.17.2"></a><h3>17.2.&nbsp;
Interface CICM::Answer::PutStream</h3>

<p>Interface CICM::Answer::PutStream
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>interface PutStream : CICM::Stream {</pre></div>
<p>A stream that can write data to a module.
</p>
<a name="anchor254"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.17.2.1"></a><h3>17.2.1.&nbsp;
CICM::Answer::PutStream Inheritance</h3>

<p>CICM::Answer::PutStream inherits from: CICM::Stream.
</p>
<a name="anchor255"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.17.2.2"></a><h3>17.2.2.&nbsp;
CICM::Answer::PutStream Methods</h3>

<p>Method CICM::Answer::PutStream::put()
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>CICM::Status put(
	in  CICM::Buffer buffer
);</pre></div>
<p>Sends data to the module for transformation.
</p>
<p>Remarks:
							</p>
<blockquote class="text">
<p>This method blocks until the data is sent to the
							module.
</p>
</blockquote><p>
						
</p>
<p>Parameters:
							</p>
<blockquote class="text">
<p>[in] buffer
								  Buffer to write to the module.
</p>
</blockquote><p>
						
</p>
<p>Returns:
							</p>
<blockquote class="text">
<p>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_INVALID,
							  S_KEY_EXPIRED, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR,
							  S_CHANNEL_IO_ERROR, S_CHANNEL_DATA_INVALID,
							  S_CHANNEL_DATA_INVALID_LEN
</p>
</blockquote><p>
						
</p>
<a name="anchor256"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.17.3"></a><h3>17.3.&nbsp;
Interface CICM::Answer::HashConduit</h3>

<p>Interface CICM::Answer::HashConduit
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>interface HashConduit :
	CICM::Conduit,
	CICM::Answer::PutStream {</pre></div>
<p>CICM::Answer::HashConduit supports hashing operations within
					a single security domain. It is created by calling
					CICM::ChannelManager::create_hash_conduit.
</p>
<p>Remarks:
						</p>
<blockquote class="text">
<p>Keyed hashes are supported by MAC channels.
</p>
</blockquote><p>
					
</p>
<a name="anchor257"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.17.3.1"></a><h3>17.3.1.&nbsp;
CICM::Answer::HashConduit Inheritance</h3>

<p>CICM::Answer::HashConduit inherits from:
						CICM::Conduit and CICM::Answer::PutStream.
</p>
<a name="anchor258"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.17.3.2"></a><h3>17.3.2.&nbsp;
CICM::Answer::HashConduit Attributes</h3>

<p>AttributeCICM::Answer::HashConduit::algorithm
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>readonly attribute CICM::HashAlgorithmId algorithm;</pre></div>
<p>Algorithm used to compute the hash.
</p>
<a name="anchor259"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.17.3.3"></a><h3>17.3.3.&nbsp;
CICM::Answer::HashConduit Methods</h3>

<p>Method CICM::Answer::HashConduit::end_get_hash()
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>CICM::Status end_get_hash(
	out HashBuffer hash
);</pre></div>
<p>Direct the module to compute and output the message digest
						value, and reset the conduit to accept additional data.
</p>
<p>Parameters:
							</p>
<blockquote class="text">
<p>[out] hash
								  Resulting hash.
</p>
</blockquote><p>
						
</p>
<p>Returns:
							</p>
<blockquote class="text">
<p>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR
</p>
</blockquote><p>
						
</p>
<a name="anchor260"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.17.4"></a><h3>17.4.&nbsp;
Interface CICM::Answer::MACConduit</h3>

<p>Interface CICM::Answer::MACConduit
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>interface MACConduit :
	CICM::AbstractMACConduit,
	CICM::Answer::PutStream {</pre></div>
<p>CICM::Answer::MACConduit supports message authentication code
					operations within a single security domain. It is created by
					calling CICM::ChannelManager::create_mac_conduit.
</p>
<a name="anchor261"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.17.4.1"></a><h3>17.4.1.&nbsp;
CICM::Answer::MACConduit Inheritance</h3>

<p>CICM::Answer::MACConduit inherits from:
						CICM::AbstractMACConduit and CICM::Answer::PutStream.
</p>
<a name="anchor262"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.17.5"></a><h3>17.5.&nbsp;
Interface CICM::Answer::MACVerifyConduit</h3>

<p>Interface  CICM::Answer::MACVerifyConduit
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>interface MACVerifyConduit :
	CICM::AbstractMACVerifyConduit,
	CICM::Answer::PutStream {</pre></div>
<p>CICM::Answer::MACVerifyConduit supports message
					authentication code verification operations within a single
					security domain. It is created by calling
					CICM::ChannelManager::create_mac_verify_conduit.
</p>
<a name="anchor263"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.17.5.1"></a><h3>17.5.1.&nbsp;
CICM::Answer::MACVerifyConduit Inheritance</h3>

<p>CICM::Answer::MACVerifyConduit inherits from:
						CICM::AbstractMACVerifyConduit and CICM::Answer::PutStream.
</p>
<a name="anchor264"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.17.6"></a><h3>17.6.&nbsp;
Interface CICM::Answer::SignConduit</h3>

<p>Interface CICM::Answer::SignConduit
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>interface SignConduit :
	CICM::AbstractSignConduit,
	CICM::Answer::PutStream {</pre></div>
<p>CICM::Answer::SignConduit supports signature operations
					within a single security domain. It is created by calling
					CICM::ChannelManager::create_sign_conduit.
</p>
<a name="anchor265"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.17.6.1"></a><h3>17.6.1.&nbsp;
CICM::Answer::SignConduit Inheritance</h3>

<p>CICM::Answer::SignConduit inherits from:
						CICM::AbstractSignConduit and CICM::Answer::PutStream.
</p>
<a name="anchor266"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.17.7"></a><h3>17.7.&nbsp;
Interface CICM::Answer::SignHashConduit</h3>

<p>Interface  CICM::Answer::SignHashConduit
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>interface SignHashConduit : CICM::Answer::SignConduit {};</pre></div>
<p>CICM::Answer::SignHashConduit supports signature operations
					accepting a pre-generated hash value within a single security
					domain. It is created by calling
					CICM::ChannelManager::create_sign_hash_conduit.
</p>
<a name="anchor267"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.17.7.1"></a><h3>17.7.1.&nbsp;
CICM::Answer::SignHashConduit Inheritance</h3>

<p>CICM::Answer::SignHashConduit inherits from:
						CICM::Answer::SignConduit.
</p>
<a name="anchor268"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.17.8"></a><h3>17.8.&nbsp;
Interface CICM::Answer::VerifyConduit</h3>

<p>Interface CICM::Answer::VerifyConduit
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>interface VerifyConduit :
	CICM::AbstractSigVerifyConduit,
	CICM::Answer::PutStream {</pre></div>
<p>CICM::Answer::VerifyConduit supports verification operations
					within a single security domain. It is created by calling
					CICM::ChannelManager::create_verify_conduit.
</p>
<a name="anchor269"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.17.8.1"></a><h3>17.8.1.&nbsp;
CICM::Answer::VerifyConduit Inheritance</h3>

<p>CICM::Answer::VerifyConduit inherits from:
						CICM::AbstractSigVerifyConduit and CICM::Answer::PutStream.
</p>
<a name="anchor270"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.17.9"></a><h3>17.9.&nbsp;
Interface CICM::Answer::VerifyHashConduit</h3>

<p>Interface  CICM::Answer::VerifyHashConduit
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>interface VerifyHashConduit : CICM::Answer::VerifyConduit {};</pre></div>
<p>CICM::Answer::VerifyHashConduit supports verification
					operations accepting a pre-generated hash value within a single
					security domain. It is created by calling
					CICM::ChannelManager::create_verify_hash_conduit.
</p>
<a name="anchor271"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.17.9.1"></a><h3>17.9.1.&nbsp;
CICM::Answer::VerifyHashConduit Inheritance</h3>

<p>CICM::Answer::VerifyHashConduit inherits from:
						CICM::Answer::VerifyConduit.
</p>
<a name="sec-coprocessor"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.18"></a><h3>18.&nbsp;
Single-Domain</h3>

<p>Namespace CICM::Coprocessor
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>module Coprocessor {</pre></div>
<p>The CICM::Coprocessor namespace contains interfaces that
				support encryption/decryption operations within a single security
				domain.
</p>
<a name="anchor272"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.18.1"></a><h3>18.1.&nbsp;
Interface CICM::Coprocessor::ChannelManager</h3>

<p>Interface  CICM::Coprocessor::ChannelManager
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>interface ChannelManager {</pre></div>
<p>CICM::Coprocessor::ChannelManager is an abstraction inherited
					by CICM::ChannelManager that supports the creation of conduits to
					encrypt and decrypt data within a single security domain. See
					CICM::ChannelManager for additional information.
</p>
<a name="anchor273"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.18.1.1"></a><h3>18.1.1.&nbsp;
CICM::Coprocessor::ChannelManager Methods</h3>

<p>Method CICM::Coprocessor::ChannelManager::create_coprocessor_encrypt_conduit()
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>CICM::Status create_coprocessor_encrypt_conduit(
	in  CICM::SymKey key_ref,
	in  CICM::SymEncrAlgorithmId algorithm,
	out CICM::Coprocessor::EncryptConduit conduit_ref
);</pre></div>
<p>Create conduit to encrypt a stream of data within a single
						security domain.
</p>
<p>Parameters:
							</p>
<blockquote class="text">
<p>[in] key_ref
								  Reference to encryption key.
</p>
<p>[in] algorithm
								  Encryption algorithm/mode.
</p>
<p>[out] conduit_ref
								  Reference to resulting conduit.
</p>
</blockquote><p>
						
</p>
<p>Returns:
							</p>
<blockquote class="text">
<p>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_USED_INVALID,
							  S_KEY_USED_EXPIRED, S_KEY_USED_WRAPPED, S_KEY_USED_CONTEXT,
							  S_KEY_INVALID, S_KEY_EXPIRED, S_ALGO_INVALID,
							  S_ALGO_INCOMPATIBLE, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR,
							  S_CHANNEL_MAX
</p>
</blockquote><p>
						
</p>
<p>Method CICM::Coprocessor::ChannelManager::create_coprocessor_encrypt_with_mac_conduit()
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>CICM::Status create_coprocessor_encrypt_with_mac_conduit(
	in  CICM::SymKey mac_key_ref,
	in  CICM::SymKey encrypt_key_ref,
	in  CICM::SymMacAlgorithmId mac_algorithm,
	in  CICM::SymEncrAlgorithmId encrypt_algorithm,
	out CICM::Coprocessor::EncryptWithMACConduit conduit_ref
);</pre></div>
<p>Create conduit to MAC and encrypt a stream of data within a
						single security domain.
</p>
<p>Parameters:
							</p>
<blockquote class="text">
<p>[in] mac_key_ref
								  Reference to MAC key.
</p>
<p>[in] encrypt_key_ref
								  Reference to encryption key.
</p>
<p>[in] mac_algorithm
								  MAC algorithm.
</p>
<p>[in] encrypt_algorithm
								  Encryption algorithm/mode.
</p>
<p>[out] conduit_ref
								  Reference to resulting conduit.
</p>
</blockquote><p>
						
</p>
<p>Returns:
							</p>
<blockquote class="text">
<p>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_USED_INVALID,
							  S_KEY_USED_EXPIRED, S_KEY_USED_WRAPPED, S_KEY_USED_CONTEXT,
							  S_KEY_INVALID, S_KEY_EXPIRED, S_ALGO_INVALID,
							  S_ALGO_INCOMPATIBLE, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR,
							  S_CHANNEL_MAX
</p>
</blockquote><p>
						
</p>
<p>Method CICM::Coprocessor::ChannelManager::create_coprocessor_encrypt_with_sign_conduit()
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>CICM::Status create_coprocessor_encrypt_with_sign_conduit(
	in  CICM::AsymKey sign_key_ref,
	in  CICM::SymKey encrypt_key_ref,
	in  CICM::AsymSigAlgorithmId sign_algorithm,
	in  CICM::SymEncrAlgorithmId encrypt_algorithm,
	out CICM::Coprocessor::EncryptWithSignConduit conduit_ref
);</pre></div>
<p>Create conduit to sign and encrypt a stream of data within a
						single security domain.
</p>
<p>Parameters:
							</p>
<blockquote class="text">
<p>[in] sign_key_ref
								  Reference to signature key.
</p>
<p>[in] encrypt_key_ref
								  Reference to encryption key.
</p>
<p>[in] sign_algorithm
								  Signature algorithm.
</p>
<p>[in] encrypt_algorithm
								  Encryption algorithm/mode.
</p>
<p>[out] conduit_ref
								  Reference to resulting conduit.
</p>
</blockquote><p>
						
</p>
<p>Returns:
							</p>
<blockquote class="text">
<p>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_USED_INVALID,
							  S_KEY_USED_EXPIRED, S_KEY_USED_WRAPPED, S_KEY_USED_CONTEXT,
							  S_KEY_USED_COMPONENT_NOT_AVAIL, S_KEY_INVALID, S_KEY_EXPIRED,
							  S_ALGO_INVALID, S_ALGO_INCOMPATIBLE, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR,
							  S_CHANNEL_MAX
</p>
</blockquote><p>
						
</p>
<p>Method CICM::Coprocessor::ChannelManager::create_coprocessor_decrypt_conduit()
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>CICM::Status create_coprocessor_decrypt_conduit(
	in  CICM::SymKey key_ref,
	in  CICM::SymEncrAlgorithmId algorithm,
	out CICM::Coprocessor::DecryptConduit conduit_ref
);</pre></div>
<p>Create conduit to decrypt a stream of data within a single
						security domain.
</p>
<p>Parameters:
							</p>
<blockquote class="text">
<p>[in] key_ref
								  Reference to decryption key.
</p>
<p>[in] algorithm
								  Decryption algorithm/mode.
</p>
<p>[out] conduit_ref
								  Reference to resulting conduit.
</p>
</blockquote><p>
						
</p>
<p>Returns:
							</p>
<blockquote class="text">
<p>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_USED_INVALID,
							  S_KEY_USED_EXPIRED, S_KEY_USED_WRAPPED, S_KEY_USED_CONTEXT,
							  S_KEY_INVALID, S_KEY_EXPIRED, S_ALGO_INVALID,
							  S_ALGO_INCOMPATIBLE, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR,
							  S_CHANNEL_MAX
</p>
</blockquote><p>
						
</p>
<p>Method CICM::Coprocessor::ChannelManager::create_coprocessor_decrypt_with_mac_conduit()
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>CICM::Status create_coprocessor_decrypt_with_mac_conduit(
	in  CICM::SymKey mac_key_ref,
	in  CICM::SymKey decrypt_key_ref,
	in  CICM::SymMacAlgorithmId mac_algorithm,
	in  CICM::SymEncrAlgorithmId encrypt_algorithm,
	out CICM::Coprocessor::DecryptWithMACConduit conduit_ref
);</pre></div>
<p>Create conduit to MAC verify and decrypt a stream of data
						within a single security domain.
</p>
<p>Parameters:
							</p>
<blockquote class="text">
<p>[in] mac_key_ref
								  Reference to MAC key.
</p>
<p>[in] decrypt_key_ref
								  Reference to decryption key.
</p>
<p>[in] mac_algorithm
								  MAC algorithm.
</p>
<p>[in] encrypt_algorithm
								  Encryption algorithm/mode.
</p>
<p>[out] conduit_ref
								  Reference to resulting conduit.
</p>
</blockquote><p>
						
</p>
<p>Returns:
							</p>
<blockquote class="text">
<p>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_USED_INVALID,
							  S_KEY_USED_EXPIRED, S_KEY_USED_WRAPPED, S_KEY_USED_CONTEXT,
							  S_KEY_INVALID, S_KEY_EXPIRED, S_ALGO_INVALID,
							  S_ALGO_INCOMPATIBLE, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR,
							  S_CHANNEL_MAX
</p>
</blockquote><p>
						
</p>
<p>Method CICM::Coprocessor::ChannelManager::create_coprocessor_decrypt_with_verify_conduit()
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>CICM::Status create_coprocessor_decrypt_with_verify_conduit(
	in  CICM::AsymKey verify_key_ref,
	in  CICM::SymKey decrypt_key_ref,
	in  CICM::AsymSigAlgorithmId verify_algorithm,
	in  CICM::SymEncrAlgorithmId decrypt_algorithm,
	out CICM::Coprocessor::DecryptWithVerifyConduit conduit_ref
);</pre></div>
<p>Create conduit to verify and decrypt a stream of data within
						a single security domain.
</p>
<p>Parameters:
							</p>
<blockquote class="text">
<p>[in] verify_key_ref
								  Reference to verification key.
</p>
<p>[in] decrypt_key_ref
								  Reference to decryption key.
</p>
<p>[in] verify_algorithm
								  Verification algorithm.
</p>
<p>[in] decrypt_algorithm
								  Decryption algorithm/mode.
</p>
<p>[out] conduit_ref
								  Reference to resulting conduit.
</p>
</blockquote><p>
						
</p>
<p>Returns:
							</p>
<blockquote class="text">
<p>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_USED_INVALID,
							  S_KEY_USED_EXPIRED, S_KEY_USED_WRAPPED, S_KEY_USED_CONTEXT,
							  S_KEY_USED_COMPONENT_NOT_AVAIL, S_KEY_INVALID, S_KEY_EXPIRED,
							  S_ALGO_INVALID, S_ALGO_INCOMPATIBLE, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR,
							  S_CHANNEL_MAX
</p>
</blockquote><p>
						
</p>
<a name="anchor274"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.18.2"></a><h3>18.2.&nbsp;
Interface CICM::Coprocessor::Stream</h3>

<p>Interface CICM::Coprocessor::Stream
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>interface Stream : CICM::Stream {</pre></div>
<p>CICM::Coprocessor::Stream is an abstraction inherited by all
					conduits in the CICM::Coprocessor namespace.
</p>
<a name="anchor275"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.18.2.1"></a><h3>18.2.1.&nbsp;
CICM::Coprocessor::Stream Inheritance</h3>

<p>CICM::Coprocessor::Stream inherits from: CICM::Stream.
</p>
<a name="anchor276"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.18.2.2"></a><h3>18.2.2.&nbsp;
CICM::Coprocessor::Stream Methods</h3>

<p>Method CICM::Coprocessor::Stream::get_final_buffer()
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>CICM::Status get_final_buffer(
	out CICM::Buffer buffer
);</pre></div>
<p>Returns the final block of transformed data, if available.
						The method blocks until data becomes available.
</p>
<p>Remarks:
							</p>
<blockquote class="text">
<p>In certain cases, it may be necessary to retrieve the last
							transformed block of data, if, for example, a partial block
							remains after the last full block was retrieved. This call
							MUST be called after all data is supplied to the module
							and MUST precede any end_get_* calls.
</p>
</blockquote><p>
						
</p>
<p>Parameters:
							</p>
<blockquote class="text">
<p>[out] buffer
								  Buffer of data read from stream.
</p>
</blockquote><p>
						
</p>
<p>Returns:
							</p>
<blockquote class="text">
<p>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_INVALID,
							  S_KEY_EXPIRED, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT
</p>
</blockquote><p>
						
</p>
<a name="anchor277"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.18.3"></a><h3>18.3.&nbsp;
Interface CICM::Coprocessor::EncryptConduit</h3>

<p>Interface  CICM::Coprocessor::EncryptConduit
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>interface EncryptConduit :
	CICM::Conduit,
	CICM::SymKeyController,
	CICM::GenVectorController,
	CICM::ResyncController,
	CICM::Coprocessor::Stream {</pre></div>
<p>CICM::Coprocessor::EncryptConduit supports encryption
					operations within a single security domain. The resulting conduit
					is capable of managing the channel, accepting data for
					transformation, and receiving the result. It is created by calling
					CICM::ChannelManager::create_coprocessor_encrypt_conduit.
</p>
<a name="anchor278"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.18.3.1"></a><h3>18.3.1.&nbsp;
CICM::Coprocessor::EncryptConduit Inheritance</h3>

<p>CICM::Coprocessor::EncryptConduit inherits from:
						CICM::Conduit, CICM::SymKeyController, CICM::GenVectorController,
						CICM::ResyncController and CICM::Coprocessor::Stream.
</p>
<a name="anchor279"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.18.3.2"></a><h3>18.3.2.&nbsp;
CICM::Coprocessor::EncryptConduit Methods</h3>

<p>Method CICM::Coprocessor::EncryptConduit::encrypt()
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>CICM::Status encrypt(
	in  CICM::Buffer plaintext,
	out CICM::Buffer ciphertext
);</pre></div>
<p>Send plaintext to the module to be encrypted, receiving the
						ciphertext resulting from the transformation as the result.
</p>
<p>Parameters:
							</p>
<blockquote class="text">
<p>[in] plaintext
								  Plaintext to encrypt.
</p>
<p>[out] ciphertext
								  Ciphertext resulting from encryption operation.
</p>
</blockquote><p>
						
</p>
<p>Returns:
							</p>
<blockquote class="text">
<p>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR,
							  S_CHANNEL_IO_ERROR, S_CHANNEL_DATA_INVALID,
							  S_CHANNEL_DATA_INVALID_LEN, S_CHANNEL_BUFFER_LEN
</p>
</blockquote><p>
						
</p>
<a name="anchor280"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.18.4"></a><h3>18.4.&nbsp;
Interface CICM::Coprocessor::EncryptWithMACConduit</h3>

<p>Interface  CICM::Coprocessor::EncryptWithMACConduit
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>interface EncryptWithMACConduit :
	CICM::AbstractMACConduit,
	CICM::Coprocessor::EncryptConduit {</pre></div>
<p>CICM::Coprocessor::EncryptWithMACConduit supports encryption
					with MAC operations within a single security domain. The resulting
					conduit is capable of managing the channel, accepting data for
					transformation, and receiving the result (both ciphertext and a MAC
					value). It is created by calling
					CICM::ChannelManager::create_coprocessor_encrypt_with_mac_conduit.
</p>
<a name="anchor281"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.18.4.1"></a><h3>18.4.1.&nbsp;
CICM::Coprocessor::EncryptWithMACConduit Inheritance</h3>

<p>CICM::Coprocessor::EncryptWithMACConduit inherits
						from: CICM::AbstractMACConduit and
						CICM::Coprocessor::EncryptConduit.
</p>
<a name="anchor282"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.18.5"></a><h3>18.5.&nbsp;
Interface CICM::Coprocessor::EncryptWithSignConduit</h3>

<p>Interface  CICM::Coprocessor::EncryptWithSignConduit
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>interface EncryptWithSignConduit :
	CICM::AbstractSignConduit,
	CICM::Coprocessor::EncryptConduit {</pre></div>
<p>CICM::Coprocessor::EncryptWithSignConduit supports encryption
					with signature operations within a single security domain. The
					resulting conduit is capable of managing the channel, accepting
					data for transformation, and receiving the result (both ciphertext
					and a signature). It is created by calling
					CICM::ChannelManager::create_coprocessor_encrypt_with_sign_conduit.
</p>
<a name="anchor283"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.18.5.1"></a><h3>18.5.1.&nbsp;
CICM::Coprocessor::EncryptWithSignConduit Inheritance</h3>

<p>CICM::Coprocessor::EncryptWithSignConduit inherits
						from: CICM::AbstractSignConduit and
						CICM::Coprocessor::EncryptConduit.
</p>
<a name="anchor284"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.18.6"></a><h3>18.6.&nbsp;
Interface CICM::Coprocessor::DecryptConduit</h3>

<p>Interface  CICM::Coprocessor::DecryptConduit
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>interface DecryptConduit :
	CICM::Conduit,
	CICM::SymKeyController,
	CICM::SetVectorController,
	CICM::ResyncController,
	CICM::Coprocessor::Stream {</pre></div>
<p>CICM::Coprocessor::DecryptConduit supports decryption
					operations within a single security domain. The resulting conduit
					is capable of managing the channel, accepting data for
					transformation, and receiving the result. It is created by calling
					CICM::ChannelManager::create_coprocessor_decrypt_conduit.
</p>
<a name="anchor285"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.18.6.1"></a><h3>18.6.1.&nbsp;
CICM::Coprocessor::DecryptConduit Inheritance</h3>

<p>CICM::Coprocessor::DecryptConduit inherits from:
						CICM::Conduit, CICM::SymKeyController, CICM::SetVectorController,
						CICM::ResyncController and CICM::Coprocessor::Stream.
</p>
<a name="anchor286"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.18.6.2"></a><h3>18.6.2.&nbsp;
CICM::Coprocessor::DecryptConduit Methods</h3>

<p>Method CICM::Coprocessor::DecryptConduit::decrypt()
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>CICM::Status decrypt(
	in  CICM::Buffer ciphertext,
	out CICM::Buffer plaintext
);</pre></div>
<p>Send ciphertext to the module to be decrypted, receiving the
						plaintext resulting from the transformation as the result.
</p>
<p>Parameters:
							</p>
<blockquote class="text">
<p>[in] ciphertext
								  Ciphertext to decrypt.
</p>
<p>[out] plaintext
								  Plaintext resulting from decryption operation.
</p>
</blockquote><p>
						
</p>
<p>Returns:
							</p>
<blockquote class="text">
<p>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR,
							  S_CHANNEL_IO_ERROR, S_CHANNEL_DATA_INVALID,
							  S_CHANNEL_DATA_INVALID_LEN, S_CHANNEL_BUFFER_LEN
</p>
</blockquote><p>
						
</p>
<a name="anchor287"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.18.7"></a><h3>18.7.&nbsp;
Interface CICM::Coprocessor::DecryptWithMACConduit</h3>

<p>Interface  CICM::Coprocessor::DecryptWithMACConduit
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>interface DecryptWithMACConduit :
	CICM::AbstractMACVerifyConduit,
	CICM::Coprocessor::DecryptConduit {</pre></div>
<p>CICM::Coprocessor::DecryptWithMACConduit supports encryption
					with MAC verification operations within a single security domain.
					The resulting conduit is capable of managing the channel, accepting
					data for transformation, and receiving the result (both plaintext
					and an indication as to whether verification succeeded or failed).
					It is created by calling
					CICM::ChannelManager::create_coprocessor_decrypt_with_mac_conduit.
</p>
<a name="anchor288"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.18.7.1"></a><h3>18.7.1.&nbsp;
CICM::Coprocessor::DecryptWithMACConduit Inheritance</h3>

<p>CICM::Coprocessor::DecryptWithMACConduit inherits
						from: CICM::AbstractMACVerifyConduit and
						CICM::Coprocessor::DecryptConduit.
</p>
<a name="anchor289"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.18.8"></a><h3>18.8.&nbsp;
Interface CICM::Coprocessor::DecryptWithVerifyConduit</h3>

<p>Interface  CICM::Coprocessor::DecryptWithVerifyConduit
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>interface DecryptWithVerifyConduit :
CICM::AbstractSigVerifyConduit,
CICM::Coprocessor::DecryptConduit {</pre></div>
<p>CICM::Coprocessor::DecryptWithVerifyConduit supports
					encryption with signature verification operations within a single
					security domain. The resulting conduit is capable of managing the
					channel, accepting data for transformation, and receiving the
					result (both plaintext and an indication as to whether verification
					succeeded or failed). It is created by calling
					CICM::ChannelManager::create_coprocessor_decrypt_with_verify_conduit.
</p>
<a name="anchor290"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.18.8.1"></a><h3>18.8.1.&nbsp;
CICM::Coprocessor::DecryptWithVerifyConduit Inheritance</h3>

<p>CICM::Coprocessor::DecryptWithVerifyConduit
						inherits from: CICM::AbstractSigVerifyConduit and
						CICM::Coprocessor::DecryptConduit.
</p>
<a name="anchor291"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.19"></a><h3>19.&nbsp;
Channel Events</h3>

<a name="anchor292"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.19.1"></a><h3>19.1.&nbsp;
Interface CICM::ChannelEventManager</h3>

<p>Interface CICM::ChannelEventManager
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>interface ChannelEventManager {</pre></div>
<p>CICM::ChannelEventManager supports registering and
					unregistering user-defined channel event listeners
					(CICM::ChannelEventListener) for specific channel events. It is
					accessed from any channel via its CICM::Channel::event_manager
					attribute.
</p>
<p>Remarks:
						</p>
<blockquote class="text">
<p>In certain cases it may be necessary for a channel to
						asynchronously notify a client program of an event. Client
						programs can register to receive channel notifications using
						CICM::ChannelEventManager. This manager enables a client
						program to register a listener (callback) method designed to
						handle a specific condition. The event method prototype
						provided by the client program is defined in
						CICM::ChannelEventListener. CICM::ChannelEventListener also
						defines the conditions that may result in a notification,
						including: channel failure or channel destruction.
</p>
</blockquote><p>
					
</p>
<a name="anchor293"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.19.1.1"></a><h3>19.1.1.&nbsp;
CICM::ChannelEventManager Methods</h3>

<p>Method CICM::ChannelEventManager::register()
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>CICM::Status register(
	in  CICM::ChannelEventListener::ChannelEvent event,
	in  CICM::ChannelEventListener listener
);</pre></div>
<p>Registers the listener for a specific channel event.
</p>
<p>Remarks:
							</p>
<blockquote class="text">
<p>The provided listener applies only to the client program
							from which the registration is initiated.
</p>
</blockquote><p>
						
</p>
<p>Parameters:
							</p>
<blockquote class="text">
<p>[in] event
								  Event for which this listener is being
								  registered.
</p>
<p>[in] listener
								  Listener that will receive a notification about the
								  specified event.
</p>
</blockquote><p>
						
</p>
<p>Returns:
							</p>
<blockquote class="text">
<p>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_HOST_RESOURCES,
							  S_INVALID_STATE, S_ALARM_STATE, S_MODULE_NOT_AVAILABLE,
							  S_TIMEOUT, S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED,
							  S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT,
							  S_EVENT_REGISTERED, S_EVENT_NOT_SUPPORTED
</p>
</blockquote><p>
						
</p>
<p>Method CICM::ChannelEventManager::unregister()
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>CICM::Status unregister(
	in  CICM::ChannelEventListener::ChannelEvent event
);</pre></div>
<p>Unregisters the listener associated with the specified
						event.
</p>
<p>Remarks:
							</p>
<blockquote class="text">
<p>The listener associated with the specified event is only
							unregistered from the client program from which this method is
							called.
</p>
</blockquote><p>
						
</p>
<p>Parameters:
							</p>
<blockquote class="text">
<p>[in] event
								  Event that will no longer have a listener associated
								  with it.
</p>
</blockquote><p>
						
</p>
<p>Returns:
							</p>
<blockquote class="text">
<p>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_HOST_RESOURCES,
							  S_INVALID_STATE, S_ALARM_STATE, S_MODULE_NOT_AVAILABLE,
							  S_TIMEOUT, S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED,
							  S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT,
							  S_EVENT_NOT_REGISTERED
</p>
</blockquote><p>
						
</p>
<a name="anchor294"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.19.2"></a><h3>19.2.&nbsp;
Interface CICM::ChannelEventListener</h3>

<p>Interface CICM::ChannelEventListener
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>interface ChannelEventListener {</pre></div>
<p>CICM::ChannelEventListener is unlike other CICM interfaces in
					that the interface is implemented by the developer of the client
					program to service a specific channel event and is then registered
					via the CICM::ChannelEventManager.
</p>
<a name="anchor295"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.19.2.1"></a><h3>19.2.1.&nbsp;
CICM::ChannelEventListener Types and Constants</h3>

<p>Type CICM::ChannelEventListener::ChannelEvent
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>typedef CICM::UInt32 ChannelEvent;</pre></div>
<p>Events for which a ChannelEventListener can be notified.
</p>
<p>Constant CICM::ChannelEventListener::C_CHANNEL_DATA_AVAILABLE
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>const CICM::ChannelEventListener::ChannelEvent
	C_CHANNEL_DATA_AVAILABLE = 0x00004001;</pre></div>
<p>Data from remote peer is available.
</p>
<p>Constant CICM::ChannelEventListener::C_CHANNEL_ERROR
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>const CICM::ChannelEventListener::ChannelEvent
	C_CHANNEL_ERROR = 0x00004002;</pre></div>
<p>General error has occurred on the channel.
</p>
<p>Constant CICM::ChannelEventListener::C_CHANNEL_INSUFFICIENT_ENTROPY
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>const CICM::ChannelEventListener::ChannelEvent
	C_CHANNEL_INSUFFICIENT_ENTROPY = 0x00004004;</pre></div>
<p>Insufficient entropy available on the channel.
</p>
<p>Constant CICM::ChannelEventListener::C_CHANNEL_LOST_SYNC
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>const CICM::ChannelEventListener::ChannelEvent
	C_CHANNEL_LOST_SYNC = 0x00004007;</pre></div>
<p>Cryptographic synchronization with remote peer has been
						  lost; this may not be detectable by the cryptographic
						  module.
</p>
<p>Constant CICM::ChannelEventListener::C_CHANNEL_PEER_RESET
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>const CICM::ChannelEventListener::ChannelEvent
	C_CHANNEL_PEER_RESET = 0x00004008;</pre></div>
<p>Remote peer is no longer available; this may not be
						  detectable by the cryptographic module.
</p>
<a name="anchor296"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.19.2.2"></a><h3>19.2.2.&nbsp;
CICM::ChannelEventListener Methods</h3>

<p>Method CICM::ChannelEventListener::event_occurred()
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre> void event_occurred(
	in  CICM::ChannelEventListener::ChannelEvent event,
	in  CICM::Buffer event_data
);</pre></div>
<p>Method implemented by client program that receives a message
						about a channel event that occurred. An opaque data field with
						additional information about the event in a module-specific format
						may optionally be provided with the event itself.
</p>
<p>Remarks:
							</p>
<blockquote class="text">
<p>The format of the event data value is not defined by CICM.
							The Implementation Conformance Statement (see
							Conformance and Extensions in <a class='info' href='#CICM'>[CICM]<span> (</span><span class='info'>Lanz, D. and L. Novikov, &ldquo;Common Interface to Cryptographic Modules (CICM)           [RFC Editor: Please update the RFC reference and date prior to publication.],&rdquo; January&nbsp;2011.</span><span>)</span></a>) MUST
              reference a standard format or
							define a module-specific format for this datatype.
</p>
</blockquote><p>
						
</p>
<p>Note:
							</p>
<blockquote class="text">
<p>Because this method is called by the runtime system and not
							a client program, it does not return a status value.
</p>
</blockquote><p>
						
</p>
<p>Parameters:
							</p>
<blockquote class="text">
<p>[in] event
								  Event that occurred.
</p>
<p>[in] event_data
								  Opaque data associated with the event.
</p>
</blockquote><p>
						
</p>
<a name="anchor297"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.20"></a><h3>20.&nbsp;
Channel Groups</h3>

<a name="anchor298"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.20.1"></a><h3>20.1.&nbsp;
Interface CICM::ControllerGroup</h3>

<p>Interface CICM::ControllerGroup
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>interface ControllerGroup {</pre></div>
<p>Group of controllers and/or conduits.
</p>
<p>Remarks:
						</p>
<blockquote class="text">
<p>All of the controllers in a controller group share certain
						  characteristics, such as a state vector. Whenever a shared
						  characteristic is changed on a member of the group, the change is
						  applied to all members of the group. Thus, if a client program
						  has grouped controllers/conduits to follow advancing TOD rules,
						  for example, when one controller/conduit performs an operation at
						  time X as expressed in the TOD value, all other grouped
						  controllers/conduits are prohibited from using a TOD value
						  earlier than time X.
</p>
</blockquote><p>
					
</p>
<a name="anchor299"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.20.1.1"></a><h3>20.1.1.&nbsp;
CICM::ControllerGroup Methods</h3>

<p>Method CICM::ControllerGroup::add()
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>CICM::Status add(
	in CICM::Controller controller_ref
);</pre></div>
<p>Add a controller or conduit to this controller group.
</p>
<p>Parameters:
							</p>
<blockquote class="text">
<p>[in] controller_ref
								  Controller to add to the group.
</p>
</blockquote><p>
						
</p>
<p>Returns:
							</p>
<blockquote class="text">
<p>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_IN_GROUP,
							  S_CHANNEL_CLASSIFICATION
</p>
</blockquote><p>
						
</p>
<a name="anchor300"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.21"></a><h3>21.&nbsp;
IANA Considerations</h3>

<p>[RFC Editor: Please remove this section prior to publication.]
</p>
<p>This document has no IANA actions.
</p>
<a name="anchor301"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.22"></a><h3>22.&nbsp;
Security Considerations</h3>

<a name="anchor302"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.22.1"></a><h3>22.1.&nbsp;
Confidentiality</h3>

<p>This document defines several channels that provide confidentiality
          services such encryption and decryption as defined in the CICM::Encrypt,
          CICM::Decrypt, CICM::Duplex, CICM::EncryptBypass, CICM::DecryptBypass,
          and CICM::Coprocessor namespaces. Note, however, that the CICM::EncryptBypass
          and CICM::DecryptBypass namespaces are capable of sending unencrypted data
          (see Bypass below).
</p>
<a name="anchor303"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.22.2"></a><h3>22.2.&nbsp;
Bypass</h3>

<p>This document defines four namespaces related to sending and receiving
          bypass data. CICM::BypassWrite and CICM::BypassRead are for full bypass while
          CICM::EncryptBypass and CICM::DecryptBypass are for selective bypass.
</p>
<p>Unintentional sending of bypass data is typically considered a comprimise
          in the confidentiality of a system, and therefore implementors are urged to
          consider their security policies carefully.
</p>
<p>To mitigate against accidental programming errors related to bypass, this document 
          ensures that:
            </p>
<ol class="text">
<li>All bypass functionality is contained four clearly labeled distinct namespaces.
</li>
<li>Each method that touches bypass data contains bypass as part of its name 
              (e.g., CICM::BypassWrite::Stream::write_bypass()).
</li>
</ol><p>
          
</p>
<a name="anchor304"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.22.3"></a><h3>22.3.&nbsp;
Data Integrity</h3>

<p>This document defines several data integrity services either as stand-alone or 
          hybrid channels. The CICM::Answer namespace contains channels for hashing, signing,
          and verifying signed data. Similarly, CICM::Encrypt, CICM::Decrypt, CICM::Coprocessor 
          have channels that, in addition to encrypting or decrypting, sign or verify the 
          transmitted data.
</p>
<a name="anchor305"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.22.4"></a><h3>22.4.&nbsp;
Peer Entity Authentication</h3>

<p>This document defines a CICM::Negotiator which defines the basic peer-entity authentication
          mechanism. Channels defined in the CICM::Encrypt, CICM::Decrypt, CICM::Duplex, 
          CICM::EncryptBypass, and CICM::DecryptBypass namespaces define negotiated versions of
          most of the channels. See Channel Negotiation (<a class='info' href='#sec_channel_negotiation'>Section&nbsp;8<span> (</span><span class='info'>Channel Negotiation</span><span>)</span></a>)
          for more information.
</p>
<a name="rfc.references"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.23"></a><h3>23.&nbsp;
References</h3>

<a name="rfc.references1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>23.1.&nbsp;Normative References</h3>
<table width="99%" border="0">
<tr><td class="author-text" valign="top"><a name="CICM">[CICM]</a></td>
<td class="author-text">Lanz, D. and L. Novikov, &ldquo;<a href="http://tools.ietf.org/id/draft-lanz-cicm-02.txt">Common Interface to Cryptographic Modules (CICM)
          [RFC Editor: Please update the RFC reference and date prior to publication.]</a>,&rdquo; January&nbsp;2011.</td></tr>
<tr><td class="author-text" valign="top"><a name="CICM-KM">[CICM-KM]</a></td>
<td class="author-text">Lanz, D. and L. Novikov, &ldquo;<a href="http://tools.ietf.org/id/draft-lanz-cicm-keys-00.txt">Common Interface to Cryptographic Modules (CICM) Key Management
          [RFC Editor: Please update the RFC reference and date prior to publication.]</a>,&rdquo; January&nbsp;2011.</td></tr>
<tr><td class="author-text" valign="top"><a name="IDL">[IDL]</a></td>
<td class="author-text">International Standards Organization, &ldquo;Information technology — Open Distributed Processing — Interface Definition Language,&rdquo; ISO/IEC&nbsp;14750:1999(E), March&nbsp;1999.</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC2119">[RFC2119]</a></td>
<td class="author-text"><a href="mailto:sob@harvard.edu">Bradner, S.</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>,&rdquo; BCP&nbsp;14, RFC&nbsp;2119, March&nbsp;1997 (<a href="http://www.rfc-editor.org/rfc/rfc2119.txt">TXT</a>, <a href="http://xml.resource.org/public/rfc/html/rfc2119.html">HTML</a>, <a href="http://xml.resource.org/public/rfc/xml/rfc2119.xml">XML</a>).</td></tr>
</table>

<a name="rfc.references2"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>23.2.&nbsp;Informative References</h3>
<table width="99%" border="0">
<tr><td class="author-text" valign="top"><a name="CICM-LM">[CICM-LM]</a></td>
<td class="author-text">Lanz, D. and L. Novikov, &ldquo;<a href="http://tools.ietf.org/id/draft-lanz-cicm-model-00.txt">Common Interface to Cryptographic Modules (CICM) Logical Model
          [RFC Editor: Please update the RFC reference and date prior to publication.]</a>,&rdquo; January&nbsp;2011.</td></tr>
<tr><td class="author-text" valign="top"><a name="CORBA">[CORBA]</a></td>
<td class="author-text">Object Management Group, &ldquo;Common Object Request Broker Architecture (CORBA) Specification, Version 3.1,&rdquo; January&nbsp;2008.</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC3552">[RFC3552]</a></td>
<td class="author-text">Rescorla, E. and B. Korver, &ldquo;<a href="http://tools.ietf.org/html/rfc3552">Guidelines for Writing RFC Text on Security Considerations</a>,&rdquo; BCP&nbsp;72, RFC&nbsp;3552, July&nbsp;2003 (<a href="http://www.rfc-editor.org/rfc/rfc3552.txt">TXT</a>).</td></tr>
</table>

<a name="idl-code"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.A"></a><h3>Appendix A.&nbsp;
IDL Definitions</h3>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>module CICM {
  typedef CICM::Buffer MACBuffer;
  typedef CICM::Buffer SigBuffer;
  typedef CICM::Buffer HashBuffer;
  typedef CICM::Buffer Vector;

  typedef CICM::UInt32 TransId;

  typedef CICM::CharString HashAlgorithmId;

  typedef CICM::CharString AsymEncrAlgorithmId;
  const CICM::AsymEncrAlgorithmId IMPLICIT_ASYM_ENCR_ALGO = "IMPLICIT";

  typedef CICM::CharString AsymSigAlgorithmId;
  const CICM::AsymSigAlgorithmId IMPLICIT_ASYM_SIG_ALGO = "IMPLICIT";

  typedef CICM::CharString SymEncrAlgorithmId;
  const CICM::SymEncrAlgorithmId IMPLICIT_SYM_ENCR_ALGO = "IMPLICIT";

  typedef CICM::CharString SymMacAlgorithmId;
  const CICM::SymMacAlgorithmId IMPLICIT_SYM_MAC_ALGO = "IMPLICIT";

  typedef CICM::CharString KeyWrapAlgorithmId;
  const CICM::KeyWrapAlgorithmId IMPLICIT_KEY_WRAP_ALGO = "IMPLICIT";

  typedef CICM::CharString ProtocolId;
  const CICM::ProtocolId IMPLICIT_PROTOCOL_ID = "IMPLICIT";

  interface PeerInfo {
    readonly attribute CICM::CharString peer_name;
    readonly attribute CICM::Classification classification;
    readonly attribute CICM::CharString compartment;
    readonly attribute CICM::CharString message;
  };

  interface Negotiator {
    CICM::Status get_remote_info(
      out CICM::PeerInfo peer_info );

    CICM::Status abort_negotiation();
  };

  interface ChannelEventListener {
    typedef CICM::UInt32 ChannelEvent;
    const CICM::ChannelEventListener::ChannelEvent
      C_CHANNEL_DATA_AVAILABLE = 0x00004001;

    const CICM::ChannelEventListener::ChannelEvent
      C_CHANNEL_ERROR = 0x00004002;

    const CICM::ChannelEventListener::ChannelEvent
      C_CHANNEL_INSUFFICIENT_ENTROPY = 0x00004004;

    const CICM::ChannelEventListener::ChannelEvent
      C_CHANNEL_LOST_SYNC = 0x00004007;

    const CICM::ChannelEventListener::ChannelEvent
      C_CHANNEL_PEER_RESET = 0x00004008;

    void event_occurred(
      in  CICM::ChannelEventListener::ChannelEvent event,
      in  CICM::Buffer event_data );
  };

  interface ChannelEventManager {
    CICM::Status register(
      in  CICM::ChannelEventListener::ChannelEvent event,
      in  CICM::ChannelEventListener listener );

    CICM::Status unregister(
      in  CICM::ChannelEventListener::ChannelEvent event );
  };

  interface Channel {
    readonly attribute CICM::ChannelEventManager event_manager;
  };

  interface Stream : CICM::Channel {};

  interface WriteStream : CICM::Stream {
    typedef CICM::UInt32 WriteStatus;
    const CICM::WriteStream::WriteStatus C_WRITE_NOT_READY = 0x00006067;
    const CICM::WriteStream::WriteStatus C_WRITE_READY = 0x00006068;
  };

  interface ReadStream : CICM::Stream {
    typedef CICM::UInt32 ReadStatus;
    const CICM::ReadStream::ReadStatus C_READ_NOT_READY = 0x0000605E;
    const CICM::ReadStream::ReadStatus C_READ_READY = 0x00006061;
  };

  interface Controller : CICM::Channel {
    CICM::Status destroy();
  };

  interface MultiDomainController : CICM::Controller {
    readonly attribute CICM::LocalPort local_port;
    readonly attribute CICM::RemotePort remote_port;
  };

  interface SymKeyController : CICM::Controller {
    readonly attribute CICM::SymKey key;

    CICM::Status update_key();

    CICM::Status update_key_with_algo(
      in  CICM::SymEncrAlgorithmId algorithm );

    CICM::Status rollover_key();

    CICM::Status rollover_key_with_key(
      in  CICM::SymKey next_key );
  };

  interface AsymKeyController : CICM::Controller {
    readonly attribute CICM::AsymKey key;
  };

  interface NegotiatedController :
    CICM::MultiDomainController,
    CICM::AsymKeyController,
    CICM::Negotiator {

    readonly attribute CICM::Classification negotiated_grade;

    CICM::Status renegotiate();

    CICM::Status initiate_grade_change(
      in  CICM::Classification new_grade );

    CICM::Status acknowledge_grade_change();
  };

  interface SetVectorController : CICM::Controller {
    readonly attribute CICM::Vector vec;

    CICM::Status set_vector(
      in  CICM::Vector vec );

    CICM::Status set_vector_no_check(
      in  CICM::Vector vec );

    CICM::Status reset_vector();
  };

  interface GenVectorController : CICM::SetVectorController {
    CICM::Status generate_vector();
    CICM::Status generate_vector_existing_state();
  };

  interface ResyncController : CICM::Controller {
    CICM::Status resync();
    CICM::Status resync_with_sync_vector(
      in  CICM::Vector vec );
  };

  interface ControllerGroup {
    CICM::Status add(
      in CICM::Controller controller_ref );
  };

  interface Conduit :
    CICM::Controller,
    CICM::Stream {
  };

  interface AbstractMACConduit : CICM::Conduit {
    readonly attribute CICM::SymKey mac_key;
    readonly attribute CICM::SymMacAlgorithmId mac_algorithm;

    CICM::Status end_get_mac(
      out CICM::MACBuffer mac );
  };

  interface AbstractSignConduit : CICM::Conduit {
    readonly attribute CICM::AsymKey sign_key;
    readonly attribute CICM::AsymSigAlgorithmId sign_algorithm;

    CICM::Status end_get_signature(
      out CICM::SigBuffer signature );
  };

  interface AbstractVerifyConduit : CICM::Conduit {
    typedef CICM::UInt32 VerifyStatus;
    const CICM::AbstractVerifyConduit::VerifyStatus
      C_DATA_VERIFIED = 0x00006025;

    const CICM::AbstractVerifyConduit::VerifyStatus
      C_DATA_NOT_VERIFIED = 0x00006026;

  };

  interface AbstractMACVerifyConduit : CICM::AbstractVerifyConduit {
    readonly attribute CICM::SymKey verify_key;
    readonly attribute CICM::SymMacAlgorithmId verify_algorithm;

    CICM::Status end_get_verified(
      in  CICM::MACBuffer mac,
      out CICM::AbstractVerifyConduit::VerifyStatus status );
  };

  interface AbstractSigVerifyConduit : CICM::AbstractVerifyConduit {
    readonly attribute CICM::AsymKey verify_key;
    readonly attribute CICM::AsymSigAlgorithmId verify_algorithm;

    CICM::Status end_get_verified(
      in  CICM::SigBuffer signature,
      out CICM::AbstractVerifyConduit::VerifyStatus status );
  };

  module Encrypt {
    interface Stream : CICM::WriteStream {
      CICM::Status encrypt(
        in  CICM::Buffer buffer );

      CICM::Status encrypt_non_blocking(
        in  CICM::Buffer buffer,
        in  CICM::TransId transaction_id );

      CICM::Status encrypt_poll(
        in  CICM::TransId transaction_id,
        out CICM::WriteStream::WriteStatus status );
    };

    interface KeyWrapStream : CICM::Stream {
      CICM::Status wrap_key(
        in CICM::Key key_ref );
    };

    interface Controller :
      CICM::MultiDomainController,
      CICM::SymKeyController,
      CICM::GenVectorController,
      CICM::ResyncController {};

    interface NegotiatedController :
      CICM::NegotiatedController,
      CICM::GenVectorController,
      CICM::ResyncController {};

    interface Conduit :
      CICM::Conduit,
      CICM::Encrypt::Controller,
      CICM::Encrypt::Stream {};

    interface NegotiatedConduit :
      CICM::Conduit,
      CICM::Encrypt::NegotiatedController,
      CICM::Encrypt::Stream {};

    interface WithMACConduit :
      CICM::AbstractMACConduit,
      CICM::Encrypt::Conduit {};

    interface WithMACNegotiatedConduit :
      CICM::AbstractMACConduit,
      CICM::Encrypt::NegotiatedConduit {};

    interface WithSignConduit :
      CICM::AbstractSignConduit,
      CICM::Encrypt::Conduit {};

    interface WithSignNegotiatedConduit :
      CICM::AbstractSignConduit,
      CICM::Encrypt::NegotiatedConduit {};

    interface KeyWrapConduit :
      CICM::Encrypt::Controller,
      CICM::Encrypt::KeyWrapStream {};

    interface ControllerNegotiator : CICM::Negotiator {
      CICM::Status complete(
        out CICM::Encrypt::NegotiatedController controller_ref );
    };

    interface Negotiator : CICM::Negotiator {
      CICM::Status complete(
        out CICM::Encrypt::NegotiatedConduit conduit_ref );
    };

    interface WithMACNegotiator : CICM::Negotiator {
      CICM::Status complete(
        out CICM::Encrypt::WithMACNegotiatedConduit conduit_ref );
    };

    interface WithSignNegotiator : CICM::Negotiator {
      CICM::Status complete(
        out CICM::Encrypt::WithSignNegotiatedConduit conduit_ref );
    };

    interface ChannelManager {
      CICM::Status negotiate_encrypt_conduit(
        in  CICM::RemotePort remote_port,
        in  CICM::ProtocolId protocol,
        in  CICM::AsymKey key_ref,
        out CICM::Encrypt::Negotiator negotiator_ref );

      CICM::Status negotiate_encrypt_with_mac_conduit(
        in  CICM::RemotePort remote_port,
        in  CICM::ProtocolId protocol,
        in  CICM::SymKey mac_key_ref,
        in  CICM::AsymKey nego_key_ref,
        in  CICM::SymMacAlgorithmId mac_algorithm,
        out CICM::Encrypt::WithMACNegotiator negotiator_ref );

      CICM::Status negotiate_encrypt_with_sign_conduit(
        in  CICM::RemotePort remote_port,
        in  CICM::ProtocolId protocol,
        in  CICM::AsymKey sign_key_ref,
        in  CICM::AsymKey nego_key_ref,
        in  CICM::AsymSigAlgorithmId sign_algorithm,
        out CICM::Encrypt::WithSignNegotiator negotiator_ref );

      CICM::Status negotiate_encrypt_controller(
        in  CICM::LocalPort local_port,
        in  CICM::RemotePort remote_port,
        in  CICM::ProtocolId protocol,
        in  CICM::AsymKey key_ref,
        out CICM::Encrypt::ControllerNegotiator negotiator_ref );

      CICM::Status create_encrypt_conduit(
        in  CICM::RemotePort remote_port,
        in  CICM::SymKey key_ref,
        in  CICM::SymEncrAlgorithmId algorithm,
        out CICM::Encrypt::Conduit conduit_ref );

      CICM::Status create_encrypt_with_mac_conduit(
        in  CICM::RemotePort remote_port,
        in  CICM::SymKey mac_key_ref,
        in  CICM::SymKey encrypt_key_ref,
        in  CICM::SymMacAlgorithmId mac_algorithm,
        in  CICM::SymEncrAlgorithmId encr_algorithm,
        out CICM::Encrypt::WithMACConduit conduit_ref );

      CICM::Status create_encrypt_with_sign_conduit(
        in  CICM::RemotePort remote_port,
        in  CICM::AsymKey sign_key_ref,
        in  CICM::SymKey encrypt_key_ref,
        in  CICM::AsymSigAlgorithmId sign_algorithm,
        in  CICM::SymEncrAlgorithmId encr_algorithm,
        out CICM::Encrypt::WithSignConduit conduit_ref );
      CICM::Status create_key_wrap_conduit(
        in  CICM::RemotePort remote_port,
        in  CICM::SymKey kek_ref,
        in  CICM::KeyWrapAlgorithmId algorithm,
        out CICM::Encrypt::KeyWrapConduit conduit_ref );

      CICM::Status create_encrypt_controller(
        in  CICM::LocalPort local_port,
        in  CICM::RemotePort remote_port,
        in  CICM::SymKey key_ref,
        in  CICM::SymEncrAlgorithmId algorithm,
        out CICM::Encrypt::Controller controller_ref );

      CICM::Status get_encrypt_stream(
        in  CICM::LocalPort local_port,
        out CICM::Encrypt::Stream stream_ref );
    };
  };

  module Decrypt {
    interface Stream : CICM::ReadStream {
      CICM::Status decrypt(
        out CICM::Buffer buffer );

      CICM::Status decrypt_non_blocking(
        out CICM::Buffer buffer,
        in  CICM::TransId transaction_id );

      CICM::Status decrypt_poll(
        in  CICM::TransId transaction_id,
        out CICM::ReadStream::ReadStatus status );
    };

    interface KeyUnwrapStream : CICM::Stream {
      CICM::Status unwrap_sym_key(
        out CICM::SymKey key_ref );

      CICM::Status unwrap_asym_key(
        out CICM::AsymKey key_ref );
    };

    interface Controller :
      CICM::MultiDomainController,
      CICM::SymKeyController,
      CICM::SetVectorController,
      CICM::ResyncController {};

    interface NegotiatedController :
      CICM::NegotiatedController,
      CICM::SetVectorController,
      CICM::ResyncController {};

    interface Conduit :
      CICM::Conduit,
      CICM::Decrypt::Controller,
      CICM::Decrypt::Stream {};

    interface NegotiatedConduit :
      CICM::Conduit,
      CICM::Decrypt::NegotiatedController,
      CICM::Decrypt::Stream {};

    interface WithMACConduit :
      CICM::AbstractMACVerifyConduit,
      CICM::Decrypt::Conduit {};

    interface WithMACNegotiatedConduit :
      CICM::AbstractMACVerifyConduit,
      CICM::Decrypt::NegotiatedConduit {};

    interface WithVerifyConduit :
      CICM::AbstractSigVerifyConduit,
      CICM::Decrypt::Conduit {};

    interface WithVerifyNegotiatedConduit :
      CICM::AbstractSigVerifyConduit,
      CICM::Decrypt::NegotiatedConduit {};

    interface KeyUnwrapConduit :
      CICM::Decrypt::Controller,
      CICM::Decrypt::KeyUnwrapStream {};

    interface Negotiator : CICM::Negotiator {
      CICM::Status complete(
        out CICM::Decrypt::NegotiatedConduit conduit_ref );
    };

    interface ControllerNegotiator : CICM::Negotiator {
      CICM::Status complete(
        out CICM::Decrypt::NegotiatedController controller_ref );
    };

    interface WithMACNegotiator : CICM::Negotiator {
      CICM::Status complete(
        out CICM::Decrypt::WithMACNegotiatedConduit conduit_ref );
    };

    interface WithVerifyNegotiator : CICM::Negotiator {
      CICM::Status complete(
        out CICM::Decrypt::WithVerifyNegotiatedConduit conduit_ref );
    };

    interface ChannelManager {
      CICM::Status negotiate_decrypt_conduit(
        in  CICM::RemotePort remote_port,
        in  CICM::ProtocolId protocol,
        in  CICM::AsymKey key_ref,
        out CICM::Decrypt::Negotiator negotiator_ref );

      CICM::Status negotiate_decrypt_with_mac_conduit(
        in  CICM::RemotePort remote_port,
        in  CICM::ProtocolId protocol,
        in  CICM::SymKey verify_key_ref,
        in  CICM::AsymKey nego_key_ref,
        in  CICM::SymMacAlgorithmId verify_algorithm,
        out CICM::Decrypt::WithMACNegotiator negotiator_ref );

      CICM::Status negotiate_decrypt_with_verify_conduit(
        in  CICM::RemotePort remote_port,
        in  CICM::ProtocolId protocol,
        in  CICM::AsymKey verify_key_ref,
        in  CICM::AsymKey nego_key_ref,
        in  CICM::AsymSigAlgorithmId verify_algorithm,
        out CICM::Decrypt::WithVerifyNegotiator negotiator_ref );

      CICM::Status negotiate_decrypt_controller(
        in  CICM::LocalPort local_port,
        in  CICM::RemotePort remote_port,
        in  CICM::ProtocolId protocol,
        in  CICM::AsymKey key_ref,
        out CICM::Decrypt::ControllerNegotiator negotiator_ref );

      CICM::Status create_decrypt_conduit(
        in  CICM::RemotePort remote_port,
        in  CICM::SymKey key_ref,
        in  CICM::SymEncrAlgorithmId algorithm,
        out CICM::Decrypt::Conduit conduit_ref );

      CICM::Status create_decrypt_with_mac_conduit(
        in  CICM::RemotePort remote_port,
        in  CICM::SymKey verify_key_ref,
        in  CICM::SymKey decrypt_key_ref,
        in  CICM::SymMacAlgorithmId verify_algorithm,
        in  CICM::SymEncrAlgorithmId decrypt_algorithm,
        out CICM::Decrypt::WithMACConduit conduit_ref );

      CICM::Status create_decrypt_with_verify_conduit(
        in  CICM::RemotePort remote_port,
        in  CICM::AsymKey verify_key_ref,
        in  CICM::SymKey decrypt_key_ref,
        in  CICM::AsymSigAlgorithmId verify_algorithm,
        in  CICM::SymEncrAlgorithmId decrypt_algorithm,
        out CICM::Decrypt::WithVerifyConduit conduit_ref );

      CICM::Status create_key_unwrap_conduit(
        in  CICM::RemotePort remote_port,
        in  CICM::SymKey kek_ref,
        in  CICM::KeyWrapAlgorithmId algorithm,
        out CICM::Decrypt::KeyUnwrapConduit conduit_ref );

      CICM::Status create_decrypt_controller(
        in  CICM::LocalPort local_port,
        in  CICM::RemotePort remote_port,
        in  CICM::SymKey key_ref,
        in  CICM::SymEncrAlgorithmId algorithm,
        out CICM::Decrypt::Controller controller_ref );

      CICM::Status get_decrypt_stream(
        in  CICM::LocalPort local_port,
        out CICM::Decrypt::Stream stream_ref );
    };
  };

  module Duplex {
    interface Stream :
      CICM::Encrypt::Stream,
      CICM::Decrypt::Stream {};

    interface Controller :
      CICM::Encrypt::Controller,
      CICM::Decrypt::Controller {};

    interface NegotiatedController :
      CICM::Encrypt::NegotiatedController,
      CICM::Decrypt::NegotiatedController {};

    interface Conduit :
      CICM::Conduit,
      CICM::Duplex::Controller,
      CICM::Duplex::Stream {};

    interface NegotiatedConduit :
      CICM::Duplex::NegotiatedController,
      CICM::Duplex::Stream {};

    interface ControllerNegotiator : CICM::Negotiator {
      CICM::Status complete(
        out CICM::Duplex::NegotiatedController controller_ref );
    };

    interface Negotiator : CICM::Negotiator {
       CICM::Status complete(
        out CICM::Duplex::NegotiatedConduit conduit_ref );
    };

    interface ChannelManager {
      CICM::Status negotiate_duplex_conduit(
        in  CICM::RemotePort remote_port,
        in  CICM::ProtocolId protocol,
        in  CICM::AsymKey key_ref,
        out CICM::Duplex::Negotiator negotiator_ref );

      CICM::Status negotiate_duplex_controller(
        in  CICM::LocalPort local_port,
        in  CICM::RemotePort remote_port,
        in  CICM::ProtocolId protocol,
        in  CICM::AsymKey key_ref,
        out CICM::Duplex::ControllerNegotiator negotiator_ref );

      CICM::Status create_duplex_conduit(
        in  CICM::RemotePort remote_port,
        in  CICM::SymKey key_ref,
        in  CICM::SymEncrAlgorithmId algorithm,
        out CICM::Duplex::Conduit conduit_ref );

      CICM::Status create_duplex_controller(
        in  CICM::LocalPort local_port,
        in  CICM::RemotePort remote_port,
        in  CICM::SymKey key_ref,
        in  CICM::SymEncrAlgorithmId algorithm,
        out CICM::Duplex::Controller controller_ref );

      CICM::Status get_duplex_stream(
        in  CICM::LocalPort local_port,
        out CICM::Duplex::Stream stream_ref );
    };
  };

  module BypassWrite {
    interface Stream : CICM::WriteStream {
      CICM::Status write_bypass(
        in  CICM::Buffer buffer );

      CICM::Status write_bypass_non_blocking(
        in  CICM::Buffer buffer,
        in  CICM::TransId transaction_id );

      CICM::Status write_bypass_poll(
        in  CICM::TransId transaction_id,
        out CICM::WriteStream::WriteStatus status );
    };

    interface Controller : CICM::MultiDomainController {};

    interface Conduit :
      CICM::Conduit,
      CICM::BypassWrite::Controller,
      CICM::BypassWrite::Stream {};

    interface ChannelManager {
      CICM::Status create_bypass_write_conduit(
        in  CICM::RemotePort remote_port,
        out CICM::BypassWrite::Conduit conduit_ref );

      CICM::Status create_bypass_write_controller(
        in  CICM::LocalPort local_port,
        in  CICM::RemotePort remote_port,
        out CICM::BypassWrite::Controller controller_ref );

      CICM::Status get_bypass_write_stream(
        in  CICM::LocalPort local_port,
        out CICM::BypassWrite::Stream stream_ref );
    };
  };

  module BypassRead {
    interface Stream : CICM::ReadStream {
      CICM::Status read_bypass(
        out CICM::Buffer buffer );

      CICM::Status read_bypass_non_blocking(
        out CICM::Buffer buffer,
        in   CICM::TransId transaction_id );

      CICM::Status read_bypass_poll(
        in  CICM::TransId transaction_id,
        out CICM::ReadStream::ReadStatus status );
    };

    interface Controller : CICM::MultiDomainController {};

    interface Conduit :
      CICM::Conduit,
      CICM::BypassRead::Controller,
      CICM::BypassRead::Stream {};

    interface ChannelManager {
      CICM::Status create_bypass_read_conduit(
        in  CICM::RemotePort remote_port,
        out CICM::BypassRead::Conduit conduit_ref );

      CICM::Status create_bypass_read_controller(
        in  CICM::LocalPort local_port,
        in  CICM::RemotePort remote_port,
        out CICM::BypassRead::Controller controller_ref );

      CICM::Status get_bypass_read_stream(
        in  CICM::LocalPort local_port,
        out CICM::BypassRead::Stream stream_ref );
    };
  };

  module EncryptBypass {
    interface Stream :
      CICM::Encrypt::Stream,
      CICM::BypassWrite::Stream {
    };

    interface NegotiatedController :
      CICM::Encrypt::NegotiatedController {};

    interface Controller : CICM::Encrypt::Controller {};

    interface Conduit :
      CICM::Encrypt::Conduit,
      CICM::EncryptBypass::Stream {};

    interface NegotiatedConduit :
      CICM::Encrypt::NegotiatedController,
      CICM::EncryptBypass::Stream {};

    interface ControllerNegotiator : CICM::Negotiator {
      CICM::Status complete(
        out CICM::EncryptBypass::NegotiatedController controller_ref );
    };

    interface Negotiator : CICM::Negotiator {
      CICM::Status complete(
        out CICM::EncryptBypass::NegotiatedConduit conduit_ref );
    };

    interface ChannelManager {
      CICM::Status negotiate_encrypt_bypass_conduit(
        in  CICM::RemotePort remote_port,
        in  CICM::ProtocolId protocol,
        in  CICM::AsymKey key_ref,
        out CICM::EncryptBypass::Negotiator negotiator_ref );

      CICM::Status negotiate_encrypt_bypass_controller(
        in  CICM::LocalPort local_port,
        in  CICM::RemotePort remote_port,
        in  CICM::ProtocolId protocol,
        in  CICM::AsymKey key_ref,
        out CICM::EncryptBypass::ControllerNegotiator negotiator_ref );

      CICM::Status create_encrypt_bypass_conduit(
        in  CICM::RemotePort remote_port,
        in  CICM::SymKey key_ref,
        in  CICM::SymEncrAlgorithmId algorithm,
        out CICM::EncryptBypass::Conduit conduit_ref );

      CICM::Status create_encrypt_bypass_controller(
        in  CICM::LocalPort local_port,
        in  CICM::RemotePort remote_port,
        in  CICM::SymKey key_ref,
        in  CICM::SymEncrAlgorithmId algorithm,
        out CICM::EncryptBypass::Controller controller_ref );

      CICM::Status get_encrypt_bypass_stream(
        in  CICM::LocalPort local_port,
        out CICM::EncryptBypass::Stream stream_ref );
    };
  };

  module DecryptBypass {
    interface Stream : CICM::Decrypt::Stream {};

    interface NegotiatedController :
      CICM::Decrypt::NegotiatedController {};

    interface Controller : CICM::Encrypt::Controller {};

    interface Conduit :
      CICM::Decrypt::Conduit,
      CICM::DecryptBypass::Controller,
      CICM::DecryptBypass::Stream {};

    interface NegotiatedConduit :
      CICM::Decrypt::NegotiatedConduit,
      CICM::DecryptBypass::NegotiatedController,
      CICM::DecryptBypass::Stream {};

    interface ControllerNegotiator : CICM::Negotiator {
      CICM::Status complete(
        out CICM::DecryptBypass::NegotiatedController controller_ref );
    };

    interface Negotiator : CICM::Negotiator {
      CICM::Status complete(
        out CICM::DecryptBypass::NegotiatedConduit conduit_ref );
    };

    interface ChannelManager {
      CICM::Status negotiate_decrypt_bypass_conduit(
        in  CICM::RemotePort remote_port,
        in  CICM::ProtocolId protocol,
        in  CICM::AsymKey key_ref,
        out CICM::DecryptBypass::Negotiator negotiator_ref );

      CICM::Status negotiate_decrypt_bypass_controller(
        in  CICM::LocalPort local_port,
        in  CICM::RemotePort remote_port,
        in  CICM::ProtocolId protocol,
        in  CICM::AsymKey key_ref,
        out CICM::DecryptBypass::ControllerNegotiator negotiator_ref );

      CICM::Status create_decrypt_bypass_conduit(
        in  CICM::RemotePort remote_port,
        in  CICM::SymKey key_ref,
        in  CICM::SymEncrAlgorithmId algorithm,
        out CICM::DecryptBypass::Conduit conduit_ref );

      CICM::Status create_decrypt_bypass_controller(
        in  CICM::LocalPort local_port,
        in  CICM::RemotePort remote_port,
        in  CICM::SymKey key_ref,
        in  CICM::SymEncrAlgorithmId algorithm,
        out CICM::DecryptBypass::Controller controller_ref );

      CICM::Status get_decrypt_bypass_stream(
        in  CICM::LocalPort local_port,
        out CICM::DecryptBypass::Stream stream_ref );
    };
  };

  module Emit {
    interface GetStream : CICM::ReadStream {
      CICM::Status get(
        in  CICM::UInt32 length,
        out CICM::Buffer buffer );

      CICM::Status get_non_blocking(
        in  CICM::UInt32 length,
        out CICM::Buffer buffer,
        in  CICM::TransId transaction_id );

      CICM::Status get_poll(
        in  CICM::TransId transaction_id,
        out CICM::ReadStream::ReadStatus status );
    };

    interface Controller : CICM::Controller {
      readonly attribute CICM::RemotePort remote_port;
    };

    interface KeyStreamGenController :
      CICM::SymKeyController,
      CICM::GenVectorController,
      CICM::Emit::Controller {};

    interface PseudoRandomController :
      CICM::SymKeyController,
      CICM::Emit::Controller {};

    interface RandomController : CICM::Emit::Controller {};

    interface KeyStreamGenConduit :
      CICM::Conduit,
      CICM::SymKeyController,
      CICM::GenVectorController,
      CICM::Emit::GetStream {};

    interface PseudoRandomConduit :
      CICM::Conduit,
      CICM::SymKeyController,
      CICM::Emit::GetStream {};

    interface RandomConduit :
      CICM::Conduit,
      CICM::Emit::GetStream {};

    interface ChannelManager {
      CICM::Status create_key_stream_gen_controller(
        in  CICM::RemotePort remote_port,
        in  CICM::SymKey key_ref,
        in  CICM::SymEncrAlgorithmId algorithm,
        out CICM::Emit::KeyStreamGenController controller_ref );

      CICM::Status create_pseudorandom_controller(
        in  CICM::RemotePort remote_port,
        in  CICM::SymKey seed,
        out CICM::Emit::PseudoRandomController controller_ref );

      CICM::Status create_random_controller(
        in  CICM::RemotePort remote_port,
        out CICM::Emit::RandomController controller_ref );

      CICM::Status create_key_stream_gen_conduit(
        in  CICM::SymKey key_ref,
        in  CICM::SymEncrAlgorithmId algorithm,
        out CICM::Emit::KeyStreamGenConduit conduit_ref );

      CICM::Status create_pseudorandom_conduit(
        in  CICM::SymKey seed,
        out CICM::Emit::PseudoRandomConduit conduit_ref );

      CICM::Status create_random_conduit(
        out CICM::Emit::RandomConduit conduit_ref );
    };
  };

  module Answer {
    interface PutStream : CICM::Stream {
      CICM::Status put(
        in  CICM::Buffer buffer );
    };

    interface HashConduit :
      CICM::Conduit,
      CICM::Answer::PutStream {

      readonly attribute CICM::HashAlgorithmId algorithm;

      CICM::Status end_get_hash(
        out HashBuffer hash );
    };

    interface MACConduit :
      CICM::AbstractMACConduit,
      CICM::Answer::PutStream {};

    interface MACVerifyConduit :
      CICM::AbstractMACVerifyConduit,
      CICM::Answer::PutStream {};

    interface SignConduit :
      CICM::AbstractSignConduit,
      CICM::Answer::PutStream {};

    interface SignHashConduit : CICM::Answer::SignConduit {};

    interface VerifyConduit :
      CICM::AbstractSigVerifyConduit,
      CICM::Answer::PutStream {};

    interface VerifyHashConduit : CICM::Answer::VerifyConduit {};

    interface ChannelManager {
      CICM::Status create_hash_conduit(
        in  CICM::HashAlgorithmId algorithm,
        out CICM::Answer::HashConduit conduit_ref );

      CICM::Status create_mac_conduit(
        in  CICM::SymKey key_ref,
        in  CICM::SymMacAlgorithmId algorithm,
        out CICM::Answer::MACConduit conduit_ref );

      CICM::Status create_mac_verify_conduit(
        in  CICM::SymKey key_ref,
        in  CICM::SymMacAlgorithmId algorithm,
        out CICM::Answer::MACVerifyConduit conduit_ref );

      CICM::Status create_sign_conduit(
        in  CICM::AsymKey key_ref,
        in  CICM::AsymSigAlgorithmId algorithm,
        out CICM::Answer::SignConduit conduit_ref );

      CICM::Status create_sign_hash_conduit(
        in  CICM::AsymKey key_ref,
        in  CICM::AsymSigAlgorithmId algorithm,
        out CICM::Answer::SignHashConduit conduit_ref );

      CICM::Status create_verify_conduit(
        in  CICM::AsymKey key_ref,
        in  CICM::AsymSigAlgorithmId algorithm,
        out CICM::Answer::VerifyConduit conduit_ref );

      CICM::Status create_verify_hash_conduit(
        in  CICM::AsymKey key_ref,
        in  CICM::AsymSigAlgorithmId algorithm,
        out CICM::Answer::VerifyHashConduit conduit_ref );
    };
  };

  module Coprocessor {
    interface Stream : CICM::Stream {
      CICM::Status get_final_buffer(
        out CICM::Buffer buffer );
    };

    interface EncryptConduit :
      CICM::Conduit,
      CICM::SymKeyController,
      CICM::GenVectorController,
      CICM::ResyncController,
      CICM::Coprocessor::Stream {

      CICM::Status encrypt(
        in  CICM::Buffer plaintext,
        out CICM::Buffer ciphertext );
    };

    interface EncryptWithMACConduit :
      CICM::AbstractMACConduit,
      CICM::Coprocessor::EncryptConduit {};

    interface EncryptWithSignConduit :
      CICM::AbstractSignConduit,
      CICM::Coprocessor::EncryptConduit {};

    interface DecryptConduit :
      CICM::Conduit,
      CICM::SymKeyController,
      CICM::SetVectorController,
      CICM::ResyncController,
      CICM::Coprocessor::Stream {

      CICM::Status decrypt(
        in  CICM::Buffer ciphertext,
        out CICM::Buffer plaintext );
    };

    interface DecryptWithMACConduit :
      CICM::AbstractMACVerifyConduit,
      CICM::Coprocessor::DecryptConduit {};

    interface DecryptWithVerifyConduit :
      CICM::AbstractSigVerifyConduit,
      CICM::Coprocessor::DecryptConduit {};

    interface ChannelManager {
      CICM::Status create_coprocessor_encrypt_conduit(
        in  CICM::SymKey key_ref,
        in  CICM::SymEncrAlgorithmId algorithm,
        out CICM::Coprocessor::EncryptConduit conduit_ref );

      CICM::Status create_coprocessor_encrypt_with_mac_conduit(
        in  CICM::SymKey mac_key_ref,
        in  CICM::SymKey encrypt_key_ref,
        in  CICM::SymMacAlgorithmId mac_algorithm,
        in  CICM::SymEncrAlgorithmId encrypt_algorithm,
        out CICM::Coprocessor::EncryptWithMACConduit conduit_ref );

      CICM::Status create_coprocessor_encrypt_with_sign_conduit(
        in  CICM::AsymKey sign_key_ref,
        in  CICM::SymKey encrypt_key_ref,
        in  CICM::AsymSigAlgorithmId sign_algorithm,
        in  CICM::SymEncrAlgorithmId encrypt_algorithm,
        out CICM::Coprocessor::EncryptWithSignConduit conduit_ref );

      CICM::Status create_coprocessor_decrypt_conduit(
        in  CICM::SymKey key_ref,
        in  CICM::SymEncrAlgorithmId algorithm,
        out CICM::Coprocessor::DecryptConduit conduit_ref );

      CICM::Status create_coprocessor_decrypt_with_mac_conduit(
        in  CICM::SymKey mac_key_ref,
        in  CICM::SymKey decrypt_key_ref,
        in  CICM::SymMacAlgorithmId mac_algorithm,
        in  CICM::SymEncrAlgorithmId encrypt_algorithm,
        out CICM::Coprocessor::DecryptWithMACConduit conduit_ref );

      CICM::Status create_coprocessor_decrypt_with_verify_conduit(
        in  CICM::AsymKey verify_key_ref,
        in  CICM::SymKey decrypt_key_ref,
        in  CICM::AsymSigAlgorithmId verify_algorithm,
        in  CICM::SymEncrAlgorithmId decrypt_algorithm,
        out CICM::Coprocessor::DecryptWithVerifyConduit conduit_ref );
    };
  };

  interface ChannelManager :
    CICM::Answer::ChannelManager,
    CICM::BypassRead::ChannelManager,
    CICM::BypassWrite::ChannelManager,
    CICM::Coprocessor::ChannelManager,
    CICM::Decrypt::ChannelManager,
    CICM::DecryptBypass::ChannelManager,
    CICM::Duplex::ChannelManager,
    CICM::Emit::ChannelManager,
    CICM::Encrypt::ChannelManager,
    CICM::EncryptBypass::ChannelManager {

    CICM::Status create_controller_group(
      out CICM::ControllerGroup controller_group_ref );
  };
};</pre></div>
<a name="rfc.authors"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>Authors' Addresses</h3>
<table width="99%" border="0" cellpadding="0" cellspacing="0">
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Daniel J. Lanz</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">The MITRE Corporation</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:dlanz@mitre.org">dlanz@mitre.org</a></td></tr>
<tr cellpadding="3"><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Lev Novikov</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">The MITRE Corporation</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:lnovikov@mitre.org">lnovikov@mitre.org</a></td></tr>
</table>
</body></html>
