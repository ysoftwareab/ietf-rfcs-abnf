<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" 
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html lang="en" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head profile="http://www.w3.org/2006/03/hcard%20http://dublincore.org/documents/2008/08/04/dc-html/">
  <meta http-equiv="Content-Type" content="text/html; charset=us-ascii" />

  <title>The WebSocket protocol</title>

  <style type="text/css" title="Xml2Rfc (sans serif)">
  /*<![CDATA[*/
	  a {
	  text-decoration: none;
	  }
	  a.smpl {
	  color: black;
	  }
	  a:hover {
	  text-decoration: underline;
	  }
	  a:active {
	  text-decoration: underline;
	  }
	  address {
	  margin-top: 1em;
	  margin-left: 2em;
	  font-style: normal;
	  }
	  body {
	  color: black;
	  font-family: verdana, helvetica, arial, sans-serif;
	  font-size: 10pt;
	  
	  }
	  cite {
	  font-style: normal;
	  }
	  dd {
	  margin-right: 2em;
	  }
	  dl {
	  margin-left: 2em;
	  }
	
	  ul.empty {
	  list-style-type: none;
	  }
	  ul.empty li {
	  margin-top: .5em;
	  }
	  dl p {
	  margin-left: 0em;
	  }
	  dt {
	  margin-top: .5em;
	  }
	  h1 {
	  font-size: 14pt;
	  line-height: 21pt;
	  page-break-after: avoid;
	  }
	  h1.np {
	  page-break-before: always;
	  }
	  h1 a {
	  color: #333333;
	  }
	  h2 {
	  font-size: 12pt;
	  line-height: 15pt;
	  page-break-after: avoid;
	  }
	  h3, h4, h5, h6 {
	  font-size: 10pt;
	  page-break-after: avoid;
	  }
	  h2 a, h3 a, h4 a, h5 a, h6 a {
	  color: black;
	  }
	  img {
	  margin-left: 3em;
	  }
	  li {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  ol {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  ol p {
	  margin-left: 0em;
	  }
	  p {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  pre {
	  margin-left: 3em;
	  background-color: lightyellow;
	  padding: .25em;
	  }
	  pre.text2 {
	  border-style: dotted;
	  border-width: 1px;
	  background-color: #f0f0f0;
	  width: 69em;
	  }
	  pre.inline {
	  background-color: white;
	  padding: 0em;
	  }
	  pre.text {
	  border-style: dotted;
	  border-width: 1px;
	  background-color: #f8f8f8;
	  width: 69em;
	  }
	  pre.drawing {
	  border-style: solid;
	  border-width: 1px;
	  background-color: #f8f8f8;
	  padding: 2em;
	  }
	  table {
	  margin-left: 2em;
	  }
	  table.tt {
	  vertical-align: top;
	  }
	  table.full {
	  border-style: outset;
	  border-width: 1px;
	  }
	  table.headers {
	  border-style: outset;
	  border-width: 1px;
	  }
	  table.tt td {
	  vertical-align: top;
	  }
	  table.full td {
	  border-style: inset;
	  border-width: 1px;
	  }
	  table.tt th {
	  vertical-align: top;
	  }
	  table.full th {
	  border-style: inset;
	  border-width: 1px;
	  }
	  table.headers th {
	  border-style: none none inset none;
	  border-width: 1px;
	  }
	  table.left {
	  margin-right: auto;
	  }
	  table.right {
	  margin-left: auto;
	  }
	  table.center {
	  margin-left: auto;
	  margin-right: auto;
	  }
	  caption {
	  caption-side: bottom;
	  font-weight: bold;
	  font-size: 9pt;
	  margin-top: .5em;
	  }
	
	  table.header {
	  border-spacing: 1px;
	  width: 95%;
	  font-size: 10pt;
	  color: white;
	  }
	  td.top {
	  vertical-align: top;
	  }
	  td.topnowrap {
	  vertical-align: top;
	  white-space: nowrap; 
	  }
	  table.header td {
	  background-color: gray;
	  width: 50%;
	  }
	  table.header a {
	  color: white;
	  }
	  td.reference {
	  vertical-align: top;
	  white-space: nowrap;
	  padding-right: 1em;
	  }
	  thead {
	  display:table-header-group;
	  }
	  ul.toc, ul.toc ul {
	  list-style: none;
	  margin-left: 1.5em;
	  margin-right: 0em;
	  padding-left: 0em;
	  }
	  ul.toc li {
	  line-height: 150%;
	  font-weight: bold;
	  font-size: 10pt;
	  margin-left: 0em;
	  margin-right: 0em;
	  }
	  ul.toc li li {
	  line-height: normal;
	  font-weight: normal;
	  font-size: 9pt;
	  margin-left: 0em;
	  margin-right: 0em;
	  }
	  li.excluded {
	  font-size: 0pt;
	  }
	  ul p {
	  margin-left: 0em;
	  }
	
	  .comment {
	  background-color: yellow;
	  }
	  .center {
	  text-align: center;
	  }
	  .error {
	  color: red;
	  font-style: italic;
	  font-weight: bold;
	  }
	  .figure {
	  font-weight: bold;
	  text-align: center;
	  font-size: 9pt;
	  }
	  .filename {
	  color: #333333;
	  font-weight: bold;
	  font-size: 12pt;
	  line-height: 21pt;
	  text-align: center;
	  }
	  .fn {
	  font-weight: bold;
	  }
	  .hidden {
	  display: none;
	  }
	  .left {
	  text-align: left;
	  }
	  .right {
	  text-align: right;
	  }
	  .title {
	  color: #990000;
	  font-size: 18pt;
	  line-height: 18pt;
	  font-weight: bold;
	  text-align: center;
	  margin-top: 36pt;
	  }
	  .vcardline {
	  display: block;
	  }
	  .warning {
	  font-size: 14pt;
	  background-color: yellow;
	  }
	
	
	  @media print {
	  .noprint {
		display: none;
	  }
	
	  a {
		color: black;
		text-decoration: none;
	  }
	
	  table.header {
		width: 90%;
	  }
	
	  td.header {
		width: 50%;
		color: black;
		background-color: white;
		vertical-align: top;
		font-size: 12pt;
	  }
	
	  ul.toc a::after {
		content: leader('.') target-counter(attr(href), page);
	  }
	
	  ul.ind li li a {
		content: target-counter(attr(href), page);
	  }
	
	  .print2col {
		column-count: 2;
		-moz-column-count: 2;
		column-fill: auto;
	  }
	  }
	
	  @page {
	  @top-left {
		   content: "Internet-Draft"; 
	  } 
	  @top-right {
		   content: "December 2010"; 
	  } 
	  @top-center {
		   content: "Abbreviated Title";3
	  } 
	  @bottom-left {
		   content: "Doe"; 
	  } 
	  @bottom-center {
		   content: "Expires June 2011"; 
	  } 
	  @bottom-right {
		   content: "[Page " counter(page) "]"; 
	  } 
	  }
	
	  @page:first { 
		@top-left {
		  content: normal;
		}
		@top-right {
		  content: normal;
		}
		@top-center {
		  content: normal;
		}
	  }
  /*]]>*/
  </style>

  <link href="#rfc.toc" rel="Contents">
<link href="#rfc.section.1" rel="Chapter" title="1 Introduction">
<link href="#rfc.section.1.1" rel="Chapter" title="1.1 Background">
<link href="#rfc.section.1.2" rel="Chapter" title="1.2 Protocol Overview">
<link href="#rfc.section.1.3" rel="Chapter" title="1.3 Opening Handshake">
<link href="#rfc.section.1.4" rel="Chapter" title="1.4 Closing Handshake">
<link href="#rfc.section.1.5" rel="Chapter" title="1.5 Design Philosophy">
<link href="#rfc.section.1.6" rel="Chapter" title="1.6 Security Model">
<link href="#rfc.section.1.7" rel="Chapter" title="1.7 Relationship to TCP and HTTP">
<link href="#rfc.section.1.8" rel="Chapter" title="1.8 Establishing a Connection">
<link href="#rfc.section.1.9" rel="Chapter" title="1.9 Subprotocols Using the WebSocket protocol">
<link href="#rfc.section.2" rel="Chapter" title="2 Conformance Requirements">
<link href="#rfc.section.2.1" rel="Chapter" title="2.1 Terminology and other conventions">
<link href="#rfc.section.3" rel="Chapter" title="3 WebSocket URIs">
<link href="#rfc.section.4" rel="Chapter" title="4 Opening Handshake">
<link href="#rfc.section.4.1" rel="Chapter" title="4.1 Client Requirements">
<link href="#rfc.section.4.2" rel="Chapter" title="4.2 Server-side Requirements">
<link href="#rfc.section.4.2.1" rel="Chapter" title="4.2.1 Reading the Client's Opening Handshake">
<link href="#rfc.section.4.2.2" rel="Chapter" title="4.2.2 Sending the Server's Opening Handshake">
<link href="#rfc.section.4.3" rel="Chapter" title="4.3 Collected ABNF for new header fields used in handshake">
<link href="#rfc.section.4.4" rel="Chapter" title="4.4 Supporting multiple versions of WebSocket protocol">
<link href="#rfc.section.5" rel="Chapter" title="5 Data Framing">
<link href="#rfc.section.5.1" rel="Chapter" title="5.1 Overview">
<link href="#rfc.section.5.2" rel="Chapter" title="5.2 Base Framing Protocol">
<link href="#rfc.section.5.3" rel="Chapter" title="5.3 Client-to-Server Masking">
<link href="#rfc.section.5.4" rel="Chapter" title="5.4 Fragmentation">
<link href="#rfc.section.5.5" rel="Chapter" title="5.5 Control Frames">
<link href="#rfc.section.5.5.1" rel="Chapter" title="5.5.1 Close">
<link href="#rfc.section.5.5.2" rel="Chapter" title="5.5.2 Ping">
<link href="#rfc.section.5.5.3" rel="Chapter" title="5.5.3 Pong">
<link href="#rfc.section.5.6" rel="Chapter" title="5.6 Data Frames">
<link href="#rfc.section.5.7" rel="Chapter" title="5.7 Examples">
<link href="#rfc.section.5.8" rel="Chapter" title="5.8 Extensibility">
<link href="#rfc.section.6" rel="Chapter" title="6 Sending and Receiving Data">
<link href="#rfc.section.6.1" rel="Chapter" title="6.1 Sending Data">
<link href="#rfc.section.6.2" rel="Chapter" title="6.2 Receiving Data">
<link href="#rfc.section.7" rel="Chapter" title="7 Closing the connection">
<link href="#rfc.section.7.1" rel="Chapter" title="7.1 Definitions">
<link href="#rfc.section.7.1.1" rel="Chapter" title="7.1.1 Close the WebSocket Connection">
<link href="#rfc.section.7.1.2" rel="Chapter" title="7.1.2 Start the WebSocket Closing Handshake">
<link href="#rfc.section.7.1.3" rel="Chapter" title="7.1.3 The WebSocket Closing Handshake is Started">
<link href="#rfc.section.7.1.4" rel="Chapter" title="7.1.4 The WebSocket Connection is Closed">
<link href="#rfc.section.7.1.5" rel="Chapter" title="7.1.5 The WebSocket Connection Close Code">
<link href="#rfc.section.7.1.6" rel="Chapter" title="7.1.6 The WebSocket Connection Close Reason">
<link href="#rfc.section.7.1.7" rel="Chapter" title="7.1.7 Fail the WebSocket Connection">
<link href="#rfc.section.7.2" rel="Chapter" title="7.2 Abnormal Closures">
<link href="#rfc.section.7.2.1" rel="Chapter" title="7.2.1 Client-Initiated Closure">
<link href="#rfc.section.7.2.2" rel="Chapter" title="7.2.2 Server-Initiated Closure">
<link href="#rfc.section.7.2.3" rel="Chapter" title="7.2.3 Recovering From Abnormal Closure">
<link href="#rfc.section.7.3" rel="Chapter" title="7.3 Normal Closure of Connections">
<link href="#rfc.section.7.4" rel="Chapter" title="7.4 Status Codes">
<link href="#rfc.section.7.4.1" rel="Chapter" title="7.4.1 Defined Status Codes">
<link href="#rfc.section.7.4.2" rel="Chapter" title="7.4.2 Reserved Status Code Ranges">
<link href="#rfc.section.8" rel="Chapter" title="8 Error Handling">
<link href="#rfc.section.8.1" rel="Chapter" title="8.1 Handling Errors in UTF-8 Encoded Data">
<link href="#rfc.section.9" rel="Chapter" title="9 Extensions">
<link href="#rfc.section.9.1" rel="Chapter" title="9.1 Negotiating Extensions">
<link href="#rfc.section.9.2" rel="Chapter" title="9.2 Known Extensions">
<link href="#rfc.section.10" rel="Chapter" title="10 Security Considerations">
<link href="#rfc.section.10.1" rel="Chapter" title="10.1 Non-Browser Clients">
<link href="#rfc.section.10.2" rel="Chapter" title="10.2 Origin Considerations">
<link href="#rfc.section.10.3" rel="Chapter" title="10.3 Attacks On Infrastructure (Masking)">
<link href="#rfc.section.10.4" rel="Chapter" title="10.4 Implementation-Specific Limits">
<link href="#rfc.section.10.5" rel="Chapter" title="10.5 WebSocket client authentication">
<link href="#rfc.section.10.6" rel="Chapter" title="10.6 Connection confidentiality and integrity">
<link href="#rfc.section.10.7" rel="Chapter" title="10.7 Handling of invalid data">
<link href="#rfc.section.10.8" rel="Chapter" title="10.8 Use of SHA-1 by the WebSocket handshake">
<link href="#rfc.section.11" rel="Chapter" title="11 IANA Considerations">
<link href="#rfc.section.11.1" rel="Chapter" title="11.1 Registration of new URI Schemes">
<link href="#rfc.section.11.1.1" rel="Chapter" title='11.1.1 Registration of "ws" Scheme'>
<link href="#rfc.section.11.1.2" rel="Chapter" title='11.1.2 Registration of "wss" Scheme'>
<link href="#rfc.section.11.2" rel="Chapter" title='11.2 Registration of the "WebSocket" HTTP Upgrade Keyword'>
<link href="#rfc.section.11.3" rel="Chapter" title="11.3 Registration of new HTTP Header Fields">
<link href="#rfc.section.11.3.1" rel="Chapter" title="11.3.1 Sec-WebSocket-Key">
<link href="#rfc.section.11.3.2" rel="Chapter" title="11.3.2 Sec-WebSocket-Extensions">
<link href="#rfc.section.11.3.3" rel="Chapter" title="11.3.3 Sec-WebSocket-Accept">
<link href="#rfc.section.11.3.4" rel="Chapter" title="11.3.4 Sec-WebSocket-Protocol">
<link href="#rfc.section.11.3.5" rel="Chapter" title="11.3.5 Sec-WebSocket-Version">
<link href="#rfc.section.11.4" rel="Chapter" title="11.4 WebSocket Extension Name Registry">
<link href="#rfc.section.11.5" rel="Chapter" title="11.5 WebSocket Subprotocol Name Registry">
<link href="#rfc.section.11.6" rel="Chapter" title="11.6 WebSocket Version Number Registry">
<link href="#rfc.section.11.7" rel="Chapter" title="11.7 WebSocket Close Code Number Registry">
<link href="#rfc.section.11.8" rel="Chapter" title="11.8 WebSocket Opcode Registry">
<link href="#rfc.section.11.9" rel="Chapter" title="11.9 WebSocket Framing Header Bits Registry">
<link href="#rfc.section.12" rel="Chapter" title="12 Using the WebSocket protocol from Other Specifications">
<link href="#rfc.section.13" rel="Chapter" title="13 Acknowledgements">
<link href="#rfc.references" rel="Chapter" title="14 References">
<link href="#rfc.references.1" rel="Chapter" title="14.1 Normative References">
<link href="#rfc.references.2" rel="Chapter" title="14.2 Informative References">
<link href="#rfc.authors" rel="Chapter">


  <meta name="generator" content=
  "http://greenbytes.de/tech/webdav/rfc2629.xslt, Revision 1.539, 2011-01-02 17:13:00, XSLT vendor: SAXON 6.5.5 from Michael Kay http://saxon.sf.net/" />
  <link rel="schema.dct" href="http://purl.org/dc/terms/" />
  <meta name="dct.creator" content="Doe, J." />
  <meta name="dct.identifier" content="urn:ietf:id:draft-sample-input-00" />
  <meta name="dct.issued" scheme="ISO8601" content="2010-12" />
  
  <meta name="dct.abstract" content="The WebSocket protocol enables two-way communication between a client running untrusted code running in a controlled environment to a remote host that has opted-in to communications from that code. The security model used for this is the Origin-based security model commonly used by Web browsers.  The protocol consists of an opening handshake followed by basic message framing, layered over TCP. The goal of this technology is to provide a mechanism for browser-based applications that need two-way communication with servers that does not rely on opening multiple HTTP connections (e.g. using XMLHttpRequest or <iframe>s and long polling).  " />
  <meta name="description" content="The WebSocket protocol enables two-way communication between a client running untrusted code running in a controlled environment to a remote host that has opted-in to communications from that code. The security model used for this is the Origin-based security model commonly used by Web browsers.  The protocol consists of an opening handshake followed by basic message framing, layered over TCP. The goal of this technology is to provide a mechanism for browser-based applications that need two-way communication with servers that does not rely on opening multiple HTTP connections (e.g. using XMLHttpRequest or <iframe>s and long polling).  " />
  <meta name="keywords" content="HYBI, websocket" />

</head>

<body>

  <table class="header">
    <tbody>
    
    	<tr>
<td class="left">HyBi Working Group</td>
<td class="right">I.F. Fette</td>
</tr>
<tr>
<td class="left">Internet-Draft</td>
<td class="right">Google, Inc.</td>
</tr>
<tr>
<td class="left">Intended status: Standards Track</td>
<td class="right">A. Melnikov</td>
</tr>
<tr>
<td class="left">Expires: April 02, 2012</td>
<td class="right">Isode Ltd</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">September 30, 2011</td>
</tr>

    	
    </tbody>
  </table>

  <p class="title">The WebSocket protocol<br />
  <span class="filename">draft-ietf-hybi-thewebsocketprotocol-17</span></p>
  
  <h1 id="rfc.abstract"><a href="#rfc.abstract">Abstract</a></h1>
<p>The WebSocket protocol enables two-way communication between a client running untrusted code running in a controlled environment to a remote host that has opted-in to communications from that code. The security model used for this is the Origin-based security model commonly used by Web browsers.  The protocol consists of an opening handshake followed by basic message framing, layered over TCP. The goal of this technology is to provide a mechanism for browser-based applications that need two-way communication with servers that does not rely on opening multiple HTTP connections (e.g. using XMLHttpRequest or &lt;iframe&gt;s and long polling).  </p>
<p>Please send feedback to the hybi@ietf.org mailing list.</p>
<h1 id="rfc.status"><a href="#rfc.status">Status of this Memo</a></h1>
<p>This Internet-Draft is submitted in full conformance with the provisions of BCP 78 and BCP 79.</p>
<p>Internet-Drafts are working documents of the Internet Engineering Task Force (IETF).  Note that other groups may also distribute working documents as Internet-Drafts.  The list of current Internet- Drafts is at http://datatracker.ietf.org/drafts/current/.</p>
<p>Internet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other documents at any time.  It is inappropriate to use Internet-Drafts as reference material or to cite them other than as "work in progress."</p>
<p>This Internet-Draft will expire on April 02, 2012.</p>
<h1 id="rfc.copyrightnotice"><a href="#rfc.copyrightnotice">Copyright Notice</a></h1>
<p>Copyright (c) 2011 IETF Trust and the persons identified as the document authors.  All rights reserved.</p>
<p>This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document.  Please review these documents carefully, as they describe your rights and restrictions with respect to this document.  Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.</p>

  
  <hr class="noprint" />
  <h1 class="np" id="rfc.toc"><a href="#rfc.toc">Table of Contents</a></h1>
  <ul class="toc">

  	<li>1.   <a href="#rfc.section.1">Introduction</a>
</li>
<li>1.1.   <a href="#rfc.section.1.1">Background</a>
</li>
<li>1.2.   <a href="#rfc.section.1.2">Protocol Overview</a>
</li>
<li>1.3.   <a href="#rfc.section.1.3">Opening Handshake</a>
</li>
<li>1.4.   <a href="#rfc.section.1.4">Closing Handshake</a>
</li>
<li>1.5.   <a href="#rfc.section.1.5">Design Philosophy</a>
</li>
<li>1.6.   <a href="#rfc.section.1.6">Security Model</a>
</li>
<li>1.7.   <a href="#rfc.section.1.7">Relationship to TCP and HTTP</a>
</li>
<li>1.8.   <a href="#rfc.section.1.8">Establishing a Connection</a>
</li>
<li>1.9.   <a href="#rfc.section.1.9">Subprotocols Using the WebSocket protocol</a>
</li>
<li>2.   <a href="#rfc.section.2">Conformance Requirements</a>
</li>
<li>2.1.   <a href="#rfc.section.2.1">Terminology and other conventions</a>
</li>
<li>3.   <a href="#rfc.section.3">WebSocket URIs</a>
</li>
<li>4.   <a href="#rfc.section.4">Opening Handshake</a>
</li>
<li>4.1.   <a href="#rfc.section.4.1">Client Requirements</a>
</li>
<li>4.2.   <a href="#rfc.section.4.2">Server-side Requirements</a>
</li>
<li>4.2.1.   <a href="#rfc.section.4.2.1">Reading the Client's Opening Handshake</a>
</li>
<li>4.2.2.   <a href="#rfc.section.4.2.2">Sending the Server's Opening Handshake</a>
</li>
<li>4.3.   <a href="#rfc.section.4.3">Collected ABNF for new header fields used in handshake</a>
</li>
<li>4.4.   <a href="#rfc.section.4.4">Supporting multiple versions of WebSocket protocol</a>
</li>
<li>5.   <a href="#rfc.section.5">Data Framing</a>
</li>
<li>5.1.   <a href="#rfc.section.5.1">Overview</a>
</li>
<li>5.2.   <a href="#rfc.section.5.2">Base Framing Protocol</a>
</li>
<li>5.3.   <a href="#rfc.section.5.3">Client-to-Server Masking</a>
</li>
<li>5.4.   <a href="#rfc.section.5.4">Fragmentation</a>
</li>
<li>5.5.   <a href="#rfc.section.5.5">Control Frames</a>
</li>
<li>5.5.1.   <a href="#rfc.section.5.5.1">Close</a>
</li>
<li>5.5.2.   <a href="#rfc.section.5.5.2">Ping</a>
</li>
<li>5.5.3.   <a href="#rfc.section.5.5.3">Pong</a>
</li>
<li>5.6.   <a href="#rfc.section.5.6">Data Frames</a>
</li>
<li>5.7.   <a href="#rfc.section.5.7">Examples</a>
</li>
<li>5.8.   <a href="#rfc.section.5.8">Extensibility</a>
</li>
<li>6.   <a href="#rfc.section.6">Sending and Receiving Data</a>
</li>
<li>6.1.   <a href="#rfc.section.6.1">Sending Data</a>
</li>
<li>6.2.   <a href="#rfc.section.6.2">Receiving Data</a>
</li>
<li>7.   <a href="#rfc.section.7">Closing the connection</a>
</li>
<li>7.1.   <a href="#rfc.section.7.1">Definitions</a>
</li>
<li>7.1.1.   <a href="#rfc.section.7.1.1">Close the WebSocket Connection</a>
</li>
<li>7.1.2.   <a href="#rfc.section.7.1.2">Start the WebSocket Closing Handshake</a>
</li>
<li>7.1.3.   <a href="#rfc.section.7.1.3">The WebSocket Closing Handshake is Started</a>
</li>
<li>7.1.4.   <a href="#rfc.section.7.1.4">The WebSocket Connection is Closed</a>
</li>
<li>7.1.5.   <a href="#rfc.section.7.1.5">The WebSocket Connection Close Code</a>
</li>
<li>7.1.6.   <a href="#rfc.section.7.1.6">The WebSocket Connection Close Reason</a>
</li>
<li>7.1.7.   <a href="#rfc.section.7.1.7">Fail the WebSocket Connection</a>
</li>
<li>7.2.   <a href="#rfc.section.7.2">Abnormal Closures</a>
</li>
<li>7.2.1.   <a href="#rfc.section.7.2.1">Client-Initiated Closure</a>
</li>
<li>7.2.2.   <a href="#rfc.section.7.2.2">Server-Initiated Closure</a>
</li>
<li>7.2.3.   <a href="#rfc.section.7.2.3">Recovering From Abnormal Closure</a>
</li>
<li>7.3.   <a href="#rfc.section.7.3">Normal Closure of Connections</a>
</li>
<li>7.4.   <a href="#rfc.section.7.4">Status Codes</a>
</li>
<li>7.4.1.   <a href="#rfc.section.7.4.1">Defined Status Codes</a>
</li>
<li>7.4.2.   <a href="#rfc.section.7.4.2">Reserved Status Code Ranges</a>
</li>
<li>8.   <a href="#rfc.section.8">Error Handling</a>
</li>
<li>8.1.   <a href="#rfc.section.8.1">Handling Errors in UTF-8 Encoded Data</a>
</li>
<li>9.   <a href="#rfc.section.9">Extensions</a>
</li>
<li>9.1.   <a href="#rfc.section.9.1">Negotiating Extensions</a>
</li>
<li>9.2.   <a href="#rfc.section.9.2">Known Extensions</a>
</li>
<li>10.   <a href="#rfc.section.10">Security Considerations</a>
</li>
<li>10.1.   <a href="#rfc.section.10.1">Non-Browser Clients</a>
</li>
<li>10.2.   <a href="#rfc.section.10.2">Origin Considerations</a>
</li>
<li>10.3.   <a href="#rfc.section.10.3">Attacks On Infrastructure (Masking)</a>
</li>
<li>10.4.   <a href="#rfc.section.10.4">Implementation-Specific Limits</a>
</li>
<li>10.5.   <a href="#rfc.section.10.5">WebSocket client authentication</a>
</li>
<li>10.6.   <a href="#rfc.section.10.6">Connection confidentiality and integrity</a>
</li>
<li>10.7.   <a href="#rfc.section.10.7">Handling of invalid data</a>
</li>
<li>10.8.   <a href="#rfc.section.10.8">Use of SHA-1 by the WebSocket handshake</a>
</li>
<li>11.   <a href="#rfc.section.11">IANA Considerations</a>
</li>
<li>11.1.   <a href="#rfc.section.11.1">Registration of new URI Schemes</a>
</li>
<li>11.1.1.   <a href="#rfc.section.11.1.1">Registration of "ws" Scheme</a>
</li>
<li>11.1.2.   <a href="#rfc.section.11.1.2">Registration of "wss" Scheme</a>
</li>
<li>11.2.   <a href="#rfc.section.11.2">Registration of the "WebSocket" HTTP Upgrade Keyword</a>
</li>
<li>11.3.   <a href="#rfc.section.11.3">Registration of new HTTP Header Fields</a>
</li>
<li>11.3.1.   <a href="#rfc.section.11.3.1">Sec-WebSocket-Key</a>
</li>
<li>11.3.2.   <a href="#rfc.section.11.3.2">Sec-WebSocket-Extensions</a>
</li>
<li>11.3.3.   <a href="#rfc.section.11.3.3">Sec-WebSocket-Accept</a>
</li>
<li>11.3.4.   <a href="#rfc.section.11.3.4">Sec-WebSocket-Protocol</a>
</li>
<li>11.3.5.   <a href="#rfc.section.11.3.5">Sec-WebSocket-Version</a>
</li>
<li>11.4.   <a href="#rfc.section.11.4">WebSocket Extension Name Registry</a>
</li>
<li>11.5.   <a href="#rfc.section.11.5">WebSocket Subprotocol Name Registry</a>
</li>
<li>11.6.   <a href="#rfc.section.11.6">WebSocket Version Number Registry</a>
</li>
<li>11.7.   <a href="#rfc.section.11.7">WebSocket Close Code Number Registry</a>
</li>
<li>11.8.   <a href="#rfc.section.11.8">WebSocket Opcode Registry</a>
</li>
<li>11.9.   <a href="#rfc.section.11.9">WebSocket Framing Header Bits Registry</a>
</li>
<li>12.   <a href="#rfc.section.12">Using the WebSocket protocol from Other Specifications</a>
</li>
<li>13.   <a href="#rfc.section.13">Acknowledgements</a>
</li>
<li>14.   <a href="#rfc.references">References</a>
</li>
<li>14.1.   <a href="#rfc.references.1">Normative References</a>
</li>
<li>14.2.   <a href="#rfc.references.2">Informative References</a>
</li>
<li><a href="#rfc.authors">Authors' Addresses</a>
</li>


  </ul>

  <h1 id="rfc.section.1">
<a href="#rfc.section.1">1.</a> Introduction</h1>
<h1 id="rfc.section.1.1">
<a href="#rfc.section.1.1">1.1.</a> Background</h1>
<p><em>This section is non-normative.</em> </p>
<p id="rfc.section.1.1.p.2">Historically, creating Web applications that need bidirectional communication between a client and a server (e.g., instant messaging and gaming applications) has required an abuse of HTTP to poll the server for updates while sending upstream notifications as distinct HTTP calls.<a href="#RFC6202">[RFC6202]</a></p>
<p id="rfc.section.1.1.p.3">This results in a variety of problems: </p>

<ul>
<li>The server is forced to use a number of different underlying TCP connections for each client: one for sending information to the client, and a new one for each incoming message.</li>
<li>The wire protocol has a high overhead, with each client-to-server message having an HTTP header.</li>
<li>The client-side script is forced to maintain a mapping from the outgoing connections to the incoming connection to track replies.</li>
</ul>

<p> </p>
<p id="rfc.section.1.1.p.4">A simpler solution would be to use a single TCP connection for traffic in both directions. This is what the WebSocket protocol provides. Combined with the WebSocket API, it provides an alternative to HTTP polling for two-way communication from a Web page to a remote server. <a href="#WSAPI">[WSAPI]</a> </p>
<p id="rfc.section.1.1.p.5">The same technique can be used for a variety of Web applications: games, stock tickers, multiuser applications with simultaneous editing, user interfaces exposing server-side services in real time, etc.</p>
<p id="rfc.section.1.1.p.6">The WebSocket protocol is designed to supersede existing bidirectional communication technologies which use HTTP as a transport layer to benefit from existing infrastructure (proxies, filtering, authentication).  Such technologies were implemented as trade-offs between efficiency and reliability because HTTP was not initially meant to be used for bidirectional communication (see <a href="#RFC6202">[RFC6202]</a> for further discussion).  The WebSocket protocol attempts to address the goals of existing bidirectional HTTP technologies in the context of the existing HTTP infrastructure; as such, it is designed to work over HTTP ports 80 and 443 as well as to support HTTP proxies and intermediaries, even if this implies some complexity specific to the current environment.  However, the design does not limit WebSocket to HTTP, and future implementations could use a simpler handshake over a dedicated port without revinventing the entire protocol.  This last point is important because the traffic patterns of interactive messaging do not closely match standard HTTP traffic and can induce unusual loads on some components.  </p>
<h1 id="rfc.section.1.2">
<a href="#rfc.section.1.2">1.2.</a> Protocol Overview</h1>
<p><em>This section is non-normative.</em> </p>
<p id="rfc.section.1.2.p.2">The protocol has two parts: a handshake, and then the data transfer.</p>
<p id="rfc.section.1.2.p.3">The handshake from the client looks as follows:</p>
<div id="#rfc.figure.1"></div>
<pre>
     GET /chat HTTP/1.1
     Host: server.example.com
     Upgrade: websocket
     Connection: Upgrade
     Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==
     Origin: http://example.com
     Sec-WebSocket-Protocol: chat, superchat
     Sec-WebSocket-Version: 13
          </pre>
<p id="rfc.section.1.2.p.4">The handshake from the server looks as follows:</p>
<div id="#rfc.figure.2"></div>
<pre>
     HTTP/1.1 101 Switching Protocols
     Upgrade: websocket
     Connection: Upgrade
     Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=
     Sec-WebSocket-Protocol: chat
          </pre>
<p id="rfc.section.1.2.p.5">The leading line from the client follows the Request-Line format. The leading line from the server follows the Status-Line format. The Request-Line and Status-Line productions are defined in <a href="#RFC2616">[RFC2616]</a>.  </p>
<p id="rfc.section.1.2.p.6">After the leading line in both cases come an unordered set of header fields. The meaning of these header fields is specified in <a href="#handshake">Section 4</a> of this document. Additional header fields may also be present, such as cookies <a href="#RFC6265">[RFC6265]</a>. The format and parsing of headers is as defined in <a href="#RFC2616">[RFC2616]</a>.  </p>
<p><br><br></p>
<p id="rfc.section.1.2.p.8">Once the client and server have both sent their handshakes, and if the handshake was successful, then the data transfer part starts. This is a two-way communication channel where each side can, independently from the other, send data at will.</p>
<p id="rfc.section.1.2.p.9">Clients and servers, after a successful handshake, transfer data back and forth in conceptual units referred to in this specification as "messages".  On the wire a message is composed of one or more frames.  The WebSocket message does not necessarily correspond to a particular network layer framing, as a fragmented message may be coalesced or split by an intermediary.</p>
<p id="rfc.section.1.2.p.10">A frame has an associated type. Each frame belonging to the same message contain the same type of data. Broadly speaking, there are types for textual data, which is interpreted as UTF-8 <a href="#RFC3629">[RFC3629]</a> text, binary data (whose interpretation is left up to the application), and control frames, which are not intended to carry data for the application, but instead for protocol-level signaling, such as to signal that the connection should be closed. This version of the protocol defines six frame types and leaves ten reserved for future use.</p>
<h1 id="rfc.section.1.3">
<a href="#rfc.section.1.3">1.3.</a> Opening Handshake</h1>
<p><em>This section is non-normative.</em> </p>
<p id="rfc.section.1.3.p.2">The opening handshake is intended to be compatible with HTTP-based server-side software and intermediaries, so that a single port can be used by both HTTP clients talking to that server and WebSocket clients talking to that server. To this end, the WebSocket client's handshake is an HTTP Upgrade request:</p>
<div id="#rfc.figure.3"></div>
<pre>
     GET /chat HTTP/1.1
     Host: server.example.com
     Upgrade: websocket
     Connection: Upgrade
     Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==
     Origin: http://example.com
     Sec-WebSocket-Protocol: chat, superchat
     Sec-WebSocket-Version: 13
          </pre>
<p id="rfc.section.1.3.p.3">In compliance with <a href="#RFC2616">[RFC2616]</a>, header fields in the handshake may be sent by the client in any order, so the order in which different header fields are received is not significant.</p>
<p id="rfc.section.1.3.p.4">The "Request-URI" of the GET method <a href="#RFC2616">[RFC2616]</a> is used to identify the endpoint of the WebSocket connection, both to allow multiple domains to be served from one IP address and to allow multiple WebSocket endpoints to be served by a single server.<br><br></p>
<p id="rfc.section.1.3.p.5">The client includes the hostname in the Host header field of its handshake as per <a href="#RFC2616">[RFC2616]</a>, so that both the client and the server can verify that they agree on which host is in use.</p>
<p id="rfc.section.1.3.p.6">Additional header fields are used to select options in the WebSocket protocol.  Typical options available in this version are the subprotocol selector (|Sec-WebSocket-Protocol|), list of extensions support by the client (|Sec-WebSocket-Extensions|), |Origin| header field, etc.  The |Sec-WebSocket-Protocol| request-header field can be used to indicate what subprotocols (application-level protocols layered over the WebSocket protocol) are acceptable to the client. The server selects one or none of the acceptable protocols and echoes that value in its handshake to indicate that it has selected that protocol.</p>
<div id="#rfc.figure.4"></div>
<pre>     Sec-WebSocket-Protocol: chat</pre>
<p id="rfc.section.1.3.p.7">The |Origin| header field <a href="#I-D.ietf-websec-origin">[I-D.ietf-websec-origin]</a> is used to protect against unauthorized cross-origin use of a WebSocket server by scripts using the |WebSocket| API in a Web browser. The server is informed of the script origin generating the WebSocket connection request. If the server does not wish to accept connections from this origin, it can choose to reject the connection by sending an appropriate HTTP error code. This header field is sent by browser clients, for non-browser clients this header field may be sent if it makes sense in the context of those clients.</p>
<p id="rfc.section.1.3.p.8">Finally, the server has to prove to the client that it received the client's WebSocket handshake, so that the server doesn't accept connections that are not WebSocket connections. This prevents an attacker from tricking a WebSocket server by sending it carefully-crafted packets using |XMLHttpRequest| <a href="#XMLHttpRequest">[XMLHttpRequest]</a> or a |form| submission.</p>
<p id="rfc.section.1.3.p.9">To prove that the handshake was received, the server has to take two pieces of information and combine them to form a response. The first piece of information comes from the |Sec-WebSocket-Key| header field in the client handshake:</p>
<div id="#rfc.figure.5"></div>
<pre>
     Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==
          </pre>
<p id="rfc.section.1.3.p.10">For this header field, the server has to take the value (as present in the header field, e.g. the base64-encoded <a href="#RFC4648">[RFC4648]</a> version minus any leading and trailing whitespace), and concatenate this with the Globally Unique Identifier (GUID, <a href="#RFC4122">[RFC4122]</a>) "258EAFA5-E914-47DA-95CA-C5AB0DC85B11" in string form, which is unlikely to be used by network endpoints that do not understand the WebSocket protocol. A SHA-1 hash (160 bits), base64-encoded (see Section 4 of <a href="#RFC4648">[RFC4648]</a>), of this concatenation is then returned in the server's handshake <a href="#FIPS.180-2.2002">[FIPS.180-2.2002]</a>.  </p>
<p id="rfc.section.1.3.p.11">Concretely, if as in the example above, |Sec-WebSocket-Key| header field had the value "dGhlIHNhbXBsZSBub25jZQ==", the server would concatenate the string "258EAFA5-E914-47DA-95CA-C5AB0DC85B11" to form the string "dGhlIHNhbXBsZSBub25jZQ==258EAFA5-E914-47DA-95CA-C5AB0DC85B11". The server would then take the SHA-1 hash of this, giving the value 0xb3 0x7a 0x4f 0x2c 0xc0 0x62 0x4f 0x16 0x90 0xf6 0x46 0x06 0xcf 0x38 0x59 0x45 0xb2 0xbe 0xc4 0xea. This value is then base64-encoded (see Section 4 of <a href="#RFC4648">[RFC4648]</a>), to give the value "s3pPLMBiTxaQ9kYGzzhZRbK+xOo=". This value would then be echoed in the |Sec-WebSocket-Accept| header field.</p>
<p><br><br> </p>
<p id="rfc.section.1.3.p.13">The handshake from the server is much simpler than the client handshake. The first line is an HTTP Status-Line, with the status code 101:<br><br></p>
<div id="#rfc.figure.6"></div>
<pre>     HTTP/1.1 101 Switching Protocols</pre>
<p id="rfc.section.1.3.p.14">Any status code other than 101 indicates that the WebSocket handshake has not completed, and that the semantics of HTTP still apply. The headers follow the status code.</p>
<p id="rfc.section.1.3.p.15">The |Connection| and |Upgrade| header fields complete the HTTP Upgrade. The |Sec-WebSocket-Accept| header field indicates whether the server is willing to accept the connection. If present, this header field must include a hash of the client's nonce sent in |Sec-WebSocket-Key| along with a predefined GUID. Any other value must not be interpreted as an acceptance of the connection by the server.<br><br></p>
<div id="#rfc.figure.7"></div>
<pre>
     HTTP/1.1 101 Switching Protocols
     Upgrade: websocket
     Connection: Upgrade
     Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=
          </pre>
<p id="rfc.section.1.3.p.16">These fields are checked by the |WebSocket| client for scripted pages. If the |Sec-WebSocket-Accept| value does not match the expected value, or if the header field is missing, or if the HTTP status code is not 101, the connection will not be established and WebSocket frames will not be sent.</p>
<p id="rfc.section.1.3.p.17">Option fields can also be included. In this version of the protocol, the main option field is |Sec-WebSocket-Protocol|, which indicates the subprotocol that the server has selected. WebSocket clients verify that the server included one of the values as was specified in the WebSocket client's handshake. A server that speaks multiple subprotocols has to make sure it selects one based on the client's handshake and specifies it in its handshake.<br><br></p>
<div id="#rfc.figure.8"></div>
<pre>     Sec-WebSocket-Protocol: chat</pre>
<p id="rfc.section.1.3.p.18">The server can also set cookie-related option fields to <em>set</em> cookies, as described in <a href="#RFC6265">[RFC6265]</a>.  </p>
<h1 id="rfc.section.1.4">
<a href="#rfc.section.1.4">1.4.</a> Closing Handshake</h1>
<p><em>This section is non-normative.</em> </p>
<p id="rfc.section.1.4.p.2">The closing handshake is far simpler than the opening handshake.</p>
<p id="rfc.section.1.4.p.3">Either peer can send a control frame with data containing a specified control sequence to begin the closing handshake (detailed in <a href="#closeframe">Section 5.5.1</a>). Upon receiving such a frame, the other peer sends a close frame in response, if it hasn't already sent one. Upon receiving <em>that</em> control frame, the first peer then closes the connection, safe in the knowledge that no further data is forthcoming.</p>
<p id="rfc.section.1.4.p.4">After sending a control frame indicating the connection should be closed, a peer does not send any further data; after receiving a control frame indicating the connection should be closed, a peer discards any further data received.</p>
<p id="rfc.section.1.4.p.5">It is safe for both peers to initiate this handshake simultaneously.</p>
<p id="rfc.section.1.4.p.6">The closing handshake is intended to complement the TCP closing handshake (FIN/ACK), on the basis that the TCP closing handshake is not always reliable end-to-end, especially in the presence of intercepting proxies and other intermediaries.</p>
<p id="rfc.section.1.4.p.7">By sending a close frame and waiting for a close frame in response, certain cases are avoided where data may be unnecessarily lost. For instance, on some platforms, if a socket is closed with data in the receive queue, a RST packet is sent, which will then cause recv() to fail for the party that received the RST, even if there was data waiting to be read.</p>
<h1 id="rfc.section.1.5">
<a href="#rfc.section.1.5">1.5.</a> Design Philosophy</h1>
<p><em>This section is non-normative.</em> </p>
<p id="rfc.section.1.5.p.2">The WebSocket protocol is designed on the principle that there should be minimal framing (the only framing that exists is to make the protocol frame-based instead of stream-based, and to support a distinction between Unicode text and binary frames). It is expected that metadata would be layered on top of WebSocket by the application layer, in the same way that metadata is layered on top of TCP by the application layer (e.g., HTTP).</p>
<p id="rfc.section.1.5.p.3">Conceptually, WebSocket is really just a layer on top of TCP that does the following: </p>

<ul>
<li>adds a Web "origin"-based security model for browsers</li>
<li>adds an addressing and protocol naming mechanism to support multiple services on one port and multiple host names on one IP address;</li>
<li>layers a framing mechanism on top of TCP to get back to the IP packet mechanism that TCP is built on, but without length limits</li>
<li>includes an additional closing handshake in-band that is designed to work in the presence of proxies and other intermediaries</li>
</ul>

<p> Other than that, WebSocket adds nothing.  Basically it is intended to be as close to just exposing raw TCP to script as possible given the constraints of the Web. It's also designed in such a way that its servers can share a port with HTTP servers, by having its handshake be a valid HTTP Upgrade request mechanism also. One could conceptually use other protocols to establish client-server messaging, but the intent of WebSockets was to provide a relatively simple protocol that can coexist with HTTP and deployed HTTP infrastructure (such as proxies) that is as close to TCP as is safe for use with such infrastructure given security considerations, with targeted additions to simplify usage and make simple things simple (such as the addition of message semantics).</p>
<p id="rfc.section.1.5.p.4">The protocol is intended to be extensible; future versions will likely introduce additional concepts such as multiplexing.</p>
<h1 id="rfc.section.1.6">
<a href="#rfc.section.1.6">1.6.</a> <a href="#secmodel" id="secmodel">Security Model</a>
</h1>
<p><em>This section is non-normative.</em> </p>
<p id="rfc.section.1.6.p.2">The WebSocket protocol uses the origin model used by Web browsers to restrict which Web pages can contact a WebSocket server when the WebSocket protocol is used from a Web page. Naturally, when the WebSocket protocol is used by a dedicated client directly (i.e. not from a Web page through a Web browser), the origin model is not useful, as the client can provide any arbitrary origin string.</p>
<p id="rfc.section.1.6.p.3">This protocol is intended to fail to establish a connection with servers of pre-existing protocols like SMTP <a href="#RFC5321">[RFC5321]</a> and HTTP, while allowing HTTP servers to opt-in to supporting this protocol if desired. This is achieved by having a strict and elaborate handshake, and by limiting the data that can be inserted into the connection before the handshake is finished (thus limiting how much the server can be influenced).</p>
<p id="rfc.section.1.6.p.4">It is similarly intended to fail to establish a connection when data from other protocols, especially HTTP, is sent to a WebSocket server, for example as might happen if an HTML |form| were submitted to a WebSocket server. This is primarily achieved by requiring that the server prove that it read the handshake, which it can only do if the handshake contains the appropriate parts which themselves can only be sent by a WebSocket handshake. In particular, at the time of writing of this specification, fields starting with |Sec-| cannot be set by an attacker from a Web browser using only HTML and JavaScript APIs such as |XMLHttpRequest| <a href="#XMLHttpRequest">[XMLHttpRequest]</a>.</p>
<h1 id="rfc.section.1.7">
<a href="#rfc.section.1.7">1.7.</a> Relationship to TCP and HTTP</h1>
<p><em>This section is non-normative.</em> </p>
<p id="rfc.section.1.7.p.2">The WebSocket protocol is an independent TCP-based protocol. Its only relationship to HTTP is that its handshake is interpreted by HTTP servers as an Upgrade request.</p>
<p id="rfc.section.1.7.p.3">By default the WebSocket protocol uses port 80 for regular WebSocket connections and port 443 for WebSocket connections tunneled over TLS <a href="#RFC2818">[RFC2818]</a>.</p>
<h1 id="rfc.section.1.8">
<a href="#rfc.section.1.8">1.8.</a> Establishing a Connection</h1>
<p><em>This section is non-normative.</em> </p>
<p id="rfc.section.1.8.p.2">When a connection is to be made to a port that is shared by an HTTP server (a situation that is quite likely to occur with traffic to ports 80 and 443), the connection will appear to the HTTP server to be a regular GET request with an Upgrade offer.  In relatively simple setups with just one IP address and a single server for all traffic to a single hostname, this might allow a practical way for systems based on the WebSocket protocol to be deployed.  In more elaborate setups (e.g. with load balancers and multiple servers), a dedicated set of hosts for WebSocket connections separate from the HTTP servers is probably easier to manage. At the time of writing of this specification, it should be noted that connections on port 80 and 443 have significantly different success rates, with connections on port 443 being significantly more likely to succeed, though this may change with time.  </p>
<h1 id="rfc.section.1.9">
<a href="#rfc.section.1.9">1.9.</a> Subprotocols Using the WebSocket protocol</h1>
<p><em>This section is non-normative.</em> </p>
<p id="rfc.section.1.9.p.2">The client can request that the server use a specific subprotocol by including the |Sec-WebSocket-Protocol| field in its handshake. If it is specified, the server needs to include the same field and one of the selected subprotocol values in its response for the connection to be established.</p>
<p id="rfc.section.1.9.p.3">These subprotocol names should be registered as per <a href="#spr">Section 11.5</a>. To avoid potential collisions, it is recommended to use names that contain the ASCII version of the domain name of the subprotocol's originator. For example, if Example Corporation were to create a Chat subprotocol to be implemented by many servers around the Web, they could name it "chat.example.com". If the Example Organization called their competing subprotocol "chat.example.org", then the two subprotocols could be implemented by servers simultaneously, with the server dynamically selecting which subprotocol to use based on the value sent by the client.</p>
<p id="rfc.section.1.9.p.4">Subprotocols can be versioned in backwards-incompatible ways by changing the subprotocol name, e.g. going from "bookings.example.net" to "v2.bookings.example.net". These subprotocols would be considered completely separate by WebSocket clients. Backwards-compatible versioning can be implemented by reusing the same subprotocol string but carefully designing the actual subprotocol to support this kind of extensibility.</p>
<h1 id="rfc.section.2">
<a href="#rfc.section.2">2.</a> Conformance Requirements</h1>
<p id="rfc.section.2.p.1">All diagrams, examples, and notes in this specification are non-normative, as are all sections explicitly marked non-normative. Everything else in this specification is normative.</p>
<p id="rfc.section.2.p.2">The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC2119. <a href="#RFC2119">[RFC2119]</a> </p>
<p id="rfc.section.2.p.3">Requirements phrased in the imperative as part of algorithms (such as "strip any leading space characters" or "return false and abort these steps") are to be interpreted with the meaning of the key word ("must", "should", "may", etc) used in introducing the algorithm.</p>
<p id="rfc.section.2.p.4">Conformance requirements phrased as algorithms or specific steps MAY be implemented in any manner, so long as the end result is equivalent. (In particular, the algorithms defined in this specification are intended to be easy to follow, and not intended to be performant.)</p>
<h1 id="rfc.section.2.1">
<a href="#rfc.section.2.1">2.1.</a> Terminology and other conventions</h1>
<p><em>ASCII</em> shall mean the character-encoding scheme defined in  <a href="#ANSI.X3-4.1986">[ANSI.X3-4.1986]</a>.  </p>
<p id="rfc.section.2.1.p.2">This document makes reference to UTF-8 values and uses UTF-8 notational formats as defined in STD 63 <a href="#RFC3629">[RFC3629]</a>.  </p>
<p id="rfc.section.2.1.p.3">Key Terms such as named algorithms or definitions are indicated like <em>this</em>.  </p>
<p id="rfc.section.2.1.p.4">Names of header fields or variables are indicated like |this|.  </p>
<p id="rfc.section.2.1.p.5">Variable values are indicated like /this/.  </p>
<p id="rfc.section.2.1.p.6">This document references the procedure to <em>Fail the WebSocket Connection</em>. This procedure is defined in <a href="#fail_ws">Section 7.1.7</a>.  </p>
<p><em>Converting a string to ASCII lowercase</em> means replacing all characters in the range U+0041 to U+005A (i.e. LATIN CAPITAL LETTER A to LATIN CAPITAL LETTER Z) with the corresponding characters in the range U+0061 to U+007A (i.e. LATIN SMALL LETTER A to LATIN SMALL LETTER Z).  </p>
<p id="rfc.section.2.1.p.8">Comparing two strings in an <em>ASCII case-insensitive</em> manner means comparing them exactly, code point for code point, except that the characters in the range U+0041 to U+005A (i.e. LATIN CAPITAL LETTER A to LATIN CAPITAL LETTER Z) and the corresponding characters in the range U+0061 to U+007A (i.e. LATIN SMALL LETTER A to LATIN SMALL LETTER Z) are considered to also match.  </p>
<p id="rfc.section.2.1.p.9">The term "URI" is used in this document as defined in <a href="#RFC3986">[RFC3986]</a>.  </p>
<p id="rfc.section.2.1.p.10">When an implementation is required to <em>send</em> data as part of the WebSocket protocol, the implementation MAY delay the actual transmission arbitrarily, e.g. buffering data so as to send fewer IP packets.  </p>
<p id="rfc.section.2.1.p.11">Note that this document uses both <a href="#RFC5234">[RFC5234]</a> and <a href="#RFC2616">[RFC2616]</a> variants of ABNF in different sections.</p>
<h1 id="rfc.section.3">
<a href="#rfc.section.3">3.</a> <a href="#ws_uris" id="ws_uris">WebSocket URIs</a>
</h1>
<p id="rfc.section.3.p.1">This specification defines two URI schemes, using the ABNF syntax defined in RFC 5234 <a href="#RFC5234">[RFC5234]</a>, and terminology and ABNF productions defined by the URI specification RFC 3986 <a href="#RFC3986">[RFC3986]</a>.  </p>
<div id="#rfc.figure.9"></div>
<pre>
       ws-URI = "ws:" "//" host [ ":" port ] path [ "?" query ]
       wss-URI = "wss:" "//" host [ ":" port ] path [ "?" query ]

       host = &lt;host, defined in [RFC3986], Section 3.2.2&gt;
       port = &lt;port, defined in [RFC3986], Section 3.2.3&gt;
       path = &lt;path-abempty, defined in [RFC3986], Section 3.3&gt;
       query = &lt;query, defined in [RFC3986], Section 3.4&gt;
</pre>
<p></p>
<p id="rfc.section.3.p.3">The port component is OPTIONAL; the default for "ws" is port 80, while the default for "wss" is port 443.  </p>
<p id="rfc.section.3.p.4">The URI is called "secure" (and it said that "the secure flag is set") if the scheme component matches "wss" case-insensitively.  </p>
<p id="rfc.section.3.p.5">The "resource-name" (also known as /resource name/ in <a href="#clienths">Section 4.1</a>) can be constructed by concatenating </p>

<ul>
<li>"/" if the path component is empty </li>
<li>the path component </li>
<li>"?" if the query component is non-empty </li>
<li>the query component </li>
</ul>

<p> </p>
<p id="rfc.section.3.p.6">Fragment identifiers are meaningless in the context of WebSocket URIs, and MUST NOT be used on these URIs. The character "#" in URIs MUST be escaped as %23 if used as part of the query component.  </p>
<h1 id="rfc.section.4">
<a href="#rfc.section.4">4.</a> <a href="#handshake" id="handshake">Opening Handshake</a>
</h1>
<h1 id="rfc.section.4.1">
<a href="#rfc.section.4.1">4.1.</a> <a href="#clienths" id="clienths">Client Requirements</a>
</h1>
<p id="rfc.section.4.1.p.1">To <em>Establish a WebSocket Connection</em>, a client opens a connection and sends a handshake as defined in this section. A connection is defined to initially be in a CONNECTING state.  A client will need to supply a /host/, /port/, /resource name/, and a /secure/ flag, which are the components of a WebSocket URI as discussed in <a href="#ws_uris">Section 3</a>, along with a list of /protocols/ and /extensions/ to be used. Additionally, if the client is a web browser, it supplies /origin/.  </p>
<p id="rfc.section.4.1.p.2">Clients running in controlled environments, e.g. browsers on mobile handsets tied to specific carriers, MAY offload the management of the connection to another agent on the network. In such a situation, the client for the purposes of this specification is considered to include both the handset software and any such agents.</p>
<div id="#rfc.figure.10"></div>
<pre>
           CONNECT example.com:80 HTTP/1.1
           Host: example.com
              </pre>
<div id="#rfc.figure.11"></div>
<pre>
           CONNECT example.com:80 HTTP/1.1
           Host: example.com
           Proxy-authorization: Basic ZWRuYW1vZGU6bm9jYXBlcyE=
              </pre>
<p id="rfc.section.4.1.p.3">When the client is to <em>Establish a WebSocket Connection</em> given a set of (/host/, /port/, /resource name/, and /secure/ flag), along with a list of /protocols/ and /extensions/ to be used, and an /origin/ in the case of web browsers, it MUST open a connection, send an opening handshake, and read the server's handshake in response. The exact requirements of how the connection should be opened, what should be sent in the opening handshake, and how the server's response should be interpreted, are as follows in this section.  In the following text, we will use terms from <a href="#ws_uris">Section 3</a> such as "/host/" and "/secure/ flag" as defined in that section.  </p>

<ol>
<li>The components of the WebSocket URI passed into this algorithm (/host/, /port/, /resource name/ and /secure/ flag) MUST be valid according to the specification of WebSocket URIs specified in <a href="#ws_uris">Section 3</a>. If any of the components are invalid, the client MUST <em>Fail the WebSocket Connection</em> and abort these steps.  </li>
<li>If the client already has a WebSocket connection to the remote host (IP address) identified by /host/ and port /port/ pair, even if the remote host is known by another name, the client MUST wait until that connection has been established or for that connection to have failed. There MUST be no more than one connection in a CONNECTING state. If multiple connections to the same IP address are attempted simultaneously, the client MUST serialize them so that there is no more than one connection at a time running through the following steps.  <br><br> If the client cannot determine the IP address of the remote host (for example because all communication is being done through a proxy server that performs DNS queries itself), then the client MUST assume for the purposes of this step that each host name refers to a distinct remote host, and instead the client SHOULD limit the total number of simultaneous pending connections to a reasonably low number (e.g., the client might allow simultaneous pending connections to a.example.com and b.example.com, but if thirty simultaneous connections to a single host are requested, that may not be allowed).  For example in a Web browser context, the client needs to consider the number of tabs the user has open in setting a limit to the number of simultaneous pending connections.  <br><br> NOTE: This makes it harder for a script to perform a denial of service attack by just opening a large number of WebSocket connections to a remote host. A server can further reduce the load on itself when attacked by pausing before closing the connection, as that will reduce the rate at which the client reconnects.  <br><br> NOTE: There is no limit to the number of established WebSocket connections a client can have with a single remote host.  Servers can refuse to accept connections from hosts/IP addresses with an excessive number of existing connections, or disconnect resource-hogging connections when suffering high load.</li>
<li>
<em>Proxy Usage</em>: If the client is configured to use a proxy when using the WebSocket protocol to connect to host /host/ and port /port/, then the client SHOULD connect to that proxy and ask it to open a TCP connection to the host given by /host/ and the port given by /port/.  <ul class="empty">
<li>EXAMPLE: For example, if the client uses an HTTP proxy for all traffic, then if it was to try to connect to port 80 on server example.com, it might send the following lines to the proxy server: <br><br> </li>
<li>If there was a password, the connection might look like: <br><br> </li>
</ul>
<p> If the client is not configured to use a proxy, then a direct TCP connection SHOULD be opened to the host given by /host/ and the port given by /port/.  </p>
<br><br> NOTE: Implementations that do not expose explicit UI for selecting a proxy for WebSocket connections separate from other proxies are encouraged to use a SOCKS5 <a href="#RFC1928">[RFC1928]</a> proxy for WebSocket connections, if available, or failing that, to prefer the proxy configured for HTTPS connections over the proxy configured for HTTP connections.  <br><br> For the purpose of proxy autoconfiguration scripts, the URI to pass the function MUST be constructed from /host/, /port/, /resource name/, and the /secure/ flag using the definition of a WebSocket URI as given in <a href="#ws_uris">Section 3</a>.  <br><br> NOTE: The WebSocket protocol can be identified in proxy autoconfiguration scripts from the scheme ("ws" for unencrypted connections and "wss" for encrypted connections).</li>
<li>If the connection could not be opened, either because a direct connection failed or because any proxy used returned an error, then the client MUST <em>Fail the WebSocket Connection</em> and abort the connection attempt.</li>
<li>If /secure/ is true, the client MUST perform a TLS handshake over the connection after opening the connection and before sending the handshake data <a href="#RFC2818">[RFC2818]</a>. If this fails (e.g. the server's certificate could not be verified), then the client MUST <em>Fail the WebSocket Connection</em> and abort the connection. Otherwise, all further communication on this channel MUST run through the encrypted tunnel. <a href="#RFC5246">[RFC5246]</a> <br><br> Clients MUST use the Server Name Indication extension in the TLS handshake. <a href="#RFC6066">[RFC6066]</a> </li>
</ol>

<p> </p>
<p id="rfc.section.4.1.p.4">Once a connection to the server has been established (including a connection via a proxy or over a TLS-encrypted tunnel), the client MUST send an opening handshake to the server. The handshake consists of an HTTP upgrade request, along with a list of required and optional header fields. The requirements for this handshake are as follows.  </p>

<ol>
<li>The handshake MUST be a valid HTTP request as specified by <a href="#RFC2616">[RFC2616]</a>.</li>
<li>The Method of the request MUST be GET and the HTTP version MUST be at least 1.1.  <br><br> For example, if the WebSocket URI is "ws://example.com/chat", The first line sent should be "GET /chat HTTP/1.1"</li>
<li>The "Request-URI" part of the request MUST match the /resource name/ <a href="#ws_uris">Section 3</a> (a relative URI), or be an absolute http/https URI that, when parsed, has a /resource name/, /host/ and /port/ that match the corresponding ws/wss URI.</li>
<li>The request MUST contain a "Host" header field whose value is equal to /host/.</li>
<li>The request MUST contain an "Upgrade" header field whose value is equal to "websocket".</li>
<li>The request MUST contain a "Connection" header field whose value MUST include the "Upgrade" token.</li>
<li>The request MUST include a header field with the name "Sec-WebSocket-Key". The value of this header field MUST be a nonce consisting of a randomly selected 16-byte value that has been base64-encoded (see Section 4 of <a href="#RFC4648">[RFC4648]</a>). The nonce MUST be selected randomly for each connection. <br><br> NOTE: As an example, if the randomly selected value was the sequence of bytes 0x01 0x02 0x03 0x04 0x05 0x06 0x07 0x08 0x09 0x0a 0x0b 0x0c 0x0d 0x0e 0x0f 0x10, the value of the header field would be "AQIDBAUGBwgJCgsMDQ4PEC=="</li>
<li>The request MUST include a header field with the name "Origin" <a href="#I-D.ietf-websec-origin">[I-D.ietf-websec-origin]</a> if the request is coming from a browser client. If the connection is from a non-browser client, the request MAY include this header field if the semantics of that client match the use-case described here for browser clients.  The value of this header field is the ASCII serialization of origin of the context in which the code establishing the connection is running. See <a href="#I-D.ietf-websec-origin">[I-D.ietf-websec-origin]</a> for the details of how this header field value is constructed.  <br><br> As an example, if code downloaded from www.example.com attempts to establish a connection to ww2.example.com, the value of the header field would be "http://www.example.com".</li>
<li>The request MUST include a header field with the name "Sec-WebSocket-Version". The value of this header field MUST be 13.  <em>Note: Although drafts -09, -10, -11 and -12 were published, as they were mostly comprised of editorial changes and clarifications and not changes to the wire protocol, values 9, 10, 11 and 12 were not used as valid values for Sec-WebSocket-Version. These values were reserved in the IANA registry but were not and will not be used.</em> </li>
<li>The request MAY include a header field with the name "Sec-WebSocket-Protocol". If present, this value indicates one or more comma separated subprotocol the client wishes to speak, ordered by preference.  The elements that comprise this value MUST be non-empty strings with characters in the range U+0021 to U+007E not including separator characters as defined in <a href="#RFC2616">[RFC2616]</a>, and MUST all be unique strings.  The ABNF for the value of this header field is 1#token, where the definitions of constructs and rules are as given in <a href="#RFC2616">[RFC2616]</a>.</li>
<li>The request MAY include a header field with the name "Sec-WebSocket-Extensions". If present, this value indicates the protocol-level extension(s) the client wishes to speak. The interpretation and format of this header field is described in <a href="#negotiation">Section 9.1</a>.</li>
<li>The request MAY include any other header fields, for example cookies <a href="#RFC6265">[RFC6265]</a> and/or authentication related header fields such as Authorization header field <a href="#RFC2616">[RFC2616]</a>, which are processed according to documents that define them.  </li>
</ol>

<p> </p>
<p id="rfc.section.4.1.p.5">Once the client's opening handshake has been sent, the client MUST wait for a response from the server before sending any further data.  The client MUST validate the server's response as follows: </p>

<ol>
<li>If the status code received from the server is not 101, the client handles the response per HTTP <a href="#RFC2616">[RFC2616]</a> procedures, in particular the client might perform authentication if it receives 401 status code, the server might redirect the client using a 3xx status code (but clients are not required to follow them), etc.  Otherwise, proceed as follows.</li>
<li>If the response lacks an "Upgrade" header field or the "Upgrade" header field contains a value that is not an ASCII case-insensitive match for the value "websocket", the client MUST <em>Fail the WebSocket Connection </em>.</li>
<li>If the response lacks a "Connection" header field or the "Connection" header field doesn't contain a token that is an ASCII case-insensitive match for the value "Upgrade", the client MUST <em>Fail the WebSocket Connection</em>.</li>
<li>If the response lacks a "Sec-WebSocket-Accept" header field or the "Sec-WebSocket-Accept" contains a value other than the base64-encoded SHA-1 of the concatenation of the "Sec-WebSocket-Key" (as a string, not base64-decoded) with the string "258EAFA5-E914-47DA-95CA-C5AB0DC85B11", but ignoring any leading and trailing whitespace, the client MUST <em>Fail the WebSocket Connection</em> </li>
<li>If the response includes a "Sec-WebSocket-Extensions" header field, and this header field indicates the use of an extension that was not present in the client' handshake (the server has indicated an extension not requested by the client), the client MUST <em>Fail the WebSocket Connection</em>.  (The parsing of this header field to determine which extensions are requested is discussed in <a href="#negotiation">Section 9.1</a>.)</li>
<li>If the response includes a "Sec-WebSocket-Protocol" header field, and this header field indicates the use of a subprotocol that was not present in the client' handshake (the server has indicated a subprotocol not requested by the client), the client MUST <em>Fail the WebSocket Connection</em>.</li>
</ol>

<p> </p>
<p id="rfc.section.4.1.p.6">If the server's response does not conform to the requirements for the server's handshake as defined in this section and in <a href="#server_handshake">Section 4.2.2</a>, the client MUST <em>Fail the WebSocket Connection</em>.  </p>
<p id="rfc.section.4.1.p.7">Please note that according to <a href="#RFC2616">[RFC2616]</a> all header field names in both HTTP requests and HTTP responses are case-insensitive.</p>
<p id="rfc.section.4.1.p.8">If the server's response is validated as provided for above, it is said that <em>The WebSocket Connection is Established</em> and that the WebSocket Connection is in the OPEN state. The <em>Extensions In Use</em> is defined to be a (possibly empty) string, the value of which is equal to the value of the |Sec-WebSocket-Extensions| header field supplied by the server's handshake, or the null value if that header field was not present in the server's handshake. The <em>Subprotocol In Use</em> is defined to be the value of the |Sec-WebSocket-Protocol| header field in the server's handshake, or the null value if that header field was not present in the server's handshake. Additionally, if any header fields in the server's handshake indicate that cookies should be set (as defined by <a href="#RFC6265">[RFC6265]</a>), these cookies are referred to as <em>Cookies Set During the Server's Opening Handshake</em>.  </p>
<h1 id="rfc.section.4.2">
<a href="#rfc.section.4.2">4.2.</a> Server-side Requirements</h1>
<p id="rfc.section.4.2.p.1">Servers MAY offload the management of the connection to other agents on the network, for example load balancers and reverse proxies.  In such a situation, the server for the purposes of this specification is considered to include all parts of the server-side infrastructure from the first device to terminate the TCP connection all the way to the server that processes requests and sends responses.</p>
<p id="rfc.section.4.2.p.2">EXAMPLE: For example, a data center might have a server that responds to WebSocket requests with an appropriate handshake, and then passes the connection to another server to actually process the data frames. For the purposes of this specification, the "server" is the combination of both computers.</p>
<h1 id="rfc.section.4.2.1">
<a href="#rfc.section.4.2.1">4.2.1.</a> Reading the Client's Opening Handshake</h1>
<p id="rfc.section.4.2.1.p.1">When a client starts a WebSocket connection, it sends its part of the opening handshake. The server must parse at least part of this handshake in order to obtain the necessary information to generate the server part of the handshake.</p>
<p id="rfc.section.4.2.1.p.2">The client's opening handshake consists of the following parts. If the server, while reading the handshake, finds that the client did not send a handshake that matches the description below (note that as per <a href="#RFC2616">[RFC2616]</a> the order of the header fields is not important), including but not limited to any violations of the ABNF grammar specified for the components of the handshake, the server MUST stop processing the client's handshake, and return an HTTP response with an appropriate error code (such as 400 Bad Request).  </p>

<ol>
<li>An HTTP/1.1 or higher GET request, including a "Request-URI" <a href="#RFC2616">[RFC2616]</a> that should be interpreted as a /resource name/ <a href="#ws_uris">Section 3</a> (or an absolute HTTP/HTTPS URI containing the /resource name/). </li>
<li>A "Host" header field containing the server's authority.</li>
<li>An "Upgrade" header field containing the value "websocket", treated as an ASCII case-insensitive value.</li>
<li>A "Connection" header field that includes the token "Upgrade", treated as an ASCII case-insensitive value.</li>
<li>A "Sec-WebSocket-Key" header field with a base64-encoded (see Section 4 of <a href="#RFC4648">[RFC4648]</a>) value that, when decoded, is 16 bytes in length.</li>
<li>A "Sec-WebSocket-Version" header field, with a value of 13.</li>
<li>Optionally, an "Origin" header field. This header field is sent by all browser clients. A connection attempt lacking this header field SHOULD NOT be interpreted as coming from a browser client.</li>
<li>Optionally, a "Sec-WebSocket-Protocol" header field, with a list of values indicating which protocols the client would like to speak, ordered by preference.</li>
<li>Optionally, a "Sec-WebSocket-Extensions" header field, with a list of values indicating which extensions the client would like to speak. The interpretation of this header field is discussed in <a href="#negotiation">Section 9.1</a>.</li>
<li>Optionally, other header fields, such as those used to send cookies or request authentication to a server. Unknown header fields are ignored, as per <a href="#RFC2616">[RFC2616]</a>.</li>
</ol>

<p> </p>
<h1 id="rfc.section.4.2.2">
<a href="#rfc.section.4.2.2">4.2.2.</a> <a href="#server_handshake" id="server_handshake">Sending the Server's Opening Handshake</a>
</h1>
<div id="#rfc.figure.12"></div>
<pre>
      Sec-WebSocket-Accept     = base64-value-non-empty
      base64-value-non-empty = (1*base64-data [ base64-padding ]) |
                               base64-padding
      base64-data      = 4base64-character
      base64-padding   = (2base64-character "==") |
                         (3base64-character "=")
      base64-character = ALPHA | DIGIT | "+" | "/"
                </pre>
<p id="rfc.section.4.2.2.p.1">When a client establishes a WebSocket connection to a server, the server MUST complete the following steps to accept the connection and send the server's opening handshake.  </p>

<ol>
<li>If the connection is happening on an HTTPS (HTTP-over-TLS) port, perform a TLS handshake over the connection. If this fails (e.g. the client indicated a host name in the extended client hello "server_name" extension that the server does not host), then close the connection; otherwise, all further communication for the connection (including the server's handshake) MUST run through the encrypted tunnel. <a href="#RFC5246">[RFC5246]</a>
</li>
<li>The server can perform additional client authentication, for example by returning a 401 status code with the corresponding WWW-Authenticate header field as described in <a href="#RFC2616">[RFC2616]</a>.</li>
<li>The server MAY redirect the client using a 3xx status code <a href="#RFC2616">[RFC2616]</a>. Note that this step can happen together with, before or after the optional authentication step described above.</li>
<li>Establish the following information: <dl>
<dt>/origin/</dt>
<dd style="margin-left: 8">
<br> The |Origin| header field in the client's handshake indicates the origin of the script establishing the connection.  The origin is serialized to ASCII and converted to lowercase.  The server MAY use this information as part of a determination of whether to accept the incoming connection. If the server does not validate the origin, it will accept connections from anywhere.  If the server does not wish to accept this connection, it MUST return an appropriate HTTP error code (e.g. 403 Forbidden) and abort the WebSocket handshake described in this section.  For more detail, refer to <a href="#securityconsiderations">Section 10</a>.</dd>
<dt>/key/</dt>
<dd style="margin-left: 8">
<br> The |Sec-WebSocket-Key| header field in the client's handshake includes a base64-encoded value that, if decoded, is 16 bytes in length. This (encoded) value is used in the creation of the server's handshake to indicate an acceptance of the connection. It is not necessary for the server to base64-decode the "Sec-WebSocket-Key" value.</dd>
<dt>/version/</dt>
<dd style="margin-left: 8">
<br> The |Sec-WebSocket-Version| header field in the client's handshake includes the version of the WebSocket protocol the client is attempting to communicate with. If this version does not match a version understood by the server, the server MUST abort the websocket handshake described in this section and instead send an appropriate HTTP error code (such as 426 Upgrade Required), and a |Sec-WebSocket-Version| header field indicating the version(s) the server is capable of understanding.  </dd>
<dt>/resource name/</dt>
<dd style="margin-left: 8">
<br> An identifier for the service provided by the server. If the server provides multiple services, then the value should be derived from the resource name given in the client's handshake from the Request-URI <a href="#RFC2616">[RFC2616]</a> of the GET method. If the requested service is not available, the server MUST send an appropriate HTTP error code (such as 404 Not Found) and abort the WebSocket handshake.</dd>
<dt>/subprotocol/</dt>
<dd style="margin-left: 8">
<br> Either a single value representing the subprotocol the server is ready to use or null. The value chosen MUST be derived from the client's handshake, specifically by selecting one of the values from the "Sec-WebSocket-Protocol" field that the server is willing to use for this connection (if any). If the client's handshake did not contain such a header field, or if the server does not agree to any of the client's requested subprotocols, the only acceptable value is null.  The absence of such a field is equivalent to the null value (meaning that if the server does not wish to agree to one of the suggested subprotocols, it MUST NOT send back a |Sec-WebSocket-Protocol| header field in its response). The empty string is not the same as the null value for these purposes, and is not a legal value for this field. The ABNF for the value of this header field is (token), where the definitions of constructs and rules are as given in <a href="#RFC2616">[RFC2616]</a>.</dd>
<dt>/extensions/</dt>
<dd style="margin-left: 8">
<br> A (possibly empty) list representing the protocol-level extensions the server is ready to use. If the server supports multiple extensions, then the value MUST be derived from the client's handshake, specifically by selecting one or more of the values from the "Sec-WebSocket-Extensions" field. The absence of such a field is equivalent to the null value. The empty string is not the same as the null value for these purposes. Extensions not listed by the client MUST NOT be listed.  The method by which these values should be selected and interpreted is discussed in <a href="#negotiation">Section 9.1</a>.</dd>
</dl>
<p> </p>
</li>
<li>If the server chooses to accept the incoming connection, it MUST reply with a valid HTTP response indicating the following.  <ol>
<li>A Status-Line with a 101 response code as per RFC 2616 <a href="#RFC2616">[RFC2616]</a>. Such a response could look like "HTTP/1.1 101 Switching Protocols"</li>
<li>An "Upgrade" header field with value "websocket" as per RFC 2616 <a href="#RFC2616">[RFC2616]</a>.  </li>
<li>A "Connection" header field with value "Upgrade"</li>
<li>A "Sec-WebSocket-Accept" header field. The value of this header field is constructed by concatenating /key/, defined above in <a href="#server_handshake_info">[server_handshake_info]</a> of <a href="#server_handshake">Section 4.2.2</a>, with the string "258EAFA5-E914-47DA-95CA-C5AB0DC85B11", taking the SHA-1 hash of this concatenated value to obtain a 20-byte value, and base64-encoding (see Section 4 of <a href="#RFC4648">[RFC4648]</a>) this 20-byte hash.  <br><br>The ABNF <a href="#RFC2616">[RFC2616]</a> of this header field is defined as follows: <br><br> NOTE: As an example, if the value of the "Sec-WebSocket-Key" header field in the client's handshake were "dGhlIHNhbXBsZSBub25jZQ==", the server would append the string "258EAFA5-E914-47DA-95CA-C5AB0DC85B11" to form the string "dGhlIHNhbXBsZSBub25jZQ==258EAFA5-E914-47DA-95CA-C5AB0DC85B11".  The server would then take the SHA-1 hash of this string, giving the value 0xb3 0x7a 0x4f 0x2c 0xc0 0x62 0x4f 0x16 0x90 0xf6 0x46 0x06 0xcf 0x38 0x59 0x45 0xb2 0xbe 0xc4 0xea. This value is then base64-encoded, to give the value "s3pPLMBiTxaQ9kYGzzhZRbK+xOo=", which would be returned in the "Sec-WebSocket-Accept" header field.</li>
<li>Optionally, a "Sec-WebSocket-Protocol" header field, with a value /subprotocol/ as defined in <a href="#server_handshake_info">[server_handshake_info]</a> of <a href="#server_handshake">Section 4.2.2</a>.</li>
<li>Optionally, a "Sec-WebSocket-Extensions" header field, with a value /extensions/ as defined in <a href="#server_handshake_info">[server_handshake_info]</a> of <a href="#server_handshake">Section 4.2.2</a>. If multiple extensions are to be used, they can all be listed in a single Sec-WebSocket-Extensions header field, or split between multiple instances of the Sec-WebSocket-Extensions header field.  </li>
</ol>
<p> </p>
</li>
</ol>

<p> </p>
<p id="rfc.section.4.2.2.p.2">This completes the server's handshake. If the server finishes these steps without aborting the WebSocket handshake, the server considers the WebSocket connection to be established and that the WebSocket connection is in the OPEN state. At this point, the server may begin sending (and receiving) data.  </p>
<h1 id="rfc.section.4.3">
<a href="#rfc.section.4.3">4.3.</a> Collected ABNF for new header fields used in handshake</h1>
<p id="rfc.section.4.3.p.1">This section is using ABNF syntax/rules from Section 2.1 of <a href="#RFC2616">[RFC2616]</a>, including "implied *LWS rule".  </p>
<p id="rfc.section.4.3.p.2">Note that the following ABNF conventions are used in this section: Some names of the rules correspond to names of the corresponding header fields.  Such rules express values of the corresponding header fields, for example the Sec-WebSocket-Key ABNF rule describes syntax of the Sec-WebSocket-Key header field value.  ABNF rules with the "-Client" suffix in the name are only used in requests sent by the client to the server; ABNF rules with the "-Server" suffix in the name are only used in responses sent by the server to the client. For example, the ABNF rule Sec-WebSocket-Protocol-Client describes syntax of the Sec-WebSocket-Protocol header field value sent by the client to the server.  </p>
<p id="rfc.section.4.3.p.3">The following new header field can be sent during the handshake from the client to the server:</p>
<div id="#rfc.figure.13"></div>
<pre>
            Sec-WebSocket-Key = base64-value-non-empty
            Sec-WebSocket-Extensions = extension-list
            Sec-WebSocket-Protocol-Client = 1#token
            Sec-WebSocket-Version-Client = version

            base64-value-non-empty = (1*base64-data [ base64-padding ]) |
                                      base64-padding
            base64-data      = 4base64-character
            base64-padding   = (2base64-character "==") |
                               (3base64-character "=")
            base64-character = ALPHA | DIGIT | "+" | "/"
            extension-list = 1#extension
            extension = extension-token *( ";" extension-param )
            extension-token = registered-token
            registered-token = token
            extension-param = token [ "=" (token | quoted-string) ]
                 ;When using the quoted-string syntax variant, the value
                 ;after quoted-string unescaping MUST conform to the 'token' ABNF.
            NZDIGIT       =  "1" | "2" | "3" | "4" | "5" | "6" |
                             "7" | "8" | "9"
            version = DIGIT | (NZDIGIT DIGIT) |
                      ("1" DIGIT DIGIT) | ("2" DIGIT DIGIT)
                      ; Limited to 0-255 range, with no leading zeros
          </pre>
<p id="rfc.section.4.3.p.4">The following new header field can be sent during the handshake from the server to the client: </p>
<div id="#rfc.figure.14"></div>
<pre>
            Sec-WebSocket-Extensions = extension-list
            Sec-WebSocket-Accept     = base64-value-non-empty
            Sec-WebSocket-Protocol-Server = token
            Sec-WebSocket-Version-Server = 1#version
            </pre>
<h1 id="rfc.section.4.4">
<a href="#rfc.section.4.4">4.4.</a> Supporting multiple versions of WebSocket protocol</h1>
<p id="rfc.section.4.4.p.1">This section provides some guidance on supporting multiple versions of the WebSocket protocol in clients and servers.</p>
<p id="rfc.section.4.4.p.2">Using the WebSocket version advertisement capability (the "Sec-WebSocket-Version" header field) client can initially request the version of the WebSocket protocol that it prefers (which doesn't necessarily have to be the latest supported by the client).  If the server supports the requested version and the handshake message is otherwise valid, the server will accept that version.  If the server doesn't support the requested version, it MUST respond with a Sec-WebSocket-Version header field (or multiple Sec-WebSocket-Version header fields) containing all versions it is willing to use.  At this point, if the client supports one of the advertised versions, it can repeat the WebSocket handshake using a new version value.</p>
<p id="rfc.section.4.4.p.3">The following example demonstrates version negotiation described above:</p>
<div id="#rfc.figure.15"></div>
<pre>
     GET /chat HTTP/1.1
     Host: server.example.com
     Upgrade: websocket
     Connection: Upgrade
     ...
     Sec-WebSocket-Version: 25
          </pre>
<p id="rfc.section.4.4.p.4">The response from the server might look as follows:</p>
<div id="#rfc.figure.16"></div>
<pre>
     HTTP/1.1 400 Bad Request
     ...
     Sec-WebSocket-Version: 13, 8, 7
          </pre>
<p id="rfc.section.4.4.p.5">Note that the last response from the server might also look like:</p>
<div id="#rfc.figure.17"></div>
<pre>
     HTTP/1.1 400 Bad Request
     ...
     Sec-WebSocket-Version: 13
     Sec-WebSocket-Version: 8, 7
          </pre>
<p id="rfc.section.4.4.p.6">The client now repeats the handshake that conforms to version 13:</p>
<div id="#rfc.figure.18"></div>
<pre>
     GET /chat HTTP/1.1
     Host: server.example.com
     Upgrade: websocket
     Connection: Upgrade
     ...
     Sec-WebSocket-Version: 13
          </pre>
<h1 id="rfc.section.5">
<a href="#rfc.section.5">5.</a> <a href="#framing" id="framing">Data Framing</a>
</h1>
<h1 id="rfc.section.5.1">
<a href="#rfc.section.5.1">5.1.</a> Overview</h1>
<p id="rfc.section.5.1.p.1">In the WebSocket protocol, data is transmitted using a sequence of frames. To avoid confusing network intermediaries (such as intercepting proxies) and for security reasons that are further discussed in <a href="#masking-reasons">Section 10.3</a>, a client MUST mask all frames that it sends to the server (see <a href="#masking">Section 5.3</a> for further details).  (Note that masking is done whether or not the WebSocket protocol is running over TLS.) The server MUST close the connection upon receiving a frame that is not masked.  In this case, a server MAY send a close frame with a status code of 1002 (protocol error) as defined in <a href="#closestatus">Section 7.4.1</a>.  A server MUST NOT mask any frames that it sends to the client.  A client MUST close a connection if it detects a masked frame.  In this case, it MAY use the status code 1002 (protocol error) as defined in <a href="#closestatus">Section 7.4.1</a>.  (These rules might be relaxed in a future specification.)</p>
<p id="rfc.section.5.1.p.2">The base framing protocol defines a frame type with an opcode, a payload length, and designated locations for extension and application data, which together define the <em>payload</em> data. Certain bits and opcodes are reserved for future expansion of the protocol.</p>
<p id="rfc.section.5.1.p.3">A data frame MAY be transmitted by either the client or the server at any time after opening handshake completion and before that endpoint has sent a close frame (<a href="#closeframe">Section 5.5.1</a>).</p>
<h1 id="rfc.section.5.2">
<a href="#rfc.section.5.2">5.2.</a> <a href="#baseframing" id="baseframing">Base Framing Protocol</a>
</h1>
<p id="rfc.section.5.2.p.1">This wire format for the data transfer part is described by the ABNF <a href="#RFC5234">[RFC5234]</a> given in detail in this section.  (Note that unlike in other sections of this document the ABNF in this section is operating on groups of bits. The length of each group of bits is indicated in a comment. When encoded on the wire the most significant bit is the leftmost in the ABNF).  A high level overview of the framing is given in the following figure.  In a case of conflict between the figure below and the ABNF specified later in this section, the figure is authoritative.  <br><br> </p>
<div id="#rfc.figure.19"></div>
<pre>
   0                   1                   2                   3
   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
  +-+-+-+-+-------+-+-------------+-------------------------------+
  |F|R|R|R| opcode|M| Payload len |    Extended payload length    |
  |I|S|S|S|  (4)  |A|     (7)     |             (16/64)           |
  |N|V|V|V|       |S|             |   (if payload len==126/127)   |
  | |1|2|3|       |K|             |                               |
  +-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - +
  |     Extended payload length continued, if payload len == 127  |
  + - - - - - - - - - - - - - - - +-------------------------------+
  |                               |Masking-key, if MASK set to 1  |
  +-------------------------------+-------------------------------+
  | Masking-key (continued)       |          Payload Data         |
  +-------------------------------- - - - - - - - - - - - - - - - +
  :                     Payload Data continued ...                :
  + - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +
  |                     Payload Data continued ...                |
  +---------------------------------------------------------------+
          </pre>
<p></p>

<dl>
<dt>FIN:</dt>
<dd style="margin-left: 8">1 bit <br><br> Indicates that this is the final fragment in a message. The first fragment MAY also be the final fragment.  </dd>
<dt>RSV1, RSV2, RSV3:</dt>
<dd style="margin-left: 8">1 bit each <br><br> MUST be 0 unless an extension is negotiated which defines meanings for non-zero values. If a nonzero value is received and none of the negotiated extensions defines the meaning of such a nonzero value, the receiving endpoint MUST <em>Fail the WebSocket Connection</em>.  </dd>
<dt>Opcode:</dt>
<dd style="margin-left: 8">4 bits <br><br> Defines the interpretation of the payload data. If an unknown opcode is received, the receiving endpoint MUST <em>Fail the WebSocket Connection</em>.  The following values are defined.  <ul>
<li>%x0 denotes a continuation frame</li>
<li>%x1 denotes a text frame</li>
<li>%x2 denotes a binary frame</li>
<li>%x3-7 are reserved for further non-control frames</li>
<li>%x8 denotes a connection close</li>
<li>%x9 denotes a ping</li>
<li>%xA denotes a pong</li>
<li>%xB-F are reserved for further control frames</li>
</ul>
<p> </p>
</dd>
<dt>Mask:</dt>
<dd style="margin-left: 8">1 bit <br><br> Defines whether the payload data is masked. If set to 1, a masking key is present in masking-key, and this is used to unmask the payload data as per <a href="#masking">Section 5.3</a>. All frames sent from client to server have this bit set to 1.  </dd>
<dt>Payload length:</dt>
<dd style="margin-left: 8">7 bits, 7+16 bits, or 7+64 bits <br><br> The length of the payload data, in bytes: if 0-125, that is the payload length. If 126, the following 2 bytes interpreted as a 16 bit unsigned integer are the payload length.  If 127, the following 8 bytes interpreted as a 64-bit unsigned integer (the most significant bit MUST be 0) are the payload length. Multibyte length quantities are expressed in network byte order. Note that in all case the minimal number of bytes MUST be used to encode the length, for example the length of a 124 byte long string can't be encoded as the sequence 126, 0, 124. The payload length is the length of the extension data + the length of the application data. The length of the extension data may be zero, in which case the payload length is the length of the application data.  </dd>
<dt>Masking-key:</dt>
<dd style="margin-left: 8">0 or 4 bytes <br><br> All frames sent from the client to the server are masked by a 32-bit value that is contained within the frame. This field is present if the mask bit is set to 1, and is absent if the mask bit is set to 0. See <a href="#masking">Section 5.3</a> for further information on client-to-server masking.  </dd>
<dt>Payload data:</dt>
<dd style="margin-left: 8">(x+y) bytes <br><br> The payload data is defined as extension data concatenated with application data.  </dd>
<dt>Extension data:</dt>
<dd style="margin-left: 8">x bytes <br><br> The extension data is 0 bytes unless an extension has been negotiated. Any extension MUST specify the length of the extension data, or how that length may be calculated, and how the extension use MUST be negotiated during the opening handshake. If present, the extension data is included in the total payload length.  </dd>
<dt>Application data:</dt>
<dd style="margin-left: 8">y bytes <br><br> Arbitrary application data, taking up the remainder of the frame after any extension data. The length of the application data is equal to the payload length minus the length of the extension data.  </dd>
</dl>

<p> </p>
<p id="rfc.section.5.2.p.3">The base framing protocol is formally defined by the following ABNF <a href="#RFC5234">[RFC5234]</a>. It is important to note that the representation of this data is binary, not ASCII characters. As such, a field with a length of 1 bit that takes values %x0 / %x1 is represented as a single bit whose value is 0 or 1, not a full byte (octet) that stands for the characters "0" or "1" in the ASCII encoding. A field with a length of 4 bits with values between %x0-F again is represented by 4 bits, again NOT by an ASCII character or full byte (octet) with these values. <a href="#RFC5234">[RFC5234]</a> does not specify a character encoding - " Rules resolve into a string of terminal values, sometimes called characters.  In ABNF, a character is merely a non-negative integer. In certain contexts, a specific mapping (encoding) of values into a character set (such as ASCII) will be specified." Here, the specified encoding is a binary encoding where each terminal value is encoded in the specified number of bits, which varies for each field.  </p>
<div id="#rfc.figure.20"></div>
<pre>
   ws-frame                = frame-fin           ; 1 bit in length
                             frame-rsv1          ; 1 bit in length
                             frame-rsv2          ; 1 bit in length
                             frame-rsv3          ; 1 bit in length
                             frame-opcode        ; 4 bits in length
                             frame-masked        ; 1 bit in length
                             frame-payload-length   ;  7 bits in length
                             [ frame-masking-key ]  ; 16 or 64 bits in length
                             frame-payload-data     ; n * 8 bits in length,
                                                    ; where n &gt;= 0

   frame-fin               = %x0 ; more frames of this message follow
                           / %x1 ; final frame of this message
                                 ; 1 bit in length

   frame-rsv1              = %x0 / %x1
                             ; 1 bit in length, MUST be 0 unless negotiated
                             ; otherwise

   frame-rsv2              = %x0 / %x1
                             ; 1 bit in length, MUST be 0 unless negotiated
                             ; otherwise

   frame-rsv3              = %x0 / %x1
                             ; 1 bit in length, MUST be 0 unless negotiated
                             ; otherwise

   frame-opcode            = frame-opcode-non-control /
                             frame-opcode-control

   frame-opcode-non-control= %x1 ; text frame
                           / %x2 ; binary frame
                           / %x3-7
			  ; reserved for further non-control frames

   frame-opcode-control    = %x8 ; connection close
                           / %x9 ; ping
                           / %xA ; pong
                           / %xB-F ; reserved for further control frames
                                ; 4 bits in length

   frame-masked            = %x0
                          ; frame is not masked, no frame-masking-key
                           / %x1
                          ; frame is masked, frame-masking-key present
                          ; 1 bit in length

   frame-payload-length    = %x00-7D
                           / %x7E frame-payload-length-16
                           / %x7F frame-payload-length-63
                           ; 7 bits in length

   frame-payload-length-16 = %x0000-FFFF ; 16 bits in length

   frame-payload-length-63 = %x0000000000000000-7FFFFFFFFFFFFFFF
                           ; 64 bits in length

   frame-masking-key       = 4( %0x00-FF )
                             ; present only if frame-masked is 1
                             ; 32 bits in length

   frame-payload-data      = (frame-masked-extension-data
                              frame-masked-application-data)
                           ; frame-masked 1
                             / (frame-unmasked-extension-data
                               frame-unmasked-application-data)
                           ; frame-masked 0

   frame-masked-extension-data     = *( %x00-FF )
                           ; reserved for future extensibility
                                   ; n*8 bits in length , where n &gt;= 0

   frame-masked-application-data   = *( %x00-FF )
                                   ; n*8 bits in length, where n &gt;= 0

   frame-unmasked-extension-data   = *( %x00-FF )
                           ; reserved for future extensibility
                                   ; n*8 bits in length, where n &gt;= 0

   frame-unmasked-application-data = *( %x00-FF )
                                   ; n*8 bits in length, where n &gt;= 0
</pre>
<p></p>
<h1 id="rfc.section.5.3">
<a href="#rfc.section.5.3">5.3.</a> <a href="#masking" id="masking">Client-to-Server Masking</a>
</h1>
<p id="rfc.section.5.3.p.1">A masked frame MUST have the field frame-masked set to 1, as defined in <a href="#baseframing">Section 5.2</a>.  </p>
<p id="rfc.section.5.3.p.2">The masking key is contained completely within the frame, as defined in <a href="#baseframing">Section 5.2</a> as frame-masking-key. It is used to mask the payload data defined in the same section as frame-payload-data, which includes extension and application data.</p>
<p id="rfc.section.5.3.p.3">The masking key is a 32-bit value chosen at random by the client.  When preparing a masked frame, the client MUST pick a fresh masking key from the set of allowed 32-bit values. The masking key needs to be unpredictable, thus the masking key MUST be derived from a strong source of entropy, and the masking key for a given frame MUST NOT make it simple for a server/proxy to predict the masking key for a subsequent frame.  The unpredictability of the masking key is essential to prevent the author of malicious applications from selecting the bytes that appear on the wire. RFC 4086 <a href="#RFC4086">[RFC4086]</a> discusses what entails a suitable source of entropy for security-sensitive applications.</p>
<p id="rfc.section.5.3.p.4">The masking does not affect the length of the payload data. To convert masked data into unmasked data, or vice versa, the following algorithm is applied. The same algorithm applies regardless of the direction of the translation - e.g. the same steps are applied to mask the data as to unmask the data.</p>
<p id="rfc.section.5.3.p.5">Octet i of the transformed data ("transformed-octet-i") is the XOR of octet i of the original data ("original-octet-i") with octet at index i modulo 4 of the masking key ("masking-key-octet-j"):</p>
<div id="#rfc.figure.21"></div>
<pre>
            
  j                   = i MOD 4
  transformed-octet-i = original-octet-i XOR masking-key-octet-j
            
          </pre>
<p id="rfc.section.5.3.p.6">The payload length, indicated in the framing as frame-payload-length, does NOT include the length of the masking key. It is the length of the payload data, e.g. the number of bytes following the masking key.</p>
<h1 id="rfc.section.5.4">
<a href="#rfc.section.5.4">5.4.</a> <a href="#fragmentation" id="fragmentation">Fragmentation</a>
</h1>
<p id="rfc.section.5.4.p.1">The primary purpose of fragmentation is to allow sending a message that is of unknown size when the message is started without having to buffer that message. If messages couldn't be fragmented, then an endpoint would have to buffer the entire message so its length could be counted before first byte is sent. With fragmentation, a server or intermediary may choose a reasonable size buffer, and when the buffer is full write a fragment to the network.  </p>
<p id="rfc.section.5.4.p.2">A secondary use-case for fragmentation is for multiplexing, where it is not desirable for a large message on one logical channel to monopolize the output channel, so the MUX needs to be free to split the message into smaller fragments to better share the output channel. (Note that the multiplexing extension is not described in this document.) </p>
<p id="rfc.section.5.4.p.3">Unless specified otherwise by an extension, frames have no semantic meaning. An intermediary might coalesce and/or split frames, if no extensions were negotiated by the client and the server, or if some extensions were negotiated, but the intermediary understood all the extensions negotiated and knows how to coalesce and/or split frames in presence of these extensions. One implication of this is that in absence of extensions senders and receivers must not depend on presence of specific frame boundaries.</p>
<p id="rfc.section.5.4.p.4">The following rules apply to fragmentation: </p>

<ul>
<li>An unfragmented message consists of a single frame with the FIN bit set (<a href="#baseframing">Section 5.2</a>) and an opcode other than 0.</li>
<li>A fragmented message consists of a single frame with the FIN bit clear and an opcode other than 0, followed by zero or more frames with the FIN bit clear and the opcode set to 0, and terminated by a single frame with the FIN bit set and an opcode of 0. A fragmented message is conceptually equivalent to a single larger message whose payload is equal to the concatenation of the payloads of the fragments in order, however in the presence of extensions this may not hold true as the extension defines the interpretation of the extension data present. For instance, extension data may only be present at the beginning of the first fragment and apply to subsequent fragments, or there may be extension data present in each of the fragments that applies only to that particular fragment. In absence of extension data, the following example demonstrates how fragmentation works.  <br><br> EXAMPLE: For a text message sent as three fragments, the first fragment would have an opcode of 0x1 and a FIN bit clear, the second fragment would have an opcode of 0x0 and a FIN bit clear, and the third fragment would have an opcode of 0x0 and a FIN bit that is set.  </li>
<li>Control frames (see <a href="#controlframes">Section 5.5</a>) MAY be injected in the middle of a fragmented message. Control frames themselves MUST NOT be fragmented.</li>
<li>Message fragments MUST be delivered to the recipient in the order sent by the sender.</li>
<li>The fragments of one message MUST NOT be interleaved between the fragments of another message unless an extension has been negotiated that can interpret the interleaving.</li>
<li>An endpoint MUST be capable of handling control frames in the middle of a fragmented message.</li>
<li>A sender MAY create fragments of any size for non-control messages.</li>
<li>Clients and servers MUST support receiving both fragmented and unfragmented messages.  </li>
<li>As control frames cannot be fragmented, an intermediary MUST NOT attempt to change the fragmentation of a control frame.</li>
<li>An intermediary MUST NOT change the fragmentation of a message if any reserved bit values are used and the meaning of these values is not known to the intermediary.</li>
<li>An intermediary MUST NOT change the fragmentation of any message in the context of a connection where extensions have been negotiated and the intermediary is not aware of the semantics of the negotiated extensions.  Similarly, an intermediary that didn't see the WebSocket handshake (and wasn't notified about its content) that resulted in a WebSocket connection MUST NOT change the fragmentation of any message of such connection.</li>
<li>As a consequence of these rules, all fragments of a message are of the same type, as set by the first fragment's opcode. Since Control frames cannot be fragmented, the type for all fragments in a message MUST be either text or binary, or one of the reserved opcodes.  </li>
</ul>

<p> </p>
<p><em>Note: if control frames could not be interjected, the latency of a ping, for example, would be very long if behind a large message. Hence, the requirement of handling control frames in the middle of a fragmented message.</em> </p>
<p><em>Implementation Note: in absence of any extension a receiver doesn't have to buffer the whole frame in order to process it.  For example if a streaming API is used, a part of a frame can be delivered to the application. But note that that assumption might not hold true for all future WebSocket extensions.</em> </p>
<h1 id="rfc.section.5.5">
<a href="#rfc.section.5.5">5.5.</a> <a href="#controlframes" id="controlframes">Control Frames</a>
</h1>
<p id="rfc.section.5.5.p.1">Control frames are identified by opcodes where the most significant bit of the opcode is 1. Currently defined opcodes for control frames include 0x8 (Close), 0x9 (Ping), and 0xA (Pong). Opcodes 0xB-0xF are reserved for further control frames yet to be defined.</p>
<p id="rfc.section.5.5.p.2">Control frames are used to communicate state about the WebSocket. Control frames can be interjected in the middle of a fragmented message.  </p>
<p id="rfc.section.5.5.p.3">All control frames MUST have a payload length of 125 bytes or less and MUST NOT be fragmented.</p>
<h1 id="rfc.section.5.5.1">
<a href="#rfc.section.5.5.1">5.5.1.</a> <a href="#closeframe" id="closeframe">Close</a>
</h1>
<p id="rfc.section.5.5.1.p.1">The Close frame contains an opcode of 0x8.</p>
<p id="rfc.section.5.5.1.p.2">The Close frame MAY contain a body (the "application data" portion of the frame) that indicates a reason for closing, such as an endpoint shutting down, an endpoint having received a frame too large, or an endpoint having received a frame that does not conform to the format expected by the other endpoint. If there is a body, the first two bytes of the body MUST be a 2-byte unsigned integer (in network byte order) representing a status code with value /code/ defined in <a href="#status_codes">Section 7.4</a>.  Following the 2-byte integer the body MAY contain UTF-8 encoded data with value /reason/, the interpretation of which is not defined by this specification. This data is not necessarily human readable, but may be useful for debugging or passing information relevant to the script that opened the connection. As the data is not guaranteed to be human readable, clients MUST NOT show it to end users.</p>
<p id="rfc.section.5.5.1.p.3">Close frames sent from client to server must be masked as per <a href="#masking">Section 5.3</a>.  </p>
<p id="rfc.section.5.5.1.p.4">The application MUST NOT send any more data frames after sending a close frame.</p>
<p id="rfc.section.5.5.1.p.5">If an endpoint receives a Close frame and that endpoint did not previously send a Close frame, the endpoint MUST send a Close frame in response. (When sending a Close frame in response the endpoint typically echos the status code it received.) It SHOULD do so as soon as practical. An endpoint MAY delay sending a close frame until its current message is sent (for instance, if the majority of a fragmented message is already sent, an endpoint MAY send the remaining fragments before sending a Close frame). However, there is no guarantee that the endpoint which has already sent a Close frame will continue to process data.  </p>
<p id="rfc.section.5.5.1.p.6">After both sending and receiving a close message, an endpoint considers the WebSocket connection closed, and MUST close the underlying TCP connection. The server MUST close the underlying TCP connection immediately; the client SHOULD wait for the server to close the connection but MAY close the connection at any time after sending and receiving a close message, e.g. if it has not received a TCP close from the server in a reasonable time period.</p>
<p id="rfc.section.5.5.1.p.7">If a client and server both send a Close message at the same time, both endpoints will have sent and received a Close message and should consider the WebSocket connection closed and close the underlying TCP connection.</p>
<h1 id="rfc.section.5.5.2">
<a href="#rfc.section.5.5.2">5.5.2.</a> <a href="#pingframe" id="pingframe">Ping</a>
</h1>
<p id="rfc.section.5.5.2.p.1">The Ping frame contains an opcode of 0x9.</p>
<p id="rfc.section.5.5.2.p.2">A Ping frame MAY include Application Data.</p>
<p id="rfc.section.5.5.2.p.3">Upon receipt of a Ping frame, an endpoint MUST send a Pong frame in response, unless it already received a Close frame.  It SHOULD respond with Pong frame as soon as is practical. Pong frames are discussed in <a href="#pongframe">Section 5.5.3</a>.  </p>
<p id="rfc.section.5.5.2.p.4">An endpoint MAY send a Ping frame any time after the connection is established and before the connection is closed. NOTE: A ping frame may serve either as a keepalive, or to verify that the remote endpoint is still responsive.</p>
<h1 id="rfc.section.5.5.3">
<a href="#rfc.section.5.5.3">5.5.3.</a> <a href="#pongframe" id="pongframe">Pong</a>
</h1>
<p id="rfc.section.5.5.3.p.1">The Pong frame contains an opcode of 0xA.</p>
<p><a href="#pingframe">Section 5.5.2</a> details requirements that apply to both Ping and Pong frames.</p>
<p id="rfc.section.5.5.3.p.3">A Pong frame sent in response to a Ping frame must have identical Application Data as found in the message body of the Ping frame being replied to.</p>
<p id="rfc.section.5.5.3.p.4">If an endpoint receives a Ping frame and has not yet sent Pong frame(s) in response to previous Ping frame(s), the endpoint MAY elect to send a Pong frame for only the most recently processed Ping frame.  </p>
<p id="rfc.section.5.5.3.p.5">A Pong frame MAY be sent unsolicited. This serves as a unidirectional heartbeat. A response to an unsolicited pong is not expected.</p>
<h1 id="rfc.section.5.6">
<a href="#rfc.section.5.6">5.6.</a> <a href="#dataframes" id="dataframes">Data Frames</a>
</h1>
<p id="rfc.section.5.6.p.1">Data frames (e.g. non-control frames) are identified by opcodes where the most significant bit of the opcode is 0. Currently defined opcodes for data frames include 0x1 (Text), 0x2 (Binary). Opcodes 0x3-0x7 are reserved for further non-control frames yet to be defined.  </p>
<p id="rfc.section.5.6.p.2">Data frames carry application-layer and/or extension-layer data. The opcode determines the interpretation of the data: </p>

<dl>
<dt>Text</dt>
<dd style="margin-left: 8">
<br><br> The payload data is text data encoded as UTF-8.  Note that a particular text frame might include a partial UTF-8 sequence, however the whole message MUST contain valid UTF-8.  Invalid UTF-8 in reassembled messages is handled as described in <a href="#badutf8">Section 8.1</a>.  </dd>
<dt>Binary</dt>
<dd style="margin-left: 8">
<br><br> The payload data is arbitrary binary data whose interpretation is solely up to the application layer.  </dd>
</dl>

<p> </p>
<h1 id="rfc.section.5.7">
<a href="#rfc.section.5.7">5.7.</a> Examples</h1>
<p></p>

<ul>
<li>A single-frame unmasked text message <ul><li>0x81 0x05 0x48 0x65 0x6c 0x6c 0x6f (contains "Hello")</li></ul>
<p> </p>
</li>
<li>A single-frame masked text message <ul><li>0x81 0x85 0x37 0xfa 0x21 0x3d 0x7f 0x9f 0x4d 0x51 0x58 (contains "Hello")</li></ul>
<p> </p>
</li>
<li>A fragmented unmasked text message <ul>
<li>0x01 0x03 0x48 0x65 0x6c (contains "Hel")</li>
<li>0x80 0x02 0x6c 0x6f (contains "lo")</li>
</ul>
<p> </p>
</li>
<li>Unmasked Ping request and masked Ping response <ul>
<li>0x89 0x05 0x48 0x65 0x6c 0x6c 0x6f (contains a body of "Hello", but the contents of the body are arbitrary)</li>
<li>0x8a 0x85 0x37 0xfa 0x21 0x3d 0x7f 0x9f 0x4d 0x51 0x58 (contains a body of "Hello", matching the body of the ping)</li>
</ul>
<p> </p>
</li>
<li>256 bytes binary message in a single unmasked frame <ul><li>0x82 0x7E 0x0100 [256 bytes of binary data]</li></ul>
<p> </p>
</li>
<li>64KiB binary message in a single unmasked frame <ul><li>0x82 0x7F 0x0000000000010000 [65536 bytes of binary data]</li></ul>
<p> </p>
</li>
</ul>

<p> </p>
<h1 id="rfc.section.5.8">
<a href="#rfc.section.5.8">5.8.</a> Extensibility</h1>
<p id="rfc.section.5.8.p.1">The protocol is designed to allow for extensions, which will add capabilities to the base protocol. The endpoints of a connection MUST negotiate the use of any extensions during the opening handshake. This specification provides opcodes 0x3 through 0x7 and 0xB through 0xF, the extension data field, and the frame-rsv1, frame-rsv2, and frame-rsv3 bits of the frame header for use by extensions. The negotiation of extensions is discussed in further detail in <a href="#negotiation">Section 9.1</a>.  Below are some anticipated uses of extensions. This list is neither complete nor prescriptive.  </p>

<ul>
<li>Extension data may be placed in the payload data before the application data.</li>
<li>Reserved bits can be allocated for per-frame needs.</li>
<li>Reserved opcode values can be defined.</li>
<li>Reserved bits can be allocated to the opcode field if more opcode values are needed.</li>
<li>A reserved bit or an "extension" opcode can be defined which allocates additional bits out of the payload data to define larger opcodes or more per-frame bits.</li>
</ul>

<p> </p>
<h1 id="rfc.section.6">
<a href="#rfc.section.6">6.</a> Sending and Receiving Data</h1>
<h1 id="rfc.section.6.1">
<a href="#rfc.section.6.1">6.1.</a> <a href="#send_data" id="send_data">Sending Data</a>
</h1>
<p id="rfc.section.6.1.p.1">To <em>Send a WebSocket Message</em> comprising of /data/ over a WebSocket connection, an endpoint MUST perform the following steps.  </p>

<ol>
<li>The endpoint MUST ensure the WebSocket connection is in the OPEN state (cf. <a href="#clienths">Section 4.1</a> and <a href="#server_handshake">Section 4.2.2</a>.) If at any point the state of the WebSocket connection changes, the endpoint MUST abort the following steps.  </li>
<li>An endpoint MUST encapsulate the /data/ in a WebSocket frame as defined in <a href="#baseframing">Section 5.2</a>. If the data to be sent is large, or if the data is not available in its entirety at the point the endpoint wishes to begin sending the data, the endpoint MAY alternately encapsulate the data in a series of frames as defined in <a href="#fragmentation">Section 5.4</a>.  </li>
<li>The opcode (frame-opcode) of the first frame containing the data MUST be set to the appropriate value from <a href="#baseframing">Section 5.2</a> for data that is to be interpreted by the recipient as text or binary data.  </li>
<li>The FIN bit (frame-fin) of the last frame containing the data MUST be set to 1 as defined in <a href="#baseframing">Section 5.2</a>.  </li>
<li>If the data is being sent by the client, the frame(s) MUST be masked as defined in <a href="#masking">Section 5.3</a>.  </li>
<li>If any extensions (<a href="#extensions">Section 9</a>) have been negotiated for the WebSocket connection, additional considerations may apply as per the definition of those extensions.  </li>
<li>The frame(s) that have been formed MUST be transmitted over the underlying network connection.  </li>
</ol>

<p> </p>
<h1 id="rfc.section.6.2">
<a href="#rfc.section.6.2">6.2.</a> <a href="#rcv_data" id="rcv_data">Receiving Data</a>
</h1>
<p id="rfc.section.6.2.p.1">To receive WebSocket data, an endpoint listens on the underlying network connection. Incoming data MUST be parsed as WebSocket frames as defined in <a href="#baseframing">Section 5.2</a>.  If a control frame (<a href="#controlframes">Section 5.5</a>) is received, the frame MUST be handled as defined by <a href="#controlframes">Section 5.5</a>.  Upon receiving a data frame (<a href="#dataframes">Section 5.6</a>), the endpoint MUST note the /type/ of the data as defined by the Opcode (frame-opcode) from <a href="#baseframing">Section 5.2</a>. The <em>Application Data</em> from this frame is defined as the /data/ of the message. If the frame comprises an unfragmented message (<a href="#fragmentation">Section 5.4</a>), it is said that <em>A WebSocket Message Has Been Received</em> with type /type/ and data /data/. If the frame is part of a fragmented message, the <em>Application Data</em> of the subsequent data frames is concatenated to form the /data/. When the last fragment is received as indicated by the FIN bit (frame-fin), it is said that <em>A WebSocket Message Has Been Received</em> with data /data/ (comprised of the concatenation of the <em>Application Data</em> of the fragments) and type /type/ (noted from the first frame of the fragmented message).  Subsequent data frames MUST be interpreted as belonging to a new WebSocket Message.  </p>
<p id="rfc.section.6.2.p.2">Extensions (<a href="#extensions">Section 9</a>) MAY change the semantics of how data is read, specifically including what comprises a message boundary. Extensions, in addition to adding "Extension data" before the "Application data" in a payload, MAY also modify the "Application data" (such as by compressing it).  </p>
<p id="rfc.section.6.2.p.3">A server MUST remove masking for data frames received from a client as described in <a href="#masking">Section 5.3</a>.  </p>
<h1 id="rfc.section.7">
<a href="#rfc.section.7">7.</a> <a href="#closing_connection" id="closing_connection">Closing the connection</a>
</h1>
<h1 id="rfc.section.7.1">
<a href="#rfc.section.7.1">7.1.</a> Definitions</h1>
<h1 id="rfc.section.7.1.1">
<a href="#rfc.section.7.1.1">7.1.1.</a> <a href="#close_wsc" id="close_wsc">Close the WebSocket Connection</a>
</h1>
<p id="rfc.section.7.1.1.p.1">To <em>Close the WebSocket Connection</em>, an endpoint closes the underlying TCP connection. An endpoint SHOULD use a method that cleanly closes the TCP connection, as well as the TLS session, if applicable, discarding any trailing bytes that may be received. An endpoint MAY close the connection via any means available when necessary, such as when under attack.  </p>
<p id="rfc.section.7.1.1.p.2">The underlying TCP connection, in most normal cases, SHOULD be closed first by the server, so that it holds the TIME_WAIT state and not the client (as this would prevent it from re-opening the connection for 2 MSL, while there is no corresponding server impact as a TIME_WAIT connection is immediately reopened upon a new SYN with a higher seq number). In abnormal cases (such as not having received a TCP Close from the server after a reasonable amount of time) a client MAY initiate the TCP Close. As such, when a server is instructed to <em>Close the WebSocket Connection</em> it SHOULD initiate a TCP Close immediately, and when a client is instructed to do the same, it SHOULD wait for a TCP Close from the server.  </p>
<p id="rfc.section.7.1.1.p.3">As an example of how to obtain a clean closure in C using Berkeley sockets, one would call shutdown() with SHUT_WR on the socket, call recv() until obtaining a return value of 0 indicating that the peer has also performed an orderly shutdown, and finally calling close() on the socket.  </p>
<h1 id="rfc.section.7.1.2">
<a href="#rfc.section.7.1.2">7.1.2.</a> <a href="#start_closing" id="start_closing">Start the WebSocket Closing Handshake</a>
</h1>
<p id="rfc.section.7.1.2.p.1">To <em>Start the WebSocket Closing Handshake</em> with a status code (<a href="#status_codes">Section 7.4</a>) /code/ and an optional close reason (<a href="#close_reason">Section 7.1.6</a>) /reason/, an endpoint MUST send a Close control frame, as described in <a href="#closeframe">Section 5.5.1</a> whose status code is set to /code/ and whose close reason is set to /reason/.  Once an endpoint has both sent and received a Close control frame, that endpoint SHOULD <em>Close the WebSocket Connection</em> as defined in <a href="#close_wsc">Section 7.1.1</a>.  </p>
<h1 id="rfc.section.7.1.3">
<a href="#rfc.section.7.1.3">7.1.3.</a> The WebSocket Closing Handshake is Started</h1>
<p id="rfc.section.7.1.3.p.1">Upon either sending or receiving a Close control frame, it is said that <em>The WebSocket Closing Handshake is Started</em> and that the WebSocket connection is in the CLOSING state.  </p>
<h1 id="rfc.section.7.1.4">
<a href="#rfc.section.7.1.4">7.1.4.</a> <a href="#is_closed" id="is_closed">The WebSocket Connection is Closed</a>
</h1>
<p id="rfc.section.7.1.4.p.1">When the underlying TCP connection is closed, it is said that <em>The WebSocket Connection is Closed</em> and that the WebSocket connection is in the CLOSED state.  If the tcp connection was closed after the WebSocket closing handshake was completed, the WebSocket connection is said to have been closed <em>cleanly</em>.  </p>
<p id="rfc.section.7.1.4.p.2">If the WebSocket connection could not be established, it is also said that <em>The WebSocket Connection is Closed</em>, but not cleanly.  </p>
<h1 id="rfc.section.7.1.5">
<a href="#rfc.section.7.1.5">7.1.5.</a> <a href="#closecode" id="closecode">The WebSocket Connection Close Code</a>
</h1>
<p id="rfc.section.7.1.5.p.1">As defined in <a href="#closeframe">Section 5.5.1</a> and <a href="#status_codes">Section 7.4</a>, a Close control frame may contain a status code indicating a reason for closure. A closing of the WebSocket connection may be initiated by either endpoint, potentially simultaneously. <em>The WebSocket Connection Close Code</em> is defined as the status code (<a href="#status_codes">Section 7.4</a>) contained in the first Close control frame received by the application implementing this protocol.  If this Close control frame contains no status code, <em>The WebSocket Connection Close Code</em> is considered to be 1005. If <em>The WebSocket Connection is Closed</em> and no Close control frame was received by the endpoint (such as could occur if the underlying transport connection is lost), <em>The WebSocket Connection Close Code</em> is considered to be 1006.  </p>
<p id="rfc.section.7.1.5.p.2">NOTE: Two endpoints may not agree on the value of <em>The WebSocket Connection Close Code</em>.  As an example, if the remote endpoint sent a Close frame but the local application has not yet read the data containing the Close frame from its socket's receive buffer, and the local application independently decided to close the connection and send a Close frame, both endpoints will have sent and received a Close frame, and will not send further Close frames. Each endpoint will see the Connection Close Code sent by the other end as the <em>WebSocket Connection Close Code</em>.  As such, it is possible that the two endpoints may not agree on the value of <em>The WebSocket Connection Close Code</em> in the case that both endpoints <em>Start the WebSocket Closing Handshake</em> independently and at roughly the same time.  </p>
<h1 id="rfc.section.7.1.6">
<a href="#rfc.section.7.1.6">7.1.6.</a> <a href="#close_reason" id="close_reason">The WebSocket Connection Close Reason</a>
</h1>
<p id="rfc.section.7.1.6.p.1">As defined in <a href="#closeframe">Section 5.5.1</a> and <a href="#status_codes">Section 7.4</a>, a Close control frame may contain a status code indicating a reason for closure, followed by UTF-8 encoded data, the interpretation of said data being left to the endpoints and not defined by this protocol. A closing of the WebSocket connection may be initiated by either endpoint, potentially simultaneously. <em>The WebSocket Connection Close Reason</em> is defined as the UTF-8 encoded data following the status code (<a href="#status_codes">Section 7.4</a>) contained in the first Close control frame received by the application implementing this protocol.  If there is no such data in the Close control frame, <em>The WebSocket Connection Close Reason</em> is the empty string.</p>
<p id="rfc.section.7.1.6.p.2">NOTE: Following the same logic as noted in <a href="#closecode">Section 7.1.5</a>, two endpoints may not agree on <em>The WebSocket Connection Close Reason</em>.  </p>
<h1 id="rfc.section.7.1.7">
<a href="#rfc.section.7.1.7">7.1.7.</a> <a href="#fail_ws" id="fail_ws">Fail the WebSocket Connection</a>
</h1>
<p id="rfc.section.7.1.7.p.1">Certain algorithms and specifications require an endpoint to <em>Fail the WebSocket Connection</em>. To do so, the client MUST <em>Close the WebSocket Connection</em>, and MAY report the problem to the user (which would be especially useful for developers) in an appropriate manner. Similarly, to do so, the server MUST <em>Close the WebSocket Connection</em>, and SHOULD log the problem.  </p>
<p id="rfc.section.7.1.7.p.2">If <em>The WebSocket Connection is Established</em> prior to the point where the endpoint is required to <em>Fail the WebSocket Connection</em>, the endpoint SHOULD send a Close frame with an appropriate status code <a href="#status_codes">Section 7.4</a> before proceeding to <em>Close the WebSocket Connection</em>. An endpoint MAY omit sending a Close frame if it believes the other side is unlikely to be able to receive and process the close frame, due to the nature of the error that led to the WebSocket connection being failed in the first place. An endpoint MUST NOT continue to attempt to process data (including a responding Close frame) from the remote endpoint after being instructed to <em>Fail the WebSocket Connection</em>.  </p>
<p id="rfc.section.7.1.7.p.3">Except as indicated above or as specified by the application layer (e.g. a script using the WebSocket API), clients SHOULD NOT close the connection.  </p>
<h1 id="rfc.section.7.2">
<a href="#rfc.section.7.2">7.2.</a> Abnormal Closures</h1>
<h1 id="rfc.section.7.2.1">
<a href="#rfc.section.7.2.1">7.2.1.</a> Client-Initiated Closure</h1>
<p id="rfc.section.7.2.1.p.1">Certain algorithms, namely during the opening handshake, require the client to <em>Fail the WebSocket Connection</em>. To do so, the client MUST <em>Fail the WebSocket Connection</em> as defined in <a href="#fail_ws">Section 7.1.7</a>.  </p>
<p id="rfc.section.7.2.1.p.2">If at any point the underlying transport layer connection is unexpectedly lost, the client MUST <em>Fail the WebSocket Connection</em>.  </p>
<p id="rfc.section.7.2.1.p.3">Except as indicated above or as specified by the application layer (e.g. a script using the WebSocket API), clients SHOULD NOT close the connection.  </p>
<h1 id="rfc.section.7.2.2">
<a href="#rfc.section.7.2.2">7.2.2.</a> Server-Initiated Closure</h1>
<p id="rfc.section.7.2.2.p.1">Certain algorithms require or recommend that the server <em>Abort the WebSocket Connection</em> during the opening handshake. To do so, the server MUST simply <em>Close the WebSocket Connection</em> (<a href="#close_wsc">Section 7.1.1</a>).  </p>
<h1 id="rfc.section.7.2.3">
<a href="#rfc.section.7.2.3">7.2.3.</a> Recovering From Abnormal Closure</h1>
<p id="rfc.section.7.2.3.p.1">Abnormal closures may be caused by any number of reasons. Such closures could be the result of a transient error, in which case reconnecting may lead to a good connection and a resumption of normal operations. Such closures may also be the result of a nontransient problem, in which case if each deployed client experiences an abnormal closure and immediately and persistently tries to reconnect, the server may experience what amounts to a denial of service attack by a large number of clients trying to reconnect. The end result of such a scenario could be that the service is unable to recover, or recovery is made much more difficult, in any sort of timely manner.  </p>
<p id="rfc.section.7.2.3.p.2">To prevent this, clients SHOULD use some form of backoff when trying to reconnect after abnormal closures as described in this section.  </p>
<p id="rfc.section.7.2.3.p.3">The first reconnect attempt SHOULD be delayed by a random amount of time. The parameters by which this random delay is chosen are left to the client to decide; a value chosen randomly between 0 and 5 seconds is a reasonable initial delay though clients MAY choose a different interval from which to select a delay length based on implementation experience and particular application.  </p>
<p id="rfc.section.7.2.3.p.4">Should the first reconnect attempt fail, subsequent reconnect attempts SHOULD be delayed by increasingly longer amounts of time, using a method such as truncated binary exponential backoff.  </p>
<h1 id="rfc.section.7.3">
<a href="#rfc.section.7.3">7.3.</a> Normal Closure of Connections</h1>
<p id="rfc.section.7.3.p.1">Servers MAY close the WebSocket connection whenever desired. Clients SHOULD NOT close the WebSocket connection arbitrarily. In either case, an endpoint initiates a closure by following the procedures to <em>Start the WebSocket Closing Handshake</em> (<a href="#start_closing">Section 7.1.2</a>).  </p>
<h1 id="rfc.section.7.4">
<a href="#rfc.section.7.4">7.4.</a> <a href="#status_codes" id="status_codes">Status Codes</a>
</h1>
<p id="rfc.section.7.4.p.1">When closing an established connection (e.g. when sending a Close frame, after the opening handshake has completed), an endpoint MAY indicate a reason for closure. The interpretation of this reason by an endpoint, and the action an endpoint should take given this reason, are left undefined by this specification. This specification defines a set of pre-defined status codes, and specifies which ranges may be used by extensions, frameworks, and end applications. The status code and any associated textual message are optional components of a Close frame.  </p>
<h1 id="rfc.section.7.4.1">
<a href="#rfc.section.7.4.1">7.4.1.</a> <a href="#closestatus" id="closestatus">Defined Status Codes</a>
</h1>
<p id="rfc.section.7.4.1.p.1">Endpoints MAY use the following pre-defined status codes when sending a Close frame.  </p>

<dl>
<dt>1000</dt>
<dd style="margin-left: 8">
<br><br> 1000 indicates a normal closure, meaning whatever purpose the connection was established for has been fulfilled.  </dd>
<dt>1001</dt>
<dd style="margin-left: 8">
<br><br> 1001 indicates that an endpoint is "going away", such as a server going down, or a browser having navigated away from a page.  </dd>
<dt>1002</dt>
<dd style="margin-left: 8">
<br><br> 1002 indicates that an endpoint is terminating the connection due to a protocol error.  </dd>
<dt>1003</dt>
<dd style="margin-left: 8">
<br><br> 1003 indicates that an endpoint is terminating the connection because it has received a type of data it cannot accept (e.g.  an endpoint that understands only text data MAY send this if it receives a binary message).  </dd>
<dt>1004</dt>
<dd style="margin-left: 8">
<br><br> Reserved. The specific meaning might be defined in the future.  </dd>
<dt>1005</dt>
<dd style="margin-left: 8">
<br><br> 1005 is a reserved value and MUST NOT be set as a status code in a Close control frame by an endpoint. It is designated for use in applications expecting a status code to indicate that no status code was actually present.  </dd>
<dt>1006</dt>
<dd style="margin-left: 8">
<br><br> 1006 is a reserved value and MUST NOT be set as a status code in a Close control frame by an endpoint. It is designated for use in applications expecting a status code to indicate that the connection was closed abnormally, e.g. without sending or receiving a Close control frame.  </dd>
<dt>1007</dt>
<dd style="margin-left: 8">
<br><br> 1007 indicates that an endpoint is terminating the connection because it has received data within a message that was not consistent with the type of the message (e.g., non-UTF-8 <a href="#RFC3629">[RFC3629]</a> data within a text message).  </dd>
<dt>1008</dt>
<dd style="margin-left: 8">
<br><br> 1008 indicates that an endpoint is terminating the connection because it has received a message that violates its policy.  This is a generic status code that can be returned when there is no other more suitable status code (e.g. 1003 or 1009), or if there is a need to hide specific details about the policy.  </dd>
<dt>1009</dt>
<dd style="margin-left: 8">
<br><br> 1009 indicates that an endpoint is terminating the connection because it has received a message which is too big for it to process.  </dd>
<dt>1010</dt>
<dd style="margin-left: 8">
<br><br> 1010 indicates that an endpoint (client) is terminating the connection because it has expected the server to negotiate one or more extension, but the server didn't return them in the response message of the WebSocket handshake. The list of extensions which are needed SHOULD appear in the /reason/ part of the Close frame.  Note that this status code is not used by the server, because it can fail the WebSocket handshake instead.  </dd>
</dl>

<p> </p>
<h1 id="rfc.section.7.4.2">
<a href="#rfc.section.7.4.2">7.4.2.</a> Reserved Status Code Ranges</h1>
<p></p>

<dl>
<dt>0-999</dt>
<dd style="margin-left: 8">
<br><br> Status codes in the range 0-999 are not used.  </dd>
<dt>1000-2999</dt>
<dd style="margin-left: 8">
<br><br> Status codes in the range 1000-2999 are reserved for definition by this protocol, its future revisions, and extensions specified in a permanent and readily available public specification.  </dd>
<dt>3000-3999</dt>
<dd style="margin-left: 8">
<br><br> Status codes in the range 3000-3999 are reserved for use by libraries, frameworks and application. These status codes are registered directly with IANA.  The interpretation of these codes is undefined by this protocol.  </dd>
<dt>4000-4999</dt>
<dd style="margin-left: 8">
<br><br> Status codes in the range 4000-4999 are reserved for private use and thus can't be registered. Such codes can be used by prior agreements between WebSocket applications.  The interpretation of these codes is undefined by this protocol.  </dd>
</dl>

<p> </p>
<h1 id="rfc.section.8">
<a href="#rfc.section.8">8.</a> Error Handling</h1>
<h1 id="rfc.section.8.1">
<a href="#rfc.section.8.1">8.1.</a> <a href="#badutf8" id="badutf8">Handling Errors in UTF-8 Encoded Data</a>
</h1>
<p id="rfc.section.8.1.p.1">When an endpoint is to interpret a byte stream as UTF-8 but finds that the byte stream is not in fact a valid UTF-8 stream, that endpoint MUST <em>Fail the WebSocket Connection</em>.  This rule applies both during the opening handshake and during subsequent data exchange.  </p>
<h1 id="rfc.section.9">
<a href="#rfc.section.9">9.</a> <a href="#extensions" id="extensions">Extensions</a>
</h1>
<p id="rfc.section.9.p.1">WebSocket clients MAY request extensions to this specification, and WebSocket servers MAY accept some or all extensions requested by the client. A server MUST NOT respond with any extension not requested by the client. If extension parameters are included in negotiations between the client and the server, those parameters MUST be chosen in accordance with the specification of the extension to which the parameters apply.</p>
<h1 id="rfc.section.9.1">
<a href="#rfc.section.9.1">9.1.</a> <a href="#negotiation" id="negotiation">Negotiating Extensions</a>
</h1>
<p id="rfc.section.9.1.p.1">A client requests extensions by including a "Sec-WebSocket-Extensions" header field, which follows the normal rules for HTTP header fields (see <a href="#RFC2616">[RFC2616]</a> section 4.2) and the value of the header field is defined by the following ABNF <a href="#RFC2616">[RFC2616]</a>. Note that this section is using ABNF syntax/rules from <a href="#RFC2616">[RFC2616]</a>, including "implied *LWS rule". If a value is received by either the client or the server during negotiation that does not conform to the ABNF below, the recipient of such malformed data MUST immediately <em>Fail the WebSocket Connection</em>.  </p>
<div id="#rfc.figure.22"></div>
<pre>
      Sec-WebSocket-Extensions = extension-list
      extension-list = 1#extension
      extension = extension-token *( ";" extension-param )
      extension-token = registered-token
      registered-token = token
      extension-param = token [ "=" (token | quoted-string) ]
          ;When using the quoted-string syntax variant, the value
          ;after quoted-string unescaping MUST conform to the
          ;'token' ABNF.
          </pre>
<p id="rfc.section.9.1.p.2">Note that like other HTTP header fields, this header field MAY be split or combined across multiple lines. Ergo, the following are equivalent:</p>
<div id="#rfc.figure.23"></div>
<pre>
      Sec-WebSocket-Extensions: foo
      Sec-WebSocket-Extensions: bar; baz=2
          </pre>
<p id="rfc.section.9.1.p.3">is exactly equivalent to</p>
<div id="#rfc.figure.24"></div>
<pre>
      Sec-WebSocket-Extensions: foo, bar; baz=2
          </pre>
<p id="rfc.section.9.1.p.4">Any extension-token used MUST be a registered token (see <a href="#enr">Section 11.4</a>). The parameters supplied with any given extension MUST be defined for that extension. Note that the client is only offering to use any advertised extensions, and MUST NOT use them unless the server indicates that it wishes to use the extension.</p>
<p id="rfc.section.9.1.p.5">Note that the order of extensions is significant. Any interactions between multiple extensions MAY be defined in the documents defining the extensions. In the absence of such definition, the interpretation is that the header fields listed by the client in its request represent a preference of the header fields it wishes to use, with the first options listed being most preferable. The extensions listed by the server in response represent the extensions actually in use for the connection.  Should the extensions modify the data and/or framing, the order of operations on the data should be assumed to be the same as the order in which the extensions are listed in the server's response in the opening handshake.</p>
<p id="rfc.section.9.1.p.6">For example, if there are two extensions "foo" and "bar", if the header field |Sec-WebSocket-Extensions| sent by the server has the value "foo, bar" then operations on the data will be made as bar(foo(data)), be those changes to the data itself (such as compression) or changes to the framing that may "stack".</p>
<p id="rfc.section.9.1.p.7">Non-normative examples of acceptable extension header fields (note that long lines are folded for readability):</p>
<div id="#rfc.figure.25"></div>
<pre>
      Sec-WebSocket-Extensions: deflate-stream
      Sec-WebSocket-Extensions: mux; max-channels=4; flow-control,
       deflate-stream
      Sec-WebSocket-Extensions: private-extension
          </pre>
<p id="rfc.section.9.1.p.8">A server accepts one or more extensions by including a |Sec-WebSocket-Extensions| header field containing one or more extensions which were requested by the client. The interpretation of any extension parameters, and what constitutes a valid response by a server to a requested set of parameters by a client, will be defined by each such extension.</p>
<h1 id="rfc.section.9.2">
<a href="#rfc.section.9.2">9.2.</a> Known Extensions</h1>
<p id="rfc.section.9.2.p.1">Extensions provide a mechanism for implementations to opt-in to additional protocol features. This document doesn't define any extension but implementations MAY use extensions defined separately.</p>
<h1 id="rfc.section.10">
<a href="#rfc.section.10">10.</a> <a href="#securityconsiderations" id="securityconsiderations">Security Considerations</a>
</h1>
<p id="rfc.section.10.p.1">This section describes some security considerations applicable to the WebSocket protocol.  Specific security considerations are described in subsections of this section.</p>
<h1 id="rfc.section.10.1">
<a href="#rfc.section.10.1">10.1.</a> Non-Browser Clients</h1>
<p id="rfc.section.10.1.p.1">Many threats anticipated by the WebSocket protocol protect from malicious JavaScript running inside a trusted application such as a web browser, for example checking of the "Origin" header field (see below).  See <a href="#secmodel">Section 1.6</a> for additional details.  Such assumptions don't hold true in the case of a more capable client.  </p>
<p id="rfc.section.10.1.p.2">While this protocol is intended to be used by scripts in Web pages, it can also be used directly by hosts. Such hosts are acting on their own behalf, and can therefore send fake "Origin" header fields, misleading the server.  Servers should therefore be careful about assuming that they are talking directly to scripts from known origins, and must consider that they might be accessed in unexpected ways. In particular, a server should not trust that any input is valid.</p>
<p id="rfc.section.10.1.p.3">EXAMPLE: For example, if the server uses input as part of SQL queries, all input text should be escaped before being passed to the SQL server, lest the server be susceptible to SQL injection.</p>
<h1 id="rfc.section.10.2">
<a href="#rfc.section.10.2">10.2.</a> Origin Considerations</h1>
<p id="rfc.section.10.2.p.1">Servers that are not intended to process input from any Web page but only for certain sites SHOULD verify the "Origin" field is an origin they expect.  If the origin indicated is unacceptable to the server, then it SHOULD respond to the WebSocket handshake with a reply containing HTTP 403 Forbidden status code.  </p>
<p><br><br> </p>
<p id="rfc.section.10.2.p.3">The "Origin" header field protects from the attack cases when the untrusted party is typically the author of a JavaScript application that is executing in the context of the trusted client. The client itself can contact the server and via the mechanism of the "Origin" header field, determine whether to extend those communication privileges to the JavaScript application.  The intent is not to prevent non-browsers from establishing connections, but rather to ensure that trusted browsers under the control of potentially malicious JavaScript cannot fake a WebSocket handshake.  </p>
<h1 id="rfc.section.10.3">
<a href="#rfc.section.10.3">10.3.</a> <a href="#masking-reasons" id="masking-reasons">Attacks On Infrastructure (Masking)</a>
</h1>
<p id="rfc.section.10.3.p.1">In addition to endpoints being the target of attacks via WebSockets, other parts of web infrastructure, such as proxies, may be the subject of an attack.  </p>
<p id="rfc.section.10.3.p.2">As this protocol was being developed, an experiment was conducted to demonstrate a class of attacks on proxies that led to the poisoning of caching proxies deployed in the wild <a href="#TALKING">[TALKING]</a>.  The general form of the attack was to establish a connection to a server under the "attacker's" control, perform an UPGRADE on the HTTP connection similar to what the WebSocket protocol does to establish a connection, and to subsequently send data over that UPGRADEd connection that looked like a GET request for a specific known resource (which in an attack would likely be something like a widely deployed script for tracking hits, or a resource on an ad-serving network). The remote server would respond with something that looked like a response to the fake GET request, and this response would be cached by a nonzero percentage of deployed intermediaries, thus poisioning the cache. The net effect of this attack would be that if a user could be convinced to visit a website the attacker controlled, the attacker could potentially poison the cache for that user and other users behind the same cache and run malicious script on other origins, compromising the web security model.  </p>
<p id="rfc.section.10.3.p.3">To avoid such attacks on deployed intermediaries,  it is not sufficient to prefix application supplied data with framing that is not compliant HTTP, as it is not possible to exhaustively discover and test that each nonconformant intermediary does not skip such non HTTP framing and act incorrectly on the frame payload.  Thus the defence adopted is to mask all data from the client to the server, so that the remote script (attacker) does not have control over how the data being sent appears on the wire, and thus cannot construct a message that could be misinterpreted by an intermediary as an HTTP request.  </p>
<p id="rfc.section.10.3.p.4">Clients MUST choose a new masking key for each frame, using an algorithm that cannot be predicted by end applications that provide data.  For example, each masking could be drawn from a cryptographically strong random number generator.  If the same key is used, or a decipherable pattern exists for how the next key is chosen, the attacker can send a message that, when masked, could appear to be an HTTP request (by taking the message the attacker wishes to see on the wire, and masking it with the next masking key to be used, when the client applies the masking key it will effectively unmask the data.) </p>
<p id="rfc.section.10.3.p.5">It is also necessary that once the transmission of a frame from a client has begun, the payload (application supplied data) of that frame must not be capable of being modified by the application. Otherwise, an attacker could send a long frame where the initial data was a known value (such as all zeros), compute the masking key being used upon receipt of the first part of the data, and then modify the data that is yet to be sent in the frame to appear as an HTTP request when masked. (This is essentially the same problem described in the previous paragraph with using a known or predictable masking key.) If additional data is to be sent or data to be sent is somehow changed, that new or changed data must be sent in a new frame and thus with a new masking key. In short, once transmission of a frame begins, the contents must not be modifiable by the remote script (application).  </p>
<p id="rfc.section.10.3.p.6">The threat model being protected against is one in which the client sends data that appears to be a HTTP request. As such, the channel that needs to be masked is the data from the client to the server. The data from the server to the client can be made to look like a response, but to accomplish this request the client must also be able to forge a request. As such, it was not deemed necessary to mask data in both directions (the data from the server to the client is not masked).  </p>
<p id="rfc.section.10.3.p.7">Despite the protection provided by masking, non-compliant HTTP proxies will still be vulnerable to poisoning attacks of this type by clients and servers that do not apply masking.  </p>
<h1 id="rfc.section.10.4">
<a href="#rfc.section.10.4">10.4.</a> Implementation-Specific Limits</h1>
<p id="rfc.section.10.4.p.1">Implementations which have implementation- and/or platform-specific limitations regarding the frame size or total message size after reassembly from multiple frames MUST protect themselves against exceeding those limits.  (For example, a malicious endpoint can try to exhaust its peer's memory or mount a denial of service attack by sending either a single big frame (e.g. of size 2**60), or by sending a long stream of small frames which are a part of a fragmented message.) Such an implementation SHOULD impose limit on frame sizes and the total message size after reassembly from multiple frames.</p>
<h1 id="rfc.section.10.5">
<a href="#rfc.section.10.5">10.5.</a> WebSocket client authentication</h1>
<p id="rfc.section.10.5.p.1">This protocol doesn't prescribe any particular way that servers can authenticate clients during the WebSocket handshake. The WebSocket server can use any client authentication mechanism available to a generic HTTP server, such as Cookies, HTTP Authentication, or TLS authentication.  </p>
<h1 id="rfc.section.10.6">
<a href="#rfc.section.10.6">10.6.</a> Connection confidentiality and integrity</h1>
<p id="rfc.section.10.6.p.1">Communications confidentiality and integrity is provided by running the WebSocket protocol over TLS (wss URIs). WebSocket implementations MUST support TLS, and SHOULD employ it when communicating with their peers.</p>
<p id="rfc.section.10.6.p.2">For connections using TLS, the amount of benefit provided by TLS depends greatly on the strength of the algorithms negotiated during the TLS handshake. For example some TLS cipher mechanisms don't provide connection confidentiality. To achieve reasonable levels of protections, clients should use only Strong TLS algorithms. "Web Security Context: User Interface Guidelines" <a href="#W3C.REC-wsc-ui-20100812">[W3C.REC-wsc-ui-20100812]</a> discusses what constitutes Strong TLS algorithms.  <a href="#RFC5246">[RFC5246]</a> provides additional guidance in Appendix A.5 and Appendix D.3.  </p>
<h1 id="rfc.section.10.7">
<a href="#rfc.section.10.7">10.7.</a> Handling of invalid data</h1>
<p id="rfc.section.10.7.p.1">Incoming data MUST always be validated by both clients and servers.  If at any time an endpoint is faced with data that it does not understand, or that violates some criteria by which the endpoint determines safety of input, or when the endpoint sees an opening handshake that does not correspond to the values it is expecting (e.g. incorrect path or origin in the client request), the endpoint MAY drop the TCP connection. If the invalid data received after a successful WebSocket handshake, the endpoint SHOULD send a Close frame with an appropriate status code <a href="#status_codes">Section 7.4</a> before proceeding to <em>Close the WebSocket Connection</em>.  Use of a Close frame with an appropriate status code can help in diagnosing the problem.  If the invalid data is sent during the WebSocket handshake the server SHOULD return an appropriate HTTP <a href="#RFC2616">[RFC2616]</a> status code.  </p>
<p><br><br> </p>
<p id="rfc.section.10.7.p.3">A common class of security problems arise when sending text data using using the wrong encoding. This protocol specifies that messages with a Text data type (as opposed to Binary or other types) contain UTF-8 encoded data. Although the length is still indicated and applications implementing this protocol should use the length to determine where the frame actually ends, sending data in an improper encoding may still break assumptions applications built on top of this protocol may make, leading from anything to misinterpretation of data to loss of data to potential security bugs.</p>
<h1 id="rfc.section.10.8">
<a href="#rfc.section.10.8">10.8.</a> Use of SHA-1 by the WebSocket handshake</h1>
<p id="rfc.section.10.8.p.1">The WebSocket handshake described in this document doesn't depend on any security properties of SHA-1, such as collision resistance or resistance to the second pre-image attack (as described in <a href="#RFC4270">[RFC4270]</a>).  </p>
<h1 id="rfc.section.11">
<a href="#rfc.section.11">11.</a> IANA Considerations</h1>
<h1 id="rfc.section.11.1">
<a href="#rfc.section.11.1">11.1.</a> Registration of new URI Schemes</h1>
<h1 id="rfc.section.11.1.1">
<a href="#rfc.section.11.1.1">11.1.1.</a> <a href="#wsdef" id="wsdef">Registration of "ws" Scheme</a>
</h1>
<div id="#rfc.figure.26"></div>
<pre>        "ws:" "//" authority path-abempty [ "?" query ]</pre>
<p id="rfc.section.11.1.1.p.1">A |ws| URI identifies a WebSocket server and resource name.  </p>

<dl>
<dt>URI scheme name.</dt>
<dd style="margin-left: 8">
<br>ws </dd>
<dt>Status.</dt>
<dd style="margin-left: 8">
<br>Permanent.  </dd>
<dt>URI scheme syntax.</dt>
<dd style="margin-left: 8">
<br>In ABNF <a href="#RFC5234">[RFC5234]</a> terms using the terminals from the URI specifications: <a href="#RFC5234">[RFC5234]</a> <a href="#RFC3986">[RFC3986]</a><br><br><br><br> The &lt;path-abempty&gt; and &lt;query&gt; <a href="#RFC3986">[RFC3986]</a> components form the resource name sent to the server to identify the kind of service desired. Other components have the meanings described in RFC3986.  </dd>
<dt>URI scheme semantics.</dt>
<dd style="margin-left: 8">
<br>The only operation for this scheme is to open a connection using the WebSocket protocol.  </dd>
<dt>Encoding considerations.</dt>
<dd style="margin-left: 8">
<br>Characters in the host component that are excluded by the syntax defined above MUST be converted from Unicode to ASCII as specified in <a href="#RFC3987">[RFC3987]</a> or its replacement. For the purposes of scheme-based normalization IDN forms of the host component and their conversions to punycode are considered equivalent (see Section 5.3.3 of <a href="#RFC3987">[RFC3987]</a>).  <br><br> Characters in other components that are excluded by the syntax defined above MUST be converted from Unicode to ASCII by first encoding the characters as UTF-8 and then replacing the corresponding bytes using their percent-encoded form as defined in the URI and IRI specifications. <a href="#RFC3986">[RFC3986]</a> <a href="#RFC3987">[RFC3987]</a> </dd>
<dt>Applications/protocols that use this URI scheme name.</dt>
<dd style="margin-left: 8">
<br>WebSocket protocol.  </dd>
<dt>Interoperability considerations.</dt>
<dd style="margin-left: 8">
<br>Use of WebSocket requires use of HTTP version 1.1 or higher.  </dd>
<dt>Security considerations.</dt>
<dd style="margin-left: 8">
<br>See "Security considerations" section above.  </dd>
<dt>Contact.</dt>
<dd style="margin-left: 8">
<br>HYBI WG &lt;hybi@ietf.org&gt; </dd>
<dt>Author/Change controller.</dt>
<dd style="margin-left: 8">
<br>IETF &lt;iesg@ietf.org&gt; </dd>
<dt>References.</dt>
<dd style="margin-left: 8">
<br>RFC XXXX </dd>
</dl>

<p> </p>
<h1 id="rfc.section.11.1.2">
<a href="#rfc.section.11.1.2">11.1.2.</a> <a href="#wssdef" id="wssdef">Registration of "wss" Scheme</a>
</h1>
<div id="#rfc.figure.27"></div>
<pre>        "wss:" "//" authority path-abempty [ "?" query ]</pre>
<p id="rfc.section.11.1.2.p.1">A |wss| URI identifies a WebSocket server and resource name, and indicates that traffic over that connection is to be protected via TLS (including standard benefits of TLS such as data confidentiality and integrity, and endpoint authentication).  </p>

<dl>
<dt>URI scheme name.</dt>
<dd style="margin-left: 8">
<br>wss </dd>
<dt>Status.</dt>
<dd style="margin-left: 8">
<br>Permanent.  </dd>
<dt>URI scheme syntax.</dt>
<dd style="margin-left: 8">
<br>In ABNF <a href="#RFC5234">[RFC5234]</a> terms using the terminals from the URI specifications: <a href="#RFC5234">[RFC5234]</a> <a href="#RFC3986">[RFC3986]</a><br><br><br><br> The &lt;path-abempty&gt; and &lt;query&gt; components form the resource name sent to the server to identify the kind of service desired. Other components have the meanings described in RFC3986.  </dd>
<dt>URI scheme semantics.</dt>
<dd style="margin-left: 8">
<br>The only operation for this scheme is to open a connection using the WebSocket protocol, encrypted using TLS.  </dd>
<dt>Encoding considerations.</dt>
<dd style="margin-left: 8">
<br>Characters in the host component that are excluded by the syntax defined above MUST be converted from Unicode to ASCII as specified in <a href="#RFC3987">[RFC3987]</a> or its replacement. For the purposes of scheme-based normalization IDN forms of the host component and their conversions to punycode are considered equivalent (see Section 5.3.3 of <a href="#RFC3987">[RFC3987]</a>).  <br><br> Characters in other components that are excluded by the syntax defined above MUST be converted from Unicode to ASCII by first encoding the characters as UTF-8 and then replacing the corresponding bytes using their percent-encoded form as defined in the URI and IRI specification. <a href="#RFC3986">[RFC3986]</a> <a href="#RFC3987">[RFC3987]</a> </dd>
<dt>Applications/protocols that use this URI scheme name.</dt>
<dd style="margin-left: 8">
<br>WebSocket protocol over TLS.  </dd>
<dt>Interoperability considerations.</dt>
<dd style="margin-left: 8">
<br>Use of WebSocket requires use of HTTP version 1.1 or higher.  </dd>
<dt>Security considerations.</dt>
<dd style="margin-left: 8">
<br>See "Security considerations" section above.  </dd>
<dt>Contact.</dt>
<dd style="margin-left: 8">
<br>HYBI WG &lt;hybi@ietf.org&gt; </dd>
<dt>Author/Change controller.</dt>
<dd style="margin-left: 8">
<br>IETF &lt;iesg@ietf.org&gt; </dd>
<dt>References.</dt>
<dd style="margin-left: 8">
<br>RFC XXXX </dd>
</dl>

<p> </p>
<h1 id="rfc.section.11.2">
<a href="#rfc.section.11.2">11.2.</a> Registration of the "WebSocket" HTTP Upgrade Keyword</h1>
<p id="rfc.section.11.2.p.1">This section defines a keyword for registration in the "HTTP Upgrade Tokens" registry as per RFC 2817 <a href="#RFC2817">[RFC2817]</a>.  </p>

<dl>
<dt>Name of token.</dt>
<dd style="margin-left: 8">
<br>WebSocket </dd>
<dt>Author/Change controller.</dt>
<dd style="margin-left: 8">
<br>IETF &lt;iesg@ietf.org&gt; </dd>
<dt>Contact.</dt>
<dd style="margin-left: 8">
<br>HYBI &lt;hybi@ietf.org&gt; </dd>
<dt>References.</dt>
<dd style="margin-left: 8">
<br>RFC XXXX </dd>
</dl>

<p> </p>
<h1 id="rfc.section.11.3">
<a href="#rfc.section.11.3">11.3.</a> Registration of new HTTP Header Fields</h1>
<h1 id="rfc.section.11.3.1">
<a href="#rfc.section.11.3.1">11.3.1.</a> Sec-WebSocket-Key</h1>
<p id="rfc.section.11.3.1.p.1">This section describes a header field for registration in the Permanent Message Header Field Registry. <a href="#RFC3864">[RFC3864]</a> </p>
<p></p>

<dl>
<dt>Header field name</dt>
<dd style="margin-left: 8">
<br>Sec-WebSocket-Key </dd>
<dt>Applicable protocol</dt>
<dd style="margin-left: 8">
<br>http </dd>
<dt>Status</dt>
<dd style="margin-left: 8">
<br>standard </dd>
<dt>Author/Change controller</dt>
<dd style="margin-left: 8">
<br>IETF </dd>
<dt>Specification document(s)</dt>
<dd style="margin-left: 8">
<br>RFC XXXX </dd>
<dt>Related information</dt>
<dd style="margin-left: 8">
<br>This header field is only used for WebSocket opening handshake.  </dd>
</dl>

<p> </p>
<p id="rfc.section.11.3.1.p.3">The |Sec-WebSocket-Key| header field is used in the WebSocket opening handshake.  It is sent from the client to the server to provide part of the information used by the server to prove that it received a valid WebSocket opening handshake.  This helps ensure that the server does not accept connections from non-WebSocket clients (e.g. HTTP clients) that are being abused to send data to unsuspecting WebSocket servers.</p>
<p id="rfc.section.11.3.1.p.4">The |Sec-WebSocket-Key| header field MUST NOT appear more than once in an HTTP request.</p>
<h1 id="rfc.section.11.3.2">
<a href="#rfc.section.11.3.2">11.3.2.</a> <a href="#swe" id="swe">Sec-WebSocket-Extensions</a>
</h1>
<p id="rfc.section.11.3.2.p.1">This section describes a header field for registration in the Permanent Message Header Field Registry. <a href="#RFC3864">[RFC3864]</a> </p>
<p></p>

<dl>
<dt>Header field name</dt>
<dd style="margin-left: 8">
<br>Sec-WebSocket-Extensions </dd>
<dt>Applicable protocol</dt>
<dd style="margin-left: 8">
<br>http </dd>
<dt>Status</dt>
<dd style="margin-left: 8">
<br>standard </dd>
<dt>Author/Change controller</dt>
<dd style="margin-left: 8">
<br>IETF </dd>
<dt>Specification document(s)</dt>
<dd style="margin-left: 8">
<br>RFC XXXX </dd>
<dt>Related information</dt>
<dd style="margin-left: 8">
<br>This header field is only used for WebSocket opening handshake.  </dd>
</dl>

<p> </p>
<p id="rfc.section.11.3.2.p.3">The |Sec-WebSocket-Extensions| header field is used in the WebSocket opening handshake.  It is initially sent from the client to the server, and then subsequently sent from the server to the client, to agree on a set of protocol-level extensions to use for the duration of the connection.</p>
<p id="rfc.section.11.3.2.p.4">The |Sec-WebSocket-Extensions| header field MAY appear multiple times in an HTTP request (which is logically the same as a single |Sec-WebSocket-Extensions| header field that contains all values.  However the |Sec-WebSocket-Extensions| header field MUST NOT appear more than once in an HTTP response.</p>
<h1 id="rfc.section.11.3.3">
<a href="#rfc.section.11.3.3">11.3.3.</a> Sec-WebSocket-Accept</h1>
<p id="rfc.section.11.3.3.p.1">This section describes a header field for registration in the Permanent Message Header Field Registry. <a href="#RFC3864">[RFC3864]</a> </p>
<p></p>

<dl>
<dt>Header field name</dt>
<dd style="margin-left: 8">
<br>Sec-WebSocket-Accept </dd>
<dt>Applicable protocol</dt>
<dd style="margin-left: 8">
<br>http </dd>
<dt>Status</dt>
<dd style="margin-left: 8">
<br>standard </dd>
<dt>Author/Change controller</dt>
<dd style="margin-left: 8">
<br>IETF </dd>
<dt>Specification document(s)</dt>
<dd style="margin-left: 8">
<br>RFC XXXX </dd>
<dt>Related information</dt>
<dd style="margin-left: 8">
<br>This header field is only used for WebSocket opening handshake.  </dd>
</dl>

<p> </p>
<p id="rfc.section.11.3.3.p.3">The |Sec-WebSocket-Accept| header field is used in the WebSocket opening handshake.  It is sent from the server to the client to confirm that the server is willing to initiate the WebSocket connection.</p>
<p id="rfc.section.11.3.3.p.4">The |Sec-WebSocket-Accept| header MUST NOT appear more than once in an HTTP response.</p>
<h1 id="rfc.section.11.3.4">
<a href="#rfc.section.11.3.4">11.3.4.</a> <a href="#swp" id="swp">Sec-WebSocket-Protocol</a>
</h1>
<p id="rfc.section.11.3.4.p.1">This section describes a header field for registration in the Permanent Message Header Field Registry. <a href="#RFC3864">[RFC3864]</a> </p>
<p></p>

<dl>
<dt>Header field name</dt>
<dd style="margin-left: 8">
<br>Sec-WebSocket-Protocol </dd>
<dt>Applicable protocol</dt>
<dd style="margin-left: 8">
<br>http </dd>
<dt>Status</dt>
<dd style="margin-left: 8">
<br>standard </dd>
<dt>Author/Change controller</dt>
<dd style="margin-left: 8">
<br>IETF </dd>
<dt>Specification document(s)</dt>
<dd style="margin-left: 8">
<br>RFC XXXX </dd>
<dt>Related information</dt>
<dd style="margin-left: 8">
<br>This header field is only used for WebSocket opening handshake.  </dd>
</dl>

<p> </p>
<p id="rfc.section.11.3.4.p.3">The |Sec-WebSocket-Protocol| header field is used in the WebSocket opening handshake.  It is sent from the client to the server and back from the server to the client to confirm the subprotocol of the connection. This enables scripts to both select a subprotocol and be sure that the server agreed to serve that subprotocol.</p>
<p id="rfc.section.11.3.4.p.4">The |Sec-WebSocket-Protocol| header field MAY appear multiple times in an HTTP request (which is logically the same as a single |Sec-WebSocket-Protocol| header field that contains all values.  However the |Sec-WebSocket-Protocol| header field MUST NOT appear more than once in an HTTP response.</p>
<h1 id="rfc.section.11.3.5">
<a href="#rfc.section.11.3.5">11.3.5.</a> Sec-WebSocket-Version</h1>
<p id="rfc.section.11.3.5.p.1">This section describes a header field for registration in the Permanent Message Header Field Registry <a href="#RFC3864">[RFC3864]</a>.  </p>
<p></p>

<dl>
<dt>Header field name</dt>
<dd style="margin-left: 8">
<br>Sec-WebSocket-Version </dd>
<dt>Applicable protocol</dt>
<dd style="margin-left: 8">
<br>http </dd>
<dt>Status</dt>
<dd style="margin-left: 8">
<br>standard </dd>
<dt>Author/Change controller</dt>
<dd style="margin-left: 8">
<br>IETF </dd>
<dt>Specification document(s)</dt>
<dd style="margin-left: 8">
<br>RFC XXXX </dd>
<dt>Related information</dt>
<dd style="margin-left: 8">
<br>This header field is only used for WebSocket opening handshake.  </dd>
</dl>

<p> </p>
<p id="rfc.section.11.3.5.p.3">The |Sec-WebSocket-Version| header field is used in the WebSocket opening handshake.  It is sent from the client to the server to indicate the protocol version of the connection. This enables servers to correctly interpret the opening handshake and subsequent data being sent from the data, and close the connection if the server cannot interpret that data in a safe manner.  The |Sec-WebSocket-Version| header field is also sent from the server to the client on WebSocket handshake error, when the version received from the client does not match a version understood by the server. In such a case the header field includes the protocol version(s) supported by the server.  </p>
<p id="rfc.section.11.3.5.p.4">Note that there is no expectation that higher version numbers are necessarily backward compatible with lower version numbers.  </p>
<p id="rfc.section.11.3.5.p.5">The |Sec-WebSocket-Version| header field MAY appear multiple times in an HTTP response (which is logically the same as a single |Sec-WebSocket-Version| header field that contains all values.  However the |Sec-WebSocket-Version| header field MUST NOT appear more than once in an HTTP request.</p>
<h1 id="rfc.section.11.4">
<a href="#rfc.section.11.4">11.4.</a> <a href="#enr" id="enr">WebSocket Extension Name Registry</a>
</h1>
<p id="rfc.section.11.4.p.1">This specification requests the creation of a new IANA registry for WebSocket Extension names to be used with the WebSocket protocol in accordance with the principles set out in RFC 5226 <a href="#RFC5226">[RFC5226]</a>.  </p>
<p id="rfc.section.11.4.p.2">As part of this registry IANA will maintain the following information: </p>

<dl>
<dt>Extension Identifier</dt>
<dd style="margin-left: 8">
<br>The identifier of the extension, as will be used in the Sec-WebSocket-Extension header field registered in <a href="#swe">Section 11.3.2</a> of this specification. The value must conform to the requirements for an extension-token as defined in <a href="#negotiation">Section 9.1</a> of this specification.  </dd>
<dt>Extension Common Name</dt>
<dd style="margin-left: 8">
<br>The name of the extension, as the extension is generally referred to.  </dd>
<dt>Extension Definition</dt>
<dd style="margin-left: 8">
<br>A reference to the document in which the extension being used with the WebSocket protocol is defined.  </dd>
<dt>Known Incompatible Extensions</dt>
<dd style="margin-left: 8">
<br>A list of extension identifiers with which this extension is known to be incompatible.  </dd>
</dl>

<p> </p>
<p id="rfc.section.11.4.p.3">WebSocket Extension names are to be subject to "First Come First Served" IANA registration policy <a href="#RFC5226">[RFC5226]</a>.  </p>
<p id="rfc.section.11.4.p.4">There are no initial values in this registry.  </p>
<h1 id="rfc.section.11.5">
<a href="#rfc.section.11.5">11.5.</a> <a href="#spr" id="spr">WebSocket Subprotocol Name Registry</a>
</h1>
<p id="rfc.section.11.5.p.1">This specification requests the creation of a new IANA registry for WebSocket Subprotocol names to be used with the WebSocket protocol in accordance with the principles set out in RFC 5226 <a href="#RFC5226">[RFC5226]</a>.  </p>
<p id="rfc.section.11.5.p.2">As part of this registry IANA will maintain the following information: </p>

<dl>
<dt>Subprotocol Identifier</dt>
<dd style="margin-left: 8">
<br>The identifier of the subprotocol, as will be used in the Sec-WebSocket-Protocol header field registered in <a href="#swp">Section 11.3.4</a> of this specification. The value must conform to the requirements given in <a href="#swp-defined">[swp-defined]</a> of <a href="#clienths">Section 4.1</a> of this specification, namely the value must be a token as defined by RFC 2616 <a href="#RFC2616">[RFC2616]</a>.  </dd>
<dt>Subprotocol Common Name</dt>
<dd style="margin-left: 8">
<br>The name of the subprotocol, as the subprotocol is generally referred to.  </dd>
<dt>Subprotocol Definition</dt>
<dd style="margin-left: 8">
<br>A reference to the document in which the subprotocol being used with the WebSocket protocol is defined.  </dd>
</dl>

<p> </p>
<p id="rfc.section.11.5.p.3">WebSocket Subprotocol names are to be subject to "First Come First Served" IANA registration policy <a href="#RFC5226">[RFC5226]</a>.  </p>
<h1 id="rfc.section.11.6">
<a href="#rfc.section.11.6">11.6.</a> WebSocket Version Number Registry</h1>
<p id="rfc.section.11.6.p.1">This specification requests the creation of a new IANA registry for WebSocket Version Numbers to be used with the WebSocket protocol in accordance with the principles set out in RFC 5226 <a href="#RFC5226">[RFC5226]</a>.  </p>
<p id="rfc.section.11.6.p.2">As part of this registry IANA will maintain the following information: </p>

<dl>
<dt>Version Number</dt>
<dd style="margin-left: 8">
<br>The version number to be used in the Sec-WebSocket-Version as specified in <a href="#clienths">Section 4.1</a> of this specification. The value must be a non negative integer in the range between 0 and 255 (inclusive).  </dd>
<dt>Reference</dt>
<dd style="margin-left: 8">
<br>The RFC requesting a new version number.  </dd>
</dl>

<p> </p>
<p id="rfc.section.11.6.p.3">WebSocket Version Numbers are to be subject to "IETF Review" IANA registration policy <a href="#RFC5226">[RFC5226]</a>.  In order to improve interoperability with intermediate versions published in Internet Drafts, version numbers associated with such drafts might be registered in this registry. Note that "IETF Review" applies to registrations corresponding to Internet Drafts.  </p>
<div id="#rfc.figure.28"></div>
<pre>
   Version Number  | Reference
 -+----------------+-----------------------------------------+-
  | 0              + draft-ietf-hybi-thewebsocketprotocol-00 |
 -+----------------+-----------------------------------------+-
  | 1              + draft-ietf-hybi-thewebsocketprotocol-01 |
 -+----------------+-----------------------------------------+-
  | 2              + draft-ietf-hybi-thewebsocketprotocol-02 |
 -+----------------+-----------------------------------------+-
  | 3              + draft-ietf-hybi-thewebsocketprotocol-03 |
 -+----------------+-----------------------------------------+-
  | 4              + draft-ietf-hybi-thewebsocketprotocol-04 |
 -+----------------+-----------------------------------------+-
  | 5              + draft-ietf-hybi-thewebsocketprotocol-05 |
 -+----------------+-----------------------------------------+-
  | 6              + draft-ietf-hybi-thewebsocketprotocol-06 |
 -+----------------+-----------------------------------------+-
  | 7              + draft-ietf-hybi-thewebsocketprotocol-07 |
 -+----------------+-----------------------------------------+-
  | 8              + draft-ietf-hybi-thewebsocketprotocol-08 |
 -+----------------+-----------------------------------------+-
  | 9              +                Reserved                 |
 -+----------------+-----------------------------------------+-
  | 10             +                Reserved                 |
 -+----------------+-----------------------------------------+-
  | 11             +                Reserved                 |
 -+----------------+-----------------------------------------+-
  | 12             +                Reserved                 |
 -+----------------+-----------------------------------------+-
  | 13             +   RFCXXXX (RFC Editor: please update)   |
 -+----------------+-----------------------------------------+-
</pre>
<p id="rfc.section.11.6.p.4">IANA is asked to add initial values to the registry, with suggested numerical values as these have been used in past versions of this protocol.  </p>
<h1 id="rfc.section.11.7">
<a href="#rfc.section.11.7">11.7.</a> WebSocket Close Code Number Registry</h1>
<p id="rfc.section.11.7.p.1">This specification requests the creation of a new IANA registry for WebSocket Connection Close Code Numbers in accordance with the principles set out in RFC 5226 <a href="#RFC5226">[RFC5226]</a>.  </p>
<p id="rfc.section.11.7.p.2">As part of this registry IANA will maintain the following information: </p>

<dl>
<dt>Status Code</dt>
<dd style="margin-left: 8">
<br>The Status Code which denotes a reason for a WebSocket connection closure as per <a href="#status_codes">Section 7.4</a> of this document. The status code is an integer number between 1000 and 4999 (inclusive).  </dd>
<dt>Meaning</dt>
<dd style="margin-left: 8">
<br>The meaning of the status code.  Each status code has to have a unique meaning.  </dd>
<dt>Contact</dt>
<dd style="margin-left: 8">
<br>A contact for the entity reserving the status code.  </dd>
<dt>Reference</dt>
<dd style="margin-left: 8">
<br>The stable document requesting the status codes and defining their meaning. This is required for status codes in the range 1000-2999, and recommended for status codes in the range 3000-3999.  </dd>
</dl>

<p> </p>
<p id="rfc.section.11.7.p.3">WebSocket Close Code Numbers are to be subject to different registration requirements depending on their range. Unless otherwise specified, requests are subject to "Standards Action" IANA registration policy <a href="#RFC5226">[RFC5226]</a>. Requests for status codes for use by this protocol, its subsequent versions or extensions are subject to any one of "Standards Action", "Specification Required" (which implies "Designated Expert") or "IESG Review" IANA registration policies and should be granted status codes in the range 1000-2999. Requests for status codes for use by libraries, frameworks and applications are subject to "First Come First Served" IANA registration policy and should be granted in the range 3000-3999.  The range of status codes from 4000-4999 is designated for Private Use.  Requests should indicate whether they are requesting status codes for use by the WebSocket protocol (or a future version of the protocol) or by extensions, or by libraries/frameworks/applications.  </p>
<div id="#rfc.figure.29"></div>
<pre>
  |Status Code | Meaning         | Contact       | Reference |
 -+------------+-----------------+---------------+-----------|
  | 1000       | Normal Closure  | hybi@ietf.org | RFC XXXX  |
 -+------------+-----------------+---------------+-----------|
  | 1001       | Going Away      | hybi@ietf.org | RFC XXXX  |
 -+------------+-----------------+---------------+-----------|
  | 1002       | Protocol error  | hybi@ietf.org | RFC XXXX  |
 -+------------+-----------------+---------------+-----------|
  | 1003       | Unsupported Data| hybi@ietf.org | RFC XXXX  |
 -+------------+-----------------+---------------+-----------|
  | 1004       | ---Reserved---- | hybi@ietf.org | RFC XXXX  |
 -+------------+-----------------+---------------+-----------|
  | 1005       | No Status Rcvd  | hybi@ietf.org | RFC XXXX  |
 -+------------+-----------------+---------------+-----------|
  | 1006       | Abnormal Closure| hybi@ietf.org | RFC XXXX  |
 -+------------+-----------------+---------------+-----------|
  | 1007       | Invalid frame   | hybi@ietf.org | RFC XXXX  |
  |            | payload data    |               |           |
 -+------------+-----------------+---------------+-----------|
  | 1008       | Policy Violation| hybi@ietf.org | RFC XXXX  |
 -+------------+-----------------+---------------+-----------|
  | 1009       | Message Too Big | hybi@ietf.org | RFC XXXX  |
 -+------------+-----------------+---------------+-----------|
  | 1010       | Mandatory Ext.  | hybi@ietf.org | RFC XXXX  |
 -+------------+-----------------+---------------+-----------|
</pre>
<p id="rfc.section.11.7.p.4">IANA is asked to add initial values to the registry, with suggested numerical values as these have been used in past versions of this protocol.  </p>
<h1 id="rfc.section.11.8">
<a href="#rfc.section.11.8">11.8.</a> WebSocket Opcode Registry</h1>
<p id="rfc.section.11.8.p.1">This specification requests the creation of a new IANA registry for WebSocket Opcodes in accordance with the principles set out in RFC 5226 <a href="#RFC5226">[RFC5226]</a>.  </p>
<p id="rfc.section.11.8.p.2">As part of this registry IANA will maintain the following information: </p>

<dl>
<dt>Opcode</dt>
<dd style="margin-left: 8">
<br>The opcode denotes the frame type of the WebSocket frame, as defined in <a href="#baseframing">Section 5.2</a>.  The status code is an integer number between 0 and 15, inclusive.  </dd>
<dt>Meaning</dt>
<dd style="margin-left: 8">
<br>The meaning of the opcode code.  </dd>
<dt>Reference</dt>
<dd style="margin-left: 8">
<br>The specification requesting the opcode.  </dd>
</dl>

<p> </p>
<p id="rfc.section.11.8.p.3">WebSocket Opcode numbers are subject to "Standards Action" IANA registration policy <a href="#RFC5226">[RFC5226]</a>.  </p>
<div id="#rfc.figure.30"></div>
<pre>
  |Opcode  | Meaning                             | Reference |
 -+--------+-------------------------------------+-----------|
  | 0      | Continuation Frame                  | RFC XXXX  |
 -+--------+-------------------------------------+-----------|
  | 1      | Text Frame                          | RFC XXXX  |
 -+--------+-------------------------------------+-----------|
  | 2      | Binary Frame                        | RFC XXXX  |
 -+--------+-------------------------------------+-----------|
  | 8      | Connection Close Frame              | RFC XXXX  |
 -+--------+-------------------------------------+-----------|
  | 9      | Ping Frame                          | RFC XXXX  |
 -+--------+-------------------------------------+-----------|
  | 10     | Pong Frame                          | RFC XXXX  |
 -+--------+-------------------------------------+-----------|
</pre>
<p id="rfc.section.11.8.p.4">IANA is asked to add initial values to the registry, with suggested numerical values as these have been used in past versions of this protocol.  </p>
<h1 id="rfc.section.11.9">
<a href="#rfc.section.11.9">11.9.</a> WebSocket Framing Header Bits Registry</h1>
<p id="rfc.section.11.9.p.1">This specification requests the creation of a new IANA registry for WebSocket Framing Header Bits in accordance with the principles set out in RFC 5226 <a href="#RFC5226">[RFC5226]</a>. This registry controls assignment of the bits marked RSV1, RSV2, and RSV3 in <a href="#baseframing">Section 5.2</a>.  </p>
<p id="rfc.section.11.9.p.2">These bits are reserved for future versions or extensions of this specification.</p>
<p id="rfc.section.11.9.p.3">WebSocket Framing Header Bits assignments are subject to "Standards Action" IANA registration policy <a href="#RFC5226">[RFC5226]</a>.  </p>
<h1 id="rfc.section.12">
<a href="#rfc.section.12">12.</a> <a href="#otherspecs" id="otherspecs">Using the WebSocket protocol from Other Specifications</a>
</h1>
<p id="rfc.section.12.p.1">The WebSocket protocol is intended to be used by another specification to provide a generic mechanism for dynamic author-defined content, e.g. in a specification defining a scripted API.</p>
<p id="rfc.section.12.p.2">Such a specification first needs to <em>Establish a WebSocket Connection</em>, providing that algorithm with: </p>

<ul>
<li>The destination, consisting of a /host/ and a /port/.</li>
<li>A /resource name/, which allows for multiple services to be identified at one host and port.</li>
<li>A /secure/ flag, which is true if the connection is to be encrypted, and false otherwise.</li>
<li>An ASCII serialization of an origin that is being made responsible for the connection. <a href="#I-D.ietf-websec-origin">[I-D.ietf-websec-origin]</a> </li>
<li>Optionally a string identifying a protocol that is to be layered over the WebSocket connection.</li>
</ul>

<p> </p>
<p id="rfc.section.12.p.3">The /host/, /port/, /resource name/, and /secure/ flag are usually obtained from a URI using the steps to parse a WebSocket URI's components. These steps fail if the URI does not specify a WebSocket.</p>
<p id="rfc.section.12.p.4">If at any time the connection is to be closed, then the specification needs to use the <em>Close the WebSocket Connection</em> algorithm (<a href="#close_wsc">Section 7.1.1</a>).</p>
<p><a href="#is_closed">Section 7.1.4</a> defines when <em>The WebSocket Connection is Closed</em>.</p>
<p id="rfc.section.12.p.6">While a connection is open, the specification will need to handle the cases when <em>A WebSocket Message Has Been Received</em> (<a href="#rcv_data">Section 6.2</a>).</p>
<p id="rfc.section.12.p.7">To send some data /data/ to an open connection, the specification needs to <em>Send a WebSocket Message</em> (<a href="#send_data">Section 6.1</a>).</p>
<h1 id="rfc.section.13">
<a href="#rfc.section.13">13.</a> Acknowledgements</h1>
<p id="rfc.section.13.p.1">Special thanks are due to Ian Hickson, who was the original author and editor of this protocol. The initial design of this specification benefitted from the participation of many people in the WHATWG and WHATWG mailing list. Contributions to that specification are not tracked by section, but a list of all who contributed to that specification is given in the WHATWG HTML specification at http://whatwg.org/html5.  </p>
<p id="rfc.section.13.p.2">Special thanks also to John Tamplin for providing a significant amount of text for the Data Framing section of this specification.</p>
<p id="rfc.section.13.p.3">Special thanks also to Adam Barth for providing a significant amount of text and background research for the Data Masking section of this specification.</p>
<p id="rfc.section.13.p.4">Special thanks to Lisa Dusseault for the Apps Area review (and for helping to start this work), Richard Barnes for the Gen-Art review and Magnus Westerlund for the Transport Area Review. Special thanks to HYBI WG past and present WG chairs who tirelessly worked behind the scene to move this work toward completion: Joe Hildebrand, Salvatore Loreto and Gabriel Montenegro. And last but not least, special thank you to the responsible Area Director Peter Saint-Andre.  </p>
<p id="rfc.section.13.p.5">Thank you to the following people who participated in discussions on the HYBI WG mailing list and contributed ideas and/or provided detailed reviews (the list is likely to be incomplete): Greg Wilkins, John Tamplin, Willy Tarreau, Maciej Stachowiak, Jamie Lokier, Scott Ferguson, Bjoern Hoehrmann, Julian Reschke, Dave Cridland, Andy Green, Eric Rescorla, Inaki Baz Castillo, Martin Thomson, Roberto Peon, Patrick McManus, Zhong Yu, Bruce Atherton, Takeshi Yoshino, Martin J. Duerst, James Graham, Simon Pieters, Roy T. Fielding, Mykyta Yevstifeyev, Len Holgate, Paul Colomiets, Piotr Kulaga, Brian Raymor, Jan Koehler, Joonas Lehtolahti, Sylvain Hellegouarch, Stephen Farrell, Sean Turner, Pete Resnick, Peter Thorson, Joe Mason, John Fallows, Alexander Philippou.  Note that people listed above didn't necessarily endorse the end result of this work.</p>
<h1 id="rfc.references">
<a href="#rfc.references">14.</a> References</h1>
<h1 id="rfc.references.1">
<a href="#rfc.references.1">14.1.</a> Normative References</h1>
<table><tbody>
<tr>
<td class="reference"><b id="ANSI.X3-4.1986">[ANSI.X3-4.1986]</b></td>
<td class="top">
<a>American National Standards Institute</a>, "<a>Coded Character Set - 7-bit American Standard Code for Information Interchange</a>", ANSI X3.4, 1986.</td>
</tr>
<tr>
<td class="reference"><b id="FIPS.180-2.2002">[FIPS.180-2.2002]</b></td>
<td class="top">
<a>National Institute of Standards and Technology</a>, "<a>Secure Hash Standard</a>", FIPS PUB 180-2, August 2002.</td>
</tr>
<tr>
<td class="reference"><b id="RFC1928">[RFC1928]</b></td>
<td class="top">
<a href="mailto:mleech@bnr.ca" title="Bell-Northern Research Ltd">Leech, M.</a>, <a title="International Business Machines">Ganis, M.</a>, <a title="NEC Systems Laboratory">Lee, Y.</a>, <a title="Unify Corporation">Kuris, R.</a>, <a title="Independent Consultant">Koblas, D.</a> and <a title="Hewlett-Packard Company">L. Jones</a>, "<a href="http://tools.ietf.org/html/rfc1928">SOCKS Protocol Version 5</a>", RFC 1928, March 1996.</td>
</tr>
<tr>
<td class="reference"><b id="RFC2119">[RFC2119]</b></td>
<td class="top">
<a href="mailto:sob@harvard.edu" title="Harvard University">Bradner, S.</a>, "<a href="http://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>", BCP 14, RFC 2119, March 1997.</td>
</tr>
<tr>
<td class="reference"><b id="RFC2616">[RFC2616]</b></td>
<td class="top">
<a href="mailto:fielding@ics.uci.edu" title="Department of Information and Computer Science">Fielding, R.</a>, <a href="mailto:jg@w3.org" title="World Wide Web Consortium">Gettys, J.</a>, <a href="mailto:mogul@wrl.dec.com" title="Compaq Computer Corporation">Mogul, J.</a>, <a href="mailto:frystyk@w3.org" title="World Wide Web Consortium">Frystyk, H.</a>, <a href="mailto:masinter@parc.xerox.com" title="Xerox Corporation">Masinter, L.</a>, <a href="mailto:paulle@microsoft.com" title="Microsoft Corporation">Leach, P.</a> and <a href="mailto:timbl@w3.org" title="World Wide Web Consortium">T. Berners-Lee</a>, "<a href="http://tools.ietf.org/html/rfc2616">Hypertext Transfer Protocol -- HTTP/1.1</a>", RFC 2616, June 1999.</td>
</tr>
<tr>
<td class="reference"><b id="RFC2817">[RFC2817]</b></td>
<td class="top">
<a>Khare, R.</a> and <a>S. Lawrence</a>, "<a href="http://tools.ietf.org/html/rfc2817">Upgrading to TLS Within HTTP/1.1</a>", RFC 2817, May 2000.</td>
</tr>
<tr>
<td class="reference"><b id="RFC2818">[RFC2818]</b></td>
<td class="top">
<a>Rescorla, E.</a>, "<a href="http://tools.ietf.org/html/rfc2818">HTTP Over TLS</a>", RFC 2818, May 2000.</td>
</tr>
<tr>
<td class="reference"><b id="RFC3629">[RFC3629]</b></td>
<td class="top">
<a>Yergeau, F.</a>, "<a href="http://tools.ietf.org/html/rfc3629">UTF-8, a transformation format of ISO 10646</a>", STD 63, RFC 3629, November 2003.</td>
</tr>
<tr>
<td class="reference"><b id="RFC3864">[RFC3864]</b></td>
<td class="top">
<a>Klyne, G.</a>, <a>Nottingham, M.</a> and <a>J. Mogul</a>, "<a href="http://tools.ietf.org/html/rfc3864">Registration Procedures for Message Header Fields</a>", BCP 90, RFC 3864, September 2004.</td>
</tr>
<tr>
<td class="reference"><b id="RFC3986">[RFC3986]</b></td>
<td class="top">
<a href="mailto:timbl@w3.org" title="World Wide Web Consortium">Berners-Lee, T.</a>, <a href="mailto:fielding@gbiv.com" title="Day Software">Fielding, R.</a> and <a href="mailto:LMM@acm.org" title="Adobe Systems Incorporated">L. Masinter</a>, "<a href="http://tools.ietf.org/html/rfc3986">Uniform Resource Identifier (URI): Generic Syntax</a>", STD 66, RFC 3986, January 2005.</td>
</tr>
<tr>
<td class="reference"><b id="RFC3987">[RFC3987]</b></td>
<td class="top">
<a>Duerst, M.</a> and <a>M. Suignard</a>, "<a href="http://tools.ietf.org/html/rfc3987">Internationalized Resource Identifiers (IRIs)</a>", RFC 3987, January 2005.</td>
</tr>
<tr>
<td class="reference"><b id="RFC4086">[RFC4086]</b></td>
<td class="top">
<a>Eastlake, D.</a>, <a>Schiller, J.</a> and <a>S. Crocker</a>, "<a href="http://tools.ietf.org/html/rfc4086">Randomness Requirements for Security</a>", BCP 106, RFC 4086, June 2005.</td>
</tr>
<tr>
<td class="reference"><b id="RFC5246">[RFC5246]</b></td>
<td class="top">
<a>Dierks, T.</a> and <a>E. Rescorla</a>, "<a href="http://tools.ietf.org/html/rfc5246">The Transport Layer Security (TLS) Protocol Version 1.2</a>", RFC 5246, August 2008.</td>
</tr>
<tr>
<td class="reference"><b id="RFC6066">[RFC6066]</b></td>
<td class="top">
<a>Eastlake, D.</a>, "<a href="http://tools.ietf.org/html/rfc6066">Transport Layer Security (TLS) Extensions: Extension Definitions</a>", RFC 6066, January 2011.</td>
</tr>
<tr>
<td class="reference"><b id="RFC4648">[RFC4648]</b></td>
<td class="top">
<a>Josefsson, S.</a>, "<a href="http://tools.ietf.org/html/rfc4648">The Base16, Base32, and Base64 Data Encodings</a>", RFC 4648, October 2006.</td>
</tr>
<tr>
<td class="reference"><b id="RFC5226">[RFC5226]</b></td>
<td class="top">
<a>Narten, T.</a> and <a>H. Alvestrand</a>, "<a href="http://tools.ietf.org/html/rfc5226">Guidelines for Writing an IANA Considerations Section in RFCs</a>", BCP 26, RFC 5226, May 2008.</td>
</tr>
<tr>
<td class="reference"><b id="RFC5234">[RFC5234]</b></td>
<td class="top">
<a>Crocker, D.</a> and <a>P. Overell</a>, "<a href="http://tools.ietf.org/html/rfc5234">Augmented BNF for Syntax Specifications: ABNF</a>", STD 68, RFC 5234, January 2008.</td>
</tr>
<tr>
<td class="reference"><b id="I-D.ietf-websec-origin">[I-D.ietf-websec-origin]</b></td>
<td class="top">
<a>Barth, A</a>, "<a href="http://tools.ietf.org/html/draft-ietf-websec-origin-05">The Web Origin Concept</a>", Internet-Draft draft-ietf-websec-origin-05, September 2011.</td>
</tr>
</tbody></table>
<h1 id="rfc.references.2">
<a href="#rfc.references.2">14.2.</a> Informative References</h1>
<table><tbody>
<tr>
<td class="reference"><b id="WSAPI">[WSAPI]</b></td>
<td class="top">
<a title="Google, Inc.">Hickson, I.E.</a>, "<a>The Web Sockets API</a>", August 2010.</td>
</tr>
<tr>
<td class="reference"><b id="RFC4122">[RFC4122]</b></td>
<td class="top">
<a href="mailto:paulle@microsoft.com" title="Microsoft">Leach, P.</a>, <a href="mailto:michael@refactored-networks.com" title="Refactored Networks, LLC">Mealling, M.</a> and <a href="mailto:rsalz@datapower.com" title="DataPower Technology, Inc.">R. Salz</a>, "<a href="http://tools.ietf.org/html/rfc4122">A Universally Unique IDentifier (UUID) URN Namespace</a>", RFC 4122, July 2005.</td>
</tr>
<tr>
<td class="reference"><b id="RFC6265">[RFC6265]</b></td>
<td class="top">
<a>Barth, A.</a>, "<a href="http://tools.ietf.org/html/rfc6265">HTTP State Management Mechanism</a>", RFC 6265, April 2011.</td>
</tr>
<tr>
<td class="reference"><b id="RFC5321">[RFC5321]</b></td>
<td class="top">
<a>Klensin, J.</a>, "<a href="http://tools.ietf.org/html/rfc5321">Simple Mail Transfer Protocol</a>", RFC 5321, October 2008.</td>
</tr>
<tr>
<td class="reference"><b id="RFC6202">[RFC6202]</b></td>
<td class="top">
<a>Loreto, S.</a>, <a>Saint-Andre, P.</a>, <a>Salsano, S.</a> and <a>G. Wilkins</a>, "<a href="http://tools.ietf.org/html/rfc6202">Known Issues and Best Practices for the Use of Long Polling and Streaming in Bidirectional HTTP</a>", RFC 6202, April 2011.</td>
</tr>
<tr>
<td class="reference"><b id="RFC4270">[RFC4270]</b></td>
<td class="top">
<a>Hoffman, P.</a> and <a>B. Schneier</a>, "<a href="http://tools.ietf.org/html/rfc4270">Attacks on Cryptographic Hashes in Internet Protocols</a>", RFC 4270, November 2005.</td>
</tr>
<tr>
<td class="reference"><b id="W3C.REC-wsc-ui-20100812">[W3C.REC-wsc-ui-20100812]</b></td>
<td class="top">
<a>Roessler, T.</a> and <a>A. Saldhana</a>, "<a>Web Security Context: User Interface Guidelines</a>", World Wide Web Consortium Recommendation REC-wsc-ui-20100812, August 2010.</td>
</tr>
<tr>
<td class="reference"><b id="TALKING">[TALKING]</b></td>
<td class="top">
<a title="Carnegie Mellon University">Huang, L-S.</a>, <a title="Carnegie Mellon University">Chen, E. Y.</a>, <a title="Google, Inc.">Barth, A.</a> and <a title="RTFM">E. Rescorla</a>, "<a>Talking to Yourself for Fun and Profit</a>", 2010.</td>
</tr>
<tr>
<td class="reference"><b id="XMLHttpRequest">[XMLHttpRequest]</b></td>
<td class="top">
<a title="Opera Software ASA">van Kesteren, A.</a>, "<a>XMLHttpRequest</a>", August 2010.</td>
</tr>
</tbody></table>
<h1 id="rfc.authors"><a href="#rfc.authors">Authors' Addresses</a></h1>
<div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Ian Fette</span> 
	  <span class="n hidden">
		<span class="family-name">Fette</span>
	  </span>
	</span>
	<span class="org vcardline">Google, Inc.</span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality"></span> 
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline"></span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:ifette+ietf@google.com">ifette+ietf@google.com</a></span>

<span class="vcardline">URI: <a href="http://www.ianfette.com/">http://www.ianfette.com/</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Alexey Melnikov</span> 
	  <span class="n hidden">
		<span class="family-name">Melnikov</span>
	  </span>
	</span>
	<span class="org vcardline">Isode Ltd</span>
	<span class="adr">
	  <span>5 Castle Business Village</span>
<span>36 Station Road</span>

	  <span class="vcardline">
		<span class="locality">Hampton</span>,  
		<span class="region">Middlesex</span> 
		<span class="code">TW12 2BX</span>
	  </span>
	  <span class="country-name vcardline">UK</span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:Alexey.Melnikov@isode.com">Alexey.Melnikov@isode.com</a></span>

  </address>
</div>

</body>
</html>