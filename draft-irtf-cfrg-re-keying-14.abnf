q_i = L / m_max, i = 1, ... , t.
K_root = K
q = L / N.
l_max = ceil(m_max/N).

           Figure 9: Internal re-keying without a master key


D = ( 80 | 81 | 82 | 83 | 84 | 85 | 86 | 87
n = 128:  f = a^128 + a^7 + a^2 + a^1 + 1,

n = 256:  f = a^256 + a^10 + a^5 + a^2 + 1.

t = T* / d,
l_max = ceil(m_max / (N * t)).

                   Figure 10: Internal re-keying with a master key


   During the processing of the input message M with the length m in
   some mode of operation that uses ACPKM-Master key transformation with
   the initial key K and the master key frequency T* the message M is
   divided into l = ceil(m / N) sections (denoted as M = M_1 | M_2 |
   ... | M_l, where M_i is in V_N for i in {1, 2, ... , l - 1} and M_l
   is in V_r, r <= N).  The j-th section of each message is processed
   with the key material K[j], j in {1, ... , l}, |K[j]| = d, that is
   calculated with the ACPKM-Master algorithm as follows:

      K[1] | ... | K[l] = ACPKM-Master(T*, K, d, l) = CTR-ACPKM-Encrypt
      (T*, K, 1^{n/2}, 0^{d*l}).

   Note: the parameters d and l MUST be such that d * l <= n *
   2^{n/2-1}.
n = 128:  f = a^128 + a^7 + a^2 + a^1 + 1,

n = 256:  f = a^256 + a^10 + a^5 + a^2 + 1.

k = 256
t = 128

k = 256
t = 128

k = 256
t = 128
k = 256
t = 128

k = 256
n = 128
c = 64
N = 256

k = 128
n = 128
c = 32
N = 256

k = 256
n = 128
N = 256
k = 192
n = 128
N = 256

k = 256
n = 128
N = 256
k = 256
n = 128
N = 256
k = 256
n = 128
N = 256
