D_ITER = 0x00 in the iterations of the LM-OTS algorithms

D_PBLC = 0x01 when computing the hash of all of the iterates in
D_MESG = 0x02 when computing the hash of the message in the LM-
D_LEAF = 0x03 when computing the hash of the leaf of an LMS
D_INTR = 0x04 when computing the hash of an interior node of an
tmp = x[i]
tmp = H(tmp || I || q || uint16str(i) || uint8str(j) || D_ITER)
sum = 0
sum = sum + (2^w - 1) - coef(S, i, w)
Q = H(message || C || I || q || D_MESG)
a = coef(Q || Cksm(Q), i, w)
tmp = x[i]
tmp = H(tmp || I || q || uint16str(i) || uint8str(j) || D_ITER)
type = first 4 bytes
C = next n bytes
I = next 31 bytes
NULL = next byte; this padding value is discarded
q = next four bytes
Q = H(message || C || I || q || D_MESG)
a = (2^w - 1) - coef(Q || Cksm(Q), i, w)
tmp = y[i]
tmp = H(tmp || I || q || uint16str(i) || uint8str(j) || D_ITER)
candidate = H(z[0] || z[1] || ... || z[p-1] || I || q || D_PBLC)
ots_reserved        = 0,
lmots_sha256_m16_w1  = 0x00000001,
lmots_sha256_m16_w2  = 0x00000002,
lmots_sha256_m16_w4  = 0x00000003,
lmots_sha256_m16_w8  = 0x00000004,
lmots_sha256_n32_w1  = 0x00000005,
lmots_sha256_n32_w2  = 0x00000006,
lmots_sha256_n32_w4  = 0x00000007,
lmots_sha256_n32_w8  = 0x00000008
n=32 and p=265 for lmots_sha256_n32_w1.

n = node number = 2^h + leaf_number
tmp = candidate public key computed from LM-OTS signature and message
tmp = H(tmp || I || uint32str(node_num) || D_LEAF)
i = 0
tmp = H(path[i] || tmp || I || uint32str(node_num/2) || D_INTR)
tmp = H(tmp || path[i] || I || uint32str(node_num/2) || D_INTR)
node_num = node_num/2
i = i + 1
lms_reserved       = 0x00000000,
lms_sha256_n32_h20 = 0x00000001,
lms_sha256_n32_h10 = 0x00000002,
lms_sha256_n32_h5  = 0x00000003
lms_sha256_n16_h20 = 0x00000004,
lms_sha256_n16_h10 = 0x00000005,
lms_sha256_n16_h5  = 0x00000006
n=16, the LM-OTS iterates a 55-byte value (that is, the string that
c = Cksm(H(message)) (see Section 4.7).  To attempt a forgery, an
a = coef(h, j, w), and

b = coef(c, k, w), and
u = ceil(8*n/w)
v = ceil((floor(lg((2^w - 1) * u)) + 1) / w)
ls = (number of bits in sum) - (v * w)
p = u + v

level = 0;
r = node number
siblings = ""
siblings = (pop(data stack) || siblings)
level = pop(integer stack)
r = node number
public_key = pop(data stack)

   Note that this pseudocode expects that all 2^h leaves of the tree
   have equal depth.  Neither stack ever contains more than h+1
   elements.  For typical parameters, these stacks will hold around 512
   bytes of data.

D_ITER = chr(0x00) # in the iterations of the LM-OTS algorithms
D_PBLC = chr(0x01) # when computing the hash of all of the iterates in the LM-OTS algorithm
D_MESG = chr(0x02) # when computing the hash of the message in the LMOTS algorithms
D_LEAF = chr(0x03) # when computing the hash of the leaf of an LMS tree
D_INTR = chr(0x04) # when computing the hash of an interior node of an LMS tree

NULL   = chr(0)    # used as padding for encoding

lmots_sha256_n32_w8 = 0x08000008 # typecode for LM-OTS with n=32, w=8
lms_sha256_n32_h10  = 0x02000002 # typecode for LMS with n=32, h=10
hlms_sha256_n32_l2  = 0x01000001 # typecode for two-level HLMS with n=32


n = 32; p = 34; w = 8; ls = 0

h = SHA256.new()
tmp = x
tmp = H(tmp + I + q + uint16ToString(i) + uint8ToString(j) + D_ITER)

entropySource = Random.new()

c4 = chr(x & 0xff)
x = x >> 8
c3 = chr(x & 0xff)
x = x >> 8
c2 = chr(x & 0xff)
x = x >> 8
c1 = chr(x & 0xff)
c2 = chr(x & 0xff)
x = x >> 8
c1 = chr(x & 0xff)
sum = 0
sum = sum * 256 + ord(c)
result = uint32ToString(lmots_sha256_n32_w8) + C + I + NULL + q
result = result + y[i]
typecode = sig[0:4]
C = sig[4:n+4]
I = sig[n+4:n+35]
q = sig[n+36:n+40] # note: skip over NULL
y = list()
pos = n+40
pos = pos + n
priv = list()
hash = SHA256.new()
tmp = x
tmp = H(tmp + I + q + uint16ToString(i) + uint8ToString(j) + D_ITER)
sum = 0
sum = sum + ord(c)
c1 = chr(sum >> 8)
c2 = chr(sum & 0xff)
C = entropySource.read(n)
hashQ = H(message + C + I + q + D_MESG)
V = hashQ + checksum(hashQ)
y = list()
tmp = x
tmp = H(tmp + I + q + uint16ToString(i) + uint8ToString(j) + D_ITER)
hashQ = H(message + C + I + q + D_MESG)
V = hashQ + checksum(hashQ)
hash = SHA256.new()
tmp = y
tmp = H(tmp + I + q + uint16ToString(i) + uint8ToString(j) + D_ITER)
z = lmots_sig_to_pub(sig, message)
I = entropySource.read(31)
q = uint32ToString(0)
private_key = lmots_gen_priv()

public_key = lmots_gen_pub(private_key, I, q)

message = "The right of the people to be secure in their persons, houses, papers, and effects, against unreasonable searches and seizures, shall not be violated, and no warrants shall issue, but upon probable cause, supported by oath or affirmation, and particularly describing the place to be searched, and the persons or things to be seized."

sig = lmots_gen_sig(private_key, I, q, message)

h = 10 # height (number of levels -1) of tree

result = uint32ToString(lms_sha256_n32_h10) + lmots_sig
result = result + path[i]
typecode = sig[0:4]
pos = 4 + bytes_in_lmots_sig()
lmots_sig = sig[4:pos]
path = list()
pos = pos + n
ots_priv = lmots_gen_priv()
ots_pub = lmots_gen_pub(ots_priv, self.I, uint32ToString(q))
node_num = leaf_num + 2**h
path = list()
node_num = node_num/2
sig = lmots_gen_sig(self.priv[self.leaf_num], self.I, uint32ToString(self.leaf_num), message)
path = self.get_path(self.leaf_num)
leaf_num = self.leaf_num
node_num = stringToUint(q) + 2**h
pathvalue = iter(path)
tmp = lmots_sig_to_pub(lmots_sig, message)
tmp = H(tmp + I + uint32ToString(node_num) + D_LEAF)
tmp = H(pathvalue.next() + tmp + I + uint32ToString(node_num/2) + D_INTR)
tmp = H(tmp + pathvalue.next() + I + uint32ToString(node_num/2) + D_INTR)
node_num = node_num/2
lms_priv = lms_private_key()
lms_pub = lms_public_key(lms_priv.get_public_key())

sig = lms_priv.sign(message)

result = uint32ToString(hlms_sha256_n32_l2)
result = result + pub2
result = result + sig1
result = result + lms_sig
typecode = sig[0:4]
pub2 = sig[4:36]
lms_sig_len = bytes_in_lms_sig()
sig1 = sig[36:36+lms_sig_len]
lms_sig = sig[36+lms_sig_len:36+2*lms_sig_len]
lms_sig = self.prv2.sign(message)
lms_sig = self.prv2.sign(message)
hlms_prv = hlms_private_key()

hlms_pub = hlms_public_key(hlms_prv.get_public_key())

sig = hlms_prv.sign(message)

