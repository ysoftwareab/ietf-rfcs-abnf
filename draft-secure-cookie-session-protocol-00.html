<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" 
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html lang="en" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head profile="http://www.w3.org/2006/03/hcard%20http://dublincore.org/documents/2008/08/04/dc-html/">
  <meta http-equiv="Content-Type" content="text/html; charset=us-ascii" />

  <title>SCS: Secure Cookie Sessions for HTTP</title>

  <style type="text/css" title="Xml2Rfc (sans serif)">
  /*<![CDATA[*/
	  a {
	  text-decoration: none;
	  }
	  a.smpl {
	  color: black;
	  }
	  a:hover {
	  text-decoration: underline;
	  }
	  a:active {
	  text-decoration: underline;
	  }
	  address {
	  margin-top: 1em;
	  margin-left: 2em;
	  font-style: normal;
	  }
	  body {
	  color: black;
	  font-family: verdana, helvetica, arial, sans-serif;
	  font-size: 10pt;
	  
	  }
	  cite {
	  font-style: normal;
	  }
	  dd {
	  margin-right: 2em;
	  }
	  dl {
	  margin-left: 2em;
	  }
	
	  ul.empty {
	  list-style-type: none;
	  }
	  ul.empty li {
	  margin-top: .5em;
	  }
	  dl p {
	  margin-left: 0em;
	  }
	  dt {
	  margin-top: .5em;
	  }
	  h1 {
	  font-size: 14pt;
	  line-height: 21pt;
	  page-break-after: avoid;
	  }
	  h1.np {
	  page-break-before: always;
	  }
	  h1 a {
	  color: #333333;
	  }
	  h2 {
	  font-size: 12pt;
	  line-height: 15pt;
	  page-break-after: avoid;
	  }
	  h3, h4, h5, h6 {
	  font-size: 10pt;
	  page-break-after: avoid;
	  }
	  h2 a, h3 a, h4 a, h5 a, h6 a {
	  color: black;
	  }
	  img {
	  margin-left: 3em;
	  }
	  li {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  ol {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  ol p {
	  margin-left: 0em;
	  }
	  p {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  pre {
	  margin-left: 3em;
	  background-color: lightyellow;
	  padding: .25em;
	  }
	  pre.text2 {
	  border-style: dotted;
	  border-width: 1px;
	  background-color: #f0f0f0;
	  width: 69em;
	  }
	  pre.inline {
	  background-color: white;
	  padding: 0em;
	  }
	  pre.text {
	  border-style: dotted;
	  border-width: 1px;
	  background-color: #f8f8f8;
	  width: 69em;
	  }
	  pre.drawing {
	  border-style: solid;
	  border-width: 1px;
	  background-color: #f8f8f8;
	  padding: 2em;
	  }
	  table {
	  margin-left: 2em;
	  }
	  table.tt {
	  vertical-align: top;
	  }
	  table.full {
	  border-style: outset;
	  border-width: 1px;
	  }
	  table.headers {
	  border-style: outset;
	  border-width: 1px;
	  }
	  table.tt td {
	  vertical-align: top;
	  }
	  table.full td {
	  border-style: inset;
	  border-width: 1px;
	  }
	  table.tt th {
	  vertical-align: top;
	  }
	  table.full th {
	  border-style: inset;
	  border-width: 1px;
	  }
	  table.headers th {
	  border-style: none none inset none;
	  border-width: 1px;
	  }
	  table.left {
	  margin-right: auto;
	  }
	  table.right {
	  margin-left: auto;
	  }
	  table.center {
	  margin-left: auto;
	  margin-right: auto;
	  }
	  caption {
	  caption-side: bottom;
	  font-weight: bold;
	  font-size: 9pt;
	  margin-top: .5em;
	  }
	
	  table.header {
	  border-spacing: 1px;
	  width: 95%;
	  font-size: 10pt;
	  color: white;
	  }
	  td.top {
	  vertical-align: top;
	  }
	  td.topnowrap {
	  vertical-align: top;
	  white-space: nowrap; 
	  }
	  table.header td {
	  background-color: gray;
	  width: 50%;
	  }
	  table.header a {
	  color: white;
	  }
	  td.reference {
	  vertical-align: top;
	  white-space: nowrap;
	  padding-right: 1em;
	  }
	  thead {
	  display:table-header-group;
	  }
	  ul.toc, ul.toc ul {
	  list-style: none;
	  margin-left: 1.5em;
	  margin-right: 0em;
	  padding-left: 0em;
	  }
	  ul.toc li {
	  line-height: 150%;
	  font-weight: bold;
	  font-size: 10pt;
	  margin-left: 0em;
	  margin-right: 0em;
	  }
	  ul.toc li li {
	  line-height: normal;
	  font-weight: normal;
	  font-size: 9pt;
	  margin-left: 0em;
	  margin-right: 0em;
	  }
	  li.excluded {
	  font-size: 0pt;
	  }
	  ul p {
	  margin-left: 0em;
	  }
	
	  .comment {
	  background-color: yellow;
	  }
	  .center {
	  text-align: center;
	  }
	  .error {
	  color: red;
	  font-style: italic;
	  font-weight: bold;
	  }
	  .figure {
	  font-weight: bold;
	  text-align: center;
	  font-size: 9pt;
	  }
	  .filename {
	  color: #333333;
	  font-weight: bold;
	  font-size: 12pt;
	  line-height: 21pt;
	  text-align: center;
	  }
	  .fn {
	  font-weight: bold;
	  }
	  .hidden {
	  display: none;
	  }
	  .left {
	  text-align: left;
	  }
	  .right {
	  text-align: right;
	  }
	  .title {
	  color: #990000;
	  font-size: 18pt;
	  line-height: 18pt;
	  font-weight: bold;
	  text-align: center;
	  margin-top: 36pt;
	  }
	  .vcardline {
	  display: block;
	  }
	  .warning {
	  font-size: 14pt;
	  background-color: yellow;
	  }
	
	
	  @media print {
	  .noprint {
		display: none;
	  }
	
	  a {
		color: black;
		text-decoration: none;
	  }
	
	  table.header {
		width: 90%;
	  }
	
	  td.header {
		width: 50%;
		color: black;
		background-color: white;
		vertical-align: top;
		font-size: 12pt;
	  }
	
	  ul.toc a::after {
		content: leader('.') target-counter(attr(href), page);
	  }
	
	  ul.ind li li a {
		content: target-counter(attr(href), page);
	  }
	
	  .print2col {
		column-count: 2;
		-moz-column-count: 2;
		column-fill: auto;
	  }
	  }
	
	  @page {
	  @top-left {
		   content: "Internet-Draft"; 
	  } 
	  @top-right {
		   content: "December 2010"; 
	  } 
	  @top-center {
		   content: "Abbreviated Title";3
	  } 
	  @bottom-left {
		   content: "Doe"; 
	  } 
	  @bottom-center {
		   content: "Expires June 2011"; 
	  } 
	  @bottom-right {
		   content: "[Page " counter(page) "]"; 
	  } 
	  }
	
	  @page:first { 
		@top-left {
		  content: normal;
		}
		@top-right {
		  content: normal;
		}
		@top-center {
		  content: normal;
		}
	  }
  /*]]>*/
  </style>

  <link href="#rfc.toc" rel="Contents">
<link href="#rfc.section.1" rel="Chapter" title="1 Introduction">
<link href="#rfc.section.2" rel="Chapter" title="2 Requirements Language">
<link href="#rfc.section.3" rel="Chapter" title="3 SCS Protocol">
<link href="#rfc.section.3.1" rel="Chapter" title="3.1 PDU Description">
<link href="#rfc.section.3.1.1" rel="Chapter" title="3.1.1 SCS_ATIME">
<link href="#rfc.section.3.1.2" rel="Chapter" title="3.1.2 SCS_DATA">
<link href="#rfc.section.3.1.3" rel="Chapter" title="3.1.3 SCS_TID">
<link href="#rfc.section.3.1.4" rel="Chapter" title="3.1.4 SCS_IV">
<link href="#rfc.section.3.1.5" rel="Chapter" title="3.1.5 SCS_AUTHTAG">
<link href="#rfc.section.3.2" rel="Chapter" title="3.2 Crypto Transform">
<link href="#rfc.section.3.2.1" rel="Chapter" title="3.2.1 Cipher Set">
<link href="#rfc.section.3.2.2" rel="Chapter" title="3.2.2 Compression">
<link href="#rfc.section.3.2.3" rel="Chapter" title="3.2.3 Cookie Encoding">
<link href="#rfc.section.3.2.4" rel="Chapter" title="3.2.4 Outbound Transform">
<link href="#rfc.section.3.2.5" rel="Chapter" title="3.2.5 Inbound Transform">
<link href="#rfc.section.3.3" rel="Chapter" title="3.3 PDU Exchange">
<link href="#rfc.section.3.3.1" rel="Chapter" title="3.3.1 Cookie Attributes">
<link href="#rfc.section.3.3.1.1" rel="Chapter" title="3.3.1.1 Expires">
<link href="#rfc.section.3.3.1.2" rel="Chapter" title="3.3.1.2 Max-Age">
<link href="#rfc.section.3.3.1.3" rel="Chapter" title="3.3.1.3 Domain">
<link href="#rfc.section.3.3.1.4" rel="Chapter" title="3.3.1.4 Secure">
<link href="#rfc.section.4" rel="Chapter" title="4 Key Management and Session State">
<link href="#rfc.section.5" rel="Chapter" title="5 Acknowledgements">
<link href="#rfc.section.6" rel="Chapter" title="6 IANA Considerations">
<link href="#rfc.section.7" rel="Chapter" title="7 Security Considerations">
<link href="#rfc.section.7.1" rel="Chapter" title="7.1 Security of the Cryptographic Protocol">
<link href="#rfc.section.7.2" rel="Chapter" title="7.2 Impact of the SCS Cookie Model">
<link href="#rfc.section.7.2.1" rel="Chapter" title="7.2.1 Old cookie replay">
<link href="#rfc.section.7.2.2" rel="Chapter" title="7.2.2 Cookie Deletion">
<link href="#rfc.section.7.2.3" rel="Chapter" title="7.2.3 Cookie Sharing or Theft">
<link href="#rfc.section.7.3" rel="Chapter" title="7.3 Advantages of SCS over Server-side Sessions">
<link href="#rfc.references" rel="Chapter" title="8 References">
<link href="#rfc.references.1" rel="Chapter" title="8.1 Normative References">
<link href="#rfc.references.2" rel="Chapter" title="8.2 Informative References">
<link href="#rfc.appendix.Appendix%20A" rel="Chapter" title="Appendix A Reference Implementation">
<link href="#rfc.authors" rel="Chapter">


  <meta name="generator" content=
  "http://greenbytes.de/tech/webdav/rfc2629.xslt, Revision 1.539, 2011-01-02 17:13:00, XSLT vendor: SAXON 6.5.5 from Michael Kay http://saxon.sf.net/" />
  <link rel="schema.dct" href="http://purl.org/dc/terms/" />
  <meta name="dct.creator" content="Doe, J." />
  <meta name="dct.identifier" content="urn:ietf:id:draft-sample-input-00" />
  <meta name="dct.issued" scheme="ISO8601" content="2010-12" />
  
  <meta name="dct.abstract" content="This document provides an overview of SCS, a cryptographic protocol layered on top of the HTTP cookie facility, that allows an origin server to handle session state without storing it locally." />
  <meta name="description" content="This document provides an overview of SCS, a cryptographic protocol layered on top of the HTTP cookie facility, that allows an origin server to handle session state without storing it locally." />
  <meta name="keywords" content="HTTP Secure Cookies" />

</head>

<body>

  <table class="header">
    <tbody>
    
    	<tr>
<td class="left">Internet Engineering Task Force</td>
<td class="right">S.B. Barbato</td>
</tr>
<tr>
<td class="left">Internet-Draft</td>
<td class="right">S.D. Dorigotti</td>
</tr>
<tr>
<td class="left">Intended status: Informational</td>
<td class="right">T.F. Fossati, Ed.</td>
</tr>
<tr>
<td class="left">Expires: August 25, 2011</td>
<td class="right">KoanLogic</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">February 21, 2011</td>
</tr>

    	
    </tbody>
  </table>

  <p class="title">SCS: Secure Cookie Sessions for HTTP<br />
  <span class="filename">draft-secure-cookie-session-protocol-00</span></p>
  
  <h1 id="rfc.abstract"><a href="#rfc.abstract">Abstract</a></h1>
<p>This document provides an overview of SCS, a cryptographic protocol layered on top of the HTTP cookie facility, that allows an origin server to handle session state without storing it locally.</p>
<p>Its typical use cases include devices with little or no storage offering some functionality via an HTTP interface, and web applications with High Availability or load balancing requirements which may want to handle application state without the need to synchronize the pool through shared storage or peering.</p>
<p>Nevertheless, its security properties allow it to be used whenever privacy and integrity of cookies is a concern, at the cost of increased server CPU and bandwidth usage, and of some "credential-ownership" implications which will be thoroughly analysed.</p>
<h1 id="rfc.status"><a href="#rfc.status">Status of this Memo</a></h1>
<p>This Internet-Draft is submitted in full conformance with the provisions of BCP 78 and BCP 79.</p>
<p>Internet-Drafts are working documents of the Internet Engineering Task Force (IETF).  Note that other groups may also distribute working documents as Internet-Drafts.  The list of current Internet- Drafts is at http://datatracker.ietf.org/drafts/current/.</p>
<p>Internet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other documents at any time.  It is inappropriate to use Internet-Drafts as reference material or to cite them other than as "work in progress."</p>
<p>This Internet-Draft will expire on August 25, 2011.</p>
<h1 id="rfc.copyrightnotice"><a href="#rfc.copyrightnotice">Copyright Notice</a></h1>
<p>Copyright (c) 2011 IETF Trust and the persons identified as the document authors.  All rights reserved.</p>
<p>This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document.  Please review these documents carefully, as they describe your rights and restrictions with respect to this document.  Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.</p>

  
  <hr class="noprint" />
  <h1 class="np" id="rfc.toc"><a href="#rfc.toc">Table of Contents</a></h1>
  <ul class="toc">

  	<li>1.   <a href="#rfc.section.1">Introduction</a>
</li>
<li>2.   <a href="#rfc.section.2">Requirements Language</a>
</li>
<li>3.   <a href="#rfc.section.3">SCS Protocol</a>
</li>
<li>3.1.   <a href="#rfc.section.3.1">PDU Description</a>
</li>
<li>3.1.1.   <a href="#rfc.section.3.1.1">SCS_ATIME</a>
</li>
<li>3.1.2.   <a href="#rfc.section.3.1.2">SCS_DATA</a>
</li>
<li>3.1.3.   <a href="#rfc.section.3.1.3">SCS_TID</a>
</li>
<li>3.1.4.   <a href="#rfc.section.3.1.4">SCS_IV</a>
</li>
<li>3.1.5.   <a href="#rfc.section.3.1.5">SCS_AUTHTAG</a>
</li>
<li>3.2.   <a href="#rfc.section.3.2">Crypto Transform</a>
</li>
<li>3.2.1.   <a href="#rfc.section.3.2.1">Cipher Set</a>
</li>
<li>3.2.2.   <a href="#rfc.section.3.2.2">Compression</a>
</li>
<li>3.2.3.   <a href="#rfc.section.3.2.3">Cookie Encoding</a>
</li>
<li>3.2.4.   <a href="#rfc.section.3.2.4">Outbound Transform</a>
</li>
<li>3.2.5.   <a href="#rfc.section.3.2.5">Inbound Transform</a>
</li>
<li>3.3.   <a href="#rfc.section.3.3">PDU Exchange</a>
</li>
<li>3.3.1.   <a href="#rfc.section.3.3.1">Cookie Attributes</a>
</li>
<li>3.3.1.1.   <a href="#rfc.section.3.3.1.1">Expires</a>
</li>
<li>3.3.1.2.   <a href="#rfc.section.3.3.1.2">Max-Age</a>
</li>
<li>3.3.1.3.   <a href="#rfc.section.3.3.1.3">Domain</a>
</li>
<li>3.3.1.4.   <a href="#rfc.section.3.3.1.4">Secure</a>
</li>
<li>4.   <a href="#rfc.section.4">Key Management and Session State</a>
</li>
<li>5.   <a href="#rfc.section.5">Acknowledgements</a>
</li>
<li>6.   <a href="#rfc.section.6">IANA Considerations</a>
</li>
<li>7.   <a href="#rfc.section.7">Security Considerations</a>
</li>
<li>7.1.   <a href="#rfc.section.7.1">Security of the Cryptographic Protocol</a>
</li>
<li>7.2.   <a href="#rfc.section.7.2">Impact of the SCS Cookie Model</a>
</li>
<li>7.2.1.   <a href="#rfc.section.7.2.1">Old cookie replay</a>
</li>
<li>7.2.2.   <a href="#rfc.section.7.2.2">Cookie Deletion</a>
</li>
<li>7.2.3.   <a href="#rfc.section.7.2.3">Cookie Sharing or Theft</a>
</li>
<li>7.3.   <a href="#rfc.section.7.3">Advantages of SCS over Server-side Sessions</a>
</li>
<li>8.   <a href="#rfc.references">References</a>
</li>
<li>8.1.   <a href="#rfc.references.1">Normative References</a>
</li>
<li>8.2.   <a href="#rfc.references.2">Informative References</a>
</li>
<li>Appendix A.   <a href="#rfc.appendix.Appendix%20A">Reference Implementation</a>
</li>
<li><a href="#rfc.authors">Authors' Addresses</a>
</li>


  </ul>

  <h1 id="rfc.section.1">
<a href="#rfc.section.1">1.</a> <a href="#sec_intro" id="sec_intro">Introduction</a>
</h1>
<p id="rfc.section.1.p.1">SCS is a cryptographic protocol layered on top of the HTTP cookie facility <a href="#I-D.ietf-httpstate-cookie">[I-D.ietf-httpstate-cookie]</a>, that allows an origin server to handle clients' session state without storing it locally.</p>
<p id="rfc.section.1.p.2">An SCS enabled server delegates the application state storage to the client (e.g. a browser) - which basically acts as a remote storage device. A set of cryptographic transformations is used to ensure that information authenticity and confidentiality attributes of state data have the same characteristics as for typical "server-side" sessions.</p>
<p id="rfc.section.1.p.3">Anyway, a peculiar difference between SCS and "server-side" cookie sessions arises when we carefully consider the roles of the playing entities. In the "server-side" model, the Server acts a triple role as the "generator", the "owner", and the "verifier" of cookie credentials.  Instead, a server implementing SCS acts the "generator" and "verifier" roles only -- the "owner" being inapplicable as long as we have imposed the no-storage requirement.</p>
<p id="rfc.section.1.p.4">In all respects, the Server grants the custody of the generated cookie to the Client, whose trust model needs to be taken into consideration when designing applications using SCS. The consequences of such discrepancy (e.g. deliberate deletion of a cookie, explicit privilege revocation, etc.) will be explored and analyzed in <a href="#sec_impact_of_scs_cookie_model">Section 7.2</a>.</p>
<p id="rfc.section.1.p.5">The no-storage requirement, which is the key design constraint of SCS, makes it an ideal candidate in the following settings: </p>

<ol style="list-style-type: lower-alpha">
<li>devices with little or no storage -- typically embedded devices which provide functionality such as software updates, configuration, device monitoring, etc. via an HTTP interface;</li>
<li>web applications with HA or load balancing requirements, which may delegate handling of the application state to clients instead of using shared storage or forced peering, to enhance overall parallelism.</li>
</ol>
<p id="rfc.section.1.p.6">An SCS server can be implemented within a web application by means of a user library that exposes the core SCS functionality and leaves explicit control over SCS cookies to the programmer, or transparently, by hiding the "diskless session" facility behind a generic session API abstraction.</p>
<h1 id="rfc.section.2">
<a href="#rfc.section.2">2.</a> Requirements Language</h1>
<p id="rfc.section.2.p.1">The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in <a href="#RFC2119">[RFC2119]</a>.</p>
<h1 id="rfc.section.3">
<a href="#rfc.section.3">3.</a> <a href="#sec_scs_protocol" id="sec_scs_protocol">SCS Protocol</a>
</h1>
<p id="rfc.section.3.p.1">The SCS protocol defines: </p>

<ul>
<li>a PDU, as a well-defined aggregate of cookies (<a href="#sec_pdu_description">Section 3.1</a>);</li>
<li>the cryptographic transformations which manipulate the PDU field (<a href="#sec_crypto_transform">Section 3.2</a>);</li>
<li>the HTTP-based PDU exchange model (<a href="#sec_pdu_exchange">Section 3.3</a>).</li>
</ul>
<p id="rfc.section.3.p.2">Note that the PDU is transmitted to the client as an opaque data block, hence no interpretation nor validation is necessary.</p>
<p id="rfc.section.3.p.3">The single requirement for client-side support of SCS is cookie activation on the browser. Only the server is involved in the PDU manipulation process.</p>
<p id="rfc.section.3.p.4">In the following sections we assume S to be one or more interchangeable HTTP server entities (e.g. a server pool in a load-balanced or HA environment) and C to be the client with a cookie-enabled browser, or User Agent with equivalent capabilities.</p>
<h1 id="rfc.section.3.1">
<a href="#rfc.section.3.1">3.1.</a> <a href="#sec_pdu_description" id="sec_pdu_description">PDU Description</a>
</h1>
<p id="rfc.section.3.1.p.1">S and C exchange the same PDU (<a href="#sec_pdu_exchange">Section 3.3</a>), which consists of a set of interdependent cookies tied together by cryptographic transformations.</p>
<p id="rfc.section.3.1.p.2">Confidentiality is limited to the application state information (i.e. SCS_DATA cookie), while integrity and authentication apply to the entire PDU.</p>
<p id="rfc.section.3.1.p.3">The following subsections describe the syntax and semantics of of each SCS cookie.</p>
<h1 id="rfc.section.3.1.1">
<a href="#rfc.section.3.1.1">3.1.1.</a> <a href="#sec_scs_atime" id="sec_scs_atime">SCS_ATIME</a>
</h1>
<p id="rfc.section.3.1.1.p.1">Timestamp relating to the last read or write operation performed on session data, encoded a numeric string holding the number of seconds since UNIX epoch.</p>
<p id="rfc.section.3.1.1.p.2">This value is updated with each client contact and is used to identify expired sessions.</p>
<p id="rfc.section.3.1.1.p.3">If the received SCS_ATIME value is older than a predefined "session_max_age" (which is chosen by S as an application-level parameter), a session is considered to be no longer valid, and is therefore rejected.</p>
<h1 id="rfc.section.3.1.2">
<a href="#rfc.section.3.1.2">3.1.2.</a> <a href="#sec_scs_data" id="sec_scs_data">SCS_DATA</a>
</h1>
<p id="rfc.section.3.1.2.p.1">Block of encrypted and optionally compressed data, containing session state.  Note that no restriction is imposed on plain text structure: the protocol is completely agnostic as to state data layout.</p>
<p id="rfc.section.3.1.2.p.2">If the total size of the SCS_DATA cookie, including name, value and attributes, exceeds 4096 bytes (see Section 6.1. of <a href="#I-D.ietf-httpstate-cookie">[I-D.ietf-httpstate-cookie]</a>), it is sliced into n SCS_DATA{n} cookies, each 4KB in size, so that the concatenation of their values ordered by cookie name (1, 2, ..., N) yields the original SCS_DATA.</p>
<p id="rfc.section.3.1.2.p.3">It is suggested <a href="#I-D.ietf-httpstate-cookie">[I-D.ietf-httpstate-cookie]</a> that browsers accept at least 50 cookies per domain, which could lead to a theoretical limit of 184 KB as the maximum allowed state data block.</p>
<p id="rfc.section.3.1.2.p.4">Anyway, in order to minimize both network bandwidth and client cookie store consumption, applications should try to upper bound state data to some sensible value. Also, an SCS implementation MAY decide to limit the accepted state data to any value greater than or equal to 4KB.</p>
<h1 id="rfc.section.3.1.3">
<a href="#rfc.section.3.1.3">3.1.3.</a> <a href="#sec_scs_tid" id="sec_scs_tid">SCS_TID</a>
</h1>
<p id="rfc.section.3.1.3.p.1">ASCII string that uniquely identifies the transform set (keys and algorithms) used to generate this PDU.</p>
<p id="rfc.section.3.1.3.p.2">SCS assumes that a key-agreement/distribution mechanism exists for environments in which S consists of multiple servers (it may consist of a simple key-refresh in the case |S|=1), which provides a unique external identifier for each transform set defined and shared amongst pool members.</p>
<p id="rfc.section.3.1.3.p.3">This identifier (equivalent to a SPI in a Data Security SA <a href="#RFC3740">[RFC3740]</a>) is represented in the cookie value.</p>
<h1 id="rfc.section.3.1.4">
<a href="#rfc.section.3.1.4">3.1.4.</a> <a href="#sec_scs_iv" id="sec_scs_iv">SCS_IV</a>
</h1>
<p id="rfc.section.3.1.4.p.1">Initialization Vector used for the encryption algorithm (<a href="#sec_crypto_transform">Section 3.2</a>).</p>
<p id="rfc.section.3.1.4.p.2">In order to avoid providing correlation information to a possible attacker with access to a sample of SCS PDUs, the IV MUST be created randomly for each PDU.</p>
<h1 id="rfc.section.3.1.5">
<a href="#rfc.section.3.1.5">3.1.5.</a> <a href="#sec_scs_authtag" id="sec_scs_authtag">SCS_AUTHTAG</a>
</h1>
<p id="rfc.section.3.1.5.p.1">Authentication tag based on the concatenation of SCS_ATIME, SCS_DATA, SCS_TID and SCS_IV.</p>
<p id="rfc.section.3.1.5.p.2">The concatenation operation is done by packing the four strings containing the base64 encoded values in order (e.g.: "ZGF0YQ==YXRpbWU=dGlkaXY="), and supplying the resulting string to HMAC.</p>
<h1 id="rfc.section.3.2">
<a href="#rfc.section.3.2">3.2.</a> <a href="#sec_crypto_transform" id="sec_crypto_transform">Crypto Transform</a>
</h1>
<p id="rfc.section.3.2.p.1">SCS could potentially use any combination of primitives capable of performing authenticated encryption. In practice an encrypt-then-mac approach <a href="#Kohno">[Kohno]</a> with CBC-mode encryption and <a href="#RFC2104">HMAC</a> <cite title="NONE">[RFC2104]</cite> authentication was chosen.</p>
<p id="rfc.section.3.2.p.2">The two algorithms MUST be associated with two independent keys.</p>
<p id="rfc.section.3.2.p.3">The possibility of using UMAC for authentication <a href="#RFC4418">[RFC4418]</a> has been taken into consideration, but priority was given to space over performance: the nonce field transfer would require an extra cookie, therefore reducing the space reserved to state information by another 4KB.</p>
<p id="rfc.section.3.2.p.4">The following conventions will be used in the algorithm description (<a href="#sec_outbound_transform">Section 3.2.4</a> and <a href="#sec_inbound_transform">Section 3.2.5</a>): </p>

<ul>
<li>Enc/Dec(): block encryption/decryption functions (<a href="#sec_cipher_set">Section 3.2.1</a>);</li>
<li>HMAC(): authentication function (<a href="#sec_cipher_set">Section 3.2.1</a>);</li>
<li>Comp/Uncomp(): compression/decompression functions (<a href="#sec_compression">Section 3.2.2</a>);</li>
<li>e/d(): cookie value encoding/decoding functions (<a href="#sec_cookie_encoding">Section 3.2.3</a>);</li>
<li>RAND(): random number generator <a href="#RFC4086">[RFC4086]</a>.</li>
</ul>
<h1 id="rfc.section.3.2.1">
<a href="#rfc.section.3.2.1">3.2.1.</a> <a href="#sec_cipher_set" id="sec_cipher_set">Cipher Set</a>
</h1>
<p id="rfc.section.3.2.1.p.1">Implementors MUST support at least the following algorithms: <a href="#Bellare">[Bellare]</a>, are widely available, and can be implemented in a few kilobytes of memory, providing an extremely valuable feature in constrained devices.</p>

<ul>
<li>AES-CBC-128 for encryption;</li>
<li>HMAC-SHA1 with a 128 bit key for authenticity and integrity,</li>
</ul>

<p> which appear to be sufficiently secure in a wide range of use cases </p>
<p id="rfc.section.3.2.1.p.2">One should consider using larger cryptographic key lengths (192 or 256 bit) according to the actual security and overall system performance requirements.</p>
<h1 id="rfc.section.3.2.2">
<a href="#rfc.section.3.2.2">3.2.2.</a> <a href="#sec_compression" id="sec_compression">Compression</a>
</h1>
<p id="rfc.section.3.2.2.p.1">Compression, which may be useful or even necessary when handling large quantities of data, is not compulsory (in such case Comp/Uncomp are replaced by an identity matrix). If this function is enabled, <a href="#RFC1951">DEFLATE</a> <cite title="NONE">[RFC1951]</cite> format MUST be supported.</p>
<p id="rfc.section.3.2.2.p.2">Compression should not be enabled when handling relatively short and entropic state (e.g. pseudo random session identifiers).  Instead, large and quite regular state blobs could get a significant boost when compressed.</p>
<h1 id="rfc.section.3.2.3">
<a href="#rfc.section.3.2.3">3.2.3.</a> <a href="#sec_cookie_encoding" id="sec_cookie_encoding">Cookie Encoding</a>
</h1>
<p><a href="#RFC4648">Base-64</a> <cite title="NONE">[RFC4648]</cite> is used for encoding/decoding of SCS cookie values. It is very wide-spread, and falls smoothly into the encoding rules defined in Section 4.1.1 of <a href="#I-D.ietf-httpstate-cookie">[I-D.ietf-httpstate-cookie]</a>.</p>
<h1 id="rfc.section.3.2.4">
<a href="#rfc.section.3.2.4">3.2.4.</a> <a href="#sec_outbound_transform" id="sec_outbound_transform">Outbound Transform</a>
</h1>
<p id="rfc.section.3.2.4.p.1">The output data transformation as seen by the server (the only actor which manipulates PDUs) is illustrated by the pseudo-code in <a href="#fig_outbound_transform">Figure 1</a>.</p>
<div id="#rfc.figure.1"></div>
<div id="#fig_outbound_transform"></div>
<pre>
1.  iv = RAND()
2.  atime = NOW
3.  data = Enc(Comp(state))
4.  tag = HMAC(e(data)||e(atime)||e(tid)||e(iv))
                </pre>
<p id="rfc.section.3.2.4.p.2">NOW is defined as the current timestamp of the server clock.</p>
<p id="rfc.section.3.2.4.p.3">Since the only user of the atime field is the server, it is unnecessary for it to be synchronized with the client. However, if multiple servers are active in a load-balancing configuration, clocks SHOULD be synchronized to avoid errors in the calculation of session expiry.</p>
<p id="rfc.section.3.2.4.p.4">If the length of (compressed) state is not a multiple of the block size, its value MUST be filled with padding bytes of equal value as the pad length -- equivalent to the scheme defined in Section 6.3 of <a href="#RFC5652">[RFC5652]</a>.</p>
<p id="rfc.section.3.2.4.p.5">Hence the SCS PDU fields are created as follows:</p>
<p></p>

<ul class="empty">
<li>SCS_ATIME = e(atime)</li>
<li>SCS_AUTHTAG = e(tag)</li>
<li>SCS_DATA = e(data)</li>
<li>SCS_TID = e(tid)</li>
<li>SCS_IV = e(iv)</li>
</ul>
<h1 id="rfc.section.3.2.5">
<a href="#rfc.section.3.2.5">3.2.5.</a> <a href="#sec_inbound_transform" id="sec_inbound_transform">Inbound Transform</a>
</h1>
<p id="rfc.section.3.2.5.p.1">The inbound transformation is described in <a href="#fig_inbound_transform">Figure 2</a>.</p>
<div id="#rfc.figure.2"></div>
<div id="#fig_inbound_transform"></div>
<pre>
1.  If (tid is available)
2.      data' = d($SCS_DATA)
        atime' = d($SCS_ATIME)
        tid' = d($SCS_TID)
        iv' = d($SCS_IV)
        tag' = d($SCS_AUTHTAG)
3.      tag = HMAC(&lt;data'&gt;||&lt;atime'&gt;||&lt;tid'&gt;||&lt;iv'&gt;)
4.      If (tag == tag' &amp;&amp; NOW - atime' &lt;= session_max_age)
5.          state = Uncomp(Dec(data'))
6.      Else discard PDU
7.  Else discard PDU
                </pre>
<p id="rfc.section.3.2.5.p.2">If the cryptographic credentials (encryption and authentication algorithms and keys identified by SCS_TID) are unavailable (step 7.), the inbound PDU cannot be interpreted correctly.</p>
<p id="rfc.section.3.2.5.p.3">This may happen for several reasons: e.g., if a device without storage has been reset and loses the credentials stored in RAM, if a server pool node desynchronizes, or in case of a key compromise that forces the invalidation of all available TIDs, etc.</p>
<p id="rfc.section.3.2.5.p.4">Note that step 4. allows any altered packets or expired sessions to be discarded, hence avoiding unnecessary state decryption and decompression.</p>
<h1 id="rfc.section.3.3">
<a href="#rfc.section.3.3">3.3.</a> <a href="#sec_pdu_exchange" id="sec_pdu_exchange">PDU Exchange</a>
</h1>
<p id="rfc.section.3.3.p.1">SCS can be modeled in the same manner as a typical store-and-forward protocol, in which the endpoints are S, consisting of one or more HTTP servers, and the client C, an intermediate node used to "temporarily" store the data to be successively forwarded to S.</p>
<p id="rfc.section.3.3.p.2">In brief, S and C exchange an immutable cookie data block (<a href="#sec_pdu_description">Section 3.1</a>): the state is stored on the client at the first hop and then restored on the server at the second, as in <a href="#fig_pdu_exchange">Figure 3</a>.</p>
<div id="#rfc.figure.3"></div>
<div id="#fig_pdu_exchange"></div>
<pre>
1.  dump-state:
           Set-Cookie: SCS_DATA=...;
           Expires=...; Path=...;
           Domain=...;
    S --&gt;                           --&gt; C
           Set-Cookie: SCS_TID=...;
           Expires=...; Path=...;
           Domain=...;
           ...

2.  restore-state:
           Cookie: SCS_DATA=...;
    C --&gt;  Cookie: SCS_TID=...;     --&gt; S
           ...
            </pre>
<p id="rfc.section.3.3.p.3">Note that although SCS cookies always have the same naming, there can be multiple active SCS sessions in use at a given user-agent as long as the tuple &lt;SCS PDU, Domain, Path&gt; is different.</p>
<p id="rfc.section.3.3.p.4">SCS cookies MUST NOT be folded into a single HTTP header field, see Section 3 of <a href="#I-D.ietf-httpstate-cookie">[I-D.ietf-httpstate-cookie]</a>.</p>
<h1 id="rfc.section.3.3.1">
<a href="#rfc.section.3.3.1">3.3.1.</a> <a href="#sec_cookie_attributes" id="sec_cookie_attributes">Cookie Attributes</a>
</h1>
<p id="rfc.section.3.3.1.p.1">All SCS cookies belonging to the same PDU MUST carry the same attributes' set. This is not elegant nor bandwidth-friendly solution, but it is necessary in order to guarantee PDU coherence.</p>
<p id="rfc.section.3.3.1.p.2">In the following sub paragraphs a series of recommendations is provided in order to maximize SCS PDU fitness in the generic cookie ecosystem.</p>
<h1 id="rfc.section.3.3.1.1">
<a href="#rfc.section.3.3.1.1">3.3.1.1.</a> <a href="#sec_expires" id="sec_expires">Expires</a>
</h1>
<p id="rfc.section.3.3.1.1.p.1">SCS cookies MUST include an Expires attribute which shall be set to a value consistent with session_max_age.</p>
<p id="rfc.section.3.3.1.1.p.2">For maximum compatibility with existing user agents the timestamp value MUST be encoded in rfc1123-date format which requires a 4-digit year.</p>
<h1 id="rfc.section.3.3.1.2">
<a href="#rfc.section.3.3.1.2">3.3.1.2.</a> <a href="#sec_max_age" id="sec_max_age">Max-Age</a>
</h1>
<p id="rfc.section.3.3.1.2.p.1">Since not all UAs support this attribute, it MUST NOT be present in any SCS cookie.</p>
<h1 id="rfc.section.3.3.1.3">
<a href="#rfc.section.3.3.1.3">3.3.1.3.</a> <a href="#sec_domain" id="sec_domain">Domain</a>
</h1>
<p id="rfc.section.3.3.1.3.p.1">SCS cookies MUST include a Domain attribute compatible with application usage.</p>
<p id="rfc.section.3.3.1.3.p.2">A trailing '.' MUST NOT be present in order to minimize the possibility of a user-agent ignoring the attribute value.</p>
<h1 id="rfc.section.3.3.1.4">
<a href="#rfc.section.3.3.1.4">3.3.1.4.</a> <a href="#sec_secure" id="sec_secure">Secure</a>
</h1>
<p id="rfc.section.3.3.1.4.p.1">This attribute MUST always be asserted when SCS sessions are carried over a TLS channel.</p>
<h1 id="rfc.section.4">
<a href="#rfc.section.4">4.</a> <a href="#sec_key_management" id="sec_key_management">Key Management and Session State</a>
</h1>
<p id="rfc.section.4.p.1">This specification provides some common recommendations and praxis relevant to cryptographic key management.</p>
<p id="rfc.section.4.p.2">In the following, the term 'key' references both encryption and HMAC keys. </p>

<ul>
<li>The key SHOULD be generated securely following the randomness recommendations in <a href="#RFC4086">[RFC4086]</a>;</li>
<li>the key length SHOULD be at least 128 bits;</li>
<li>the key SHOULD only be used to generate and verify SCS PDUs;</li>
<li>the key SHOULD be replaced regularly as well as any time the format of SCS PDUs or cryptographic algorithms changes.</li>
</ul>
<p id="rfc.section.4.p.3">Furthermore, to preserve the validity of active HTTP sessions upon renewal of cryptographic credentials (whenever the value of SCS_TID changes), an SCS server MUST be capable of managing at least two transforms contemporarily: the currently instantiated one, and its predecessor.</p>
<p id="rfc.section.4.p.4">Each transform set SHOULD be associated with an attribute pair: "refresh" and "expiry", which is used to identify the exposure limits (in terms of time or quantity of encrypted and/or authenticated bytes, etc) of related cryptographic material.</p>
<p id="rfc.section.4.p.5">In particular, the "refresh" attribute specifies the time limit for substitution of transform set T with new material T'. From that moment onwards, and for an amount of time determined by "expiry", all new sessions will be created using T', while the active T-protected ones go through a translation phase in which: </p>

<ul>
<li>the inbound transformation authenticates and decrypts/decompresses using T (identified by SCS_TID);</li>
<li>the outbound transformation encrypts/compresses and authenticates using T'.</li>
</ul>
<div id="#rfc.figure.4"></div>
<div id="#fig_keylifetime"></div>
<pre>
T' {not valid yet} |---------------------|----------------
                   |  translation stage  |
T  ----------------|---------------------| {no longer valid}
                 refresh         refresh + expiry
        </pre>
<p id="rfc.section.4.p.6">As shown in <a href="#fig_keylifetime">Figure 4</a>, the duration of the HTTP session MUST fit within the lifetime of a given transform set (i.e.  from creation time until "refresh" + "expiry").</p>
<p id="rfc.section.4.p.7">In practice, this should not be an obstacle because the longevity of the two entities (HTTP session and SCS transform set) should differ by one or two orders of magnitude.</p>
<p id="rfc.section.4.p.8">An SCS server may take this into account by determining the duration of a session adaptively according to the expected deletion time of the active T, or by setting the "expiry" value to at least the maximum lifetime allowed by an HTTP session.</p>
<p id="rfc.section.4.p.9">Since there is only one refresh attribute also in situations with more than one key (e.g. one for encryption and one for authentication) within the same T, the smallest value is chosen.</p>
<h1 id="rfc.section.5">
<a href="#rfc.section.5">5.</a> <a href="#sec_ack" id="sec_ack">Acknowledgements</a>
</h1>
<p id="rfc.section.5.p.1">We would like to thank David Wagner and Lorenzo Cavallaro for their valuable feedback on this document.</p>
<h1 id="rfc.section.6">
<a href="#rfc.section.6">6.</a> <a href="#sec_iana" id="sec_iana">IANA Considerations</a>
</h1>
<p id="rfc.section.6.p.1">This memo includes no request to IANA.</p>
<h1 id="rfc.section.7">
<a href="#rfc.section.7">7.</a> <a href="#sec_security_considerations" id="sec_security_considerations">Security Considerations</a>
</h1>
<h1 id="rfc.section.7.1">
<a href="#rfc.section.7.1">7.1.</a> <a href="#sec_security_of_the_crypto_protocol" id="sec_security_of_the_crypto_protocol">Security of the Cryptographic Protocol</a>
</h1>
<p id="rfc.section.7.1.p.1">From a cryptographic architecture perspective, the described mechanism can be easily traced to an Encode-then-EtM scheme described in <a href="#Kohno">[Kohno]</a>.</p>
<p id="rfc.section.7.1.p.2">Given a "provably-secure" encryption scheme and MAC (as for the algorithms mandated in <a href="#sec_cipher_set">Section 3.2.1</a>), Kohno et al. <a href="#Kohno">[Kohno]</a> demonstrate that their composition results in a secure authenticated encryption scheme.</p>
<h1 id="rfc.section.7.2">
<a href="#rfc.section.7.2">7.2.</a> <a href="#sec_impact_of_scs_cookie_model" id="sec_impact_of_scs_cookie_model">Impact of the SCS Cookie Model</a>
</h1>
<p id="rfc.section.7.2.p.1">The fact that the server does not own the cookie it produces, gives rise to a series of consequences that must be clearly understood when one envisages the use of SCS as a cookie provider and validator for his/her application.</p>
<p id="rfc.section.7.2.p.2">In the following paragraphs, a set of different attack scenarios (together with corresponding countermeasures where applicable) are identified and analyzed.</p>
<h1 id="rfc.section.7.2.1">
<a href="#rfc.section.7.2.1">7.2.1.</a> <a href="#sec_old_cookie_replay" id="sec_old_cookie_replay">Old cookie replay</a>
</h1>
<p id="rfc.section.7.2.1.p.1">SCS doesn't address replay of old cookie values.</p>
<p id="rfc.section.7.2.1.p.2">In fact, there is nothing that guarantees an SCS application about the client having returned the most recent version of the cookie.</p>
<p id="rfc.section.7.2.1.p.3">As with "server-side" sessions, if an attacker gains possession of a given user's cookies - via simple passive interception or another technique - he/she will always be able to restore the state of an intercepted session by representing the captured data to the server.</p>
<p id="rfc.section.7.2.1.p.4">The SCS_ATIME value along with the session_max_age configuration parameter allow SCS to mitigate the chances of an attack (by forcing a time window outside of which a given cookie is no longer valid), but cannot exclude it completely.</p>
<p id="rfc.section.7.2.1.p.5">A countermeasure against the "passive interception and replay" scenario can be applied at transport/network level using the anti-replay services provided by e.g., <a href="#RFC5246">SSL/TLS</a> <cite title="NONE">[RFC5246]</cite> or <a href="#RFC4301">IPsec</a> <cite title="NONE">[RFC4301]</cite>.</p>
<p id="rfc.section.7.2.1.p.6">Anyway, a generic solution is still out of scope: an SCS application wishing to be replay-resistant must put in place some ad hoc mechanism to prevent clients (both rogue and legitimate) from (a) being able to replay old cookies as valid credentials and/or (b) getting any advantage by replaying them.</p>
<p id="rfc.section.7.2.1.p.7">In the following, some typical use cases are illustrated: </p>

<ul>
<li>Session inactivity timeout scenario (implicit invalidation): use the session_max_age parameter if a global setting is viable, else place an explicit TTL in the cookie (e.g.  validity_period="start_time, duration") that can be verified by the application each time the Client presents the SCS cookie.</li>
<li>Session voidance scenario (explicit invalidation): put a randomly chosen string into each SCS cookie (cid="$(random())") and keep a list of valid session cid's against which the SCS cookie presented by the client can be checked. When a cookie needs to be invalidated, delete the corresponding cid from the list. The described method has the drawback that, in case a non-permanent storage is used to archive valid cid's, a reboot/restart would invalidate all sessions (It can't be used when |S| &gt; 1).</li>
<li>One-shot transaction scenario (ephemeral): this is a variation on the previous theme when sessions are consumed within a single request/response. Put a nonce="$(random())" within the state information and keep a list of not-yet-consumed nonces in RAM. Once the client presents its cookie credential, the embodied nonce is deleted from the list and will be therefore discarded whenever replayed.</li>
</ul>
<p id="rfc.section.7.2.1.p.8">It may be noteworthy that despite the chances of preventing replay in some well established circumstances by using aforementioned mechanisms, if the attacker is able to use the cookie before the legitimate client gets a chance to, then the impersonation attack will always succeed.</p>
<h1 id="rfc.section.7.2.2">
<a href="#rfc.section.7.2.2">7.2.2.</a> <a href="#sec_cookie_deletion" id="sec_cookie_deletion">Cookie Deletion</a>
</h1>
<p id="rfc.section.7.2.2.p.1">A direct, and important, consequence of the missing owner role in SCS is that a client could intentionally delete its cookie and return nothing.</p>
<p id="rfc.section.7.2.2.p.2">The application protocol has to be designed so there is no incentive to do so, for instance: </p>

<ul>
<li>it is safe for the cookie to represent some kind of positive capability - the possession of which increases the client's powers;</li>
<li>It is not safe to use the cookie to represent negative capabilities - where possession reduces the client's powers-, or for revocation.</li>
</ul>
<p id="rfc.section.7.2.2.p.3">Note that this behavior is not equivalent to cookie removal in the "server-side" cookie model, because in case of missing cookie backup by other parties (e.g. the application using SCS), the Client could simply make it disappear once and for all.</p>
<h1 id="rfc.section.7.2.3">
<a href="#rfc.section.7.2.3">7.2.3.</a> <a href="#sec_cookie_sharing_or_theft" id="sec_cookie_sharing_or_theft">Cookie Sharing or Theft</a>
</h1>
<p id="rfc.section.7.2.3.p.1">SCS doesn't prevent sharing (both voluntary and illegitimate) of cookies between multiple clients.</p>
<p id="rfc.section.7.2.3.p.2">In the context of voluntary cookie sharing, using HTTPS is useless: Client certificates are just as shareable as cookies, hence equivalently to the "server-side" cookie model, there seems to be no way to prevent this threat.</p>
<p id="rfc.section.7.2.3.p.3">The theft could be mitigated by securing the wire (e.g. via HTTPS, IPsec, VPN, ...), thus reducing the opportunity of cookie stealing to a successful attack on the protocol endpoints.</p>
<h1 id="rfc.section.7.3">
<a href="#rfc.section.7.3">7.3.</a> <a href="#sec_advantages" id="sec_advantages">Advantages of SCS over Server-side Sessions</a>
</h1>
<p id="rfc.section.7.3.p.1">Note that all the abovementioned vulnerabilities also apply to typical server-side sessions, making SCS at least as secure (based on the current analysis), but there are a few good reasons to consider its security level enhanced.</p>
<p id="rfc.section.7.3.p.2">First of all, the confidentiality feature provided by SCS protects cookie state information which is normally plain-text.</p>
<p id="rfc.section.7.3.p.3">Furthermore, none of the common vulnerabilities of server-side sessions (SID prediction, SID brute forcing, session fixation <a href="#Kolsec">[Kolsec]</a>) can be exploited when using SCS, unless the attacker possesses encryption and HMAC keys (both current ones and those relating to the previous set of credentials).</p>
<p id="rfc.section.7.3.p.4">More generally no slicing nor altering operations can be done over an SCS PDU without controlling the cryptographic keyset and cipherset.</p>
<h1 id="rfc.references">
<a href="#rfc.references">8.</a> References</h1>
<h1 id="rfc.references.1">
<a href="#rfc.references.1">8.1.</a> Normative References</h1>
<table><tbody>
<tr>
<td class="reference"><b id="RFC2119">[RFC2119]</b></td>
<td class="top">
<a href="mailto:sob@harvard.edu" title="Harvard University">Bradner, S.</a>, "<a href="http://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>", BCP 14, RFC 2119, March 1997.</td>
</tr>
<tr>
<td class="reference"><b id="RFC4648">[RFC4648]</b></td>
<td class="top">
<a>Josefsson, S.</a>, "<a href="http://tools.ietf.org/html/rfc4648">The Base16, Base32, and Base64 Data Encodings</a>", RFC 4648, October 2006.</td>
</tr>
<tr>
<td class="reference"><b id="RFC1951">[RFC1951]</b></td>
<td class="top">
<a href="mailto:ghost@aladdin.com" title="Aladdin Enterprises">Deutsch, P.</a>, "<a href="http://tools.ietf.org/html/rfc1951">DEFLATE Compressed Data Format Specification version 1.3</a>", RFC 1951, May 1996.</td>
</tr>
<tr>
<td class="reference"><b id="RFC4086">[RFC4086]</b></td>
<td class="top">
<a>Eastlake, D.</a>, <a>Schiller, J.</a> and <a>S. Crocker</a>, "<a href="http://tools.ietf.org/html/rfc4086">Randomness Requirements for Security</a>", BCP 106, RFC 4086, June 2005.</td>
</tr>
<tr>
<td class="reference"><b id="RFC2104">[RFC2104]</b></td>
<td class="top">
<a href="mailto:hugo@watson.ibm.com" title="IBM, T.J. Watson Research Center">Krawczyk, H.</a>, <a href="mailto:mihir@cs.ucsd.edu" title="University of California at San Diego, Dept of Computer Science and Engineering">Bellare, M.</a> and <a href="mailto:canetti@watson.ibm.com" title="IBM T.J. Watson Research Center">R. Canetti</a>, "<a href="http://tools.ietf.org/html/rfc2104">HMAC: Keyed-Hashing for Message Authentication</a>", RFC 2104, February 1997.</td>
</tr>
<tr>
<td class="reference"><b id="RFC5652">[RFC5652]</b></td>
<td class="top">
<a>Housley, R.</a>, "<a href="http://tools.ietf.org/html/rfc5652">Cryptographic Message Syntax (CMS)</a>", STD 70, RFC 5652, September 2009.</td>
</tr>
<tr>
<td class="reference"><b id="I-D.ietf-httpstate-cookie">[I-D.ietf-httpstate-cookie]</b></td>
<td class="top">
<a>Barth, A</a>, "<a href="http://tools.ietf.org/html/draft-ietf-httpstate-cookie-22">HTTP State Management Mechanism</a>", Internet-Draft draft-ietf-httpstate-cookie-22, February 2011.</td>
</tr>
</tbody></table>
<h1 id="rfc.references.2">
<a href="#rfc.references.2">8.2.</a> Informative References</h1>
<table><tbody>
<tr>
<td class="reference"><b id="RFC5246">[RFC5246]</b></td>
<td class="top">
<a>Dierks, T.</a> and <a>E. Rescorla</a>, "<a href="http://tools.ietf.org/html/rfc5246">The Transport Layer Security (TLS) Protocol Version 1.2</a>", RFC 5246, August 2008.</td>
</tr>
<tr>
<td class="reference"><b id="RFC3740">[RFC3740]</b></td>
<td class="top">
<a>Hardjono, T.</a> and <a>B. Weis</a>, "<a href="http://tools.ietf.org/html/rfc3740">The Multicast Group Security Architecture</a>", RFC 3740, March 2004.</td>
</tr>
<tr>
<td class="reference"><b id="RFC4418">[RFC4418]</b></td>
<td class="top">
<a>Krovetz, T.</a>, "<a href="http://tools.ietf.org/html/rfc4418">UMAC: Message Authentication Code using Universal Hashing</a>", RFC 4418, March 2006.</td>
</tr>
<tr>
<td class="reference"><b id="RFC4301">[RFC4301]</b></td>
<td class="top">
<a>Kent, S.</a> and <a>K. Seo</a>, "<a href="http://tools.ietf.org/html/rfc4301">Security Architecture for the Internet Protocol</a>", RFC 4301, December 2005.</td>
</tr>
<tr>
<td class="reference"><b id="Bellare">[Bellare]</b></td>
<td class="top">
<a>Bellare, M.B.</a>, "<a>New Proofs for NMAC and HMAC: Security Without Collision-Resistance</a>", 2006.</td>
</tr>
<tr>
<td class="reference"><b id="Kohno">[Kohno]</b></td>
<td class="top">
<a>Kohno, T.K.</a>, <a>Palacio, A.P.</a> and <a>J.B. Black</a>, "<a>Building Secure Cryptographic Transforms, or How to Encrypt and MAC</a>", 2003.</td>
</tr>
<tr>
<td class="reference"><b id="Kolsec">[Kolsec]</b></td>
<td class="top">
<a>Kolsec, M.K.</a>, "<a>Session Fixation Vulnerability in Web-based Applications</a>", 2002.</td>
</tr>
</tbody></table>
<h1 id="rfc.appendix.Appendix A">
<a href="#rfc.appendix.Appendix%20A">Appendix A.</a> <a href="#ref-impl" id="ref-impl">Reference Implementation</a>
</h1>
<p id="rfc.section.Appendix A.p.1">A reference implementation (at present in very early stage) of the SCS protocol can be found at <a href="http://github.com/koanlogic/libscs">http://github.com/koanlogic/libscs</a>.</p>
<h1 id="rfc.authors"><a href="#rfc.authors">Authors' Addresses</a></h1>
<div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Stefano Barbato</span> 
	  <span class="n hidden">
		<span class="family-name">Barbato</span>
	  </span>
	</span>
	<span class="org vcardline">KoanLogic</span>
	<span class="adr">
	  <span>Via Marmolada, 4</span>

	  <span class="vcardline">
		<span class="locality">Vitorchiano (VT)</span>,  
		<span class="region"></span>
		<span class="code">01030</span>
	  </span>
	  <span class="country-name vcardline">Italy</span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:tat@koanlogic.com">tat@koanlogic.com</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Steven Dorigotti</span> 
	  <span class="n hidden">
		<span class="family-name">Dorigotti</span>
	  </span>
	</span>
	<span class="org vcardline">KoanLogic</span>
	<span class="adr">
	  <span>Via Maso della Pieve 25/C</span>

	  <span class="vcardline">
		<span class="locality">Bolzano</span>,  
		<span class="region"></span>
		<span class="code">39100</span>
	  </span>
	  <span class="country-name vcardline">Italy</span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:stewy@koanlogic.com">stewy@koanlogic.com</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Thomas Fossati</span> editor
	  <span class="n hidden">
		<span class="family-name">Fossati</span>
	  </span>
	</span>
	<span class="org vcardline">KoanLogic</span>
	<span class="adr">
	  <span>Via di Sabbiuno 11/5</span>

	  <span class="vcardline">
		<span class="locality">Bologna</span>,  
		<span class="region"></span>
		<span class="code">40139</span>
	  </span>
	  <span class="country-name vcardline">Italy</span>
	</span>
	<span class="vcardline">Phone: +39 051 644 82 68</span>

<span class="vcardline">EMail: <a href="mailto:tho@koanlogic.com">tho@koanlogic.com</a></span>

  </address>
</div>

</body>
</html>