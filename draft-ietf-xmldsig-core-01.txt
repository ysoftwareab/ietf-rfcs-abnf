XML Digital Signatures Working Group               D. Eastlake,
INTERNET-DRAFT                                     IBM
draft-ietf-xmldsig-core-01.txt                       J. Reagle,
Expires April 22, 2000                             W3C/MIT
                                                   D. Solo,
                                                   Citigroup

                    XML-Signature Core Syntax and Processing
                                      
Copyright Notice

   Copyright (c) 1999 The Internet Society & W3C (MIT, INRIA, Keio), All
   Rights Reserved.
   
IETF Status of this Memo

   This document is an Internet-Draft and is in full conformance with all
   provisions of Section 10 of RFC2026.
   
   Internet-Drafts are working documents of the Internet Engineering Task
   Force (IETF), its areas, and its working groups. Note that other
   groups may also distribute working documents as Internet-Drafts.
   
   Internet-Drafts are draft documents valid for a maximum of six months
   and may be updated, replaced, or obsoleted by other documents at any
   time. It is inappropriate to use Internet- Drafts as reference
   material or to cite them other than as "work in progress."
   
   The list of current Internet-Drafts can be accessed at
   http://www.ietf.org/ietf/1id-abstracts.txt
   
   The list of Internet-Draft Shadow Directories can be accessed at
   http://www.ietf.org/shadow.html.
   
W3C Status of this document

   This document is a production of the joint IETF/W3C XML Signature
   Working Group.
   
   http://www.w3.org/Signature
   
   The comparable html draft of this version may be found at
   
   http://www.w3.org/TR/1999/WD-xmldsig-core-19991022
   
   The latest version of this draft series may be found at:
   
   http://www.w3.org/TR/xmldsig-core
   
   This is the second (and rough) public draft of this specification.
   This draft covers most of the topics the final specification will
   cover, however parts of the text and syntax within this specification
   are subject to change (and may be incorrect or inconsistent.)
   
   Please send comments to the editors and cc: the list


Eastlake, Reagle, Solo							[Page 1]


Internet Draft		XML-Signature Core Syntax	October 1999

   <w3c-ietf-xmldsig@w3.org>. Publication as a Working Draft does not
   imply endorsement by the W3C membership or IESG. This is a draft
   document and may be updated, replaced or obsoleted by other documents
   at any time. It is inappropriate to cite W3C Drafts as other than
   "work in progress." A list of current W3C working drafts can be found
   at http://www.w3.org/TR
   
   Patent disclosures relevant to this specification may be found on the
   WG's patent disclosure page.
   
Abstract

   This document specifies the syntax and processing rules for the
   encoding of digital signatures using XML. Such signatures can provide
   integrity, message authentication, and/or signer authentication
   services for data of any type, whether located within the XML that
   includes the signature or locatable elsewhere.
   
Table of Contents

     1. Introduction
          1.1 Editorial Conventions
          1.2 Design Philosophy
          1.3 Versions
     2.  Signature Overview
          2.1 The Signature Element
          2.2 The SignedInfo Element
          2.3 The ObjectReference Element
          2.4 The Manifest and Package Elements
     3. Core Signature Syntax
          3.1 The Signature element
          3.2 The SignatureValue Element
          3.3 The SignedInfo Element
          3.4 The KeyInfo Element
          3.5 The Object Element
          3.6 The Parameter Element
     4. Additional Signature Syntax
          4.1 The Manifest and Package Elements
          4.2 The Properties Element
          4.3 Processing Instructions
          4.4 Comments in dsig Elements
     5. Algorithms
          5.1 Algorithm Identifiers and Requirements
          5.2 Message Digests
          5.3 Message Authentication Codes
          5.4 Signature Algorithms
          5.5 Canonicalization Algorithms
          5.6 Transform Algorithms
          5.7. Algorithm References
     6. Processing rules
          6.1 Generation
          6.2 Signature Validation
     7. Security Considerations

Eastlake, Reagle, Solo							[Page 2]


Internet Draft		XML-Signature Core Syntax	October 1999

          7.1 Only What is Signed is Secure
          7.2 Only What is "Seen" Should be Signed
          7.3 Check the Security Model
          7.4 Algorithms, Key Lengths, Etc.
     8. Example syntax
     9. DTD
     10. Open Issues
     11. Acknowledgements
     12. Other Useful Types
     13. References
       
1 Introduction

   This document describes the proposed syntax and processing rules for
   the XML Digital Signature specification. This specification provides a
   mechanism for applying digital signatures to XML documents and other
   Internet resources and encoding those signatures as XML.
   
   The structure allows for both embedded and detached signatures. An
   embedded signature can include the signature within the signed object
   or embed the signed object within the signature. A detached signature
   allows the signature to be independent of the object. The processing
   structure allows for switching between embedded and detached
   signatures without necessailry invalidating the signature.
   
   In addition to the basic signature type, this document also defines
   other useful types including methods of referencing multiple resources
   and key management and algorithm definitions.
   
  1.1 Editorial Conventions
  
   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
   document are to be interpreted as described in [RFC2119].
   
   The XML namespace [XML-namespace] URI that MUST be used by
   experimental implementations of this dated specification is:
   
   xmlns="http://www.w3.org/1999/10/signature-core"
   
   While applications MUST support XML-namespaces, the use of our "dsig"
   XML namespace prefix and defaulting/scoping conventions are OPTIONAL
   -- we use these facilities so as to provide compact and readable
   examples.
   
   The URI in the namespace declaration above is also used as a prefix
   for URIs which identify resources, algorithms, or semantics under
   control of this specification. We use MIME types to identify
   algorithms, resources, or their characteristics under the control of
   IANA. Otherwise we define a URN Namespace Identifiers [RFC2141] for
   other organizations, for example: urn:ietf-org:hmac-sha1
   
   This document includes the following abbreviations for long words.

Eastlake, Reagle, Solo							[Page 3]


Internet Draft		XML-Signature Core Syntax	October 1999


   (The acronyms are generated by wrapping the word_length-2 in the first
   and last letter):
     * c14n: canonicalization
     * i18n: internationalization
       
   Finally, this document includes a list of open issues which are still
   being addressed by the working group.
   
   Readers unfamiliar with DTD syntax may wish to refer to Ron Bourret's
   "Declaring Elements and Attributes in an XML DTD."
   
  1.2 Design Philosophy
  
   The design philosophy and requirements of this specification are
   addressed in the XML-Signature Requirements document
   [XML-Signature-RD].
   
  1.3 Versions
  
   No provision is made for an explicit version number in this syntax. If
   a future version is needed, it is expected to use a different
   Namespace.
   
2 Signature Overview

   This section provides a general top down overview of XML digital
   signature syntax and processing. The formal specification is provided
   in later sections. General familiarity with digital signature concepts
   and XML syntax is assumed.
   
  2.1 The Signature Element
  
   XML digital signatures are very flexible and may be used to apply
   signatures to any type of resource. The object(s) being signed may be
   included within the signature, outside the signature in the same
   document, or completely outside of the document.
   
   XML digital signatures are represented by the Signature element which
   has the following structure:
   
   <Signature>
     (SignedInfo)
     (SignatureValue)
     (KeyInfo)?
     (Object)*
   </Signature>
   
   The required SignedInfo element is the information which is actually
   signed. SignedInfo includes a digest calculated over each of the data
   objects being signed. The core signature verification includes the
   verification of these digests. The algorithms used in calculating the
   SignatureValue are also included in the signed information. The
   signature can not cover itself so the SignatureValue element is

Eastlake, Reagle, Solo							[Page 4]


Internet Draft		XML-Signature Core Syntax	October 1999


   outside SignedInfo.
   
   KeyInfo indicates what key was used to create the signature. It is
   optional because in some applications the key is implied by the
   circumstances. A wide variety of KeyInfo forms are available including
   certificates, key names, key agreement algorithms and information,
   etc. The keying information is outside of the signed information so
   that it need not be signed. KeyInfo might contain auxiliary
   information it is not desired to reveal to all signature verifiers. If
   KeyInfo were signed, it would be necessary to pass all of it to all
   verifiers. On the other hand, if it is desired to bind the keying
   information in to the signature, its digest and a pointer to it can
   easily be included in the signed information.
   
   Object is an optional element for carrying the signed data. A
   signature can be applied to a mix of external and embedded objects.
   The data can be optionally typed and/or encoded. While Object elements
   can appear inside a signature as shown above, they can also appear
   outside of the Signature element in the same document or in other
   documents.
   
   There is no explicit provision for additional signature properties
   such as time of signing. (These are traditional called "attributes"
   although that term in that context has no relationship to the XML term
   "attribute".) Signature properties can be included as a type of Object
   and thus can easily be signed or not as appropriate.
   
  2.2 The SignedInfo Element
  
   The SignedInfo element has the structure indicated below.
   
   <Signature>
     <SignedInfo>
       (CanonicalizationMethod)
       (SignatureMethod)
       (ObjectReference)+
     </SignedInfo>
     (SignatureValue)
     (KeyInfo)?
     (Object)*
   </Signature>
   
   The CanonicalizationMethod is the algorithm which is used to
   canonicalize the SignedInfo element before it is digested as part of
   the signature operation. [The working group is considering specifying
   a fixed CanonicalizationMethod which would eliminate the need for this
   element.]
   
   The SignatureMethod is the algorithm used to convert the canonicalized
   SignedInfo into the SignatureValue. It is a combination of a digest
   algorithm and a key dependent algorithm such as RSA-SHA1 or HMAC-SHA1.
   The algorithm names are signed to resist attacks based on substituting
   a weaker algorithm.

Eastlake, Reagle, Solo							[Page 5]


Internet Draft		XML-Signature Core Syntax	October 1999


   
   To promote interoperability, there are mandatory to implement
   canonicalization and signature algorithms. Additional standard
   algorithms are specified as Recommended or Optional and user defined
   algorithms are permitted.
   
   The ObjectReference elements specify the things secured by the
   signature. As discussed in more detail below, they point to the thing,
   specify any transformations, specify the digest algorithm, and include
   the digest value itself. It is the signing of this digest value and
   its verification as part of the signature verification that secures
   the thing pointed to.
   
   The indirect reference to secured things via the ObjectReference means
   that it is possible to change a Signature from one where the data in
   enclosed as an Object within the Signature to one where the Object
   appears elsewhere or to move a secure item between locations outside a
   Signature without invalidating the signature provided the secured data
   can still be located from the same ObjectReference.
   
  2.3 The ObjectReference Element
  
   The ObjectReference element has the structure indicated below.
   
   ...
   <SignedInfo>
      (CanonicalizationMethod)?
      (SignatureMethod)
      <ObjectReference Location=? Type=? >
        (Transforms)?
        (DigestMethod)
        (DigestValue)
      </ObjectReference>+
   </SignedInfo>
   ...
   
   The optional Location attribute says where the secured thing is.
   
   The optional Type attribute provides information about the content of
   the thing at Location. In particular, it can indicate that the thing
   consists of signature Properties or is a Manifest or Package (see
   below).
   
   Transforms is an optional ordered list of processing steps that are
   applied to the thing at Location before it is digested. These
   transforms can include any number of canonicalizations, encoding and
   decoding including compression and inflation, and XPath based and
   other transforms. XPath based transforms permit parts of an XML thing
   to be omitted. For example, if a thing being secured encloses the
   signature itself, such a transform must be used to exclude the
   signature from the data covered. If no Transforms element is present,
   the data pointed at by Location is digested directly.
   

Eastlake, Reagle, Solo							[Page 6]


Internet Draft		XML-Signature Core Syntax	October 1999


   To promote interoperability, there are mandatory to implement
   canonicalization and decoding algorithms. Additional standard
   canonicalization, coding, and XPath based transform algorithms are
   specified as Recommended or Optional and user defined transform
   algorithms are permitted.
   
   DigestMethod is the algorithm which, when applied to the thing at
   Location after Transforms is applied, results in DigestValue. The
   signing of the DigestValue is what secures the thing pointed to.
   
  2.4 The Manifest and Package Elements
  
   There are cases where it is efficient to have one signature covering
   many items. One approach is to include multiple object references
   within SignedInfo. Since the core verification behavior of this
   specification includes verifying the digests of objects referenced
   within SignedInfo, some applications may need an alternative approach
   which allows pushing the validation decision to the application. This
   allows more complex processing to be defined on an application
   specific basis; for example, it may be sufficient if the signature's
   validity for n out of m of the items can be verified or there may be a
   large number of items that it is desired to sign with multiple
   signature algorithms and / or keys where listing all of the items
   within the SignedInfo element of each Signature is too bulky.
   
   To answer these requirements, additional object types have been
   defined which may be referenced by SignedInfo. The Manifest element is
   provided which similarly contains a collection of references and
   objects (like SignedInfo), but leaves it entirely up to the
   application which digest or digests it will verify. Multiple
   signatures over the possibly large number of items in a Manifest need
   only point to the Manifest from one ObjectReference in each
   signature's SignedInfo.
   
   The structure of Manifest, which reuses the ObjectReference and Object
   elements described above, is as follows:
   
   <Manifest>
     (ObjectReference)+
     (Object)*
   </Manifest>
   
   A Package is syntactically identical to a Manifest but asserts the
   identity of each of its ObjectReference elements after Transforms
   application.
   
   Manifest and Package appear as the content of Objects.
   
3 Core Signature Syntax

   The general structure of an XML signature is described in section 2
   above. This section provides detailed syntax of the core signature
   features and actual exampes (TBD). Syntax in this section is mandatory

Eastlake, Reagle, Solo							[Page 7]


Internet Draft		XML-Signature Core Syntax	October 1999


   to implement unless othewise indicated.
   
  3.1 The Signature element
  
   <!ELEMENT Signature (SignedInfo, SignatureValue, KeyInfo?, Object*)>
   <!ATTLIST SignedInfo
             Id     ID       #IMPLIED>
   
   A simple example follows:
   
   <Signature xmlns="http://www.w3.org/1999/10/signature-core">
     <SignedInfo>
       <CanonicalizationMethod
   Algorithm="http://www.w3.org/.../xml-c14n"/>
       <SignatureMethod Algorithm="dsig:dsaWithSHA-1"/>
       <ObjectReference Location="http://www.ietf.org">
         <DigestMethod Algorithm="urn:nist-gov:sha1"/>
         <DigestValue
   encoding="urn:ietf-org:base64">a23bcd43</DigestValue>
       </ObjectReference>
     </SignedInfo>
     <SignatureValue
   encoding="urn:ietf-org:base64">dd2323dd</SignatureValue>
     <KeyInfo>
        <keyname>Solo</keyname>
     </KeyInfo>
   </Signature>
   
   Note: this example will be revised to ensure hash/signature validate.
   
  3.2 The SignatureValue Element
  
   The SignatureValue element contains the actual value of the digital
   signature. The ability to define a SignatureMethod and SignatureValue
   pair which includes multiple distinct signatures is explicitly
   permitted (e.g. "rsawithsha-1 and ecdsawithsha-1").
   
   <!ELEMENT SignatureValue CDATA >
   <!-- base64 encoded signature value -->
   <!ATTLIST SignatureValue
             encoding    CDATA     "urn:ietf-org:base64" >
   
  3.3 The SignedInfo Element
  
   The structure of SignedInfo includes a canonicalization algorithm, a
   signature algorithm, and one or more references to objects. The
   SignedInfo element may contain an optional ID attribute that will
   allow it to be referenced by other signatures and objects.
   
   <!ELEMENT SignedInfo(CanonicalizationMethod, SignatureMethod,
   ObjectReference+ ) >
   <!ATTLIST SignedInfo
             Id     ID       #IMPLIED >

Eastlake, Reagle, Solo							[Page 8]


Internet Draft		XML-Signature Core Syntax	October 1999


   
   SignedInfo does not include explicit signature properties. If an
   application needs to associate properties (such as signing time,
   signing device, etc.) with the signature, it may add an additional
   Object that includes that data and reference that Object via an
   ObjectReference. See the Properties element below.
   
    3.3.1 The CanonicalizationMethodElement
    
   CanonicalizationMethod is a mandatory element which specifies the
   canonicalization algorithm applied to the SignedInfo element prior to
   performing signature calculations. This element uses the general
   structure here for algorithms in which a URI is included as an
   attribute naming the algorithm and optional Parameter contents of the
   element contain any parameter, value, or other information for the
   algorithm. Possible options may include a minimal algorithm (CRLF and
   charset normalization), or more extensive operations such as
   [XML-C14N]. An expected default for this value will be defined once
   the specification of XML aware canonicalization algorithms are
   finalized.
   
   <!ELEMENT CanonicalizationMethod Parameter* >
   <!ATTLIST CanonicalizationMethod
             Algorithm  CDATA    #REQUIRED >
        <!-- Where CDATA conforms to the
             productions specified by [URI] -->
   
   [The working group is considering specifying a fixed
   CanonicalizationMethod which would eliminate the need for this
   element.]
   
    3.3.2 The SignatureMethod Element
    
   SignatureMethod is a required element which specifies the algorithm
   used for signature generation and validation. This algorithm
   identifies all cryptographic functions involved in the signature
   operation (e.g. hashing, public key algorithms, MACs, etc.). This
   element uses the general structure here for algorithms in which a URI
   is included as an attribute naming the algorithm and optional
   Parameter contents of the element contain any parameter, value, or
   other information for the algorithm. While there is a single
   identifier, that identifier may specify a format containing multiple
   distinct signature values.
   
   <!ELEMENT SignatureMethod Parameter* >
   <!ATTLIST SignatureMethod
             Algorithm  CDATA    #REQUIRED >
        <!-- Where CDATA conforms to the
             productions specified by [URI] -->
   
    3.3.3 The ObjectReference Element
    
   ObjectReference is an element that may occur one or more times. It

Eastlake, Reagle, Solo							[Page 9]


Internet Draft		XML-Signature Core Syntax	October 1999


   includes a pointer to the object being signed, the type of the object,
   an optional list of transforms to be applied prior to digesting, a
   digest algorithm and digest value.
   
   <!ELEMENT ObjectReference ( Transforms?, DigestMethod, DigestValue ) >
   <!ATTLIST ObjectReference
             Id        ID       #IMPLIED
             Location  CDATA    #IMPLIED>
             Type      CDATA    #IMPLIED>
   <!-- The values of Location and Type conform
          to the productions specified by [URI] -->
   
   There is an optional ID attribute so that it can be referenced from
   elsewhere.
   
   The optional Location attribute identifies where to find the Object
   using a URI. As the terms are defined in RFC2396 [URI], some URIs are
   used in conjunction with a fragment identifier by use of a separating
   hash (#), but the URI does not include the fragment identifier.
   Location only permits a URI, and fragment identification is covered
   under Transforms. Note that a null URI is proper an indicates the
   current document (Location=""). If this attribute is omitted, then the
   receiving application is expected to be able to determine the object
   to which the signature applies. For example, this attribute might be
   omitted for a signature in a lightweight protocol data unit. The
   location may be omitted only if there is a single object reference. If
   there are multiple object references, they each must contain an
   explicit location. Note, it is the content yielded after the URI is
   dereferenced, decoded, and transformed that the digest algorithm is
   applied to. If the URI indicates an XML document, the document is
   assumed to be unparsed prior to the application of Transforms. If
   there are no Transforms, then the indicated resource is passed to the
   digest algorithm unmodified.
   
   The optional Type attribute contains information about the type of
   object being signed (e.g. manifest, package, document, SignedInfo.
   This is represented as a URI.
   
   Examples follow:
   
   Type="http://www.w3.org/1999/10/signature-core/manifest"
   Type="urn:ietf-org:hmac-sha1"
   
    3.3.3.1 The Transforms Element
    
   Transforms is an optional element that contains one or more operations
   to be performed on an indicated resource prior to digest calculation.
   (These operations are different from those specified in the Signature;
   those are are applied over SignedInfo.) If the Transforms element is
   omitted, the exact data referenced is digested byte for byte.
   
   The Transforms element contains an ordered list of Transform elements.
   The output of each Transform serves as input to the next Transform.

Eastlake, Reagle, Solo							[Page 10]


Internet Draft		XML-Signature Core Syntax	October 1999


   The input to the first Transform is the raw data result of obtaining
   the resource given by the Location attrbiute or as determined by the
   application if no Location is meaningful for that application. The
   output from the last Transform is the input for the digest algorithm.
   
   <!ELEMENT Transforms (Transformation+) >
   
   Each Transform consists of an Algorithm attribute, optional Encoding,
   Type, and Charset attributes, and content appropriate for the given
   algorithm. The Algorithm attribute value specifies the name of the
   algorithm to be performed, and the Transform content is provided as
   additional data to govern the algorithm's processing of the input
   resource. If the Encoding attribute indicates that the Transform
   content is base 64 encoded, then the Transform content will be base-64
   decoded before it is presented to the transformation algorithm.
   
   The optional Type and Charset attributes are made available to
   algorithms which need and are otherwise unable to deduce that
   inforamtion about the data they are processing.
   
   <!ELEMENT Transform ANY>
   <!ATTLIST Transform
             Algorithm   CDATA    #REQUIRED
             Encoding    CDATA    #IMPLIED
             Type        CDATA    #IMPLIED
             Charset     CDATA    #IMPLIED >
   <!-- The CDATA for Algoirhtm and Encoding conforms
       to the productions specified by [URI] -->
   
   Examples of resource transforms include but are not limited to base-64
   decoding, canonicalization, XPath filtering, and XSLT. The generic
   definition of the Transform element also allows application-specific
   transform algorithms. For example, the transform could be a
   decompression routine given by a base-64 encoded Java class appearing
   in the Transform content. However, applications should refrain from
   using application-specific transforms whenever possible since the
   resulting signature will not necessarily be verifiable outside of the
   application domain. The section Transform Algorithms defines the list
   of standard transformations.
   
   Implementation Comment: When transformations are applied the signer is
   not signing the native (original) document but the resulting
   (transformed) document that is not captured explicitly in the
   signature syntax.
   
    3.3.3.2 The DigestMethod Element
    
   DigestMethod is a required element which identifies the digest
   algorithm to be applied to the signed object. This element uses the
   general structure here for algorithms in which a URI is included as an
   attribute naming the algorithm and optional Parameter contents of the
   element contain any parameter, value, or other information for the
   algorithm.

Eastlake, Reagle, Solo							[Page 11]


Internet Draft		XML-Signature Core Syntax	October 1999


   
   <!ELEMENT DigestMethod Parameter* >
   <!ATTLIST DigestMethod
             Algorithm  CDATA   #REQUIRED >
        <!-- Where CDATA conforms to the
             productions specified by [URI] -->
   
    3.3.3.3 The DigestValue Element
    
   DigestValue is an element which contains the base64 encoded value of
   the digest.
   
   <!ELEMENT DigestValue CDATA>
   <!-- base64 encoded signature value -->
   <!ATTLIST DigestValue
             Encoding    CDATA     "urn:ietf-org:base64">
   
  3.4 The KeyInfo Element
  
   KeyInfo may contain keys, names, certificates and other public key
   management information (such as inband key distribution or agreement
   data or data supporting any other method.) This specification defines
   a few simple types but applications may place (embed) their own key
   identification and exchange semantics within this element through the
   XML-namespace facility. [XML-namespace]
   
   <!ELEMENT KeyInfo  (#PCDATA | (KeyName | KeyValue |
             SubjectName | RetrievalMethod | x509Data |
             PGPData | MgmtData)* )>
   
   KeyInfo is an optional element which enables the recipient(s) to
   obtain the key(s) needed to validate the signature. If omitted, the
   recipient is expected to be able to identify the key based on
   application context information. This element contains one KeyInfo
   data element providing information for the recipient(s). Applications
   may define and use any mechanism they choose through inclusion of
   elements from a different namespace.
   
   Compliant versions implementing KeyInfo MUST implement KeyValue, and
   SHOULD implement RetrievalMethod.
     * KeyName contains an identifier for the key which may be useful to
       the recipient. This may be a name, index, etc.
     * KeyValue contains the actual key(s) used to validate the
       signature. If the key is sent in protected form, the MgmtData
       element should be used. Specific types must be defined for each
       algorithm type (see algorithms).
     * SubjectName contains one or more names for the sender. Forms to be
       supported include a simple name string, encoded DN, email address,
       etc.
     * RetrievalMethod is a URI which may be used to obtain key and/or
       certificate information. The URI should contain the complete
       string for retrieving the key needed for this message (rather than
       a generic URI).

Eastlake, Reagle, Solo							[Page 12]


Internet Draft		XML-Signature Core Syntax	October 1999


     * X509Data contains an identifier of the key/cert used for
       validation (either an IssuerSerial value, a subject name, or a
       subjectkeyID) and an optional collection of certificates and
       revocation/status information which may be used by the recipient.
       IssuerSerial contains the encoded issuer name (RFC 2253) along
       with the serial number.
     * PGPData data associated with a PGP key.
     * MgmtData contains in-band key distribution or agreement data.
       Examples may include DH key exchange, RSA key encryption etc.
       
   <!ELEMENT KeyValue ANY>
   <!ELEMENT KeyName (#PCDATA) >
   <!ELEMENT SubjectName (#PCDATA) >
   <!ELEMENT RetrievalMethod (#PCDATA) >
   <!ELEMENT X509Data ((X509IssuerSerial | X509SKI | X509Name),
                       (X509Certificate | X509CRL | ANY)* ) >
   <!ELEMENT MgmtData (#PCDATA)>
   <!ELEMENT PGPData (PGPKeyID, PGPKeyPacket?)>
   
   <!ELEMENT X509IssuerSerial (X509Name, X509SerialNumber)>
   <!ELEMENT X509Name (#PCDATA)>
   <!-- Where the name is encoded accroding to RFC 2253 -->
   <!ELEMENT X509SerialNumber (#PCDATA)>
   <!-- Where the data is the serial number encoded as a decimal integer
   -->
   <!ELEMENT X509SKI (#PCDATA)>
   <!-- Where the data consists of the SKI base64 encoded -->
   <!ELEMENT X509Certificate (#PCDATA)>
   <!-- Where the data conists of the base64 encoded certificate -->
   <!ELEMENT X509CRL (#PCDATA)>
   <!-- Where the data consists of the base64 encoded CRL -->
   
   <!ELEMENT PGPKeyID (#PCDATA)>
   <!-- Where the data conists of the hex encoding of the key ID. -->
   <!ELEMENT PGPKeyPacket (#PCDATA)>
   <!-- Where the data consists of the base64 encoded key packet --->
   
   Note:  This section is preliminary. A more detailed version will be
   included in a subsequent version of this specification.
   
  3.5 The Object Element
  
   Object is an optional element which may occur one or more times. When
   present this element may contain any item and specifies the encoding.
   The digest is calculated over the entire Object element including
   start and end tags. If the application wishes to exclude the <Object>
   tags from the digest calculation, then a transform must be used.
   Exclusion of the object tags may be desired for cases where the
   signature is intended to survive a change between embedded and
   detached objects or where the content of the Object is an encoding of
   an original binary document and it is desired to extract and decode so
   as to sign the original as closely as possible.
   

Eastlake, Reagle, Solo							[Page 13]


Internet Draft		XML-Signature Core Syntax	October 1999


   <!ELEMENT Object ANY>
   <!ATTLIST Object
             Id        ID       #IMPLIED
             Type      CDATA    #IMPLIED
             Encoding  CDATA    #IMPLIED >
        <!-- Where type and encoding CDATA conforms to the
             productions specified by [URI] -->
   
   The Object's ID is referenced from the ObjectReference in SignedInfo.
   This element is used for embedded signatures where the object being
   signed is to be included in the signature document. The Object element
   may include optional type, ID, and encoding attributes.
   
  3.6 The Parameter Element
  
   Algorithms are provided with parameters and input data, when
   necessary, by having Parameter elements in the content of the
   algorithm element. Algorithms also have an implicit input such as the
   canonicalized SignedInfo for SignatureMethod and the tranformed data
   pointed to for DigestMethod.
   
   Where more than one Parameter appears, they are passed to the
   algorithm as an ordered vector corresponding to the order they appear
   in the algorithm element content.
   
   <!ELEMENT Parameter #PCDATA>
   <!ATTLIST Parameter
             Encoding  CDATA    #IMPLIED >
   <!-- Encoding CDATA conforms to the productions
          specified by [URI] -->
   
4 Additional Signature Syntax

   This section describes the optional to implement Manifest and Package
   elements and describes the handling of XML Processing Instructions and
   Comments.
   
  4.1 The Manifest and Package Elements
  
   The Manifest element provides a list of ObjectReferences. The
   difference from the list in SignedInfo is that it is application
   defined which, if any, of the digests are actually checked against the
   objects referenced and what to do if the object is inaccessible or the
   digest compare fails. If a Manifest is pointed to from SignedInfo, the
   digest over the Manifest itself will be checked by the core signture
   verifciation behavior. The digests within such a Manifest are checked
   at application discretion. If a Manifest is referenced from another
   Manifest, even the overall digest of this two level deep Manifest
   might not be checked.
   
   A Package has the same syntax as a Manifest but also asserts the
   equality of each of its referenced objects, after any transforms. The
   testing of this equality and action if it fails is also entirely at

Eastlake, Reagle, Solo							[Page 14]


Internet Draft		XML-Signature Core Syntax	October 1999


   the discretion of the applicaiton.
   
   <!ELEMENT Manifest ( ObjectReference+, Object* ) >
   <!ATTLIST Manifest
             Id     ID       #IMPLIED >
   <!ELEMENT Package ( ObjectReference+, Object* ) >
   <!ATTLIST Package
             Id     ID       #IMPLIED >
   
  4.2 The Properties Element
  
   Additional information concerning the signature overall or as it
   applied to particular ObjectReferences can be placed in a Properties
   element inside an Object. This should be such information as signing
   time or the serial number of crypto hardware used. Additional
   information concerning data being signed should be with that data.
   
   <!ELEMENT Property ANY >
   <!ATTLIST Property
             Target   IDREF    #REQUIRED >
   
  4.3 Processing Instructions
  
   TDB - will specify the use, if any, of XML processing instructions by
   this specification and the handling of PIs appearing within elements
   specified in this document.
   
  4.4 Comments in dsig Elements
  
   TDB - will specify the use, if any, and handling of XML comments
   appearing within elements specified in this document.
   
5 Algorithms

   This section identifies algorithms used with the XML digital signature
   standard. Entries contain the identifier to be used in signature
   documents, a reference to the formal specification, and definitions,
   where applicable, for the representation of keys and the results of
   cryptographic operations.
   
  5.1 Algorithm Identifiers and Requirements
  
   The specification defines a set of algorithms, their URIs, and
   requirements for implementation. Requirements are specified over
   implementation, not over requirements for signature use. Furthermore,
   the mechanism is extensible, alternative algorithms may be used by
   signature applications.
   
   Algorithm Type Algorithm Requirements Algorithm URI URN Derivation
   Digest
     SHA1 REQUIRED urn:nist-gov:sha1 IOTP
   Encoding
     Base64 REQUIRED urn:ietf-org:base64 suggested

Eastlake, Reagle, Solo							[Page 15]


Internet Draft		XML-Signature Core Syntax	October 1999


   MAC
     HMAC-SHA1 REQUIRED urn:ietf-org:hmac-sha1 extrapolated from IOTP
   Signature
     DSAwithSHA1 (DSS) REQUIRED urn:nist-gov:dsa IOTP
     RSAwithSHA1 RECOMMENDED urn:rsasdi-com:rsa-sha1 extrapolated from
   IOTP
     ECDSA OPTIONAL urn:nist-gov:ecdsa extrapolated from IOTP
   Canonicalization
     minimal REQUIRED http://www.w3.org/1999/10/signature-core/minimal
   suggested W3C
     XML-Canonicalization RECOMMENDED
   http://www.w3.org/1999/07/WD-xml-c14n-19990729 W3C
   Transform
     XSLT RECOMMENDED http://www.w3.org/TR/1999/PR-xslt-19991008 W3C
     XPath RECOMMENDED http://www.w3.org/TR/1999/PR-xpath-19991008 W3C
     XPointer RECOMMENDED http://www.w3.org/1999/07/WD-xptr-19990709 W3C
   
  5.2 Message Digests
  
    5.2.1 SHA-1
    
   The SHA-1 algorithm identifier is urn:nist-gov:sha1. The SHA-1
   algorithm takes no parameters. An example of an SHA-1 DigestAlg
   element is
   
   <DigestMethod Algorithm="urn:nist-gov:sha1"/>
   
   An SHA-1 digest is a 160-bit string. The content of the DigestValue
   element shall be the base64 encoding of this bit string viewed as a
   20-octet octet stream. Example: the DigestValue element for the
   message digest
   
   A9993E36 4706816A BA3E2571 7850C26C 9CD0D89D
   
   from Appendix A of the SHA-1 standard would be
   
   <DigestValue>qZk+NkcGgWq6PiVxeFDCbJzQ2J0=</DigestValue>
   
  5.3 Message Authentication Codes
  
    5.3.1 HMAC
    
   The HMAC algorithm identifiers are urn:ietf-org:hmac-sha1 and
   urn:ietf-org:hmac-md5. The HMAC algorithm takes the truncation length
   in bits as a parameter (parameter identifier
   urn:ietf-org:hmac-outputlength).   An example of an HMAC
   SignatureMethod element:
   
   <SignatureMethod Algorithm="urn:ietf-org:hmac-sha1">
     <Parameter type="urn:ietf-org:hmac-outputlength">
        128
     </Parameter>
   </SignatureMethod>

Eastlake, Reagle, Solo							[Page 16]


Internet Draft		XML-Signature Core Syntax	October 1999


   
   The output of the HMAC algorithm is ultimately the output (possibly
   truncated) of the chosen digest algorithm. This value shall be base64
   encoded in the same straightforward fashion as the output of the
   digest algorithms. Example: the SignatureValue element for the
   HMAC-MD5 digest
   
   9294727A 3638BB1C 13F48EF8 158BFC9D
   
   from the test vectors in [RFC 2104] would be
   
   <SignatureValue>kpRyejY4uxwT9I74FYv8nQ==</SignatureValue>
   
  5.4 Signature Algorithms
  
    5.4.1 DSA
    
   The DSA algorithm identifier is urn:nist-gov:dsa. The DSA algorithm
   takes no parameters. An example of a DSA SignatureMethod element is
   
   <SignatureMethod Algorithm="urn:nist-gov:dsa"/>
   
   The output of the DSA algorithm consists of a pair of integers usually
   referred by the pair (r, s). The signature value shall consist of the
   base64 encoding of the concatenation of two octet-streams that
   respectively result from the octet-encoding of the values r and s.
   Integer to octet-stream conversion shall be done according to the
   I2OSP operation defined in the PKCS #1 specification with a k
   parameter equal to 20. Example: the SignatureValue element for a DSA
   signature (r, s) with values specified in hexadecimal
   
   r = 8BAC1AB6 6410435C B7181F95 B16AB97C 92B341C0
   s = 41E2345F 1F56DF24 58F426D1 55B4BA2D B6DCD8C8
   
   from the example in Appendix 5 of the DSS standard would be
   
   <SignatureValue>i6watmQQQ1y3GB+VsWq5fJKzQcBB4jRfH1bfJFj0JtFVtLotttzYyA
   ==</SignatureValue>
   
   DSA key values have the following set of fields: P, Q, G and Y are
   mandatory when appearing as a key value, J, seed and pgenCounter are
   optional but SHOULD be present. (The seed and pgenCounter fields MUST
   both either appear or be absent). All parameters are encoded as base64
   values.
   
   <!ELEMENT DssKeyValue (P, Q, G, Y, J?, (seed, pgenCounter)?) >
   <!-- Each of these fields consists a CDATA where the data is base64
   encoded -->
   
    5.4.2 RSA
    
   The expression "RSA algorithm" as used in this document refers to the
   RSASSA-PKCS1-v1_5 algorithm described in RFC 2437.

Eastlake, Reagle, Solo							[Page 17]


Internet Draft		XML-Signature Core Syntax	October 1999


   
   The RSA algorithm identifiers are urn:rsasdi-com:rsa-sha1 and
   urn:rsasdi-com:rsa-md5. The RSA algorithm takes no parameters. An
   example of an RSA SignatureMethod element is
   
   <SignatureMethod name="urn:rsasdi-com:rsa-sha1"/>
   
   The output of the RSA algorithm is an octet string. The SignatureValue
   content for an RSA signature shall be the base64 encoding of this
   octet string. Example: TBD
   
   RSA key values have two fields: Modulus and Exponent.
   
   <!ELEMENT RSAKeyValue ( Modulus, Exponent ) > <!-- Each field contains
   a CDATA which is the value for that item base64 encoded -->
   
    5.4.3 ECDSA
    
   The expression ECDSA as used in this document refers to the signature
   algorithms specified in ANSI X9.62.  Additional details are to be
   provided.
   
  5.5 Canonicalization Algorithms
  
    5.5.1 Null Canonicalization
    
   Null canonicalization, i.e., no modification whatsoever, can be
   achieved for signed data by simply not putting any canonicalization in
   the Transforms element (omitting it entirely if no other tranforms are
   needed).
   
    5.5.2 Minimal Canonicalization
    
   The algorithm identifier for the minimal canonicalization is
   http://www.w3.org/1999/10/signature-core/minimal. An example of a
   minimal canonicalization CanonicalizationAlg element is
   
   <CanonicalizationMethod
   name="http://www.w3.org/1999/10/signature-core/minimal"/>
   
   The minimal canonicalization algorithm:
     * converts the character encoding to UTF-8, removing the encoding
       pseudo-attribute
     * normalizes line endings
       
   This algorithm is only applicable to XML resources.
   
    5.5.3 Canonical XML
    
   The algorithm identifier for XML canonicalization is
   http://www.w3.org/1999/07/WD-xml-c14n-19990729. An example of an XML
   canonicalization CanonicalizationAlg element is
   

Eastlake, Reagle, Solo							[Page 18]


Internet Draft		XML-Signature Core Syntax	October 1999


   <CanonicalizationMethod
   name="http://www.w3.org/1999/07/WD-xml-c14n-19990729"/>
   
   See the Canonical XML specification.
   
  5.6 Transform Algorithms
  
   Application developers are strongly encouraged to support all
   transforms listed in this section as RECOMMENDED unless the
   application environment has severe resource constraints that would
   make such support impractical. The working group goal is to maximize
   application interoperability on XML signatures, and the working group
   expects ubiquitous availability of software to support these
   transforms that can be incorporated into applications without
   extensive development.
   
    5.6.1 Canonicalization
    
   The Algorithm value for canonicalization is defined above.
   
   The Transform element content MUST include a Canonicalization element,
   which specifies the canonicalization algorithm that will be applied to
   the input of the Transform element.
   
    5.6.2 Base-64 Decoding
    
   The Algorithm value for the base 64 decoding transform is
   urn:ietf-org:base64.
   
   The base-64 decoding algorithm identifier is urn:ietf-org:base64.
   
   The base-64 Transform element has no content. The input (from the
   Location or from the previous Transform) is base-64 decoded by this
   algorithm. This transform is useful if an application needs to sign
   the raw data associated with base-64 encoded content of an element.
   
    5.6.3 XPath Filtering
    
   The Algorithm value for the XPath filtering transform is
   "http://www.w3.org/TR/1999/PR-xpath-19991008"
   
   The Transform element content MUST conform to the XML Path Language
   (XPath) syntax.
   
   XPath assumes that an XML processor has processed the input resource.
   So, for example, entity reference expansion, normalization of
   linefeeds and attribute values are normalized, and CDATA section
   replacement are expected. As well, XPath joins all consecutive
   characters into a single text node.
   
   The input resource MUST be a well-formed XML document. The result of
   applying the XPath to the input resource MUST be a node-set (as
   defined in XPath). The output of this transform is a new XML document

Eastlake, Reagle, Solo							[Page 19]


Internet Draft		XML-Signature Core Syntax	October 1999


   with the following characteristics:
    1. The output document has the XML declaration of the input resource
       (see rule 23 XMLDecl in XML specification). If the encoding is
       UTF-16, the output document has the same byte order mark as the
       input resource.
    2. The output document contains the nodes in the node-set identified
       by the XPath, and excludes the nodes of the input resource that
       are not not in the node-set identified by the XPath.
    3. The nodes in the output document appear in the document order (as
       defined in XPath) of the input resource.
    4. The output document has all of the input resource's entity
       references expanded, except that characters corresponding to
       illegal XML are reencoded as character references (XML rule 66)
       except the ampersand and less than symbol, which are encoded using
       &amp; and &lt;, respectively.
    5. Attribute values are normalized in accordance with the rules for a
       validating XML processor (even if the implementation did not use a
       validating XML processor to parse the input resource).
       
   It is RECOMMENDED that the XPath be constructed such that the result
   of this operation is a well-formed XML document. This should be the
   case if root element of the input resource is included by the XPath
   (even if a number of its descendant elements and attributes are
   omitted by the XPath).
   
    5.6.4 XPointer Filtering
    
   The Algorithm value for the XPointer filtering transform is
   "http://www.w3.org/1999/07/WD-xptr-19990709".
   
   The Transform element content MUST conform to the XML Pointer Language
   (XPointer) syntax.
   
   The processing rules for XPointer filtering are identical to those for
   XPath filtering (stated above), except that the additional
   functionality offered by XPointer can be utilized in constructing the
   output node-set.
   
   The XPointer filter is particularly important if the input resource is
   processed by a validating XML processor since the XPointer barename
   shortcut could then be used to implement the well-known fragment
   identification by ID attribute.
   
   NOTE: In application environments with severe resource limitations,
   applications MAY constrain XPointer support to barename processing and
   also to determination of the ID attribute by means other than a
   validating XML processor. In fact, the use of an XML processor for
   barename resolution is OPTIONAL. However, the output expectations of
   this transform MUST be supported by the application.
   
    5.6.5 XSLT Transform
    
   The Algorithm value for the XSLT transform is

Eastlake, Reagle, Solo							[Page 20]


Internet Draft		XML-Signature Core Syntax	October 1999


   "http://www.w3.org/TR/1999/PR-xslt-19991008"
   
   The Transform element content MUST conform to the XSL Transforms
   (XSLT) language syntax.
   
   The processing rules for the XSLT transform are stated in the XSLT
   specification.
   
    5.6.6 Java Transform
    
   The Algorithm value for the Java transform is urn:ECMA-org:java.
   
   Details to be determined.
   
   Although the Algorithm attribute of a Transform can take
   application-specific values, having a Java transform seems to be the
   most reasonable way to allow application-specific transforms that can
   be processed outside of the application domain.
   
  5.7 Algorithm References
  
   Base64
          RFC 2045. Multipurpose Internet Mail Extensions (MIME) Part
          One: Format of Internet Message Bodies. N. Freed & N.
          Borenstein. DRAFT STANDARD.
          http://www.ietf.org/rfc/rfc2045.txt
          
   DSS
          FIPS PUB 186-1. Digital Signature Standard (DSS). U.S.
          Department of Commerce/National Institute of Standards and
          Technology.
          http://www.ietf.org/rfc/rfc2104.txt
          
   HMAC
          RFC 2104. HMAC: Keyed-Hashing for Message Authentication. H.
          Krawczyk, M. Bellare, R. Canetti. INFORMATIONAL.
          
   MD5
          RFC 1321. The MD5 Message-Digest Algorithm. R. Rivest.
          INFORMATIONAL.
          http://www.ietf.org/rfc/rfc1321.
          
   RSA
          RFC 2437. PKCS #1: RSA Cryptography Specifications Version 2.0.
          B. Kaliski, J. Staddon. INFORMATIONAL.
          http://www.ietf.org/rfc/rfc2432.txt
          
   SHA-1
          FIPS PUB 180-1. Secure Hash Standard. U.S. Department of
          Commerce/National Institute of Standards and Technology.
          http://csrc.nist.gov/fips/fip180-1.pdf
          
   URNs

Eastlake, Reagle, Solo							[Page 21]


Internet Draft		XML-Signature Core Syntax	October 1999


          RFC 2141. URN Syntax. R. Moats. PROPOSED STANDARD.
          ftp://ftp.isi.edu/in-notes/rfc2141.txt
          RFC 2611. URN Namespace Definition Mechanisms. L. Daigle, D.
          van Gulik, R. Iannella, P. Falstrom. BEST CURRENT PRACTICE.
          ftp://ftp.isi.edu/in-notes/rfc2611.txt
          
   XML-Canonicalization
          Canonical XML. W3C Working Draft
          http://www.w3.org/1999/07/WD-xml-c14n-19990729
          
   XPath
          XML Path Language (XPath)Version 1.0. W3C Proposed
          Recommendation
          http://www.w3.org/TR/1999/PR-xpath-19991008
          
   XPointer
          XML Pointer Language (XPointer). W3C Working Draft.
          http://www.w3.org/1999/07/WD-xptr-19990709
          
   XSL
          Extensible Stylesheet Language (XSL) W3C Working Draft
          http://www.w3.org/TR/1999/WD-xsl-19990421
          
   XSLT
          XSL Transforms (XSLT) Version 1.0. W3C Proposed Recommendation
          http://www.w3.org/TR/1999/PR-xslt-19991008
          
6 Processing rules

   These sections describe the operations to be performed as part of
   signature generation and validation. The description is of a logical
   behavior and does not specify an order of execution, nor specify
   discrete steps.
   
  6.1 Generation
  
    1. apply Transforms determined by application to each object being
       signed.
    2. calculate digest over each transformed object (including start and
       end tags)
    3. create ObjectReference element(s) including location of object,
       digest, digest algorithm, and transform elements, if required.
    4. create SignedInfo element with SignatureMethod,
       CanonicalizationMethod, and ObjectReference(s).
    5. canonicalize and calculate signature over SignedInfo based on
       algorithms in step 4.
    6. construct signature document with SignedInfo, Object (s) (if
       desired, encoding may be different than that used for signing),
       KeyInfo (if required), and SignatureValue.
       
  6.2 Signature Validation
  
    1. locate object and apply Transforms  to the specified resource

Eastlake, Reagle, Solo							[Page 22]


Internet Draft		XML-Signature Core Syntax	October 1999


       based on each ObjectReference(s) in the SignedInfo element.  Each
       transform is applied in order from left to right to the object
       with the output of each transform being the input to the next.
    2. calculate digest over each transformed signed object(s) (including
       start and end tags) based on the algorithm in ObjectReference(s).
    3. compare value against DigestValue in SignedInfo for each reference
       (if any mismatch, validation fails).
    4. canonicalize the SignedInfo element based on the
       CanonicalizationMethod in SignedInfo.
    5. obtain the validation keying info from KeyInfo or externally.
    6. validate the SignatureValue based on the SignatureMethod in the
       SignedInfo element, the key obtained in step 5, and the results of
       step 4. - Digest calculation is performed over the SignedInfo
       element including start and end tags.
       
   Any processing beyond cryptographic validation (e.g. certificate
   validation, applicability decisions, time related processing) is
   outside the scope of this specification.
   
7 Security Considerations

   The XML digital signature standard provides a very flexible mechanism.
   In designing a system to make use of it, due consideration should be
   given to the threat model being defended against and to the factors
   covered in the subsections below.
   
  7.1 Only What is Signed is Secure
  
   The flexible Transforms mechanism, including canonicalization and
   explicit filtering and extraction, permit securing only a subset of
   data in an object. This is good for many applications where a limited
   portion of an object must change after the signature or different
   signatures secure different parts or the application modifies aspects
   of the object that are not significant and can be omitted from
   signature coverage or the like. Keep in mind that whenever this is
   done, those aspects that are not signed can be arbitrarily modified
   and the signature will still validate.
   
  7.2 Only What is "Seen" Should be Signed
  
   If signing is intended to convey the judgment or consent of an
   automated mechanism or person concerning some information, then it is
   normally necessary to secure as exactly as possible the information
   that was presented to that mechanism or person. Note that this can be
   accomplished by literally signing what was presented, for example the
   screen images shown a user. However, this may result in data which it
   is difficult for subsequent software to manipulate. It can be
   effective instead to secure the full data along with whatever filters,
   style sheets, or the like were used to control the part of the
   information that was presented.
   
  7.3 Check the Security Model
  

Eastlake, Reagle, Solo							[Page 23]


Internet Draft		XML-Signature Core Syntax	October 1999


   This standard specifies public key signatures and secret key keyed
   hash authentication codes. These have substantially different security
   models. Furthermore, it permits user specified additions which may
   have other models.
   
   With public key signatures, any number of parties can hold the public
   key and verify signatures while only the parties with the secret key
   can create signatures. The number of holders of the secret key should
   be minimized and preferably be one. Confidence by verifiers in the
   public key they are using and its binding to the entity or
   capabilities represented by the corresponding secret key is an
   important issue, usually addressed by certificate or on line authority
   systems.
   
   Keyed hash authentication codes, based on secret keys, are typically
   much more efficient in terms of the computational effort required but
   have the characteristic that all verifiers need to have possession of
   the same key as the signer. Thus any verifier can forge signatures.
   
   This standard permits user provided signature algorithms and keying
   information designators. Such user provided algorithms may have
   further different security models. For example, methods involving
   biometrics usually depend on a "key" which is a physical
   characteristic of the user and thus can not be changed the way public
   or secret keys can be and may have other security model differences.
   
  7.4 7.4 Algorithms, Key Lengths, Etc.
  
   The strength of a particular signature depends on all links in the
   security chain. This includes the signature and digest algorithms
   used, the strength of the key generation [RFC 1750] and the size of
   the key, the security of key and certificate authentication and
   distribution mechanisms, protection of all cryptographic processing
   from hostile observation and tampering, etc. The security of an
   overall system would also depend on the security and integrity of its
   operating procedures, its personnel, and on the administrative
   enforcement of those procedures. The factors listed in this paragraph,
   while critical to the overall security of a system, are mostly beyond
   the scope of this document.
   
8 Example syntax

   <Signature xmlns="http://www.w3.org/1999/10/signature-core">
     <SignedInfo Id="5">
       <CanonicalizationMethod
   Algorithm="http://www.w3.org/.../xml-c14n"/>
       <SignatureMethod Algorithm="urn:nist-gov:dsa"/>
       <ObjectReference Location="...">
           <!-- pointer to external signedobject   -->
         <Transforms>
            <Transform
   Algorithm="http://www.w3.org/1999/10/signature-core/null">
            <Encoding Algorithm="urn:ietf-org:base64"/>

Eastlake, Reagle, Solo							[Page 24]


Internet Draft		XML-Signature Core Syntax	October 1999


         </Transforms>
         <DigestMethod Algorithm="urn:nist-gov:sha1"/>
         <DigestValue>a23bcd43"</DigestValue>
       </ObjectReference>
       <ObjectReference Locations="#timestamp"
   
   Type="http://www.w3.org/1999/10/signature-core/signatureattributes">
   <!-- points to Object below -->
         <Transforms>
            <CanonicalizationMethod name="http://..."/>
         </Transforms>
         <DigestMethod Algorithm="urn:nist-gov:sha1"/>
         <DigestValue>a53uud43"</DigestValue>
       </ObjectReference>
     </SignedInfo>
     <SignatureValue
   encoding="urn:ietf-org:base64">dd2323dd</SignatureValue>
     <Object ID="timestamp"
   
   type="http://www.w3.org/1999/10/signature-core/signatureattributes " >
       <timestamp about="#5" xmlns="http://www.ietf.org/rfc/1234">
         <date>19990908</date>
         <time>14:34:34:34</time>
       </timestamp>
     </Object>
     <KeyInfo>
        <keyname>Solo</keyname>
     </KeyInfo>
   </Signature>
   
9 DTD

   [TBD: Combined DTD]
   
10 Open Issues

    1. Additional review is required on use of the dsig namespace; other
       use of namespaces; specification of types; etc.
    2. Need to review Default CanonicalizationMethod algorithms for
       SignedInfo and for objects. Other defaults. Mandatory to implement
       cryptographic algorithms.
    3. Much more detail for KeyInfo types.
    4. Make sure we are consistent with respect to types, algorithm IDs,
       URIs, etc.
    5. The signature data structures specified in this document are not
       yet associated with a data model.
       
11 Acknowledgements

     * Milton Anderson, FSTC
     * Mark Bartel, JetForm Corporation (Author)
     * John Boyer, UWI.com (Author)
     * Richard Brown, Globeset

Eastlake, Reagle, Solo							[Page 25]


Internet Draft		XML-Signature Core Syntax	October 1999


     * Donald Eastlake 3rd, IBM (Chair, Editor)
     * Barb Fox, Microsoft (Author)
     * Phillip Hallam-Baker, VeriSign Inc
     * Richard Himes, US Courts
     * Joseph Reagle, W3C (Chair, Editor)
     * Ed Simon , Entrust Technologies Inc.
     * Chris Smithies, PenOp
     * David Solo, Citigroup (Editor)
     * Winchel Todd Vincent III, GSU
     * Greg Whitehead, Signio Inc.
       
12 12.0 Other Useful Types

   We define the following types for use in identifying XML resources
   that include Signture semantics.
   
   http://www.w3.org/1999/10/signature-core/signatureproperties
          designates that the referenced resource is a statement about
          the referring signature.
          
   http://www.w3.org/1999/10/signature-core/manifest
          designates that the referenced resource is a collection of
          other resources.
          
   http://www.w3.org/1999/10/signature-core/package
          designates that the referenced resources is a collection of
          other resources and the creator of that collection asserts that
          the specified resources, when transformed as specified, yield
          the same exact content.
          
13 References

   Other references can be found in section 5.7.
   
   DOMHASH
          Internet Draft. Digest Values for DOM (DOMHASH)
          http://search.ietf.org/internet-drafts/draft-hiroshi-dom-hash-0
          1.txt .
          
   RDF
          RDF Schema
          http://www.w3.org/TR/1999/PR-rdf-schema-19990303
          RDF Model and Syntax
          http://www.w3.org/TR/1999/REC-rdf-syntax-19990222
          
   [RFC1750]
          RFC1750 -- Randomness Recommendations for Security.
          http://www.ietf.org/rfc/rfc1750.txt
          
   [RFC2119]
          RFC2119 -- Key words for use in RFCs to Indicate Requirement
          Levels.
          http://www.ietf.org/rfc/rfc2119.txt

Eastlake, Reagle, Solo							[Page 26]


Internet Draft		XML-Signature Core Syntax	October 1999


          
   URI
          Uniform Resource Identifiers (URI): Generic Syntax
          http://www.ietf.org/rfc/rfc2396.txt
          
   XLink
          XML Linking Language
          http://www.w3.org/1999/07/WD-xlink-19990726
          
   XML
          Extensible Markup Language (XML) Recommendation.
          http://www.w3.org/TR/1998/REC-xml-19980210
          
   XML-namespace
          Namespaces in XML
          http://www.w3.org/TR/1999/REC-xml-names-19990114
          
   XML-schema
          XML Schema Part 1: Structures
          http://www.w3.org/1999/05/06-xmlschema-1/
          XML Schema Part 2: Datatypes
          http://www.w3.org/1999/05/06-xmlschema-2/
          
   XML-Signature-RD
          XML-Signature Requirements
          http://www.w3.org/1999/08/WD-xmldsig-requirements-990820
          
   WebData
          Web Architecture: Describing and Exchanging Data.
          http://www.w3.org/1999/04/WebData























Eastlake, Reagle, Solo							[Page 27]

