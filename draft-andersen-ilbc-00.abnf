FILTERORDER=10 LPC filter coefficients using the autocorrelation 
i=0,...,119 
lag=0,...,FILTERORDER; n=0,...,BLOCKL-lag 
    
i=1,...,FILTERORDER 
    
i=0,....BLOCKL-1 
    
i=0,...,FILTERORDER-1 
         e[i] = lsf1[i] - lsfmean[i] - lsfhat[i]; i=0,...,FILTERORDER-1 
    
i=0,...,FILTERORDER-1 
    
     
nsub=1,...,NSUB-1  
base_size=lMem-lTarget+1; 
cb_index=0; 
alfa1=(float)1.0/(float)ilen; 
alfa=0.0; 
max_measure = (float)-10000000.0; 
best_index = 0; 
    
crossDot=0.0; 
invDot=0.0; 
invDot = (float)1.0/(invDot+EPS); 
    
measure = crossDot*crossDot*invDot; 
    
best_index = cb_index; 
max_measure = measure; 
gain = crossDot*invDot; 
base_index = best_index; 
sInd=base_index-RESRANGE/2; 
eInd = sInd+RESRANGE; 
eInd=base_size-1; 
sInd=eInd-RESRANGE; 
gain = crossDot*invDot;  
    
correction_factor = sqrt( (Ee/Eet)  / (Ess/Esst) );  
    
index=(int)(correction_factor*16)-1; 
LMEM=147 adaptive codebook memory are filled with the samples of the 
e = sum_{m=-W, m!=0}^{m=W} a_m z^T x_m, (1) 
    
y = sum_{m=-W, m!=0}^{m=W} a_m x_m, (4) 
    
z =  y sqrt( x_0^T x_0 / (y^T y)). (5) 
     
z= Ay + B x_0 (6)  
     
A = sqrt((b-b^2/4)  x_0^T x_0/(y^Ty - (y^T x_0)^2/(x_0^T x_0))) (7) 
    
B = 1 - b/2 - A (y^T x_0)/(x_0^T x_0). (8) 
    
dtmp=decblock[k]; 
dtmp=MIN_SAMPLE; 
dtmp=MAX_SAMPLE; 
starttime=clock()/(float)CLOCKS_PER_SEC;  
    
runtime = (float)(clock()/(float)CLOCKS_PER_SEC-starttime); 
outtime = (float)((float)blockcount* 
           (float)TIME_PER_FRAME/1000.0); 
start = FrameClassify(residual);   
        
diff = STATE_LEN - STATE_SHORT_LEN; 
en1 = 0; 
index = (start-1)*SUBL; 
en2 = 0; 
index = (start-1)*SUBL+diff; 
state_first = 1; 
start_pos = (start-1)*SUBL; 
state_first = 0; 
start_pos = (start-1)*SUBL + diff; 
meml_gotten = STATE_SHORT_LEN; 
subcount=0; 
    
Nfor = NSUB-start-1; 
Nback = start-1; 
meml_gotten = SUBL*(NSUB+1-start); 
gc_index =  gaincorr_Encode(decresidual, start_pos,  
           gainadjusttarget); 
    
    
pbytes=bytes; 
diff = STATE_LEN - STATE_SHORT_LEN; 
meml_gotten = STATE_SHORT_LEN; 
subcount=0; 
    
Nfor = NSUB-start-1; 
Nback = start-1; 
meml_gotten = SUBL*(NSUB+1-start); 
factor=(float)(gc_index+1)/(float)16.0; 
std_decresidual = 0.0; 
std_decresidual = (float)sqrt(std_decresidual); 
    
one_minus_factor_scaled =  
              (float)sqrt(1-factor*factor)*std_decresidual; 
gaussstart =  
              (int)ceil(decresidual[0]) % (GAUSS_NOISE_L-BLOCKL); 
pbytes=bytes; 
check=LSF_check(lsfunq, FILTERORDER, LPC_N); 
start=0; 
            
order_plus_one = FILTERORDER + 1; 
pi = &In[0]; 
po = &Out[0]; 
    
cb_index=0; 
ppe=energy; 
    
k=cbveclen; 
pp=mem+lMem-k; 
pp=mem+lMem-cbveclen-1; 
ppo=mem+lMem-1; 
ilow=0; 
ihigh=k/2-1; 
ilen=ihigh-ilow+1; 
pp=mem+lMem-k/2; 
alfa1=(float)1.0/(float)ilen; 
alfa=0.0; 
pp=cb+cb_index*cbveclen+ilow; 
     
ppo=mem+lMem-k/2+ilow; 
ppi=mem+lMem-k+ilow; 
pp=mem+lMem-k+ihigh+1; 
cb_index = createSection(cb, invenergy, mem, lMem, cbveclen); 
    
accum=0.0; 
memInd=k+1-CBHALFFILT; 
sInd=0; 
     
eInd=CBFILTLEN; 
pp=mem+sInd+memInd; pp1=&cbfilters[filtno-1][sInd]; 
k = createSection(cb+cb_index*cbveclen, invenergy+cb_index,  
               tmpbuf, lMem, cbveclen); 
ftmp1 = 0.0; 
ftmp2 = 0.0; 
lag=inlag; 
lag=(*iLBCdec_inst).prevLag; 
gain=(*iLBCdec_inst).prevGain; 
pitchfact = YT_MIX; 
pitchfact = YB_MIX; 
pitchfact = YB_MIX + (gain - XB_MIX) *  
                   (YT_MIX - YB_MIX) / (XT_MIX - XB_MIX); 
            
randlag = 50 + ((signed long) (*iLBCdec_inst).seed)%70; 
pick = i - randlag; 
pick = i - lag; 
gain=0.0; 
ftmp=BWEXPAND; 
lag = (*iLBCdec_inst).prevLag; 
gain = (*iLBCdec_inst).prevGain; 
            
pitchfact = YT_MIX; 
pitchfact = YB_MIX; 
pitchfact = YB_MIX + (gain - XB_MIX) *  
                       (YT_MIX - YB_MIX) / (XT_MIX - XB_MIX); 
    
randlag = 50 + ((signed long)  
                       (*iLBCdec_inst).seed)%70; 
                    
pick = i - randlag; 
pick = i - lag; 
offset = 3*SUBL; 
ftmp1 = (float) (i+1) / (float) (offset+1); 
ftmp = (float)1.0 - ftmp1; 
crit=array[0]-value; 
bestcrit=crit*crit; 
crit=array[i]-value; 
crit=crit*crit; 
bestcrit=crit; 
filterlength=2*hfl+1; 
filterlength=%d > dim1=%d\n", filterlength, dim1); */ 
    
hfl2=(int) (dim1/2); 
hfl=hfl2; 
filterlength=2*hfl+1; 
pu=useq1; 
pp = polyp[j]; 
ps = seq1+i; 
pp = polyp[j]; 
ps = seq1+i; 
pp = polyp[j]+q; 
ps = seq1+dim1-1; 
bl=(int)(bl0 - 0.5); 
slop = (int) (0.15*period+0.5); 
e=b+blockl-1; 
bll0=bl-slop; if(bll0<0){ bll0=0;} 
bll1=bl+slop; if(bll1+blockl >= idatal){ bll1=idatal-blockl-1;} 
     
corrdim=bll1-bll0+1; 
            
tloc=0; maxv=corr33[0]; 
tloc=i; 
maxv=corr33[i]; 
tloc2=(int)(tloc/ENH_UPS0); if(tloc>tloc2*ENH_UPS0){tloc2++;} 
st=bll0+tloc2-ENH_FL0; 
vectl=blockl+2*ENH_FL0; 
en=st+vectl; 
fraction=tloc2*ENH_UPS0-tloc; 
        
psseq=sseq+k*blockl;  
psseq=sseq+k*blockl;  
w00 = w10 = w11 = 0.0; 
psseq=sseq+hl*blockl; /* current block ("x_0" in patent) */ 
C = (float)sqrt( w00/w11); 
        
errs=0.0; 
psseq=sseq+hl*blockl; 
err=psseq[i]-odata[i]; 
denom = (w11*w00-w10*w10)/(w00*w00); 
A = (float)sqrt( (alpha0- alpha0*alpha0/4)/denom); 
B = -alpha0/2 - A * w10/w00; 
B = B+1; 
A= 0.0; 
B= 1.0; 
psseq=sseq+hl*blockl; 
e=b+blockl-1; 
hblockl=(int)(0.5*blockl); 
        
psseq=sseq+blockl*hl;  
psseq=sseq+q*blockl;  
psseq=sseq+q*blockl;  
ftmp1 = 0.0; 
ftmp2 = 0.0; 
enh_buf=(*iLBCdec_inst).enh_buf; 
enh_period=(*iLBCdec_inst).enh_period; 
        
lag = 20; 
maxcc = xCorrCoef(enh_buf+(ENH_NBLOCKS_EXTRA+iblock)* 
               ENH_BLOCKL, enh_buf+(ENH_NBLOCKS_EXTRA+iblock)* 
               ENH_BLOCKL-lag, ENH_BLOCKL); 
cc = xCorrCoef(enh_buf+(ENH_NBLOCKS_EXTRA+iblock)* 
                   ENH_BLOCKL, enh_buf+(ENH_NBLOCKS_EXTRA+iblock)* 
                   ENH_BLOCKL-ilag, ENH_BLOCKL); 
maxcc = cc; 
lag = ilag; 
max_ssq = -1.0; 
k = n*SUBL + l; 
max_ssq = ssq[n]; 
max_ssq_n = n; 
residual_energy = 0.0, dec_residual_energy = 0.0; 
state_loss_factor = dec_state_energy / state_energy; 
residual_loss_factor = dec_residual_energy / residual_energy; 
correction_factor = (float)sqrt(residual_loss_factor /  
           state_loss_factor); 
    
index=(int)(correction_factor*16)-1; 
factor=(float)(index+1)/(float)16.0; 
std_decresidual = (float)sqrt(dec_residual_energy); 
    
one_minus_factor_scaled =  
              (float)sqrt(1-factor*factor)*std_decresidual; 
gaussstart =  
              (int)ceil(decresidual[0]) % (GAUSS_NOISE_L-BLOCKL); 
scale=maxIn; 
cb = gain_sq3; 
cb = gain_sq4; 
    
minmeasure=10000.0; 
measure=(in-scale*cb[i])*(in-scale*cb[i]); 
tindex=i; 
minmeasure=measure; 
scale=(float)fabs(maxIn); 
base_size=lMem-cbveclen+1; 
k=index+cbveclen; 
k=2*(index-(lMem-cbveclen+1))+cbveclen; 
    
ilow=0; 
ihigh=k/2-1; 
ilen=ihigh-ilow+1; 
alfa1=(float)1.0/(float)ilen; 
alfa=0.0; 
filtno=index/base_size; 
    
k=index-filtno*base_size+cbveclen; 
    
sFilt=lMem-k; 
eFilt=lMem-k+cbveclen; 
accum=0.0; 
memInd=n+1-CBHALFFILT; 
sInd=0; 
eInd=CBFILTLEN; 
k=2*(index-filtno*base_size-(lMem-cbveclen+1))+cbveclen; 
    
sFilt=lMem-k; 
eFilt=lMem; 
accum=0.0; 
memInd=n+1-CBHALFFILT; 
sInd=0; 
eInd=CBFILTLEN; 
ilow=0; 
ihigh=k/2-1; 
ilen=ihigh-ilow+1; 
alfa1=(float)1.0/(float)ilen; 
alfa=0.0; 
sum = 0; 
alpha = r[0] + r[1] * k[0]; 
sum = r[m + 1]; 
m_h = (m + 1) >> 1; 
sum = a[i+1] + k[m] * a[m - i]; 
invcoef = (float)1.0 - coef; 
chirp = coef; 
        
pos = 0; 
mindist = FLOAT_MAX; 
dist = X[0] - CB[pos]; 
tmp = X[i] - CB[pos + i]; 
mindist = dist; 
minindex = j; 
cb_pos = 0; 
X_pos= 0; 
i = 0; 
pos=m*dim+k; 
tmp=lsf[pos+1]; 
change=1; 
change=1; 
change=1; 
pi = &In[0]; 
po = &Out[0]; 
po = &Out[0]; 
pi = &In[0]; 
po = &Out[0]; 
po = &Out[0]; 
base_size=lMem-lTarget+1; 
base_size=lMem-lTarget+1+lTarget/2; 
    
max_measure = (float)-10000000.0; 
best_index = 0; 
    
crossDot=0.0; 
pp = cb+icount*lTarget; 
measure=(float)-10000000.0; 
measure = crossDot*crossDot*invenergy[icount]; 
measure = crossDot*crossDot*invenergy[icount]; 
best_index = icount; 
max_measure = measure; 
gain = crossDot*invenergy[icount]; 
base_index=best_index; 
    
sInd=0; 
eInd=base_size-1; 
sInd=base_index-RESRANGE/2; 
eInd = sInd+RESRANGE; 
eInd=base_size-1; 
sInd=eInd-RESRANGE; 
crossDot=0.0; 
pp=cb+icount*lTarget; 
measure=(float)-10000000.0; 
measure = crossDot*crossDot* 
                               invenergy[icount]; 
measure = crossDot*crossDot*invenergy[icount]; 
best_index = icount; 
max_measure = measure; 
gain = crossDot*invenergy[icount]; 
gain = gainquant(gain, 1.0, 16, &gain_index[stage]); 
gain = gain * (float)fabs(gains[stage-1])/ 
                       (float)fabs(gain); 
gain = gainquant(gain, (float)fabs(gains[stage-1]),  
                   8, &gain_index[stage]); 
pos = 0; 
cb_pos = 0; 
pos = 0; 
cb_pos = 0; 
lsfunq2 = lsfunq + length; 
lp_length = length + 1; 
        
pos = lp_length; 
is = k*LPC_AHEADL; 
            
lsf2 = lsf + length; 
lsfq2 = lsfq + length; 
lp_length = length + 1; 
        
pos = lp_length; 
change=LSF_check(lsfq, FILTERORDER, LPC_N); 
     
omega = 0.0; 
old_omega = 0.0; 
    
old_p = FLOAT_MAX; 
old_q = FLOAT_MAX; 
        
pq_coef = p_pre; 
old = &old_p; 
pq_coef = q_pre; 
old = &old_q; 
hlp = (float)cos(omega * TWO_PI); 
hlp1 = (float)2.0 * hlp + pq_coef[0]; 
hlp2 = (float)2.0 * hlp * hlp1 - (float)1.0 +  
                   pq_coef[1]; 
hlp3 = (float)2.0 * hlp * hlp2 - hlp1 + pq_coef[2]; 
hlp4 = (float)2.0 * hlp * hlp3 - hlp2 + pq_coef[3]; 
hlp5 = hlp * hlp4 - hlp3 + pq_coef[4]; 
                
omega = old_omega; 
step_idx = 0; 
                        
step_idx = NUMBER_OF_STEPS; 
old_omega = omega; 
step = steps[step_idx]; 
hlp = (freq[FILTERORDER - 1] - freq[0]) /  
               (float) (FILTERORDER - 1); 
    
bbe=8; 
bbe-=bbs;  
bbs=0; 
bbe=0; 
bbe-=bbs; bbs=0; 
maxVal = state_frgq[idxForMax]; 
maxVal = (float)pow(10,maxVal)/(float)4.5; 
            
tmp = &tmpbuf[FILTERORDER];  
fout = &foutbuf[FILTERORDER]; 
    
tmpi = len-1-k; 
target = &targetBuf[FILTERORDER]; 
syntOut = &syntOutBuf[FILTERORDER]; 
weightOut = &weightOutBuf[FILTERORDER]; 
        
toQ = in[n]-syntOut[n]; 
tmp = &tmpbuf[FILTERORDER];  
fout = &foutbuf[FILTERORDER]; 
    
maxVal = fout[0]; 
maxVal = fout[k]; 
maxVal=(float)fabs(maxVal); 
            
maxVal = 10.0; 
maxVal = (float)log10(maxVal); 
maxVal=state_frgq[index]; 
utmp=index; 
maxVal = (float)pow(10,maxVal); 
maxVal = (float)(4.5)/maxVal; 
po = &Out[0]; 
