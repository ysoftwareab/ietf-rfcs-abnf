





Network Working Group                                      P. Riikonen
Internet-Draft
draft-riikonen-silc-spec-03.txt                         21 August 2001
Expires: 21 February 2002


                 Secure Internet Live Conferencing (SILC),
                          Protocol Specification
                     <draft-riikonen-silc-spec-03.txt>

Status of this Memo

   This document is an Internet-Draft and is in full conformance with
   all provisions of Section 10 of RFC 2026.  Internet-Drafts are
   working documents of the Internet Engineering Task Force (IETF), its
   areas, and its working groups.  Note that other groups may also
   distribute working documents as Internet-Drafts.

   Internet-Drafts are draft documents valid for a maximum of six months
   and may be updated, replaced, or obsoleted by other documents at any
   time.  It is inappropriate to use Internet-Drafts as reference
   material or to cite them other than as "work in progress."

   The list of current Internet-Drafts can be accessed at
   http://www.ietf.org/ietf/1id-abstracts.txt

   The list of Internet-Draft Shadow Directories can be accessed at
   http://www.ietf.org/shadow.html

   The distribution of this memo is unlimited.


Abstract

   This memo describes a Secure Internet Live Conferencing (SILC)
   protocol which provides secure conferencing services over insecure
   network channel.  SILC is IRC [IRC] like protocol, however, it is
   not equivalent to IRC and does not support IRC.  Strong cryptographic
   methods are used to protect SILC packets inside the SILC network.
   Three other Internet Drafts relates very closely to this memo;
   SILC Packet Protocol [SILC2], SILC Key Exchange and Authentication
   Protocols [SILC3] and SILC Commands [SILC4].









Riikonen                                                        [Page 1]

Internet Draft                                            21 August 2001


Table of Contents

   1 Introduction ..................................................  3
     1.1 Requirements Terminology ..................................  4
   2 SILC Concepts .................................................  4
     2.1 SILC Network Topology .....................................  4
     2.2 Communication Inside a Cell ...............................  5
     2.3 Communication in the Network ..............................  6
     2.4 Channel Communication .....................................  7
     2.5 Router Connections ........................................  7
     2.6 Backup Routers ............................................  8
   3 SILC Specification ............................................ 10
     3.1 Client .................................................... 10
         3.1.1 Client ID ........................................... 10
     3.2 Server .................................................... 11
         3.2.1 Server's Local ID List .............................. 12
         3.2.2 Server ID ........................................... 13
         3.2.3 SILC Server Ports ................................... 14
     3.3 Router .................................................... 14
         3.3.1 Router's Local ID List .............................. 14
         3.3.2 Router's Global ID List ............................. 15
         3.3.3 Router's Server ID .................................. 15
     3.4 Channels .................................................. 16
         3.4.1 Channel ID .......................................... 17
     3.5 Operators ................................................. 17
     3.6 SILC Commands ............................................. 18
     3.7 SILC Packets .............................................. 18
     3.8 Packet Encryption ......................................... 19
         3.8.1 Determination of the Source and the Destination ..... 19
         3.8.2 Client To Client .................................... 20
         3.8.3 Client To Channel ................................... 21
         3.8.4 Server To Server .................................... 22
     3.9 Key Exchange And Authentication ........................... 22
         3.9.1 Authentication Payload .............................. 22
     3.10 Algorithms ............................................... 24
         3.10.1 Ciphers ............................................ 24
         3.10.2 Public Key Algorithms .............................. 25
         3.10.3 Hash Functions ..................................... 26
         3.10.4 MAC Algorithms ..................................... 26
         3.10.5 Compression Algorithms ............................. 26
     3.11 SILC Public Key .......................................... 27
     3.12 SILC Version Detection ................................... 29
   4 SILC Procedures ............................................... 30
     4.1 Creating Client Connection ................................ 30
     4.2 Creating Server Connection ................................ 31
         4.2.1 Announcing Clients, Channels and Servers ............ 32
     4.3 Joining to a Channel ...................................... 33
     4.4 Channel Key Generation .................................... 34



Riikonen                                                        [Page 2]

Internet Draft                                            21 August 2001


     4.5 Private Message Sending and Reception ..................... 34
     4.6 Private Message Key Generation ............................ 35
     4.7 Channel Message Sending and Reception ..................... 35
     4.8 Session Key Regeneration .................................. 36
     4.9 Command Sending and Reception ............................. 37
     4.10 Closing Connection ....................................... 37
   5 Security Considerations ....................................... 38
   6 References .................................................... 38
   7 Author's Address .............................................. 40



List of Figures

   Figure 1:  SILC Network Topology
   Figure 2:  Communication Inside cell
   Figure 3:  Communication Between Cells
   Figure 4:  Router Connections
   Figure 5:  SILC Public Key


1. Introduction

   This document describes a Secure Internet Live Conferencing (SILC)
   protocol which provides secure conferencing services over insecure
   network channel.  SILC is IRC [IRC] like protocol, however, it is
   not equivalent to IRC and does not support IRC.

   Strong cryptographic methods are used to protect SILC packets inside
   the SILC network.  Three other Internet Drafts relates very closely
   to this memo; SILC Packet Protocol [SILC2], SILC Key Exchange and
   Authentication Protocols [SILC3] and SILC Commands [SILC4].

   The protocol uses extensively packets as conferencing protocol
   requires message and command sending.  The SILC Packet Protocol is
   described in [SILC2] and should be read to fully comprehend this
   document and protocol.  [SILC2] also describes the packet encryption
   and decryption in detail.

   The security of SILC protocol, and for any security protocol for that
   matter, is based on strong and secure key exchange protocol.  The SILC
   Key Exchange protocol is described in [SILC3] along with connection
   authentication protocol and should be read to fully comprehend this
   document and protocol.

   The SILC protocol has been developed to work on TCP/IP network
   protocol, although it could be made to work on other network protocols
   with only minor changes.  However, it is recommended that TCP/IP



Riikonen                                                        [Page 3]

Internet Draft                                            21 August 2001


   protocol is used under SILC protocol.  Typical implementation would
   be made in client-server model.


1.1 Requirements Terminology

   The keywords MUST, MUST NOT, REQUIRED, SHOULD, SHOULD NOT, RECOMMENDED,
   MAY, and OPTIONAL, when they appear in this document, are to be
   interpreted as described in [RFC2119].


2. SILC Concepts

   This section describes various SILC protocol concepts that forms the
   actual protocol, and in the end, the actual SILC network.  The mission
   of the protocol is to deliver messages from clients to other clients
   through routers and servers in secure manner.  The messages may also
   be delivered from one client to many clients forming a group, also
   known as a channel.

   This section does not focus to security issues.  Instead, basic network
   concepts are introduced to make the topology of the SILC network
   clear.


2.1 SILC Network Topology

   SILC network is a cellular network as opposed to tree style network
   topology.  The rationale for this is to have servers that can perform
   specific kind of tasks what other servers cannot perform.  This leads
   to two kinds of servers; normal SILC servers and SILC routers.

   A difference between normal server and router server is that routers
   knows everything about everything in the network.  They also do the
   actual routing of the messages to the correct receiver.  Normal servers
   knows only about local information and nothing about global information.
   This makes the network faster as there are less servers that needs to
   keep global information up to date at all time.

   This, on the other hand, leads to cellular like network, where routers
   are in the center of the cell and servers are connected to the router.










Riikonen                                                        [Page 4]

Internet Draft                                            21 August 2001


   The following diagram represents SILC network topology.

          ---- ---- ----         ---- ---- ----
         | S8 | S5 | S4 |       | S7 | S5 | S6 |
         ----- ---- -----       ----- ---- -----
        | S7 | S/R1 | S2 | --- | S8 | S/R2 | S4 |
         ---- ------ ----       ---- ------ ----
         | S6 | S3 | S1 |       | S1 | S3 | S2 |         ---- ----
          ---- ---- ----         ---- ---- ----         | S3 | S1 |
             Cell 1.   \             Cell 2.  | \____  ----- -----
                        |                     |        | S4 | S/R4 |
            ---- ---- ----         ---- ---- ----       ---- ------
           | S7 | S4 | S2 |       | S1 | S3 | S2 |      | S2 | S5 |
           ----- ---- -----       ----- ---- -----       ---- ----
          | S6 | S/R3 | S1 | --- | S4 | S/R5 | S5 | ____/ Cell 4.
           ---- ------ ----       ---- ------ ----
           | S8 | S5 | S3 |       | S6 | S7 | S8 |     ... etc ...
            ---- ---- ----         ---- ---- ----
               Cell 3.                Cell 5.

                     Figure 1:  SILC Network Topology


   A cell is formed when a server or servers connect to one router.  In
   SILC network normal server cannot directly connect to other normal
   server.  Normal server may only connect to SILC router which then
   routes the messages to the other servers in the cell.  Router servers
   on the other hand may connect to other routers to form the actual SILC
   network, as seen in above figure.  However, router is also normal SILC
   server; clients may connect to it the same way as to normal SILC
   server.  Normal server also cannot have active connections to more
   than one router.  Normal server cannot be connected to two different
   cells.  Router servers, on the other hand, may have as many router to
   router connections as needed.

   There are many issues in this network topology that needs to be careful
   about.  Issues like the size of the cells, the number of the routers in
   the SILC network and the capacity requirements of the routers.  These
   issues should be discussed in the Internet Community and additional
   documents on the issue may be written.


2.2 Communication Inside a Cell

   It is always guaranteed that inside a cell message is delivered to the
   recipient with at most two server hops.  A client which is connected to
   server in the cell and is talking on channel to other client connected
   to other server in the same cell, will have its messages delivered from



Riikonen                                                        [Page 5]

Internet Draft                                            21 August 2001


   its local server first to the router of the cell, and from the router
   to the other server in the cell.

   The following diagram represents this scenario:


                         1 --- S1     S4 --- 5
                                  S/R
                          2 -- S2     S3
                              /        |
                             4         3


                   Figure 2:  Communication Inside cell


   Example:  Client 1. connected to Server 1. send message to
             Client 4. connected to Server 2. travels from Server 1.
             first to Router which routes the message to Server 2.
             which then sends it to the Client 4.  All the other
             servers in the cell will not see the routed message.


   If the client is connected directly to the router, as router is also normal
   SILC server, the messages inside the cell are always delivered only with
   one server hop.  If clients communicating with each other are connected
   to the same server, no router interaction is needed.  This is the optimal
   situation of message delivery in the SILC network.


2.3 Communication in the Network

   If the message is destined to server that does not belong to local cell
   the message is routed to the router server to which the destination
   server belongs, if the local router is connected to destination router.
   If there is no direct connection to the destination router, the local
   router routes the message to its primary route.  The following diagram
   represents message sending between cells.


                1 --- S1     S4 --- 5            S2 --- 1
                         S/R - - - - - - - - S/R
                 2 -- S2     S3           S1
                     /        |             \
                    4         3              2

                   Cell 1.               Cell 2.




Riikonen                                                        [Page 6]

Internet Draft                                            21 August 2001


                  Figure 3:  Communication Between Cells


   Example:  Client 5. connected to Server 4. in Cell 1. sends message
             to Client 2. connected to Server 1. in Cell 2. travels
             from Server 4. to Router which routes the message to
             Router in Cell 2, which then routes the message to
             Server 1.  All the other servers and routers in the
             network will not see the routed message.


   The optimal case of message delivery from the client point of view is
   when clients are connected directly to the routers and the messages
   are delivered from one router to the other.


2.4 Channel Communication

   Messages may be sent to group of clients as well.  Sending messages to
   many clients works the same way as sending messages point to point, from
   message delivery point of view.  Security issues are another matter
   which are not discussed in this section.

   Router server handles the message routing to multiple recipients.  If
   any recipient is not in the same cell as the sender the messages are
   routed further.

   Server distributes the channel message to its local clients which are
   joined to the channel.  Router also distributes the message to its
   local clients on the channel.


2.5 Router Connections

   Router connections play very important role in making the SILC like
   network topology to work.  For example, sending broadcast packets in
   SILC network require special connections between routers; routers must
   be connected in a specific way.

   Every router has their primary route which is a connection to another
   router in the network.  Unless there is only two routers in the network
   must not routers use each other as their primary routes.  The router
   connections in the network must form a circular.








Riikonen                                                        [Page 7]

Internet Draft                                            21 August 2001


   Example with three routers in the network:


                    S/R1 - > - > - > - > - > - > - S/R2
                     \                               /
                      ^                             v
                       \ - < -  < - S/R3 - < - < - /


                       Figure 4:  Router Connections


   Example:  Network with three routers.  Router 1. uses Router 2. as its
             primary router.  Router 2. uses Router 3. as its primary router,
             and Router 3. uses Router 1. as its primary router.  There may
             be other direct connections between the routers but they must
             not be used as primary routes.

   The above example is applicable to any amount of routers in the network
   except for two routers.  If there are only two routers in the network both
   routers must be able to handle situation where they use each other as their
   primary routes.

   The issue of router connections are very important especially with SILC
   broadcast packets.  Usually all router wide information in the network is
   distributed by SILC broadcast packets.


2.6 Backup Routers

   Backup routers may exist in the cell in addition of the primary router.
   However, they must not be active routers and act as routers in the cell.
   Only one router may be acting as primary router in the cell.  In the case
   of failure of the primary router may one of the backup routers become
   active.  The purpose of backup routers are in case of failure of the
   primary router to maintain working connections inside the cell and outside
   the cell and to avoid netsplits.

   Backup routers are normal servers in the cell that are prepared to take
   over the tasks of the primary router if needed.  They need to have at
   least one direct and active connection to the primary router of the cell.
   This communication channel is used to send the router information to
   the backup router.

   Backup router must know everything that the primary router knows to be
   able to take over the tasks of the primary router.  It is the primary
   router's responsibility to feed the data to the backup router.  If the
   backup router does not know all the data in the case of failure some



Riikonen                                                        [Page 8]

Internet Draft                                            21 August 2001


   connections may be lost.  The primary router of the cell must consider
   the backup router being normal router server and feed the data
   accordingly.

   In addition of having direct connection to the primary router of the
   cell the backup router must also have connection to the same router
   the primary router of the cell is connected.  However, it must not be
   active router connection meaning that the backup router must not use
   that channel as its primary route and it must not notify the router
   about having connected servers, channels and clients behind it.  It
   merely connects to the router.  This sort of connection is later
   referred as being passive connection.  Some keepalive actions may be
   needed by the router to keep the connection alive.

   The primary router notifies its primary router about having backup
   routers in the cell by sending SILC_PACKET_CELL_ROUTERS packet.  If
   and when the primary router of the cell becomes unresponsive, its
   primary router knows that there exists backup routers in the cell.
   After that it will start using the first backup router sent in the
   packet as router of that cell.

   In this case the backup router must notify its new primary router about
   the servers, channels and clients it has connected to it.  The primary
   router knows that this server has become a router of the cell because
   of failure of the primary router in the cell.  It must also cope with
   the fact that the servers, channels and clients that the new backup
   router announces are not really new, since they used to exist in the
   primary router of the cell.

   It is required that other normal servers has passive connections to
   the backup router(s) in the cell.  Some keepalive actions may be needed
   by the server to keep the connection alive.  After they notice the
   failure of the primary router they must start using the connection to
   the first backup router as their primary route.

   It is RECOMMENDED that there would be at least one backup router in
   the cell.  It is NOT RECOMMENDED to have all servers in the cell acting
   as backup routers as it requires establishing several connections to
   several servers in the cell.  Large cells can easily have several
   backup routers in the cell.

   The order of the backup routers are decided at the primary router of the
   cell and servers and backup routers in the cell must be configured
   accordingly.  It is not required that the backup server is actually
   active server in the cell.  Backup router may be a spare server in the
   cell that does not accept normal client connections at all.  It may be
   reserved purely for the backup purposes.  These, however, are cell
   management issues.



Riikonen                                                        [Page 9]

Internet Draft                                            21 August 2001


   If also the first backup router is down as well and there is another
   backup router in the cell then it will start acting as the primary
   router as described above.


3. SILC Specification

   This section describes the SILC protocol.  However, [SILC2] and
   [SILC3] describes other important protocols that are part of this SILC
   specification and must be read.


3.1 Client

   A client is a piece of software connecting to SILC server.  SILC client
   cannot be SILC server.  Purpose of clients is to provide the user
   interface of the SILC services for end user.  Clients are distinguished
   from other clients by unique Client ID.  Client ID is a 128 bit ID that
   is used in the communication in the SILC network.  The client ID is
   based on the nickname selected by the user.  User uses logical nicknames
   in communication which are then mapped to the corresponding Client ID.
   Client ID's are low level identifications and must not be seen by the
   end user.

   Clients provide other information about the end user as well. Information
   such as the nickname of the user, username and the host name of the end
   user and user's real name.  See section 3.2 Server for information of
   the requirements of keeping this information.

   The nickname selected by the user is not unique in the SILC network.
   There can be 2^8 same nicknames for one IP address.  As for comparison
   to IRC [IRC] where nicknames are unique this is a fundamental difference
   between SILC and IRC.  This causes the server names or client's host names
   to be used along with the nicknames to identify specific users when sending
   messages.  This feature of SILC makes IRC style nickname-wars obsolete as
   no one owns their nickname; there can always be someone else with the same
   nickname.  The maximum length of nickname is 128 characters.


3.1.1 Client ID

   Client ID is used to identify users in the SILC network.  The Client ID
   is unique to the extent that there can be 2^128 different Client ID's,
   and ID's based on IPv6 addresses extends this to 2^224 different Client
   ID's.  Collisions are not expected to happen.  The Client ID is defined
   as follows.





Riikonen                                                       [Page 10]

Internet Draft                                            21 August 2001


      128 bit Client ID based on IPv4 addresses:

      32 bit  Server ID IP address (bits 1-32)
       8 bit  Random number or counter
      88 bit  Truncated MD5 hash value of the nickname

      224 bit Client ID based on IPv6 addresses:

      128 bit  Server ID IP address (bits 1-128)
        8 bit  Random number or counter
       88 bit  Truncated MD5 hash value of the nickname

      o Server ID IP address - Indicates the server where this
        client is coming from.  The IP address hence equals the
        server IP address where to the client has connected.

      o Random number or counter - Random number to further
        randomize the Client ID.  Another choice is to use
        a counter starting from the zero (0).  This makes it
        possible to have 2^8 same nicknames from the same
        server IP address.

      o MD5 hash - MD5 hash value of the nickname is truncated
        taking 88 bits from the start of the hash value.  This
        hash value is used to search the user's Client ID from
        the ID lists.

   Collisions could occur when more than 2^8 clients using same nickname
   from the same server IP address is connected to the SILC network.
   Server MUST be able to handle this situation by refusing to accept
   anymore of that nickname.

   Another possible collision may happen with the truncated hash value of
   the nickname.  It could be possible to have same truncated hash value for
   two different nicknames.  However, this is not expected to happen nor
   cause any problems if it would occur.  Nicknames are usually logical and
   it is unlikely to have two distinct logical nicknames produce same
   truncated hash value.


3.2 Server

   Servers are the most important parts of the SILC network.  They form the
   basis of the SILC, providing a point to which clients may connect to.
   There are two kinds of servers in SILC; normal servers and router servers.
   This section focus on the normal server and router server is described
   in the section 3.3 Router.




Riikonen                                                       [Page 11]

Internet Draft                                            21 August 2001


   Normal servers MUST NOT directly connect to other normal server.  Normal
   servers may only directly connect to router server.  If the message sent
   by the client is destined outside the local server it is always sent to
   the router server for further routing.  Server may only have one active
   connection to router on same port.  Normal server MUST NOT connect to other
   cell's router except in situations where its cell's router is unavailable.

   Servers and routers in the SILC network are considered to be trusted.
   With out a doubt, servers that are set to work on ports above 1023 are
   not considered to be trusted.  Also, the service provider acts important
   role in the server's trustworthy.


3.2.1 Server's Local ID List

   Normal server keeps various information about the clients and their end
   users connected to it.  Every normal server MUST keep list of all locally
   connected clients, Client ID's, nicknames, usernames and host names and
   user's real name.  Normal servers only keeps local information and it
   does not keep any global information.  Hence, normal servers knows only
   about their locally connected clients.  This makes servers efficient as
   they don't have to worry about global clients.  Server is also responsible
   of creating the Client ID's for their clients.

   Normal server also keeps information about locally created channels and
   their Channel ID's.


   Hence, local list for normal server includes:

      server list        - Router connection
         o Server name
         o Server IP address
         o Server ID
         o Sending key
         o Receiving key
         o Public key

      client list        - All clients in server
         o Nickname
         o Username@host
         o Real name
         o Client ID
         o Sending key
         o Receiving key
         o Public key





Riikonen                                                       [Page 12]

Internet Draft                                            21 August 2001


      channel list       - All channels in server
         o Channel name
         o Channel ID
         o Client ID's on channel
         o Client ID modes on channel
         o Channel key


3.2.2 Server ID

   Servers are distinguished from other servers by unique 64 bit Server ID
   (for IPv4) or 160 bit Server ID (for IPv6).  The Server ID is used in
   the SILC to route messages to correct servers.  Server ID's also provide
   information for Client ID's, see section 3.1.1 Client ID.  Server ID is
   defined as follows.

      64 bit Server ID based on IPv4 addresses:

      32 bit  IP address of the server
      16 bit  Port
      16 bit  Random number

      160 bit Server ID based on IPv6 addresses:

      128 bit  IP address of the server
       16 bit  Port
       16 bit  Random number

      o IP address of the server - This is the real IP address of
        the server.

      o Port - This is the port the server is bound to.

      o Random number - This is used to further randomize the Server ID.

   Collisions are not expected to happen in any conditions.  The Server ID
   is always created by the server itself and server is responsible of
   distributing it to the router.


3.2.3 SILC Server Ports

   The following ports has been assigned by IANA for the SILC protocol:

          silc            706/tcp    SILC
          silc            706/udp    SILC





Riikonen                                                       [Page 13]

Internet Draft                                            21 August 2001


   If there are needs to create new SILC networks in the future the port
   numbers must be officially assigned by the IANA.

   Server on network above privileged ports (>1023) SHOULD NOT be trusted
   as they could have been set up by untrusted party.


3.3 Router

   Router server in SILC network is responsible for keeping the cell together
   and routing messages to other servers and to other routers.  Router server
   is also a normal server thus clients may connect to it as it would be
   just normal SILC server.

   However, router servers has a lot of important tasks that normal servers
   do not have.  Router server knows everything about everything in the SILC.
   They know all clients currently on SILC, all servers and routers and all
   channels in SILC.  Routers are the only servers in SILC that care about
   global information and keeping them up to date at all time.  And, this
   is what they must do.


3.3.1 Router's Local ID List

   Router server as well MUST keep local list of connected clients and
   locally created channels.  However, this list is extended to include all
   the informations of the entire cell, not just the server itself as for
   normal servers.

   However, on router this list is a lot smaller since routers do not need
   to keep information about user's nickname, username and host name and real
   name since these are not needed by the router.  The router keeps only
   information that it needs.


   Hence, local list for router includes:

      server list        - All servers in the cell
         o Server name
         o Server ID
         o Router's Server ID
         o Sending key
         o Receiving key

      client list        - All clients in the cell
         o Client ID





Riikonen                                                       [Page 14]

Internet Draft                                            21 August 2001


      channel list       - All channels in the cell
         o Channel ID
         o Client ID's on channel
         o Client ID modes on channel
         o Channel key


   Note that locally connected clients and other information include all the
   same information as defined in section section 3.2.1 Server's Local ID
   List.


3.3.2 Router's Global ID List

   Router server MUST also keep global list.  Normal servers do not have
   global list as they know only about local information.  Global list
   includes all the clients on SILC, their Client ID's, all created channels
   and their Channel ID's and all servers and routers on SILC and their
   Server ID's.  That is said, global list is for global information and the
   list must not include the local information already on the router's local
   list.

   Note that the global list does not include information like nicknames,
   usernames and host names or user's real names.  Router does not need to
   keep these informations as they are not needed by the router.  This
   information is available from the client's server which maybe queried
   when needed.

   Hence, global list includes:

      server list        - All servers in SILC
         o Server name
         o Server ID
         o Router's Server ID

      client list        - All clients in SILC
         o Client ID

      channel list       - All channels in SILC
         o Channel ID
         o Client ID's on channel
         o Client ID modes on channel









Riikonen                                                       [Page 15]

Internet Draft                                            21 August 2001


3.3.3 Router's Server ID

   Router's Server ID's are equivalent to normal Server ID's.  As routers
   are normal servers as well same types of ID's applies for routers as well.
   Thus, see section 3.2.2 Server ID.


3.4 Channels

   A channel is a named group of one or more clients which will all receive
   messages addressed to that channel.  The channel is created when first
   client requests JOIN command to the channel, and the channel ceases to
   exist when the last client has left it.  When channel exists, any client
   can reference it using the name of the channel.

   Channel names are unique although the real uniqueness comes from 64 bit
   Channel ID.  However, channel names are still unique and no two global
   channels with same name may exist.  The Channel name is a string of
   maximum length of 256 characters.  Channel names MUST NOT contain any
   spaces (`  '), any non-printable ASCII characters, commas (`,') and
   wildcard characters.

   Channels can have operators that can administrate the channel and
   operate all of its modes.  The following operators on channel exist on
   the SILC network.

      o Channel founder - When channel is created the joining client becomes
        channel founder.  Channel founder is channel operator with some more
        privileges.  Basically, channel founder can fully operate the channel
        and all of its modes.  The privileges are limited only to the
        particular channel.  There can be only one channel founder per
        channel. Channel founder supersedes channel operator's privileges.

        Channel founder privileges cannot be removed by any other operator on
        channel.  When channel founder leaves the channel there is no channel
        founder on the channel.  However, it is possible to set a mode for
        the channel which allows the original channel founder to regain the
        founder privileges even after leaving the channel.  Channel founder
        also cannot be removed by force from the channel.

      o Channel operator - When client joins to channel that has not existed
        previously it will become automatically channel operator (and channel
        founder discussed above).  Channel operator is able administrate the
        channel, set some modes on channel, remove a badly behaving client
        from the channel and promote other clients to become channel
        operator.  The privileges are limited only to the particular channel.

        Normal channel user may be promoted (opped) to channel operator



Riikonen                                                       [Page 16]

Internet Draft                                            21 August 2001


        gaining channel operator privileges.  Channel founder or other
        channel operator may also demote (deop) channel operator to normal
        channel user.


3.4.1 Channel ID

   Channels are distinguished from other channels by unique Channel ID.
   The Channel ID is a 64 bit ID (for IPv4) or 160 bit ID (for IPv6), and
   collisions are not expected to happen in any conditions.  Channel names
   are just for logical use of channels.  The Channel ID is created by the
   server where the channel is created.  The Channel ID is defined as
   follows.

      64 bit Channel ID based on IPv4 addresses:

      32 bit  Router's Server ID IP address (bits 1-32)
      16 bit  Router's Server ID port (bits 33-48)
      16 bit  Random number

      160 bit Channel ID based on IPv6 addresses:

      128 bit  Router's Server ID IP address (bits 1-128)
       16 bit  Router's Server ID port (bits 129-144)
       16 bit  Random number

      o Router's Server ID IP address - Indicates the IP address of
        the router of the cell where this channel is created.  This is
        taken from the router's Server ID.  This way SILC router knows
        where this channel resides in the SILC network.

      o Router's Server ID port - Indicates the port of the channel on
        the server.  This is taken from the router's Server ID.

      o Random number - To further randomize the Channel ID.  This makes
        sure that there are no collisions.  This also means that
        in a cell there can be 2^16 channels.


3.5 Operators

   Operators are normal users with extra privileges to their server or
   router.  Usually these people are SILC server and router administrators
   that take care of their own server and clients on them.  The purpose of
   operators is to administrate the SILC server or router.  However, even
   an operator with highest privileges is not able to enter invite-only
   channel, to gain access to the contents of a encrypted and authenticated
   packets traveling in the SILC network or to gain channel operator



Riikonen                                                       [Page 17]

Internet Draft                                            21 August 2001


   privileges on public channels without being promoted.  They have the
   same privileges as everyone else except they are able to administrate
   their server or router.


3.6 SILC Commands

   Commands are very important part on SILC network especially for client
   which uses commands to operate on the SILC network.  Commands are used
   to set nickname, join to channel, change modes and many other things.

   Client usually sends the commands and server replies by sending a reply
   packet to the command.  Server MAY also send commands usually to serve
   the original client's request.  However, server MUST NOT send commands
   to client and there are some commands that server must not send.

   Note that the command reply is usually sent only after client has sent
   the command request but server is allowed to send command reply packet
   to client even if client has not requested the command.  Client MAY,
   choose to ignore the command reply.

   It is expected that some of the commands may be miss-used by clients
   resulting various problems on the server side.  Every implementation
   SHOULD assure that commands may not be executed more than once, say,
   in two (2) seconds.  However, to keep response rate up, allowing for
   example five (5) commands before limiting is allowed.  It is RECOMMENDED
   that commands such as SILC_COMMAND_NICK, SILC_COMMAND_JOIN,
   SILC_COMMAND_LEAVE and SILC_COMMAND_KILL SHOULD be limited in all cases
   as they require heavy operations.  This should be sufficient to prevent
   the miss-use of commands.

   SILC commands are described in [SILC4].


3.7 SILC Packets

   Packets are naturally the most important part of the protocol and the
   packets are what actually makes the protocol.  Packets in SILC network
   are always encrypted using, usually the shared secret session key
   or some other key, for example, channel key, when encrypting channel
   messages.  The SILC Packet Protocol is a wide protocol and is described
   in [SILC2].  This document does not define or describe details of
   SILC packets.








Riikonen                                                       [Page 18]

Internet Draft                                            21 August 2001


3.8 Packet Encryption

   All packets passed in SILC network MUST be encrypted.  This section
   defines how packets must be encrypted in the SILC network.  The detailed
   description of the actual encryption process of the packets are
   described in [SILC2].

   Client and its server shares secret symmetric session key which is
   established by the SILC Key Exchange Protocol, described in [SILC3].
   Every packet sent from client to server, with exception of packets for
   channels, are encrypted with this session key.

   Channels has their own key that are shared by every client on the channel.
   However, the channel keys are cell specific thus one cell does not know
   the channel key of the other cell, even if that key is for same channel.
   Channel key is also known by the routers and all servers that has clients
   on the channel.  However, channels MAY have channel private keys that
   are entirely local setting for the client.  All clients on the channel
   MUST know the channel private key before hand to be able to talk on the
   channel.  In this case, no server or router know the key for channel.

   Server shares secret symmetric session key with router which is
   established by the SILC Key Exchange Protocol.  Every packet passed from
   server to router, with exception of packets for channels, are encrypted
   with the shared session key.  Same way, router server shares secret
   symmetric key with its primary route.  However, every packet passed
   from router to other router, including packets for channels, are
   encrypted with the shared session key.  Every router connection has
   their own session keys.


3.8.1 Determination of the Source and the Destination

   The source and the destination of the packet needs to be determined
   to be able to route the packets to correct receiver.  This information
   is available in the SILC Packet Header which is included in all packets
   sent in SILC network.  The SILC Packet Header is described in [SILC2].

   The header MUST be encrypted with the session key who is next receiver
   of the packet along the route.  The receiver of the packet, for example
   a router along the route, is able to determine the sender and the
   destination of the packet by decrypting the SILC Packet Header and
   checking the ID's attached to the header.  The ID's in the header will
   tell to where the packet needs to be sent and where it is coming from.

   The header in the packet MUST NOT change during the routing of the
   packet.  The original sender, for example client, assembles the packet
   and the packet header and server or router between the sender and the



Riikonen                                                       [Page 19]

Internet Draft                                            21 August 2001


   receiver MUST NOT change the packet header.

   Note that the packet and the packet header may be encrypted with
   different keys.  For example, packets to channels are encrypted with
   the channel key, however, the header is encrypted with the session key
   as described above.  However, the header and the packet may be encrypted
   with same key.  This is the case, for example, with command packets.


3.8.2 Client To Client

   The process of message delivery and encryption from client to another
   client is as follows.

   Example:  Private message from client to another client on different
             servers.  Clients do not share private message delivery
             keys; normal session keys are used.

   o Client 1. sends encrypted packet to its server.  The packet is
     encrypted with the session key shared between client and its
     server.

   o Server determines the destination of the packet and decrypts
     the packet.  Server encrypts the packet with session key shared
     between the server and its router, and sends the packet to the
     router.

   o Router determines the destination of the packet and decrypts
     the packet.  Router encrypts the packet with session key
     shared between the router and the destination server, and sends
     the packet to the server.

   o Server determines the client to which the packet is destined
     to and decrypts the packet.  Server encrypts the packet with
     session key shared between the server and the destination client,
     and sends the packet to the client.

   o Client 2. decrypts the packet.


   Example:  Private message from client to another client on different
             servers.  Clients has established secret shared private
             message delivery key with each other and that is used in
             the message encryption.

   o Client 1. sends encrypted packet to its server.  The packet is
     encrypted with the private message delivery key shared between
     clients.



Riikonen                                                       [Page 20]

Internet Draft                                            21 August 2001


   o Server determines the destination of the packet and sends the
     packet to the router.

   o Router determines the destination of the packet and sends the
     packet to the server.

   o Server determines the client to which the packet is destined
     to and sends the packet to the client.

   o Client 2. decrypts the packet with the secret shared key.


   If clients share secret key with each other the private message
   delivery is much simpler since servers and routers between the
   clients do not need to decrypt and re-encrypt the packet.

   The process for clients on same server is much simpler as there are
   no need to send the packet to the router.  The process for clients
   on different cells is same as above except that the packet is routed
   outside the cell.  The router of the destination cell routes the
   packet to the destination same way as described above.


3.8.3 Client To Channel

   Process of message delivery from client on channel to all the clients
   on the channel.

   Example:  Channel of four users; two on same server, other two on
             different cells.  Client sends message to the channel.

   o Client 1. encrypts the packet with channel key and sends the
     packet to its server.

   o Server determines local clients on the channel and sends the
     packet to the Client on the same server.  Server then sends
     the packet to its router for further routing.

   o Router determines local clients on the channel, if found
     sends packet to the local clients.  Router determines global
     clients on the channel and sends the packet to its primary
     router or fastest route.

   o (Other router(s) do the same thing and sends the packet to
      the server(s))

   o Server determines local clients on the channel and sends the
     packet to the client.



Riikonen                                                       [Page 21]

Internet Draft                                            21 August 2001


   o All clients receiving the packet decrypts the packet.


3.8.4 Server To Server

   Server to server packet delivery and encryption is described in above
   examples. Router to router packet delivery is analogous to server to
   server.  However, some packets, such as channel packets, are processed
   differently.  These cases are described later in this document and
   more in detail in [SILC2].


3.9 Key Exchange And Authentication

   Key exchange is done always when for example client connects to server
   but also when server and router, and router and router connects to each
   other.  The purpose of key exchange protocol is to provide secure key
   material to be used in the communication.  The key material is used to
   derive various security parameters used to secure SILC packets.  The
   SILC Key Exchange protocol is described in detail in [SILC3].

   Authentication is done after key exchange protocol has been successfully
   completed.  The purpose of authentication is to authenticate for example
   client connecting to the server.  However, usually clients are accepted
   to connect to server without explicit authentication.  Servers are
   required use authentication protocol when connecting.  The authentication
   may be based on passphrase (pre-shared-secret) or public key.  The
   connection authentication protocol is described in detail in [SILC3].


3.9.1 Authentication Payload

   Authentication payload is used separately from the SKE and the Connection
   Authentication protocol.  It is used during the session to authenticate
   with the remote.  For example, the client can authenticate itself to the
   server to become server operator.  In this case, Authentication Payload is
   used.














Riikonen                                                       [Page 22]

Internet Draft                                            21 August 2001


   The format of the Authentication Payload is as follows:


                          1                   2                   3
      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |        Payload Length         |     Authentication Method     |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |      Public Data Length       |                               |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+                               +
     |                                                               |
     ~                           Public Data                         ~
     |                                                               |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |   Authentication Data Length  |                               |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+                               +
     |                                                               |
     ~                       Authentication Data                     ~
     |                                                               |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

                     Figure 5:  Authentication Payload


      o Payload Length (2 bytes) - Length of the entire payload.

      o Authentication Method (2) - The method of the authentication.
        The authentication methods are defined in [SILC2] in the
        Connection Auth Request Payload.  The NONE authentication
        method SHOULD NOT be used.

      o Public Data Length (2 bytes) - Indicates the length of
        the Public Data field.

      o Public Data (variable length) - This is defined only if
        the authentication method is public key.  If it is any other
        this field does not exist and the Public Data Length field
        is set to zero (0).

        When the authentication method is public key this includes
        128 to 4096 bytes of non-zero random data that is used in
        the signature process, described subsequently.

      o Authentication Data Length (2 bytes) - Indicates the
        length of the Authentication Data field.

      o Authentication Data (variable length) - Authentication
        method dependent authentication data.



Riikonen                                                       [Page 23]

Internet Draft                                            21 August 2001


   If the authentication method is password based, the Authentication
   Data field includes the plaintext password.  It is safe to send
   plaintext password since the entire payload is encrypted.  In this
   case the Public Data Length is set to zero (0).

   If the authentication method is public key based (or certificate)
   the Authentication Data is computed as follows:

     HASH = hash(random bytes | ID | public key (or certificate));
     Authentication Data = sign(HASH);

   The hash() and the sign() are the hash function and the public key
   cryptography function selected in the SKE protocol.  The public key
   is SILC style public key unless certificates are used.  The ID is the
   entity's ID (Client or Server ID) which is authenticating itself.  The
   ID is raw ID data.  The random bytes are non-zero random bytes of
   length between 128 and 4096 bytes, and will be included into the
   Public Data field as is.

   The receiver will compute the signature using the random data received
   in the payload, the ID associated to the connection and the public key
   (or certificate) received in the SKE protocol.  After computing the
   receiver MUST verify the signature.  In this case also, the entire
   payload is encrypted.


3.10 Algorithms

   This section defines all the allowed algorithms that can be used in
   the SILC protocol.  This includes mandatory cipher, mandatory public
   key algorithm and MAC algorithms.


3.10.1 Ciphers

   Cipher is the encryption algorithm that is used to protect the data
   in the SILC packets.  See [SILC2] of the actual encryption process and
   definition of how it must be done.  SILC has a mandatory algorithm that
   must be supported in order to be compliant with this protocol.

   The following ciphers are defined in SILC protocol:

      aes-256-cbc         AES in CBC mode, 256 bit key       (REQUIRED)
      aes-192-cbc         AES in CBC mode, 192 bit key       (OPTIONAL)
      aes-128-cbc         AES in CBC mode, 128 bit key       (OPTIONAL)
      twofish-256-cbc     Twofish in CBC mode, 256 bit key   (OPTIONAL)
      twofish-192-cbc     Twofish in CBC mode, 192 bit key   (OPTIONAL)
      twofish-128-cbc     Twofish in CBC mode, 128 bit key   (OPTIONAL)



Riikonen                                                       [Page 24]

Internet Draft                                            21 August 2001


      blowfish-128-cbc    Blowfish in CBC mode, 128 bit key  (OPTIONAL)
      cast-256-cbc        CAST-256 in CBC mode, 256 bit key  (OPTIONAL)
      cast-192-cbc        CAST-256 in CBC mode, 192 bit key  (OPTIONAL)
      cast-128-cbc        CAST-256 in CBC mode, 128 bit key  (OPTIONAL)
      rc6-256-cbc         RC6 in CBC mode, 256 bit key       (OPTIONAL)
      rc6-192-cbc         RC6 in CBC mode, 192 bit key       (OPTIONAL)
      rc6-128-cbc         RC6 in CBC mode, 128 bit key       (OPTIONAL)
      mars-256-cbc        Mars in CBC mode, 256 bit key      (OPTIONAL)
      mars-192-cbc        Mars in CBC mode, 192 bit key      (OPTIONAL)
      mars-128-cbc        Mars in CBC mode, 128 bit key      (OPTIONAL)
      none                No encryption                      (OPTIONAL)


   Algorithm none does not perform any encryption process at all and
   thus is not recommended to be used.  It is recommended that no client
   or server implementation would accept none algorithms except in special
   debugging mode.

   Additional ciphers MAY be defined to be used in SILC by using the
   same name format as above.


3.10.2 Public Key Algorithms

   Public keys are used in SILC to authenticate entities in SILC network
   and to perform other tasks related to public key cryptography.  The
   public keys are also used in the SILC Key Exchange protocol [SILC3].

   The following public key algorithms are defined in SILC protocol:

      rsa        RSA  (REQUIRED)
      dss        DSS  (OPTIONAL)

   DSS is described in [Menezes].  The RSA MUST be implemented according
   PKCS #1 [PKCS1].  The mandatory PKCS #1 implementation in SILC MUST be
   compliant to either PKCS #1 version 1.5 or newer with the following
   notes: The signature encoding is always in same format as the encryption
   encoding regardless of the PKCS #1 version.  The signature with appendix
   (with hash algorithm OID in the data) MUST NOT be used in the SILC.  The
   rationale for this is that there is no binding between the PKCS #1 OIDs
   and the hash algorithms used in the SILC protocol.  Hence, the encoding
   is always in PKCS #1 version 1.5 format.

   Additional public key algorithms MAY be defined to be used in SILC.







Riikonen                                                       [Page 25]

Internet Draft                                            21 August 2001


3.10.3 Hash Functions

   Hash functions are used as part of MAC algorithms defined in the next
   section.  They are also used in the SILC Key Exchange protocol defined
   in the [SILC3].

   The following Hash algorithm are defined in SILC protocol:

      sha1             SHA-1, length = 20      (REQUIRED)
      md5              MD5, length = 16        (OPTIONAL)


3.10.4 MAC Algorithms

   Data integrity is protected by computing a message authentication code
   (MAC) of the packet data.  See [SILC2] for details how to compute the
   MAC.

   The following MAC algorithms are defined in SILC protocol:

      hmac-sha1-96     HMAC-SHA1, length = 12  (REQUIRED)
      hmac-md5-96      HMAC-MD5, length = 12   (OPTIONAL)
      hmac-sha1        HMAC-SHA1, length = 20  (OPTIONAL)
      hmac-md5         HMAC-MD5, length = 16   (OPTIONAL)
      none             No MAC                  (OPTIONAL)

   The none MAC is not recommended to be used as the packet is not
   authenticated when MAC is not computed.  It is recommended that no
   client or server would accept none MAC except in special debugging
   mode.

   The HMAC algorithm is described in [HMAC] and hash algorithms that
   are used as part of the HMACs are described in [Scheneir] and in
   [Menezes]

   Additional MAC algorithms MAY be defined to be used in SILC.


3.10.5 Compression Algorithms

   SILC protocol supports compression that may be applied to unencrypted
   data.  It is recommended to use compression on slow links as it may
   significantly speed up the data transmission.  By default, SILC does not
   use compression which is the mode that must be supported by all SILC
   implementations.






Riikonen                                                       [Page 26]

Internet Draft                                            21 August 2001


   The following compression algorithms are defined:

      none        No compression               (REQUIRED)
      zlib        GNU ZLIB (LZ77) compression  (OPTIONAL)

   Additional compression algorithms MAY be defined to be used in SILC.


3.11 SILC Public Key

   This section defines the type and format of the SILC public key.  All
   implementations MUST support this public key type.  See [SILC3] for
   other optional public key and certificate types allowed in the SILC
   protocol.  Public keys in SILC may be used to authenticate entities
   and to perform other tasks related to public key cryptography.

   The format of the SILC Public Key is as follows:


                          1                   2                   3
      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |                        Public Key Length                      |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |     Algorithm Name Length     |                               |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+                               +
     |                                                               |
     ~                         Algorithm Name                        ~
     |                                                               |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |       Identifier Length       |                               |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+                               +
     |                                                               |
     ~                           Identifier                          ~
     |                                                               |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |                                                               |
     ~                           Public Data                         ~
     |                                                               |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

                        Figure 5:  SILC Public Key


      o Public Key Length (4 bytes) - Indicates the full length
        of the public key, not including this field.

      o Algorithm Name Length (2 bytes) - Indicates the length



Riikonen                                                       [Page 27]

Internet Draft                                            21 August 2001


        of the Algorithm Length field, not including this field.

      o Algorithm name (variable length) - Indicates the name
        of the public key algorithm that the key is.  See the
        section 3.10.2 Public Key Algorithms for defined names.

      o Identifier Length (2 bytes) - Indicates the length of
        the Identifier field, not including this field.

      o Identifier (variable length) - Indicates the identifier
        of the public key.  This data can be used to identify
        the owner of the key.  The identifier is of the following
        format:

           UN   User name
           HN   Host name or IP address
           RN   Real name
           E    EMail address
           O    Organization
           C    Country


        Examples of an identifier:

          `UN=priikone, HN=poseidon.pspt.fi, E=priikone@poseidon.pspt.fi'

          `UN=sam, HN=dummy.fi, RN=Sammy Sam, O=Company XYZ, C=Finland'

        At least user name (UN) and host name (HN) MUST be provided as
        identifier.  The fields are separated by commas (`,').  If
        comma is in the identifier string it must be written as `\,',
        for example, `O=Company XYZ\, Inc.'.

      o Public Data (variable length) - Includes the actual
        public data of the public key.

        The format of this field for RSA algorithm is
        as follows:

           4 bytes            Length of e
           variable length    e
           4 bytes            Length of n
           variable length    n


        The format of this field for DSS algorithm is
        as follows:




Riikonen                                                       [Page 28]

Internet Draft                                            21 August 2001


           4 bytes            Length of p
           variable length    p
           4 bytes            Length of q
           variable length    q
           4 bytes            Length of g
           variable length    g
           4 bytes            Length of y
           variable length    y

        The variable length fields are multiple precession
        integers encoded as strings in both examples.

        Other algorithms must define their own type of this
        field if they are used.

   All fields in the public key are in MSB (most significant byte first)
   order.


3.12 SILC Version Detection

   The version detection of both client and server is performed at the
   connection phase while executing the SILC Key Exchange protocol.  The
   version identifier is exchanged between initiator and responder.  The
   version identifier is of the following format:

      SILC-<protocol version>-<software version>

   The version strings are of the following format:

      protocol version = <major>.<minor>
      software version = <major>[.<minor>[.<build>]]

   Protocol version MAY provide both major and minor version.  Currently
   implementations MUST set the protocol version and accept the protocol
   version as SILC-1.0-<software version>.

   Software version MAY provide major, minor and build version.  The
   software version MAY be freely set and accepted.


   Thus, the version string could be, for example:

      SILC-1.0-1.2







Riikonen                                                       [Page 29]

Internet Draft                                            21 August 2001


4 SILC Procedures

   This section describes various SILC procedures such as how the
   connections are created and registered, how channels are created and
   so on.  The section describes the procedures only generally as details
   are described in [SILC2] and [SILC3].


4.1 Creating Client Connection

   This section describes the procedure when client connects to SILC server.
   When client connects to server the server MUST perform IP address lookup
   and reverse IP address lookup to assure that the origin host really is
   who it claims to be.  Client, host, connecting to server SHOULD have
   both valid IP address and fully qualified domain name (FQDN).

   After that the client and server performs SILC Key Exchange protocol
   which will provide the key material used later in the communication.
   The key exchange protocol MUST be completed successfully before the
   connection registration may continue.  The SILC Key Exchange protocol
   is described in [SILC3].

   Typical server implementation would keep a list of connections that it
   allows to connect to the server.  The implementation would check, for
   example, the connecting client's IP address from the connection list
   before the SILC Key Exchange protocol has been started.  Reason for
   this is that if the host is not allowed to connect to the server there
   is no reason to perform the key exchange protocol.

   After successful key exchange protocol the client and server performs
   connection authentication protocol.  The purpose of the protocol is to
   authenticate the client connecting to the server.  Flexible
   implementation could also accept the client to connect to the server
   without explicit authentication.  However, if authentication is
   desired for a specific client it may be based on passphrase or
   public key authentication.  If authentication fails the connection
   MUST be terminated.  The connection authentication protocol is described
   in [SILC3].

   After successful key exchange and authentication protocol the client
   registers itself by sending SILC_PACKET_NEW_CLIENT packet to the
   server.  This packet includes various information about the client
   that the server uses to create the client.  Server creates the client
   and sends SILC_PACKET_NEW_ID to the client which includes the created
   Client ID that the client MUST start using after that.  After that
   all SILC packets from the client MUST have the Client ID as the
   Source ID in the SILC Packet Header, described in [SILC2].




Riikonen                                                       [Page 30]

Internet Draft                                            21 August 2001


   Client MUST also get the server's Server ID that is to be used as
   Destination ID in the SILC Packet Header when communicating with
   the server (for example when sending commands to the server).  The
   ID may be resolved in two ways.  Client can take the ID from an
   previously received packet from server that MUST include the ID,
   or to send SILC_COMMAND_INFO command and receive the Server ID as
   command reply.

   Server MAY choose not to use the information received in the
   SILC_PACKET_NEW_CLIENT packet.  For example, if public key or
   certificate were used in the authentication, server MAY use those
   informations rather than what it received from client.  This is suitable
   way to get the true information about client if it is available.

   The nickname of client is initially set to the username sent in the
   SILC_PACKET_NEW_CLIENT packet.  User should set the nickname to more
   suitable by sending SILC_COMMAND_NICK command.  However, this is not
   required as part of registration process.

   Server MUST also distribute the information about newly registered
   client to its router (or if the server is router, to all routers in
   the SILC network).  More information about this in [SILC2].


4.2 Creating Server Connection

   This section describes the procedure when server connects to its
   router (or when router connects to other router, the cases are
   equivalent).  The procedure is very much alike when client connects
   to the server thus it is not repeated here.

   One difference is that server MUST perform connection authentication
   protocol with proper authentication.  A proper authentication is based
   on passphrase or public key authentication.

   After server and router has successfully performed the key exchange
   and connection authentication protocol, the server register itself
   to the router by sending SILC_PACKET_NEW_SERVER packet.  This packet
   includes the server's Server ID that it has created by itself and
   other relevant information about the server.

   After router has received the SILC_PACKET_NEW_SERVER packet it
   distributes the information about newly registered server to all routers
   in the SILC network.  More information about this in [SILC2].

   As client needed to resolve the destination ID this MUST be done by the
   server that connected to the router, as well.  The way to resolve it is
   to get the ID from previously received packet.  The server MAY also



Riikonen                                                       [Page 31]

Internet Draft                                            21 August 2001


   use SILC_COMMAND_INFO command to resolve the ID.  Server MUST also start
   using its own Server ID as Source ID in SILC Packet Header and the
   router's Server ID as Destination when communicating with the router.


4.2.1 Announcing Clients, Channels and Servers

   After server or router has connected to the remote router, and it already
   has connected clients and channels it MUST announce them to the router.
   If the server is router server, also all the local servers in the cell
   MUST be announced.

   All clients are announced by compiling a list of ID Payloads into the
   SILC_PACKET_NEW_ID packet.  All channels are announced by compiling a
   list of Channel Payloads into the SILC_PACKET_NEW_CHANNEL packet.  Also,
   the channel users on the channels must be announced by compiling a
   list of Notify Payloads with the SILC_NOTIFY_TYPE_JOIN notify type into
   the SILC_PACKET_NOTIFY packet.  The users' modes on the channel must
   also be announced by compiling list of Notify Payloads with the
   SILC_NOTIFY_TYPE_CUMODE_CHANGE notify type into the SILC_PACKET_NOTIFY
   packet.

   The router MUST also announce the local servers by compiling list of
   ID Payloads into the SILC_PACKET_NEW_ID packet.

   The router which receives these lists MUST process them and broadcast
   the packets to its primary route.

   When processing the announced channels and channel users the router MUST
   check whether a channel exists already with the same name.  If channel
   exists with the same name it MUST check whether the Channel ID is
   different.  If the Channel ID is different the router MUST send the notify
   type SILC_NOTIFY_TYPE_CHANNEL_CHANGE to the server to force the channel ID
   change to the ID the router has.  If the mode of the channel is different
   the router MUST send the notify type SILC_NOTIFY_TYPE_CMODE_CHANGE to the
   server to force the mode change to the mode that the router has.

   The router MUST also generate new channel key and distribute it to the
   channel.  The key MUST NOT be generated if the SILC_CMODE_PRIVKEY mode
   is set.

   If the channel has channel founder on the router the router MUST send
   the notify type SILC_NOTIFY_TYPE_CUMODE_CHANGE to the server to force
   the mode change for the channel founder on the server.  The channel
   founder privileges MUST be removed.

   The router processing the channels MUST also compile a list of
   Notify Payloads with the SILC_NOTIFY_TYPE_JOIN notify type into the



Riikonen                                                       [Page 32]

Internet Draft                                            21 August 2001


   SILC_PACKET_NOTIFY and send the packet to the server.  This way the
   server (or router) will receive the clients on the channel that
   the router has.


4.3 Joining to a Channel

   This section describes the procedure when client joins to a channel.
   Client joins to channel by sending command SILC_COMMAND_JOIN to the
   server.  If the receiver receiving join command is normal server the
   server MUST check its local list whether this channel already exists
   locally.  This would indicate that some client connected to the server
   has already joined to the channel.  If this is case the client is
   joined to the channel, new channel key is created and information about
   newly joined channel is sent to the router.  The router is informed
   by sending SILC_NOTIFY_TYPE_JOIN notify type.  The notify type MUST
   also be sent to the local clients on the channel.  The new channel key
   is also sent to the router and to local clients on the channel.

   If the channel does not exist in the local list the client's command
   MUST be sent to the router which will then perform the actual joining
   procedure.  When server receives the reply to the command from the
   router it MUST be sent to the client which sent the command originally.
   Server will also receive the channel key from the server that it MUST
   send to the client which originally requested the join command.  The
   server MUST also save the channel key.

   If the receiver of the join command is router it MUST first check its
   local list whether anyone in the cell has already joined to the channel.
   If this is the case the client is joined to the channel and reply is
   sent to the client.  If the command was sent by server the command reply
   is sent to the server which sent it.  Then the router MUST also create
   new channel key and distribute it to all clients on the channel and
   all servers that has clients on the channel.  Router MUST also send
   the SILC_NOTIFY_TYPE_JOIN notify type to local clients on the channel
   and to local servers that has clients on the channel.

   If the channel does not exist on the router's local list it MUST
   check the global list whether the channel exists at all.  If it does
   the client is joined to the channel as described previously.  If
   the channel does not exist the channel is created and the client
   is joined to the channel.  The channel key is also created and
   distributed as previously described.  The client joining to the created
   channel is made automatically channel founder and both channel founder
   and channel operator privileges is set for the client.

   If the router created the channel in the process, information about the
   new channel MUST be broadcasted to all routers.  This is done by



Riikonen                                                       [Page 33]

Internet Draft                                            21 August 2001


   broadcasting SILC_PACKET_NEW_CHANNEL packet to the router's primary
   route.  When the router joins the client to the channel it MUST also
   send information about newly joined client to all routers in the SILC
   network.  This is done by broadcasting the SILC_NOTIFY_TYPE_JOIN notify
   type to the router's primary route.

   It is important to note that new channel key is created always when
   new client joins to channel, whether the channel has existed previously
   or not.  This way the new client on the channel is not able to decrypt
   any of the old traffic on the channel.  Client which receives the reply to
   the join command MUST start using the received Channel ID in the channel
   message communication thereafter.  Client also receives the key for the
   channel in the command reply.  Note that the channel key is never
   generated if the SILC_CMODE_PRIVKEY mode is set.


4.4 Channel Key Generation

   Channel keys are created by router which creates the channel by taking
   enough randomness from cryptographically strong random number generator.
   The key is generated always when channel is created, when new client
   joins a channel and after the key has expired.  Key could expire for
   example in an hour.

   The key MUST also be re-generated whenever some client leaves a channel.
   In this case the key is created from scratch by taking enough randomness
   from the random number generator.  After that the key is distributed to
   all clients on the channel.  However, channel keys are cell specific thus
   the key is created only on the cell where the client, which left the
   channel, exists.  While the server or router is creating the new channel
   key, no other client may join to the channel.  Messages that are sent
   while creating the new key are still processed with the old key.  After
   server has sent the SILC_PACKET_CHANNEL_KEY packet MUST client start
   using the new key.  If server creates the new key the server MUST also
   send the new key to its router.  See [SILC2] on more information about
   how channel messages must be encrypted and decrypted when router is
   processing them.

   When client receives the SILC_PACKET_CHANNEL_KEY packet with the
   Channel Key Payload it MUST process the key data to create encryption
   and decryption key, and to create the HMAC key that is used to compute
   the MACs of the channel messages.  The processing is as follows:

     channel_key  = raw key data
     HMAC key     = hash(raw key data)

   The raw key data is the key data received in the Channel Key Payload.
   The hash() function is the hash function used in the HMAC of the channel.



Riikonen                                                       [Page 34]

Internet Draft                                            21 August 2001


   Note that the server MUST also save the channel key.


4.5 Private Message Sending and Reception

   Private messages are sent point to point.  Client explicitly destines
   a private message to specific client that is delivered to only to that
   client.  No other client may receive the private message.  The receiver
   of the private message is destined in the SILC Packet Header as any
   other packet as well.

   If the sender of a private message does not know the receiver's Client
   ID, it MUST resolve it from server.  There are two ways to resolve the
   client ID from server; it is RECOMMENDED that client implementations
   send SILC_COMMAND_IDENTIFY command to receive the Client ID.  Client
   MAY also send SILC_COMMAND_WHOIS command to receive the Client ID.
   If the sender has received earlier a private message from the receiver
   it should have cached the Client ID from the SILC Packet Header.

   See [SILC2] for description of private message encryption and decryption
   process.


4.6 Private Message Key Generation

   Private message MAY be protected by the key generated by the client.
   The key may be generated and sent to the other client by sending packet
   SILC_PACKET_PRIVATE_MESSAGE_KEY which travels through the network
   and is secured by session keys.  After that the private message key
   is used in the private message communication between those clients.

   Other choice is to entirely use keys that are not sent through
   the SILC network at all.  This significantly adds security.  This key
   would be pre-shared-key that is known by both of the clients.  Both
   agree about using the key and starts sending packets that indicate
   that the private message is secured using private message key.

   The key material used as private message key is implementation issue.
   However, SILC_PACKET_KEY_AGREEMENT packet MAY be used to negotiate
   the key material.  If the key is normal pre-shared-key or randomly
   generated key, and the SILC_PACKET_KEY_AGREEMENT was not used, then
   the key material SHOULD be processed as defined in the [SILC3].  In
   the processing, however, the HASH, as defined in [SILC3] MUST be
   ignored.  After processing the key material it is employed as defined
   in [SILC3], however, the HMAC key material MUST be discarded.

   If the key is pre-shared-key or randomly generated the implementations
   should use the SILC protocol's mandatory cipher as the cipher.  If the



Riikonen                                                       [Page 35]

Internet Draft                                            21 August 2001


   SKE was used to negotiate key material the cipher was negotiated as well.

4.7 Channel Message Sending and Reception

   Channel messages are delivered to group of users.  The group forms a
   channel and all clients on the channel receives messages sent to the
   channel.

   Channel messages are destined to channel by specifying the Channel ID
   as Destination ID in the SILC Packet Header.  The server MUST then
   distribute the message to all clients on the channel by sending the
   channel message destined explicitly to a client on the channel.

   See [SILC2] for description of channel message encryption and decryption
   process.


4.8 Session Key Regeneration

   Session keys MUST be regenerated periodically, say, once in an hour.
   The re-key process is started by sending SILC_PACKET_REKEY packet to
   other end, to indicate that re-key must be performed.  The initiator
   of the connection SHOULD initiate the re-key.

   If perfect forward secrecy (PFS) flag was selected in the SILC Key
   Exchange protocol [SILC3] the re-key MUST cause new key exchange with
   SKE protocol.  In this case the protocol is secured with the old key
   and the protocol results to new key material.  See [SILC3] for more
   information.  After the SILC_PACKET_REKEY packet is sent the sender
   will perform the SKE protocol.

   If PFS flag was set the resulted key material is processed as described
   in the section Processing the Key Material in [SILC3].  The difference
   with re-key in the processing is that the initial data for the hash
   function is just the resulted key material and not the HASH as it
   is not computed at all with re-key.  Other than that, the key processing
   it equivalent to normal SKE negotiation.

   If PFS flag was not set, which is the default case, then re-key is done
   without executing SKE protocol.  In this case, the new key is created by
   providing the current sending encryption key to the SKE protocol's key
   processing function.  The process is described in the section Processing
   the Key Material in [SILC3].  The difference in the processing is that
   the initial data for the hash function is the current sending encryption
   key and not the SKE's KEY and HASH values.  Other than that, the key
   processing is equivalent to normal SKE negotiation.

   After both parties has regenerated the session key, both MUST send



Riikonen                                                       [Page 36]

Internet Draft                                            21 August 2001


   SILC_PACKET_REKEY_DONE packet to each other.  These packets are still
   secured with the old key.  After these packets, the subsequent packets
   MUST be protected with the new key.




4.9 Command Sending and Reception

   Client usually sends the commands in the SILC network.  In this case
   the client simply sends the command packet to server and the server
   processes it and replies with command reply packet.

   However, if the server is not able to process the command, it is sent
   to the server's router.  This is case for example with commands such
   as, SILC_COMMAND_JOIN and SILC_COMMAND_WHOIS commands.  However, there
   are other commands as well.  For example, if client sends the WHOIS
   command requesting specific information about some client the server must
   send the WHOIS command to router so that all clients in SILC network
   are searched.  The router, on the other hand, sends the WHOIS command
   further to receive the exact information about the requested client.
   The WHOIS command travels all the way to the server which owns the client
   and it replies with command reply packet.  Finally, the server which
   sent the command receives the command reply and it must be able to
   determine which client sent the original command.  The server then
   sends command reply to the client.  Implementations should have some
   kind of cache to handle, for example, WHOIS information.  Servers
   and routers along the route could all cache the information for faster
   referencing in the future.

   The commands sent by server may be sent hop by hop until someone is able
   to process the command.  However, it is preferred to destine the command
   as precisely as it is possible.  In this case, other routers en route
   MUST route the command packet by checking the true sender and true
   destination of the packet.  However, servers and routers MUST NOT route
   command reply packets to clients coming from other server.  Client
   MUST NOT accept command reply packet originated from anyone else but
   from its own server.


4.10 Closing Connection

   When remote client connection is closed the server MUST send the notify
   type SILC_NOTIFY_TYPE_SIGNOFF to its primary router and to all channels
   the client was joined.  The server MUST also save the client's information
   for a period of time for history purposes.

   When remote server or router connection is closed the server or router



Riikonen                                                       [Page 37]

Internet Draft                                            21 August 2001


   MUST also remove all the clients that was behind the server or router
   from the SILC Network.  The server or router MUST also send the notify
   type SILC_NOTIFY_TYPE_SERVER_SIGNOFF to its primary router and to all
   local clients that are joined on the same channels with the remote
   server's or router's clients.


5 Security Considerations

   Security is central to the design of this protocol, and these security
   considerations permeate the specification.  Common security considerations
   such as keeping private keys truly private and using adequate lengths for
   symmetric and asymmetric keys must be followed in order to maintain the
   security of this protocol.

   Special attention must also be paid on the servers and routers that are
   running the SILC service.  The SILC protocol's security depends greatly
   on the security and the integrity of the servers and administrators that
   are running the service.  It is recommended that some form of registration
   is required by the server and router administrator prior acceptance to
   the SILC Network.  The clients must be able to trust the servers they
   are using.

   It must also be noted that if the client requires absolute security by
   not trusting any of the servers or routers in the SILC Network, this can
   be accomplished by negotiating private keys outside the SILC Network,
   either using SKE or some other key negotiation protocol, or to use some
   other external means for distributing the keys.  This applies for all
   messages, private messages and channel messages.  It is important to note
   that SILC, like any other security protocol is not full proof system and
   cannot secure from insecure environment; the SILC servers and routers could
   very well be compromised.  However, to provide acceptable level of security
   and usability for end user the protocol uses many times session keys or
   other keys generated by the servers to secure the messages.  If this is
   unacceptable for the client or end user, the private keys negotiatied
   outside the SILC Network should always be used.  In the end it is always
   implementor's choice whether to negotiate private keys by default or
   whether to use the keys generated by the servers.

   It is also recommended that router operators in the SILC Network would
   form a joint forum to discuss the router and SILC Network management
   issues.  Also, router operators along with the cell's server operators
   should have a forum to discuss the cell management issues.


6 References

   [SILC2]      Riikonen, P., "SILC Packet Protocol", Internet Draft,



Riikonen                                                       [Page 38]

Internet Draft                                            21 August 2001


                April 2001.

   [SILC3]      Riikonen, P., "SILC Key Exchange and Authentication
                Protocols", Internet Draft, April 2001.

   [SILC4]      Riikonen, P., "SILC Commands", Internet Draft, April 2001.

   [IRC]        Oikarinen, J., and Reed D., "Internet Relay Chat Protocol",
                RFC 1459, May 1993.

   [IRC-ARCH]   Kalt, C., "Internet Relay Chat: Architecture", RFC 2810,
                April 2000.

   [IRC-CHAN]   Kalt, C., "Internet Relay Chat: Channel Management", RFC
                2811, April 2000.

   [IRC-CLIENT] Kalt, C., "Internet Relay Chat: Client Protocol", RFC
                2812, April 2000.

   [IRC-SERVER] Kalt, C., "Internet Relay Chat: Server Protocol", RFC
                2813, April 2000.

   [SSH-TRANS]  Ylonen, T., et al, "SSH Transport Layer Protocol",
                Internet Draft.

   [PGP]        Callas, J., et al, "OpenPGP Message Format", RFC 2440,
                November 1998.

   [SPKI]       Ellison C., et al, "SPKI Certificate Theory", RFC 2693,
                September 1999.

   [PKIX-Part1] Housley, R., et al, "Internet X.509 Public Key
                Infrastructure, Certificate and CRL Profile", RFC 2459,
                January 1999.

   [Schneier]   Schneier, B., "Applied Cryptography Second Edition",
                John Wiley & Sons, New York, NY, 1996.

   [Menezes]    Menezes, A., et al, "Handbook of Applied Cryptography",
                CRC Press 1997.

   [OAKLEY]     Orman, H., "The OAKLEY Key Determination Protocol",
                RFC 2412, November 1998.

   [ISAKMP]     Maughan D., et al, "Internet Security Association and
                Key Management Protocol (ISAKMP)", RFC 2408, November
                1998.




Riikonen                                                       [Page 39]

Internet Draft                                            21 August 2001


   [IKE]        Harkins D., and Carrel D., "The Internet Key Exchange
                (IKE)", RFC 2409, November 1998.

   [HMAC]       Krawczyk, H., "HMAC: Keyed-Hashing for Message
                Authentication", RFC 2104, February 1997.

   [PKCS1]      Kalinski, B., and Staddon, J., "PKCS #1 RSA Cryptography
                Specifications, Version 2.0", RFC 2437, October 1998.

   [RFC2119]    Bradner, S., "Key Words for use in RFCs to Indicate
                Requirement Levels", BCP 14, RFC 2119, March 1997.


7 Author's Address

   Pekka Riikonen
   Snellmanninkatu 34 A 15
   70100 Kuopio
   Finland

   EMail: priikone@silcnet.org

   This Internet-Draft expires 21 February 2002




























Riikonen                                                       [Page 40]
