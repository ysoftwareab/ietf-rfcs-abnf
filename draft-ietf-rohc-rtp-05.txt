



Network Working Group              Carsten Bormann (ed.), TZI/Uni Bremen
INTERNET-DRAFT
Expires: April 2000
                                          Carsten Burmeister, Matsushita
                                              Christopher Clanton, Nokia
                                          Mikael Degermark, U of Arizona
                                           Hideaki Fukushima, Matsushita
                                                    Hans Hannu, Ericsson
                                             Lars-Erik Jonsson, Ericsson
                                              Rolf Hakenberg, Matsushita
                                                      Tmima Koren, Cisco
                                                         Khiem Le, Nokia
                                                      Zhigang Liu, Nokia
                                              Anton Martensson, Ericsson
                                            Akihiro Miyazaki, Matsushita
                                               Krister Svanbro, Ericsson
                                               Thomas Wiebke, Matsushita
                                           Takeshi Yoshimura, NTT DoCoMo
                                                    Haihong Zheng, Nokia

                                                        October 23, 2000
                     RObust Header Compression (ROHC)
                       <draft-ietf-rohc-rtp-05.txt>




Status of this memo

   This document is an Internet-Draft and is in full conformance with
   all provisions of Section 10 of RFC2026.

   Internet-Drafts are working documents of the Internet Engineering
   Task Force (IETF), its areas, and its working groups. Note that other
   groups may also distribute working documents as Internet-Drafts.

   Internet-Drafts are draft documents valid for a maximum of six months
   and may be updated, replaced, or obsoleted by other documents at any
   time. It is inappropriate to use Internet-Drafts as reference
   material or cite them other than as "work in progress".

   The list of current Internet-Drafts can be accessed at
   http://www.ietf.org/ietf/lid-abstracts.txt

   The list of Internet-Draft Shadow Directories can be accessed at
   http://www.ietf.org/shadow.html

   This document is a product of the IETF ROHC WG. Comments should be
   directed to its mailing list, rohc@cdt.luth.se.




Bormann (ed.)                                                   [Page 1]

INTERNET-DRAFT          Robust Header Compression           Oct 23, 2000



Abstract

   Existing header compression schemes do not work well when used over
   links with significant error rates and long round-trip times. For
   many bandwidth limited links where header compression is essential,
   such characteristics are common.

   A highly robust and efficient header compression scheme for
   RTP/UDP/IP and UDP/IP is specified in this document. The scheme can
   adapt to the characteristics of the link over which it is used and
   also to the properties of the packet streams whose headers it
   compresses.


Revision History

   -05: Editorial changes
   -04: Complete 5.5 and 5.8.  Remove section 7 (no longer needed) and
          renumber.  Restructure section 5 to clearly separate the
          profiles.
   -03: Redo packet formats to allow new ROHC framework. Fill in gaps.
   -02: Major changes after 48th IETF
   -01: Minor editorial changes for 48th IETF
   -00: Document created from ROHC submissions

ROHC WG internal short-term time plan

   This document is intended as the penultimate version before last-
   calling the final revision on Oct 31.
























Bormann (ed.)                                                   [Page 2]

INTERNET-DRAFT          Robust Header Compression           Oct 23, 2000


Table of contents

   Status of this memo.................................................1
   Abstract............................................................2
   Revision History....................................................2
   ROHC WG internal short-term time plan...............................2
   Table of contents...................................................3
   1.  Introduction....................................................7
   2.  Terminology.....................................................9
   3.  Background.....................................................13
   3.1.  Header compression fundamentals..............................13
   3.2.  Existing header compression schemes..........................13
   3.3.  Requirements on a new header compression scheme..............14
   3.4.  Classification of header fields..............................15
   4.  Header compression framework...................................17
   4.1.  Operating assumptions .......................................17
   4.2.  Dynamicity...................................................18
   4.3.  Compression and decompression states.........................19
   4.3.1.  Compressor states..........................................19
   4.3.1.1.  Initialization and Refresh (IR) State....................20
   4.3.1.2.  First Order (FO) State...................................20
   4.3.1.3.  Second Order (SO) State..................................21
   4.3.2.  Decompressor states........................................21
   4.4.  Modes of operation...........................................21
   4.4.1.  Unidirectional mode - U-mode...............................22
   4.4.2.  Bi-directional optimistic mode - O-mode....................23
   4.4.3.  Bi-directional reliable mode - R-mode......................23
   4.5.  Encoding methods.............................................23
   4.5.1.  Least Significant Bits (LSB) encoding .....................24
   4.5.2.  Window-based LSB encoding (W-LSB encoding).................26
   4.5.2.  Scaled RTP Timestamp encoding .............................27
   4.5.4.  Timer-Based Compression of RTP Timestamp...................29
   4.5.5.  Offset IP-ID encoding......................................31
   4.5.6.  Self-describing variable-length values. ...................33
   4.5.7.  Encoded values across several fields in compressed headers.33
   4.6  Errors caused by residual errors..............................34
   5.  The protocol...................................................35
   5.1.  Data structures..............................................35
   5.1.1.  Per-channel parameters.....................................35
   5.1.2.  Per-context parameters, profiles...........................35
   5.1.3.  Contexts and context identifiers ..........................36
   5.2. ROHC Packets & packet types...................................36
   5.2.1.  ROHC feedback .............................................38
   5.2.2.  ROHC feedback format ......................................39
   5.2.3.  ROHC IR packet type .......................................42
   5.2.4.  ROHC segmentation..........................................42
   5.2.5.  ROHC Initial decompressor processing.......................44
   5.2.6.  ROHC RTP Packet formats from compressor to decompressor....45
   5.2.7.  Parameters needed for mode transition in ROHC RTP..........46
   5.3.  Operation in unidirectional mode.............................47
   5.3.1.  Compressor states and logic (U-mode).......................47



Bormann (ed.)                                                   [Page 3]

INTERNET-DRAFT          Robust Header Compression           Oct 23, 2000


   5.3.1.1.  State transition logic (U-mode)..........................47
   5.3.1.1.1.  Optimistic approach, upwards transition................47
   5.3.1.1.2.  Timeouts, downward transition..........................48
   5.3.1.1.3.  Need for updates, downward transition..................48
   5.3.1.2.  Compression logic and packets used (U-mode)..............48
   5.3.1.3.  Feedback in unidirectional mode..........................48
   5.3.2.  Decompressor states and logic (U-mode).....................48
   5.3.2.1.  State transition logic (U-mode)..........................49
   5.3.2.2.  Decompression logic (U-mode).............................49
   5.3.2.2.1.  Decide whether decompression is allowed................49
   5.3.2.2.2.  Reconstruct and verify the header......................49
   5.3.2.2.3.  Actions upon CRC failure...............................50
   5.3.2.2.4.  Correction of SN LSB wrap-around.......................51
   5.3.2.2.5.  Repair of incorrect SN updates.........................52
   5.3.2.3.  Feedback in unidirectional mode..........................53
   5.4.  Operation in bi-directional optimistic mode..................54
   5.4.1.  Compressor states and logic (O-mode).......................54
   5.4.1.1.  State transition logic...................................54
   5.4.1.1.1.  Negative acknowledgments (NACKs), downward transition..54
   5.4.1.1.2.  Optional acknowledgments, upwards transition...........55
   5.4.1.2.  Compression logic and packets used.......................55
   5.4.2.  Decompressor states and logic (O-mode).....................55
   5.4.2.1.  Decompression logic, timer-based timestamp decompression.55
   5.4.2.2.  Feedback logic (O-mode)..................................56
   5.5.  Operation in bi-directional reliable mode....................57
   5.5.1.  Compressor states and logic (R-mode).......................57
   5.5.1.1.  State transition logic (R-mode)..........................57
   5.5.1.1.1 Upwards transition.......................................57
   5.5.1.1.2 Downward transition......................................57
   5.5.1.2.  Compression logic and packets used (R-mode)..............58
   5.5.2.  Decompressor states and logic (R-mode).....................58
   5.5.2.1.  Decompression logic (R-mode).............................58
   5.5.2.2.  Feedback logic (R-mode)..................................59
   5.6.1.  Compression and decompression during mode transitions......60
   5.6.2.  Transition from Unidirectional to Optimistic mode..........61
   5.6.3.  From Optimistic to Reliable mode...........................61
   5.6.4.  From Unidirectional to Reliable mode.......................62
   5.6.5.  From Reliable to Optimistic mode...........................62
   5.6.6.  Transition to Unidirectional mode..........................63
   5.7.  Packet formats ..............................................64
   5.7.1.  Packet type 0: UO-0, R-0, R-0-CRC .........................67
   5.7.2.  Packet type 1 (R-mode): R-1, R-1-TS, R-1-ID ...............68
   5.7.3.  Packet type 1 (UO-modes): UO-1, UO-1-ID, UO-1-TS ..........69
   5.7.4.  Packet type 2: UOR-2 ......................................70
   5.7.5.  Extension formats..........................................71
   5.7.5.1.  RND flags and packet types...............................75
   5.7.5.2.  Flags/Fields in context..................................76
   5.7.6.  Feedback packets and formats...............................77
   5.7.6.1.  Feedback formats for ROHC RTP............................77
   5.7.6.2.  ROHC RTP Feedback options................................78
   5.7.6.3.  The CRC option...........................................79



Bormann (ed.)                                                   [Page 4]

INTERNET-DRAFT          Robust Header Compression           Oct 23, 2000


   5.7.6.4.  The REJECT option........................................79
   5.7.6.5.  The SN option............................................79
   5.7.6.6.  The CLOCK option.........................................80
   5.7.6.7.  The JITTER option........................................80
   5.7.6.8.  The LOSS option..........................................81
   5.7.6.9.  Unknown option types.....................................81
   5.7.6.10.  RTP feedback example....................................81
   5.7.7.  RTP IR and IR-DYN packets..................................82
   5.7.7.2.  Basic structure of the IR-DYN packet.....................84
   5.7.7.3.  Initialization of IPv6 Header [IPv6].....................85
   5.7.7.4. Initialization of IPv4 Header [IPv4, section 3.1].........86
   5.7.7.5. Initialization of UDP Header [RFC-768]....................87
   5.7.7.6. Initialization of RTP Header [RTP]........................87
   5.7.7.7 Initialization of ESP header [ESP, section 2] .............89
   5.8.  List compression.............................................89
   5.8.1 Table-based item compression.................................90
   5.8.1.1 Translation Table in R-mode................................91
   5.8.1.2 Translation Table in U/O-modes.............................91
   5.8.2 Reference list determination.................................92
   5.8.2.1 Reference list in R-mode and UO-modes......................92
   5.8.3 Encoding Schemes for the compressed list.....................94
   5.8.4.  Special Handling for IP Extension Headers..................97
   5.8.4.1.  Next Header Field........................................97
   5.8.4.2.  Authentication Header (AH)...............................99
   5.8.4.3.  Encapsulating Security Payload Header....................99
   5.8.4.4.  Mobile IPv6 Related Destination Option Header...........101
   5.8.4.5.  GRE Header..............................................102
   5.8.5.  Format of Compressed Lists................................103
   5.8.5.1.  Format of IP Extension Hdr(s) field.....................103
   5.8.5.2 Format of Compressed CSRC List............................104
   5.8.6 Compressed list formats.....................................104
   5.8.6.1  Encoding Type 0 (generic scheme).........................104
   5.8.6.2 Encoding Type 1 (insertion only scheme)...................106
   5.8.6.3 Encoding Type 2 (removal only scheme).....................107
   5.8.6.4 Encoding Type 3 (remove then insert scheme) ..............108
   5.8.7 CRC coverage for extension headers .........................108
   5.9.  Header compression CRCs, coverage and polynomials...........108
   5.9.1.  IR & IR-DYN packet CRCs...................................109
   5.9.2.  CRCs in compressed packets................................109
   5.10. ROHC UNCOMPRESSED _ no compression (Profile 0)..............110
   5.10.1 IR packet..................................................110
   5.10.2 Normal packet..............................................111
   5.10.3 States and Modes...........................................111
   5.10.4 Feedback...................................................112
   5.11. ROHC UDP - non-RTP UDP/IP compression (Profile 2)...........113
   5.11.1 Initialization.............................................113
   5.11.2 States and Modes...........................................114
   5.11.3 Packet types...............................................114
   5.11.4 Extensions.................................................115
   5.11.5 IP-ID......................................................116
   5.11.6. Feedback..................................................116



Bormann (ed.)                                                   [Page 5]

INTERNET-DRAFT          Robust Header Compression           Oct 23, 2000


   5.12. ROHC ESP - ESP/IP compression (Profile 3)...................116
   5.12.1.  Initialization...........................................116
   5.12.2.  Packet types.............................................117
   6.  Implementation issues.........................................118
   6.1.  Reverse decompression.......................................118
   6.2.  RTCP........................................................119
   6.3.  Implementation parameters and signals.......................119
   6.3.1.  ROHC implementation parameters at compressor:.............120
   6.3.2.  ROHC implementation parameters at decompressor:...........121
   6.4.  Handling of resource limitations at the decompressor........122
   6.5.  Implementation structures...................................122
   6.5.1. Compressor Context.........................................122
   6.5.2. Decompressor Context.......................................124
   6.5.3. List Compression: Sliding Windows in R-mode and UO-modes...125
   7.  Security considerations.......................................126
   8.  IANA Considerations...........................................127
   9.  Acknowledgments...............................................127
   8z.  Intellectual property considerations.........................128
   10.  References...................................................129
   11.  Authors' addresses...........................................130
   Appendix A.  Detailed classification of header fields.............131
   A.1.  General classification......................................131
   A.1.1.  IPv6 header fields........................................132
   A.1.2.  IPv4 header fields........................................133
   A.1.3.  UDP header fields.........................................135
   A.1.4.  RTP header fields.........................................136
   A.1.5.  Summary for IP/UDP/RTP....................................137
   A.2.  Analysis of change patterns of header fields................137
   A.2.1.  IPv4 Identification.......................................139
   A.2.2.  IP Traffic-Class / Type-Of-Service........................140
   A.2.3.  IP Hop-Limit / Time-To-Live...............................141
   A.2.4.  UDP Checksum..............................................141
   A.2.5.  RTP CSRC Counter..........................................141
   A.2.6.  RTP Marker................................................141
   A.2.7.  RTP Payload Type..........................................141
   A.2.8.  RTP Sequence Number.......................................141
   A.2.9.  RTP Timestamp.............................................141
   A.2.10.  RTP Contributing Sources (CSRC)..........................142
   A.3.  Header compression strategies...............................142
   A.3.1.  Do not send at all........................................142
   A.3.2.  Transmit only initially...................................143
   A.3.3.  Transmit initially, but be prepared to update.............143
   A.3.4.  Be prepared to update or send as-is frequently............143
   A.3.5.  Guarantee continuous robustness...........................143
   A.3.6.  Transmit as-is in all packets.............................144
   A.3.7.  Establish and be prepared to update delta.................144
   Appendix B.  Encoding Examples....................................145
   B.1.  Basic W-LSB.................................................145
   B.2.  Timer-Based Compression.....................................146





Bormann (ed.)                                                   [Page 6]

INTERNET-DRAFT          Robust Header Compression           Oct 23, 2000


1.  Introduction

   During the last five years, two communication technologies in
   particular have become commonly used by the general public: cellular
   telephony and the Internet. Cellular telephony has provided its users
   with the revolutionary possibility of always being reachable with
   reasonable service quality no matter where they are. The main service
   provided by the dedicated terminals has been speech. The Internet, on
   the other hand, has from the beginning been designed for multiple
   services and its flexibility for all kinds of usage has been one of
   its strengths. Internet terminals have usually been general-purpose
   and have been attached over fixed connections. The experienced
   quality of some services (such as Internet telephony) has sometimes
   been low.

   Today, IP telephony is gaining momentum thanks to improved technical
   solutions. It seems reasonable to believe that in the years to come,
   IP will become a commonly used way to carry telephony. Some future
   cellular telephony links might also be based on IP and IP telephony.
   Cellular phones may have become more general-purpose, and may have IP
   stacks supporting not only audio and video, but also web browsing,
   email, gaming, etc.

   One of the scenarios we are envisioning might then be the one in
   Figure 1.1, where two mobile terminals are communicating with each
   other. Both are connected to base stations over cellular links, and
   the base stations are connected to each other through a wired (or
   possibly wireless) network. Instead of two mobile terminals, there
   could of course be one mobile and one wired terminal, but the case
   with two cellular links is technically more demanding.


   Mobile            Base                      Base            Mobile
   Terminal          Station                   Station         Terminal


         |  ~   ~   ~  \ /                       \ /  ~   ~   ~   ~  |
         |              |                         |                  |
      +--+              |                         |               +--+
      |  |              |                         |               |  |
      |  |              |                         |               |  |
      +--+              |                         |               +--+
                        |                         |
                        |=========================|

            Cellular              Wired               Cellular
            Link                  Network             Link

        Figure 1.1 : Scenario for IP telephony over cellular links





Bormann (ed.)                                                   [Page 7]

INTERNET-DRAFT          Robust Header Compression           Oct 23, 2000


   It is obvious that the wired network can be IP-based. With the
   cellular links, the situation is less clear. IP could be terminated
   in the fixed network, and special solutions implemented for each
   supported service over the cellular link. However, this would limit
   the flexibility of the services supported. If technically and
   economically feasible, a solution with pure IP all the way from
   terminal to terminal would have certain advantages. However, to make
   this a viable alternative, a number of problems have to be addressed,
   in particular problems regarding bandwidth efficiency.

   For cellular phone systems, it is of vital importance to use the
   scarce radio resources in an efficient way. A sufficient number of
   users per cell is crucial, otherwise deployment costs will be
   prohibitive [CELL]. The quality of the voice service should also be
   as good as in today's cellular systems. It is likely that even with
   support for new services, lower quality of the voice service is
   acceptable only if costs are significantly reduced.

   A problem with IP over cellular links when used for interactive voice
   conversations is the large header overhead. Speech data for IP
   telephony will most likely be carried by RTP [RTP]. A packet will
   then, in addition to link layer framing, have an IP [IPv4] header (20
   octets), a UDP [UDP] header (8 octets), and an RTP header (12 octets)
   for a total of 40 octets. With IPv6 [IPv6], the IP header is 40
   octets for a total of 60 octets. The size of the payload depends on
   the speech coding and frame sizes being used and may be as low as 15-
   20 octets.

   From these numbers, the need for reducing header sizes for efficiency
   reasons is obvious. However, cellular links have characteristics that
   make header compression as defined in [IPHC,CRTP,PPPHC] perform less
   than well. The most important characteristic is the lossy behavior of
   cellular links, where a bit error rate (BER) as high as 1e-3 must be
   accepted to keep the radio resources efficiently utilized [CELL]. In
   severe operating situations, the BER can be as high as 1e-2. The
   other problematic characteristic is the long round-trip time (RTT) of
   the cellular link, which can be as high as 100-200 milliseconds
   [CELL]. An additional problem is that the residual BER is nontrivial,
   i.e., lower layers can sometimes deliver frames containing undetected
   errors. A viable header compression scheme for cellular links must be
   able to handle loss on the link between the compression and
   decompression point as well as loss before the compression point.

   Bandwidth is the most costly resource in cellular links. Processing
   power is very cheap in comparison. Implementation or computational
   simplicity of a header compression scheme is therefore of less
   importance than its compression ratio and robustness.







Bormann (ed.)                                                   [Page 8]

INTERNET-DRAFT          Robust Header Compression           Oct 23, 2000


2.  Terminology

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
   document are to be interpreted as described in RFC 2119.

   BER

     Bit Error Rate. Cellular radio links can have a rather high BER. In
     this document BER is usually given as a probability, but one also
     needs to consider the error distribution as bit errors are not
     independent.

   Cellular links

     Wireless links between mobile terminals and base stations.

   Compression efficiency

     The performance of a header compression scheme can be described
     with three parameters, compression efficiency, robustness and
     compression transparency. The compression efficiency is determined
     by how much the header sizes are reduced by the compression scheme.

   Compression transparency

     The performance of a header compression scheme can be described
     with three parameters, compression efficiency, robustness and
     compression transparency. The compression transparency is a measure
     for how well the scheme ensures that the decompressed headers are
     semantically identical to the original headers. If all decompressed
     headers are semantically identical to the corresponding original
     headers, the transparency is 100 per cent. Compression transparency
     is high when damage propagation is low.

   Context

     The context of the compressor is the state it uses to compress a
     header. The context of the decompressor is the state it uses to
     decompress a header. Either of these or the two in combination are
     usually referred to as "context", when it is clear which is
     intended. The context contains relevant information from previous
     headers in the packet stream, such as static fields and possible
     reference values for compression and decompression. Moreover,
     additional information describing the packet stream is also part of
     the context, for example information about how the IP Identifier
     field changes and the typical inter-packet increase in sequence
     numbers or timestamps.

   Context damage




Bormann (ed.)                                                   [Page 9]

INTERNET-DRAFT          Robust Header Compression           Oct 23, 2000


     When the context of the decompressor is not consistent with the
     context of the compressor, decompression may fail to reproduce the
     original header. This situation can occur when the context of the
     decompressor has not been initialized properly or when packets have
     been lost or damaged between compressor and decompressor. Packets
     for which the decompressor detects they cannot be decompressed due
     to inconsistent contexts are said to be lost due to context damage.

   Context repair mechanism

     Context repair mechanisms are mechanisms that bring the contexts in
     sync when they were not. This is needed to avoid excessive loss due
     to context damage. Examples are the context request mechanism of
     CRTP, the NACK mechanisms of O- and R-mode, and the periodic
     refreshes of U-mode.

     Note that there are also mechanisms that prevents (some) context
     inconsistencies from occurring, for example the ACK-based updates
     of the context in R-mode, the repetitions after change in U- and O-
     mode, and the CRCs which protect context updating information.

   CRC-DYNAMIC

     Opposite of CRC-STATIC.

   CRC-STATIC

     A CRC over the original header is the primary mechanism of ROHC to
     detect incorrect decompression. In order to decrease computational
     complexity, the fields of the header are conceptually rearranged
     when computing the CRC, such that it is first computed over octets
     which are static (called CRC-STATIC in this document) and then over
     octets whose values are expected to change between packets (CRC-
     DYNAMIC). In this manner, the intermediate result of the CRC
     computation, after it has covered the CRC-STATIC fields, can be
     reused for several packets. The restarted CRC computation only
     covers the CRC-DYNAMIC octets. See section 5.9.

   Damage propagation

     Generation of incorrect decompressed headers due to damage to
     previous packet(s).

   Loss propagation

     Failure to decompress headers due to loss of previous frame(s).

   Error detection

     Detection of errors. If error detection is not perfect, there will
     be residual errors.



Bormann (ed.)                                                  [Page 10]

INTERNET-DRAFT          Robust Header Compression           Oct 23, 2000



   Error propagation

     Damage propagation or loss propagation.

   Header compression profile

     A header compression profile is a specification of how to compress
     the headers of a certain kind of packet stream over a certain kind
     of link. Compression profiles provide the details of the header
     compression framework introduced in this document. The profile
     concept makes use of profile identifiers to separate different
     profiles which are used when setting up the compression scheme. All
     variations and parameters of the header compression scheme that are
     not part of the context state are handled by different profile
     identifiers.

   Packet

     Generally, a unit of transmission and reception (protocol data
     unit). Specifically, when contrasted to "frame", the packet
     compressed and then decompressed by ROHC.  Also called
     "uncompressed packet".

   Pre-HC links

     Pre-HC links are all links a packet has traversed before the header
     compression point. If we consider a path with cellular links as
     first and last hops, the Pre-HC links for the compressor at the
     last link are the first cellular link plus the wired links in
     between.

   Residual error

     Error introduced during transmission and not detected by lower-
     layer error detection schemes.

   Robustness

     The performance of a header compression scheme can be described
     with three parameters, compression efficiency, robustness and
     compression transparency. A robust scheme tolerates loss and
     residual errors on the link over which header compression takes
     place without losing additional packets or introducing additional
     errors in decompressed headers.

   RTT

     Round-trip time - Time elapsed between a packet is sent by the
     compressor and feedback related to that packet is received by the
     compressor, when such feedback is sent.



Bormann (ed.)                                                  [Page 11]

INTERNET-DRAFT          Robust Header Compression           Oct 23, 2000


   Spectrum efficiency

     Radio resources are limited and expensive. Therefore they must be
     used efficiently to make the system economically feasible. In
     cellular systems this is achieved by maximizing the number of users
     served within each cell, while the quality of the provided services
     is kept at an acceptable level. A consequence of efficient spectrum
     use is a high rate of errors (frame loss and residual bit errors),
     even after channel coding with error correction.

   String

     A sequence of headers in which the values of all fields being
     compressed change with a fixed pattern with respect to a sequence
     number, so that it can be compressed by representing it with a
     sequence of ROHC headers that essentially just carry an encoded
     sequence number. Note that fields not being compressed (e.g. random
     IP-ID, UDP checksum) are irrelevant to this definition.

   Timestamp stride

     The timestamp stride (TS STRIDE) is the expected increase in the
     timestamp value between two RTP packets with consecutive sequence
     numbers.






























Bormann (ed.)                                                  [Page 12]

INTERNET-DRAFT          Robust Header Compression           Oct 23, 2000


3.  Background

   This chapter provides a background to the subject of header
   compression. The fundamental ideas are described together with
   descriptions of existing header compression schemes, their drawbacks
   and requirements and motivation for new header compression solutions.


3.1.  Header compression fundamentals

   The main reason why header compression can be done at all is the fact
   that there is significant redundancy between header fields, both
   within the same packet header but in particular between consecutive
   packets belonging to the same packet stream. By sending static field
   information only initially and utilizing dependencies and
   predictability for other fields, the header size can be significantly
   reduced for most packets.

   Relevant information from past packets is maintained in a context.
   The context information is used to compress (decompress) subsequent
   packets. The compressor and decompressor updates their contexts upon
   certain events. Impairment events may lead to inconsistencies between
   the contexts of the compressor and decompressor, which in turn may
   cause incorrect decompression. A robust header compression scheme
   needs mechanisms for avoiding context inconsistencies and also needs
   mechanisms for making the contexts consistent when they were not.


3.2.  Existing header compression schemes

   The original header compression scheme, CTCP [VJHC], was invented by
   Van Jacobson. CTCP compresses the 40 octet IP+TCP header to 4 octets.
   The CTCP compressor detects transport-level retransmissions and sends
   a header that updates the context completely when they occur. This
   repair mechanism does not require any explicit signaling between
   compressor and decompressor.

   A general IP header compression scheme, IP header compression [IPHC],
   improves somewhat on CTCP and can compress arbitrary IP, TCP, and UDP
   headers. When compressing non-TCP headers, IPHC does not use delta
   encoding and is robust. When compressing TCP, the repair mechanism of
   CTCP is augmented with a link-level nacking scheme which speeds up
   the repair. IPHC does not compress RTP headers.

   CRTP [CRTP, IPHC] by Casner and Jacobson is a header compression
   scheme that compresses 40 octets of IPv4/UDP/RTP headers to a minimum
   of 2 octets when the UDP checksum is not enabled. If the UDP checksum
   is enabled, the minimum CRTP header is 4 octets. CRTP cannot use the
   same repair mechanism as CTCP since UDP/RTP does not retransmit.
   Instead, CRTP uses explicit signaling messages from decompressor to
   compressor, called CONTEXT_STATE messages, to indicate that the



Bormann (ed.)                                                  [Page 13]

INTERNET-DRAFT          Robust Header Compression           Oct 23, 2000


   context is out of sync. The link roundtrip time will thus limit the
   speed of this context repair mechanism.

   On lossy links with long roundtrip times, such as most cellular
   links, CRTP does not perform well. Each lost packet over the link
   causes several subsequent packets to be lost since the context is out
   of sync during at least one link roundtrip time. This behavior is
   documented in [CRTPC]. For voice conversations such long loss events
   will degrade the voice quality. Moreover, bandwidth is wasted by the
   large headers sent by CRTP when updating the context. [CRTPC] found
   that CRTP did not perform well enough for a lossy cellular link. It
   is clear that CRTP alone is not a viable header compression scheme
   for IP telephony over cellular links.

   To avoid losing packets due to the context being out of sync, CRTP
   decompressors can attempt to repair the context locally by using a
   mechanism known as TWICE. Each CRTP packet contains a counter which
   is incremented by one for each packet sent out by the CRTP
   compressor. If the counter increases by more than one, at least one
   packet was lost over the link. The decompressor then attempts to
   repair the context by guessing how the lost packet(s) would have
   updated it. The guess is then verified by decompressing the packet
   and checking the UDP checksum - if it succeeds, the repair is deemed
   successful and the packet can be forwarded or delivered. TWICE
   derives its name from the observation that when the compressed packet
   stream is regular, the correct guess is to apply the update in the
   current packet twice. [CRTPC] found that even with TWICE, CRTP
   doubled the number of lost packets. TWICE improves CRTP performance
   significantly. However, there are several problems with using TWICE:

   1) It becomes mandatory to use the UDP checksum:

      - the minimal compressed header size increases by 100% to 4
        octets.

      - most speech codecs developed for cellular links tolerate errors
        in the encoded data. Such codecs will not want to enable the UDP
        checksum, since they do want damaged packets to be delivered.

      - errors in the payload will make the UDP checksum fail when the
        guess is correct (and might make it succeed when it is wrong).

   2) Loss in an RTP stream that occurs before the compression point
      will make updates in CRTP headers less regular. Simple-minded
      versions of TWICE will then perform badly. More sophisticated
      versions would need more repair attempts to succeed.


3.3.  Requirements on a new header compression scheme

   The major problem with CRTP is that it is not sufficiently robust



Bormann (ed.)                                                  [Page 14]

INTERNET-DRAFT          Robust Header Compression           Oct 23, 2000


   against packets being damaged between compressor and decompressor. A
   viable header compression scheme must be less fragile. This increased
   robustness must be obtained without increasing the compressed header
   size; a larger header would make IP telephony over cellular links
   economically unattractive.

   A major cause of the bad performance of CRTP over cellular links is
   the long link roundtrip time, during which many packets are lost when
   the context is out of sync. This problem can be attacked directly by
   finding ways to reduce the link roundtrip time. Future generations of
   cellular technologies may indeed achieve lower link roundtrip times.
   However, these will probably always be rather high [CELL]. The
   benefits in terms of lower loss and smaller bandwidth demands if the
   context can be repaired locally will be present even if the link
   roundtrip time is decreased. A reliable way to detect a successful
   context repair is then needed.

   One might argue that a better way to solve the problem is to improve
   the cellular link so that packet loss is less likely to occur. Such
   modifications do not appear to come for free, however. If links were
   made (almost) error free, the system might not be able to support a
   sufficiently large number of users per cell and might thus be
   economically infeasible [CELL].

   One might also argue that the speech codecs should be able to deal
   with the kind of packet loss induced by CRTP, in particular since the
   speech codecs probably must be able to deal with packet loss anyway
   if the RTP stream crosses the Internet. While the latter is true, the
   kind of loss induced by CRTP is difficult to deal with. It is usually
   not possible to completely hide a loss event where well over 100 ms
   worth of sound is completely lost. If such loss occurs frequently at
   both ends of the end-to-end path, the speech quality will suffer.

   A detailed description of the requirements specified for ROHC may be
   found in [REQ].


3.4.  Classification of header fields

   As mentioned earlier, header compression is possible due to the fact
   that there is much redundancy between header field values within
   packets, but especially between consecutive packets. To utilize these
   properties for header compression, it is important to understand the
   change patterns of the various header fields.

   All header fields have been classified in detail in appendix A. The
   fields are first classified on a high level and then some of them are
   studied more in detail. Finally, the appendix concludes with
   recommendations about how the various fields should be handled by
   header compression algorithms. The main conclusion that can be drawn
   is that most of the header fields can easily be compressed away since



Bormann (ed.)                                                  [Page 15]

INTERNET-DRAFT          Robust Header Compression           Oct 23, 2000


   they never or seldom change. Only 5 fields, with a combined size of
   about 10 octets, need more sophisticated mechanisms. Those fields
   are:

    - IPv4 Identification (16 bits)   - IP-ID
    - UDP Checksum (16 bits)
    - RTP Marker (1 bit)              - M-bit
    - RTP Sequence Number (16 bits)   - SN
    - RTP Timestamp (32 bits)         - TS

   The analysis in Appendix A reveals that the values of the TS and IP-
   ID fields can usually be predicted from the RTP Sequence Number,
   which increments by one for each packet emitted by an RTP source. M-
   bit is also usually the same, but needs to be communicated explicitly
   occasionally. The UDP checksum should not be predicted and is sent
   as-is when enabled.

   The way ROHC RTP compression operates, then, is to first establish
   functions from SN to the other fields, and then reliably communicate
   the SN. Whenever a function from SN to another field changes, i.e.,
   the existing function gives a result which is different from the
   field in the header to be compressed, additional information is sent
   to update the parameters of that function.































Bormann (ed.)                                                  [Page 16]

INTERNET-DRAFT          Robust Header Compression           Oct 23, 2000



4.  Header compression framework


4.1.  Operating assumptions

   The cellular links which are a primary target for ROHC have a number
   of characteristics that are briefly described here. ROHC requires
   functionality from lower layers which is outlined here and more
   thoroughly described in the lower layer guidelines document [LLG].

   Channels

     ROHC header-compressed packets flow on channels. Unlike many fixed
     links, some cellular radio links can have several channels
     connecting the same pair of nodes. Each channel can have different
     characteristics in terms of error rate, bandwidth, etc.

   Context identifiers

     On some channels, the ability to transport multiple packet streams
     is required.  It can also be feasible to have channels dedicated to
     individual packet streams. Therefore, ROHC uses a distinct context
     identifier space per channel and can eliminate context identifiers
     completely for one stream when few streams share a channel.

   Packet type indication

     Packet type indication is done in the header compression scheme
     itself. Unless the link already has a way of indicating packet
     types which can be used, such as PPP, this provides smaller
     compressed headers, overall. It may also be less difficult to
     allocate a single packet type, rather than many, in order to run
     ROHC over links such as PPP.

   Reordering

     The channel between compressor and decompressor is not assumed to
     reorder packets, i.e., the decompressor receives packets in the
     same order as the compressor sends them.  (Reordering before the
     compression point, however, is dealt with, i.e., there is no
     assumption that the compressor will only receive packets in
     sequence.)

   Packet length


     ROHC is designed under the assumption that lower layers indicate
     the length of a compressed packet. ROHC packets do not contain
     length information for the payload.




Bormann (ed.)                                                  [Page 17]

INTERNET-DRAFT          Robust Header Compression           Oct 23, 2000


   Framing

     The link layer must provide framing, which makes it possible to
     distinguish frame boundaries and individual frames.

   Error detection/protection

     The ROHC scheme has been designed to cope with residual errors in
     the headers delivered to the decompressor. CRCs and sanity checks
     are used to prevent or reduce damage propagation. However, it is
     RECOMMENDED that lower layers deploy error detection for ROHC
     headers and do not deliver ROHC headers with high residual error
     rates.

     Without giving a hard limit on the residual error rate acceptable
     to ROHC, it is noted that for a residual bit error rate of at most
     1E-5, the ROHC scheme has been designed not to increase the number
     of damaged headers, i.e., the number of damaged headers due to
     damage propagation is designed to be less than the number of
     damaged headers caught by the ROHC error detection scheme.

   Negotiation

     In addition to the packet handling mechanisms above, the link layer
     MUST provide a way to negotiate header compression parameters.
     (For unidirectional links, this negotiation may be performed out-
     of-band or even a-priori.)


4.2.  Dynamicity

   The ROHC protocol achieves its compression gain by establishing state
   at both ends of the link, i.e., at the compressor and at the
   decompressor. Different parts of the state are established at
   different times and with different frequency; hence, it can be said
   some state is more dynamic that other state.

   Some state is established at the time a channel is established; ROHC
   assumes the existence of an out-of-band negotiation protocol (such as
   PPP), or pre-defined channel state (most useful for uni-directional
   links). In both cases, we speak of "negotiated channel state".  ROHC
   does not assume that this state can change dynamically during the
   channel lifetime (and does not explicitly support such changes,
   although some changes may be innocuous from a protocol point of
   view).  An example of negotiated channel state is the maximum size of
   packet headers that can be compressed (MAX_HEADER).

   Other state is associated with the individual packet streams in the
   channel; this state is said to be part of the context.  Using context
   identifiers (CIDs), multiple packet streams with different contexts
   can share a channel.  The highest context identifier to be used is



Bormann (ed.)                                                  [Page 18]

INTERNET-DRAFT          Robust Header Compression           Oct 23, 2000


   one of the members of the negotiated channel state, as well as the
   selection of one of two ways to indicate the CID in the compressed
   header.

   It is up to the compressor to decide which packets to associate with
   a context (or, equivalently, which packets constitute a single
   stream); however, ROHC is efficient only when all packets of a stream
   share certain properties, such as having the same values for fields
   that are described as "static" in this document (e.g., the IP
   addresses, port numbers, and RTP parameters such as the payload
   type). The efficiency of ROHC RTP also depends on the compressor
   seeing most RTP sequence numbers.

   Streams need not share all characteristics important for compression.
   ROHC has a notion of compression profiles: a compression profile
   denotes a pre-defined set of such characteristics.  To provide for
   extensibility, the negotiated channel state includes the set of
   profiles acceptable to the decompressor. The context state includes
   the profile currently in use for the context.

   Other elements of the context state may include:  The current value
   of all header fields (from this one can deduce whether an IPv4 header
   is present in the header chain, and whether UDP checksums are
   enabled), as well as additional compression context that is not part
   of an uncompressed header: e.g., TS STRIDE, IP-ID characteristics (in
   network byte order? random?), a number of old reference headers, and
   the compressor/decompressor state machines (see next section).


4.3.  Compression and decompression states

   Header compression with ROHC can be characterized as an interaction
   between two state machines, one compressor machine and one
   decompressor machine, each instantiated once per context. The
   compressor and the decompressor have three states each, which in many
   ways are related to each other even if the meaning of the states are
   slightly different for the two parties. Both machines start in the
   lowest compression state and transits gradually to higher states.
   Transitions need not be synchronized between the two machines. In
   normal operation it is only the compressor that temporarily transits
   back to lower states. The decompressor will transit back only when
   context damage is detected.

   Subsequent sections present an overview of the state machines and
   their corresponding states respectively, starting with the
   compressor.

4.3.1.  Compressor states

   For ROHC compression, the three compressor states are the
   Initialization and Refresh (IR), First Order (FO), and Second Order



Bormann (ed.)                                                  [Page 19]

INTERNET-DRAFT          Robust Header Compression           Oct 23, 2000


   (SO) states. The compressor starts in the lowest compression state
   (IR) and transits gradually to higher compression states. The
   compressor will always operate in the highest possible compression
   state, under the constraint that the compressor is sufficiently
   confident that the decompressor has the information necessary to
   decompress a header compressed according to that state.

    +----------+                +----------+                +----------+
    | IR State |   <-------->   | FO State |   <-------->   | SO State |
    +----------+                +----------+                +----------+

   Decisions about transitions between the various compression states
   are taken by the compressor based on:

      - variations in packet headers.
      - positive feedback from decompressor (Acknowledgements - ACKs)
      - negative feedback from decompressor (Negative ACKs - NACKs)
      - periodic timeouts (when no feedback is used)

   How transitions are performed is explained in detail in chapter 5 for
   each mode of operation.


4.3.1.1.  Initialization and Refresh (IR) State

   The purpose of the IR state is to initialize the static parts of the
   context at the decompressor or to recover after failure. In this
   state, the compressor sends complete header information. This
   includes all static and non-static fields in uncompressed form plus
   some additional information.

   The compressor stays in IR state until it is rather confident that
   the decompressor has received the static information correctly.


4.3.1.2.  First Order (FO) State

   The purpose of the FO state is to efficiently communicate
   irregularities in the packet stream. When operating in this state,
   the compressor rarely sends information about all dynamic fields, and
   the information sent is usually compressed at least partially. Only a
   few static fields can be updated. The difference between IR and FO
   should therefore be clear.

   The compressor enters this state from the IR state, and from the SO
   state whenever the headers of the packet stream do not conform to
   their previous pattern. It stays in FO state until it is confident
   that the decompressor has acquired all the parameters of the new
   pattern. Changes in fields that are always irregular are communicated
   in all packets and are therefore part of what is a uniform pattern.




Bormann (ed.)                                                  [Page 20]

INTERNET-DRAFT          Robust Header Compression           Oct 23, 2000


   Some or all packets sent in the FO state carry context updating
   information. It is very important to detect corruption of such
   packets to avoid erroneous updates and context inconsistencies.

4.3.1.3.  Second Order (SO) State

   This is the state where compression is optimal. The compressor enters
   SO state when the header to be compressed is completely predictable
   given the SN, and the compressor is sufficiently confident that the
   decompressor has acquired all parameters of the functions from SN to
   other fields. Correct decompression of packets sent in the SO state
   only hinges on correct decompression of the SN. However, successful
   decompression also requires that the information sent in preceding FO
   state packets has been successfully received by the decompressor.

   The compressor leaves this state and goes back to the FO state when
   the header no longer conforms to the uniform pattern and can not be
   independently compressed based on previous context information.


4.3.2.  Decompressor states

   The decompressor starts in its lowest compression state, "No Context"
   and gradually transits to higher states. The decompressor state
   machine normally never leaves the "Full Context" state when it once
   has started to work in that state.

    +--------------+         +----------------+         +--------------+
    |  No Context  |  <--->  | Static Context |  <--->  | Full Context |
    +--------------+         +----------------+         +--------------+

   When initially working in the "No Context" state, the decompressor
   has never successfully decompressed any packet. When a packet once
   has been decompressed correctly (upon reception of an initialization
   packet with static and dynamic information, for example), the
   decompressor can transit all the way to "Full Context" state, and
   only upon repeated failures will it transit back to lower states.
   However, when that happens it first transits back to "Static Context"
   state. There, reception of any packet sent in FO state is normally
   sufficient to enable transition to "Full Context" state again. Only
   when decompression of several packets sent in FO state fails in
   "Static Context" state will the decompressor go all the way back to
   the "No Context" state.

   When state transitions are performed is explained in detail in
   chapter 5.


4.4.  Modes of operation.





Bormann (ed.)                                                  [Page 21]

INTERNET-DRAFT          Robust Header Compression           Oct 23, 2000


   The ROHC scheme has three modes of operation, called Unidirectional,
   Bi-directional Optimistic, and Bi-directional Reliable mode.

   It is important to understand the difference between states, as
   described in previous chapter, and modes. These abstractions are
   orthogonal to each other. The state abstraction is the same for all
   modes of operation, while the mode controls the logic of state
   transitions and what actions to perform in each state.

                          +----------------------+
                          |  Unidirectional Mode |
                          |   +--+  +--+  +--+   |
                          |   |IR|  |FO|  |SO|   |
                          |   +--+  +--+  +--+   |
                          +----------------------+
                            ^                  ^
                           /                    \
                          /                      \
                         v                        v
     +----------------------+                  +----------------------+
     |   Optimistic Mode    |                  |    Reliable Mode     |
     |   +--+  +--+  +--+   |                  |   +--+  +--+  +--+   |
     |   |IR|  |FO|  |SO|   | <--------------> |   |IR|  |FO|  |SO|   |
     |   +--+  +--+  +--+   |                  |   +--+  +--+  +--+   |
     +----------------------+                  +----------------------+

   The optimal mode to operate in depends on the characteristics of the
   environment of the compression protocol, such as feedback abilities,
   error probabilities and distributions, header size variation effects,
   etc. All ROHC implementations MUST implement and support all three
   modes of operation. The three modes are briefly described in the
   following subsections.

   Detailed descriptions of the three modes of operation regarding
   compression and decompression logic are given in chapter 5. The mode
   transition mechanisms are also described in chapter 5.


4.4.1.  Unidirectional mode - U-mode

   When in the unidirectional mode of operation, packets are sent in one
   direction only; from compressor to decompressor. This mode therefore
   makes ROHC usable over links where a return path from decompressor to
   compressor is not available or is undesirable.

   In U-mode, transitions between compressor states are performed based
   only on periodic timeouts and irregularities in the header field
   change patterns in the compressed packet stream. Due to the periodic
   refreshes and the lack of feedback for initiation of error recovery,
   compression in the unidirectional mode will be less efficient and




Bormann (ed.)                                                  [Page 22]

INTERNET-DRAFT          Robust Header Compression           Oct 23, 2000


   have a slightly higher probability for loss propagation compared to
   any of the bi-directional modes.

   Compression with ROHC MUST start in the unidirectional mode.
   Transition to any of the bi-directional modes can be performed as
   soon as a packet has reached the decompressor and it has replied with
   a feedback packet indicating that a mode transition is desired (see
   chapter 5).


4.4.2.  Bi-directional optimistic mode - O-mode

   The bi-directional optimistic mode is similar to the unidirectional
   mode. The difference is that a feedback channel is used to send error
   recovery requests and (optionally) acknowledgments of significant
   context updates from decompressor to compressor (not for sequence
   number updates only). Periodic refreshes are not used in the bi-
   directional optimistic mode.

   O-mode is designed for good compression efficiency and sparse usage
   of the return channel while maintaining reasonable robustness. Loss
   of compressor-decompressor synchronization and introduction of loss
   propagation is rare even under high probabilistic error rates, but
   can occur with longer consecutive loss events. When loss propagation
   does occur, the amount is limited by the CRC check and NACKing scheme
   used. Nevertheless, this mode is not completely robust against loss
   propagation.


4.4.3.  Bi-directional reliable mode - R-mode

   The bi-directional reliable mode differs in many ways from the
   previous two. The most important differences are a more intensive
   usage of the feedback channel and a stricter logic at both the
   compressor and the decompressor that prevents loss of context
   synchronization between compressor and decompressor except for very
   high residual bit error rates. Feedback is sent to acknowledge all
   context updates, including updates of the sequence number field.
   However, not every packet updates the context in reliable mode.

   The chief advantage of R-mode is almost complete robustness against
   packet loss between compressor and decompressor. Loss propagation can
   never occur due to header compression when operating in this mode.
   For reasonably well-behaving links, the price is slightly higher
   overhead in some cases and additional feedback traffic.

4.5.  Encoding methods

   This chapter describes the encoding methods that are used for
   different header fields. How the methods are applied to each field
   (e.g., values of associated parameters) is specified in section 5.7.



Bormann (ed.)                                                  [Page 23]

INTERNET-DRAFT          Robust Header Compression           Oct 23, 2000




4.5.1. Least Significant Bits (LSB) encoding

   Least Significant Bits (LSB) encoding is used for header fields whose
   values are usually subject to small changes. With LSB encoding, the k
   least significant bits of the field value are transmitted instead of
   the original field value, where k is a positive integer. After
   receiving k bits, the decompressor derives the original value using a
   previously received value as reference (v_ref).

   The scheme is guaranteed to be correct if the compressor and the
   decompressor agree on an interpretation interval

     1) in which the original value resides, and
     2) in which the original value is the only value that has the exact
        same k least significant bits as those transmitted.

   The interpretation interval can be described as a function f(v_ref,
   k). Let

      f(v_ref, k) = [v_ref - p, v_ref + (2^k - 1) - p]

   where p is an integer.


      <------- interpretation interval (size is 2^k) ------->
      |-------------+---------------------------------------|
   v_ref - p        v_ref                        v_ref + (2^k-1) - p


   The function f has the following property: for any value k, k least
   significant bits will uniquely identify a value in f(v_ref, k).

   The parameter p is introduced so that the interpretation interval can
   be shifted with respect to v_ref. Choosing a good value for p will
   yield more efficient encoding for fields with certain
   characteristics. Examples of appropriate values of p are

   a) for field values that are expected to always increase, p can be
      set to -1. The interpretation interval becomes
      [v_ref + 1, v_ref + 2^k].

   b) for field values that stay the same or increase, p can be set to
      0. The interpretation interval becomes [v_ref, v_ref + 2^k - 1].

   c) for field values that are expected to have small deviations around
      a constant value, p can be set to 2^(k-1)-1. The interpretation
      interval becomes [v_ref - 2^(k-1) + 1, v_ref + 2^(k-1)].





Bormann (ed.)                                                  [Page 24]

INTERNET-DRAFT          Robust Header Compression           Oct 23, 2000


   d) for field values that are expected to have small negative changes
      and larger positive changes, such as the RTP TS for video, or RTP
      SN when there is misordering, p can be set to 2^(k-2). The
      interval becomes [v_ref - 2^(k-2) + 1, v_ref + 3 * 2^(k-2)], i.e.,
      3/4 of the interval is used for positive changes.

   The following is a simplified procedure for LSB compression and
   decompression, it is modified for robustness and damage propagation
   protection in the next subsection:

     1) The compressor (decompressor) always uses v_ref_c (v_ref_d), the
        last value that has been compressed (decompressed), as v_ref;

     2) When compressing a value v, the compressor finds the minimal
        value of k such that v falls into the interval f(v_ref_c, k).
        Call this function k = g(v_ref_c, v).

        When only a few distinct values of k are possible, for example
        due to limitations imposed by packet formats (see section 5.7),
        the compressor will instead pick the smallest k of those
        possible such that v is in the interval f(v_ref_c, k).

     3) When receiving m LSBs, the decompressor uses the interpretation
        interval f(v_ref_d, m), called interval d. It picks as the
        decompressed value the one in interval_d whose LSBs match the
        received m bits.

   Note that the values to be encoded have a finite range; for example
   the RTP SN ranges from 0 to 0xFFFF. When the SN value is close to 0
   or 0xFFFF, the interpretation interval can straddle the wrap-around
   boundary between 0 and 0xFFFF.

   The scheme is complicated by two factors: packet loss between the
   compressor and decompressor, and transmission errors undetected by
   the lower layer. In the former case, the compressor and decompressor
   will lose the synchronization of v_ref, and thus also of the
   interpretation interval. If v is still covered by the
   intersection(interval_c, interval_d), decompression will be correct.
   Otherwise, incorrect decompression will happen. The next section will
   address this issue further.

   In the case of undetected transmission errors, the corrupted LSBs
   will give an incorrectly decompressed value that will later be used
   as v_ref_d, which in turn is likely to lead to damage propagation.
   This problem is addressed by using a secure reference, i.e., a
   reference value whose correctness is verified by a protecting CRC.
   Consequently, the procedure 1) above is modified as follows:

    1) a) the compressor always uses as v_ref_c the last value that has
          been compressed and sent with a protecting CRC.
       b) the decompressor always uses as v_ref_d the last correct



Bormann (ed.)                                                  [Page 25]

INTERNET-DRAFT          Robust Header Compression           Oct 23, 2000


          value, as verified by a succeeding CRC.

   Note that in U/O mode, 1) b) is modified so that if decompression of
   the SN fails using the last verified SN reference, another
   decompression attempt is made using the last but one verified SN
   reference. This procedure dampens damage propagation when a small CRC
   fails to detect a damaged value. See 5.3.2.2.3 for further details.

4.5.2.  Window-based LSB encoding (W-LSB encoding)

   This section describes how to modify the simplified algorithm in
   4.5.1 to achieve robustness.

   The compressor may not be able to determine the exact value of
   v_ref_d that will be used by the decompressor for a particular value
   v, since some candidates for v_ref_d may have been lost or damaged.
   However, by using feedback or by making reasonable assumptions the
   compressor can limit the candidate set. The compressor then
   calculates k such that no matter which v_ref_d in the candidate set
   the decompressor uses, v is covered by the resulting interval_d.

   Since the decompressor always uses the last received value where the
   CRC succeeded as the reference, the compressor maintains a sliding
   window (VSW) containing the candidates for v_ref_d. VSW is initially
   empty. The following operations are performed on VSW by the
   compressor:

     1) After sending a value v (compressed or uncompressed) protected
        by a CRC, the compressor adds v to the VSW;
     2) For each value v being compressed, the compressor chooses k =
        max(g(v, v_min), g(v, v_max)), where v_min and v_max are the
        minimal and maximal values in VSW, and g is the function defined
        in the previous section;
     3) When the compressor has sufficient confidence that a certain
        value v will not be used as a reference by the decompressor, the
        window is advanced by removing v and all values older than v.
        The confidence may be obtained by various means. In R mode an
        ACK from the decompressor implies that values older than the
        ACKed one can be removed from VSW. In U/O mode there is always a
        CRC to verify correct decompression, and a VSW with a limited
        maximum width is used. The window width is an implementation
        dependent optimization parameter.

   Note that the decompressor follows the procedure described in the
   previous section, except that in R mode it MUST ACK each value
   received with a CRC (see also section 5.5).








Bormann (ed.)                                                  [Page 26]

INTERNET-DRAFT          Robust Header Compression           Oct 23, 2000


4.5.2. Scaled RTP Timestamp encoding

   The RTP Timestamp (TS) will usually not increase by an arbitrary
   number from packet to packet. Instead, the increase is normally an
   integral multiple of some unit (TS_STRIDE). For example, in the case
   of audio, the sample rate is normally 8Khz and one voice frame may
   cover 20 ms. Furthermore, each voice frame is usually carried in one
   RTP packet. In this case, the RTP increment is always n * 160 (= 8000
   * 0.02), for some integer n. Note that silence periods has no impact
   on this as the sample clock at the source normally keeps running
   without changing either frame rate or frame boundaries.

   For the case of video, there is usually a TS_STRIDE as well when we
   consider the video frame level. The sample rate for most video codecs
   is 90Khz. If the video frame rate is fixed, say to 30 frames/second,
   the TS will increase by n * 3000 (= n * 90000 / 30) between video
   frames. Note that a video frame is often divided into several RTP
   packets to achieve robustness against packet loss. In this case
   several RTP packets will carry the same TS.

   When using scaled RTP Timestamp encoding, the TS is downscaled by a
   factor of TS_STRIDE before compression. This saves

       floor(log2(TS_STRIDE))

   bits for each compressed TS. The following equality holds between TS
   and TS SCALED:

       TS = TS SCALED * TS STRIDE + TS OFFSET

   TS STRIDE is explicitly, and TS OFFSET implicitly, communicated to
   the decompressor. The following algorithm is used:

     1. Initialization: The compressor sends to the decompressor the
        value of TS_STRIDE (e.g., via in-band signaling, see packet
        format section) and the absolute value of one or several TS. The
        latter are used by the decompressor to initialize TS_OFFSET to
        (absolute value) modulo TS_STRIDE. Note that TS OFFSET is the
        same regardless of which absolute value is used, as long as the
        unscaled TS value does not wrap around, see 4) below.

     2. Compression: After initialization, the compressor no longer
        compresses the original TS values. Instead, it compresses the
        down-scaled values: TS_SCALED = TS / TS_STRIDE. The compression
        method could be either W-LSB encoding or the timer-based
        encoding described in the next section.


     3. Decompression: When receiving the compressed value of TS_SCALED,
        the decompressor first derives the value of the original




Bormann (ed.)                                                  [Page 27]

INTERNET-DRAFT          Robust Header Compression           Oct 23, 2000


        TS_SCALED. The original RTP TS is then calculated as TS =
        TS_SCALED * TS_STRIDE + TS_OFFSET.


     4. Offset at wrap around: Wrap around of the unscaled 32-bit TS
        will invalidate the current value of TS_OFFSET used in the
        equation above. For example, let us assume TS_STRIDE = 160 =
        0xA0 and the current TS = 0xFFFFFFF0. TS_OFFSET is then 0x50 =
        80. Then if the next RTP TS = 0x00000130 (i.e., the increment is
        160 * 2 = 320), the new TS_OFFSET should be 0x00000130 modulo
        0xA0 = 0x90 = 144. The compressor is not required to re-
        initialize TS OFFSET at wrap around. Instead, the decompressor
        MUST detect wrap around of the unscaled TS (which is trivial)
        and update TS_OFFSET to

           TS OFFSET = (Wrapped around unscaled TS) modulo TS STRIDE

     5.Interpretation interval at wrap around: Special rules are needed
        for the interpretation interval of the scaled TS at wrap-around,
        since the maximum scaled TS, TSS_MAX, (0xFFFFFFFF / TS_STRIDE)
        may not have the form 2^m _1. For example, when TS_STRIDE is
        160, the scaled TS is at most 26843545 which has LSBs 10011001.
        The wrap around boundary between the TSS_MAX may thus not
        correspond to a natural boundary between LSBs.

                     interpretation interval
                |<------------------------------>|

                             unused                       scaled TS
            ------------|--------------|---------------------->
                      TSS_MAX         zero

        When TSS_MAX is part of the interpretation interval, a number of
        unused values are conceptually inserted into it after TSS_MAX
        such that their LSBs follow naturally upon each other. For
        example, for k=4 values corresponding to the LSBs 1010 through
        1111 are inserted. The number of conceptually inserted values
        depends on k. The number of valid values in the interpretation
        interval should be high enough to maintain robustness. This can
        be ensured by the following rule:

           Let a be the number of LSBs needed if there was no wrap
           around, and let b be then number of LSBs needed to
           disambiguate between TSS_MAX and zero. The number of LSB
           bits to send while TSS_MAX or zero is part of the
           interpretation interval is max(a + 1, b).

   This scaling method can be applied to many frame-based codecs.
   However, the value of TS_STRIDE might change during a session, for
   example due to adaptation strategies. If that happens, the unscaled




Bormann (ed.)                                                  [Page 28]

INTERNET-DRAFT          Robust Header Compression           Oct 23, 2000


   TS is compressed until re-initialization of the new TS_STRIDE and
   TS_OFFSET is completed.


4.5.4.  Timer-Based Compression of RTP Timestamp

   The RTP timestamp [RFC 1889] is defined to identify the number of the
   first sample used to generate the payload. When RTP packets carry
   payloads corresponding to a fixed sampling interval, the sampling is
   done at a constant rate, and packets are generated in lock-step with
   sampling, the timestamp will closely follow a linear pattern as a
   function of the time of day. This is the case for conversational
   media, such as interactive speech. The linear ratio is determined by
   the source sample rate. The linear pattern can be complicated by
   packetization (e.g., in the case of video where a video frame usually
   corresponds to several RTP packets) or frame re-arrangement (e.g.,
   MPEG B-frames are sent out-of-order by some video codecs).

   With a fixed sample rate of 8kHz, 20 ms in time domain is equivalent
   to an increment of 160 in the unscaled TS domain, and to an increment
   of 1 in the scaled TS domain with TS_STRIDE=160.

   As a consequence, the (scaled) TS of headers coming to the
   decompressor will follow a linear pattern as a function of time of
   day, with some deviation due to the delay jitter between the source
   and the decompressor. In normal operation, i.e., no crashes or
   failures, the delay jitter will be bounded to meet the requirements
   of conversational real-time traffic.  Hence, by using a local clock
   the decompressor can obtain an approximation of the (scaled) TS in
   the header to be decompressed by considering its arrival time. The
   approximation can then be refined with the k LSBs of the (scaled) TS
   carried in the header. The required value of k to ensure correct
   decompression is a function of the jitter between the source and
   decompressor.

   If the compressor knows the potential jitter introduced between
   compressor and decompressor, it can determine k by using a local
   clock to estimate jitter in packet arrival times, or alternatively it
   can use a fixed k and discard packets arriving too much out of time.

   The advantages of this scheme include:

   a) The size of the compressed TS is constant and small. In
      particular, it does NOT depend on the length of silence intervals.
      This is in contrast to other TS compression techniques, which at
      the beginning of a talk-spurt requires sending a number of bits
      dependent on the duration of the preceding silence interval.

   b) No synchronization is required between the clock local to the
      compressor and the clock local to the decompressor.




Bormann (ed.)                                                  [Page 29]

INTERNET-DRAFT          Robust Header Compression           Oct 23, 2000


   Note that although this scheme can be made to work using both scaled
   and unscaled TS, in practice it is always combined with scaled TS
   encoding because of the less demanding requirement on the clock
   resolution, e.g., 20 ms instead of 1/8 ms. Therefore, the algorithm
   described below assumes that the clock-based encoding scheme operates
   on the scaled TS. The case of unscaled TS would be similar, with
   changes to scale factors.

   Compressor: its major task is to determine the value of k. Its
   sliding window, TSW, now contains not only potential reference values
   for the TS, but also their times of arrival at the compressor.

     1) The compressor maintains a sliding window TSW = {(T_j, a_j),
        for each header j that can be used as a reference}, where T_j is
        the scaled TS for header j, and a_j is the arrival time of
        header j. The TSW fills the same purpose as the VSW of section
        4.5.2.

     2) When a new header n arrives with T_n as the scaled TS, the
        compressor notes the arrival time a_n. It then calculates

        Max_Jitter_BC =

            max {|(T_n - T_j) - ((a_n - a_j) / TIME_STRIDE)|,
                 for all headers j in TSW},

        where TIME_STRIDE is the time interval equivalent to one
        TS_STRIDE, e.g., 20 ms. Max_Jitter_BC is the maximum observed
        jitter before the compressor, in units of TS_STRIDE, for the
        headers in TSW.

     3) k is calculated as: k = ceiling(log2(2 * J + 1), where J =
        Max_Jitter_BC + Max_Jitter_CD + 2.

        Max_Jitter_CD is the upper bound of jitter expected on the
        communication channel between compressor and decompressor (CD-
        CC). It depends only on the characteristics of CD-CC.

        The factor 2 accounts for the quantization error introduced by
        the clocks at the compressor and decompressor, which can be +/-
        1.

        Note that the calculation of k follows the compression algorithm
        described in section 4.5.1, with p = 2^(k-1) - 1.

     4) TSW is subject to the same window operations as in section
        4.5.2, 1) and 3), except that the values added and removed are
        paired with their arrival times.

   Decompressor:




Bormann (ed.)                                                  [Page 30]

INTERNET-DRAFT          Robust Header Compression           Oct 23, 2000


     1) The decompressor uses as its reference header the last correctly
        (as verified by CRC) decompressed header. It maintains the pair
        (T_ref, a_ref), where T_ref is the scaled TS of the reference
        header, and a_ref is the arrival time of the reference header.

     2) When receiving a compressed header n at time a_n, the
        approximation of the original scaled TS is calculated as:

            T_approx = T_ref + (a_n - a_ref) / TIME_STRIDE.

     3) The approximation is then refined by the k least significant
        bits carried in header n, following the decompression algorithm
        of section 4.5.1, with p = 2^(k-1) - 1.

   Note: the algorithm does not assume any particular pattern in the
   packets arriving to the compressor, i.e., it tolerates reordering
   before the compressor and non-increasing RTP timestamp behavior.

   Note: Integer arithmetic is used in all equations above. If
   TIME_STRIDE is not equal to an integral number of clock ticks, time
   must be normalized such that TIME_STRIDE is an integral number of
   clock ticks. For example, if a clock tick is 20 ms and TIME STRIDE is
   30 ms, (a_n - a_ref) in 2) can be multiplied by 3 and TIME_STRIDE can
   have the value 2.

   Note: the clock resolution of compressor or decompressor can be worse
   than TIME_STRIDE, in which case the difference, i.e., actual
   resolution - TIME_STRIDE, is treated as additional jitter in the
   calculation of k.

   Note: the clock resolution of the decompressor may be communicated to
   the compressor using the CLOCK feedback option.

   Note: the decompressor may observe the jitter and report this to the
   compressor using the JITTER feedback option. The compressor may use
   this information to refine its estimate of Max_Jitter_CD.

4.5.5.  Offset IP-ID encoding

   As all IPv4 packets have an IP Identifier to allow for fragmentation,
   ROHC provides for transparent compression of this ID.  There is no
   explicit support in ROHC for the IPv6 fragmentation header, so there
   is never a need to discuss IP IDs outside the context of IPv4.

   This section assumes (initially) that the IPv4 stack at the source
   host assigns IP-ID to the value of a 2-byte counter which is
   increased by one after each assignment to an outgoing packet.
   Therefore, the IP-ID field of a particular IPv4 packet flow will
   increment by 1 from packet to packet except when the source has
   emitted intermediate packets not belonging to that flow.




Bormann (ed.)                                                  [Page 31]

INTERNET-DRAFT          Robust Header Compression           Oct 23, 2000


   For such IPv4 stacks, the RTP SN will increase by 1 for each packet
   emitted and the IP-ID will increase by at least the same amount.
   Thus, it is more efficient to compress the offset, i.e., (IP-ID - RTP
   SN), instead of IP-ID itself.

   The following text describes how to compress/decompress the sequence
   of offsets using W-LSB encoding/decoding, with p = 0 (see section
   4.5.1).  All IP-ID arithmetic is done using unsigned 16-bit
   quantities, i.e. modulo 2^16.

   Compressor:

     The compressor uses W-LSB encoding to compress a sequence of
     offsets

        Offset_i = ID_i - SN_i,

     where ID_i and SN_i are the values of the IP-ID and RTP SN of
     header i. The sliding window contains such offsets and not the
     values of header fields, but the rules for adding and deleting
     offsets from the window otherwise follow section 4.5.2.

   Decompressor:

     The reference header is the last correctly (as verified by CRC)
     decompressed header.

     When receiving a compressed packet m, the decompressor calculates
     Offset_ref = ID_ref - SN_ref, where ID_ref and SN_ref are the
     values of IP-ID and RTP SN in the reference header, respectively.
     Then W-LSB decoding is used to decompress Offset_m, using the
     received LSBs in packet m and Offset_ref. Note that m may contain
     zero LSBs for Offset_m, in which case Offset_m = Offset_ref.

     Finally, the IP-ID for packet m is regenerated as

       IP-ID for m = decompressed SN of packet m + Offset_m


   Network byte order:

   Some IPv4 stacks do use a counter to generate IP ID values as
   described, but do not transmit the contents of this counter in
   network byte order, but instead send the two octets reversed. In this
   case, the compressor can compress the IP-ID field after swapping the
   bytes. Consequently, the decompressor also swaps the bytes of the IP-
   ID after decompression to regenerate the original IP-ID. This
   requires that the compressor and the decompressor synchronize on the
   byte order of the IP-ID field using the NBO or NBO2 flag (see section
   5.7.)




Bormann (ed.)                                                  [Page 32]

INTERNET-DRAFT          Robust Header Compression           Oct 23, 2000


   Random IP Identifier:

   Some IPv4 stacks generate the IP Identifier values using a pseudo-
   random number generator. While this may provide some security
   benefits, it makes it pointless to attempt compressing the field.
   Therefore, the compressor should detect such random behavior of the
   field. After detection and synchronization with the decompressor
   using the RND or RND2 flag, the field is sent as-is in its entirety
   as additional octets after the compressed header.


4.5.6.  Self-describing variable-length values.

   The values of TS STRIDE and a few other compression parameters can
   vary widely. TS STRIDE can be 160 for voice and 90 000 for 1 f/s
   video. To optimize the transfer of such values, a variable number of
   octets is used to encode them. The first few bits of the encoded
   value determines its length.

   1 octet: first bit is zero. 7 bits transferred. Up to 127 decimal.
               Encoded octets in hexadecimal: 00 to 7F

   2 octets: first bits 10. 14 bits. Up to 16 383 decimal.
               Encoded octets in hexadecimal: 80 00 to BF FF

   3 octets: first bits 110. 21 bits. Up to 2 097 151 decimal.
               Encoded octets in hexadecimal: C0 00 00 to DF FF FF

   4 octets: first bits 111. 29 bits. Up to 536 870 911 decimal.
               Encoded octets in hexadecimal: E0 00 00 00 to FF FF FF FF


4.5.7.  Encoded values across several fields in compressed headers.

   When a compressed header has an extension, pieces of an encoded value
   can be present in more than one field. When an encoded value is split
   over several fields in this manner, the more significant bits of the
   value are closer to the beginning of the header. If the number of
   bits available in compressed header fields exceeds the number of bits
   of the value, the most significant field is padded with zeroes in its
   most significant bits.

   For example, an unscaled TS value can be transferred using an UOR-2
   header (see section 5.7) with an extension of type 3. The Tsc bit of
   the extension is then unset (zero) and the variable length TS field
   of the extension is 4 octets, with 29 bits available for the TS (see
   section 4.5.6). The UOR-2 TS field will contain the most significant
   three bits of the unscaled TS, and the 4-octet TS field in the
   extension will contain the remaining 29 bits.





Bormann (ed.)                                                  [Page 33]

INTERNET-DRAFT          Robust Header Compression           Oct 23, 2000



4.6  Errors caused by residual errors

   ROHC is designed under the assumption that packets can be damaged
   between the compressor and decompressor, and that such damaged
   packets can be delivered to the decompressor.

   Residual errors may damage the SN in compressed headers. Such damage
   will cause generation of a header which upper layers may not be able
   to distinguish from a correct header. When the compressed header
   contains a CRC, the CRC will catch the bad header with a probability
   dependent on the size of the CRC. When the CRC does not catch the
   error, or when there is no CRC, the bad header will be delivered to
   upper layers.

   Damage is not confined to the SN.
   a) Damage to packet type indication bits can cause a header to be
      interpreted as having another packet type.
   b) Damage to CID information may cause a packet to be interpreted
      according to another context and possibly also according to
      another profile. Damage to CIDs will be more harmful when a large
      part of the CID space is being used, so that it is likely that the
      damaged CID corresponds to an active context.
   c) Feedback information can also be subject to residual errors, and
      will be when feedback is interleaved or piggybacked. ROHC uses
      sanity checks and adds CRCs to vital feedback information to allow
      detection of some damaged feedback.

   The smallest compressed headers in this document either include a 3-
   bit CRC or do not carry a CRC at all. Fewer bad headers will be
   delivered to upper layers due to the kind of damage outlined above
   when all headers carry CRCs than when they do not. However, since a
   3-bit CRC will only catch roughly 7/8 of all bad headers, this
   is a quantitative difference only. All modes will deliver some bad
   headers when there are residual errors. The number of damaged headers
   will be smaller than when header compression is not being used,
   however, since large uncompressed headers are more likely to be
   damaged than small compressed headers.

   An example illustrating this the number of bad headers delivered when
   header damage is proportional to the header size. Compression with R-
   mode will deliver roughly 36 times fewer damaged headers, and
   compression with O-mode will deliver roughly 230 times fewer damaged
   headers, compared to when headers are not being compressed at all.










Bormann (ed.)                                                  [Page 34]

INTERNET-DRAFT          Robust Header Compression           Oct 23, 2000


5.  The protocol

5.1.  Data structures

   The ROHC protocol is based on a number of parameters that form part
   of the negotiated channel state and the per-context state.  This
   section describes some of this state in an abstract way.
   Implementations can use a different structure and representation of
   this state.  In particular, negotiation protocols that set up per-
   channel state need to establish the information that constitutes the
   negotiated channel state, but it is not necessary to exchange it in
   the form described here.

5.1.1.  Per-channel parameters

   MAX_CID: non-negative integer; highest context ID number to be used
   by the compressor (note that this parameter is not coupled to, but in
   effect further constrained by, LARGE_CIDS).

   LARGE_CIDS: Boolean; if false, the short CID representation (0 bytes
   or 1 prefix byte, covering CID 0 to 15) is used, if true, the
   embedded CID representation (1 or 2 embedded CID bytes covering CID 0
   to 16383) is used.

   PROFILES: Set of non-negative integers, each integer indicating a
   profile supported by the decompressor. The compressor MUST NOT
   compress using a profile not in PROFILES.

   FEEDBACK_FOR: Optional reference to a channel in the reverse
   direction.  If provided, this parameter indicates which channel any
   feedback sent on this channel refers to (see 5.7.6.1).

   MRRU: Maximum reconstructed reception unit.  This is the size of the
   largest reconstructed unit in octets that the decompressor is
   expected to reassemble from segments (see 5.2.4).  Note that this
   size includes the CRC.  If MRRU is negotiated 0, no segment headers
   are allowed on the channel.


5.1.2.  Per-context parameters, profiles

   Per-context parameters are established with IR headers (see section
   5.2.3).  An IR header contains a profile identifier, which determines
   how the rest of the header is to be interpreted. Note that the
   profile parameter determines the syntax and semantics of the packet
   type identifiers and packet types used for a specific context.  This
   document describes profiles 0, 1, 2, and 3; further profiles may be
   defined when ROHC is extended in the future.

   Profile 0 is for sending uncompressed IP packets. See section 5.10.




Bormann (ed.)                                                  [Page 35]

INTERNET-DRAFT          Robust Header Compression           Oct 23, 2000


   Profile 1 is for RTP/UDP/IP compression, see sections 5.3 to 5.9.

   Profile 2 is for UDP/IP compression, i.e., compression of the first
      12 octets of the UDP payload is not attempted. See section 5.11.

   Profile 3 is for ESP/IP compression, i.e., compression of the header
      chain up to and including the first ESP header, but not
      subsequent subheaders. See section 5.12.

   Initially, all contexts are in no context state, i.e. all packets
   referencing this context except for IR packets are discarded.  If
   defined by a "ROHC over X" document, per-channel negotiation can be
   used to pre-establish state for a context (e.g. negotiating profile 0
   for CID 15).  Such state can also be marked read-only in the
   negotiation, which would cause the decompressor to discard any IR
   packet attempting to modify it.


5.1.3.  Contexts and context identifiers

   Associated with each compressed flow is a context, which is the state
   compressor and decompressor maintains in order to correctly compress
   or decompress the headers of the packet stream. Contexts are
   identified by a context identifier, CID, which is sent along with
   compressed headers and feedback information.

   The CID space is distinct for each channel, i.e., CID 3 over channel
   A and CID 3 over channel B do not refer to the same context, even if
   the endpoints of A and B are the same nodes.  In particular, CIDs for
   any pairs of forward and reverse channels are not related (forward
   and reverse channels need not even have CID spaces of the same size).

   Context information is conceptually kept in a table. The context
   table is indexed using the CID which is sent along with compressed
   headers and feedback information. The CID space can be negotiated to
   be either small, which means that CIDs can take the values 0 through
   15, or large, which means that CIDs take values between 0 and 2^14-1
   = 16383. Whether the CID space is large or small is negotiated no
   later than when a channel is established.

   A small CID is either CID 0, which is represented using zero bits, or
   CID 1 through 15, which are represented using a packet type plus four
   bits.  A large CID is represented using the encoding scheme of
   section 4.5.6., limited to two octets.


5.2. ROHC Packets & packet types

   A ROHC packet has the following general format.





Bormann (ed.)                                                  [Page 36]

INTERNET-DRAFT          Robust Header Compression           Oct 23, 2000


    --- --- --- --- --- --- --- ---
   /           Padding             /
    --- --- --- --- --- --- --- ---
   /           Feedback            /    includes CID information
    --- --- --- --- --- --- --- ---
   /            Header             /    includes CID information
    --- --- --- --- --- --- --- ---
   /           Payload             /
    --- --- --- --- --- --- --- ---

   Padding is any number (zero or more) of padding octets.

   Padding Octet

     0   1   2   3   4   5   6   7
   +---+---+---+---+---+---+---+---+
   | 1   1   1   0   0   0   0   0 |
   +---+---+---+---+---+---+---+---+

   (Note that the Padding Octet looks like, and in some implementations
   can be processed as, an Add-CID Octet for CID 0.)

   Either of Feedback or Header must be present. Header is either a
   profile-specific header or an IR header (see 5.2.6). Feedback and
   Header either

   1) do not carry any CID information (indicating CID zero), or

   2) start with one Add-CID Octet (see below), or

   3) contain embedded CID information of length one or two octets.

   Alternatives 1) and 2) apply only to compressed headers in channels
   where the CID space is small, and feedback related to such headers.
   Alternative 3) applies only to compressed headers in channels where
   the CID space is large, and feedback related to such headers.

   Add-CID Octet

     0   1   2   3   4   5   6   7
   +---+---+---+---+---+---+---+---+
   | 1   1   1   0 |      CID      |
   +---+---+---+---+---+---+---+---+

      CID:   0x1 through 0xF indicates CIDs 1 through 15.
             (0x0 indicates a padding octet.)


   Header and Feedback either start with a packet type indication or,
   when they start with an Add-CID octet, have a packet type indication




Bormann (ed.)                                                  [Page 37]

INTERNET-DRAFT          Robust Header Compression           Oct 23, 2000


   in their second octet. All Header packet types have the following
   general format:

     0              x-1  x       7
    --- --- --- --- --- --- --- ---
   |         Add-CID octet         | if for CID 1-15 and small CIDs
   +---+--- --- --- ---+--- --- ---+
   | type indication   |   body    | 1 octet (8-x bits of body)
   +---+--- ---+---+---+--- --- ---+
   |                               |
   /    0, 1, or 2 octets of CID   / 1 or 2 octets if large CIDs
   |                               |
   +---+---+---+---+---+---+---+---+
   /             body              /  variable
   +---+---+---+---+---+---+---+---+

   The large CID, if present, is encoded according to section 4.5.6. The
   format of the Feedback part is described in 5.2.2.


5.2.1.  ROHC feedback

   Feedback carries information from decompressor to compressor. The
   following principal kinds of feedback is supported. In addition to
   the kind of feedback, other information may be included in profile-
   specific feedback information.

   ACK         : Acknowledges successful decompression of a packet,
                which means that the context is up to date with a high
                probability.

   NACK        : Indicates that the dynamic context of the
                decompressor is out of sync. Generated when several
                packets have failed to decompressed correctly.

   STATIC-NACK : Indicates that the static context of the decompressor
                is not valid or has not been established.

   It is anticipated that feedback to the compressor can be realized in
   many ways, depending on the properties of the particular lower layer.
   The exact details of how feedback is realized is to be specified in a
   "ROHC over X" document, for each lower layer X in question. As
   examples, feedback might be realized using

   1) lower-layer specific mechanisms, or

   2) a dedicated feedback-only channel, realized for example by the
      lower layer providing a way to indicate that a packet is a
      feedback packet, or





Bormann (ed.)                                                  [Page 38]

INTERNET-DRAFT          Robust Header Compression           Oct 23, 2000


   3) a dedicated feedback-only channel, where the timing of the
      feedback provides information about which compressed packet caused
      the feedback, or

   4) interleaving of feedback packets among normal compressed packets
      going in the same direction as the feedback (lower layers do not
      indicate feedback), or

   5) piggybacking of feedback information in compressed packets going
      in the same direction as the feedback (this technique may reduce
      the per-feedback overhead).

   6) Interleaving and piggybacking in the same channel, i.e., both 4)
      and 5).

   Alternatives 1-3 do not place any particular requirements on the ROHC
   packet type scheme. Alternatives 4-6 do, however. The ROHC packet
   type scheme has been designed to allow alternatives 4-6, these may be
   used for example over PPP.

   A)the ROHC scheme provides a feedback packet type. The packet type
     is able to carry variable-length feedback information.

   B)The feedback information sent in a particular channel is passed
     to, and interpreted by, the compressor associated with feedback on
     that channel. Thus, the feedback information must contain CID
     information if the associated compressor can use more than one
     context. How a compressor is associated with feedback on a
     particular channel needs to be defined in a "ROHC over X"
     document.

   C)The ROHC feedback information format is octet-aligned, i.e.,
     starts at an octet boundary, to allow using the format over a
     dedicated feedback channel, 2).

   D)To allow piggybacking, 5), it is possible to deduce the length of
     feedback information by examining the first few octets of the
     feedback. This allows the decompressor to pass piggybacked
     feedback information to the associated same-side compressor
     without understanding its format. The length information decouples
     the decompressor from the compressor in the sense that the
     decompressor can process the compressed header immediately without
     waiting for the compressor to hand it back after parsing the
     feedback information.


5.2.2.  ROHC feedback format

   Feedback sent in a ROHC channel has the following format:





Bormann (ed.)                                                  [Page 39]

INTERNET-DRAFT          Robust Header Compression           Oct 23, 2000


     0   1   2   3   4   5   6   7
    --- --- --- --- --- --- --- ---
   |         Add-CID octet         |  if for CID!=0 for small CIDs
   +---+---+---+---+---+---+---+---+
   | 1   1   1   1   1   0 | Code  |  feedback type octet
   +---+---+---+---+---+---+---+---+
   :             Size              :  if Code=0
   +---+---+---+---+---+---+---+---+
   |                               |
   /       0-2 octets of CID       /  1-2 octets if for large CIDs
   |                               |
   +---+---+---+---+---+---+---+---+
   /           feedback            /
   +---+---+---+---+---+---+---+---+

       Code:   0 indicates that a Size octet is present.
               1-3 indicates the feedback size. The feedback size
               includes the CID info field but not the Add-CID octet.

      Size: indicates the feedback size. The feedback size includes the
            CID field but not the Add-CID octet.

      CID: 1-2 octets if for large CIDs. Encoded according to section
           4.5.6.

      Feedback: Profile-specific feedback information.

   The Add-CID octet or CID info identifies the context the feedback
   refers to.

   The total size of the feedback information is determinable upon
   reception by the decompressor, by inspection of the Code field and
   possibly the Size field. This explicit length information allows
   piggybacking and also sending of more than one feedback element in  a
   packet. The decompressor does not need to know whether the associated
   compressor uses large or small CIDs.

   When the decompressor has determined the size of the feedback, it
   removes the feedback type octet and the Size field (if present) and
   gives the rest to the same-side associated compressor together with
   an indication of its total size (including Add-CID octet if present).
   The information received by the compressor has the following
   structure.

   Feedback information received by compressor

     0   1   2   3   4   5   6   7
    --- --- --- --- --- --- --- ---
   |         Add-CID octet         |  if for CID!=0 for small CIDs
   +---+---+---+---+---+---+---+---+
   |                               |



Bormann (ed.)                                                  [Page 40]

INTERNET-DRAFT          Robust Header Compression           Oct 23, 2000


   /       0-2 octets of CID       /  1-2 octets if for large CIDs
   |                               |
   +---+---+---+---+---+---+---+---+
   /           feedback            /
   +---+---+---+---+---+---+---+---+


   The ROHC scheme requires that feedback has either of the following
   two formats

   FEEDBACK-1

     0   1   2   3   4   5   6   7
   +---+---+---+---+---+---+---+---+
   | profile specific information  | 1 octet
   +---+---+---+---+---+---+---+---+


   FEEDBACK-2

     0   1   2   3   4   5   6   7
   +---+---+---+---+---+---+---+---+
   |Acktype|                       |
   +---+---+   profile specific    / at least 2 octets
   /             information       |
   +---+---+---+---+---+---+---+---+

     Acktype:  0 = ACK
               1 = NACK
               2 = STATIC-NACK
               3 is reserved (must not be used)

   The compressor can use the following logic to parse received feedback
   information.

      1) If for large CIDs, the feedback will always start with a CID
         encoded according to section 4.5.6. If the first bit is 0, the
         CID uses one octet. If the first bit is 1, the CID uses two
         octets.
      2) If for small CIDs and the size is one octet, the feedback is a
         FEEDBACK-1 (see 5.7.6.1).
      3) If for small CIDs, and the size is larger than one octet, and
         the feedback starts with the two bits 11, the feedback starts
         with an Add-CID octet. If the size is 2, it is followed by a
         FEEDBACK-1. If the size is larger than 2 the Add-CID is
         followed by a FEEDBACK-2.
      4) Otherwise, there is no Add-CID octet and the feedback starts
         with a FEEDBACK-2.






Bormann (ed.)                                                  [Page 41]

INTERNET-DRAFT          Robust Header Compression           Oct 23, 2000


5.2.3.  ROHC IR packet type

   The IR header associates a CID with a profile, and typically also
   initializes the context. It has the following general format.

     0   1   2   3   4   5   6   7
    --- --- --- --- --- --- --- ---
   |         Add-CID octet         |  if for CID!=0 for small CIDs
   +---+---+---+---+---+---+---+---+
   | 1   1   1   1   1   1   0 | x |  IR type octet
   +---+---+---+---+---+---+---+---+
   |                               |
   /      0-2 octets of CID        /  1-2 octets if for large CIDs
   |                               |
   +---+---+---+---+---+---+---+---+
   |            Profile            |  1 octet
   +---+---+---+---+---+---+---+---+
   |              CRC              |  1 octet
   +---+---+---+---+---+---+---+---+
   |                               |
   / profile specific information  /  variable length
   |                               |
    - - - - - - - - - - - - - - - -

     x:  profile specific information

     Profile: the profile to be associated with the CID.

     CRC: 8-bit CRC computed using the polynomial of section 5.9.1. Its
         coverage is profile-dependent, but it MUST cover at least the
         initial part of the packet ending with the Profile field. Any
         information which initializes the context of the decompressor
         should be protected by the CRC.

     Profile specific information: this part of the IR packet is
         defined by the individual profiles.

5.2.4.  ROHC segmentation

   Some link layers may provide a much more efficient service if the set
   of different packet sizes to be transported is limited to a small
   number.  For such link layers, these sizes will normally be chosen to
   efficiently transport frequently occurring packets, with less
   frequently occuring packets possibly adapted to the next larger size
   by adding padding.  The link layer may, however, be limited in the
   size of packets it can offer in this efficient mode, or it may be
   desirable to request only a limited largest size.  To accommodate the
   occasional packet that is larger than that largest size negotiated,
   ROHC defines a simple segmentation protocol.  Note that this protocol
   is not intended to replace link layer segmentation functions; these
   SHOULD be used whenever available.



Bormann (ed.)                                                  [Page 42]

INTERNET-DRAFT          Robust Header Compression           Oct 23, 2000



   Segment-7

     0   1   2   3   4   5   6   7
   +---+---+---+---+---+---+---+---+
   | 1   1   1   1   1   1   1 | F |
   +---+---+---+---+---+---+---+---+
   |                               |
   /           Segment             /  variable length
   |                               |
    - - - - - - - - - - - - - - - -

   F - Final bit.  If set, indicates this is the last segment in a
   reconstructed unit.

   The segment header may be preceded by padding.  It never carries a
   CID.

   All segment header packets for one reconstructed unit have to be sent
   consecutively on a channel, i.e. any non-segment-header packet
   following a non-final segment header aborts the reassembly of the
   current reconstructed unit and causes the decompressor to discard the
   non-final segments received on this channel so far.

   When a final segment header is received, the decompressor reassembles
   the segment of this packet and any non-final segments that
   immediately preceded it into a single reconstructed unit, in the
   order they were transmitted.  This has the format:

   Reconstructed unit

     0   1   2   3   4   5   6   7
   +---+---+---+---+---+---+---+---+
   |                               |
   /   Reconstructed ROHC packet   /  variable length
   |                               |
   +---+---+---+---+---+---+---+---+
   |              CRC              |  4 octets
   +---+---+---+---+---+---+---+---+

   The CRC is used by the decompressor to validate the reconstructed
   unit.  It uses the FCS-32 algorithm, with a generator polynomial of:
   x^0 + x^1 + x^2 + x^4 + x^5 + x^7 + x^8 + x^10 + x^11 + x^12 + x^16 +
   x^22 + x^23 + x^26 + x^32 [HDLC].  If the reconstructed unit is 4
   octets or less, or if the CRC fails, or if it is larger than the
   channel parameter MRRU (see 5.1.1), the reconstructed unit is
   discarded by the decompressor.

   If the CRC succeeds, the reconstructed ROHC packet is interpreted as
   a ROHC header, optionally followed by a ROHC payload.  Note that this
   means that there can be no padding and no feedback in the



Bormann (ed.)                                                  [Page 43]

INTERNET-DRAFT          Robust Header Compression           Oct 23, 2000


   reconstructed unit, and that the CID is derived from the initial
   octets of the reconstructed unit.

   (It should be noted that the ROHC segmentation protocol was inspired
   by Steve Deering's et al. SEAL, which later became ATM AAL5.  The
   same arguments for not having sequence numbers in the segments but
   instead providing a strong CRC in the reconstructed unit do apply
   here.  Note that, as a result of this protocol, there is no way in
   ROHC to make any use of a segment that has residual bit errors.)


5.2.5.  ROHC Initial decompressor processing

   The following packet types are reserved in the ROHC scheme:

   1110:     Padding or Add-CID octet
   111110:   Feedback
   1111110:  IR packet
   1111111:  Segment

   Other packet types can be used at will by individual profiles.

   The following steps is an outline of initial decompressor processing
   which upon reception of a ROHC packet can determine its contents.

   1) If the first octet is a Padding Octet (11100000),
           strip away all initial Padding Octets and goto next step.

   2) If the first remaining octet starts with 1110, it is an Add-CID
      octet.
           remember the Add-CID octet; remove octet.

   3) If the first remaining octet starts with 111110, this is feedback.
           find the size of the feedback, call it s;
           Remove the feedback type octet;
           Remove the size octet if code was 0;
           If an Add-CID was found in 2),
               Prepend it to the feedback;
               Let s be s+1;
           Send feedback of length s to same-side associated compressor;
           If packet exhausted, stop. Otherwise goto 2);

   4) If the first remaining octet starts with 1111111, this is a
      segment.  Attempt reconstruction using the segmentation protocol
      (5.2.4.); this finishes the processing of this packet.

   5) Here, it is known that the rest is forward information (unless the
      header is damaged).






Bormann (ed.)                                                  [Page 44]

INTERNET-DRAFT          Robust Header Compression           Oct 23, 2000


   6) If the forward traffic uses small CIDs, there is no large CID in
      the packet. If an Add-CID immediately preceded the packet type
      (step 2), it has the CID of the Add-CID. Otherwise it has CID 0.

   7) If the forward traffic uses large CIDs, the CID starts with the
      second remaining octet. If the first bit(s) of that octet are not
      0 or 10, the packet MUST be discarded without further action. If
      an Add-CID octet immediately preceded the packet type, the packet
      MUST be discarded without further action.

   8) Use the CID to find the context. The profile noted in the context
      determines how the rest of the packet should be interpreted. If
      the CID has not been initialized by an IR packet, and the packet
      type in the first octet is not the IR packet type, the packet
      MUST be discarded without further action.

   The procedure for examining the first few octets of the feedback to
   find its size is as follows:

     Examine the two bits which immediately follow the feedback packet
     type. When these bits are
         1-3: the size of the feedback is given by the bits.
         0:   a Size octet, which explicitly gives the size of the
              feedback, is present after the feedback type octet.


5.2.6.  ROHC RTP Packet formats from compressor to decompressor

   ROHC RTP uses three packet types to identify compressed headers, and
   two for initialization/refresh. The format of a compressed packet can
   depend on the mode. Therefore a naming scheme of the form

       <modes format is used in>-<packet type number>-<some property>

   is used to uniquely identify the format when necessary. E.g, UOR-2,
   R-1. For exact formats of the packet types, see section 5.7.

   Packet type zero: R-0, R-0-CRC, UO-0.

     This, the minimal, packet type is used when parameters of all SN-
     functions are known by the decompressor, and the header to be
     compressed adheres to those functions. Thus, only the W-LSB encoded
     RTP SN needs to be communicated.

     R-mode:  Only if a CRC is present (packet type R-0-CRC) may the
     header be used as a reference for subsequent decompression.

     U-mode and O-mode: A small CRC is present in the UO-0 packet.

   Packet type 1: R-1, R-1-ID, R-1-TS, UO-1, UO-1-ID, UO-1-TS.




Bormann (ed.)                                                  [Page 45]

INTERNET-DRAFT          Robust Header Compression           Oct 23, 2000


     This packet type is used when the number of bits needed for the SN
     exceeds those available in packet type zero, or when the parameters
     of the SN-functions for RTP TS or IP-ID change.

     R-mode: R-1-* packets are not used as references for subsequent
     decompression. Values for other fields than the RTP TS or IP-ID can
     be communicated using an extension, but they do not update the
     context.

     U-mode and O-mode: Only the values of RTP SN, RTP TS and IP-ID can
     be used as references for future compression. Non-updating values
     can be provided for other fields using an extension (UO-1-ID).

   Packet type 2: UOR-2, UOR-2-ID, UOR-2-TS

     This packet type can be used to change the parameters of any SN-
     function, except for those for most static fields. Headers of
     packets transferred using packet type 2 can be used as references
     for subsequent decompression.

   Packet type 5: IR

     This packet type communicates the static part of the context, i.e.,
     the value of the constant SN-functions. It can optionally also
     communicate the dynamic part of the context, i.e., the parameters
     of the non-constant SN-functions.

   Packet type 6: IR-DYN

     This packet type communicates the dynamic part of the context,
     i.e., the parameters of non-constant SN-functions.


5.2.7.  Parameters needed for mode transition in ROHC RTP

   The packet type UOR-2 is common for all modes. It can carry an
   extension with a mode parameter which can take the values U  =
   Unidirectional, O = Bi-directional Optimistic, and R= Bi-directional
   Reliable.

   Feedback of types ACK, NACK, and STATIC-NACK carry sequence numbers
   and feedback packets can also carry a mode parameter indicating the
   desired compression mode: U, O, or R.

   As a shorthand, the notation PACKET(mode) is used to indicate which
   mode value a packet carries. For example, an ACK with mode parameter
   R is written ACK(R), and an UOR-2 with mode parameter O is written
   UOR-2(O).






Bormann (ed.)                                                  [Page 46]

INTERNET-DRAFT          Robust Header Compression           Oct 23, 2000


5.3.  Operation in unidirectional mode

5.3.1.  Compressor states and logic (U-mode)

   Below is the state machine for the compressor in unidirectional mode.
   Details of the transitions between states and compression logic are
   given subsequent to the figure.

                            Optimistic approach
      +------>------>------>------>------>------>------>------>------+
      |                                                              |
      |        Optimistic approach         Optimistic approach       |
      |      +------>------>------+      +------>------>------+      |
      |      |                    |      |                    |      |
      |      |                    v      |                    v      v
    +----------+                +----------+                +----------+
    | IR State |                | FO State |                | SO State |
    +----------+                +----------+                +----------+
      ^      ^                    |      ^                    |      |
      |      |      Timeout       |      |  Timeout / Update  |      |
      |      +------<------<------+      +------<------<------+      |
      |                                                              |
      |                           Timeout                            |
      +------<------<------<------<------<------<------<------<------+


5.3.1.1.  State transition logic (U-mode)

   The transition logic for compression states in unidirectional mode is
   based on three principles; the optimistic approach principle,
   timeouts, and the need for updates.


5.3.1.1.1.  Optimistic approach, upwards transition

   Transition to higher compression state in unidirectional mode is
   carried out according to the optimistic approach principle. This
   means that the compressor transits to a higher compression state when
   it is rather confident that the decompressor has received enough
   information to correctly decompress packets sent according to the
   higher compression state.

   When the compressor is in IR state, it will stay there until it
   assumes that the decompressor has correctly received the static
   context information. For transition from FO to SO state, the
   compressor should be confident that the decompressor has all
   parameters needed to decompress according to a fixed pattern.

   The compressor normally gets its confidence about decompressor status
   by sending several packets with the same information according to the
   lower compression state. If the decompressor receives any of these



Bormann (ed.)                                                  [Page 47]

INTERNET-DRAFT          Robust Header Compression           Oct 23, 2000


   packets, it will be in sync with the compressor. The number of
   consecutive packets to send for confidence is not defined in this
   document.


5.3.1.1.2.  Timeouts, downward transition

   By using the optimistic approach described above, there will always
   be a possibility for failure since the decompressor may not have
   received sufficient information for correct decompression. Therefore,
   the compressor MUST periodically transit to lower compression states.
   Periodic transition to IR state SHOULD be carried out less often than
   transition to FO state. Two different timeouts SHOULD therefore be
   used for these transitions. For an example of how to implement
   periodic refreshes, see [IPHC] chapter 3.3.1-3.3.2.


5.3.1.1.3.  Need for updates, downward transition

   In addition to the downward state transitions carried out due to
   periodic timeouts, the compressor must also immediately transit back
   to FO state when the header to be compressed does not conform to the
   established pattern.


5.3.1.2.  Compression logic and packets used (U-mode)

   The compressor chooses the smallest possible packet format that can
   communicate the desired changes, and has the required number of bits
   for W-LSB encoded values. Sliding windows used in W-LSB encoding have
   a fixed width, not defined in this document.


5.3.1.3.  Feedback in unidirectional mode

   The unidirectional mode of operation is designed to operate over
   links where a feedback channel is not available. If a feedback
   channel is available, however, the decompressor MAY send an
   acknowledgment of successful decompression with the mode parameter
   set to U (send an ACK(U)). When the compressor receives such a
   message, it MAY disable (or increase the interval between) periodic
   IR refreshes.


5.3.2.  Decompressor states and logic (U-mode)

   Below is the state machine for the decompressor in unidirectional
   mode. Details of the transitions between states and decompression
   logic are given subsequent to the figure.

                                  Success



Bormann (ed.)                                                  [Page 48]

INTERNET-DRAFT          Robust Header Compression           Oct 23, 2000


                 +-->------>------>------>------>------>--+
                 |                                        |
     No Static   |            No Dynamic        Success   |    Success
      +-->--+    |             +-->--+      +--->----->---+    +-->--+
      |     |    |             |     |      |             |    |     |
      |     v    |             |     v      |             v    |     v
    +--------------+         +----------------+         +--------------+
    |  No Context  |         | Static Context |         | Full Context |
    +--------------+         +----------------+         +--------------+
       ^                         |        ^                         |
       | k_1 out of n_1 failures |        | k_2 out of n_2 failures |
       +-----<------<------<-----+        +-----<------<------<-----+


5.3.2.1.  State transition logic (U-mode)

   Successful decompression will always move the decompressor to the
   Full Context state. Repeated failed decompression will force the
   decompressor to transit downwards to a lower state. The decompressor
   does not attempt to decompress headers at all in the No Context and
   Static Context states unless sufficient information is included in
   the packet itself.


5.3.2.2.  Decompression logic (U-mode)

   Decompression in unidirectional mode is carried out following three
   steps which are described in subsequent sections.


5.3.2.2.1.  Decide whether decompression is allowed

   In Full Context state, decompression may be attempted regardless of
   what kind of packet is received. However, for the other states
   decompression is not always allowed. In the No Context state only IR
   packets, which carry the static information fields, may be
   decompressed. Further, when in the Static Context state, only packets
   carrying a 7- or 8-bit CRC can be decompressed (i.e., IR, IR-DYN, or
   UOR-2 packets). If decompression may not be performed the packet is
   discarded, unless the optional delayed decompression mechanism is
   used, see section 6.1.


5.3.2.2.2.  Reconstruct and verify the header

   When reconstructing the header, the decompressor takes the header
   information already stored in the context, and updates it with the
   information received in the current header (if the reconstructed
   header fails the CRC check, these updates MUST be undone.)





Bormann (ed.)                                                  [Page 49]

INTERNET-DRAFT          Robust Header Compression           Oct 23, 2000


   The sequence number is reconstructing by replacing the sequence
   number LSBs in the context with those received in the header. The
   resulting value is then verified to be within the interpretation
   interval based on a previously reconstructed reference value v_ref
   (see section 4.5.1.). If not within this interval, an adjustment is
   applied by adding N x interval_size to the reconstructed value so
   that the result is within the interpretation interval. Note that N
   can be negative.

   If RTP Timestamp and IP Identification fields are not included in the
   received header, they are supposed to be calculated based on the
   sequence number. The IP Identifier is usually increasing with the
   same delta as the sequence number and the timestamp with the same
   delta times a fixed value. See chapters 4.5.3 and 4.5.5 for details
   about how these fields are encoded in compressed headers.

   When working in unidirectional mode, all decompressed headers carry a
   CRC which MUST be used to verify decompression.


5.3.2.2.3.  Actions upon CRC failure

   This section is written so that is applicable to all modes.

   A mismatch in the CRC can be caused by one or more of:

     1. residual bit errors in the current header,

     2. a damaged context due to residual bit errors in previous
        headers, or

     3. many consecutive packets being lost between compressor and
        decompressor can cause the LSBs of the SN in compressed packets
        to be interpreted wrongly, since the decompressor did not move
        the interpretation interval due to lack of input (which is, in
        essence, a kind of context damage).

   The 3-bit CRC present in some header formats will reliably detect
   context damage eventually, since the probability of undetected
   context damage decreases exponentially with each new header
   processed.  However, residual bit errors in the current header are
   only detected with good probability, not reliably.

   When a CRC mismatch is caused by residual bit errors in the current
   header (case 1 above), the decompressor should stay in its current
   state to avoid unnecessary loss of subsequent packets. On the other
   hand, when the mismatch is caused by a damaged context (case 2), the
   decompressor should attempt to repair the context locally. If the
   local repair attempt fails, it must move to a lower state to avoid
   delivering incorrect headers. When the mismatch is caused by long




Bormann (ed.)                                                  [Page 50]

INTERNET-DRAFT          Robust Header Compression           Oct 23, 2000


   loss (case 3), the decompressor might attempt additional
   decompression attempts. Note that case 3 does not occur in R-mode.


   The following actions MUST be taken when a CRC check fails:

   First, attempt to determine whether SN LSB wrap-around (case 3) is
   likely, and if so attempt a correction. For this, the algorithm of
   section 5.3.2.2.4 MAY be used. If another algorithm is used, it MUST
   have at least as high rates of correct repairs as the one in
   5.3.2.2.4. (This first step is not applicable to R-mode.)

   Second, if the previous step did not attempt a correction, a repair
   should be attempted under the assumption that the reference SN has
   been incorrectly updated. For this, the algorithm of section
   5.3.2.2.5 MAY be used. If another algorithm is used, it MUST have at
   least as high rates of correct repairs as the one in 5.3.2.2.5. (This
   step is OPTIONAL in R-mode.)

   If both the above steps fail, additional decompression attempts
   SHOULD NOT be made. There are two possible reasons for the CRC
   failure: case 1 or unrecoverable context damage. It is impossible to
   know which of these is the real cause. The following rules are to be
   used:

   a. When CRC checks fail only occasionally, assume residual errors in
      current header and simply discard the packet. NACKs SHOULD NOT be
      sent at this time.

   b. When the CRC check of k_1 out of the last n_1 decompressed packets
      have failed, context damage SHOULD be assumed and a NACK is sent
      in O- and R-mode. The decompressor moves to the Static Context
      state and discards all packets until an update (IR, IR-DYN, UOR-
      2) which passes the CRC check is received.

   c. When the CRC check of k_2 out of the last n_2 updates (IR, IR-DYN,
      UOR-2) have failed, static context damage SHOULD be assumed and a
      STATIC-NACK is sent in O- and R-mode. The decompressor moves to
      the No Context state and discards all packets until a static
      update (IR) which passes the CRC check is received.

   Note that appropriate values for k_1, n_1, k_2, and n_2, are related
   to the residual error rate of the link. When the residual error rate
   is close to zero, k_1 = n_1 = k_2 = n_2 = 1 can be appropriate.


5.3.2.2.4.  Correction of SN LSB wrap-around

   When many consecutive packets are lost there will be a risk of
   sequence number LSB wrap around, i.e., the SN LSBs being interpreted
   wrongly because the interpretation interval has not moved due to lack



Bormann (ed.)                                                  [Page 51]

INTERNET-DRAFT          Robust Header Compression           Oct 23, 2000


   of input.  The decompressor might be able to detect this situation
   and avoiding context damage by using a local clock. The following
   algorithm MAY be used:

     a.The decompressor notes the arrival time, a(i), of each incoming
       packet i. Arrival times of packets where decompression fails are
       discarded.

     b.When decompression fails, the decompressor computes INTERVAL =
       a(i) - a(i-1), i.e., the time elapsed between the arrival of the
       previous correctly decompressed packet and the current packet.

     c.If wrap-around has occurred, INTERVAL will correspond to at
       least 2^k inter-packet times, where k is the number of SN bits
       in the current header. Based on an estimate of the packet inter-
       arrival time, obtained for example using a moving average of
       arrival times, TS STRIDE, or TS TIME, the decompressor judges if
       INTERVAL can correspond to 2^k inter-packet times.

     d.If INTERVAL is judged to be at least 2^k packet inter-arrival
       times, the decompressor adds 2^k to the reference SN and
       attempts to decompress the packet using the new reference SN.

     e.If this decompression succeeds, the decompressor updates the
       context but SHOULD NOT deliver the packet to upper layers. The
       following packet is also decompressed and updates the context if
       its CRC succeeds, but SHOULD be discarded. If decompression of
       the third packet using the new context also succeeds, the
       context repair is deemed successful and this and subsequent
       decompressed packets are delivered to the upper layers.

     f.If any of the three decompression attempts in d. and e. fails,
       the decompressor discards the packets and acts according to
       rules a) through c) of section 5.3.2.2.3.

   Using this mechanism, the decompressor may be able to repair the
   context after excessive loss, at the expense of discarding two
   packets.


5.3.2.2.5.  Repair of incorrect SN updates

   The CRC can fail to detect residual errors in the compressed header
   because of its limited length, i.e., the incorrectly decompressed
   packet can happen to have the same CRC as the original uncompressed
   packet. The incorrect decompressed header will then update the
   context. This can lead to an erroneous reference SN being used in W-
   LSB decoding, as the reference SN is updated for each successfully
   decompressed header of certain types.





Bormann (ed.)                                                  [Page 52]

INTERNET-DRAFT          Robust Header Compression           Oct 23, 2000


   In this situation, the decompressor will detect the incorrect
   decompression of the following packet with high probability, but it
   does not know the reason for the failure. The following mechanism
   allows the decompressor to judge if the context was updated
   incorrectly by an earlier packet and if so attempt a repair.

   a. The decompressor maintains two decompressed sequence numbers: the
      last one (ref 0) and the one before that (ref -1).

   b. When receiving a compressed header the SN (SN curr1) is
      decompressed using ref 0 as the reference. The other header
      fields are decompressed using this decompressed SN curr1. (This
      is part of the normal decompression procedure prior to any CRC
      test failures.)

   c. If the decompressed header generated in b. passes the CRC test
      the references are shifted as follows:
           ref -1 = ref 0
           ref 0  = SN curr1.

   d. If the header generated in b. does not pass the CRC test, and the
      SN (SN curr2) generated when using ref _1 as the reference is
      different from SN curr1, an additional decompression attempt is
      performed based on SN curr2 as the decompressed SN.

   e. If the decompressed header generated in b. does not pass the CRC
      test and SN curr2 is the same as SN curr1, an additional
      decompression attempt is not useful and is not attempted.

   f. If the decompressed header generated in d. passes the CRC test,
      ref -1 is not changed while ref 0 is set to SN curr2.

   g. If the decompressed header generated in d. does not pass the CRC
      test, the decompressor acts according to rules a) through c) of
      section 5.3.2.2.3.

   The purpose of this algorithm is to repair the context. If the header
   generated in d. passes the CRC test the references are updated
   according to f., but two more headers MUST also be successfully
   decompressed before the repair is deemed successful. Of the three
   successful headers, the first two SHOULD be discarded and only the
   third delivered to upper layers. If decompression of any of the three
   headers fail, the decompressor MUST discard that header and the
   previously generated headers, and act according to rules a) through
   c) of section 5.3.2.2.3.


5.3.2.3.  Feedback in unidirectional mode

   To improve performance for the unidirectional mode over a link that
   does have a feedback channel, the decompressor MAY send an



Bormann (ed.)                                                  [Page 53]

INTERNET-DRAFT          Robust Header Compression           Oct 23, 2000


   acknowledgment when decompression succeeds. Setting the mode
   parameter in the ACK packet to U indicates that the compressor is to
   stay in unidirectional mode.  When receiving an ACK(U), the
   compressor should reduce the frequency of IR packets since the static
   information has been correctly received, but it is not required to
   stop sending IR packets. If IR packets continue to arrive, the
   decompressor MAY repeat the ACK(U), but it SHOULD not repeat the
   ACK(U) continuously.


5.4.  Operation in bi-directional optimistic mode

5.4.1.  Compressor states and logic (O-mode)

   Below is the state machine for the compressor in bi-directional
   optimistic mode. Details of each state, the transitions between
   states and compression logic are given subsequent to the figure.

                         Optimistic approach / ACK
      +------>------>------>------>------>------>------>------>------+
      |                                                              |
      |      Optimistic appr. / ACK      Optimistic appr. / ACK      |
      |      +------>------>------+      +------>------>------+      |
      |      |                    |      |                    |      |
      |      |                    v      |                    v      v
    +----------+                +----------+                +----------+
    | IR State |                | FO State |                | SO State |
    +----------+                +----------+                +----------+
      ^      ^                    |      ^                    |      |
      |      |    STATIC-NACK     |      |    NACK / Update   |      |
      |      +------<------<------+      +------<------<------+      |
      |                                                              |
      |                         STATIC-NACK                          |
      +------<------<------<------<------<------<------<------<------+


5.4.1.1.  State transition logic

   The transition logic for compression states in bi-directional
   optimistic mode has much in common with the logic of the
   unidirectional mode. The optimistic approach principle and
   transitions because of the need for updates works in the same way as
   described in chapter 5.3.1. However, in optimistic mode there are no
   timeouts. Instead, the optimistic mode makes use of feedback from
   decompressor to compressor for transitions in the backward direction
   and for OPTIONAL improved forward transition.

5.4.1.1.1.  Negative acknowledgments (NACKs), downward transition

   Negative acknowledgments (NACKs), also called context requests,
   obviate the periodic updates needed in unidirectional mode. Upon



Bormann (ed.)                                                  [Page 54]

INTERNET-DRAFT          Robust Header Compression           Oct 23, 2000


   reception of a NACK the compressor transits back to the FO state and
   sends updates (IR-DYN, UOR-2, or possibly IR) to the decompressor.
   NACKs carry the SN of the latest packet successfully decompressed,
   and this information MAY be used by the compressor to determine what
   fields need to be updated.

   Similarly, reception of a STATIC-NACK packet makes the compressor
   transit back to IR state.

5.4.1.1.2.  Optional acknowledgments, upwards transition

   In addition to NACKs, also positive feedback (ACKs) MAY be used for
   PT2 packets in the bi-directional optimistic mode. Upon reception of
   an ACK for an updating packet, the compressor knows that the
   decompressor has received the acknowledged packet and transition to a
   higher compression state can be carried out immediately. This
   functionality is optional, so a compressor MUST NOT expect to get
   such ACKs initially.

   The compressor MAY use the following algorithm to determine when to
   expect ACKs for UOR-2 packets. Let an update event be when a sequence
   of UOR-2 headers are sent to communicate an irregularity in the
   packet stream. When ACKs have been received for k_3 out of the last
   n_3 update events, the compressor will expect ACKs. A compressor
   which expects ACKs will repeat updates (possibly not in every packet)
   until an ACK is received.


5.4.1.2.  Compression logic and packets used

   The compression logic is the same for bi-directional optimistic mode
   as for the unidirectional mode (see section 5.3.1.2).


5.4.2.  Decompressor states and logic (O-mode)

   The decompression states and the state transition logic are the same
   as for the unidirectional case (see section 5.3.2). What differs is
   the decompression and feedback logic.


5.4.2.1.  Decompression logic, timer-based timestamp decompression

   In bi-directional mode, timer-based timestamp decompression may be
   used to improve compression efficiency when RTP timestamp values are
   proportional to wall-clock time. The mechanisms used are those
   described in 4.5.4.







Bormann (ed.)                                                  [Page 55]

INTERNET-DRAFT          Robust Header Compression           Oct 23, 2000



5.4.2.2.  Feedback logic (O-mode)

   The feedback logic defines what feedback to send due to different
   events when operating in the various states. As mentioned above,
   there are three principal kinds of feedback; ACK, NACK and STATIC-
   NACK. Further, the logic described below will refer to three kinds of
   packets that can be received by the decompressor; Initialization and
   Refresh (IR or IR-DYN) packets, type 1 (UO-1) or 2 (UOR-2) packets
   and type 0 packets (UO-0). A type 0 packet carries a packet header
   compressed according to a fixed pattern while type 1 and 2 packets
   are used when this patterns is broken.

   Below, rules for which feedback to use when are defined. For the
   optional feedback, it is REQUIRED that if used once, the decompressor
   must continue to send optional feedback for the lifetime of the
   packet stream.

   State  Actions
     NC   - When an IR packet passes the CRC check, send an ACK(O).
          - When receiving a type 0, 1, or 2 packet, or an IR packet has
           failed the CRC check, use the logic in section 5.3.2.2.3 to
           decide if a NACK(O) should be sent. Reception of type 0, 1,
           or 2 is logically treated as a CRC failure.

     SC   - When an IR packet is correctly decompressed, send an ACK(O).
          -When a type 2 packet is correctly decompressed, optionally
           send an ACK(O).
          -When a type 0 or 1 packet is received, treat it as a
           mismatching CRC and use the logic of section 5.3.2.2.3 to
           decide if a NACK(O) should be sent.
          -When decompression of a type 2 packet or an IR packet has
           failed, use the logic of section 5.3.2.2.3 to decide if a
           STATIC-NACK(O) should be sent.

     FC   - When an IR packet is correctly decompressed, send an IR-
           ACK(O).
          -When an UOR2 packet is correctly decompressed, optionally
           send an ACK(O).
          - When a type 0 or 1 packet is correctly decompressed, no
           feedback is sent.
          -When any packet fails the CRC check, use the logic of
           5.3.2.2.3 to decide if a NACK(O) should be sent.











Bormann (ed.)                                                  [Page 56]

INTERNET-DRAFT          Robust Header Compression           Oct 23, 2000


5.5.  Operation in bi-directional reliable mode

5.5.1.  Compressor states and logic (R-mode)

   Below is the state machine for the compressor in bi-directional
   reliable mode. Details of each state, the transitions between states
   and compression logic are given subsequent to the figure.

                                       ACK
      +------>------>------>------>------>------>------>------+
      |                                                       |
      |               ACK                         ACK         |   ACK
      |      +------>------>------+      +------>------>------+  +->-+
      |      |                    |      |                    |  |   |
      |      |                    v      |                    v  |   v
    +----------+                +----------+                +----------+
    | IR State |                | FO State |                | SO State |
    +----------+                +----------+                +----------+
      ^      ^                    |      ^                    |      |
      |      |    STATIC-NACK     |      |    NACK / Update   |      |
      |      +------<------<------+      +------<------<------+      |
      |                                                              |
      |                         STATIC-NACK                          |
      +------<------<------<------<------<------<------<------<------+


5.5.1.1.  State transition logic (R-mode)

   The transition logic for compression states in reliable mode is based
   on three principles: the secure reference principle, the need for
   updates, and negative acknowledgements.


5.5.1.1.1 Upwards transition

   The upwards transition is determined by the secure reference
   principle.  The transition procedure is similar to the one described
   in section 5.3.1.1.1, with one important difference -- the compressor
   bases its confidence only on acknowledgments received from the
   decompressor. This ensures that the synchronization between the
   compression context and decompression context will never be lost due
   to packet losses.


5.5.1.1.2 Downward transition

   Downward transitions are triggered by the need for updates or by
   negative acknowledgment (NACKs and STATIC_NACKs), as described in
   section 5.3.1.1.3 and 5.4.1.1.1, respectively. Note that NACKs should
   rarely occur in R-mode due to the secure reference used (see third
   paragraph of next section).



Bormann (ed.)                                                  [Page 57]

INTERNET-DRAFT          Robust Header Compression           Oct 23, 2000




5.5.1.2.  Compression logic and packets used (R-mode)

   The compressor starts in IR state by sending IR packets. It transits
   to FO state once it receives a valid ACK for an IR packet sent (an
   ACK can only be valid if it refers to an SN sent earlier). In FO
   state, it sends the smallest packets that can communicate the
   changes, according to W-LSB or other encoding rules. Those packets
   could be of type R-1*, UOR-2, or even IR-DYN.

   The compressor will transit to SO state after it determines there is
   a string, AND it is confident that 1) the decompressor has the string
   parameters and 2) the decompressor has correctly received at least
   one header belonging to that string. The confidence can be based on
   ACKs. One ACK is enough for both 2) and 1) if the pattern of the
   string has been previously established by the decompressor.
   Otherwise, two ACKs are required for 1) since the decompressor needs
   two headers to learn the pattern. In SO state, R-0* packets will be
   sent.

   Note that a direct transition from IR state to SO state is possible.

   The secure reference principle is enforced in both compression and
   decompression logic. The principle means that only a packet carrying
   a 7- or 8-bit CRC can update the decompression context and be used as
   reference for subsequent decompression. Consequently, only field
   values of update packets need to be added to the encoding sliding
   windows (see 4.5) maintained by the compressor.

   The reasons for the compressor to send update packets include:
   1) the update can lead to the transition to higher compression
      efficiency (which means either higher compression state or
      smaller packets in the same state)
   2) it is desirable to shrink sliding windows. Windows are only shrunk
      when an ACK is received.

   The generation of CRC is infrequent since it is only needed for an
   update packet.

5.5.2.  Decompressor states and logic (R-mode)

   The decompression states and the state transition logic are the same
   as for the unidirectional case (see section 5.3.2). What differs is
   the decompression and feedback logic.


5.5.2.1.  Decompression logic (R-mode)

   The rules for when decompression is allowed are the same as for U-
   mode. Although the acking scheme of R-mode guarantees that non-



Bormann (ed.)                                                  [Page 58]

INTERNET-DRAFT          Robust Header Compression           Oct 23, 2000


   decompressible packets are never sent by the compressor, residual
   errors can cause delivery of unexpected packets for which
   decompression should not be attempted.

   Decompression MUST follow the secure reference principle as described
   in 5.5.1.2.

   CRC verification is infrequent since only update packets carry CRCs.
   A CRC mismatch can only occur due to 1) residual bit errors in the
   current header, and/or 2) a damaged context due to residual bit
   errors in previous headers. Although it is impossible to determine
   which is the real cause, case 1 is more likely as a previous header
   reconstructed according to a damaged packet is unlikely to pass the
   7- or 8-bit CRC. The decompressor SHOULD act according to section
   5.3.2.2.3 when CRCs fail, except that SN wrap-around is not possible
   and thus there is no need to detect it.

5.5.2.2.  Feedback logic (R-mode)

   The feedback logic for the bi-directional reliable mode is as
   follows:

   - When an updating packet (i.e., a packet carrying a 7- or 8-bit CRC)
     is correctly decompressed, send an ACK(R).

   - When context damage is detected, send a NACK(R) if in Full Context
     state, or a STATIC-NACK(R) if in Static Context state.

   - Feedback is never sent for packets not updating the context (i.e.
     packets that do not carry a CRC)

   Negative feedback is sent according to the same principles as in
   5.3.2.2.3. See also previous section.

   When the decompressor is capable of timer-based compression of RTP
   Timestamp (e.g., it has access to a clock with sufficient resolution
   and the jitter introduced internally in the receiving node is
   sufficiently small) it SHOULD signal that it is ready to do timer-
   based compression of the RTP timestamp. (The compressor will then
   decide based on its knowledge of the channel and the observed
   properties of the packet stream.)


5.6.  Mode transitions

   The decision to move from one compression mode to another is taken by
   the decompressor and the possible mode transitions are shown in the
   figure below. Subsequent chapters describe how the transitions are
   performed together with exceptions for the compression and
   decompression functionality during transitions.




Bormann (ed.)                                                  [Page 59]

INTERNET-DRAFT          Robust Header Compression           Oct 23, 2000


                         +-------------------------+
                         | Unidirectional (U) mode |
                         +-------------------------+
                           / ^                 \ ^
                          / /Feedback(U)        \ \Feedback(U)
                         / /                     \ \
                        / /                       \ \
            Feedback(O)/ /              Feedback(R)\ \
                      v /                           v \
      +---------------------+    Feedback(R)    +-------------------+
      | Optimistic (O) mode | ----------------> | Reliable (R) mode |
      |                     | <---------------- |                   |
      +---------------------+    Feedback(O)    +-------------------+


5.6.1.  Compression and decompression during mode transitions

   The following sections assume that compressor and decompressor for
   each context maintains a variable, whose value is the current
   compression mode for that context. The value of the variable controls
   which packet types to use, actions taken, etc, for that context.

   As a safeguard against residual errors, all feedback sent during a
   mode transition MUST be protected by a CRC, i.e., the CRC option MUST
   be used. Mode transition MUST NOT be initiated by feedback which is
   not protected by a CRC.

   Subsequent chapters define exactly when to change the value of the
   MODE variable. When ROHC transits between compression modes, there
   are several cases where the behavior of compressor or decompressor
   must be restricted during the transition phase. These restrictions
   are defined by exception parameters that specifies which restrictions
   to apply. The transition descriptions in subsequent chapters refer to
   these exception parameters and defines when and to what values they
   are set. All mode related parameters are listed below together with
   their possible values, with explanations and restrictions:

   Parameters for the compressor side:

      - C_MODE
                Possible values for the C_MODE parameter are
                (U)NIDIRECTIONAL, (O)PTIMISTIC and (R)ELIABLE. C MODE
                MUST be initialized to U.

      - C_TRANS
                Possible values for the C_TRANS parameter are (P)ENDING
                and (D)ONE. C TRANS MUST be initialized to D. When C
                TRANS is P, it is REQUIRED that
                1) the compressor only uses packet formats common to
                   all modes,
                2) it does not transit to SO state.



Bormann (ed.)                                                  [Page 60]

INTERNET-DRAFT          Robust Header Compression           Oct 23, 2000


                3) New mode transition requests are ignored.

   Parameters for the decompressor side:

      - D_MODE
                Possible values for the D_MODE parameter are
                (U)NIDIRECTIONAL, (O)PTIMISTIC and (R)ELIABLE. C MODE
                MUST be initialized to U.


      - D_TRANS
                Possible values for the D_TRANS parameter are
                (I)NITIATED, (P)ENDING and (D)ONE. D TRANS MUST be
                initialized to D. A mode transition can be initiated
                only when D TRANS is D. While D TRANS is I, the
                decompressor sends a NACK or ACK for all received
                packets.


5.6.2.  Transition from Unidirectional to Optimistic mode

   As long as there is a feedback channel available, the decompressor
   may at any moment decide to initiate transition from unidirectional
   to bi-directional Optimistic mode. Any feedback packet carrying a CRC
   can be used with the mode parameter set to O. The decompressor can
   then directly start working in Optimistic mode. The compressor
   transits from unidirectional to optimistic mode as soon as it
   receives any feedback packet with the mode parameter set to O which
   passes the CRC check. The transition procedure is described below:

               Compressor                     Decompressor
              ----------------------------------------------
                    |                               |
                    |        ACK(O)/NACK(O) +-<-<-<-|  D_MODE = O
                    |       +-<-<-<-<-<-<-<-+       |
    C_MODE = O      |-<-<-<-+                       |
                    |                               |

   If the feedback packet is lost, the compressor will continue to work
   in unidirectional mode, but as soon as any feedback packet reaches
   the compressor it will transit to Optimistic mode.


5.6.3.  From Optimistic to Reliable mode

   Transition from Optimistic to Reliable mode is permitted only after
   at least one packet has been correctly decompressed, which means that
   at least the static part of the context is established. An ACK(R) or
   a NACK(R) feedback packet carrying a CRC is sent to initiate the mode
   transition. The compressor MUST NOT use packet types 0 or 1 during
   transition. The transition procedure is described below:



Bormann (ed.)                                                  [Page 61]

INTERNET-DRAFT          Robust Header Compression           Oct 23, 2000



               Compressor                     Decompressor
              ----------------------------------------------
                    |                               |
                    |        ACK(R)/NACK(R) +-<-<-<-|  D_TRANS = I
                    |       +-<-<-<-<-<-<-<-+       |
    C_TRANS = P     |-<-<-<-+                       |
    C_MODE = R      |                               |
                    |->->->-+   FO(SN0,R)           |
                    |       +->->->->->->->-+       |
                    |->-..                  +->->->-|  D TRANS = P
                    |->-..                          |  D_MODE = R
                    |           ACK(SN0,R)  +-<-<-<-|
                    |       +-<-<-<-<-<-<-<-+       |
    C_TRANS = D     |-<-<-<-+                       |
                    |                               |
                    |->->->-+ SO (Reliable mode)    |
                    |       +->->->->->->->-+       |
                    |                       +->->->-|  D_TRANS = D
                    |                               |

   As long as the decompressor has not received an FO packet with the
   mode transition parameter set to R, it must stay in Optimistic mode.
   The compressor must stay in FO state until it has received an ACK for
   an FO packet sent with the mode transition parameter set to R
   (indicated by the sequence number).


5.6.4.  From Unidirectional to Reliable mode

   Since transition from Unidirectional to Optimistic mode do not
   require any handshakes, it is possible to transit directly from
   Unidirectional to Reliable mode, following the same transition
   procedure in 5.6.3 above.


5.6.5.  From Reliable to Optimistic mode

   Either the ACK(O) or the NACK(O) feedback packet is used to initiate
   the transition from Reliable to Optimistic mode and the compressor
   MUST always run in FO state during transition. The transition
   procedure is described below:

               Compressor                     Decompressor
              ----------------------------------------------
                    |                               |
                    |        ACK(O)/NACK(O) +-<-<-<-|  D_TRANS = I
                    |       +-<-<-<-<-<-<-<-+       |
    C_TRANS = P     |-<-<-<-+                       |
    C_MODE = O      |                               |
                    |->->->-+   FO(SN0,O)           |



Bormann (ed.)                                                  [Page 62]

INTERNET-DRAFT          Robust Header Compression           Oct 23, 2000


                    |       +->->->->->->->-+       |
                    |->-..                  +->->->-|  D_MODE = O
                    |->-..                          |
                    |           ACK(SN0,O)  +-<-<-<-|
                    |       +-<-<-<-<-<-<-<-+       |
    C_TRANS = D     |-<-<-<-+                       |
                    |                               |
                    |->->->-+ SO (Optimistic mode)  |
                    |       +->->->->->->->-+       |
                    |                       +->->->-|  D_TRANS = D
                    |                               |

   As long as the decompressor has not received an FO packet with the
   mode transition parameter set to O, it must stay in Reliable mode.
   The compressor must stay in FO state until it has received an ACK for
   a FO packet sent with the mode transition parameter set to O
   (indicated by the sequence number).


5.6.6.  Transition to Unidirectional mode

   It is possible to force transition back to unidirectional mode if the
   decompressor desires to do so. Independent of which mode it starts
   from, a three way handshake MUST be carried out to ensure correct
   transition on the compressor side. The transition procedure is
   described below:

               Compressor                     Decompressor
              ----------------------------------------------
                    |                               |
                    |        ACK(U)/NACK(U) +-<-<-<-|  D_TRANS = I
                    |       +-<-<-<-<-<-<-<-+       |
    C_TRANS = P     |-<-<-<-+                       |
    C_MODE = U      |                               |
                    |->->->-+   FO(SN0,U)           |
                    |       +->->->->->->->-+       |
                    |->-..                  +->->->-|
                    |->-..                          |
                    |           ACK(SN0,U)  +-<-<-<-|
                    |       +-<-<-<-<-<-<-<-+       |
    C_TRANS = D     |-<-<-<-+                       |
                    |                               |
                    |->->->-+ SO (Uni. mode)        |
                    |       +->->->->->->->-+       |
                    |                       +->->->-|  D_TRANS = D
                    |                               |  D_MODE = U

   The decompressor must continue to send feedback until it knows that
   the compressor is ready with the transition.





Bormann (ed.)                                                  [Page 63]

INTERNET-DRAFT          Robust Header Compression           Oct 23, 2000



5.7.  Packet formats

   Similar fields occur in several formats, therefore it is explained
   here how these fields are used. The following notation is used:

     bits(X) = the number of bits for field X present in the compressed
                   header (including extension).

     field(X) = the value of field X in the compressed header.

     context(X) = the value of field X as established in the context.

     value(X) = field(X) if X is present in the compressed header, else
                context(X).

     hdr(X) = the value of field X in the uncompressed or
              decompressed header.



   The following fields occur in several headers and extensions.

   SN    The compressed RTP sequence number.

     Compressed with W-LSB. The interpretation intervals, see section
     4.5.1, are defined as follows:

           p = -1                  if bits(SN) <= 4
           p = 2^(bits(SN)-2) - 1  if bits(SN) >  4


   IP-ID   A compressed IP-ID field.

     IP-ID fields in compressed base headers carry the compressed IP-ID
     of the innermost IPv4 header whose corresponding RND flag is not 1.

     The rules below assume the IP-ID is for the innermost IP header. If
     it is for an outer IP header, the RND2 and NBO2 flags should be
     used instead of RND and NBO.

     If value(RND)=0, hdr(IP-ID) is compressed using Offset IP-ID
     encoding, see section 4.5.5., using p=0 and default-slope(IP-ID
     offset)=0.

     If value(RND)=1, IP-ID is the uncompressed hdr(IP-ID). IP-ID is
     then passed as additional octets at the end of the compressed
     header, after any Extensions.






Bormann (ed.)                                                  [Page 64]

INTERNET-DRAFT          Robust Header Compression           Oct 23, 2000


     If value(NBO)=1, the octets of hdr(IP-ID) are swapped before
     compression and after decompression. It is pointless but not
     harmful to set both NBO and RND.


   TS    The compressed RTP Timestamp value.

     If value(TIME_STRIDE) > 0, Timer-based compression of RTP
     Timestamp, see section 4.5.4., is used.

     If value(Tsc)=1, Scaled RTP Timestamp encoding is used before
     compression, see section 4.5.3., and default-slope(TS) = 1.

     If value(Tsc)=0, the Timestamp value is compressed as-is, and
     default-slope(TS) = value(TS_STRIDE).


   CRC   CRC over the original, uncompressed, header.

     For 3-bit CRCs, the polynomial of section 5.9.2 is used.
     For 7-bit CRCs, the polynomial of section 5.9.2 is used.
     For 8-bit CRCs, the polynomial of section 5.9.1 is used.


   M   RTP Marker bit.

     Context(M) is initially zero and is never updated. Value(M)=1 only
     when field(M)=1.


























Bormann (ed.)                                                  [Page 65]

INTERNET-DRAFT          Robust Header Compression           Oct 23, 2000


   The general format for a compressed RTP header is as follows

     0   1   2   3   4   5   6   7
    --- --- --- --- --- --- --- ---
   |         Add-CID octet         | if for CID 1-15 and small CIDs
   +---+---+---+---+---+---+---+---+
   |   first octet of base header  | (with type indication)
   +---+---+---+---+---+---+---+---+
   |                               |
   /   0, 1, or 2 octets of CID    / 1-2 octets if large CIDs
   |                               |
   +---+---+---+---+---+---+---+---+
   /   remainder of base header    / variable number of bits
   +---+---+---+---+---+---+---+---+
   /     Extension (see 5.7.5)     / extension, if X=1 in base header
    --- --- --- --- --- --- --- ---
   /   IP-ID of inner Ipv4 header  / 2 octets, if value(RND)=1
    --- --- --- --- --- --- --- ---
   /   IP-ID of outer IPv4 header  / 2 octets, if value(RND2)=1
    --- --- --- --- --- --- --- ---
   /         UDP Checksum          / 2 oct, if context(UDP Checksum)!= 0
    --- --- --- --- --- --- --- ---
   /    AH data for outer list     / variable  (see 5.8.4.2)
    --- --- --- --- --- --- --- ---
   /    AH data for inner list     / variable  (see 5.8.4.2)
    --- --- --- --- --- --- --- ---
   /         GRE checksum          / 2 octets, if GRE flag C = 1
    --- --- --- --- --- --- --- ---  (see 5.8.4.2)


   In subsequent sections, the position of the large CID is indicated
   using the notation

   +===+===+===+===+===+===+===+===+


   Whether the UDP Checksum field is present or not is controlled by the
   value of the UDP Checksum in the context. If non-zero, the UDP
   checksum is enabled and sent along with each packet. If zero, the UDP
   Checksum is disabled and not sent. Should hdr(UDP checksum) be non-
   zero when context(UDP Checksum) is non-zero, the header cannot be
   compressed. It must be sent uncompressed or the context reinitialized
   using an IR-packet.

   When an IPv4 header is present in the static context, for which the
   corresponding RND flag has not been established to be 1, packet types
   R-1 and UO-1 MUST NOT be used.

   When no IPv4 header is present in the static context, or the RND
   flags for all IPv4 headers in the context have been established to be




Bormann (ed.)                                                  [Page 66]

INTERNET-DRAFT          Robust Header Compression           Oct 23, 2000


   1, packet types R-1-ID, R-1-TS, UO-1-ID, and UO-1-TS MUST NOT be
   used.

   During the transient state when an RND flag is being established,
   packet types R-1-ID, R-1-TS, UO-1-ID, or UO-1-TS, MUST NOT be used.
   This implies that the RND flag(s) of the Extension 3 may have to be
   consulted before the format of a base header carrying an Extension 3
   can be determined.


5.7.1. Packet type 0: UO-0, R-0, R-0-CRC

   Packet type 0 is indicated by the first bit being 0:

   R-0

     0   1   2   3   4   5   6   7
   +---+---+---+---+---+---+---+---+
   | 0 | 0 |          SN           |
   +===+===+===+===+===+===+===+===+

     Updating properties: R-0 packets do not update any part of the
     context.


   R-0-CRC

     0   1   2   3   4   5   6   7
   +---+---+---+---+---+---+---+---+
   | 0 | 1 |            SN         |
   +===+===+===+===+===+===+===+===+
   |SN |            CRC            |
   +---+---+---+---+---+---+---+---+

     Updating properties: R-0-CRC packets updates context(RTP sequence
     number).

     Note: the SN field straddles the CID field.


   UO-0

     0   1   2   3   4   5   6   7
   +---+---+---+---+---+---+---+---+
   | 0 |      SN       |    CRC    |
   +===+===+===+===+===+===+===+===+

     Updating properties: The UO-0 packet updates the current value of
     context(RTP sequence number).





Bormann (ed.)                                                  [Page 67]

INTERNET-DRAFT          Robust Header Compression           Oct 23, 2000


5.7.2. Packet type 1 (R-mode): R-1, R-1-TS, R-1-ID

   Packet type 1 is indicated by the first bits being 10

   R-1

     0   1   2   3   4   5   6   7
   +---+---+---+---+---+---+---+---+
   | 1   0 |          SN           |
   +===+===+===+===+===+===+===+===+
   | M | X |          TS           |
   +---+---+---+---+---+---+---+---+

     Note: R-1 cannot be used if the context contains at least one IPv4
     header with value(RND) = 0.  This disambiguates it from R-1-ID and
     R-1-TS.

   R-1-ID

     0   1   2   3   4   5   6   7
   +---+---+---+---+---+---+---+---+
   | 1   0 |          SN           |
   +===+===+===+===+===+===+===+===+
   | M | X |T=0|       IP-ID       |
   +---+---+---+---+---+---+---+---+

     Note: R-1-ID cannot be used if there is no IPv4 header in the
     context or if value(RND) and value(RND2) are both 1.

   R-1-TS

     0   1   2   3   4   5   6   7
   +---+---+---+---+---+---+---+---+
   | 1   0 |          SN           |
   +===+===+===+===+===+===+===+===+
   | M | X |T=1|        TS         |
   +---+---+---+---+---+---+---+---+

     Note: R-1-TS cannot be used if there is no IPv4 header in the
     context or if value(RND) and value(RND2) are both 1.

     X: X=0 indicates that no Extension is present,
        X=1 indicates that an Extension is present.

     T: T=0 indicates format R-1-ID,
        T=1 indicates format R-1-TS.

     Updating properties: R-1* headers do not update any part of the
     context.





Bormann (ed.)                                                  [Page 68]

INTERNET-DRAFT          Robust Header Compression           Oct 23, 2000


5.7.3. Packet type 1 (UO-modes): UO-1, UO-1-ID, UO-1-TS

   UO-1

     0   1   2   3   4   5   6   7
   +---+---+---+---+---+---+---+---+
   | 1   0 |          TS           |
   +===+===+===+===+===+===+===+===+
   | M |      SN       |    CRC    |
   +---+---+---+---+---+---+---+---+

     Note: UO-1 cannot be used if the context contains at least one IPv4
     header with value(RND) = 0.  This disambiguates it from UO-1-ID and
     UO-1-TS.


   UO-1-ID

     0   1   2   3   4   5   6   7
   +---+---+---+---+---+---+---+---+
   | 1   0 |T=0|       IP-ID       |
   +===+===+===+===+===+===+===+===+
   | X |      SN       |    CRC    |
   +---+---+---+---+---+---+---+---+

     Note: UO-1-ID cannot be used if there is no IPv4 header in the
     context or if value(RND) and value(RND2) are both 1.


   UO-1-TS

     0   1   2   3   4   5   6   7
   +---+---+---+---+---+---+---+---+
   | 1   0 |T=1|        TS         |
   +===+===+===+===+===+===+===+===+
   | M |      SN       |    CRC    |
   +---+---+---+---+---+---+---+---+

     Note: UO-1-TS cannot be used if there is no IPv4 header in the
     context or if value(RND) and value(RND2) are both 1.

     X: X=0 indicates that no Extension is present,
        X=1 indicates that an Extension is present.

     T: T=0 indicates format UO-1-ID, T=1 indicates format UO-1-TS.

     Updating properties: UO-1* packets update context(RTP sequence
     number). UO-1 and UO-1-TS packets update context(RTP Timestamp).
     UO-1-ID packets update context(IP-ID). Values provided in
     Extensions, other than in other SN, TS, or IP-ID fields, do not
     update the context.



Bormann (ed.)                                                  [Page 69]

INTERNET-DRAFT          Robust Header Compression           Oct 23, 2000


5.7.4. Packet type 2: UOR-2

   Packet type 2 is indicated by the first bits being 110

   UOR-2

     0   1   2   3   4   5   6   7
   +---+---+---+---+---+---+---+---+
   | 1   1   0 |        TS         |
   +===+===+===+===+===+===+===+===+
   |TS | M |          SN           |
   +---+---+---+---+---+---+---+---+
   | X |            CRC            |
   +---+---+---+---+---+---+---+---+

     Note: UOR-2 cannot be used if the context contains at least one
     IPv4 header with value(RND) = 0.  This disambiguates it from UOR-2-
     ID and UOR-2-TS.


   UOR-2-ID

     0   1   2   3   4   5   6   7
   +---+---+---+---+---+---+---+---+
   | 1   1   0 |       IP-ID       |
   +===+===+===+===+===+===+===+===+
   |T=0| M |          SN           |
   +---+---+---+---+---+---+---+---+
   | X |            CRC            |
   +---+---+---+---+---+---+---+---+

     Note: UOR-2-ID cannot be used if there is no IPv4 header in the
     context or if value(RND) and value(RND2) are both 1.

   UOR-2-TS

     0   1   2   3   4   5   6   7
   +---+---+---+---+---+---+---+---+
   | 1   1   0 |        TS         |
   +===+===+===+===+===+===+===+===+
   |T=1| M |          SN           |
   +---+---+---+---+---+---+---+---+
   | X |            CRC            |
   +---+---+---+---+---+---+---+---+

     Note: UOR-2-TS cannot be used if there is no IPv4 header in the
     context or if value(RND) and value(RND2) are both 1.

     X: X=0 indicates that no Extension is present,
        X=1 indicates that an Extension is present.




Bormann (ed.)                                                  [Page 70]

INTERNET-DRAFT          Robust Header Compression           Oct 23, 2000


     T: T=0 indicates format UOR-2-ID, T=1 indicates format UOR-2-TS.

     Updating properties: All values provided in UOR-2* packets update
     the context, unless explicitly stated otherwise.


5.7.5.  Extension formats

   Fields in extensions are concatenated with the corresponding field in
   the base compressed header, if any. Bits in an extension are less
   significant than bits in the base compressed header (see 4.5.7.).

   The TS field is scaled in all extensions, as it is in the base
   header, except optionally when using extension 3 where the Tsc flag
   can indicate that the TS field is not scaled. Value(TS_STRIDE) is
   used as the scale factor when scaling the TS field.

   In the following three extensions, the interpretation of the fields
   depend on whether there is a T-bit in the base compressed header, and
   if so, on the value of that field. When there is no T-bit, +T and -T
   both mean TS. This is the case when  there are no IPv4 headers in the
   static context, and when all IPv4 headers in the static context have
   their corresponding RND flag set (i.e., RND=1).

   If there is a T-bit,

     T = 1   indicates that +T is TS, and
                            -T is IP-ID.

     T = 0   indicates that +T is IP-ID, and
                            -T is TS.


   Extension 0:

     0   1   2   3   4   5   6   7
   +---+---+---+---+---+---+---+---+
   | 0   0 |    SN     |    +T     |
   +---+---+---+---+---+---+---+---+

   Extension 1:

   +---+---+---+---+---+---+---+---+
   | 0   1 |    SN     |    +T     |
   +---+---+---+---+---+---+---+---+
   |              -T               |
   +---+---+---+---+---+---+---+---+

   Extension 2:





Bormann (ed.)                                                  [Page 71]

INTERNET-DRAFT          Robust Header Compression           Oct 23, 2000


   +---+---+---+---+---+---+---+---+
   | 1   0 |    SN     |    +T     |
   +---+---+---+---+---+---+---+---+
   |              +T               |
   +---+---+---+---+---+---+---+---+
   |              -T               |
   +---+---+---+---+---+---+---+---+

   Extension 3 is a more elaborate extension which can give values for
   fields other than SN, TS, and IP-ID. Three optional flag octets
   indicates changes to IP header(s) and RTP header, respectively.

   Extension 3:

      0     1     2     3     4     5     6     7
   +-----+-----+-----+-----+-----+-----+-----+-----+
   |  1     1  |  S  |R-TS | Tsc |  I  | ip  | rtp |            (FLAGS)
   +-----+-----+-----+-----+-----+-----+-----+-----+
   |              Inner IP hdr flags         | ip2 |  if ip=1
    ..... ..... ..... ..... ..... ..... ..... .....
   |              Outer IP hdr flags               |  if ip2=1
    ..... ..... ..... ..... ..... ..... ..... .....
   |                      SN                       |  if S=1
    ..... ..... ..... ..... ..... ..... ..... .....
   /       TS (encoded as in section 4.5.6.)       /  1-4 oct, if R-TS=1
    ..... ..... ..... ..... ..... ..... ..... .....
   |                                               |
   /            Inner IP header fields             /  variable, if ip=1
   |                                               |
    ..... ..... ..... ..... ..... ..... ..... .....
   |                     IP-ID                     |  2 octets if I=1
    ..... ..... ..... ..... ..... ..... ..... .....
   |                                               |
   /            Outer IP header fields             /  variable, if ip2=1
   |                                               |
    ..... ..... ..... ..... ..... ..... ..... .....
   |                                               |
   /          RTP header flags and fields          /  variable, if rtp=1
   |                                               |
    ..... ..... ..... ..... ..... ..... ..... .....

     S, R-TS, I, ip, rtp, ip2: Indicate presence of fields as shown to
     the right of each field above.

     Tsc: Tsc=0 indicates that TS is not scaled.
          Tsc=1 indicates that TS is scaled according to section 4.5.3,
          using value(TS STRIDE).
          Context(Tsc) is always 1. If scaling is not desired, the
          compressor will establish TS_STRIDE = 1

     SN: see beginning of section 5.7.



Bormann (ed.)                                                  [Page 72]

INTERNET-DRAFT          Robust Header Compression           Oct 23, 2000



     TS: Variable number of bits of TS, encoded according to
         section 4.5.6. See beginning of section 5.7.

     IP-ID: see beginning of section 5.7.


   Inner IP header flags

     These correspond to the inner IP header if there are two, and the
     single IP header otherwise.

      0     1     2     3     4     5     6     7
    ..... ..... ..... ..... ..... ..... ..... .....
   | TOS | TTL | DF  | PR  | IPX | NBO | RND | ip2 |  if ip=1
    ..... ..... ..... ..... ..... ..... ..... .....

     TOS, TTL, PR, IPX: Indicates presence of fields as shown to the
        right of the field in question below.

     DF: Don't Fragment bit of IP header.

     NBO: Indicates whether the octets of hdr(IP identifier) of this IP
     header are swapped before compression and after decompression.
     NBO=1 indicates that the octets need not be swapped. NBO=0
     indicates that the octets are to be swapped. See section 4.5.5.

     RND: Indicates whether hdr(IP identifier) is not to be compressed
     but instead sent as-is in compressed headers.

     IP2: Indicates presence of Outer IP header fields. Unless the
     static context contains two IP headers, IP2 is always zero.


   Inner IP header fields

    ..... ..... ..... ..... ..... ..... ..... .....
   |         Type of Service/ Traffic Class        |  if TOS=1
    ..... ..... ..... ..... ..... ..... ..... .....
   |         Time to live/ Hop Limit               |  if TTL=1
    ..... ..... ..... ..... ..... ..... ..... .....
   |         Protocol/ Next Header                 |  if PR=1
    ..... ..... ..... ..... ..... ..... ..... .....
   /         IP extension hdrs                     /  variable, if IPX=1
    ..... ..... ..... ..... ..... ..... ..... .....


     Type of Service/Traffic Class: That field in the IP header,
     absolute value.

     Time to live/ Hop Limit: That field in the IP header.



Bormann (ed.)                                                  [Page 73]

INTERNET-DRAFT          Robust Header Compression           Oct 23, 2000



     Protocol/ Next Header: That field in the IP header.

     IP extension hdr(s): According to section 5.8.5.


   Outer IP header flags

     The fields in this part of the Extension 3 header refers to the
     outermost IP header.

      0     1     2     3     4     5     6     7
    ..... ..... ..... ..... ..... ..... ..... .....
   | TOS2| TTL2| DF2 | PR2 |IPX2 |NBO2 |RND2 |  I2 |  if ip2=1
    ..... ..... ..... ..... ..... ..... ..... .....

     These flags are the same as the Inner IP header flags, but refer to
     the outer IP header instead of the inner IP header. The following
     flag, however, has no counterpart in the Inner IP header flags:

        I2: indicates presence of the IP-ID field.


   Outer IP header fields

    ..... ..... ..... ..... ..... ..... ..... .....
   |         Type of Service/ Traffic Class        |  if TOS2=1
    ..... ..... ..... ..... ..... ..... ..... .....
   |         Time to live/ Hop Limit               |  if TTL2=1
    ..... ..... ..... ..... ..... ..... ..... .....
   |         Protocol/ Next Header                 |  if PR2=1
    ..... ..... ..... ..... ..... ..... ..... .....
   /         IP extension hdr(s)                   / variable, if IPX2=1
    ..... ..... ..... ..... ..... ..... ..... .....
   |                     IP-ID                     |  2 octets if I2=1
    ..... ..... ..... ..... ..... ..... ..... .....

     The fields in this part of the Extension 3 are as for the Inner IP
     header fields, but refers to the outer IP header instead of the
     inner IP header. The following field, however, has no counterpart
     among the Inner IP header fields:

        IP-ID: the IP Identifier field of the outer IP header, unless
        the inner header is an IPv6 header, in which case I2 is always
        zero.









Bormann (ed.)                                                  [Page 74]

INTERNET-DRAFT          Robust Header Compression           Oct 23, 2000


   RTP header flags and fields

      0     1     2     3     4     5     6     7
    ..... ..... ..... ..... ..... ..... ..... .....
   |   Mode    |R-PT |  M  |  RX |CSRC | TSS | IPT |  if rtp=1
    ..... ..... ..... ..... ..... ..... ..... .....
   |  M  |             RTP PT                      |  if R-PT=1
    ..... ..... ..... ..... ..... ..... ..... .....
   /           Compressed CSRC-list                /  if CSRC=1
    ..... ..... ..... ..... ..... ..... ..... .....
   /                  TS STRIDE                    /  1-4 oct if TSS=1
    ..... ..... ..... ..... ..... ..... ..... ....
   /           TIME STRIDE (milliseconds)          /  1-4 oct if IPT=1
    ..... ..... ..... ..... ..... ..... ..... .....
   / R-P | R-X |          Reserved                 /  1 oct if RX=1
    ..... ..... ..... ..... ..... ..... ..... .....

     Mode: Compression mode. 0 = Reserved,
                             1 = Unidirectional,
                             2 = Bi-directional Optimistic,
                             3 = Bi-directional Reliable.

     RX, R-PT, CSRC, TSS, IPT: Indicate presence of fields as shown to
          the right of each field below.

     R-P: RTP Padding bit, absolute value (presumed zero if absent).

     R-X: RTP eXtension bit, absolute value (presumed zero if absent).

     M: see beginning of section 5.7.

     RTP PT: Absolute value of RTP Payload type field.

     Compressed CSRC-list: see section 5.8.1.

     TS STRIDE: Predicted increment/decrement of the RTP Timestamp
     field, when it changes. Encoded as in section 4.5.6.

     TIME STRIDE: Predicted time interval between changes in RTP
     Timestamp, in milliseconds. Also indication that compressor desires
     to do Timer-based compression of the RTP Timestamp field, see
     section 4.5.4. Encoded as in section 4.5.6.

     Reserved: reserved for future extension, must be sent as zero.


5.7.5.1.  RND flags and packet types

   The values of the RND flag or RND2 flag is changed by sending UOR-2
   packets with an Extension 3 where the flag(s) have the new value. In
   U mode, the UOR-2 with Extension 3 is sent several times in order to



Bormann (ed.)                                                  [Page 75]

INTERNET-DRAFT          Robust Header Compression           Oct 23, 2000


   ensure that the decompressor receives at least one. In O mode and R
   mode, the UOR-2 with Extension 3 is repeated until an  acknowledgment
   for a packet with the new RND flag value(s) is received.

   The decompressor updates the value of its RND and RND2 flags whenever
   it receives an UOR-2 with an Extension 3 carrying values for RND or
   RND2, and the UOR-2 CRC verifies successful decompression.

   When an IPv4 header is present in the static context, for which the
   corresponding RND flag has not been established to be 1, packet types
   R-1 and UO-1 MUST NOT be used.

   When no IPv4 header is present in the static context, or the RND
   flags for all IPv4 headers in the context have been established to be
   1, packet types R-1-ID, R-1-TS, UO-1-ID, and UO-1-TS MUST NOT be
   used.

   During the transient state when an RND flag is being established,
   packet types R-1-ID, R-1-TS, UO-1-ID, or UO-1-TS, MUST NOT be used.
   This implies that the RND flag(s) of the Extension 3 may have to be
   consulted before the exact format of a base header carrying an
   Extension 3 can be determined, i.e., whether a T-bit is present or
   not.


5.7.5.2.  Flags/Fields in context

   Some flags and fields in Extension 3 need to be maintained in the
   context of the decompressor. Their values are established using the
   mechanism appropriate to the compression mode, unless otherwise
   indicated in the table below and in referred sections.

   Flag/Field      Initial value   comment
   ---------------------------------------------------------------------
     Mode          Unidirectional  See section 5.x.x

     NBO               1
     RND               0

     NBO2              1
     RND2              0

     TS STRIDE         1
     TIME STRIDE       0
     Tsc               0           Tsc is always 0 in context.
                                   Can be 1 only when an Ext 3
                                   is present.







Bormann (ed.)                                                  [Page 76]

INTERNET-DRAFT          Robust Header Compression           Oct 23, 2000


5.7.6.  Feedback packets and formats

   When the roundtrip time between compressor and decompressor is large,
   several packets can be in flight. Therefore, several packets can be
   received by the decompressor after feedback has been sent and before
   the compressor has reacted to feedback. Moreover, decompression can
   fail due to residual errors in the compressed header.

   Therefore,

   a) in O-mode the decompressor SHOULD limit the rate at which feedback
      regarding successful decompression is sent (if sent at all).
   b) When decompression fails, feedback SHOULD be sent only when
      decompression of several consecutive packets have failed, and then
      the rate at which feedback is sent should be limited.
   c) When packets are received for a rejected packet stream, the rate
      at which feedback is sent SHOULD be limited.

   A compressor MAY limit the rate at which feedback is sent by only
   sending feedback for every k packets provoking the same (kind of)
   feedback. A suitable value for k is implementation dependent; k might
   be chosen such that feedback is sent 1-3 times per link roundtrip
   time.

   See section 5.2.2 for a discussion concerning ways to provide
   feedback information to the compressor.


5.7.6.1.  Feedback formats for ROHC RTP

   The following is the format for feedback information for ROHC RTP.
   See also 5.2.2.

   Several feedback formats carry a field labeled SN. The SN field
   contains LSBs of an RTP sequence number. The sequence number to use
   is the sequence number of the header which caused the feedback
   information to be sent. If that sequence number cannot be determined,
   for example when decompression fails, the sequence number to use is
   that of the last successfully decompressed header. If no sequence
   number is available, the SN field is set to zero upon transmission
   (note that the value zero has no special significance on reception).
   Upon reception, the compressor correlates the SN LSBs with the most
   recent header sent that would correlate to these SN LSBs.  The
   decompressor must ensure it sends enough SN LSBs in its feedback that
   this correlation does not become ambiguous; e.g., if an 8-bit SN LSB
   field could wrap around within a round-trip time, FEEDBACK-1 format
   cannot be used.


   FEEDBACK-1




Bormann (ed.)                                                  [Page 77]

INTERNET-DRAFT          Robust Header Compression           Oct 23, 2000


     0   1   2   3   4   5   6   7
   +---+---+---+---+---+---+---+---+
   |              SN               |
   +---+---+---+---+---+---+---+---+

     A FEEDBACK-1 is an ACK. In order to send a NACK or a STATIC-NACK,
     FEEDBACK-2 must be used. FEEDBACK-1 does not contain any mode
     information, FEEDBACK-2 must be used when mode information is
     required.


   FEEDBACK-2

     0   1   2   3   4   5   6   7
   +---+---+---+---+---+---+---+---+
   |Acktype| Mode  |      SN       |
   +---+---+---+---+---+---+---+---+
   |              SN               |
   +---+---+---+---+---+---+---+---+
   /       Feedback options        /
   +---+---+---+---+---+---+---+---+

     Acktype:  0 = ACK
               1 = NACK
               2 = STATIC-NACK
               3 is reserved (must not be used)

     Mode:     0 is reserved
               1 = Unidirectional mode
               2 = Bi-directional Optimistic mode
               3 = Bi-directional Reliable mode

     Feedback options: A variable number of feedback options, see
        section 5.7.6.2. Options may appear in any order.


5.7.6.2.  ROHC RTP Feedback options

   A ROHC RTP Feedback option has variable length and the following
   general format

     0   1   2   3   4   5   6   7
   +---+---+---+---+---+---+---+---+
   |   Opt Type    |   Opt Len     |
   +---+---+---+---+---+---+---+---+
   /          option data          /  Opt Len octets
   +---+---+---+---+---+---+---+---+

   Sections 5.7.6.3-8 describe the currently defined ROHC RTP feedback
   options.




Bormann (ed.)                                                  [Page 78]

INTERNET-DRAFT          Robust Header Compression           Oct 23, 2000




5.7.6.3.  The CRC option

   The CRC option contains an 8-bit CRC computed over the entire
   feedback payload, without the packet type and code octet, but
   including any CID fields, using the polynomial of section 5.9.1. If
   the CID is given with an Add-CID octet, the Add-CID octet immediately
   precedes the FEEDBACK-1 or FEEDBACK-2 format. For purposes of
   computing the CRC, the CRC fields of all CRC options are zero.

     0   1   2   3   4   5   6   7
   +---+---+---+---+---+---+---+---+
   |  Opt Type = 1 |  Opt Len = 1  |
   +---+---+---+---+---+---+---+---+
   |              CRC              |
   +---+---+---+---+---+---+---+---+

   When receiving feedback information with a CRC option, the compressor
   MUST verify the information by computing the CRC and comparing the
   result with the CRC carried in the CRC option. If the two are not
   identical, the feedback information MUST be ignored.


5.7.6.4.  The REJECT option

   The REJECT option informs the compressor that the decompressor does
   not have sufficient resources to handle the flow.

     0   1   2   3   4   5   6   7
   +---+---+---+---+---+---+---+---+
   |  Opt Type = 2 |  Opt Len = 0  |
   +---+---+---+---+---+---+---+---+

   When receiving a REJECT option, the compressor stops compressing the
   packet stream, and should refrain from attempting to increase the
   number of compressed packet streams for some time. Any FEEDBACK
   packet carrying a REJECT option MUST also carry a CRC option.


5.7.6.5.  The SN option

   The SN option provides 8 additional bits of SN.

     0   1   2   3   4   5   6   7
   +---+---+---+---+---+---+---+---+
   |  Opt Type = 3 |  Opt Len = 1  |
   +---+---+---+---+---+---+---+---+
   |              SN               |
   +---+---+---+---+---+---+---+---+




Bormann (ed.)                                                  [Page 79]

INTERNET-DRAFT          Robust Header Compression           Oct 23, 2000



5.7.6.6.  The CLOCK option

   The CLOCK option informs the compressor of the clock resolution of
   the decompressor. This is needed to allow the compressor to estimate
   the jitter introduced by the clock of the decompressor when doing
   Timer-based compression of the RTP timestamp.

     0   1   2   3   4   5   6   7
   +---+---+---+---+---+---+---+---+
   |  Opt Type = 4 |  Opt Len = 1  |
   +---+---+---+---+---+---+---+---+
   |     clock resolution (ms)     |
   +---+---+---+---+---+---+---+---+

   The smallest clock resolution which can be indicated is 1
   millisecond. The value zero has a special meaning: it indicates that
   the decompressor cannot do Timer-based compression of the RTP
   timestamp. Any FEEDBACK packet carrying a CLOCK option SHOULD also
   carry a CRC option.


5.7.6.7.  The JITTER option

   The JITTER option allows the decompressor to report the maximum
   jitter it has observed lately, using the following formula which is
   very similar to the formula for Max_Jitter BC in section 4.5.4.

   Let Observation window i contain the decompressor's best
   approximation of the TSW of the compressor (see section 4.5.4) when
   header i is received.

      Max_Jitter i_=

            max {|(T_i - T_j) - ((a_i - a_j) / TIME_STRIDE)|,
                 for all headers j in Observation window i}

      Max Jitter =

            max { Max Jitter i, for a large number of recent headers i }

   This information may be used by the compressor to refine the formula
   for determining k when doing Timer-based compression of the RTP
   Timestamp.

     0   1   2   3   4   5   6   7
   +---+---+---+---+---+---+---+---+
   |  Opt Type = 5 |  Opt Len = 1  |
   +---+---+---+---+---+---+---+---+
   |          Max Jitter           |
   +---+---+---+---+---+---+---+---+



Bormann (ed.)                                                  [Page 80]

INTERNET-DRAFT          Robust Header Compression           Oct 23, 2000



   The decompressor MAY ignore the oldest observed values of Max Jitter
   i. Thus, the reported Max Jitter may decrease. Robustness will be
   reduced if the compressor uses a jitter estimate which is too small.
   Therefore, a FEEDBACK packet carrying a JITTER option SHOULD also
   carry a CRC option. Moreover, the compressor MAY ignore decreasing
   Max Jitter values.


5.7.6.8.  The LOSS option

   The LOSS option allows the decompressor to report the largest
   observed number of packets lost in sequence. This information MAY be
   used by the compressor to adjust the size of the reference window
   used in U and O mode.

     0   1   2   3   4   5   6   7
   +---+---+---+---+---+---+---+---+
   |  Opt Type = 6 |  Opt Len = 1  |
   +---+---+---+---+---+---+---+---+
   | longest loss event (packets)  |
   +---+---+---+---+---+---+---+---+

   The decompressor MAY choose to ignore the oldest loss events. Thus,
   the value reported may decrease. Since setting the reference window
   too small can reduce robustness, a FEEDBACK packet carrying a LOSS
   option SHOULD also carry a CRC option. The compressor MAY choose to
   ignore decreasing loss values.


5.7.6.9.  Unknown option types

   If an option type unknown to the compressor is encountered,
   it must continue parsing the rest of the FEEDBACK packet, which is
   possible since the length of the option is explicit, but MUST
   otherwise ignore the unknown option.


5.7.6.10.  RTP feedback example

   Feedback for CID 8 indicating an ACK for SN 17 and Bi-directional
   Reliable mode can have the following format.

   Assuming small CIDs:

     0   1   2   3   4   5   6   7
   +---+---+---+---+---+---+---+---+
   | 1   1   1   0 | 1   0   0   0 |  Add-CID octet with CID=8
   +---+---+---+---+---+---+---+---+
   | 1   1   1   1   1   0 |   2   |  feedback packet type, Code=2
   +---+---+---+---+---+---+---+---+



Bormann (ed.)                                                  [Page 81]

INTERNET-DRAFT          Robust Header Compression           Oct 23, 2000


   | 0   1 | 1   1 |  SN MSB = 0   |  AckType = ACK, Mode = Reliable
   +---+---+---+---+---+---+---+---+
   |          SN LSB=17            |
   +---+---+---+---+---+---+---+---+

         The first, third, and fourth octet would be delivered.

   The FEEDBACK-1 format may also be used. Assuming large CIDs:

     0   1   2   3   4   5   6   7
   +---+---+---+---+---+---+---+---+
   | 1   1   1   1   1   0 |   2   |  feedback packet type, Code=2
   +---+---+---+---+---+---+---+---+
   | 0   0   0   0   1   0   0   0 |  large CID with value 8
   +---+---+---+---+---+---+---+---+
   |             SN=17             |
   +---+---+---+---+---+---+---+---+

         The second and third octet would be delivered.

   Assuming small CIDs:

     0   1   2   3   4   5   6   7
   +---+---+---+---+---+---+---+---+
   | 1   1   1   0 | 1   0   0   0 |  Add-CID octet with CID=8
   +---+---+---+---+---+---+---+---+
   | 1   1   1   1   1   0 |   1   |  feedback packet type, Code=1
   +---+---+---+---+---+---+---+---+
   |             SN=17             |
   +---+---+---+---+---+---+---+---+

        The first and third octet would be delivered.


5.7.7.  RTP IR and IR-DYN packets

   The subheaders which are compressible are split into a STATIC part
   and a DYNAMIC part. These parts are defined in sections 5.7.7.3 to
   5.7.7.7.

   The structure of a chain of subheaders is determined by each header
   having a Next Header, or Protocol, field. This field identifies the
   type of the following header. Each Static part below that is followed
   by another Static part contains that field and allows parsing of the
   Static chain; the Dynamic chain, if present, is structure
   analogously.








Bormann (ed.)                                                  [Page 82]

INTERNET-DRAFT          Robust Header Compression           Oct 23, 2000


5.7.7.1.  Basic structure of the IR packet

   This packet type communicates the static part of the context, i.e.,
   the value of the constant SN-functions. It can optionally also
   communicate the dynamic part of the context, i.e., the parameters of
   non-constant SN-functions. It can also optionally communicate the
   payload of an original packet, if any.

     0   1   2   3   4   5   6   7
    --- --- --- --- --- --- --- ---
   |         Add-CID octet         |  if for CID!=0 for small CIDs
   +---+---+---+---+---+---+---+---+
   | 1   1   1   1   1   1   0 | D |
   +---+---+---+---+---+---+---+---+
   |                               |
   /    0-2 octets of CID info     /  1-2 octets if for large CIDs
   |                               |
   +---+---+---+---+---+---+---+---+
   |            Profile            |  1 octet
   +---+---+---+---+---+---+---+---+
   |              CRC              |  1 octet
   +---+---+---+---+---+---+---+---+
   |                               |
   |         Static chain          |  variable length
   |                               |
   +---+---+---+---+---+---+---+---+
   |                               |
   |         Dynamic chain         |  present if D=1, variable length
   |                               |
    - - - - - - - - - - - - - - - -
   |                               |
   |           Payload             |  variable length
   |                               |
    - - - - - - - - - - - - - - - -

     D:   D=1 indicates that the dynamic chain is present.

     Profile:  Indicates transport/application of this stream.

          CRC: 8-bit CRC, computed according to section 5.9.1.

     Static chain: A chain of static subheader information.

     Dynamic chain: A chain of dynamic subheader information. What
     dynamic information is present is inferred from the Static chain.

     Payload: payload of corresponding original packet, if any. Presence
     inferred from packet size.






Bormann (ed.)                                                  [Page 83]

INTERNET-DRAFT          Robust Header Compression           Oct 23, 2000


5.7.7.2.  Basic structure of the IR-DYN packet

   This packet type communicates the dynamic part of the context, i.e.,
   the parameters of non-constant SN-functions.

     0   1   2   3   4   5   6   7
    --- --- --- --- --- --- --- ---
   |         Add-CID octet         |  if for CID!=0 for small CIDs
   +---+---+---+---+---+---+---+---+
   | 1   1   1   1   1   1   1   0 |
   +---+---+---+---+---+---+---+---+
   |                               |
   /     0-2 octets of CID info    /  1-2 octets if for large CIDs
   |                               |
   +---+---+---+---+---+---+---+---+
   |            Profile            |  1 octet
   +---+---+---+---+---+---+---+---+
   |              CRC              |  1 octet
   +---+---+---+---+---+---+---+---+
   |                               |
   /         Dynamic chain         /  variable length
   |                               |
   +---+---+---+---+---+---+---+---+
   |                               |
   /           Payload             /  variable length
   |                               |
    - - - - - - - - - - - - - - - -

     Profile:  Indicates transport/application of this stream.

     CRC: 8-bit checksum covering original header, computed according to
     section 5.9.1.

     Dynamic chain: A chain of dynamic subheader information. What
     dynamic information is present is inferred from the Static chain of
     the context.

     Payload: payload of corresponding original packet, if any.
              (Presence of payload is inferred from length of packet.)


   NOTE: The static and dynamic chains of IR or IR-DYN packets for
   profile 0 MUST end with static and dynamic parts for an RTP header.
   If not, the packet MUST be discarded and the context must not be
   updated.

   NOTE: The static or dynamic chains of IR or IR-DYN packets for
   profile 1 MUST end with static and dynamic parts for a UDP header.
   If not, the packet MUST be discarded and the packet must not be
   updated.




Bormann (ed.)                                                  [Page 84]

INTERNET-DRAFT          Robust Header Compression           Oct 23, 2000




5.7.7.3.  Initialization of IPv6 Header [IPv6]

      Static part:

        +---+---+---+---+---+---+---+---+
        |  Version = 6  |Flow Label(msb)|   1 octet
        +---+---+---+---+---+---+---+---+
        /        Flow Label (lsb)       /   2 octets
        +---+---+---+---+---+---+---+---+
        |          Next Header          |   1 octet
        +---+---+---+---+---+---+---+---+
        /        Source Address         /   16 octets
        +---+---+---+---+---+---+---+---+
        /      Destination Address      /   16 octets
        +---+---+---+---+---+---+---+---+

      Dynamic part:

        +---+---+---+---+---+---+---+---+
        |         Traffic Class         |   1 octet
        +---+---+---+---+---+---+---+---+
        |           Hop Limit           |   1 octet
        +---+---+---+---+---+---+---+---+
        / Generic extension header list /  variable length
        +---+---+---+---+---+---+---+---+


      Eliminated:

         Payload Length

      Extras

         Generic extension header list
              Encoded according to section 5.8.6.1, with all header
              items present in uncompressed form.

   CRC-DYNAMIC: Payload Length field (octets 5-6).

   CRC-STATIC: All other fields (octets 1-4, 7-40).

   CRC coverage for extension headers is defined in section 5.8.7.










Bormann (ed.)                                                  [Page 85]

INTERNET-DRAFT          Robust Header Compression           Oct 23, 2000


5.7.7.4. Initialization of IPv4 Header [IPv4, section 3.1].

      Static part:

           Version, Protocol, Source Address, Destination Address.

        +---+---+---+---+---+---+---+---+
        |  Version = 4  |       0       |
        +---+---+---+---+---+---+---+---+
        |           Protocol            |
        +---+---+---+---+---+---+---+---+
        /        Source Address         /   4 octets
        +---+---+---+---+---+---+---+---+
        /      Destination Address      /   4 octets
        +---+---+---+---+---+---+---+---+

      Dynamic part:

           Type of Service, Time to Live, Identification, DF, RND, NBO,
           extension header list.

         +---+---+---+---+---+---+---+---+
         |        Type of Service        |
         +---+---+---+---+---+---+---+---+
         |         Time to Live          |
         +---+---+---+---+---+---+---+---+
         /        Identification         /   2 octets
         +---+---+---+---+---+---+---+---+
         |DF |RND|NBO|         0         |
         +---+---+---+---+---+---+---+---+
         / Generic extension header list /  variable length
         +---+---+---+---+---+---+---+---+


      Eliminated:

         IHL               (must be 5)
         Total Length      (inferred in decompressed packets)
         MF flag           (More Fragments flag, must be 0)
         Fragment Offset   (must be 0)
         Header Checksum   (inferred in decompressed packets)
         Options, Padding  (must not be present)

     Extras:

        RND, NBO           See section 5.7.

        Generic extension header list
                           Encoded according to section 5.8.6.1, with
                           all header items present in uncompressed
                           form.



Bormann (ed.)                                                  [Page 86]

INTERNET-DRAFT          Robust Header Compression           Oct 23, 2000




     CRC-DYNAMIC: Total Length, Identification, Header Checksum
                    (octets 3-4, 5-6, 11-12).

     CRC-STATIC: All other fields (octets 1-2, 7-10, 13-20)

     CRC coverage for extension headers covered in section 5.8.7.


5.7.7.5. Initialization of UDP Header [RFC-768].

    Static part:

        +---+---+---+---+---+---+---+---+
        /          Source Port          /   2 octets
        +---+---+---+---+---+---+---+---+
        /       Destination Port        /   2 octets
        +---+---+---+---+---+---+---+---+

    Dynamic part:

        +---+---+---+---+---+---+---+---+
        /           Checksum            /   2 octets
        +---+---+---+---+---+---+---+---+

    Eliminated:

         Length

   The Length field of the UDP header MUST match the Length field(s) of
   preceding subheaders, i.e., there must not be any padding after the
   UDP payload that is covered by the IP Length.


   CRC-DYNAMIC: Length field, Checksum (octets 5-8).

   CRC-STATIC: All other fields (octets 1-4).


5.7.7.6. Initialization of RTP Header [RTP].

      Static part:

         SSRC.

           0   1   2   3   4   5   6   7
         +---+---+---+---+---+---+---+---+
         /             SSRC              /   4 octets
         +---+---+---+---+---+---+---+---+




Bormann (ed.)                                                  [Page 87]

INTERNET-DRAFT          Robust Header Compression           Oct 23, 2000




      Dynamic part:

           P, X, CC, PT, M, sequence number, timestamp, timestamp
           stride, CSRC identifiers.

           0   1   2   3   4   5   6   7
         +---+---+---+---+---+---+---+---+
         |  V=2  | P | RX|      CC       |  (RX is NOT the RTP X bit)
         +---+---+---+---+---+---+---+---+
         | M |            PT             |
         +---+---+---+---+---+---+---+---+
         /      RTP sequence number      /  2 octets
         +---+---+---+---+---+---+---+---+
         /   RTP timestamp (absolute)    /  4 octets
         +---+---+---+---+---+---+---+---+
         /      Generic CSRC list        /  variable length
         +---+---+---+---+---+---+---+---+
         | Reserved  | X |  Mode |IPT|TSS| if RX=1
         +---+---+---+---+---+---+---+---+
         /         TS_Stride             / 1-4 octets, if TSS=1
         +---+---+---+---+---+---+---+---+
         /         Time_Stride           / 1-4 octets, if IPT=1
         +---+---+---+---+---+---+---+---+


      Eliminated:

         Nothing.

      Extras:

         RX:controls presence of extension

         Mode: Compression mode. 0 = Reserved,
                             1 = Unidirectional,
                             2 = Bi-directional Optimistic,
                             3 = Bi-directional Reliable.

         X: copy of X bit from RTP header (presumed 0 if RX=0)

         Reserved: reserved for future extension, must be zero

        Generic CSRC list   CSRC list encoded according to section
                            5.8.6.1, with all CSRC items present.

      CRC-DYNAMIC: Octet containing M-bit, sequence number field,
                   timestamp (octets 2-8).

      CRC-STATIC: All other fields (octets 1, 9-12, original CSRC list).



Bormann (ed.)                                                  [Page 88]

INTERNET-DRAFT          Robust Header Compression           Oct 23, 2000




5.7.7.7  Initialization of ESP header [ESP, section 2]

   This is for the case when the NULL encryption algorithm [NULL] is NOT
   being used with ESP, so that subheaders after the ESP header are
   encrypted (see 5.12). See 5.8.4.3 for compression of the ESP header
   when NULL encryption is being used.

   Static Part:


        +---+---+---+---+---+---+---+---+
        /              SPI              /   4 octets
        +---+---+---+---+---+---+---+---+


   Dynamic Part:

        +---+---+---+---+---+---+---+---+
        /       Sequence Number         /   4 octets
        +---+---+---+---+---+---+---+---+

   Eliminated:

      Other fields are encrypted, and can neither be located nor
      compressed.

   CRC-Static: SPI (octets 1-4)

   CRC-Dynamic: Sequence number (octets 5-8)


5.8.  List compression

   Header information from the packet stream to be compressed can be
   structured as an ordered list, which is largely constant between
   packets. The generic structure of such a list is as follows.

            +--------+--------+--...--+--------+
      list: | item 1 | item 2 |       | item n |
            +--------+--------+--...--+--------+

   This section describes the compression scheme for such information.
   The basic idea of list-based compression is that

   1) while the list is constant, no information regarding the list is
      sent in compressed headers.






Bormann (ed.)                                                  [Page 89]

INTERNET-DRAFT          Robust Header Compression           Oct 23, 2000


   2) Small changes in the list are represented as additions (Insertion
      scheme) or deletions (Removal scheme), or both (Remove Then Insert
      scheme).

   3) The list can also be sent in its entirety (Generic scheme).

   There are two kinds of lists: CSRC lists in RTP packets, and
   extension header chains in IP packets (both IPv4 and IPv6).

   IPv6 base headers and IPv4 headers can not be part of an extension
   header chain. Headers which can be part of extension header chains
   include
   a) the AH header,
   b) the null ESP header,
   c) the minimal encapsulation header [RFC2004, section 3.1],
   d) the GRE header [RFC1701],
   e) IPv6 extension headers.

   The table-based item compression scheme (5.8.1), which reduces the
   size of each item, is described first. Then it is defined which
   reference list to use in the insertion and removal schemes (5.8.2).
   List encoding schemes are described in section 5.8.3., and a few
   special handling cases in 5.8.5. Finally, exact formats are described
   in 5.8.5 through 5.8.6.


5.8.1 Table-based item compression

   The Table-based item compression scheme is a way to compress
   individual items sent in compressed lists. The compressor assigns
   each item in a list a unique identifier Index. The compressor
   conceptually maintains a table with all items, indexed by Index. The
   (Index, item) pair are sent together in compressed lists until the
   compressor gains enough confidence that the decompressor has observed
   the mapping between the item and its Index. Such confidence is
   obtained by receiving an acknowledgment from the decompressor in R-
   mode, and in UO-modes by sending L (Index, item) pairs (not
   necessarily consecutively). Thereafter, the Index alone is sent in
   compressed lists to indicate the corresponding item. The compressor
   may reassign an existing Index to a new item, and then needs to
   reestablish the mapping in the same manner as above.

   The decompressor conceptually maintains a table that contains all
   item and Index pairs it knows about. The table is updated whenever an
   (Index, item) pair is received (and decompression is verified by a
   CRC). The decompressor retrieves the item from the table whenever an
   Index without an accompanying item is received.







Bormann (ed.)                                                  [Page 90]

INTERNET-DRAFT          Robust Header Compression           Oct 23, 2000


5.8.1.1 Translation Table in R-mode

   At the compressor side, an entry in the Translation Table
   conceptually has the following structure.

              +-------+------+---------------+
      index i | Known | item | SN1, SN2, ... |
              +-------+------+---------------+

   The Known flag indicates whether the mapping between Index i and item
   has been established, i.e., if index i alone can be sent in
   compressed lists. Known is initially zero. It is also set to zero
   whenever Index i is assigned to a new item. Known is set to one when
   the corresponding item and Index pair is acknowledged.
   Acknowledgments are based on the RTP sequence number, so a list of
   RTP sequence numbers of each packet which contain the item and Index
   pair is included in the translation table. When a packet with a
   sequence number in the sequence number list is acknowledged, the
   Known flag is set, and the sequence number list can be discarded.

   Each entry in the Translation Table at the decompressor side
   conceptually has the following structure.

              +-------+------+
      index i | Known | item |
              +-------+------+

   All Known fields are initiated to zero. Whenever the decompressor
   receives an (Index, item) pair, it inserts item into the table at
   position Index and sets the Known flag in that entry to one. If an
   index without an accompanying item is received for which the Known
   flag is zero, the header MUST be discarded and a NACK SHOULD be sent.


5.8.1.2 Translation Table in U/O-modes

   At the compressor side, each entry in the Translation Table
   conceptually has the following structure.

            +-------+------+---------+
      Index | Known | item | Counter |
            +-------+------+---------+

   The Index, Known, and item fields have the same meaning as in section
   5.8.2.2.

   Known is set when the (Index, item) pair has been sent in L
   compressed lists (not necessarily consecutively). The Counter field
   keeps track of how many times the pair has been sent. Counter is set
   to 0 for each new entry added to the table, and whenever Index is
   assigned to a new item. Counter is incremented by 1 whenever an



Bormann (ed.)                                                  [Page 91]

INTERNET-DRAFT          Robust Header Compression           Oct 23, 2000


   (Index, item) pair is sent. When the counter reaches L, the Known
   field is set and thereafter only the Index needs to be sent in
   compressed lists.

   At the decompressor side, the Translation Table is the same as the
   Translation Table defined in R-mode.


5.8.2 Reference list determination

   In reference based compression schemes (i.e., addition or deletion
   based schemes), compression and decompression of a list (curr_list)
   is based on a reference list (ref_list) which is assumed to be
   present in the context of both compressor and decompressor. The
   compressed list is an encoding of the differences between curr_list
   and ref_list. Upon reception of a compressed list, the decompressor
   applies the differences to its reference list to obtain the original
   list.

   To identify the reference list (to be) used, each compressed list
   carries an identifier (ref_id). The reference list is established
   with different methods in R-mode and UO-modes.


5.8.2.1 Reference list in R-mode and UO-modes

   In R-mode, the reference list is chosen based on acknowledgments,
   i.e., the compressor uses as ref_list the latest list which has been
   acknowledged by the decompressor. The ref_list is updated only upon
   receiving an acknowledgment. The least significant bits of the RTP
   sequence number of the acknowledged packet is used as the ref_id.

   In UO-modes, a sequence of identical lists are considered as
   belonging to the same generation and are all assigned the same
   generation identifier (gen_id). Gen_id increases by 1 each time the
   list changes and is carried in compressed and uncompressed lists that
   are candidates for being used as reference lists. Normally, Gen_id
   must have been repeated in at least L headers before the list can be
   used as a ref_list. However, some acknowledgments may be sent in O-
   mode (and also in U-mode), and whenever an acknowledgment for a
   header is received, the list of that header is considered known and
   need not be repeated further. The least significant bits of the
   Gen_id is used as the ref_id in UO-modes.

   The logic of the compressor and the decompressor for reference based
   list compression is similar to that for SN and TS. The principal
   difference is that the decompressor maintains a sliding window with
   candidates for ref_list, and retrieves ref_list from the sliding
   window based on the ref_id of the compressed list.

   Logic of compressor:



Bormann (ed.)                                                  [Page 92]

INTERNET-DRAFT          Robust Header Compression           Oct 23, 2000



   a)In the IR state, the compressor sends Generic lists (see 5.8.5)
     containing all items of the current list to establish or refresh
     the context of the decompressor.

     In R-mode, such Generic lists are sent until a header is
     acknowledged. The list of that header can be used as a reference
     list to compress subsequent lists.

     In UO-mode, the compressor sends generation identifiers with the
     Generic lists until
     1) a generation id has been repeated L times, or
     2) an acknowledgment for a header carrying a generation id has
        been received.
     The repeated (1) or acknowledged (2) list can be used as a
     reference list to compress subsequent lists and is kept together
     with its generation id.

   b)When not in IR-state, the compressor moves to FO-state when it
     observes a difference between curr_list and the previous list. It
     sends compressed lists based on ref_list to update the context of
     the decompressor. (However, see d)

     In R-mode, the compressor keeps sending compressed lists using the
     same reference until it receives an acknowledgment for a packet
     containing the newest list. The compressor may then move to SO
     state with regards to the list.

     In UO-modes, the compressor keeps sending compressed lists with
     generation identifiers until
     1) a generation id has been repeated L times, or
     2) an acknowledgment for a header carrying the latest generation
        id has been received.
     The repeated or acknowledged list is used as the future reference
     list. The compressor may move to SO state with regards to the
     list.

   c)In R-mode, the compressor maintains a sliding window containing
     the lists which have been sent to update the context of the
     decompressor and have not yet been acknowledged. The sliding
     window shrinks when an acknowledgment arrives: all list sent
     before the acknowledged list are removed. The compressor may use
     the Index to represent items of lists in the sliding window.

     In UO-modes, the compressor needs to store
        1) the reference list and its generation id, and
        2) if the current generation id is different from the reference
           generation: the current list and the sequence numbers with
           which the current list has been sent.
     (2) is needed to determine if an acknowledgment is for the latest
     generation. It is not needed in U-mode.



Bormann (ed.)                                                  [Page 93]

INTERNET-DRAFT          Robust Header Compression           Oct 23, 2000



   d)In UO-modes, the compressor may choose to not send a generation
     identifier with a compressed list. Such lists without generation
     identifiers are not assigned a new generation identifier and must
     not be used as future reference lists. They do not update the
     context. This feature is useful when a new list is repeated few
     times and the list then reverts back to its old value.

   Logic of decompressor:

   e)In R-mode, the decompressor acknowledges all received uncompressed
     or compressed lists which establish or update the context. (Such
     compressed headers contain a CRC.)

     In O-mode, the decompressor MAY acknowledge a list with a new
     generation identifier, see section 5.4.2.2.

     In U-mode, the decompressor MAY acknowledge a list sent in an IR
     packet, see section 5.3.2.3.

   f)The decompressor maintains a sliding window which contains the
     lists that may be used as reference lists.

     In R-mode, the sliding window contains lists which have been
     acknowledged but not yet used as reference lists.

     In UO-mode, the sliding window contains at most one list per
     generation. It contains all generations seen by the decompressor
     newer than the last generation used as a reference.

   g)When the decompressor receives a compressed list, it retrieves the
     proper ref_list from the sliding window based on the ref_id, and
     decompresses the compressed list obtaining curr_list.

     In R-mode, curr_list is inserted into the sliding window if an
     acknowledgment is sent for it. The sliding window is shrunk by
     removing all lists received before ref_list.

     In UO-mode, curr_list is inserted into the sliding window together
     with its generation identifier if the compressed list had a
     generation identifier and the sliding window does not contain a
     list with that generation identifer. All lists with generations
     older than ref_id are removed from the sliding window.


5.8.3 Encoding Schemes for the compressed list

   Four encoding schemes for the compressed list are described here. The
   exact format of the compressed CSRC list and compressed IP extension
   header list using these encoding schemes are described in sections
   5.8.5 and 5.8.6.



Bormann (ed.)                                                  [Page 94]

INTERNET-DRAFT          Robust Header Compression           Oct 23, 2000



   Generic scheme

     In contrast to subsequent schemes, this scheme does not rely on a
     reference list having been established. The entire list is sent,
     using table based compression for each individual item. The
     generic scheme is always used when establishing the context of the
     decompressor and may also be used at other times, as the
     compressor sees fit.

   Insertion Only scheme

     When the new list can be constructed from ref_list by adding
     items, a list of the added items is sent (using table based
     compression), along with the positions in ref_list where the new
     items will be inserted. An insertion bit mask indicates the
     insertion positions in ref_list.

     Upon reception of a list compressed according to the Insertion
     Only scheme, curr_list is obtained by scanning the insertion bit
     mask from left to right. When a '0' is observed, an item is copied
     from the ref_list. When a '1' is observed, an item is copied from
     the list of added items. If a '1' is observed when the list of
     added items has been exhausted, an error has occurred and
     decompression fails. The header must not be delivered to upper
     layers, should be discarded, and must neither be acknowledged nor
     used as a reference.

     To construct the insertion bit mask and the list of added items,
     the compressor MAY use the algorithm described with the following
     steps.

     1) An empty bit list and an empty Inserted Item list are generated
        as the starting point.

     2) Start by considering the first item of curr_list and ref_list.

     3) If curr_list has a different item than ref_list,

            a set bit (1) is appended to the bit list;
            the first item in curr_list (represented using table-based
               item compression) is appended to the Inserted Item list;
            advance to the next item of the curr_list;

        otherwise,

            a zero bit (0) is appended to the bit list;
            advance to the next item of the curr_list;
            advance to the next item of the ref_list.

     4) Repeat 3) until curr_list has been exhausted.



Bormann (ed.)                                                  [Page 95]

INTERNET-DRAFT          Robust Header Compression           Oct 23, 2000



     5) If the length of the bit list is less than the required bit mask
        length, append additional zeroes.

   Removal Only scheme

     This scheme can be used when curr_list can be obtained by removing
     some items in ref_list. The positions of the items which are in
     ref_list, but not in curr_list, are sent as a removal bit mask.

     Upon reception of the compressed list, the decompressor obtains
     curr_list by scanning the removal bit mask from left to right.
     When a '0' is observed, the next item of ref_list is copied into
     curr_list. When a '1' is observed, the next item of ref_list is
     skipped over without being copied. If a '0' is observed when
     ref_list has been exhausted, an error has occurred and
     decompression fails. The header must not be delivered to upper
     layers, should be discarded, and must neither be acknowledged nor
     used as a reference.

     To construct the removal bit mask and the list of added items, the
     compressor MAY use the algorithm described with the following
     steps.

     1) An empty bit list is generated as the starting point.

     2) Start by considering the first item of curr_list and ref_list.

     3) If curr_list has a different item than ref_list,

            a set bit (1) is appended to the bit list;
            advance to the next item of the ref_list;

        otherwise,

            a zero bit (0) is appended to the bit list;
            advance to the next item of the curr_list;
            advance to the next item of the ref_list.

     4) Repeat 3) until curr_list has been exhausted.

     5) If the length of the bit list is less than the required bit mask
        length, append additional ones.

   Remove Then Insert scheme

     In this scheme, curr_list is obtained by first removing items from
     ref_list, and then inserting items into the resulting list. A
     removal bit mask, an insertion bit mask, and a list of added items
     is sent.




Bormann (ed.)                                                  [Page 96]

INTERNET-DRAFT          Robust Header Compression           Oct 23, 2000


     Upon reception of the compressed list, the decompressor processes
     the removal bit mask as in the Removal Only scheme. The resulting
     list is then used as the reference list when the insertion bit
     mask and the list of added items is processed as in the Insertion
     Only scheme.


5.8.4.  Special Handling for IP Extension Headers

   In CSRC list compression, each CSRC is assigned an index. In
   contrast, in IP extension header list compression an index is usually
   associated with a type of extension header. When there is more than
   one IP header, there is more than one list of extension headers. An
   index per type per list is then used.

   The association to a type means that a new index need not always be
   used each time a field in an IP extension header changes. However,
   when a field in an extension header changes, the mapping between the
   index and the new value of the extension header needs to be
   established, except in the special handling cases defined in the
   following subsections.

5.8.4.1.  Next Header Field

   The next header field in an IP header or extension header changes
   whenever the type of the immediately following header changes, e.g.,
   when a new extension header is inserted after it, when the immediate
   subsequent extension header is removed from the list, or when the
   order of several extension headers is changed. Thus it may not be
   uncommon that for a given header, the next header field changes while
   the remaining fields do not change.

   Therefore, in the case that only the next header field changes, the
   extension header is considered to be unchanged and rules for special
   treatment of the change in the next header field is defined as
   follows.

   a) In the case that a subsequent extension header is removed from
     the list, the new value of the next header field is obtained from
     the reference extension header list. For example, assume that the
     reference header list (ref_list) consists of headers A, B and C
     (ref_ext_hdr A, B, C), and the current extension header list
     (curr_list) only consists of extension headers A and C
     (curr_ext_hdr A, C). The order and value of the next header field
     of these extension headers are as follows.

        ref_list:
        +--------+-----+    +--------+-----+    +--------+-----+
        | type B |     |    | type C |     |    | type D |     |
        +--------+     |    +--------+     |    +--------+     |
        |              |    |              |    |              |



Bormann (ed.)                                                  [Page 97]

INTERNET-DRAFT          Robust Header Compression           Oct 23, 2000


        +--------------+    +--------------+    +--------------+
         ref_ext_hdr A        ref_ext_hdr B       ref_ext_hdr C

        curr_list:
        +--------+-----+    +--------+-----+
        | type C |     |    | type D |     |
        +--------+     |    +--------+     |
        |              |    |              |
        +--------------+    +--------------+
         curr_ext_hdr A      curr_ext_hdr C

     Comparing the curr_ext_hdr A in curr_list and the ref_ext_hdr A
     in ref_list, the value of next header field is changed from
     "type B" to "type C" because of removal of extension header B.
     The new value of the next header field in curr_ext_hdr A, i.e.,
     "type C" does not need to be sent to the decompressor. Instead, it
     is retrieved from the next header field of the removed ref_ext_hdr
     B.

   b) In the case that a new extension header is inserted after an
     existing extension header, the next header field in the
     communicated item will carry the type of itself, rather than the
     type of the header that follows. For example, assume that the
     reference header list (ref_list) consists of headers A and C
     (ref_ext_hdr A, C), and the current header list (curr_list)
     consists of headers A, B and C (curr_ext_hdr A, B, C). The order
     and the value of the next header field of these extension headers
     are as follows.

        ref_list:
        +--------+-----+    +--------+-----+
        | type C |     |    | type D |     |
        +--------+     |    +--------+     |
        |              |    |              |
        +--------------+    +--------------+
         ref_ext_hdr A        ref_ext_hdr C

        curr_list:
        +--------+-----+    +--------+-----+    +--------+-----+
        | type B |     |    | type C |     |    | type D |     |
        +--------+     |    +--------+     |    +--------+     |
        |              |    |              |    |              |
        +--------------+    +--------------+    +--------------+
         curr_ext_hdr A      curr_ext_hdr B      curr_ext_hdr C

     Comparing the curr_list and the ref_list, the value of the next
     header field in extension header A is changed from "type C" to
     "type B".

     The uncompressed curr_ext_hdr B is carried in the compressed
     header list. However, it carries "type B" instead of "type C" in



Bormann (ed.)                                                  [Page 98]

INTERNET-DRAFT          Robust Header Compression           Oct 23, 2000


     its next header field. When the decompressor inserts a new header
     after curr_ext_hdr A, the next header field of A is taken from the
     new header, and the next header field of the new header is taken
     from ref_ext_hdr A.


5.8.4.2.  Authentication Header (AH)

   The sequence number field in the AH contains a monotonically
   increasing counter value for a security association. Therefore,
   when comparing curr_list with ref_list, if the sequence number in AH
   changes and SPI field doesn't change, the AH is not considered as
   changed.

   If the sequence number in the AH linearly increases as RTP sequence
   number increases and the compressor is confident that the
   decompressor has obtained the pattern, the sequence number in AH need
   not be sent. The decompressor applies linear extrapolation to
   reconstruct the sequence number in the AH.

   Otherwise, a compressed sequence number is included in the IPX
   compression field in an extension 3 of an UOR-2 header.

   The authentication data field in AH changes from packet to packet
   and is sent as-is. If the uncompressed AH is sent, the authentication
   data field is sent inside the uncompressed AH; otherwise, it is sent
   after the compressed IP/UDP/RTP and IPv6 extension headers and before
   the payload. See beginning of section 5.7.


5.8.4.3.  Encapsulating Security Payload Header

   When the Encapsulating Security Payload Header (ESP) [ESP] is present
   and an encryption algorithm other than NULL is being used, the UDP
   and RTP headers are both encrypted and cannot be compressed. The ESP
   header thus ends the compressible header chain. The ROHC ESP profile
   defined in section 5.12 MAY be used for the stream in this case.

   A special case is when the NULL encryption algorithm is used. This is
   the case when the ESP header is used for authentication only, and not
   for encryption. The payload is not encrypted by the NULL encryption
   algorithm, so compression of the rest of the header chain is
   possible. The rest of this section describes compression of the ESP
   header when the NULL encryption algorithm is used with ESP.

   It is not possible to determine whether NULL encryption is used by
   inspecting a header of the stream, this information is present only
   at encryption endpoints. However, a compressor may attempt
   compression under the assumption that the NULL encryption algorithm
   is being used, and later abort compression when the assumption proves
   to be false.



Bormann (ed.)                                                  [Page 99]

INTERNET-DRAFT          Robust Header Compression           Oct 23, 2000



   The compressor may, for example, inspect the Next Header fiels and
   the header fields supposed to be static in subsequent headers in
   order to determine if NULL encryption is being used. If these change
   unpredictably, an encryption algorithm other than NULL is probably
   being used and compression of subsequent headers SHOULD be aborted.
   Compression of the stream is then either discontinued, or a profile
   that compresses only up to the ESP header may be used (see 5.12).
   While attempting to compress the header, the compressor should use
   the SPI of the ESP header together with the destination IP address as
   the defining fields for determining which packets belong to the
   stream.

   In the ESP header [ESP, section 2], the fields that can be compressed
   are the SPI, the sequence number, the Next Header, and possibly the
   padding bytes if they are in the standard format defined in [ESP].

   ESP header [ESP, section 2]:

    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |              Security Parameters Index (SPI)                  |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                      Sequence Number                          |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                    Payload Data (variable)                    |
   ~                                                               ~
   |                                                               |
   +               +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |               |     Padding (0-255 octets)                    |
   +-+-+-+-+-+-+-+-+               +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                               |  Pad Length   | Next Header   |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                     Authentication Data                       |
   +        (variable length, but assumed to be 12 octets)         +
   |                                                               |
   +                                                               +
   |                                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

     SPI: Static. If it changes, it needs to be reestablished.

     Sequence Number: Not sent when the offset from the sequence number
        of the compressed header is constant. When offset is not
        constant, the sequence number may be compressed by sending
        LSBs. See 5.8.4.

     Payload Data: This is where subsequent headers are to be found.
        Parsed according to the Next Header field.




Bormann (ed.)                                                 [Page 100]

INTERNET-DRAFT          Robust Header Compression           Oct 23, 2000


     Padding: The padding octets are assumed to be as defined in [ESP],
        i.e., to take the values 1, 2, ..., k, where k = Pad Length. If
        the padding in the static context has this pattern, padding in
        compressed headers is assumed to have this pattern as well and
        is removed. If padding in the static context does not have this
        pattern, padding is not removed.

     Pad Length: Dynamic. Always sent. 14th octet from end of packet.

     Next Header: Static. 13th octet from end of packet.

   Authentication Data: Can have variable length, but when compression
   of NULL-encryption ESP header is attempted, it is assumed to have
   length 12 octets.

   The sequence number in ESP has the same behavior as the sequence
   number field in AH. When it increases linearly, it can be compressed
   to zero bits. When it does not increase linearly, a compressed
   sequence number is included in the IPX compression field in an
   extension 3 of an UOR-2 header.

   The information which is part of an uncompressed item of a compressed
   list is the SPI, and the Sequence Number. The Padding, Pad Length,
   Next Header, and Authentication Data is sent as-is at the end of the
   packet.

   A compressed item consists of a compressed sequence number. When an
   item is compressed, the Padding (if according to 1, 2, ..., k
   pattern) and Next Header is removed from the end of the packet. The
   Authentication Data and the Pad Length remains at the end of the
   packet.


5.8.4.4.  Mobile IPv6 Related Destination Option Header

   A Destination Option Header that carries one or more mobile IPv6
   related options (Binding Update option (BU), Binding Request option
   (BR), Binding Acknowledgment option (BA), or Home Address option
   (HA)) can be sent compressed or uncompressed.

   The option list carried in the destination option header could in
   principle be compressed using the list compression scheme. However,
   to keep the algorithm simple, the following simplified scheme is
   used.

   Each type of option in the destination option header can be sent
   compressed or uncompressed. The sequence of the compressed or
   uncompressed option in the compressed option list must be the same as
   in the original option list. A particular option can be sent
   compressed when the compressor observes that all the fields except
   sequence number field in BU and BA are unchanged and when it has



Bormann (ed.)                                                 [Page 101]

INTERNET-DRAFT          Robust Header Compression           Oct 23, 2000


   sufficient confidence that an option with the same option type has
   been received by the decompressor.

   Such confidence is obtained by the acknowledgment in R-mode and can
   be obtained by an acknowledgment in O-mode. In UO-mode, an option
   which has been sent L times is also considered to be known. Mobile
   IPv6 related options are sent every once in a while and normally not
   in a large number of consecutive packets. However, whenever an option
   type has been sent L times (not necessarily consecutively), it is
   assumed to be known to the decompressor.

   The format of the compressed option depends on the option type. The
   compressed BU and BA options contain the option type field followed
   by the sequence number field. The compressed BR and BA options
   contain only the option type field. Unknown options are sent
   uncompressed.

   compressed BU or BA:

     0   1   2   3   4   5   6   7
   +---+---+---+---+---+---+---+---+
   |          Option Type          |
   +---+---+---+---+---+---+---+---+
   |                               |
   +        Sequence Number        +
   |                               |
   +---+---+---+---+---+---+---+---+


   compressed BR or HA:

     0   1   2   3   4   5   6   7
   +---+---+---+---+---+---+---+---+
   |          Option Type          |
   +---+---+---+---+---+---+---+---+

   A bit mask indicating whether or not the corresponding MIPv6 related
   option is sent compressed is included. If a particular option is not
   included in current packet, the corresponding bit is set to 0. The
   format of such bit masks is shown in section 5.8.6.1.

5.8.4.5.  GRE Header

   The GRE header is a set of flags, followed by a mandatory protocol ID
   and optional parts as indicated by the flags.

   The sequence number field in the GRE header contains a counter value
   for a GRE tunnel. Therefore, when comparing curr_list with ref_list,
   if the sequence number in GRE changes, the GRE is not considered as
   changed.




Bormann (ed.)                                                 [Page 102]

INTERNET-DRAFT          Robust Header Compression           Oct 23, 2000


   If the sequence number in the GRE header linearly increases as the
   RTP sequence number increases and the compressor is confident that
   the decompressor has obtained the pattern, the sequence number in GRE
   need not be sent. The decompressor applies linear extrapolation to
   reconstruct the sequence number in the GRE header.

   Otherwise, a compressed sequence number is included in the IPX
   compression field in an extension 3 of an UOR-2 header.

   The checksum data field in GRE, if present, changes from packet to
   packet and is sent as-is. If the uncompressed GRE header is sent, the
   checksum data field is sent inside the uncompressed GRE header;
   otherwise, if present, it is sent after the compressed IP/UDP/RTP and
   IPv6 extension headers and before the payload. See beginning of
   section 5.7.

   [[Editor's note: I have found no information that would convince me
   key is always static.  Input from GRE gurus is desirable...]]


5.8.5.  Format of Compressed Lists

5.8.5.1.  Format of IP Extension Hdr(s) field

   In Extension 3 (section 5.7.5), there is a field called IP extension
   hdr(s). This section describes the format of that field.

         0     1     2     3     4     5     6     7
      +-----+-----+-----+-----+-----+-----+-----+-----+
      | CL  | ASeq| ESeq| Gseq| CBU | CBA | CBR | CHA | 1 octet
      +-----+-----+-----+-----+-----+-----+-----+-----+
      /    compressed AH Seq Number, 1 or 4 octets    / if ASeq=1
       ----- ----- ----- ----- ----- ----- ----- -----
      /    compressed ESP Seq Number, 1 or 4 octets   / if Eseq=1
       ----- ----- ----- ----- ----- ----- ----- -----
      /    compressed GRE Seq Number, 1 or 4 octets   / if Gseq=1
       ----- ----- ----- ----- ----- ----- ----- -----
      /    compressed header list, variable length    / if CL=1
       ----- ----- ----- ----- ----- ----- ----- -----

      ASeq: indicates presence of compressed AH Seq Number
      ESeq: indicates presence of compressed ESP Seq Number
      GSeq: indicates presence of compressed GRE Seq Number
      CL: indicates presence of compressed header list
      res: reserved. Set to zero when sending, ignored when received.
      CBU: indicates if Binding Update option is sent compressed
      CBA: indicates if Binding Ack option is sent compressed
      CBR: indicates if Binding Request option is sent compressed
      CHA: indicates if Home Address option is sent compressed





Bormann (ed.)                                                 [Page 103]

INTERNET-DRAFT          Robust Header Compression           Oct 23, 2000


   When Aseq, Eseq, or Gseq is set, the corresponding header item (AH,
   ESP, or GRE header) is compressed. When not set, the corresponding
   header item is sent uncompressed or is not present.

   When CBU, CBA, CBR, or CHA is zero, this means that the option in
   question is either not present or not compressed.

   The format of compressed AH, ESP and GRE Sequence Numbers can each be
   either of the following:

     0   1   2   3   4   5   6   7       0   1   2   3   4   5   6   7
   +---+---+---+---+---+---+---+---+   +---+---+---+---+---+---+---+---+
   | 0 |   LSB of sequence number  |   | 1 |                           |
   +---+---+---+---+---+---+---+---+   +---+                           +
                                       |                               |
                                       +     LSB of sequence number    +
                                       |                               |
                                       +                               +
                                       |                               |
                                       +---+---+---+---+---+---+---+---+

   The format of the compressed IPv6 extension hdr field is described in
   section 5.8.6.


5.8.5.2 Format of Compressed CSRC List

   The Compressed CSRC List field in the RTP header part of an extension
   3 (section 5.7.5) is as in section 5.8.6.


5.8.6 Compressed list formats

   This section describes the format of compressed lists. It is the same
   for header lists and CSRC lists; items are CSRC identifiers for CSRC
   lists, and uncompressed or compressed headers as described in
   5.8.4.2-4 for header lists.

5.8.6.1  Encoding Type 0 (generic scheme)

     0   1   2   3   4   5   6   7
   +---+---+---+---+---+---+---+---+
   | ET=0  |GP |PS |    CC = m     |
   +---+---+---+---+---+---+---+---+
   :            gen_id             :  1 octet, if GP=1
   +---+---+---+---+---+---+---+---+
   |        XI 1, ..., XI m        |  m octets, or m*4 bits
   /                --- --- --- ---/
   |               |    Padding    |  if PS=0 and m is odd.
   +---+---+---+---+---+---+---+---+
   |                               |



Bormann (ed.)                                                 [Page 104]

INTERNET-DRAFT          Robust Header Compression           Oct 23, 2000


   /       item 1, ..., item n     /  n * 4 octets
   |                               |
   +---+---+---+---+---+---+---+---+

      ET: encoding type is zero.

      PS: indicates size of XI fields
            PS=0 indicates 4-bit XI fields
            PS=1 indicates 8-bit XI fields

      GP: indicates presence of gen_id field

      CC: CSRC counter from original RTP header

     gen_id: identifier for a sequence of identical lists. It is
        present in UO-mode when the compressor decides that it may use
        this list as a future reference list.

      XI 1, ..., XI m: m XI items. The format of an XI item is

                     +---+---+---+---+
         when PS=0:  | X |   Index   |
                     +---+---+---+---+

                       0   1   2   3   4   5   6   7
                     +---+---+---+---+---+---+---+---+
         when PS=1:  | X |           Index           |
                     +---+---+---+---+---+---+---+---+

           X = 1: indicates that the item corresponding to the Index
                  is sent in the item 0, ..., item n list
           X = 0: indicates that the item corresponding to the Index is
                  not sent.

        When 4-bit XI items are used and m>1, the XI items are placed
        in octets in the following manner:

                       0   1   2   3   4   5   6   7
                     +---+---+---+---+---+---+---+---+
                     |     XI k      |     XI k+1    |
                     +---+---+---+---+---+---+---+---+

      Padding: a 4-bit padding field is present when PS=0 and m is odd.
         The Padding field is set to zero when sending and ignored when
         receiving.

      Item 1, ..., item n:
         Each item corresponds to an XI with X=1 in XI 1, ..., XI m.






Bormann (ed.)                                                 [Page 105]

INTERNET-DRAFT          Robust Header Compression           Oct 23, 2000


5.8.6.2 Encoding Type 1 (insertion only scheme)

     0   1   2   3   4   5   6   7
   +---+---+---+---+---+---+---+---+
   | ET=1  |GP |PS |     XI 1      |
   +---+---+---+---+---+---+---+---+
   :            gen_id             :  1 octet, if GP=1
   +---+---+---+---+---+---+---+---+
   |            ref_id             |
   +---+---+---+---+---+---+---+---+
   /      insertion bit mask       /  1-2 octets
   +---+---+---+---+---+---+---+---+
   |            XI list            |  k octets, or (k-1)*4 bits
   /                --- --- --- ---/
   |               |    Padding    |  if PS=0 and k is even.
   +---+---+---+---+---+---+---+---+
   |                               |
   /      item 1, ..., item n      /  n * 4 octets
   |                               |
   +---+---+---+---+---+---+---+---+

   Unless explicitly stated otherwise, fields have the same meaning and
   values as for encoding type 0.

      ET: encoding type is one (1).

      XI 1: when PS=0, the first 4-bit XI item is placed here.
        when PS=1, the field is set to zero when sending, and ignored
        when receiving.

      ref_id: the identifier of the reference CSRC list used when the
        list was compressed. It is the 8 least significant bits of
        the RTP sequence number in R-mode and gen_id (see section
        5.8.2) in UO-modes.

     insertion bit mask: bit-mask indicating the positions where new
        items are to be inserted. See Insertion Only scheme in section
        5.8.3. The bit-mask can have either of the following two
        formats

              0   1   2   3   4   5   6   7
            +---+---+---+---+---+---+---+---+
            | 0 |        7-bit mask         |  bit 1 is first bit
            +---+---+---+---+---+---+---+---+

            +---+---+---+---+---+---+---+---+
            | 1 |                           |  bit 1 is first bit
            +---+      15-bit mask          +
            |                               |  bit 7 is last bit
            +---+---+---+---+---+---+---+---+




Bormann (ed.)                                                 [Page 106]

INTERNET-DRAFT          Robust Header Compression           Oct 23, 2000


     XI list: XI fields for items to be inserted. When the insertion
        bit mask has k ones, the total number of XI fields is k. When
        PS=1, all XI fields are in the XI list. When PS=0, the first XI
        field is in the XI 1 field, and the remaining k-1 XI fields are
        in the XI list.

     Padding: present when PS=0 and k is even.

     item 1, ..., item n: an item for each XI field with the X bit set.


5.8.6.3 Encoding Type 2 (removal only scheme)

     0   1   2   3   4   5   6   7
   +---+---+---+---+---+---+---+---+
   | ET=2  |GP |res|     Count     |
   +---+---+---+---+---+---+---+---+
   :            gen_id             :  1 octet, if GP=1
   +---+---+---+---+---+---+---+---+
   |            ref_id             |
   +---+---+---+---+---+---+---+---+
   /       removal bit mask        /  1-2 octets
   +---+---+---+---+---+---+---+---+

   Unless explicitly stated otherwise, fields have the same meaning and
   values as in section 5.8.5.2.

      ET: Encoding type is 2.

     res: Reserved. Set to zero when sending, ignored when received.

     Count: number of elements in ref_list.

     removal bit mask: indicates the elements in ref_list to be removed
        in order to obtain the current list. See section 5.8.3. The
        removal bit mask has the same format as the insertion bit mask
        of section 5.8.5.3.

















Bormann (ed.)                                                 [Page 107]

INTERNET-DRAFT          Robust Header Compression           Oct 23, 2000


5.8.6.4 Encoding Type 3 (remove then insert scheme)

   See section 5.8.3 for a description of the Remove then insert scheme.

     0   1   2   3   4   5   6   7
   +---+---+---+---+---+---+---+---+
   | ET=3  |GP |PS |     XI 1      |
   +---+---+---+---+---+---+---+---+
   :            gen_id             :  1 octet, if GP=1
   +---+---+---+---+---+---+---+---+
   |            ref_id             |
   +---+---+---+---+---+---+---+---+
   /       removal bit mask        /  1-2 octets
   +---+---+---+---+---+---+---+---+
   /      insertion bit mask       /  1-2 octets
   +---+---+---+---+---+---+---+---+
   |            XI list            |  k octets, or (k-1)*4 bits
   /                --- --- --- ---/
   |               |    Padding    |  if PS=0 and k is even.
   +---+---+---+---+---+---+---+---+
   |                               |
   /      item 1, ..., item n      /  n * 4 octets
   |                               |
   +---+---+---+---+---+---+---+---+

   The fields in this header has the same meaning and formats as in
   section 5.8.5.2, except when explicitly stated otherwise below.

      ET: Encoding type is 3.

      removal bit mask: see section 5.8.5.3.


5.8.7  CRC coverage for extension headers

   All fields of Extension headers are CRC-STATIC, with the following
   exceptions which are CRC-DYNAMIC.

   1) Entire AH header.
   2) Entire ESP header.
   3) Sequence numbers in Mobile IP related options, i.e., sequence
      numbers in BU and BA options.
   4) Sequence number in GRE [[what else???]]


5.9.  Header compression CRCs, coverage and polynomials

   This chapter describes how to calculate the CRCs used in packet
   headers defined in this document.  (Note that another type of CRC is
   defined for reconstructed units in 5.2.4.)




Bormann (ed.)                                                 [Page 108]

INTERNET-DRAFT          Robust Header Compression           Oct 23, 2000



5.9.1.  IR & IR-DYN packet CRCs

   The CRC in the IR and IR-DYN packet is calculated over the entire IR
   or IR-DYN packet, excluding Payload and including CID. For purposes
   of computing the CRC, the CRC field in the header is set to zero.

   The initial content of the CRC register is to be preset to all 1's.

   The CRC polynomial to be used is:

     C(x) = 1 + x + x^2 + x^8


5.9.2.  CRCs in compressed packets

   The CRC in compressed headers is calculated over all octets of the
   entire original header, before compression, in the following manner.

   The octets of the header are classified as either CRC-STATIC or CRC-
   DYNAMIC, and the CRC is calculated over:

   1) the concatenated CRC-STATIC octets of the original header, placed
      in the same order as they appear in the original header, followed
      by

   2) the concatenated CRC-DYNAMIC octets of the original header, placed
      in the same order as they appear in the original header.

   The intent is that the state of the CRC computation after 1) will be
   saved. As long as the CRC-STATIC octets do not change, the CRC
   calculation will then only need to process the CRC-DYNAMIC octets.

   For a typical RTP/UDP/IPv4 header, 25 octets are CRC-STATIC and 15
   are CRC-DYNAMIC. For a typical RTP/UDP/IPv6 header, 49 octets are
   CRC-STATIC and 11 are CRC-DYNAMIC. This technique will thus reduce
   the computational complexity of the CRC calculation by roughly 60%
   for RTP/UDP/IPv4 and by roughly 80% for RTP/UDP/IPv6.

   Note: whenever the CRC-STATIC fields change, the new saved CRC state
   after 1) is compared with the old state. If the states are identical,
   the CRC cannot catch the error that the decompressor has not updated
   the static context. The compressor should then require an ACK in O
   mode and send the information for a longer time in U mode. Optimistic
   transition from IR or FO state should not be attempted in this case.

   The initial content of the CRC register is preset to all 1's.

   The polynomial to be used for the 3 bit CRC is:

     C(x) = 1 + x + x^3



Bormann (ed.)                                                 [Page 109]

INTERNET-DRAFT          Robust Header Compression           Oct 23, 2000



   The polynomial to be used for the 7 bit CRC is:

     C(x) = 1 + x + x^2 + x^3 + x^6 + x^7

   The CRC in compressed packets is calculated over the entire original
   header, before compression.


5.10. ROHC UNCOMPRESSED _ no compression (Profile 0)

   In ROHC, compression has not been defined for all kinds of IP
   headers. Profile 0 provides a way to send IP packets without
   compressing them. This can be used for IP fragments, RTCP packets,
   and in general for any packet for which compression of the header has
   not been defined, is not possible due to resource constraints, or is
   not desirable for any other reason.

   After initialization, the only overhead for sending packets using
   Profile 0 is the size of the CID. When uncompressed packets are
   frequent, Profile 0 should be associated with a CID with size zero or
   one octet. There is no need to associate Profile 0 with more than one
   CID.

5.10.1 IR packet

   The initialization packet (IR packet) for Profile 0 has the following
   format:

     0   1   2   3   4   5   6   7
    --- --- --- --- --- --- --- ---
   |         Add-CID octet         |  if for CID!=0 for small CIDs
   +---+---+---+---+---+---+---+---+
   | 1   1   1   1   1   1   0 |res|
   +---+---+---+---+---+---+---+---+
   |                               |
   /    0-2 octets of CID info     /  1-2 octets if for large CIDs
   |                               |
   +---+---+---+---+---+---+---+---+
   |          Profile = 0          |  1 octet
   +---+---+---+---+---+---+---+---+
   |              CRC              |  1 octet
   +---+---+---+---+---+---+---+---+
   |                               |  (optional)
   /           IP packet           /  variable length
   |                               |
    - - - - - - - - - - - - - - - -

      res: Always zero.

      Profile: 0.



Bormann (ed.)                                                 [Page 110]

INTERNET-DRAFT          Robust Header Compression           Oct 23, 2000



      CRC: 8-bit CRC, computed using the polynomial of section 5.9.1.
         The CRC is covers the first octet of the IR packet through the
         Profile octet of the IR packet, i.e., it does not cover the
         CRC itself nor the IP packet.

      IP packet: An uncompressed IP packet may be included in the IR
         packet. The decompressor determines if the IP packet is
         present by considering the length of the IR packet.


5.10.2 Normal packet

   A Normal packet is a normal IP packet plus CID information. When the
   channel uses small CIDs, and profile 0 is associated with a CID >0,
   an Add-CID octet is prepended to the IP packet. When the channel uses
   large CIDs, the CID is placed so that it starts at the second octet
   of the Normal packet.

     0   1   2   3   4   5   6   7
    --- --- --- --- --- --- --- ---
   |         Add-CID octet         |  if for CID!=0 for small CIDs
   +---+---+---+---+---+---+---+---+
   |   first octet of IP packet    |
   +---+---+---+---+---+---+---+---+
   |                               |
   /    0-2 octets of CID info     /  1-2 octets if for large CIDs
   |                               |
   +---+---+---+---+---+---+---+---+
   |                               |
   /      rest of IP packet        /  variable length
   |                               |
   +---+---+---+---+---+---+---+---+

   Note that the first octet of the IP packet starts with the bit
   pattern 0100 (IPv4) or 0110 (IPv6). This does not conflict with any
   reserved packet types. Hence, no bits in addition to the CID are
   needed. The profile is reasonably future-proof since problems do not
   occur until IP version 14.


5.10.3 States and Modes

   There are two modes in Profile 0: Unidirectional mode and Bi-
   directional mode. In Unidirectional mode, the compressor repeats the
   IR packet periodically. In Bi-directional mode, the compressor never
   repeats the IR packet. Compressor and decompressor always start in
   Unidirectional mode. Whenever feedback is received, the compressor
   moves to Bi-directional mode.





Bormann (ed.)                                                 [Page 111]

INTERNET-DRAFT          Robust Header Compression           Oct 23, 2000


   The compressor can be in either of two states: the IR state or the
   Normal state. It starts in the IR state.

   a) IR State: Only IR packets can be sent. After sending a small
      number of IR packets, one when refreshing, the compressor moves
      to the Normal state.

   b) Normal state: Only Normal packets can be sent. When in
      Unidirectional mode, the compressor periodically transits back to
      the IR state. The length of the period is implementation
      dependent, but should be fairly long. Exponential backoff may be
      used.

   c) When feedback is received in any state, the compressor moves  to
      Bi-directional mode.

   The decompressor can be in either of two states: NO_CONTEXT or
   FULL_CONTEXT. It starts in NO_CONTEXT.

   d) When an IR packet is received in the NO_CONTEXT state, the
      decompressor first verifies the packet using the CRC. If the
      packet is ok, the decompressor 1) moves to the FULL_CONTEXT
      state, 2) delivers the IP packet to upper layers if present, 3)
      MAY send an ACK. If the packet is not ok, it is discarded without
      further action.

   e) When any other packet is received in the NO_CONTEXT state, it is
      discarded without further action.

   f) When an IR packet is received in the FULL_CONTEXT state, the
      packet is first verified using the CRC. If ok, the decompressor
      1) delivers the IP packet to upper layers if present, 2) MAY send
      an ACK. If the packet is not ok, no action is taken.

   g) When a Normal packet is received in the FULL_CONTEXT state, the
      CID information is removed and the IP packet is delivered to
      upper layers.


5.10.4 Feedback

   The only kind of feedback in Profile 0 is ACKs. Profile 0 must not be
   rejected. Profile 0 should be associated with at most one CID. ACKs
   use the FEEDBACK-1 format of section 5.2. The value of the profile-
   specific octet in the FEEDBACK-1 ACK is 0 (zero).









Bormann (ed.)                                                 [Page 112]

INTERNET-DRAFT          Robust Header Compression           Oct 23, 2000


5.11. ROHC UDP - non-RTP UDP/IP compression (Profile 2)

   UDP/IP headers do not have a sequence number which is as well-behaved
   as the RTP sequence number. For UDP/IPv4, there is an IP-ID field
   which may be echoed in feedback information, but when no IPv4 header
   is present such feedback identification becomes problematic.

   Therefore, in the ROHC UDP profile, the compressor generates a 16-bit
   sequence number SN which increases by one for each packet received in
   the packet stream. This sequence number is thus relatively well-
   behaved and can serve as the basis for most mechanisms described for
   ROHC RTP. It is called SN or UDP SN below. Unless stated otherwise,
   the mechanisms of ROHC RTP are used also for ROHC UDP, with the UDP
   SN taking the role of the RTP sequence number.

   The ROHC UDP profile always uses p=-1 when interpreting the SN, since
   there will be no repetitions or reordering of the compressor-
   generated SN. The interpretation interval thus always starts with
   (ref_SN + 1).


5.11.1 Initialization

   The static context for ROHC UDP streams can be initialized in either
   of two ways;

   1) By using an IR packet as in section 5.7.7.1, where the profile is
      two (2) and the static chain ends with the static part of an UDP
      packet. At the compressor, UDP SN is initialized to a random value
      when the IR packet is sent.

   2) By reusing an existing context, where the existing static chain
      contains the static part of a UDP packet, e.g., the context of a
      stream compressed using ROHC RTP (profile 1). This is done with an
      IR-DYN packet (section 5.7.7.2) with profile = 2, where the
      dynamic chain corresponds to the prefix of the existing static
      chain that ends with the UDP header. UDP SN is initialized to the
      RTP sequence number if the earlier profile was profile 1, and to a
      random number otherwise.

   For ROHC UDP, the dynamic part of a UDP packet is different from
   section 5.7.7.5; a two-octet field containing the UDP SN is added
   after the Checksum field. This affects the format of dynamic chains
   in IR and IR-DYN packets.

   Note: 2) can be used for packet streams where the initial assumption
   was that they were RTP streams, so compression started with profile
   1, and it later becomes evident that they are not RTP streams.






Bormann (ed.)                                                 [Page 113]

INTERNET-DRAFT          Robust Header Compression           Oct 23, 2000


5.11.2 States and Modes

   ROHC UDP uses the same states and modes as ROHC RTP. Mode transitions
   and state logic is the same except when explicitly stated otherwise.
   Mechanisms dealing with fields in the RTP header (except the RTP SN)
   are not used. The decompressed UDP SN is never included in any header
   delivered to upper layers. The UDP SN is used in place of the RTP SN
   in feedback.

5.11.3 Packet types

   The general format of a ROHC UDP packet is the same as for ROHC RTP
   (see beginning of section 5.7.). Padding and CIDs are the same, as is
   the feedback packet type (5.7.6.1) and the feedback. IR and IR-DYN
   packets (5.7.7) are changed as described in 5.11.2.

   The general format of compressed packets is also the same, but there
   are differences in specific formats and extensions as follows. The
   differences are caused by removal of all RTP specific information
   except the RTP SN which is replaced by the UDP SN.

   Unless explicitly stated below, the packet formats are as in sections
   5.7.1-6.

   R-1

      The TS field is replaced by an IP-ID field. M flag has become
      another bit of IP-ID. X bit has moved. Formats R-1-ID and R-1-TS
      are not used.

     0   1   2   3   4   5   6   7
   +---+---+---+---+---+---+---+---+
   | 1   0 |          SN           |
   +===+===+===+===+===+===+===+===+
   | X |           IP-ID           |
   +---+---+---+---+---+---+---+---+


   UO-1

      The TS field is replaced by an IP-ID field. M-flag has become
      part of SN. Formats UO-1-ID and UO-1-TS are not used.

     0   1   2   3   4   5   6   7
   +---+---+---+---+---+---+---+---+
   | 1   0 |         IP-ID         |
   +===+===+===+===+===+===+===+===+
   |        SN         |    CRC    |
   +---+---+---+---+---+---+---+---+

   UOR-2



Bormann (ed.)                                                 [Page 114]

INTERNET-DRAFT          Robust Header Compression           Oct 23, 2000



      New format.

     0   1   2   3   4   5   6   7
   +---+---+---+---+---+---+---+---+
   | 1   1   0 |        SN         |
   +===+===+===+===+===+===+===+===+
   | X |            CRC            |
   +---+---+---+---+---+---+---+---+




5.11.4 Extensions

   Extensions are as in 5.7.5, with the following exceptions:

   Extension 0:

     +---+---+---+---+---+---+---+---+
     | 0   0 |    SN     |   IP-ID   |
     +---+---+---+---+---+---+---+---+

   Extension 1:

     +---+---+---+---+---+---+---+---+
     | 0   1 |    SN     |   IP-ID   |
     +---+---+---+---+---+---+---+---+
     |             IP-ID             |
     +---+---+---+---+---+---+---+---+

   Extension 2:

     +---+---+---+---+---+---+---+---+
     | 0   1 |    SN     |   IP-ID2  |
     +---+---+---+---+---+---+---+---+
     |            IP-ID2             |
     +---+---+---+---+---+---+---+---+
     |             IP-ID             |
     +---+---+---+---+---+---+---+---+

        IP-ID2: for outer IP-ID field.

   Extension 3 is the same as Extension 3 in section 5.7.5, with the
   following exceptions.

   1) The initial flag octet has the following format:

         0     1     2     3     4     5     6     7
      +-----+-----+-----+-----+-----+-----+-----+-----+
      |  1     1  |  S  |   Mode    |  I  | ip  | ip2 |



Bormann (ed.)                                                 [Page 115]

INTERNET-DRAFT          Robust Header Compression           Oct 23, 2000


      +-----+-----+-----+-----+-----+-----+-----+-----+

      Mode: replaces R-TS and Tsc of 5.7.5. Provides mode information
         as was earlier done in RTP header flags and fields.

      ip2: replaces rtp-bit of 5.7.5. Moved here from the Inner IP hdr
         flags octet (that bit is now always zero).

   2) The bit which was the ip2 flag in the Inner IP hdr flags in 5.7.5
      is reserved. It is set to zero when sending and ignored when
      receiving.


5.11.5 IP-ID

   Treated as in ROHC RTP but offset is from UDP SN.


5.11.6. Feedback

   Feedback is as for ROHC RTP with the following exceptions:

   1) UDP SN replaces RTP SN in feedback.
   2) The CLOCK option (5.7.6.6) is not used.
   3) The JITTER option (5.7.6.7) is not used.


5.12. ROHC ESP - ESP/IP compression (Profile 3)

   When the ESP header is being used with an encryption algorithm other
   than NULL, subheaders after the ESP header are encrypted and cannot
   be compressed. Profile number 3 is for compression of the chain of
   headers up to and including the ESP header in this case. When the
   NULL encryption algorithm is being used, other profiles can be used
   and would give higher compression rates. See section 5.8.4.3.

   This profile is very similar to the ROHC UDP profile. It uses the ESP
   sequence number as the basis for compression instead of a generated
   number, but is otherwise very similar to ROHC UDP.  The
   interpretation interval (value of p) for the ESP-based SN is as with
   ROHC RTP (profile 1).  Apart from that, unless stated explicitly
   below, mechanisms and formats are as for ROHC UDP.


5.12.1.  Initialization

   The static context for ROHC ESP streams can be initialized in either
   of two ways;






Bormann (ed.)                                                 [Page 116]

INTERNET-DRAFT          Robust Header Compression           Oct 23, 2000


   3) By using an IR packet as in section 5.7.7.1, where the profile is
      three (3) and the static chain ends with the static part of an ESP
      header.

   4) By reusing an existing context, where the existing static chain
      contains the static part of an ESP header. This is done with an
      IR-DYN packet (section 5.7.7.2) with profile = 3, where the
      dynamic chain corresponds to the prefix of the existing static
      chain that ends with the ESP header.

   In contrast to ROHC UDP, no extra sequence number is added to the
   dynamic part of the ESP header; the ESP sequence number is the only
   element.

   Note: 2) can be used for streams where compression was initiated
   under the initial assumption that NULL encryption was being used with
   ESP. When it later becomes obvious that an encryption algorithm other
   than NULL is being used, the compressor may send an IR-DYN according
   to 2) to switch to profile 3 without having to send an IR packet.


5.12.2.  Packet types

   The packet types for ROHC ESP are the same as for ROHC UDP, except
   that the ESP sequence number is used instead of the generated
   sequence number of ROHC UDP. The ESP header is not part of any
   compressed list in ROHC ESP.



























Bormann (ed.)                                                 [Page 117]

INTERNET-DRAFT          Robust Header Compression           Oct 23, 2000


6.  Implementation issues

   This document specifies mechanisms for the protocol and leaves many
   details on how to use these mechanisms to the implementers to decide
   upon. This chapter is aimed to give guidelines, ideas and suggestions
   for implementing the scheme.


6.1.  Reverse decompression

   This chapter describes an OPTIONAL decompressor operation to reduce
   discarded packets due to an invalid context.

   Once a context becomes invalid (e.g., in the case when more
   consecutive packet losses than expected has occurred), subsequent
   compressed packets cannot be decompressed correctly immediately.
   Reverse decompression aims at decompressing such packets later
   instead of discarding them, by storing them until the context has
   been updated and validated and then attempting decompression.

   Let the sequence of stored packets be i, i+1, ..., i+k, where i is
   the first packet and I+k is the packet before the context was
   updated. The decompressor will attempt to recover the stored packets
   in reverse order, i.e., starting with i+k, and working towards i.
   When a stored packet has been reconstructed, its correctness is
   verified using its CRC. Packets not carrying a CRC must not be
   delivered to upper layers. Packets where the CRC succeeds, are
   delivered to upper layers in the original order, i.e., i, ..., i+k.

   Note that this reverse decompression introduces buffering while
   waiting for the context to be validated and thereby introduces
   additional delay. Thus, it should be used only when some amount of
   delay is acceptable. For example, for video packets belonging to the
   same video frame, the delay of packet arrival time does not cause
   presentation time delay. Delay-insensitive streaming applications can
   also be tolerant to such delay. If the decompressor cannot determine
   if the application can tolerate delay, it should not do reverse
   decompression.

   The following illustrates the decompression procedure in some detail:

   1. The decompressor stores compressed packets that cannot be
      decompressed correctly due to an invalid context.

   2. When the decompressor has received a context updating packet and
      the context has been validated, it starts to recover the stored
      packets in reverse order. Decompression is carried out followed
      by the last decompressed packet to its previous packet as if the
      two packets were reordered. After that, the decompressor checks
      the correctness of the reconstructed header using the CRC.




Bormann (ed.)                                                 [Page 118]

INTERNET-DRAFT          Robust Header Compression           Oct 23, 2000


   3. If the CRC indicates successful decompression, the decompressor
      stores the complete packet and attempts to decompress the
      preceeding packet. In this way, the stored packets are recovered
      until no compressed packets are left. For each packet, the
      decompressor checks the correctness of the decompressed headers
      using header compression CRC.

   4. If the CRC indicates an incorrectly decompressed packet, the
      reverse decompression attempt must be terminated and all
      remaining uncompressed packets must be discarded.

   5. Finally, the decompressor forwards all the correctly decompressed
      packets to upper layers in the original order.

6.2.  RTCP

   RTCP is the RTP Control Protocol, [RTP]. RTCP is based on periodic
   transmission of control packets to all participants in a session,
   using the same distribution mechanism as for data packets. Its
   primary function is to provide feedback from the data receivers on
   the quality of the data distribution. The feedback information may be
   used for issues related to congestion control functions, and directly
   useful for control of adaptive encodings.

   In an RTP session there will be two types of packet streams; one with
   the RTP-header and application data, and a second stream with the
   RTCP control information. The difference between the streams at the
   transport level is the UDP port numbers, which is plus one for RTCP.
   The ROHC header compressor implementation has several ways at hand to
   handle the RTCP stream.

     1. One compressor/decompressor entity for both streams and carried
        on the same channel using CIDs to distinguish between them. On
        the RTCP stream, basically only IP/UDP compression will be
        utilized.

     2. Two compressor/decompressor entities, one for RTP and another
        one for RTCP, and the streams carried on their own channel. This
        means that they will not share the same CID number space.

     3. RTCP headers may be sent uncompressed using profile 0.


6.3.  Implementation parameters and signals

   A ROHC implementation may have two kinds of parameters; configuration
   parameters that are mandatory and must be negotiated between
   compressor and decompressor peers, and also implementation parameters
   that are optional and when used, mandate how a ROHC implementation is
   to operate.




Bormann (ed.)                                                 [Page 119]

INTERNET-DRAFT          Robust Header Compression           Oct 23, 2000



   Configuration parameters are mandatory and must be negotiated between
   compressor and decompressor, so they have the same values at
   compressor and decompressor. An example of a configuration parameter
   is whether context identification bits (CID) should be used or not.

   Implementation parameters make it possible for an external entity to
   mandate how an implementation of a ROHC compressor or decompressor
   should operate.  Implementation parameters have local significance,
   are optional to use and are thus not necessary to negotiate between
   compressor and decompressor.  Note: this does not preclude that
   implementation parameters may be signaled or negotiated using lower
   layer functionality in order to set the way a ROHC implementation
   operate. Some implementation parameters are valid only at either of
   compressor or decompressor. Implementation parameters may further be
   divided into parameters that allow an external entity to describe the
   way the implementation should operate and into parameters that allow
   an external entity to trigger a specific event, i.e., signals.

6.3.1.  ROHC implementation parameters at compressor:


   CONTEXT_REINITIALIZATION - signal
   This parameter triggers a reinitialization of the entire context at
   the decompressor, both the static and the dynamic part. The
   compressor MUST, when CONTEXT_REINITIALIZATION is triggered, back off
   to IR State and fully reinitialize the context by sending IR packets
   with both the static and dynamic chains covering the entire full
   headers until it is reasonably confident that the decompressor
   contexts are reinitialized. The context reinitialization MUST be done
   for all contexts at the compressor. This parameter may for instance
   be used to do context relocation at e.g. a cellular handover that
   result in a change of compression point in the radio access network.

   NO_OF_PACKET_SIZES ALLOWED - value: positive integer value
   This parameter only may be set by an external entity when
   PACKET_SIZES is not used by an external entity, to mandate the number
   of packet sizes a ROHC implementation can use. With this parameter
   set, the ROHC implementation at the compressor MUST NOT use more
   different packet sizes than the value this parameter mandates. The
   ROHC implementation must be able to determine itself which packet
   sizes will be used and describe that to an external entity using
   PACKET_SIZES USED. It should be noted that one packet size might be
   used for several header formats, and that the number of packet sizes
   can be reduced by employing padding and segmentation.

   NO OF PACKET SIZES USED _ value: positive integer value
   This parameter is set by the ROHC implementation to indicate how many
   packet sizes it will actually use.  It can be set to a large value to
   indicate that no particular attempt is made to minimize that number.




Bormann (ed.)                                                 [Page 120]

INTERNET-DRAFT          Robust Header Compression           Oct 23, 2000


   PACKET_SIZES_ALLOWED - value: list of positive integer values (bytes)
   This parameter, if set, mandates which packet sizes in bytes can be
   used by the ROHC implementation. Thus, packet sizes not in the set of
   values for this parameter MUST NOT be used. Hence, an external entity
   can mandate a ROHC implementation to produce packet sizes that better
   fit on pre-configured lower layers. If this parameter is used to
   mandate which packet sizes a ROHC implementation can use, the
   following rules apply:
   - A packet size large enough to allow for the entire IR header, both
   static and dynamic chain, MUST be part of the set of sizes, unless
   MRRU is set to a large enough value to allow segmentation.
   - The packet size likely to be used most frequently in SO state
   SHOULD be part of the set.
   - The packet size likely to be used most frequently in FO state
   SHOULD be part of the set.

   PACKET_SIZES USED - values: set of positive integer values (bytes)
   This parameter describes which packet sizes a ROHC implementation
   uses if NO_OF_PACKET_SIZES ALLOWED or PACKET SIZES ALLOWED is used by
   an external entity to mandate how many packet sizes a ROHC
   implementation should use. The information about used packet sizes
   (bytes) in this parameter, may then be used to configure lower
   layers.

   PAYLOAD SIZES _ values: set of positive integer values (bytes)
   This parameter is set by an external entity that wants to make use of
   the PACKET SIZES USED parameter to indicate which payload sizes can
   be expected.

   When a ROHC implementation has a limited set of packet sizes to use
   and the header format most preferable to use has a size that is not
   part of the set, it can either:
   - Choose the header format from the allowed set that is closest but
   larger in size. This is probably the most efficient choice.
   - Use the most preferable header format as if there were no
   restrictions on size, and then pad with padding octets to the next
   larger size in the allowed set.
   - Use segmentation to fragment the packet into pieces that would
   correspond to , possibly after adding padding.

   It should be noted that even if these two latter parameters introduce
   the possibility to restrict the number of packet sizes used, such
   restrictions will have a negative impact on compression performance.


6.3.2.  ROHC implementation parameters at decompressor:

   MODE - values: [U_mode, O_mode, R_mode]
   This parameter triggers a mode transition using the mechanism
   described in chapter 5 when the parameter changes value, i.e. to
   U_mode (Unidirectional mode), O_mode (bidirectional Optimistic mode)



Bormann (ed.)                                                 [Page 121]

INTERNET-DRAFT          Robust Header Compression           Oct 23, 2000


   or R_mode (bidirectional Reliable mode). The mode transition is made
   from the current mode to the new mode as signaled in the
   implementation parameter. For example, if the current mode is
   bidirectional optimistic mode, MODE should have the value: O_mode. If
   the MODE is changed to R_mode, a mode transition MUST be made from
   bidirectional optimistic mode to bidirectional reliable mode. MODE
   should not only serve as a trigger for mode transitions, but also
   make it visible which mode ROHC operates in.

   CLOCK_RESOLUTION - value: non-negative integer
   This parameter indicates the system clock resolution in units of
   milliseconds. A zero (0) value means there is no clock available. If
   non-zero, this parameter allows the decompressor to use timer-based
   TS compression (4.5.4) and SN wrap-around detection (5.3.2.2.3.1).
   In this case, its specific value is also significant for correctness
   of the algorithms.

   REVERSE_DECOMPRESSION_DEPTH - value: non-negative integer
   This parameter determines whether reverse decompression as described
   in section 6.1 should be used or not, and if used, to what extent.
   The value indicates the maximum number of packets that can be
   buffered, and thus possibly be reverse decompressed by the
   decompressor. A zero (0) value means reverse decompression MUST NOT
   be used.

6.4.  Handling of resource limitations at the decompressor

   In a point to point link the two nodes can agree on the number of
   compressed sessions they are prepared to support for this link.  It
   may, however, not be possible for the decompressor to accurately
   predict when it will run out of resources.  ROHC allows the
   negotiated number of contexts to be larger than could be accommodated
   in the worst case.  Then, as context resources are consumed, an
   attempt to set up a new context may be rejected by the decompressor,
   using the REJECT option of the feedback payload.

   Upon reception of a REJECT option, the compressor SHOULD wait for a
   while before attempting to compress additional streams destined to
   the rejecting host.

6.5.  Implementation structures

   This section provides some explanatory material on data structures
   that a ROHC implementation will have to maintain in one form or
   another.  It is not intended to constrain the implementations.

6.5.1. Compressor Context

   Compressor context consists of Static part and Dynamic part. The
   content of the static part is the same as the static chain defined in




Bormann (ed.)                                                 [Page 122]

INTERNET-DRAFT          Robust Header Compression           Oct 23, 2000


   section 5.7.7. The dynamic part consists of multiple elements which
   can be categorized into four types.

   a) Sliding Window (SW)
   b) Translation Table (TT)
   c) Flag
   d) Field

   These elements may be common to all modes or mode specific. The
   following table summarizes all these elements.

   +--------+------------------------+----------------+----------------+
   |        |       Common to        |   Specific to  |   Specific to  |
   |        |       all modes        |     R mode     |     UO modes   |
   +--------+------------------------+----------------+----------------+
   | SWs    | GSW                    | R_CSW          | UO_CSW         |
   |        |                        | R_IESW         | UO_IESW        |
   +--------+------------------------+----------------+----------------+
   | TTs    |                        | R_CTT          | UO_CTT         |
   |        |                        | R_IETT         | UO_IETT        |
   +--------+------------------------+----------------+----------------+
   | Flags  | UDP Chksum             |                | ACKED          |
   |        | TSS, IPT               |                |                |
   |        | RND, RND2              |                |                |
   |        | NBO, NBO2              |                |                |
   +--------+------------------------+----------------+----------------+
   | Fields | Profile                |                | CSRC_REF_ID    |
   |        | C_MODE                 |                | CSRC_GEN_ID    |
   |        | C_STATE                |                | CSRC_GEN_COUNT |
   |        | C_TRANS                |                | IPEH_REF_ID    |
   |        | TS_STRIDE(if TSS=1)    |                | IPEH_GEN_ID    |
   |        | TS_OFFSET(if TSS=1)    |                | IPEH_GEN_COUNT |
   |        | TIME_STRIDE(if IPT=1)  |                |                |
   |        | CURR_TIME(if IPT=1)    |                |                |
   |        | MAX_JITTER_CD(if IPT=1)|                |                |
   |        | LONGEST LOSS EVENT(O)  |                |                |
   |        | CLOCK RESOLUTION(O)    |                |                |
   |        | MAX JITTER(O)          |                |                |
   +--------+------------------------+----------------+----------------+

   1) GSW: Generic W_LSB Sliding Window

     Each element in GSW consists of all the dynamic fields in dynamic
     chain (defined in section 5.7.7) plus the fields specified in a)
     and excluding the fields specified in b).

      a) Packet Arrival Time (if IPT=1)
         Scaled RTP Time Stamp (if TSS=1) (optional)
         Offset_i (if RND=0) (optional)

      b) UDP Checksum, TS Stride, CSRC list, IPv6 Extension Headers



Bormann (ed.)                                                 [Page 123]

INTERNET-DRAFT          Robust Header Compression           Oct 23, 2000



   2) R_CSW: CSRC Sliding Window in R mode

      R_IESW: IPv6 Extension Header Sliding Window in R mode

      UO_CSW: CSRC Sliding Window in UO modes

      UO_IESW: IPv6 Extension Header Sliding Window in UO mode

     Each element in R_CSW, R_IESW, UO_CSW and UO_IESW is defined in
     section 5.8.2.2.

   3) R_CTT: CSRC Translation Table in R mode

      R_IETT: IPv6 Extension Header Translation Table in UO mode

      UO_CTT: CSRC Translation Table in UO modes

      UO_IETT: IPv6 Extension Header Translation Table in UO modes

      Each element in R_CTT and R_IETT is defined in section 5.8.1.1.
      Each element in UO_CTT and UO_IETT is defined in section 5.8.1.2.

   4) ACKED: indicates whether or not the decompressor has ever acked

   5) CURR_TIME: the current time value (used for context relocation
              timer base time stamp compression is used)

   6) All the other flags and fields are defined throughout the ROHC
      document.

6.5.2. Decompressor Context

   Decompressor context consists of Static part and Dynamic part. The
   content of the static part is the same as the static chain defined in
   section 5.7.7. The dynamic part consists of multiple elements, one of
   which is the non-static reference header that includes all the non-
   static fields. These non-static fields are the fields in the dynamic
   chain defined in section 5.7.7, excluding UDP checksum and TS Stride.
   All the remaining elements can be categorized into four types.

   a) Sliding Window (SW)
   b) Translation Table (TT)
   d) Flag
   e) Field

   These elements may be mode specific or common to all modes.
   The following table summarizes all these elements.

   +--------+------------------------+----------------+----------------+
   |        |       Common to        |   Specific to  |   Specific to  |



Bormann (ed.)                                                 [Page 124]

INTERNET-DRAFT          Robust Header Compression           Oct 23, 2000


   |        |       all modes        |     R mode     |     UO modes   |
   +--------+------------------------+----------------+----------------+
   | SWs    |                        | R_CSW          | UO_CSW         |
   |        |                        | R_IESW         | UO_IESW        |
   +--------+------------------------+----------------+----------------+
   | TTs    |                        | R_CTT          | UO_CTT         |
   |        |                        | R_IETT         | UO_IETT        |
   +--------+------------------------+----------------+----------------+
   | Flags  | UDP Chksum             |                | ACKED          |
   |        | TSS, IPT               |                |                |
   |        | RND, RND2              |                |                |
   |        | NBO, NBO2              |                |                |
   +--------+------------------------+----------------+----------------+
   | Fields | Profile                |                | CSRC_GEN_ID    |
   |        | D_MODE                 |                | IPEH_GEN_ID    |
   |        | D_STATE                |                | PRE_SN_V_REF   |
   |        | D_TRANS                |                |                |
   |        | TS_STRIDE(if TSS=1)    |                |                |
   |        | TS_OFFSET(if TSS=1)    |                |                |
   |        | TIME_STRIDE(if IPT=1)  |                |                |
   |        | PKT_ARR_TIME(if IPT=1) |                |                |
   |        | LONGEST LOSS EVENT(O)  |                |                |
   |        | CLOCK RESOLUTION(O)    |                |                |
   |        | MAX JITTER(O)          |                |                |
   +--------+------------------------+----------------+----------------+

   1) ACKED: indicates whether or not ACK has ever been sent
   2) PKT_ARR_TIME: the arrival time of the packet that has been
                    decompressed and verified using CRC most recently

      PRE_SN_V_REF: the sequence number of the packet which has been
   verified
                    before the most recently verified packet

      CSRC_GEN_ID: the CSRC gen_id of the most recently received packet

      IPEH_GEN_ID: the IPv6 Extension Header gen_id of the most recently
                   received packet

   3) The remaining elements are the same as defined in compressor
   context.

6.5.3. List Compression: Sliding Windows in R-mode and UO-modes

   In R-mode list compression (see 5.8.2.2), each entry in the sliding
   window at both the compressor side and decompressor side has the
   following structure.

   +---------------------+--------+------------+
   | RTP Sequence Number | icount | index list |
   +---------------------+--------+------------+



Bormann (ed.)                                                 [Page 125]

INTERNET-DRAFT          Robust Header Compression           Oct 23, 2000



   The table index list contains a list of index. Each of these index
   corresponds to the item in the original list carried in the packet
   identified by the RTP Sequence Number. The mapping between the index
   and the item is identified in the translation table. The icount field
   carries the number of index in the following index list.

   In UO-mode list compression, each entry in the sliding window at both
   the compressor side and decompressor side has the following
   structure.

   +--------+--------+------------+
   | Gen_id | icount | index list |
   +--------+--------+------------+

   The icount and index list fields are the same as defined in R mode.
   Instead of using RTP Sequence Number to identify each entry, the
   Gen_id is included in the sliding window in UO-modes.


7.  Security considerations

   Because encryption eliminates the redundancy that header compression
   schemes try to exploit, there is some inducement to forego encryption
   of headers in order to enable operation over low-bandwidth links.
   However, for those cases where encryption of data (and not headers)
   is sufficient, RTP does specify an alternative encryption method in
   which only the RTP payload is encrypted and the headers are left in
   the clear. That would still allow header compression to be applied.

   ROHC compression is transparent with regards to the RTP sequence
   number and RTP timestamp fields, so the values of those fields can be
   trusted by payload encryption schemes.

   A malfunctioning or malicious header compressor could cause the
   header decompressor to reconstitute packets that do not match the
   original packets but still have valid IP, UDP and RTP headers and
   possibly also valid UDP checksums. Such corruption may be detected
   with end-to-end authentication and integrity mechanisms which will
   not be affected by the compression. Moreover, this header compression
   scheme uses an internal checksum for verification of re-constructed
   headers. This reduces the probability of producing decompressed
   headers not matching the original ones without this being noticed.

   Denial-of-service attacks are possible if an intruder can introduce
   (for example) bogus STATIC, DYNAMIC or FEEDBACK packets onto the link
   and thereby cause compression efficiency to be reduced. However, an
   intruder having the ability to inject arbitrary packets at the link
   layer in this manner raises additional security issues that dwarf
   those related to the use of header compression.




Bormann (ed.)                                                 [Page 126]

INTERNET-DRAFT          Robust Header Compression           Oct 23, 2000



8.  IANA Considerations

   Following the policies outlined in [IANA-CONSIDERATIONS], the IANA
   policy for assigning new values for the profile identifier shall be
   Specification Required - Values and their meaning must be documented
   in an RFC or other permanent and readily available reference, in
   sufficient detail so that interoperability between independent
   implementations is possible.  The range 0 to 127 is reserved for IETF
   standard-track specifications, the range 128 to 254 is available for
   other specifications that meet this requirement (such as
   Informational RFCs).   The value 255 is reserved for future
   extensibility of the present specification.

   The following profile identifiers are already allocated:

   Profile     Document       Usage
   identifier

   0           RFCthis        ROHC uncompressed
   1           RFCthis        ROHC RTP
   2           RFCthis        ROHC UDP
   3           RFCthis        ROHC ESP



9.  Acknowledgments

   Earlier header compression schemes described in [CJHC], [IPHC] and
   [CRTP] have been important sources of ideas and knowledge.

   Thanks to Andreas Jonsson (Lulea University), who supported this work
   by his study of header field change patterns.

   The editor would like to thank Mikael Degermark, who actually did a
   lot of the editing work.


















Bormann (ed.)                                                 [Page 127]

INTERNET-DRAFT          Robust Header Compression           Oct 23, 2000



8z.  Intellectual property considerations

   (Editor's note: this section will go to www.ietf.org/ipr and be
   replaced by the standard reference to that, but for now it is left in
   the draft to simplify working on it.)

   This proposal in is conformity with RFC 2026.

   Telefonaktiebolaget LM Ericsson and its subsidiaries, in accordance
   with corporate policy, will for submissions rightfully made by its
   employees which are adopted or recommended as a standard by the IETF
   offer patent licensing as follows:

   If part(s) of a submission by Ericsson employees is (are) included in
   a standard and Ericsson has patents and/or patent application(s) that
   are essential to implementation of such included part(s) in said
   standard, Ericsson is prepared to grant - on the basis of reciprocity
   (grant-back) - a license on such included part(s) on reasonable, non-
   discriminatory terms and conditions.

   For the avoidance of doubt this general patent licensing undertaking
   applies to this proposal.


   Nokia has filed patent applications that might possibly have
   technical relation to this contribution.


   Matsushita has filed patent applications that might possibly have
   technical relation to this contribution.
   If part(s) of the contribution by Matsushita employee is (are)
   included in a standard and Matsushita has patents and/or patent
   application(s) that are essential to implementation of such included
   part(s) in said standard, Matsushita is prepared to grant - on the
   basis of reciprocity (grantback) - a license on such included part(s)
   on reasonable, non-discriminatory terms and conditions (in according
   with paragraph 10.3.3 of the RFC 2026).


   NTT DoCoMo, Inc. also declares this text may relevant to their
   patent, and offer patent licensing as follows:

   If part(s) of this text provided by NTT DoCoMo employees is (are)
   included in a standard and NTT DoCoMo has patents and/or patent
   application(s) that are essential to implementation of such included
   part(s) in said standard, NTT DoCoMo is prepared to grant - on the
   basis of reciprocity (grant-back) - a license on such included
   part(s) on reasonable, non-discriminatory terms and conditions.





Bormann (ed.)                                                 [Page 128]

INTERNET-DRAFT          Robust Header Compression           Oct 23, 2000


10.  References

   [UDP]    Jon Postel, "User Datagram Protocol", RFC 768, August 1980.

   [IPv4]   J. Postel, "Internet Protocol", RFC 791, September 1981.

   [IPv6]   S. Deering, R. Hinden, "Internet Protocol, Version 6
            (IPv6) Specification", RFC 2460, December 1998.

   [RTP]    H. Schulzrinne, S. Casner, R. Frederick, Van
            Jacobson, "RTP: A Transport Protocol for Real-Time
            Applications", RFC 1889, January 1996.

   [HDLC]   W. Simpson, "PPP in HDLC-like framing", RFC 1662, 1994.

   [VJHC]   V. Jacobson, "Compressing TCP/IP Headers for Low-Speed
            Serial Links", RFC 1144, February 1990.

   [IPHC]   M. Degermark, B. Nordgren, S. Pink, "IP Header
            Compression", RFC 2507, February 1999.

   [CRTP]   S. Casner, V. Jacobson, "Compressing IP/UDP/RTP Headers
            for Low-Speed Serial Links", RFC 2508, February 1999.

   [PPPHC]  M. Engan, S. Casner, C. Bormann, "IP Header
            Compression over PPP", RFC 2509, February 1999.

   [CRTPC]  M. Degermark, H. Hannu, L.E. Jonsson, K. Svanbro,
           "Evaluation of CRTP Performance over Cellular Radio
           Networks", IEEE Personal Communication Magazine, Volume 7,
           number 4, pp. 20-25, August 2000

   [REQ]   M. Degermark, "Requirements for robust IP/UDP/RTP header
           compression", Internet Draft (work in progress), June 2000.
           <draft-ietf-rohc-rtp-requirements-01.txt>

   [LLG]   K. Svanbro, "Lower Layer Guidelines for Robust RTP/UDP/IP
           Header Compression", Internet Draft (work in progress),
           October 2000.
           <draft-ietf-rohc-rtp-lower-layer-guidelines-00.txt>

   [ESP]    S. Kent, R. Atkinson, "IP Encapsulating Security Payload",
           RFC 2406, November 1998.

   [NULL]   R. Glenn, S. Kent, "The NULL Encryption Algorithm and Its
           Use With Ipsec", RFC 2410, November 1998.

   [IANA-CONSIDERATIONS] Alvestrand, H. and T. Narten, "Guidelines for
           Writing an IANA Considerations Section in RFCs", BCP 26, RFC
           2434, October 1998.




Bormann (ed.)                                                 [Page 129]

INTERNET-DRAFT          Robust Header Compression           Oct 23, 2000


11.  Authors' addresses

   Carsten Bormann               Tel: +49 421 218 7024
   Universitaet Bremen TZI       Fax: +49 421 218 7000
   Postfach 330440               EMail: cabo@tzi.org
   D-28334 Bremen, GERMANY

   Carsten Burmeister            Tel.  +49-6103-766-263
   Rolf Hakenberg                Tel.  +49-6103-766-162
   Thomas Wiebke                 Tel.  +49-6103-766-161
   Panasonic European Laboratories GmbH   Fax.  +49-6103-766-166
   Monzastr. 4c                  Email: burmeister@panasonic.de
   63225 Langen, Germany         Email: hakenberg@panasonic.de
                                 Email: wiebke@panasonic.de

   Mikael Degermark              Tel: +1 520 621-3498
   The University of Arizona     Fax: +1 520 621-4642
   Dept of Computer Science      Email: micke@cs.arizona.edu
   P.O. Box 210077
   Tucson, AZ 85721-0077, USA

   Hideaki Fukushima             Email: fukusima@isl.mei.co.jp
   Akihiro Miyazaki              Email: akihiro@isl.mei.co.jp
   Matsushita Electric Industrial Co., Ltd    Tel.  +81-6-6900-9192
   1006, Kadoma, Kadoma City, Osaka, Japan    Fax.  +81-6-6900-9193

   Hans Hannu                    Tel: +46 920 20 21 84
   Lars-Erik Jonsson             Tel: +46 920 20 21 07
   Krister Svanbro               Tel: +46 920 20 20 77
   Box 920                       Fax: +46 920 20 20 99
   Ericsson Erisoft AB           EMail: lars-erik.jonsson@ericsson.com
   SE-971 28 Lulea, Sweden       Email: krister.svanbro@ericsson.com
                                 EMail: hans.hannu@ericsson.com

   Khiem Le                      Tel: +1-972-894-4882
   Zhigang Liu                   Tel: +1 972 894-5935
   Haihong Zheng                 Tel: +1 972 894-4232
   Nokia Research Center         Fax: +1 972 894-4589
   6000 Connection Drive         Email: khiem.le@nokia.com
   Irving, TX 75039, USA         Email: zhigang.liu@nokia.com
                                 Email: haihong.zheng@nokia.com

   Anton Martensson              Tel: +46 8 404 3881
   Ericsson Radio Systems AB     Fax: +46 8 757 5550
   Torshamnsgatan 23
   SE-164 80 Stockholm, Sweden   Email: anton.martensson@era.ericsson.se








Bormann (ed.)                                                 [Page 130]

INTERNET-DRAFT          Robust Header Compression           Oct 23, 2000


Appendix A.  Detailed classification of header fields

   Header compression is possible due to the fact that most header
   fields do not vary randomly from packet to packet. Many of the fields
   exhibit static behavior or changes in a more or less predictable way.
   When designing a header compression scheme, it is of fundamental
   importance to understand the behavior of the fields in detail.

   In this appendix, all IP, UDP and RTP header fields are classified
   and analyzed in two steps. First, we have a general classification in
   A.1 where the fields are classified based on stable knowledge and
   assumptions. The general classification does not take into account
   the change characteristics of changing fields because those will vary
   more or less depending on the implementation and on the application
   used. A less stable but more detailed analysis considering the change
   characteristics is then done in A.2. Finally, A.3 summarizes this
   appendix with conclusions about how the various header fields should
   be handled by the header compression scheme to optimize compression
   and functionality.

A.1.  General classification

   On a general level, the header fields are separated into 5 classes:

   INFERRED       These fields contain values that can be inferred from
                  other values, for example the size of the frame
                  carrying the packet, and thus does not have to be
                  handled at all by the compression scheme.

   STATIC         These fields are expected to be constant throughout
                  the lifetime of the packet stream. Static information
                  must in some way be communicated once.

   STATIC-DEF     STATIC fields whose values define a packet stream.
                  They are in general handled as STATIC.

   STATIC-KNOWN   These STATIC fields are expected to have well-known
                  values and therefore do not need to be communicated
                  at all.

   CHANGING       These fields are expected to vary in some way, either
                  randomly, within a limited value set or range, or in
                  some other manner.


   In this section, each of the IP, UDP and RTP header fields is
   assigned to one of these classes. For all fields except those
   classified as CHANGING, the motives for the classification are also
   stated. CHANGING fields are in A.2 further examined and classified
   based on their expected change behavior.




Bormann (ed.)                                                 [Page 131]

INTERNET-DRAFT          Robust Header Compression           Oct 23, 2000


A.1.1.  IPv6 header fields

    +---------------------+-------------+----------------+
    | Field               | Size (bits) |    Class       |
    +---------------------+-------------+----------------+
    | Version             |      4      |  STATIC-KNOWN  |
    | Traffic Class       |      8      |    CHANGING    |
    | Flow Label          |     20      |   STATIC-DEF   |
    | Payload Length      |     16      |    INFERRED    |
    | Next Header         |      8      |  STATIC-KNOWN  |
    | Hop Limit           |      8      |    CHANGING    |
    | Source Address      |    128      |   STATIC-DEF   |
    | Destination Address |    128      |   STATIC-DEF   |
    +---------------------+-------------+----------------+


   Version

     The version field states which IP version the packet is based on.
     Packets with different values in this field must be handled by
     different IP stacks. For header compression, different compression
     profiles must also be used. When compressor and decompressor have
     negotiated which profile to use, the IP version is also known to
     both parties. The field is therefore classified as STATIC-KNOWN.


   Flow Label

     This field may be used to identify packets belonging to a specific
     packet stream. If not used, the value should be set to zero.
     Otherwise, all packets belonging to the same stream must have the
     same value in this field, it being one of the fields defining the
     stream. The field is therefore classified as STATIC-DEF.


   Payload Length

     Information about the packet length (and then also payload length)
     is expected to be provided by the link layer. The field is
     therefore classified as INFERRED.


   Next Header

     This field is expected to have the same value in all packets of a
     packet stream. As for the version number, a certain compression
     profile can only handle a specific next header which means that
     this value is known when profile has been negotiated. The field is
     therefore classified as STATIC-KNOWN.





Bormann (ed.)                                                 [Page 132]

INTERNET-DRAFT          Robust Header Compression           Oct 23, 2000


   Source and Destination addresses

     These fields are part of the definition of a stream and must thus
     be constant for all packets in the stream. The fields are therefore
     classified as STATIC-DEF.


   Summarizing the bits corresponding to the classes gives:

    +--------------+--------------+
    | Class        | Size (octets)|
    +--------------+--------------+
    | INFERRED     |       2      |
    | STATIC-DEF   |     34.5     |
    | STATIC-KNOWN |      1.5     |
    | CHANGING     |       2      |
    +--------------+--------------+


A.1.2.  IPv4 header fields

    +---------------------+-------------+----------------+
    | Field               | Size (bits) |     Class      |
    +---------------------+-------------+----------------+
    | Version             |      4      |  STATIC-KNOWN  |
    | Header Length       |      4      |  STATIC-KNOWN  |
    | Type Of Service     |      8      |    CHANGING    |
    | Packet Length       |     16      |    INFERRED    |
    | Identification      |     16      |    CHANGING    |
    | Reserved flag       |      1      |  STATIC-KNOWN  |
    | May Fragment flag   |      1      |     STATIC     |
    | Last Fragment flag  |      1      |  STATIC-KNOWN  |
    | Fragment Offset     |     13      |  STATIC-KNOWN  |
    | Time To Live        |      8      |    CHANGING    |
    | Protocol            |      8      |  STATIC-KNOWN  |
    | Header Checksum     |     16      |    INFERRED    |
    | Source Address      |     32      |   STATIC-DEF   |
    | Destination Address |     32      |   STATIC-DEF   |
    +---------------------+-------------+----------------+


   Version

     The version field states which IP version the packet is based on
     and packets with different values in this field must be handled by
     different IP stacks. For header compression, different compression
     profiles must also be used. When compressor and decompressor has
     negotiated which profile to use, the IP version is also well known
     to both parties. The field is therefore classified as STATIC-KNOWN.





Bormann (ed.)                                                 [Page 133]

INTERNET-DRAFT          Robust Header Compression           Oct 23, 2000


   Header Length

     As long as there are no options present in the IP header, the
     header length is constant and well known. If there are options, the
     fields would be STATIC, but we assume no options. The field is
     therefore classified as STATIC-KNOWN.


   Packet Length

     Information about the packet length is expected to be provided by
     the link layer. The field is therefore classified as INFERRED.


   Flags

     The Reserved flag must be set to zero and is therefore classified
     as STATIC-KNOWN. The May Fragment flag will be constant for all
     packets in a stream and is therefore classified as STATIC. Finally,
     the Last Fragment bit is expected to be zero because fragmentation
     is NOT expected, due to the small packet size expected. The Last
     Fragment bit is therefore classified as STATIC-KNOWN.


   Fragment Offset

     With the assumption that no fragmentation occurs, the fragment
     offset is always zero. The field is therefore classified as STATIC-
     KNOWN.


   Protocol

     This field is expected to have the same value in all packets of a
     packet stream. As for the version number, a certain compression
     profile can only handle a specific next header which means that
     this value is well known when profile has been negotiated. The
     field is therefore classified as STATIC-KNOWN.


   Header Checksum

     The header checksum protects individual hops from processing a
     corrupted header. When almost all IP header information is
     compressed away, there is no need to have this additional checksum;
     instead it can be regenerate at the decompressor side. The field is
     therefore classified as INFERRED.


   Source and Destination addresses




Bormann (ed.)                                                 [Page 134]

INTERNET-DRAFT          Robust Header Compression           Oct 23, 2000


     These fields are part of the definition of a stream and must thus
     be constant for all packets in the stream. The fields are therefore
     classified as STATIC-DEF.


   Summarizing the bits corresponding to the classes gives:

    +--------------+--------------+
    | Class        | Size (octets)|
    +--------------+--------------+
    | INFERRED     |      4       |
    | STATIC       |    1 bit     |
    | STATIC-DEF   |      8       |
    | STATIC-KNOWN |   3 +7 bits  |
    | CHANGING     |      4       |
    +--------------+--------------+


A.1.3.  UDP header fields

    +------------------+-------------+-------------+
    | Field            | Size (bits) |    Class    |
    +------------------+-------------+-------------+
    | Source Port      |     16      | STATIC-DEF  |
    | Destination Port |     16      | STATIC-DEF  |
    | Length           |     16      |  INFERRED   |
    | Checksum         |     16      |  CHANGING   |
    +------------------+-------------+-------------+


   Source and Destination ports

     These fields are part of the definition of a stream and must thus
     be constant for all packets in the stream. The fields are therefore
     classified as STATIC-DEF.


   Length

     This field is redundant and is therefore classified as INFERRED.


   Summarizing the bits corresponding to the classes gives:

    +------------+--------------+
    | Class      | Size (octets)|
    +------------+--------------+
    | INFERRED   |       2      |
    | STATIC-DEF |       4      |
    | CHANGING   |       2      |
    +------------+--------------+



Bormann (ed.)                                                 [Page 135]

INTERNET-DRAFT          Robust Header Compression           Oct 23, 2000




A.1.4.  RTP header fields

    +-----------------+-------------+----------------+
    | Field           | Size (bits) |     Class      |
    +-----------------+-------------+----------------+
    | Version         |      2      |  STATIC-KNOWN  |
    | Padding         |      1      |     STATIC     |
    | Extension       |      1      |     STATIC     |
    | CSRC Counter    |      4      |    CHANGING    |
    | Marker          |      1      |    CHANGING    |
    | Payload Type    |      7      |    CHANGING    |
    | Sequence Number |     16      |    CHANGING    |
    | Timestamp       |     32      |    CHANGING    |
    | SSRC            |     32      |   STATIC-DEF   |
    | CSRC            |   0(-480)   |    CHANGING    |
    +-----------------+-------------+----------------+


   Version

     There exists only one working RTP version and that is version 2.
     The field is therefore classified as STATIC-KNOWN.


   Padding

     The use of this field depends on the application, but when payload
     padding is used it is likely to be present in all packets. The
     field is therefore classified as STATIC.


   Extension

     If RTP extensions is used by the application, it is likely to be an
     extension present in all packets (but use of extensions is very
     uncommon). However, for safety's sake this field is classified as
     STATIC and not STATIC-KNOWN.


   SSRC

     This field is part of the definition of a stream and must thus be
     constant for all packets in the stream. The field is therefore
     classified as STATIC-DEF.








Bormann (ed.)                                                 [Page 136]

INTERNET-DRAFT          Robust Header Compression           Oct 23, 2000




   Summarizing the bits corresponding to the classes gives:

    +--------------+--------------+
    | Class        | Size (octets)|
    +--------------+--------------+
    | STATIC       |    2 bits    |
    | STATIC-DEF   |      4       |
    | STATIC-KNOWN |    2 bits    |
    | CHANGING     |  7.5(-67.5)  |
    +--------------+--------------+


A.1.5.  Summary for IP/UDP/RTP

   If we summarize this for IP/UDP/RTP we get:

    +----------------+--------------+--------------+
    | Class \ IP ver | IPv6 (octets)| IPv4 (octets)|
    +----------------+--------------+--------------+
    | INFERRED       |       4      |       6      |
    | STATIC         |    2 bits    |    3 bits    |
    | STATIC-DEF     |     42.5     |      16      |
    | STATIC-KNOWN   |   1 +6 bits  |   4 +1 bit   |
    | CHANGING       |  11.5(-71.5) |  13.5(-73.5) |
    +----------------+--------------+--------------+
    | Total          |   60(-120)   |   40(-100)   |
    +----------------+--------------+--------------+


A.2.  Analysis of change patterns of header fields

   To design suitable mechanisms for efficient compression of all header
   fields, their change patterns must be analyzed. For this reason, an
   extended classification is done based on the general classification
   in A.1, considering the fields which were labeled CHANGING in that
   classification. Different applications will use the fields in
   different ways, which may affect their behavior. When this is the
   case, typical behavior for conversational audio and video will be
   discussed.

   The CHANGING fields are separated into five different subclasses:

   STATIC                These are fields that were classified as
                         CHANGING on a general basis, but are classified
                         as STATIC here due to certain additional
                         assumptions.

   SEMISTATIC            These fields are STATIC most of the time.
                         However, occasionally the value changes but



Bormann (ed.)                                                 [Page 137]

INTERNET-DRAFT          Robust Header Compression           Oct 23, 2000


                         reverts to its original value after a known
                         number of packets.

   RARELY-CHANGING (RC)  These are fields that change their values
                         occasionally and then keep their new values.

   ALTERNATING           These fields alternate between a small number
                         of different values.

   IRREGULAR             These, finally, are the fields for which no
                         useful change pattern can be identified.

   To further expand the classification possibilities without increasing
   complexity, the classification can be done either according to the
   values of the field and/or according to the values of the deltas for
   the field.

   When the classification is done, other details are also stated
   regarding possible additional knowledge about the field values and/or
   field deltas, according to the classification. For fields classified
   as STATIC or SEMISTATIC, the case could be that the value of the
   field is not only STATIC but also well KNOWN a priori (two states for
   SEMISTATIC fields). For fields with non-irregular change behavior, it
   could be known that changes usually are within a LIMITED range
   compared to the maximal change for the field. For other fields, the
   values are completely UNKNOWN.

   Table A.1 classifies all the CHANGING fields based on their expected
   change patterns, especially for conversational audio and video.



    +------------------------+-------------+-------------+-------------+
    |         Field          | Value/Delta |    Class    |  Knowledge  |
    +========================+=============+=============+=============+
    |             Sequential |    Delta    |    STATIC   |    KNOWN    |
    |             -----------+-------------+-------------+-------------+
    | IPv4 Id:    Seq. jump  |    Delta    |      RC     |   LIMITED   |
    |             -----------+-------------+-------------+-------------+
    |             Random     |    Value    |  IRREGULAR  |   UNKNOWN   |
    +------------------------+-------------+-------------+-------------+
    | IP TOS / Tr. Class     |    Value    |      RC     |   UNKNOWN   |
    +------------------------+-------------+-------------+-------------+
    | IP TTL / Hop Limit     |    Value    | ALTERNATING |   LIMITED   |
    +------------------------+-------------+-------------+-------------+
    |               Disabled |    Value    |    STATIC   |    KNOWN    |
    | UDP Checksum: ---------+-------------+-------------+-------------+
    |               Enabled  |    Value    |  IRREGULAR  |   UNKNOWN   |
    +------------------------+-------------+-------------+-------------+
    |                 No mix |    Value    |    STATIC   |    KNOWN    |
    | RTP CSRC Count: -------+-------------+-------------+-------------+



Bormann (ed.)                                                 [Page 138]

INTERNET-DRAFT          Robust Header Compression           Oct 23, 2000


    |                 Mixed  |    Value    |      RC     |   LIMITED   |
    +------------------------+-------------+-------------+-------------+
    | RTP Marker             |    Value    |  SEMISTATIC | KNOWN/KNOWN |
    +------------------------+-------------+-------------+-------------+
    | RTP Payload Type       |    Value    |      RC     |   UNKNOWN   |
    +------------------------+-------------+-------------+-------------+
    | RTP Sequence Number    |    Delta    |    STATIC   |    KNOWN    |
    +------------------------+-------------+-------------+-------------+
    | RTP Timestamp          |    Delta    |      RC     |   LIMITED   |
    +------------------------+-------------+-------------+-------------+
    |                 No mix |      -      |      -      |      -      |
    | RTP CSRC List:  -------+-------------+-------------+-------------+
    |                 Mixed  |    Value    |      RC     |   UNKNOWN   |
    +------------------------+-------------+-------------+-------------+

           Table A.1 : Classification of CHANGING header fields

   The following subsections discuss the various header fields in
   detail. Note that table A.1 and the discussions below do not consider
   changes caused by loss or reordering before the compression point.


A.2.1.  IPv4 Identification

   The Identification field (IP ID) of the IPv4 header is there to
   identify which fragments constitute a datagram when reassembling
   fragmented datagrams. The IPv4 specification does not specify exactly
   how this field is to be assigned values, only that each packet should
   get an IP ID that is unique for the source-destination pair and
   protocol for the time the datagram (or any of its fragments) could be
   alive in the network. This means that assignment of IP ID values can
   be done in various ways, which we have separated into three classes.

   Sequential

      This assignment policy keeps a separate counter for each outgoing
      packet stream and thus the IP ID value will increment by one for
      each packet in the stream. Therefore, the delta value of the
      field is constant and well known a priori. When RTP is used on
      top of UDP and IP, the IP ID value follows the RTP sequence
      number. This assignment policy is the most desirable for header
      compression purposes but its usage is not as common as it should
      be. The reason is that it can be realized only if UDP and IP are
      implemented together so that UDP, which separates packet streams
      by the port identification, can make IP use separate ID counters
      for each packet stream.

   Sequential jump

      This is the most common assignment policy in today's IP stacks.
      The difference from the sequential method is that only one



Bormann (ed.)                                                 [Page 139]

INTERNET-DRAFT          Robust Header Compression           Oct 23, 2000


      counter is used for all connections. When the sender is running
      more than one packet stream simultaneously, the IP ID can
      increase by more than one. The IP ID values will be much more
      predictable and require less bits to transfer than random values,
      and the packet-to-packet increment (determined by the number of
      active outgoing packet streams and sending frequencies) will
      usually be limited.

   Random

      Some IP stacks assign IP ID values using a pseudo-random number
      generator. There is thus no correlation between the ID values of
      subsequent datagrams. Therefore there is no way to predict the IP
      ID value for the next datagram. For header compression purposes,
      this means that the IP ID field needs to be sent uncompressed
      with each datagram, resulting in two extra octets of header. IP
      stacks in cellular terminals SHOULD NOT use this IP ID assignment
      policy.

   It should be noted that the ID is an IPv4 mechanism and is therefore
   not needed at all in IPv6 profiles. For IPv4 the ID could be handled
   in three different ways. Firstly, we have the inefficient but
   reliable solution where the ID field is sent as-is in all packets,
   increasing the compressed headers with two octets. This is the best
   way to handle the ID field if the sender uses random assignment of
   the ID field. Secondly, there can be solutions with more flexible
   mechanisms requiring less bits for the ID handling as long as
   sequential jump assignment is used. Such solutions will probably
   require even more bits if random assignment is used by the sender.
   Knowledge about the sender's assignment policy could therefore be
   useful when choosing between the two solutions above. Finally, even
   for IPv4, header compression could be designed without any additional
   information for the ID field included in compressed headers. To use
   such schemes, it must be known that the sender makes use of the pure
   sequential assignment policy for the ID field. That might not be
   possible to know, which implies that the applicability of such
   solutions is very uncertain. However, designers of IPv4 stacks for
   cellular terminals SHOULD use the sequential policy.


A.2.2.  IP Traffic-Class / Type-Of-Service

   The Traffic-Class (IPv6) or Type-Of-Service (IPv4) field is expected
   to be constant during the lifetime of a packet stream or to change
   relatively seldom.









Bormann (ed.)                                                 [Page 140]

INTERNET-DRAFT          Robust Header Compression           Oct 23, 2000


A.2.3.  IP Hop-Limit / Time-To-Live

   The Hop-Limit (IPv6) or Time-To-Live (IPv4) field is expected to be
   constant during the lifetime of a packet stream or to alternate
   between a limited number of values due to route changes.


A.2.4.  UDP Checksum

   The UDP checksum is optional. If disabled, its value is constantly
   zero and could be compressed away. If enabled, its value depends on
   the payload, which for compression purposes is equivalent to it
   changing randomly with every packet.


A.2.5.  RTP CSRC Counter

   This is a counter indicating the number of CSRC items present in the
   CSRC list. This number is expected to be almost constant on a packet-
   to-packet basis and change by small amount. As long as no RTP mixer
   is used, the value of this field is zero.

A.2.6.  RTP Marker

   For audio the marker bit should be set only in the first packet of a
   talkspurt while for video it should be set in the last packet of
   every picture. This means that in both cases the RTP marker is
   classified as SEMISTATIC with well-known values for both states.


A.2.7.  RTP Payload Type

   Changes of the RTP payload type within a packet stream are expected
   to be rare. Applications could adapt to congestion by changing
   payload type and/or frame sizes, but that is not expected to happen
   frequently.


A.2.8.  RTP Sequence Number

   The RTP sequence number will be incremented by one for each packet
   sent.


A.2.9.  RTP Timestamp

   In the audio case:

      As long as there are no pauses in the audio stream, the RTP
      timestamp will be incremented by a constant delta, corresponding
      to the number of samples in the speech frame. It will thus mostly



Bormann (ed.)                                                 [Page 141]

INTERNET-DRAFT          Robust Header Compression           Oct 23, 2000


      follow the RTP sequence number. When there has been a silent
      period and a new talkspurt begins, the timestamp will jump in
      proportion to the length of the silent period. However, the
      increment will probably be within a relatively limited range.

   In the video case:

      The timestamp change between two consecutive packets will either
      be zero or increase by a multiple of a fixed value corresponding
      to the picture clock frequency. The timestamp can also decrease
      by a multiple of the fixed value if B-pictures are used. The
      delta interval, expressed as a multiple of the picture clock
      frequency, is in most cases very limited.


A.2.10.  RTP Contributing Sources (CSRC)

   The participants in a session, which are identified by the CSRC
   fields, are expected to be almost the same on a packet-to-packet
   basis with relatively few additions or removals. As long as RTP
   mixers are not used, no CSRC fields are present at all.

A.3.  Header compression strategies

   This section elaborates on what has been done in previous sections.
   Based in the classifications, recommendations are given on how to
   handle the various fields in the header compression process. Seven
   different actions are possible and these are listed together with the
   fields to which each action applies.


A.3.1.  Do not send at all

   The fields that have well known values a priori do not have to be
   sent at all. These are:

   - IP Version
   - IPv6 Payload Length
   - IPv6 Next Header
   - IPv4 Header Length
   - IPv4 Reserved Flag
   - IPv4 Last Fragment Flag
   - IPv4 Fragment Offset
   - IPv4 Protocol
   - UDP Checksum (if disabled)
   - RTP Version








Bormann (ed.)                                                 [Page 142]

INTERNET-DRAFT          Robust Header Compression           Oct 23, 2000


A.3.2.  Transmit only initially

   The fields that are constant throughout the lifetime of the packet
   stream have to be transmitted and correctly delivered to the
   decompressor only once. These are:

   - IP Source Address
   - IP Destination Address
   - IPv6 Flow Label
   - IPv4 May Fragment Flag
   - UDP Source Port
   - UDP Destination Port
   - RTP Padding Flag
   - RTP Extension Flag
   - RTP SSRC


A.3.3.  Transmit initially, but be prepared to update

   The fields that are changing only occasionally must be transmitted
   initially but there must also be a way to update these fields with
   new values if they change. These fields are:

   - IPv6 Traffic Class
   - IPv6 Hop Limit
   - IPv4 Type Of Service (TOS)
   - IPv4 Time To Live (TTL)
   - RTP CSRC Counter
   - RTP Payload Type
   - RTP CSRC List


A.3.4.  Be prepared to update or send as-is frequently

   For fields that normally are either constant or whose values can be
   deduced from some other field but frequently diverge from that
   behavior, there must be an efficient way to update the field value or
   send it as-is in some packets. Those fields are:

   - IPv4 Identification (if not sequentially assigned)
   - RTP Marker
   - RTP Timestamp


A.3.5.  Guarantee continuous robustness

   Fields that behave like a counter with a fixed delta for ALL packets,
   the only requirement on the transmission encoding is that packet
   losses between compressor and decompressor must be tolerable. If more
   than one such field exists, all these can be communicated together.
   Such fields can also be used to interpret the values for fields



Bormann (ed.)                                                 [Page 143]

INTERNET-DRAFT          Robust Header Compression           Oct 23, 2000


   listed in the previous section. Fields that have this counter
   behavior are:

   - IPv4 Identification (if sequentially assigned)
   - RTP Sequence Number


A.3.6.  Transmit as-is in all packets

   Fields that have completely random values for each packet must be
   included as-is in all compressed headers. Those fields are:

   - IPv4 Identification (if randomly assigned)
   - UDP Checksum (if enabled)


A.3.7.  Establish and be prepared to update delta

   Finally, there is a field that is usually increasing by a fixed delta
   and is correlated to another field. For this field it would make
   sense to make that delta part of the context state. The delta must
   then be possible to initiate and update in the same way as the fields
   listed in A.3.3. The field to which this applies is:

   - RTP Timestamp





























Bormann (ed.)                                                 [Page 144]

INTERNET-DRAFT          Robust Header Compression           Oct 23, 2000



Appendix B.  Encoding Examples

   [[Editor's note: Not quite finished updating this with current
   terminology.]]

B.1.  Basic W-LSB

   The examples below illustrate the operation of window-based LSB-
   coding under various scenarios.  The field values used in the
   examples could correspond to any fields that we wish to compress.
   The examples illustrate the scenario where the compressed field has
   resolution of one bit.

      Example 1: Normal operation (no packet loss prior to compressor,
   no reodering prior to compressor).

   Suppose packets with header fields 279, 280, 281, 282, and 283 have
   been sent, and 279 and 283 are fields of potential reference packets.

   The current window is {279, 283}.  When a packet with field value 284
   is received next, W-LSB computes the following values:

      New Value   VMax    VMin             r                   # LSBs
         284      283     279    max[|284-279|,|284-283|]=5       4

   The window is unmodified if we assuming the new packet {284} is not a
   potential reference.  The field is encoded using 4 bits in this case,
   and the actual encoded value is the 4 least significant bits of 284
   (10011100) which = 1100.

      Example 2:  Packet Loss prior to compressor.

   Suppose packets with header fields 279, 280, 281, 282, and 283 have
   been sent, and 279 and 283 are fields of potential reference packets
   such that the VSW is again {279, 283}.

   If a packet with field value = 290 is received next, W-LSB computes
   the following values

      New Value  VMax  VMin             r                # LSBs
        290      283   279   max[|290-283|,|290-279|]=11    5

   So the field is encoded using 5 bits.  Actual encoded value is the 5
   LSBs of 290 (100100010) which = 00010.

   If we assume the new value is a potential reference, the new window
   is {279, 283, 290}.

      Example 3:  Packet Misordering prior to compressor.




Bormann (ed.)                                                 [Page 145]

INTERNET-DRAFT          Robust Header Compression           Oct 23, 2000


   Suppose packets with header fields 279, 280, 281, 282, and 283 have
   been sent, and 279 and 283 are fields of potential reference packets
   such that the window is again {279, 283}.

   If a packet with field value = 278 is received next, W-LSB computes
   the following values

      New Value     VMax    VMin             r                  # LSBs
        278         283     279   max[|278-283|,|278-279|]=5      4

   So the field is encoded using 4 bits.  Actual encoded value is the 4
   LSBs of 278 (10010110) which = 0110.

   If we assume the new value is a potential reference, the new window
   is {283, 290, 278}.

   The decompressor behavior in all the example cases is the same- it
   uses as a reference a specific decompressed header field value. For
   example let's assume that the last correctly decompressed packet
   which qualifies as a reference was the packet with header field =
   291.  Now suppose the encoded field value of 303 (10001111) is
   received and = 01111.  The two values closest values to 291 which
   have LSBs = 01111 are 271 and 303.  303 is closest, therefore it is
   correctly selected as the uncompressed field value.

B.2.  Timer-Based Compression

   As a an example of timer-based compression, consider the case of a
   voice codec (20 ms), such that TS_stride = 160.  Assume T_current and
   p_TS_current are 357 and 351, respectively, and that we have sliding
   window TSW which contains the following values 4 entries:

           j           T_j         p_TS_j

           1            9            7
           2            8            6
           3            7            4
           4            3            1

      j above is the packet number.

      In this case we have

      Network_jitter(1)=|(357-9)-(351-7)|=4 (80 ms Network Jitter)
      Network_jitter(2)=|(357-8)-(351-6)|=4  (80 ms Network Jitter)
      Network_jitter(3)=|(357-7)-(351-4)|=3 (60 ms Network Jitter)
      Network_jitter(4)=|(357-3)-(351-1)|=4  (80 ms Network Jitter)

      So Max_Network_Jitter = 4.





Bormann (ed.)                                                 [Page 146]

INTERNET-DRAFT          Robust Header Compression           Oct 23, 2000


      We assume a maximum CD-CC jitter of 2 (40 ms); the total jitter to
   be handled in this case is then

           J = 4 + 2 + 2 = 8 packets (160 ms)

      and k = 5 bits (since 2 * 5 + 1 < 2^5).  The compressor sends the
   5 LSBs of p_TS_current to the decompressor (351 = 101011111, so the
   encoded TS value = 11111).

      When the decompressor receives this value, it first attempts to
   estimate the timestamp by computing the time difference between the
   last reference established and the current packet

            T_current - T_ref, where T_ref is the value of the wall
   clock time at which the reference headers was received by the
   decompressor


      That value is added to p_TS_ref, the packed RTP TS of the
   reference header, to get the estimate.

      Assume that at the decompressor packet #3 is used as the
   reference:


           - T_current = 359
           - T_ref = 7
           - p_TS_ref = 4

      Note:

      T_current is picked here as any value; the difference between it
   and T_ref represents the length of the silence interval as observed
   at the decompressor.  Then:

           T_current - T_ref = 359 - 7 = 352
           p_TS_current(estimate) = 352 + 4 = 356


      The decompressor searches for the closest value to 356 which has,
   in this case, LSBs = 11111.  The value in this case is 351, the
   original p_TS.


      If instead the compressor were to send the timestamp jump as
   simply the difference in consecutive packed RTP Timestamps, that
   value would be

      p_TS_current - p_TS_ref = 351-4 = 347 = 101011011

      So over twice as many bits would be sent for a silence interval of



Bormann (ed.)                                                 [Page 147]

INTERNET-DRAFT          Robust Header Compression           Oct 23, 2000



           347 (20 ms) = 6.94 seconds

      Due to basic conversational real-time requirements, the cumulative
   jitter in normal operation is expected to be at most only a few times
   T stride for voice.  For this reason, the FO payload formats in
   section 4.3 are optimized (in terms of representing different k-
   length encoded TS values) for the case of k=4 (handles up to 16
   discrepencies in the timestamp).  The remaining formats allow a wide
   range of jitter conditions (outside of just voice) to be handled as
   well.







































   This Internet-Draft expires April 22, 2001.



