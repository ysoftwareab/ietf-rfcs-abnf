smallest = largest - ack_range

largest = previous_smallest - gap - 2

v = data.next_byte()
prefix = v >> 6
length = 1 << prefix

v = v & 0x3f
v = (v << 8) + data.next_byte()
num_unacked = full_pn + 1
num_unacked = full_pn - largest_acked

min_bits = log(num_unacked, 2) + 1
num_bytes = ceil(min_bits / 8)

expected_pn  = largest_pn + 1
pn_win       = 1 << pn_nbits
pn_hwin      = pn_win / 2
pn_mask      = pn_win - 1
candidate_pn = (expected_pn & ~pn_mask) | truncated_pn
