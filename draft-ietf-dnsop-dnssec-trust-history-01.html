<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="en"><head><title>DNSSEC Trust Anchor History Service</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="description" content="DNSSEC Trust Anchor History Service">
<meta name="keywords" content="DNS, DNSSEC, DNSKEY, history, rollover, trust anchor">
<meta name="generator" content="xml2rfc v1.35 (http://xml.resource.org/)">
<meta name="viewport" content="width=600;" />
<style type='text/css'><!--
        body {
                font-family: verdana, charcoal, helvetica, arial, sans-serif;
                font-size: 85%;
		max-width: 40em; 
		color: #000; background-color: #FFF;
                margin: 2em;
        }
        h1, h2, h3, h4, h5, h6 {
                font-family: helvetica, monaco, "MS Sans Serif", arial, sans-serif;
                font-weight: bold; font-style: normal;
        }
        h1 { color: #900; background-color: transparent; text-align: right; }
        h3 { color: #333; background-color: transparent; }

        td.RFCbug {
                font-size: x-small; text-decoration: none;
                width: 30px; height: 30px; padding-top: 2px;
                text-align: justify; vertical-align: middle;
                background-color: #000;
        }
        td.RFCbug span.RFC {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: bold; color: #666;
        }
        td.RFCbug span.hotText {
                font-family: charcoal, monaco, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: normal; text-align: center; color: #FFF;
        }

        table.TOCbug { width: 30px; height: 15px; }
        td.TOCbug {
                text-align: center; width: 30px; height: 15px;
                color: #FFF; background-color: #900;
        }
        td.TOCbug a {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, sans-serif;
                font-weight: bold; font-size: x-small; text-decoration: none;
                color: #FFF; background-color: transparent;
        }

        td.header {
                font-family: arial, helvetica, sans-serif; font-size: x-small;
                vertical-align: top; width: 33%;
                color: #FFF; background-color: #666;
        }
        td.author { font-weight: bold; font-size: x-small; margin-left: 4em; }
        td.author-text { font-size: x-small; }

        /* info code from SantaKlauss at http://www.madaboutstyle.com/tooltip2.html */
        a.info {
                /* This is the key. */
                position: relative;
                z-index: 24;
                text-decoration: none;
        }
        a.info:hover {
                z-index: 25;
                color: #FFF; background-color: #900;
        }
        a.info span { display: none; }
        a.info:hover span.info {
                /* The span will display just on :hover state. */
                display: block;
                position: absolute;
                font-size: smaller;
                top: 2em; left: -5em; width: 15em;
                padding: 2px; border: 1px solid #333;
                color: #900; background-color: #EEE;
                text-align: left;
        }

        a { font-weight: bold; }
        a:link    { color: #900; background-color: transparent; }
        a:visited { color: #633; background-color: transparent; }
        a:active  { color: #633; background-color: transparent; }

        p { margin-left: 2em; margin-right: 2em; }
        p.copyright { font-size: x-small; }
        p.toc { font-size: 85%;
		max-width: 40em; 
		font-weight: bold; margin-left: 3em; }
        table.toc { margin: 0 0 0 3em; padding: 0; border: 0; vertical-align: text-top; }
        td.toc { font-size: 85%;
		max-width: 40em; 
		font-weight: bold; vertical-align: text-top; }

        ol.text { margin-left: 2em; margin-right: 2em; }
        ul.text { margin-left: 2em; margin-right: 2em; }
        li      { margin-left: 3em; }

        /* RFC-2629 <spanx>s and <artwork>s. */
        em     { font-style: italic; }
        strong { font-weight: bold; }
        dfn    { font-weight: bold; font-style: normal; }
        cite   { font-weight: normal; font-style: normal; }
        tt     { color: #036; }
        tt, pre, pre dfn, pre em, pre cite, pre span {
                font-family: "Courier New", Courier, monospace; font-size: small;
        }
        pre {
                text-align: left; padding: 4px;
                color: #000; background-color: #CCC;
        }
        pre dfn  { color: #900; }
        pre em   { color: #66F; background-color: #FFC; font-weight: normal; }
        pre .key { color: #33C; font-weight: bold; }
        pre .id  { color: #900; }
        pre .str { color: #000; background-color: #CFF; }
        pre .val { color: #066; }
        pre .rep { color: #909; }
        pre .oth { color: #000; background-color: #FCF; }
        pre .err { background-color: #FCC; }

        /* RFC-2629 <texttable>s. */
        table.all, table.full, table.headers, table.none {
                font-size: 85%;
		max-width: 40em; 
		text-align: center; border-width: 2px;
                vertical-align: top; border-collapse: collapse;
        }
        table.all, table.full { border-style: solid; border-color: black; }
        table.headers, table.none { border-style: none; }
        th {
                font-weight: bold; border-color: black;
                border-width: 2px 2px 3px 2px;
        }
        table.all th, table.full th { border-style: solid; }
        table.headers th { border-style: none none solid none; }
        table.none th { border-style: none; }
        table.all td {
                border-style: solid; border-color: #333;
                border-width: 1px 2px;
        }
        table.full td, table.headers td, table.none td { border-style: none; }

        hr { height: 1px; }
        hr.insert {
                width: 80%; border-style: none; border-width: 0;
                color: #CCC; background-color: #CCC;
        }
--></style>
</head>
<body>
<table summary="layout" width="66%" border="0" cellpadding="0" cellspacing="0"><tr><td><table summary="layout" width="100%" border="0" cellpadding="2" cellspacing="1">
<tr><td class="header">Domain Name System Operations</td><td class="header">W. Wijngaards</td></tr>
<tr><td class="header">Internet-Draft</td><td class="header">O. Kolkman</td></tr>
<tr><td class="header">Intended status: Standards Track</td><td class="header">NLnet Labs</td></tr>
<tr><td class="header">Expires: August 26, 2010</td><td class="header">February 22, 2010</td></tr>
</table></td></tr></table>
<h1><br />DNSSEC Trust Anchor History Service<br />draft-ietf-dnsop-dnssec-trust-history-01</h1>

<h3>Abstract</h3>

<p> When DNS validators have trusted keys, but have been
offline for a longer period, key rollover will fail and they are stuck
with stale trust anchors.  History service allows validators to query for
older DNSKEY RRsets and pick up the rollover trail where they left off.

</p>
<h3>Requirements Language</h3>

<p>The key words &quot;MUST&quot;, &quot;MUST NOT&quot;, 
&quot;REQUIRED&quot;, &quot;SHALL&quot;, &quot;SHALL NOT&quot;,
&quot;SHOULD&quot;, &quot;SHOULD NOT&quot;, &quot;RECOMMENDED&quot;,
&quot;MAY&quot;, and &quot;OPTIONAL&quot; in this document are to be
interpreted as described in  <a class='info' href='#RFC2119'>RFC 2119<span> (</span><span class='info'>Bradner, S., &ldquo;Key words for use in RFCs to Indicate Requirement Levels,&rdquo; March&nbsp;1997.</span><span>)</span></a> [RFC2119].
</p>
<h3>Status of This Memo</h3>
<p>
This Internet-Draft is submitted to IETF in full
conformance with the provisions of BCP&nbsp;78 and BCP&nbsp;79.</p>
<p>
Internet-Drafts are working documents of the Internet Engineering
Task Force (IETF), its areas, and its working groups.
Note that other groups may also distribute working documents as
Internet-Drafts.</p>
<p>
Internet-Drafts are draft documents valid for a maximum of six months
and may be updated, replaced, or obsoleted by other documents at any time.
It is inappropriate to use Internet-Drafts as reference material or to cite
them other than as &ldquo;work in progress.&rdquo;</p>
<p>
The list of current Internet-Drafts can be accessed at
<a href='http://www.ietf.org/ietf/1id-abstracts.txt'>http://www.ietf.org/ietf/1id-abstracts.txt</a>.</p>
<p>
The list of Internet-Draft Shadow Directories can be accessed at
<a href='http://www.ietf.org/shadow.html'>http://www.ietf.org/shadow.html</a>.</p>
<p>
This Internet-Draft will expire on August 26, 2010.</p>

<h3>Copyright Notice</h3>
<p>
Copyright (c) 2010 IETF Trust and the persons identified as the
document authors.  All rights reserved.</p>
<p>
This document is subject to BCP 78 and the IETF Trust's Legal
Provisions Relating to IETF Documents
(http://trustee.ietf.org/license-info) in effect on the date of
publication of this document.  Please review these documents
carefully, as they describe your rights and restrictions with respect
to this document. Code Components extracted from this document must
include Simplified BSD License text as described in Section 4.e of
the Trust Legal Provisions and are provided without warranty as
described in the BSD License.</p>

<a name="anchor1"></a><br /><hr />
<a name="rfc.section.1"></a><h3>1.&nbsp;
Introduction</h3>

<p> This memo defines a trust history service for DNS validators -- the
component in a resolver that performs DNSSEC <a class='info' href='#RFC4034'>[RFC4034]<span> (</span><span class='info'>Arends, R., Austein, R., Larson, M., Massey, D., and S. Rose, &ldquo;Resource Records for the DNS Security Extensions,&rdquo; March&nbsp;2005.</span><span>)</span></a>
validation, validator for short.  
</p>
<p> A validator that has been offline or missed an (emergency)
rollover can use this service to reconfigure themselves with the
current trust-anchor.  Using a newly defined resource record (RR)
that links old DNSKEYS together, the TALINK RR, a validator fetches
old DNSKEY RRsets and checks they form a chain to the latest key (see
<a class='info' href='#TALINK'>Section&nbsp;2<span> (</span><span class='info'>The  TALINK Resource Record</span><span>)</span></a>). The lists of old DNSKEYS, linked with the
TALINK RRs, do not necessarily need to be published in the zone for
which the DNSKEY history is being maintained but can be published in
any DNS domain.  We will call the entity that offers the trust history
the History Provider.  The choice of the History Provider is made by
the maintainer of the validator, possibly based on a hint provided,
using the TALINK, by the zone owner. 
</p>
<p> The algorithm that the validator uses to construct a history
and reconfigure a new key is detailed in <a class='info' href='#lookup'>Section&nbsp;3<span> (</span><span class='info'>Trust History Lookup</span><span>)</span></a>. The
algorithms for how providers of trust history can fetch the DNSKEY data
as published by the zone they track and publish that are explained in
<a class='info' href='#tracker'>Section&nbsp;4<span> (</span><span class='info'>Trust History Tracker</span><span>)</span></a>. 
</p>
<a name="TALINK"></a><br /><hr />
<a name="rfc.section.2"></a><h3>2.&nbsp;
The  TALINK Resource Record</h3>

<p> The DNS Resource Record type TALINK (decimal 58) ties the elements
of a linked list of DNSKEY RRs together. 
</p>
<p> The rdata consists of two domain names.  The first name is the start,
or previous name, and the other name the end or next name in the list.
The empty label '.' is used at the endpoints of the list. 
</p>
<p> The presentation format is the two domain names.  The wire encoding
is the two domain names, with no compression so the type can be treated
according to <a class='info' href='#RFC3597'>[RFC3597]<span> (</span><span class='info'>Gustafsson, A., &ldquo;Handling of Unknown DNS Resource Record (RR) Types,&rdquo; September&nbsp;2003.</span><span>)</span></a>.  The list is a double linked list,
because this empowers low memory hosts to perform consistency checks. 
</p>
<a name="lookup"></a><br /><hr />
<a name="rfc.section.3"></a><h3>3.&nbsp;
Trust History Lookup</h3>

<p> This is the algorithm that a validator uses to detect and resolve
the situation in which a trust-anchor is out of sync with the DNSKEYs
published by a zone owner. The algorithm uses the TALINK RR type
which is used to link various old DNSKEYs as published by the History
Provider, to arrive from the outdated configured Trust Anchor to one
that matches the current DNSKEY. The TALINK RR type is defined in 
<a class='info' href='#TALINK'>Section&nbsp;2<span> (</span><span class='info'>The  TALINK Resource Record</span><span>)</span></a>. 
</p>
<p> When the algorithm below results in failure the trust history cannot
be build and a new trust anchor will need to be re-configured using
another mechanism. 
</p>
<p>
  </p>
<blockquote class="text"><dl>
<dt>Step 1:</dt>
<dd> 
      The validator performs a DNSKEY lookup to the target zone, which
      looks like any other initial DNSKEY lookup that the validator
      needs to match a trust anchor to the currently used DNSKEY RR
      set.  If the keyset verifies with the trust anchor currently
      held, the trust-anchor is not out of sync. Otherwise, store the
      DNSKEY RR set as result. The algorithm will successfully build
      a linked list to this DNSKEY RR, or delete the trust point, or fail.
    
</dd>
<dt></dt>
<dd> 
      All nameservers (the ones authoritative for the zone or the upstream
      resolver caches when the validator is not full resolver) SHOULD be
      checked to make sure the DNSKEY RR sets are the same.  The results
      can differ if a key-rollover is in progress and not all nameservers
      are in sync yet. This case can be detected by checking that the
      older keyset signs the newer and take the newer as result keyset.
      The keysets are distinguished by the average over the middle of the
      inception and expiration dates of the signatures that are validated
      by the keyset itself.  Otherwise, the history lookup fails.  If the
      check fails then the inconsistency may be the result of spoofing,
      or compromise of (DNS) infrastructure elements.
    
</dd>
<dt>Step 2:</dt>
<dd> 
      Fetch the trust history list end points.  Perform a query of
      QTYPE TALINK and QNAME the domain name that is configured to be
      the History Provider for the particular domain you are trying to
      update the trust-anchor for.
    
</dd>
<dt>Step 3:</dt>
<dd>
      Go backwards through the trust history list as provided by the
      TALINK linked list. Verify that the keyset validly signs the next
      keyset.  This is <a class='info' href='#RFC4034'>[RFC4034]<span> (</span><span class='info'>Arends, R., Austein, R., Larson, M., Massey, D., and S. Rose, &ldquo;Resource Records for the DNS Security Extensions,&rdquo; March&nbsp;2005.</span><span>)</span></a> validation, but the RRSIG
      expiration date is ignored. [Editor note: Are we shure that there
      are no server implementations that will not serve expired RRSIG,
      are such 'smart' servers allowed by the specs? In other words do we
      need clarification in the DNSSEC-updates document?]  Replace the
      owner domain name with the target zone name for verification.
      One of the keys that signs the next keyset MUST have the SEP
      bit set.  The middle of inception and expiration date from the
      valid signature MUST be older than that of the signature that
      validates the next keys in the list.  Query type TALINK to get
      previous and next locations.
    
</dd>
<dt></dt>
<dd>
      If all SEP keys have the REVOKE flag set at this step, and the
      keyset is signed by all SEP keys, then continue but store that
      the end result is that the trust point is deleted, see <a class='info' href='#RFC5011'>Section 5<span> (</span><span class='info'>StJohns, M., &ldquo;Automated Updates of DNS Security (DNSSEC) Trust Anchors,&rdquo; September&nbsp;2007.</span><span>)</span></a> [RFC5011].
    
</dd>
<dt></dt>
<dd> 
      If all SEP keys are of an unknown algorithm at this step,
      continue and at the next step, when you verify if the keyset
      signs validly: if false, continue with result a failure, if true,
      continue with the end result that the trust point is deleted.
      Thus, the keysets with unknown algorithms are stepped over with an
      end result of failure because the validator cannot determine if
      unknown algorithm signatures are valid, until the oldest keyset
      with unknown algorithms is signed by a known algorithm and the
      result is set to deletion and step 3 continues to a known key.
    
</dd>
<dt>Step 4:</dt>
<dd> 
      When the trust anchor currently held by the validator verifies
      the keyset, the algorithm is done.  The validator SHOULD store
      the result on stable storage.  Use the new trust anchor for
      validation (if using <a class='info' href='#RFC5011'>[RFC5011]<span> (</span><span class='info'>StJohns, M., &ldquo;Automated Updates of DNS Security (DNSSEC) Trust Anchors,&rdquo; September&nbsp;2007.</span><span>)</span></a>, put it in state
      VALID). 
    
</dd>
</dl></blockquote><p>

</p>
<a name="tracker"></a><br /><hr />
<a name="rfc.section.4"></a><h3>4.&nbsp;
Trust History Tracker</h3>

<p>
  External trackers can poll the target zone DNSKEY RRset regularly.
  Ignore date changes in the RRSIG.  Ignore changes to keys with no SEP
  flag.  Copy the newly polled DNSKEY RRset and RRSIGs, change the owner
  name to a new name at the history location.  Publish the new RRset and
  TALINK records to make it the last element in the list.  Update the
  TALINK that advertises the first and last name. 

</p>
<p> Integrated into the rollover, the keys are stored in the history and
the TALINK is updated when a new key is used in the rollover process.
This gives the TALINK and new historical key time to propagate. 
</p>
<p> The signer can support trust history.  Trust history key sets need
only contain SEP keys.  To use older signers, move historical RRSIGs to
another file.  Sign the zone, including the TALINK and DNSKEY records.
Append the historical RRSIGs to the result.  Signing the zone like this
obviates the need for changes to signer and server software. 
</p>
<a name="anchor2"></a><br /><hr />
<a name="rfc.section.5"></a><h3>5.&nbsp;
Example</h3>

<p> In this example example.com is the History Provider for example.net.
The DNSKEY rdata and RRSIG rdata is omitted for brevity, it is a copy
and paste of the data from example.net. 
</p>
<p>

<p>
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>$ORIGIN example.com.
example.com. TALINK h0.example.com. h2.example.com.

h0 TALINK . h1.example.com.
h0 DNSKEY ...
h0 RRSIG ...

h1 TALINK h0.example.com. h2.example.com.
h1 DNSKEY ...
h1 RRSIG ...

h2 TALINK h1.example.com. .
h2 DNSKEY ...
h2 RRSIG ...
</pre></div>
<p>
</p>


<p> The example.net zone can advertise the example.com History Provider
by providing the TALINK shown here at example.com at the apex of the
example.net zone.  The TALINK at example.com is then not needed. 
</p>
<a name="anchor3"></a><br /><hr />
<a name="rfc.section.6"></a><h3>6.&nbsp;
Deployment</h3>

<p> The trust history is advertised with TALINK RRs at the zone apex.
These represent alternative history sources, that can be searched in turn.
The TALINK at the zone apex contains the first and last name of the list
of historical keys. 
</p>
<p> The historical list of keys grows perpetually.  Since most validators
have recent keys, their processing time remains similar as the list grows.
If validators no longer have trust in the keys then they need no longer
be published.  The oldest key entries can be omitted from the list to
shorten it. 
</p>
<p> The validator decides how long it trusts a key.  A recommendation from
the zone owner can be configured for keys of that zone, or recommendations
per algorithm and key size can be used (e.g. see <a class='info' href='#NIST800-57'>[NIST800&#8209;57]<span> (</span><span class='info'>Barker, E., Barker, W., Burr, W., Polk, W., and M. Smid, &ldquo;Recommendations for Key Management,&rdquo; March&nbsp;2007.</span><span>)</span></a>).  If a key is older than that, trust history lookup fails with it and
the trust point can be considered deleted.  This assumes the validator has
decided on a security policy and also can take actions when the update
of the trust anchor fails.  Without such policy, or if the alternative
is no DNSSEC, the approach below can be used. 
</p>
<p> In general, the decision can be that any key - no matter how old
or how small - is better than no security.  The validator then never
considers a key too old, and the lookup algorithm becomes an unsecured
update mechanism at the time where the key can be trivially broken.
The history provider SHOULD provide these broken keys to facilitate
clients performing the unsecured update.  If a key can not be trivially
broken then it provides a non-trivial amount of security that the history
lookup algorithm uses to get the current keys.  Conceivably after
the update the result is stored on stable storage and the client is
thereafter safe - it performs a leap of faith.  The validator operator
can opt for this set up after considering the trade-off between loss of
DNSSEC, loss of connectivity, and the argument that perceived security
is worse than no security. 
</p>
<p> The history lookup can be used on its own.  Then, the trust history is
used whenever the key rolls over and no polling is performed.  This has
associated risks, in that the immediate rollover without timeout that
it provides could be abused, and certainly when taken together with
leap-of-faith such systems SHOULD inform their user that the key has
changed and urge them to do immediate checks.  Initially we put a hold
down timer on such rollovers to mitigate the abuse risks but these make
following normal rollovers impossible. 
</p>
<p> If a validator is also using <a class='info' href='#RFC5011'>[RFC5011]<span> (</span><span class='info'>StJohns, M., &ldquo;Automated Updates of DNS Security (DNSSEC) Trust Anchors,&rdquo; September&nbsp;2007.</span><span>)</span></a> for the
target zone, then the trust history algorithm SHOULD only be invoked if
the <a class='info' href='#RFC5011'>[RFC5011]<span> (</span><span class='info'>StJohns, M., &ldquo;Automated Updates of DNS Security (DNSSEC) Trust Anchors,&rdquo; September&nbsp;2007.</span><span>)</span></a> algorithm failed due to the inability to
perform probes.  This is the case when the last <a class='info' href='#RFC5011'>[RFC5011]<span> (</span><span class='info'>StJohns, M., &ldquo;Automated Updates of DNS Security (DNSSEC) Trust Anchors,&rdquo; September&nbsp;2007.</span><span>)</span></a>
successful probe was more than 30 days ago.  If a new key has been
announced, invoke the history if no 2 probes succeeded during the add
hold-down time and there was no successful probe after the add hold-down
time passed.  Therefore the time of the last successful probe MUST be
stored on stable storage. 
</p>
<p> For testing the potentially very infrequently used lookup, the
following SHOULD be implemented.  For the test the lookup is triggered
manually by allowing the system to be given a particular keyset with a
last successful lookup date in the past and a test History Provider. The
test History Provider provides access to a generated back-dated test
history. 
</p>
<a name="Security"></a><br /><hr />
<a name="rfc.section.7"></a><h3>7.&nbsp;
Security Considerations</h3>

<p> The History Provider only provides copies of old data. If that
historic data is altered or withheld the lookup algorithm fails because
of validation errors in Step 3 of the algorithm.  If the History provider
or a Man in the Middle Adversary (MIMA) has access to the original private
keys (through theft, cryptanalisis, or otherwise), history can be altered
without failure of the algorithm. Below we only consider MIMAs and assume
the History Provider is a trusted party.  
</p>
<p> Spoofing by a MIMA of data looked up in step 2 or 3, i.e. spoofing
of TALINK and DNSKEY data, can present some alternate history. However
the DNSKEY RR set trusted that the history should arrive at is already
fixed by step 1. If an attempt is made to subvert the algorithm at
step 2 or 3, then the result keyset can not be replaced by another
keyset unnoticed. 
</p>
<p> To change the keyset trusted as the outcome, the step 1 data has to
be spoofed and the key held by the validator (or a newer historic key)
has to be compromised.  Unless such spoof is targeted to a specific
victim, a spoof of the step 1 result has a high visibility. Since
most of the validators that receive the spoof have an up-to-date trust
anchor most validators that would receive this spoof return validation
failure for data from the zone that contains the DNSKEYs. An adversary
will therefore have to target the attack to validators that are in the
process of an update. Since validators do not announce that they use
trust history lookup until step 2 adversaries will not be able to select
the validators.
</p>
<p> A spoof of data in steps 2 and 3, together with a compromised (old) key,
can result in a downgrade.  At steps 2 and 3 a faked trust point deletion
or algorithm rollover can be inserted in a fake history.  This avoids
the high visibility of spoofing the current key (see previous paragraph)
and downgrades to insecure. 
</p>
<p> Finally there is the case that one of the keys published by the
History Providers has been compromised.  Since someone spoofing at
step 1 of the lookup algorithm and presenting some fake history to a
compromised key, of course does not include key revocations and does
extend the history to contain the compromised key, it therefore is not
really useful for a History Provider to remove the key from the
published history.  That only makes lookups fail for those validators
who are not under attack. Useful action could be to update validators
using some other means. 
</p>
<p> Rollover with <a class='info' href='#RFC5011'>[RFC5011]<span> (</span><span class='info'>StJohns, M., &ldquo;Automated Updates of DNS Security (DNSSEC) Trust Anchors,&rdquo; September&nbsp;2007.</span><span>)</span></a> revokes keys after use.
If a History Provider is used, then such revoked keys SHOULD be used
to perform history tracking and history lookup.  The old keys that the
validator starts with and final current keys MUST NOT be trusted if they
are revoked. 
</p>
<p> Depending on choices by the validator operator, it may accept a
leap-of-faith, and possibly allow non-hold-down rollovers.  Although
this allows very fast emergency rollover if all clients are known to do
trust-history lookups without the RFC5011-algorithm, it also allows an
attacker with the private key to attempt to take over a zone quickly and
get validators to roll to a trust anchor of the attacker's choosing. 
</p>
<p> The SEP bit is checked to make sure that control over the KSK is
necessary to change the keyset for the target zone. 
</p>
<p> The algorithm can be used to get the inception and expiration times
of signatures on the current keyset, a clock.  A MIMA can attempt to
shorten history and put back that clock, but the algorithm attempts to
make this difficult to target and highly visible to others. 
</p>
<p> If the clock of the validator can be influenced, then setting it
forward is unlikely to give advantage, but setting it backward enables
a replay attack of old DNSSEC data and signatures.  This vulnerability
exists also in plain DNSSEC. 
</p>
<a name="IANA"></a><br /><hr />
<a name="rfc.section.8"></a><h3>8.&nbsp;
IANA Considerations</h3>

<p> Resource record type TALINK has been defined using RFC5395 expert
review, it has RR type number 58 (decimal). 
</p>
<a name="ack"></a><br /><hr />
<a name="rfc.section.9"></a><h3>9.&nbsp;
Acknowledgments</h3>

<p> Thanks to the people who provided review and suggestions, Joe Abley,
George Barwood, Edward Lewis, Michael StJohns, Bert Hubert, Mark Andrews,
Ted Lemon, Steve Crocker, Bill Manning, Eric Osterweil, Wolfgang Nagele,
Alfred Hoenes, Olafur Gudmundsson, Roy Arends and Matthijs Mekking. 
</p>
<a name="rfc.references"></a><br /><hr />
<a name="rfc.section.10"></a><h3>10.&nbsp;
References</h3>

<a name="rfc.references1"></a><br /><hr />
<h3>10.1.&nbsp;Informative References</h3>
<table width="99%" border="0">
<tr><td class="author-text" valign="top"><a name="NIST800-57">[NIST800-57]</a></td>
<td class="author-text">Barker, E., Barker, W., Burr, W., Polk, W., and M. Smid, &ldquo;Recommendations for Key Management,&rdquo; NIST SP&nbsp;800-57, March&nbsp;2007.</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC5011">[RFC5011]</a></td>
<td class="author-text">StJohns, M., &ldquo;<a href="http://tools.ietf.org/html/rfc5011">Automated Updates of DNS Security (DNSSEC) Trust Anchors</a>,&rdquo; RFC&nbsp;5011, September&nbsp;2007 (<a href="http://www.rfc-editor.org/rfc/rfc5011.txt">TXT</a>).</td></tr>
</table>

<a name="rfc.references2"></a><br /><hr />
<h3>10.2.&nbsp;Normative References</h3>
<table width="99%" border="0">
<tr><td class="author-text" valign="top"><a name="RFC2119">[RFC2119]</a></td>
<td class="author-text"><a href="mailto:sob@harvard.edu">Bradner, S.</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>,&rdquo; BCP&nbsp;14, RFC&nbsp;2119, March&nbsp;1997 (<a href="http://www.rfc-editor.org/rfc/rfc2119.txt">TXT</a>, <a href="http://xml.resource.org/public/rfc/html/rfc2119.html">HTML</a>, <a href="http://xml.resource.org/public/rfc/xml/rfc2119.xml">XML</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC3597">[RFC3597]</a></td>
<td class="author-text">Gustafsson, A., &ldquo;<a href="http://tools.ietf.org/html/rfc3597">Handling of Unknown DNS Resource Record (RR) Types</a>,&rdquo; RFC&nbsp;3597, September&nbsp;2003 (<a href="http://www.rfc-editor.org/rfc/rfc3597.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4034">[RFC4034]</a></td>
<td class="author-text">Arends, R., Austein, R., Larson, M., Massey, D., and S. Rose, &ldquo;<a href="http://tools.ietf.org/html/rfc4034">Resource Records for the DNS Security Extensions</a>,&rdquo; RFC&nbsp;4034, March&nbsp;2005 (<a href="http://www.rfc-editor.org/rfc/rfc4034.txt">TXT</a>).</td></tr>
</table>

<a name="rfc.authors"></a><br /><hr />
<h3>Authors' Addresses</h3>
<table width="99%" border="0" cellpadding="0" cellspacing="0">
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Wouter Wijngaards</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">NLnet Labs</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Science Park 140</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Amsterdam  1098 XG</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">The Netherlands</td></tr>
<tr><td class="author" align="right">EMail:&nbsp;</td>
<td class="author-text"><a href="mailto:wouter@nlnetlabs.nl">wouter@nlnetlabs.nl</a></td></tr>
<tr cellpadding="3"><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Olaf Kolkman</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">NLnet Labs</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Science Park 140</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Amsterdam  1098 XG</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">The Netherlands</td></tr>
<tr><td class="author" align="right">EMail:&nbsp;</td>
<td class="author-text"><a href="mailto:olaf@nlnetlabs.nl">olaf@nlnetlabs.nl</a></td></tr>
</table>
</body></html>
