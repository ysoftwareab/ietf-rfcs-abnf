<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="en"><head><title>Blockwise transfers in CoAP</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="description" content="Blockwise transfers in CoAP">
<meta name="keywords" content="Internet-Draft">
<meta name="generator" content="xml2rfc v1.35 (http://xml.resource.org/)">
<meta name="viewport" content="width=600;" />
<style type='text/css'><!--
        body {
                font-family: verdana, charcoal, helvetica, arial, sans-serif;
                font-size: 85%;
		max-width: 60em; 
		color: #000; background-color: #FFF;
                margin: 2em;
        }
        h1, h2, h3, h4, h5, h6 {
                font-family: helvetica, monaco, "MS Sans Serif", arial, sans-serif;
                font-weight: bold; font-style: normal;
        }
        h1 { color: #900; background-color: transparent; text-align: right; }
        h3 { color: #333; background-color: transparent; }

        td.RFCbug {
                font-size: x-small; text-decoration: none;
                width: 30px; height: 30px; padding-top: 2px;
                text-align: justify; vertical-align: middle;
                background-color: #000;
        }
        td.RFCbug span.RFC {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: bold; color: #666;
        }
        td.RFCbug span.hotText {
                font-family: charcoal, monaco, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: normal; text-align: center; color: #FFF;
        }

        table.TOCbug { width: 30px; height: 15px; }
        td.TOCbug {
                text-align: center; width: 30px; height: 15px;
                color: #FFF; background-color: #900;
        }
        td.TOCbug a {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, sans-serif;
                font-weight: bold; font-size: x-small; text-decoration: none;
                color: #FFF; background-color: transparent;
        }

        td.header {
                font-family: arial, helvetica, sans-serif; font-size: x-small;
                vertical-align: top; width: 33%;
                color: #FFF; background-color: #666;
        }
        td.author { font-weight: bold; font-size: x-small; margin-left: 4em; }
        td.author-text { font-size: x-small; }

        /* info code from SantaKlauss at http://www.madaboutstyle.com/tooltip2.html */
        a.info {
                /* This is the key. */
                position: relative;
                z-index: 24;
                text-decoration: none;
        }
        a.info:hover {
                z-index: 25;
                color: #FFF; background-color: #900;
        }
        a.info span { display: none; }
        a.info:hover span.info {
                /* The span will display just on :hover state. */
                display: block;
                position: absolute;
                font-size: smaller;
                top: 2em; left: -5em; width: 15em;
                padding: 2px; border: 1px solid #333;
                color: #900; background-color: #EEE;
                text-align: left;
        }

        a { font-weight: bold; }
        a:link    { color: #900; background-color: transparent; }
        a:visited { color: #633; background-color: transparent; }
        a:active  { color: #633; background-color: transparent; }

        p { margin-left: 2em; margin-right: 2em; }
        p.copyright { font-size: x-small; }
        p.toc { font-size: 85%;
		max-width: 60em; 
		font-weight: bold; margin-left: 3em; }
        table.toc { margin: 0 0 0 3em; padding: 0; border: 0; vertical-align: text-top; }
        td.toc { font-size: 85%;
		max-width: 60em; 
		font-weight: bold; vertical-align: text-top; }

        ol.text { margin-left: 2em; margin-right: 2em; }
        ul.text { margin-left: 2em; margin-right: 2em; }
        li      { margin-left: 3em; }

        /* RFC-2629 <spanx>s and <artwork>s. */
        em     { font-style: italic; }
        strong { font-weight: bold; }
        dfn    { font-weight: bold; font-style: normal; }
        cite   { font-weight: normal; font-style: normal; }
        tt     { color: #036; }
        tt, pre, pre dfn, pre em, pre cite, pre span {
                font-family: "Courier New", Courier, monospace; font-size: small;
        }
        pre {
                text-align: left; padding: 4px;
                color: #000; background-color: #CCC;
        }
        pre dfn  { color: #900; }
        pre em   { color: #66F; background-color: #FFC; font-weight: normal; }
        pre .key { color: #33C; font-weight: bold; }
        pre .id  { color: #900; }
        pre .str { color: #000; background-color: #CFF; }
        pre .val { color: #066; }
        pre .rep { color: #909; }
        pre .oth { color: #000; background-color: #FCF; }
        pre .err { background-color: #FCC; }

        /* RFC-2629 <texttable>s. */
        table.all, table.full, table.headers, table.none {
                font-size: 85%;
		max-width: 60em; 
		text-align: center; border-width: 2px;
                vertical-align: top; border-collapse: collapse;
        }
        table.all, table.full { border-style: solid; border-color: black; }
        table.headers, table.none { border-style: none; }
        th {
                font-weight: bold; border-color: black;
                border-width: 2px 2px 3px 2px;
        }
        table.all th, table.full th { border-style: solid; }
        table.headers th { border-style: none none solid none; }
        table.none th { border-style: none; }
        table.all td {
                border-style: solid; border-color: #333;
                border-width: 1px 2px;
        }
        table.full td, table.headers td, table.none td { border-style: none; }

        hr { height: 1px; }
        hr.insert {
                width: 80%; border-style: none; border-width: 0;
                color: #CCC; background-color: #CCC;
        }
--></style>
</head>
<body>
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<table summary="layout" width="66%" border="0" cellpadding="0" cellspacing="0"><tr><td><table summary="layout" width="100%" border="0" cellpadding="2" cellspacing="1">
<tr><td class="header">CoRE Working Group</td><td class="header">Z. Shelby, Ed.</td></tr>
<tr><td class="header">Internet-Draft</td><td class="header">Sensinode</td></tr>
<tr><td class="header">Intended status: Standards Track</td><td class="header">C. Bormann</td></tr>
<tr><td class="header">Expires: July 29, 2011</td><td class="header">Universitaet Bremen TZI</td></tr>
<tr><td class="header">&nbsp;</td><td class="header">January 25, 2011</td></tr>
</table></td></tr></table>
<h1><br />Blockwise transfers in CoAP<br />draft-ietf-core-block-01</h1>

<h3>Abstract</h3>

<p>
        CoAP is a RESTful transfer protocol for constrained nodes and networks.
        CoAP is based on datagram transport, which limits the maximum size of
        resource representations that can be transferred without too
        much fragmentation. The Block option provides a minimal way to transfer larger representations in a block-wise fashion.
      
</p>
<h3>Status of this Memo</h3>
<p>
This Internet-Draft is submitted  in full
conformance with the provisions of BCP&nbsp;78 and BCP&nbsp;79.</p>
<p>
Internet-Drafts are working documents of the Internet Engineering
Task Force (IETF).  Note that other groups may also distribute
working documents as Internet-Drafts.  The list of current
Internet-Drafts is at http://datatracker.ietf.org/drafts/current/.</p>
<p>
Internet-Drafts are draft documents valid for a maximum of six months
and may be updated, replaced, or obsoleted by other documents at any time.
It is inappropriate to use Internet-Drafts as reference material or to cite
them other than as &ldquo;work in progress.&rdquo;</p>
<p>
This Internet-Draft will expire on July 29, 2011.</p>

<h3>Copyright Notice</h3>
<p>
Copyright (c) 2011 IETF Trust and the persons identified as the
document authors.  All rights reserved.</p>
<p>
This document is subject to BCP 78 and the IETF Trust's Legal
Provisions Relating to IETF Documents
(http://trustee.ietf.org/license-info) in effect on the date of
publication of this document.  Please review these documents
carefully, as they describe your rights and restrictions with respect
to this document. Code Components extracted from this document must
include Simplified BSD License text as described in Section 4.e of
the Trust Legal Provisions and are provided without warranty as
described in the Simplified BSD License.</p>
<a name="toc"></a><br /><hr />
<h3>Table of Contents</h3>
<p class="toc">
<a href="#problems">1.</a>&nbsp;
Introduction<br />
<a href="#block-wise-transfers">2.</a>&nbsp;
Block-wise transfers<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#block-option">2.1.</a>&nbsp;
The Block Option<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#block-usage">2.2.</a>&nbsp;
Using the Block Option<br />
<a href="#examples">3.</a>&nbsp;
Examples<br />
<a href="#iana-considerations">4.</a>&nbsp;
IANA Considerations<br />
<a href="#security-considerations">5.</a>&nbsp;
Security Considerations<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#mitigating-exhaustion-attacks">5.1.</a>&nbsp;
Mitigating Resource Exhaustion Attacks<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#mitigating-amplification-attacks">5.2.</a>&nbsp;
Mitigating Amplification Attacks<br />
<a href="#acknowledgements">6.</a>&nbsp;
Acknowledgements<br />
<a href="#rfc.references1">7.</a>&nbsp;
References<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#rfc.references1">7.1.</a>&nbsp;
Normative References<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#rfc.references2">7.2.</a>&nbsp;
Informative References<br />
<a href="#rfc.authors">&#167;</a>&nbsp;
Authors' Addresses<br />
</p>
<br clear="all" />

<a name="problems"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1"></a><h3>1.&nbsp;
Introduction</h3>

<p>The CoRE WG is tasked with standardizing an
Application Protocol for Constrained Networks/Nodes, CoAP.
This protocol is intended to provide RESTful <a class='info' href='#REST'>[REST]<span> (</span><span class='info'>Fielding, R., &ldquo;Architectural Styles and the Design of Network-based Software Architectures,&rdquo; 2000.</span><span>)</span></a> services not
unlike HTTP <a class='info' href='#RFC2616'>[RFC2616]<span> (</span><span class='info'>Fielding, R., Gettys, J., Mogul, J., Frystyk, H., Masinter, L., Leach, P., and T. Berners-Lee, &ldquo;Hypertext Transfer Protocol -- HTTP/1.1,&rdquo; June&nbsp;1999.</span><span>)</span></a>,
while reducing the complexity of implementation as well as the size of
packets exchanged in order to make these services useful in a highly
constrained network of themselves highly constrained nodes.
</p>
<p>This objective requires restraint in a number of sometimes conflicting ways:
</p>
<p></p>
<ul class="text">
<li>reducing implementation complexity in order to minimize code size,
</li>
<li>reducing message sizes in order to minimize the number of fragments
needed for each message (in turn to maximize the probability of
delivery of the message), the amount of transmission power needed
and the loading of the limited-bandwidth channel,
</li>
<li>reducing requirements on the environment such as stable storage,
good sources of randomness or user interaction capabilities.
</li>
</ul>

<p>CoAP is based on datagram transports such as UDP, which limit the
maximum size of resource representations that can be transferred
without creating unreasonable levels of IP fragmentation.
In addition, not all resource representations will fit into a single
link layer packet of a constrained network, which may cause adaptation
layer fragmentation even if IP layer fragmentation is not required.
Using fragmentation (either at the
adaptation layer or at the IP layer) to enable the transport of larger
representations is possible up to the maximum size of the underlying
datagram protocol (such as UDP),
but the fragmentation/reassembly process loads the lower layers
with conversation state that is better managed in the application
layer.
</p>
<p>This specification defines a CoAP option to enable <em>block-wise</em> access to
resource representations.
The Block option provides a minimal way to transfer larger
resource representations in a block-wise fashion.
The overriding objective is to avoid
creating conversation state at the server for block-wise GET requests.
(It is impossible to fully avoid creating conversation state for
POST/PUT, if the creation/replacement of resources is to be atomic;
where that property is not needed, there is no need to create server
conversation state in this case, either.)
</p>
<p> In summary, this specification adds a Block option to CoAP that
can be used for block-wise transfers.  Benefits of using this option include:
</p>
<p></p>
<ul class="text">
<li>
  Transfers larger than can be accommodated in constrained-network
link-layer packets can be performed in smaller blocks.
</li>
<li>No hard-to-manage conversation state is created at the adaptation
layer or IP layer for fragmentation.
</li>
<li>The transfer of each block is acknowledged, enabling retransmission
if required.
</li>
<li>Both sides have a say in the block size that actually will be used.
</li>
<li>The resulting exchanges are easy to understand using packet
  analyzer tools and thus quite accessible to debugging.
</li>
<li>If needed, the Block option can also be used as is to provide random
  access to power-of-two sized blocks within a resource representation.
</li>
</ul>

<p>The key words "MUST", "MUST NOT", "REQUIRED",
"SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY",
and "OPTIONAL" in this document are to be interpreted as described in
RFC 2119, BCP 14 <a class='info' href='#RFC2119'>[RFC2119]<span> (</span><span class='info'>Bradner, S., &ldquo;Key words for use in RFCs to Indicate Requirement Levels,&rdquo; March&nbsp;1997.</span><span>)</span></a> and indicate requirement
levels for compliant CoAP implementations.
</p>
<p>In this document, the term "byte" is used in its now customary
sense as a synonym for "octet".
</p>
<p>Where bit arithmetic is explained, this document uses the notation
familiar from the programming language C, except that the operator "^"
stands for exponentiation.
</p>
<a name="block-wise-transfers"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2"></a><h3>2.&nbsp;
Block-wise transfers</h3>

<a name="block-option"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2.1"></a><h3>2.1.&nbsp;
The Block Option</h3>
<table class="full" align="center" border="0" cellpadding="2" cellspacing="2">
<col align="right"><col align="left"><col align="left"><col align="left"><col align="left"><col align="left">
<tr><th align="right">Type</th><th align="left">C/E</th><th align="left">Name</th><th align="left">Data type</th><th align="left">Length</th><th align="left">Default</th></tr>
<tr>
<td align="right">13</td>
<td align="left">C</td>
<td align="left">Block</td>
<td align="left">uint</td>
<td align="left">1-3 B</td>
<td align="left">0 (see below)</td>
</tr>
</table>
<br clear="all" />

<p>Implementation of the Block option is intended to be optional.
However, when it is present in a CoAP message, it MUST be processed
(or the message rejected);
therefore it is identified as a critical option.
</p>
<p>The size of the blocks should not be fixed by the protocol.  On the
other hand, implementation should be as simple as possible.  The Block
option therefore supports a small range of power-of-two block sizes, from 2^4
(16) to 2^11 (2048) bytes.  One of these eight values can be encoded
in three bits (0 for 2^4 to 7 for 2^11 bytes), which we call the <tt>SZX</tt> (size
exponent); the actual block size is then <tt>1 &lt;&lt; (SZX + 4)</tt>.
</p>
<p>When a representation is larger than can be comfortably transferred in
a single UDP datagram, the Block option can be used to indicate a
block-wise transfer.  Block is a 1-, 2- or 3-byte integer, the four least
significant bits of which indicate the size and whether the current
block-wise transfer is the last block being transferred (M or "more"
bit).  The option value divided by sixteen is the number of the block
currently being transferred, starting from zero, i.e., the current
transfer is about the <tt>size</tt> bytes starting
at byte <tt>block number &lt;&lt; (SZX +
4)</tt>.  The default value of
the Block Option is zero, indicating that the current block is the first
(block number 0) and only (M bit not set) block of the transfer;
however, there is no explicit size implied by this default value.
</p><br /><hr class="insert" />
<a name="block"></a>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
        0
        0 1 2 3 4 5 6 7
       +-+-+-+-+-+-+-+-+
       |  NUM  |M| SZX |
       +-+-+-+-+-+-+-+-+

        0                   1
        0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |          NUM          |M| SZX |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

        0                   1                   2
        0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |                   NUM                 |M| SZX |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;1: Block option&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>(Note that, as an implementation convenience, the option value with
the last 4 bits masked out, shifted to the
left by the value of SZX, gives the byte position of the block.)
</p>
<p>
       </p>
<blockquote class="text"><dl>
<dt>NUM:</dt>
<dd>
         Block Number. The block number is a variable-size (4, 12, or 20 bit) unsigned integer indicating the block number being requested or provided. Block number 0 indicates the first block of a representation.
         
</dd>
<dt>M:</dt>
<dd>
         More Flag. This flag indicates if this block is the last in a representation when set. When not set it indicates that there are one or more blocks available. When the block option is used to retrieve a specific block number the M bit MUST be sent as zero and ignored on reception.
         
</dd>
<dt>SZX:</dt>
<dd>
         Block Size. The block size is a three-bit unsigned integer indicating the size of a block to
         the power of two. Thus block size = 2^(SZX + 4). As there are
         three bits available for SZX, the minimum block size is 2^(0+4) = 16
         and the maximum is 2^(7+4) = 2048.
         
</dd>
</dl></blockquote><p>
     
</p>
<p>The Block option is used in one of three roles:
</p>
<p></p>
<ul class="text">
<li>In the request for a GET, the Block option gives the block number requested and suggests a block size (block number 0) or echoes the block size of
previous blocks received (block numbers other than 0).
</li>
<li>In the response for a GET or in the request for a PUT or POST, the
Block option
describes what block number is contained in the payload, and whether
further blocks are required to complete the transfer of that body (M bit).  If the M bit is set,
the size of the payload body in bytes MUST indeed be the power of
two given by the block size.  All blocks for a REST transfer MUST use
the same block size, except for the last block (M bit not set).
</li>
<li>In the response for a PUT or POST, the Block option indicates what
block number is
being acknowledged.  In this case, the M bit is set to indicate that
this response does not carry the final response to the request; this
can occur when the M bit was set in the request and the server
implements PUT/POST atomically (i.e., acts only upon reception of the last
block).
</li>
</ul>

<a name="block-usage"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2.2"></a><h3>2.2.&nbsp;
Using the Block Option</h3>

<p>Using the Block option, a single REST operation can be split into
multiple CoAP message exchanges.  Each of these message
exchanges uses their own CoAP Message ID.
</p>
<p>When a GET is answered with a response carrying a Block option with
the M bit set, the requester may retrieve additional blocks of the
resource representation by sending
requests with a Block option giving the block number desired.  In such
a Block option, the M bit MUST be sent as zero and ignored on
reception.
</p>
<p>To influence the block size used in response to a GET request, the
requester uses the Block option, giving the desired size, a block
number of zero and an M bit of zero.  A server SHOULD use the block
size indicated or a smaller size.  Any further block-wise requests for
blocks beyond the first one MUST indicate the same block size that was
used by the server in the
response for the first one.
</p>
<p>If the Block option is used by the requester, all GET requests in a
single transfer
MUST ultimately use the same size, except that there may not be enough
content to fill the last block (the one returned with the M bit not set).
The server SHOULD use the block
size indicated in the request option or a smaller size, but the
requester MUST take note of the actual block size used in the response
it receives
to its initial GET and proceed to use it in subsequent GETs; the
server behavior MUST ensure that this client behavior results in the
same block size for all responses in a sequence (except for the last
one with the M bit not set).
</p>
<p>Block-wise transfers can be used to GET resources the representations of
which are entirely static (not changing over time at all, such as in a
schema describing a device), or for dynamically changing resources.
In the latter case, the Block option SHOULD be used in conjunction
with the Etag option, to ensure that the blocks being reassembled are
from the same version of the representation.
When reassembling the representation from the blocks being exchanged,
the reassembler MUST compare Etag options.  If the Etag options do not
match in a GET transfer, the requester has the option of attempting to
retrieve fresh values for the blocks it retrieved first.  To minimize
the resulting inefficiency, the server MAY cache the current value of
a representation for an ongoing sequence of requests, but there is no
requirement for the server to establish any state.  The client MAY
facilitate identifying the sequence by using the Token option with a
non-default value.
</p>
<p>In a PUT or POST transfer, the Block option refers to the body in
the request, i.e., there is no way to perform a block-wise retrieval
of the body of the response.  Servers that do need to supply large
bodies in response to PUT/POST SHOULD therefore be employing
mechanisms such as providing a location for a resource that can be
used in a GET to obtain that information.
</p>
<p>In a PUT or POST transfer that is intended to be implemented in an
atomic fashion at the server, the actual creation/replacement takes
place at the time the final block, i.e. a block with the M bit unset, is received.  If not
all previous blocks are available at the server at this time, the
transfer fails and error code 4.08 (Request Entity Incomplete) MUST be returned.  The error
code 4.13 (Request Entity Too Large) can be returned at any time by a server that does not
currently have the resources to store blocks for a block-wise PUT or
POST transfer that it would intend to implement in an atomic fashion.
</p>
<p>If multiple concurrently proceeding block-wise PUT or POST operations
are possible, the requester SHOULD use the Token option to clearly separate the different sequences.
In this case, when reassembling the representation from the blocks
being exchanged to enable atomic processing, the reassembler MUST
compare any Token options present (and, as usual, taking an absent Token option
to default to the empty Token).
If atomic processing is not desired, there is no need to process the
Token option (but it is still returned in the response as usual).
</p>
<a name="examples"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3"></a><h3>3.&nbsp;
Examples</h3>

<p>This section gives a number of short examples with message flows for a
block-wise GET, and for a PUT or POST.
These examples demonstrate the basic operation, the operation in the
presence of retransmissions, and examples for the operation of the
block size negotiation.
</p>
<p>In all these examples, a block option is shown in a decomposed way
separating the block number (NUM), more bit (M), and block size exponent
(2^(SZX+4)) by slashes.  E.g., a block option value of 33 would be shown as
2/0/32, or a block option value of 59 would be shown as 3/1/128.
</p>
<p>The first example (<a class='info' href='#simple-get'>Figure&nbsp;2<span> (</span><span class='info'>Simple blockwise GET</span><span>)</span></a>) shows a GET request that is split
into three blocks.
The server proposes a block size of 128, and the client agrees.
The first two ACKs contain 128 bytes of payload each, and third ACK
contains between 1 and 128 bytes.
</p><br /><hr class="insert" />
<a name="simple-get"></a>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
CLIENT                                                     SERVER
  |                                                          |
  | CON [MID=1234], GET, /status                     ------&gt; |
  |                                                          |
  | &lt;------   ACK [MID=1234], 2.00 OK, 0/1/128               |
  |                                                          |
  | CON [MID=1235], GET, /status, 1/0/128            ------&gt; |
  |                                                          |
  | &lt;------   ACK [MID=1235], 2.00 OK, 1/1/128               |
  |                                                          |
  | CON [MID=1236], GET, /status, 2/0/128            ------&gt; |
  |                                                          |
  | &lt;------   ACK [MID=1236], 2.00 OK, 2/0/128               |
</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;2: Simple blockwise GET&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>In the second example (<a class='info' href='#early-get'>Figure&nbsp;3<span> (</span><span class='info'>Blockwise GET with early negotiation</span><span>)</span></a>), the client anticipates the blockwise transfer
(e.g., because of a size indication in the link-format description)
and sends a size proposal.  All ACK messages except for the last carry
64 bytes of payload; the last one carries between 1 and 64 bytes.
</p><br /><hr class="insert" />
<a name="early-get"></a>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
CLIENT                                                     SERVER
  |                                                          |
  | CON [MID=1234], GET, /status, 0/0/64             ------&gt; |
  |                                                          |
  | &lt;------   ACK [MID=1234], 2.00 OK, 0/1/64                |
  |                                                          |
  | CON [MID=1235], GET, /status, 1/0/64             ------&gt; |
  |                                                          |
  | &lt;------   ACK [MID=1235], 2.00 OK, 1/1/64                |
  :                                                          :
  :                          ...                             :
  :                                                          :
  | CON [MID=1238], GET, /status, 4/0/64             ------&gt; |
  |                                                          |
  | &lt;------   ACK [MID=1238], 2.00 OK, 4/1/64                |
  |                                                          |
  | CON [MID=1239], GET, /status, 5/0/64             ------&gt; |
  |                                                          |
  | &lt;------   ACK [MID=1239], 2.00 OK, 5/0/64                |
</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;3: Blockwise GET with early negotiation&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>In the third example (<a class='info' href='#late-get'>Figure&nbsp;4<span> (</span><span class='info'>Blockwise GET with late negotiation</span><span>)</span></a>), the client is surprised by the
need for a blockwise transfer, and unhappy with the size chosen
unilaterally by the server.  As it did not send a size proposal
initially, the negotiation only influences the size from the second
message exchange.  Since the client already obtained both the first and
second 64-byte block in the first 128-byte exchange, it goes on
requesting the third 64-byte block.  None of this is understood by the
server, which simply responds to the requests as it best can.
</p><br /><hr class="insert" />
<a name="late-get"></a>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
CLIENT                                                     SERVER
  |                                                          |
  | CON [MID=1234], GET, /status                     ------&gt; |
  |                                                          |
  | &lt;------   ACK [MID=1234], 2.00 OK, 0/1/128               |
  |                                                          |
  | CON [MID=1235], GET, /status, 2/0/64             ------&gt; |
  |                                                          |
  | &lt;------   ACK [MID=1235], 2.00 OK, 2/1/64                |
  |                                                          |
  | CON [MID=1236], GET, /status, 3/0/64             ------&gt; |
  |                                                          |
  | &lt;------   ACK [MID=1236], 2.00 OK, 3/1/64                |
  |                                                          |
  | CON [MID=1237], GET, /status, 4/0/64             ------&gt; |
  |                                                          |
  | &lt;------   ACK [MID=1237], 2.00 OK, 4/1/64                |
  |                                                          |
  | CON [MID=1238], GET, /status, 5/0/64             ------&gt; |
  |                                                          |
  | &lt;------   ACK [MID=1238], 2.00 OK, 5/0/64                |
</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;4: Blockwise GET with late negotiation&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>In all these (and the following) cases, retransmissions are handled by
the CoAP message exchange layer, so they don't influence the block
operations (<a class='info' href='#late-get-lost-con'>Figure&nbsp;5<span> (</span><span class='info'>Blockwise GET with late negotiation and lost CON</span><span>)</span></a>, <a class='info' href='#late-get-lost-ack'>Figure&nbsp;6<span> (</span><span class='info'>Blockwise GET with late negotiation and lost ACK</span><span>)</span></a>).
</p><br /><hr class="insert" />
<a name="late-get-lost-con"></a>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
CLIENT                                                     SERVER
  |                                                          |
  | CON [MID=1234], GET, /status                     ------&gt; |
  |                                                          |
  | &lt;------   ACK [MID=1234], 2.00 OK, 0/1/128               |
  |                                                          |
  | CON [MID=1235], GE/////////////////////////              |
  |                                                          |
  | (timeout)                                                |
  |                                                          |
  | CON [MID=1235], GET, /status, 2/0/64             ------&gt; |
  |                                                          |
  | &lt;------   ACK [MID=1235], 2.00 OK, 2/1/64                |
  :                                                          :
  :                          ...                             :
  :                                                          :
  | CON [MID=1238], GET, /status, 5/0/64             ------&gt; |
  |                                                          |
  | &lt;------   ACK [MID=1238], 2.00 OK, 5/0/64                |
</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;5: Blockwise GET with late negotiation and lost CON&nbsp;</b></font><br /></td></tr></table><hr class="insert" />
<br /><hr class="insert" />
<a name="late-get-lost-ack"></a>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
CLIENT                                                     SERVER
  |                                                          |
  | CON [MID=1234], GET, /status                     ------&gt; |
  |                                                          |
  | &lt;------   ACK [MID=1234], 2.00 OK, 0/1/128               |
  |                                                          |
  | CON [MID=1235], GET, /status, 2/0/64             ------&gt; |
  |                                                          |
  | /////////////////////////////////OK, 2/1/64              |
  |                                                          |
  | (timeout)                                                |
  |                                                          |
  | CON [MID=1235], GET, /status, 2/0/64             ------&gt; |
  |                                                          |
  | &lt;------   ACK [MID=1235], 2.00 OK, 2/1/64                |
  :                                                          :
  :                          ...                             :
  :                                                          :
  | CON [MID=1238], GET, /status, 5/0/64             ------&gt; |
  |                                                          |
  | &lt;------   ACK [MID=1238], 2.00 OK, 5/0/64                |
</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;6: Blockwise GET with late negotiation and lost ACK&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>The following examples demonstrate a PUT exchange; a POST exchange
looks the same, with different requirements on atomicity/idempotence.
To ensure that the blocks relate to the same version of the resource
representation carried in the request, the client in
<a class='info' href='#simple-put-atomic'>Figure&nbsp;7<span> (</span><span class='info'>Simple atomic blockwise PUT</span><span>)</span></a> sets the Token to
"v17" in all requests.  Note that, as with the GET, the responses to
the requests that have a more bit in the request block option are
provisional; only the final response tells the client that the PUT
succeeded.
</p><br /><hr class="insert" />
<a name="simple-put-atomic"></a>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
CLIENT                                                     SERVER
  |                                                          |
  | CON [MID=1234], PUT, /options, v17, 0/1/128      ------&gt; |
  |                                                          |
  | &lt;------   ACK [MID=1234], 2.04 Changed, 0/1/128          |
  |                                                          |
  | CON [MID=1235], PUT, /options, v17, 1/1/12       ------&gt; |
  |                                                          |
  | &lt;------   ACK [MID=1235], 2.04 Changed, 1/1/128          |
  |                                                          |
  | CON [MID=1236], PUT, /options, v17, 2/0/128      ------&gt; |
  |                                                          |
  | &lt;------   ACK [MID=1236], 2.04 Changed, 2/0/128          |
</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;7: Simple atomic blockwise PUT&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>A stateless server that simply builds/updates the resource in place
(statelessly) may indicate this by not setting the more bit in the
response (<a class='info' href='#simple-put-stateless'>Figure&nbsp;8<span> (</span><span class='info'>Simple stateless blockwise PUT</span><span>)</span></a>); in this case, the response codes are valid separately for
each block being updated.  This is of course only an acceptable
behavior of the server if the potential inconsistency present during
the run of the message exchange sequence does not lead to problems,
e.g. because the resource being created or changed is not yet or not currently in
use.
</p><br /><hr class="insert" />
<a name="simple-put-stateless"></a>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
CLIENT                                                     SERVER
  |                                                          |
  | CON [MID=1234], PUT, /options, v17, 0/1/128      ------&gt; |
  |                                                          |
  | &lt;------   ACK [MID=1234], 2.04 Changed, 0/0/128          |
  |                                                          |
  | CON [MID=1235], PUT, /options, v17, 1/1/12       ------&gt; |
  |                                                          |
  | &lt;------   ACK [MID=1235], 2.04 Changed, 1/0/128          |
  |                                                          |
  | CON [MID=1236], PUT, /options, v17, 2/0/128      ------&gt; |
  |                                                          |
  | &lt;------   ACK [MID=1236], 2.04 Changed, 2/0/128          |
</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;8: Simple stateless blockwise PUT&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<a name="iana-considerations"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4"></a><h3>4.&nbsp;
IANA Considerations</h3>

<p>This draft adds the following option number to the CoAP Option
Numbers registry of
<a class='info' href='#I-D.ietf-core-coap'>[I&#8209;D.ietf&#8209;core&#8209;coap]<span> (</span><span class='info'>Shelby, Z., Frank, B., and D. Sturek, &ldquo;Constrained Application Protocol (CoAP),&rdquo; October&nbsp;2010.</span><span>)</span></a>:
</p><br /><hr class="insert" />
<a name="tab-option-registry"></a>
<table class="full" align="center" border="0" cellpadding="2" cellspacing="2">
<col align="right"><col align="left"><col align="left">
<tr><th align="right">Number</th><th align="left">Name</th><th align="left">Reference</th></tr>
<tr>
<td align="right">13</td>
<td align="left">Block        </td>
<td align="left"><a class='info' href='#block-option'>Section&nbsp;2.1<span> (</span><span class='info'>The Block Option</span><span>)</span></a>        </td>
</tr>
</table>
<br clear="all" />
<table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Table 1: CoAP Option Numbers&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>This draft adds the following response code to the CoAP Response Codes registry of
<a class='info' href='#I-D.ietf-core-coap'>[I&#8209;D.ietf&#8209;core&#8209;coap]<span> (</span><span class='info'>Shelby, Z., Frank, B., and D. Sturek, &ldquo;Constrained Application Protocol (CoAP),&rdquo; October&nbsp;2010.</span><span>)</span></a>:
</p><br /><hr class="insert" />
<a name="tab-response-code-registry"></a>
<table class="full" align="center" border="0" cellpadding="2" cellspacing="2">
<col align="right"><col align="left"><col align="left">
<tr><th align="right">Code</th><th align="left">Description</th><th align="left">Reference</th></tr>
<tr>
<td align="right"> 136</td>
<td align="left">4.08 Request Entity Incomplete                    </td>
<td align="left"><a class='info' href='#block-option'>Section&nbsp;2.1<span> (</span><span class='info'>The Block Option</span><span>)</span></a>                    </td>
</tr>
</table>
<br clear="all" />
<table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Table 2: CoAP Response Codes&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<a name="security-considerations"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5"></a><h3>5.&nbsp;
Security Considerations</h3>

<p>
Providing access to blocks within a resource may lead to
surprising vulnerabilities.
Where requests are not implemented atomically, an attacker may be able
to exploit a race condition or confuse a server by inducing it to use
a partially updated resource representation.
Partial transfers may also make certain problematic data invisible to
intrusion detection systems; it is RECOMMENDED that an intrusion
detection system (IDS) that analyzes resource representations transferred by
CoAP implement the Block option to gain access to entire resource representations.
Still, approaches such as transferring even-numbered blocks on one path and odd-numbered
blocks on another path, or even transferring blocks multiple times
with different content and
obtaining a different interpretation of temporal order at the IDS than
at the server, may prevent an IDS from seeing the whole picture.
These kinds of attacks are well understood from IP fragmentation and
TCP segmentation; CoAP does not add fundamentally new considerations.

</p>
<p>
Where access to a resource is only granted to clients making use of a specific security
association, all blocks of that resource MUST be subject to the same
security checks; it MUST NOT be possible for unprotected exchanges to
influence blocks of an otherwise protected resource.
As a related consideration, where object security is employed,
PUT/POST should be implemented in the atomic fashion, unless the
object security operation is performed on each access and the
creation of unusable resources can be tolerated.

</p>
<a name="mitigating-exhaustion-attacks"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.1"></a><h3>5.1.&nbsp;
Mitigating Resource Exhaustion Attacks</h3>

<p>
  Certain blockwise requests may induce the server to create state, e.g. to
  create a snapshot for the blockwise GET of a fast-changing resource
  to enable consistent access to the same
  version of a resource for all blocks, or to create temporary
  resource representations that are collected until pressed into
  service by a final PUT or POST with the more bit unset.
All mechanisms that induce a server to create state that cannot simply
be cleaned up create opportunities for denial-of-service attacks.
Servers SHOULD avoid being subject to resource exhaustion based on state
created by untrusted sources.
But even if this is done, the mitigation may cause a denial-of-service
to a legitimate request when it is drowned out by other state-creating
requests.
Wherever possible, servers should therefore minimize the opportunities
to create state for untrusted sources, e.g. by using stateless approaches.

</p>
<p>
Performing segmentation at the application layer is almost always
better in this respect than at the transport layer or lower (IP fragmentation,
adaptation layer fragmentation), e.g. because there is application
layer semantics that can be used for mitigation or because lower
layers provide security associations that can prevent attacks.
However, it is less common to apply timeouts and keepalive mechanisms
at the application layer than at lower layers.  Servers MAY want to
clean up accreted state by timing it out (cf. response code 4.08), and
clients SHOULD be prepared to run blockwise transfers in an expedient
way to minimize the likelihood of running into such a timeout.

</p>
<a name="mitigating-amplification-attacks"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.2"></a><h3>5.2.&nbsp;
Mitigating Amplification Attacks</h3>

<p><a class='info' href='#I-D.ietf-core-coap'>[I&#8209;D.ietf&#8209;core&#8209;coap]<span> (</span><span class='info'>Shelby, Z., Frank, B., and D. Sturek, &ldquo;Constrained Application Protocol (CoAP),&rdquo; October&nbsp;2010.</span><span>)</span></a> discusses the susceptibility of
CoAP end-points for use in amplification attacks.

</p>
<p>A CoAP server can reduce the amount of amplification it provides to an
attacker by offering large resource representations only in relatively
small blocks.  With this, e.g., for a 1000 byte resource, a 10-byte request might
result in an 80-byte response (with a 64-byte block) instead of a
1016-byte response, considerably reducing the amplification provided.
</p>
<a name="acknowledgements"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6"></a><h3>6.&nbsp;
Acknowledgements</h3>

<p>Much of the content of this draft is the result of
discussions with the <a class='info' href='#I-D.ietf-core-coap'>[I&#8209;D.ietf&#8209;core&#8209;coap]<span> (</span><span class='info'>Shelby, Z., Frank, B., and D. Sturek, &ldquo;Constrained Application Protocol (CoAP),&rdquo; October&nbsp;2010.</span><span>)</span></a> authors, and via many CoRE WG discussions. Tokens were suggested by Gilman Tolle and refined by Klaus Hartke.
</p>
<a name="rfc.references"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7"></a><h3>7.&nbsp;
References</h3>

<a name="rfc.references1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>7.1.&nbsp;Normative References</h3>
<table width="99%" border="0">
<tr><td class="author-text" valign="top"><a name="I-D.ietf-core-coap">[I-D.ietf-core-coap]</a></td>
<td class="author-text">Shelby, Z., Frank, B., and D. Sturek, &ldquo;<a href="http://www.ietf.org/internet-drafts/draft-ietf-core-coap-03.txt">Constrained Application Protocol (CoAP)</a>,&rdquo; draft-ietf-core-coap-03 (work in progress), October&nbsp;2010 (<a href="http://www.ietf.org/internet-drafts/draft-ietf-core-coap-03.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC2119">[RFC2119]</a></td>
<td class="author-text"><a href="mailto:sob@harvard.edu">Bradner, S.</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>,&rdquo; BCP&nbsp;14, RFC&nbsp;2119, March&nbsp;1997 (<a href="http://www.rfc-editor.org/rfc/rfc2119.txt">TXT</a>, <a href="http://xml.resource.org/public/rfc/html/rfc2119.html">HTML</a>, <a href="http://xml.resource.org/public/rfc/xml/rfc2119.xml">XML</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC2616">[RFC2616]</a></td>
<td class="author-text"><a href="mailto:fielding@ics.uci.edu">Fielding, R.</a>, <a href="mailto:jg@w3.org">Gettys, J.</a>, <a href="mailto:mogul@wrl.dec.com">Mogul, J.</a>, <a href="mailto:frystyk@w3.org">Frystyk, H.</a>, <a href="mailto:masinter@parc.xerox.com">Masinter, L.</a>, <a href="mailto:paulle@microsoft.com">Leach, P.</a>, and <a href="mailto:timbl@w3.org">T. Berners-Lee</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc2616">Hypertext Transfer Protocol -- HTTP/1.1</a>,&rdquo; RFC&nbsp;2616, June&nbsp;1999 (<a href="http://www.rfc-editor.org/rfc/rfc2616.txt">TXT</a>, <a href="http://www.rfc-editor.org/rfc/rfc2616.ps">PS</a>, <a href="http://www.rfc-editor.org/rfc/rfc2616.pdf">PDF</a>, <a href="http://xml.resource.org/public/rfc/html/rfc2616.html">HTML</a>, <a href="http://xml.resource.org/public/rfc/xml/rfc2616.xml">XML</a>).</td></tr>
</table>

<a name="rfc.references2"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>7.2.&nbsp;Informative References</h3>
<table width="99%" border="0">
<tr><td class="author-text" valign="top"><a name="REST">[REST]</a></td>
<td class="author-text">Fielding, R., &ldquo;Architectural Styles and the Design of Network-based Software Architectures,&rdquo; 2000.</td></tr>
</table>

<a name="rfc.authors"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>Authors' Addresses</h3>
<table width="99%" border="0" cellpadding="0" cellspacing="0">
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Zach Shelby (editor)</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Sensinode</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Kidekuja 2</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Vuokatti  88600</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Finland</td></tr>
<tr><td class="author" align="right">Phone:&nbsp;</td>
<td class="author-text">+358407796297</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:zach@sensinode.com">zach@sensinode.com</a></td></tr>
<tr cellpadding="3"><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Carsten Bormann</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Universitaet Bremen TZI</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Postfach 330440</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Bremen  D-28359</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Germany</td></tr>
<tr><td class="author" align="right">Phone:&nbsp;</td>
<td class="author-text">+49-421-218-63921</td></tr>
<tr><td class="author" align="right">Fax:&nbsp;</td>
<td class="author-text">+49-421-218-7000</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:cabo@tzi.org">cabo@tzi.org</a></td></tr>
</table>
</body></html>
