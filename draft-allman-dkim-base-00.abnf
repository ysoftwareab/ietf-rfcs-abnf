SWSP =  CR / LF / WSP   ; streaming white space


selector =      sub-domain *( "." sub-domain )


tag-list  =  tag-spec 0*( ";" tag-spec ) [ ";" ]
tag-spec  =  [FWS] tag-name [FWS] "=" [FWS] tag-value [FWS]
tag-name  =  ALPHA 0*ALNUMPUNC
tag-value =  *VALCHAR    ; SWSP prohibited at beginning and end
VALCHAR   =  %9 / %d32 - %d58 / %d60 - %d126
                             ; HTAB and SP to TILDE except SEMICOLON
ALNUMPUNC =  ALPHA / DIGIT / "-"
                             ; alphanumeric plus hyphen.


Tag=value pairs that represent the default value MAY be included to
v=   Version (MUST NOT be included).  This tag is reserved for future
      use to indicate a possible new, incompatible version of the
      specification.  It MUST NOT be included in the DKIM-Signature
      header field.

a=   The algorithm used to generate the signature (plain-text;
      REQUIRED).  Signers and verifiers MUST support "rsa-sha1", an RSA-
      signed SHA-1 digest.  See section XINDX for a description of
      algorithms.

         INFORMATIVE RATIONALE:  The authors understand that SHA-1 has
         been theoretically compromised.  However, viable attacks
         require the attacker to choose both sets of input text; given a
         preexisting input (a "preimaging" attack), it is still hard to
         determine another input that produces an SHA-1 collision, and
         the chance that such input would be of value to an attacker is
         minimal.  Also, there is broad library for SHA-1, whereas
         alternatives such as SHA-256 are just emerging.  Finally, DKIM
         is not intended to have legal- or military-grade requirements.
         There is nothing inherent in using SHA-1 here other than
         implementer convenience.  See
         <http://www3.ietf.org/proceedings/05mar/slides/saag-3.pdf> for
         a discussion of the security issues.

b=   The signature data (base64; REQUIRED).  Whitespace is ignored in
      this value and MUST be ignored when re-assembling the original
      signature.  This is another way of saying that the signing process
      can safely insert FWS in this value in arbitrary places to conform
      to line-length limits.  See section [XINDX (Signer Actions)] for
      how the signature is computed.

c=   Body canonicalization (plain-text; OPTIONAL, default is
      "simple").  This tag informs the verifier of the type of
      canonicalization used to prepare the message for signing.  The
      semantics of this field is described in section XINDX above.

d=   The domain of the signing entity (plain-text; REQUIRED).  This
      is the domain that will be queried for the public key.  This
      domain MUST be the same as or a parent domain of the "i=" tag.
      When presented with a signature that does not meet this
      requirement, verifiers MUST either ignore the signature or reject
      the message..

h=   Signed header fields (plain-text, but see description;
      REQUIRED).  A colon-separated list of header field names that
      identify the header fields presented to the signing algorithm.
      The field MUST contain the complete list of header fields in the
      order presented to the signing algorithm.  The field MAY contain
      names of header fields that do not exist when signed; nonexistent
      header fields do not contribute to the signature computation (that
      is, they are treated as the null input, including the header field
      name, the separating colon, the header field value, and any CRLF
      terminator), and when verified non-existent header fields MUST be
      treated in the same way.  The field MUST NOT include the DKIM-
      Signature header field that is being created or verified.  Folding
      white space (FWS) MAY be included on either side of the colon
      separator.  Header field names MUST be compared against actual
      header field names in a case insensitive manner.

      ABNF:


sig-h-tag  = "h=" *FWS hdr-name 0*( *FWS ":" *FWS hdr-name )
hdr-name   = field-name
         INFORMATIVE EXPLANATION:  By "signing" header fields that do
         not actually exist, a signer can prevent insertion of those
         header fields before verification.  However, since a sender
         cannot possibly know what header fields might be created in the
         future, and that some MUAs might present header fields that are
         embedded inside a message (e.g., as a message/rfc822 content
         type), the security of this solution is not total.

         INFORMATIVE EXPLANATION:  The exclusion of the header field
         name and colon as well as the header field value for non-
         existent header fields prevents an attacker from inserting an
         actual header field with a null value.

i=   Identity of the user or agent (e.g., a mailing list manager) on
      behalf of which this message is signed (quoted-printable;
      OPTIONAL, default is an empty local-part followed by an "@"
      followed by the domain from the "d=" tag).  The syntax is a
      standard email address where the local-part is optional.  If the
      signing domain is unable or unwilling to commit to an individual
      user name within their domain, the local-part of the address MUST
      be omitted.  If the local-part of the address is omitted or the
      "i=" tag is not present, the key used to sign MUST be valid for
      any address in the domain.  The domain part of the address MUST be
      the same as or a subdomain of the value of the "d=" tag.

      ABNF:


sig-i-tag =     "i=" [ Local-part ] "@" Domain


         INFORMATIVE DISCUSSION:  This document does not require the
         value of the "i=" tag to match the identity in any message
         header field fields.  This is considered to be a verifier
         policy issue, described in another document [XREF-TBD].
         Constraints between the value of the "i=" tag and other
         identities in other header fields seek to apply basic
         authentication into the semantics of trust associated with a
         role such as content author.  Trust is a broad and complex
         topic and trust mechanisms are subject to highly creative
         attacks.  The real-world efficacy of any but the most basic
         bindings between the "i=" value and other identities is not
         well established, nor is its vulnerability to subversion by an
         attacker.  Hence reliance on the use of these options SHOULD be
         strictly limited.  In particular it is not at all clear to what
         extent a typical end-user recipient can rely on any assurances
         that might be made by successful use of the "i=" options.
l=   Body count (plain-text decimal integer; OPTIONAL, default is
      entire body).  This tag informs the verifier of the number of
      bytes in the body of the email included in the cryptographic hash,
      starting from 0 immediately following the CRLF preceding the body.

         INFORMATIVE IMPLEMENTATION WARNING:  Use of the l= tag might
         allow display of fraudulent content without appropriate warning
         to end users.  The l= tag is intended for increasing signature
         robustness when sending to mailing lists that both modify their
         content and do not sign their messages.  However, using the l=
         tag enables man-in-the-middle attacks in which an intermediary
         with malicious intent modifies a message to include content
         that solely benefits the attacker.  It is possible for the
         appended content to completely replace the original content in
         the end recipient's eyes and to defeat duplicate message
         detection algorithms.  Examples are described in Security
         Considerations [XINDX].

         To avoid this attack, signers should be extremely wary of using
         this tag, and verifiers might wish to ignore the tag or remove
         text that appears after the specified content length.

q=   A colon-separated list of query methods used to retrieve the
      public key (plain-text; OPTIONAL, default is "dns").  Each query
      method is of the form "type[/options]", where the syntax and
      semantics of the options depends on the type.  If there are
      multiple query mechanisms listed, the choice of query mechanism
      MUST NOT change the interpretation of the signature.  Currently
      the only valid value is "dns" which defines the DNS lookup
      algorithm described elsewhere in this document.  No options are
      defined for the "dns" query type, but the string "dns" MAY have a
      trailing "/" character.  Verifiers and signers MUST support "dns".

         INFORMATIVE RATIONALE:  Explicitly allowing a trailing "/" on
         "dns" allows for the possibility of adding options later and
         makes it clear that matching of the query type must terminate
         on either "/" or end of string.

s=   The selector subdividing the namespace for the "d=" (domain) tag
      (plain-text; REQUIRED).

t= Signature Timestamp (plain-text; RECOMMENDED, default is an
x=   Signature Expiration (plain-text; RECOMMENDED, default is no
      expiration).  Signature expiration in seconds-since-1970 format as
      an absolute date, not as a time delta from the signing timestamp.
      Signatures MUST NOT be considered valid if the current time at the
      verifier is past the expiration date.  The value is expressed as
      an unsigned integer in decimal ASCII.

         INFORMATIVE IMPLEMENTATION NOTE:  See above.

         INFORMATIVE NOTE:  The x= tag is not intended as an anti-replay
         defense.

z=   Copied header fields (plain-text, but see description; OPTIONAL,
      default is null).  A vertical-bar-separated list of header field
      names and copies of header field values that identify the header
      fields presented to the signing algorithm.  The field MUST contain
      the complete list of header fields in the order presented to the
      signing algorithm.  Copied header field values MUST immediately
      follow the header field name with a colon separator (no white
      space permitted).  Header field values MUST be represented as
      Quoted-Printable [XREF] with vertical bars, colons, semicolons,
      and white space encoded in addition to the usual requirements.

sig-z-tag    = "z=" *FWS hdr-copy *( *FWS "|" hdr-copy )
                        *FWS <hdr-copy =   hdr-name ":"
                        *FWS qp-hdr-value
qp-hdr-value = <quoted-printable text with WS,
                    "|", ":", and ";" encoded>
                        ; needs to be updated with real definition
                        ; (could be messy)


      INFORMATIVE EXAMPLE of a signature header field spread across
      multiple continuation lines:

c=simple; q=dns; i=@eng.example.net; t=1117574938; x=1118006938;
h=from:to:subject:date;
z=From:foo@eng.example.net|To:joe@example.com|
        Subject:demo%20run|Date:July%205,%202005%203:44:08%20PM%20-0700
b=dzdVyOfAKCdLXdJOc9G2q8LoXSlEniSbav+yuU4zGeeruD00lszZ
               VoG4ZHRNiYzR



v=   Version of the DKIM key record (plain-text; RECOMMENDED, default
      is "DKIM1").  If specified, this tag MUST be set to "DKIM1"
      (without the quotes).  This tag MUST be the first tag in the
      response.  Responses beginning with a "v=" tag with any other
      value MUST be discarded.

g=   granularity of the key (plain-text; OPTIONAL, default is "*").
      This value MUST match the local part of the signing address, with
      a "*" character acting as a wildcard.  The intent of this tag is
      to constrain which signing address can legitimately use this
      selector.  An email with a signing address that does not match the
      value of this tag constitutes a failed verification.  Wildcarding
      allows matching for addresses such as "user+*".  An empty "g="
      value never matches any addresses.

h=   Acceptable hash algorithms (plain-text; OPTIONAL, defaults to
      allowing all algorithms).  A colon-separated list of hash
      algorithms that might be used.  Signers and Verifiers MUST support
      the "sha1" hash algorithm.

k=   Key type (plain-text; OPTIONAL, default is "rsa").  Signers and
      verifiers MUST support the 'rsa' key type.

n=   Notes that might be of interest to a human (quoted-printable;
      OPTIONAL, default is empty).  No interpretation is made by any
      program.  This tag should be used sparingly in any key server
      mechanism that has space limitations (notably DNS).

p=   Public-key data (base64; REQUIRED).  An empty value means that
      this public key has been revoked.  The syntax and semantics of
      this tag value is defined by the k= tag.

s=   Service Type (plain-text; OPTIONAL; default is "*").  A colon-
      separated list of service types to which this record applies.
      Verifiers for a given service type MUST ignore this record if the
      appropriate type is not listed.  Currently defined service types
      are:

      *   matches all service types

      email   electronic mail (not necessarily limited to SMTP)

         This tag is intended to permit senders to constrain the use of
         delegated keys, e.g., where a company is willing to delegate
         the right to send mail in their name to an outsourcer, but not
         to send IM or make VoIP calls.  (This of course presumes that
         these keys are used in other services in the future.)
t=   Flags, represented as a colon-separated list of names (plain-
      text; OPTIONAL, default is no flags set).  The defined flags are:

      y   This domain is testing DKIM; unverified email MUST NOT be
         treated differently from verified email.  Verifier systems MAY
         wish to track testing mode results to assist the signer.

         Unrecognized flags MUST be ignored.


width=578 height=370>
c=simple; q=dns; i=joe@football.example.com;
h=Received : From : To : Subject : Date : Message-ID;
b=dzdVyOfAKCdLXdJOc9G2q8LoXSlEniSbav+yuU4zGeeruD00lszZ
           VoG4ZHRNiYzR;
c=simple; q=dns; i=joe@football.example.com;
h=Received : From : To : Subject : Date : Message-ID;
b=dzdVyOfAKCdLXdJOc9G2q8LoXSlEniSbav+yuU4zGeeruD00lszZ
             VoG4ZHRNiYzR
