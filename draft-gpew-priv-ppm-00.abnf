payload = context.Seal(time || nonce || extensions, input_share)

context = SetupBaseR(helper_share.enc, sk,
                        "pda input share" || task_id || server_role)
input_share = context.Open(time || nonce || extensions, helper_share)

encrypted_output_share = context.Seal(batch_interval, output_share)

   where pk is the HPKE public key encoded by the collector's HPKE key
   configuration, task_id is OutputShareReq.task_id and server_role is
   the role of the server (0x01 for the leader and 0x00 for the helper).
   output_share is the serialized OutputShare, and batch_interval is
   obtained from the OutputShareReq.

   This encryption prevents the leader from learning the actual result,
   as it only has its own share and not the helper's share, which is
   encrypted for the collector.  The helper responds to the collector
   with HTTP status 200 OK and a body consisting of the following
   structure:

   struct {
     HpkeConfigId collector_hpke_config_id;
     opaque enc<1..2^16-1>;
     opaque payload<1..2^16>;
   } EncryptedOutputShare;

   *  collector_hpke_config_id is collector_config.id from the task
      parameters corresponding to CollectReq.task_id.

   *  enc is the encapsulated HPKE context, used by the collector to
      decrypt the output share.

   *  payload is an encrypted OutputShare.
   The leader uses the helper's output share response to respond to the
   collector's collect request (see Section 4.4).

