<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" 
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html lang="en" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head profile="http://www.w3.org/2006/03/hcard%20http://dublincore.org/documents/2008/08/04/dc-html/">
  <meta http-equiv="Content-Type" content="text/html; charset=us-ascii" />

  <title>Common Interface to Cryptographic Modules (CICM) Channel Management </title>

  <style type="text/css" title="Xml2Rfc (sans serif)">
  /*<![CDATA[*/
	  a {
	  text-decoration: none;
	  }
	  a.smpl {
	  color: black;
	  }
	  a:hover {
	  text-decoration: underline;
	  }
	  a:active {
	  text-decoration: underline;
	  }
	  address {
	  margin-top: 1em;
	  margin-left: 2em;
	  font-style: normal;
	  }
	  body {
	  color: black;
	  font-family: verdana, helvetica, arial, sans-serif;
	  font-size: 10pt;
	  
	  }
	  cite {
	  font-style: normal;
	  }
	  dd {
	  margin-right: 2em;
	  }
	  dl {
	  margin-left: 2em;
	  }
	
	  ul.empty {
	  list-style-type: none;
	  }
	  ul.empty li {
	  margin-top: .5em;
	  }
	  dl p {
	  margin-left: 0em;
	  }
	  dt {
	  margin-top: .5em;
	  }
	  h1 {
	  font-size: 14pt;
	  line-height: 21pt;
	  page-break-after: avoid;
	  }
	  h1.np {
	  page-break-before: always;
	  }
	  h1 a {
	  color: #333333;
	  }
	  h2 {
	  font-size: 12pt;
	  line-height: 15pt;
	  page-break-after: avoid;
	  }
	  h3, h4, h5, h6 {
	  font-size: 10pt;
	  page-break-after: avoid;
	  }
	  h2 a, h3 a, h4 a, h5 a, h6 a {
	  color: black;
	  }
	  img {
	  margin-left: 3em;
	  }
	  li {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  ol {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  ol p {
	  margin-left: 0em;
	  }
	  p {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  pre {
	  margin-left: 3em;
	  background-color: lightyellow;
	  padding: .25em;
	  }
	  pre.text2 {
	  border-style: dotted;
	  border-width: 1px;
	  background-color: #f0f0f0;
	  width: 69em;
	  }
	  pre.inline {
	  background-color: white;
	  padding: 0em;
	  }
	  pre.text {
	  border-style: dotted;
	  border-width: 1px;
	  background-color: #f8f8f8;
	  width: 69em;
	  }
	  pre.drawing {
	  border-style: solid;
	  border-width: 1px;
	  background-color: #f8f8f8;
	  padding: 2em;
	  }
	  table {
	  margin-left: 2em;
	  }
	  table.tt {
	  vertical-align: top;
	  }
	  table.full {
	  border-style: outset;
	  border-width: 1px;
	  }
	  table.headers {
	  border-style: outset;
	  border-width: 1px;
	  }
	  table.tt td {
	  vertical-align: top;
	  }
	  table.full td {
	  border-style: inset;
	  border-width: 1px;
	  }
	  table.tt th {
	  vertical-align: top;
	  }
	  table.full th {
	  border-style: inset;
	  border-width: 1px;
	  }
	  table.headers th {
	  border-style: none none inset none;
	  border-width: 1px;
	  }
	  table.left {
	  margin-right: auto;
	  }
	  table.right {
	  margin-left: auto;
	  }
	  table.center {
	  margin-left: auto;
	  margin-right: auto;
	  }
	  caption {
	  caption-side: bottom;
	  font-weight: bold;
	  font-size: 9pt;
	  margin-top: .5em;
	  }
	
	  table.header {
	  border-spacing: 1px;
	  width: 95%;
	  font-size: 10pt;
	  color: white;
	  }
	  td.top {
	  vertical-align: top;
	  }
	  td.topnowrap {
	  vertical-align: top;
	  white-space: nowrap; 
	  }
	  table.header td {
	  background-color: gray;
	  width: 50%;
	  }
	  table.header a {
	  color: white;
	  }
	  td.reference {
	  vertical-align: top;
	  white-space: nowrap;
	  padding-right: 1em;
	  }
	  thead {
	  display:table-header-group;
	  }
	  ul.toc, ul.toc ul {
	  list-style: none;
	  margin-left: 1.5em;
	  margin-right: 0em;
	  padding-left: 0em;
	  }
	  ul.toc li {
	  line-height: 150%;
	  font-weight: bold;
	  font-size: 10pt;
	  margin-left: 0em;
	  margin-right: 0em;
	  }
	  ul.toc li li {
	  line-height: normal;
	  font-weight: normal;
	  font-size: 9pt;
	  margin-left: 0em;
	  margin-right: 0em;
	  }
	  li.excluded {
	  font-size: 0pt;
	  }
	  ul p {
	  margin-left: 0em;
	  }
	
	  .comment {
	  background-color: yellow;
	  }
	  .center {
	  text-align: center;
	  }
	  .error {
	  color: red;
	  font-style: italic;
	  font-weight: bold;
	  }
	  .figure {
	  font-weight: bold;
	  text-align: center;
	  font-size: 9pt;
	  }
	  .filename {
	  color: #333333;
	  font-weight: bold;
	  font-size: 12pt;
	  line-height: 21pt;
	  text-align: center;
	  }
	  .fn {
	  font-weight: bold;
	  }
	  .hidden {
	  display: none;
	  }
	  .left {
	  text-align: left;
	  }
	  .right {
	  text-align: right;
	  }
	  .title {
	  color: #990000;
	  font-size: 18pt;
	  line-height: 18pt;
	  font-weight: bold;
	  text-align: center;
	  margin-top: 36pt;
	  }
	  .vcardline {
	  display: block;
	  }
	  .warning {
	  font-size: 14pt;
	  background-color: yellow;
	  }
	
	
	  @media print {
	  .noprint {
		display: none;
	  }
	
	  a {
		color: black;
		text-decoration: none;
	  }
	
	  table.header {
		width: 90%;
	  }
	
	  td.header {
		width: 50%;
		color: black;
		background-color: white;
		vertical-align: top;
		font-size: 12pt;
	  }
	
	  ul.toc a::after {
		content: leader('.') target-counter(attr(href), page);
	  }
	
	  ul.ind li li a {
		content: target-counter(attr(href), page);
	  }
	
	  .print2col {
		column-count: 2;
		-moz-column-count: 2;
		column-fill: auto;
	  }
	  }
	
	  @page {
	  @top-left {
		   content: "Internet-Draft"; 
	  } 
	  @top-right {
		   content: "December 2010"; 
	  } 
	  @top-center {
		   content: "Abbreviated Title";3
	  } 
	  @bottom-left {
		   content: "Doe"; 
	  } 
	  @bottom-center {
		   content: "Expires June 2011"; 
	  } 
	  @bottom-right {
		   content: "[Page " counter(page) "]"; 
	  } 
	  }
	
	  @page:first { 
		@top-left {
		  content: normal;
		}
		@top-right {
		  content: normal;
		}
		@top-center {
		  content: normal;
		}
	  }
  /*]]>*/
  </style>

  <link href="#rfc.toc" rel="Contents">
<link href="#rfc.section.1" rel="Chapter" title="1 Introduction">
<link href="#rfc.section.1.1" rel="Chapter" title="1.1 Requirements Language">
<link href="#rfc.section.1.2" rel="Chapter" title="1.2 Definition Language">
<link href="#rfc.section.1.3" rel="Chapter" title="1.3 Conformance and Extension Language">
<link href="#rfc.section.2" rel="Chapter" title="2 CICM Dependencies">
<link href="#rfc.section.2.1" rel="Chapter" title="2.1 Namespaces">
<link href="#rfc.section.2.2" rel="Chapter" title="2.2 Types">
<link href="#rfc.section.2.3" rel="Chapter" title="2.3 Interfaces">
<link href="#rfc.section.3" rel="Chapter" title="3 Channel Namespaces">
<link href="#rfc.section.4" rel="Chapter" title="4 Channel Abstractions">
<link href="#rfc.section.4.1" rel="Chapter" title="4.1 Algorithm Types">
<link href="#rfc.section.4.2" rel="Chapter" title="4.2 State Vector">
<link href="#rfc.section.4.3" rel="Chapter" title="4.3 Integrity Buffers">
<link href="#rfc.section.4.4" rel="Chapter" title="4.4 Interface CICM::ChannelManager">
<link href="#rfc.section.4.4.1" rel="Chapter" title="4.4.1 CICM::ChannelManager Inheritance">
<link href="#rfc.section.4.4.2" rel="Chapter" title="4.4.2 CICM::ChannelManager Methods">
<link href="#rfc.section.4.5" rel="Chapter" title="4.5 Interface CICM::Channel">
<link href="#rfc.section.4.5.1" rel="Chapter" title="4.5.1 CICM::Channel Attributes">
<link href="#rfc.section.4.6" rel="Chapter" title="4.6 Interface CICM::Conduit">
<link href="#rfc.section.4.6.1" rel="Chapter" title="4.6.1 CICM::Conduit Inheritance">
<link href="#rfc.section.4.7" rel="Chapter" title="4.7 Interface CICM::Controller">
<link href="#rfc.section.4.7.1" rel="Chapter" title="4.7.1 CICM::Controller Inheritance">
<link href="#rfc.section.4.7.2" rel="Chapter" title="4.7.2 CICM::Controller Methods">
<link href="#rfc.section.4.8" rel="Chapter" title="4.8 Interface CICM::Stream">
<link href="#rfc.section.4.8.1" rel="Chapter" title="4.8.1 CICM::Stream Inheritance">
<link href="#rfc.section.5" rel="Chapter" title="5 Conduit Abstractions">
<link href="#rfc.section.5.1" rel="Chapter" title="5.1 Interface CICM::AbstractMACConduit">
<link href="#rfc.section.5.1.1" rel="Chapter" title="5.1.1 CICM::AbstractMACConduit Inheritance">
<link href="#rfc.section.5.1.2" rel="Chapter" title="5.1.2 CICM::AbstractMACConduit Attributes">
<link href="#rfc.section.5.1.3" rel="Chapter" title="5.1.3 CICM::AbstractMACConduit Methods">
<link href="#rfc.section.5.2" rel="Chapter" title="5.2 Interface CICM::AbstractSignConduit">
<link href="#rfc.section.5.2.1" rel="Chapter" title="5.2.1 CICM::AbstractSignConduit Inheritance">
<link href="#rfc.section.5.2.2" rel="Chapter" title="5.2.2 CICM::AbstractSignConduit Attributes">
<link href="#rfc.section.5.2.3" rel="Chapter" title="5.2.3 CICM::AbstractSignConduit Methods">
<link href="#rfc.section.5.3" rel="Chapter" title="5.3 Interface CICM::AbstractVerifyConduit">
<link href="#rfc.section.5.3.1" rel="Chapter" title="5.3.1 CICM::AbstractVerifyConduit Inheritance">
<link href="#rfc.section.5.3.2" rel="Chapter" title="5.3.2 CICM::AbstractVerifyConduit Types and Constants">
<link href="#rfc.section.5.4" rel="Chapter" title="5.4 Interface CICM::AbstractMACVerifyConduit">
<link href="#rfc.section.5.4.1" rel="Chapter" title="5.4.1 CICM::AbstractMACVerifyConduit Inheritance">
<link href="#rfc.section.5.4.2" rel="Chapter" title="5.4.2 CICM::AbstractMACVerifyConduit Attributes">
<link href="#rfc.section.5.4.3" rel="Chapter" title="5.4.3 CICM::AbstractMACVerifyConduit Methods">
<link href="#rfc.section.5.5" rel="Chapter" title="5.5 Interface CICM::AbstractSigVerifyConduit">
<link href="#rfc.section.5.5.1" rel="Chapter" title="5.5.1 CICM::AbstractSigVerifyConduit Inheritance">
<link href="#rfc.section.5.5.2" rel="Chapter" title="5.5.2 CICM::AbstractSigVerifyConduit Attributes">
<link href="#rfc.section.5.5.3" rel="Chapter" title="5.5.3 CICM::AbstractSigVerifyConduit Methods">
<link href="#rfc.section.6" rel="Chapter" title="6 Stream Abstractions">
<link href="#rfc.section.6.1" rel="Chapter" title="6.1 Interface CICM::WriteStream">
<link href="#rfc.section.6.1.1" rel="Chapter" title="6.1.1 CICM::WriteStream Inheritance">
<link href="#rfc.section.6.1.2" rel="Chapter" title="6.1.2 CICM::WriteStream Types and Constants">
<link href="#rfc.section.6.2" rel="Chapter" title="6.2 Interface CICM::ReadStream">
<link href="#rfc.section.6.2.1" rel="Chapter" title="6.2.1 CICM::ReadStream Inheritance">
<link href="#rfc.section.6.2.2" rel="Chapter" title="6.2.2 CICM::ReadStream Types and Constants">
<link href="#rfc.section.7" rel="Chapter" title="7 Controller Abstractions">
<link href="#rfc.section.7.1" rel="Chapter" title="7.1 Interface CICM::MultiDomainController">
<link href="#rfc.section.7.1.1" rel="Chapter" title="7.1.1 CICM::MultiDomainController Inheritance">
<link href="#rfc.section.7.1.2" rel="Chapter" title="7.1.2 CICM::MultiDomainController Attributes">
<link href="#rfc.section.7.2" rel="Chapter" title="7.2 Interface CICM::SymKeyController">
<link href="#rfc.section.7.2.1" rel="Chapter" title="7.2.1 CICM::SymKeyController Inheritance">
<link href="#rfc.section.7.2.2" rel="Chapter" title="7.2.2 CICM::SymKeyController Attributes">
<link href="#rfc.section.7.2.3" rel="Chapter" title="7.2.3 CICM::SymKeyController Methods">
<link href="#rfc.section.7.3" rel="Chapter" title="7.3 Interface CICM::AsymKeyController">
<link href="#rfc.section.7.3.1" rel="Chapter" title="7.3.1 CICM::AsymKeyController Inheritance">
<link href="#rfc.section.7.3.2" rel="Chapter" title="7.3.2 CICM::AsymKeyController Attributes">
<link href="#rfc.section.7.4" rel="Chapter" title="7.4 Interface CICM::NegotiatedController">
<link href="#rfc.section.7.4.1" rel="Chapter" title="7.4.1 CICM::NegotiatedController Inheritance">
<link href="#rfc.section.7.4.2" rel="Chapter" title="7.4.2 CICM::NegotiatedController Attributes">
<link href="#rfc.section.7.4.3" rel="Chapter" title="7.4.3 CICM::NegotiatedController Methods">
<link href="#rfc.section.7.5" rel="Chapter" title="7.5 Interface CICM::SetVectorController">
<link href="#rfc.section.7.5.1" rel="Chapter" title="7.5.1 CICM::SetVectorController Inheritance">
<link href="#rfc.section.7.5.2" rel="Chapter" title="7.5.2 CICM::SetVectorController Attributes">
<link href="#rfc.section.7.5.3" rel="Chapter" title="7.5.3 CICM::SetVectorController Methods">
<link href="#rfc.section.7.6" rel="Chapter" title="7.6 Interface CICM::GenVectorController">
<link href="#rfc.section.7.6.1" rel="Chapter" title="7.6.1 CICM::GenVectorController Inheritance">
<link href="#rfc.section.7.6.2" rel="Chapter" title="7.6.2 CICM::GenVectorController Methods">
<link href="#rfc.section.7.7" rel="Chapter" title="7.7 Interface CICM::ResyncController">
<link href="#rfc.section.7.7.1" rel="Chapter" title="7.7.1 CICM::ResyncController Inheritance">
<link href="#rfc.section.7.7.2" rel="Chapter" title="7.7.2 CICM::ResyncController Methods">
<link href="#rfc.section.8" rel="Chapter" title="8 Channel Negotiation">
<link href="#rfc.section.8.1" rel="Chapter" title="8.1 Negotiating Channels and Controllers">
<link href="#rfc.section.8.2" rel="Chapter" title="8.2 Interface CICM::Negotiator">
<link href="#rfc.section.8.2.1" rel="Chapter" title="8.2.1 CICM::Negotiator Methods">
<link href="#rfc.section.8.3" rel="Chapter" title="8.3 Interface CICM::PeerInfo">
<link href="#rfc.section.8.3.1" rel="Chapter" title="8.3.1 CICM::PeerInfo Attributes">
<link href="#rfc.section.9" rel="Chapter" title="9 Encryption">
<link href="#rfc.section.9.1" rel="Chapter" title="9.1 Interface CICM::Encrypt::ChannelManager">
<link href="#rfc.section.9.1.1" rel="Chapter" title="9.1.1 CICM::Encrypt::ChannelManager Methods">
<link href="#rfc.section.9.2" rel="Chapter" title="9.2 Interface CICM::Encrypt::Stream">
<link href="#rfc.section.9.2.1" rel="Chapter" title="9.2.1 CICM::Encrypt::Stream Inheritance">
<link href="#rfc.section.9.2.2" rel="Chapter" title="9.2.2 CICM::Encrypt::Stream Methods">
<link href="#rfc.section.9.3" rel="Chapter" title="9.3 Interface CICM::Encrypt::KeyWrapStream">
<link href="#rfc.section.9.3.1" rel="Chapter" title="9.3.1 CICM::Encrypt::KeyWrapStream Inheritance">
<link href="#rfc.section.9.3.2" rel="Chapter" title="9.3.2 CICM::Encrypt::KeyWrapStream Methods">
<link href="#rfc.section.9.4" rel="Chapter" title="9.4 Interface CICM::Encrypt::Controller">
<link href="#rfc.section.9.4.1" rel="Chapter" title="9.4.1 CICM::Encrypt::Controller Inheritance">
<link href="#rfc.section.9.5" rel="Chapter" title="9.5 Interface CICM::Encrypt::NegotiatedController">
<link href="#rfc.section.9.5.1" rel="Chapter" title="9.5.1 CICM::Encrypt::NegotiatedController Inheritance">
<link href="#rfc.section.9.6" rel="Chapter" title="9.6 Interface CICM::Encrypt::Conduit">
<link href="#rfc.section.9.6.1" rel="Chapter" title="9.6.1 CICM::Encrypt::Conduit Inheritance">
<link href="#rfc.section.9.7" rel="Chapter" title="9.7 Interface CICM::Encrypt::NegotiatedConduit">
<link href="#rfc.section.9.7.1" rel="Chapter" title="9.7.1 CICM::Encrypt::NegotiatedConduit Inheritance">
<link href="#rfc.section.9.8" rel="Chapter" title="9.8 Interface CICM::Encrypt::WithMACConduit">
<link href="#rfc.section.9.8.1" rel="Chapter" title="9.8.1 CICM::Encrypt::WithMACConduit Inheritance">
<link href="#rfc.section.9.9" rel="Chapter" title="9.9 Interface CICM::Encrypt::WithMACNegotiatedConduit">
<link href="#rfc.section.9.9.1" rel="Chapter" title="9.9.1 CICM::Encrypt::WithMACNegotiatedConduit Inheritance">
<link href="#rfc.section.9.10" rel="Chapter" title="9.10 Interface CICM::Encrypt::WithSignConduit">
<link href="#rfc.section.9.10.1" rel="Chapter" title="9.10.1 CICM::Encrypt::WithSignConduit Inheritance">
<link href="#rfc.section.9.11" rel="Chapter" title="9.11 Interface CICM::Encrypt::WithSignNegotiatedConduit">
<link href="#rfc.section.9.11.1" rel="Chapter" title="9.11.1 CICM::Encrypt::WithSignNegotiatedConduit Inheritance">
<link href="#rfc.section.9.12" rel="Chapter" title="9.12 Interface CICM::Encrypt::KeyWrapConduit">
<link href="#rfc.section.9.12.1" rel="Chapter" title="9.12.1 CICM::Encrypt::KeyWrapConduit Inheritance">
<link href="#rfc.section.9.13" rel="Chapter" title="9.13 Interface CICM::Encrypt::ControllerNegotiator">
<link href="#rfc.section.9.13.1" rel="Chapter" title="9.13.1 CICM::Encrypt::ControllerNegotiator Inheritance">
<link href="#rfc.section.9.13.2" rel="Chapter" title="9.13.2 CICM::Encrypt::ControllerNegotiator Methods">
<link href="#rfc.section.9.14" rel="Chapter" title="9.14 Interface CICM::Encrypt::Negotiator">
<link href="#rfc.section.9.14.1" rel="Chapter" title="9.14.1 CICM::Encrypt::Negotiator Inheritance">
<link href="#rfc.section.9.14.2" rel="Chapter" title="9.14.2 CICM::Encrypt::Negotiator Methods">
<link href="#rfc.section.9.15" rel="Chapter" title="9.15 Interface CICM::Encrypt::WithMACNegotiator">
<link href="#rfc.section.9.15.1" rel="Chapter" title="9.15.1 CICM::Encrypt::WithMACNegotiator Inheritance">
<link href="#rfc.section.9.15.2" rel="Chapter" title="9.15.2 CICM::Encrypt::WithMACNegotiator Methods">
<link href="#rfc.section.9.16" rel="Chapter" title="9.16 Interface CICM::Encrypt::WithSignNegotiator">
<link href="#rfc.section.9.16.1" rel="Chapter" title="9.16.1 CICM::Encrypt::WithSignNegotiator Inheritance">
<link href="#rfc.section.9.16.2" rel="Chapter" title="9.16.2 CICM::Encrypt::WithSignNegotiator Methods">
<link href="#rfc.section.10" rel="Chapter" title="10 Decryption">
<link href="#rfc.section.10.1" rel="Chapter" title="10.1 Interface CICM::Decrypt::ChannelManager">
<link href="#rfc.section.10.1.1" rel="Chapter" title="10.1.1 CICM::Decrypt::ChannelManager Methods">
<link href="#rfc.section.10.2" rel="Chapter" title="10.2 Interface CICM::Decrypt::Stream">
<link href="#rfc.section.10.2.1" rel="Chapter" title="10.2.1 CICM::Decrypt::Stream Inheritance">
<link href="#rfc.section.10.2.2" rel="Chapter" title="10.2.2 CICM::Decrypt::Stream Methods">
<link href="#rfc.section.10.3" rel="Chapter" title="10.3 Interface CICM::Decrypt::KeyUnwrapStream">
<link href="#rfc.section.10.3.1" rel="Chapter" title="10.3.1 CICM::Decrypt::KeyUnwrapStream Inheritance">
<link href="#rfc.section.10.3.2" rel="Chapter" title="10.3.2 CICM::Decrypt::KeyUnwrapStream Methods">
<link href="#rfc.section.10.4" rel="Chapter" title="10.4 Interface CICM::Decrypt::Controller">
<link href="#rfc.section.10.4.1" rel="Chapter" title="10.4.1 CICM::Decrypt::Controller Inheritance">
<link href="#rfc.section.10.5" rel="Chapter" title="10.5 Interface CICM::Decrypt::NegotiatedController">
<link href="#rfc.section.10.5.1" rel="Chapter" title="10.5.1 CICM::Decrypt::NegotiatedController Inheritance">
<link href="#rfc.section.10.6" rel="Chapter" title="10.6 Interface CICM::Decrypt::Conduit">
<link href="#rfc.section.10.6.1" rel="Chapter" title="10.6.1 CICM::Decrypt::Conduit Inheritance">
<link href="#rfc.section.10.7" rel="Chapter" title="10.7 Interface CICM::Decrypt::NegotiatedConduit">
<link href="#rfc.section.10.7.1" rel="Chapter" title="10.7.1 CICM::Decrypt::NegotiatedConduit Inheritance">
<link href="#rfc.section.10.8" rel="Chapter" title="10.8 Interface CICM::Decrypt::WithMACConduit">
<link href="#rfc.section.10.8.1" rel="Chapter" title="10.8.1 CICM::Decrypt::WithMACConduit Inheritance">
<link href="#rfc.section.10.9" rel="Chapter" title="10.9 Interface CICM::Decrypt::WithMACNegotiatedConduit">
<link href="#rfc.section.10.9.1" rel="Chapter" title="10.9.1 CICM::Decrypt::WithMACNegotiatedConduit Inheritance">
<link href="#rfc.section.10.10" rel="Chapter" title="10.10 Interface CICM::Decrypt::WithVerifyConduit">
<link href="#rfc.section.10.10.1" rel="Chapter" title="10.10.1 CICM::Decrypt::WithVerifyConduit Inheritance">
<link href="#rfc.section.10.11" rel="Chapter" title="10.11 Interface CICM::Decrypt::WithVerifyNegotiatedConduit">
<link href="#rfc.section.10.11.1" rel="Chapter" title="10.11.1 CICM::Decrypt::WithVerifyNegotiatedConduit Inheritance">
<link href="#rfc.section.10.12" rel="Chapter" title="10.12 Interface CICM::Decrypt::KeyUnwrapConduit">
<link href="#rfc.section.10.12.1" rel="Chapter" title="10.12.1 CICM::Decrypt::KeyUnwrapConduit Inheritance">
<link href="#rfc.section.10.13" rel="Chapter" title="10.13 Interface CICM::Decrypt::Negotiator">
<link href="#rfc.section.10.13.1" rel="Chapter" title="10.13.1 CICM::Decrypt::Negotiator Inheritance">
<link href="#rfc.section.10.13.2" rel="Chapter" title="10.13.2 CICM::Decrypt::Negotiator Methods">
<link href="#rfc.section.10.14" rel="Chapter" title="10.14 Interface CICM::Decrypt::ControllerNegotiator">
<link href="#rfc.section.10.14.1" rel="Chapter" title="10.14.1 CICM::Decrypt::ControllerNegotiator Inheritance">
<link href="#rfc.section.10.14.2" rel="Chapter" title="10.14.2 CICM::Decrypt::ControllerNegotiator Methods">
<link href="#rfc.section.10.15" rel="Chapter" title="10.15 Interface CICM::Decrypt::WithMACNegotiator">
<link href="#rfc.section.10.15.1" rel="Chapter" title="10.15.1 CICM::Decrypt::WithMACNegotiator Inheritance">
<link href="#rfc.section.10.15.2" rel="Chapter" title="10.15.2 CICM::Decrypt::WithMACNegotiator Methods">
<link href="#rfc.section.10.16" rel="Chapter" title="10.16 Interface CICM::Decrypt::WithVerifyNegotiator">
<link href="#rfc.section.10.16.1" rel="Chapter" title="10.16.1 CICM::Decrypt::WithVerifyNegotiator Inheritance">
<link href="#rfc.section.10.16.2" rel="Chapter" title="10.16.2 CICM::Decrypt::WithVerifyNegotiator Methods">
<link href="#rfc.section.11" rel="Chapter" title="11 Duplex">
<link href="#rfc.section.11.1" rel="Chapter" title="11.1 Interface CICM::Duplex::ChannelManager">
<link href="#rfc.section.11.1.1" rel="Chapter" title="11.1.1 CICM::Duplex::ChannelManager Methods">
<link href="#rfc.section.11.2" rel="Chapter" title="11.2 Interface CICM::Duplex::Stream">
<link href="#rfc.section.11.2.1" rel="Chapter" title="11.2.1 CICM::Duplex::Stream Inheritance">
<link href="#rfc.section.11.3" rel="Chapter" title="11.3 Interface CICM::Duplex::Controller">
<link href="#rfc.section.11.3.1" rel="Chapter" title="11.3.1 CICM::Duplex::Controller Inheritance">
<link href="#rfc.section.11.4" rel="Chapter" title="11.4 Interface CICM::Duplex::NegotiatedController">
<link href="#rfc.section.11.4.1" rel="Chapter" title="11.4.1 CICM::Duplex::NegotiatedController Inheritance">
<link href="#rfc.section.11.5" rel="Chapter" title="11.5 Interface CICM::Duplex::Conduit">
<link href="#rfc.section.11.5.1" rel="Chapter" title="11.5.1 CICM::Duplex::Conduit Inheritance">
<link href="#rfc.section.11.6" rel="Chapter" title="11.6 Interface CICM::Duplex::NegotiatedConduit">
<link href="#rfc.section.11.6.1" rel="Chapter" title="11.6.1 CICM::Duplex::NegotiatedConduit Inheritance">
<link href="#rfc.section.11.7" rel="Chapter" title="11.7 Interface CICM::Duplex::ControllerNegotiator">
<link href="#rfc.section.11.7.1" rel="Chapter" title="11.7.1 CICM::Duplex::ControllerNegotiator Inheritance">
<link href="#rfc.section.11.7.2" rel="Chapter" title="11.7.2 CICM::Duplex::ControllerNegotiator Methods">
<link href="#rfc.section.11.8" rel="Chapter" title="11.8 Interface CICM::Duplex::Negotiator">
<link href="#rfc.section.11.8.1" rel="Chapter" title="11.8.1 CICM::Duplex::Negotiator Inheritance">
<link href="#rfc.section.11.8.2" rel="Chapter" title="11.8.2 CICM::Duplex::Negotiator Methods">
<link href="#rfc.section.12" rel="Chapter" title="12 Bypass (Send)">
<link href="#rfc.section.12.1" rel="Chapter" title="12.1 Interface CICM::BypassWrite::ChannelManager">
<link href="#rfc.section.12.1.1" rel="Chapter" title="12.1.1 CICM::BypassWrite::ChannelManager Methods">
<link href="#rfc.section.12.2" rel="Chapter" title="12.2 Interface CICM::BypassWrite::Stream">
<link href="#rfc.section.12.2.1" rel="Chapter" title="12.2.1 CICM::BypassWrite::Stream Inheritance">
<link href="#rfc.section.12.2.2" rel="Chapter" title="12.2.2 CICM::BypassWrite::Stream Methods">
<link href="#rfc.section.12.3" rel="Chapter" title="12.3 Interface CICM::BypassWrite::Controller">
<link href="#rfc.section.12.3.1" rel="Chapter" title="12.3.1 CICM::BypassWrite::Controller Inheritance">
<link href="#rfc.section.12.4" rel="Chapter" title="12.4 Interface CICM::BypassWrite::Conduit">
<link href="#rfc.section.12.4.1" rel="Chapter" title="12.4.1 CICM::BypassWrite::Conduit Inheritance">
<link href="#rfc.section.13" rel="Chapter" title="13 Bypass (Read)">
<link href="#rfc.section.13.1" rel="Chapter" title="13.1 Interface CICM::BypassRead::ChannelManager">
<link href="#rfc.section.13.1.1" rel="Chapter" title="13.1.1 CICM::BypassRead::ChannelManager Methods">
<link href="#rfc.section.13.2" rel="Chapter" title="13.2 Interface CICM::BypassRead::Stream">
<link href="#rfc.section.13.2.1" rel="Chapter" title="13.2.1 CICM::BypassRead::Stream Inheritance">
<link href="#rfc.section.13.2.2" rel="Chapter" title="13.2.2 CICM::BypassRead::Stream Methods">
<link href="#rfc.section.13.3" rel="Chapter" title="13.3 Interface CICM::BypassRead::Controller">
<link href="#rfc.section.13.3.1" rel="Chapter" title="13.3.1 CICM::BypassRead::Controller Inheritance">
<link href="#rfc.section.13.4" rel="Chapter" title="13.4 Interface CICM::BypassRead::Conduit">
<link href="#rfc.section.13.4.1" rel="Chapter" title="13.4.1 CICM::BypassRead::Conduit Inheritance">
<link href="#rfc.section.14" rel="Chapter" title="14 Encryption with Selective Bypass">
<link href="#rfc.section.14.1" rel="Chapter" title="14.1 Interface CICM::EncryptBypass::ChannelManager">
<link href="#rfc.section.14.1.1" rel="Chapter" title="14.1.1 CICM::EncryptBypass::ChannelManager Methods">
<link href="#rfc.section.14.2" rel="Chapter" title="14.2 Interface CICM::EncryptBypass::Stream">
<link href="#rfc.section.14.2.1" rel="Chapter" title="14.2.1 CICM::EncryptBypass::Stream Inheritance">
<link href="#rfc.section.14.3" rel="Chapter" title="14.3 Interface CICM::EncryptBypass::NegotiatedController">
<link href="#rfc.section.14.3.1" rel="Chapter" title="14.3.1 CICM::EncryptBypass::NegotiatedController Inheritance">
<link href="#rfc.section.14.4" rel="Chapter" title="14.4 Interface CICM::EncryptBypass::Controller">
<link href="#rfc.section.14.4.1" rel="Chapter" title="14.4.1 CICM::EncryptBypass::Controller Inheritance">
<link href="#rfc.section.14.5" rel="Chapter" title="14.5 Interface CICM::EncryptBypass::Conduit">
<link href="#rfc.section.14.5.1" rel="Chapter" title="14.5.1 CICM::EncryptBypass::Conduit Inheritance">
<link href="#rfc.section.14.6" rel="Chapter" title="14.6 Interface CICM::EncryptBypass::NegotiatedConduit">
<link href="#rfc.section.14.6.1" rel="Chapter" title="14.6.1 CICM::EncryptBypass::NegotiatedConduit Inheritance">
<link href="#rfc.section.14.7" rel="Chapter" title="14.7 Interface CICM::EncryptBypass::ControllerNegotiator">
<link href="#rfc.section.14.7.1" rel="Chapter" title="14.7.1 CICM::EncryptBypass::ControllerNegotiator Inheritance">
<link href="#rfc.section.14.7.2" rel="Chapter" title="14.7.2 CICM::EncryptBypass::ControllerNegotiator Methods">
<link href="#rfc.section.14.8" rel="Chapter" title="14.8 Interface CICM::EncryptBypass::Negotiator">
<link href="#rfc.section.14.8.1" rel="Chapter" title="14.8.1 CICM::EncryptBypass::Negotiator Inheritance">
<link href="#rfc.section.14.8.2" rel="Chapter" title="14.8.2 CICM::EncryptBypass::Negotiator Methods">
<link href="#rfc.section.15" rel="Chapter" title="15 Decryption with Selective Bypass">
<link href="#rfc.section.15.1" rel="Chapter" title="15.1 Interface CICM::DecryptBypass::ChannelManager">
<link href="#rfc.section.15.1.1" rel="Chapter" title="15.1.1 CICM::DecryptBypass::ChannelManager Methods">
<link href="#rfc.section.15.2" rel="Chapter" title="15.2 Interface CICM::DecryptBypass::Stream">
<link href="#rfc.section.15.2.1" rel="Chapter" title="15.2.1 CICM::DecryptBypass::Stream Inheritance">
<link href="#rfc.section.15.3" rel="Chapter" title="15.3 Interface CICM::DecryptBypass::Controller">
<link href="#rfc.section.15.3.1" rel="Chapter" title="15.3.1 CICM::DecryptBypass::Controller Inheritance">
<link href="#rfc.section.15.4" rel="Chapter" title="15.4 Interface CICM::DecryptBypass::NegotiatedController">
<link href="#rfc.section.15.4.1" rel="Chapter" title="15.4.1 CICM::DecryptBypass::NegotiatedController Inheritance">
<link href="#rfc.section.15.5" rel="Chapter" title="15.5 Interface CICM::DecryptBypass::Conduit">
<link href="#rfc.section.15.5.1" rel="Chapter" title="15.5.1 CICM::DecryptBypass::Conduit Inheritance">
<link href="#rfc.section.15.6" rel="Chapter" title="15.6 Interface CICM::DecryptBypass::NegotiatedConduit">
<link href="#rfc.section.15.6.1" rel="Chapter" title="15.6.1 CICM::DecryptBypass::NegotiatedConduit Inheritance">
<link href="#rfc.section.15.7" rel="Chapter" title="15.7 Interface CICM::DecryptBypass::ControllerNegotiator">
<link href="#rfc.section.15.7.1" rel="Chapter" title="15.7.1 CICM::DecryptBypass::ControllerNegotiator Inheritance">
<link href="#rfc.section.15.7.2" rel="Chapter" title="15.7.2 CICM::DecryptBypass::ControllerNegotiator Methods">
<link href="#rfc.section.15.8" rel="Chapter" title="15.8 Interface CICM::DecryptBypass::Negotiator">
<link href="#rfc.section.15.8.1" rel="Chapter" title="15.8.1 CICM::DecryptBypass::Negotiator Inheritance">
<link href="#rfc.section.15.8.2" rel="Chapter" title="15.8.2 CICM::DecryptBypass::Negotiator Methods">
<link href="#rfc.section.16" rel="Chapter" title="16 Random, Pseudorandom and Keystream">
<link href="#rfc.section.16.1" rel="Chapter" title="16.1 Interface CICM::Emit::ChannelManager">
<link href="#rfc.section.16.1.1" rel="Chapter" title="16.1.1 CICM::Emit::ChannelManager Methods">
<link href="#rfc.section.16.2" rel="Chapter" title="16.2 Interface CICM::Emit::GetStream">
<link href="#rfc.section.16.2.1" rel="Chapter" title="16.2.1 CICM::Emit::GetStream Inheritance">
<link href="#rfc.section.16.2.2" rel="Chapter" title="16.2.2 CICM::Emit::GetStream Methods">
<link href="#rfc.section.16.3" rel="Chapter" title="16.3 Interface CICM::Emit::Controller">
<link href="#rfc.section.16.3.1" rel="Chapter" title="16.3.1 CICM::Emit::Controller Inheritance">
<link href="#rfc.section.16.3.2" rel="Chapter" title="16.3.2 CICM::Emit::Controller Attributes">
<link href="#rfc.section.16.4" rel="Chapter" title="16.4 Interface CICM::Emit::RandomController">
<link href="#rfc.section.16.4.1" rel="Chapter" title="16.4.1 CICM::Emit::RandomController Inheritance">
<link href="#rfc.section.16.5" rel="Chapter" title="16.5 Interface CICM::Emit::RandomConduit">
<link href="#rfc.section.16.5.1" rel="Chapter" title="16.5.1 CICM::Emit::RandomConduit Inheritance">
<link href="#rfc.section.16.6" rel="Chapter" title="16.6 Interface CICM::Emit::PseudoRandomController">
<link href="#rfc.section.16.6.1" rel="Chapter" title="16.6.1 CICM::Emit::PseudoRandomController Inheritance">
<link href="#rfc.section.16.7" rel="Chapter" title="16.7 Interface CICM::Emit::PseudoRandomConduit">
<link href="#rfc.section.16.7.1" rel="Chapter" title="16.7.1 CICM::Emit::PseudoRandomConduit Inheritance">
<link href="#rfc.section.16.8" rel="Chapter" title="16.8 Interface CICM::Emit::KeyStreamGenController">
<link href="#rfc.section.16.8.1" rel="Chapter" title="16.8.1 CICM::Emit::KeyStreamGenController Inheritance">
<link href="#rfc.section.16.9" rel="Chapter" title="16.9 Interface CICM::Emit::KeyStreamGenConduit">
<link href="#rfc.section.16.9.1" rel="Chapter" title="16.9.1 CICM::Emit::KeyStreamGenConduit Inheritance">
<link href="#rfc.section.17" rel="Chapter" title="17 Data Integrity">
<link href="#rfc.section.17.1" rel="Chapter" title="17.1 Interface CICM::Answer::ChannelManager">
<link href="#rfc.section.17.1.1" rel="Chapter" title="17.1.1 CICM::Answer::ChannelManager Methods">
<link href="#rfc.section.17.2" rel="Chapter" title="17.2 Interface CICM::Answer::PutStream">
<link href="#rfc.section.17.2.1" rel="Chapter" title="17.2.1 CICM::Answer::PutStream Inheritance">
<link href="#rfc.section.17.2.2" rel="Chapter" title="17.2.2 CICM::Answer::PutStream Methods">
<link href="#rfc.section.17.3" rel="Chapter" title="17.3 Interface CICM::Answer::HashConduit">
<link href="#rfc.section.17.3.1" rel="Chapter" title="17.3.1 CICM::Answer::HashConduit Inheritance">
<link href="#rfc.section.17.3.2" rel="Chapter" title="17.3.2 CICM::Answer::HashConduit Attributes">
<link href="#rfc.section.17.3.3" rel="Chapter" title="17.3.3 CICM::Answer::HashConduit Methods">
<link href="#rfc.section.17.4" rel="Chapter" title="17.4 Interface CICM::Answer::MACConduit">
<link href="#rfc.section.17.4.1" rel="Chapter" title="17.4.1 CICM::Answer::MACConduit Inheritance">
<link href="#rfc.section.17.5" rel="Chapter" title="17.5 Interface CICM::Answer::MACVerifyConduit">
<link href="#rfc.section.17.5.1" rel="Chapter" title="17.5.1 CICM::Answer::MACVerifyConduit Inheritance">
<link href="#rfc.section.17.6" rel="Chapter" title="17.6 Interface CICM::Answer::SignConduit">
<link href="#rfc.section.17.6.1" rel="Chapter" title="17.6.1 CICM::Answer::SignConduit Inheritance">
<link href="#rfc.section.17.7" rel="Chapter" title="17.7 Interface CICM::Answer::SignHashConduit">
<link href="#rfc.section.17.7.1" rel="Chapter" title="17.7.1 CICM::Answer::SignHashConduit Inheritance">
<link href="#rfc.section.17.8" rel="Chapter" title="17.8 Interface CICM::Answer::VerifyConduit">
<link href="#rfc.section.17.8.1" rel="Chapter" title="17.8.1 CICM::Answer::VerifyConduit Inheritance">
<link href="#rfc.section.17.9" rel="Chapter" title="17.9 Interface CICM::Answer::VerifyHashConduit">
<link href="#rfc.section.17.9.1" rel="Chapter" title="17.9.1 CICM::Answer::VerifyHashConduit Inheritance">
<link href="#rfc.section.18" rel="Chapter" title="18 Single-Domain">
<link href="#rfc.section.18.1" rel="Chapter" title="18.1 Interface CICM::Coprocessor::ChannelManager">
<link href="#rfc.section.18.1.1" rel="Chapter" title="18.1.1 CICM::Coprocessor::ChannelManager Methods">
<link href="#rfc.section.18.2" rel="Chapter" title="18.2 Interface CICM::Coprocessor::Stream">
<link href="#rfc.section.18.2.1" rel="Chapter" title="18.2.1 CICM::Coprocessor::Stream Inheritance">
<link href="#rfc.section.18.2.2" rel="Chapter" title="18.2.2 CICM::Coprocessor::Stream Methods">
<link href="#rfc.section.18.3" rel="Chapter" title="18.3 Interface CICM::Coprocessor::EncryptConduit">
<link href="#rfc.section.18.3.1" rel="Chapter" title="18.3.1 CICM::Coprocessor::EncryptConduit Inheritance">
<link href="#rfc.section.18.3.2" rel="Chapter" title="18.3.2 CICM::Coprocessor::EncryptConduit Methods">
<link href="#rfc.section.18.4" rel="Chapter" title="18.4 Interface CICM::Coprocessor::EncryptWithMACConduit">
<link href="#rfc.section.18.4.1" rel="Chapter" title="18.4.1 CICM::Coprocessor::EncryptWithMACConduit Inheritance">
<link href="#rfc.section.18.5" rel="Chapter" title="18.5 Interface CICM::Coprocessor::EncryptWithSignConduit">
<link href="#rfc.section.18.5.1" rel="Chapter" title="18.5.1 CICM::Coprocessor::EncryptWithSignConduit Inheritance">
<link href="#rfc.section.18.6" rel="Chapter" title="18.6 Interface CICM::Coprocessor::DecryptConduit">
<link href="#rfc.section.18.6.1" rel="Chapter" title="18.6.1 CICM::Coprocessor::DecryptConduit Inheritance">
<link href="#rfc.section.18.6.2" rel="Chapter" title="18.6.2 CICM::Coprocessor::DecryptConduit Methods">
<link href="#rfc.section.18.7" rel="Chapter" title="18.7 Interface CICM::Coprocessor::DecryptWithMACConduit">
<link href="#rfc.section.18.7.1" rel="Chapter" title="18.7.1 CICM::Coprocessor::DecryptWithMACConduit Inheritance">
<link href="#rfc.section.18.8" rel="Chapter" title="18.8 Interface CICM::Coprocessor::DecryptWithVerifyConduit">
<link href="#rfc.section.18.8.1" rel="Chapter" title="18.8.1 CICM::Coprocessor::DecryptWithVerifyConduit Inheritance">
<link href="#rfc.section.19" rel="Chapter" title="19 Channel Events">
<link href="#rfc.section.19.1" rel="Chapter" title="19.1 Interface CICM::ChannelEventManager">
<link href="#rfc.section.19.1.1" rel="Chapter" title="19.1.1 CICM::ChannelEventManager Methods">
<link href="#rfc.section.19.2" rel="Chapter" title="19.2 Interface CICM::ChannelEventListener">
<link href="#rfc.section.19.2.1" rel="Chapter" title="19.2.1 CICM::ChannelEventListener Types and Constants">
<link href="#rfc.section.19.2.2" rel="Chapter" title="19.2.2 CICM::ChannelEventListener Methods">
<link href="#rfc.section.20" rel="Chapter" title="20 Channel Groups">
<link href="#rfc.section.20.1" rel="Chapter" title="20.1 Interface CICM::ControllerGroup">
<link href="#rfc.section.20.1.1" rel="Chapter" title="20.1.1 CICM::ControllerGroup Methods">
<link href="#rfc.section.21" rel="Chapter" title="21 IANA Considerations">
<link href="#rfc.section.22" rel="Chapter" title="22 Security Considerations">
<link href="#rfc.section.22.1" rel="Chapter" title="22.1 Confidentiality">
<link href="#rfc.section.22.2" rel="Chapter" title="22.2 Bypass">
<link href="#rfc.section.22.3" rel="Chapter" title="22.3 Data Integrity">
<link href="#rfc.section.22.4" rel="Chapter" title="22.4 Peer Entity Authentication">
<link href="#rfc.references" rel="Chapter" title="23 References">
<link href="#rfc.references.1" rel="Chapter" title="23.1 Normative References">
<link href="#rfc.references.2" rel="Chapter" title="23.2 Informative References">
<link href="#rfc.appendix.Appendix%20A" rel="Chapter" title="Appendix A IDL Definitions">
<link href="#rfc.authors" rel="Chapter">


  <meta name="generator" content=
  "http://greenbytes.de/tech/webdav/rfc2629.xslt, Revision 1.539, 2011-01-02 17:13:00, XSLT vendor: SAXON 6.5.5 from Michael Kay http://saxon.sf.net/" />
  <link rel="schema.dct" href="http://purl.org/dc/terms/" />
  <meta name="dct.creator" content="Doe, J." />
  <meta name="dct.identifier" content="urn:ietf:id:draft-sample-input-00" />
  <meta name="dct.issued" scheme="ISO8601" content="2010-12" />
  
  <meta name="dct.abstract" content="[RFC Editor: Please update the RFC references prior to publication.]" />
  <meta name="description" content="[RFC Editor: Please update the RFC references prior to publication.]" />
  <meta name="keywords" content="" />

</head>

<body>

  <table class="header">
    <tbody>
    
    	<tr>
<td class="left">Internet Engineering Task Force</td>
<td class="right">D. Lanz</td>
</tr>
<tr>
<td class="left">Internet-Draft</td>
<td class="right">L. Novikov</td>
</tr>
<tr>
<td class="left">Intended status: Informational</td>
<td class="right">MITRE</td>
</tr>
<tr>
<td class="left">Expires: January 26, 2012</td>
<td class="right">July 25, 2011</td>
</tr>

    	
    </tbody>
  </table>

  <p class="title">Common Interface to Cryptographic Modules (CICM) Channel Management <br />
  <span class="filename">draft-lanz-cicm-cm-01</span></p>
  
  <h1 id="rfc.abstract"><a href="#rfc.abstract">Abstract</a></h1>
<p>[RFC Editor: Please update the RFC references prior to publication.]</p>
<p>This memo defines a programming interface for the management of cryptographic channels as outlined in draft-lanz-cicm-lm-00 and required by draft-lanz-cicm-02 including creating and negotiating channels for encryption, decryption, bypass, data integrity, or to generate random data.</p>
<p>Comments are solicited and should be addressed to the mailing list at cicm@ietf.org.</p>
<h1 id="rfc.status"><a href="#rfc.status">Status of this Memo</a></h1>
<p>This Internet-Draft is submitted in full conformance with the provisions of BCP 78 and BCP 79.</p>
<p>Internet-Drafts are working documents of the Internet Engineering Task Force (IETF).  Note that other groups may also distribute working documents as Internet-Drafts.  The list of current Internet- Drafts is at http://datatracker.ietf.org/drafts/current/.</p>
<p>Internet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other documents at any time.  It is inappropriate to use Internet-Drafts as reference material or to cite them other than as "work in progress."</p>
<p>This Internet-Draft will expire on January 26, 2012.</p>
<h1 id="rfc.copyrightnotice"><a href="#rfc.copyrightnotice">Copyright Notice</a></h1>
<p>Copyright (c) 2011 IETF Trust and the persons identified as the document authors.  All rights reserved.</p>
<p>This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document.  Please review these documents carefully, as they describe your rights and restrictions with respect to this document.  Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.</p>

  
  <hr class="noprint" />
  <h1 class="np" id="rfc.toc"><a href="#rfc.toc">Table of Contents</a></h1>
  <ul class="toc">

  	<li>1.   <a href="#rfc.section.1">Introduction</a>
</li>
<li>1.1.   <a href="#rfc.section.1.1">Requirements Language</a>
</li>
<li>1.2.   <a href="#rfc.section.1.2">Definition Language</a>
</li>
<li>1.3.   <a href="#rfc.section.1.3">Conformance and Extension Language</a>
</li>
<li>2.   <a href="#rfc.section.2">CICM Dependencies</a>
</li>
<li>2.1.   <a href="#rfc.section.2.1">Namespaces</a>
</li>
<li>2.2.   <a href="#rfc.section.2.2">Types</a>
</li>
<li>2.3.   <a href="#rfc.section.2.3">Interfaces</a>
</li>
<li>3.   <a href="#rfc.section.3">Channel Namespaces</a>
</li>
<li>4.   <a href="#rfc.section.4">Channel Abstractions</a>
</li>
<li>4.1.   <a href="#rfc.section.4.1">Algorithm Types</a>
</li>
<li>4.2.   <a href="#rfc.section.4.2">State Vector</a>
</li>
<li>4.3.   <a href="#rfc.section.4.3">Integrity Buffers</a>
</li>
<li>4.4.   <a href="#rfc.section.4.4">Interface CICM::ChannelManager</a>
</li>
<li>4.4.1.   <a href="#rfc.section.4.4.1">CICM::ChannelManager Inheritance</a>
</li>
<li>4.4.2.   <a href="#rfc.section.4.4.2">CICM::ChannelManager Methods</a>
</li>
<li>4.5.   <a href="#rfc.section.4.5">Interface CICM::Channel</a>
</li>
<li>4.5.1.   <a href="#rfc.section.4.5.1">CICM::Channel Attributes</a>
</li>
<li>4.6.   <a href="#rfc.section.4.6">Interface CICM::Conduit</a>
</li>
<li>4.6.1.   <a href="#rfc.section.4.6.1">CICM::Conduit Inheritance</a>
</li>
<li>4.7.   <a href="#rfc.section.4.7">Interface CICM::Controller</a>
</li>
<li>4.7.1.   <a href="#rfc.section.4.7.1">CICM::Controller Inheritance</a>
</li>
<li>4.7.2.   <a href="#rfc.section.4.7.2">CICM::Controller Methods</a>
</li>
<li>4.8.   <a href="#rfc.section.4.8">Interface CICM::Stream</a>
</li>
<li>4.8.1.   <a href="#rfc.section.4.8.1">CICM::Stream Inheritance</a>
</li>
<li>5.   <a href="#rfc.section.5">Conduit Abstractions</a>
</li>
<li>5.1.   <a href="#rfc.section.5.1">Interface CICM::AbstractMACConduit</a>
</li>
<li>5.1.1.   <a href="#rfc.section.5.1.1">CICM::AbstractMACConduit Inheritance</a>
</li>
<li>5.1.2.   <a href="#rfc.section.5.1.2">CICM::AbstractMACConduit Attributes</a>
</li>
<li>5.1.3.   <a href="#rfc.section.5.1.3">CICM::AbstractMACConduit Methods</a>
</li>
<li>5.2.   <a href="#rfc.section.5.2">Interface CICM::AbstractSignConduit</a>
</li>
<li>5.2.1.   <a href="#rfc.section.5.2.1">CICM::AbstractSignConduit Inheritance</a>
</li>
<li>5.2.2.   <a href="#rfc.section.5.2.2">CICM::AbstractSignConduit Attributes</a>
</li>
<li>5.2.3.   <a href="#rfc.section.5.2.3">CICM::AbstractSignConduit Methods</a>
</li>
<li>5.3.   <a href="#rfc.section.5.3">Interface CICM::AbstractVerifyConduit</a>
</li>
<li>5.3.1.   <a href="#rfc.section.5.3.1">CICM::AbstractVerifyConduit Inheritance</a>
</li>
<li>5.3.2.   <a href="#rfc.section.5.3.2">CICM::AbstractVerifyConduit Types and Constants</a>
</li>
<li>5.4.   <a href="#rfc.section.5.4">Interface CICM::AbstractMACVerifyConduit</a>
</li>
<li>5.4.1.   <a href="#rfc.section.5.4.1">CICM::AbstractMACVerifyConduit Inheritance</a>
</li>
<li>5.4.2.   <a href="#rfc.section.5.4.2">CICM::AbstractMACVerifyConduit Attributes</a>
</li>
<li>5.4.3.   <a href="#rfc.section.5.4.3">CICM::AbstractMACVerifyConduit Methods</a>
</li>
<li>5.5.   <a href="#rfc.section.5.5">Interface CICM::AbstractSigVerifyConduit</a>
</li>
<li>5.5.1.   <a href="#rfc.section.5.5.1">CICM::AbstractSigVerifyConduit Inheritance</a>
</li>
<li>5.5.2.   <a href="#rfc.section.5.5.2">CICM::AbstractSigVerifyConduit Attributes</a>
</li>
<li>5.5.3.   <a href="#rfc.section.5.5.3">CICM::AbstractSigVerifyConduit Methods</a>
</li>
<li>6.   <a href="#rfc.section.6">Stream Abstractions</a>
</li>
<li>6.1.   <a href="#rfc.section.6.1">Interface CICM::WriteStream</a>
</li>
<li>6.1.1.   <a href="#rfc.section.6.1.1">CICM::WriteStream Inheritance</a>
</li>
<li>6.1.2.   <a href="#rfc.section.6.1.2">CICM::WriteStream Types and Constants</a>
</li>
<li>6.2.   <a href="#rfc.section.6.2">Interface CICM::ReadStream</a>
</li>
<li>6.2.1.   <a href="#rfc.section.6.2.1">CICM::ReadStream Inheritance</a>
</li>
<li>6.2.2.   <a href="#rfc.section.6.2.2">CICM::ReadStream Types and Constants</a>
</li>
<li>7.   <a href="#rfc.section.7">Controller Abstractions</a>
</li>
<li>7.1.   <a href="#rfc.section.7.1">Interface CICM::MultiDomainController</a>
</li>
<li>7.1.1.   <a href="#rfc.section.7.1.1">CICM::MultiDomainController Inheritance</a>
</li>
<li>7.1.2.   <a href="#rfc.section.7.1.2">CICM::MultiDomainController Attributes</a>
</li>
<li>7.2.   <a href="#rfc.section.7.2">Interface CICM::SymKeyController</a>
</li>
<li>7.2.1.   <a href="#rfc.section.7.2.1">CICM::SymKeyController Inheritance</a>
</li>
<li>7.2.2.   <a href="#rfc.section.7.2.2">CICM::SymKeyController Attributes</a>
</li>
<li>7.2.3.   <a href="#rfc.section.7.2.3">CICM::SymKeyController Methods</a>
</li>
<li>7.3.   <a href="#rfc.section.7.3">Interface CICM::AsymKeyController</a>
</li>
<li>7.3.1.   <a href="#rfc.section.7.3.1">CICM::AsymKeyController Inheritance</a>
</li>
<li>7.3.2.   <a href="#rfc.section.7.3.2">CICM::AsymKeyController Attributes</a>
</li>
<li>7.4.   <a href="#rfc.section.7.4">Interface CICM::NegotiatedController</a>
</li>
<li>7.4.1.   <a href="#rfc.section.7.4.1">CICM::NegotiatedController Inheritance</a>
</li>
<li>7.4.2.   <a href="#rfc.section.7.4.2">CICM::NegotiatedController Attributes</a>
</li>
<li>7.4.3.   <a href="#rfc.section.7.4.3">CICM::NegotiatedController Methods</a>
</li>
<li>7.5.   <a href="#rfc.section.7.5">Interface CICM::SetVectorController</a>
</li>
<li>7.5.1.   <a href="#rfc.section.7.5.1">CICM::SetVectorController Inheritance</a>
</li>
<li>7.5.2.   <a href="#rfc.section.7.5.2">CICM::SetVectorController Attributes</a>
</li>
<li>7.5.3.   <a href="#rfc.section.7.5.3">CICM::SetVectorController Methods</a>
</li>
<li>7.6.   <a href="#rfc.section.7.6">Interface CICM::GenVectorController</a>
</li>
<li>7.6.1.   <a href="#rfc.section.7.6.1">CICM::GenVectorController Inheritance</a>
</li>
<li>7.6.2.   <a href="#rfc.section.7.6.2">CICM::GenVectorController Methods</a>
</li>
<li>7.7.   <a href="#rfc.section.7.7">Interface CICM::ResyncController</a>
</li>
<li>7.7.1.   <a href="#rfc.section.7.7.1">CICM::ResyncController Inheritance</a>
</li>
<li>7.7.2.   <a href="#rfc.section.7.7.2">CICM::ResyncController Methods</a>
</li>
<li>8.   <a href="#rfc.section.8">Channel Negotiation</a>
</li>
<li>8.1.   <a href="#rfc.section.8.1">Negotiating Channels and Controllers</a>
</li>
<li>8.2.   <a href="#rfc.section.8.2">Interface CICM::Negotiator</a>
</li>
<li>8.2.1.   <a href="#rfc.section.8.2.1">CICM::Negotiator Methods</a>
</li>
<li>8.3.   <a href="#rfc.section.8.3">Interface CICM::PeerInfo</a>
</li>
<li>8.3.1.   <a href="#rfc.section.8.3.1">CICM::PeerInfo Attributes</a>
</li>
<li>9.   <a href="#rfc.section.9">Encryption</a>
</li>
<li>9.1.   <a href="#rfc.section.9.1">Interface CICM::Encrypt::ChannelManager</a>
</li>
<li>9.1.1.   <a href="#rfc.section.9.1.1">CICM::Encrypt::ChannelManager Methods</a>
</li>
<li>9.2.   <a href="#rfc.section.9.2">Interface CICM::Encrypt::Stream</a>
</li>
<li>9.2.1.   <a href="#rfc.section.9.2.1">CICM::Encrypt::Stream Inheritance</a>
</li>
<li>9.2.2.   <a href="#rfc.section.9.2.2">CICM::Encrypt::Stream Methods</a>
</li>
<li>9.3.   <a href="#rfc.section.9.3">Interface CICM::Encrypt::KeyWrapStream</a>
</li>
<li>9.3.1.   <a href="#rfc.section.9.3.1">CICM::Encrypt::KeyWrapStream Inheritance</a>
</li>
<li>9.3.2.   <a href="#rfc.section.9.3.2">CICM::Encrypt::KeyWrapStream Methods</a>
</li>
<li>9.4.   <a href="#rfc.section.9.4">Interface CICM::Encrypt::Controller</a>
</li>
<li>9.4.1.   <a href="#rfc.section.9.4.1">CICM::Encrypt::Controller Inheritance</a>
</li>
<li>9.5.   <a href="#rfc.section.9.5">Interface CICM::Encrypt::NegotiatedController</a>
</li>
<li>9.5.1.   <a href="#rfc.section.9.5.1">CICM::Encrypt::NegotiatedController Inheritance</a>
</li>
<li>9.6.   <a href="#rfc.section.9.6">Interface CICM::Encrypt::Conduit</a>
</li>
<li>9.6.1.   <a href="#rfc.section.9.6.1">CICM::Encrypt::Conduit Inheritance</a>
</li>
<li>9.7.   <a href="#rfc.section.9.7">Interface CICM::Encrypt::NegotiatedConduit</a>
</li>
<li>9.7.1.   <a href="#rfc.section.9.7.1">CICM::Encrypt::NegotiatedConduit Inheritance</a>
</li>
<li>9.8.   <a href="#rfc.section.9.8">Interface CICM::Encrypt::WithMACConduit</a>
</li>
<li>9.8.1.   <a href="#rfc.section.9.8.1">CICM::Encrypt::WithMACConduit Inheritance</a>
</li>
<li>9.9.   <a href="#rfc.section.9.9">Interface CICM::Encrypt::WithMACNegotiatedConduit</a>
</li>
<li>9.9.1.   <a href="#rfc.section.9.9.1">CICM::Encrypt::WithMACNegotiatedConduit Inheritance</a>
</li>
<li>9.10.   <a href="#rfc.section.9.10">Interface CICM::Encrypt::WithSignConduit</a>
</li>
<li>9.10.1.   <a href="#rfc.section.9.10.1">CICM::Encrypt::WithSignConduit Inheritance</a>
</li>
<li>9.11.   <a href="#rfc.section.9.11">Interface CICM::Encrypt::WithSignNegotiatedConduit</a>
</li>
<li>9.11.1.   <a href="#rfc.section.9.11.1">CICM::Encrypt::WithSignNegotiatedConduit Inheritance</a>
</li>
<li>9.12.   <a href="#rfc.section.9.12">Interface CICM::Encrypt::KeyWrapConduit</a>
</li>
<li>9.12.1.   <a href="#rfc.section.9.12.1">CICM::Encrypt::KeyWrapConduit Inheritance</a>
</li>
<li>9.13.   <a href="#rfc.section.9.13">Interface CICM::Encrypt::ControllerNegotiator</a>
</li>
<li>9.13.1.   <a href="#rfc.section.9.13.1">CICM::Encrypt::ControllerNegotiator Inheritance</a>
</li>
<li>9.13.2.   <a href="#rfc.section.9.13.2">CICM::Encrypt::ControllerNegotiator Methods</a>
</li>
<li>9.14.   <a href="#rfc.section.9.14">Interface CICM::Encrypt::Negotiator</a>
</li>
<li>9.14.1.   <a href="#rfc.section.9.14.1">CICM::Encrypt::Negotiator Inheritance</a>
</li>
<li>9.14.2.   <a href="#rfc.section.9.14.2">CICM::Encrypt::Negotiator Methods</a>
</li>
<li>9.15.   <a href="#rfc.section.9.15">Interface CICM::Encrypt::WithMACNegotiator</a>
</li>
<li>9.15.1.   <a href="#rfc.section.9.15.1">CICM::Encrypt::WithMACNegotiator Inheritance</a>
</li>
<li>9.15.2.   <a href="#rfc.section.9.15.2">CICM::Encrypt::WithMACNegotiator Methods</a>
</li>
<li>9.16.   <a href="#rfc.section.9.16">Interface CICM::Encrypt::WithSignNegotiator</a>
</li>
<li>9.16.1.   <a href="#rfc.section.9.16.1">CICM::Encrypt::WithSignNegotiator Inheritance</a>
</li>
<li>9.16.2.   <a href="#rfc.section.9.16.2">CICM::Encrypt::WithSignNegotiator Methods</a>
</li>
<li>10.   <a href="#rfc.section.10">Decryption</a>
</li>
<li>10.1.   <a href="#rfc.section.10.1">Interface CICM::Decrypt::ChannelManager</a>
</li>
<li>10.1.1.   <a href="#rfc.section.10.1.1">CICM::Decrypt::ChannelManager Methods</a>
</li>
<li>10.2.   <a href="#rfc.section.10.2">Interface CICM::Decrypt::Stream</a>
</li>
<li>10.2.1.   <a href="#rfc.section.10.2.1">CICM::Decrypt::Stream Inheritance</a>
</li>
<li>10.2.2.   <a href="#rfc.section.10.2.2">CICM::Decrypt::Stream Methods</a>
</li>
<li>10.3.   <a href="#rfc.section.10.3">Interface CICM::Decrypt::KeyUnwrapStream</a>
</li>
<li>10.3.1.   <a href="#rfc.section.10.3.1">CICM::Decrypt::KeyUnwrapStream Inheritance</a>
</li>
<li>10.3.2.   <a href="#rfc.section.10.3.2">CICM::Decrypt::KeyUnwrapStream Methods</a>
</li>
<li>10.4.   <a href="#rfc.section.10.4">Interface CICM::Decrypt::Controller</a>
</li>
<li>10.4.1.   <a href="#rfc.section.10.4.1">CICM::Decrypt::Controller Inheritance</a>
</li>
<li>10.5.   <a href="#rfc.section.10.5">Interface CICM::Decrypt::NegotiatedController</a>
</li>
<li>10.5.1.   <a href="#rfc.section.10.5.1">CICM::Decrypt::NegotiatedController Inheritance</a>
</li>
<li>10.6.   <a href="#rfc.section.10.6">Interface CICM::Decrypt::Conduit</a>
</li>
<li>10.6.1.   <a href="#rfc.section.10.6.1">CICM::Decrypt::Conduit Inheritance</a>
</li>
<li>10.7.   <a href="#rfc.section.10.7">Interface CICM::Decrypt::NegotiatedConduit</a>
</li>
<li>10.7.1.   <a href="#rfc.section.10.7.1">CICM::Decrypt::NegotiatedConduit Inheritance</a>
</li>
<li>10.8.   <a href="#rfc.section.10.8">Interface CICM::Decrypt::WithMACConduit</a>
</li>
<li>10.8.1.   <a href="#rfc.section.10.8.1">CICM::Decrypt::WithMACConduit Inheritance</a>
</li>
<li>10.9.   <a href="#rfc.section.10.9">Interface CICM::Decrypt::WithMACNegotiatedConduit</a>
</li>
<li>10.9.1.   <a href="#rfc.section.10.9.1">CICM::Decrypt::WithMACNegotiatedConduit Inheritance</a>
</li>
<li>10.10.   <a href="#rfc.section.10.10">Interface CICM::Decrypt::WithVerifyConduit</a>
</li>
<li>10.10.1.   <a href="#rfc.section.10.10.1">CICM::Decrypt::WithVerifyConduit Inheritance</a>
</li>
<li>10.11.   <a href="#rfc.section.10.11">Interface CICM::Decrypt::WithVerifyNegotiatedConduit</a>
</li>
<li>10.11.1.   <a href="#rfc.section.10.11.1">CICM::Decrypt::WithVerifyNegotiatedConduit Inheritance</a>
</li>
<li>10.12.   <a href="#rfc.section.10.12">Interface CICM::Decrypt::KeyUnwrapConduit</a>
</li>
<li>10.12.1.   <a href="#rfc.section.10.12.1">CICM::Decrypt::KeyUnwrapConduit Inheritance</a>
</li>
<li>10.13.   <a href="#rfc.section.10.13">Interface CICM::Decrypt::Negotiator</a>
</li>
<li>10.13.1.   <a href="#rfc.section.10.13.1">CICM::Decrypt::Negotiator Inheritance</a>
</li>
<li>10.13.2.   <a href="#rfc.section.10.13.2">CICM::Decrypt::Negotiator Methods</a>
</li>
<li>10.14.   <a href="#rfc.section.10.14">Interface CICM::Decrypt::ControllerNegotiator</a>
</li>
<li>10.14.1.   <a href="#rfc.section.10.14.1">CICM::Decrypt::ControllerNegotiator Inheritance</a>
</li>
<li>10.14.2.   <a href="#rfc.section.10.14.2">CICM::Decrypt::ControllerNegotiator Methods</a>
</li>
<li>10.15.   <a href="#rfc.section.10.15">Interface CICM::Decrypt::WithMACNegotiator</a>
</li>
<li>10.15.1.   <a href="#rfc.section.10.15.1">CICM::Decrypt::WithMACNegotiator Inheritance</a>
</li>
<li>10.15.2.   <a href="#rfc.section.10.15.2">CICM::Decrypt::WithMACNegotiator Methods</a>
</li>
<li>10.16.   <a href="#rfc.section.10.16">Interface CICM::Decrypt::WithVerifyNegotiator</a>
</li>
<li>10.16.1.   <a href="#rfc.section.10.16.1">CICM::Decrypt::WithVerifyNegotiator Inheritance</a>
</li>
<li>10.16.2.   <a href="#rfc.section.10.16.2">CICM::Decrypt::WithVerifyNegotiator Methods</a>
</li>
<li>11.   <a href="#rfc.section.11">Duplex</a>
</li>
<li>11.1.   <a href="#rfc.section.11.1">Interface CICM::Duplex::ChannelManager</a>
</li>
<li>11.1.1.   <a href="#rfc.section.11.1.1">CICM::Duplex::ChannelManager Methods</a>
</li>
<li>11.2.   <a href="#rfc.section.11.2">Interface CICM::Duplex::Stream</a>
</li>
<li>11.2.1.   <a href="#rfc.section.11.2.1">CICM::Duplex::Stream Inheritance</a>
</li>
<li>11.3.   <a href="#rfc.section.11.3">Interface CICM::Duplex::Controller</a>
</li>
<li>11.3.1.   <a href="#rfc.section.11.3.1">CICM::Duplex::Controller Inheritance</a>
</li>
<li>11.4.   <a href="#rfc.section.11.4">Interface CICM::Duplex::NegotiatedController</a>
</li>
<li>11.4.1.   <a href="#rfc.section.11.4.1">CICM::Duplex::NegotiatedController Inheritance</a>
</li>
<li>11.5.   <a href="#rfc.section.11.5">Interface CICM::Duplex::Conduit</a>
</li>
<li>11.5.1.   <a href="#rfc.section.11.5.1">CICM::Duplex::Conduit Inheritance</a>
</li>
<li>11.6.   <a href="#rfc.section.11.6">Interface CICM::Duplex::NegotiatedConduit</a>
</li>
<li>11.6.1.   <a href="#rfc.section.11.6.1">CICM::Duplex::NegotiatedConduit Inheritance</a>
</li>
<li>11.7.   <a href="#rfc.section.11.7">Interface CICM::Duplex::ControllerNegotiator</a>
</li>
<li>11.7.1.   <a href="#rfc.section.11.7.1">CICM::Duplex::ControllerNegotiator Inheritance</a>
</li>
<li>11.7.2.   <a href="#rfc.section.11.7.2">CICM::Duplex::ControllerNegotiator Methods</a>
</li>
<li>11.8.   <a href="#rfc.section.11.8">Interface CICM::Duplex::Negotiator</a>
</li>
<li>11.8.1.   <a href="#rfc.section.11.8.1">CICM::Duplex::Negotiator Inheritance</a>
</li>
<li>11.8.2.   <a href="#rfc.section.11.8.2">CICM::Duplex::Negotiator Methods</a>
</li>
<li>12.   <a href="#rfc.section.12">Bypass (Send)</a>
</li>
<li>12.1.   <a href="#rfc.section.12.1">Interface CICM::BypassWrite::ChannelManager</a>
</li>
<li>12.1.1.   <a href="#rfc.section.12.1.1">CICM::BypassWrite::ChannelManager Methods</a>
</li>
<li>12.2.   <a href="#rfc.section.12.2">Interface CICM::BypassWrite::Stream</a>
</li>
<li>12.2.1.   <a href="#rfc.section.12.2.1">CICM::BypassWrite::Stream Inheritance</a>
</li>
<li>12.2.2.   <a href="#rfc.section.12.2.2">CICM::BypassWrite::Stream Methods</a>
</li>
<li>12.3.   <a href="#rfc.section.12.3">Interface CICM::BypassWrite::Controller</a>
</li>
<li>12.3.1.   <a href="#rfc.section.12.3.1">CICM::BypassWrite::Controller Inheritance</a>
</li>
<li>12.4.   <a href="#rfc.section.12.4">Interface CICM::BypassWrite::Conduit</a>
</li>
<li>12.4.1.   <a href="#rfc.section.12.4.1">CICM::BypassWrite::Conduit Inheritance</a>
</li>
<li>13.   <a href="#rfc.section.13">Bypass (Read)</a>
</li>
<li>13.1.   <a href="#rfc.section.13.1">Interface CICM::BypassRead::ChannelManager</a>
</li>
<li>13.1.1.   <a href="#rfc.section.13.1.1">CICM::BypassRead::ChannelManager Methods</a>
</li>
<li>13.2.   <a href="#rfc.section.13.2">Interface CICM::BypassRead::Stream</a>
</li>
<li>13.2.1.   <a href="#rfc.section.13.2.1">CICM::BypassRead::Stream Inheritance</a>
</li>
<li>13.2.2.   <a href="#rfc.section.13.2.2">CICM::BypassRead::Stream Methods</a>
</li>
<li>13.3.   <a href="#rfc.section.13.3">Interface CICM::BypassRead::Controller</a>
</li>
<li>13.3.1.   <a href="#rfc.section.13.3.1">CICM::BypassRead::Controller Inheritance</a>
</li>
<li>13.4.   <a href="#rfc.section.13.4">Interface CICM::BypassRead::Conduit</a>
</li>
<li>13.4.1.   <a href="#rfc.section.13.4.1">CICM::BypassRead::Conduit Inheritance</a>
</li>
<li>14.   <a href="#rfc.section.14">Encryption with Selective Bypass</a>
</li>
<li>14.1.   <a href="#rfc.section.14.1">Interface CICM::EncryptBypass::ChannelManager</a>
</li>
<li>14.1.1.   <a href="#rfc.section.14.1.1">CICM::EncryptBypass::ChannelManager Methods</a>
</li>
<li>14.2.   <a href="#rfc.section.14.2">Interface CICM::EncryptBypass::Stream</a>
</li>
<li>14.2.1.   <a href="#rfc.section.14.2.1">CICM::EncryptBypass::Stream Inheritance</a>
</li>
<li>14.3.   <a href="#rfc.section.14.3">Interface CICM::EncryptBypass::NegotiatedController</a>
</li>
<li>14.3.1.   <a href="#rfc.section.14.3.1">CICM::EncryptBypass::NegotiatedController Inheritance</a>
</li>
<li>14.4.   <a href="#rfc.section.14.4">Interface CICM::EncryptBypass::Controller</a>
</li>
<li>14.4.1.   <a href="#rfc.section.14.4.1">CICM::EncryptBypass::Controller Inheritance</a>
</li>
<li>14.5.   <a href="#rfc.section.14.5">Interface CICM::EncryptBypass::Conduit</a>
</li>
<li>14.5.1.   <a href="#rfc.section.14.5.1">CICM::EncryptBypass::Conduit Inheritance</a>
</li>
<li>14.6.   <a href="#rfc.section.14.6">Interface CICM::EncryptBypass::NegotiatedConduit</a>
</li>
<li>14.6.1.   <a href="#rfc.section.14.6.1">CICM::EncryptBypass::NegotiatedConduit Inheritance</a>
</li>
<li>14.7.   <a href="#rfc.section.14.7">Interface CICM::EncryptBypass::ControllerNegotiator</a>
</li>
<li>14.7.1.   <a href="#rfc.section.14.7.1">CICM::EncryptBypass::ControllerNegotiator Inheritance</a>
</li>
<li>14.7.2.   <a href="#rfc.section.14.7.2">CICM::EncryptBypass::ControllerNegotiator Methods</a>
</li>
<li>14.8.   <a href="#rfc.section.14.8">Interface CICM::EncryptBypass::Negotiator</a>
</li>
<li>14.8.1.   <a href="#rfc.section.14.8.1">CICM::EncryptBypass::Negotiator Inheritance</a>
</li>
<li>14.8.2.   <a href="#rfc.section.14.8.2">CICM::EncryptBypass::Negotiator Methods</a>
</li>
<li>15.   <a href="#rfc.section.15">Decryption with Selective Bypass</a>
</li>
<li>15.1.   <a href="#rfc.section.15.1">Interface CICM::DecryptBypass::ChannelManager</a>
</li>
<li>15.1.1.   <a href="#rfc.section.15.1.1">CICM::DecryptBypass::ChannelManager Methods</a>
</li>
<li>15.2.   <a href="#rfc.section.15.2">Interface CICM::DecryptBypass::Stream</a>
</li>
<li>15.2.1.   <a href="#rfc.section.15.2.1">CICM::DecryptBypass::Stream Inheritance</a>
</li>
<li>15.3.   <a href="#rfc.section.15.3">Interface CICM::DecryptBypass::Controller</a>
</li>
<li>15.3.1.   <a href="#rfc.section.15.3.1">CICM::DecryptBypass::Controller Inheritance</a>
</li>
<li>15.4.   <a href="#rfc.section.15.4">Interface CICM::DecryptBypass::NegotiatedController</a>
</li>
<li>15.4.1.   <a href="#rfc.section.15.4.1">CICM::DecryptBypass::NegotiatedController Inheritance</a>
</li>
<li>15.5.   <a href="#rfc.section.15.5">Interface CICM::DecryptBypass::Conduit</a>
</li>
<li>15.5.1.   <a href="#rfc.section.15.5.1">CICM::DecryptBypass::Conduit Inheritance</a>
</li>
<li>15.6.   <a href="#rfc.section.15.6">Interface CICM::DecryptBypass::NegotiatedConduit</a>
</li>
<li>15.6.1.   <a href="#rfc.section.15.6.1">CICM::DecryptBypass::NegotiatedConduit Inheritance</a>
</li>
<li>15.7.   <a href="#rfc.section.15.7">Interface CICM::DecryptBypass::ControllerNegotiator</a>
</li>
<li>15.7.1.   <a href="#rfc.section.15.7.1">CICM::DecryptBypass::ControllerNegotiator Inheritance</a>
</li>
<li>15.7.2.   <a href="#rfc.section.15.7.2">CICM::DecryptBypass::ControllerNegotiator Methods</a>
</li>
<li>15.8.   <a href="#rfc.section.15.8">Interface CICM::DecryptBypass::Negotiator</a>
</li>
<li>15.8.1.   <a href="#rfc.section.15.8.1">CICM::DecryptBypass::Negotiator Inheritance</a>
</li>
<li>15.8.2.   <a href="#rfc.section.15.8.2">CICM::DecryptBypass::Negotiator Methods</a>
</li>
<li>16.   <a href="#rfc.section.16">Random, Pseudorandom and Keystream</a>
</li>
<li>16.1.   <a href="#rfc.section.16.1">Interface CICM::Emit::ChannelManager</a>
</li>
<li>16.1.1.   <a href="#rfc.section.16.1.1">CICM::Emit::ChannelManager Methods</a>
</li>
<li>16.2.   <a href="#rfc.section.16.2">Interface CICM::Emit::GetStream</a>
</li>
<li>16.2.1.   <a href="#rfc.section.16.2.1">CICM::Emit::GetStream Inheritance</a>
</li>
<li>16.2.2.   <a href="#rfc.section.16.2.2">CICM::Emit::GetStream Methods</a>
</li>
<li>16.3.   <a href="#rfc.section.16.3">Interface CICM::Emit::Controller</a>
</li>
<li>16.3.1.   <a href="#rfc.section.16.3.1">CICM::Emit::Controller Inheritance</a>
</li>
<li>16.3.2.   <a href="#rfc.section.16.3.2">CICM::Emit::Controller Attributes</a>
</li>
<li>16.4.   <a href="#rfc.section.16.4">Interface CICM::Emit::RandomController</a>
</li>
<li>16.4.1.   <a href="#rfc.section.16.4.1">CICM::Emit::RandomController Inheritance</a>
</li>
<li>16.5.   <a href="#rfc.section.16.5">Interface CICM::Emit::RandomConduit</a>
</li>
<li>16.5.1.   <a href="#rfc.section.16.5.1">CICM::Emit::RandomConduit Inheritance</a>
</li>
<li>16.6.   <a href="#rfc.section.16.6">Interface CICM::Emit::PseudoRandomController</a>
</li>
<li>16.6.1.   <a href="#rfc.section.16.6.1">CICM::Emit::PseudoRandomController Inheritance</a>
</li>
<li>16.7.   <a href="#rfc.section.16.7">Interface CICM::Emit::PseudoRandomConduit</a>
</li>
<li>16.7.1.   <a href="#rfc.section.16.7.1">CICM::Emit::PseudoRandomConduit Inheritance</a>
</li>
<li>16.8.   <a href="#rfc.section.16.8">Interface CICM::Emit::KeyStreamGenController</a>
</li>
<li>16.8.1.   <a href="#rfc.section.16.8.1">CICM::Emit::KeyStreamGenController Inheritance</a>
</li>
<li>16.9.   <a href="#rfc.section.16.9">Interface CICM::Emit::KeyStreamGenConduit</a>
</li>
<li>16.9.1.   <a href="#rfc.section.16.9.1">CICM::Emit::KeyStreamGenConduit Inheritance</a>
</li>
<li>17.   <a href="#rfc.section.17">Data Integrity</a>
</li>
<li>17.1.   <a href="#rfc.section.17.1">Interface CICM::Answer::ChannelManager</a>
</li>
<li>17.1.1.   <a href="#rfc.section.17.1.1">CICM::Answer::ChannelManager Methods</a>
</li>
<li>17.2.   <a href="#rfc.section.17.2">Interface CICM::Answer::PutStream</a>
</li>
<li>17.2.1.   <a href="#rfc.section.17.2.1">CICM::Answer::PutStream Inheritance</a>
</li>
<li>17.2.2.   <a href="#rfc.section.17.2.2">CICM::Answer::PutStream Methods</a>
</li>
<li>17.3.   <a href="#rfc.section.17.3">Interface CICM::Answer::HashConduit</a>
</li>
<li>17.3.1.   <a href="#rfc.section.17.3.1">CICM::Answer::HashConduit Inheritance</a>
</li>
<li>17.3.2.   <a href="#rfc.section.17.3.2">CICM::Answer::HashConduit Attributes</a>
</li>
<li>17.3.3.   <a href="#rfc.section.17.3.3">CICM::Answer::HashConduit Methods</a>
</li>
<li>17.4.   <a href="#rfc.section.17.4">Interface CICM::Answer::MACConduit</a>
</li>
<li>17.4.1.   <a href="#rfc.section.17.4.1">CICM::Answer::MACConduit Inheritance</a>
</li>
<li>17.5.   <a href="#rfc.section.17.5">Interface CICM::Answer::MACVerifyConduit</a>
</li>
<li>17.5.1.   <a href="#rfc.section.17.5.1">CICM::Answer::MACVerifyConduit Inheritance</a>
</li>
<li>17.6.   <a href="#rfc.section.17.6">Interface CICM::Answer::SignConduit</a>
</li>
<li>17.6.1.   <a href="#rfc.section.17.6.1">CICM::Answer::SignConduit Inheritance</a>
</li>
<li>17.7.   <a href="#rfc.section.17.7">Interface CICM::Answer::SignHashConduit</a>
</li>
<li>17.7.1.   <a href="#rfc.section.17.7.1">CICM::Answer::SignHashConduit Inheritance</a>
</li>
<li>17.8.   <a href="#rfc.section.17.8">Interface CICM::Answer::VerifyConduit</a>
</li>
<li>17.8.1.   <a href="#rfc.section.17.8.1">CICM::Answer::VerifyConduit Inheritance</a>
</li>
<li>17.9.   <a href="#rfc.section.17.9">Interface CICM::Answer::VerifyHashConduit</a>
</li>
<li>17.9.1.   <a href="#rfc.section.17.9.1">CICM::Answer::VerifyHashConduit Inheritance</a>
</li>
<li>18.   <a href="#rfc.section.18">Single-Domain</a>
</li>
<li>18.1.   <a href="#rfc.section.18.1">Interface CICM::Coprocessor::ChannelManager</a>
</li>
<li>18.1.1.   <a href="#rfc.section.18.1.1">CICM::Coprocessor::ChannelManager Methods</a>
</li>
<li>18.2.   <a href="#rfc.section.18.2">Interface CICM::Coprocessor::Stream</a>
</li>
<li>18.2.1.   <a href="#rfc.section.18.2.1">CICM::Coprocessor::Stream Inheritance</a>
</li>
<li>18.2.2.   <a href="#rfc.section.18.2.2">CICM::Coprocessor::Stream Methods</a>
</li>
<li>18.3.   <a href="#rfc.section.18.3">Interface CICM::Coprocessor::EncryptConduit</a>
</li>
<li>18.3.1.   <a href="#rfc.section.18.3.1">CICM::Coprocessor::EncryptConduit Inheritance</a>
</li>
<li>18.3.2.   <a href="#rfc.section.18.3.2">CICM::Coprocessor::EncryptConduit Methods</a>
</li>
<li>18.4.   <a href="#rfc.section.18.4">Interface CICM::Coprocessor::EncryptWithMACConduit</a>
</li>
<li>18.4.1.   <a href="#rfc.section.18.4.1">CICM::Coprocessor::EncryptWithMACConduit Inheritance</a>
</li>
<li>18.5.   <a href="#rfc.section.18.5">Interface CICM::Coprocessor::EncryptWithSignConduit</a>
</li>
<li>18.5.1.   <a href="#rfc.section.18.5.1">CICM::Coprocessor::EncryptWithSignConduit Inheritance</a>
</li>
<li>18.6.   <a href="#rfc.section.18.6">Interface CICM::Coprocessor::DecryptConduit</a>
</li>
<li>18.6.1.   <a href="#rfc.section.18.6.1">CICM::Coprocessor::DecryptConduit Inheritance</a>
</li>
<li>18.6.2.   <a href="#rfc.section.18.6.2">CICM::Coprocessor::DecryptConduit Methods</a>
</li>
<li>18.7.   <a href="#rfc.section.18.7">Interface CICM::Coprocessor::DecryptWithMACConduit</a>
</li>
<li>18.7.1.   <a href="#rfc.section.18.7.1">CICM::Coprocessor::DecryptWithMACConduit Inheritance</a>
</li>
<li>18.8.   <a href="#rfc.section.18.8">Interface CICM::Coprocessor::DecryptWithVerifyConduit</a>
</li>
<li>18.8.1.   <a href="#rfc.section.18.8.1">CICM::Coprocessor::DecryptWithVerifyConduit Inheritance</a>
</li>
<li>19.   <a href="#rfc.section.19">Channel Events</a>
</li>
<li>19.1.   <a href="#rfc.section.19.1">Interface CICM::ChannelEventManager</a>
</li>
<li>19.1.1.   <a href="#rfc.section.19.1.1">CICM::ChannelEventManager Methods</a>
</li>
<li>19.2.   <a href="#rfc.section.19.2">Interface CICM::ChannelEventListener</a>
</li>
<li>19.2.1.   <a href="#rfc.section.19.2.1">CICM::ChannelEventListener Types and Constants</a>
</li>
<li>19.2.2.   <a href="#rfc.section.19.2.2">CICM::ChannelEventListener Methods</a>
</li>
<li>20.   <a href="#rfc.section.20">Channel Groups</a>
</li>
<li>20.1.   <a href="#rfc.section.20.1">Interface CICM::ControllerGroup</a>
</li>
<li>20.1.1.   <a href="#rfc.section.20.1.1">CICM::ControllerGroup Methods</a>
</li>
<li>21.   <a href="#rfc.section.21">IANA Considerations</a>
</li>
<li>22.   <a href="#rfc.section.22">Security Considerations</a>
</li>
<li>22.1.   <a href="#rfc.section.22.1">Confidentiality</a>
</li>
<li>22.2.   <a href="#rfc.section.22.2">Bypass</a>
</li>
<li>22.3.   <a href="#rfc.section.22.3">Data Integrity</a>
</li>
<li>22.4.   <a href="#rfc.section.22.4">Peer Entity Authentication</a>
</li>
<li>23.   <a href="#rfc.references">References</a>
</li>
<li>23.1.   <a href="#rfc.references.1">Normative References</a>
</li>
<li>23.2.   <a href="#rfc.references.2">Informative References</a>
</li>
<li>Appendix A.   <a href="#rfc.appendix.Appendix%20A">IDL Definitions</a>
</li>
<li><a href="#rfc.authors">Authors' Addresses</a>
</li>


  </ul>

  <h1 id="rfc.section.1">
<a href="#rfc.section.1">1.</a> Introduction</h1>
<p id="rfc.section.1.p.1">This document defines the key management functions for the Common Interface to Cryptographic Modules (CICM) as defined in <a href="#CICM">[CICM]</a>. The underlying logical model and terminology is defined in <a href="#CICM-LM">[CICM-LM]</a>.</p>
<h1 id="rfc.section.1.1">
<a href="#rfc.section.1.1">1.1.</a> Requirements Language</h1>
<p id="rfc.section.1.1.p.1">The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in <a href="#RFC2119">[RFC2119]</a>.</p>
<h1 id="rfc.section.1.2">
<a href="#rfc.section.1.2">1.2.</a> Definition Language</h1>
<p id="rfc.section.1.2.p.1">This document uses the Interface Definition Language (IDL) <a href="#IDL">[IDL]</a> to specify language-neutral interfaces and is not intended to prescribe or preclude a particular communications protocol such as General Inter-ORB Protocol (GIOP) <a href="#CORBA">[CORBA]</a> between programs in different address spaces or on different devices. In other words, any specific protocol is strictly OPTIONAL. See Definition Language in <a href="#CICM">[CICM]</a> for more information.  </p>
<h1 id="rfc.section.1.3">
<a href="#rfc.section.1.3">1.3.</a> Conformance and Extension Language</h1>
<p id="rfc.section.1.3.p.1">This document contains definitions for several opaque data parameters whose format is not defined by CICM. Instead, implementers are required to create an Implementation Conformance Statement which MUST reference a standard format or define a module developer-specific format implemented by the module for these datatypes. See Conformance and Extensions in <a href="#CICM">[CICM]</a> for more details.</p>
<h1 id="rfc.section.2">
<a href="#rfc.section.2">2.</a> CICM Dependencies</h1>
<p id="rfc.section.2.p.1">This document depends on type definitions and interfaces that are defined in other CICM documents.</p>
<h1 id="rfc.section.2.1">
<a href="#rfc.section.2.1">2.1.</a> Namespaces</h1>
<p id="rfc.section.2.1.p.1">The CICM namespace is defined in <a href="#CICM">[CICM]</a>.</p>
<h1 id="rfc.section.2.2">
<a href="#rfc.section.2.2">2.2.</a> Types</h1>
<p id="rfc.section.2.2.p.1">The following type definitions are defined in <a href="#CICM">[CICM]</a>: </p>

<ul class="empty">
<li>CICM::UInt32</li>
<li>CICM::CharString</li>
<li>CICM::Buffer</li>
<li>CICM::Status (including all return values)</li>
<li>CICM::LocalPort</li>
<li>CICM::RemotePort</li>
<li>CICM::Classification</li>
</ul>

<p> </p>
<h1 id="rfc.section.2.3">
<a href="#rfc.section.2.3">2.3.</a> Interfaces</h1>
<p id="rfc.section.2.3.p.1">The interface CICM::Iterator is defined in <a href="#CICM">[CICM]</a>; CICM::Key, CICM::AsymKey and CICM::SymKey are defined in <a href="#CICM-KM">[CICM-KM]</a>.</p>
<h1 id="rfc.section.3">
<a href="#rfc.section.3">3.</a> Channel Namespaces</h1>
<p id="rfc.section.3.p.1">Due to the large number of potential configurations, the definitions of the channel types and their operations are divided into ten namespaces which group together similar or related types of channels.</p>
<p id="rfc.section.3.p.2">The namespaces are: <a href="#CICM-LM">[CICM-LM]</a> for a high level description of the channel types or below for the channel definitions.</p>

<ol>
<li>CICM::Encrypt (<a href="#sec-encrypt">Section 9</a>)</li>
<li>CICM::Decrypt (<a href="#sec-decrypt">Section 10</a>)</li>
<li>CICM::Duplex (<a href="#sec-duplex">Section 11</a>)</li>
<li>CICM::BypassWrite (<a href="#sec-bypass-write">Section 12</a>)</li>
<li>CICM::BypassRead (<a href="#sec-bypass-read">Section 13</a>)</li>
<li>CICM::EncryptBypass (<a href="#sec-encrypt-bypass">Section 14</a>)</li>
<li>CICM::DecryptBypass (<a href="#sec-decrypt-bypass">Section 15</a>)</li>
<li>CICM::Emit (<a href="#sec-emit">Section 16</a>)</li>
<li>CICM::Answer (<a href="#sec-answer">Section 17</a>)</li>
<li>CICM::Coprocessor (<a href="#sec-coprocessor">Section 18</a>)</li>
</ol>

<p> See </p>
<h1 id="rfc.section.4">
<a href="#rfc.section.4">4.</a> Channel Abstractions</h1>
<h1 id="rfc.section.4.1">
<a href="#rfc.section.4.1">4.1.</a> Algorithm Types</h1>
<div id="#rfc.figure.1"></div>
<p>Type CICM::HashAlgorithmId</p>
<pre>typedef CICM::CharString HashAlgorithmId;</pre>
<p>Unique hash algorithm identifier.</p>
<div id="#rfc.figure.2"></div>
<p>Type CICM::AsymEncrAlgorithmId</p>
<pre>typedef CICM::CharString AsymEncrAlgorithmId;</pre>
<p>Unique asymmetric encryption algorithm identifier.</p>
<div id="#rfc.figure.3"></div>
<p>Constant CICM::IMPLICIT_ASYM_ENCR_ALGO</p>
<pre>const CICM::AsymEncrAlgorithmId
IMPLICIT_ASYM_ENCR_ALGO = "IMPLICIT";</pre>
<p>Value that indicates that the encryption algorithm is implicit in the key being provided to the module.</p>
<div id="#rfc.figure.4"></div>
<p>Type CICM::AsymSigAlgorithmId</p>
<pre>typedef CICM::CharString
AsymSigAlgorithmId;</pre>
<p>Unique asymmetric signature algorithm identifier.</p>
<div id="#rfc.figure.5"></div>
<p>Constant CICM::IMPLICIT_ASYM_SIG_ALGO</p>
<pre>const CICM::AsymSigAlgorithmId
IMPLICIT_ASYM_SIG_ALGO = "IMPLICIT";</pre>
<p>Value that indicates that the signature algorithm is implicit in the key being provided to the module.</p>
<div id="#rfc.figure.6"></div>
<p>Type CICM::KeyWrapAlgorithmId</p>
<pre>typedef CICM::CharString
KeyWrapAlgorithmId;</pre>
<p>Unique key wrap algorithm identifier, incorporating both the algorithm and the mode.</p>
<div id="#rfc.figure.7"></div>
<p>Constant CICM::IMPLICIT_KEY_WRAP_ALGO</p>
<pre>const CICM::KeyWrapAlgorithmId
IMPLICIT_KEY_WRAP_ALGO = "IMPLICIT";</pre>
<p>Value that indicates that the key wrap algorithm is implicit in the key being provided to the module.</p>
<div id="#rfc.figure.8"></div>
<p>Type CICM::SymEncrAlgorithmId</p>
<pre>typedef CICM::CharString SymEncrAlgorithmId;</pre>
<p>Unique symmetric encryption algorithm identifier, incorporating both the algorithm and the mode.</p>
<div id="#rfc.figure.9"></div>
<p>Constant CICM::IMPLICIT_SYM_ENCR_ALGO</p>
<pre>const CICM::SymEncrAlgorithmId
IMPLICIT_SYM_ENCR_ALGO = "IMPLICIT";</pre>
<p>Value that indicates that the encryption algorithm is implicit in the key being provided to the module.</p>
<div id="#rfc.figure.10"></div>
<p>Type CICM::SymMacAlgorithmId</p>
<pre>typedef CICM::CharString SymMacAlgorithmId;</pre>
<p>Unique symmetric MAC algorithm identifier.</p>
<div id="#rfc.figure.11"></div>
<p>Constant CICM::IMPLICIT_SYM_MAC_ALGO</p>
<pre>const CICM::SymMacAlgorithmId
IMPLICIT_SYM_MAC_ALGO = "IMPLICIT";</pre>
<p>Value that indicates that the MAC algorithm is implicit in the key being provided to the module.</p>
<div id="#rfc.figure.12"></div>
<p>Type CICM::ProtocolId</p>
<pre>typedef CICM::CharString ProtocolId;</pre>
<p>Unique key agreement protocol identifier.</p>
<div id="#rfc.figure.13"></div>
<p>Constant CICM::IMPLICIT_PROTOCOL_ID</p>
<pre>const CICM::ProtocolId
IMPLICIT_PROTOCOL_ID = "IMPLICIT";</pre>
<p>Value that indicates that the key agreement protocol is implicit in the message being provided to the module.</p>
<h1 id="rfc.section.4.2">
<a href="#rfc.section.4.2">4.2.</a> State Vector</h1>
<div id="#rfc.figure.14"></div>
<p>Type CICM::Vector</p>
<pre>typedef CICM::Buffer Vector;</pre>
<p>State vector, used to represent initialization vectors, synchronization vectors, counter values, and time-of-day values.</p>
<h1 id="rfc.section.4.3">
<a href="#rfc.section.4.3">4.3.</a> Integrity Buffers</h1>
<div id="#rfc.figure.15"></div>
<p>Type CICM::HashBuffer</p>
<pre>typedef CICM::Buffer HashBuffer;</pre>
<p>Cryptographic hash.</p>
<div id="#rfc.figure.16"></div>
<p>Type CICM::MACBuffer</p>
<pre>typedef CICM::Buffer MACBuffer;</pre>
<p>Message authentication code (MAC).</p>
<div id="#rfc.figure.17"></div>
<p>Type CICM::SigBuffer</p>
<pre>typedef CICM::Buffer SigBuffer;</pre>
<p>Cryptographic signature.</p>
<h1 id="rfc.section.4.4">
<a href="#rfc.section.4.4">4.4.</a> Interface CICM::ChannelManager</h1>
<div id="#rfc.figure.18"></div>
<p>Interface CICM::ChannelManager</p>
<pre>interface ChannelManager :
	CICM::Answer::ChannelManager,
	CICM::BypassRead::ChannelManager,
	CICM::BypassWrite::ChannelManager,
	CICM::Coprocessor::ChannelManager,
	CICM::Decrypt::ChannelManager,
	CICM::DecryptBypass::ChannelManager,
	CICM::Duplex::ChannelManager,
	CICM::Emit::ChannelManager,
	CICM::Encrypt::ChannelManager,
	CICM::EncryptBypass::ChannelManager {</pre>
<p>CICM::ChannelManager supports the creation and negotiation of cryptographic channels. It is accessed from CICM::CryptoModule via the CICM::CryptoModule::channel_manager attribute.  CICM::ChannelManager enables a variety of different channel types to be constructed.</p>
<p id="rfc.section.4.4.p.1">Note: </p>

<ul class="empty"><li>Conforming implementations need only implement one or more of the ChannelManager's dependencies thereby limiting which negotiators, controllers, streams, and channels are available. See Conformance and Extensions in <a href="#CICM">[CICM]</a> for more information.</li></ul>

<p> </p>
<h1 id="rfc.section.4.4.1">
<a href="#rfc.section.4.4.1">4.4.1.</a> CICM::ChannelManager Inheritance</h1>
<p id="rfc.section.4.4.1.p.1">CICM::ChannelManager inherits from: CICM::Answer::ChannelManager, CICM::BypassRead::ChannelManager, CICM::BypassWrite::ChannelManager, CICM::Coprocessor::ChannelManager, CICM::Decrypt::ChannelManager, CICM::DecryptBypass::ChannelManager, CICM::Duplex::ChannelManager, CICM::Emit::ChannelManager, CICM::Encrypt::ChannelManager and CICM::EncryptBypass::ChannelManager.</p>
<h1 id="rfc.section.4.4.2">
<a href="#rfc.section.4.4.2">4.4.2.</a> CICM::ChannelManager Methods</h1>
<div id="#rfc.figure.19"></div>
<p>Method CICM::ChannelManager::create_controller_group()</p>
<pre>CICM::Status create_controller_group(
	out CICM::ControllerGroup controller_group_ref
);</pre>
<p>Creates a CICM::ControllerGroup to group controllers and conduits together.</p>
<p id="rfc.section.4.4.2.p.1">Parameters: </p>

<ul class="empty"><li>[out] controller_group_ref Reference to the created controller group.</li></ul>

<p> </p>
<p id="rfc.section.4.4.2.p.2">Returns: </p>

<ul class="empty"><li>S_OK, S_GENERAL_ERROR, S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION, S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE, S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT, S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT</li></ul>

<p> </p>
<h1 id="rfc.section.4.5">
<a href="#rfc.section.4.5">4.5.</a> Interface CICM::Channel</h1>
<div id="#rfc.figure.20"></div>
<p>Interface CICM::Channel</p>
<pre>interface Channel {</pre>
<p>Defines the logical path through the module. Interface from which all conduit, streams and controllers inherit.  Channels are created via the CICM::ChannelManager interface.</p>
<h1 id="rfc.section.4.5.1">
<a href="#rfc.section.4.5.1">4.5.1.</a> CICM::Channel Attributes</h1>
<div id="#rfc.figure.21"></div>
<p>AttributeCICM::Channel::event_manager</p>
<pre>readonly attribute CICM::ChannelEventManager event_manager;</pre>
<p>Provides access to the event manager.</p>
<h1 id="rfc.section.4.6">
<a href="#rfc.section.4.6">4.6.</a> Interface CICM::Conduit</h1>
<div id="#rfc.figure.22"></div>
<p>Interface CICM::Conduit</p>
<pre>interface Conduit :
	CICM::Controller,
	CICM::Stream {</pre>
<p>Interface from which all other conduits are inherited. A conduit is a combination of a stream and controller.</p>
<h1 id="rfc.section.4.6.1">
<a href="#rfc.section.4.6.1">4.6.1.</a> CICM::Conduit Inheritance</h1>
<p id="rfc.section.4.6.1.p.1">CICM::Conduit inherits from: CICM::Controller and CICM::Stream.</p>
<h1 id="rfc.section.4.7">
<a href="#rfc.section.4.7">4.7.</a> Interface CICM::Controller</h1>
<div id="#rfc.figure.23"></div>
<p>Interface CICM::Controller</p>
<pre>interface Controller : CICM::Channel {</pre>
<p>Interface from which all other controllers are inherited.  Controls general characteristics of a cryptographic transformation, but does not provide data to be transformed.</p>
<p id="rfc.section.4.7.p.1">Remarks: </p>

<ul class="empty"><li>There may be cases in which a client program wishes to delegate responsibility for sending or receiving data from the module to another process while retaining the authority to manage the channel. To support this task, both processes must share a known local port. The client-program responsible for controlling the channel creates a CICM::Controller of the appropriate type after which the corresponding CICM::Stream may be obtained by the second process. A stream is tied to the specific controller that configured the channel by a common port value.</li></ul>

<p> </p>
<h1 id="rfc.section.4.7.1">
<a href="#rfc.section.4.7.1">4.7.1.</a> CICM::Controller Inheritance</h1>
<p id="rfc.section.4.7.1.p.1">CICM::Controller inherits from: CICM::Channel.</p>
<h1 id="rfc.section.4.7.2">
<a href="#rfc.section.4.7.2">4.7.2.</a> CICM::Controller Methods</h1>
<div id="#rfc.figure.24"></div>
<p>Method CICM::Controller::destroy()</p>
<pre>CICM::Status destroy();</pre>
<p>Destroys the controller.</p>
<p id="rfc.section.4.7.2.p.1">Returns: </p>

<ul class="empty"><li>S_OK, S_GENERAL_ERROR, S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION, S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE, S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT, S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT</li></ul>

<p> </p>
<h1 id="rfc.section.4.8">
<a href="#rfc.section.4.8">4.8.</a> Interface CICM::Stream</h1>
<div id="#rfc.figure.25"></div>
<p>Interface CICM::Stream</p>
<pre>interface Stream : CICM::Channel {};</pre>
<p>Interface from which all streams inherit. Streams manage the flow of data on a channel, but not its attributes.</p>
<h1 id="rfc.section.4.8.1">
<a href="#rfc.section.4.8.1">4.8.1.</a> CICM::Stream Inheritance</h1>
<p id="rfc.section.4.8.1.p.1">CICM::Stream inherits from: CICM::Channel.</p>
<h1 id="rfc.section.5">
<a href="#rfc.section.5">5.</a> Conduit Abstractions</h1>
<h1 id="rfc.section.5.1">
<a href="#rfc.section.5.1">5.1.</a> Interface CICM::AbstractMACConduit</h1>
<div id="#rfc.figure.26"></div>
<p>Interface CICM::AbstractMACConduit</p>
<pre>interface AbstractMACConduit : CICM::Conduit {</pre>
<p>Interface from which other MAC conduits are inherited.</p>
<h1 id="rfc.section.5.1.1">
<a href="#rfc.section.5.1.1">5.1.1.</a> CICM::AbstractMACConduit Inheritance</h1>
<p id="rfc.section.5.1.1.p.1">CICM::AbstractMACConduit inherits from: CICM::Conduit.</p>
<h1 id="rfc.section.5.1.2">
<a href="#rfc.section.5.1.2">5.1.2.</a> CICM::AbstractMACConduit Attributes</h1>
<div id="#rfc.figure.27"></div>
<p>AttributeCICM::AbstractMACConduit::mac_key</p>
<pre>readonly attribute CICM::SymKey mac_key;</pre>
<p>The key used for computing the MAC.</p>
<div id="#rfc.figure.28"></div>
<p>AttributeCICM::AbstractMACConduit::mac_algorithm</p>
<pre>readonly attribute CICM::SymMacAlgorithmId mac_algorithm;</pre>
<p>The algorithm used to MAC the data.</p>
<h1 id="rfc.section.5.1.3">
<a href="#rfc.section.5.1.3">5.1.3.</a> CICM::AbstractMACConduit Methods</h1>
<div id="#rfc.figure.29"></div>
<p>Method CICM::AbstractMACConduit::end_get_mac()</p>
<pre>CICM::Status end_get_mac(
	out CICM::MACBuffer mac
);</pre>
<p>Direct the module to compute and output the MAC value, and reset the channel to accept additional data.</p>
<p id="rfc.section.5.1.3.p.1">Parameters: </p>

<ul class="empty"><li>[out] mac Computed MAC value.</li></ul>

<p> </p>
<p id="rfc.section.5.1.3.p.2">Returns: </p>

<ul class="empty"><li>S_OK, S_GENERAL_ERROR, S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION, S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE, S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT, S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR, S_CHANNEL_PEER_RESET</li></ul>

<p> </p>
<h1 id="rfc.section.5.2">
<a href="#rfc.section.5.2">5.2.</a> Interface CICM::AbstractSignConduit</h1>
<div id="#rfc.figure.30"></div>
<p>Interface CICM::AbstractSignConduit</p>
<pre>interface AbstractSignConduit : CICM::Conduit {</pre>
<p>Interface from which other sign conduits are inherited.</p>
<h1 id="rfc.section.5.2.1">
<a href="#rfc.section.5.2.1">5.2.1.</a> CICM::AbstractSignConduit Inheritance</h1>
<p id="rfc.section.5.2.1.p.1">CICM::AbstractSignConduit inherits from: CICM::Conduit.</p>
<h1 id="rfc.section.5.2.2">
<a href="#rfc.section.5.2.2">5.2.2.</a> CICM::AbstractSignConduit Attributes</h1>
<div id="#rfc.figure.31"></div>
<p>AttributeCICM::AbstractSignConduit::sign_key</p>
<pre>readonly attribute CICM::AsymKey sign_key;</pre>
<p>Key used for signing the data.</p>
<div id="#rfc.figure.32"></div>
<p>AttributeCICM::AbstractSignConduit::sign_algorithm</p>
<pre>readonly attribute CICM::AsymSigAlgorithmId sign_algorithm;</pre>
<p>Algorithm used to sign the data.</p>
<h1 id="rfc.section.5.2.3">
<a href="#rfc.section.5.2.3">5.2.3.</a> CICM::AbstractSignConduit Methods</h1>
<div id="#rfc.figure.33"></div>
<p>Method CICM::AbstractSignConduit::end_get_signature()</p>
<pre>CICM::Status end_get_signature(
	out CICM::SigBuffer signature
);</pre>
<p>Direct the module to compute and output the signature, and reset the conduit to accept additional data.</p>
<p id="rfc.section.5.2.3.p.1">Parameters: </p>

<ul class="empty"><li>[out] signature The computed signature.</li></ul>

<p> </p>
<p id="rfc.section.5.2.3.p.2">Returns: </p>

<ul class="empty"><li>S_OK, S_GENERAL_ERROR, S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION, S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE, S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT, S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR, S_CHANNEL_PEER_RESET</li></ul>

<p> </p>
<h1 id="rfc.section.5.3">
<a href="#rfc.section.5.3">5.3.</a> Interface CICM::AbstractVerifyConduit</h1>
<div id="#rfc.figure.34"></div>
<p>Interface CICM::AbstractVerifyConduit</p>
<pre>interface AbstractVerifyConduit : CICM::Conduit {</pre>
<p>Interface from which other verification conduits are inherited.</p>
<h1 id="rfc.section.5.3.1">
<a href="#rfc.section.5.3.1">5.3.1.</a> CICM::AbstractVerifyConduit Inheritance</h1>
<p id="rfc.section.5.3.1.p.1">CICM::AbstractVerifyConduit inherits from: CICM::Conduit.</p>
<h1 id="rfc.section.5.3.2">
<a href="#rfc.section.5.3.2">5.3.2.</a> CICM::AbstractVerifyConduit Types and Constants</h1>
<div id="#rfc.figure.35"></div>
<p>Type CICM::AbstractVerifyConduit::VerifyStatus</p>
<pre>typedef CICM::UInt32 VerifyStatus;</pre>
<p>Verification status (data verifies/does not verify).</p>
<div id="#rfc.figure.36"></div>
<p>Constant CICM::AbstractVerifyConduit::C_DATA_VERIFIED</p>
<pre>const CICM::AbstractVerifyConduit::VerifyStatus
	C_DATA_VERIFIED = 0x00006025;</pre>
<p>Data verifies.</p>
<div id="#rfc.figure.37"></div>
<p>Constant CICM::AbstractVerifyConduit::C_DATA_NOT_VERIFIED</p>
<pre>const CICM::AbstractVerifyConduit::VerifyStatus
C_DATA_NOT_VERIFIED = 0x00006026;</pre>
<p>Data does not verify.</p>
<h1 id="rfc.section.5.4">
<a href="#rfc.section.5.4">5.4.</a> Interface CICM::AbstractMACVerifyConduit</h1>
<div id="#rfc.figure.38"></div>
<p>Interface CICM::AbstractMACVerifyConduit</p>
<pre>interface AbstractMACVerifyConduit : CICM::AbstractVerifyConduit {</pre>
<p>Interface from which other MAC verify conduits are inherited.</p>
<h1 id="rfc.section.5.4.1">
<a href="#rfc.section.5.4.1">5.4.1.</a> CICM::AbstractMACVerifyConduit Inheritance</h1>
<p id="rfc.section.5.4.1.p.1">CICM::AbstractMACVerifyConduit inherits from: CICM::AbstractVerifyConduit.</p>
<h1 id="rfc.section.5.4.2">
<a href="#rfc.section.5.4.2">5.4.2.</a> CICM::AbstractMACVerifyConduit Attributes</h1>
<div id="#rfc.figure.39"></div>
<p>AttributeCICM::AbstractMACVerifyConduit::verify_key</p>
<pre>readonly attribute CICM::SymKey verify_key;</pre>
<p>Key used to verify the MAC.</p>
<div id="#rfc.figure.40"></div>
<p>AttributeCICM::AbstractMACVerifyConduit::verify_algorithm</p>
<pre>readonly attribute CICM::SymMacAlgorithmId verify_algorithm;</pre>
<p>Algorithm used to verify the data.</p>
<h1 id="rfc.section.5.4.3">
<a href="#rfc.section.5.4.3">5.4.3.</a> CICM::AbstractMACVerifyConduit Methods</h1>
<div id="#rfc.figure.41"></div>
<p>Method CICM::AbstractMACVerifyConduit::end_get_verified()</p>
<pre>CICM::Status end_get_verified(
	in  CICM::MACBuffer mac,
	out CICM::AbstractVerifyConduit::VerifyStatus status
);</pre>
<p>Direct the module to compute and output the MAC verification status, and reset the channel to accept additional data for verification.</p>
<p id="rfc.section.5.4.3.p.1">Parameters: </p>

<ul class="empty">
<li>[in] mac Message authentication code.</li>
<li>[out] status Status indicating whether or not the data verifies.</li>
</ul>

<p> </p>
<p id="rfc.section.5.4.3.p.2">Returns: </p>

<ul class="empty"><li>S_OK, S_GENERAL_ERROR, S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION, S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE, S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT, S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR, S_CHANNEL_PEER_RESET, S_CHANNEL_DATA_INVALID, S_CHANNEL_DATA_INVALID_LEN</li></ul>

<p> </p>
<h1 id="rfc.section.5.5">
<a href="#rfc.section.5.5">5.5.</a> Interface CICM::AbstractSigVerifyConduit</h1>
<div id="#rfc.figure.42"></div>
<p>Interface  CICM::AbstractSigVerifyConduit</p>
<pre>interface AbstractSigVerifyConduit : CICM::AbstractVerifyConduit {</pre>
<p>Interface from which other signature verification conduits are inherited.</p>
<h1 id="rfc.section.5.5.1">
<a href="#rfc.section.5.5.1">5.5.1.</a> CICM::AbstractSigVerifyConduit Inheritance</h1>
<p id="rfc.section.5.5.1.p.1">CICM::AbstractSigVerifyConduit inherits from: CICM::AbstractVerifyConduit.</p>
<h1 id="rfc.section.5.5.2">
<a href="#rfc.section.5.5.2">5.5.2.</a> CICM::AbstractSigVerifyConduit Attributes</h1>
<div id="#rfc.figure.43"></div>
<p>AttributeCICM::AbstractSigVerifyConduit::verify_key</p>
<pre>readonly attribute CICM::AsymKey verify_key;</pre>
<p>Key used to verify the signature.</p>
<div id="#rfc.figure.44"></div>
<p>AttributeCICM::AbstractSigVerifyConduit::verify_algorithm</p>
<pre>readonly attribute CICM::AsymSigAlgorithmId verify_algorithm;</pre>
<p>Algorithm used to verify the data.</p>
<h1 id="rfc.section.5.5.3">
<a href="#rfc.section.5.5.3">5.5.3.</a> CICM::AbstractSigVerifyConduit Methods</h1>
<div id="#rfc.figure.45"></div>
<p>Method CICM::AbstractSigVerifyConduit::end_get_verified()</p>
<pre>CICM::Status end_get_verified(
	in  CICM::SigBuffer signature,
	out CICM::AbstractVerifyConduit::VerifyStatus status
);</pre>
<p>Direct the module to compute and output the verification status, and reset the channel to accept additional data for verification.</p>
<p id="rfc.section.5.5.3.p.1">Parameters: </p>

<ul class="empty">
<li>[in] signature Signature.</li>
<li>[out] status Status indicating whether or not the data verifies.</li>
</ul>

<p> </p>
<p id="rfc.section.5.5.3.p.2">Returns: </p>

<ul class="empty"><li>S_OK, S_GENERAL_ERROR, S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION, S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE, S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT, S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR, S_CHANNEL_PEER_RESET, S_CHANNEL_DATA_INVALID, S_CHANNEL_DATA_INVALID_LEN</li></ul>

<p> </p>
<h1 id="rfc.section.6">
<a href="#rfc.section.6">6.</a> Stream Abstractions</h1>
<h1 id="rfc.section.6.1">
<a href="#rfc.section.6.1">6.1.</a> Interface CICM::WriteStream</h1>
<div id="#rfc.figure.46"></div>
<p>Interface CICM::WriteStream</p>
<pre>interface WriteStream : CICM::Stream {</pre>
<p>Interface from which other streams that write data to the module inherit.</p>
<h1 id="rfc.section.6.1.1">
<a href="#rfc.section.6.1.1">6.1.1.</a> CICM::WriteStream Inheritance</h1>
<p id="rfc.section.6.1.1.p.1">CICM::WriteStream inherits from: CICM::Stream.</p>
<h1 id="rfc.section.6.1.2">
<a href="#rfc.section.6.1.2">6.1.2.</a> CICM::WriteStream Types and Constants</h1>
<div id="#rfc.figure.47"></div>
<p>Type CICM::WriteStream::WriteStatus</p>
<pre>typedef CICM::UInt32 WriteStatus;</pre>
<p>Status of an non-blocking write.</p>
<div id="#rfc.figure.48"></div>
<p>Constant   CICM::WriteStream::C_WRITE_NOT_READY</p>
<pre>const CICM::WriteStream::WriteStatus
	C_WRITE_NOT_READY = 0x00006067;</pre>
<p>Module is not ready to receive data for writing.</p>
<div id="#rfc.figure.49"></div>
<p>Constant   CICM::WriteStream::C_WRITE_READY</p>
<pre>const CICM::WriteStream::WriteStatus
	C_WRITE_READY = 0x00006068;</pre>
<p>Module is ready to receive data for writing.</p>
<h1 id="rfc.section.6.2">
<a href="#rfc.section.6.2">6.2.</a> Interface CICM::ReadStream</h1>
<div id="#rfc.figure.50"></div>
<p>Interface CICM::ReadStream</p>
<pre>interface ReadStream : CICM::Stream {</pre>
<p>Interface from which all other streams that read data from the module inherit.</p>
<h1 id="rfc.section.6.2.1">
<a href="#rfc.section.6.2.1">6.2.1.</a> CICM::ReadStream Inheritance</h1>
<p id="rfc.section.6.2.1.p.1">CICM::ReadStream inherits from: CICM::Stream.</p>
<h1 id="rfc.section.6.2.2">
<a href="#rfc.section.6.2.2">6.2.2.</a> CICM::ReadStream Types and Constants</h1>
<div id="#rfc.figure.51"></div>
<p>Type CICM::ReadStream::ReadStatus</p>
<pre>typedef CICM::UInt32 ReadStatus;</pre>
<p>Status of a non-blocking read.</p>
<div id="#rfc.figure.52"></div>
<p>Constant   CICM::ReadStream::C_READ_NOT_READY</p>
<pre>const CICM::ReadStream::ReadStatus
	C_READ_NOT_READY = 0x0000605E;</pre>
<p>Module does not have data ready for reading.</p>
<div id="#rfc.figure.53"></div>
<p>Constant   CICM::ReadStream::C_READ_READY</p>
<pre>const CICM::ReadStream::ReadStatus
	C_READ_READY = 0x00006061;</pre>
<p>Module has data ready for reading.</p>
<h1 id="rfc.section.7">
<a href="#rfc.section.7">7.</a> Controller Abstractions</h1>
<h1 id="rfc.section.7.1">
<a href="#rfc.section.7.1">7.1.</a> Interface CICM::MultiDomainController</h1>
<div id="#rfc.figure.54"></div>
<p>Interface CICM::MultiDomainController</p>
<pre>interface MultiDomainController : CICM::Controller {</pre>
<p>Interface from which any other multi-domain-related controller or conduit inherits.</p>
<p id="rfc.section.7.1.p.1">Remarks: </p>

<ul class="empty"><li>Provides read access to the local and remote port values associated with the controller.</li></ul>

<p> </p>
<h1 id="rfc.section.7.1.1">
<a href="#rfc.section.7.1.1">7.1.1.</a> CICM::MultiDomainController Inheritance</h1>
<p id="rfc.section.7.1.1.p.1">CICM::MultiDomainController inherits from: CICM::Controller.</p>
<h1 id="rfc.section.7.1.2">
<a href="#rfc.section.7.1.2">7.1.2.</a> CICM::MultiDomainController Attributes</h1>
<div id="#rfc.figure.55"></div>
<p>AttributeCICM::MultiDomainController::local_port</p>
<pre>readonly attribute CICM::LocalPort local_port;</pre>
<p>Local port associated with this controller.</p>
<div id="#rfc.figure.56"></div>
<p>AttributeCICM::MultiDomainController::remote_port</p>
<pre>readonly attribute CICM::RemotePort remote_port;</pre>
<p>Remote port associated with this controller.</p>
<h1 id="rfc.section.7.2">
<a href="#rfc.section.7.2">7.2.</a> Interface CICM::SymKeyController</h1>
<div id="#rfc.figure.57"></div>
<p>Interface CICM::SymKeyController</p>
<pre>interface SymKeyController : CICM::Controller {</pre>
<p>Interface from which all controllers using a symmetric key inherit.</p>
<h1 id="rfc.section.7.2.1">
<a href="#rfc.section.7.2.1">7.2.1.</a> CICM::SymKeyController Inheritance</h1>
<p id="rfc.section.7.2.1.p.1">CICM::SymKeyController inherits from: CICM::Controller.</p>
<h1 id="rfc.section.7.2.2">
<a href="#rfc.section.7.2.2">7.2.2.</a> CICM::SymKeyController Attributes</h1>
<div id="#rfc.figure.58"></div>
<p>Attribute CICM::SymKeyController::key</p>
<pre>readonly attribute CICM::SymKey key;</pre>
<p>The key associated with this controller.</p>
<h1 id="rfc.section.7.2.3">
<a href="#rfc.section.7.2.3">7.2.3.</a> CICM::SymKeyController Methods</h1>
<div id="#rfc.figure.59"></div>
<p>Method CICM::SymKeyController::update_key()</p>
<pre>CICM::Status update_key();</pre>
<p>Cryptographically update the key associated with this controller using the key's native algorithm.</p>
<p id="rfc.section.7.2.3.p.1">Remarks: </p>

<ul class="empty"><li>To update an arbitrary key, use CICM::SymKey::update.</li></ul>

<p> </p>
<p id="rfc.section.7.2.3.p.2">Returns: </p>

<ul class="empty"><li>S_OK, S_GENERAL_ERROR, S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION, S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE, S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT, S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR, S_CHANNEL_PEER_RESET</li></ul>

<p> </p>
<p id="rfc.section.7.2.3.p.3">See also: </p>

<ul class="empty"><li>CICM::SymKey::update_key_with_algo for the version of this method that accepts an algorithm.</li></ul>

<p> </p>
<div id="#rfc.figure.60"></div>
<p>Method CICM::SymKeyController::update_key_with_algo()</p>
<pre>CICM::Status update_key_with_algo(
	in  CICM::SymEncrAlgorithmId algorithm
);</pre>
<p>Cryptographically update the key associated with this controller using the specified algorithm.</p>
<p id="rfc.section.7.2.3.p.4">Remarks: </p>

<ul class="empty"><li>To update an arbitrary key, use CICM::SymKey::update.</li></ul>

<p> </p>
<p id="rfc.section.7.2.3.p.5">Parameters: </p>

<ul class="empty"><li>[in] algorithm Cryptographic algorithm/mode to use to effect the key update.</li></ul>

<p> </p>
<p id="rfc.section.7.2.3.p.6">Returns: </p>

<ul class="empty"><li>S_OK, S_GENERAL_ERROR, S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION, S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE, S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT, S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_ALGO_INVALID, S_ALGO_INCOMPATIBLE, S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR, S_CHANNEL_PEER_RESET</li></ul>

<p> </p>
<p id="rfc.section.7.2.3.p.7">See also: </p>

<ul class="empty"><li>CICM::SymKey::update_key for the version of this method that does not require an algorithm to be specified.</li></ul>

<p> </p>
<div id="#rfc.figure.61"></div>
<p>Method CICM::SymKeyController::rollover_key()</p>
<pre>CICM::Status rollover_key();</pre>
<p>Specify that the next pre-placed key be used with this controller.</p>
<p id="rfc.section.7.2.3.p.8">Remarks: </p>

<ul class="empty"><li>A call to this method may be required when a key reaches the end of its specified or usable lifespan or for other reasons that require that a controller move to a new key.</li></ul>

<p> </p>
<p id="rfc.section.7.2.3.p.9">Returns: </p>

<ul class="empty"><li>S_OK, S_GENERAL_ERROR, S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION, S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE, S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT, S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_NO_NEXT, S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR, S_CHANNEL_PEER_RESET</li></ul>

<p> </p>
<p id="rfc.section.7.2.3.p.10">See also: </p>

<ul class="empty"><li>CICM::SymKey::rollover_key_with_key for the version of this method that accepts a key.</li></ul>

<p> </p>
<div id="#rfc.figure.62"></div>
<p>Method CICM::SymKeyController::rollover_key_with_key()</p>
<pre>CICM::Status rollover_key_with_key(
	in  CICM::SymKey next_key
);</pre>
<p>Specify the next pre-placed key to be used with this controller.</p>
<p id="rfc.section.7.2.3.p.11">Remarks: </p>

<ul class="empty"><li>A call to this method may be required when a key reaches the end of its specified or usable lifespan or for other reasons that require that a controller move to a new key.</li></ul>

<p> </p>
<p id="rfc.section.7.2.3.p.12">Parameters: </p>

<ul class="empty"><li>[in] next_key Reference to pre-placed key to use with this controller.</li></ul>

<p> </p>
<p id="rfc.section.7.2.3.p.13">Returns: </p>

<ul class="empty"><li>S_OK, S_GENERAL_ERROR, S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION, S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE, S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT, S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_USED_INVALID, S_KEY_USED_EXPIRED, S_KEY_USED_CLASSIFICATION, S_KEY_USED_WRAPPED, S_KEY_USED_CONTEXT, S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR, S_CHANNEL_PEER_RESET</li></ul>

<p> </p>
<p id="rfc.section.7.2.3.p.14">See also: </p>

<ul class="empty"><li>CICM::SymKey::rollover_key for the version of this method for which the key is implicit.</li></ul>

<p> </p>
<h1 id="rfc.section.7.3">
<a href="#rfc.section.7.3">7.3.</a> Interface CICM::AsymKeyController</h1>
<div id="#rfc.figure.63"></div>
<p>Interface CICM::AsymKeyController</p>
<pre>interface AsymKeyController : CICM::Controller {</pre>
<p>Interface from which all controllers using an asymmetric key inherit.</p>
<h1 id="rfc.section.7.3.1">
<a href="#rfc.section.7.3.1">7.3.1.</a> CICM::AsymKeyController Inheritance</h1>
<p id="rfc.section.7.3.1.p.1">CICM::AsymKeyController inherits from: CICM::Controller.</p>
<h1 id="rfc.section.7.3.2">
<a href="#rfc.section.7.3.2">7.3.2.</a> CICM::AsymKeyController Attributes</h1>
<div id="#rfc.figure.64"></div>
<p>AttributeCICM::AsymKeyController::key</p>
<pre>readonly attribute CICM::AsymKey key;</pre>
<p>Provides read-only access to the key associated with a controller.</p>
<h1 id="rfc.section.7.4">
<a href="#rfc.section.7.4">7.4.</a> Interface CICM::NegotiatedController</h1>
<div id="#rfc.figure.65"></div>
<p>Interface CICM::NegotiatedController</p>
<pre>interface NegotiatedController :
	CICM::MultiDomainController,
	CICM::AsymKeyController,
	CICM::Negotiator {</pre>
<p>Interface from which all other negotiated controllers inherit.  A controller that uses a negotiated key.</p>
<h1 id="rfc.section.7.4.1">
<a href="#rfc.section.7.4.1">7.4.1.</a> CICM::NegotiatedController Inheritance</h1>
<p id="rfc.section.7.4.1.p.1">CICM::NegotiatedController inherits from: CICM::MultiDomainController, CICM::AsymKeyController and CICM::Negotiator.</p>
<h1 id="rfc.section.7.4.2">
<a href="#rfc.section.7.4.2">7.4.2.</a> CICM::NegotiatedController Attributes</h1>
<div id="#rfc.figure.66"></div>
<p>AttributeCICM::NegotiatedController::negotiated_grade</p>
<pre>readonly attribute CICM::Classification negotiated_grade;</pre>
<p>Returns the grade (classification level) of the channel.</p>
<h1 id="rfc.section.7.4.3">
<a href="#rfc.section.7.4.3">7.4.3.</a> CICM::NegotiatedController Methods</h1>
<div id="#rfc.figure.67"></div>
<p>Method CICM::NegotiatedController::renegotiate()</p>
<pre>CICM::Status renegotiate();</pre>
<p>Renegotiates the traffic encryption key with the associated peer.</p>
<p id="rfc.section.7.4.3.p.1">Remarks: </p>

<ul class="empty"><li>In cases where the key is no longer usable, e.g. it expired or was zeroized, the session MUST be torn down and rebuilt.  Note that renegotiation MAY NOT need to be explicitly initiated in all cases because some modules will automatically initiate a renegotiation when sensing a certain condition (e.g., key expiration, cumulative traffic volume threshold passed, etc.).</li></ul>

<p> </p>
<p id="rfc.section.7.4.3.p.2">Returns: </p>

<ul class="empty"><li>S_OK, S_GENERAL_ERROR, S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION, S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE, S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT, S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT, S_NEGOTIATION_ABORTED, S_NEGOTIATION_FAILURE, S_NEGOTIATION_IN_PROGRESS, S_NEGOTIATION_TIMEOUT, S_CERT_LOCAL_INVALID, S_CERT_LOCAL_EXPIRED, S_CERT_REMOTE_INVALID, S_CERT_REMOTE_EXPIRED, S_CERT_REMOTE_PATH, S_CHANNEL_ERROR</li></ul>

<p> </p>
<div id="#rfc.figure.68"></div>
<p>Method CICM::NegotiatedController::initiate_grade_change()</p>
<pre>CICM::Status initiate_grade_change(
	in  CICM::Classification new_grade
);</pre>
<p>Requests a change of grade (classification level) for the current traffic.</p>
<p id="rfc.section.7.4.3.p.3">Parameters: </p>

<ul class="empty"><li>[in] new_grade New grade for the traffic.</li></ul>

<p> </p>
<p id="rfc.section.7.4.3.p.4">Returns: </p>

<ul class="empty"><li>S_OK, S_GENERAL_ERROR, S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION, S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE, S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT, S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT, S_NEGOTIATION_ABORTED, S_NEGOTIATION_FAILURE, S_NEGOTIATION_IN_PROGRESS, S_NEGOTIATION_TIMEOUT, S_CERT_LOCAL_INVALID, S_CERT_LOCAL_EXPIRED, S_CERT_REMOTE_INVALID, S_CERT_REMOTE_EXPIRED, S_CERT_REMOTE_PATH, S_CHANNEL_ERROR, S_CHANNEL_PEER_RESET</li></ul>

<p> </p>
<div id="#rfc.figure.69"></div>
<p>Method CICM::NegotiatedController::acknowledge_grade_change()</p>
<pre>CICM::Status acknowledge_grade_change();</pre>
<p>Positively acknowledges the requested change of grade.</p>
<p id="rfc.section.7.4.3.p.5">Returns: </p>

<ul class="empty"><li>S_OK, S_GENERAL_ERROR, S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION, S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE, S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT, S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT, S_NEGOTIATION_ABORTED, S_NEGOTIATION_FAILURE, S_NEGOTIATION_IN_PROGRESS, S_NEGOTIATION_TIMEOUT, S_CERT_LOCAL_INVALID, S_CERT_LOCAL_EXPIRED, S_CERT_REMOTE_INVALID, S_CERT_REMOTE_EXPIRED, S_CERT_REMOTE_PATH, S_CHANNEL_ERROR, S_CHANNEL_PEER_RESET</li></ul>

<p> </p>
<h1 id="rfc.section.7.5">
<a href="#rfc.section.7.5">7.5.</a> Interface CICM::SetVectorController</h1>
<div id="#rfc.figure.70"></div>
<p>Interface CICM::SetVectorController</p>
<pre>interface SetVectorController : CICM::Controller {</pre>
<p>Provides access to the state vector associated with a controller.</p>
<h1 id="rfc.section.7.5.1">
<a href="#rfc.section.7.5.1">7.5.1.</a> CICM::SetVectorController Inheritance</h1>
<p id="rfc.section.7.5.1.p.1">CICM::SetVectorController inherits from: CICM::Controller.</p>
<h1 id="rfc.section.7.5.2">
<a href="#rfc.section.7.5.2">7.5.2.</a> CICM::SetVectorController Attributes</h1>
<div id="#rfc.figure.71"></div>
<p>AttributeCICM::SetVectorController::vec</p>
<pre>readonly attribute CICM::Vector vec;</pre>
<p>State vector associated with this controller.</p>
<h1 id="rfc.section.7.5.3">
<a href="#rfc.section.7.5.3">7.5.3.</a> CICM::SetVectorController Methods</h1>
<div id="#rfc.figure.72"></div>
<p>Method CICM::SetVectorController::set_vector()</p>
<pre>CICM::Status set_vector(
	in  CICM::Vector vec
);</pre>
<p>Set channel state vector.</p>
<p id="rfc.section.7.5.3.p.1">Remarks: </p>

<ul class="empty"><li>This state value may be set when a controller is initially created (initialization vector). It may also be set on a block-by-block basis for appropriate algorithms/modes or for each time epoch (e.g., for time-of-day encryption).</li></ul>

<p> </p>
<p id="rfc.section.7.5.3.p.2">Parameters: </p>

<ul class="empty"><li>[in] vec State vector.</li></ul>

<p> </p>
<p id="rfc.section.7.5.3.p.3">Returns: </p>

<ul class="empty"><li>S_OK, S_GENERAL_ERROR, S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION, S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE, S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT, S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_INVALID_VECTOR, S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT</li></ul>

<p> </p>
<div id="#rfc.figure.73"></div>
<p>Method CICM::SetVectorController::set_vector_no_check()</p>
<pre>CICM::Status set_vector_no_check(
	in  CICM::Vector vec
);</pre>
<p>Set channel state vector without a policy check.</p>
<p id="rfc.section.7.5.3.p.4">Remarks: </p>

<ul class="empty">
<li>This state value may be set when a controller is initially created (initialization vector) or on a per-message basis, depending upon how the cryptographic algorithm uses the vector.  The length and format of the vector are specific to the algorithm associated with the channel and system in which the channel is being used.</li>
<li>This version of the set_vector() method may be used on the decrypt side, for example, to specify no TOD check in cases where TOD rules are not enforced for decryption.</li>
</ul>

<p> </p>
<p id="rfc.section.7.5.3.p.5">Parameters: </p>

<ul class="empty"><li>[in] vec State vector.</li></ul>

<p> </p>
<p id="rfc.section.7.5.3.p.6">Returns: </p>

<ul class="empty"><li>S_OK, S_GENERAL_ERROR, S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION, S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE, S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT, S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_INVALID_VECTOR, S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT</li></ul>

<p> </p>
<div id="#rfc.figure.74"></div>
<p>Method CICM::SetVectorController::reset_vector()</p>
<pre>CICM::Status reset_vector();</pre>
<p>Reset channel state vector to system-dependent value.</p>
<p id="rfc.section.7.5.3.p.7">Remarks: </p>

<ul class="empty"><li>This can be used by the client program to manage time-of-day or counter rollover.</li></ul>

<p> </p>
<p id="rfc.section.7.5.3.p.8">Returns: </p>

<ul class="empty"><li>S_OK, S_GENERAL_ERROR, S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION, S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE, S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT, S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT</li></ul>

<p> </p>
<h1 id="rfc.section.7.6">
<a href="#rfc.section.7.6">7.6.</a> Interface CICM::GenVectorController</h1>
<div id="#rfc.figure.75"></div>
<p>Interface CICM::GenVectorController</p>
<pre>interface GenVectorController : CICM::SetVectorController {</pre>
<p>Enables an state vector to be generated.</p>
<h1 id="rfc.section.7.6.1">
<a href="#rfc.section.7.6.1">7.6.1.</a> CICM::GenVectorController Inheritance</h1>
<p id="rfc.section.7.6.1.p.1">CICM::GenVectorController inherits from: CICM::SetVectorController.</p>
<h1 id="rfc.section.7.6.2">
<a href="#rfc.section.7.6.2">7.6.2.</a> CICM::GenVectorController Methods</h1>
<div id="#rfc.figure.76"></div>
<p>Method CICM::GenVectorController::generate_vector()</p>
<pre>CICM::Status generate_vector();</pre>
<p>Generate a vector for this controller utilizing new random state.</p>
<p id="rfc.section.7.6.2.p.1">Remarks: </p>

<ul class="empty"><li>It may not be necessary for a client program to explicitly generate a vector. Some cryptographic modules will implicitly generate an IV, for example, as a byproduct of channel creation. In other cases, an existing vector will be associated with a controller by calling the CICM::SetVectorController::set_vector method.</li></ul>

<p> </p>
<p id="rfc.section.7.6.2.p.2">Returns: </p>

<ul class="empty"><li>S_OK, S_GENERAL_ERROR, S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION, S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE, S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT, S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT, S_INSUFFICIENT_ENTROPY</li></ul>

<p> </p>
<div id="#rfc.figure.77"></div>
<p>Method CICM::GenVectorController::generate_vector_existing_state()</p>
<pre>CICM::Status generate_vector_existing_state();</pre>
<p>Generate a vector for this controller utilizing the latest unused state.</p>
<p id="rfc.section.7.6.2.p.3">Remarks: </p>

<ul class="empty"><li>It may not be necessary for a client program to explicitly generate a vector. Some cryptographic modules will implicitly generate an IV, for example, as a byproduct of channel creation. In other cases, an existing vector will be associated with a controller by calling the CICM::SetVectorController::set_vector method.</li></ul>

<p> </p>
<p id="rfc.section.7.6.2.p.4">Returns: </p>

<ul class="empty"><li>S_OK, S_GENERAL_ERROR, S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION, S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE, S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT, S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT, S_INSUFFICIENT_ENTROPY</li></ul>

<p> </p>
<h1 id="rfc.section.7.7">
<a href="#rfc.section.7.7">7.7.</a> Interface CICM::ResyncController</h1>
<div id="#rfc.figure.78"></div>
<p>Interface CICM::ResyncController</p>
<pre>interface ResyncController : CICM::Controller {</pre>
<p>Provides methods to resynchronize a controller or conduit.</p>
<h1 id="rfc.section.7.7.1">
<a href="#rfc.section.7.7.1">7.7.1.</a> CICM::ResyncController Inheritance</h1>
<p id="rfc.section.7.7.1.p.1">CICM::ResyncController inherits from: CICM::Controller.</p>
<h1 id="rfc.section.7.7.2">
<a href="#rfc.section.7.7.2">7.7.2.</a> CICM::ResyncController Methods</h1>
<div id="#rfc.figure.79"></div>
<p>Method CICM::ResyncController::resync()</p>
<pre>CICM::Status resync();</pre>
<p>Resynchronize the channel.</p>
<p id="rfc.section.7.7.2.p.1">Remarks: </p>

<ul class="empty"><li>A client program-initiated resync is required when the host is responsible for ensuring cryptographic synchronization is maintained because the operating mode used does not enable the module to determine that it is out of sync. The action taken by the module as the result of a call to this method will differ based upon characteristics of the cryptographic algorithm, communications path framing, and details of the protocol used to achieve cryptographic synchronization between two modules.</li></ul>

<p> </p>
<p id="rfc.section.7.7.2.p.2">Returns: </p>

<ul class="empty"><li>S_OK, S_GENERAL_ERROR, S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION, S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE, S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT, S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR, S_CHANNEL_PEER_RESET</li></ul>

<p> </p>
<p id="rfc.section.7.7.2.p.3">See also: </p>

<ul class="empty"><li>CICM::ResyncController::resync_with_sync_vector for the version of this method that accepts a synchronization vector.</li></ul>

<p> </p>
<div id="#rfc.figure.80"></div>
<p>Method CICM::ResyncController::resync_with_sync_vector()</p>
<pre>CICM::Status resync_with_sync_vector(
	in  CICM::Vector vec
);</pre>
<p>Resynchronize the channel, using the specified synchronization vector (required by certain operating modes to initiate a resync).</p>
<p id="rfc.section.7.7.2.p.4">Remarks: </p>

<ul class="empty"><li>A client program-initiated resync is required when the host is responsible for ensuring cryptographic synchronization is maintained because the operating mode used does not enable the module to determine that it is out of sync. The action taken by the module as the result of a call to this method will differ based upon characteristics of the cryptographic algorithm, communications path framing, and details of the protocol used to achieve cryptographic synchronization among modules.</li></ul>

<p> </p>
<p id="rfc.section.7.7.2.p.5">Parameters: </p>

<ul class="empty"><li>[in] vec Synchronization vector to use to resynchronize the channel.</li></ul>

<p> </p>
<p id="rfc.section.7.7.2.p.6">Returns: </p>

<ul class="empty"><li>S_OK, S_GENERAL_ERROR, S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION, S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE, S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT, S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_INVALID_VECTOR, S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR, S_CHANNEL_PEER_RESET</li></ul>

<p> </p>
<p id="rfc.section.7.7.2.p.7">See also: </p>

<ul class="empty"><li>CICM::ResyncController::resync for the version of this method that does not require a synchronization vector.</li></ul>

<p> </p>
<h1 id="rfc.section.8">
<a href="#rfc.section.8">8.</a> <a href="#sec_channel_negotiation" id="sec_channel_negotiation">Channel Negotiation</a>
</h1>
<h1 id="rfc.section.8.1">
<a href="#rfc.section.8.1">8.1.</a> Negotiating Channels and Controllers</h1>
<p id="rfc.section.8.1.p.1">When creating an encryption or decryption channel using an asymmetric keyset, a negotiation process must be initiated between the two communicating entities, resulting in an ephemeral symmetric key held by each entity. The following details the steps in the negotiation process: </p>

<ol>
<li>Retrieve a negotiator. The client program uses the CICM::ChannelManager to create the appropriate CICM::Negotiator, thus initiating the negotiation.</li>
<li>Validate remote peer. Most systems will use a trust anchor to validate that the remote peer is legitimate and will further verify the peer appears on the appropriate access control list(s). In some cases, the above validation will be sufficient.  In others, it will be necessary to display information about the remote peer to a human user to receive a positive response from the user that the displayed peer is the expected peer. This validation procedure differs depending upon the display configuration: <ul>
<li>If the system is configured with a trusted display, information about the remote peer is displayed to the trusted display and the user is solicited for a response which is returned to the module. The trusted display interactions take place independent of the API.</li>
<li>If the system is not configured with a trusted display, the client program uses CICM::Negotiator::get_remote_info to retrieve information about the remote peer and then displays this information to the user (independent of CICM) to allow the user to determine if this is the expected remote peer; the client program calls CICM::Negotiator::abort_negotiation to abort the negotiation if the user rejects the remote peer.</li>
</ul>
</li>
<li>Complete negotiation. The client program explicitly completes the negotiation using the negotiator's complete() method.</li>
</ol>
<p id="rfc.section.8.1.p.2">A successful negotation results in a negotiated controller.</p>
<h1 id="rfc.section.8.2">
<a href="#rfc.section.8.2">8.2.</a> Interface CICM::Negotiator</h1>
<div id="#rfc.figure.81"></div>
<p>Interface CICM::Negotiator</p>
<pre>interface Negotiator {</pre>
<p>CICM::Negotiator is an abstraction inherited by controllers and CICM::KeyProtocolSender to assist in the management of the negotiation process.</p>
<h1 id="rfc.section.8.2.1">
<a href="#rfc.section.8.2.1">8.2.1.</a> CICM::Negotiator Methods</h1>
<div id="#rfc.figure.82"></div>
<p>Method CICM::Negotiator::get_remote_info()</p>
<pre>CICM::Status get_remote_info(
	out CICM::PeerInfo peer_info
);</pre>
<p>Retrieve remote peer identification information.  The peer information must be displayed to the local user to enable determination to be made as to whether negotiation should continue or be aborted.  If the decision is made to abort negotiation, the CICM::Negotiator::abort_negotiation method MUST be called to destroy any protocol session state.</p>
<p id="rfc.section.8.2.1.p.1">Parameters: </p>

<ul class="empty"><li>[out] peer_info Identifying information about the remote peer.</li></ul>

<p> </p>
<p id="rfc.section.8.2.1.p.2">Returns: </p>

<ul class="empty"><li>S_OK,  S_GENERAL_ERROR,  S_NON_FUNCTIONAL, S_OPERATION_FAILED,  S_POLICY_VIOLATION, S_MODULE_RESOURCES,  S_HOST_RESOURCES,  S_INVALID_STATE, S_ALARM_STATE,  S_MODULE_NOT_AVAILABLE,  S_TIMEOUT, S_NOT_AUTHENTICATED,  S_NOT_AUTHORIZED,  S_NOT_AVAILABLE, S_TOKEN_NOT_PRESENT,  S_TOKEN_ADMIN_NOT_PRESENT,  S_TRUSTED_DISPLAY, S_NEGOTIATION_ABORTED,  S_NEGOTIATION_FAILURE, S_NEGOTIATION_NOT_IN_PROGRESS,  S_NEGOTIATION_TIMEOUT, S_CERT_LOCAL_INVALID,  S_CERT_LOCAL_EXPIRED,  S_CERT_REMOTE_INVALID, S_CERT_REMOTE_EXPIRED,  S_CERT_REMOTE_PATH,  S_CHANNEL_ERROR, S_CHANNEL_PEER_RESET</li></ul>

<p> </p>
<div id="#rfc.figure.83"></div>
<p>Method CICM::Negotiator::abort_negotiation()</p>
<pre>CICM::Status abort_negotiation();</pre>
<p>Abort negotiation or renegotiation.  This method must be called in the event the identification information for the remote host does not correspond to the expected host.</p>
<p id="rfc.section.8.2.1.p.3">Returns: </p>

<ul class="empty"><li>S_OK, S_GENERAL_ERROR, S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION, S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE, S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT, S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT, S_NEGOTIATION_NOT_IN_PROGRESS, S_CHANNEL_ERROR, S_CHANNEL_PEER_RESET</li></ul>

<p> </p>
<h1 id="rfc.section.8.3">
<a href="#rfc.section.8.3">8.3.</a> Interface CICM::PeerInfo</h1>
<div id="#rfc.figure.84"></div>
<p>Interface CICM::PeerInfo</p>
<pre>interface PeerInfo {</pre>
<p>Information about a peer entity participating in a key negotiation.</p>
<h1 id="rfc.section.8.3.1">
<a href="#rfc.section.8.3.1">8.3.1.</a> CICM::PeerInfo Attributes</h1>
<div id="#rfc.figure.85"></div>
<p>Attribute CICM::PeerInfo::peer_name</p>
<pre>readonly attribute CICM::CharString peer_name;</pre>
<p>Name/organization of remote entity participating in key agreement prototcol.</p>
<div id="#rfc.figure.86"></div>
<p>AttributeCICM::PeerInfo::classification</p>
<pre>readonly attribute CICM::Classification classification;</pre>
<p>Highest security classification level at which the remote entity participating in the key agreement protocol is capable of communicating.</p>
<div id="#rfc.figure.87"></div>
<p>Attribute CICM::PeerInfo::compartment</p>
<pre>readonly attribute CICM::CharString compartment;</pre>
<p>Compartment of remote entity participating in key agreement protocol.</p>
<div id="#rfc.figure.88"></div>
<p>Attribute CICM::PeerInfo::message</p>
<pre>readonly attribute CICM::CharString message;</pre>
<p>Message to be displayed regarding the remote entities' participation in key agreement protocol.</p>
<h1 id="rfc.section.9">
<a href="#rfc.section.9">9.</a> <a href="#sec-encrypt" id="sec-encrypt">Encryption</a>
</h1>
<div id="#rfc.figure.89"></div>
<p>Namespace CICM::Encrypt</p>
<pre>module Encrypt {</pre>
<p>The CICM::Encrypt namespace contains interfaces that support encryption operations between two independent security domains.</p>
<h1 id="rfc.section.9.1">
<a href="#rfc.section.9.1">9.1.</a> Interface CICM::Encrypt::ChannelManager</h1>
<div id="#rfc.figure.90"></div>
<p>Interface  CICM::Encrypt::ChannelManager</p>
<pre>interface ChannelManager {</pre>
<p>CICM::Encrypt::ChannelManager is an abstraction inherited by CICM::ChannelManager that supports the creation of encryption negotiators, conduits, controllers, and streams. See CICM::ChannelManager for additional information.</p>
<h1 id="rfc.section.9.1.1">
<a href="#rfc.section.9.1.1">9.1.1.</a> CICM::Encrypt::ChannelManager Methods</h1>
<div id="#rfc.figure.91"></div>
<p>Method CICM::Encrypt::ChannelManager::negotiate_encrypt_conduit()</p>
<pre>CICM::Status negotiate_encrypt_conduit(
	in  CICM::RemotePort remote_port,
	in  CICM::ProtocolId protocol,
	in  CICM::AsymKey key_ref,
	out CICM::Encrypt::Negotiator negotiator_ref
);</pre>
<p>Initiate a negotiation to establish a shared key with a peer.  The channel that results will encrypt a stream of data.</p>
<p id="rfc.section.9.1.1.p.1">Parameters: </p>

<ul class="empty">
<li>[in] remote_port Remote port.</li>
<li>[in] protocol Protocol identifier.</li>
<li>[in] key_ref Reference to negotiation key.</li>
<li>[out] negotiator_ref Reference to resulting negotiator.</li>
</ul>

<p> </p>
<p id="rfc.section.9.1.1.p.2">Returns: </p>

<ul class="empty"><li>S_OK, S_GENERAL_ERROR, S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION, S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE, S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT, S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_USED_INVALID, S_KEY_USED_EXPIRED, S_KEY_USED_WRAPPED, S_KEY_USED_CONTEXT, S_KEY_USED_COMPONENT_NOT_AVAIL, S_KEY_INVALID, S_KEY_EXPIRED, S_REMOTE_PORT_INVALID, S_REMOTE_PORT_IN_USE, S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT, S_NEGOTIATION_ABORTED, S_NEGOTIATION_FAILURE, S_NEGOTIATION_IN_PROGRESS, S_NEGOTIATION_TIMEOUT, S_CERT_LOCAL_INVALID, S_CERT_LOCAL_EXPIRED, S_CERT_REMOTE_INVALID, S_CERT_REMOTE_EXPIRED, S_CERT_REMOTE_PATH, S_PROTO_INVALID, S_PROTO_INCOMPATIBLE, S_PROTO_UNDETERMINED, S_CHANNEL_ERROR, S_CHANNEL_MAX</li></ul>

<p> </p>
<div id="#rfc.figure.92"></div>
<p>Method CICM::Encrypt::ChannelManager::negotiate_encrypt_with_mac_conduit()</p>
<pre>CICM::Status negotiate_encrypt_with_mac_conduit(
	in  CICM::RemotePort remote_port,
	in  CICM::ProtocolId protocol,
	in  CICM::SymKey mac_key_ref,
	in  CICM::AsymKey nego_key_ref,
	in  CICM::SymMacAlgorithmId mac_algorithm,
	out CICM::Encrypt::WithMACNegotiator negotiator_ref
);</pre>
<p>Initiate a negotiation to establish a shared key with a peer.  The channel that results will MAC and encrypt a stream of data.</p>
<p id="rfc.section.9.1.1.p.3">Remarks: </p>

<ul class="empty"><li>Negotiation applies only to the negotiation key, not the MAC key.</li></ul>

<p> </p>
<p id="rfc.section.9.1.1.p.4">Parameters: </p>

<ul class="empty">
<li>[in] remote_port Remote port.</li>
<li>[in] protocol Protocol identifier.</li>
<li>[in] mac_key_ref Reference to MAC key.</li>
<li>[in] nego_key_ref Reference to negotiation key.</li>
<li>[in] mac_algorithm MAC algorithm.</li>
<li>[out] negotiator_ref Reference to resulting negotiator.</li>
</ul>

<p> </p>
<p id="rfc.section.9.1.1.p.5">Returns: </p>

<ul class="empty"><li>S_OK, S_GENERAL_ERROR, S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION, S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE, S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT, S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_USED_INVALID, S_KEY_USED_EXPIRED, S_KEY_USED_WRAPPED, S_KEY_USED_CONTEXT, S_KEY_USED_COMPONENT_NOT_AVAIL, S_KEY_INVALID, S_KEY_EXPIRED, S_REMOTE_PORT_INVALID, S_REMOTE_PORT_IN_USE, S_ALGO_INVALID, S_ALGO_INCOMPATIBLE, S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT, S_NEGOTIATION_ABORTED, S_NEGOTIATION_FAILURE, S_NEGOTIATION_IN_PROGRESS, S_NEGOTIATION_TIMEOUT, S_CERT_LOCAL_INVALID, S_CERT_LOCAL_EXPIRED, S_CERT_REMOTE_INVALID, S_CERT_REMOTE_EXPIRED, S_CERT_REMOTE_PATH, S_PROTO_INVALID, S_PROTO_INCOMPATIBLE, S_PROTO_UNDETERMINED, S_CHANNEL_ERROR, S_CHANNEL_MAX</li></ul>

<p> </p>
<div id="#rfc.figure.93"></div>
<p>Method CICM::Encrypt::ChannelManager::negotiate_encrypt_with_sign_conduit()</p>
<pre>CICM::Status negotiate_encrypt_with_sign_conduit(
	in  CICM::RemotePort remote_port,
	in  CICM::ProtocolId protocol,
	in  CICM::AsymKey sign_key_ref,
	in  CICM::AsymKey nego_key_ref,
	in  CICM::AsymSigAlgorithmId sign_algorithm,
	out CICM::Encrypt::WithSignNegotiator negotiator_ref
);</pre>
<p>Initiate a negotiation to establish a shared key with a peer.  The channel that results will sign and encrypt a stream of data.</p>
<p id="rfc.section.9.1.1.p.6">Remarks: </p>

<ul class="empty"><li>Negotiation applies only to the negotiation key, not the signature key.</li></ul>

<p> </p>
<p id="rfc.section.9.1.1.p.7">Parameters: </p>

<ul class="empty">
<li>[in] remote_port Remote port.</li>
<li>[in] protocol Protocol identifier.</li>
<li>[in] sign_key_ref Reference to signature key.</li>
<li>[in] nego_key_ref Reference to negotiation key.</li>
<li>[in] sign_algorithm Signature algorithm.</li>
<li>[out] negotiator_ref Reference to resulting negotiator.</li>
</ul>

<p> </p>
<p id="rfc.section.9.1.1.p.8">Returns: </p>

<ul class="empty"><li>S_OK, S_GENERAL_ERROR, S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION, S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE, S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT, S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_USED_INVALID, S_KEY_USED_EXPIRED, S_KEY_USED_WRAPPED, S_KEY_USED_CONTEXT, S_KEY_USED_COMPONENT_NOT_AVAIL, S_KEY_INVALID, S_KEY_EXPIRED, S_REMOTE_PORT_INVALID, S_REMOTE_PORT_IN_USE, S_ALGO_INVALID, S_ALGO_INCOMPATIBLE, S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT, S_NEGOTIATION_ABORTED, S_NEGOTIATION_FAILURE, S_NEGOTIATION_IN_PROGRESS, S_NEGOTIATION_TIMEOUT, S_CERT_LOCAL_INVALID, S_CERT_LOCAL_EXPIRED, S_CERT_REMOTE_INVALID, S_CERT_REMOTE_EXPIRED, S_CERT_REMOTE_PATH, S_PROTO_INVALID, S_PROTO_INCOMPATIBLE, S_PROTO_UNDETERMINED, S_CHANNEL_ERROR, S_CHANNEL_MAX</li></ul>

<p> </p>
<div id="#rfc.figure.94"></div>
<p>Method CICM::Encrypt::ChannelManager::negotiate_encrypt_controller()</p>
<pre>CICM::Status negotiate_encrypt_controller(
	in  CICM::LocalPort local_port,
	in  CICM::RemotePort remote_port,
	in  CICM::ProtocolId protocol,
	in  CICM::AsymKey key_ref,
	out CICM::Encrypt::ControllerNegotiator negotiator_ref
);</pre>
<p>Initiate a negotiation to establish a shared key with a peer, resulting in a controller to manage an encryption channel.</p>
<p id="rfc.section.9.1.1.p.9">Parameters: </p>

<ul class="empty">
<li>[in] local_port Local port.</li>
<li>[in] remote_port Remote port.</li>
<li>[in] protocol Protocol identifier.</li>
<li>[in] key_ref Reference to encryption key.</li>
<li>[out] negotiator_ref Reference to resulting negotiator.</li>
</ul>

<p> </p>
<p id="rfc.section.9.1.1.p.10">Returns: </p>

<ul class="empty"><li>S_OK, S_GENERAL_ERROR, S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION, S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE, S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT, S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_USED_INVALID, S_KEY_USED_EXPIRED, S_KEY_USED_WRAPPED, S_KEY_USED_CONTEXT, S_KEY_USED_COMPONENT_NOT_AVAIL, S_KEY_INVALID, S_KEY_EXPIRED, S_LOCAL_PORT_INVALID, S_LOCAL_PORT_INCOMPATIBLE, S_LOCAL_PORT_IN_USE, S_REMOTE_PORT_INVALID, S_REMOTE_PORT_IN_USE, S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT, S_NEGOTIATION_ABORTED, S_NEGOTIATION_FAILURE, S_NEGOTIATION_IN_PROGRESS, S_NEGOTIATION_TIMEOUT, S_CERT_LOCAL_INVALID, S_CERT_LOCAL_EXPIRED, S_CERT_REMOTE_INVALID, S_CERT_REMOTE_EXPIRED, S_CERT_REMOTE_PATH, S_PROTO_INVALID, S_PROTO_INCOMPATIBLE, S_PROTO_UNDETERMINED, S_CHANNEL_ERROR, S_CHANNEL_MAX</li></ul>

<p> </p>
<div id="#rfc.figure.95"></div>
<p>Method CICM::Encrypt::ChannelManager::create_encrypt_conduit()</p>
<pre>CICM::Status create_encrypt_conduit(
	in  CICM::RemotePort remote_port,
	in  CICM::SymKey key_ref,
	in  CICM::SymEncrAlgorithmId algorithm,
	out CICM::Encrypt::Conduit conduit_ref
);</pre>
<p>Create conduit to encrypt a stream of data.</p>
<p id="rfc.section.9.1.1.p.11">Parameters: </p>

<ul class="empty">
<li>[in] remote_port Remote port.</li>
<li>[in] key_ref Reference to encryption key.</li>
<li>[in] algorithm Encryption algorithm/mode.</li>
<li>[out] conduit_ref Reference to resulting conduit.</li>
</ul>

<p> </p>
<p id="rfc.section.9.1.1.p.12">Returns: </p>

<ul class="empty"><li>S_OK, S_GENERAL_ERROR, S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION, S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE, S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT, S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_USED_INVALID, S_KEY_USED_EXPIRED, S_KEY_USED_WRAPPED, S_KEY_USED_CONTEXT, S_KEY_INVALID, S_KEY_EXPIRED, S_REMOTE_PORT_INVALID, S_REMOTE_PORT_IN_USE, S_ALGO_INVALID, S_ALGO_INCOMPATIBLE, S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR, S_CHANNEL_MAX</li></ul>

<p> </p>
<div id="#rfc.figure.96"></div>
<p>Method CICM::Encrypt::ChannelManager::create_encrypt_with_mac_conduit()</p>
<pre>CICM::Status create_encrypt_with_mac_conduit(
	in  CICM::RemotePort remote_port,
	in  CICM::SymKey mac_key_ref,
	in  CICM::SymKey encrypt_key_ref,
	in  CICM::SymMacAlgorithmId mac_algorithm,
	in  CICM::SymEncrAlgorithmId encr_algorithm,
	out CICM::Encrypt::WithMACConduit conduit_ref
);</pre>
<p>Create conduit to MAC and encrypt a stream of data.</p>
<p id="rfc.section.9.1.1.p.13">Parameters: </p>

<ul class="empty">
<li>[in] remote_port Remote port.</li>
<li>[in] mac_key_ref Reference to MAC key.</li>
<li>[in] encrypt_key_ref Reference to encryption key.</li>
<li>[in] mac_algorithm MAC algorithm.</li>
<li>[in] encr_algorithm Encryption algorithm/mode.</li>
<li>[out] conduit_ref Reference to resulting conduit.</li>
</ul>

<p> </p>
<p id="rfc.section.9.1.1.p.14">Returns: </p>

<ul class="empty"><li>S_OK, S_GENERAL_ERROR, S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION, S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE, S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT, S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_USED_INVALID, S_KEY_USED_EXPIRED, S_KEY_USED_WRAPPED, S_KEY_USED_CONTEXT, S_KEY_INVALID, S_KEY_EXPIRED, S_REMOTE_PORT_INVALID, S_REMOTE_PORT_IN_USE, S_ALGO_INVALID, S_ALGO_INCOMPATIBLE, S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR, S_CHANNEL_MAX</li></ul>

<p> </p>
<div id="#rfc.figure.97"></div>
<p>Method CICM::Encrypt::ChannelManager::create_encrypt_with_sign_conduit()</p>
<pre>CICM::Status create_encrypt_with_sign_conduit(
	in  CICM::RemotePort remote_port,
	in  CICM::AsymKey sign_key_ref,
	in  CICM::SymKey encrypt_key_ref,
	in  CICM::AsymSigAlgorithmId sign_algorithm,
	in  CICM::SymEncrAlgorithmId encr_algorithm,
	out CICM::Encrypt::WithSignConduit conduit_ref
);</pre>
<p>Create conduit to sign and encrypt a stream of data.</p>
<p id="rfc.section.9.1.1.p.15">Parameters: </p>

<ul class="empty">
<li>[in] remote_port Remote port.</li>
<li>[in] sign_key_ref Reference to signature key.</li>
<li>[in] encrypt_key_ref Reference to encryption key.</li>
<li>[in] sign_algorithm Signature algorithm.</li>
<li>[in] encr_algorithm Encryption algorithm/mode.</li>
<li>[out] conduit_ref Reference to resulting conduit.</li>
</ul>

<p> </p>
<p id="rfc.section.9.1.1.p.16">Returns: </p>

<ul class="empty"><li>S_OK, S_GENERAL_ERROR, S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION, S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE, S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT, S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_USED_INVALID, S_KEY_USED_EXPIRED, S_KEY_USED_WRAPPED, S_KEY_USED_CONTEXT, S_KEY_USED_COMPONENT_NOT_AVAIL, S_KEY_INVALID, S_KEY_EXPIRED, S_REMOTE_PORT_INVALID, S_REMOTE_PORT_IN_USE, S_ALGO_INVALID, S_ALGO_INCOMPATIBLE, S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR, S_CHANNEL_MAX</li></ul>

<p> </p>
<div id="#rfc.figure.98"></div>
<p>Method CICM::Encrypt::ChannelManager::create_key_wrap_conduit()</p>
<pre>CICM::Status create_key_wrap_conduit(
	in  CICM::RemotePort remote_port,
	in  CICM::SymKey kek_ref,
	in  CICM::KeyWrapAlgorithmId algorithm,
	out CICM::Encrypt::KeyWrapConduit conduit_ref
);</pre>
<p>Create conduit to wrap a key.</p>
<p id="rfc.section.9.1.1.p.17">Remarks: </p>

<ul class="empty"><li>This type of conduit may be used to wrap key material bound for a peer cryptographic module. To wrap individual keys already in the module, use CICM::Symkey::wrap or CICM::Asymkey::wrap.</li></ul>

<p> </p>
<p id="rfc.section.9.1.1.p.18">Parameters: </p>

<ul class="empty">
<li>[in] remote_port Remote port.</li>
<li>[in] kek_ref Reference to key encryption key.</li>
<li>[in] algorithm Key wrapping algorithm/mode.</li>
<li>[out] conduit_ref Reference to resulting conduit.</li>
</ul>

<p> </p>
<p id="rfc.section.9.1.1.p.19">Returns: </p>

<ul class="empty"><li>S_OK, S_GENERAL_ERROR, S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION, S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE, S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT, S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_USED_INVALID, S_KEY_USED_EXPIRED, S_KEY_USED_WRAPPED, S_KEY_USED_CONTEXT, S_KEY_INVALID, S_KEY_EXPIRED, S_REMOTE_PORT_INVALID, S_REMOTE_PORT_IN_USE, S_ALGO_INVALID, S_ALGO_INCOMPATIBLE, S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR, S_CHANNEL_MAX</li></ul>

<p> </p>
<div id="#rfc.figure.99"></div>
<p>Method CICM::Encrypt::ChannelManager::create_encrypt_controller()</p>
<pre>CICM::Status create_encrypt_controller(
	in  CICM::LocalPort local_port,
	in  CICM::RemotePort remote_port,
	in  CICM::SymKey key_ref,
	in  CICM::SymEncrAlgorithmId algorithm,
	out CICM::Encrypt::Controller controller_ref
);</pre>
<p>Create controller to configure and control an encryption channel.</p>
<p id="rfc.section.9.1.1.p.20">Remarks: </p>

<ul class="empty"><li>In some cases, hosts may depend upon separate processes to control and use a channel. This method returns the channel controller and MUST be called before the corresponding stream is retrieved.</li></ul>

<p> </p>
<p id="rfc.section.9.1.1.p.21">Parameters: </p>

<ul class="empty">
<li>[in] local_port Local port.</li>
<li>[in] remote_port Remote port.</li>
<li>[in] key_ref Reference to encryption key.</li>
<li>[in] algorithm Encryption algorithm/mode.</li>
<li>[out] controller_ref Reference to resulting controller.</li>
</ul>

<p> </p>
<p id="rfc.section.9.1.1.p.22">Returns: </p>

<ul class="empty"><li>S_OK, S_GENERAL_ERROR, S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION, S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE, S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT, S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_INVALID, S_KEY_EXPIRED, S_LOCAL_PORT_INVALID, S_LOCAL_PORT_INCOMPATIBLE, S_LOCAL_PORT_IN_USE, S_REMOTE_PORT_INVALID, S_REMOTE_PORT_IN_USE, S_ALGO_INVALID, S_ALGO_INCOMPATIBLE, S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR, S_CHANNEL_MAX</li></ul>

<p> </p>
<div id="#rfc.figure.100"></div>
<p>Method CICM::Encrypt::ChannelManager::get_encrypt_stream()</p>
<pre>CICM::Status get_encrypt_stream(
	in  CICM::LocalPort local_port,
	out CICM::Encrypt::Stream stream_ref
);</pre>
<p>Create stream associated with previously created controller to accept data for transformation.</p>
<p id="rfc.section.9.1.1.p.23">Parameters: </p>

<ul class="empty">
<li>[in] local_port Local port.</li>
<li>[out] stream_ref Reference to resulting stream.</li>
</ul>

<p> </p>
<p id="rfc.section.9.1.1.p.24">Returns: </p>

<ul class="empty"><li>S_OK, S_GENERAL_ERROR, S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION, S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE, S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT, S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_INVALID, S_KEY_EXPIRED, S_LOCAL_PORT_INVALID, S_LOCAL_PORT_INCOMPATIBLE, S_LOCAL_PORT_IN_USE, S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR, S_CHANNEL_PEER_RESET, S_CHANNEL_NOT_FOUND</li></ul>

<p> </p>
<h1 id="rfc.section.9.2">
<a href="#rfc.section.9.2">9.2.</a> Interface CICM::Encrypt::Stream</h1>
<div id="#rfc.figure.101"></div>
<p>Interface CICM::Encrypt::Stream</p>
<pre>interface Stream : CICM::WriteStream {</pre>
<p>CICM::Encrypt::Stream supports encryption operations between two independent security domains. The resulting stream is capable of accepting data for transformation, but not managing the channel.  It is created by calling CICM::ChannelManager::get_encrypt_stream.</p>
<h1 id="rfc.section.9.2.1">
<a href="#rfc.section.9.2.1">9.2.1.</a> CICM::Encrypt::Stream Inheritance</h1>
<p id="rfc.section.9.2.1.p.1">CICM::Encrypt::Stream inherits from: CICM::WriteStream.</p>
<h1 id="rfc.section.9.2.2">
<a href="#rfc.section.9.2.2">9.2.2.</a> CICM::Encrypt::Stream Methods</h1>
<div id="#rfc.figure.102"></div>
<p>Method CICM::Encrypt::Stream::encrypt()</p>
<pre>CICM::Status encrypt(
	in  CICM::Buffer buffer
);</pre>
<p>Sends data to the module to be encrypted. The method blocks until data is sent.</p>
<p id="rfc.section.9.2.2.p.1">Parameters: </p>

<ul class="empty"><li>[in] buffer Plaintext to encrypt.</li></ul>

<p> </p>
<p id="rfc.section.9.2.2.p.2">Returns: </p>

<ul class="empty"><li>S_OK, S_GENERAL_ERROR, S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION, S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE, S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT, S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_INVALID, S_KEY_EXPIRED, S_KEY_WRAPPED, S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR, S_CHANNEL_PEER_RESET, S_CHANNEL_IO_ERROR, S_CHANNEL_DATA_INVALID, S_CHANNEL_DATA_INVALID_LEN</li></ul>

<p> </p>
<div id="#rfc.figure.103"></div>
<p>Method CICM::Encrypt::Stream::encrypt_non_blocking()</p>
<pre>CICM::Status encrypt_non_blocking(
	in  CICM::Buffer buffer,
	in  CICM::TransId transaction_id
);</pre>
<p>Registers a buffer of data to be sent to the module for encryption and then immediately returns control to the caller. The length of the data is encapsulated in the buffer parameter. The caller may use the CICM::Encrypt::Stream::encrypt_poll method to proactively poll the channel to determine the status of the operation. The caller is responsible for maintaining any necessary metadata associated with the transaction_id parameter. Memory responsibilities and calling conventions MUST follow the appropriate IDL language mapping conventions.</p>
<p id="rfc.section.9.2.2.p.3">Parameters: </p>

<ul class="empty">
<li>[in] buffer Plaintext to encrypt.</li>
<li>[in] transaction_id Unique transaction id that will be used by the CICM::Encrypt::Stream::encrypt_poll method to determine to which buffer the poll status applies.</li>
</ul>

<p> </p>
<p id="rfc.section.9.2.2.p.4">Returns: </p>

<ul class="empty"><li>S_OK, S_GENERAL_ERROR, S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION, S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE, S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT, S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_INVALID, S_KEY_EXPIRED, S_KEY_WRAPPED, S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR, S_CHANNEL_PEER_RESET, S_CHANNEL_IO_ERROR, S_CHANNEL_DATA_INVALID, S_CHANNEL_DATA_INVALID_LEN</li></ul>

<p> </p>
<div id="#rfc.figure.104"></div>
<p>Method CICM::Encrypt::Stream::encrypt_poll()</p>
<pre>CICM::Status encrypt_poll(
	in  CICM::TransId transaction_id,
	out CICM::WriteStream::WriteStatus status
);</pre>
<p>Returns the status of the non-blocking encryption operation specified by the transaction_id parameter. Memory responsibilities and calling conventions shall follow the appropriate IDL language mapping conventions.</p>
<p id="rfc.section.9.2.2.p.5">Parameters: </p>

<ul class="empty">
<li>[in] transaction_id Unique transaction id previously specified to the CICM::Encrypt::Stream::encrypt_non_blocking method that allows the poll operation to determine to which buffer the poll status applies.</li>
<li>[out] status Status of the non-blocking operation corresponding to the transaction_id parameter.</li>
</ul>

<p> </p>
<p id="rfc.section.9.2.2.p.6">Returns: </p>

<ul class="empty"><li>S_OK, S_GENERAL_ERROR, S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION, S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE, S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT, S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_INVALID, S_KEY_EXPIRED, S_KEY_WRAPPED, S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR, S_CHANNEL_PEER_RESET, S_CHANNEL_IO_ERROR</li></ul>

<p> </p>
<h1 id="rfc.section.9.3">
<a href="#rfc.section.9.3">9.3.</a> Interface CICM::Encrypt::KeyWrapStream</h1>
<div id="#rfc.figure.105"></div>
<p>Interface  CICM::Encrypt::KeyWrapStream</p>
<pre>interface KeyWrapStream : CICM::Stream {</pre>
<p>CICM::Encrypt::KeyWrapStream is an abstraction that allows key material to be presented to a stream for wrapping prior to passing into a different security domain.</p>
<h1 id="rfc.section.9.3.1">
<a href="#rfc.section.9.3.1">9.3.1.</a> CICM::Encrypt::KeyWrapStream Inheritance</h1>
<p id="rfc.section.9.3.1.p.1">CICM::Encrypt::KeyWrapStream inherits from: CICM::Stream.</p>
<h1 id="rfc.section.9.3.2">
<a href="#rfc.section.9.3.2">9.3.2.</a> CICM::Encrypt::KeyWrapStream Methods</h1>
<div id="#rfc.figure.106"></div>
<p>Method CICM::Encrypt::KeyWrapStream::wrap_key()</p>
<pre>CICM::Status wrap_key(
	in CICM::Key key_ref
);</pre>
<p>Write the key to be wrapped to the channel stream.</p>
<p id="rfc.section.9.3.2.p.1">Remarks: </p>

<ul class="empty"><li>The method blocks until the key has been written.</li></ul>

<p> </p>
<p id="rfc.section.9.3.2.p.2">Parameters: </p>

<ul class="empty"><li>[in] key_ref Reference to key to be wrapped.</li></ul>

<p> </p>
<p id="rfc.section.9.3.2.p.3">Returns: </p>

<ul class="empty"><li>S_OK, S_GENERAL_ERROR, S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION, S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE, S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT, S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_INVALID, S_KEY_EXPIRED, S_KEY_CLASSIFICATION, S_KEY_WRAPPED, S_KEY_NOT_WRAPPABLE, S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR, S_CHANNEL_PEER_RESET, S_CHANNEL_IO_ERROR</li></ul>

<p> </p>
<h1 id="rfc.section.9.4">
<a href="#rfc.section.9.4">9.4.</a> Interface CICM::Encrypt::Controller</h1>
<div id="#rfc.figure.107"></div>
<p>Interface CICM::Encrypt::Controller</p>
<pre>interface Controller :
	CICM::MultiDomainController,
	CICM::SymKeyController,
	CICM::GenVectorController,
	CICM::ResyncController {</pre>
<p>CICM::Encrypt::Controller supports encryption operations between two independent security domains. The resulting controller is capable of managing the channel, but not accepting data for transformation. It is created by calling CICM::ChannelManager::create_encrypt_controller.</p>
<h1 id="rfc.section.9.4.1">
<a href="#rfc.section.9.4.1">9.4.1.</a> CICM::Encrypt::Controller Inheritance</h1>
<p id="rfc.section.9.4.1.p.1">CICM::Encrypt::Controller inherits from: CICM::MultiDomainController, CICM::SymKeyController, CICM::GenVectorController and CICM::ResyncController.</p>
<h1 id="rfc.section.9.5">
<a href="#rfc.section.9.5">9.5.</a> Interface CICM::Encrypt::NegotiatedController</h1>
<div id="#rfc.figure.108"></div>
<p>Interface  CICM::Encrypt::NegotiatedController</p>
<pre>interface NegotiatedController :
	CICM::NegotiatedController,
	CICM::GenVectorController,
	CICM::ResyncController {</pre>
<p>CICM::Encrypt::NegotiatedController is the negotiated version of CICM::Encrypt::Controller. It is the result of a successful negotiation by CICM::Encrypt::ControllerNegotiator.</p>
<h1 id="rfc.section.9.5.1">
<a href="#rfc.section.9.5.1">9.5.1.</a> CICM::Encrypt::NegotiatedController Inheritance</h1>
<p id="rfc.section.9.5.1.p.1">CICM::Encrypt::NegotiatedController inherits from: CICM::NegotiatedController, CICM::GenVectorController and CICM::ResyncController.</p>
<h1 id="rfc.section.9.6">
<a href="#rfc.section.9.6">9.6.</a> Interface CICM::Encrypt::Conduit</h1>
<div id="#rfc.figure.109"></div>
<p>Interface CICM::Encrypt::Conduit</p>
<pre>interface Conduit :
	CICM::Conduit,
	CICM::Encrypt::Controller,
	CICM::Encrypt::Stream {</pre>
<p>CICM::Encrypt::Conduit supports encryption operations between two independent security domains. The resulting conduit is capable of both managing the channel and accepting data for transformation.  It is created by calling CICM::ChannelManager::create_encrypt_conduit.</p>
<h1 id="rfc.section.9.6.1">
<a href="#rfc.section.9.6.1">9.6.1.</a> CICM::Encrypt::Conduit Inheritance</h1>
<p id="rfc.section.9.6.1.p.1">CICM::Encrypt::Conduit inherits from: CICM::Conduit, CICM::Encrypt::Controller and CICM::Encrypt::Stream.</p>
<h1 id="rfc.section.9.7">
<a href="#rfc.section.9.7">9.7.</a> Interface CICM::Encrypt::NegotiatedConduit</h1>
<div id="#rfc.figure.110"></div>
<p>Interface  CICM::Encrypt::NegotiatedConduit</p>
<pre>interface NegotiatedConduit :
CICM::Conduit,
CICM::Encrypt::NegotiatedController,
CICM::Encrypt::Stream {</pre>
<p>CICM::Encrypt::NegotiatedConduit is the negotiated version of CICM::Encrypt::Conduit. It is the result of a successful negotiation by CICM::Encrypt::Negotiator.</p>
<h1 id="rfc.section.9.7.1">
<a href="#rfc.section.9.7.1">9.7.1.</a> CICM::Encrypt::NegotiatedConduit Inheritance</h1>
<p id="rfc.section.9.7.1.p.1">CICM::Encrypt::NegotiatedConduit inherits from: CICM::Conduit, CICM::Encrypt::NegotiatedController and CICM::Encrypt::Stream.</p>
<h1 id="rfc.section.9.8">
<a href="#rfc.section.9.8">9.8.</a> Interface CICM::Encrypt::WithMACConduit</h1>
<div id="#rfc.figure.111"></div>
<p>Interface CICM::Encrypt::WithMACConduit</p>
<pre>interface WithMACConduit :
CICM::AbstractMACConduit,
CICM::Encrypt::Conduit {</pre>
<p>CICM::Encrypt::WithMACConduit supports encryption operations between two independent security domains with the receipt of a MAC value in the initiating domain. The resulting conduit is capable of both managing the channel and accepting data for transformation. It is created by calling CICM::ChannelManager::create_encrypt_with_mac_conduit.</p>
<h1 id="rfc.section.9.8.1">
<a href="#rfc.section.9.8.1">9.8.1.</a> CICM::Encrypt::WithMACConduit Inheritance</h1>
<p id="rfc.section.9.8.1.p.1">CICM::Encrypt::WithMACConduit inherits from: CICM::AbstractMACConduit and CICM::Encrypt::Conduit.</p>
<h1 id="rfc.section.9.9">
<a href="#rfc.section.9.9">9.9.</a> Interface CICM::Encrypt::WithMACNegotiatedConduit</h1>
<div id="#rfc.figure.112"></div>
<p>Interface  CICM::Encrypt::WithMACNegotiatedConduit</p>
<pre>interface WithMACNegotiatedConduit :
CICM::AbstractMACConduit,
CICM::Encrypt::NegotiatedConduit {</pre>
<p>CICM::Encrypt::WithMACNegotiatedConduit is the negotiated version of CICM::Encrypt::WithMACConduit. It is the result of a successful negotiation by CICM::Encrypt::WithMACNegotiator.</p>
<h1 id="rfc.section.9.9.1">
<a href="#rfc.section.9.9.1">9.9.1.</a> CICM::Encrypt::WithMACNegotiatedConduit Inheritance</h1>
<p id="rfc.section.9.9.1.p.1">CICM::Encrypt::WithMACNegotiatedConduit inherits from: CICM::AbstractMACConduit and CICM::Encrypt::NegotiatedConduit.</p>
<h1 id="rfc.section.9.10">
<a href="#rfc.section.9.10">9.10.</a> Interface CICM::Encrypt::WithSignConduit</h1>
<div id="#rfc.figure.113"></div>
<p>Interface  CICM::Encrypt::WithSignConduit</p>
<pre>interface WithSignConduit :
CICM::AbstractSignConduit,
CICM::Encrypt::Conduit {</pre>
<p>CICM::Encrypt::WithSignConduit supports encryption operations between two independent security domains with the receipt of a signature value in the initiating domain. The resulting conduit is capable of both managing the channel and accepting data for transformation. It is created by calling CICM::ChannelManager::create_encrypt_with_sign_conduit.</p>
<h1 id="rfc.section.9.10.1">
<a href="#rfc.section.9.10.1">9.10.1.</a> CICM::Encrypt::WithSignConduit Inheritance</h1>
<p id="rfc.section.9.10.1.p.1">CICM::Encrypt::WithSignConduit inherits from: CICM::AbstractSignConduit and CICM::Encrypt::Conduit.</p>
<h1 id="rfc.section.9.11">
<a href="#rfc.section.9.11">9.11.</a> Interface CICM::Encrypt::WithSignNegotiatedConduit</h1>
<div id="#rfc.figure.114"></div>
<p>Interface  CICM::Encrypt::WithSignNegotiatedConduit</p>
<pre>interface WithSignNegotiatedConduit :
CICM::AbstractSignConduit,
CICM::Encrypt::NegotiatedConduit {</pre>
<p>CICM::Encrypt::WithSignNegotiatedConduit is the negotiated version of CICM::Encrypt::WithSignConduit. It is the result of a successful negotiation by CICM::Encrypt::WithSignNegotiator.</p>
<h1 id="rfc.section.9.11.1">
<a href="#rfc.section.9.11.1">9.11.1.</a> CICM::Encrypt::WithSignNegotiatedConduit Inheritance</h1>
<p id="rfc.section.9.11.1.p.1">CICM::Encrypt::WithSignNegotiatedConduit inherits from: CICM::AbstractSignConduit and CICM::Encrypt::NegotiatedConduit.</p>
<h1 id="rfc.section.9.12">
<a href="#rfc.section.9.12">9.12.</a> Interface CICM::Encrypt::KeyWrapConduit</h1>
<div id="#rfc.figure.115"></div>
<p>Interface  CICM::Encrypt::KeyWrapConduit</p>
<pre>interface KeyWrapConduit :
CICM::Encrypt::Controller,
CICM::Encrypt::KeyWrapStream {</pre>
<p>CICM::Encrypt::KeyWrapConduit supports key wrapping operations between two independent security domains. The resulting conduit is capable of both managing the channel and accepting keys for transformation. It is created by calling CICM::ChannelManager::create_key_wrap_conduit.</p>
<h1 id="rfc.section.9.12.1">
<a href="#rfc.section.9.12.1">9.12.1.</a> CICM::Encrypt::KeyWrapConduit Inheritance</h1>
<p id="rfc.section.9.12.1.p.1">CICM::Encrypt::KeyWrapConduit inherits from: CICM::Encrypt::Controller and CICM::Encrypt::KeyWrapStream.</p>
<h1 id="rfc.section.9.13">
<a href="#rfc.section.9.13">9.13.</a> Interface CICM::Encrypt::ControllerNegotiator</h1>
<div id="#rfc.figure.116"></div>
<p>Interface  CICM::Encrypt::ControllerNegotiator</p>
<pre>interface ControllerNegotiator : CICM::Negotiator {</pre>
<p>CICM::Encrypt::ControllerNegotiator initiates a negotiation to establish a shared key with a remote entity that is used to support encryption operations between two independent security domains. The result of a successful negotiation is a CICM::Encrypt::NegotiatedController which is capable of managing the channel, but not accepting data for transformation.  CICM::Encrypt::ControllerNegotiator is created by calling CICM::ChannelManager::negotiate_encrypt_controller.</p>
<h1 id="rfc.section.9.13.1">
<a href="#rfc.section.9.13.1">9.13.1.</a> CICM::Encrypt::ControllerNegotiator Inheritance</h1>
<p id="rfc.section.9.13.1.p.1">CICM::Encrypt::ControllerNegotiator inherits from: CICM::Negotiator.</p>
<h1 id="rfc.section.9.13.2">
<a href="#rfc.section.9.13.2">9.13.2.</a> CICM::Encrypt::ControllerNegotiator Methods</h1>
<div id="#rfc.figure.117"></div>
<p>Method CICM::Encrypt::ControllerNegotiator::complete()</p>
<pre>CICM::Status complete(
	out CICM::Encrypt::NegotiatedController controller_ref
);</pre>
<p>Complete negotiation and retrieve a negotiated negotiated encrypt controller.</p>
<p id="rfc.section.9.13.2.p.1">Parameters: </p>

<ul class="empty"><li>[out] controller_ref Reference to resulting controller.</li></ul>

<p> </p>
<p id="rfc.section.9.13.2.p.2">Returns: </p>

<ul class="empty"><li>S_OK, S_GENERAL_ERROR, S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION, S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE, S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT, S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT, S_NEGOTIATION_ABORTED, S_NEGOTIATION_FAILURE, S_NEGOTIATION_NOT_IN_PROGRESS, S_NEGOTIATION_TIMEOUT, S_CERT_LOCAL_INVALID, S_CERT_LOCAL_EXPIRED, S_CERT_REMOTE_INVALID, S_CERT_REMOTE_EXPIRED, S_CERT_REMOTE_PATH, S_CHANNEL_ERROR, S_CHANNEL_PEER_RESET</li></ul>

<p> </p>
<h1 id="rfc.section.9.14">
<a href="#rfc.section.9.14">9.14.</a> Interface CICM::Encrypt::Negotiator</h1>
<div id="#rfc.figure.118"></div>
<p>Interface CICM::Encrypt::Negotiator</p>
<pre>interface Negotiator : CICM::Negotiator {</pre>
<p>CICM::Encrypt::Negotiator initiates a negotiation to establish a shared key with a remote entity that is used to support encryption operations between two independent security domains. The result of a successful negotiation is a CICM::Encrypt::NegotiatedConduit which is capable of both managing the channel and accepting data for transformation. CICM::Negotiator is created by calling CICM::Encrypt::ChannelManager::negotiate_encrypt_conduit.</p>
<h1 id="rfc.section.9.14.1">
<a href="#rfc.section.9.14.1">9.14.1.</a> CICM::Encrypt::Negotiator Inheritance</h1>
<p id="rfc.section.9.14.1.p.1">CICM::Encrypt::Negotiator inherits from: CICM::Negotiator.</p>
<h1 id="rfc.section.9.14.2">
<a href="#rfc.section.9.14.2">9.14.2.</a> CICM::Encrypt::Negotiator Methods</h1>
<div id="#rfc.figure.119"></div>
<p>Method CICM::Encrypt::Negotiator::complete()</p>
<pre>CICM::Status complete(
	out CICM::Encrypt::NegotiatedConduit conduit_ref
);</pre>
<p>Complete negotiation and retrieve a negotiated encrypt conduit.</p>
<p id="rfc.section.9.14.2.p.1">Parameters: </p>

<ul class="empty"><li>[out] conduit_ref Reference to resulting conduit.</li></ul>

<p> </p>
<p id="rfc.section.9.14.2.p.2">Returns: </p>

<ul class="empty"><li>S_OK, S_GENERAL_ERROR, S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION, S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE, S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT, S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT, S_NEGOTIATION_ABORTED, S_NEGOTIATION_FAILURE, S_NEGOTIATION_NOT_IN_PROGRESS, S_NEGOTIATION_TIMEOUT, S_CERT_LOCAL_INVALID, S_CERT_LOCAL_EXPIRED, S_CERT_REMOTE_INVALID, S_CERT_REMOTE_EXPIRED, S_CERT_REMOTE_PATH, S_CHANNEL_ERROR, S_CHANNEL_PEER_RESET</li></ul>

<p> </p>
<h1 id="rfc.section.9.15">
<a href="#rfc.section.9.15">9.15.</a> Interface CICM::Encrypt::WithMACNegotiator</h1>
<div id="#rfc.figure.120"></div>
<p>Interface  CICM::Encrypt::WithMACNegotiator</p>
<pre>interface WithMACNegotiator : CICM::Negotiator {</pre>
<p>CICM::Encrypt::WithMACNegotiator initiates a negotiation to establish a shared key with a remote entity that is used to support encryption operations between two independent security domains.  Additionally, a message authentication code (MAC) is received in the initiating domain. The result of a successful negotiation is a CICM::Encrypt::WithMACNegotiatedConduit which is capable of both managing the channel and accepting data for transformation.  CICM::Encrypt::WithMACNegotiator is created by calling CICM::ChannelManager::negotiate_encrypt_with_mac_conduit.</p>
<h1 id="rfc.section.9.15.1">
<a href="#rfc.section.9.15.1">9.15.1.</a> CICM::Encrypt::WithMACNegotiator Inheritance</h1>
<p id="rfc.section.9.15.1.p.1">CICM::Encrypt::WithMACNegotiator inherits from: CICM::Negotiator.</p>
<h1 id="rfc.section.9.15.2">
<a href="#rfc.section.9.15.2">9.15.2.</a> CICM::Encrypt::WithMACNegotiator Methods</h1>
<div id="#rfc.figure.121"></div>
<p>Method CICM::Encrypt::WithMACNegotiator::complete()</p>
<pre>CICM::Status complete(
	out CICM::Encrypt::WithMACNegotiatedConduit conduit_ref
);</pre>
<p>Complete negotiation and retrieve a negotiated MAC encrypt conduit.</p>
<p id="rfc.section.9.15.2.p.1">Parameters: </p>

<ul class="empty"><li>[out] conduit_ref Reference to resulting conduit.</li></ul>

<p> </p>
<p id="rfc.section.9.15.2.p.2">Returns: </p>

<ul class="empty"><li>S_OK, S_GENERAL_ERROR, S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION, S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE, S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT, S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT, S_NEGOTIATION_ABORTED, S_NEGOTIATION_FAILURE, S_NEGOTIATION_NOT_IN_PROGRESS, S_NEGOTIATION_TIMEOUT, S_CERT_LOCAL_INVALID, S_CERT_LOCAL_EXPIRED, S_CERT_REMOTE_INVALID, S_CERT_REMOTE_EXPIRED, S_CERT_REMOTE_PATH, S_CHANNEL_ERROR, S_CHANNEL_PEER_RESET</li></ul>

<p> </p>
<h1 id="rfc.section.9.16">
<a href="#rfc.section.9.16">9.16.</a> Interface CICM::Encrypt::WithSignNegotiator</h1>
<div id="#rfc.figure.122"></div>
<p>Interface  CICM::Encrypt::WithSignNegotiator</p>
<pre>interface WithSignNegotiator : CICM::Negotiator {</pre>
<p>CICM::Encrypt::WithSignNegotiator initiates a negotiation to establish a shared key with a remote entity that is used to support encryption operations between two independent security domains.  Additionally, a signature value is received in the initiating domain. The result of a successful negotiation is a CICM::Encrypt::WithSignNegotiatedConduit which is capable of both managing the channel and accepting data for transformation.  CICM::Encrypt::WithSignNegotiator is created by calling CICM::ChannelManager::negotiate_encrypt_with_sign_conduit.</p>
<h1 id="rfc.section.9.16.1">
<a href="#rfc.section.9.16.1">9.16.1.</a> CICM::Encrypt::WithSignNegotiator Inheritance</h1>
<p id="rfc.section.9.16.1.p.1">CICM::Encrypt::WithSignNegotiator inherits from: CICM::Negotiator.</p>
<h1 id="rfc.section.9.16.2">
<a href="#rfc.section.9.16.2">9.16.2.</a> CICM::Encrypt::WithSignNegotiator Methods</h1>
<div id="#rfc.figure.123"></div>
<p>Method CICM::Encrypt::WithSignNegotiator::complete()</p>
<pre>CICM::Status complete(
	out CICM::Encrypt::WithSignNegotiatedConduit conduit_ref
);</pre>
<p>Complete negotiation and retrieve a negotiated sign encrypt conduit.</p>
<p id="rfc.section.9.16.2.p.1">Parameters: </p>

<ul class="empty"><li>[out] conduit_ref Reference to resulting conduit.</li></ul>

<p> </p>
<p id="rfc.section.9.16.2.p.2">Returns: </p>

<ul class="empty"><li>S_OK, S_GENERAL_ERROR, S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION, S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE, S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT, S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT, S_NEGOTIATION_ABORTED, S_NEGOTIATION_FAILURE, S_NEGOTIATION_NOT_IN_PROGRESS, S_NEGOTIATION_TIMEOUT, S_CERT_LOCAL_INVALID, S_CERT_LOCAL_EXPIRED, S_CERT_REMOTE_INVALID, S_CERT_REMOTE_EXPIRED, S_CERT_REMOTE_PATH, S_CHANNEL_ERROR, S_CHANNEL_PEER_RESET</li></ul>

<p> </p>
<h1 id="rfc.section.10">
<a href="#rfc.section.10">10.</a> <a href="#sec-decrypt" id="sec-decrypt">Decryption</a>
</h1>
<div id="#rfc.figure.124"></div>
<p>Namespace CICM::Decrypt</p>
<pre>module Decrypt {</pre>
<p>The CICM::Decrypt namespace contains interfaces that support decryption operations between two independent security domains.</p>
<h1 id="rfc.section.10.1">
<a href="#rfc.section.10.1">10.1.</a> Interface CICM::Decrypt::ChannelManager</h1>
<div id="#rfc.figure.125"></div>
<p>Interface  CICM::Decrypt::ChannelManager</p>
<pre>interface ChannelManager {</pre>
<p>CICM::Decrypt::ChannelManager is an abstraction inherited by CICM::ChannelManager that supports the creation of decryption negotiators, conduits, controllers, and streams. See CICM::ChannelManager for additional information.</p>
<h1 id="rfc.section.10.1.1">
<a href="#rfc.section.10.1.1">10.1.1.</a> CICM::Decrypt::ChannelManager Methods</h1>
<div id="#rfc.figure.126"></div>
<p>Method CICM::Decrypt::ChannelManager::negotiate_decrypt_conduit()</p>
<pre>CICM::Status negotiate_decrypt_conduit(
	in  CICM::RemotePort remote_port,
	in  CICM::ProtocolId protocol,
	in  CICM::AsymKey key_ref,
	out CICM::Decrypt::Negotiator negotiator_ref
);</pre>
<p>Creates a negotiator that, upon successful negotiation, results in a CICM::Decrypt::NegotiatedConduit.</p>
<p id="rfc.section.10.1.1.p.1">Parameters: </p>

<ul class="empty">
<li>[in] remote_port Remote port.</li>
<li>[in] protocol Protocol identifier.</li>
<li>[in] key_ref Reference to negotiation key.</li>
<li>[out] negotiator_ref Reference to resulting negotiator.</li>
</ul>

<p> </p>
<p id="rfc.section.10.1.1.p.2">Returns: </p>

<ul class="empty"><li>S_OK, S_GENERAL_ERROR, S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION, S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE, S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT, S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_USED_INVALID, S_KEY_USED_EXPIRED, S_KEY_USED_WRAPPED, S_KEY_USED_CONTEXT, S_KEY_USED_COMPONENT_NOT_AVAIL, S_KEY_INVALID, S_KEY_EXPIRED, S_REMOTE_PORT_INVALID, S_REMOTE_PORT_IN_USE, S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT, S_NEGOTIATION_ABORTED, S_NEGOTIATION_FAILURE, S_NEGOTIATION_IN_PROGRESS, S_NEGOTIATION_TIMEOUT, S_CERT_LOCAL_INVALID, S_CERT_LOCAL_EXPIRED, S_CERT_REMOTE_INVALID, S_CERT_REMOTE_EXPIRED, S_CERT_REMOTE_PATH, S_PROTO_INVALID, S_PROTO_INCOMPATIBLE, S_PROTO_UNDETERMINED, S_CHANNEL_ERROR, S_CHANNEL_MAX</li></ul>

<p> </p>
<div id="#rfc.figure.127"></div>
<p>Method CICM::Decrypt::ChannelManager::negotiate_decrypt_with_mac_conduit()</p>
<pre>CICM::Status negotiate_decrypt_with_mac_conduit(
	in  CICM::RemotePort remote_port,
	in  CICM::ProtocolId protocol,
	in  CICM::SymKey verify_key_ref,
	in  CICM::AsymKey nego_key_ref,
	in  CICM::SymMacAlgorithmId verify_algorithm,
	out CICM::Decrypt::WithMACNegotiator negotiator_ref
);</pre>
<p>Creates a negotiator that, upon successful negotiation, results in a CICM::Decrypt::MACNegotiatedConduit.</p>
<p id="rfc.section.10.1.1.p.3">Remarks: </p>

<ul class="empty"><li>Negotiation applies only to the negotiation key, not the MAC key.</li></ul>

<p> </p>
<p id="rfc.section.10.1.1.p.4">Parameters: </p>

<ul class="empty">
<li>[in] remote_port Remote port.</li>
<li>[in] protocol Protocol identifier.</li>
<li>[in] verify_key_ref Reference to verification key.</li>
<li>[in] nego_key_ref Reference to negotiation key.</li>
<li>[in] verify_algorithm Verification algorithm.</li>
<li>[out] negotiator_ref Reference to resulting negotiator.</li>
</ul>

<p> </p>
<p id="rfc.section.10.1.1.p.5">Returns: </p>

<ul class="empty"><li>S_OK, S_GENERAL_ERROR, S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION, S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE, S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT, S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_USED_INVALID, S_KEY_USED_EXPIRED, S_KEY_USED_WRAPPED, S_KEY_USED_CONTEXT, S_KEY_USED_COMPONENT_NOT_AVAIL, S_KEY_INVALID, S_KEY_EXPIRED, S_REMOTE_PORT_INVALID, S_REMOTE_PORT_IN_USE, S_ALGO_INVALID, S_ALGO_INCOMPATIBLE, S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT, S_NEGOTIATION_ABORTED, S_NEGOTIATION_FAILURE, S_NEGOTIATION_IN_PROGRESS, S_NEGOTIATION_TIMEOUT, S_CERT_LOCAL_INVALID, S_CERT_LOCAL_EXPIRED, S_CERT_REMOTE_INVALID, S_CERT_REMOTE_EXPIRED, S_CERT_REMOTE_PATH, S_PROTO_INVALID, S_PROTO_INCOMPATIBLE, S_PROTO_UNDETERMINED, S_CHANNEL_ERROR, S_CHANNEL_MAX</li></ul>

<p> </p>
<div id="#rfc.figure.128"></div>
<p>Method CICM::Decrypt::ChannelManager::negotiate_decrypt_with_verify_conduit()</p>
<pre>CICM::Status negotiate_decrypt_with_verify_conduit(
	in  CICM::RemotePort remote_port,
	in  CICM::ProtocolId protocol,
	in  CICM::AsymKey verify_key_ref,
	in  CICM::AsymKey nego_key_ref,
	in  CICM::AsymSigAlgorithmId verify_algorithm,
	out CICM::Decrypt::WithVerifyNegotiator negotiator_ref
);</pre>
<p>Initiate a negotiation to establish a shared key with a peer.  The channel that results will decrypt and verify a stream of data.</p>
<p id="rfc.section.10.1.1.p.6">Remarks: </p>

<ul class="empty"><li>Negotiation applies only to the negotiation key, not the signature verification key.</li></ul>

<p> </p>
<p id="rfc.section.10.1.1.p.7">Parameters: </p>

<ul class="empty">
<li>[in] remote_port Remote port.</li>
<li>[in] protocol Protocol identifier.</li>
<li>[in] verify_key_ref Reference to verification key.</li>
<li>[in] nego_key_ref Reference to negotiation key.</li>
<li>[in] verify_algorithm Verification algorithm.</li>
<li>[out] negotiator_ref Reference to resulting negotiator.</li>
</ul>

<p> </p>
<p id="rfc.section.10.1.1.p.8">Returns: </p>

<ul class="empty"><li>S_OK, S_GENERAL_ERROR, S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION, S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE, S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT, S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_USED_INVALID, S_KEY_USED_EXPIRED, S_KEY_USED_WRAPPED, S_KEY_USED_CONTEXT, S_KEY_USED_COMPONENT_NOT_AVAIL, S_KEY_INVALID, S_KEY_EXPIRED, S_REMOTE_PORT_INVALID, S_REMOTE_PORT_IN_USE, S_ALGO_INVALID, S_ALGO_INCOMPATIBLE, S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT, S_NEGOTIATION_ABORTED, S_NEGOTIATION_FAILURE, S_NEGOTIATION_IN_PROGRESS, S_NEGOTIATION_TIMEOUT, S_CERT_LOCAL_INVALID, S_CERT_LOCAL_EXPIRED, S_CERT_REMOTE_INVALID, S_CERT_REMOTE_EXPIRED, S_CERT_REMOTE_PATH, S_PROTO_INVALID, S_PROTO_INCOMPATIBLE, S_PROTO_UNDETERMINED, S_CHANNEL_ERROR, S_CHANNEL_MAX</li></ul>

<p> </p>
<div id="#rfc.figure.129"></div>
<p>Method CICM::Decrypt::ChannelManager::negotiate_decrypt_controller()</p>
<pre>CICM::Status negotiate_decrypt_controller(
	in  CICM::LocalPort local_port,
	in  CICM::RemotePort remote_port,
	in  CICM::ProtocolId protocol,
	in  CICM::AsymKey key_ref,
	out CICM::Decrypt::ControllerNegotiator negotiator_ref
);</pre>
<p>Initiate a negotiation to establish a shared key with a peer, resulting in a controller to manage a decryption channel.</p>
<p id="rfc.section.10.1.1.p.9">Parameters: </p>

<ul class="empty">
<li>[in] local_port Local port.</li>
<li>[in] remote_port Remote port.</li>
<li>[in] protocol Protocol identifier.</li>
<li>[in] key_ref Reference to negotiation key.</li>
<li>[out] negotiator_ref Reference to resulting negotiator.</li>
</ul>

<p> </p>
<p id="rfc.section.10.1.1.p.10">Returns: </p>

<ul class="empty"><li>S_OK, S_GENERAL_ERROR, S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION, S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE, S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT, S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_USED_INVALID, S_KEY_USED_EXPIRED, S_KEY_USED_WRAPPED, S_KEY_USED_CONTEXT, S_KEY_USED_COMPONENT_NOT_AVAIL, S_KEY_INVALID, S_KEY_EXPIRED, S_LOCAL_PORT_INVALID, S_LOCAL_PORT_INCOMPATIBLE, S_LOCAL_PORT_IN_USE, S_REMOTE_PORT_INVALID, S_REMOTE_PORT_IN_USE, S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT, S_NEGOTIATION_ABORTED, S_NEGOTIATION_FAILURE, S_NEGOTIATION_IN_PROGRESS, S_NEGOTIATION_TIMEOUT, S_CERT_LOCAL_INVALID, S_CERT_LOCAL_EXPIRED, S_CERT_REMOTE_INVALID, S_CERT_REMOTE_EXPIRED, S_CERT_REMOTE_PATH, S_PROTO_INVALID, S_PROTO_INCOMPATIBLE, S_PROTO_UNDETERMINED, S_CHANNEL_ERROR, S_CHANNEL_MAX</li></ul>

<p> </p>
<div id="#rfc.figure.130"></div>
<p>Method CICM::Decrypt::ChannelManager::create_decrypt_conduit()</p>
<pre>CICM::Status create_decrypt_conduit(
	in  CICM::RemotePort remote_port,
	in  CICM::SymKey key_ref,
	in  CICM::SymEncrAlgorithmId algorithm,
	out CICM::Decrypt::Conduit conduit_ref
);</pre>
<p>Create channel to decrypt a stream of data.</p>
<p id="rfc.section.10.1.1.p.11">Parameters: </p>

<ul class="empty">
<li>[in] remote_port Remote port.</li>
<li>[in] key_ref Reference to decryption key.</li>
<li>[in] algorithm Decryption algorithm/mode.</li>
<li>[out] conduit_ref Reference to resulting conduit.</li>
</ul>

<p> </p>
<p id="rfc.section.10.1.1.p.12">Returns: </p>

<ul class="empty"><li>S_OK, S_GENERAL_ERROR, S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION, S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE, S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT, S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_USED_INVALID, S_KEY_USED_EXPIRED, S_KEY_INVALID, S_KEY_EXPIRED, S_REMOTE_PORT_INVALID, S_REMOTE_PORT_IN_USE, S_ALGO_INVALID, S_ALGO_INCOMPATIBLE, S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR, S_CHANNEL_MAX</li></ul>

<p> </p>
<div id="#rfc.figure.131"></div>
<p>Method CICM::Decrypt::ChannelManager::create_decrypt_with_mac_conduit()</p>
<pre>CICM::Status create_decrypt_with_mac_conduit(
	in  CICM::RemotePort remote_port,
	in  CICM::SymKey verify_key_ref,
	in  CICM::SymKey decrypt_key_ref,
	in  CICM::SymMacAlgorithmId verify_algorithm,
	in  CICM::SymEncrAlgorithmId decrypt_algorithm,
	out CICM::Decrypt::WithMACConduit conduit_ref
);</pre>
<p>Create channel to MAC verify and decrypt a stream of data.</p>
<p id="rfc.section.10.1.1.p.13">Parameters: </p>

<ul class="empty">
<li>[in] remote_port Remote port.</li>
<li>[in] verify_key_ref Reference to verification key.</li>
<li>[in] decrypt_key_ref Reference to decryption key.</li>
<li>[in] verify_algorithm Verification algorithm.</li>
<li>[in] decrypt_algorithm Decryption algorithm/mode.</li>
<li>[out] conduit_ref Reference to resulting conduit.</li>
</ul>

<p> </p>
<p id="rfc.section.10.1.1.p.14">Returns: </p>

<ul class="empty"><li>S_OK, S_GENERAL_ERROR, S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION, S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE, S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT, S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_USED_INVALID, S_KEY_USED_EXPIRED, S_KEY_INVALID, S_KEY_EXPIRED, S_REMOTE_PORT_INVALID, S_REMOTE_PORT_IN_USE, S_ALGO_INVALID, S_ALGO_INCOMPATIBLE, S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR, S_CHANNEL_MAX</li></ul>

<p> </p>
<div id="#rfc.figure.132"></div>
<p>Method CICM::Decrypt::ChannelManager::create_decrypt_with_verify_conduit()</p>
<pre>CICM::Status create_decrypt_with_verify_conduit(
	in  CICM::RemotePort remote_port,
	in  CICM::AsymKey verify_key_ref,
	in  CICM::SymKey decrypt_key_ref,
	in  CICM::AsymSigAlgorithmId verify_algorithm,
	in  CICM::SymEncrAlgorithmId decrypt_algorithm,
	out CICM::Decrypt::WithVerifyConduit conduit_ref
);</pre>
<p>Create channel to verify and decrypt a stream of data.</p>
<p id="rfc.section.10.1.1.p.15">Parameters: </p>

<ul class="empty">
<li>[in] remote_port Remote port.</li>
<li>[in] verify_key_ref Reference to verification key.</li>
<li>[in] decrypt_key_ref Reference to decryption key.</li>
<li>[in] verify_algorithm Verification algorithm.</li>
<li>[in] decrypt_algorithm Decryption algorithm/mode.</li>
<li>[out] conduit_ref Reference to resulting conduit.</li>
</ul>

<p> </p>
<p id="rfc.section.10.1.1.p.16">Returns: </p>

<ul class="empty"><li>S_OK, S_GENERAL_ERROR, S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION, S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE, S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT, S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_USED_INVALID, S_KEY_USED_EXPIRED, S_KEY_USED_WRAPPED, S_KEY_USED_CONTEXT, S_KEY_INVALID, S_KEY_EXPIRED, S_REMOTE_PORT_INVALID, S_REMOTE_PORT_IN_USE, S_ALGO_INVALID, S_ALGO_INCOMPATIBLE, S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR, S_CHANNEL_MAX</li></ul>

<p> </p>
<div id="#rfc.figure.133"></div>
<p>Method CICM::Decrypt::ChannelManager::create_key_unwrap_conduit()</p>
<pre>CICM::Status create_key_unwrap_conduit(
	in  CICM::RemotePort remote_port,
	in  CICM::SymKey kek_ref,
	in  CICM::KeyWrapAlgorithmId algorithm,
	out CICM::Decrypt::KeyUnwrapConduit conduit_ref
);</pre>
<p>Create channel to unwrap a key. This type of channel may be used to bulk unwrap key material originating at a key infrastructure component or from a peer cryptographic module. Note that, to unwrap individual keys already in the module, use CICM::Symkey::unwrap or CICM::Asymkey::unwrap.</p>
<p id="rfc.section.10.1.1.p.17">Parameters: </p>

<ul class="empty">
<li>[in] remote_port Remote port.</li>
<li>[in] kek_ref Reference to key encryption key.</li>
<li>[in] algorithm Key unwrapping algorithm/mode.</li>
<li>[out] conduit_ref Reference to resulting conduit.</li>
</ul>

<p> </p>
<p id="rfc.section.10.1.1.p.18">Returns: </p>

<ul class="empty"><li>S_OK, S_GENERAL_ERROR, S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION, S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE, S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT, S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_USED_INVALID, S_KEY_USED_EXPIRED, S_KEY_INVALID, S_KEY_EXPIRED, S_REMOTE_PORT_INVALID, S_REMOTE_PORT_IN_USE, S_ALGO_INVALID, S_ALGO_INCOMPATIBLE, S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR, S_CHANNEL_MAX</li></ul>

<p> </p>
<div id="#rfc.figure.134"></div>
<p>Method CICM::Decrypt::ChannelManager::create_decrypt_controller()</p>
<pre>CICM::Status create_decrypt_controller(
	in  CICM::LocalPort local_port,
	in  CICM::RemotePort remote_port,
	in  CICM::SymKey key_ref,
	in  CICM::SymEncrAlgorithmId algorithm,
	out CICM::Decrypt::Controller controller_ref
);</pre>
<p>Create controller to configure and control an decryption channel.</p>
<p id="rfc.section.10.1.1.p.19">Remarks: </p>

<ul class="empty"><li>In some cases, hosts may depend upon separate processes to control and use a channel. This method returns the channel controller and must be called before the corresponding stream is retrieved.</li></ul>

<p> </p>
<p id="rfc.section.10.1.1.p.20">Parameters: </p>

<ul class="empty">
<li>[in] local_port Local port.</li>
<li>[in] remote_port Remote port.</li>
<li>[in] key_ref Reference to decryption key.</li>
<li>[in] algorithm Decryption algorithm/mode.</li>
<li>[out] controller_ref Reference to resulting controller.</li>
</ul>

<p> </p>
<p id="rfc.section.10.1.1.p.21">Returns: </p>

<ul class="empty"><li>S_OK, S_GENERAL_ERROR, S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION, S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE, S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT, S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_USED_INVALID, S_KEY_USED_EXPIRED, S_KEY_INVALID, S_KEY_EXPIRED, S_LOCAL_PORT_INVALID, S_LOCAL_PORT_INCOMPATIBLE, S_LOCAL_PORT_IN_USE, S_REMOTE_PORT_INVALID, S_REMOTE_PORT_IN_USE, S_ALGO_INVALID, S_ALGO_INCOMPATIBLE, S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR, S_CHANNEL_MAX</li></ul>

<p> </p>
<div id="#rfc.figure.135"></div>
<p>Method CICM::Decrypt::ChannelManager::get_decrypt_stream()</p>
<pre>CICM::Status get_decrypt_stream(
	in  CICM::LocalPort local_port,
	out CICM::Decrypt::Stream stream_ref
);</pre>
<p>Create stream associated with previously created controller to receive transformed data.</p>
<p id="rfc.section.10.1.1.p.22">Parameters: </p>

<ul class="empty">
<li>[in] local_port Local port.</li>
<li>[out] stream_ref Reference to resulting stream.</li>
</ul>

<p> </p>
<p id="rfc.section.10.1.1.p.23">Returns: </p>

<ul class="empty"><li>S_OK, S_GENERAL_ERROR, S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION, S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE, S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT, S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_INVALID, S_KEY_EXPIRED, S_LOCAL_PORT_INVALID, S_LOCAL_PORT_INCOMPATIBLE, S_LOCAL_PORT_IN_USE, S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR, S_CHANNEL_PEER_RESET, S_CHANNEL_NOT_FOUND</li></ul>

<p> </p>
<h1 id="rfc.section.10.2">
<a href="#rfc.section.10.2">10.2.</a> Interface CICM::Decrypt::Stream</h1>
<div id="#rfc.figure.136"></div>
<p>Interface CICM::Decrypt::Stream</p>
<pre>interface Stream : CICM::ReadStream {</pre>
<p>CICM::Decrypt::Stream supports decryption operations between two independent security domains. The resulting stream is capable of accepting transformed data, but not managing the channel. It is created by calling CICM::ChannelManager::get_decrypt_stream.</p>
<h1 id="rfc.section.10.2.1">
<a href="#rfc.section.10.2.1">10.2.1.</a> CICM::Decrypt::Stream Inheritance</h1>
<p id="rfc.section.10.2.1.p.1">CICM::Decrypt::Stream inherits from: CICM::ReadStream.</p>
<h1 id="rfc.section.10.2.2">
<a href="#rfc.section.10.2.2">10.2.2.</a> CICM::Decrypt::Stream Methods</h1>
<div id="#rfc.figure.137"></div>
<p>Method CICM::Decrypt::Stream::decrypt()</p>
<pre>CICM::Status decrypt(
	out CICM::Buffer buffer
);</pre>
<p>Read plaintext data off of decrypt channel stream. The method blocks until data becomes available.</p>
<p id="rfc.section.10.2.2.p.1">Parameters: </p>

<ul class="empty"><li>[out] buffer Plaintext resulting from decryption operation.</li></ul>

<p> </p>
<p id="rfc.section.10.2.2.p.2">Returns: </p>

<ul class="empty"><li>S_OK, S_GENERAL_ERROR, S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION, S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE, S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT, S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_INVALID, S_KEY_EXPIRED, S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR, S_CHANNEL_PEER_RESET, S_CHANNEL_IO_ERROR, S_CHANNEL_BUFFER_LEN, S_INTEGRITY</li></ul>

<p> </p>
<div id="#rfc.figure.138"></div>
<p>Method CICM::Decrypt::Stream::decrypt_non_blocking()</p>
<pre>CICM::Status decrypt_non_blocking(
	out CICM::Buffer buffer,
	in  CICM::TransId transaction_id
);</pre>
<p>Registers a buffer into which plaintext resulting from the decryption operation will be copied, and then immediately returns control to the caller. The size of the allocated buffer and length of the resulting plaintext is encapsulated in the buffer parameter.  The caller may use the CICM::Decrypt::Stream::decrypt_poll method to proactively poll the channel to determine the status of the operation. The caller is responsible for maintaining any necessary metadata associated with the transaction_id parameter. Memory responsibilities and calling conventions shall follow the appropriate IDL language mapping conventions.</p>
<p id="rfc.section.10.2.2.p.3">Parameters: </p>

<ul class="empty">
<li>[out] buffer Plaintext resulting from decryption operation.</li>
<li>[in] transaction_id Unique transaction id that will be used by the CICM::Decrypt::Stream::decrypt_poll method to determine to which buffer the poll status applies.</li>
</ul>

<p> </p>
<p id="rfc.section.10.2.2.p.4">Returns: </p>

<ul class="empty"><li>S_OK, S_GENERAL_ERROR, S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION, S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE, S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT, S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_INVALID, S_KEY_EXPIRED, S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR, S_CHANNEL_PEER_RESET, S_CHANNEL_IO_ERROR, S_CHANNEL_BUFFER_LEN, S_INTEGRITY</li></ul>

<p> </p>
<div id="#rfc.figure.139"></div>
<p>Method CICM::Decrypt::Stream::decrypt_poll()</p>
<pre>CICM::Status decrypt_poll(
	in  CICM::TransId transaction_id,
	out CICM::ReadStream::ReadStatus status
);</pre>
<p>Returns the status of the non-blocking decryption operation specified by the transaction_id parameter. Upon completion of the operation, the caller must use the metadata associated with the transaction_id parameter to determine which buffer has been populated. Memory responsibilities and calling conventions shall follow the appropriate IDL language mapping conventions.</p>
<p id="rfc.section.10.2.2.p.5">Parameters: </p>

<ul class="empty">
<li>[in] transaction_id Unique transaction id previously specified to the CICM::Decrypt::Stream::decrypt_non_blocking method that allows the poll operation to determine to which buffer the poll status applies.</li>
<li>[out] status Status of the non-blocking operation corresponding to the transaction_id parameter.</li>
</ul>

<p> </p>
<p id="rfc.section.10.2.2.p.6">Returns: </p>

<ul class="empty"><li>S_OK, S_GENERAL_ERROR, S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION, S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE, S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT, S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_INVALID, S_KEY_EXPIRED, S_KEY_WRAPPED, S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR, S_CHANNEL_PEER_RESET, S_CHANNEL_IO_ERROR</li></ul>

<p> </p>
<h1 id="rfc.section.10.3">
<a href="#rfc.section.10.3">10.3.</a> Interface CICM::Decrypt::KeyUnwrapStream</h1>
<div id="#rfc.figure.140"></div>
<p>Interface  CICM::Decrypt::KeyUnwrapStream</p>
<pre>interface KeyUnwrapStream : CICM::Stream {</pre>
<p>CICM::Decrypt::KeyUnwrapStream is an abstraction that allows unwrapped key material received from another domain to be retrieved.</p>
<h1 id="rfc.section.10.3.1">
<a href="#rfc.section.10.3.1">10.3.1.</a> CICM::Decrypt::KeyUnwrapStream Inheritance</h1>
<p id="rfc.section.10.3.1.p.1">CICM::Decrypt::KeyUnwrapStream inherits from: CICM::Stream.</p>
<h1 id="rfc.section.10.3.2">
<a href="#rfc.section.10.3.2">10.3.2.</a> CICM::Decrypt::KeyUnwrapStream Methods</h1>
<div id="#rfc.figure.141"></div>
<p>Method CICM::Decrypt::KeyUnwrapStream::unwrap_sym_key()</p>
<pre>CICM::Status unwrap_sym_key(
	out CICM::SymKey key_ref
);</pre>
<p>Read one unwrapped symmetric key off of channel stream and return a reference to the key. The method blocks until a key becomes available.</p>
<p id="rfc.section.10.3.2.p.1">Parameters: </p>

<ul class="empty"><li>[in] key_ref Reference to key encryption key.</li></ul>

<p> </p>
<p id="rfc.section.10.3.2.p.2">Returns: </p>

<ul class="empty"><li>S_OK, S_GENERAL_ERROR, S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION, S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE, S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT, S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_INVALID, S_KEY_EXPIRED, S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR, S_CHANNEL_PEER_RESET, S_CHANNEL_IO_ERROR</li></ul>

<p> </p>
<div id="#rfc.figure.142"></div>
<p>Method CICM::Decrypt::KeyUnwrapStream::unwrap_asym_key()</p>
<pre>CICM::Status unwrap_asym_key(
	out CICM::AsymKey key_ref
);</pre>
<p>Read one unwrapped asymmetric key off of channel stream and return a reference to the key. The method blocks until a key becomes available.</p>
<p id="rfc.section.10.3.2.p.3">Parameters: </p>

<ul class="empty"><li>[in] key_ref Reference to key encryption key.</li></ul>

<p> </p>
<p id="rfc.section.10.3.2.p.4">Returns: </p>

<ul class="empty"><li>S_OK, S_GENERAL_ERROR, S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION, S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE, S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT, S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_INVALID, S_KEY_EXPIRED, S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR, S_CHANNEL_PEER_RESET, S_CHANNEL_IO_ERROR</li></ul>

<p> </p>
<h1 id="rfc.section.10.4">
<a href="#rfc.section.10.4">10.4.</a> Interface CICM::Decrypt::Controller</h1>
<div id="#rfc.figure.143"></div>
<p>Interface CICM::Decrypt::Controller</p>
<pre>interface Controller :
	CICM::MultiDomainController,
	CICM::SymKeyController,
	CICM::SetVectorController,
	CICM::ResyncController {</pre>
<p>CICM::Decrypt::Controller supports decryption operations between two independent security domains. The resulting controller is capable of managing the channel, but not accepting transformed data. It is created by calling CICM::ChannelManager::create_decrypt_controller.</p>
<h1 id="rfc.section.10.4.1">
<a href="#rfc.section.10.4.1">10.4.1.</a> CICM::Decrypt::Controller Inheritance</h1>
<p id="rfc.section.10.4.1.p.1">CICM::Decrypt::Controller inherits from: CICM::MultiDomainController, CICM::SymKeyController, CICM::SetVectorController and CICM::ResyncController.</p>
<h1 id="rfc.section.10.5">
<a href="#rfc.section.10.5">10.5.</a> Interface CICM::Decrypt::NegotiatedController</h1>
<div id="#rfc.figure.144"></div>
<p>Interface  CICM::Decrypt::NegotiatedController</p>
<pre>interface NegotiatedController :
	CICM::NegotiatedController,
	CICM::SetVectorController,
	CICM::ResyncController {</pre>
<p>CICM::Decrypt::NegotiatedController is the negotiated version of CICM::Decrypt::Controller. It is the result of a successful negotiation by CICM::Decrypt::ControllerNegotiator.</p>
<h1 id="rfc.section.10.5.1">
<a href="#rfc.section.10.5.1">10.5.1.</a> CICM::Decrypt::NegotiatedController Inheritance</h1>
<p id="rfc.section.10.5.1.p.1">CICM::Decrypt::NegotiatedController inherits from: CICM::NegotiatedController, CICM::SetVectorController and CICM::ResyncController.</p>
<h1 id="rfc.section.10.6">
<a href="#rfc.section.10.6">10.6.</a> Interface CICM::Decrypt::Conduit</h1>
<div id="#rfc.figure.145"></div>
<p>Interface CICM::Decrypt::Conduit</p>
<pre>interface Conduit :
	CICM::Conduit,
	CICM::Decrypt::Controller,
	CICM::Decrypt::Stream {</pre>
<p>CICM::Decrypt::Conduit supports decryption operations between two independent security domains. The resulting conduit is capable of both managing the channel and accepting transformed data. It is created by calling CICM::ChannelManager::create_decrypt_conduit.</p>
<h1 id="rfc.section.10.6.1">
<a href="#rfc.section.10.6.1">10.6.1.</a> CICM::Decrypt::Conduit Inheritance</h1>
<p id="rfc.section.10.6.1.p.1">CICM::Decrypt::Conduit inherits from: CICM::Conduit, CICM::Decrypt::Controller and CICM::Decrypt::Stream.</p>
<h1 id="rfc.section.10.7">
<a href="#rfc.section.10.7">10.7.</a> Interface CICM::Decrypt::NegotiatedConduit</h1>
<div id="#rfc.figure.146"></div>
<p>Interface  CICM::Decrypt::NegotiatedConduit</p>
<pre>interface NegotiatedConduit :
	CICM::Conduit,
	CICM::Decrypt::NegotiatedController,
	CICM::Decrypt::Stream {</pre>
<p>CICM::Decrypt::NegotiatedConduit is the negotiated version of CICM::Decrypt::Conduit. It is the result of a successful negotiation by CICM::Decrypt::Negotiator.</p>
<h1 id="rfc.section.10.7.1">
<a href="#rfc.section.10.7.1">10.7.1.</a> CICM::Decrypt::NegotiatedConduit Inheritance</h1>
<p id="rfc.section.10.7.1.p.1">CICM::Decrypt::NegotiatedConduit inherits from: CICM::Conduit, CICM::Decrypt::NegotiatedController and CICM::Decrypt::Stream.</p>
<h1 id="rfc.section.10.8">
<a href="#rfc.section.10.8">10.8.</a> Interface CICM::Decrypt::WithMACConduit</h1>
<div id="#rfc.figure.147"></div>
<p>Interface  CICM::Decrypt::WithMACConduit</p>
<pre>interface WithMACConduit :
	CICM::AbstractMACVerifyConduit,
	CICM::Decrypt::Conduit {</pre>
<p>CICM::Decrypt::WithMACConduit supports decryption operations between two independent security domains with the receipt of an indication as to whether MAC verification succeeded or failed in the initiating domain. The resulting conduit is capable of both managing the channel and accepting data for transformation. It is created by calling CICM::ChannelManager::create_decrypt_with_mac_conduit.</p>
<h1 id="rfc.section.10.8.1">
<a href="#rfc.section.10.8.1">10.8.1.</a> CICM::Decrypt::WithMACConduit Inheritance</h1>
<p id="rfc.section.10.8.1.p.1">CICM::Decrypt::WithMACConduit inherits from: CICM::AbstractMACVerifyConduit and CICM::Decrypt::Conduit.</p>
<h1 id="rfc.section.10.9">
<a href="#rfc.section.10.9">10.9.</a> Interface CICM::Decrypt::WithMACNegotiatedConduit</h1>
<div id="#rfc.figure.148"></div>
<p>Interface  CICM::Decrypt::WithMACNegotiatedConduit</p>
<pre>interface WithMACNegotiatedConduit :
	CICM::AbstractMACVerifyConduit,
	CICM::Decrypt::NegotiatedConduit {</pre>
<p>CICM::Decrypt::WithMACNegotiatedConduit is the negotiated version of CICM::Decrypt::WithMACConduit. It is the result of a successful negotiation by CICM::Decrypt::WithMACNegotiator.</p>
<h1 id="rfc.section.10.9.1">
<a href="#rfc.section.10.9.1">10.9.1.</a> CICM::Decrypt::WithMACNegotiatedConduit Inheritance</h1>
<p id="rfc.section.10.9.1.p.1">CICM::Decrypt::WithMACNegotiatedConduit inherits from: CICM::AbstractMACVerifyConduit and CICM::Decrypt::NegotiatedConduit.</p>
<h1 id="rfc.section.10.10">
<a href="#rfc.section.10.10">10.10.</a> Interface CICM::Decrypt::WithVerifyConduit</h1>
<div id="#rfc.figure.149"></div>
<p>Interface  CICM::Decrypt::WithVerifyConduit</p>
<pre>interface WithVerifyConduit :
	CICM::AbstractSigVerifyConduit,
	CICM::Decrypt::Conduit {</pre>
<p>CICM::Decrypt::WithVerifyConduit supports decryption operations between two independent security domains with the receipt of an indication as to whether signature verification succeeded or failed in the initiating domain. The resulting conduit is capable of both managing the channel and accepting transformed data. It is created by calling CICM::ChannelManager::create_decrypt_with_verify_conduit.</p>
<h1 id="rfc.section.10.10.1">
<a href="#rfc.section.10.10.1">10.10.1.</a> CICM::Decrypt::WithVerifyConduit Inheritance</h1>
<p id="rfc.section.10.10.1.p.1">CICM::Decrypt::WithVerifyConduit inherits from: CICM::AbstractSigVerifyConduit and CICM::Decrypt::Conduit.</p>
<h1 id="rfc.section.10.11">
<a href="#rfc.section.10.11">10.11.</a> Interface CICM::Decrypt::WithVerifyNegotiatedConduit</h1>
<div id="#rfc.figure.150"></div>
<p>Interface  CICM::Decrypt::WithVerifyNegotiatedConduit</p>
<pre>interface WithVerifyNegotiatedConduit :
	CICM::AbstractSigVerifyConduit,
	CICM::Decrypt::NegotiatedConduit {</pre>
<p>CICM::Decrypt::WithVerifyNegotiatedConduit is the negotiated version of CICM::Decrypt::WithVerifyConduit. It is the result of a successful negotiation by CICM::Decrypt::WithVerifyNegotiator.</p>
<h1 id="rfc.section.10.11.1">
<a href="#rfc.section.10.11.1">10.11.1.</a> CICM::Decrypt::WithVerifyNegotiatedConduit Inheritance</h1>
<p id="rfc.section.10.11.1.p.1">CICM::Decrypt::WithVerifyNegotiatedConduit inherits from: CICM::AbstractSigVerifyConduit and CICM::Decrypt::NegotiatedConduit.</p>
<h1 id="rfc.section.10.12">
<a href="#rfc.section.10.12">10.12.</a> Interface CICM::Decrypt::KeyUnwrapConduit</h1>
<div id="#rfc.figure.151"></div>
<p>Interface  CICM::Decrypt::KeyUnwrapConduit</p>
<pre>interface KeyUnwrapConduit :
	CICM::Decrypt::Controller,
	CICM::Decrypt::KeyUnwrapStream {</pre>
<p>CICM::Decrypt::KeyUnwrapConduit supports key unwrapping operations between two independent security domains. The resulting conduit is capable of both managing the channel and accepting transformed keys. It is created by calling CICM::ChannelManager::create_key_unwrap_conduit.</p>
<h1 id="rfc.section.10.12.1">
<a href="#rfc.section.10.12.1">10.12.1.</a> CICM::Decrypt::KeyUnwrapConduit Inheritance</h1>
<p id="rfc.section.10.12.1.p.1">CICM::Decrypt::KeyUnwrapConduit inherits from: CICM::Decrypt::Controller and CICM::Decrypt::KeyUnwrapStream.</p>
<h1 id="rfc.section.10.13">
<a href="#rfc.section.10.13">10.13.</a> Interface CICM::Decrypt::Negotiator</h1>
<div id="#rfc.figure.152"></div>
<p>Interface CICM::Decrypt::Negotiator</p>
<pre>interface Negotiator : CICM::Negotiator {</pre>
<p>CICM::Decrypt::Negotiator initiates a negotiation to establish a shared key with a remote entity that is used to support encryption operations between two independent security domains. The result of a successful negotiation is a CICM::Decrypt::NegotiatedConduit which is capable of both managing the channel and accepting data for transformation.  CICM::Decrypt::Negotiator is created by calling CICM::ChannelManager::negotiate_decrypt_conduit.</p>
<h1 id="rfc.section.10.13.1">
<a href="#rfc.section.10.13.1">10.13.1.</a> CICM::Decrypt::Negotiator Inheritance</h1>
<p id="rfc.section.10.13.1.p.1">CICM::Decrypt::Negotiator inherits from: CICM::Negotiator.</p>
<h1 id="rfc.section.10.13.2">
<a href="#rfc.section.10.13.2">10.13.2.</a> CICM::Decrypt::Negotiator Methods</h1>
<div id="#rfc.figure.153"></div>
<p>Method CICM::Decrypt::Negotiator::complete()</p>
<pre>CICM::Status complete(
	out CICM::Decrypt::NegotiatedConduit conduit_ref
);</pre>
<p>Complete negotiation and retrieve a negotiated decrypt conduit.</p>
<p id="rfc.section.10.13.2.p.1">Parameters: </p>

<ul class="empty"><li>[out] conduit_ref Reference to resulting conduit.</li></ul>

<p> </p>
<p id="rfc.section.10.13.2.p.2">Returns: </p>

<ul class="empty"><li>S_OK, S_GENERAL_ERROR, S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION, S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE, S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT, S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT, S_NEGOTIATION_ABORTED, S_NEGOTIATION_FAILURE, S_NEGOTIATION_NOT_IN_PROGRESS, S_NEGOTIATION_TIMEOUT, S_CERT_LOCAL_INVALID, S_CERT_LOCAL_EXPIRED, S_CERT_REMOTE_INVALID, S_CERT_REMOTE_EXPIRED, S_CERT_REMOTE_PATH, S_CHANNEL_ERROR, S_CHANNEL_PEER_RESET</li></ul>

<p> </p>
<h1 id="rfc.section.10.14">
<a href="#rfc.section.10.14">10.14.</a> Interface CICM::Decrypt::ControllerNegotiator</h1>
<div id="#rfc.figure.154"></div>
<p>Interface  CICM::Decrypt::ControllerNegotiator</p>
<pre>interface ControllerNegotiator : CICM::Negotiator {</pre>
<p>CICM::Decrypt::ControllerNegotiator initiates a negotiation to establish a shared key with a remote entity that is used to support decryption operations between two independent security domains. The result of a successful negotiation is a CICM::Decrypt::NegotiatedController which is capable of managing the channel, but not accepting data for transformation.  CICM::Decrypt::ControllerNegotiator is created by calling CICM::ChannelManager::negotiate_decrypt_controller.</p>
<h1 id="rfc.section.10.14.1">
<a href="#rfc.section.10.14.1">10.14.1.</a> CICM::Decrypt::ControllerNegotiator Inheritance</h1>
<p id="rfc.section.10.14.1.p.1">CICM::Decrypt::ControllerNegotiator inherits from: CICM::Negotiator.</p>
<h1 id="rfc.section.10.14.2">
<a href="#rfc.section.10.14.2">10.14.2.</a> CICM::Decrypt::ControllerNegotiator Methods</h1>
<div id="#rfc.figure.155"></div>
<p>Method CICM::Decrypt::ControllerNegotiator::complete()</p>
<pre>CICM::Status complete(
	out CICM::Decrypt::NegotiatedController controller_ref
);</pre>
<p>Complete negotiation and retrieve a negotiated control-only decrypt channel.</p>
<p id="rfc.section.10.14.2.p.1">Parameters: </p>

<ul class="empty"><li>[out] controller_ref Reference to resulting controller.</li></ul>

<p> </p>
<p id="rfc.section.10.14.2.p.2">Returns: </p>

<ul class="empty"><li>S_OK, S_GENERAL_ERROR, S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION, S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE, S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT, S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT, S_NEGOTIATION_ABORTED, S_NEGOTIATION_FAILURE, S_NEGOTIATION_NOT_IN_PROGRESS, S_NEGOTIATION_TIMEOUT, S_CERT_LOCAL_INVALID, S_CERT_LOCAL_EXPIRED, S_CERT_REMOTE_INVALID, S_CERT_REMOTE_EXPIRED, S_CERT_REMOTE_PATH, S_CHANNEL_ERROR, S_CHANNEL_PEER_RESET</li></ul>

<p> </p>
<h1 id="rfc.section.10.15">
<a href="#rfc.section.10.15">10.15.</a> Interface CICM::Decrypt::WithMACNegotiator</h1>
<div id="#rfc.figure.156"></div>
<p>Interface  CICM::Decrypt::WithMACNegotiator</p>
<pre>interface WithMACNegotiator : CICM::Negotiator {</pre>
<p>CICM::Decrypt::WithMACNegotiator initiates a negotiation to establish a shared key with a remote entity that is used to support decryption operations between two independent security domains.  Additionally, a message authentication code is received in the initiating domain. The result of a successful negotiation is a CICM::Decrypt::WithMACNegotiatedConduit which is capable of both managing the channel and accepting data for transformation.  CICM::Decrypt::WithMACNegotiator is created by calling CICM::ChannelManager::negotiate_decrypt_with_mac_conduit.</p>
<h1 id="rfc.section.10.15.1">
<a href="#rfc.section.10.15.1">10.15.1.</a> CICM::Decrypt::WithMACNegotiator Inheritance</h1>
<p id="rfc.section.10.15.1.p.1">CICM::Decrypt::WithMACNegotiator inherits from: CICM::Negotiator.</p>
<h1 id="rfc.section.10.15.2">
<a href="#rfc.section.10.15.2">10.15.2.</a> CICM::Decrypt::WithMACNegotiator Methods</h1>
<div id="#rfc.figure.157"></div>
<p>Method CICM::Decrypt::WithMACNegotiator::complete()</p>
<pre>CICM::Status complete(
	out CICM::Decrypt::WithMACNegotiatedConduit conduit_ref
);</pre>
<p>Complete negotiation and retrieve a negotiated MAC verify decrypt conduit.</p>
<p id="rfc.section.10.15.2.p.1">Parameters: </p>

<ul class="empty"><li>[out] conduit_ref Reference to resulting conduit.</li></ul>

<p> </p>
<p id="rfc.section.10.15.2.p.2">Returns: </p>

<ul class="empty"><li>S_OK, S_GENERAL_ERROR, S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION, S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE, S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT, S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT, S_NEGOTIATION_ABORTED, S_NEGOTIATION_FAILURE, S_NEGOTIATION_NOT_IN_PROGRESS, S_NEGOTIATION_TIMEOUT, S_CERT_LOCAL_INVALID, S_CERT_LOCAL_EXPIRED, S_CERT_REMOTE_INVALID, S_CERT_REMOTE_EXPIRED, S_CERT_REMOTE_PATH, S_CHANNEL_ERROR, S_CHANNEL_PEER_RESET</li></ul>

<p> </p>
<h1 id="rfc.section.10.16">
<a href="#rfc.section.10.16">10.16.</a> Interface CICM::Decrypt::WithVerifyNegotiator</h1>
<div id="#rfc.figure.158"></div>
<p>Interface  CICM::Decrypt::WithVerifyNegotiator</p>
<pre>interface WithVerifyNegotiator : CICM::Negotiator {</pre>
<p>CICM::Decrypt::WithVerifyNegotiator initiates a negotiation to establish a shared key with a remote entity that is used to support decryption operations between two independent security domains. Additionally, an indication as to whether verification succeeded or failed is received in the initiating domain. The result of a successful negotiation is a CICM::Decrypt::WithVerifyNegotiatedConduit which is capable of both managing the channel and accepting data for transformation.  CICM::Decrypt::WithVerifyNegotiator is created by calling CICM::ChannelManager::negotiate_decrypt_with_verify_conduit.</p>
<h1 id="rfc.section.10.16.1">
<a href="#rfc.section.10.16.1">10.16.1.</a> CICM::Decrypt::WithVerifyNegotiator Inheritance</h1>
<p id="rfc.section.10.16.1.p.1">CICM::Decrypt::WithVerifyNegotiator inherits from: CICM::Negotiator.</p>
<h1 id="rfc.section.10.16.2">
<a href="#rfc.section.10.16.2">10.16.2.</a> CICM::Decrypt::WithVerifyNegotiator Methods</h1>
<div id="#rfc.figure.159"></div>
<p>Method CICM::Decrypt::WithVerifyNegotiator::complete()</p>
<pre>CICM::Status complete(
	out CICM::Decrypt::WithVerifyNegotiatedConduit conduit_ref
);</pre>
<p>Complete negotiation and retrieve a negotiated verify and decrypt conduit.</p>
<p id="rfc.section.10.16.2.p.1">Parameters: </p>

<ul class="empty"><li>[out] conduit_ref Reference to resulting conduit.</li></ul>

<p> </p>
<p id="rfc.section.10.16.2.p.2">Returns: </p>

<ul class="empty"><li>S_OK, S_GENERAL_ERROR, S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION, S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE, S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT, S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT, S_NEGOTIATION_ABORTED, S_NEGOTIATION_FAILURE, S_NEGOTIATION_NOT_IN_PROGRESS, S_NEGOTIATION_TIMEOUT, S_CERT_LOCAL_INVALID, S_CERT_LOCAL_EXPIRED, S_CERT_REMOTE_INVALID, S_CERT_REMOTE_EXPIRED, S_CERT_REMOTE_PATH, S_CHANNEL_ERROR, S_CHANNEL_PEER_RESET</li></ul>

<p> </p>
<h1 id="rfc.section.11">
<a href="#rfc.section.11">11.</a> <a href="#sec-duplex" id="sec-duplex">Duplex</a>
</h1>
<div id="#rfc.figure.160"></div>
<p>Namespace CICM::Duplex</p>
<pre>module Duplex {</pre>
<p>The CICM::Duplex namespace contains interfaces that support encryption/decryption operations between two independent security domains.</p>
<h1 id="rfc.section.11.1">
<a href="#rfc.section.11.1">11.1.</a> Interface CICM::Duplex::ChannelManager</h1>
<div id="#rfc.figure.161"></div>
<p>Interface  CICM::Duplex::ChannelManager</p>
<pre>interface ChannelManager {</pre>
<p>CICM::Duplex::ChannelManager is an abstraction inherited by CICM::ChannelManager that supports the creation of encryption/decryption negotiators, conduits, controllers, and streams. See CICM::ChannelManager for additional information.</p>
<h1 id="rfc.section.11.1.1">
<a href="#rfc.section.11.1.1">11.1.1.</a> CICM::Duplex::ChannelManager Methods</h1>
<div id="#rfc.figure.162"></div>
<p>Method CICM::Duplex::ChannelManager::negotiate_duplex_conduit()</p>
<pre>CICM::Status negotiate_duplex_conduit(
	in  CICM::RemotePort remote_port,
	in  CICM::ProtocolId protocol,
	in  CICM::AsymKey key_ref,
	out CICM::Duplex::Negotiator negotiator_ref
);</pre>
<p>Initiate a negotiation to establish a shared key with a peer, resulting in a conduit that results will encrypt/decrypt data.</p>
<p id="rfc.section.11.1.1.p.1">Parameters: </p>

<ul class="empty">
<li>[in] remote_port Remote port.</li>
<li>[in] protocol Protocol identifier.</li>
<li>[in] key_ref Reference to negotiation key.</li>
<li>[out] negotiator_ref Reference to resulting negotiator.</li>
</ul>

<p> </p>
<p id="rfc.section.11.1.1.p.2">Returns: </p>

<ul class="empty"><li>S_OK, S_GENERAL_ERROR, S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION, S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE, S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT, S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_USED_INVALID, S_KEY_USED_EXPIRED, S_KEY_USED_WRAPPED, S_KEY_USED_CONTEXT, S_KEY_USED_COMPONENT_NOT_AVAIL, S_KEY_INVALID, S_KEY_EXPIRED, S_REMOTE_PORT_INVALID, S_REMOTE_PORT_IN_USE, S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT, S_NEGOTIATION_ABORTED, S_NEGOTIATION_FAILURE, S_NEGOTIATION_IN_PROGRESS, S_NEGOTIATION_TIMEOUT, S_CERT_LOCAL_INVALID, S_CERT_LOCAL_EXPIRED, S_CERT_REMOTE_INVALID, S_CERT_REMOTE_EXPIRED, S_CERT_REMOTE_PATH, S_PROTO_INVALID, S_PROTO_INCOMPATIBLE, S_PROTO_UNDETERMINED, S_CHANNEL_ERROR, S_CHANNEL_MAX</li></ul>

<p> </p>
<div id="#rfc.figure.163"></div>
<p>Method CICM::Duplex::ChannelManager::negotiate_duplex_controller()</p>
<pre>CICM::Status negotiate_duplex_controller(
	in  CICM::LocalPort local_port,
	in  CICM::RemotePort remote_port,
	in  CICM::ProtocolId protocol,
	in  CICM::AsymKey key_ref,
	out CICM::Duplex::ControllerNegotiator negotiator_ref
);</pre>
<p>Initiate a negotiation to establish a shared key with a peer, resulting in a controller to manage a duplex channel.</p>
<p id="rfc.section.11.1.1.p.3">Parameters: </p>

<ul class="empty">
<li>[in] local_port Local port.</li>
<li>[in] remote_port Remote port.</li>
<li>[in] protocol Protocol identifier.</li>
<li>[in] key_ref Reference to negotiation key.</li>
<li>[out] negotiator_ref Reference to resulting negotiator.</li>
</ul>

<p> </p>
<p id="rfc.section.11.1.1.p.4">Returns: </p>

<ul class="empty"><li>S_OK, S_GENERAL_ERROR, S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION, S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE, S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT, S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_USED_INVALID, S_KEY_USED_EXPIRED, S_KEY_USED_WRAPPED, S_KEY_USED_CONTEXT, S_KEY_USED_COMPONENT_NOT_AVAIL, S_KEY_INVALID, S_KEY_EXPIRED, S_LOCAL_PORT_INVALID, S_LOCAL_PORT_INCOMPATIBLE, S_LOCAL_PORT_IN_USE, S_REMOTE_PORT_INVALID, S_REMOTE_PORT_IN_USE, S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT, S_NEGOTIATION_ABORTED, S_NEGOTIATION_FAILURE, S_NEGOTIATION_IN_PROGRESS, S_NEGOTIATION_TIMEOUT, S_CERT_LOCAL_INVALID, S_CERT_LOCAL_EXPIRED, S_CERT_REMOTE_INVALID, S_CERT_REMOTE_EXPIRED, S_CERT_REMOTE_PATH, S_PROTO_INVALID, S_PROTO_INCOMPATIBLE, S_PROTO_UNDETERMINED, S_CHANNEL_ERROR, S_CHANNEL_MAX</li></ul>

<p> </p>
<div id="#rfc.figure.164"></div>
<p>Method CICM::Duplex::ChannelManager::create_duplex_conduit()</p>
<pre>CICM::Status create_duplex_conduit(
	in  CICM::RemotePort remote_port,
	in  CICM::SymKey key_ref,
	in  CICM::SymEncrAlgorithmId algorithm,
	out CICM::Duplex::Conduit conduit_ref
);</pre>
<p>Create duplex channel to encrypt/decrypt a stream of data.</p>
<p id="rfc.section.11.1.1.p.5">Parameters: </p>

<ul class="empty">
<li>[in] remote_port Remote port.</li>
<li>[in] key_ref Reference to decryption key.</li>
<li>[in] algorithm Encryption/decryption algorithm/mode.</li>
<li>[out] conduit_ref Reference to resulting conduit.</li>
</ul>

<p> </p>
<p id="rfc.section.11.1.1.p.6">Returns: </p>

<ul class="empty"><li>S_OK, S_GENERAL_ERROR, S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION, S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE, S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT, S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_USED_INVALID, S_KEY_USED_EXPIRED, S_KEY_USED_WRAPPED, S_KEY_USED_CONTEXT, S_KEY_INVALID, S_KEY_EXPIRED, S_REMOTE_PORT_INVALID, S_REMOTE_PORT_IN_USE, S_ALGO_INVALID, S_ALGO_INCOMPATIBLE, S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR, S_CHANNEL_MAX</li></ul>

<p> </p>
<div id="#rfc.figure.165"></div>
<p>Method CICM::Duplex::ChannelManager::create_duplex_controller()</p>
<pre>CICM::Status create_duplex_controller(
	in  CICM::LocalPort local_port,
	in  CICM::RemotePort remote_port,
	in  CICM::SymKey key_ref,
	in  CICM::SymEncrAlgorithmId algorithm,
	out CICM::Duplex::Controller controller_ref
);</pre>
<p>Create controller to configure and control a duplex channel.</p>
<p id="rfc.section.11.1.1.p.7">Remarks: </p>

<ul class="empty"><li>In some cases, hosts may depend upon separate processes to control and use a channel. This method returns the channel controller and must be called before the corresponding stream is retrieved.</li></ul>

<p> </p>
<p id="rfc.section.11.1.1.p.8">Parameters: </p>

<ul class="empty">
<li>[in] local_port Local port.</li>
<li>[in] remote_port Remote port.</li>
<li>[in] key_ref Reference to negotiation key.</li>
<li>[in] algorithm Encryption/decryption algorithm/mode.</li>
<li>[out] controller_ref Reference to resulting controller.</li>
</ul>

<p> </p>
<p id="rfc.section.11.1.1.p.9">Returns: </p>

<ul class="empty"><li>S_OK, S_GENERAL_ERROR, S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION, S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE, S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT, S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_USED_INVALID, S_KEY_USED_EXPIRED, S_KEY_USED_WRAPPED, S_KEY_USED_CONTEXT, S_KEY_INVALID, S_KEY_EXPIRED, S_LOCAL_PORT_INVALID, S_LOCAL_PORT_INCOMPATIBLE, S_LOCAL_PORT_IN_USE, S_REMOTE_PORT_INVALID, S_REMOTE_PORT_IN_USE, S_ALGO_INVALID, S_ALGO_INCOMPATIBLE, S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR, S_CHANNEL_MAX</li></ul>

<p> </p>
<div id="#rfc.figure.166"></div>
<p>Method CICM::Duplex::ChannelManager::get_duplex_stream()</p>
<pre>CICM::Status get_duplex_stream(
	in  CICM::LocalPort local_port,
	out CICM::Duplex::Stream stream_ref
);</pre>
<p>Create stream associated with previously created controller to accept data for transformation.</p>
<p id="rfc.section.11.1.1.p.10">Parameters: </p>

<ul class="empty">
<li>[in] local_port Local port.</li>
<li>[out] stream_ref Reference to resulting stream.</li>
</ul>

<p> </p>
<p id="rfc.section.11.1.1.p.11">Returns: </p>

<ul class="empty"><li>S_OK, S_GENERAL_ERROR, S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION, S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE, S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT, S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_INVALID, S_KEY_EXPIRED, S_LOCAL_PORT_INVALID, S_LOCAL_PORT_INCOMPATIBLE, S_LOCAL_PORT_IN_USE, S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR, S_CHANNEL_PEER_RESET, S_CHANNEL_NOT_FOUND</li></ul>

<p> </p>
<h1 id="rfc.section.11.2">
<a href="#rfc.section.11.2">11.2.</a> Interface CICM::Duplex::Stream</h1>
<div id="#rfc.figure.167"></div>
<p>Interface CICM::Duplex::Stream</p>
<pre>interface Stream :
	CICM::Encrypt::Stream,
	CICM::Decrypt::Stream {</pre>
<p>CICM::Duplex::Stream supports encryption/decryption operations between two independent security domains. The resulting stream is capable of accepting data for transformation and receiving transformed data, but not managing the channel. It is created by calling CICM::ChannelManager::get_duplex_stream.</p>
<h1 id="rfc.section.11.2.1">
<a href="#rfc.section.11.2.1">11.2.1.</a> CICM::Duplex::Stream Inheritance</h1>
<p id="rfc.section.11.2.1.p.1">CICM::Duplex::Stream inherits from: CICM::Encrypt::Stream and CICM::Decrypt::Stream.</p>
<h1 id="rfc.section.11.3">
<a href="#rfc.section.11.3">11.3.</a> Interface CICM::Duplex::Controller</h1>
<div id="#rfc.figure.168"></div>
<p>Interface CICM::Duplex::Controller</p>
<pre>interface Controller :
	CICM::Encrypt::Controller,
	CICM::Decrypt::Controller {</pre>
<p>CICM::Duplex::Controller supports encryption/decryption operations between two independent security domains. The resulting controller is capable of managing the channel, but not accepting data for transformation and receiving transformed data. It is created by calling CICM::ChannelManager::create_duplex_controller.</p>
<h1 id="rfc.section.11.3.1">
<a href="#rfc.section.11.3.1">11.3.1.</a> CICM::Duplex::Controller Inheritance</h1>
<p id="rfc.section.11.3.1.p.1">CICM::Duplex::Controller inherits from: CICM::Encrypt::Controller and CICM::Decrypt::Controller.</p>
<h1 id="rfc.section.11.4">
<a href="#rfc.section.11.4">11.4.</a> Interface CICM::Duplex::NegotiatedController</h1>
<div id="#rfc.figure.169"></div>
<p>Interface  CICM::Duplex::NegotiatedController</p>
<pre>interface NegotiatedController :
	CICM::Encrypt::NegotiatedController,
	CICM::Decrypt::NegotiatedController {</pre>
<p>CICM::Duplex::NegotiatedController is the negotiated version of CICM::Duplex::Controller. It is the result of a successful negotiation by CICM::Duplex::ControllerNegotiator.</p>
<h1 id="rfc.section.11.4.1">
<a href="#rfc.section.11.4.1">11.4.1.</a> CICM::Duplex::NegotiatedController Inheritance</h1>
<p id="rfc.section.11.4.1.p.1">CICM::Duplex::NegotiatedController inherits from: CICM::Encrypt::NegotiatedController and CICM::Decrypt::NegotiatedController.</p>
<h1 id="rfc.section.11.5">
<a href="#rfc.section.11.5">11.5.</a> Interface CICM::Duplex::Conduit</h1>
<div id="#rfc.figure.170"></div>
<p>Interface CICM::Duplex::Conduit</p>
<pre>interface Conduit :
	CICM::Conduit,
	CICM::Duplex::Controller,
	CICM::Duplex::Stream {</pre>
<p>CICM::Duplex::Conduit supports encryption/decryption operations between two independent security domains. The resulting conduit is capable of both managing the channel and accepting data for transformation and receiving transformed data. It is created by calling CICM::ChannelManager::create_duplex_conduit.</p>
<h1 id="rfc.section.11.5.1">
<a href="#rfc.section.11.5.1">11.5.1.</a> CICM::Duplex::Conduit Inheritance</h1>
<p id="rfc.section.11.5.1.p.1">CICM::Duplex::Conduit inherits from: CICM::Conduit, CICM::Duplex::Controller and CICM::Duplex::Stream.</p>
<h1 id="rfc.section.11.6">
<a href="#rfc.section.11.6">11.6.</a> Interface CICM::Duplex::NegotiatedConduit</h1>
<div id="#rfc.figure.171"></div>
<p>Interface  CICM::Duplex::NegotiatedConduit</p>
<pre>interface NegotiatedConduit :
	CICM::Duplex::NegotiatedController,
	CICM::Duplex::Stream {</pre>
<p>CICM::Duplex::NegotiatedConduit is the negotiated version of CICM::Duplex::Conduit. It is the result of a successful negotiation by CICM::Duplex::Negotiator.</p>
<h1 id="rfc.section.11.6.1">
<a href="#rfc.section.11.6.1">11.6.1.</a> CICM::Duplex::NegotiatedConduit Inheritance</h1>
<p id="rfc.section.11.6.1.p.1">CICM::Duplex::NegotiatedConduit inherits from: CICM::Duplex::NegotiatedController and CICM::Duplex::Stream.</p>
<h1 id="rfc.section.11.7">
<a href="#rfc.section.11.7">11.7.</a> Interface CICM::Duplex::ControllerNegotiator</h1>
<div id="#rfc.figure.172"></div>
<p>Interface  CICM::Duplex::ControllerNegotiator</p>
<pre>interface ControllerNegotiator : CICM::Negotiator {</pre>
<p>CICM::Duplex::ControllerNegotiator initiates a negotiation to establish a shared key with a remote entity that is used to support encryption/decryption operations between two independent security domains. The result of a successful negotiation is a CICM::Duplex::NegotiatedController which is capable of managing the channel, but not accepting data for transformation.  CICM::Duplex::ControllerNegotiator is created by calling CICM::ChannelManager::negotiate_duplex_controller.</p>
<h1 id="rfc.section.11.7.1">
<a href="#rfc.section.11.7.1">11.7.1.</a> CICM::Duplex::ControllerNegotiator Inheritance</h1>
<p id="rfc.section.11.7.1.p.1">CICM::Duplex::ControllerNegotiator inherits from: CICM::Negotiator.</p>
<h1 id="rfc.section.11.7.2">
<a href="#rfc.section.11.7.2">11.7.2.</a> CICM::Duplex::ControllerNegotiator Methods</h1>
<div id="#rfc.figure.173"></div>
<p>Method CICM::Duplex::ControllerNegotiator::complete()</p>
<pre>CICM::Status complete(
	out CICM::Duplex::NegotiatedController controller_ref
);</pre>
<p>Complete negotiation and retrieve a negotiated control-only duplex conduit.</p>
<p id="rfc.section.11.7.2.p.1">Parameters: </p>

<ul class="empty"><li>[out] controller_ref Reference to resulting controller.</li></ul>

<p> </p>
<p id="rfc.section.11.7.2.p.2">Returns: </p>

<ul class="empty"><li>S_OK, S_GENERAL_ERROR, S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION, S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE, S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT, S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT, S_NEGOTIATION_ABORTED, S_NEGOTIATION_FAILURE, S_NEGOTIATION_NOT_IN_PROGRESS, S_NEGOTIATION_TIMEOUT, S_CERT_LOCAL_INVALID, S_CERT_LOCAL_EXPIRED, S_CERT_REMOTE_INVALID, S_CERT_REMOTE_EXPIRED, S_CERT_REMOTE_PATH, S_CHANNEL_ERROR, S_CHANNEL_PEER_RESET</li></ul>

<p> </p>
<h1 id="rfc.section.11.8">
<a href="#rfc.section.11.8">11.8.</a> Interface CICM::Duplex::Negotiator</h1>
<div id="#rfc.figure.174"></div>
<p>Interface CICM::Duplex::Negotiator</p>
<pre>interface Negotiator : CICM::Negotiator {</pre>
<p>CICM::Duplex::Negotiator initiates a negotiation to establish a shared key with a remote entity that is used to support encryption/decryption operations between two independent security domains. The result of a successful negotiation is a CICM::Duplex::NegotiatedConduit which is capable of both managing the channel and accepting data for transformation.  CICM::Duplex::Negotiator is created by calling CICM::ChannelManager::negotiate_duplex_conduit.</p>
<h1 id="rfc.section.11.8.1">
<a href="#rfc.section.11.8.1">11.8.1.</a> CICM::Duplex::Negotiator Inheritance</h1>
<p id="rfc.section.11.8.1.p.1">CICM::Duplex::Negotiator inherits from: CICM::Negotiator.</p>
<h1 id="rfc.section.11.8.2">
<a href="#rfc.section.11.8.2">11.8.2.</a> CICM::Duplex::Negotiator Methods</h1>
<div id="#rfc.figure.175"></div>
<p>Method CICM::Duplex::Negotiator::complete()</p>
<pre> CICM::Status complete(
	out CICM::Duplex::NegotiatedConduit conduit_ref
);</pre>
<p>Complete negotiation and retrieve a negotiated duplex channel.</p>
<p id="rfc.section.11.8.2.p.1">Parameters: </p>

<ul class="empty"><li>[out] conduit_ref Reference to resulting channel.</li></ul>

<p> </p>
<p id="rfc.section.11.8.2.p.2">Returns: </p>

<ul class="empty"><li>S_OK, S_GENERAL_ERROR, S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION, S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE, S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT, S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT, S_NEGOTIATION_ABORTED, S_NEGOTIATION_FAILURE, S_NEGOTIATION_NOT_IN_PROGRESS, S_NEGOTIATION_TIMEOUT, S_CERT_LOCAL_INVALID, S_CERT_LOCAL_EXPIRED, S_CERT_REMOTE_INVALID, S_CERT_REMOTE_EXPIRED, S_CERT_REMOTE_PATH, S_CHANNEL_ERROR, S_CHANNEL_PEER_RESET</li></ul>

<p> </p>
<h1 id="rfc.section.12">
<a href="#rfc.section.12">12.</a> <a href="#sec-bypass-write" id="sec-bypass-write">Bypass (Send)</a>
</h1>
<div id="#rfc.figure.176"></div>
<p>Namespace CICM::BypassWrite</p>
<pre>module BypassWrite {</pre>
<p>The CICM::BypassWrite namespace contains channels that support full bypass write operations between two independent security domains.</p>
<h1 id="rfc.section.12.1">
<a href="#rfc.section.12.1">12.1.</a> Interface CICM::BypassWrite::ChannelManager</h1>
<div id="#rfc.figure.177"></div>
<p>Interface  CICM::BypassWrite::ChannelManager</p>
<pre>interface ChannelManager {</pre>
<p>CICM::BypassWrite::ChannelManager is an abstraction inherited by CICM::ChannelManager that supports the creation of full bypass conduits, controllers, and streams for writing. See CICM::ChannelManager for additional information.</p>
<h1 id="rfc.section.12.1.1">
<a href="#rfc.section.12.1.1">12.1.1.</a> CICM::BypassWrite::ChannelManager Methods</h1>
<div id="#rfc.figure.178"></div>
<p>Method CICM::BypassWrite::ChannelManager::create_bypass_write_conduit()</p>
<pre>CICM::Status create_bypass_write_conduit(
	in  CICM::RemotePort remote_port,
	out CICM::BypassWrite::Conduit conduit_ref
);</pre>
<p>Creates a conduit to write bypass data.</p>
<p id="rfc.section.12.1.1.p.1">Parameters: </p>

<ul class="empty">
<li>[in] remote_port Remote port.</li>
<li>[out] conduit_ref Reference to resulting conduit.</li>
</ul>

<p> </p>
<p id="rfc.section.12.1.1.p.2">Returns: </p>

<ul class="empty"><li>S_OK, S_GENERAL_ERROR, S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION, S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE, S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT, S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_INVALID, S_KEY_EXPIRED, S_REMOTE_PORT_INVALID, S_REMOTE_PORT_IN_USE, S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR, S_CHANNEL_MAX</li></ul>

<p> </p>
<div id="#rfc.figure.179"></div>
<p>Method CICM::BypassWrite::ChannelManager::create_bypass_write_controller()</p>
<pre>CICM::Status create_bypass_write_controller(
	in  CICM::LocalPort local_port,
	in  CICM::RemotePort remote_port,
	out CICM::BypassWrite::Controller controller_ref
);</pre>
<p>Returns the controller of a channel that writes bypass data.</p>
<p id="rfc.section.12.1.1.p.3">Remarks: </p>

<ul class="empty"><li>In some cases, hosts may depend upon separate processes to control and use a channel. This method returns the channel controller and must be called before the corresponding stream is retrieved.</li></ul>

<p> </p>
<p id="rfc.section.12.1.1.p.4">See also: </p>

<ul class="empty"><li>CICM::BypassWrite::ChannelManager::get_bypass_write_stream for the method that returns the channel stream.</li></ul>

<p> </p>
<p id="rfc.section.12.1.1.p.5">Parameters: </p>

<ul class="empty">
<li>[in] local_port Local port.</li>
<li>[in] remote_port Remote port.</li>
<li>[out] controller_ref Reference to resulting controller.</li>
</ul>

<p> </p>
<p id="rfc.section.12.1.1.p.6">Returns: </p>

<ul class="empty"><li>S_OK, S_GENERAL_ERROR, S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION, S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE, S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT, S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_INVALID, S_KEY_EXPIRED, S_LOCAL_PORT_INVALID, S_LOCAL_PORT_INCOMPATIBLE, S_LOCAL_PORT_IN_USE, S_REMOTE_PORT_INVALID, S_REMOTE_PORT_IN_USE, S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR, S_CHANNEL_MAX</li></ul>

<p> </p>
<div id="#rfc.figure.180"></div>
<p>Method CICM::BypassWrite::ChannelManager::get_bypass_write_stream()</p>
<pre>CICM::Status get_bypass_write_stream(
	in  CICM::LocalPort local_port,
	out CICM::BypassWrite::Stream stream_ref
);</pre>
<p>Returns the stream corresponding to a pre-existing controller on the given local port.</p>
<p id="rfc.section.12.1.1.p.7">See also: </p>

<ul class="empty"><li>CICM::BypassWrite::ChannelManager::create_bypass_write_controller for the method that returns the channel controller.</li></ul>

<p> </p>
<p id="rfc.section.12.1.1.p.8">Parameters: </p>

<ul class="empty">
<li>[in] local_port Local port.</li>
<li>[out] stream_ref Reference to resulting stream.</li>
</ul>

<p> </p>
<p id="rfc.section.12.1.1.p.9">Returns: </p>

<ul class="empty"><li>S_OK, S_GENERAL_ERROR, S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION, S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE, S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT, S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_INVALID, S_KEY_EXPIRED, S_LOCAL_PORT_INVALID, S_LOCAL_PORT_INCOMPATIBLE, S_LOCAL_PORT_IN_USE, S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR, S_CHANNEL_PEER_RESET, S_CHANNEL_NOT_FOUND</li></ul>

<p> </p>
<h1 id="rfc.section.12.2">
<a href="#rfc.section.12.2">12.2.</a> Interface CICM::BypassWrite::Stream</h1>
<div id="#rfc.figure.181"></div>
<p>Interface CICM::BypassWrite::Stream</p>
<pre>interface Stream : CICM::WriteStream {</pre>
<p>CICM::BypassWrite::Stream supports full bypass between two independent security domains. The resulting stream is capable of accepting data for bypass, but not managing the channel. It is created by calling CICM::ChannelManager::get_bypass_write_stream.</p>
<h1 id="rfc.section.12.2.1">
<a href="#rfc.section.12.2.1">12.2.1.</a> CICM::BypassWrite::Stream Inheritance</h1>
<p id="rfc.section.12.2.1.p.1">CICM::BypassWrite::Stream inherits from: CICM::WriteStream.</p>
<h1 id="rfc.section.12.2.2">
<a href="#rfc.section.12.2.2">12.2.2.</a> CICM::BypassWrite::Stream Methods</h1>
<div id="#rfc.figure.182"></div>
<p>Method CICM::BypassWrite::Stream::write_bypass()</p>
<pre>CICM::Status write_bypass(
	in  CICM::Buffer buffer
);</pre>
<p>Write bypass data to a channel stream. The method blocks until the data has been sent.</p>
<p id="rfc.section.12.2.2.p.1">Parameters: </p>

<ul class="empty"><li>[in] buffer Data to bypass.</li></ul>

<p> </p>
<p id="rfc.section.12.2.2.p.2">Returns: </p>

<ul class="empty"><li>S_OK, S_GENERAL_ERROR, S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION, S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE, S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT, S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_INVALID, S_KEY_EXPIRED, S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR, S_CHANNEL_PEER_RESET, S_CHANNEL_IO_ERROR, S_CHANNEL_DATA_INVALID, S_CHANNEL_DATA_INVALID_LEN, S_BYPASS_DATARATE_EXCEEDED, S_BYPASS_DATALIMIT_EXCEEDED</li></ul>

<p> </p>
<div id="#rfc.figure.183"></div>
<p>Method CICM::BypassWrite::Stream::write_bypass_non_blocking()</p>
<pre>CICM::Status write_bypass_non_blocking(
	in  CICM::Buffer buffer,
	in  CICM::TransId transaction_id
);</pre>
<p>Registers a buffer of data to be sent to the module for bypass and then immediately returns control to the caller. The length of the data is encapsulated in the buffer parameter. The caller may use the CICM::BypassWrite::Stream::write_bypass_poll method to proactively poll the channel to determine the status of the operation. The caller is responsible for maintaining any necessary metadata associated with the transaction_id parameter.  Memory responsibilities and calling conventions shall follow the appropriate IDL language mapping conventions.</p>
<p id="rfc.section.12.2.2.p.3">Parameters: </p>

<ul class="empty">
<li>[in] buffer Data to bypass.</li>
<li>[in] transaction_id Unique transaction id that will be used by the CICM::BypassWrite::Stream::write_bypass_poll method to determine to which buffer the poll status applies.</li>
</ul>

<p> </p>
<p id="rfc.section.12.2.2.p.4">Returns: </p>

<ul class="empty"><li>S_OK, S_GENERAL_ERROR, S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION, S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE, S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT, S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_INVALID, S_KEY_EXPIRED, S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR, S_CHANNEL_PEER_RESET, S_CHANNEL_IO_ERROR, S_CHANNEL_DATA_INVALID, S_CHANNEL_DATA_INVALID_LEN, S_BYPASS_DATARATE_EXCEEDED, S_BYPASS_DATALIMIT_EXCEEDED</li></ul>

<p> </p>
<div id="#rfc.figure.184"></div>
<p>Method CICM::BypassWrite::Stream::write_bypass_poll()</p>
<pre>CICM::Status write_bypass_poll(
	in  CICM::TransId transaction_id,
	out CICM::WriteStream::WriteStatus status
);</pre>
<p>Returns the status of the non-blocking bypass operation specified by the transaction_id parameter. Memory responsibilities and calling conventions shall follow the appropriate IDL language mapping conventions.</p>
<p id="rfc.section.12.2.2.p.5">Parameters: </p>

<ul class="empty">
<li>[in] transaction_id Unique transaction id previously specified to the CICM::BypassWrite::Stream::write_bypass_non_blocking method that allows the poll operation to determine to which buffer the poll status applies.</li>
<li>[out] status Status of the non-blocking operation corresponding to the transaction_id parameter.</li>
</ul>

<p> </p>
<p id="rfc.section.12.2.2.p.6">Returns: </p>

<ul class="empty"><li>S_OK, S_GENERAL_ERROR, S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION, S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE, S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT, S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_INVALID, S_KEY_EXPIRED, S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR, S_CHANNEL_PEER_RESET, S_CHANNEL_IO_ERROR</li></ul>

<p> </p>
<h1 id="rfc.section.12.3">
<a href="#rfc.section.12.3">12.3.</a> Interface CICM::BypassWrite::Controller</h1>
<div id="#rfc.figure.185"></div>
<p>Interface  CICM::BypassWrite::Controller</p>
<pre>interface Controller : CICM::MultiDomainController {};</pre>
<p>CICM::BypassWrite::Controller supports full bypass between two independent security domains. The resulting controller is capable of managing the channel, but not accepting data for bypass.  It is created by calling CICM::ChannelManager::create_bypass_write_controller.</p>
<h1 id="rfc.section.12.3.1">
<a href="#rfc.section.12.3.1">12.3.1.</a> CICM::BypassWrite::Controller Inheritance</h1>
<p id="rfc.section.12.3.1.p.1">CICM::BypassWrite::Controller inherits from: CICM::MultiDomainController.</p>
<h1 id="rfc.section.12.4">
<a href="#rfc.section.12.4">12.4.</a> Interface CICM::BypassWrite::Conduit</h1>
<div id="#rfc.figure.186"></div>
<p>Interface CICM::BypassWrite::Conduit</p>
<pre>interface Conduit :
	CICM::Conduit,
	CICM::BypassWrite::Controller,
	CICM::BypassWrite::Stream {</pre>
<p>CICM::BypassWrite::Conduit supports full bypass between two security domains. The resulting conduit is capable of both managing the channel and accepting data for bypass. It is created by calling CICM::ChannelManager::create_bypass_write_conduit.</p>
<h1 id="rfc.section.12.4.1">
<a href="#rfc.section.12.4.1">12.4.1.</a> CICM::BypassWrite::Conduit Inheritance</h1>
<p id="rfc.section.12.4.1.p.1">CICM::BypassWrite::Conduit inherits from: CICM::Conduit, CICM::BypassWrite::Controller and CICM::BypassWrite::Stream.</p>
<h1 id="rfc.section.13">
<a href="#rfc.section.13">13.</a> <a href="#sec-bypass-read" id="sec-bypass-read">Bypass (Read)</a>
</h1>
<div id="#rfc.figure.187"></div>
<p>Namespace CICM::BypassRead</p>
<pre>module BypassRead {</pre>
<p>The CICM::BypassRead namespace contains channels that support full bypass read operations between two independent security domains.</p>
<h1 id="rfc.section.13.1">
<a href="#rfc.section.13.1">13.1.</a> Interface CICM::BypassRead::ChannelManager</h1>
<div id="#rfc.figure.188"></div>
<p>Interface  CICM::BypassRead::ChannelManager</p>
<pre>interface ChannelManager {</pre>
<p>CICM::BypassRead::ChannelManager is an abstraction inherited by CICM::ChannelManager that supports the creation of full bypass conduits, controllers, and streams for reading. See CICM::ChannelManager for additional information.</p>
<h1 id="rfc.section.13.1.1">
<a href="#rfc.section.13.1.1">13.1.1.</a> CICM::BypassRead::ChannelManager Methods</h1>
<div id="#rfc.figure.189"></div>
<p>Method CICM::BypassRead::ChannelManager::create_bypass_read_conduit()</p>
<pre>CICM::Status create_bypass_read_conduit(
	in  CICM::RemotePort remote_port,
	out CICM::BypassRead::Conduit conduit_ref
);</pre>
<p>Creates a conduit to read bypass data.</p>
<p id="rfc.section.13.1.1.p.1">Parameters: </p>

<ul class="empty">
<li>[in] remote_port Remote port.</li>
<li>[out] conduit_ref Reference to resulting conduit.</li>
</ul>

<p> </p>
<p id="rfc.section.13.1.1.p.2">Returns: </p>

<ul class="empty"><li>S_OK, S_GENERAL_ERROR, S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION, S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE, S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT, S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_INVALID, S_KEY_EXPIRED, S_REMOTE_PORT_INVALID, S_REMOTE_PORT_IN_USE, S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR, S_CHANNEL_MAX</li></ul>

<p> </p>
<div id="#rfc.figure.190"></div>
<p>Method CICM::BypassRead::ChannelManager::create_bypass_read_controller()</p>
<pre>CICM::Status create_bypass_read_controller(
	in  CICM::LocalPort local_port,
	in  CICM::RemotePort remote_port,
	out CICM::BypassRead::Controller controller_ref
);</pre>
<p>Returns the controller of a channel that reads bypass data.</p>
<p id="rfc.section.13.1.1.p.3">Remarks: </p>

<ul class="empty"><li>In some cases, hosts may depend upon separate processes to control and use a channel. This method returns the channel controller and must be called before the corresponding stream is retrieved.</li></ul>

<p> </p>
<p id="rfc.section.13.1.1.p.4">See also: </p>

<ul class="empty"><li>CICM::BypassRead::ChannelManager::get_bypass_read_stream for the method that returns the channel stream.</li></ul>

<p> </p>
<p id="rfc.section.13.1.1.p.5">Parameters: </p>

<ul class="empty">
<li>[in] local_port Local port.</li>
<li>[in] remote_port Remote port.</li>
<li>[out] controller_ref Reference to resulting controller.</li>
</ul>

<p> </p>
<p id="rfc.section.13.1.1.p.6">Returns: </p>

<ul class="empty"><li>S_OK, S_GENERAL_ERROR, S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION, S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE, S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT, S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_INVALID, S_KEY_EXPIRED, S_LOCAL_PORT_INVALID, S_LOCAL_PORT_INCOMPATIBLE, S_LOCAL_PORT_IN_USE, S_REMOTE_PORT_INVALID, S_REMOTE_PORT_IN_USE, S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR, S_CHANNEL_MAX</li></ul>

<p> </p>
<div id="#rfc.figure.191"></div>
<p>Method CICM::BypassRead::ChannelManager::get_bypass_read_stream()</p>
<pre>CICM::Status get_bypass_read_stream(
	in  CICM::LocalPort local_port,
	out CICM::BypassRead::Stream stream_ref
);</pre>
<p>Returns the stream corresponding to a pre-existing controller on the given local port.</p>
<p id="rfc.section.13.1.1.p.7">See also: </p>

<ul class="empty"><li>CICM::BypassRead::ChannelManager::get_bypass_read_controller for the method that returns the channel controller.</li></ul>

<p> </p>
<p id="rfc.section.13.1.1.p.8">Parameters: </p>

<ul class="empty">
<li>[in] local_port Local port.</li>
<li>[out] stream_ref Reference to resulting stream.</li>
</ul>

<p> </p>
<p id="rfc.section.13.1.1.p.9">Returns: </p>

<ul class="empty"><li>S_OK, S_GENERAL_ERROR, S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION, S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE, S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT, S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_INVALID, S_KEY_EXPIRED, S_LOCAL_PORT_INVALID, S_LOCAL_PORT_INCOMPATIBLE, S_LOCAL_PORT_IN_USE, S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR, S_CHANNEL_PEER_RESET, S_CHANNEL_NOT_FOUND</li></ul>

<p> </p>
<h1 id="rfc.section.13.2">
<a href="#rfc.section.13.2">13.2.</a> Interface CICM::BypassRead::Stream</h1>
<div id="#rfc.figure.192"></div>
<p>Interface CICM::BypassRead::Stream</p>
<pre>interface Stream : CICM::ReadStream {</pre>
<p>CICM::BypassRead::Stream supports full bypass between two independent security domains. The resulting stream is capable of accepting bypassed data, but not managing the channel. It is created by calling CICM::ChannelManager::get_bypass_read_stream.</p>
<h1 id="rfc.section.13.2.1">
<a href="#rfc.section.13.2.1">13.2.1.</a> CICM::BypassRead::Stream Inheritance</h1>
<p id="rfc.section.13.2.1.p.1">CICM::BypassRead::Stream inherits from: CICM::ReadStream.</p>
<h1 id="rfc.section.13.2.2">
<a href="#rfc.section.13.2.2">13.2.2.</a> CICM::BypassRead::Stream Methods</h1>
<div id="#rfc.figure.193"></div>
<p>Method CICM::BypassRead::Stream::read_bypass()</p>
<pre>CICM::Status read_bypass(
	out CICM::Buffer buffer
);</pre>
<p>Read bypass data off of channel stream. The method blocks until data becomes available.</p>
<p id="rfc.section.13.2.2.p.1">Parameters: </p>

<ul class="empty"><li>[out] buffer Bypassed data read from module.</li></ul>

<p> </p>
<p id="rfc.section.13.2.2.p.2">Returns: </p>

<ul class="empty"><li>S_OK, S_GENERAL_ERROR, S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION, S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE, S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT, S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_INVALID, S_KEY_EXPIRED, S_KEY_WRAPPED, S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR, S_CHANNEL_PEER_RESET, S_CHANNEL_IO_ERROR, S_CHANNEL_BUFFER_LEN</li></ul>

<p> </p>
<div id="#rfc.figure.194"></div>
<p>Method CICM::BypassRead::Stream::read_bypass_non_blocking()</p>
<pre>CICM::Status read_bypass_non_blocking(
	out CICM::Buffer buffer,
	in  CICM::TransId transaction_id
);</pre>
<p>Registers a buffer into which bypass data will be copied, and then immediately returns control to the caller. The size of the allocated buffer and length of the resulting bypassed data is encapsulated in the buffer parameter. The caller may use the CICM::BypassRead::Stream::read_bypass_poll method to proactively poll the channel to determine the status of the operation. The caller is responsible for maintaining any necessary metadata associated with the transaction_id parameter. Memory responsibilities and calling conventions shall follow the appropriate IDL language mapping conventions.</p>
<p id="rfc.section.13.2.2.p.3">Parameters: </p>

<ul class="empty">
<li>[out] buffer Bypassed data to read.</li>
<li>[in] transaction_id Unique transaction id that will be used by the CICM::BypassRead::Stream::read_bypass_poll method to determine to which buffer the poll status applies.</li>
</ul>

<p> </p>
<p id="rfc.section.13.2.2.p.4">Returns: </p>

<ul class="empty"><li>S_OK, S_GENERAL_ERROR, S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION, S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE, S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT, S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_INVALID, S_KEY_EXPIRED, S_KEY_WRAPPED, S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR, S_CHANNEL_PEER_RESET, S_CHANNEL_IO_ERROR, S_CHANNEL_BUFFER_LEN</li></ul>

<p> </p>
<div id="#rfc.figure.195"></div>
<p>Method CICM::BypassRead::Stream::read_bypass_poll()</p>
<pre>CICM::Status read_bypass_poll(
	in  CICM::TransId transaction_id,
	out CICM::ReadStream::ReadStatus status
);</pre>
<p>Returns the status of the non-blocking bypass operation specified by the transaction_id parameter. Upon completion of the operation, the caller must use the metadata associated with the transaction_id parameter to determine which buffer has been populated. Memory responsibilities and calling conventions shall follow the appropriate IDL language mapping conventions.</p>
<p id="rfc.section.13.2.2.p.5">Parameters: </p>

<ul class="empty">
<li>[in] transaction_id Unique transaction id previously specified to the CICM::BypassRead::Stream::read_bypass_non_blocking method that allows the poll operation to determine to which buffer the poll status applies.</li>
<li>[out] status Status of the non-blocking operation corresponding to the transaction_id parameter.</li>
</ul>

<p> </p>
<p id="rfc.section.13.2.2.p.6">Returns: </p>

<ul class="empty"><li>S_OK, S_GENERAL_ERROR, S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION, S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE, S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT, S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR, S_CHANNEL_PEER_RESET, S_CHANNEL_IO_ERROR</li></ul>

<p> </p>
<h1 id="rfc.section.13.3">
<a href="#rfc.section.13.3">13.3.</a> Interface CICM::BypassRead::Controller</h1>
<div id="#rfc.figure.196"></div>
<p>Interface  CICM::BypassRead::Controller</p>
<pre>interface Controller : CICM::MultiDomainController {};</pre>
<p>CICM::BypassRead::Controller supports full bypass between two independent security domains. The resulting controller is capable of managing the channel, but not accepting bypassed data. It is created by calling CICM::ChannelManager::create_bypass_read_controller.</p>
<h1 id="rfc.section.13.3.1">
<a href="#rfc.section.13.3.1">13.3.1.</a> CICM::BypassRead::Controller Inheritance</h1>
<p id="rfc.section.13.3.1.p.1">CICM::BypassRead::Controller inherits from: CICM::MultiDomainController.</p>
<h1 id="rfc.section.13.4">
<a href="#rfc.section.13.4">13.4.</a> Interface CICM::BypassRead::Conduit</h1>
<div id="#rfc.figure.197"></div>
<p>Interface CICM::BypassRead::Conduit</p>
<pre>interface Conduit :
	CICM::Conduit,
	CICM::BypassRead::Controller,
	CICM::BypassRead::Stream {</pre>
<p>CICM::BypassRead::Conduit supports full bypass between two independent security domains. The resulting conduit is capable of both managing the channel and accepting bypassed data. It is created by calling CICM::ChannelManager::create_bypass_read_conduit.</p>
<h1 id="rfc.section.13.4.1">
<a href="#rfc.section.13.4.1">13.4.1.</a> CICM::BypassRead::Conduit Inheritance</h1>
<p id="rfc.section.13.4.1.p.1">CICM::BypassRead::Conduit inherits from: CICM::Conduit, CICM::BypassRead::Controller and CICM::BypassRead::Stream.</p>
<h1 id="rfc.section.14">
<a href="#rfc.section.14">14.</a> <a href="#sec-encrypt-bypass" id="sec-encrypt-bypass">Encryption with Selective Bypass</a>
</h1>
<div id="#rfc.figure.198"></div>
<p>Namespace CICM::EncryptBypass</p>
<pre>module EncryptBypass {</pre>
<p>The CICM::EncryptBypass namespace contains interfaces that support encryption with selective bypass operations between two indepenent security domains.</p>
<h1 id="rfc.section.14.1">
<a href="#rfc.section.14.1">14.1.</a> Interface CICM::EncryptBypass::ChannelManager</h1>
<div id="#rfc.figure.199"></div>
<p>Interface CICM::EncryptBypass::ChannelManager</p>
<pre>interface ChannelManager {</pre>
<p>CICM::EncryptBypass::ChannelManager is an abstraction inherited by CICM::ChannelManager that supports the creation of encryption with selective bypass negotiators, conduits, controllers, and streams. See CICM::ChannelManager for additional information.</p>
<p id="rfc.section.14.1.p.1">Remarks: </p>

<ul class="empty"><li>Note that if a system is using selective bypass channels to perform header bypass, policy may govern that a system performs the bypass function before the encryption function and performs the bypass function only once.</li></ul>
<h1 id="rfc.section.14.1.1">
<a href="#rfc.section.14.1.1">14.1.1.</a> CICM::EncryptBypass::ChannelManager Methods</h1>
<div id="#rfc.figure.200"></div>
<p>Method CICM::EncryptBypass::ChannelManager::negotiate_encrypt_bypass_conduit()</p>
<pre>CICM::Status negotiate_encrypt_bypass_conduit(
	in  CICM::RemotePort remote_port,
	in  CICM::ProtocolId protocol,
	in  CICM::AsymKey key_ref,
	out CICM::EncryptBypass::Negotiator negotiator_ref
);</pre>
<p>Initiate a negotiation to establish a shared key with a peer.  The channel that results will selectively encrypt or bypass a stream of data.</p>
<p id="rfc.section.14.1.1.p.1">Parameters: </p>

<ul class="empty">
<li>[in] remote_port Remote port.</li>
<li>[in] protocol Protocol identifier.</li>
<li>[in] key_ref Reference to negotiation key.</li>
<li>[out] negotiator_ref Reference to resulting negotiator.</li>
</ul>

<p> </p>
<p id="rfc.section.14.1.1.p.2">Returns: </p>

<ul class="empty"><li>S_OK, S_GENERAL_ERROR, S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION, S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE, S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT, S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_USED_INVALID, S_KEY_USED_EXPIRED, S_KEY_USED_WRAPPED, S_KEY_USED_CONTEXT, S_KEY_USED_COMPONENT_NOT_AVAIL, S_KEY_INVALID, S_KEY_EXPIRED, S_REMOTE_PORT_INVALID, S_REMOTE_PORT_IN_USE, S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT, S_NEGOTIATION_ABORTED, S_NEGOTIATION_FAILURE, S_NEGOTIATION_IN_PROGRESS, S_NEGOTIATION_TIMEOUT, S_CERT_LOCAL_INVALID, S_CERT_LOCAL_EXPIRED, S_CERT_REMOTE_INVALID, S_CERT_REMOTE_EXPIRED, S_CERT_REMOTE_PATH, S_PROTO_INVALID, S_PROTO_INCOMPATIBLE, S_PROTO_UNDETERMINED, S_CHANNEL_ERROR, S_CHANNEL_MAX</li></ul>

<p> </p>
<div id="#rfc.figure.201"></div>
<p>Method CICM::EncryptBypass::ChannelManager::negotiate_encrypt_bypass_controller()</p>
<pre>CICM::Status negotiate_encrypt_bypass_controller(
	in  CICM::LocalPort local_port,
	in  CICM::RemotePort remote_port,
	in  CICM::ProtocolId protocol,
	in  CICM::AsymKey key_ref,
	out CICM::EncryptBypass::ControllerNegotiator negotiator_ref
);</pre>
<p>Initiate a negotiation to establish a shared key with a peer, resulting in a controller to manage an encrypt with bypass channel.</p>
<p id="rfc.section.14.1.1.p.3">Parameters: </p>

<ul class="empty">
<li>[in] local_port Remote port.</li>
<li>[in] remote_port Remote port.</li>
<li>[in] protocol Protocol identifier.</li>
<li>[in] key_ref Reference to negotiation key.</li>
<li>[out] negotiator_ref Reference to resulting negotiator.</li>
</ul>

<p> </p>
<p id="rfc.section.14.1.1.p.4">Returns: </p>

<ul class="empty"><li>S_OK, S_GENERAL_ERROR, S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION, S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE, S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT, S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_USED_INVALID, S_KEY_USED_EXPIRED, S_KEY_USED_WRAPPED, S_KEY_USED_CONTEXT, S_KEY_USED_COMPONENT_NOT_AVAIL, S_KEY_INVALID, S_KEY_EXPIRED, S_LOCAL_PORT_INVALID, S_LOCAL_PORT_INCOMPATIBLE, S_LOCAL_PORT_IN_USE, S_REMOTE_PORT_INVALID, S_REMOTE_PORT_IN_USE, S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT, S_NEGOTIATION_ABORTED, S_NEGOTIATION_FAILURE, S_NEGOTIATION_IN_PROGRESS, S_NEGOTIATION_TIMEOUT, S_CERT_LOCAL_INVALID, S_CERT_LOCAL_EXPIRED, S_CERT_REMOTE_INVALID, S_CERT_REMOTE_EXPIRED, S_CERT_REMOTE_PATH, S_PROTO_INVALID, S_PROTO_INCOMPATIBLE, S_PROTO_UNDETERMINED, S_CHANNEL_ERROR, S_CHANNEL_MAX</li></ul>

<p> </p>
<div id="#rfc.figure.202"></div>
<p>Method CICM::EncryptBypass::ChannelManager::create_encrypt_bypass_conduit()</p>
<pre>CICM::Status create_encrypt_bypass_conduit(
	in  CICM::RemotePort remote_port,
	in  CICM::SymKey key_ref,
	in  CICM::SymEncrAlgorithmId algorithm,
	out CICM::EncryptBypass::Conduit conduit_ref
);</pre>
<p>Create conduit to selectively encrypt or bypass a stream of  data.</p>
<p id="rfc.section.14.1.1.p.5">Parameters: </p>

<ul class="empty">
<li>[in] remote_port Remote port.</li>
<li>[in] key_ref Reference to encryption key.</li>
<li>[in] algorithm Encryption algorithm/mode.</li>
<li>[out] conduit_ref Reference to resulting negotiator.</li>
</ul>

<p> </p>
<p id="rfc.section.14.1.1.p.6">Returns: </p>

<ul class="empty"><li>S_OK, S_GENERAL_ERROR, S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION, S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE, S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT, S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_INVALID, S_KEY_EXPIRED, S_REMOTE_PORT_INVALID, S_REMOTE_PORT_IN_USE, S_ALGO_INVALID, S_ALGO_INCOMPATIBLE, S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR, S_CHANNEL_MAX</li></ul>

<p> </p>
<div id="#rfc.figure.203"></div>
<p>Method CICM::EncryptBypass::ChannelManager::create_encrypt_bypass_controller()</p>
<pre>CICM::Status create_encrypt_bypass_controller(
	in  CICM::LocalPort local_port,
	in  CICM::RemotePort remote_port,
	in  CICM::SymKey key_ref,
	in  CICM::SymEncrAlgorithmId algorithm,
	out CICM::EncryptBypass::Controller controller_ref
);</pre>
<p>Create controller to configure and control an encrypt with bypass channel.</p>
<p id="rfc.section.14.1.1.p.7">Remarks: </p>

<ul class="empty"><li>In some cases, hosts may depend upon separate processes to control and use a channel. This method returns the channel controller and must be called before the corresponding stream is retrieved.</li></ul>

<p> </p>
<p id="rfc.section.14.1.1.p.8">Parameters: </p>

<ul class="empty">
<li>[in] local_port Local port.</li>
<li>[in] remote_port Remote port.</li>
<li>[in] key_ref Reference to encryption key.</li>
<li>[in] algorithm Encryption algorithm/mode.</li>
<li>[out] controller_ref Reference to resulting controller.</li>
</ul>

<p> </p>
<p id="rfc.section.14.1.1.p.9">Returns: </p>

<ul class="empty"><li>S_OK, S_GENERAL_ERROR, S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION, S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE, S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT, S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_INVALID, S_KEY_EXPIRED, S_LOCAL_PORT_INVALID, S_LOCAL_PORT_INCOMPATIBLE, S_LOCAL_PORT_IN_USE, S_REMOTE_PORT_INVALID, S_REMOTE_PORT_IN_USE, S_ALGO_INVALID, S_ALGO_INCOMPATIBLE, S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR, S_CHANNEL_MAX</li></ul>

<p> </p>
<div id="#rfc.figure.204"></div>
<p>Method CICM::EncryptBypass::ChannelManager::get_encrypt_bypass_stream()</p>
<pre>CICM::Status get_encrypt_bypass_stream(
	in  CICM::LocalPort local_port,
	out CICM::EncryptBypass::Stream stream_ref
);</pre>
<p>Create stream associated with previously created controller to accept data for transformation.</p>
<p id="rfc.section.14.1.1.p.10">Parameters: </p>

<ul class="empty">
<li>[in] local_port Local port.</li>
<li>[out] stream_ref Reference to resulting stream.</li>
</ul>

<p> </p>
<p id="rfc.section.14.1.1.p.11">Returns: </p>

<ul class="empty"><li>S_OK, S_GENERAL_ERROR, S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION, S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE, S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT, S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_INVALID, S_KEY_EXPIRED, S_LOCAL_PORT_INVALID, S_LOCAL_PORT_INCOMPATIBLE, S_LOCAL_PORT_IN_USE, S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR, S_CHANNEL_PEER_RESET, S_CHANNEL_NOT_FOUND</li></ul>

<p> </p>
<h1 id="rfc.section.14.2">
<a href="#rfc.section.14.2">14.2.</a> Interface CICM::EncryptBypass::Stream</h1>
<div id="#rfc.figure.205"></div>
<p>Interface CICM::EncryptBypass::Stream</p>
<pre>interface Stream :
	CICM::Encrypt::Stream,
	CICM::BypassWrite::Stream {</pre>
<p>CICM::EncryptBypass::Stream supports encryption and selective bypass operations between two independent security domains. The resulting stream is capable of accepting data for transformation, but not managing the channel. It is created by calling CICM::ChannelManager::get_encrypt_bypass_stream.</p>
<h1 id="rfc.section.14.2.1">
<a href="#rfc.section.14.2.1">14.2.1.</a> CICM::EncryptBypass::Stream Inheritance</h1>
<p id="rfc.section.14.2.1.p.1">CICM::EncryptBypass::Stream inherits from: CICM::Encrypt::Stream and CICM::BypassWrite::Stream.</p>
<h1 id="rfc.section.14.3">
<a href="#rfc.section.14.3">14.3.</a> Interface CICM::EncryptBypass::NegotiatedController</h1>
<div id="#rfc.figure.206"></div>
<p>Interface  CICM::EncryptBypass::NegotiatedController</p>
<pre>interface NegotiatedController : CICM::Encrypt::NegotiatedController {};</pre>
<p>CICM::EncryptBypass::NegotiatedController is the negotiated version of CICM::EncryptBypass::Controller. It is the result of a successful negotiation by CICM::EncryptBypass::ControllerNegotiator.</p>
<h1 id="rfc.section.14.3.1">
<a href="#rfc.section.14.3.1">14.3.1.</a> CICM::EncryptBypass::NegotiatedController Inheritance</h1>
<p id="rfc.section.14.3.1.p.1">CICM::EncryptBypass::NegotiatedController inherits from: CICM::Encrypt::NegotiatedController.</p>
<h1 id="rfc.section.14.4">
<a href="#rfc.section.14.4">14.4.</a> Interface CICM::EncryptBypass::Controller</h1>
<div id="#rfc.figure.207"></div>
<p>Interface  CICM::EncryptBypass::Controller</p>
<pre>interface Controller : CICM::Encrypt::Controller {};</pre>
<p>CICM::EncryptBypass::Controller supports encryption and selective bypass operations between two independent security domains. The resulting controller is capable of managing the channel, but not accepting data for transformation/bypass. It is created by calling CICM::ChannelManager::create_encrypt_bypass_controller.</p>
<h1 id="rfc.section.14.4.1">
<a href="#rfc.section.14.4.1">14.4.1.</a> CICM::EncryptBypass::Controller Inheritance</h1>
<p id="rfc.section.14.4.1.p.1">CICM::EncryptBypass::Controller inherits from: CICM::Encrypt::Controller.</p>
<h1 id="rfc.section.14.5">
<a href="#rfc.section.14.5">14.5.</a> Interface CICM::EncryptBypass::Conduit</h1>
<div id="#rfc.figure.208"></div>
<p>Interface  CICM::EncryptBypass::Conduit</p>
<pre>interface Conduit :
	CICM::Encrypt::Conduit,
	CICM::EncryptBypass::Stream {</pre>
<p>CICM::EncryptBypass::Conduit supports encryption and selective bypass operations between two independent security domains. The resulting conduit is capable of both managing the channel and accepting data for transformation/bypass. It is created by calling CICM::ChannelManager::create_encrypt_bypass_conduit.</p>
<h1 id="rfc.section.14.5.1">
<a href="#rfc.section.14.5.1">14.5.1.</a> CICM::EncryptBypass::Conduit Inheritance</h1>
<p id="rfc.section.14.5.1.p.1">CICM::EncryptBypass::Conduit inherits from: CICM::Encrypt::Conduit and CICM::EncryptBypass::Stream.</p>
<h1 id="rfc.section.14.6">
<a href="#rfc.section.14.6">14.6.</a> Interface CICM::EncryptBypass::NegotiatedConduit</h1>
<div id="#rfc.figure.209"></div>
<p>Interface  CICM::EncryptBypass::NegotiatedConduit</p>
<pre>interface NegotiatedConduit :
	CICM::Encrypt::NegotiatedController,
	CICM::EncryptBypass::Stream {</pre>
<p>CICM::EncryptBypass::NegotiatedConduit is the negotiated version of CICM::EncryptBypass::Conduit. It is the result of a successful negotiation by CICM::EncryptBypass::Negotiator.</p>
<h1 id="rfc.section.14.6.1">
<a href="#rfc.section.14.6.1">14.6.1.</a> CICM::EncryptBypass::NegotiatedConduit Inheritance</h1>
<p id="rfc.section.14.6.1.p.1">CICM::EncryptBypass::NegotiatedConduit inherits from: CICM::Encrypt::NegotiatedController and CICM::EncryptBypass::Stream.</p>
<h1 id="rfc.section.14.7">
<a href="#rfc.section.14.7">14.7.</a> Interface CICM::EncryptBypass::ControllerNegotiator</h1>
<div id="#rfc.figure.210"></div>
<p>Interface  CICM::EncryptBypass::ControllerNegotiator</p>
<pre>interface ControllerNegotiator : CICM::Negotiator {</pre>
<p>CICM::EncryptBypass::ControllerNegotiator initiates a negotiation to establish a shared key with a remote entity that is used to support encryption and selective bypass operations between two independent security domains. The result of a successful negotiation is a CICM::EncryptBypass::NegotiatedController which is capable of managing the channel, but not accepting data for transformation/bypass. CICM::EncryptBypass::ControllerNegotiator is created by calling CICM::ChannelManager::negotiate_encrypt_bypass_controller.</p>
<h1 id="rfc.section.14.7.1">
<a href="#rfc.section.14.7.1">14.7.1.</a> CICM::EncryptBypass::ControllerNegotiator Inheritance</h1>
<p id="rfc.section.14.7.1.p.1">CICM::EncryptBypass::ControllerNegotiator inherits from: CICM::Negotiator.</p>
<h1 id="rfc.section.14.7.2">
<a href="#rfc.section.14.7.2">14.7.2.</a> CICM::EncryptBypass::ControllerNegotiator Methods</h1>
<div id="#rfc.figure.211"></div>
<p>Method CICM::EncryptBypass::ControllerNegotiator::complete()</p>
<pre>CICM::Status complete(
	out CICM::EncryptBypass::NegotiatedController controller_ref
);</pre>
<p>Complete negotiation and retrieve a negotiated encrypt bypass control-only channel.</p>
<p id="rfc.section.14.7.2.p.1">Parameters: </p>

<ul class="empty"><li>[out] controller_ref Reference to resulting controller.</li></ul>

<p> </p>
<p id="rfc.section.14.7.2.p.2">Returns: </p>

<ul class="empty"><li>S_OK, S_GENERAL_ERROR, S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION, S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE, S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT, S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT, S_NEGOTIATION_ABORTED, S_NEGOTIATION_FAILURE, S_NEGOTIATION_NOT_IN_PROGRESS, S_NEGOTIATION_TIMEOUT, S_CERT_LOCAL_INVALID, S_CERT_LOCAL_EXPIRED, S_CERT_REMOTE_INVALID, S_CERT_REMOTE_EXPIRED, S_CERT_REMOTE_PATH, S_CHANNEL_ERROR, S_CHANNEL_PEER_RESET</li></ul>

<p> </p>
<h1 id="rfc.section.14.8">
<a href="#rfc.section.14.8">14.8.</a> Interface CICM::EncryptBypass::Negotiator</h1>
<div id="#rfc.figure.212"></div>
<p>Interface  CICM::EncryptBypass::Negotiator</p>
<pre>interface Negotiator : CICM::Negotiator {</pre>
<p>CICM::EncryptBypass::Negotiator initiates a negotiation to establish a shared key with a remote entity that is used to support encryption and bypass operations between two independent security domains. Additionally, selective bypass is supported on the same conduit. The result of a successful negotiation is a CICM::EncryptBypass::NegotiatedConduit which is capable of both managing the channel and accepting data for transformation/bypass.  CICM::EncryptBypass::Negotiator is created by calling CICM::ChannelManager::negotiate_encrypt_bypass_conduit.</p>
<h1 id="rfc.section.14.8.1">
<a href="#rfc.section.14.8.1">14.8.1.</a> CICM::EncryptBypass::Negotiator Inheritance</h1>
<p id="rfc.section.14.8.1.p.1">CICM::EncryptBypass::Negotiator inherits from: CICM::Negotiator.</p>
<h1 id="rfc.section.14.8.2">
<a href="#rfc.section.14.8.2">14.8.2.</a> CICM::EncryptBypass::Negotiator Methods</h1>
<div id="#rfc.figure.213"></div>
<p>Method CICM::EncryptBypass::Negotiator::complete()</p>
<pre>CICM::Status complete(
	out CICM::EncryptBypass::NegotiatedConduit conduit_ref
);</pre>
<p>Complete negotiation and retrieve a negotiated encrypt bypass conduit.</p>
<p id="rfc.section.14.8.2.p.1">Parameters: </p>

<ul class="empty"><li>[out] conduit_ref Reference to resulting conduit.</li></ul>

<p> </p>
<p id="rfc.section.14.8.2.p.2">Returns: </p>

<ul class="empty"><li>S_OK, S_GENERAL_ERROR, S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION, S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE, S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT, S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT, S_NEGOTIATION_ABORTED, S_NEGOTIATION_FAILURE, S_NEGOTIATION_NOT_IN_PROGRESS, S_NEGOTIATION_TIMEOUT, S_CERT_LOCAL_INVALID, S_CERT_LOCAL_EXPIRED, S_CERT_REMOTE_INVALID, S_CHANNEL_PEER_RESET</li></ul>

<p> </p>
<h1 id="rfc.section.15">
<a href="#rfc.section.15">15.</a> <a href="#sec-decrypt-bypass" id="sec-decrypt-bypass">Decryption with Selective Bypass</a>
</h1>
<div id="#rfc.figure.214"></div>
<p>Namespace CICM::DecryptBypass</p>
<pre>module DecryptBypass {</pre>
<p>The CICM::DecryptBypass namespace contains interfaces that support decryption with selective bypass operations between two independent security domains.</p>
<h1 id="rfc.section.15.1">
<a href="#rfc.section.15.1">15.1.</a> Interface CICM::DecryptBypass::ChannelManager</h1>
<div id="#rfc.figure.215"></div>
<p>Interface  CICM::DecryptBypass::ChannelManager</p>
<pre>interface ChannelManager {</pre>
<p>CICM::DecryptBypass::ChannelManager is an abstraction inherited by CICM::ChannelManager that supports the creation of decryption with selective bypass negotiators, conduits, controllers, and streams. See CICM::ChannelManager for additional information.</p>
<p id="rfc.section.15.1.p.1">Remarks: </p>

<ul class="empty"><li>CICM does not specify the structure of the data that is read from a selective bypass channel which may contain special formatting to indicate which subset of the data was bypassed. The Implementation Conformance Statement (see Conformance and Extensions in <a href="#CICM">[CICM]</a>) MUST reference a standard format or define a module developer-specific format implemented by the module for data read from selective bypass channels.</li></ul>

<p> </p>
<h1 id="rfc.section.15.1.1">
<a href="#rfc.section.15.1.1">15.1.1.</a> CICM::DecryptBypass::ChannelManager Methods</h1>
<div id="#rfc.figure.216"></div>
<p>Method CICM::DecryptBypass::ChannelManager::negotiate_decrypt_bypass_conduit()</p>
<pre>CICM::Status negotiate_decrypt_bypass_conduit(
	in  CICM::RemotePort remote_port,
	in  CICM::ProtocolId protocol,
	in  CICM::AsymKey key_ref,
	out CICM::DecryptBypass::Negotiator negotiator_ref
);</pre>
<p>Initiate a negotiation to establish a shared key with a peer.  The channel that results will selectively decrypt or bypass a stream of data.</p>
<p id="rfc.section.15.1.1.p.1">Parameters: </p>

<ul class="empty">
<li>[in] remote_port Remote port.</li>
<li>[in] protocol Protocol identifier.</li>
<li>[in] key_ref Reference to negotiation key.</li>
<li>[out] negotiator_ref Reference to resulting negotiator.</li>
</ul>

<p> </p>
<p id="rfc.section.15.1.1.p.2">Returns: </p>

<ul class="empty"><li>S_OK, S_GENERAL_ERROR, S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION, S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE, S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT, S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_USED_INVALID, S_KEY_USED_EXPIRED, S_KEY_USED_WRAPPED, S_KEY_USED_CONTEXT, S_KEY_USED_COMPONENT_NOT_AVAIL, S_KEY_INVALID, S_KEY_EXPIRED, S_REMOTE_PORT_INVALID, S_REMOTE_PORT_IN_USE, S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT, S_NEGOTIATION_ABORTED, S_NEGOTIATION_FAILURE, S_NEGOTIATION_IN_PROGRESS, S_NEGOTIATION_TIMEOUT, S_CERT_LOCAL_INVALID, S_CERT_LOCAL_EXPIRED, S_CERT_REMOTE_INVALID, S_CERT_REMOTE_EXPIRED, S_CERT_REMOTE_PATH, S_PROTO_INVALID, S_PROTO_INCOMPATIBLE, S_PROTO_UNDETERMINED, S_CHANNEL_ERROR, S_CHANNEL_MAX</li></ul>

<p> </p>
<div id="#rfc.figure.217"></div>
<p>Method CICM::DecryptBypass::ChannelManager::negotiate_decrypt_bypass_controller()</p>
<pre>CICM::Status negotiate_decrypt_bypass_controller(
	in  CICM::LocalPort local_port,
	in  CICM::RemotePort remote_port,
	in  CICM::ProtocolId protocol,
	in  CICM::AsymKey key_ref,
	out CICM::DecryptBypass::ControllerNegotiator negotiator_ref
);</pre>
<p>Initiate a negotiation to establish a shared key with a peer, resulting in a controller to manage a decrypt with bypass channel.</p>
<p id="rfc.section.15.1.1.p.3">Parameters: </p>

<ul class="empty">
<li>[in] local_port Local port.</li>
<li>[in] remote_port Remote port.</li>
<li>[in] protocol Protocol identifier.</li>
<li>[in] key_ref Reference to negotiation key.</li>
<li>[out] negotiator_ref Reference to resulting negotiator.</li>
</ul>

<p> </p>
<p id="rfc.section.15.1.1.p.4">Returns: </p>

<ul class="empty"><li>S_OK, S_GENERAL_ERROR, S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION, S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE, S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT, S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_USED_INVALID, S_KEY_USED_EXPIRED, S_KEY_USED_WRAPPED, S_KEY_USED_CONTEXT, S_KEY_USED_COMPONENT_NOT_AVAIL, S_KEY_INVALID, S_KEY_EXPIRED, S_LOCAL_PORT_INVALID, S_LOCAL_PORT_INCOMPATIBLE, S_LOCAL_PORT_IN_USE, S_REMOTE_PORT_INVALID, S_REMOTE_PORT_IN_USE, S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT, S_NEGOTIATION_ABORTED, S_NEGOTIATION_FAILURE, S_NEGOTIATION_IN_PROGRESS, S_NEGOTIATION_TIMEOUT, S_CERT_LOCAL_INVALID, S_CERT_LOCAL_EXPIRED, S_CERT_REMOTE_INVALID, S_CERT_REMOTE_EXPIRED, S_CERT_REMOTE_PATH, S_PROTO_INVALID, S_PROTO_INCOMPATIBLE, S_PROTO_UNDETERMINED, S_CHANNEL_ERROR, S_CHANNEL_MAX</li></ul>

<p> </p>
<div id="#rfc.figure.218"></div>
<p>Method CICM::DecryptBypass::ChannelManager::create_decrypt_bypass_conduit()</p>
<pre>CICM::Status create_decrypt_bypass_conduit(
	in  CICM::RemotePort remote_port,
	in  CICM::SymKey key_ref,
	in  CICM::SymEncrAlgorithmId algorithm,
	out CICM::DecryptBypass::Conduit conduit_ref
);</pre>
<p>Create conduit to selectively decrypt or bypass a stream of data.</p>
<p id="rfc.section.15.1.1.p.5">Remarks: </p>

<ul class="empty"><li>Both decrypted and bypassed data are read from the same stream using the appropriate decrypt() call; the entity reading from this stream must distinguish between decrypted and bypassed data, if necessary.</li></ul>

<p> </p>
<p id="rfc.section.15.1.1.p.6">Parameters: </p>

<ul class="empty">
<li>[in] remote_port Remote port.</li>
<li>[in] key_ref Reference to decryption key.</li>
<li>[in] algorithm Decryption algorithm/mode.</li>
<li>[out] conduit_ref Reference to resulting conduit.</li>
</ul>

<p> </p>
<p id="rfc.section.15.1.1.p.7">Returns: </p>

<ul class="empty"><li>S_OK, S_GENERAL_ERROR, S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION, S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE, S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT, S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_INVALID, S_KEY_EXPIRED, S_REMOTE_PORT_INVALID, S_REMOTE_PORT_IN_USE, S_ALGO_INVALID, S_ALGO_INCOMPATIBLE, S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR, S_CHANNEL_MAX</li></ul>

<p> </p>
<div id="#rfc.figure.219"></div>
<p>Method CICM::DecryptBypass::ChannelManager::create_decrypt_bypass_controller()</p>
<pre>CICM::Status create_decrypt_bypass_controller(
	in  CICM::LocalPort local_port,
	in  CICM::RemotePort remote_port,
	in  CICM::SymKey key_ref,
	in  CICM::SymEncrAlgorithmId algorithm,
	out CICM::DecryptBypass::Controller controller_ref
);</pre>
<p>Create controller to configure and control a decrypt with bypass channel.</p>
<p id="rfc.section.15.1.1.p.8">Remarks: </p>

<ul class="empty"><li>In some cases, hosts may depend upon separate processes to control and use a channel. This method returns the channel controller and must be called before the corresponding stream is retrieved.</li></ul>

<p> </p>
<p id="rfc.section.15.1.1.p.9">Parameters: </p>

<ul class="empty">
<li>[in] local_port Local port.</li>
<li>[in] remote_port Remote port.</li>
<li>[in] key_ref Reference to decryption key.</li>
<li>[in] algorithm Decryption algorithm/mode.</li>
<li>[out] controller_ref Reference to resulting controller.</li>
</ul>

<p> </p>
<p id="rfc.section.15.1.1.p.10">Returns: </p>

<ul class="empty"><li>S_OK, S_GENERAL_ERROR, S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION, S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE, S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT, S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_INVALID, S_KEY_EXPIRED, S_LOCAL_PORT_INVALID, S_LOCAL_PORT_INCOMPATIBLE, S_LOCAL_PORT_IN_USE, S_REMOTE_PORT_INVALID, S_REMOTE_PORT_IN_USE, S_ALGO_INVALID, S_ALGO_INCOMPATIBLE, S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR, S_CHANNEL_MAX</li></ul>

<p> </p>
<div id="#rfc.figure.220"></div>
<p>Method CICM::DecryptBypass::ChannelManager::get_decrypt_bypass_stream()</p>
<pre>CICM::Status get_decrypt_bypass_stream(
	in  CICM::LocalPort local_port,
	out CICM::DecryptBypass::Stream stream_ref
);</pre>
<p>Create stream associated with previously created controller to receive transformed data.</p>
<p id="rfc.section.15.1.1.p.11">Remarks: </p>

<ul class="empty"><li>Both decrypted and bypassed data are read from the same stream using the appropriate decrypt() call; the entity reading from this stream must distinguish between decrypted and bypassed data, if necessary.</li></ul>

<p> </p>
<p id="rfc.section.15.1.1.p.12">Parameters: </p>

<ul class="empty">
<li>[in] local_port Local port.</li>
<li>[out] stream_ref Reference to resulting stream.</li>
</ul>

<p> </p>
<p id="rfc.section.15.1.1.p.13">Returns: </p>

<ul class="empty"><li>S_OK, S_GENERAL_ERROR, S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION, S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE, S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT, S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_INVALID, S_KEY_EXPIRED, S_LOCAL_PORT_INVALID, S_LOCAL_PORT_INCOMPATIBLE, S_LOCAL_PORT_IN_USE, S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR, S_CHANNEL_PEER_RESET, S_CHANNEL_NOT_FOUND</li></ul>

<p> </p>
<h1 id="rfc.section.15.2">
<a href="#rfc.section.15.2">15.2.</a> Interface CICM::DecryptBypass::Stream</h1>
<div id="#rfc.figure.221"></div>
<p>Interface CICM::DecryptBypass::Stream</p>
<pre>interface Stream : CICM::Decrypt::Stream {};</pre>
<p>CICM::DecryptBypass::Stream supports decryption and selective bypass operations between two independent security domains. The resulting stream is capable of accepting transformed/bypassed data, but not managing the channel. It is created by calling CICM::ChannelManager::get_decrypt_bypass_stream.</p>
<p id="rfc.section.15.2.p.1">Remarks: </p>

<ul class="empty"><li>CICM does not specify the structure of the data that is read from a selective bypass channel which may contain special formatting to indicate which subset of the data was bypassed. The Implementation Conformance Statement (see Conformance and Extensions in <a href="#CICM">[CICM]</a>) MUST reference a standard format or define a module developer-specific format implemented by the module for data read from selective bypass channels.</li></ul>

<p> </p>
<h1 id="rfc.section.15.2.1">
<a href="#rfc.section.15.2.1">15.2.1.</a> CICM::DecryptBypass::Stream Inheritance</h1>
<p id="rfc.section.15.2.1.p.1">CICM::DecryptBypass::Stream inherits from: CICM::Decrypt::Stream.</p>
<h1 id="rfc.section.15.3">
<a href="#rfc.section.15.3">15.3.</a> Interface CICM::DecryptBypass::Controller</h1>
<div id="#rfc.figure.222"></div>
<p>Interface  CICM::DecryptBypass::Controller</p>
<pre>interface Controller : CICM::Decrypt::Controller {</pre>
<p>CICM::DecryptBypass::Controller supports decryption and selective bypass operations between two independent security domains. The resulting controller is capable of managing the channel, but not accepting transformed/bypassed data. It is created by calling CICM::ChannelManager::create_decrypt_bypass_controller.</p>
<h1 id="rfc.section.15.3.1">
<a href="#rfc.section.15.3.1">15.3.1.</a> CICM::DecryptBypass::Controller Inheritance</h1>
<p id="rfc.section.15.3.1.p.1">CICM::DecryptBypass::Controller inherits from: CICM::Decrypt::Controller.</p>
<h1 id="rfc.section.15.4">
<a href="#rfc.section.15.4">15.4.</a> Interface CICM::DecryptBypass::NegotiatedController</h1>
<div id="#rfc.figure.223"></div>
<p>Interface  CICM::DecryptBypass::NegotiatedController</p>
<pre>interface NegotiatedController : CICM::Decrypt::NegotiatedController {</pre>
<p>CICM::DecryptBypass::NegotiatedController is the negotiated version of CICM::DecryptBypass::Controller. It is the result of a successful negotiation by CICM::DecryptBypass::ControllerNegotiator.</p>
<h1 id="rfc.section.15.4.1">
<a href="#rfc.section.15.4.1">15.4.1.</a> CICM::DecryptBypass::NegotiatedController Inheritance</h1>
<p id="rfc.section.15.4.1.p.1">CICM::DecryptBypass::NegotiatedController inherits from: CICM::Decrypt::NegotiatedController.</p>
<h1 id="rfc.section.15.5">
<a href="#rfc.section.15.5">15.5.</a> Interface CICM::DecryptBypass::Conduit</h1>
<div id="#rfc.figure.224"></div>
<p>Interface  CICM::DecryptBypass::Conduit</p>
<pre>interface Conduit :
	CICM::Decrypt::Conduit,
	CICM::DecryptBypass::Controller,
	CICM::DecryptBypass::Stream {</pre>
<p>CICM::DecryptBypass::Conduit supports decryption and selective bypass operations between two independent security domains. The resulting conduit is capable of both managing the channel and accepting transformed/bypassed data. It is created by calling CICM::ChannelManager::create_decrypt_bypass_conduit.</p>
<h1 id="rfc.section.15.5.1">
<a href="#rfc.section.15.5.1">15.5.1.</a> CICM::DecryptBypass::Conduit Inheritance</h1>
<p id="rfc.section.15.5.1.p.1">CICM::DecryptBypass::Conduit inherits from: CICM::Decrypt::Conduit, CICM::DecryptBypass::Controller and CICM::DecryptBypass::Stream.</p>
<h1 id="rfc.section.15.6">
<a href="#rfc.section.15.6">15.6.</a> Interface CICM::DecryptBypass::NegotiatedConduit</h1>
<div id="#rfc.figure.225"></div>
<p>Interface  CICM::DecryptBypass::NegotiatedConduit</p>
<pre>interface NegotiatedConduit :
	CICM::Decrypt::NegotiatedConduit,
	CICM::DecryptBypass::NegotiatedController,
	CICM::DecryptBypass::Stream {</pre>
<p>CICM::DecryptBypass::NegotiatedConduit is the negotiated version of CICM::DecryptBypass::Conduit. It is the result of a successful negotiation by CICM::DecryptBypass::Negotiator.</p>
<h1 id="rfc.section.15.6.1">
<a href="#rfc.section.15.6.1">15.6.1.</a> CICM::DecryptBypass::NegotiatedConduit Inheritance</h1>
<p id="rfc.section.15.6.1.p.1">CICM::DecryptBypass::NegotiatedConduit inherits from: CICM::Decrypt::NegotiatedConduit, CICM::DecryptBypass::NegotiatedController and CICM::DecryptBypass::Stream.</p>
<h1 id="rfc.section.15.7">
<a href="#rfc.section.15.7">15.7.</a> Interface CICM::DecryptBypass::ControllerNegotiator</h1>
<div id="#rfc.figure.226"></div>
<p>Interface  CICM::DecryptBypass::ControllerNegotiator</p>
<pre>interface ControllerNegotiator : CICM::Negotiator {</pre>
<p>CICM::DecryptBypass::ControllerNegotiator initiates a negotiation to establish a shared key with a remote entity that is used to support encryption and selective bypass operations between two independent security domains. The result of a successful negotiation is a CICM::DecryptBypass::NegotiatedController which is capable of managing the channel, but not accepting data for transformation. CICM::DecryptBypass::ControllerNegotiator is created by calling CICM::ChannelManager::negotiate_decrypt_bypass_controller.</p>
<h1 id="rfc.section.15.7.1">
<a href="#rfc.section.15.7.1">15.7.1.</a> CICM::DecryptBypass::ControllerNegotiator Inheritance</h1>
<p id="rfc.section.15.7.1.p.1">CICM::DecryptBypass::ControllerNegotiator inherits from: CICM::Negotiator.</p>
<h1 id="rfc.section.15.7.2">
<a href="#rfc.section.15.7.2">15.7.2.</a> CICM::DecryptBypass::ControllerNegotiator Methods</h1>
<div id="#rfc.figure.227"></div>
<p>Method CICM::DecryptBypass::ControllerNegotiator::complete()</p>
<pre>CICM::Status complete(
	out CICM::DecryptBypass::NegotiatedController controller_ref
);</pre>
<p>Complete negotiation and retrieve a negotiated control-only decrypt bypass channel.</p>
<p id="rfc.section.15.7.2.p.1">Parameters: </p>

<ul class="empty"><li>[out] controller_ref Reference to resulting controller.</li></ul>

<p> </p>
<p id="rfc.section.15.7.2.p.2">Returns: </p>

<ul class="empty"><li>S_OK, S_GENERAL_ERROR, S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION, S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE, S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT, S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT, S_NEGOTIATION_ABORTED, S_NEGOTIATION_FAILURE, S_NEGOTIATION_NOT_IN_PROGRESS, S_NEGOTIATION_TIMEOUT, S_CERT_LOCAL_INVALID, S_CERT_LOCAL_EXPIRED, S_CERT_REMOTE_INVALID, S_CERT_REMOTE_EXPIRED, S_CERT_REMOTE_PATH, S_CHANNEL_ERROR, S_CHANNEL_PEER_RESET</li></ul>

<p> </p>
<h1 id="rfc.section.15.8">
<a href="#rfc.section.15.8">15.8.</a> Interface CICM::DecryptBypass::Negotiator</h1>
<div id="#rfc.figure.228"></div>
<p>Interface  CICM::DecryptBypass::Negotiator</p>
<pre>interface Negotiator : CICM::Negotiator {</pre>
<p>CICM::DecryptBypass::Negotiator initiates a negotiation to establish a shared key with a remote entity that is used to support encryption operations between two independent security domains.  Additionally, selective bypass is supported on the same conduit.  The result of a successful negotiation is a CICM::DecryptBypass::NegotiatedConduit which is capable of both managing the channel and accepting data for transformation.  CICM::DecryptBypass::Negotiator is created by calling CICM::ChannelManager::negotiate_decrypt_bypass_conduit.</p>
<h1 id="rfc.section.15.8.1">
<a href="#rfc.section.15.8.1">15.8.1.</a> CICM::DecryptBypass::Negotiator Inheritance</h1>
<p id="rfc.section.15.8.1.p.1">CICM::DecryptBypass::Negotiator inherits from: CICM::Negotiator.</p>
<h1 id="rfc.section.15.8.2">
<a href="#rfc.section.15.8.2">15.8.2.</a> CICM::DecryptBypass::Negotiator Methods</h1>
<div id="#rfc.figure.229"></div>
<p>Method CICM::DecryptBypass::Negotiator::complete()</p>
<pre>CICM::Status complete(
	out CICM::DecryptBypass::NegotiatedConduit conduit_ref
);</pre>
<p>Complete negotiation and retrieve a negotiated decrypt bypass conduit.</p>
<p id="rfc.section.15.8.2.p.1">Parameters: </p>

<ul class="empty"><li>[out] conduit_ref Reference to resulting conduit.</li></ul>

<p> </p>
<p id="rfc.section.15.8.2.p.2">Returns: </p>

<ul class="empty"><li>S_OK, S_GENERAL_ERROR, S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION, S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE, S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT, S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT, S_NEGOTIATION_ABORTED, S_NEGOTIATION_FAILURE, S_NEGOTIATION_NOT_IN_PROGRESS, S_NEGOTIATION_TIMEOUT, S_CERT_LOCAL_INVALID, S_CERT_LOCAL_EXPIRED, S_CERT_REMOTE_INVALID, S_CERT_REMOTE_EXPIRED, S_CERT_REMOTE_PATH, S_CHANNEL_ERROR, S_CHANNEL_PEER_RESET</li></ul>

<p> </p>
<h1 id="rfc.section.16">
<a href="#rfc.section.16">16.</a> <a href="#sec-emit" id="sec-emit">Random, Pseudorandom and Keystream</a>
</h1>
<div id="#rfc.figure.230"></div>
<p>Namespace CICM::Emit</p>
<pre>module Emit {</pre>
<p>The CICM::Emit namespace contains interfaces that generate data originating in a cryptographic module such as random, pseudorandom, and keystream data.</p>
<h1 id="rfc.section.16.1">
<a href="#rfc.section.16.1">16.1.</a> Interface CICM::Emit::ChannelManager</h1>
<div id="#rfc.figure.231"></div>
<p>Interface CICM::Emit::ChannelManager</p>
<pre>interface ChannelManager {</pre>
<p>CICM::Emit::ChannelManager is an abstraction inherited by CICM::ChannelManager that supports the creation of conduits and controllers to generate keystream, pseudorandom, and random data.  See CICM::ChannelManager for additional information.</p>
<h1 id="rfc.section.16.1.1">
<a href="#rfc.section.16.1.1">16.1.1.</a> CICM::Emit::ChannelManager Methods</h1>
<div id="#rfc.figure.232"></div>
<p>Method CICM::Emit::ChannelManager::create_key_stream_gen_controller()</p>
<pre>CICM::Status create_key_stream_gen_controller(
	in  CICM::RemotePort remote_port,
	in  CICM::SymKey key_ref,
	in  CICM::SymEncrAlgorithmId algorithm,
	out CICM::Emit::KeyStreamGenController controller_ref
);</pre>
<p>Create controller to generate keystream.</p>
<p id="rfc.section.16.1.1.p.1">Parameters: </p>

<ul class="empty">
<li>[in] remote_port Remote port.</li>
<li>[in] key_ref Reference to keystream generation key.</li>
<li>[in] algorithm Keystream generation algorithm/mode.</li>
<li>[out] controller_ref Reference to resulting controller.</li>
</ul>

<p> </p>
<p id="rfc.section.16.1.1.p.2">Returns: </p>

<ul class="empty"><li>S_OK, S_GENERAL_ERROR, S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION, S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE, S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT, S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_USED_INVALID, S_KEY_USED_EXPIRED, S_KEY_USED_WRAPPED, S_KEY_USED_CONTEXT, S_KEY_INVALID, S_KEY_EXPIRED, S_REMOTE_PORT_INVALID, S_REMOTE_PORT_IN_USE, S_ALGO_INVALID, S_ALGO_INCOMPATIBLE, S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR, S_CHANNEL_MAX</li></ul>

<p> </p>
<div id="#rfc.figure.233"></div>
<p>Method CICM::Emit::ChannelManager::create_pseudorandom_controller()</p>
<pre>CICM::Status create_pseudorandom_controller(
	in  CICM::RemotePort remote_port,
	in  CICM::SymKey seed,
	out CICM::Emit::PseudoRandomController controller_ref
);</pre>
<p>Create controller to generate pseudorandom data.</p>
<p id="rfc.section.16.1.1.p.3">Parameters: </p>

<ul class="empty">
<li>[in] remote_port Remote port.</li>
<li>[in] seed Seed material for pseudorandom generator.</li>
<li>[out] controller_ref Reference to resulting controller.</li>
</ul>

<p> </p>
<p id="rfc.section.16.1.1.p.4">Returns: </p>

<ul class="empty"><li>S_OK, S_GENERAL_ERROR, S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION, S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE, S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT, S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_USED_INVALID, S_KEY_USED_EXPIRED, S_KEY_USED_WRAPPED, S_KEY_USED_CONTEXT, S_KEY_INVALID, S_KEY_EXPIRED, S_REMOTE_PORT_INVALID, S_REMOTE_PORT_IN_USE, S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR, S_CHANNEL_MAX, S_INSUFFICIENT_ENTROPY</li></ul>

<p> </p>
<div id="#rfc.figure.234"></div>
<p>Method CICM::Emit::ChannelManager::create_random_controller()</p>
<pre>CICM::Status create_random_controller(
	in  CICM::RemotePort remote_port,
	out CICM::Emit::RandomController controller_ref
);</pre>
<p>Create controller to generate random data.</p>
<p id="rfc.section.16.1.1.p.5">Parameters: </p>

<ul class="empty">
<li>[in] remote_port Remote port.</li>
<li>[out] controller_ref Reference to resulting controller.</li>
</ul>

<p> </p>
<p id="rfc.section.16.1.1.p.6">Returns: </p>

<ul class="empty"><li>S_OK, S_GENERAL_ERROR, S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION, S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE, S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT, S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_INVALID, S_KEY_EXPIRED, S_REMOTE_PORT_INVALID, S_REMOTE_PORT_IN_USE, S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR, S_CHANNEL_MAX, S_INSUFFICIENT_ENTROPY</li></ul>

<p> </p>
<div id="#rfc.figure.235"></div>
<p>Method CICM::Emit::ChannelManager::create_key_stream_gen_conduit()</p>
<pre>CICM::Status create_key_stream_gen_conduit(
	in  CICM::SymKey key_ref,
	in  CICM::SymEncrAlgorithmId algorithm,
	out CICM::Emit::KeyStreamGenConduit conduit_ref
);</pre>
<p>Create conduit to generate keystream.</p>
<p id="rfc.section.16.1.1.p.7">Parameters: </p>

<ul class="empty">
<li>[in] key_ref Reference to keystream generation key.</li>
<li>[in] algorithm Keystream generation algorithm/mode.</li>
<li>[out] conduit_ref Reference to resulting conduit.</li>
</ul>

<p> </p>
<p id="rfc.section.16.1.1.p.8">Returns: </p>

<ul class="empty"><li>S_OK, S_GENERAL_ERROR, S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION, S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE, S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT, S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_USED_INVALID, S_KEY_USED_EXPIRED, S_KEY_USED_WRAPPED, S_KEY_USED_CONTEXT, S_KEY_INVALID, S_KEY_EXPIRED, S_ALGO_INVALID, S_ALGO_INCOMPATIBLE, S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR, S_CHANNEL_MAX</li></ul>

<p> </p>
<div id="#rfc.figure.236"></div>
<p>Method CICM::Emit::ChannelManager::create_pseudorandom_conduit()</p>
<pre>CICM::Status create_pseudorandom_conduit(
	in  CICM::SymKey seed,
	out CICM::Emit::PseudoRandomConduit conduit_ref
);</pre>
<p>Create conduit to generate pseudorandom data.</p>
<p id="rfc.section.16.1.1.p.9">Parameters: </p>

<ul class="empty">
<li>[in] seed Seed material for pseudorandom generator.</li>
<li>[out] conduit_ref Reference to resulting conduit.</li>
</ul>

<p> </p>
<p id="rfc.section.16.1.1.p.10">Returns: </p>

<ul class="empty"><li>S_OK, S_GENERAL_ERROR, S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION, S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE, S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT, S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_USED_INVALID, S_KEY_USED_EXPIRED, S_KEY_USED_WRAPPED, S_KEY_USED_CONTEXT, S_KEY_INVALID, S_KEY_EXPIRED, S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR, S_CHANNEL_MAX, S_INSUFFICIENT_ENTROPY</li></ul>

<p> </p>
<div id="#rfc.figure.237"></div>
<p>Method CICM::Emit::ChannelManager::create_random_conduit()</p>
<pre>CICM::Status create_random_conduit(
	out CICM::Emit::RandomConduit conduit_ref
);</pre>
<p>Create conduit to generate random data.</p>
<p id="rfc.section.16.1.1.p.11">Parameters: </p>

<ul class="empty"><li>[out] conduit_ref Reference to resulting conduit.</li></ul>

<p> </p>
<p id="rfc.section.16.1.1.p.12">Returns: </p>

<ul class="empty"><li>S_OK, S_GENERAL_ERROR, S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION, S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE, S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT, S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_INVALID, S_KEY_EXPIRED, S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR, S_CHANNEL_MAX, S_INSUFFICIENT_ENTROPY</li></ul>

<p> </p>
<h1 id="rfc.section.16.2">
<a href="#rfc.section.16.2">16.2.</a> Interface CICM::Emit::GetStream</h1>
<div id="#rfc.figure.238"></div>
<p>Interface CICM::Emit::GetStream</p>
<pre>interface GetStream : CICM::ReadStream {</pre>
<p>CICM::Emit::GetStream is an abstraction inherited by conduits in the CICM::Emit namespace that allows data to be read from the stream.</p>
<h1 id="rfc.section.16.2.1">
<a href="#rfc.section.16.2.1">16.2.1.</a> CICM::Emit::GetStream Inheritance</h1>
<p id="rfc.section.16.2.1.p.1">CICM::Emit::GetStream inherits from: CICM::ReadStream.</p>
<h1 id="rfc.section.16.2.2">
<a href="#rfc.section.16.2.2">16.2.2.</a> CICM::Emit::GetStream Methods</h1>
<div id="#rfc.figure.239"></div>
<p>Method CICM::Emit::GetStream::get()</p>
<pre>CICM::Status get(
	in  CICM::UInt32 length,
	out CICM::Buffer buffer
);</pre>
<p>Reads a buffer of data from the module. The method blocks until data becomes available.</p>
<p id="rfc.section.16.2.2.p.1">Parameters: </p>

<ul class="empty">
<li>[in] length Number of bytes to retrieve.</li>
<li>[out] buffer Buffer of data read from stream.</li>
</ul>

<p> </p>
<p id="rfc.section.16.2.2.p.2">Returns: </p>

<ul class="empty"><li>S_OK, S_GENERAL_ERROR, S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION, S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE, S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT, S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_INVALID, S_KEY_EXPIRED, S_KEY_WRAPPED, S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR, S_CHANNEL_PEER_RESET, S_CHANNEL_IO_ERROR, S_CHANNEL_BUFFER_LEN, S_INSUFFICIENT_ENTROPY</li></ul>

<p> </p>
<div id="#rfc.figure.240"></div>
<p>Method CICM::Emit::GetStream::get_non_blocking()</p>
<pre>CICM::Status get_non_blocking(
	in  CICM::UInt32 length,
	out CICM::Buffer buffer,
	in  CICM::TransId transaction_id
);</pre>
<p>Registers a buffer into which transformed data will be copied, and then control immediately returns to the caller. The size of the allocated buffer and length of the resulting transformed data is encapsulated in the buffer parameter. The caller may use the CICM::Emit::GetStream::get_poll method to proactively poll the channel to determine the status of the operation. The caller is responsible for maintaining any necessary metadata associated with the transaction_id parameter. Memory responsibilities and calling conventions shall follow the appropriate IDL language mapping conventions.</p>
<p id="rfc.section.16.2.2.p.3">Parameters: </p>

<ul class="empty">
<li>[in] length Number of bytes to retrieve.</li>
<li>[out] buffer Transformed data.</li>
<li>[in] transaction_id Unique transaction id that will be used by the CICM::Emit::GetStream::get_poll method to determine to which buffer the poll status applies.</li>
</ul>

<p> </p>
<p id="rfc.section.16.2.2.p.4">Returns: </p>

<ul class="empty"><li>S_OK, S_GENERAL_ERROR, S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION, S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE, S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT, S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_INVALID, S_KEY_EXPIRED, S_KEY_WRAPPED, S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR, S_CHANNEL_PEER_RESET, S_CHANNEL_IO_ERROR, S_CHANNEL_BUFFER_LEN, S_INSUFFICIENT_ENTROPY</li></ul>

<p> </p>
<div id="#rfc.figure.241"></div>
<p>Method CICM::Emit::GetStream::get_poll()</p>
<pre>CICM::Status get_poll(
	in  CICM::TransId transaction_id,
	out CICM::ReadStream::ReadStatus status
);</pre>
<p>Returns the status of the non-blocking get operation specified by the transaction_id parameter. Upon completion of the operation, the caller must use the metadata associated with the transaction_id parameter to determine which buffer has been populated. Memory responsibilities and calling conventions shall follow the appropriate IDL language mapping conventions.</p>
<p id="rfc.section.16.2.2.p.5">Parameters: </p>

<ul class="empty">
<li>[in] transaction_id Unique transaction id previously specified to the CICM::Emit::GetStream::get_non_blocking method that allows the poll operation to determine to which buffer the poll status applies.</li>
<li>[out] status Status of the non-blocking operation corresponding to the transaction_id parameter.</li>
</ul>

<p> </p>
<p id="rfc.section.16.2.2.p.6">Returns: </p>

<ul class="empty"><li>S_OK, S_GENERAL_ERROR, S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION, S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE, S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT, S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_INVALID, S_KEY_EXPIRED, S_KEY_WRAPPED, S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR, S_CHANNEL_PEER_RESET, S_CHANNEL_IO_ERROR</li></ul>

<p> </p>
<h1 id="rfc.section.16.3">
<a href="#rfc.section.16.3">16.3.</a> Interface CICM::Emit::Controller</h1>
<div id="#rfc.figure.242"></div>
<p>Interface CICM::Emit::Controller</p>
<pre>interface Controller : CICM::Controller {</pre>
<p>CICM::Emit::Controller is an abstraction from which all other controllers in the CICM::Emit namespace inherit.</p>
<h1 id="rfc.section.16.3.1">
<a href="#rfc.section.16.3.1">16.3.1.</a> CICM::Emit::Controller Inheritance</h1>
<p id="rfc.section.16.3.1.p.1">CICM::Emit::Controller inherits from: CICM::Controller.</p>
<h1 id="rfc.section.16.3.2">
<a href="#rfc.section.16.3.2">16.3.2.</a> CICM::Emit::Controller Attributes</h1>
<div id="#rfc.figure.243"></div>
<p>AttributeCICM::Emit::Controller::remote_port</p>
<pre>readonly attribute CICM::RemotePort remote_port;</pre>
<p>The remote port associated with this controller.</p>
<h1 id="rfc.section.16.4">
<a href="#rfc.section.16.4">16.4.</a> Interface CICM::Emit::RandomController</h1>
<div id="#rfc.figure.244"></div>
<p>Interface  CICM::Emit::RandomController</p>
<pre>interface RandomController : CICM::Emit::Controller {};</pre>
<p>CICM::Emit::RandomController supports creating a channel to read random data from a module. The resulting controller is capable of managing the channel, but not reading random data. It is created by calling CICM::ChannelManager::create_random_controller.</p>
<h1 id="rfc.section.16.4.1">
<a href="#rfc.section.16.4.1">16.4.1.</a> CICM::Emit::RandomController Inheritance</h1>
<p id="rfc.section.16.4.1.p.1">CICM::Emit::RandomController inherits from: CICM::Emit::Controller.</p>
<h1 id="rfc.section.16.5">
<a href="#rfc.section.16.5">16.5.</a> Interface CICM::Emit::RandomConduit</h1>
<div id="#rfc.figure.245"></div>
<p>Interface CICM::Emit::RandomConduit</p>
<pre>interface RandomConduit :
	CICM::Conduit,
	CICM::Emit::GetStream {</pre>
<p>CICM::Emit::RandomConduit supports reading random data from a module. The resulting conduit is capable of both managing the channel and reading random data. It is created by calling CICM::ChannelManager::create_random_conduit.</p>
<h1 id="rfc.section.16.5.1">
<a href="#rfc.section.16.5.1">16.5.1.</a> CICM::Emit::RandomConduit Inheritance</h1>
<p id="rfc.section.16.5.1.p.1">CICM::Emit::RandomConduit inherits from: CICM::Conduit and CICM::Emit::GetStream.</p>
<h1 id="rfc.section.16.6">
<a href="#rfc.section.16.6">16.6.</a> Interface CICM::Emit::PseudoRandomController</h1>
<div id="#rfc.figure.246"></div>
<p>Interface  CICM::Emit::PseudoRandomController</p>
<pre>interface PseudoRandomController :
	CICM::SymKeyController,
	CICM::Emit::Controller {</pre>
<p>CICM::Emit::PseudoRandomController supports creating a channel to read pseudorandom data from a module. The resulting controller is capable of managing the channel, but not reading pseudorandom data. It is created by calling CICM::ChannelManager::create_pseudorandom_controller.</p>
<h1 id="rfc.section.16.6.1">
<a href="#rfc.section.16.6.1">16.6.1.</a> CICM::Emit::PseudoRandomController Inheritance</h1>
<p id="rfc.section.16.6.1.p.1">CICM::Emit::PseudoRandomController inherits from: CICM::SymKeyController and CICM::Emit::Controller.</p>
<h1 id="rfc.section.16.7">
<a href="#rfc.section.16.7">16.7.</a> Interface CICM::Emit::PseudoRandomConduit</h1>
<div id="#rfc.figure.247"></div>
<p>Interface  CICM::Emit::PseudoRandomConduit</p>
<pre>interface PseudoRandomConduit :
	CICM::Conduit,
	CICM::SymKeyController,
	CICM::Emit::GetStream {</pre>
<p>CICM::Emit::PseudoRandomConduit supports reading pseudorandom data from a module. The resulting conduit is capable of both managing the channel and reading pseudorandom data. It is created by calling CICM::ChannelManager::create_pseudorandom_conduit.</p>
<h1 id="rfc.section.16.7.1">
<a href="#rfc.section.16.7.1">16.7.1.</a> CICM::Emit::PseudoRandomConduit Inheritance</h1>
<p id="rfc.section.16.7.1.p.1">CICM::Emit::PseudoRandomConduit inherits from: CICM::Conduit, CICM::SymKeyController and CICM::Emit::GetStream.</p>
<h1 id="rfc.section.16.8">
<a href="#rfc.section.16.8">16.8.</a> Interface CICM::Emit::KeyStreamGenController</h1>
<div id="#rfc.figure.248"></div>
<p>Interface  CICM::Emit::KeyStreamGenController</p>
<pre>interface KeyStreamGenController :
	CICM::SymKeyController,
	CICM::GenVectorController,
	CICM::Emit::Controller {</pre>
<p>CICM::Emit::KeyStreamGenController supports creating a channel to read keystream from a module. The resulting controller is capable of managing the channel, but not reading keystream. It is created by calling CICM::ChannelManager::create_key_stream_gen_controller.</p>
<h1 id="rfc.section.16.8.1">
<a href="#rfc.section.16.8.1">16.8.1.</a> CICM::Emit::KeyStreamGenController Inheritance</h1>
<p id="rfc.section.16.8.1.p.1">CICM::Emit::KeyStreamGenController inherits from: CICM::SymKeyController, CICM::GenVectorController and CICM::Emit::Controller.</p>
<h1 id="rfc.section.16.9">
<a href="#rfc.section.16.9">16.9.</a> Interface CICM::Emit::KeyStreamGenConduit</h1>
<div id="#rfc.figure.249"></div>
<p>Interface  CICM::Emit::KeyStreamGenConduit</p>
<pre>interface KeyStreamGenConduit :
	CICM::Conduit,
	CICM::SymKeyController,
	CICM::GenVectorController,
	CICM::Emit::GetStream {</pre>
<p>CICM::Emit::KeyStreamGenConduit supports reading keystream from a module. The resulting conduit is capable of both managing the channel and reading keystream. It is created by calling CICM::ChannelManager::create_key_stream_gen_conduit.</p>
<h1 id="rfc.section.16.9.1">
<a href="#rfc.section.16.9.1">16.9.1.</a> CICM::Emit::KeyStreamGenConduit Inheritance</h1>
<p id="rfc.section.16.9.1.p.1">CICM::Emit::KeyStreamGenConduit inherits from: CICM::Conduit, CICM::SymKeyController, CICM::GenVectorController and CICM::Emit::GetStream.</p>
<h1 id="rfc.section.17">
<a href="#rfc.section.17">17.</a> <a href="#sec-answer" id="sec-answer">Data Integrity</a>
</h1>
<div id="#rfc.figure.250"></div>
<p>Namespace CICM::Answer</p>
<pre>module Answer {</pre>
<p>The CICM::Answer namespace contains interfaces that support cryptographic operations that return an "answer" such a hash or a signature within a single security domain.</p>
<h1 id="rfc.section.17.1">
<a href="#rfc.section.17.1">17.1.</a> Interface CICM::Answer::ChannelManager</h1>
<div id="#rfc.figure.251"></div>
<p>Interface  CICM::Answer::ChannelManager</p>
<pre>interface ChannelManager {</pre>
<p>CICM::Answer::ChannelManager is an abstraction inherited by CICM::ChannelManager that supports the creation of conduits to sign, MAC, and hash data. See CICM::ChannelManager for additional information.</p>
<h1 id="rfc.section.17.1.1">
<a href="#rfc.section.17.1.1">17.1.1.</a> CICM::Answer::ChannelManager Methods</h1>
<div id="#rfc.figure.252"></div>
<p>Method CICM::Answer::ChannelManager::create_hash_conduit()</p>
<pre>CICM::Status create_hash_conduit(
	in  CICM::HashAlgorithmId algorithm,
	out CICM::Answer::HashConduit conduit_ref
);</pre>
<p>Create conduit to calculate and generate a hash value.</p>
<p id="rfc.section.17.1.1.p.1">Parameters: </p>

<ul class="empty">
<li>[in] algorithm Hash algorithm.</li>
<li>[out] conduit_ref Reference to resulting conduit.</li>
</ul>

<p> </p>
<p id="rfc.section.17.1.1.p.2">Returns: </p>

<ul class="empty"><li>S_OK, S_GENERAL_ERROR, S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION, S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE, S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT, S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_ALGO_INVALID, S_ALGO_INCOMPATIBLE, S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR, S_CHANNEL_MAX</li></ul>

<p> </p>
<div id="#rfc.figure.253"></div>
<p>Method CICM::Answer::ChannelManager::create_mac_conduit()</p>
<pre>CICM::Status create_mac_conduit(
	in  CICM::SymKey key_ref,
	in  CICM::SymMacAlgorithmId algorithm,
	out CICM::Answer::MACConduit conduit_ref
);</pre>
<p>Create conduit to calculate and generate a MAC.</p>
<p id="rfc.section.17.1.1.p.3">Parameters: </p>

<ul class="empty">
<li>[in] key_ref Reference to MAC key.</li>
<li>[in] algorithm MAC algorithm.</li>
<li>[out] conduit_ref Reference to resulting conduit.</li>
</ul>

<p> </p>
<p id="rfc.section.17.1.1.p.4">Returns: </p>

<ul class="empty"><li>S_OK, S_GENERAL_ERROR, S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION, S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE, S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT, S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_USED_INVALID, S_KEY_USED_EXPIRED, S_KEY_USED_WRAPPED, S_KEY_USED_CONTEXT, S_KEY_INVALID, S_KEY_EXPIRED, S_ALGO_INVALID, S_ALGO_INCOMPATIBLE, S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR, S_CHANNEL_MAX</li></ul>

<p> </p>
<div id="#rfc.figure.254"></div>
<p>Method CICM::Answer::ChannelManager::create_mac_verify_conduit()</p>
<pre>CICM::Status create_mac_verify_conduit(
	in  CICM::SymKey key_ref,
	in  CICM::SymMacAlgorithmId algorithm,
	out CICM::Answer::MACVerifyConduit conduit_ref
);</pre>
<p>Create conduit to verify a MAC.</p>
<p id="rfc.section.17.1.1.p.5">Parameters: </p>

<ul class="empty">
<li>[in] key_ref Reference to verification key.</li>
<li>[in] algorithm MAC algorithm.</li>
<li>[out] conduit_ref Reference to resulting conduit.</li>
</ul>

<p> </p>
<p id="rfc.section.17.1.1.p.6">Returns: </p>

<ul class="empty"><li>S_OK, S_GENERAL_ERROR, S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION, S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE, S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT, S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_USED_INVALID, S_KEY_USED_EXPIRED, S_KEY_USED_WRAPPED, S_KEY_USED_CONTEXT, S_KEY_INVALID, S_KEY_EXPIRED, S_ALGO_INVALID, S_ALGO_INCOMPATIBLE, S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR, S_CHANNEL_MAX</li></ul>

<p> </p>
<div id="#rfc.figure.255"></div>
<p>Method CICM::Answer::ChannelManager::create_sign_conduit()</p>
<pre>CICM::Status create_sign_conduit(
	in  CICM::AsymKey key_ref,
	in  CICM::AsymSigAlgorithmId algorithm,
	out CICM::Answer::SignConduit conduit_ref
);</pre>
<p>Create conduit to calculate and generate a signature.</p>
<p id="rfc.section.17.1.1.p.7">Parameters: </p>

<ul class="empty">
<li>[in] key_ref Reference to signature key.</li>
<li>[in] algorithm Signature algorithm.</li>
<li>[out] conduit_ref Reference to resulting conduit.</li>
</ul>

<p> </p>
<p id="rfc.section.17.1.1.p.8">Returns: </p>

<ul class="empty"><li>S_OK, S_GENERAL_ERROR, S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION, S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE, S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT, S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_USED_INVALID, S_KEY_USED_EXPIRED, S_KEY_USED_WRAPPED, S_KEY_USED_CONTEXT, S_KEY_USED_COMPONENT_NOT_AVAIL, S_KEY_INVALID, S_KEY_EXPIRED, S_ALGO_INVALID, S_ALGO_INCOMPATIBLE, S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR, S_CHANNEL_MAX</li></ul>

<p> </p>
<div id="#rfc.figure.256"></div>
<p>Method CICM::Answer::ChannelManager::create_sign_hash_conduit()</p>
<pre>CICM::Status create_sign_hash_conduit(
	in  CICM::AsymKey key_ref,
	in  CICM::AsymSigAlgorithmId algorithm,
	out CICM::Answer::SignHashConduit conduit_ref
);</pre>
<p>Create conduit to calculate and generate a signature accepting a previously generated hash value as input.</p>
<p id="rfc.section.17.1.1.p.9">Parameters: </p>

<ul class="empty">
<li>[in] key_ref Reference to signature key.</li>
<li>[in] algorithm Signature algorithm.</li>
<li>[out] conduit_ref Reference to resulting conduit.</li>
</ul>

<p> </p>
<p id="rfc.section.17.1.1.p.10">Returns: </p>

<ul class="empty"><li>S_OK, S_GENERAL_ERROR, S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION, S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE, S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT, S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_USED_INVALID, S_KEY_USED_EXPIRED, S_KEY_USED_WRAPPED, S_KEY_USED_CONTEXT, S_KEY_USED_COMPONENT_NOT_AVAIL, S_KEY_INVALID, S_KEY_EXPIRED, S_ALGO_INVALID, S_ALGO_INCOMPATIBLE, S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR, S_CHANNEL_MAX</li></ul>

<p> </p>
<div id="#rfc.figure.257"></div>
<p>Method CICM::Answer::ChannelManager::create_verify_conduit()</p>
<pre>CICM::Status create_verify_conduit(
	in  CICM::AsymKey key_ref,
	in  CICM::AsymSigAlgorithmId algorithm,
	out CICM::Answer::VerifyConduit conduit_ref
);</pre>
<p>Create conduit to verify a signature.</p>
<p id="rfc.section.17.1.1.p.11">Parameters: </p>

<ul class="empty">
<li>[in] key_ref Reference to verification key.</li>
<li>[in] algorithm Verification algorithm.</li>
<li>[out] conduit_ref Reference to resulting conduit.</li>
</ul>

<p> </p>
<p id="rfc.section.17.1.1.p.12">Returns: </p>

<ul class="empty"><li>S_OK, S_GENERAL_ERROR, S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION, S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE, S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT, S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_USED_INVALID, S_KEY_USED_EXPIRED, S_KEY_USED_WRAPPED, S_KEY_USED_CONTEXT, S_KEY_USED_COMPONENT_NOT_AVAIL, S_KEY_INVALID, S_KEY_EXPIRED, S_ALGO_INVALID, S_ALGO_INCOMPATIBLE, S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR, S_CHANNEL_MAX</li></ul>

<p> </p>
<div id="#rfc.figure.258"></div>
<p>Method CICM::Answer::ChannelManager::create_verify_hash_conduit()</p>
<pre>CICM::Status create_verify_hash_conduit(
	in  CICM::AsymKey key_ref,
	in  CICM::AsymSigAlgorithmId algorithm,
	out CICM::Answer::VerifyHashConduit conduit_ref
);</pre>
<p>Create conduit to verify a signature accepting a previously generated hash value as input.</p>
<p id="rfc.section.17.1.1.p.13">Parameters: </p>

<ul class="empty">
<li>[in] key_ref Reference to verification key.</li>
<li>[in] algorithm Verification algorithm.</li>
<li>[out] conduit_ref Reference to resulting conduit.</li>
</ul>

<p> </p>
<p id="rfc.section.17.1.1.p.14">Returns: </p>

<ul class="empty"><li>S_OK, S_GENERAL_ERROR, S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION, S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE, S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT, S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_USED_INVALID, S_KEY_USED_EXPIRED, S_KEY_USED_WRAPPED, S_KEY_USED_CONTEXT, S_KEY_USED_COMPONENT_NOT_AVAIL, S_KEY_INVALID, S_KEY_EXPIRED, S_ALGO_INVALID, S_ALGO_INCOMPATIBLE, S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR, S_CHANNEL_MAX</li></ul>

<p> </p>
<h1 id="rfc.section.17.2">
<a href="#rfc.section.17.2">17.2.</a> Interface CICM::Answer::PutStream</h1>
<div id="#rfc.figure.259"></div>
<p>Interface CICM::Answer::PutStream</p>
<pre>interface PutStream : CICM::Stream {</pre>
<p>A stream that can write data to a module.</p>
<h1 id="rfc.section.17.2.1">
<a href="#rfc.section.17.2.1">17.2.1.</a> CICM::Answer::PutStream Inheritance</h1>
<p id="rfc.section.17.2.1.p.1">CICM::Answer::PutStream inherits from: CICM::Stream.</p>
<h1 id="rfc.section.17.2.2">
<a href="#rfc.section.17.2.2">17.2.2.</a> CICM::Answer::PutStream Methods</h1>
<div id="#rfc.figure.260"></div>
<p>Method CICM::Answer::PutStream::put()</p>
<pre>CICM::Status put(
	in  CICM::Buffer buffer
);</pre>
<p>Sends data to the module for transformation.</p>
<p id="rfc.section.17.2.2.p.1">Remarks: </p>

<ul class="empty"><li>This method blocks until the data is sent to the module.</li></ul>

<p> </p>
<p id="rfc.section.17.2.2.p.2">Parameters: </p>

<ul class="empty"><li>[in] buffer Buffer to write to the module.</li></ul>

<p> </p>
<p id="rfc.section.17.2.2.p.3">Returns: </p>

<ul class="empty"><li>S_OK, S_GENERAL_ERROR, S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION, S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE, S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT, S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_INVALID, S_KEY_EXPIRED, S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR, S_CHANNEL_IO_ERROR, S_CHANNEL_DATA_INVALID, S_CHANNEL_DATA_INVALID_LEN</li></ul>

<p> </p>
<h1 id="rfc.section.17.3">
<a href="#rfc.section.17.3">17.3.</a> Interface CICM::Answer::HashConduit</h1>
<div id="#rfc.figure.261"></div>
<p>Interface CICM::Answer::HashConduit</p>
<pre>interface HashConduit :
	CICM::Conduit,
	CICM::Answer::PutStream {</pre>
<p>CICM::Answer::HashConduit supports hashing operations within a single security domain. It is created by calling CICM::ChannelManager::create_hash_conduit.</p>
<p id="rfc.section.17.3.p.1">Remarks: </p>

<ul class="empty"><li>Keyed hashes are supported by MAC channels.</li></ul>

<p> </p>
<h1 id="rfc.section.17.3.1">
<a href="#rfc.section.17.3.1">17.3.1.</a> CICM::Answer::HashConduit Inheritance</h1>
<p id="rfc.section.17.3.1.p.1">CICM::Answer::HashConduit inherits from: CICM::Conduit and CICM::Answer::PutStream.</p>
<h1 id="rfc.section.17.3.2">
<a href="#rfc.section.17.3.2">17.3.2.</a> CICM::Answer::HashConduit Attributes</h1>
<div id="#rfc.figure.262"></div>
<p>AttributeCICM::Answer::HashConduit::algorithm</p>
<pre>readonly attribute CICM::HashAlgorithmId algorithm;</pre>
<p>Algorithm used to compute the hash.</p>
<h1 id="rfc.section.17.3.3">
<a href="#rfc.section.17.3.3">17.3.3.</a> CICM::Answer::HashConduit Methods</h1>
<div id="#rfc.figure.263"></div>
<p>Method CICM::Answer::HashConduit::end_get_hash()</p>
<pre>CICM::Status end_get_hash(
	out HashBuffer hash
);</pre>
<p>Direct the module to compute and output the message digest value, and reset the conduit to accept additional data.</p>
<p id="rfc.section.17.3.3.p.1">Parameters: </p>

<ul class="empty"><li>[out] hash Resulting hash.</li></ul>

<p> </p>
<p id="rfc.section.17.3.3.p.2">Returns: </p>

<ul class="empty"><li>S_OK, S_GENERAL_ERROR, S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION, S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE, S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT, S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR</li></ul>

<p> </p>
<h1 id="rfc.section.17.4">
<a href="#rfc.section.17.4">17.4.</a> Interface CICM::Answer::MACConduit</h1>
<div id="#rfc.figure.264"></div>
<p>Interface CICM::Answer::MACConduit</p>
<pre>interface MACConduit :
	CICM::AbstractMACConduit,
	CICM::Answer::PutStream {</pre>
<p>CICM::Answer::MACConduit supports message authentication code operations within a single security domain. It is created by calling CICM::ChannelManager::create_mac_conduit.</p>
<h1 id="rfc.section.17.4.1">
<a href="#rfc.section.17.4.1">17.4.1.</a> CICM::Answer::MACConduit Inheritance</h1>
<p id="rfc.section.17.4.1.p.1">CICM::Answer::MACConduit inherits from: CICM::AbstractMACConduit and CICM::Answer::PutStream.</p>
<h1 id="rfc.section.17.5">
<a href="#rfc.section.17.5">17.5.</a> Interface CICM::Answer::MACVerifyConduit</h1>
<div id="#rfc.figure.265"></div>
<p>Interface  CICM::Answer::MACVerifyConduit</p>
<pre>interface MACVerifyConduit :
	CICM::AbstractMACVerifyConduit,
	CICM::Answer::PutStream {</pre>
<p>CICM::Answer::MACVerifyConduit supports message authentication code verification operations within a single security domain. It is created by calling CICM::ChannelManager::create_mac_verify_conduit.</p>
<h1 id="rfc.section.17.5.1">
<a href="#rfc.section.17.5.1">17.5.1.</a> CICM::Answer::MACVerifyConduit Inheritance</h1>
<p id="rfc.section.17.5.1.p.1">CICM::Answer::MACVerifyConduit inherits from: CICM::AbstractMACVerifyConduit and CICM::Answer::PutStream.</p>
<h1 id="rfc.section.17.6">
<a href="#rfc.section.17.6">17.6.</a> Interface CICM::Answer::SignConduit</h1>
<div id="#rfc.figure.266"></div>
<p>Interface CICM::Answer::SignConduit</p>
<pre>interface SignConduit :
	CICM::AbstractSignConduit,
	CICM::Answer::PutStream {</pre>
<p>CICM::Answer::SignConduit supports signature operations within a single security domain. It is created by calling CICM::ChannelManager::create_sign_conduit.</p>
<h1 id="rfc.section.17.6.1">
<a href="#rfc.section.17.6.1">17.6.1.</a> CICM::Answer::SignConduit Inheritance</h1>
<p id="rfc.section.17.6.1.p.1">CICM::Answer::SignConduit inherits from: CICM::AbstractSignConduit and CICM::Answer::PutStream.</p>
<h1 id="rfc.section.17.7">
<a href="#rfc.section.17.7">17.7.</a> Interface CICM::Answer::SignHashConduit</h1>
<div id="#rfc.figure.267"></div>
<p>Interface  CICM::Answer::SignHashConduit</p>
<pre>interface SignHashConduit : CICM::Answer::SignConduit {};</pre>
<p>CICM::Answer::SignHashConduit supports signature operations accepting a pre-generated hash value within a single security domain. It is created by calling CICM::ChannelManager::create_sign_hash_conduit.</p>
<h1 id="rfc.section.17.7.1">
<a href="#rfc.section.17.7.1">17.7.1.</a> CICM::Answer::SignHashConduit Inheritance</h1>
<p id="rfc.section.17.7.1.p.1">CICM::Answer::SignHashConduit inherits from: CICM::Answer::SignConduit.</p>
<h1 id="rfc.section.17.8">
<a href="#rfc.section.17.8">17.8.</a> Interface CICM::Answer::VerifyConduit</h1>
<div id="#rfc.figure.268"></div>
<p>Interface CICM::Answer::VerifyConduit</p>
<pre>interface VerifyConduit :
	CICM::AbstractSigVerifyConduit,
	CICM::Answer::PutStream {</pre>
<p>CICM::Answer::VerifyConduit supports verification operations within a single security domain. It is created by calling CICM::ChannelManager::create_verify_conduit.</p>
<h1 id="rfc.section.17.8.1">
<a href="#rfc.section.17.8.1">17.8.1.</a> CICM::Answer::VerifyConduit Inheritance</h1>
<p id="rfc.section.17.8.1.p.1">CICM::Answer::VerifyConduit inherits from: CICM::AbstractSigVerifyConduit and CICM::Answer::PutStream.</p>
<h1 id="rfc.section.17.9">
<a href="#rfc.section.17.9">17.9.</a> Interface CICM::Answer::VerifyHashConduit</h1>
<div id="#rfc.figure.269"></div>
<p>Interface  CICM::Answer::VerifyHashConduit</p>
<pre>interface VerifyHashConduit : CICM::Answer::VerifyConduit {};</pre>
<p>CICM::Answer::VerifyHashConduit supports verification operations accepting a pre-generated hash value within a single security domain. It is created by calling CICM::ChannelManager::create_verify_hash_conduit.</p>
<h1 id="rfc.section.17.9.1">
<a href="#rfc.section.17.9.1">17.9.1.</a> CICM::Answer::VerifyHashConduit Inheritance</h1>
<p id="rfc.section.17.9.1.p.1">CICM::Answer::VerifyHashConduit inherits from: CICM::Answer::VerifyConduit.</p>
<h1 id="rfc.section.18">
<a href="#rfc.section.18">18.</a> <a href="#sec-coprocessor" id="sec-coprocessor">Single-Domain</a>
</h1>
<div id="#rfc.figure.270"></div>
<p>Namespace CICM::Coprocessor</p>
<pre>module Coprocessor {</pre>
<p>The CICM::Coprocessor namespace contains interfaces that support encryption/decryption operations within a single security domain.</p>
<h1 id="rfc.section.18.1">
<a href="#rfc.section.18.1">18.1.</a> Interface CICM::Coprocessor::ChannelManager</h1>
<div id="#rfc.figure.271"></div>
<p>Interface  CICM::Coprocessor::ChannelManager</p>
<pre>interface ChannelManager {</pre>
<p>CICM::Coprocessor::ChannelManager is an abstraction inherited by CICM::ChannelManager that supports the creation of conduits to encrypt and decrypt data within a single security domain. See CICM::ChannelManager for additional information.</p>
<h1 id="rfc.section.18.1.1">
<a href="#rfc.section.18.1.1">18.1.1.</a> CICM::Coprocessor::ChannelManager Methods</h1>
<div id="#rfc.figure.272"></div>
<p>Method CICM::Coprocessor::ChannelManager::create_coprocessor_encrypt_conduit()</p>
<pre>CICM::Status create_coprocessor_encrypt_conduit(
	in  CICM::SymKey key_ref,
	in  CICM::SymEncrAlgorithmId algorithm,
	out CICM::Coprocessor::EncryptConduit conduit_ref
);</pre>
<p>Create conduit to encrypt a stream of data within a single security domain.</p>
<p id="rfc.section.18.1.1.p.1">Parameters: </p>

<ul class="empty">
<li>[in] key_ref Reference to encryption key.</li>
<li>[in] algorithm Encryption algorithm/mode.</li>
<li>[out] conduit_ref Reference to resulting conduit.</li>
</ul>

<p> </p>
<p id="rfc.section.18.1.1.p.2">Returns: </p>

<ul class="empty"><li>S_OK, S_GENERAL_ERROR, S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION, S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE, S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT, S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_USED_INVALID, S_KEY_USED_EXPIRED, S_KEY_USED_WRAPPED, S_KEY_USED_CONTEXT, S_KEY_INVALID, S_KEY_EXPIRED, S_ALGO_INVALID, S_ALGO_INCOMPATIBLE, S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR, S_CHANNEL_MAX</li></ul>

<p> </p>
<div id="#rfc.figure.273"></div>
<p>Method CICM::Coprocessor::ChannelManager::create_coprocessor_encrypt_with_mac_conduit()</p>
<pre>CICM::Status create_coprocessor_encrypt_with_mac_conduit(
	in  CICM::SymKey mac_key_ref,
	in  CICM::SymKey encrypt_key_ref,
	in  CICM::SymMacAlgorithmId mac_algorithm,
	in  CICM::SymEncrAlgorithmId encrypt_algorithm,
	out CICM::Coprocessor::EncryptWithMACConduit conduit_ref
);</pre>
<p>Create conduit to MAC and encrypt a stream of data within a single security domain.</p>
<p id="rfc.section.18.1.1.p.3">Parameters: </p>

<ul class="empty">
<li>[in] mac_key_ref Reference to MAC key.</li>
<li>[in] encrypt_key_ref Reference to encryption key.</li>
<li>[in] mac_algorithm MAC algorithm.</li>
<li>[in] encrypt_algorithm Encryption algorithm/mode.</li>
<li>[out] conduit_ref Reference to resulting conduit.</li>
</ul>

<p> </p>
<p id="rfc.section.18.1.1.p.4">Returns: </p>

<ul class="empty"><li>S_OK, S_GENERAL_ERROR, S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION, S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE, S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT, S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_USED_INVALID, S_KEY_USED_EXPIRED, S_KEY_USED_WRAPPED, S_KEY_USED_CONTEXT, S_KEY_INVALID, S_KEY_EXPIRED, S_ALGO_INVALID, S_ALGO_INCOMPATIBLE, S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR, S_CHANNEL_MAX</li></ul>

<p> </p>
<div id="#rfc.figure.274"></div>
<p>Method CICM::Coprocessor::ChannelManager::create_coprocessor_encrypt_with_sign_conduit()</p>
<pre>CICM::Status create_coprocessor_encrypt_with_sign_conduit(
	in  CICM::AsymKey sign_key_ref,
	in  CICM::SymKey encrypt_key_ref,
	in  CICM::AsymSigAlgorithmId sign_algorithm,
	in  CICM::SymEncrAlgorithmId encrypt_algorithm,
	out CICM::Coprocessor::EncryptWithSignConduit conduit_ref
);</pre>
<p>Create conduit to sign and encrypt a stream of data within a single security domain.</p>
<p id="rfc.section.18.1.1.p.5">Parameters: </p>

<ul class="empty">
<li>[in] sign_key_ref Reference to signature key.</li>
<li>[in] encrypt_key_ref Reference to encryption key.</li>
<li>[in] sign_algorithm Signature algorithm.</li>
<li>[in] encrypt_algorithm Encryption algorithm/mode.</li>
<li>[out] conduit_ref Reference to resulting conduit.</li>
</ul>

<p> </p>
<p id="rfc.section.18.1.1.p.6">Returns: </p>

<ul class="empty"><li>S_OK, S_GENERAL_ERROR, S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION, S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE, S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT, S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_USED_INVALID, S_KEY_USED_EXPIRED, S_KEY_USED_WRAPPED, S_KEY_USED_CONTEXT, S_KEY_USED_COMPONENT_NOT_AVAIL, S_KEY_INVALID, S_KEY_EXPIRED, S_ALGO_INVALID, S_ALGO_INCOMPATIBLE, S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR, S_CHANNEL_MAX</li></ul>

<p> </p>
<div id="#rfc.figure.275"></div>
<p>Method CICM::Coprocessor::ChannelManager::create_coprocessor_decrypt_conduit()</p>
<pre>CICM::Status create_coprocessor_decrypt_conduit(
	in  CICM::SymKey key_ref,
	in  CICM::SymEncrAlgorithmId algorithm,
	out CICM::Coprocessor::DecryptConduit conduit_ref
);</pre>
<p>Create conduit to decrypt a stream of data within a single security domain.</p>
<p id="rfc.section.18.1.1.p.7">Parameters: </p>

<ul class="empty">
<li>[in] key_ref Reference to decryption key.</li>
<li>[in] algorithm Decryption algorithm/mode.</li>
<li>[out] conduit_ref Reference to resulting conduit.</li>
</ul>

<p> </p>
<p id="rfc.section.18.1.1.p.8">Returns: </p>

<ul class="empty"><li>S_OK, S_GENERAL_ERROR, S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION, S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE, S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT, S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_USED_INVALID, S_KEY_USED_EXPIRED, S_KEY_USED_WRAPPED, S_KEY_USED_CONTEXT, S_KEY_INVALID, S_KEY_EXPIRED, S_ALGO_INVALID, S_ALGO_INCOMPATIBLE, S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR, S_CHANNEL_MAX</li></ul>

<p> </p>
<div id="#rfc.figure.276"></div>
<p>Method CICM::Coprocessor::ChannelManager::create_coprocessor_decrypt_with_mac_conduit()</p>
<pre>CICM::Status create_coprocessor_decrypt_with_mac_conduit(
	in  CICM::SymKey mac_key_ref,
	in  CICM::SymKey decrypt_key_ref,
	in  CICM::SymMacAlgorithmId mac_algorithm,
	in  CICM::SymEncrAlgorithmId encrypt_algorithm,
	out CICM::Coprocessor::DecryptWithMACConduit conduit_ref
);</pre>
<p>Create conduit to MAC verify and decrypt a stream of data within a single security domain.</p>
<p id="rfc.section.18.1.1.p.9">Parameters: </p>

<ul class="empty">
<li>[in] mac_key_ref Reference to MAC key.</li>
<li>[in] decrypt_key_ref Reference to decryption key.</li>
<li>[in] mac_algorithm MAC algorithm.</li>
<li>[in] encrypt_algorithm Encryption algorithm/mode.</li>
<li>[out] conduit_ref Reference to resulting conduit.</li>
</ul>

<p> </p>
<p id="rfc.section.18.1.1.p.10">Returns: </p>

<ul class="empty"><li>S_OK, S_GENERAL_ERROR, S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION, S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE, S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT, S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_USED_INVALID, S_KEY_USED_EXPIRED, S_KEY_USED_WRAPPED, S_KEY_USED_CONTEXT, S_KEY_INVALID, S_KEY_EXPIRED, S_ALGO_INVALID, S_ALGO_INCOMPATIBLE, S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR, S_CHANNEL_MAX</li></ul>

<p> </p>
<div id="#rfc.figure.277"></div>
<p>Method CICM::Coprocessor::ChannelManager::create_coprocessor_decrypt_with_verify_conduit()</p>
<pre>CICM::Status create_coprocessor_decrypt_with_verify_conduit(
	in  CICM::AsymKey verify_key_ref,
	in  CICM::SymKey decrypt_key_ref,
	in  CICM::AsymSigAlgorithmId verify_algorithm,
	in  CICM::SymEncrAlgorithmId decrypt_algorithm,
	out CICM::Coprocessor::DecryptWithVerifyConduit conduit_ref
);</pre>
<p>Create conduit to verify and decrypt a stream of data within a single security domain.</p>
<p id="rfc.section.18.1.1.p.11">Parameters: </p>

<ul class="empty">
<li>[in] verify_key_ref Reference to verification key.</li>
<li>[in] decrypt_key_ref Reference to decryption key.</li>
<li>[in] verify_algorithm Verification algorithm.</li>
<li>[in] decrypt_algorithm Decryption algorithm/mode.</li>
<li>[out] conduit_ref Reference to resulting conduit.</li>
</ul>

<p> </p>
<p id="rfc.section.18.1.1.p.12">Returns: </p>

<ul class="empty"><li>S_OK, S_GENERAL_ERROR, S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION, S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE, S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT, S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_USED_INVALID, S_KEY_USED_EXPIRED, S_KEY_USED_WRAPPED, S_KEY_USED_CONTEXT, S_KEY_USED_COMPONENT_NOT_AVAIL, S_KEY_INVALID, S_KEY_EXPIRED, S_ALGO_INVALID, S_ALGO_INCOMPATIBLE, S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR, S_CHANNEL_MAX</li></ul>

<p> </p>
<h1 id="rfc.section.18.2">
<a href="#rfc.section.18.2">18.2.</a> Interface CICM::Coprocessor::Stream</h1>
<div id="#rfc.figure.278"></div>
<p>Interface CICM::Coprocessor::Stream</p>
<pre>interface Stream : CICM::Stream {</pre>
<p>CICM::Coprocessor::Stream is an abstraction inherited by all conduits in the CICM::Coprocessor namespace.</p>
<h1 id="rfc.section.18.2.1">
<a href="#rfc.section.18.2.1">18.2.1.</a> CICM::Coprocessor::Stream Inheritance</h1>
<p id="rfc.section.18.2.1.p.1">CICM::Coprocessor::Stream inherits from: CICM::Stream.</p>
<h1 id="rfc.section.18.2.2">
<a href="#rfc.section.18.2.2">18.2.2.</a> CICM::Coprocessor::Stream Methods</h1>
<div id="#rfc.figure.279"></div>
<p>Method CICM::Coprocessor::Stream::get_final_buffer()</p>
<pre>CICM::Status get_final_buffer(
	out CICM::Buffer buffer
);</pre>
<p>Returns the final block of transformed data, if available.  The method blocks until data becomes available.</p>
<p id="rfc.section.18.2.2.p.1">Remarks: </p>

<ul class="empty"><li>In certain cases, it may be necessary to retrieve the last transformed block of data, if, for example, a partial block remains after the last full block was retrieved. This call MUST be called after all data is supplied to the module and MUST precede any end_get_* calls.</li></ul>

<p> </p>
<p id="rfc.section.18.2.2.p.2">Parameters: </p>

<ul class="empty"><li>[out] buffer Buffer of data read from stream.</li></ul>

<p> </p>
<p id="rfc.section.18.2.2.p.3">Returns: </p>

<ul class="empty"><li>S_OK, S_GENERAL_ERROR, S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION, S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE, S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT, S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_INVALID, S_KEY_EXPIRED, S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT</li></ul>

<p> </p>
<h1 id="rfc.section.18.3">
<a href="#rfc.section.18.3">18.3.</a> Interface CICM::Coprocessor::EncryptConduit</h1>
<div id="#rfc.figure.280"></div>
<p>Interface  CICM::Coprocessor::EncryptConduit</p>
<pre>interface EncryptConduit :
	CICM::Conduit,
	CICM::SymKeyController,
	CICM::GenVectorController,
	CICM::ResyncController,
	CICM::Coprocessor::Stream {</pre>
<p>CICM::Coprocessor::EncryptConduit supports encryption operations within a single security domain. The resulting conduit is capable of managing the channel, accepting data for transformation, and receiving the result. It is created by calling CICM::ChannelManager::create_coprocessor_encrypt_conduit.</p>
<h1 id="rfc.section.18.3.1">
<a href="#rfc.section.18.3.1">18.3.1.</a> CICM::Coprocessor::EncryptConduit Inheritance</h1>
<p id="rfc.section.18.3.1.p.1">CICM::Coprocessor::EncryptConduit inherits from: CICM::Conduit, CICM::SymKeyController, CICM::GenVectorController, CICM::ResyncController and CICM::Coprocessor::Stream.</p>
<h1 id="rfc.section.18.3.2">
<a href="#rfc.section.18.3.2">18.3.2.</a> CICM::Coprocessor::EncryptConduit Methods</h1>
<div id="#rfc.figure.281"></div>
<p>Method CICM::Coprocessor::EncryptConduit::encrypt()</p>
<pre>CICM::Status encrypt(
	in  CICM::Buffer plaintext,
	out CICM::Buffer ciphertext
);</pre>
<p>Send plaintext to the module to be encrypted, receiving the ciphertext resulting from the transformation as the result.</p>
<p id="rfc.section.18.3.2.p.1">Parameters: </p>

<ul class="empty">
<li>[in] plaintext Plaintext to encrypt.</li>
<li>[out] ciphertext Ciphertext resulting from encryption operation.</li>
</ul>

<p> </p>
<p id="rfc.section.18.3.2.p.2">Returns: </p>

<ul class="empty"><li>S_OK, S_GENERAL_ERROR, S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION, S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE, S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT, S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR, S_CHANNEL_IO_ERROR, S_CHANNEL_DATA_INVALID, S_CHANNEL_DATA_INVALID_LEN, S_CHANNEL_BUFFER_LEN</li></ul>

<p> </p>
<h1 id="rfc.section.18.4">
<a href="#rfc.section.18.4">18.4.</a> Interface CICM::Coprocessor::EncryptWithMACConduit</h1>
<div id="#rfc.figure.282"></div>
<p>Interface  CICM::Coprocessor::EncryptWithMACConduit</p>
<pre>interface EncryptWithMACConduit :
	CICM::AbstractMACConduit,
	CICM::Coprocessor::EncryptConduit {</pre>
<p>CICM::Coprocessor::EncryptWithMACConduit supports encryption with MAC operations within a single security domain. The resulting conduit is capable of managing the channel, accepting data for transformation, and receiving the result (both ciphertext and a MAC value). It is created by calling CICM::ChannelManager::create_coprocessor_encrypt_with_mac_conduit.</p>
<h1 id="rfc.section.18.4.1">
<a href="#rfc.section.18.4.1">18.4.1.</a> CICM::Coprocessor::EncryptWithMACConduit Inheritance</h1>
<p id="rfc.section.18.4.1.p.1">CICM::Coprocessor::EncryptWithMACConduit inherits from: CICM::AbstractMACConduit and CICM::Coprocessor::EncryptConduit.</p>
<h1 id="rfc.section.18.5">
<a href="#rfc.section.18.5">18.5.</a> Interface CICM::Coprocessor::EncryptWithSignConduit</h1>
<div id="#rfc.figure.283"></div>
<p>Interface  CICM::Coprocessor::EncryptWithSignConduit</p>
<pre>interface EncryptWithSignConduit :
	CICM::AbstractSignConduit,
	CICM::Coprocessor::EncryptConduit {</pre>
<p>CICM::Coprocessor::EncryptWithSignConduit supports encryption with signature operations within a single security domain. The resulting conduit is capable of managing the channel, accepting data for transformation, and receiving the result (both ciphertext and a signature). It is created by calling CICM::ChannelManager::create_coprocessor_encrypt_with_sign_conduit.</p>
<h1 id="rfc.section.18.5.1">
<a href="#rfc.section.18.5.1">18.5.1.</a> CICM::Coprocessor::EncryptWithSignConduit Inheritance</h1>
<p id="rfc.section.18.5.1.p.1">CICM::Coprocessor::EncryptWithSignConduit inherits from: CICM::AbstractSignConduit and CICM::Coprocessor::EncryptConduit.</p>
<h1 id="rfc.section.18.6">
<a href="#rfc.section.18.6">18.6.</a> Interface CICM::Coprocessor::DecryptConduit</h1>
<div id="#rfc.figure.284"></div>
<p>Interface  CICM::Coprocessor::DecryptConduit</p>
<pre>interface DecryptConduit :
	CICM::Conduit,
	CICM::SymKeyController,
	CICM::SetVectorController,
	CICM::ResyncController,
	CICM::Coprocessor::Stream {</pre>
<p>CICM::Coprocessor::DecryptConduit supports decryption operations within a single security domain. The resulting conduit is capable of managing the channel, accepting data for transformation, and receiving the result. It is created by calling CICM::ChannelManager::create_coprocessor_decrypt_conduit.</p>
<h1 id="rfc.section.18.6.1">
<a href="#rfc.section.18.6.1">18.6.1.</a> CICM::Coprocessor::DecryptConduit Inheritance</h1>
<p id="rfc.section.18.6.1.p.1">CICM::Coprocessor::DecryptConduit inherits from: CICM::Conduit, CICM::SymKeyController, CICM::SetVectorController, CICM::ResyncController and CICM::Coprocessor::Stream.</p>
<h1 id="rfc.section.18.6.2">
<a href="#rfc.section.18.6.2">18.6.2.</a> CICM::Coprocessor::DecryptConduit Methods</h1>
<div id="#rfc.figure.285"></div>
<p>Method CICM::Coprocessor::DecryptConduit::decrypt()</p>
<pre>CICM::Status decrypt(
	in  CICM::Buffer ciphertext,
	out CICM::Buffer plaintext
);</pre>
<p>Send ciphertext to the module to be decrypted, receiving the plaintext resulting from the transformation as the result.</p>
<p id="rfc.section.18.6.2.p.1">Parameters: </p>

<ul class="empty">
<li>[in] ciphertext Ciphertext to decrypt.</li>
<li>[out] plaintext Plaintext resulting from decryption operation.</li>
</ul>

<p> </p>
<p id="rfc.section.18.6.2.p.2">Returns: </p>

<ul class="empty"><li>S_OK, S_GENERAL_ERROR, S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION, S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE, S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT, S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR, S_CHANNEL_IO_ERROR, S_CHANNEL_DATA_INVALID, S_CHANNEL_DATA_INVALID_LEN, S_CHANNEL_BUFFER_LEN</li></ul>

<p> </p>
<h1 id="rfc.section.18.7">
<a href="#rfc.section.18.7">18.7.</a> Interface CICM::Coprocessor::DecryptWithMACConduit</h1>
<div id="#rfc.figure.286"></div>
<p>Interface  CICM::Coprocessor::DecryptWithMACConduit</p>
<pre>interface DecryptWithMACConduit :
	CICM::AbstractMACVerifyConduit,
	CICM::Coprocessor::DecryptConduit {</pre>
<p>CICM::Coprocessor::DecryptWithMACConduit supports encryption with MAC verification operations within a single security domain.  The resulting conduit is capable of managing the channel, accepting data for transformation, and receiving the result (both plaintext and an indication as to whether verification succeeded or failed).  It is created by calling CICM::ChannelManager::create_coprocessor_decrypt_with_mac_conduit.</p>
<h1 id="rfc.section.18.7.1">
<a href="#rfc.section.18.7.1">18.7.1.</a> CICM::Coprocessor::DecryptWithMACConduit Inheritance</h1>
<p id="rfc.section.18.7.1.p.1">CICM::Coprocessor::DecryptWithMACConduit inherits from: CICM::AbstractMACVerifyConduit and CICM::Coprocessor::DecryptConduit.</p>
<h1 id="rfc.section.18.8">
<a href="#rfc.section.18.8">18.8.</a> Interface CICM::Coprocessor::DecryptWithVerifyConduit</h1>
<div id="#rfc.figure.287"></div>
<p>Interface  CICM::Coprocessor::DecryptWithVerifyConduit</p>
<pre>interface DecryptWithVerifyConduit :
CICM::AbstractSigVerifyConduit,
CICM::Coprocessor::DecryptConduit {</pre>
<p>CICM::Coprocessor::DecryptWithVerifyConduit supports encryption with signature verification operations within a single security domain. The resulting conduit is capable of managing the channel, accepting data for transformation, and receiving the result (both plaintext and an indication as to whether verification succeeded or failed). It is created by calling CICM::ChannelManager::create_coprocessor_decrypt_with_verify_conduit.</p>
<h1 id="rfc.section.18.8.1">
<a href="#rfc.section.18.8.1">18.8.1.</a> CICM::Coprocessor::DecryptWithVerifyConduit Inheritance</h1>
<p id="rfc.section.18.8.1.p.1">CICM::Coprocessor::DecryptWithVerifyConduit inherits from: CICM::AbstractSigVerifyConduit and CICM::Coprocessor::DecryptConduit.</p>
<h1 id="rfc.section.19">
<a href="#rfc.section.19">19.</a> Channel Events</h1>
<h1 id="rfc.section.19.1">
<a href="#rfc.section.19.1">19.1.</a> Interface CICM::ChannelEventManager</h1>
<div id="#rfc.figure.288"></div>
<p>Interface CICM::ChannelEventManager</p>
<pre>interface ChannelEventManager {</pre>
<p>CICM::ChannelEventManager supports registering and unregistering user-defined channel event listeners (CICM::ChannelEventListener) for specific channel events. It is accessed from any channel via its CICM::Channel::event_manager attribute.</p>
<p id="rfc.section.19.1.p.1">Remarks: </p>

<ul class="empty"><li>In certain cases it may be necessary for a channel to asynchronously notify a client program of an event. Client programs can register to receive channel notifications using CICM::ChannelEventManager. This manager enables a client program to register a listener (callback) method designed to handle a specific condition. The event method prototype provided by the client program is defined in CICM::ChannelEventListener. CICM::ChannelEventListener also defines the conditions that may result in a notification, including: channel failure or channel destruction.</li></ul>

<p> </p>
<h1 id="rfc.section.19.1.1">
<a href="#rfc.section.19.1.1">19.1.1.</a> CICM::ChannelEventManager Methods</h1>
<div id="#rfc.figure.289"></div>
<p>Method CICM::ChannelEventManager::register()</p>
<pre>CICM::Status register(
	in  CICM::ChannelEventListener::ChannelEvent event,
	in  CICM::ChannelEventListener listener
);</pre>
<p>Registers the listener for a specific channel event.</p>
<p id="rfc.section.19.1.1.p.1">Remarks: </p>

<ul class="empty"><li>The provided listener applies only to the client program from which the registration is initiated.</li></ul>

<p> </p>
<p id="rfc.section.19.1.1.p.2">Parameters: </p>

<ul class="empty">
<li>[in] event Event for which this listener is being registered.</li>
<li>[in] listener Listener that will receive a notification about the specified event.</li>
</ul>

<p> </p>
<p id="rfc.section.19.1.1.p.3">Returns: </p>

<ul class="empty"><li>S_OK, S_GENERAL_ERROR, S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_HOST_RESOURCES, S_INVALID_STATE, S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT, S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT, S_EVENT_REGISTERED, S_EVENT_NOT_SUPPORTED</li></ul>

<p> </p>
<div id="#rfc.figure.290"></div>
<p>Method CICM::ChannelEventManager::unregister()</p>
<pre>CICM::Status unregister(
	in  CICM::ChannelEventListener::ChannelEvent event
);</pre>
<p>Unregisters the listener associated with the specified event.</p>
<p id="rfc.section.19.1.1.p.4">Remarks: </p>

<ul class="empty"><li>The listener associated with the specified event is only unregistered from the client program from which this method is called.</li></ul>

<p> </p>
<p id="rfc.section.19.1.1.p.5">Parameters: </p>

<ul class="empty"><li>[in] event Event that will no longer have a listener associated with it.</li></ul>

<p> </p>
<p id="rfc.section.19.1.1.p.6">Returns: </p>

<ul class="empty"><li>S_OK, S_GENERAL_ERROR, S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_HOST_RESOURCES, S_INVALID_STATE, S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT, S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT, S_EVENT_NOT_REGISTERED</li></ul>

<p> </p>
<h1 id="rfc.section.19.2">
<a href="#rfc.section.19.2">19.2.</a> Interface CICM::ChannelEventListener</h1>
<div id="#rfc.figure.291"></div>
<p>Interface CICM::ChannelEventListener</p>
<pre>interface ChannelEventListener {</pre>
<p>CICM::ChannelEventListener is unlike other CICM interfaces in that the interface is implemented by the developer of the client program to service a specific channel event and is then registered via the CICM::ChannelEventManager.</p>
<h1 id="rfc.section.19.2.1">
<a href="#rfc.section.19.2.1">19.2.1.</a> CICM::ChannelEventListener Types and Constants</h1>
<div id="#rfc.figure.292"></div>
<p>Type CICM::ChannelEventListener::ChannelEvent</p>
<pre>typedef CICM::UInt32 ChannelEvent;</pre>
<p>Events for which a ChannelEventListener can be notified.</p>
<div id="#rfc.figure.293"></div>
<p>Constant CICM::ChannelEventListener::C_CHANNEL_DATA_AVAILABLE</p>
<pre>const CICM::ChannelEventListener::ChannelEvent
	C_CHANNEL_DATA_AVAILABLE = 0x00004001;</pre>
<p>Data from remote peer is available.</p>
<div id="#rfc.figure.294"></div>
<p>Constant CICM::ChannelEventListener::C_CHANNEL_ERROR</p>
<pre>const CICM::ChannelEventListener::ChannelEvent
	C_CHANNEL_ERROR = 0x00004002;</pre>
<p>General error has occurred on the channel.</p>
<div id="#rfc.figure.295"></div>
<p>Constant CICM::ChannelEventListener::C_CHANNEL_INSUFFICIENT_ENTROPY</p>
<pre>const CICM::ChannelEventListener::ChannelEvent
	C_CHANNEL_INSUFFICIENT_ENTROPY = 0x00004004;</pre>
<p>Insufficient entropy available on the channel.</p>
<div id="#rfc.figure.296"></div>
<p>Constant CICM::ChannelEventListener::C_CHANNEL_LOST_SYNC</p>
<pre>const CICM::ChannelEventListener::ChannelEvent
	C_CHANNEL_LOST_SYNC = 0x00004007;</pre>
<p>Cryptographic synchronization with remote peer has been lost; this may not be detectable by the cryptographic module.</p>
<div id="#rfc.figure.297"></div>
<p>Constant CICM::ChannelEventListener::C_CHANNEL_PEER_RESET</p>
<pre>const CICM::ChannelEventListener::ChannelEvent
	C_CHANNEL_PEER_RESET = 0x00004008;</pre>
<p>Remote peer is no longer available; this may not be detectable by the cryptographic module.</p>
<h1 id="rfc.section.19.2.2">
<a href="#rfc.section.19.2.2">19.2.2.</a> CICM::ChannelEventListener Methods</h1>
<div id="#rfc.figure.298"></div>
<p>Method CICM::ChannelEventListener::event_occurred()</p>
<pre> void event_occurred(
	in  CICM::ChannelEventListener::ChannelEvent event,
	in  CICM::Buffer event_data
);</pre>
<p>Method implemented by client program that receives a message about a channel event that occurred. An opaque data field with additional information about the event in a module-specific format may optionally be provided with the event itself.</p>
<p id="rfc.section.19.2.2.p.1">Remarks: </p>

<ul class="empty"><li>The format of the event data value is not defined by CICM.  The Implementation Conformance Statement (see Conformance and Extensions in <a href="#CICM">[CICM]</a>) MUST reference a standard format or define a module-specific format for this datatype.</li></ul>

<p> </p>
<p id="rfc.section.19.2.2.p.2">Note: </p>

<ul class="empty"><li>Because this method is called by the runtime system and not a client program, it does not return a status value.</li></ul>

<p> </p>
<p id="rfc.section.19.2.2.p.3">Parameters: </p>

<ul class="empty">
<li>[in] event Event that occurred.</li>
<li>[in] event_data Opaque data associated with the event.</li>
</ul>

<p> </p>
<h1 id="rfc.section.20">
<a href="#rfc.section.20">20.</a> Channel Groups</h1>
<h1 id="rfc.section.20.1">
<a href="#rfc.section.20.1">20.1.</a> Interface CICM::ControllerGroup</h1>
<div id="#rfc.figure.299"></div>
<p>Interface CICM::ControllerGroup</p>
<pre>interface ControllerGroup {</pre>
<p>Group of controllers and/or conduits.</p>
<p id="rfc.section.20.1.p.1">Remarks: </p>

<ul class="empty"><li>All of the controllers in a controller group share certain characteristics, such as a state vector. Whenever a shared characteristic is changed on a member of the group, the change is applied to all members of the group. Thus, if a client program has grouped controllers/conduits to follow advancing TOD rules, for example, when one controller/conduit performs an operation at time X as expressed in the TOD value, all other grouped controllers/conduits are prohibited from using a TOD value earlier than time X.</li></ul>

<p> </p>
<h1 id="rfc.section.20.1.1">
<a href="#rfc.section.20.1.1">20.1.1.</a> CICM::ControllerGroup Methods</h1>
<div id="#rfc.figure.300"></div>
<p>Method CICM::ControllerGroup::add()</p>
<pre>CICM::Status add(
	in CICM::Controller controller_ref
);</pre>
<p>Add a controller or conduit to this controller group.</p>
<p id="rfc.section.20.1.1.p.1">Parameters: </p>

<ul class="empty"><li>[in] controller_ref Controller to add to the group.</li></ul>

<p> </p>
<p id="rfc.section.20.1.1.p.2">Returns: </p>

<ul class="empty"><li>S_OK, S_GENERAL_ERROR, S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION, S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE, S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT, S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_IN_GROUP, S_CHANNEL_CLASSIFICATION</li></ul>

<p> </p>
<h1 id="rfc.section.21">
<a href="#rfc.section.21">21.</a> IANA Considerations</h1>
<p id="rfc.section.21.p.1">[RFC Editor: Please remove this section prior to publication.]</p>
<p id="rfc.section.21.p.2">This document has no IANA actions.</p>
<h1 id="rfc.section.22">
<a href="#rfc.section.22">22.</a> Security Considerations</h1>
<h1 id="rfc.section.22.1">
<a href="#rfc.section.22.1">22.1.</a> Confidentiality</h1>
<p id="rfc.section.22.1.p.1">This document defines several channels that provide confidentiality services such encryption and decryption as defined in the CICM::Encrypt, CICM::Decrypt, CICM::Duplex, CICM::EncryptBypass, CICM::DecryptBypass, and CICM::Coprocessor namespaces. Note, however, that the CICM::EncryptBypass and CICM::DecryptBypass namespaces are capable of sending unencrypted data (see Bypass below).</p>
<h1 id="rfc.section.22.2">
<a href="#rfc.section.22.2">22.2.</a> Bypass</h1>
<p id="rfc.section.22.2.p.1">This document defines four namespaces related to sending and receiving bypass data. CICM::BypassWrite and CICM::BypassRead are for full bypass while CICM::EncryptBypass and CICM::DecryptBypass are for selective bypass.</p>
<p id="rfc.section.22.2.p.2">Unintentional sending of bypass data is typically considered a comprimise in the confidentiality of a system, and therefore implementors are urged to consider their security policies carefully.</p>
<p id="rfc.section.22.2.p.3">To mitigate against accidental programming errors related to bypass, this document ensures that: </p>

<ol>
<li>All bypass functionality is contained four clearly labeled distinct namespaces.</li>
<li>Each method that touches bypass data contains bypass as part of its name (e.g., CICM::BypassWrite::Stream::write_bypass()).</li>
</ol>

<p> </p>
<h1 id="rfc.section.22.3">
<a href="#rfc.section.22.3">22.3.</a> Data Integrity</h1>
<p id="rfc.section.22.3.p.1">This document defines several data integrity services either as stand-alone or hybrid channels. The CICM::Answer namespace contains channels for hashing, signing, and verifying signed data. Similarly, CICM::Encrypt, CICM::Decrypt, CICM::Coprocessor have channels that, in addition to encrypting or decrypting, sign or verify the transmitted data.</p>
<h1 id="rfc.section.22.4">
<a href="#rfc.section.22.4">22.4.</a> Peer Entity Authentication</h1>
<p id="rfc.section.22.4.p.1">This document defines a CICM::Negotiator which defines the basic peer-entity authentication mechanism. Channels defined in the CICM::Encrypt, CICM::Decrypt, CICM::Duplex, CICM::EncryptBypass, and CICM::DecryptBypass namespaces define negotiated versions of most of the channels. See Channel Negotiation (<a href="#sec_channel_negotiation">Section 8</a>) for more information.</p>
<h1 id="rfc.references">
<a href="#rfc.references">23.</a> References</h1>
<h1 id="rfc.references.1">
<a href="#rfc.references.1">23.1.</a> Normative References</h1>
<table><tbody>
<tr>
<td class="reference"><b id="RFC2119">[RFC2119]</b></td>
<td class="top">
<a href="mailto:sob@harvard.edu" title="Harvard University">Bradner, S.</a>, "<a href="http://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>", BCP 14, RFC 2119, March 1997.</td>
</tr>
<tr>
<td class="reference"><b id="CICM">[CICM]</b></td>
<td class="top">
<a>Lanz, D.</a> and <a>L. Novikov</a>, "<a>Common Interface to Cryptographic Modules (CICM) [RFC Editor: Please update the RFC reference and date prior to publication.]</a>", January 2011.</td>
</tr>
<tr>
<td class="reference"><b id="CICM-KM">[CICM-KM]</b></td>
<td class="top">
<a>Lanz, D.</a> and <a>L. Novikov</a>, "<a>Common Interface to Cryptographic Modules (CICM) Key Management [RFC Editor: Please update the RFC reference and date prior to publication.]</a>", January 2011.</td>
</tr>
<tr>
<td class="reference"><b id="IDL">[IDL]</b></td>
<td class="top">
<a>International Standards Organization</a>, "<a>Information technology &#8212; Open Distributed Processing &#8212; Interface Definition Language</a>", ISO/IEC 14750:1999(E), March 1999.</td>
</tr>
</tbody></table>
<h1 id="rfc.references.2">
<a href="#rfc.references.2">23.2.</a> Informative References</h1>
<table><tbody>
<tr>
<td class="reference"><b id="RFC3552">[RFC3552]</b></td>
<td class="top">
<a>Rescorla, E.</a> and <a>B. Korver</a>, "<a href="http://tools.ietf.org/html/rfc3552">Guidelines for Writing RFC Text on Security Considerations</a>", BCP 72, RFC 3552, July 2003.</td>
</tr>
<tr>
<td class="reference"><b id="CICM-LM">[CICM-LM]</b></td>
<td class="top">
<a>Lanz, D.</a> and <a>L. Novikov</a>, "<a>Common Interface to Cryptographic Modules (CICM) Logical Model [RFC Editor: Please update the RFC reference and date prior to publication.]</a>", January 2011.</td>
</tr>
<tr>
<td class="reference"><b id="CORBA">[CORBA]</b></td>
<td class="top">
<a>Object Management Group</a>, "<a>Common Object Request Broker Architecture (CORBA) Specification, Version 3.1</a>", January 2008.</td>
</tr>
</tbody></table>
<h1 id="rfc.appendix.Appendix A">
<a href="#rfc.appendix.Appendix%20A">Appendix A.</a> <a href="#idl-code" id="idl-code">IDL Definitions</a>
</h1>
<div id="#rfc.figure.301"></div>
<pre>module CICM {
  typedef CICM::Buffer MACBuffer;
  typedef CICM::Buffer SigBuffer;
  typedef CICM::Buffer HashBuffer;
  typedef CICM::Buffer Vector;

  typedef CICM::UInt32 TransId;

  typedef CICM::CharString HashAlgorithmId;

  typedef CICM::CharString AsymEncrAlgorithmId;
  const CICM::AsymEncrAlgorithmId IMPLICIT_ASYM_ENCR_ALGO = "IMPLICIT";

  typedef CICM::CharString AsymSigAlgorithmId;
  const CICM::AsymSigAlgorithmId IMPLICIT_ASYM_SIG_ALGO = "IMPLICIT";

  typedef CICM::CharString SymEncrAlgorithmId;
  const CICM::SymEncrAlgorithmId IMPLICIT_SYM_ENCR_ALGO = "IMPLICIT";

  typedef CICM::CharString SymMacAlgorithmId;
  const CICM::SymMacAlgorithmId IMPLICIT_SYM_MAC_ALGO = "IMPLICIT";

  typedef CICM::CharString KeyWrapAlgorithmId;
  const CICM::KeyWrapAlgorithmId IMPLICIT_KEY_WRAP_ALGO = "IMPLICIT";

  typedef CICM::CharString ProtocolId;
  const CICM::ProtocolId IMPLICIT_PROTOCOL_ID = "IMPLICIT";

  interface PeerInfo {
    readonly attribute CICM::CharString peer_name;
    readonly attribute CICM::Classification classification;
    readonly attribute CICM::CharString compartment;
    readonly attribute CICM::CharString message;
  };

  interface Negotiator {
    CICM::Status get_remote_info(
      out CICM::PeerInfo peer_info );

    CICM::Status abort_negotiation();
  };

  interface ChannelEventListener {
    typedef CICM::UInt32 ChannelEvent;
    const CICM::ChannelEventListener::ChannelEvent
      C_CHANNEL_DATA_AVAILABLE = 0x00004001;

    const CICM::ChannelEventListener::ChannelEvent
      C_CHANNEL_ERROR = 0x00004002;

    const CICM::ChannelEventListener::ChannelEvent
      C_CHANNEL_INSUFFICIENT_ENTROPY = 0x00004004;

    const CICM::ChannelEventListener::ChannelEvent
      C_CHANNEL_LOST_SYNC = 0x00004007;

    const CICM::ChannelEventListener::ChannelEvent
      C_CHANNEL_PEER_RESET = 0x00004008;

    void event_occurred(
      in  CICM::ChannelEventListener::ChannelEvent event,
      in  CICM::Buffer event_data );
  };

  interface ChannelEventManager {
    CICM::Status register(
      in  CICM::ChannelEventListener::ChannelEvent event,
      in  CICM::ChannelEventListener listener );

    CICM::Status unregister(
      in  CICM::ChannelEventListener::ChannelEvent event );
  };

  interface Channel {
    readonly attribute CICM::ChannelEventManager event_manager;
  };

  interface Stream : CICM::Channel {};

  interface WriteStream : CICM::Stream {
    typedef CICM::UInt32 WriteStatus;
    const CICM::WriteStream::WriteStatus C_WRITE_NOT_READY = 0x00006067;
    const CICM::WriteStream::WriteStatus C_WRITE_READY = 0x00006068;
  };

  interface ReadStream : CICM::Stream {
    typedef CICM::UInt32 ReadStatus;
    const CICM::ReadStream::ReadStatus C_READ_NOT_READY = 0x0000605E;
    const CICM::ReadStream::ReadStatus C_READ_READY = 0x00006061;
  };

  interface Controller : CICM::Channel {
    CICM::Status destroy();
  };

  interface MultiDomainController : CICM::Controller {
    readonly attribute CICM::LocalPort local_port;
    readonly attribute CICM::RemotePort remote_port;
  };

  interface SymKeyController : CICM::Controller {
    readonly attribute CICM::SymKey key;

    CICM::Status update_key();

    CICM::Status update_key_with_algo(
      in  CICM::SymEncrAlgorithmId algorithm );

    CICM::Status rollover_key();

    CICM::Status rollover_key_with_key(
      in  CICM::SymKey next_key );
  };

  interface AsymKeyController : CICM::Controller {
    readonly attribute CICM::AsymKey key;
  };

  interface NegotiatedController :
    CICM::MultiDomainController,
    CICM::AsymKeyController,
    CICM::Negotiator {

    readonly attribute CICM::Classification negotiated_grade;

    CICM::Status renegotiate();

    CICM::Status initiate_grade_change(
      in  CICM::Classification new_grade );

    CICM::Status acknowledge_grade_change();
  };

  interface SetVectorController : CICM::Controller {
    readonly attribute CICM::Vector vec;

    CICM::Status set_vector(
      in  CICM::Vector vec );

    CICM::Status set_vector_no_check(
      in  CICM::Vector vec );

    CICM::Status reset_vector();
  };

  interface GenVectorController : CICM::SetVectorController {
    CICM::Status generate_vector();
    CICM::Status generate_vector_existing_state();
  };

  interface ResyncController : CICM::Controller {
    CICM::Status resync();
    CICM::Status resync_with_sync_vector(
      in  CICM::Vector vec );
  };

  interface ControllerGroup {
    CICM::Status add(
      in CICM::Controller controller_ref );
  };

  interface Conduit :
    CICM::Controller,
    CICM::Stream {
  };

  interface AbstractMACConduit : CICM::Conduit {
    readonly attribute CICM::SymKey mac_key;
    readonly attribute CICM::SymMacAlgorithmId mac_algorithm;

    CICM::Status end_get_mac(
      out CICM::MACBuffer mac );
  };

  interface AbstractSignConduit : CICM::Conduit {
    readonly attribute CICM::AsymKey sign_key;
    readonly attribute CICM::AsymSigAlgorithmId sign_algorithm;

    CICM::Status end_get_signature(
      out CICM::SigBuffer signature );
  };

  interface AbstractVerifyConduit : CICM::Conduit {
    typedef CICM::UInt32 VerifyStatus;
    const CICM::AbstractVerifyConduit::VerifyStatus
      C_DATA_VERIFIED = 0x00006025;

    const CICM::AbstractVerifyConduit::VerifyStatus
      C_DATA_NOT_VERIFIED = 0x00006026;

  };

  interface AbstractMACVerifyConduit : CICM::AbstractVerifyConduit {
    readonly attribute CICM::SymKey verify_key;
    readonly attribute CICM::SymMacAlgorithmId verify_algorithm;

    CICM::Status end_get_verified(
      in  CICM::MACBuffer mac,
      out CICM::AbstractVerifyConduit::VerifyStatus status );
  };

  interface AbstractSigVerifyConduit : CICM::AbstractVerifyConduit {
    readonly attribute CICM::AsymKey verify_key;
    readonly attribute CICM::AsymSigAlgorithmId verify_algorithm;

    CICM::Status end_get_verified(
      in  CICM::SigBuffer signature,
      out CICM::AbstractVerifyConduit::VerifyStatus status );
  };

  module Encrypt {
    interface Stream : CICM::WriteStream {
      CICM::Status encrypt(
        in  CICM::Buffer buffer );

      CICM::Status encrypt_non_blocking(
        in  CICM::Buffer buffer,
        in  CICM::TransId transaction_id );

      CICM::Status encrypt_poll(
        in  CICM::TransId transaction_id,
        out CICM::WriteStream::WriteStatus status );
    };

    interface KeyWrapStream : CICM::Stream {
      CICM::Status wrap_key(
        in CICM::Key key_ref );
    };

    interface Controller :
      CICM::MultiDomainController,
      CICM::SymKeyController,
      CICM::GenVectorController,
      CICM::ResyncController {};

    interface NegotiatedController :
      CICM::NegotiatedController,
      CICM::GenVectorController,
      CICM::ResyncController {};

    interface Conduit :
      CICM::Conduit,
      CICM::Encrypt::Controller,
      CICM::Encrypt::Stream {};

    interface NegotiatedConduit :
      CICM::Conduit,
      CICM::Encrypt::NegotiatedController,
      CICM::Encrypt::Stream {};

    interface WithMACConduit :
      CICM::AbstractMACConduit,
      CICM::Encrypt::Conduit {};

    interface WithMACNegotiatedConduit :
      CICM::AbstractMACConduit,
      CICM::Encrypt::NegotiatedConduit {};

    interface WithSignConduit :
      CICM::AbstractSignConduit,
      CICM::Encrypt::Conduit {};

    interface WithSignNegotiatedConduit :
      CICM::AbstractSignConduit,
      CICM::Encrypt::NegotiatedConduit {};

    interface KeyWrapConduit :
      CICM::Encrypt::Controller,
      CICM::Encrypt::KeyWrapStream {};

    interface ControllerNegotiator : CICM::Negotiator {
      CICM::Status complete(
        out CICM::Encrypt::NegotiatedController controller_ref );
    };

    interface Negotiator : CICM::Negotiator {
      CICM::Status complete(
        out CICM::Encrypt::NegotiatedConduit conduit_ref );
    };

    interface WithMACNegotiator : CICM::Negotiator {
      CICM::Status complete(
        out CICM::Encrypt::WithMACNegotiatedConduit conduit_ref );
    };

    interface WithSignNegotiator : CICM::Negotiator {
      CICM::Status complete(
        out CICM::Encrypt::WithSignNegotiatedConduit conduit_ref );
    };

    interface ChannelManager {
      CICM::Status negotiate_encrypt_conduit(
        in  CICM::RemotePort remote_port,
        in  CICM::ProtocolId protocol,
        in  CICM::AsymKey key_ref,
        out CICM::Encrypt::Negotiator negotiator_ref );

      CICM::Status negotiate_encrypt_with_mac_conduit(
        in  CICM::RemotePort remote_port,
        in  CICM::ProtocolId protocol,
        in  CICM::SymKey mac_key_ref,
        in  CICM::AsymKey nego_key_ref,
        in  CICM::SymMacAlgorithmId mac_algorithm,
        out CICM::Encrypt::WithMACNegotiator negotiator_ref );

      CICM::Status negotiate_encrypt_with_sign_conduit(
        in  CICM::RemotePort remote_port,
        in  CICM::ProtocolId protocol,
        in  CICM::AsymKey sign_key_ref,
        in  CICM::AsymKey nego_key_ref,
        in  CICM::AsymSigAlgorithmId sign_algorithm,
        out CICM::Encrypt::WithSignNegotiator negotiator_ref );

      CICM::Status negotiate_encrypt_controller(
        in  CICM::LocalPort local_port,
        in  CICM::RemotePort remote_port,
        in  CICM::ProtocolId protocol,
        in  CICM::AsymKey key_ref,
        out CICM::Encrypt::ControllerNegotiator negotiator_ref );

      CICM::Status create_encrypt_conduit(
        in  CICM::RemotePort remote_port,
        in  CICM::SymKey key_ref,
        in  CICM::SymEncrAlgorithmId algorithm,
        out CICM::Encrypt::Conduit conduit_ref );

      CICM::Status create_encrypt_with_mac_conduit(
        in  CICM::RemotePort remote_port,
        in  CICM::SymKey mac_key_ref,
        in  CICM::SymKey encrypt_key_ref,
        in  CICM::SymMacAlgorithmId mac_algorithm,
        in  CICM::SymEncrAlgorithmId encr_algorithm,
        out CICM::Encrypt::WithMACConduit conduit_ref );

      CICM::Status create_encrypt_with_sign_conduit(
        in  CICM::RemotePort remote_port,
        in  CICM::AsymKey sign_key_ref,
        in  CICM::SymKey encrypt_key_ref,
        in  CICM::AsymSigAlgorithmId sign_algorithm,
        in  CICM::SymEncrAlgorithmId encr_algorithm,
        out CICM::Encrypt::WithSignConduit conduit_ref );
      CICM::Status create_key_wrap_conduit(
        in  CICM::RemotePort remote_port,
        in  CICM::SymKey kek_ref,
        in  CICM::KeyWrapAlgorithmId algorithm,
        out CICM::Encrypt::KeyWrapConduit conduit_ref );

      CICM::Status create_encrypt_controller(
        in  CICM::LocalPort local_port,
        in  CICM::RemotePort remote_port,
        in  CICM::SymKey key_ref,
        in  CICM::SymEncrAlgorithmId algorithm,
        out CICM::Encrypt::Controller controller_ref );

      CICM::Status get_encrypt_stream(
        in  CICM::LocalPort local_port,
        out CICM::Encrypt::Stream stream_ref );
    };
  };

  module Decrypt {
    interface Stream : CICM::ReadStream {
      CICM::Status decrypt(
        out CICM::Buffer buffer );

      CICM::Status decrypt_non_blocking(
        out CICM::Buffer buffer,
        in  CICM::TransId transaction_id );

      CICM::Status decrypt_poll(
        in  CICM::TransId transaction_id,
        out CICM::ReadStream::ReadStatus status );
    };

    interface KeyUnwrapStream : CICM::Stream {
      CICM::Status unwrap_sym_key(
        out CICM::SymKey key_ref );

      CICM::Status unwrap_asym_key(
        out CICM::AsymKey key_ref );
    };

    interface Controller :
      CICM::MultiDomainController,
      CICM::SymKeyController,
      CICM::SetVectorController,
      CICM::ResyncController {};

    interface NegotiatedController :
      CICM::NegotiatedController,
      CICM::SetVectorController,
      CICM::ResyncController {};

    interface Conduit :
      CICM::Conduit,
      CICM::Decrypt::Controller,
      CICM::Decrypt::Stream {};

    interface NegotiatedConduit :
      CICM::Conduit,
      CICM::Decrypt::NegotiatedController,
      CICM::Decrypt::Stream {};

    interface WithMACConduit :
      CICM::AbstractMACVerifyConduit,
      CICM::Decrypt::Conduit {};

    interface WithMACNegotiatedConduit :
      CICM::AbstractMACVerifyConduit,
      CICM::Decrypt::NegotiatedConduit {};

    interface WithVerifyConduit :
      CICM::AbstractSigVerifyConduit,
      CICM::Decrypt::Conduit {};

    interface WithVerifyNegotiatedConduit :
      CICM::AbstractSigVerifyConduit,
      CICM::Decrypt::NegotiatedConduit {};

    interface KeyUnwrapConduit :
      CICM::Decrypt::Controller,
      CICM::Decrypt::KeyUnwrapStream {};

    interface Negotiator : CICM::Negotiator {
      CICM::Status complete(
        out CICM::Decrypt::NegotiatedConduit conduit_ref );
    };

    interface ControllerNegotiator : CICM::Negotiator {
      CICM::Status complete(
        out CICM::Decrypt::NegotiatedController controller_ref );
    };

    interface WithMACNegotiator : CICM::Negotiator {
      CICM::Status complete(
        out CICM::Decrypt::WithMACNegotiatedConduit conduit_ref );
    };

    interface WithVerifyNegotiator : CICM::Negotiator {
      CICM::Status complete(
        out CICM::Decrypt::WithVerifyNegotiatedConduit conduit_ref );
    };

    interface ChannelManager {
      CICM::Status negotiate_decrypt_conduit(
        in  CICM::RemotePort remote_port,
        in  CICM::ProtocolId protocol,
        in  CICM::AsymKey key_ref,
        out CICM::Decrypt::Negotiator negotiator_ref );

      CICM::Status negotiate_decrypt_with_mac_conduit(
        in  CICM::RemotePort remote_port,
        in  CICM::ProtocolId protocol,
        in  CICM::SymKey verify_key_ref,
        in  CICM::AsymKey nego_key_ref,
        in  CICM::SymMacAlgorithmId verify_algorithm,
        out CICM::Decrypt::WithMACNegotiator negotiator_ref );

      CICM::Status negotiate_decrypt_with_verify_conduit(
        in  CICM::RemotePort remote_port,
        in  CICM::ProtocolId protocol,
        in  CICM::AsymKey verify_key_ref,
        in  CICM::AsymKey nego_key_ref,
        in  CICM::AsymSigAlgorithmId verify_algorithm,
        out CICM::Decrypt::WithVerifyNegotiator negotiator_ref );

      CICM::Status negotiate_decrypt_controller(
        in  CICM::LocalPort local_port,
        in  CICM::RemotePort remote_port,
        in  CICM::ProtocolId protocol,
        in  CICM::AsymKey key_ref,
        out CICM::Decrypt::ControllerNegotiator negotiator_ref );

      CICM::Status create_decrypt_conduit(
        in  CICM::RemotePort remote_port,
        in  CICM::SymKey key_ref,
        in  CICM::SymEncrAlgorithmId algorithm,
        out CICM::Decrypt::Conduit conduit_ref );

      CICM::Status create_decrypt_with_mac_conduit(
        in  CICM::RemotePort remote_port,
        in  CICM::SymKey verify_key_ref,
        in  CICM::SymKey decrypt_key_ref,
        in  CICM::SymMacAlgorithmId verify_algorithm,
        in  CICM::SymEncrAlgorithmId decrypt_algorithm,
        out CICM::Decrypt::WithMACConduit conduit_ref );

      CICM::Status create_decrypt_with_verify_conduit(
        in  CICM::RemotePort remote_port,
        in  CICM::AsymKey verify_key_ref,
        in  CICM::SymKey decrypt_key_ref,
        in  CICM::AsymSigAlgorithmId verify_algorithm,
        in  CICM::SymEncrAlgorithmId decrypt_algorithm,
        out CICM::Decrypt::WithVerifyConduit conduit_ref );

      CICM::Status create_key_unwrap_conduit(
        in  CICM::RemotePort remote_port,
        in  CICM::SymKey kek_ref,
        in  CICM::KeyWrapAlgorithmId algorithm,
        out CICM::Decrypt::KeyUnwrapConduit conduit_ref );

      CICM::Status create_decrypt_controller(
        in  CICM::LocalPort local_port,
        in  CICM::RemotePort remote_port,
        in  CICM::SymKey key_ref,
        in  CICM::SymEncrAlgorithmId algorithm,
        out CICM::Decrypt::Controller controller_ref );

      CICM::Status get_decrypt_stream(
        in  CICM::LocalPort local_port,
        out CICM::Decrypt::Stream stream_ref );
    };
  };

  module Duplex {
    interface Stream :
      CICM::Encrypt::Stream,
      CICM::Decrypt::Stream {};

    interface Controller :
      CICM::Encrypt::Controller,
      CICM::Decrypt::Controller {};

    interface NegotiatedController :
      CICM::Encrypt::NegotiatedController,
      CICM::Decrypt::NegotiatedController {};

    interface Conduit :
      CICM::Conduit,
      CICM::Duplex::Controller,
      CICM::Duplex::Stream {};

    interface NegotiatedConduit :
      CICM::Duplex::NegotiatedController,
      CICM::Duplex::Stream {};

    interface ControllerNegotiator : CICM::Negotiator {
      CICM::Status complete(
        out CICM::Duplex::NegotiatedController controller_ref );
    };

    interface Negotiator : CICM::Negotiator {
       CICM::Status complete(
        out CICM::Duplex::NegotiatedConduit conduit_ref );
    };

    interface ChannelManager {
      CICM::Status negotiate_duplex_conduit(
        in  CICM::RemotePort remote_port,
        in  CICM::ProtocolId protocol,
        in  CICM::AsymKey key_ref,
        out CICM::Duplex::Negotiator negotiator_ref );

      CICM::Status negotiate_duplex_controller(
        in  CICM::LocalPort local_port,
        in  CICM::RemotePort remote_port,
        in  CICM::ProtocolId protocol,
        in  CICM::AsymKey key_ref,
        out CICM::Duplex::ControllerNegotiator negotiator_ref );

      CICM::Status create_duplex_conduit(
        in  CICM::RemotePort remote_port,
        in  CICM::SymKey key_ref,
        in  CICM::SymEncrAlgorithmId algorithm,
        out CICM::Duplex::Conduit conduit_ref );

      CICM::Status create_duplex_controller(
        in  CICM::LocalPort local_port,
        in  CICM::RemotePort remote_port,
        in  CICM::SymKey key_ref,
        in  CICM::SymEncrAlgorithmId algorithm,
        out CICM::Duplex::Controller controller_ref );

      CICM::Status get_duplex_stream(
        in  CICM::LocalPort local_port,
        out CICM::Duplex::Stream stream_ref );
    };
  };

  module BypassWrite {
    interface Stream : CICM::WriteStream {
      CICM::Status write_bypass(
        in  CICM::Buffer buffer );

      CICM::Status write_bypass_non_blocking(
        in  CICM::Buffer buffer,
        in  CICM::TransId transaction_id );

      CICM::Status write_bypass_poll(
        in  CICM::TransId transaction_id,
        out CICM::WriteStream::WriteStatus status );
    };

    interface Controller : CICM::MultiDomainController {};

    interface Conduit :
      CICM::Conduit,
      CICM::BypassWrite::Controller,
      CICM::BypassWrite::Stream {};

    interface ChannelManager {
      CICM::Status create_bypass_write_conduit(
        in  CICM::RemotePort remote_port,
        out CICM::BypassWrite::Conduit conduit_ref );

      CICM::Status create_bypass_write_controller(
        in  CICM::LocalPort local_port,
        in  CICM::RemotePort remote_port,
        out CICM::BypassWrite::Controller controller_ref );

      CICM::Status get_bypass_write_stream(
        in  CICM::LocalPort local_port,
        out CICM::BypassWrite::Stream stream_ref );
    };
  };

  module BypassRead {
    interface Stream : CICM::ReadStream {
      CICM::Status read_bypass(
        out CICM::Buffer buffer );

      CICM::Status read_bypass_non_blocking(
        out CICM::Buffer buffer,
        in   CICM::TransId transaction_id );

      CICM::Status read_bypass_poll(
        in  CICM::TransId transaction_id,
        out CICM::ReadStream::ReadStatus status );
    };

    interface Controller : CICM::MultiDomainController {};

    interface Conduit :
      CICM::Conduit,
      CICM::BypassRead::Controller,
      CICM::BypassRead::Stream {};

    interface ChannelManager {
      CICM::Status create_bypass_read_conduit(
        in  CICM::RemotePort remote_port,
        out CICM::BypassRead::Conduit conduit_ref );

      CICM::Status create_bypass_read_controller(
        in  CICM::LocalPort local_port,
        in  CICM::RemotePort remote_port,
        out CICM::BypassRead::Controller controller_ref );

      CICM::Status get_bypass_read_stream(
        in  CICM::LocalPort local_port,
        out CICM::BypassRead::Stream stream_ref );
    };
  };

  module EncryptBypass {
    interface Stream :
      CICM::Encrypt::Stream,
      CICM::BypassWrite::Stream {
    };

    interface NegotiatedController :
      CICM::Encrypt::NegotiatedController {};

    interface Controller : CICM::Encrypt::Controller {};

    interface Conduit :
      CICM::Encrypt::Conduit,
      CICM::EncryptBypass::Stream {};

    interface NegotiatedConduit :
      CICM::Encrypt::NegotiatedController,
      CICM::EncryptBypass::Stream {};

    interface ControllerNegotiator : CICM::Negotiator {
      CICM::Status complete(
        out CICM::EncryptBypass::NegotiatedController controller_ref );
    };

    interface Negotiator : CICM::Negotiator {
      CICM::Status complete(
        out CICM::EncryptBypass::NegotiatedConduit conduit_ref );
    };

    interface ChannelManager {
      CICM::Status negotiate_encrypt_bypass_conduit(
        in  CICM::RemotePort remote_port,
        in  CICM::ProtocolId protocol,
        in  CICM::AsymKey key_ref,
        out CICM::EncryptBypass::Negotiator negotiator_ref );

      CICM::Status negotiate_encrypt_bypass_controller(
        in  CICM::LocalPort local_port,
        in  CICM::RemotePort remote_port,
        in  CICM::ProtocolId protocol,
        in  CICM::AsymKey key_ref,
        out CICM::EncryptBypass::ControllerNegotiator negotiator_ref );

      CICM::Status create_encrypt_bypass_conduit(
        in  CICM::RemotePort remote_port,
        in  CICM::SymKey key_ref,
        in  CICM::SymEncrAlgorithmId algorithm,
        out CICM::EncryptBypass::Conduit conduit_ref );

      CICM::Status create_encrypt_bypass_controller(
        in  CICM::LocalPort local_port,
        in  CICM::RemotePort remote_port,
        in  CICM::SymKey key_ref,
        in  CICM::SymEncrAlgorithmId algorithm,
        out CICM::EncryptBypass::Controller controller_ref );

      CICM::Status get_encrypt_bypass_stream(
        in  CICM::LocalPort local_port,
        out CICM::EncryptBypass::Stream stream_ref );
    };
  };

  module DecryptBypass {
    interface Stream : CICM::Decrypt::Stream {};

    interface NegotiatedController :
      CICM::Decrypt::NegotiatedController {};

    interface Controller : CICM::Encrypt::Controller {};

    interface Conduit :
      CICM::Decrypt::Conduit,
      CICM::DecryptBypass::Controller,
      CICM::DecryptBypass::Stream {};

    interface NegotiatedConduit :
      CICM::Decrypt::NegotiatedConduit,
      CICM::DecryptBypass::NegotiatedController,
      CICM::DecryptBypass::Stream {};

    interface ControllerNegotiator : CICM::Negotiator {
      CICM::Status complete(
        out CICM::DecryptBypass::NegotiatedController controller_ref );
    };

    interface Negotiator : CICM::Negotiator {
      CICM::Status complete(
        out CICM::DecryptBypass::NegotiatedConduit conduit_ref );
    };

    interface ChannelManager {
      CICM::Status negotiate_decrypt_bypass_conduit(
        in  CICM::RemotePort remote_port,
        in  CICM::ProtocolId protocol,
        in  CICM::AsymKey key_ref,
        out CICM::DecryptBypass::Negotiator negotiator_ref );

      CICM::Status negotiate_decrypt_bypass_controller(
        in  CICM::LocalPort local_port,
        in  CICM::RemotePort remote_port,
        in  CICM::ProtocolId protocol,
        in  CICM::AsymKey key_ref,
        out CICM::DecryptBypass::ControllerNegotiator negotiator_ref );

      CICM::Status create_decrypt_bypass_conduit(
        in  CICM::RemotePort remote_port,
        in  CICM::SymKey key_ref,
        in  CICM::SymEncrAlgorithmId algorithm,
        out CICM::DecryptBypass::Conduit conduit_ref );

      CICM::Status create_decrypt_bypass_controller(
        in  CICM::LocalPort local_port,
        in  CICM::RemotePort remote_port,
        in  CICM::SymKey key_ref,
        in  CICM::SymEncrAlgorithmId algorithm,
        out CICM::DecryptBypass::Controller controller_ref );

      CICM::Status get_decrypt_bypass_stream(
        in  CICM::LocalPort local_port,
        out CICM::DecryptBypass::Stream stream_ref );
    };
  };

  module Emit {
    interface GetStream : CICM::ReadStream {
      CICM::Status get(
        in  CICM::UInt32 length,
        out CICM::Buffer buffer );

      CICM::Status get_non_blocking(
        in  CICM::UInt32 length,
        out CICM::Buffer buffer,
        in  CICM::TransId transaction_id );

      CICM::Status get_poll(
        in  CICM::TransId transaction_id,
        out CICM::ReadStream::ReadStatus status );
    };

    interface Controller : CICM::Controller {
      readonly attribute CICM::RemotePort remote_port;
    };

    interface KeyStreamGenController :
      CICM::SymKeyController,
      CICM::GenVectorController,
      CICM::Emit::Controller {};

    interface PseudoRandomController :
      CICM::SymKeyController,
      CICM::Emit::Controller {};

    interface RandomController : CICM::Emit::Controller {};

    interface KeyStreamGenConduit :
      CICM::Conduit,
      CICM::SymKeyController,
      CICM::GenVectorController,
      CICM::Emit::GetStream {};

    interface PseudoRandomConduit :
      CICM::Conduit,
      CICM::SymKeyController,
      CICM::Emit::GetStream {};

    interface RandomConduit :
      CICM::Conduit,
      CICM::Emit::GetStream {};

    interface ChannelManager {
      CICM::Status create_key_stream_gen_controller(
        in  CICM::RemotePort remote_port,
        in  CICM::SymKey key_ref,
        in  CICM::SymEncrAlgorithmId algorithm,
        out CICM::Emit::KeyStreamGenController controller_ref );

      CICM::Status create_pseudorandom_controller(
        in  CICM::RemotePort remote_port,
        in  CICM::SymKey seed,
        out CICM::Emit::PseudoRandomController controller_ref );

      CICM::Status create_random_controller(
        in  CICM::RemotePort remote_port,
        out CICM::Emit::RandomController controller_ref );

      CICM::Status create_key_stream_gen_conduit(
        in  CICM::SymKey key_ref,
        in  CICM::SymEncrAlgorithmId algorithm,
        out CICM::Emit::KeyStreamGenConduit conduit_ref );

      CICM::Status create_pseudorandom_conduit(
        in  CICM::SymKey seed,
        out CICM::Emit::PseudoRandomConduit conduit_ref );

      CICM::Status create_random_conduit(
        out CICM::Emit::RandomConduit conduit_ref );
    };
  };

  module Answer {
    interface PutStream : CICM::Stream {
      CICM::Status put(
        in  CICM::Buffer buffer );
    };

    interface HashConduit :
      CICM::Conduit,
      CICM::Answer::PutStream {

      readonly attribute CICM::HashAlgorithmId algorithm;

      CICM::Status end_get_hash(
        out HashBuffer hash );
    };

    interface MACConduit :
      CICM::AbstractMACConduit,
      CICM::Answer::PutStream {};

    interface MACVerifyConduit :
      CICM::AbstractMACVerifyConduit,
      CICM::Answer::PutStream {};

    interface SignConduit :
      CICM::AbstractSignConduit,
      CICM::Answer::PutStream {};

    interface SignHashConduit : CICM::Answer::SignConduit {};

    interface VerifyConduit :
      CICM::AbstractSigVerifyConduit,
      CICM::Answer::PutStream {};

    interface VerifyHashConduit : CICM::Answer::VerifyConduit {};

    interface ChannelManager {
      CICM::Status create_hash_conduit(
        in  CICM::HashAlgorithmId algorithm,
        out CICM::Answer::HashConduit conduit_ref );

      CICM::Status create_mac_conduit(
        in  CICM::SymKey key_ref,
        in  CICM::SymMacAlgorithmId algorithm,
        out CICM::Answer::MACConduit conduit_ref );

      CICM::Status create_mac_verify_conduit(
        in  CICM::SymKey key_ref,
        in  CICM::SymMacAlgorithmId algorithm,
        out CICM::Answer::MACVerifyConduit conduit_ref );

      CICM::Status create_sign_conduit(
        in  CICM::AsymKey key_ref,
        in  CICM::AsymSigAlgorithmId algorithm,
        out CICM::Answer::SignConduit conduit_ref );

      CICM::Status create_sign_hash_conduit(
        in  CICM::AsymKey key_ref,
        in  CICM::AsymSigAlgorithmId algorithm,
        out CICM::Answer::SignHashConduit conduit_ref );

      CICM::Status create_verify_conduit(
        in  CICM::AsymKey key_ref,
        in  CICM::AsymSigAlgorithmId algorithm,
        out CICM::Answer::VerifyConduit conduit_ref );

      CICM::Status create_verify_hash_conduit(
        in  CICM::AsymKey key_ref,
        in  CICM::AsymSigAlgorithmId algorithm,
        out CICM::Answer::VerifyHashConduit conduit_ref );
    };
  };

  module Coprocessor {
    interface Stream : CICM::Stream {
      CICM::Status get_final_buffer(
        out CICM::Buffer buffer );
    };

    interface EncryptConduit :
      CICM::Conduit,
      CICM::SymKeyController,
      CICM::GenVectorController,
      CICM::ResyncController,
      CICM::Coprocessor::Stream {

      CICM::Status encrypt(
        in  CICM::Buffer plaintext,
        out CICM::Buffer ciphertext );
    };

    interface EncryptWithMACConduit :
      CICM::AbstractMACConduit,
      CICM::Coprocessor::EncryptConduit {};

    interface EncryptWithSignConduit :
      CICM::AbstractSignConduit,
      CICM::Coprocessor::EncryptConduit {};

    interface DecryptConduit :
      CICM::Conduit,
      CICM::SymKeyController,
      CICM::SetVectorController,
      CICM::ResyncController,
      CICM::Coprocessor::Stream {

      CICM::Status decrypt(
        in  CICM::Buffer ciphertext,
        out CICM::Buffer plaintext );
    };

    interface DecryptWithMACConduit :
      CICM::AbstractMACVerifyConduit,
      CICM::Coprocessor::DecryptConduit {};

    interface DecryptWithVerifyConduit :
      CICM::AbstractSigVerifyConduit,
      CICM::Coprocessor::DecryptConduit {};

    interface ChannelManager {
      CICM::Status create_coprocessor_encrypt_conduit(
        in  CICM::SymKey key_ref,
        in  CICM::SymEncrAlgorithmId algorithm,
        out CICM::Coprocessor::EncryptConduit conduit_ref );

      CICM::Status create_coprocessor_encrypt_with_mac_conduit(
        in  CICM::SymKey mac_key_ref,
        in  CICM::SymKey encrypt_key_ref,
        in  CICM::SymMacAlgorithmId mac_algorithm,
        in  CICM::SymEncrAlgorithmId encrypt_algorithm,
        out CICM::Coprocessor::EncryptWithMACConduit conduit_ref );

      CICM::Status create_coprocessor_encrypt_with_sign_conduit(
        in  CICM::AsymKey sign_key_ref,
        in  CICM::SymKey encrypt_key_ref,
        in  CICM::AsymSigAlgorithmId sign_algorithm,
        in  CICM::SymEncrAlgorithmId encrypt_algorithm,
        out CICM::Coprocessor::EncryptWithSignConduit conduit_ref );

      CICM::Status create_coprocessor_decrypt_conduit(
        in  CICM::SymKey key_ref,
        in  CICM::SymEncrAlgorithmId algorithm,
        out CICM::Coprocessor::DecryptConduit conduit_ref );

      CICM::Status create_coprocessor_decrypt_with_mac_conduit(
        in  CICM::SymKey mac_key_ref,
        in  CICM::SymKey decrypt_key_ref,
        in  CICM::SymMacAlgorithmId mac_algorithm,
        in  CICM::SymEncrAlgorithmId encrypt_algorithm,
        out CICM::Coprocessor::DecryptWithMACConduit conduit_ref );

      CICM::Status create_coprocessor_decrypt_with_verify_conduit(
        in  CICM::AsymKey verify_key_ref,
        in  CICM::SymKey decrypt_key_ref,
        in  CICM::AsymSigAlgorithmId verify_algorithm,
        in  CICM::SymEncrAlgorithmId decrypt_algorithm,
        out CICM::Coprocessor::DecryptWithVerifyConduit conduit_ref );
    };
  };

  interface ChannelManager :
    CICM::Answer::ChannelManager,
    CICM::BypassRead::ChannelManager,
    CICM::BypassWrite::ChannelManager,
    CICM::Coprocessor::ChannelManager,
    CICM::Decrypt::ChannelManager,
    CICM::DecryptBypass::ChannelManager,
    CICM::Duplex::ChannelManager,
    CICM::Emit::ChannelManager,
    CICM::Encrypt::ChannelManager,
    CICM::EncryptBypass::ChannelManager {

    CICM::Status create_controller_group(
      out CICM::ControllerGroup controller_group_ref );
  };
};</pre>
<h1 id="rfc.authors"><a href="#rfc.authors">Authors' Addresses</a></h1>
<div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Daniel J. Lanz</span> 
	  <span class="n hidden">
		<span class="family-name">Lanz</span>
	  </span>
	</span>
	<span class="org vcardline">The MITRE Corporation</span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality"></span> 
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline"></span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:dlanz@mitre.org">dlanz@mitre.org</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Lev Novikov</span> 
	  <span class="n hidden">
		<span class="family-name">Novikov</span>
	  </span>
	</span>
	<span class="org vcardline">The MITRE Corporation</span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality"></span> 
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline"></span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:lnovikov@mitre.org">lnovikov@mitre.org</a></span>

  </address>
</div>

</body>
</html>