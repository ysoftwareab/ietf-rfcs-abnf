z = x + y

z = x + y mod p.


x1=x2 and y1=y2, or when both points are the point at infinity.  The
x3 = ((y2-y1)/(x2-x1))^2 - x1 - x2 and
y3 = (x1-x3)*(y2-y1)/(x2-x1) - y1 when P is not equal to Q and
x3 = ((3*x1^2 + a)/(2*y1))^2 - 2*x1 and
y3 = (x1-x3)*(3*x1^2 + a)/(2*y1) - y1 if P is equal to Q and y1 is
P3=(X3,Y3,Z3) = P1 * P2 is given by

X3 = v * (Z2 * (Z1 * u^2 - 2 * X1 * v^2) - v^3) mod p

Y3 = Z2 * (3 * X1 * u * v^2 - Y1 * v^3 - Z1 * u^3) + u * v^3 mod p

Z3 = v^3 * Z1 * Z2 mod p

X3 = 2 * Y1 * Z1 * (w^2 - 8 * X1 * Y1^2 * Z1) mod p

Y3 = 4 * Y1^2 * Z1 * (3 * w * X1 - 2 * Y1^2 * Z1) - w^3 mod p

Z3 = 8 * (Y1 * Z1)^3 mod p

b = 0 and p = 3 (mod 4), and parameter sets in which a = 0 and
p = 2 (mod 3) [MOV1993].  These parameter choices are inferior for
Y = alpha^z.  Each public key is associated with a particular
s1 = 0 or s2 = 0, a new value of k SHOULD be generated and the
s1 = 0 or s2 = 0 if signatures are generated properly.)

u1 = h(m) * s2 mod q, and

u2 = s1 * s2 mod q.

s1 = 0 or s2 = 0, a new value of k SHOULD be generated and the
s1 = 0 or s2 = 0 if signatures are generated properly.)

u1 = h(m) * s2_inv mod q, and

u2 = s1 * s2_inv mod q.

A = x_A * B + k * C (mod q)

m = - r * z + s * k (mod q).

z = - h(m) / s1 mod q.  We follow [FIPS186] in checking for this
n = q1 * q2 * ... * qz,

w = z ^ ((p+1)/4) (mod p);

w = (x^3 + a*x + b)^((p+1)/4) (mod p).

p = 2^(256)-2^(224)+2^(192)+2^(96)-1.


