<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" 
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html lang="en" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head profile="http://www.w3.org/2006/03/hcard%20http://dublincore.org/documents/2008/08/04/dc-html/">
  <meta http-equiv="Content-Type" content="text/html; charset=us-ascii" />

  <title>A Google Congestion Control for Real-Time Communication on the World Wide Web</title>

  <style type="text/css" title="Xml2Rfc (sans serif)">
  /*<![CDATA[*/
	  a {
	  text-decoration: none;
	  }
	  a.smpl {
	  color: black;
	  }
	  a:hover {
	  text-decoration: underline;
	  }
	  a:active {
	  text-decoration: underline;
	  }
	  address {
	  margin-top: 1em;
	  margin-left: 2em;
	  font-style: normal;
	  }
	  body {
	  color: black;
	  font-family: verdana, helvetica, arial, sans-serif;
	  font-size: 10pt;
	  
	  }
	  cite {
	  font-style: normal;
	  }
	  dd {
	  margin-right: 2em;
	  }
	  dl {
	  margin-left: 2em;
	  }
	
	  ul.empty {
	  list-style-type: none;
	  }
	  ul.empty li {
	  margin-top: .5em;
	  }
	  dl p {
	  margin-left: 0em;
	  }
	  dt {
	  margin-top: .5em;
	  }
	  h1 {
	  font-size: 14pt;
	  line-height: 21pt;
	  page-break-after: avoid;
	  }
	  h1.np {
	  page-break-before: always;
	  }
	  h1 a {
	  color: #333333;
	  }
	  h2 {
	  font-size: 12pt;
	  line-height: 15pt;
	  page-break-after: avoid;
	  }
	  h3, h4, h5, h6 {
	  font-size: 10pt;
	  page-break-after: avoid;
	  }
	  h2 a, h3 a, h4 a, h5 a, h6 a {
	  color: black;
	  }
	  img {
	  margin-left: 3em;
	  }
	  li {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  ol {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  ol p {
	  margin-left: 0em;
	  }
	  p {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  pre {
	  margin-left: 3em;
	  background-color: lightyellow;
	  padding: .25em;
	  }
	  pre.text2 {
	  border-style: dotted;
	  border-width: 1px;
	  background-color: #f0f0f0;
	  width: 69em;
	  }
	  pre.inline {
	  background-color: white;
	  padding: 0em;
	  }
	  pre.text {
	  border-style: dotted;
	  border-width: 1px;
	  background-color: #f8f8f8;
	  width: 69em;
	  }
	  pre.drawing {
	  border-style: solid;
	  border-width: 1px;
	  background-color: #f8f8f8;
	  padding: 2em;
	  }
	  table {
	  margin-left: 2em;
	  }
	  table.tt {
	  vertical-align: top;
	  }
	  table.full {
	  border-style: outset;
	  border-width: 1px;
	  }
	  table.headers {
	  border-style: outset;
	  border-width: 1px;
	  }
	  table.tt td {
	  vertical-align: top;
	  }
	  table.full td {
	  border-style: inset;
	  border-width: 1px;
	  }
	  table.tt th {
	  vertical-align: top;
	  }
	  table.full th {
	  border-style: inset;
	  border-width: 1px;
	  }
	  table.headers th {
	  border-style: none none inset none;
	  border-width: 1px;
	  }
	  table.left {
	  margin-right: auto;
	  }
	  table.right {
	  margin-left: auto;
	  }
	  table.center {
	  margin-left: auto;
	  margin-right: auto;
	  }
	  caption {
	  caption-side: bottom;
	  font-weight: bold;
	  font-size: 9pt;
	  margin-top: .5em;
	  }
	
	  table.header {
	  border-spacing: 1px;
	  width: 95%;
	  font-size: 10pt;
	  color: white;
	  }
	  td.top {
	  vertical-align: top;
	  }
	  td.topnowrap {
	  vertical-align: top;
	  white-space: nowrap; 
	  }
	  table.header td {
	  background-color: gray;
	  width: 50%;
	  }
	  table.header a {
	  color: white;
	  }
	  td.reference {
	  vertical-align: top;
	  white-space: nowrap;
	  padding-right: 1em;
	  }
	  thead {
	  display:table-header-group;
	  }
	  ul.toc, ul.toc ul {
	  list-style: none;
	  margin-left: 1.5em;
	  margin-right: 0em;
	  padding-left: 0em;
	  }
	  ul.toc li {
	  line-height: 150%;
	  font-weight: bold;
	  font-size: 10pt;
	  margin-left: 0em;
	  margin-right: 0em;
	  }
	  ul.toc li li {
	  line-height: normal;
	  font-weight: normal;
	  font-size: 9pt;
	  margin-left: 0em;
	  margin-right: 0em;
	  }
	  li.excluded {
	  font-size: 0pt;
	  }
	  ul p {
	  margin-left: 0em;
	  }
	
	  .comment {
	  background-color: yellow;
	  }
	  .center {
	  text-align: center;
	  }
	  .error {
	  color: red;
	  font-style: italic;
	  font-weight: bold;
	  }
	  .figure {
	  font-weight: bold;
	  text-align: center;
	  font-size: 9pt;
	  }
	  .filename {
	  color: #333333;
	  font-weight: bold;
	  font-size: 12pt;
	  line-height: 21pt;
	  text-align: center;
	  }
	  .fn {
	  font-weight: bold;
	  }
	  .hidden {
	  display: none;
	  }
	  .left {
	  text-align: left;
	  }
	  .right {
	  text-align: right;
	  }
	  .title {
	  color: #990000;
	  font-size: 18pt;
	  line-height: 18pt;
	  font-weight: bold;
	  text-align: center;
	  margin-top: 36pt;
	  }
	  .vcardline {
	  display: block;
	  }
	  .warning {
	  font-size: 14pt;
	  background-color: yellow;
	  }
	
	
	  @media print {
	  .noprint {
		display: none;
	  }
	
	  a {
		color: black;
		text-decoration: none;
	  }
	
	  table.header {
		width: 90%;
	  }
	
	  td.header {
		width: 50%;
		color: black;
		background-color: white;
		vertical-align: top;
		font-size: 12pt;
	  }
	
	  ul.toc a::after {
		content: leader('.') target-counter(attr(href), page);
	  }
	
	  ul.ind li li a {
		content: target-counter(attr(href), page);
	  }
	
	  .print2col {
		column-count: 2;
		-moz-column-count: 2;
		column-fill: auto;
	  }
	  }
	
	  @page {
	  @top-left {
		   content: "Internet-Draft"; 
	  } 
	  @top-right {
		   content: "December 2010"; 
	  } 
	  @top-center {
		   content: "Abbreviated Title";3
	  } 
	  @bottom-left {
		   content: "Doe"; 
	  } 
	  @bottom-center {
		   content: "Expires June 2011"; 
	  } 
	  @bottom-right {
		   content: "[Page " counter(page) "]"; 
	  } 
	  }
	
	  @page:first { 
		@top-left {
		  content: normal;
		}
		@top-right {
		  content: normal;
		}
		@top-center {
		  content: normal;
		}
	  }
  /*]]>*/
  </style>

  <link href="#rfc.toc" rel="Contents">
<link href="#rfc.section.1" rel="Chapter" title="1 Introduction">
<link href="#rfc.section.1.1" rel="Chapter" title="1.1 Mathemathical notation conventions">
<link href="#rfc.section.2" rel="Chapter" title="2 System model">
<link href="#rfc.section.3" rel="Chapter" title="3 Receiver side control">
<link href="#rfc.section.3.1" rel="Chapter" title="3.1 Arrival-time filter">
<link href="#rfc.section.3.2" rel="Chapter" title="3.2 Over-use detector">
<link href="#rfc.section.3.3" rel="Chapter" title="3.3 Rate control">
<link href="#rfc.section.4" rel="Chapter" title="4 Sender side control">
<link href="#rfc.section.5" rel="Chapter" title="5 Interoperability Considerations">
<link href="#rfc.section.6" rel="Chapter" title="6 Implementation Experience">
<link href="#rfc.section.7" rel="Chapter" title="7 Further Work">
<link href="#rfc.section.8" rel="Chapter" title="8 IANA Considerations">
<link href="#rfc.section.9" rel="Chapter" title="9 Security Considerations">
<link href="#rfc.section.10" rel="Chapter" title="10 Acknowledgements">
<link href="#rfc.references" rel="Chapter" title="11 References">
<link href="#rfc.references.1" rel="Chapter" title="11.1 Normative References">
<link href="#rfc.references.2" rel="Chapter" title="11.2 Informative References">
<link href="#rfc.authors" rel="Chapter">


  <meta name="generator" content=
  "http://greenbytes.de/tech/webdav/rfc2629.xslt, Revision 1.539, 2011-01-02 17:13:00, XSLT vendor: SAXON 6.5.5 from Michael Kay http://saxon.sf.net/" />
  <link rel="schema.dct" href="http://purl.org/dc/terms/" />
  <meta name="dct.creator" content="Doe, J." />
  <meta name="dct.identifier" content="urn:ietf:id:draft-sample-input-00" />
  <meta name="dct.issued" scheme="ISO8601" content="2010-12" />
  
  <meta name="dct.abstract" content="This document describes two methods of congestion control when using real-time communications on the World Wide Web (RTCWEB); one sender-based and one receiver-based." />
  <meta name="description" content="This document describes two methods of congestion control when using real-time communications on the World Wide Web (RTCWEB); one sender-based and one receiver-based." />
  <meta name="keywords" content="" />

</head>

<body>

  <table class="header">
    <tbody>
    
    	<tr>
<td class="left">Network Working Group</td>
<td class="right">H. Lundin</td>
</tr>
<tr>
<td class="left">Internet-Draft</td>
<td class="right">S. Holmer</td>
</tr>
<tr>
<td class="left">Intended status: Informational</td>
<td class="right">H. T. Alvestrand, Ed.</td>
</tr>
<tr>
<td class="left">Expires: March 08, 2012</td>
<td class="right">Google</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">September 05, 2011</td>
</tr>

    	
    </tbody>
  </table>

  <p class="title">A Google Congestion Control for Real-Time Communication on the World Wide Web<br />
  <span class="filename">draft-alvestrand-rtcweb-congestion-00</span></p>
  
  <h1 id="rfc.abstract"><a href="#rfc.abstract">Abstract</a></h1>
<p>This document describes two methods of congestion control when using real-time communications on the World Wide Web (RTCWEB); one sender-based and one receiver-based.</p>
<p>It is published to aid the discussion on mandatory-to-implement flow control for RTCWEB applications; initial discussion is expected in the RTCWEB WG's mailing list.</p>
<h1><a>Requirements Language</a></h1>
<p>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in <a href="#RFC2119">RFC 2119</a> <cite title="NONE">[RFC2119]</cite>.</p>
<h1 id="rfc.status"><a href="#rfc.status">Status of this Memo</a></h1>
<p>This Internet-Draft is submitted in full conformance with the provisions of BCP 78 and BCP 79.</p>
<p>Internet-Drafts are working documents of the Internet Engineering Task Force (IETF).  Note that other groups may also distribute working documents as Internet-Drafts.  The list of current Internet- Drafts is at http://datatracker.ietf.org/drafts/current/.</p>
<p>Internet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other documents at any time.  It is inappropriate to use Internet-Drafts as reference material or to cite them other than as "work in progress."</p>
<p>This Internet-Draft will expire on March 08, 2012.</p>
<h1 id="rfc.copyrightnotice"><a href="#rfc.copyrightnotice">Copyright Notice</a></h1>
<p>Copyright (c) 2011 IETF Trust and the persons identified as the document authors.  All rights reserved.</p>
<p>This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document.  Please review these documents carefully, as they describe your rights and restrictions with respect to this document.  Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.</p>

  
  <hr class="noprint" />
  <h1 class="np" id="rfc.toc"><a href="#rfc.toc">Table of Contents</a></h1>
  <ul class="toc">

  	<li>1.   <a href="#rfc.section.1">Introduction</a>
</li>
<li>1.1.   <a href="#rfc.section.1.1">Mathemathical notation conventions</a>
</li>
<li>2.   <a href="#rfc.section.2">System model</a>
</li>
<li>3.   <a href="#rfc.section.3">Receiver side control</a>
</li>
<li>3.1.   <a href="#rfc.section.3.1">Arrival-time filter</a>
</li>
<li>3.2.   <a href="#rfc.section.3.2">Over-use detector</a>
</li>
<li>3.3.   <a href="#rfc.section.3.3">Rate control</a>
</li>
<li>4.   <a href="#rfc.section.4">Sender side control</a>
</li>
<li>5.   <a href="#rfc.section.5">Interoperability Considerations</a>
</li>
<li>6.   <a href="#rfc.section.6">Implementation Experience</a>
</li>
<li>7.   <a href="#rfc.section.7">Further Work</a>
</li>
<li>8.   <a href="#rfc.section.8">IANA Considerations</a>
</li>
<li>9.   <a href="#rfc.section.9">Security Considerations</a>
</li>
<li>10.   <a href="#rfc.section.10">Acknowledgements</a>
</li>
<li>11.   <a href="#rfc.references">References</a>
</li>
<li>11.1.   <a href="#rfc.references.1">Normative References</a>
</li>
<li>11.2.   <a href="#rfc.references.2">Informative References</a>
</li>
<li><a href="#rfc.authors">Authors' Addresses</a>
</li>


  </ul>

  <h1 id="rfc.section.1">
<a href="#rfc.section.1">1.</a> Introduction</h1>
<p id="rfc.section.1.p.1">Congestion control is a requirement for all applications that wish to share the Internet <a href="#RFC2914">[RFC2914]</a>.</p>
<p id="rfc.section.1.p.2">The problem of doing congestion control for real-time media is made difficult for a number of reasons:</p>
<p></p>

<ul>
<li>The media is usually encoded in forms that cannot be quickly changed to accomodate varying bandwidth, and bandwidth requirements can often be changed only in discrete, rather large steps</li>
<li>The participants may have certain specific wishes on how to respond - which may not be reducing the bandwidth required by the flow on which congestion is discovered</li>
<li>The encodings are usually sensitive to packet loss, while the real time requirement precludes the repair of packet loss by retransmission</li>
</ul>

<p>This memo describes two congestion control algorithms that together are seen to give reasonable performance and reasonable (not perfect) bandwidth sharing with other conferences and with TCP-using applications that share the same links.</p>
<p id="rfc.section.1.p.4">The signalling used consists of standard RTP timestamps <a href="#RFC3550">[RFC3550]</a>, standard RTCP feedback reports and Temporary Maximum Media Stream Bit Rate Requests (TMMBR) as defined in <a href="#RFC5104">[RFC5104]</a> section 3.5.4.</p>
<p></p>
<h1 id="rfc.section.1.1">
<a href="#rfc.section.1.1">1.1.</a> Mathemathical notation conventions</h1>
<p id="rfc.section.1.1.p.1">The mathematics of this document have been transcribed from a more formula-friendly format.</p>
<p id="rfc.section.1.1.p.2">The following notational conventions are used:</p>
<p></p>

<dl>
<dt>X_bar</dt>
<dd style="margin-left: 8">The variable X, where X is a vector - conventionally marked by a bar on top of the variable name.</dd>
<dt>X_hat</dt>
<dd style="margin-left: 8">An estimate of the true value of variable X - conventionally marked by a circumflex accent on top of the variable name.</dd>
<dt>X(i)</dt>
<dd style="margin-left: 8">The "i"th value of X - conventionally marked by a subscript i.</dd>
<dt>[x y z]</dt>
<dd style="margin-left: 8">A row vector consisting of elements x, y and z.</dd>
<dt>X_bar^T</dt>
<dd style="margin-left: 8">The transpose of vector X_bar.</dd>
</dl>
<h1 id="rfc.section.2">
<a href="#rfc.section.2">2.</a> System model</h1>
<p id="rfc.section.2.p.1">The following elements are in the system:</p>
<p></p>

<ul>
<li>Incoming media stream</li>
<li>Media codec - has a bandwidth control, and encodes the incoming media stream into an RTP stream.</li>
<li>RTP sender - sends the RTP stream over the network to the RTP receiver. Generates the RTP timestamp.</li>
<li>RTP receiver - receives the RTP stream, notes the time of arrival. Regenerates the media stream for the recipient.</li>
<li>RTCP sender at RTP sender - sends sender reports.</li>
<li>RTCP sender at RTP receiver - sends receiver reports and TMMBR messages.</li>
<li>RTCP receiver at RTP sender - receives receiver reports and TMMBR messages, reports these to sender side control.</li>
<li>RTCP receiver at RTP receiver.</li>
<li>Sender side control - takes loss rate info, round trip time info, and TMMBR messages and computes a sending bitrate.</li>
<li>Receiver side control - takes the packet arrival info at the RTP receiver and decides when to send TMMBR messages.</li>
</ul>

<p>Together, sender side control and receiver side control implement the congestion control algorithm.</p>
<p></p>
<h1 id="rfc.section.3">
<a href="#rfc.section.3">3.</a> <a href="#receiverside" id="receiverside">Receiver side control</a>
</h1>
<p id="rfc.section.3.p.1">The receive-side algorithm can be further decomposed into three parts: an arrival-time filter, an over-use detector, and a remote rate-control.</p>
<p></p>
<h1 id="rfc.section.3.1">
<a href="#rfc.section.3.1">3.1.</a> Arrival-time filter</h1>
<p id="rfc.section.3.1.p.1">This section describes an adaptive filter that continuously updates estimates of network parameters based on the timing of the received frames.</p>
<p id="rfc.section.3.1.p.2">At the receiving side we are observing groups of incoming video packets, where each group of packets corresponding to the same frame having timestamp T(i).</p>
<p id="rfc.section.3.1.p.3">Each frame is assigned a receive time t(i), which corresponds to the time at which the whole frame has been received (ignoring any packet losses). A frame is delayed relative to its predecessor if t(i)-t(i-1)&gt;T(i)-T(i-1), i.e., if the arrival time difference is larger than the timestamp difference.</p>
<p id="rfc.section.3.1.p.4">We define the (relative) inter-arrival time, d(i) as</p>
<div id="#rfc.figure.1"></div>
<pre> 
  d(i) = t(i)-t(i-1)-(T(i)-T(i-1))

</pre>
<p id="rfc.section.3.1.p.5">Since the time ts to send a frame of size L over a path with a capacity of C is</p>
<div id="#rfc.figure.2"></div>
<pre>
  ts = L/C

</pre>
<p id="rfc.section.3.1.p.6">we can model the inter-arrival time as</p>
<div id="#rfc.figure.3"></div>
<pre> 
           L(i)-L(i-1)
  d(i) = -------------- + w(i) =~ dL(i)/C+w(i)
               C

</pre>
<p id="rfc.section.3.1.p.7">Here, w(i) is a sample from a stochastic process W, which is a function of the capacity C, the current cross traffic X(i), and the current send bit rate R(i). We model W as a white Gaussian process. If we are over-using the channel we expect w(i) to increase, and if a queue on the network path is being emptied, w(i) will decrease; otherwise the mean of w(i) will be zero.</p>
<p id="rfc.section.3.1.p.8">Breaking out the mean of w(i) to make it zero mean, we get</p>
<div id="#rfc.figure.4"></div>
<p>Equation 5</p>
<pre>
  d(i) = dL(i)/C + m(i) + v(i)

</pre>
<p id="rfc.section.3.1.p.9">This is our fundamental model, where we take into account that a large frame needs more time to traverse the link than a small frame, thus arriving with higher relative delay. The noise term represents network jitter and other delay effects not captured by the model.</p>
<p id="rfc.section.3.1.p.10">When graphing the values for d(i) versus dL(i) on a scatterplot, we find that most samples cluster around the center, and the outliers are clustered along a line with average slope 1/C and zero offset.</p>
<p id="rfc.section.3.1.p.11">When using a regular video codec, most frames are roughly the same size after encoding (the central &#8220;cloud&#8221;); the exceptions are I-frames (or key frames) which are typically much larger than the average causing positive outliers (the I-frame itself) and negative outliers (the frame after an I-frame).</p>
<p id="rfc.section.3.1.p.12">The parameters d(i) and dL(i) are readily available for each frame i, and we want to estimate C and m(i) and use those estimates to detect whether or not we are over-using the bandwidth currently available. These parameters are easily estimated by any adaptive filter &#8211; we are using the Kalman filter.</p>
<p id="rfc.section.3.1.p.13">Let</p>
<div id="#rfc.figure.5"></div>
<pre>
  theta_bar(i) = [1/C(i) m(i)]^T
</pre>
<p id="rfc.section.3.1.p.14">and call it the state of time i. We model the state evolution from time i to time i+1 as</p>
<p></p>
<div id="#rfc.figure.6"></div>
<pre>
  theta_bar(i+1) = theta_bar(i) + u_bar(i)
</pre>
<p id="rfc.section.3.1.p.16">where u_bar(i) is the zero mean white Gaussian process noise with covariance</p>
<p></p>
<div id="#rfc.figure.7"></div>
<p>Equation 7</p>
<pre>
  Q(i) = E{u_bar(i) u_bar(i)^T}

</pre>
<p id="rfc.section.3.1.p.18">Given equation 5 we get</p>
<div id="#rfc.figure.8"></div>
<p>Equation 8</p>
<pre>
  d(i) = h_bar(i)^T theta_bar(i) + v(i)

  h_bar(i) = [ dL(i) 1 ]^T

</pre>
<p id="rfc.section.3.1.p.19">where v(i) is zero mean white Gaussian measurement noise with variance var_v = sigma(v,i)^2</p>
<p id="rfc.section.3.1.p.20">The Kalman filter recursively updates our estimate</p>
<div id="#rfc.figure.9"></div>
<pre>
  theta_hat(i) = [1/C_hat(i) m_hat(i)]^T</pre>
<p id="rfc.section.3.1.p.21">as</p>
<div id="#rfc.figure.10"></div>
<pre>
  z(i) = d(i) - h_bar(i)^T * theta_hat(i-1)

  theta_hat(i) = theta_hat(i-1) + z(i) * k_bar(i)

                 E(i-1) * h_bar(i)
  k_bar(i) = ------------------------------
               var_v_hat + h_bar(i)^T E(i-1)h_bar(i)

  E(i)=(I - K_bar(i) h_bar(i)^T) * E(i-1) + Q(i)
</pre>
<p id="rfc.section.3.1.p.22">I is the 2-by-2 identity matrix.</p>
<p id="rfc.section.3.1.p.23">The variance var_v = sigma(v,i)^2 is estimated using an exponential averaging filter, modified for variable sampling rate</p>
<div id="#rfc.figure.11"></div>
<pre>
  var_v_hat = beta*sigma(v,i-1)^2 + (1-beta)*z(i)^2

  beta = (1-alpha)30/(1000 * f_max)

</pre>
<p id="rfc.section.3.1.p.24">where f_max = max {1/(T(j) - T(j-1))} for j in i-K+1...i is the highest rate at which frames have been captured by the camera the last K frames and alpha is a filter coefficient typically chosen as a number in the interval [0.1, 0.001]. Since our assumption that v(i) should be zero mean WGN is less accurate in some cases, we have introduced an additional outlier filter around the updates of var_v_hat. If z(i) &gt; 3 var_v_hat the filter is updated with 3 sqrt(var_v_hat) rather than z(i). In a similar way, Q(i) is chosen as a diagonal matrix with main diagonal elements given by</p>
<div id="#rfc.figure.12"></div>
<pre>
  diag(Q(i)) = 30/(1000 * f_max)[10^-10 10^-2]^T
</pre>
<p id="rfc.section.3.1.p.25">It is necessary to scale these filter parameters with the frame rate to make the detector respond as quickly at low frame rates as at high frame rates.</p>
<h1 id="rfc.section.3.2">
<a href="#rfc.section.3.2">3.2.</a> Over-use detector</h1>
<p id="rfc.section.3.2.p.1">The offset estimate m(i) is compared with a threshold gamma_1. An estimate above the threshold is considered as an indication of over-use. Such an indication is not enough for the detector to signal over-use to the rate control subsystem. Not until over-use has been detected for at least gamma_2 milliseconds and at least gamma_3 frames, a definitive over-use will be signaled. However, if the offset estimate m(i) was decreased in the last update, over-use will not be signaled even if all the above conditions are met. Similarly, the opposite state, under-use, is detected when m(i) &lt; -gamma_1. If neither over-use nor under-use is detected, the detector will be in the normal state.</p>
<h1 id="rfc.section.3.3">
<a href="#rfc.section.3.3">3.3.</a> Rate control</h1>
<p id="rfc.section.3.3.p.1">The rate control at the receiving side is designed to increase the available bandwidth estimate A_hat as long as the detected state is normal. Doing that assures that we, sooner or later, will reach the available bandwidth of the channel and detect an over-use.</p>
<p id="rfc.section.3.3.p.2">As soon as over-use has been detected the available bandwidth estimate is decreased. In this way we get a recursive and adaptive estimate of the available bandwidth.</p>
<p id="rfc.section.3.3.p.3">In this design description we make the assumption that the rate control subsystem is executed periodically and that this period is constant.</p>
<p id="rfc.section.3.3.p.4">The rate control subsystem has 3 states: Increase, Decrease and Hold. "Increase" is the state when no congestion is detected; "Decrease" is the state where congestion is detected, and "Hold" is a state that waits until built-up queues have drained before going to "increase" state.</p>
<p id="rfc.section.3.3.p.5">The state transitions (with blank fields meaning "remain in state") are:</p>
<p></p>
<div id="#rfc.figure.13"></div>
<pre>State ----&gt;  | Hold      |Increase    |Decrease
Signal-----------------------------------------
  v          |           |            |
Over-use     | Decrease  |Decrease    |
-----------------------------------------------
Normal       | Increase  |            |Hold
-----------------------------------------------
Under-use    |           |Hold        |Hold
-----------------------------------------------



</pre>
<p id="rfc.section.3.3.p.7">The subsystem starts in the increase state, where it will stay until over-use or under-use has been detected by the detector subsystem. On every update the available bandwidth is increased with a factor which is a function of the global system response time and the estimated measurement noise variance var_v_hat. The global system response time is the time from an increase that causes over-use until that over-use can be detected by the over-use detector. The variance var_v_hat affects how responsive the Kalman filter is, and is thus used as an indicator of the delay inflicted by the Kalman filter.</p>
<div id="#rfc.figure.14"></div>
<pre>
  A(i) = eta*A(i-1)
                                 1.001+B
  eta(RTT, var_v_hat) = ------------------------------------------
                           1+e^(b(d*RTT - (c1 * var_v_hat + c2)))</pre>
<p id="rfc.section.3.3.p.8">Here, B, b, d, c1 and c2 are design parameters.</p>
<p id="rfc.section.3.3.p.9">Since the system depends on over-using the channel to verify the current available bandwidth estimate, we must make sure that our estimate doesn&#8217;t diverge from the rate at which the sender is actually sending. Thus, if the sender is unable to produce a bit stream with the bit rate the receiver is asking for, the available bandwidth estimate must stay within a given bound. Therefore we introduce a threshold</p>
<div id="#rfc.figure.15"></div>
<pre>
  A_hat(i) &lt; 1.5 * R_hat(i)
</pre>
<p id="rfc.section.3.3.p.10">where R_hat(i) is the incoming bit rate measured over a T seconds window:</p>
<div id="#rfc.figure.16"></div>
<pre>
  R_hat(i) = 1/T * sum(L(j)) for j from 1 to N(i)</pre>
<p id="rfc.section.3.3.p.11">N(i) is the number of frames received the past T seconds and L(j) is the payload size of frame j.</p>
<p id="rfc.section.3.3.p.12">When an over-use is detected the system transitions to the decrease state, where the available bandwidth estimate is decreased to a factor times the currently incoming bit rate.</p>
<div id="#rfc.figure.17"></div>
<pre>
  A_hat(i) = alpha*R_hat(i)</pre>
<p id="rfc.section.3.3.p.13">alpha is typically chosen to be in the interval [0.8, 0.95].</p>
<p id="rfc.section.3.3.p.14">When the detector signals under-use to the rate control subsystem, we know that queues in the network path are being emptied, indicating that our available bandwidth estimate is lower than the actual available bandwidth. Upon that signal the rate control subsystem will enter the hold state, where the available bandwidth estimate will be held constant while waiting for the queues to stabilize at a lower level &#8211; a way of keeping the delay as low as possible. This decrease of delay is wanted, and expected, immediately after the estimate has been reduced due to over-use, but can also happen if the cross traffic over some links is reduced. In either case we want to measure the highest incoming rate during the under-use interval:</p>
<div id="#rfc.figure.18"></div>
<pre>
  R_max = max{R_hat(i)} for i in 1..K

</pre>
<p id="rfc.section.3.3.p.15">where K is the number of frames of under-use before returning to the normal state. R_max is a measure of the actual bandwidth available and is a good guess of what bit rate we should be able to transmit at.  Therefore the available bandwidth will be set to Rmax when we transition from the hold state to the increase state.</p>
<h1 id="rfc.section.4">
<a href="#rfc.section.4">4.</a> <a href="#senderside" id="senderside">Sender side control</a>
</h1>
<p id="rfc.section.4.p.1">An additional congestion controller resides at the sending side. It bases its decisions on the round-trip time, packet loss and available bandwidth estimates transmitted from the receiving side.</p>
<p id="rfc.section.4.p.2">The available bandwidth estimates produced by the receiving side are only reliable when the size of the queues along the channel are large enough. If the queues are very short, over-use will only be visible through packet losses, which aren't used by the receiving side algorithm.</p>
<p id="rfc.section.4.p.3">This algorithm is run every time a receive report arrives at the sender, which will happen [[how often do we expect? and why?]]. If no receive report is recieved within [[what timeout?]], the algorithm will take action as if all packets in the interval have been lost. [[does that make sense?]]</p>
<p></p>

<ul>
<li>If 2-10% of the packets have been lost since the previous report from the receiver, the sender available bandwidth estimate As(i) (As denotes &#8216;sender available bandwidth&#8217;) will be kept unchanged.</li>
<li>If more than 10% of the packets have been lost a new estimate is calculated as As(i)=As(i-1)(1-0.5p), where p is the loss ratio.</li>
<li>As long as less than 2% of the packets have been lost As(i) will be increased as As(i)=1.05(As(i-1)+1000)</li>
</ul>
<p id="rfc.section.4.p.5">The new send-side estimate is limited by the TCP Friendly Rate Control formula <a href="#RFC3448">[RFC3448]</a> and the receive-side estimate of the available bandwidth A(i):</p>
<div id="#rfc.figure.19"></div>
<pre>                               8 s
As(i) &gt;= ----------------------------------------------------------
         R*sqrt(2*b*p/3) + (t_RTO*(3*sqrt(3*b*p/8) * p * (1+32*p^2)))

As(i) &lt;= A(i)

</pre>
<p id="rfc.section.4.p.6">where b is the number of packets acknowledged by a single TCP acknowledgement (set to 1 per TFRC recommendations), t_RTO is the TCP retransmission timeout value in seconds (set to 4*R) and s is the average packet size in bytes.</p>
<p id="rfc.section.4.p.7">(The multiplication by 8 comes because TFRC is computing bandwidth in bytes, while this document computes bandwidth in bits.)</p>
<p id="rfc.section.4.p.8">In words: The sender-side estimate will never be larger than the receiver-side estimate, and will never be lower than the estimate from the TFRC formula.</p>
<p id="rfc.section.4.p.9">We motivate the packet loss thresholds by noting that if we have small amount of packet losses due to over-use, that amount will soon increase if we don&#8217;t adjust our bit rate. Therefore we will soon enough reach above the 10 % threshold and adjust As(i). However if the packet loss rate does not increase, the losses are probably not related to self-induced channel over-use and therefore we should not react on them.</p>
<h1 id="rfc.section.5">
<a href="#rfc.section.5">5.</a> Interoperability Considerations</h1>
<p id="rfc.section.5.p.1">There are three scenarios of interest, and one included for reference</p>
<p></p>

<ul>
<li>Both parties implement the algorithms described here</li>
<li>Sender implements the algorithm described in section <a href="#senderside">Section 4</a>, recipient does not implement <a href="#receiverside">Section 3</a>
</li>
<li>Recipient implements the algorithm in section <a href="#receiverside">Section 3</a>, sender does not implement <a href="#senderside">Section 4</a>.</li>
</ul>

<p>In the case where both parties implement the algorithms, we expect to see most of the congestion control response to slowly varying conditions happen by TMMBR messages from recipient to sender. At most times, the sender will send less than the congestion-inducing bandwidth limit C, and when he sends more, congestion will be detected before packets are lost.</p>
<p id="rfc.section.5.p.3">If sudden changes happen, packets will be lost, and the sender side control will trigger, limiting traffic until the congestion becomes low enough that the system switches back to the receiver-controlled state.</p>
<p id="rfc.section.5.p.4">In the case where sender only implements, we expect to see somewhat higher loss rates and delays, but the system will still be overall TCP friendly and self-adjusting; the governing term in the calculation will be the TFRC formula.</p>
<p id="rfc.section.5.p.5">In the case where recipient implements this algorithm and sender does not, congestion will be avoided for slow changes as long as the sender understands and obeys TMMBR; there will be no backoff for packet-loss-inducing changes in capacity. Given that some kind of congestion control is mandatory for the sender according to the TMMBR spec, this case has to be reevaluated against the specific congestion control implemented by the sender.</p>
<h1 id="rfc.section.6">
<a href="#rfc.section.6">6.</a> Implementation Experience</h1>
<p id="rfc.section.6.p.1">This algorithm has been implemented in the open-source WebRTC project.</p>
<h1 id="rfc.section.7">
<a href="#rfc.section.7">7.</a> Further Work</h1>
<p id="rfc.section.7.p.1">This draft is offered as input to the congestion control discussion.</p>
<p id="rfc.section.7.p.2">Work that can be done on this basis includes:</p>
<p></p>

<ul>
<li>Consideration of timing info: It may be sensible to use the proposed TFRC RTP header extensions <a href="#I-D.gharai-avtcore-rtp-tfrc">[I-D.gharai-avtcore-rtp-tfrc]</a>to carry per-packet timing information, which would both give more data points and a timestamp applied closer to the network interface.</li>
<li>Considerations of cross-channel calculation: If all packets in multiple streams follow the same path over the network, congestion or queueing information should be considered across all packets between two parties, not just per media stream.</li>
<li>Considerations of cross-channel balancing: The decision to slow down sending in a situation with multiple media streams should be taken across all media streams, not per stream.</li>
<li>Considerations of additional input: How and where packet loss detected at the recipient can be added to the algorithm.</li>
<li>Considerations of locus of control: Whether the sender or the recipient is in the best position to figure out which media streams it makes sense to slow down, and therefore whether one should use TMMBR to slow down one channel, signal an overall bandwidth change and let the sender make the decision, or signal the (possibly processed) delay info and let the sender run the algorithm.</li>
</ul>

<p>These are matters for further work; since some of them involve extensions that have not yet been standardized, this could take some time, and it's important to consider when this work can be completed.</p>
<h1 id="rfc.section.8">
<a href="#rfc.section.8">8.</a> <a href="#IANA" id="IANA">IANA Considerations</a>
</h1>
<p id="rfc.section.8.p.1">This document makes no request of IANA.</p>
<p id="rfc.section.8.p.2">Note to RFC Editor: this section may be removed on publication as an RFC.</p>
<h1 id="rfc.section.9">
<a href="#rfc.section.9">9.</a> <a href="#Security" id="Security">Security Considerations</a>
</h1>
<p id="rfc.section.9.p.1">An attacker with the ability to insert or remove messages on the connection will, of course, have the ability to mess up rate control, causing people to send either too fast or too slow, and causing congestion.</p>
<p id="rfc.section.9.p.2">In this case, the control information is carried inside RTP, and can be protected against modification or message insertion using SRTP, just as for the media. Given that timestamps are carried in the RTP header, which is not encrypted, this is not protected against disclosure, but it seems hard to mount an attack based on timing information only.</p>
<h1 id="rfc.section.10">
<a href="#rfc.section.10">10.</a> <a href="#Acknowledgements" id="Acknowledgements">Acknowledgements</a>
</h1>
<p></p>
<h1 id="rfc.references">
<a href="#rfc.references">11.</a> References</h1>
<h1 id="rfc.references.1">
<a href="#rfc.references.1">11.1.</a> Normative References</h1>
<table><tbody>
<tr>
<td class="reference"><b id="RFC2119">[RFC2119]</b></td>
<td class="top">
<a href="mailto:sob@harvard.edu" title="Harvard University">Bradner, S.</a>, "<a href="http://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>", BCP 14, RFC 2119, March 1997.</td>
</tr>
<tr>
<td class="reference"><b id="RFC3448">[RFC3448]</b></td>
<td class="top">
<a>Handley, M.</a>, <a>Floyd, S.</a>, <a>Padhye, J.</a> and <a>J. Widmer</a>, "<a href="http://tools.ietf.org/html/rfc3448">TCP Friendly Rate Control (TFRC): Protocol Specification</a>", RFC 3448, January 2003.</td>
</tr>
<tr>
<td class="reference"><b id="RFC3550">[RFC3550]</b></td>
<td class="top">
<a>Schulzrinne, H.</a>, <a>Casner, S.</a>, <a>Frederick, R.</a> and <a>V. Jacobson</a>, "<a href="http://tools.ietf.org/html/rfc3550">RTP: A Transport Protocol for Real-Time Applications</a>", STD 64, RFC 3550, July 2003.</td>
</tr>
<tr>
<td class="reference"><b id="RFC5104">[RFC5104]</b></td>
<td class="top">
<a>Wenger, S.</a>, <a>Chandra, U.</a>, <a>Westerlund, M.</a> and <a>B. Burman</a>, "<a href="http://tools.ietf.org/html/rfc5104">Codec Control Messages in the RTP Audio-Visual Profile with Feedback (AVPF)</a>", RFC 5104, February 2008.</td>
</tr>
</tbody></table>
<h1 id="rfc.references.2">
<a href="#rfc.references.2">11.2.</a> Informative References</h1>
<table><tbody>
<tr>
<td class="reference"><b id="I-D.gharai-avtcore-rtp-tfrc">[I-D.gharai-avtcore-rtp-tfrc]</b></td>
<td class="top">
<a>Gharai, L</a> and <a>C Perkins</a>, "<a href="http://tools.ietf.org/html/draft-gharai-avtcore-rtp-tfrc-01">RTP with TCP Friendly Rate Control</a>", Internet-Draft draft-gharai-avtcore-rtp-tfrc-01, September 2011.</td>
</tr>
<tr>
<td class="reference"><b id="RFC2914">[RFC2914]</b></td>
<td class="top">
<a>Floyd, S.</a>, "<a href="http://tools.ietf.org/html/rfc2914">Congestion Control Principles</a>", BCP 41, RFC 2914, September 2000.</td>
</tr>
</tbody></table>
<h1 id="rfc.authors"><a href="#rfc.authors">Authors' Addresses</a></h1>
<div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Henrik Lundin</span> 
	  <span class="n hidden">
		<span class="family-name">Lundin</span>
	  </span>
	</span>
	<span class="org vcardline">Google</span>
	<span class="adr">
	  <span>Kungsbron 2</span>

	  <span class="vcardline">
		<span class="locality">Stockholm</span>,  
		<span class="region"></span>
		<span class="code">11122</span>
	  </span>
	  <span class="country-name vcardline">Sweden</span>
	</span>
	
  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Stefan Holmer</span> 
	  <span class="n hidden">
		<span class="family-name">Holmer</span>
	  </span>
	</span>
	<span class="org vcardline">Google</span>
	<span class="adr">
	  <span>Kungsbron 2</span>

	  <span class="vcardline">
		<span class="locality">Stockholm</span>,  
		<span class="region"></span>
		<span class="code">11122</span>
	  </span>
	  <span class="country-name vcardline">Sweden</span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:holmer@google.com">holmer@google.com</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Harald Alvestrand</span> editor
	  <span class="n hidden">
		<span class="family-name">Alvestrand</span>
	  </span>
	</span>
	<span class="org vcardline">Google</span>
	<span class="adr">
	  <span>Kungsbron 2</span>

	  <span class="vcardline">
		<span class="locality">Stockholm</span>,  
		<span class="region"></span>
		<span class="code">11122</span>
	  </span>
	  <span class="country-name vcardline">Sweden</span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:harald@alvestrand.no">harald@alvestrand.no</a></span>

  </address>
</div>

</body>
</html>