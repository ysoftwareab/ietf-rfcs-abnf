Tag = H_K1(M) xor F_K2(Nonce)

n = bytelength(S) / 4
T = <empty string>
SReversed_i = W_4 || W_3 || W_2 || W_1
T = T || SReversed_i
n = ceil(numbytes / BLOCKLEN)
Y = <empty string>

T = uint2str(index, BLOCKLEN-8) || uint2str(i, 8)
T = ENCIPHER(K, T)
Y = Y || T
Y = Y[1...numbytes]

index = str2uint(Nonce) mod (BLOCKLEN/taglen)
Nonce = Nonce xor uint2str(index, bytelength(Nonce))
Nonce = Nonce || zeroes(BLOCKLEN - bytelength(Nonce))

T = ENCIPHER(K', Nonce)
Y = T[1 + (index*taglen) ... taglen + (index*taglen)]
Y = T[1...taglen]
HashedMessage = UHASH(K, M, taglen)
Pad           = PDF(K, Nonce, taglen)
Tag           = Pad xor HashedMessage

iters = taglen / 4

L1Key  = KDF(K, 1, 1024 + (iters - 1) * 16)
L2Key  = KDF(K, 2, iters * 24)
L3Key1 = KDF(K, 3, iters * 64)
L3Key2 = KDF(K, 4, iters * 4)

Y = <empty string>
L1Key_i  = L1Key [(i-1) * 16 + 1 ... (i-1) * 16 + 1024]
L2Key_i  = L2Key [(i-1) * 24 + 1 ... i * 24]
L3Key1_i = L3Key1[(i-1) * 64 + 1 ... i * 64]
L3Key2_i = L3Key2[(i-1) * 4  + 1 ... i * 4]

A = L1-HASH(L1Key_i, M)
B = zeroes(8) || A
B = L2-HASH(L2Key_i, A)
C = L3-HASH(L3Key1_i, L3Key2_i, B)
Y = Y || C
t = max(ceil(bitlength(M)/8192), 1)
Len = uint2str(1024 * 8, 8)
Y = <empty string>
Y = Y || (NH(K, M_i) +_64 Len)
Len = uint2str(bitlength(M_t), 8)
M_t = zeropad(M_t, 32)
Y = Y || (NH(K, M_t) +_64 Len)

t = bytelength(M) / 4
Y = zeroes(8)
i = 1
Y = Y +_64 ((M_{i+0} +_32 K_{i+0}) *_64 (M_{i+4} +_32 K_{i+4}))
Y = Y +_64 ((M_{i+1} +_32 K_{i+1}) *_64 (M_{i+5} +_32 K_{i+5}))
Y = Y +_64 ((M_{i+2} +_32 K_{i+2}) *_64 (M_{i+6} +_32 K_{i+6}))
Y = Y +_64 ((M_{i+3} +_32 K_{i+3}) *_64 (M_{i+7} +_32 K_{i+7}))
i = i + 8
Mask64  = uint2str(0x01ffffff01ffffff, 8)
Mask128 = uint2str(0x01ffffff01ffffff01ffffff01ffffff, 16)
k64    = str2uint(K[1...8]  and Mask64)
k128   = str2uint(K[9...24] and Mask128)

y = POLY(64, 2^64 - 2^32,  k64, M)
M_1 = M[1...2^17]
M_2 = M[2^17 + 1 ... bytelength(M)]
M_2 = zeropad(M_2 || uint2str(0x80,1), 16)
y = POLY(64, 2^64 - 2^32, k64, M_1)
y = POLY(128, 2^128 - 2^96, k128, uint2str(y, 16) || M_2)
Y = uint2str(y, 16)

wordbytes = wordbits / 8
p = prime(wordbits)
offset = 2^wordbits - p
marker = p - 1

n = bytelength(M) / wordbytes
y = 1
m = str2uint(M_i)
y = (k * y + marker) mod p
y = (k * y + (m - offset)) mod p
y = (k * y + m) mod p
y = 0

M_i = M [(i - 1) * 2 + 1 ... i * 2]
K_i = K1[(i - 1) * 8 + 1 ... i * 8]
m_i = str2uint(M_i)
k_i = str2uint(K_i) mod prime(36)
y = (m_1 * k_1 + ... + m_8 * k_8) mod prime(36)
y = y mod 2^32
Y = uint2str(y, 4)
Y = Y xor K2

K  = "abcdefghijklmnop"                  // A 16-byte UMAC key
N  = "bcdefghi"                          // An 8-byte nonce

