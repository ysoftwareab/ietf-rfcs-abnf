count = ((Int32)16 + (c & 15)) << ((c >> 4) + EXPBIAS);

bodyLen = 1st_octet;

bodyLen = ((1st_octet - 192) << 8) + (2nd_octet) + 192

bodyLen = (2nd_octet << 24) | (3rd_octet << 16) |
                   (4th_octet << 8)  | 5th_octet

partialBodyLen = 1 << (1st_octet & 0x1f);

lengthOfLength = 1
subpacketLen = 1st_octet

lengthOfLength = 2
subpacketLen = ((1st_octet - 192) << 8) + (2nd_octet) + 192
lengthOfLength = 5
vBSFjNSiVHsuAA==
k = the length in octets of the key modulus

M = message to be encoded, an octet string of length mLen, where
        mLen <= k - 11

EM = encoded message, an octet string of length k

    Error:   "message too long"

     1. Length checking: If mLen > k - 11, output "message too long" and
        stop.

     2. Generate an octet string PS of length k - mLen - 3 consisting of
        pseudo-randomly generated nonzero octets. The length of PS will
        be at least eight octets.

     3. Concatenate PS, the message M, and other padding to form an
        encoded message EM of length k octets as

EM = 0x00 || 0x02 || PS || 0x00 || M.

EM = encoded message, an octet string

    Output:

M = message, an octet string

EM = 0x00 || 0x02 || PS || 0x00 || M.

M = message to be encoded

mL = intended length in octets of the encoded message, at least tLen
        + 11, where tLen is the octet length of the DER encoding T of a
        certain value computed during the encoding operation

    Output:

EM = encoded message, an octet string of length emLen

    Errors: "message too long"; "intended encoded message length too
    short"

    Steps:

     1. Apply the hash function to the message M to produce a hash value
        H:

H = Hash(M).

EM = 0x00 || 0x01 || PS || 0x00 || T.

