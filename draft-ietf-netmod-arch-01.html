<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="en"><head><title>An NETCONF- and NETMOD-based Architecture for Network Management</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="description" content="An NETCONF- and NETMOD-based Architecture for Network Management">
<meta name="generator" content="xml2rfc v1.35 (http://xml.resource.org/)">
<meta name="viewport" content="width=600;" />
<style type='text/css'><!--
        body {
                font-family: verdana, charcoal, helvetica, arial, sans-serif;
                font-size: 85%;
		max-width: 40em; 
		color: #000; background-color: #FFF;
                margin: 2em;
        }
        h1, h2, h3, h4, h5, h6 {
                font-family: helvetica, monaco, "MS Sans Serif", arial, sans-serif;
                font-weight: bold; font-style: normal;
        }
        h1 { color: #900; background-color: transparent; text-align: right; }
        h3 { color: #333; background-color: transparent; }

        td.RFCbug {
                font-size: x-small; text-decoration: none;
                width: 30px; height: 30px; padding-top: 2px;
                text-align: justify; vertical-align: middle;
                background-color: #000;
        }
        td.RFCbug span.RFC {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: bold; color: #666;
        }
        td.RFCbug span.hotText {
                font-family: charcoal, monaco, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: normal; text-align: center; color: #FFF;
        }

        table.TOCbug { width: 30px; height: 15px; }
        td.TOCbug {
                text-align: center; width: 30px; height: 15px;
                color: #FFF; background-color: #900;
        }
        td.TOCbug a {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, sans-serif;
                font-weight: bold; font-size: x-small; text-decoration: none;
                color: #FFF; background-color: transparent;
        }

        td.header {
                font-family: arial, helvetica, sans-serif; font-size: x-small;
                vertical-align: top; width: 33%;
                color: #FFF; background-color: #666;
        }
        td.author { font-weight: bold; font-size: x-small; margin-left: 4em; }
        td.author-text { font-size: x-small; }

        /* info code from SantaKlauss at http://www.madaboutstyle.com/tooltip2.html */
        a.info {
                /* This is the key. */
                position: relative;
                z-index: 24;
                text-decoration: none;
        }
        a.info:hover {
                z-index: 25;
                color: #FFF; background-color: #900;
        }
        a.info span { display: none; }
        a.info:hover span.info {
                /* The span will display just on :hover state. */
                display: block;
                position: absolute;
                font-size: smaller;
                top: 2em; left: -5em; width: 15em;
                padding: 2px; border: 1px solid #333;
                color: #900; background-color: #EEE;
                text-align: left;
        }

        a { font-weight: bold; }
        a:link    { color: #900; background-color: transparent; }
        a:visited { color: #633; background-color: transparent; }
        a:active  { color: #633; background-color: transparent; }

        p { margin-left: 2em; margin-right: 2em; }
        p.copyright { font-size: x-small; }
        p.toc { font-size: 85%;
		max-width: 40em; 
		font-weight: bold; margin-left: 3em; }
        table.toc { margin: 0 0 0 3em; padding: 0; border: 0; vertical-align: text-top; }
        td.toc { font-size: 85%;
		max-width: 40em; 
		font-weight: bold; vertical-align: text-top; }

        ol.text { margin-left: 2em; margin-right: 2em; }
        ul.text { margin-left: 2em; margin-right: 2em; }
        li      { margin-left: 3em; }

        /* RFC-2629 <spanx>s and <artwork>s. */
        em     { font-style: italic; }
        strong { font-weight: bold; }
        dfn    { font-weight: bold; font-style: normal; }
        cite   { font-weight: normal; font-style: normal; }
        tt     { color: #036; }
        tt, pre, pre dfn, pre em, pre cite, pre span {
                font-family: "Courier New", Courier, monospace; font-size: small;
        }
        pre {
                text-align: left; padding: 4px;
                color: #000; background-color: #CCC;
        }
        pre dfn  { color: #900; }
        pre em   { color: #66F; background-color: #FFC; font-weight: normal; }
        pre .key { color: #33C; font-weight: bold; }
        pre .id  { color: #900; }
        pre .str { color: #000; background-color: #CFF; }
        pre .val { color: #066; }
        pre .rep { color: #909; }
        pre .oth { color: #000; background-color: #FCF; }
        pre .err { background-color: #FCC; }

        /* RFC-2629 <texttable>s. */
        table.all, table.full, table.headers, table.none {
                font-size: 85%;
		max-width: 40em; 
		text-align: center; border-width: 2px;
                vertical-align: top; border-collapse: collapse;
        }
        table.all, table.full { border-style: solid; border-color: black; }
        table.headers, table.none { border-style: none; }
        th {
                font-weight: bold; border-color: black;
                border-width: 2px 2px 3px 2px;
        }
        table.all th, table.full th { border-style: solid; }
        table.headers th { border-style: none none solid none; }
        table.none th { border-style: none; }
        table.all td {
                border-style: solid; border-color: #333;
                border-width: 1px 2px;
        }
        table.full td, table.headers td, table.none td { border-style: none; }

        hr { height: 1px; }
        hr.insert {
                width: 80%; border-style: none; border-width: 0;
                color: #CCC; background-color: #CCC;
        }
--></style>
</head>
<body>
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<table summary="layout" width="66%" border="0" cellpadding="0" cellspacing="0"><tr><td><table summary="layout" width="100%" border="0" cellpadding="2" cellspacing="1">
<tr><td class="header">Network Working Group</td><td class="header">P. Shafer</td></tr>
<tr><td class="header">Internet-Draft</td><td class="header">Juniper Networks</td></tr>
<tr><td class="header">Intended status: Informational</td><td class="header">May 27, 2009</td></tr>
<tr><td class="header">Expires: November 28, 2009</td><td class="header">&nbsp;</td></tr>
</table></td></tr></table>
<h1><br />An NETCONF- and NETMOD-based Architecture for Network Management<br />draft-ietf-netmod-arch-01</h1>

<h3>Status of this Memo</h3>
<p>
This Internet-Draft is submitted to IETF in full
conformance with the provisions of BCP&nbsp;78 and BCP&nbsp;79.</p>
<p>
Internet-Drafts are working documents of the Internet Engineering
Task Force (IETF), its areas, and its working groups.
Note that other groups may also distribute working documents as
Internet-Drafts.</p>
<p>
Internet-Drafts are draft documents valid for a maximum of six months
and may be updated, replaced, or obsoleted by other documents at any time.
It is inappropriate to use Internet-Drafts as reference material or to cite
them other than as &ldquo;work in progress.&rdquo;</p>
<p>
The list of current Internet-Drafts can be accessed at
<a href='http://www.ietf.org/ietf/1id-abstracts.txt'>http://www.ietf.org/ietf/1id-abstracts.txt</a>.</p>
<p>
The list of Internet-Draft Shadow Directories can be accessed at
<a href='http://www.ietf.org/shadow.html'>http://www.ietf.org/shadow.html</a>.</p>
<p>
This Internet-Draft will expire on November 28, 2009.</p>

<h3>Copyright Notice</h3>
<p>
Copyright (c) 2009 IETF Trust and the persons identified as the
document authors.  All rights reserved.</p>
<p>
This document is subject to BCP 78 and the IETF Trust's Legal
Provisions Relating to IETF Documents in effect on the date of
publication of this document (http://trustee.ietf.org/license-info).
Please review these documents carefully, as they describe your
rights and restrictions with respect to this document.</p>

<h3>Abstract</h3>

<p>
NETCONF gives access to native capabilities of the
devices within a network, defining methods for manipulating
configuration databases, retrieving operational data, and invoking
specific operations.  YANG provides the means to define the content
carried via NETCONF, both data and operations.  Using both
technologies, standard modules can be defined to give interoperability
and commonality to devices, while still allowing devices to express
their unique capabilities.
	
</p>
<p>
This document describes how NETCONF and YANG help build network
management applications that meet the needs of network operators.
	
</p><a name="toc"></a><br /><hr />
<h3>Table of Contents</h3>
<p class="toc">
<a href="#anchor1">1.</a>&nbsp;
Key Words<br />
<a href="#anchor2">2.</a>&nbsp;
Introduction<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor3">2.1.</a>&nbsp;
Terminology<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor4">2.2.</a>&nbsp;
NETCONF<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor5">2.3.</a>&nbsp;
YANG<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor6">2.3.1.</a>&nbsp;
Extensibility Model<br />
<a href="#anchor7">3.</a>&nbsp;
An Architecture for NETMOD<br />
<a href="#anchor8">4.</a>&nbsp;
YANG and Related Technologies<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor9">4.1.</a>&nbsp;
YIN<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor10">4.2.</a>&nbsp;
DSDL (Relax NG)<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor11">4.3.</a>&nbsp;
YANG Types<br />
<a href="#anchor12">5.</a>&nbsp;
Applicability<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor13">5.1.</a>&nbsp;
Device Developer<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor14">5.2.</a>&nbsp;
Generic Content Support<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor15">5.3.</a>&nbsp;
XML &quot;over the wire&quot; Definitions<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor16">5.4.</a>&nbsp;
Application Developer<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor17">5.4.1.</a>&nbsp;
Hard Coded<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor18">5.4.2.</a>&nbsp;
Bottom Up<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor19">5.4.3.</a>&nbsp;
Top Down<br />
<a href="#anchor20">6.</a>&nbsp;
Modeling Considerations<br />
<a href="#anchor21">7.</a>&nbsp;
Security Considerations<br />
<a href="#rfc.references1">8.</a>&nbsp;
Normative References<br />
<a href="#rfc.authors">&#167;</a>&nbsp;
Author's Address<br />
</p>
<br clear="all" />

<a name="anchor1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1"></a><h3>1.&nbsp;
Key Words</h3>

<p>
The key words &quot;MUST&quot;, &quot;MUST NOT&quot;, &quot;REQUIRED&quot;, &quot;SHALL&quot;, &quot;SHALL NOT&quot;,
&quot;SHOULD&quot;, &quot;SHOULD NOT&quot;, &quot;RECOMMENDED&quot;, &quot;NOT RECOMMENDED&quot;, &quot;MAY&quot;, and
&quot;OPTIONAL&quot; in this document are to be interpreted as described in BCP
14, <a class='info' href='#RFC2119'>[RFC2119]<span> (</span><span class='info'>Bradner, S., &ldquo;Key words for use in RFCs to Indicate Requirement Levels,&rdquo; March&nbsp;1997.</span><span>)</span></a>.
    
</p>
<a name="anchor2"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2"></a><h3>2.&nbsp;
Introduction</h3>

<p>
Networks are increasing in complexity and capacity, as well as the
density of the services deployed upon them.  Uptime, reliability, and
predictable latency requirements drive the need for automation.
    
</p>
<p>
The problems with network management are not simple.  They are complex
and intricate.  But these problems must be solved for networks to meet the
stability needs of existing services while incorporating new
services in a world where the growth of the networks is exhausting the
supply of qualified networking engineers.  We need to move from a CLI
world into a world of automation, but that automation must be robust
and trustworthy.
    
</p>
<p>
This document presents an architecture based on NETCONF (<a class='info' href='#RFC4741'>[RFC4741]<span> (</span><span class='info'>Enns, R., &ldquo;NETCONF Configuration Protocol,&rdquo; December&nbsp;2006.</span><span>)</span></a>)
and <a class='info' href='#YANG'>[YANG]<span> (</span><span class='info'>Bjorklund, M., Ed., &ldquo;YANG - A data modeling language for NETCONF,&rdquo; .</span><span>)</span></a>.  NETCONF and YANG address the problems of network
management with flexibility and expressiveness.  NETCONF allows any
manner of configuration and operational data to be carried with
few rules governing the data.  YANG allows data models to be defined
that are flexible and extensible in ways that allow the data to
be cohesive and structured, but not rigid.
    
</p>
<p>
This approach allows the device to express its native capabilities in
a way that is flexible and extensible.  Evolution of devices and data
models are permitted and managed.
    
</p>
<a name="anchor3"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2.1"></a><h3>2.1.&nbsp;
Terminology</h3>

<p>
The document mirrors terminology from NETCONF.  NETCONF uses a simple
RPC-based mechanism to facilitate communication between a client and a
server.  The client can be a script or application typically running
as part of a network management system.  The server is typically a network
device.  The terms &quot;device&quot; and &quot;server&quot; are used interchangeably in
this document, as are &quot;client&quot; and &quot;application&quot;.
    
</p>
<a name="anchor4"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2.2"></a><h3>2.2.&nbsp;
NETCONF</h3>

<p>
NETCONF defines an XML-based RPC mechanism that leverages the
simplicity and availability of high-quality XML parsers.  XML gives a
rich, flexible, hierarchical, standard representation of data that
matches the needs of networking devices.  NETCONF carries
configuration data and operations encoded in XML using an RPC
mechanism over a connection-oriented transport.
    
</p>
<p>
XML&#039;s hierarchical data representation allows complex networking data
to be rendered in a natural way.  For example, the following
configuration places interfaces in OSPF areas.  The &lt;ospf&gt; element
contains a list of &lt;area&gt; elements, each of which contain a list of
&lt;interface&gt; elements.  The &lt;name&gt; element identifies the specific area
or interface.  Additional configuration for each area or interface
appears directly inside the appropriate element.
    
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
      &lt;ospf xmlns="http://ns.ietf.org/netconf/ospf"&gt;

        &lt;area&gt;
          &lt;name&gt;0.0.0.0&lt;/name&gt;

          &lt;interface&gt;
            &lt;name&gt;ge-0/0/0.0&lt;/name&gt;
            &lt;!-- The priority for this interface --&gt;
            &lt;priority&gt;30&lt;/priority&gt;
            &lt;metric&gt;100&lt;/metric&gt;
            &lt;dead-interval&gt;120&lt;/dead-interval&gt;
          &lt;/interface&gt;

          &lt;interface&gt;
            &lt;name&gt;ge-0/0/1.0&lt;/name&gt;
            &lt;metric&gt;140&lt;/metric&gt;
          &lt;/interface&gt;
        &lt;/area&gt;

        &lt;area&gt;
          &lt;name&gt;10.1.2.0&lt;/name&gt;

          &lt;interface&gt;
            &lt;name&gt;ge-0/0/2.0&lt;/name&gt;
            &lt;metric&gt;100&lt;/metric&gt;
          &lt;/interface&gt;

          &lt;interface&gt;
            &lt;name&gt;ge-0/0/3.0&lt;/name&gt;
            &lt;metric&gt;140&lt;/metric&gt;
            &lt;dead-interval&gt;120&lt;/dead-interval&gt;
          &lt;/interface&gt;
        &lt;/area&gt;
      &lt;/ospf&gt;
</pre></div>
<p>
NETCONF includes mechanisms for controlling configuration datastores,
fetching state data, receiving notifications, and allows for
additional RPC methods.  Configuration operations include the ability
to lock datastores to isolate one application from the actions of
others, the ability to save and restore configuration data sets, and
the ability to discover (via the &lt;hello&gt; message) the capabilities of
the device.
    
</p>
<a name="anchor5"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2.3"></a><h3>2.3.&nbsp;
YANG</h3>

<p>
YANG is the data model language for NETCONF that allows the
description of hierarchies of data model nodes (&quot;nodes&quot;) and the
constraints that exist amongst them.  YANG defines data models and how
to manipulate those models via NETCONF protocol operations.
    
</p>
<p>
Each YANG module defines a data model, uniquely identified by a
namespace URI.  These data models are extensible in a manner that
allows tight integration of standard data models and proprietary data
models.  Models are built from organizational containers, lists of
data instances and leaf data values.
    
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
    module ietf-ospf {
        namespace http://ns.ietf.org/netconf/ospf;
        prefix ospf;

        import network-types {  // Access another module's def'ns
            prefix nett;
        }

        container ospf {   // Declare the top-level tag
            list area {    // Declare a list of "area" nodes
                key name;  // The key "name" identifies list members
                leaf name {
                    type nett:area-id;
                }
                list interface {
                    key name;
                    leaf name {
                        type nett:interface-name;
                    }
                    leaf priority {
                        description "Designated router priority";
                        type uint {       // The type and range are
                            range 0..255; //  constraints on valid
                        }                 //  values for "priority".
                    }
                    leaf metric {
                        type uint {
                            range 1..65535;
                        }
                    }
                    leaf dead-interval {
                        units seconds;
                        type uint {
                            range 1..65535;
                        }
                    }
                }
            }
        }
    }
</pre></div>
<p>
A YANG module defines a data model in terms of the data, its
hierarchical organization, and the constraints on that data.  YANG
defines how this data is represented in XML and how that data is used
in NETCONF operations.
    
</p>
<a name="anchor6"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2.3.1"></a><h3>2.3.1.&nbsp;
Extensibility Model</h3>

<p>
XML includes the concept of namespaces, allowing XML elements from
different sources to be combined in the same hierarchy without
risking collision.  YANG modules define content for specific
namespaces, but one module may augment the definition of another module,
introducing elements from that module&#039;s namespace into the first
module&#039;s hierarchy.
    
</p>
<p>
Since one module can augment another module&#039;s definition, hierarchies
of definitions are allowed to grow, as definitions from multiple
sources are added to the base hierarchy.  These augmentations are
qualified using the namespace of the source module, helping to avoid
issues with name conflicts as the modules change over time.
    
</p>
<p>
For example, if the above OSPF configuration were the standard, a
vendor module may augment this with vendor-specific extensions.
    
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
    module vendorx-ospf {
        namespace http://vendorx.example.com/ospf;
        prefix vendorx;

        import ietf-ospf {
            prefix ospf;
        }
</pre></div>
<p>
BL: need leading slash:
    
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
        augment ospf:ospf/ospf:area/ospf:interfaces {
            leaf no-neighbor-down-notification {
                type empty;
                description "Don't inform other protocols about"
                          + " neighbor down events";
            }
        }
    }
</pre></div>
<p>
The &lt;no&#8209;neighbor&#8209;down&#8209;notification&gt; element is then placed in the
vendorx namespace:
    
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
    &lt;protocols xmlns="http://ietf.org/netconf/protocols"
               xmlns:vendorx="http://vendorx.example.com/ospf"&gt;
      &lt;ospf xmlns="http://ietf.org/netconf/ospf"&gt;

        &lt;area&gt;
          &lt;name&gt;0.0.0.0&lt;/name&gt;

          &lt;interface&gt;
            &lt;name&gt;ge-0/0/0.0&lt;/name&gt;
            &lt;priority&gt;30&lt;/priority&gt;
            &lt;vendorx:no-neighbor-down-notification/&gt;
          &lt;/interface&gt;

        &lt;/area&gt;
      &lt;/ospf&gt;
    &lt;/protocols&gt;
</pre></div>
<p>
Augmentations are seamlessly integrated with base modules, allowing
them to be fetched, archived, loaded, and deleted within their natural
hierarchy.  If a client application asks for the configuration for a
specific OSPF area, it will receive the sub-hierarchy for
that area, complete with any augmentations.
    
</p>
<a name="anchor7"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3"></a><h3>3.&nbsp;
An Architecture for NETMOD</h3>

<p>
In the NETMOD architecture, each device vendor implements a set of
data models in their devices.  These models are either standard data
models, defined in YANG modules published by a standards body, or
proprietary data models, defined in YANG modules published by vendors.
    
</p>
<p>
Standard data models define content that is independent of the vendor,
allowing client applications to request specific behavior without
concern for the vendor, product line, or installed software revision.
The translation between the standard model and the device specific
behavior is performed by the device, freeing the application from such
concerns.
    
</p>
<p>
Proprietary data models allow the vendor to accurately describe the
content and behavior of their devices in explicit detail.
Applications may take advantage of these specifics to give their users
complete control over the device.
    
</p>
<p>
When a NETCONF session begins, the namespaces for all supported
modules are announced as capabilities via the device&#039;s &lt;hello&gt;
message.  The device should also support the schema discovery
mechanism [ref], enabling applications to discover the location from
which the modules may be downloaded.
    
</p>
<p>
The schema discovery for standard YANG modules should list
a common, standard location for these modules, presumably one set by
the organization that defined the standard.
    
</p>
<p>
When an application connects with a device, it receives the list of
capabilities supported by that device.  The application may compare
the set of capabilities announced by the device with the set of
modules the application is aware of.  Any new modules or new revisions
of known modules may be downloaded as needed from the locations given
via the schema discovery mechanism.
    
</p>
<p>
Once the application has access to the YANG modules, it may manipulate
the device as a &quot;YANG data browser&quot;, capable of parsing the elements
sent from the device with an understanding of the organization of the
data.  The module describes the syntax of the data and constraints on
that data, allowing the application to create data that abides by
those constraints.
    
</p>
<p>
To have a real understanding of a module&#039;s content, the application
may need to incorporate logic specific to that module.  Semantic
information contained in description statements is not machine
readable, but module-specific custom work can be done to tailor the
user interface to the particular semantic needs of a module.
    
</p>
<p>
For example, a module could define the &quot;location&quot; of a device using
longitude and latitude, and the application can use the &quot;browser&quot;
style to display this data using input fields in a web form.  Custom
logic would be needed to take the value of these fields and place the
device on a map of the world, and additional logic would be needed to
update the data values when the user drags the device from Dallas to
Dulles.
    
</p>
<p>
If an application is meant to manage a specific problem, it may model
the data internally in whatever form is most convenient to its
organizational needs.  When the application interacts with a device,
it may choose one of two paths.  If the device implements a standard
module, the application may generate content for that standard by
translating its internal form into the standard one.
    
</p>
<p>
If the device doesn&#039;t implement such a standard or no such standard
exists, the application may use a transformation that is particular to
that device&#039;s vendor, product model, hardware, or software.  Depending
on the application, this transformation may be provided by the
application vendor, the device vendor, a third-party, or the provider.
    
</p>
<p>
For a popular application, the device vendor may wish to provide this
transformation to increase market acceptance of their devices.  For popular
devices, the application may provide this transformation as a means of
making the application useful in the maximum number of provider
networks.  For problem domains where the mapping from the application
to the device is not straight-forward or requires tailoring to the
specific provider or environment, the provider may wish to control
this transformation. Additionally, other parties may make
such transformations available via open source.
    
</p>
<p>
Note that both cases may appear within a single application on an &quot;as
needed&quot; basis.  If the device announces the capability for the
standard YANG module, the application may transmit to the device via
NETCONF the content in the standard modules format.  If the device
does not announce the appropriate capability, the application may find
a transformation that matches the device, perform the transformation
on the standard data to produce device native configuration, and
transmit via NETCONF that device configuration to the device.
    
</p>
<p>
In both cases, the key is the ability to discover the capabilities of
the specific device, download the YANG modules that support those
capabilities, gain an understanding of those data models and their
constraints, generate appropriate content, and transmit that content
to the device.
    
</p>
<a name="anchor8"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4"></a><h3>4.&nbsp;
YANG and Related Technologies</h3>

<p>
The YANG data modeling language is the central piece of a group of
related technologies.  The YANG language itself, described in [ref],
defines the syntax of the language and its statements, the meaning of
those statements, and how to combine them to build the hierarchy of
nodes that describe a data model.
    
</p>
<p>
That document also defines the &quot;on the wire&quot; XML content for NETCONF
operations on data models defined in YANG modules.  This includes the
basic mapping between YANG data tree nodes and XML elements, as well
as mechanisms used in &lt;edit&#8209;config&gt; content to manipulate that data,
such as arranging the order of nodes within a list.
    
</p>
<p>
YANG uses a syntax that is regular and easily described, primarily
designed for human readability.  YANG&#039;s syntax is friendly to email,
diff, patch, and the constraints of RFC formatting.
    
</p>
<a name="anchor9"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.1"></a><h3>4.1.&nbsp;
YIN</h3>

<p>
In some environments, incorporating a YANG parser may not be an
acceptable option.  For those scenarios, an XML grammar for YANG is
defined in YIN (YANG Independent Notation) [ref].  YIN allows the use
of XML parsers which are readily available in both open source and
commercial versions.  Conversion between YANG and YIN is direct,
loss-less and reversible.  YANG statements are converted to XML
elements, preserving the structure and content of YANG, but enabling
the use of off-the-shelf XML parsers rather than requiring the
integration of a YANG parser.  YIN maintains complete semantic
equivalence with YANG.
    
</p>
<p>
BL: use of xslt is a key use
    
</p>
<a name="anchor10"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.2"></a><h3>4.2.&nbsp;
DSDL (Relax NG)</h3>

<p>
Since NETCONF content is encoded in XML, it is natural to use XML
schema languages for their validation. To facilitate this, YANG
offers a standardized mapping of YANG modules into Document Schema
Description Languages (DSDL) [DSDL].
    
</p>
<p>
DSDL is considered to be the best choice for the given purpose
because it addresses not only grammar and datatypes of XML
documents but also semantic constraints and rules for modifying
information set of the document.
    
</p>
<p>
In addition, DSDL offers formal means for coordinating multiple
independent schemas and specifying how to apply the schemas to the
various parts of the document. This is useful since YANG content
is typically composed of multiple vocabularies.
    
</p>
<a name="anchor11"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.3"></a><h3>4.3.&nbsp;
YANG Types</h3>

<p>
YANG supports a number of builtin types, and allows additional types
to be derived from those types in an extensible manner.  New types can
add additional restrictions to allowable data values.
    
</p>
<p>
A standard type library for use by YANG is available [ref].
These YANG modules define commonly used data types for IETF-related
standards.
    
</p>
<a name="anchor12"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5"></a><h3>5.&nbsp;
Applicability</h3>

<p>
The data model in a YANG module yields value in five specific
areas.
    
</p>
<a name="anchor13"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.1"></a><h3>5.1.&nbsp;
Device Developer</h3>

<p>
The YANG model tells the device developer what data is being modeled.
The developer reads the YANG models, absorbs the zen of the model, and
writes code that supports the model.  The model describes the data
hierarchy and associated constraints, and the description and
reference material helps the developer understand how to transform the
models view into the device native implementation.
    
</p>
<a name="anchor14"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.2"></a><h3>5.2.&nbsp;
Generic Content Support</h3>

<p>
The YANG model can be compiled into a YANG-based engine for either the
client or server side.  Incoming data can be validated, as can
outgoing data.  The complete configuration datastore may be validated
in accordance with the constraints described in the data model.
    
</p>
<p>
Serializers and deserializers for generating and receiving NETCONF
content can be driven by the meta-data in the model.  As data is
received, the meta-data is consulted to ensure the validity of
incoming XML elements.
    
</p>
<a name="anchor15"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.3"></a><h3>5.3.&nbsp;
XML &quot;over the wire&quot; Definitions</h3>

<p>
The YANG module dictates the XML encoding sent &quot;over the wire&quot;, though
actual transmission should be encrypted so as not to appear as
readable text on the physical media.  The rules that define the
encoding are fixed, so the YANG module can be used to ascertain
whether a specific NETCONF payload is obeying the rules.
    
</p>
<a name="anchor16"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.4"></a><h3>5.4.&nbsp;
Application Developer</h3>

<p>
The YANG module tells the application developer what data can be
modeled.  Developers can inspect the modules and take one of three
distinct views.  In this section, we will consider them and the impact
of YANG on their design.  In the real world, most applications are a
mixture of these approaches.
    
</p>
<a name="anchor17"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.4.1"></a><h3>5.4.1.&nbsp;
Hard Coded</h3>

<p>
An application can be coded against the specific, well-known contents
of YANG modules, implementing their organization, rules, and logic
directly with explicit knowledge.  For example, a script could be
written to change the domain name of a set of devices using a standard
YANG module that includes such a leaf node.  This script takes the
new domain name as an argument and insert it into a string containing the
rest of the XML encoding as required by the YANG module.  This content
is then sent via NETCONF to the devices.
    
</p>
<p>
This type of application is useful for small, fixed problems where the
cost and complexity of flexibility is overwhelmed by the ease of hard
coding direct knowledge into the application.
    
</p>
<a name="anchor18"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.4.2"></a><h3>5.4.2.&nbsp;
Bottom Up</h3>

<p>
An application may take a generic, bottom up approach to
configuration, concentrating on the device&#039;s data directly and
treating that data without specific understanding.
    
</p>
<p>
YANG modules may be used to drive the operation of the YANG equivalent
of a &quot;MIB Browser&quot;.  Such an application  manipulates the device&#039;s
configuration data based on the data organization contained in the
YANG module.  For example, a GUI may present a straight-forward
visualization where elements of the YANG hierarchy are depicted in a
hierarchy of folders or GUI panels.  Clicking on a line expands to the
contents of the matching content.
    
</p>
<p>
BL: GUI comments don&#039;t need to be here
    
</p>
<p>
This type of GUI can easily be built by generating XSLT stylesheets
from the YANG data models.  An XSLT engine can then be used to turn
configuration data into a set of web pages.
    
</p>
<p>
The YANG modules allows the application to enforce a set of
constraints without understanding the semantics of the YANG
module.  
    
</p>
<a name="anchor19"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.4.3"></a><h3>5.4.3.&nbsp;
Top Down</h3>

<p>
In contrast to the bottom-up approach, the top-down approach allows
the application to take a view of the configuration data which is
distinct from the standard and/or proprietary YANG modules.  The
application is free to construct its own model for data organization
and to present this model to the user.  When the application needs to
transmit data to a device, the application transforms its data from
the problem-oriented view of the world into the data needed for that
particular device.  This transformation is under the control and
maintenance of the application, allowing the transformation to be
changed and updated without affecting the device.
    
</p>
<p>
For example, an application could be written that models VPNs in a
network-oriented view.  The application would need to transform these
high-level VPN definitions into the configuration data that would be
handed to any particular device within a VPN.
    
</p>
<a name="anchor20"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6"></a><h3>6.&nbsp;
Modeling Considerations</h3>

<p>
In developing good data models, there are many conflicting interests
the data modeler must keep in mind.  Modelers need to be aware of four
types of behavior in modeled device:
    
</p>
<p></p>
<ul class="text">
<li>
[strict compliance] behavior that follow the model completely
	
</li>
<li>
[modeled deviations] behavior that follows within deviations allowed
by the model 
	
</li>
<li>
[allowable deviations] behavior that falls outside the model, but
can still be handled
	
</li>
<li>
[unacceptable deviations] behavior that is not at all consistent
with the model
	
</li>
</ul>

<p>
Once the model is published, an implementer may decide to make a
particular data model node configurable, where the standard model
describes it a state data.  The implementation reports the value
normally and may have an &quot;out of band&quot; mechanism for reporting that
this device behaves in a different manner than the standard.
Applications capable of discovering such behavior can make allowances,
but applications that do not discover such behavior can continue
treating the implementation as if it were compliant.
    
</p>
<p>
Rarely, implementations may make decisions that prevent compliance
with the standard.  Such occasions are regrettable, but they remain a
part of reality, and modelers and application writers ignore them at
their own risk.  An implementation that emits an integer leaf as
&quot;cow&quot; would be difficult to manage, but applications must expect to
encounter such misbehaving devices in the field.
    
</p>
<p>
Despite this, both client and server should view the YANG module as a
contract, with both sides agreeing to abide by the terms.  The modeler
should be explicit about the terms of such a contract, and both client
and server implementations should strive to faithfully and accurately
implement the data model described in the YANG module.
    
</p>
<a name="anchor21"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7"></a><h3>7.&nbsp;
Security Considerations</h3>

<p>
This document defines a language with which to write and read
descriptions of management information.  The language itself has no
security impact on the Internet.
    
</p>
<a name="rfc.references1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>8.&nbsp;Normative References</h3>
<table width="99%" border="0">
<tr><td class="author-text" valign="top"><a name="RFC2119">[RFC2119]</a></td>
<td class="author-text">Bradner, S., &ldquo;<a href="http://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>,&rdquo; BCP&nbsp;14, RFC&nbsp;2119, March&nbsp;1997 (<a href="ftp://ftp.isi.edu/in-notes/rfc2119.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4741">[RFC4741]</a></td>
<td class="author-text">Enns, R., &ldquo;<a href="http://tools.ietf.org/html/rfc4741">NETCONF Configuration Protocol</a>,&rdquo; RFC&nbsp;4741, December&nbsp;2006 (<a href="ftp://ftp.isi.edu/in-notes/rfc4741.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="YANG">[YANG]</a></td>
<td class="author-text">Bjorklund, M., Ed., &ldquo;<a href="http://www.ietf.org/internet-drafts/draft-ietf-netmod-yang-05.txt">YANG - A data modeling language for NETCONF</a>,&rdquo; draft-ietf-netmod-yang-05 (work in progress).</td></tr>
</table>

<a name="rfc.authors"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>Author's Address</h3>
<table width="99%" border="0" cellpadding="0" cellspacing="0">
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Phil Shafer</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Juniper Networks</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:phil@juniper.net">phil@juniper.net</a></td></tr>
</table>
</body></html>
