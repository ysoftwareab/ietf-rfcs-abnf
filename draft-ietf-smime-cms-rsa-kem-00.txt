


S/MIME Working Group                                          B. Kaliski
Internet Draft                                          RSA Laboratories
Document: draft-ietf-smime-cms-rsa-kem-00.txt                   May 2003
Category: Standards


           Use of the RSA-KEM Key Transport Algorithm in CMS
                 <draft-ietf-smime-cms-rsa-kem-00.txt>


Status of this Memo

   This document is an Internet-Draft and is subject to all provisions 
   of Section 10 of RFC2026.

   Internet-Drafts are working documents of the Internet Engineering 
   Task Force (IETF), its areas, and its working groups.  Note that 
   other groups may also distribute working documents as Internet-
   Drafts.

   Internet-Drafts are draft documents valid for a maximum of six 
   months and may be updated, replaced, or obsoleted by other documents 
   at any time.  It is inappropriate to use Internet-Drafts as 
   reference material or to cite them other than as "work in progress."

   The list of current Internet-Drafts can be accessed at 
   http://www.ietf.org/1id-abstracts.html

   The list of Internet-Draft Shadow Directories can be accessed at 
   http://www.ietf.org/shadow.html

   Comments or suggestions for improvement may be made on the "ietf-
   smime" mailing list, or directly to the author.

Abstract

   The RSA-KEM Key Transport Algorithm is a one-pass (store-and-
   forward) mechanism for transporting keying data to a recipient using 
   the recipient's RSA public key. This document specifies the 
   conventions for using the RSA-KEM Key Transport Algorithm with the 
   Cryptographic Message Syntax (CMS).

Conventions Used in This Document

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", 
   "SHOULD", "SHOULD NOT", "RECOMMENDED",  "MAY", and "OPTIONAL" in 
   this document are to be interpreted as described in RFC 2119 
   [STDWORDS].






Kaliski              Standards - Exp: November 2003             [Page 1]

INTERNET DRAFT                                                  May 2003


1. Introduction

   The RSA-KEM Key Transport Algorithm is a one-pass (store-and-
   forward) mechanism for transporting keying data to a recipient using 
   the recipient's RSA public key.

   Most previous key transport algorithms based on the RSA public-key 
   cryptosystem (e.g., the popular PKCS #1 v1.5 algorithm [PKCS1]) have 
   the following general form:

      1. Format or "pad" the keying data to obtain an integer m.

      2. Encrypt the integer m with the recipient's RSA public key:

                                c = m^e mod n

      3. Output c as the encrypted keying data.

   The RSA-KEM Key Transport Algorithm takes a different approach that 
   provides higher security assurance, by encrypting a _random_ integer 
   with the recipient's public key, and using a symmetric key wrapping 
   scheme to encrypt the keying data. It has the following form: 

      1. Generate a random integer z between 0 and n-1.

      2. Encrypt the integer z with the recipient's RSA public key:

                                c = z^e mod n.

      3. Derive a key-encrypting key KEK from the integer z.

      4. Wrap the keying data using KEK to obtain wrapped keying data 
         KD.

      5. Output c and KD as the encrypted keying data.

   This different approach provides higher security assurance because 
   the input to the underlying RSA operation is random and independent 
   of the message, and the key-encrypting key KEK is derived from it in 
   a strong way. As a result, the algorithm enjoys a "tight" security 
   proof in the random oracle model. It is also architecturally 
   convenient because the public-key operations are separate from the 
   symmetric operations on the keying data. One benefit is that the 
   length of the keying data is bounded only by the symmetric key 
   wrapping scheme, not the size of the RSA modulus. 

   The RSA-KEM Key Transport Algorithm in various forms is being 
   adopted in several draft standards including ANSI X9.44 [ANSI-X9.44] 
   and ISO/IEC 18033-2 [ISO-IEC-18033-2]. It has also been recommended 
   by the NESSIE project [NESSIE]. Although the other standards are 
   still in development, the algorithm is fairly stable across the 
   drafts. For completeness, a specification of the algorithm is given 


Kaliski              Standards - Exp: November 2003             [Page 2]

INTERNET DRAFT                                                  May 2003


   in Appendix A of this document; ASN.1 syntax is given in Appendix B.

   NOTE: The term KEM stands for "key encapsulation mechanism" and 
   refers to the first three steps of the process above. The 
   formalization of key transport algorithms (or more generally, 
   asymmetric encryption schemes) in terms of key encapsulation 
   mechanisms is a result of research by Victor Shoup leading to the 
   development of the ISO/IEC 18033-2 standard [SHOUP].

2. Use in CMS

   The RSA-KEM Key Transport Algorithm MAY be employed for one or more 
   recipients in the CMS enveloped-data content type (Section 6 of 
   [CMS]), where the keying data processed by the algorithm is the CMS 
   content-encryption key.

   The RSA-KEM Key Transport Algorithm SHOULD be considered for new 
   CMS-based applications as a replacement for the widely implemented 
   RSA encryption algorithm specified originally in PKCS #1 v1.5 (see 
   [PKCS1] and Section 4.2.1 of [CMSALGS]), which is vulnerable to 
   chosen-ciphertext attacks. The RSAES-OAEP Key Transport Algorithm 
   has also been proposed as a replacement (see [PKCS1] and [CMS-
   OAEP]). RSA-KEM has the advantage over RSAES-OAEP of a tighter 
   security proof, but the disadvantage of slightly longer encrypted 
   keying data.

2.1 Underlying Components

   A CMS implementation that supports the RSA-KEM Key Transport 
   Algorithm MUST support at least the following underlying components:

      *  For the key derivation function, KDF2 (see [ANSI-X9.44][IEEE-
         P1363a]) based on SHA-1 (see [NIST-SHA2]) (this function is 
         also specified as the key derivation function in [ANSI-X9.63])

      *  For the key wrapping scheme, AES-Wrap-128, i.e., the AES Key 
         Wrap with a 128-bit key encrypting key (see [AES-WRAP])

   An implementation SHOULD also support KDF2 based on SHA-256 (see 
   [NIST-SHA2]), and the Triple-DES Key Wrap (see [3DES-WRAP]). It MAY 
   support other underlying components.

2.2 RecipientInfo Conventions

   When the RSA-KEM Key Transport Algorithm is employed for a 
   recipient, the RecipientInfo alternative for that recipient MUST be 
   KeyTransRecipientInfo. The algorithm-specific fields of the 
   KeyTransRecipientInfo value MUST have the following values:

      *  keyEncryptionAlgorithm.algorithm MUST be id-kts2-basic (see 
         Appendix B)



Kaliski              Standards - Exp: November 2003             [Page 3]

INTERNET DRAFT                                                  May 2003


      *  keyEncryptionAlgorithm.parameters MUST be a value of type 
         KTS2-Parms (see Appendix B)

      *  encryptedKey MUST be the encrypted keying data output by the 
         algorithm (see Appendix A)

2.3 Certificate Conventions

   A recipient who employs the RSA-KEM Key Transport Algorithm MAY 
   identify the public key in a certificate by the same 
   AlgorithmIdentifier as for the PKCS #1 v1.5 algorithm, i.e., using 
   the rsaEncryption object identifier [PKCS1].

   If the recipient wishes only to employ the RSA-KEM Key Transport 
   Algorithm with a given public key, the recipient MUST identify the 
   public key in the certificate using the id-kts2-basic object 
   identifier (see Appendix B) where the KTS2-Params value indicates 
   the underlying components with which the algorithm is to be 
   employed.

   [[matching rules to be added]]

2.4 SMIMECapabilities Attribute Conventions

   [[to be added]]

3. Security Considerations

   The security of the RSA-KEM Key Transport Algorithm described in 
   this document has been shown to be tightly related to the difficulty 
   of either solving the RSA problem or breaking the underlying 
   symmetric key wrapping scheme, if the underlying key derivation 
   function is modeled as a random oracle [SHOUP]. While in practice a 
   random-oracle result does not provide an actual security proof for 
   any particular key derivation function, the result does provide 
   assurance that the general construction is reasonable; a key 
   derivation function would need to be particularly weak to lead to an 
   attack that is not possible in the random oracle model.

   The RSA key size and the underlying components should be selected 
   consistent with the desired symmetric security level for an 
   application. Several security levels have been identified in [NIST-
   GUIDELINES]. For brevity, the first three levels are mentioned here:

      *  80-bit security. The RSA key size SHOULD be at least 1024 
         bits, the hash function underlying KDF2 SHOULD be SHA-1 or 
         above, and the symmetric key-wrapping scheme SHOULD be AES Key 
         Wrap or Triple-DES Key Wrap.

      *  112-bit security. The RSA key size SHOULD be at least 2048 
         bits, the hash function underlying KDF2 SHOULD be SHA-224 or 
         above, and the symmetric key-wrapping scheme SHOULD be AES Key 
         Wrap or Triple-DES Key Wrap.

Kaliski              Standards - Exp: November 2003             [Page 4]

INTERNET DRAFT                                                  May 2003


      *  128-bit security. The RSA key size SHOULD be at least 3072 
         bits, the hash function underlying KDF2 SHOULD be SHA-256 or 
         above, and the symmetric key-wrapping scheme SHOULD be AES Key 
         Wrap.

   Note that the AES Key Wrap MAY be used at all three of these levels; 
   the use of AES does not require a 128-bit security level for other 
   components.

   The security of the algorithm also depends on the strength of the 
   random number generator, which SHOULD have a comparable security 
   level. For further discussion on random number generation, please 
   see [RANDOM].

   Implementations SHOULD NOT reveal information about intermediate 
   values or calculations, whether by timing or other "side channels", 
   or otherwise an opponent may be able to determine information about 
   the keying data and/or the recipient's private key. Although not all 
   intermediate information may be useful to an opponent, it is 
   preferable to conceal as much information as is it practical to, 
   unless analysis specifically indicates that the information would 
   not be useful.

   Parties MAY wish to formalize the assurance that one another's 
   implementations are correct through implementation validation, e.g. 
   NIST's Cryptographic Module Validation Program (CMVP).

4. References

4.1 Normative References

   3DES-WRAP         Housley, R. Triple-DES and RC2 Key Wrapping. RFC 
                     3217. December 2001.

   AES-WRAP          Schaad, J. and R. Housley. Advanced Encryption 
                     Standard (AES) Key Wrap Algorithm. RFC 3394. 
                     September 2002.

   ANSI-X9.63        American National Standard X9.63-2002: Public Key 
                     Cryptography for the Financial Services Industry: 
                     Key Agreement and Key Transport Using Elliptic 
                     Curve Cryptography.

   CMS               Housley, R. Cryptographic Message Syntax. RFC 
                     3369. August 2002.

   CMSALGS           Housley, R. Cryptographic Message Syntax (CMS) 
                     Algorithms. RFC 3370. August 2002.

   NIST-SHA2         National Institute of Standards and Technology 
                     (NIST). FIPS 180-2: Secure Hash Standard. August 
                     2002.


Kaliski              Standards - Exp: November 2003             [Page 5]

INTERNET DRAFT                                                  May 2003


   STDWORDS          Bradner, S. Key Words for Use in RFCs to Indicate 
                     Requirement Levels. RFC 2119. March 1997.

4.2 Informative References

   ANSI-X9.44        ANSI X9F1 Working Group. ANSI X9.44: Public Key 
                     Cryptography for the Financial Services Industry -
                     - Key Establishment Using Integer Factorization 
                     Cryptography. Draft D4.1, April 1, 2003.

   CMS-OAEP          Housley, R. Use of the RSAES-OAEP Key Transport 
                     Algorithm in CMS. Internet Draft <draft-ietf-
                     smime-cms-rsaes-oaep-07.txt>. December 2002.

   IEEE-P1363a       IEEE P1363 Working Group. IEEE P1363a: Standard 
                     Specifications for Public Key Cryptography: 
                     Additional Techniques. Draft D12, May 12, 2003. 
                     Available via http://grouper.ieee.org/groups/1363.

   ISO-IEC-18033-2   ISO/IEC 18033-2: Information technology -- 
                     Security techniques -- Encryption algorithms -- 
                     Part 2: Asymmetric Ciphers. Committee Draft, 
                     December 18, 2002.

   NESSIE            NESSIE Consortium. Portfolio of Recommended 
                     Cryptographic Primitives. February 27, 2003. 
                     Available via http://www.cryptonessie.org/.

   NIST-GUIDELINES   National Institute of Standards and Technology. 
                     Special Publication 800-57: Recommendation for Key 
                     Management. Part 1: General Guideline. Draft, 
                     January 2003. Available via 
                     http://csrc.nist.gov/CryptoToolkit/tkkeymgmt.html.

   NIST-SCHEMES      National Institute of Standards and Technology. 
                     Special Publication 800-56: Recommendation on Key 
                     Establishment Schemes. Draft 2.0, January 2003. 
                     Available via 
                     http://csrc.nist.gov/CryptoToolkit/tkkeymgmt.html.

   PKCS1             Jonsson, J. and B. Kaliski. PKCS #1: RSA 
                     Cryptography Specifications Version 2.1. RFC 3447. 
                     February 2003.

   RANDOM            Eastlake, D., S. Crocker, and J. Schiller. 
                     Randomness Recommendations for Security. RFC 1750. 
                     December 1994.

   SHOUP             Shoup, V. A Proposal for an ISO Standard for 
                     Public Key Encryption. Version 2.1, December 20, 
                     2001. Available via http://www.shoup.net/papers/.



Kaliski              Standards - Exp: November 2003             [Page 6]

INTERNET DRAFT                                                  May 2003


5. IANA Considerations

   Within the CMS, algorithms are identified by object identifiers 
   (OIDs). All of the OIDs used in this document were assigned in 
   Public-Key Cryptography Standards (PKCS) documents, Accredited 
   Standards Committee (ASC) X9 documents, or by the National Institute 
   of Standards and Technology (NIST). No further action by the IANA is 
   necessary for this document or any anticipated updates.

6. Acknowledgments

   This document is one part of a strategy to align algorithm standards 
   produced by ASC X9, ISO/IEC JTC1 SC27, NIST, and the IETF. I would 
   like to thank the members of the ANSI X9F1 working group for their 
   contributions to drafts of ANSI X9.44 which led to this 
   specification. My thanks as well to Russ Housley as well for his 
   guidance and encouragement.

7. Author Address

   Burt Kaliski
   RSA Laboratories
   174 Middlesex Turnpike
   Bedford, MA  01730
   USA
   bkaliski@rsasecurity.com

Appendix A. RSA-KEM Key Transport Algorithm

   The RSA-KEM Key Transport Algorithm is a one-pass (store-and-
   forward) mechanism for transporting keying data to a recipient using 
   the recipient's RSA public key.

   With this type of algorithm, a sender encrypts the keying data using 
   the recipient's public key to obtain encrypted keying data. The 
   recipient decrypts the encrypted keying data using the recipient's 
   private key to recover the keying data.

A.1 Underlying Components

   The algorithm has the following underlying components:

       * KDF, a key derivation function, which derives keying data of a 
         specified length from a shared secret value

       * Wrap, a symmetric key wrapping scheme, which encrypts keying 
         data using a key-encrypting key

   In the following, kekLen denotes the length in bytes of the key-
   encrypting key for the underlying symmetric key-wrapping scheme.

   In this scheme, the length of the keying data to be transported MUST 
   be among the lengths supported by the underlying symmetric key 

Kaliski              Standards - Exp: November 2003             [Page 7]

INTERNET DRAFT                                                  May 2003


   wrapping scheme. (The AES Key Wrap, for instance, requires the 
   length of the keying data to be a multiple of 8 bytes, and at least 
   16 bytes.) Usage and formatting of the keying data (e.g., parity 
   adjustment for Triple-DES keys) is outside the scope of this 
   algorithm.

   With some key derivation functions, it is possible to include other 
   information besides the shared secret value in the input to the 
   function. Also, with some symmetric key wrapping schemes, it is 
   possible to associate a label with the keying data. Such uses are 
   outside the scope of this document, as they are not directly 
   supported by CMS.

A.2 Sender's Operations

   Let (n,e) be the recipient's RSA public key (see [PKCS1] for 
   details) and let K be the keying data to be transported.

   Let nLen denote the length in bytes of the modulus n, i.e., the 
   least integer such that 2^{8*nLen} > n.

   The sender performs the following operations:

      1. Generate a random integer z between 0 and n-1 (see Note), and 
         convert z to a byte string Z of length nLen, most significant 
         byte first:

                          z = RandomInteger (0, n-1)
                         Z = IntegerToString (z, nLen)

      2. Encrypt the random integer z using the recipient's public key 
         (n,e) and convert the resulting integer c to a ciphertext C, a 
         byte string of length nLen:

                                 c = z^e mod n
                         C = IntegerToString (c, nLen)

      3. Derive a key-encrypting key KEK of length kekLen bytes from 
         the byte string Z using the underlying key derivation 
         function:

                             KEK = KDF (Z, kekLen)

      4. Wrap the keying data K using the underlying key wrapping 
         scheme with the key-encrypting key KEK to obtain wrapped 
         keying data WK:

                              WK = Wrap (KEK, K)

     5. Concatenate the ciphertext C and the wrapped keying data WK to 
        obtain the encrypted keying data EK:

                                 EK = C || WK

Kaliski              Standards - Exp: November 2003             [Page 8]

INTERNET DRAFT                                                  May 2003


      6. Output the encrypted keying data EK.

   NOTE: The random integer z MUST be generated independently at random 
   for different encryption operations, whether for the same or 
   different recipients.

A.3 Recipient's Operations

   Let (n,d) be the recipient's RSA private key (see [PKCS1]; other 
   private key formats are allowed) and let EK be the encrypted keying 
   data.

   Let nLen denote the length in bytes of the modulus n.

   The recipient performs the following operations:

      1. Separate the encrypted keying data EK into a ciphertext C of 
         length nLen bytes and wrapped keying data WK:

                                 C || WK = EK

         If the length of the encrypted keying data is less than nLen 
         bytes, output "decryption error" and stop.

      2. Convert the ciphertext C to an integer c, most significant 
         byte first. Decrypt the integer c using the recipient's 
         private key (n,d) to recover an integer z (see Note):

                            c = StringToInteger (C)
                                 z = c^d mod n

         If the integer c is not between 0 and n-1, output "decryption 
         error" and stop.

      3. Convert the integer z to a byte string Z of length nLen, most 
         significant byte first (see Note):

                         Z = IntegerToString (z, nLen)

      4. Derive a key-encrypting key KEK of length kekLen bytes from 
         the byte string Z using the underlying key derivation function 
         (see Note):

                             KEK = KDF (Z, kekLen)

      5. Unwrap the wrapped keying data WK using the underlying key 
         wrapping scheme with the key-encrypting key KEK to recover the 

         keying data K:

                             K = Unwrap (KEK, WK)



Kaliski              Standards - Exp: November 2003             [Page 9]

INTERNET DRAFT                                                  May 2003


         If the unwrapping operation outputs an error, output 
         "decryption error" and stop.

      6. Output the keying data K.

   NOTE: Implementations SHOULD NOT reveal information about the 
   integer z and the string Z, nor about the calculation of the 
   exponentiation in Step 2, the conversion in Step 3, or the key 
   derivation in Step 4, whether by timing or other "side channels". 
   The observable behavior of the implementation SHOULD be the same at 
   these steps for all ciphertexts C that are in range. (For example, 
   IntegerToString conversion should take the same amount of time 
   regardless of the actual value of the integer z.) The integer z, the 
   string Z and other intemediate results MUST be securely deleted when 
   they are no longer needed.

Appendix B. ASN.1 Syntax

   The ASN.1 syntax for identifying the RSA-KEM Key Transport Algorithm 
   is a special case of the syntax for Key Transport Scheme 2 (KTS2) in 
   the draft ANSI X9.44 [ANSI-X9.44]. The syntax for the scheme is 
   given in Section B.1. The syntax for selected underlying components 
   including those mentioned above is given in B.2.

   The following object identifier prefixes are used in the definitions 
   below:

      x9-44 OID ::= {
         iso(1) identified-organization(3) tc68(133) country(16) 
         x9(840) x9Standards(9) x9-44(44)  
      }

      pkcs-1 OID ::= {
         iso(1) member-body(2) us(840) rsadsi(113549) pkcs(1) pkcs-1(1)
      }

      nistAlgorithm OID ::= {
         joint-iso-itu-t(2) country(16) us(840) organization(1) 
         gov(101) csor(3) nistAlgorithm(4) 
      }

   The material in this Appendix is based on a draft standard and is 
   SUBJECT TO CHANGE as that standard is developed.

B.1 RSA-KEM Key Transport Algorithm

   The object identifier for the RSA-KEM Key Transport Algorithm is the 
   same as for the basic KTS2 scheme in the draft ANSI X9.44, id-kts2-
   basic, which is defined in the draft as

      id-kts2-basic OID ::= { x9-44 schemes(2) kts2-basic(7) }



Kaliski              Standards - Exp: November 2003            [Page 10]

INTERNET DRAFT                                                  May 2003


   The associated parameters for id-kts2-basic have type KTS2-Parms:

      KTS2-Parms ::= SEQUENCE {
         kas          [0] KTS2-KeyAgreementScheme,
         kws          [1] KTS2-SymmetricKeyWrappingScheme,
         labelMethod  [2] KTS2-LabelMethod
      }

   The fields of type KTS2-Parms have the following meanings:

      *  kas identifies the underlying key agreement scheme. For the 
         RSA-KEM Key Transport Algorithm, the scheme is the basic Key 
         Agreement Scheme 1 (KAS1) from the draft ANSI X9.44.

         The object identifier for the basic KAS1 is id-kas1-basic, 
         which is defined in the draft ANSI X9.44 as

            id-kas1-basic OID ::= { x9-44 schemes(2) kas1-basic(1) }

         The associated parameters for id-kas1-basic have type KAS1-
         Parms:

            KAS1-Parms ::= SEQUENCE {
               sves             [0] KAS1-SecretValueEncapsulationScheme,
               kdf              [1] KAS1-KeyDerivationFunction,
               otherInfoMethod  [2] KAS1-OtherInfoMethod
         }

         The fields of type KAS1-Parms have the following meanings:

            *  sves identifies the underlying secret-value
               encapsulation mechanism. (In the draft ANSI X9.44, the 
               term "Secret Value Encapsulation Scheme" refers to the 
               first _two_ steps of the RSA-KEM Key Transport 
               Algorithm, which are separated from the key derivation 
               function for architectural reasons.) For the RSA-KEM Key 
               Transport Algorithm, the mechanism is RSASVES1 from the 
               draft ANSI X9.44.

               The object identifier for RSASVES1 is id-rsasves1, which 
               is defined in the draft ANSI X9.44 as

                  id-rsasves1 OID ::= { 
                     x9-44 components(1) rsasves1(2)
                  }

               This object identifier has no associated parameters.

            *  kdf identifies the underlying key derivation function. 
               For alignment with the draft ANSI X9.44, it MUST be 
               KDF2. However, other key derivation functions MAY be 
               used with CMS. Please see B.2.1 for the syntax for KDF2.


Kaliski              Standards - Exp: November 2003            [Page 11]

INTERNET DRAFT                                                  May 2003


                  KAS1-KeyDerivationFunction ::= AlgorithmIdentifier

            *  otherInfoMethod specifies the method for formatting 
               other information to be included in the input to the key 
               derivation function. For this version of the document, 
               the method MUST be the "specified other information" 
               method.

                  KAS1-OtherInfoMethod ::= AlgorithmIdentifier

               The object identifier for the "specified other 
               information" method is id-specifiedOtherInfo:

                  id-specifiedOtherInfo OID ::= [[to be defined]]

               The associated parameters for id-specifiedOtherInfo have 
               type SpecifiedOtherInfo:

                  SpecifiedOtherInfo ::= OCTET STRING SIZE((0..MAX))

               For this version of the document, the value of the other 
               information MUST be the empty string.

      *  kws identifies the underlying symmetric key-wrapping scheme. 
         For alignment with the draft ANSI X9.44, it MUST be an X9-
         approved symmetric key-wrapping scheme. (See Note.) However, 
         other schemes MAY be used with CMS. Please see B.2.2 for the 
         syntax for the AES and Triple-DES Key Wraps.

            KTS2-SymmetricKeyWrappingScheme ::= AlgorithmIdentifier

      *  labelMethod specifies the method for formatting a label to be 
         associated with the keying data. For this version of the 
         document, the method MUST be the "specified label" method.

            KTS2-LabelMethod ::= AlgorithmIdentifier

         The object identifier for the "specified label" method is id-
         specifiedLabel, which is defined in the draft ANSI X9.44 as

            id-specifiedLabel OID ::= { pkcs-1 specifiedLabel(9) } 

         The associated parameters for id-specifiedLabel have type 
         SpecifiedLabel:

            SpecifiedLabel ::= OCTET STRING SIZE((0..MAX))

         For this version of the document, the value of the label MUST 
         be the empty string.

   NOTE: As of this writing, the AES Key Wrap and the Triple-DES Key 
   Wrap are in the process of being approved by X9.


Kaliski              Standards - Exp: November 2003            [Page 12]

INTERNET DRAFT                                                  May 2003


   DISCUSSION TOPIC: In NIST's key establishment schemes recommendation 
   [NIST-SCHEMES], the parties' names are included in the "other 
   information" for key derivation. Should they be included here as 
   well?

B.2 Selected Underlying Components

B.2.1 Key Derivation Functions

   The object identifier for KDF2 (see [ANSI-X9.44]) is

      id-kdf2 OID ::= { x9-44 components(1) kdf2(1) }

   The associated parameters identify the underlying hash function. For 
   alignment with the draft ANSI X9.44, the hash function MUST be an 
   X9-approved hash function. (See Note.) However, other hash functions 
   MAY be used with CMS.

      KDF2-Parms ::= AlgorithmIdentifier

   The object identifier for SHA-1 is

      id-sha1 OID ::= {
         iso(1) identified-organization(3) oiw(14) secsig(3) 
         algorithms(2) sha1(26)
     }

   The object identifiers for SHA-256, SHA-384 and SHA-512 are

      id-sha256 OID ::= { nistAlgorithm hashAlgs(2) sha256(1) }
      id-sha384 OID ::= { nistAlgorithm hashAlgs(2) sha384(2) }
      id-sha512 OID ::= { nistAlgorithm hashAlgs(2) sha512(3) }

   There has been some confusion over whether the various SHA object 
   identifiers have a NULL parameter, or no associated parameters. As 
   also discussed in [PKCS1], implementations SHOULD generate algorithm 
   identifiers without parameters, and MUST accept algorithm 
   identifiers either without parameters, or with NULL parameters.

   NOTE: As of this writing, only SHA-1 is an X9-approved hash 
   function; SHA-224 and above are in the process of being approved. 
   The object identifier for SHA-224 has not yet been assigned.

B.2.2 Symmetric Key Wrapping Schemes

   The object identifier for the AES Key Wrap depends on the size of 
   the key encrypting key. There are three object identifiers (see 
    [AES-WRAP]):

      id-aes128-Wrap OID ::= { nistAlgorithm aes(1) aes128-Wrap(5)  } 
      id-aes192-Wrap OID ::= { nistAlgorithm aes(1) aes192-Wrap(25) } 
      id-aes256-Wrap OID ::= { nistAlgorithm aes(1) aes256-Wrap(45) }

Kaliski              Standards - Exp: November 2003            [Page 13]

INTERNET DRAFT                                                  May 2003


   These object identifiers have no associated parameters.

   The object identifier for the Triple-DES Key Wrap (see [3DES-WRAP]) 
   is

      id-alg-CMS3DESwrap OBJECT IDENTIFIER ::= {
         iso(1) member-body(2) us(840) rsadsi(113549) pkcs(1) pkcs-9(9)
         smime(16) alg(3) 6
      }

   This object identifier has a NULL parameter.

B.3 Example

   As an example, if the key derivation function is KDF2 based on SHA-1 
   and the symmetric key wrapping scheme is the AES Key Wrap with a 
   128-bit KEK, the AlgorithmIdentifier for the RSA-KEM Key Transport 
   Algorithm will have the following value:

      SEQUENCE {
         id-kts2-basic,                                    -- basic KTS2
         SEQUENCE {                                        -- KTS2-Parms
            [0] SEQUENCE {                       -- key agreement scheme
               id-kas1-basic,                              -- basic KAS1
               SEQUENCE {                                  -- KAS1-Parms
                  [0] SEQUENCE {    -- secret value encapsulation scheme
                     id-rsasves1              -- RSASVES1; no parameters
                  },
                  [1] SEQUENCE {              -- key derivation function
                     id-kdf2,                                    -- KDF2
                     SEQUENCE {                            -- KDF2-Parms
                       id-sha1              -- no parameters (preferred)
                     }
                  },
                  [2] SEQUENCE {             -- other information method
                     id-specifiedOtherInfo,     -- specified other info.
                     ''H                                 -- empty string
                  }
               }
            },
            [1] SEQUENCE {              -- symmetric key wrapping scheme
               id-aes128-Wrap             -- AES-128 Wrap; no parameters
            },
            [2] SEQUENCE {                               -- label method
               id-specifiedLabel,                     -- specified label
               ''H                                       -- empty string
            }
         } 
      }





Kaliski              Standards - Exp: November 2003            [Page 14]

INTERNET DRAFT                                                  May 2003


Full Copyright Statement

   Copyright (C) The Internet Society (2003). All Rights Reserved.

   This document and translations of it may be copied and furnished to 
   others, and derivative works that comment on or otherwise explain it 
   or assist in its implementation may be prepared, copied, published 
   and distributed, in whole or in part, without restriction of any 
   kind, provided that the above copyright notice and this paragraph 
   are included on all such copies and derivative works.  However, this 
   document itself may not be modified in any way, such as by removing 
   the copyright notice or references to the Internet Society or other 
   Internet organizations, except as needed for the purpose of 
   developing Internet standards in which case the procedures for 
   copyrights defined in the Internet Standards process must be 
   followed, or as required to translate it into languages other than 
   English.

   The limited permissions granted above are perpetual and will not be 
   revoked by the Internet Society or its successors or assigns. 


































Kaliski              Standards - Exp: November 2003            [Page 15]
