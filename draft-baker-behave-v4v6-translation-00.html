<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="en"><head><title>IP/ICMP Translation
    Algorithm</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="description" content="IP/ICMP Translation
    Algorithm">
<meta name="generator" content="xml2rfc v1.35 (http://xml.resource.org/)">
<meta name="viewport" content="width=600;" />
<style type='text/css'><!--
        body {
                font-family: verdana, charcoal, helvetica, arial, sans-serif;
                font-size: 85%;
		max-width: 40em; 
		color: #000; background-color: #FFF;
                margin: 2em;
        }
        h1, h2, h3, h4, h5, h6 {
                font-family: helvetica, monaco, "MS Sans Serif", arial, sans-serif;
                font-weight: bold; font-style: normal;
        }
        h1 { color: #900; background-color: transparent; text-align: right; }
        h3 { color: #333; background-color: transparent; }

        td.RFCbug {
                font-size: x-small; text-decoration: none;
                width: 30px; height: 30px; padding-top: 2px;
                text-align: justify; vertical-align: middle;
                background-color: #000;
        }
        td.RFCbug span.RFC {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: bold; color: #666;
        }
        td.RFCbug span.hotText {
                font-family: charcoal, monaco, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: normal; text-align: center; color: #FFF;
        }

        table.TOCbug { width: 30px; height: 15px; }
        td.TOCbug {
                text-align: center; width: 30px; height: 15px;
                color: #FFF; background-color: #900;
        }
        td.TOCbug a {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, sans-serif;
                font-weight: bold; font-size: x-small; text-decoration: none;
                color: #FFF; background-color: transparent;
        }

        td.header {
                font-family: arial, helvetica, sans-serif; font-size: x-small;
                vertical-align: top; width: 33%;
                color: #FFF; background-color: #666;
        }
        td.author { font-weight: bold; font-size: x-small; margin-left: 4em; }
        td.author-text { font-size: x-small; }

        /* info code from SantaKlauss at http://www.madaboutstyle.com/tooltip2.html */
        a.info {
                /* This is the key. */
                position: relative;
                z-index: 24;
                text-decoration: none;
        }
        a.info:hover {
                z-index: 25;
                color: #FFF; background-color: #900;
        }
        a.info span { display: none; }
        a.info:hover span.info {
                /* The span will display just on :hover state. */
                display: block;
                position: absolute;
                font-size: smaller;
                top: 2em; left: -5em; width: 15em;
                padding: 2px; border: 1px solid #333;
                color: #900; background-color: #EEE;
                text-align: left;
        }

        a { font-weight: bold; }
        a:link    { color: #900; background-color: transparent; }
        a:visited { color: #633; background-color: transparent; }
        a:active  { color: #633; background-color: transparent; }

        p { margin-left: 2em; margin-right: 2em; }
        p.copyright { font-size: x-small; }
        p.toc { font-size: 85%;
		max-width: 40em; 
		font-weight: bold; margin-left: 3em; }
        table.toc { margin: 0 0 0 3em; padding: 0; border: 0; vertical-align: text-top; }
        td.toc { font-size: 85%;
		max-width: 40em; 
		font-weight: bold; vertical-align: text-top; }

        ol.text { margin-left: 2em; margin-right: 2em; }
        ul.text { margin-left: 2em; margin-right: 2em; }
        li      { margin-left: 3em; }

        /* RFC-2629 <spanx>s and <artwork>s. */
        em     { font-style: italic; }
        strong { font-weight: bold; }
        dfn    { font-weight: bold; font-style: normal; }
        cite   { font-weight: normal; font-style: normal; }
        tt     { color: #036; }
        tt, pre, pre dfn, pre em, pre cite, pre span {
                font-family: "Courier New", Courier, monospace; font-size: small;
        }
        pre {
                text-align: left; padding: 4px;
                color: #000; background-color: #CCC;
        }
        pre dfn  { color: #900; }
        pre em   { color: #66F; background-color: #FFC; font-weight: normal; }
        pre .key { color: #33C; font-weight: bold; }
        pre .id  { color: #900; }
        pre .str { color: #000; background-color: #CFF; }
        pre .val { color: #066; }
        pre .rep { color: #909; }
        pre .oth { color: #000; background-color: #FCF; }
        pre .err { background-color: #FCC; }

        /* RFC-2629 <texttable>s. */
        table.all, table.full, table.headers, table.none {
                font-size: 85%;
		max-width: 40em; 
		text-align: center; border-width: 2px;
                vertical-align: top; border-collapse: collapse;
        }
        table.all, table.full { border-style: solid; border-color: black; }
        table.headers, table.none { border-style: none; }
        th {
                font-weight: bold; border-color: black;
                border-width: 2px 2px 3px 2px;
        }
        table.all th, table.full th { border-style: solid; }
        table.headers th { border-style: none none solid none; }
        table.none th { border-style: none; }
        table.all td {
                border-style: solid; border-color: #333;
                border-width: 1px 2px;
        }
        table.full td, table.headers td, table.none td { border-style: none; }

        hr { height: 1px; }
        hr.insert {
                width: 80%; border-style: none; border-width: 0;
                color: #CCC; background-color: #CCC;
        }
--></style>
</head>
<body>
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<table summary="layout" width="66%" border="0" cellpadding="0" cellspacing="0"><tr><td><table summary="layout" width="100%" border="0" cellpadding="2" cellspacing="1">
<tr><td class="header">behave</td><td class="header">X. Li, Ed.</td></tr>
<tr><td class="header">Internet-Draft</td><td class="header">C. Bao, Ed.</td></tr>
<tr><td class="header">Intended status: Informational</td><td class="header">CERNET Center/Tsinghua University</td></tr>
<tr><td class="header">Expires: April 29, 2009</td><td class="header">F. Baker, Ed.</td></tr>
<tr><td class="header">&nbsp;</td><td class="header">Cisco Systems</td></tr>
<tr><td class="header">&nbsp;</td><td class="header">October 26, 2008</td></tr>
</table></td></tr></table>
<h1><br />IP/ICMP Translation
    Algorithm<br />draft-baker-behave-v4v6-translation-00</h1>

<h3>Status of this Memo</h3>
<p>
By submitting this Internet-Draft,
each author represents that any applicable patent or other IPR claims of which
he or she is aware have been or will be disclosed,
and any of which he or she becomes aware will be disclosed,
in accordance with Section&nbsp;6 of BCP&nbsp;79.</p>
<p>
Internet-Drafts are working documents of the Internet Engineering
Task Force (IETF), its areas, and its working groups.
Note that other groups may also distribute working documents as
Internet-Drafts.</p>
<p>
Internet-Drafts are draft documents valid for a maximum of six months
and may be updated, replaced, or obsoleted by other documents at any time.
It is inappropriate to use Internet-Drafts as reference material or to cite
them other than as &ldquo;work in progress.&rdquo;</p>
<p>
The list of current Internet-Drafts can be accessed at
<a href='http://www.ietf.org/ietf/1id-abstracts.txt'>http://www.ietf.org/ietf/1id-abstracts.txt</a>.</p>
<p>
The list of Internet-Draft Shadow Directories can be accessed at
<a href='http://www.ietf.org/shadow.html'>http://www.ietf.org/shadow.html</a>.</p>
<p>
This Internet-Draft will expire on April 29, 2009.</p>

<h3>Abstract</h3>

<p>This document specifies an update to the Stateless IP/ICMP
      Translation Algorithm (SIIT) described in RFC 2765. The algorithm
      translates between IPv4 and IPv6 packet headers (including ICMP
      headers).
</p>
<p>This specification addresses both a stateful and a stateless mode. In
      the stateful mode, translation state is maintained between IPv4
      address/transport/port tuples and IPv6 address/transport/port tuples,
      enabling IPv6 systems to open sessions with IPv4 systems. In the
      stateless mode, translation information is carried in the address
      itself, permitting both IPv4-&gt;IPv6 and IPv6-&gt;IPv4 session
      establishment with neither state nor configuration in the translator.
      The choice of operational mode is made by the operator deploying the
      network and is critical to the operation of the applications using
      it.
</p>
<p>Significant issues exist in the stateful mode that are not addressed
      in this document, related to the maintenance of the translation tables.
      This document confines itself to the actual translation.
</p>
<h3>Acknowledgement of previous work</h3>

<p>This document is a product of the 2008-2009 effort to define a
      replacement for NAT-PT. It is an update to and directly derivative from
      Erik Nordmark's <a class='info' href='#RFC2765'>[RFC2765]<span> (</span><span class='info'>Nordmark, E., &ldquo;Stateless IP/ICMP Translation Algorithm (SIIT),&rdquo; February&nbsp;2000.</span><span>)</span></a>, which similarly provides
      both stateless and stateful translation between <a class='info' href='#RFC0791'>IPv4<span> (</span><span class='info'>Postel, J., &ldquo;Internet Protocol,&rdquo; September&nbsp;1981.</span><span>)</span></a> [RFC0791] and <a class='info' href='#RFC2460'>IPv6<span> (</span><span class='info'>Deering, S. and R. Hinden, &ldquo;Internet Protocol, Version 6 (IPv6) Specification,&rdquo; December&nbsp;1998.</span><span>)</span></a> [RFC2460], and
      between <a class='info' href='#RFC0792'>ICMPv4<span> (</span><span class='info'>Postel, J., &ldquo;Internet Control Message Protocol,&rdquo; September&nbsp;1981.</span><span>)</span></a> [RFC0792] and <a class='info' href='#RFC4443'>ICMPv6<span> (</span><span class='info'>Conta, A., Deering, S., and M. Gupta, &ldquo;Internet Control Message Protocol (ICMPv6) for the Internet Protocol Version 6 (IPv6) Specification,&rdquo; March&nbsp;2006.</span><span>)</span></a> [RFC4443]. The original document was a product of
      the NGTRANS working group. Some text had been extracted from an old
      Internet Draft titled "IPAE: The SIPP Interoperability and Transition
      Mechanism" authored by R. Gilligan, E. Nordmark, and B. Hinden.
</p>
<p>The changes in this document reflect five components:</p>
<ol class="text">
<li>Updating references
</li>
<li>Redescribing the network model to map to present and projected
          usage
</li>
<li>Moving the address format to the framework document, to
          coordinate with other drafts on the topic
</li>
<li>Some changes in ICMP.
</li>
<li>Description of both stateful and stateless operation.
</li>
</ol>
<a name="toc"></a><br /><hr />
<h3>Table of Contents</h3>
<p class="toc">
<a href="#section1">1.</a>&nbsp;
Introduction and Motivation<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section1.1">1.1.</a>&nbsp;
Applicability and Limitations<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section1.2">1.2.</a>&nbsp;
Assumptions<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#prefix-stateless">1.3.</a>&nbsp;
Stateless vs Stateful Mode<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section1.3">1.4.</a>&nbsp;
Impact Outside the Network Layer<br />
<a href="#section2">2.</a>&nbsp;
Terminology<br />
<a href="#section2.2">3.</a>&nbsp;
Requirements<br />
<a href="#section3">4.</a>&nbsp;
Translating from IPv4 to IPv6<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section3.1">4.1.</a>&nbsp;
Translating IPv4 Headers into IPv6 Headers<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section3.2">4.2.</a>&nbsp;
Translating UDP over IPv4<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section3.3">4.3.</a>&nbsp;
Translating ICMPv4 Headers into ICMPv6 Headers<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section3.4">4.4.</a>&nbsp;
Translating ICMPv4 Error Messages into ICMPv6<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section3.5">4.5.</a>&nbsp;
Knowing when to Translate<br />
<a href="#section4">5.</a>&nbsp;
Translating from IPv6 to IPv4<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section4.1">5.1.</a>&nbsp;
Translating IPv6 Headers into IPv4 Headers<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section4.2">5.2.</a>&nbsp;
Translating ICMPv6 Headers into ICMPv4 Headers<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section4.3">5.3.</a>&nbsp;
Translating ICMPv6 Error Messages into ICMPv4<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section4.4">5.4.</a>&nbsp;
Knowing when to Translate<br />
<a href="#section5">6.</a>&nbsp;
Implications for IPv6-Only Nodes<br />
<a href="#IANA">7.</a>&nbsp;
IANA Considerations<br />
<a href="#Security">8.</a>&nbsp;
Security Considerations<br />
<a href="#Acknowledgements">9.</a>&nbsp;
Acknowledgements<br />
<a href="#rfc.references1">10.</a>&nbsp;
References<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#rfc.references1">10.1.</a>&nbsp;
Normative References<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#rfc.references2">10.2.</a>&nbsp;
Informative References<br />
<a href="#rfc.authors">&#167;</a>&nbsp;
Authors' Addresses<br />
<a href="#rfc.copyright">&#167;</a>&nbsp;
Intellectual Property and Copyright Statements<br />
</p>
<br clear="all" />

<a name="section1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1"></a><h3>1.&nbsp;
Introduction and Motivation</h3>

<p>An understanding of the framework presented in <a class='info' href='#FRAMEWORK'>[FRAMEWORK]<span> (</span><span class='info'>Baker, F., &ldquo;Framework for IPv4/IPv6 Translation -           baker-behave-v4v6-framework,&rdquo; October&nbsp;2008.</span><span>)</span></a> is presumed in this document. With that
      remark...
</p>
<p>The transition mechanisms specified in <a class='info' href='#RFC4213'>[RFC4213]<span> (</span><span class='info'>Nordmark, E. and R. Gilligan, &ldquo;Basic Transition Mechanisms for IPv6 Hosts and Routers,&rdquo; October&nbsp;2005.</span><span>)</span></a>
      handle the case of dual IPv4/IPv6 hosts interoperating with both dual
      hosts and IPv4-only hosts, which is needed early in the transition to
      IPv6. The dual hosts are assigned both an IPv4 and one or more IPv6
      addresses. The number of available globally unique IPv4 addresses will
      become smaller and smaller as the Internet grows; we expect that there
      will be a desire to take advantage of the large IPv6 address and not
      require that every new Internet node have a permanently assigned IPv4
      address.
</p>
<p>There are several different scenarios where there might be IPv6-only
      hosts that need to communicate with IPv4-only hosts. These IPv6 hosts
      might be IPv4-capable, i.e. include an IPv4 implementation but not be
      assigned an IPv4 address, or they might not even include an IPv4
      implementation. Examples include:</p>
<ul class="text">
<li>A completely new network with new devices that all support IPv6.
          In this case it might be beneficial to not have to configure the
          routers within the new network to route IPv4 since none of the hosts
          in the new network are configured with IPv4 addresses. But these new
          IPv6 devices might occasionally need to communicate with some IPv4
          nodes out on the Internet.
</li>
<li>An existing network where a large number of IPv6 devices are
          added. The IPv6 devices might have both an IPv4 and an IPv6 protocol
          stack but there is not enough global IPv4 address space to give each
          one of them a permanent IPv4 address. In this case it is more likely
          that the routers in the network already route IPv4 and are upgraded
          to dual routers.
</li>
</ul>

<p>However, there are other potential solutions in this area: </p>
<ul class="text">
<li>If there is no IPv4 routing inside the network i.e., the cloud
          that contains the new devices, some possible solutions are to either
          use the translators specified in this document at the boundary of
          the cloud, or to use Application Layer Gateways (ALG) on dual nodes
          at the cloud's boundary. The ALG solution is less flexible in that
          it is application protocol specific and it is also less robust since
          an ALG box is likely to be a single point of failure for a
          connection using that box.
</li>
<li>Otherwise, if IPv4 routing is supported inside the cloud and the
          implementations support both IPv6 and IPv4 it might suffice to have
          a mechanism for allocating a temporary address IPv4 and use IPv4 end
          to end when communicating with IPv4-only nodes. However, it would
          seem that such a solution would require the pool of temporary IPv4
          addresses to be partitioned across all the subnets in the cloud
          which would either require a larger pool of IPv4 addresses or result
          in cases where communication would fail due to no available IPv4
          address for the node's subnet.
</li>
</ul>

<p>This document specifies an algorithm that is one of the components
      needed to make IPv6-only nodes interoperate with IPv4-only nodes.
</p>
<p>The IPv4 address will be used as an IPv4-translated IPv6 address as
      specified in <a class='info' href='#FRAMEWORK'>[FRAMEWORK]<span> (</span><span class='info'>Baker, F., &ldquo;Framework for IPv4/IPv6 Translation -           baker-behave-v4v6-framework,&rdquo; October&nbsp;2008.</span><span>)</span></a> and the packets will
      travel through an IP/ICMP translator that will translate the packet
      headers between IPv4 and IPv6 and translate the addresses in those
      headers between IPv4 addresses on one side and IPv4-translated or
      IPv4-mapped IPv6 addresses on the other side. There is provision for
      both stateless and stateful mappings. Translated IPv4 addresses will
      always use the mapped format; the source address of an IPv6 datagram
      translated from IPv4 will always use the mapped form. The use of the
      mapped form in the IPv6 network is, however, at the administration's
      discretion. Three obvious models emerge: </p>
<ul class="text">
<li>All systems in the IPv6 domain use IPv4-mapped addresses, which
          enables stateless translation for all systems in all cases and makes
          all systems directly accessible by the IPv4 domain,
</li>
<li>No systems in the IPv6 domain use IPv4-mapped addresses, which is
          a lot like IPv4 NAT behavior and prevents all IPv4 systems from
          accessing servers in the IPv6 domain, or
</li>
<li>Some systems in the IPv6 domain (probably servers or dominant
          peers in peer-to-peer applications) use IPv4-mapped addresses, which
          means that those systems so addressed are accessible as servers by
          systems in the IPv4 domain but others not usable as servers
          accessible by the IPv4 domain.
</li>
</ul>

<p>This specification does not cover the mechanisms used for assignment
      of IPv4-mapped addresses to IPv6 nodes or their registration in the DNS.
      One might expect IPv4-mapped addresses to be allocated by mechanisms
      similar to and derived from similar tools in IPv4 networks.
</p>
<p>The figures below show how the IP/ICMP Translation algorithm is used
      in networks that use translation. We show three cases, that of a single
      translator, that of multiple translators, and that of a domain that has
      both stateless and stateful translation.
</p><br /><hr class="insert" />
<a name="subnet"></a>
<div style='display: table; width: 0; margin-left: auto; margin-right: auto'><pre>
     --------          --------
   //  IPv4  \\      //  IPv6  \\
  /   Domain   \    /   Domain   \
 /             +----+      +--+   \
|              |XLAT|      |S2|    |  Sn: Servers
| +--+         +----+      +--+    |  Hn: Clients
| |S1|         +----+              |
| +--+         |DNS |      +--+    |  XLAT: V4/V6 NAT
 \     +--+    +----+      |H2|   /   DNS:  DNS Server
  \    |H1|    /    \      +--+  /
   \\  +--+  //      \\        //
     --------          --------
</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;1: Using translation for a single interchange point&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p><a class='info' href='#subnet'>Figure&nbsp;1<span> (</span><span class='info'>Using translation for a single interchange point</span><span>)</span></a> shows a routing domain in which IPv4 is
      implemented (whether IPv4-only or dual stack) and another domain in
      which only IPv6 routing, and potentially only IPv6-only hosts, are
      implemented. There is a translator on the boundary between them, and a
      DNS server that can serve on both sides of the translator. The
      translator advertises an IPv4 route for the prefix mapped into IPv6
      addresses in the IPv4 domain, and an IPv6 route for its prefix mapping
      the IPv4 routing domain into the IPv6 domain. </p>
<ul class="text">
<li>If H2 decides to connect to S1, it asks the DNS server for a AAAA
          record, and sends its datagram to the IPv6 address in the response.
          Unknown to it, routing takes it to a translator, which emits an IPv4
          datagram into the IPv4 domain.
</li>
<li>If H1 seeks access to S2, it similarly asks the DNS server for an
          A record and is given the IPv4 address of S2. Routing takes its data
          to the translator, which emits an IPv6 datagram into the IPv6
          domain.
</li>
<li>If H1 seeks S1, is obviously gets S1's IPv4 address and
          communicates with it directly; in the same way, if H2 seeks S2, it
          gets the AAAA record and communicates directly with S2 even if the
          address it chooses happens to be a mapped IPv4 address.
</li>
</ul>

<p>By extension, one could imagine a case in which S2 has an IPv4-mapped
      address and H2 has a general IPv6 address - any legal IPv6 address other
      than one that the translator recognizes as an IPv4-mapped address. In
      this case, should S2 (an IPv6 device using an IPv4-mapped address)
      access an IPv4 system, the behavior is as previously described. However,
      should H2 seek to access S1, the behavior is similar to the familiar
      IPv4 NAT; the translator saves H2's address and source port number and
      an overlay IPv4 address and source port number in a database, and </p>
<ul class="text">
<li>for datagrams traveling H2-&gt;S1, translates the source address
          and port according to the defined translation, and
</li>
<li>for datagrams traveling S1-&gt;H2, translates the destination
          address and port according to the defined translation.
</li>
</ul><p> A stateful mapping of this kind requires appropriate handling
      of port numbers and checksums, and of creation and deletion of state, as
      described in <a class='info' href='#I-D.bagnulo-behave-nat64'>[I&#8209;D.bagnulo&#8209;behave&#8209;nat64]<span> (</span><span class='info'>Bagnulo, M., Matthews, P., and I. Beijnum, &ldquo;NAT64: Network Address and Protocol Translation from IPv6 Clients to IPv4  Servers,&rdquo; March&nbsp;2009.</span><span>)</span></a>.
</p><br /><hr class="insert" />
<a name="cloud"></a>
<div style='display: table; width: 0; margin-left: auto; margin-right: auto'><pre>
     --------          --------
   //  IPv4  \\      //  IPv6  \\
  /   Domain   \    /   Domain   \
 /             +----+      +--+   \
|              |XLAT|      |S3|    |  Sn: Servers
| +--+         +----+      +--+    |  Hn: Clients
| |S1|         +----+              |
| +--+         |DNS |      +--+    |  XLAT: V4/V6 NAT
 \     +--+    +----+      |H3|   /   DNS:  DNS Server
  \    |H1|    /    \      +--+  /
   \   +--+   /      \          /
  /            \    /            \
 /             +----+             \
| +--+         |XLAT|     +--+     |
| |S2|         +----+     |S4|     |
| +--+         +----+     +--+     |
|      +--+    |DNS |       +--+   |
 \     |H2|    +----+       |H4|  /
  \    +--+    /    \       +--+ /
   \\        //      \\        //
     --------          --------

</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;2: Using translation with multiple interchange points&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p><a class='info' href='#cloud'>Figure&nbsp;2<span> (</span><span class='info'>Using translation with multiple interchange points</span><span>)</span></a> similarly shows a routing domain in
      which IPv4 is implemented (whether IPv4-only or dual stack) and another
      domain in which only IPv6 routing, and potentially only IPv6-only hosts,
      are implemented. The difference from <a class='info' href='#subnet'>Figure&nbsp;1<span> (</span><span class='info'>Using translation for a single interchange point</span><span>)</span></a> is
      that there are more than one translation point on the boundary between
      them, and more than one DNS server. As in the previous case, each
      translator advertises an IPv4 route for the prefix mapped into IPv6
      addresses in the IPv4 domain, and an IPv6 route for its prefix mapping
      the IPv4 routing domain into the IPv6 domain. If these are run by the
      same administration, they are likely to use the same prefix. They could
      also use different prefixes at the network administration's option, and
      if they have different administrations they likely would - and might
      apply various policies to such routing. </p>
<ul class="text">
<li>If H4 decides to connect to S1 or S2, it asks the DNS server for
          a AAAA record, and sends its datagram to the IPv6 address in the
          response. Unknown to it, routing takes it to a translator, which
          emits an IPv4 datagram into the IPv4 domain. If the prefixes used by
          the translators are the same, the choice of translator is
          immaterial; if they are different, routing will take it to the right
          translator.
</li>
<li>If H1 seeks access to S3 or S4, it similarly asks the DNS server
          for an A record and is given the relevant IPv4 address. Routing
          similarly takes its data to one of the translators, which emits an
          IPv6 datagram into the IPv6 domain.
</li>
<li>If H1 seeks S1 or S2, is obviously gets the IPv4 address and
          communicates with it directly; in the same way, if H4 seeks S3 or
          S4, it gets the AAAA record and communicates directly with it even
          if the address it chooses happens to be a mapped IPv4 address.
</li>
</ul>

<p>In both cases, if the "IPv4 network" is in fact dual stack and
      contains dual stack hosts, direct IPv6 connectivity is precisely that -
      direct. There is no translation even if the addresses used are mapped
      IPv4 addresses, because the routing is provided by more specific
      prefixes; the only datagrams translated are those that follow the more
      general route to the translator.
</p>
<p>The protocol translators are assumed to fit around some piece of
      topology that includes some IPv6-only nodes and that may also include
      IPv4 nodes as well as dual nodes. There has to be a translator on each
      path used by routing the "translatable" packets in and out of this cloud
      to ensure that such packets always get translated. This does not require
      a translator at every physical connection between the cloud and the rest
      of the Internet since the routing can be used to deliver the packets to
      the translator.
</p>
<p>The IPv6-only node communicating with an IPv4 node through a
      translator will see an IPv4-mapped address for the peer and use an
      IPv4-translatable address for its local address for that communication.
      When the IPv6-only node sends packets the IPv4-mapped address indicates
      that the translator needs to translate the packets. When the IPv4 node
      sends packets those will translated to have the IPv4-translatable
      address as a destination; it is not possible to use an IPv4-mapped or an
      IPv4-compatible address as a destination since that would either route
      the packet back to the translator (for the IPv4-mapped address) or make
      the packet be encapsulated in IPv4 (for the IPv4-compatible address).
      Thus this specification introduces the new notion of an
      IPv4-translatable address.
</p>
<a name="section1.1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1.1"></a><h3>1.1.&nbsp;
Applicability and Limitations</h3>

<p>The use of this translation algorithm assumes that the IPv6 network
        is somehow well connected i.e. when an IPv6 node wants to communicate
        with another IPv6 node there is an IPv6 path between them. Various
        tunneling schemes exist that can provide such a path, but those
        mechanisms and their use is outside the scope of this document.
</p>
<p>The translating function as specified in this document does not
        translate any IPv4 options and it does not translate IPv6 routing
        headers, hop-by-hop extension headers, or destination options headers.
        It could be possible to define a translation between source routing in
        IPv4 and IPv6. However such a translation would not be semantically
        correct due to the slight differences between the IPv4 and IPv6 source
        routing. Also, the usefulness of source routing when going through a
        header translator might be limited since all the IPv6-only routers
        would need to have an IPv4-translated IPv6 address since the IPv4-only
        node will send a source route option containing only IPv4
        addresses.
</p>
<p><a class='info' href='#RFC5382'>[RFC5382]<span> (</span><span class='info'>Guha, S., Biswas, K., Ford, B., Sivakumar, S., and P. Srisuresh, &ldquo;NAT Behavioral Requirements for TCP,&rdquo; October&nbsp;2008.</span><span>)</span></a> describes the issues and algorithms
        in the translation of datagrams containing TCP segments. The
        considerations of that document are applicable in this case as
        well.
</p>
<p>At first sight it might appear that the IPsec functionality <a class='info' href='#RFC4301'>[RFC4301]<span> (</span><span class='info'>Kent, S. and K. Seo, &ldquo;Security Architecture for the Internet Protocol,&rdquo; December&nbsp;2005.</span><span>)</span></a><a class='info' href='#RFC4302'>[RFC4302]<span> (</span><span class='info'>Kent, S., &ldquo;IP Authentication Header,&rdquo; December&nbsp;2005.</span><span>)</span></a><a class='info' href='#RFC4303'>[RFC4303]<span> (</span><span class='info'>Kent, S., &ldquo;IP Encapsulating Security Payload (ESP),&rdquo; December&nbsp;2005.</span><span>)</span></a> can not be carried across the translator.
        However, since the translator does not modify any headers above the
        logical IP layer (IP headers, IPv6 fragment headers, and ICMP
        messages) packets encrypted using ESP in Transport-mode can be carried
        through the translator. [Note that this assumes that the key
        management can operate between the IPv6-only node and the IPv4-only
        node.] The AH computation covers parts of the IPv4 header fields such
        as IP addresses, and the identification field (fields that are either
        immutable or predictable by the sender) <a class='info' href='#RFC4302'>[RFC4302]<span> (</span><span class='info'>Kent, S., &ldquo;IP Authentication Header,&rdquo; December&nbsp;2005.</span><span>)</span></a>. While the translation algorithm is specified
        so that those IPv4 fields can be predicted by the IPv6 sender it is
        not possible for the IPv6 receiver to determine the value of the IPv4
        Identification field in packets sent by the IPv4 node. Thus as the
        translation algorithm is specified in this document it is not possible
        to use end-to-end AH through the translator.
</p>
<p>For ESP Tunnel-mode to work through the translator the IPv6 node
        would have to be able to both parse and generate "inner" IPv4 headers
        since the inner IP will be encrypted together with the transport
        protocol.
</p>
<p>Thus in practise, only ESP transport mode is relatively easy to
        make work through a translator, unless an ESP tunnel is explicitly
        carrying IPv4 inner and IPv6 outer headers.
</p>
<p>IPv4 multicast addresses can not be mapped to IPv6 multicast
        addresses. For instance, 224.1.2.3 is an IPv4 multicast address, but
        an IPv6 address mapped to general IPv4 addresses and containing that
        value is not an IPv6 multicast address. While the IP/ICMP header
        translation aspect of this memo in theory works for multicast packets
        this address mapping limitation makes it impossible to apply the
        techniques in this memo for multicast traffic.
</p>
<a name="section1.2"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1.2"></a><h3>1.2.&nbsp;
Assumptions</h3>

<p>The IPv6 nodes using the translator must have an IPv4-translated
        IPv6 address while it is communicating with IPv4-only nodes.
</p>
<p>Fragmented IPv4 UDP packets that do not contain a UDP checksum
        (i.e. the UDP checksum field is zero) are not of significant use over
        wide-areas in the Internet and will not be translated by the
        translator. An <a class='info' href='#Miller'>informal trace<span> (</span><span class='info'>Miller, G., &ldquo;Email to the ngtrans mailing list,&rdquo; March&nbsp;1999.</span><span>)</span></a> [Miller] in the
        backbone showed that out of 34,984,468 IP packets there were 769
        fragmented UDP packets with a zero checksum. However, all of them were
        due to malicious or broken behavior; a port scan and first fragments
        of IP packets that are not a multiple of 8 bytes.
</p>
<a name="prefix-stateless"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1.3"></a><h3>1.3.&nbsp;
Stateless vs Stateful Mode</h3>

<p>The translator has two possible modes of operation: stateless and
        stateful. In both cases, we assume that a system that has an IPv4
        address but not an IPv6 address is communicating with a system that
        has an IPv6 address but no IPv4 address, or that the two systems do
        not have contiguous routing connectivity in either domain and hence
        are forced to have their communications translated.
</p>
<p>In the stateless mode, one system has an IPv4 address and one has
        an address of the form specified in <a class='info' href='#FRAMEWORK'>[FRAMEWORK]<span> (</span><span class='info'>Baker, F., &ldquo;Framework for IPv4/IPv6 Translation -           baker-behave-v4v6-framework,&rdquo; October&nbsp;2008.</span><span>)</span></a>,
        which is explicitly mapped to an IPv4 address. In this mode, there is
        no need to concern oneself with port translation or translation
        tables, as the IPv4 and IPv6 counterparts are algorithmically
        related.
</p>
<p>In the stateful mode, the system with the IPv4 address will be
        represented by that same address type, but the IPv6 system may use any
        <a class='info' href='#RFC4291'>[RFC4291]<span> (</span><span class='info'>Hinden, R. and S. Deering, &ldquo;IP Version 6 Addressing Architecture,&rdquo; February&nbsp;2006.</span><span>)</span></a> address except one in that range. In
        this case, a translation table is required.
</p>
<a name="section1.3"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1.4"></a><h3>1.4.&nbsp;
Impact Outside the Network Layer</h3>

<p>The potential existence of IP/ICMP translators is already taken
        care of from a protocol perspective in <a class='info' href='#RFC2460'>[RFC2460]<span> (</span><span class='info'>Deering, S. and R. Hinden, &ldquo;Internet Protocol, Version 6 (IPv6) Specification,&rdquo; December&nbsp;1998.</span><span>)</span></a>.
        However, an IPv6 node that wants to be able to use translators needs
        some additional logic in the network layer.
</p>
<p>The network layer in an IPv6-only node, when presented by the
        application with either an IPv4 destination address or an IPv4-mapped
        IPv6 destination address, is likely to drop the packet and return some
        error message to the application. In order to take advantage of
        translators such a node should instead send an IPv6 packet where the
        destination address is the IPv4-mapped address and the source address
        is the node's temporarily assigned IPv4-translated address. If the
        node does not have a temporarily assigned IPv4-translated address it
        should acquire one using mechanisms that are not discussed in this
        document.
</p>
<p>Note that the above also applies to a dual IPv4/IPv6 implementation
        node which is not configured with any IPv4 address.
</p>
<p>There are no extra changes needed to applications to operate
        through a translator beyond what applications already need to do to
        operate on a dual node. The applications that have been modified to
        work on a dual node already have the mechanisms to determine whether
        they are communicating with an IPv4 or an IPv6 peer. Thus if the
        applications need to modify their behavior depending on the type of
        the peer, such as ftp determining whether to fallback to using the
        PORT/PASV command when EPRT/EPSV fails (as specified in <a class='info' href='#RFC2428'>[RFC2428]<span> (</span><span class='info'>Allman, M., Ostermann, S., and C. Metz, &ldquo;FTP Extensions for IPv6 and NATs,&rdquo; September&nbsp;1998.</span><span>)</span></a>), they already need to do that when running
        on dual nodes and the presence of translators does not add anything.
        For example, when using the socket API <a class='info' href='#RFC3493'>[RFC3493]<span> (</span><span class='info'>Gilligan, R., Thomson, S., Bound, J., McCann, J., and W. Stevens, &ldquo;Basic Socket Interface Extensions for IPv6,&rdquo; February&nbsp;2003.</span><span>)</span></a>
        the applications know that the peer is IPv6 if they get an AF_INET6
        address from the name service and the address is not an IPv4-mapped
        address (i.e., IN6_IS_ADDR_V4MAPPED returns false). If this is not the
        case, i.e., the address is AF_INET or an IPv4-mapped IPv6 address, the
        peer is IPv4.
</p>
<p>One way of viewing the translator, which might help clarify why
        applications do not need to know that a translator is used, is to look
        at the information that is passed from the transport layer to the
        network layer. If the transport passes down an IPv4 address (whether
        or not is in the IPv4-mapped encoding) this means that at some point
        there will be IPv4 packets generated. In a dual node the generation of
        the IPv4 packets takes place in the sending node. In an IPv6-only node
        conceptually the only difference is that the IPv4 packet is generated
        by the translator - all the information that the transport layer
        passed to the network layer will be conveyed to the translator in some
        form. That form just "happens" to be in the form of an IPv6
        header.
</p>
<a name="section2"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2"></a><h3>2.&nbsp;
Terminology</h3>

<p>This documents uses the terminology defined in <a class='info' href='#RFC2460'>[RFC2460]<span> (</span><span class='info'>Deering, S. and R. Hinden, &ldquo;Internet Protocol, Version 6 (IPv6) Specification,&rdquo; December&nbsp;1998.</span><span>)</span></a> and <a class='info' href='#RFC4213'>[RFC4213]<span> (</span><span class='info'>Nordmark, E. and R. Gilligan, &ldquo;Basic Transition Mechanisms for IPv6 Hosts and Routers,&rdquo; October&nbsp;2005.</span><span>)</span></a> with these
      clarifications: </p>
<blockquote class="text"><dl>
<dt>IPv4 capable node:</dt>
<dd>A node which has an IPv4 protocol
          stack. In order for the stack to be usable the node must be assigned
          one or more IPv4 addresses.
</dd>
<dt>IPv4 enabled node:</dt>
<dd>A node which has an IPv4 protocol
          stack and is assigned one or more IPv4 addresses. Both IPv4-only and
          IPv6/IPv4 nodes are IPv4 enabled.
</dd>
<dt>IPv6 capable node:</dt>
<dd>A node which has an IPv6 protocol
          stack. In order for the stack to be usable the node must be assigned
          one or more IPv6 addresses.
</dd>
<dt>IPv6 enabled node:</dt>
<dd>A node which has an IPv6 protocol
          stack and is assigned one or more IPv6 addresses. Both IPv6-only and
          IPv6/IPv4 nodes are IPv6 enabled.
</dd>
</dl></blockquote>

<a name="section2.2"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3"></a><h3>3.&nbsp;
Requirements</h3>

<p>The keywords MUST, MUST NOT, REQUIRED, SHALL, SHALL NOT, SHOULD,
      SHOULD NOT, RECOMMENDED, MAY, and OPTIONAL, when they appear in this
      document, are to be interpreted as described in <a class='info' href='#RFC2119'>[RFC2119]<span> (</span><span class='info'>Bradner, S., &ldquo;Key words for use in RFCs to Indicate Requirement Levels,&rdquo; March&nbsp;1997.</span><span>)</span></a>.
</p>
<a name="section3"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4"></a><h3>4.&nbsp;
Translating from IPv4 to IPv6</h3>

<p>When an IPv4-to-IPv6 translator receives an IPv4 datagram addressed
      to a destination that lies outside of the attached IPv4 island, it
      translates the IPv4 header of that packet into an IPv6 header. It then
      forwards the packet based on the IPv6 destination address. The original
      IPv4 header on the packet is removed and replaced by an IPv6 header.
      Except for ICMP packets the transport layer header and data portion of
      the packet are left unchanged.
</p><br /><hr class="insert" />
<a name="v4v6xlat"></a>
<div style='display: table; width: 0; margin-left: auto; margin-right: auto'><pre>

+-------------+                 +-------------+
|    IPv4     |                 |    IPv6     |
|   Header    |                 |   Header    |
+-------------+                 +-------------+
|  Transport  |                 |  Fragment   |
|   Layer     |      ===&gt;       |   Header    |
|   Header    |                 |(not always) |
+-------------+                 +-------------+
|             |                 |  Transport  |
~    Data     ~                 |   Layer     |
|             |                 |   Header    |
+-------------+                 +-------------+
                                |             |
                                ~    Data     ~
                                |             |
                                +-------------+

</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;3: IPv4-to-IPv6 Translation&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>One of the differences between IPv4 and IPv6 is that in IPv6 path MTU
      discovery is mandatory but it is optional in IPv4. This implies that
      IPv6 routers will never fragment a packet - only the sender can do
      fragmentation.
</p>
<p>When the IPv4 node performs path MTU discovery (by setting the DF bit
      in the header) the path MTU discovery can operate end-to-end i.e. across
      the translator. In this case either IPv4 or IPv6 routers might send back
      ICMP "packet too big" messages to the sender. When these ICMP errors are
      sent by the IPv6 routers they will pass through a translator which will
      translate the ICMP error to a form that the IPv4 sender can understand.
      In this case an IPv6 fragment header is only included if the IPv4 packet
      is already fragmented.
</p>
<p>However, when the IPv4 sender does not perform path MTU discovery the
      translator has to ensure that the packet does not exceed the path MTU on
      the IPv6 side. This is done by fragmenting the IPv4 packet so that it
      fits in 1280 byte IPv6 packet since IPv6 guarantees that 1280 byte
      packets never need to be fragmented. Also, when the IPv4 sender does not
      perform path MTU discovery the translator MUST always include an IPv6
      fragment header to indicate that the sender allows fragmentation. That
      is needed should the packet pass through an IPv6-to-IPv4 translator.
</p>
<p>The above rules ensure that when packets are fragmented either by the
      sender or by IPv4 routers that the low-order 16 bits of the fragment
      identification is carried end-end to ensure that packets are correctly
      reassembled. In addition, the rules use the presence of an IPv6 fragment
      header to indicate that the sender might not be using path MTU discovery
      i.e. the packet should not have the DF flag set should it later be
      translated back to IPv4.
</p>
<p>Other than the special rules for handling fragments and path MTU
      discovery the actual translation of the packet header consists of a
      simple mapping as defined below. Note that ICMP packets require special
      handling in order to translate the content of ICMP error message and
      also to add the ICMP pseudo-header checksum.
</p>
<a name="section3.1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.1"></a><h3>4.1.&nbsp;
Translating IPv4 Headers into IPv6 Headers</h3>

<p>If the DF flag is not set and the IPv4 packet will result in an
        IPv6 packet larger than 1280 bytes the IPv4 packet MUST be fragmented
        prior to translating it. Since IPv4 packets with DF not set will
        always result in a fragment header being added to the packet the IPv4
        packets must be fragmented so that their length, excluding the IPv4
        header, is at most 1232 bytes (1280 minus 40 for the IPv6 header and 8
        for the Fragment header). The resulting fragments are then translated
        independently using the logic described below.
</p>
<p>If the DF bit is set and the packet is not a fragment (i.e., the MF
        flag is not set and the Fragment Offset is zero) then there is no need
        to add a fragment header to the packet. The IPv6 header fields are set
        as follows: </p>
<blockquote class="text"><dl>
<dt>Version:</dt>
<dd>6
</dd>
<dt>Traffic Class:</dt>
<dd>By default, copied from IP Type Of
            Service and Precedence field (all 8 bits are copied). According to
            <a class='info' href='#RFC2474'>[RFC2474]<span> (</span><span class='info'>Nichols, K., Blake, S., Baker, F., and D. Black, &ldquo;Definition of the Differentiated Services Field (DS Field) in the IPv4 and IPv6 Headers,&rdquo; December&nbsp;1998.</span><span>)</span></a> the semantics of the bits are
            identical in IPv4 and IPv6. However, in some IPv4 environments
            these fields might be used with the old semantics of "Type Of
            Service and Precedence". An implementation of a translator SHOULD
            provide the ability to ignore the IPv4 "TOS" and always set the
            IPv6 traffic class to zero.
</dd>
<dt>Flow Label:</dt>
<dd>0 (all zero bits)
</dd>
<dt>Payload Length:</dt>
<dd>Total length value from IPv4 header,
            minus the size of the IPv4 header and IPv4 options, if
            present.
</dd>
<dt>Next Header:</dt>
<dd>Protocol field copied from IPv4
            header
</dd>
<dt>Hop Limit:</dt>
<dd>TTL value copied from IPv4 header. Since
            the translator is a router, as part of forwarding the packet it
            needs to decrement either the IPv4 TTL (before the translation) or
            the IPv6 Hop Limit (after the translation). As part of
            decrementing the TTL or Hop Limit the translator (as any router)
            needs to check for zero and send the ICMPv4 or ICMPv6 "ttl
            exceeded" error.
</dd>
<dt>Source Address:</dt>
<dd>The the address is derived from the
            IPv4 address as specified in <a class='info' href='#FRAMEWORK'>[FRAMEWORK]<span> (</span><span class='info'>Baker, F., &ldquo;Framework for IPv4/IPv6 Translation -           baker-behave-v4v6-framework,&rdquo; October&nbsp;2008.</span><span>)</span></a>.
</dd>
<dt>Destination Address:</dt>
<dd>In stateless mode, which is to
            say that if the IPv4 destination address is within the range of
            the stateless translation prefix described in <a class='info' href='#prefix-stateless'>Section&nbsp;1.3<span> (</span><span class='info'>Stateless vs Stateful Mode</span><span>)</span></a>, the address is derived from the
            IPv4 address as specified in <a class='info' href='#FRAMEWORK'>[FRAMEWORK]<span> (</span><span class='info'>Baker, F., &ldquo;Framework for IPv4/IPv6 Translation -           baker-behave-v4v6-framework,&rdquo; October&nbsp;2008.</span><span>)</span></a>.
            <br />
 In stateful mode, which is to say that
            if the IPv4 destination address is among the statefully-translated
            addresses, the IPv6 address and transport layer destination port
            corresponding to the IPv4 destination address and source port are
            derived from the database reflecting current session state in the
            translator.
</dd>
</dl></blockquote>

<p>If IPv4 options are present in the IPv4 packet, they are ignored
        i.e., there is no attempt to translate them. However, if an unexpired
        source route option is present then the packet MUST instead be
        discarded, and an ICMPv4 "destination unreachable/source route failed"
        (Type 3/Code 5) error message SHOULD be returned to the sender.
</p>
<p>If there is need to add a fragment header (the DF bit is not set or
        the packet is a fragment) the header fields are set as above with the
        following exceptions: </p>
<blockquote class="text"><dl>
<dt>IPv6 fields:</dt>
<dd>
<blockquote class="text"><dl>
<dt>Payload Length:</dt>
<dd>Total length value from IPv4
                header, plus 8 for the fragment header, minus the size of the
                IPv4 header and IPv4 options, if present.
</dd>
<dt>Next Header:</dt>
<dd>Fragment Header (44).
</dd>
</dl></blockquote>
</dd>
<dt>Fragment header fields:</dt>
<dd>
<blockquote class="text"><dl>
<dt>Next Header:</dt>
<dd>Protocol field copied from IPv4
                header.
</dd>
<dt>Fragment Offset:</dt>
<dd>Fragment Offset copied from the
                IPv4 header.
</dd>
<dt>M flag</dt>
<dd>More Fragments bit copied from the IPv4
                header.
</dd>
<dt>Identification</dt>
<dd>The low-order 16 bits copied from
                the Identification field in the IPv4 header. The high-order 16
                bits set to zero.
</dd>
</dl></blockquote>
</dd>
</dl></blockquote>

<a name="section3.2"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.2"></a><h3>4.2.&nbsp;
Translating UDP over IPv4</h3>

<p>If a UDP packet has a zero UDP checksum then a valid checksum must
        be calculated in order to translate the packet. A stateless translator
        can not do this for fragmented packets but [MILLER] indicates that
        fragmented UDP packets with a zero checksum appear to only be used for
        malicious purposes. Thus this is not believed to be a noticeable
        limitation.
</p>
<p>When a translator receives the first fragment of a fragmented UDP
        IPv4 packet and the checksum field is zero the translator SHOULD drop
        the packet and generate a system management event specifying at least
        the IP addresses and port numbers in the packet. When it receives
        fragments other than the first it SHOULD silently drop the packet,
        since there is no port information to log.
</p>
<p>When a translator receives an unfragmented UDP IPv4 packet and the
        checksum field is zero the translator MUST compute the missing UDP
        checksum as part of translating the packet. Also, the translator
        SHOULD maintain a counter of how many UDP checksums are generated in
        this manner.
</p>
<a name="section3.3"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.3"></a><h3>4.3.&nbsp;
Translating ICMPv4 Headers into ICMPv6 Headers</h3>

<p>All ICMP messages that are to be translated require that the ICMP
        checksum field be updated as part of the translation since ICMPv6
        unlike ICMPv4 has a pseudo-header checksum just like UDP and TCP.
</p>
<p>In addition all ICMP packets need to have the Type value translated
        and for ICMP error messages the included IP header also needs
        translation.
</p>
<p>The actions needed to translate various ICMPv4 messages are: </p>
<blockquote class="text"><dl>
<dt>ICMPv4 query messages:</dt>
<dd>
<blockquote class="text"><dl>
<dt>Echo and Echo Reply (Type 8 and Type 0)</dt>
<dd>Adjust
                the type to 128 and 129, respectively, and adjust the ICMP
                checksum both to take the type change into account and to
                include the ICMPv6 pseudo-header.
</dd>
<dt>Information Request/Reply (Type 15 and Type 16)</dt>
<dd>Obsoleted
                in ICMPv4 Silently drop.
</dd>
<dt>Timestamp and Timestamp Reply (Type 13 and Type 14)</dt>
<dd>Obsoleted
                in ICMPv6 Silently drop.
</dd>
<dt>Address Mask Request/Reply (Type 17 and Type 18)</dt>
<dd>Obsoleted
                in ICMPv6 Silently drop.
</dd>
<dt>ICMP Router Advertisement (Type 9)</dt>
<dd>Single hop
                message. Silently drop.
</dd>
<dt>ICMP Router Solicitation (Type 10)</dt>
<dd>Single hop
                message. Silently drop.
</dd>
<dt>Unknown ICMPv4 types</dt>
<dd>Silently drop.
</dd>
<dt>IGMP messages:</dt>
<dd>While the MLD messages <a class='info' href='#RFC2710'>[RFC2710]<span> (</span><span class='info'>Deering, S., Fenner, W., and B. Haberman, &ldquo;Multicast Listener Discovery (MLD) for IPv6,&rdquo; October&nbsp;1999.</span><span>)</span></a><a class='info' href='#RFC3590'>[RFC3590]<span> (</span><span class='info'>Haberman, B., &ldquo;Source Address Selection for the Multicast Listener Discovery (MLD) Protocol,&rdquo; September&nbsp;2003.</span><span>)</span></a><a class='info' href='#RFC3810'>[RFC3810]<span> (</span><span class='info'>Vida, R. and L. Costa, &ldquo;Multicast Listener Discovery Version 2 (MLDv2) for IPv6,&rdquo; June&nbsp;2004.</span><span>)</span></a> are the logical IPv6 counterparts for
                the IPv4 IGMP messages all the "normal" IGMP messages are
                single-hop messages and should be silently dropped by the
                translator. Other IGMP messages might be used by multicast
                routing protocols and, since it would be a configuration error
                to try to have router adjacencies across IPv4/IPv6 translators
                those packets should also be silently dropped.
</dd>
<dt> ICMPv4 error messages:</dt>
<dd>
<blockquote class="text"><dl>
<dt>Destination Unreachable (Type 3)</dt>
<dd>For all
                    that are not explicitly listed below set the Type to 1.
                    <br />
 Translate the code field as
                    follows: 
<blockquote class="text"><dl>
<dt>Code 0, 1 (net, host unreachable):</dt>
<dd>Set
                        Code to 0 (no route to destination).
</dd>
<dt>Code 2 (protocol unreachable):</dt>
<dd>Translate
                        to an ICMPv6 Parameter Problem (Type 4, Code 1) and
                        make the Pointer point to the IPv6 Next Header
                        field.
</dd>
<dt>Code 3 (port unreachable):</dt>
<dd>Set Code to 4
                        (port unreachable).
</dd>
<dt>Code 4 (fragmentation needed and DF set):</dt>
<dd>Translate
                        to an ICMPv6 Packet Too Big message (Type 2) with code
                        0. The MTU field needs to be adjusted for the
                        difference between the IPv4 and IPv6 header sizes.
                        Note that if the IPv4 router did not set the MTU field
                        i.e. the router does not implement <a class='info' href='#RFC1191'>[RFC1191]<span> (</span><span class='info'>Mogul, J. and S. Deering, &ldquo;Path MTU discovery,&rdquo; November&nbsp;1990.</span><span>)</span></a>, then the translator must use
                        the plateau values specified in <a class='info' href='#RFC1191'>[RFC1191]<span> (</span><span class='info'>Mogul, J. and S. Deering, &ldquo;Path MTU discovery,&rdquo; November&nbsp;1990.</span><span>)</span></a> to determine a likely path
                        MTU and include that path MTU in the ICMPv6 packet.
                        (Use the greatest plateau value that is less than the
                        returned Total Length field.)
</dd>
<dt>Code 5 (source route failed):</dt>
<dd>Set Code
                        to 0 (no route to destination). Note that this error
                        is unlikely since source routes are not
                        translated.
</dd>
<dt>Code 6,7:</dt>
<dd>Set Code to 0 (no route to
                        destination).
</dd>
<dt>Code 8:</dt>
<dd>Set Code to 0 (no route to
                        destination).
</dd>
<dt>Code 9, 10 (communication with destination host administratively prohibited):</dt>
<dd>Set
                        Code to 1 (communication with destination
                        administratively prohibited)
</dd>
<dt>Code 11, 12:</dt>
<dd>Set Code to 0 (no route to
                        destination).
</dd>
</dl></blockquote>
</dd>
<dt>Redirect (Type 5)</dt>
<dd>Single hop message.
                    Silently drop.
</dd>
<dt>Source Quench (Type 4)</dt>
<dd>Obsoleted in ICMPv6
                    Silently drop.
</dd>
<dt>Time Exceeded (Type 11)</dt>
<dd>Set the Type field
                    to 3. The Code field is unchanged.
</dd>
<dt>Parameter Problem (Type 12)</dt>
<dd>Set the Type
                    field to 4. The Pointer needs to be updated to point to
                    the corresponding field in the translated include IP
                    header.
</dd>
</dl></blockquote>
</dd>
</dl></blockquote>
</dd>
</dl></blockquote>

<a name="section3.4"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.4"></a><h3>4.4.&nbsp;
Translating ICMPv4 Error Messages into ICMPv6</h3>

<p>There are some differences between the IPv4 and the IPv6 ICMP error
        message formats as detailed above. In addition, the ICMP error
        messages contain the IP header for the packet in error which needs to
        be translated just like a normal IP header. The translation of this
        "packet in error" is likely to change the length of the datagram thus
        the Payload Length field in the outer IPv6 header might need to be
        updated.
</p><br /><hr class="insert" />
<a name="v4v6icmp"></a>
<div style='display: table; width: 0; margin-left: auto; margin-right: auto'><pre>

+-------------+                 +-------------+
|    IPv4     |                 |    IPv6     |
|   Header    |                 |   Header    |
+-------------+                 +-------------+
|   ICMPv4    |                 |   ICMPv6    |
|   Header    |                 |   Header    |
+-------------+                 +-------------+
|    IPv4     |      ===&gt;       |    IPv6     |
|   Header    |                 |   Header    |
+-------------+                 +-------------+
|   Partial   |                 |   Partial   |
|  Transport  |                 |  Transport  |
|   Layer     |                 |   Layer     |
|   Header    |                 |   Header    |
+-------------+                 +-------------+

</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;4: IPv4-to-IPv6 ICMP Error Translation&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>The translation of the inner IP header can be done by recursively
        invoking the function that translated the outer IP headers.
</p>
<a name="section3.5"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.5"></a><h3>4.5.&nbsp;
Knowing when to Translate</h3>

<p>The translator is assumed to know the pool(s) of IPv4 address that
        are used to represent the internal IPv6-only nodes. If the translator
        is implemented in a router providing both translation and normal
        forwarding, and the address is reachable by a more specific route
        without translation, the router should forward it without translating
        it. In general, however, if the IPv4 destination field contains an
        address that falls in these configured sets of prefixes the packet
        needs to be translated to IPv6.
</p>
<a name="section4"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5"></a><h3>5.&nbsp;
Translating from IPv6 to IPv4</h3>

<p>When an IPv6-to-IPv4 translator receives an IPv6 datagram addressed
      to an IPv4-mapped IPv6 address, it translates the IPv6 header of that
      packet into an IPv4 header. It then forwards the packet based on the
      IPv4 destination address. The original IPv6 header on the packet is
      removed and replaced by an IPv4 header. Except for ICMP packets the
      transport layer header and data portion of the packet are left
      unchanged.
</p><br /><hr class="insert" />
<a name="v6v4xlat"></a>
<div style='display: table; width: 0; margin-left: auto; margin-right: auto'><pre>

+-------------+                 +-------------+
|    IPv6     |                 |    IPv4     |
|   Header    |                 |   Header    |
+-------------+                 +-------------+
|  Fragment   |                 |  Transport  |
|   Header    |      ===&gt;       |   Layer     |
|(if present) |                 |   Header    |
+-------------+                 +-------------+
|  Transport  |                 |             |
|   Layer     |                 ~    Data     ~
|   Header    |                 |             |
+-------------+                 +-------------+
|             |
~    Data     ~
|             |
+-------------+

</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;5: IPv6-to-IPv4 Translation&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>There are some differences between IPv6 and IPv4 in the area of
      fragmentation and the minimum link MTU that effect the translation. An
      IPv6 link has to have an MTU of 1280 bytes or greater. The corresponding
      limit for IPv4 is 68 bytes. Thus, unless there were special measures, it
      would not be possible to do end-to-end path MTU discovery when the path
      includes an IPv6-to-IPv4 translator since the IPv6 node might receive
      ICMP "packet too big" messages originated by an IPv4 router that report
      an MTU less than 1280. However, <a class='info' href='#RFC2460'>[RFC2460]<span> (</span><span class='info'>Deering, S. and R. Hinden, &ldquo;Internet Protocol, Version 6 (IPv6) Specification,&rdquo; December&nbsp;1998.</span><span>)</span></a> requires
      that IPv6 nodes handle such an ICMP "packet too big" message by reducing
      the path MTU to 1280 and including an IPv6 fragment header with each
      packet. This allows end-to-end path MTU discovery across the translator
      as long as the path MTU is 1280 bytes or greater. When the path MTU
      drops below the 1280 limit the IPv6 sender will originate 1280 byte
      packets that will be fragmented by IPv4 routers along the path after
      being translated to IPv4.
</p>
<p>The only drawback with this scheme is that it is not possible to use
      PMTU to do optimal UDP fragmentation (as opposed to completely avoiding
      fragmentation) at sender since the presence of an IPv6 Fragment header
      is interpreted that is it OK to fragment the packet on the IPv4 side.
      Thus if a UDP application wants to send large packets independent of the
      PMTU, the sender will only be able to determine the path MTU on the IPv6
      side of the translator. If the path MTU on the IPv4 side of the
      translator is smaller then the IPv6 sender will not receive any ICMP
      "too big" errors and can not adjust the size fragments it is
      sending.
</p>
<p>Other than the special rules for handling fragments and path MTU
      discovery the actual translation of the packet header consists of a
      simple mapping as defined below. Note that ICMP packets require special
      handling in order to translate the content of ICMP error message and
      also to add the ICMP pseudo-header checksum.
</p>
<a name="section4.1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.1"></a><h3>5.1.&nbsp;
Translating IPv6 Headers into IPv4 Headers</h3>

<p>If there is no IPv6 Fragment header the IPv4 header fields are set
        as follows: </p>
<blockquote class="text"><dl>
<dt>Version:</dt>
<dd>4
</dd>
<dt>Internet Header Length:</dt>
<dd>5 (no IPv4 options)
</dd>
<dt>Type of Service (TOS) Octet:</dt>
<dd>By default, copied from
            the IPv6 Traffic Class (all 8 bits). According to <a class='info' href='#RFC2474'>[RFC2474]<span> (</span><span class='info'>Nichols, K., Blake, S., Baker, F., and D. Black, &ldquo;Definition of the Differentiated Services Field (DS Field) in the IPv4 and IPv6 Headers,&rdquo; December&nbsp;1998.</span><span>)</span></a> the semantics of the bits are identical
            in IPv4 and IPv6. However, in some IPv4 environments these bits
            might be used with the old semantics of "Type Of Service and
            Precedence". An implementation of a translator SHOULD provide the
            ability to ignore the IPv6 traffic class and always set the IPv4
            TOS Octet to a specified value.
</dd>
<dt>Total Length:</dt>
<dd>Payload length value from IPv6 header,
            plus the size of the IPv4 header.
</dd>
<dt>Identification:</dt>
<dd>All zero.
</dd>
<dt>Flags:</dt>
<dd>The More Fragments flag is set to zero. The
            Don't Fragments flag is set to one.
</dd>
<dt>Fragment Offset:</dt>
<dd>All zero.
</dd>
<dt>Time to Live:</dt>
<dd>Hop Limit value copied from IPv6
            header. Since the translator is a router, as part of forwarding
            the packet it needs to decrement either the IPv6 Hop Limit (before
            the translation) or the IPv4 TTL (after the translation). As part
            of decrementing the TTL or Hop Limit the translator (as any
            router) needs to check for zero and send the ICMPv4 or ICMPv6 "ttl
            exceeded" error.
</dd>
<dt>Protocol:</dt>
<dd>Next Header field copied from IPv6
            header.
</dd>
<dt>Header Checksum:</dt>
<dd>Computed once the IPv4 header has
            been created.
</dd>
<dt>Source Address:</dt>
<dd>In stateless mode, which is to say
            that if the IPv6 source address is within the range of the
            stateless translation prefix described in <a class='info' href='#prefix-stateless'>Section&nbsp;1.3<span> (</span><span class='info'>Stateless vs Stateful Mode</span><span>)</span></a>, the address format is derived
            from the IPv4 address as specified in <a class='info' href='#FRAMEWORK'>[FRAMEWORK]<span> (</span><span class='info'>Baker, F., &ldquo;Framework for IPv4/IPv6 Translation -           baker-behave-v4v6-framework,&rdquo; October&nbsp;2008.</span><span>)</span></a>. <br />
 In stateful
            mode, which is to say that if the IPv6 source address is not of
            the form described in <a class='info' href='#FRAMEWORK'>[FRAMEWORK]<span> (</span><span class='info'>Baker, F., &ldquo;Framework for IPv4/IPv6 Translation -           baker-behave-v4v6-framework,&rdquo; October&nbsp;2008.</span><span>)</span></a>, the IPv4
            source address and transport layer source port corresponding to
            the IPv6 source address and source port are derived from the
            database reflecting current session state in the translator as
            described in <a class='info' href='#I-D.bagnulo-behave-nat64'>[I&#8209;D.bagnulo&#8209;behave&#8209;nat64]<span> (</span><span class='info'>Bagnulo, M., Matthews, P., and I. Beijnum, &ldquo;NAT64: Network Address and Protocol Translation from IPv6 Clients to IPv4  Servers,&rdquo; March&nbsp;2009.</span><span>)</span></a>.
</dd>
<dt>Destination Address:</dt>
<dd>IPv6 packets that are
            translated have an IPv4-mapped destination address. Thus the
            address is derived from the IPv6 address as specified in <a class='info' href='#FRAMEWORK'>[FRAMEWORK]<span> (</span><span class='info'>Baker, F., &ldquo;Framework for IPv4/IPv6 Translation -           baker-behave-v4v6-framework,&rdquo; October&nbsp;2008.</span><span>)</span></a>.
</dd>
</dl></blockquote>

<p>If any of an IPv6 hop-by-hop options header, destination options
        header, or routing header with the Segments Left field equal to zero
        are present in the IPv6 packet, they are ignored i.e., there is no
        attempt to translate them. However, the Total Length field and the
        Protocol field would have to be adjusted to "skip" these extension
        headers.
</p>
<p>If a routing header with a non-zero Segments Left field is present
        then the packet MUST NOT be translated, and an ICMPv6 "parameter
        problem/ erroneous header field encountered" (Type 4/Code 0) error
        message, with the Pointer field indicating the first byte of the
        Segments Left field, SHOULD be returned to the sender.
</p>
<p>If the IPv6 packet contains a Fragment header the header fields are
        set as above with the following exceptions: </p>
<blockquote class="text"><dl>
<dt>Total Length:</dt>
<dd>Payload length value from IPv6 header,
            minus 8 for the Fragment header, plus the size of the IPv4
            header.
</dd>
<dt>Identification:</dt>
<dd>Copied from the low-order 16-bits in
            the Identification field in the Fragment header.
</dd>
<dt>Flags:</dt>
<dd>The More Fragments flag is copied from the M
            flag in the Fragment header. The Don't Fragments flag is set to
            zero allowing this packet to be fragmented by IPv4 routers.
</dd>
<dt>Fragment Offset:</dt>
<dd>Copied from the Fragment Offset
            field in the Fragment Header.
</dd>
<dt>Protocol:</dt>
<dd>Next Header value copied from Fragment
            header.
</dd>
</dl></blockquote>

<a name="section4.2"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.2"></a><h3>5.2.&nbsp;
Translating ICMPv6 Headers into ICMPv4 Headers</h3>

<p>All ICMP messages that are to be translated require that the ICMP
        checksum field be updated as part of the translation since ICMPv6
        unlike ICMPv4 has a pseudo-header checksum just like UDP and TCP.
</p>
<p>In addition all ICMP packets need to have the Type value translated
        and for ICMP error messages the included IP header also needs
        translation.
</p>
<p>The actions needed to translate various ICMPv6 messages are: </p>
<blockquote class="text"><dl>
<dt>ICMPv6 informational messages:</dt>
<dd>
<blockquote class="text"><dl>
<dt>Echo Request and Echo Reply (Type 128 and 129)</dt>
<dd>Adjust
                the type to 0 and 8, respectively, and adjust the ICMP
                checksum both to take the type change into account and to
                exclude the ICMPv6 pseudo-header.
</dd>
<dt>MLD Multicast Listener Query/Report/Done (Type 130, 131, 132)</dt>
<dd>Single
                hop message. Silently drop.
</dd>
<dt>Neighbor Discover messages (Type 133 through 137)</dt>
<dd>Single
                hop message. Silently drop.
</dd>
<dt>Unknown informational messages</dt>
<dd>Silently
                drop.
</dd>
</dl></blockquote>
</dd>
<dt>ICMPv6 error messages:</dt>
<dd>
<blockquote class="text"><dl>
<dt>Destination Unreachable (Type 1)</dt>
<dd>Set the Type
                field to 3. Translate the code field as follows: 
<blockquote class="text"><dl>
<dt>Code 0 (no route to destination):</dt>
<dd>Set Code
                    to 1 (host unreachable).
</dd>
<dt>Code 1 (communication with destination administratively prohibited):</dt>
<dd>Set
                    Code to 10 (communication with destination host
                    administratively prohibited).
</dd>
<dt>Code 2 (beyond scope of source address):</dt>
<dd>Set
                    Code to 1 (host unreachable). Note that this error is very
                    unlikely since the IPv4-translatable source address is
                    considered to have global scope.
</dd>
<dt>Code 3 (address unreachable):</dt>
<dd>Set Code to 1
                    (host unreachable).
</dd>
<dt>Code 4 (port unreachable):</dt>
<dd>Set Code to 3
                    (port unreachable).
</dd>
</dl></blockquote>
</dd>
<dt>Packet Too Big (Type 2)</dt>
<dd>Translate to an ICMPv4
                Destination Unreachable with code 4. The MTU field needs to be
                adjusted for the difference between the IPv4 and IPv6 header
                sizes taking into account whether or not the packet in error
                includes a Fragment header.
</dd>
<dt>Time Exceeded (Type 3)</dt>
<dd>Set the Type to 11. The
                Code field is unchanged.
</dd>
<dt>Parameter Problem (Type 4)</dt>
<dd>If the Code is 1
                translate this to an ICMPv4 protocol unreachable (Type 3, Code
                2). Otherwise set the Type to 12 and the Code to zero. The
                Pointer needs to be updated to point to the corresponding
                field in the translated include IP header.
</dd>
<dt>Unknown error messages</dt>
<dd>Silently drop.
</dd>
</dl></blockquote>
</dd>
</dl></blockquote>

<a name="section4.3"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.3"></a><h3>5.3.&nbsp;
Translating ICMPv6 Error Messages into ICMPv4</h3>

<p>There are some differences between the IPv4 and the IPv6 ICMP error
        message formats as detailed above. In addition, the ICMP error
        messages contain the IP header for the packet in error which needs to
        be translated just like a normal IP header. The translation of this
        "packet in error" is likely to change the length of the datagram thus
        the Total Length field in the outer IPv4 header might need to be
        updated.
</p><br /><hr class="insert" />
<a name="v6v4icmp"></a>
<div style='display: table; width: 0; margin-left: auto; margin-right: auto'><pre>

+-------------+                 +-------------+
|    IPv6     |                 |    IPv4     |
|   Header    |                 |   Header    |
+-------------+                 +-------------+
|   ICMPv6    |                 |   ICMPv4    |
|   Header    |                 |   Header    |
+-------------+                 +-------------+
|    IPv6     |      ===&gt;       |    IPv4     |
|   Header    |                 |   Header    |
+-------------+                 +-------------+
|   Partial   |                 |   Partial   |
|  Transport  |                 |  Transport  |
|   Layer     |                 |   Layer     |
|   Header    |                 |   Header    |
+-------------+                 +-------------+

</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;6: IPv6-to-IPv4 ICMP Error Translation&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>The translation of the inner IP header can be done by recursively
        invoking the function that translated the outer IP headers.
</p>
<a name="section4.4"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.4"></a><h3>5.4.&nbsp;
Knowing when to Translate</h3>

<p>If the translator is implemented in a router providing both
        translation and normal forwarding, and the address is reachable by a
        more specific route without translation, the router should forward it
        without translating it. Otherwise, when the translator receives an
        IPv6 packet with an IPv4-mapped destination address the packet will be
        translated to IPv4.
</p>
<a name="section5"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6"></a><h3>6.&nbsp;
Implications for IPv6-Only Nodes</h3>

<p>An IPv6-only node which works through an IPv4/IPv6 translator needs
      some modifications beyond a normal IPv6-only node.
</p>
<p>As specified in <a class='info' href='#section1.3'>Section&nbsp;1.4<span> (</span><span class='info'>Impact Outside the Network Layer</span><span>)</span></a> the application
      protocols need to handle operation on a dual stack node. In addition the
      protocol stack needs to be able to: </p>
<ul class="text">
<li>Determine when an IPv4-translatable address needs to be allocated
          and the allocation needs to be refreshed/renewed. This can
          presumably be done without involving the applications by e.g.
          handling this under the socket API. For instance, when the connect
          or sendto socket calls are invoked they could check if the
          destination is an IPv4-mapped address and in that case
          allocate/refresh the IPv4-translatable address.
</li>
<li>Ensure, as part of the source address selection mechanism, that
          when the destination address is an IPv4-mapped address the source
          address MUST be an IPv4-translatable address. And an IPv4-
          translatable address MUST NOT be used with other forms of IPv6
          destination addresses.
</li>
<li>Should the peer have AAAA/A6 address records the application (or
          resolver) SHOULD never fall back to looking for A address records
          even if communication fails using the available AAAA/A6 records. The
          reason for this restriction is to prevent traffic between two IPv6
          nodes (which AAAA/A6 records in the DNS) from accidentally going
          through IPv4/IPv6 translation twice; from IPv6 to IPv4 and to IPv6
          again. It is considered preferable to instead signal a failure to
          communicate to the application. The only case in which
          IPv6/IPv4/IPv6 translation makes sense is when no other route
          exists.
</li>
</ul>

<a name="IANA"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7"></a><h3>7.&nbsp;
IANA Considerations</h3>

<p>This memo adds no new IANA considerations.
</p>
<p>Note to RFC Editor: This section will have served its purpose if it
      correctly tells IANA that no new assignments or registries are required,
      or if those assignments or registries are created during the RFC
      publication process. From the author's perspective, it may therefore be
      removed upon publication as an RFC at the RFC Editor's discretion.
</p>
<a name="Security"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.8"></a><h3>8.&nbsp;
Security Considerations</h3>

<p>The use of stateless IP/ICMP translators does not introduce any new
      security issues beyond the security issues that are already present in
      the IPv4 and IPv6 protocols and in the routing protocols which are used
      to make the packets reach the translator.
</p>
<p>As the Authentication Header <a class='info' href='#RFC4302'>[RFC4302]<span> (</span><span class='info'>Kent, S., &ldquo;IP Authentication Header,&rdquo; December&nbsp;2005.</span><span>)</span></a> is
      specified to include the IPv4 Identification field and the translating
      function not being able to always preserve the Identification field, it
      is not possible for an IPv6 endpoint to compute AH on received packets
      that have been translated from IPv4 packets. Thus AH does not work
      through a translator.
</p>
<p>Packets with ESP can be translated since ESP does not depend on
      header fields prior to the ESP header. Note that ESP transport mode is
      easier to handle than ESP tunnel mode; in order to use ESP tunnel mode
      the IPv6 node needs to be able to generate an inner IPv4 header when
      transmitting packets and remove such an IPv4 header when receiving
      packets.
</p>
<a name="Acknowledgements"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.9"></a><h3>9.&nbsp;
Acknowledgements</h3>

<p>This is under development by a large group of people. Those who have
      posted to the list during the discussion include Andrew Sullivan, Andrew
      Yourtchenko, Brian Carpenter, Dan Wing, Ed Jankiewicz, Fred Baker,
      Hiroshi Miyata, Iljitsch van Beijnum, John Schnizlein, Kevin Yin, Magnus
      Westerlund, Marcelo Bagnulo Braun, Margaret Wasserman, Masahito Endo,
      Phil Roberts, Philip Matthews, Remi Denis-Courmont, Remi Despres, and
      Xing Li.
</p>
<a name="rfc.references"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.10"></a><h3>10.&nbsp;
References</h3>

<a name="rfc.references1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>10.1.&nbsp;Normative References</h3>
<table width="99%" border="0">
<tr><td class="author-text" valign="top"><a name="FRAMEWORK">[FRAMEWORK]</a></td>
<td class="author-text">Baker, F., &ldquo;Framework for IPv4/IPv6 Translation -
          baker-behave-v4v6-framework,&rdquo; October&nbsp;2008.</td></tr>
<tr><td class="author-text" valign="top"><a name="I-D.bagnulo-behave-nat64">[I-D.bagnulo-behave-nat64]</a></td>
<td class="author-text">Bagnulo, M., Matthews, P., and I. Beijnum, &ldquo;<a href="http://www.ietf.org/internet-drafts/draft-bagnulo-behave-nat64-03.txt">NAT64: Network Address and Protocol Translation from IPv6 Clients to IPv4  Servers</a>,&rdquo; draft-bagnulo-behave-nat64-03 (work in progress), March&nbsp;2009 (<a href="http://www.ietf.org/internet-drafts/draft-bagnulo-behave-nat64-03.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC0791">[RFC0791]</a></td>
<td class="author-text">Postel, J., &ldquo;<a href="http://tools.ietf.org/html/rfc791">Internet Protocol</a>,&rdquo; STD&nbsp;5, RFC&nbsp;791, September&nbsp;1981 (<a href="http://www.rfc-editor.org/rfc/rfc791.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC0792">[RFC0792]</a></td>
<td class="author-text">Postel, J., &ldquo;<a href="http://tools.ietf.org/html/rfc792">Internet Control Message Protocol</a>,&rdquo; STD&nbsp;5, RFC&nbsp;792, September&nbsp;1981 (<a href="http://www.rfc-editor.org/rfc/rfc792.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC2119">[RFC2119]</a></td>
<td class="author-text"><a href="mailto:sob@harvard.edu">Bradner, S.</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>,&rdquo; BCP&nbsp;14, RFC&nbsp;2119, March&nbsp;1997 (<a href="http://www.rfc-editor.org/rfc/rfc2119.txt">TXT</a>, <a href="http://xml.resource.org/public/rfc/html/rfc2119.html">HTML</a>, <a href="http://xml.resource.org/public/rfc/xml/rfc2119.xml">XML</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC2460">[RFC2460]</a></td>
<td class="author-text"><a href="mailto:deering@cisco.com">Deering, S.</a> and <a href="mailto:hinden@iprg.nokia.com">R. Hinden</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc2460">Internet Protocol, Version 6 (IPv6) Specification</a>,&rdquo; RFC&nbsp;2460, December&nbsp;1998 (<a href="http://www.rfc-editor.org/rfc/rfc2460.txt">TXT</a>, <a href="http://xml.resource.org/public/rfc/html/rfc2460.html">HTML</a>, <a href="http://xml.resource.org/public/rfc/xml/rfc2460.xml">XML</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC2765">[RFC2765]</a></td>
<td class="author-text"><a href="mailto:nordmark@sun.com">Nordmark, E.</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc2765">Stateless IP/ICMP Translation Algorithm (SIIT)</a>,&rdquo; RFC&nbsp;2765, February&nbsp;2000 (<a href="http://www.rfc-editor.org/rfc/rfc2765.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4291">[RFC4291]</a></td>
<td class="author-text">Hinden, R. and S. Deering, &ldquo;<a href="http://tools.ietf.org/html/rfc4291">IP Version 6 Addressing Architecture</a>,&rdquo; RFC&nbsp;4291, February&nbsp;2006 (<a href="http://www.rfc-editor.org/rfc/rfc4291.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4443">[RFC4443]</a></td>
<td class="author-text">Conta, A., Deering, S., and M. Gupta, &ldquo;<a href="http://tools.ietf.org/html/rfc4443">Internet Control Message Protocol (ICMPv6) for the Internet Protocol Version 6 (IPv6) Specification</a>,&rdquo; RFC&nbsp;4443, March&nbsp;2006 (<a href="http://www.rfc-editor.org/rfc/rfc4443.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC5382">[RFC5382]</a></td>
<td class="author-text">Guha, S., Biswas, K., Ford, B., Sivakumar, S., and P. Srisuresh, &ldquo;<a href="http://tools.ietf.org/html/rfc5382">NAT Behavioral Requirements for TCP</a>,&rdquo; BCP&nbsp;142, RFC&nbsp;5382, October&nbsp;2008 (<a href="http://www.rfc-editor.org/rfc/rfc5382.txt">TXT</a>).</td></tr>
</table>

<a name="rfc.references2"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>10.2.&nbsp;Informative References</h3>
<table width="99%" border="0">
<tr><td class="author-text" valign="top"><a name="I-D.petithuguenin-behave-stun-pmtud">[I-D.petithuguenin-behave-stun-pmtud]</a></td>
<td class="author-text">Petit-Huguenin, M., &ldquo;<a href="http://www.ietf.org/internet-drafts/draft-petithuguenin-behave-stun-pmtud-03.txt">Path MTU Discovery Using Session Traversal Utilities for NAT (STUN)</a>,&rdquo; draft-petithuguenin-behave-stun-pmtud-03 (work in progress), March&nbsp;2009 (<a href="http://www.ietf.org/internet-drafts/draft-petithuguenin-behave-stun-pmtud-03.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="Miller">[Miller]</a></td>
<td class="author-text">Miller, G., &ldquo;Email to the ngtrans mailing list,&rdquo; March&nbsp;1999.</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC1112">[RFC1112]</a></td>
<td class="author-text"><a href="mailto:deering@PESCADERO.STANFORD.EDU">Deering, S.</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc1112">Host extensions for IP multicasting</a>,&rdquo; STD&nbsp;5, RFC&nbsp;1112, August&nbsp;1989 (<a href="http://www.rfc-editor.org/rfc/rfc1112.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC1191">[RFC1191]</a></td>
<td class="author-text"><a href="mailto:mogul@decwrl.dec.com">Mogul, J.</a> and <a href="mailto:deering@xerox.com">S. Deering</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc1191">Path MTU discovery</a>,&rdquo; RFC&nbsp;1191, November&nbsp;1990 (<a href="http://www.rfc-editor.org/rfc/rfc1191.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC1981">[RFC1981]</a></td>
<td class="author-text"><a href="mailto:mccann@zk3.dec.com">McCann, J.</a>, <a href="mailto:deering@parc.xerox.com">Deering, S.</a>, and <a href="mailto:mogul@pa.dec.com">J. Mogul</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc1981">Path MTU Discovery for IP version 6</a>,&rdquo; RFC&nbsp;1981, August&nbsp;1996 (<a href="http://www.rfc-editor.org/rfc/rfc1981.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC2428">[RFC2428]</a></td>
<td class="author-text"><a href="mailto:mallman@lerc.nasa.gov">Allman, M.</a>, <a href="mailto:ostermann@cs.ohiou.edu">Ostermann, S.</a>, and <a href="mailto:cmetz@inner.net">C. Metz</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc2428">FTP Extensions for IPv6 and NATs</a>,&rdquo; RFC&nbsp;2428, September&nbsp;1998 (<a href="http://www.rfc-editor.org/rfc/rfc2428.txt">TXT</a>, <a href="http://xml.resource.org/public/rfc/html/rfc2428.html">HTML</a>, <a href="http://xml.resource.org/public/rfc/xml/rfc2428.xml">XML</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC2474">[RFC2474]</a></td>
<td class="author-text"><a href="mailto:kmn@cisco.com">Nichols, K.</a>, <a href="mailto:slblake@torrentnet.com">Blake, S.</a>, <a href="mailto:fred@cisco.com">Baker, F.</a>, and <a href="mailto:black_david@emc.com">D. Black</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc2474">Definition of the Differentiated Services Field (DS Field) in the IPv4 and IPv6 Headers</a>,&rdquo; RFC&nbsp;2474, December&nbsp;1998 (<a href="http://www.rfc-editor.org/rfc/rfc2474.txt">TXT</a>, <a href="http://xml.resource.org/public/rfc/html/rfc2474.html">HTML</a>, <a href="http://xml.resource.org/public/rfc/xml/rfc2474.xml">XML</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC2710">[RFC2710]</a></td>
<td class="author-text"><a href="mailto:deering@cisco.com">Deering, S.</a>, <a href="mailto:fenner@research.att.com">Fenner, W.</a>, and <a href="mailto:haberman@raleigh.ibm.com">B. Haberman</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc2710">Multicast Listener Discovery (MLD) for IPv6</a>,&rdquo; RFC&nbsp;2710, October&nbsp;1999 (<a href="http://www.rfc-editor.org/rfc/rfc2710.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC3493">[RFC3493]</a></td>
<td class="author-text">Gilligan, R., Thomson, S., Bound, J., McCann, J., and W. Stevens, &ldquo;<a href="http://tools.ietf.org/html/rfc3493">Basic Socket Interface Extensions for IPv6</a>,&rdquo; RFC&nbsp;3493, February&nbsp;2003 (<a href="http://www.rfc-editor.org/rfc/rfc3493.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC3590">[RFC3590]</a></td>
<td class="author-text">Haberman, B., &ldquo;<a href="http://tools.ietf.org/html/rfc3590">Source Address Selection for the Multicast Listener Discovery (MLD) Protocol</a>,&rdquo; RFC&nbsp;3590, September&nbsp;2003 (<a href="http://www.rfc-editor.org/rfc/rfc3590.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC3810">[RFC3810]</a></td>
<td class="author-text">Vida, R. and L. Costa, &ldquo;<a href="http://tools.ietf.org/html/rfc3810">Multicast Listener Discovery Version 2 (MLDv2) for IPv6</a>,&rdquo; RFC&nbsp;3810, June&nbsp;2004 (<a href="http://www.rfc-editor.org/rfc/rfc3810.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4213">[RFC4213]</a></td>
<td class="author-text">Nordmark, E. and R. Gilligan, &ldquo;<a href="http://tools.ietf.org/html/rfc4213">Basic Transition Mechanisms for IPv6 Hosts and Routers</a>,&rdquo; RFC&nbsp;4213, October&nbsp;2005 (<a href="http://www.rfc-editor.org/rfc/rfc4213.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4301">[RFC4301]</a></td>
<td class="author-text">Kent, S. and K. Seo, &ldquo;<a href="http://tools.ietf.org/html/rfc4301">Security Architecture for the Internet Protocol</a>,&rdquo; RFC&nbsp;4301, December&nbsp;2005 (<a href="http://www.rfc-editor.org/rfc/rfc4301.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4302">[RFC4302]</a></td>
<td class="author-text">Kent, S., &ldquo;<a href="http://tools.ietf.org/html/rfc4302">IP Authentication Header</a>,&rdquo; RFC&nbsp;4302, December&nbsp;2005 (<a href="http://www.rfc-editor.org/rfc/rfc4302.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4303">[RFC4303]</a></td>
<td class="author-text">Kent, S., &ldquo;<a href="http://tools.ietf.org/html/rfc4303">IP Encapsulating Security Payload (ESP)</a>,&rdquo; RFC&nbsp;4303, December&nbsp;2005 (<a href="http://www.rfc-editor.org/rfc/rfc4303.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4821">[RFC4821]</a></td>
<td class="author-text">Mathis, M. and J. Heffner, &ldquo;<a href="http://tools.ietf.org/html/rfc4821">Packetization Layer Path MTU Discovery</a>,&rdquo; RFC&nbsp;4821, March&nbsp;2007 (<a href="http://www.rfc-editor.org/rfc/rfc4821.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4861">[RFC4861]</a></td>
<td class="author-text">Narten, T., Nordmark, E., Simpson, W., and H. Soliman, &ldquo;<a href="http://tools.ietf.org/html/rfc4861">Neighbor Discovery for IP version 6 (IPv6)</a>,&rdquo; RFC&nbsp;4861, September&nbsp;2007 (<a href="http://www.rfc-editor.org/rfc/rfc4861.txt">TXT</a>).</td></tr>
</table>

<a name="rfc.authors"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>Authors' Addresses</h3>
<table width="99%" border="0" cellpadding="0" cellspacing="0">
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Xing Li (editor)</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">CERNET Center/Tsinghua University</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Room 225, Main Building, Tsinghua University</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Beijing,   100084</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">China</td></tr>
<tr><td class="author" align="right">Phone:&nbsp;</td>
<td class="author-text">+86 62785983</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:xing@cernet.edu.cn">xing@cernet.edu.cn</a></td></tr>
<tr cellpadding="3"><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Congxiao Bao (editor)</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">CERNET Center/Tsinghua University</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Room 225, Main Building, Tsinghua University</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Beijing,   100084</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">China</td></tr>
<tr><td class="author" align="right">Phone:&nbsp;</td>
<td class="author-text">+86 62785983</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:congxiao@cernet.edu.cn">congxiao@cernet.edu.cn</a></td></tr>
<tr cellpadding="3"><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Fred Baker (editor)</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Cisco Systems</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Santa Barbara, California  93117</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">USA</td></tr>
<tr><td class="author" align="right">Phone:&nbsp;</td>
<td class="author-text">+1-408-526-4257</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:fred@cisco.com">fred@cisco.com</a></td></tr>
</table>
<a name="rfc.copyright"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>Full Copyright Statement</h3>
<p class='copyright'>
Copyright &copy; The IETF Trust (2008).</p>
<p class='copyright'>
This document is subject to the rights,
licenses and restrictions contained in BCP&nbsp;78,
and except as set forth therein,
the authors retain all their rights.</p>
<p class='copyright'>
This document and the information contained herein are provided
on an &ldquo;AS IS&rdquo; basis and THE CONTRIBUTOR,
THE ORGANIZATION HE/SHE REPRESENTS
OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY, THE IETF TRUST
AND THE INTERNET ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT
THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY
IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR
PURPOSE.</p>
<h3>Intellectual Property</h3>
<p class='copyright'>
The IETF takes no position regarding the validity or scope of any
Intellectual Property Rights or other rights that might be claimed
to pertain to the implementation or use of the technology
described in this document or the extent to which any license
under such rights might or might not be available; nor does it
represent that it has made any independent effort to identify any
such rights.
Information on the procedures with respect to
rights in RFC documents can be found in BCP&nbsp;78 and BCP&nbsp;79.</p>
<p class='copyright'>
Copies of IPR disclosures made to the IETF Secretariat and any
assurances of licenses to be made available,
or the result of an attempt made to obtain a general license or
permission for the use of such proprietary rights by implementers or
users of this specification can be obtained from the IETF on-line IPR
repository at <a href='http://www.ietf.org/ipr'>http://www.ietf.org/ipr</a>.</p>
<p class='copyright'>
The IETF invites any interested party to bring to its attention
any copyrights,
patents or patent applications,
or other
proprietary rights that may cover technology that may be required
to implement this standard.
Please address the information to the IETF at <a href='mailto:ietf-ipr@ietf.org'>ietf-ipr@ietf.org</a>.</p>
</body></html>
