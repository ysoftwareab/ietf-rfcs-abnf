s = (ibf_salt * 7) modulo 64;
kdf_salt = 0 // 16 bits
XTR=HMAC-SHA256
PRF=HMAC-SHA256
key = HKDF(XTR, PRF, kdf_salt, element) modulo 2^64
bucket = CRC32(key)
i = 0 // unsigned 32-bit index
filled = 0
element_already_in_bucket = false
j = 0
element_already_in_bucket = true
filled = filled + 1
x = (bucket << 32) | i // 64 bit result
bucket = CRC32(x)
i = i + 1
semh = sizeof(ELEMENT_MSG_HEADER)
estimated_total_diff = rsd + lsd
total_elements_local_send = rsd + lss
cost_local_full_sync = avg_es * total_elements_local_send
                              + total_elements_local_send * semh
                              + sizeof(FULL_DONE_MSG_HEADER) * 2
                              + RTT_MIN_FULL * rtt

total_elements_remote_send = lsd + rss
cost_remote_full_sync = avg_es * total_elements_remote_send
                               + total_elements_remote_send * semh
                               + sizeof(FULL_DONE_MSG_HEADER) * 2
                               + (RTT_MIN_FULL + 0.5) * rtt
                               + sizeof(REQUEST_FULL_MSG)

ibf_bucket_count = estimated_total_diff * IBF_BUCKET_NUMBER_FACTOR
ibf_bucket_count = IBF_MIN_SIZE
ibf_message_count = ceil (ibf_bucket_count / MAX_BUCKETS_PER_MESSAGE)

estimated_counter_bits = MIN (2 * LOG2(lss / ibf_bucket_count),
                                     LOG2(lss))
estimated_counter_bytes = estimated_counter_bits / 8

ibf_bytes = sizeof(IBF_MESSAGE) * ibf_message_count
                 + ibf_bucket_count * sizeof(IBF_KEY)
                 + ibf_bucket_count * sizeof(IBF_KEYHASH)
                 + ibf_bucket_count * estimated_counter_bytes
total_ibf_bytes = ibf_bytes * 1.2

done_size = sizeof(DONE_HEADER)
element_size = (avg_es + sizeof(ELEMENT_MSG_HEADER))
                    * estimated_total_diff
inquery_size = (sizeof(IBF_KEY) + sizeof(INQUERY_MSG_HEADER))
                    * estimated_total_diff
demand_size  = (sizeof(HASHCODE) + sizeof(DEMAND_MSG_HEADER))
                    * estimated_total_diff
offer_size   = (sizeof(HASHCODE) + sizeof(OFFER_MSG_HEADER))
                    * estimated_total_diff

diff_cost = element_size + done_size + inquery_size
                 + demand_size + offer_size + total_ibf_bytes
                 + DIFFERENTIAL_RTT_MEAN * rtt

full_cost_min = MIN (cost_local_full_sync,
                            cost_remote_full_sync)
next_size = IBF_BUCKET_NUMBER_FACTOR * (lis - de)
max_counter=1 # convince static analysis that we never take log2(0)
max_counter = bucket.counter
counter_bytes = ibf_get_max_counter(ibf)
store_bits = 0
store = 0
byte_ctr = 0
buf=[]

counter = bucket.counter
byte_len = counter_bytes

bit_to_shift = 0

bit_free = 8 - store_bits
bit_to_shift = byte_len - bit_free
store = store << bit_free
byte_ctr = byte_ctr + 1
counter = counter & ((1 << byte_len) - 1)
store = 0
store_bits = 0
store = (store << byte_len) | counter
store_bits = store_bits + byte_len
byte_len = 0
byte_ctr = byte_ctr + 1
ibf_bucket_ctr = 0
store = 0
store_bits = 0
byte_ctr = 0

byte_read = pd[byte_ctr]
bit_to_pack_left = 8
bit_use = cbl - store_bits

store = store << bit_use
bytes_to_shift = bit_to_pack_left - bit_use
counter_partial = byte_read >> bytes_to_shift
store = store | counter_partial
byte_read = byte_read & (( 1 << bytes_to_shift ) - 1)

store = 0
store_bits = 0
store_bits = store_bits + bit_to_pack_left

store = byte_read
store = store << bit_to_pack_left
store = store | byte_read
s = (salt * 7) modulo 64
security_level_lb = -1 * SECURITY_LEVEL

rs = 1
base = 1 - (rs / (lis + rs))
exponent = rd - rf * lis / rs
value = exponent * (LOG2(base)/LOG2(2))
