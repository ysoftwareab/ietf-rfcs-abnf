<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="en"><head><title>JSON Web Token (JWT)</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="description" content="JSON Web Token (JWT)">
<meta name="keywords" content="RFC, Request for Comments, I-D, Internet-Draft, Assertion, Claim, Simple Web Token, Security Token, SWT, JSON Web Token, JWT, JavaScript Object Notation, JSON">
<meta name="generator" content="xml2rfc v1.35 (http://xml.resource.org/)">
<meta name="viewport" content="width=600;" />
<style type='text/css'><!--
        body {
                font-family: verdana, charcoal, helvetica, arial, sans-serif;
                font-size: 85%;
		max-width: 60em; 
		color: #000; background-color: #FFF;
                margin: 2em;
        }
        h1, h2, h3, h4, h5, h6 {
                font-family: helvetica, monaco, "MS Sans Serif", arial, sans-serif;
                font-weight: bold; font-style: normal;
        }
        h1 { color: #900; background-color: transparent; text-align: right; }
        h3 { color: #333; background-color: transparent; }

        td.RFCbug {
                font-size: x-small; text-decoration: none;
                width: 30px; height: 30px; padding-top: 2px;
                text-align: justify; vertical-align: middle;
                background-color: #000;
        }
        td.RFCbug span.RFC {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: bold; color: #666;
        }
        td.RFCbug span.hotText {
                font-family: charcoal, monaco, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: normal; text-align: center; color: #FFF;
        }

        table.TOCbug { width: 30px; height: 15px; }
        td.TOCbug {
                text-align: center; width: 30px; height: 15px;
                color: #FFF; background-color: #900;
        }
        td.TOCbug a {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, sans-serif;
                font-weight: bold; font-size: x-small; text-decoration: none;
                color: #FFF; background-color: transparent;
        }

        td.header {
                font-family: arial, helvetica, sans-serif; font-size: x-small;
                vertical-align: top; width: 33%;
                color: #FFF; background-color: #666;
        }
        td.author { font-weight: bold; font-size: x-small; margin-left: 4em; }
        td.author-text { font-size: x-small; }

        /* info code from SantaKlauss at http://www.madaboutstyle.com/tooltip2.html */
        a.info {
                /* This is the key. */
                position: relative;
                z-index: 24;
                text-decoration: none;
        }
        a.info:hover {
                z-index: 25;
                color: #FFF; background-color: #900;
        }
        a.info span { display: none; }
        a.info:hover span.info {
                /* The span will display just on :hover state. */
                display: block;
                position: absolute;
                font-size: smaller;
                top: 2em; left: -5em; width: 15em;
                padding: 2px; border: 1px solid #333;
                color: #900; background-color: #EEE;
                text-align: left;
        }

        a { font-weight: bold; }
        a:link    { color: #900; background-color: transparent; }
        a:visited { color: #633; background-color: transparent; }
        a:active  { color: #633; background-color: transparent; }

        p { margin-left: 2em; margin-right: 2em; }
        p.copyright { font-size: x-small; }
        p.toc { font-size: 85%;
		max-width: 60em; 
		font-weight: bold; margin-left: 3em; }
        table.toc { margin: 0 0 0 3em; padding: 0; border: 0; vertical-align: text-top; }
        td.toc { font-size: 85%;
		max-width: 60em; 
		font-weight: bold; vertical-align: text-top; }

        ol.text { margin-left: 2em; margin-right: 2em; }
        ul.text { margin-left: 2em; margin-right: 2em; }
        li      { margin-left: 3em; }

        /* RFC-2629 <spanx>s and <artwork>s. */
        em     { font-style: italic; }
        strong { font-weight: bold; }
        dfn    { font-weight: bold; font-style: normal; }
        cite   { font-weight: normal; font-style: normal; }
        tt     { color: #036; }
        tt, pre, pre dfn, pre em, pre cite, pre span {
                font-family: "Courier New", Courier, monospace; font-size: small;
        }
        pre {
                text-align: left; padding: 4px;
                color: #000; background-color: #CCC;
        }
        pre dfn  { color: #900; }
        pre em   { color: #66F; background-color: #FFC; font-weight: normal; }
        pre .key { color: #33C; font-weight: bold; }
        pre .id  { color: #900; }
        pre .str { color: #000; background-color: #CFF; }
        pre .val { color: #066; }
        pre .rep { color: #909; }
        pre .oth { color: #000; background-color: #FCF; }
        pre .err { background-color: #FCC; }

        /* RFC-2629 <texttable>s. */
        table.all, table.full, table.headers, table.none {
                font-size: 85%;
		max-width: 60em; 
		text-align: center; border-width: 2px;
                vertical-align: top; border-collapse: collapse;
        }
        table.all, table.full { border-style: solid; border-color: black; }
        table.headers, table.none { border-style: none; }
        th {
                font-weight: bold; border-color: black;
                border-width: 2px 2px 3px 2px;
        }
        table.all th, table.full th { border-style: solid; }
        table.headers th { border-style: none none solid none; }
        table.none th { border-style: none; }
        table.all td {
                border-style: solid; border-color: #333;
                border-width: 1px 2px;
        }
        table.full td, table.headers td, table.none td { border-style: none; }

        hr { height: 1px; }
        hr.insert {
                width: 80%; border-style: none; border-width: 0;
                color: #CCC; background-color: #CCC;
        }
--></style>
</head>
<body>
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<table summary="layout" width="66%" border="0" cellpadding="0" cellspacing="0"><tr><td><table summary="layout" width="100%" border="0" cellpadding="2" cellspacing="1">
<tr><td class="header">Network Working Group</td><td class="header">M. Jones</td></tr>
<tr><td class="header">Internet-Draft</td><td class="header">Microsoft</td></tr>
<tr><td class="header">Intended status: Standards Track</td><td class="header">D. Balfanz</td></tr>
<tr><td class="header">Expires: July 1, 2011</td><td class="header">Google</td></tr>
<tr><td class="header">&nbsp;</td><td class="header">J. Bradley</td></tr>
<tr><td class="header">&nbsp;</td><td class="header">independent</td></tr>
<tr><td class="header">&nbsp;</td><td class="header">Y. Goland</td></tr>
<tr><td class="header">&nbsp;</td><td class="header">Microsoft</td></tr>
<tr><td class="header">&nbsp;</td><td class="header">J. Panzer</td></tr>
<tr><td class="header">&nbsp;</td><td class="header">Google</td></tr>
<tr><td class="header">&nbsp;</td><td class="header">N. Sakimura</td></tr>
<tr><td class="header">&nbsp;</td><td class="header">Nomura Research Institute</td></tr>
<tr><td class="header">&nbsp;</td><td class="header">December 28, 2010</td></tr>
</table></td></tr></table>
<h1><br />JSON Web Token (JWT)<br />draft-jones-json-web-token-00</h1>

<h3>Abstract</h3>

<p>JSON Web Token (JWT) defines a token format that can encode
      claims transferred between two parties. The claims in a JWT are
      encoded as a JSON object that is digitally signed.
</p>
<h3>Requirements Language</h3>

<p>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
      "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
      document are to be interpreted as described in <a class='info' href='#RFC2119'>RFC 2119<span> (</span><span class='info'>Bradner, S., &ldquo;Key words for use in RFCs to Indicate Requirement Levels,&rdquo; March&nbsp;1997.</span><span>)</span></a> [RFC2119].
</p>
<h3>Status of this Memo</h3>
<p>
This Internet-Draft is submitted  in full
conformance with the provisions of BCP&nbsp;78 and BCP&nbsp;79.</p>
<p>
Internet-Drafts are working documents of the Internet Engineering
Task Force (IETF).  Note that other groups may also distribute
working documents as Internet-Drafts.  The list of current
Internet-Drafts is at http://datatracker.ietf.org/drafts/current/.</p>
<p>
Internet-Drafts are draft documents valid for a maximum of six months
and may be updated, replaced, or obsoleted by other documents at any time.
It is inappropriate to use Internet-Drafts as reference material or to cite
them other than as &ldquo;work in progress.&rdquo;</p>
<p>
This Internet-Draft will expire on July 1, 2011.</p>

<h3>Copyright Notice</h3>
<p>
Copyright (c) 2010 IETF Trust and the persons identified as the
document authors.  All rights reserved.</p>
<p>
This document is subject to BCP 78 and the IETF Trust's Legal
Provisions Relating to IETF Documents
(http://trustee.ietf.org/license-info) in effect on the date of
publication of this document.  Please review these documents
carefully, as they describe your rights and restrictions with respect
to this document. Code Components extracted from this document must
include Simplified BSD License text as described in Section 4.e of
the Trust Legal Provisions and are provided without warranty as
described in the Simplified BSD License.</p>
<a name="toc"></a><br /><hr />
<h3>Table of Contents</h3>
<p class="toc">
<a href="#anchor1">1.</a>&nbsp;
Introduction<br />
<a href="#anchor2">2.</a>&nbsp;
Terminology<br />
<a href="#anchor3">3.</a>&nbsp;
JSON Web Token (JWT) Overview<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor4">3.1.</a>&nbsp;
Example JWT<br />
<a href="#anchor5">4.</a>&nbsp;
JWT Claims<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#ReservedClaimName">4.1.</a>&nbsp;
Reserved Claim Names<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#PublicClaimName">4.2.</a>&nbsp;
Public Claim Names<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#PrivateClaimName">4.3.</a>&nbsp;
Private Claim Names<br />
<a href="#anchor6">5.</a>&nbsp;
JWT Envelope<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#ReservedEnvelopeParameterName">5.1.</a>&nbsp;
Reserved Envelope Parameter Names<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#PublicEnvelopeParameterName">5.2.</a>&nbsp;
Public Envelope Parameter Names<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#PrivateEnvelopeParameterName">5.3.</a>&nbsp;
Private Envelope Parameter Names<br />
<a href="#anchor7">6.</a>&nbsp;
General Rules for Creating and Validating a JWT<br />
<a href="#base64urllogic">7.</a>&nbsp;
Base64url encoding as used by JWTs<br />
<a href="#Signing">8.</a>&nbsp;
Signing JWTs with Cryptographic Algorithms<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#SigningWithHMACSHA256">8.1.</a>&nbsp;
Signing a JWT with HMAC SHA-256<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#DefiningRSA">8.2.</a>&nbsp;
Signing a JWT with RSA SHA-256<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#DefiningECDSA">8.3.</a>&nbsp;
Signing a JWT with ECDSA P-256 SHA-256<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor8">8.4.</a>&nbsp;
Additional Algorithms<br />
<a href="#IANA">9.</a>&nbsp;
IANA Considerations<br />
<a href="#Security">10.</a>&nbsp;
Security Considerations<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor9">10.1.</a>&nbsp;
Unicode Comparison Security Issues<br />
<a href="#OpenIssues">11.</a>&nbsp;
Open Issues<br />
<a href="#Acknowledgements">12.</a>&nbsp;
Acknowledgements<br />
<a href="#JWTExamples">13.</a>&nbsp;
Appendix - Non-Normative - JWT Examples<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#HMACSHA256Example">13.1.</a>&nbsp;
JWT using HMAC SHA-256<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor10">13.1.1.</a>&nbsp;
Encoding<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor11">13.1.2.</a>&nbsp;
Decoding<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor12">13.1.3.</a>&nbsp;
Validating<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor13">13.2.</a>&nbsp;
JWT using RSA SHA-256<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor14">13.2.1.</a>&nbsp;
Encoding<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor15">13.2.2.</a>&nbsp;
Decoding<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor16">13.2.3.</a>&nbsp;
Validating<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor17">13.3.</a>&nbsp;
JWT using ECDSA P-256 SHA-256<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor18">13.3.1.</a>&nbsp;
Encoding<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor19">13.3.2.</a>&nbsp;
Decoding<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor20">13.3.3.</a>&nbsp;
Validating<br />
<a href="#base64urlnotes">14.</a>&nbsp;
Appendix - Non-Normative - Notes on implementing base64url encoding without padding<br />
<a href="#anchor21">15.</a>&nbsp;
Appendix - Non-Normative - Relationship of JWTs to SAML Tokens<br />
<a href="#anchor22">16.</a>&nbsp;
Appendix - Non-Normative - Relationship of JWTs to Simple Web Tokens (SWTs)<br />
<a href="#rfc.references1">17.</a>&nbsp;
References<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#rfc.references1">17.1.</a>&nbsp;
Normative References<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#rfc.references2">17.2.</a>&nbsp;
Informative References<br />
<a href="#rfc.authors">&#167;</a>&nbsp;
Authors' Addresses<br />
</p>
<br clear="all" />

<a name="anchor1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1"></a><h3>1.&nbsp;
Introduction</h3>

<p>JSON Web Token (JWT) is a simple token format intended for
      space constrained environments such as HTTP Authorization
      headers and URI query parameters. JWTs encode the claims to be
      transmitted as a JSON object (as defined in <a class='info' href='#RFC4627'>RFC 4627<span> (</span><span class='info'>Crockford, D., &ldquo;The application/json Media Type for JavaScript Object Notation (JSON),&rdquo; July&nbsp;2006.</span><span>)</span></a> [RFC4627]) that is base64url encoded and
      digitally signed.
</p>
<p>The suggested pronunciation of JWT is the same as the English word "jot".
</p>
<a name="anchor2"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2"></a><h3>2.&nbsp;
Terminology</h3>

<p></p>
<blockquote class="text"><dl>
<dt>JSON Web Token (JWT)</dt>
<dd>A string consisting of
          three JWT Token Segments: the JWT Envelope Segment, the JWT
          Claim Segment, and the JWT Crypto Segment, in that order,
          with the segments being separated by period ('.')
          characters.
</dd>
<dt>JWT Token Segment</dt>
<dd>One of the three parts that
          make up a JSON Web Token (JWT).  JWT Token Segments are
          always base64url encoded values.
</dd>
<dt>JWT Envelope Segment</dt>
<dd>A JWT Token Segment
          containing a base64url encoded JSON object that describes
          the signature applied to the JWT Claim Segment.
</dd>
<dt>JWT Claim Segment</dt>
<dd>A JWT Token Segment
          containing a base64url encoded JSON object that encodes the
          claims represented by the JWT.
</dd>
<dt>JWT Crypto Segment</dt>
<dd>A JWT Token Segment
          containing base64url encoded cryptographic signature
          material that secures the JWT Crypto Segment's contents.
</dd>
<dt>Decoded JWT Envelope Segment</dt>
<dd>A JWT Envelope Segment that
          has been base64url decoded back into a JSON object.
</dd>
<dt>Decoded JWT Claim Segment</dt>
<dd>A JWT Claim Segment that
          has been base64url decoded back into a JSON object.
</dd>
<dt>Decoded JWT Crypto Segment</dt>
<dd>A JWT Crypto Segment that
          has been base64url decoded back into cryptographic material.
</dd>
<dt>Base64url Encoding</dt>
<dd>For the purposes of this specification, 
          this term always refers to the he URL- and filename-safe Base64
          encoding described in <a class='info' href='#RFC4648'>RFC 4648<span> (</span><span class='info'>Josefsson, S., &ldquo;The Base16, Base32, and Base64 Data Encodings,&rdquo; October&nbsp;2006.</span><span>)</span></a> [RFC4648], Section 5,
          with the '=' padding characters omitted, as permitted by Section 3.2;
          see <a class='info' href='#base64urllogic'>Section&nbsp;7<span> (</span><span class='info'>Base64url encoding as used by JWTs</span><span>)</span></a> for more details.
</dd>
</dl></blockquote>

<a name="anchor3"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3"></a><h3>3.&nbsp;
JSON Web Token (JWT) Overview</h3>

<p>JWTs represent a set of claims as a JSON object that is
      base64url encoded and digitally signed.  As per <a class='info' href='#RFC4627'>RFC 4627<span> (</span><span class='info'>Crockford, D., &ldquo;The application/json Media Type for JavaScript Object Notation (JSON),&rdquo; July&nbsp;2006.</span><span>)</span></a> [RFC4627] Section 2.2, the JSON object
      consists of zero or more name/value pairs (or members), where
      the names are strings and the values are arbitrary JSON values.
      These members are the claims represented by the JWT.  The JSON
      object is base64url encoded to produce the JWT Claim Segment. An
      accompanying base64url encoded JSON envelope object describes
      the signature method used.
</p>
<p>The names within the object MUST be unique.  The names within
      the JSON object are referred to as Claim Names.  The
      corresponding values are referred to as Claim Values.
</p>
<p>JWTs contain a signature that ensures the integrity of the
      content of the JSON Claim Segment.  This signature value is
      carried in the JWT Crypto Segment.  The JSON Envelope object
      MUST contain an "alg" parameter, the value of which is a string
      that unambiguously identifies the algorithm used to sign the JWT
      Claim Segment to produce the JWT Crypto Segment.
</p>
<a name="anchor4"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.1"></a><h3>3.1.&nbsp;
Example JWT</h3>

<p>The following is an example of a JSON object that can be
      encoded to produce a JWT:
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>{"iss":"joe",
 "exp":1300819380,
 "http://example.com/is_root":true}</pre></div>
<p>Base64url encoding the UTF-8 representation of the JSON
      object yields this JWT Claim Segment value:
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>eyJpc3MiOiJqb2UiLA0KICJleHAiOjEzMDA4MTkzODAsDQogImh0dHA6Ly9leGFtcGxlLmNvbS9pc19yb290Ijp0cnVlfQ</pre></div>
<p>The following example JSON envelope object declares that the
      encoded object is a JSON Web Token (JWT) and the JWT Claim
      Segment is signed using the HMAC SHA-256 algorithm:
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>{"typ":"JWT",
 "alg":"HS256"}</pre></div>
<p>Base64url encoding the UTF-8 representation of the JSON envelope
      object yields this JWT Envelope Segment value:
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>eyJ0eXAiOiJKV1QiLA0KICJhbGciOiJIUzI1NiJ9</pre></div>
<p>Signing the JWT Claim Segment with the HMAC SHA-256 algorithm
      and base64url encoding the result, as per <a class='info' href='#SigningWithHMACSHA256'>Section&nbsp;8.1<span> (</span><span class='info'>Signing a JWT with HMAC SHA-256</span><span>)</span></a>, yields this JWT Crypto Segment value:
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>35usWj9X8HwGS-CDcx1JP2NmqcrLwZ4EKp8sNThf3cY</pre></div>
<p>Combining these segments in the order
      Envelope.Claims.Signature with period characters between the
      segments yields this complete JWT (with line breaks for display
      purposes only):
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>eyJ0eXAiOiJKV1QiLA0KICJhbGciOiJIUzI1NiJ9
.
eyJpc3MiOiJqb2UiLA0KICJleHAiOjEzMDA4MTkzODAsDQogImh0dHA6Ly9leGFtcGxlLmNvbS9pc19yb290Ijp0cnVlfQ
.
35usWj9X8HwGS-CDcx1JP2NmqcrLwZ4EKp8sNThf3cY</pre></div>
<p>This computation is illustrated in more detail in <a class='info' href='#HMACSHA256Example'>Section&nbsp;13.1<span> (</span><span class='info'>JWT using HMAC SHA-256</span><span>)</span></a>.
</p>
<a name="anchor5"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4"></a><h3>4.&nbsp;
JWT Claims</h3>

<p>The members of the JSON object represented by the Decoded JWT
      Claim Segment contain the claims. Note however, that the set of
      claims a JWT must contain to be considered valid is
      context-dependent and is outside the scope of this
      specification.
</p>
<p>There are three classes of JWT Claim Names:  Reserved Claim Names, Public Claim Names, and Private Claim Names.
</p>
<a name="ReservedClaimName"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.1"></a><h3>4.1.&nbsp;
Reserved Claim Names</h3>

<p>The following claim names are reserved. None of the claims
	defined in the table below are intended to be mandatory, but
	rather, provide a starting point for a set of useful,
	interoperable claims.  All the names are short because a core
	goal of JWTs is for the tokens themselves to be short.
</p><br /><hr class="insert" />
<a name="ClaimTable"></a>
<table class="full" align="center" border="0" cellpadding="2" cellspacing="2">
<col align="left"><col align="left"><col align="left"><col align="left">
<tr><th align="left">Claim Name</th><th align="left">JSON Value Type</th><th align="left">Claim Syntax</th><th align="left">Claim Semantics</th></tr>
<tr>
<td align="left">exp</td>
<td align="left">integer</td>
<td align="left">IntDate</td>
<td align="left">The "exp" (expiration time) claim identifies the
	  expiration time on or after which the token MUST NOT be
	  accepted for processing.  The processing of the "exp" claim
	  requires that the current date/time MUST be before the
	  expiration date/time listed in the "exp" claim. Implementers
	  MAY provide for some small leeway, usually no more than a
	  few minutes, to account for clock skew.  This claim is
	  OPTIONAL.</td>
</tr>
<tr>
<td align="left">iss</td>
<td align="left">string</td>
<td align="left">StringAndURI</td>
<td align="left">The "iss" (issuer) claim identifies the principal that
	  issued the JWT.  The processing of this claim is generally
	  application specific.  This claim is OPTIONAL.</td>
</tr>
<tr>
<td align="left">aud</td>
<td align="left">string</td>
<td align="left">StringAndURI</td>
<td align="left">The "aud" (audience) claim identifies the audience that
	  the JWT is intended for.  The processing of this claim
	  requires that if a JWT consumer receives a JWT with an "aud"
	  value that does not identify itself as the JWT audience,
	  then the JWT MUST be rejected.  The interpretation of the
	  audience value is generally application specific.  This
	  claim is OPTIONAL.</td>
</tr>
<tr>
<td align="left">typ</td>
<td align="left">string</td>
<td align="left">StringAndURI</td>
<td align="left">The "typ" (type) claim is used to declare a type for the
	  contents this JWT.  The value MAY be a <a class='info' href='#RFC2045'>MIME<span> (</span><span class='info'>Freed, N. and N. Borenstein, &ldquo;Multipurpose Internet Mail Extensions (MIME) Part One: Format of Internet Message Bodies,&rdquo; November&nbsp;1996.</span><span>)</span></a> [RFC2045] type.  This claim is
	  OPTIONAL.</td>
</tr>
</table>
<br clear="all" />
<table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Table 1: Reserved Claim Definitions&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>Additional reserved claim names MAY be defined via the IANA
	JSON Web Token Claims registry, as per <a class='info' href='#IANA'>Section&nbsp;9<span> (</span><span class='info'>IANA Considerations</span><span>)</span></a>.  The syntaxes referred to above
	are:
</p><br /><hr class="insert" />
<a name="SyntaxDefinitions"></a>
<table class="full" align="center" border="0" cellpadding="2" cellspacing="2">
<col align="left"><col align="left">
<tr><th align="left">Syntax Name</th><th align="left">Syntax Definition</th></tr>
<tr>
<td align="left">StringAndURI</td>
<td align="left">Any string value MAY be used but a value containing a ":"
	  character MUST be a URI as defined in <a class='info' href='#RFC3986'>RFC 3986<span> (</span><span class='info'>Berners-Lee, T., Fielding, R., and L. Masinter, &ldquo;Uniform Resource Identifier (URI): Generic Syntax,&rdquo; January&nbsp;2005.</span><span>)</span></a> [RFC3986].</td>
</tr>
<tr>
<td align="left">URI</td>
<td align="left">A URI as defined in <a class='info' href='#RFC3986'>RFC 3986<span> (</span><span class='info'>Berners-Lee, T., Fielding, R., and L. Masinter, &ldquo;Uniform Resource Identifier (URI): Generic Syntax,&rdquo; January&nbsp;2005.</span><span>)</span></a> [RFC3986].</td>
</tr>
<tr>
<td align="left">IntDate</td>
<td align="left">The number of seconds from 1970-01-01T0:0:0Z as measured
	  in UTC until the desired date/time. See <a class='info' href='#RFC3339'>RFC 3339<span> (</span><span class='info'>Klyne, G., Ed. and C. Newman, &ldquo;Date and Time on the Internet: Timestamps,&rdquo; July&nbsp;2002.</span><span>)</span></a> [RFC3339] for details regarding
	  date/times in general and UTC in particular.</td>
</tr>
</table>
<br clear="all" />
<table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Table 2&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<a name="PublicClaimName"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.2"></a><h3>4.2.&nbsp;
Public Claim Names</h3>

<p>Claim names can be defined at will by those using
        JWTs. However, in order to prevent collisions, any new claim
        name SHOULD either be defined in the IANA
        JSON Web Token Claims registry or be defined as
        a URI that contains a collision resistant namespace. Examples
        of collision resistant namespaces include:

          </p>
<ul class="text">
<li>Domain Names,
</li>
<li>Object Identifiers (OIDs) as defined in the ITU-T X 660 and X
            670 Recommendation series or
</li>
<li>Universally Unique IDentifier (UUID) as defined in <a class='info' href='#RFC4122'>RFC 4122<span> (</span><span class='info'>Leach, P., Mealling, M., and R. Salz, &ldquo;A Universally Unique IDentifier (UUID) URN Namespace,&rdquo; July&nbsp;2005.</span><span>)</span></a> [RFC4122].
</li>
</ul><p>
        In each case, the definer of the name or value MUST take
        reasonable precautions to make sure they are in control of the part of
        the namespace they use to define the claim name.
</p>
<a name="PrivateClaimName"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.3"></a><h3>4.3.&nbsp;
Private Claim Names</h3>

<p>A producer and consumer of a JWT may agree to any claim
         name that is not a Reserved Name <a class='info' href='#ReservedClaimName'>Section&nbsp;4.1<span> (</span><span class='info'>Reserved Claim Names</span><span>)</span></a>
	 or a Public Name <a class='info' href='#PublicClaimName'>Section&nbsp;4.2<span> (</span><span class='info'>Public Claim Names</span><span>)</span></a>. Unlike
         Public Names, these private names are subject to collision and
         should be used with caution.
</p>
<a name="anchor6"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5"></a><h3>5.&nbsp;
JWT Envelope</h3>

<p>The members of the JSON object represented by the Decoded JWT
      Envelope Segment describe the signature applied to the JWT Claim
      Segment and optionally additional properties of the JWT.
      Implementations MUST understand the entire contents of the
      envelope; otherwise, the JWT MUST be rejected for
      processing.
</p>
<a name="ReservedEnvelopeParameterName"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.1"></a><h3>5.1.&nbsp;
Reserved Envelope Parameter Names</h3>

<p>The following envelope parameter names are reserved.  All
	the names are short because a core goal of JWTs is for the
	tokens themselves to be short.
</p><br /><hr class="insert" />
<a name="EnvelopeParameterTable"></a>
<table class="full" align="center" border="0" cellpadding="2" cellspacing="2">
<col align="left"><col align="left"><col align="left"><col align="left">
<tr><th align="left">Envelope Parameter Name</th><th align="left">JSON Value Type</th><th align="left">Envelope Parameter Syntax</th><th align="left">Envelope Parameter Semantics</th></tr>
<tr>
<td align="left">alg</td>
<td align="left">string</td>
<td align="left">StringAndURI</td>
<td align="left">The "alg" (algorithm) envelope parameter identifies the
	  cryptographic algorithm used to secure the JWT.  A list of
	  reserved alg values is in <a class='info' href='#AlgTable'>Table&nbsp;4<span> (</span><span class='info'>JSON Web Token Reserved Algorithm Values</span><span>)</span></a>.
	  The processing of the "alg" (algorithm) envelope parameter,
	  if present, requires that the value of the "alg" envelope
	  parameter MUST be one that is both supported and for which
	  there exists a key for use with that algorithm associated
	  with the issuer of the JWT.  Note however, that if the "iss"
	  (issuer) claim is not included in the JWT Claim Segment,
	  then the manner in which the issuer is determined is
	  application specific. This envelope parameter is
	  REQUIRED.</td>
</tr>
<tr>
<td align="left">typ</td>
<td align="left">string</td>
<td align="left">StringAndURI</td>
<td align="left">The "typ" (type) envelope parameter is used to declare
	  that this data structure is a JWT.  If a "typ" parameter is
	  present, its value MUST be "JWT".  This envelope parameter
	  is OPTIONAL.  (Non-normative note: Other values could be
	  used by other specifications to declare data structures
	  other than JWTs, for instance, encrypted JSON tokens.)</td>
</tr>
<tr>
<td align="left">keyid</td>
<td align="left">string</td>
<td align="left">String</td>
<td align="left">The "keyid" (key ID) envelope parameter is a hint
	  indicating which specific key owned by the signer should be
	  used to validate the signature.  This allows signers to
	  explicitly signal a change of key to recipients. Omitting
	  this parameter is equivalent to setting it to an empty
	  string. The format of this parameter is unspecified.  This
	  envelope parameter is OPTIONAL.</td>
</tr>
<tr>
<td align="left">curi</td>
<td align="left">string</td>
<td align="left">URI</td>
<td align="left">The "curi" (certificates URI) envelope parameter is a URI
	  that points to X.509 public key certificates that can be
	  used to validate the signature.  This envelope parameter is
	  OPTIONAL.</td>
</tr>
<tr>
<td align="left">ctp</td>
<td align="left">string</td>
<td align="left">String</td>
<td align="left">The "ctp" (certificate thumbprint) envelope parameter
	  provides a base64url encoded SHA-1 thumbprint of the DER
	  encoding of a certificate that can be used to validate the
	  signature.  This envelope parameter is OPTIONAL.</td>
</tr>
</table>
<br clear="all" />
<table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Table 3: Reserved Envelope Parameter Definitions&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>Additional reserved envelope parameter names MAY be defined
	via the IANA JSON Web Token Envelope Parameters registry, as
	per <a class='info' href='#IANA'>Section&nbsp;9<span> (</span><span class='info'>IANA Considerations</span><span>)</span></a>.  The envelope value syntaxes
	referred to above are defined in <a class='info' href='#SyntaxDefinitions'>Table&nbsp;2</a>.
</p>
<a name="PublicEnvelopeParameterName"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.2"></a><h3>5.2.&nbsp;
Public Envelope Parameter Names</h3>

<p>Additional envelope parameter names can be defined by those using
        JWTs. However, in order to prevent collisions, any new envelope parameter
        name or algorithm value SHOULD either be defined in the IANA
        JSON Web Token Envelope Parameters registry or be defined as
        a URI that contains a collision resistant namespace.
        In each case, the definer of the name or value MUST take
        reasonable precautions to make sure they are in control of the part of
        the namespace they use to define the envelope parameter name.
</p>
<p>New envelope parameters should be introduced sparingly, as
	they can result in non-interoperable JWTs.  Nonetheless, some
	extensions needed for some use cases may require them, such as
	an extension to enable the inclusion of multiple
	signatures.
</p>
<a name="PrivateEnvelopeParameterName"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.3"></a><h3>5.3.&nbsp;
Private Envelope Parameter Names</h3>

<p>A producer and consumer of a JWT may agree to any envelope parameter
         name that is not a Reserved Name <a class='info' href='#ReservedEnvelopeParameterName'>Section&nbsp;5.1<span> (</span><span class='info'>Reserved Envelope Parameter Names</span><span>)</span></a>
	 or a Public Name <a class='info' href='#PublicEnvelopeParameterName'>Section&nbsp;5.2<span> (</span><span class='info'>Public Envelope Parameter Names</span><span>)</span></a>. Unlike
         Public Names, these private names are subject to collision and
         should be used with caution.
</p>
<p>New envelope parameters should be introduced sparingly, as
	they can result in non-interoperable JWTs.
</p>
<a name="anchor7"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6"></a><h3>6.&nbsp;
General Rules for Creating and Validating a JWT</h3>

<p>To create a JWT one MUST follow these steps:
        </p>
<ol class="text">
<li>Create a JSON object containing the desired claims.  Note
          that white space is explicitly allowed in the representation
          and no canonicalization is performed before encoding.
</li>
<li>Translate this JSON object's Unicode code points into
          UTF-8, as defined in <a class='info' href='#RFC3629'>RFC
          3629<span> (</span><span class='info'>Yergeau, F., &ldquo;UTF-8, a transformation format of ISO 10646,&rdquo; November&nbsp;2003.</span><span>)</span></a> [RFC3629].
</li>
<li>Base64url encode the UTF-8 representation of this
          JSON object as defined in this specification (without
          padding). This encoding becomes the JWT Claim Segment.
</li>
<li>Create a different JSON object containing the desired
	  envelope parameters.  Note that white space is explicitly
	  allowed in the representation and no canonicalization is
	  performed before encoding.
</li>
<li>Translate this JSON object's Unicode code points into
          UTF-8, as defined in <a class='info' href='#RFC3629'>RFC
          3629<span> (</span><span class='info'>Yergeau, F., &ldquo;UTF-8, a transformation format of ISO 10646,&rdquo; November&nbsp;2003.</span><span>)</span></a> [RFC3629].
</li>
<li>Base64url encode the UTF-8 representation of this JSON
          object as defined in this specification (without
          padding). This encoding becomes the JWT Envelope
          Segment.
</li>
<li>Construct the JWT Crypto Segment as defined for the
          particular algorithm being used.  The "alg" envelope
          parameter MUST be present in the JSON Envelope Segment, with
          the algorithm value accurately representing the algorithm
          used to construct the JWT Crypto Segment.
</li>
<li>Combine the JWT Envelope Segment, the JWT Claim Segment
          and then the JWT Crypto Segment in that order, separating
          each by period characters, to create the JWT.
</li>
</ol>

<p>When validating a JWT the following steps MUST be taken. If
      any of the listed steps fails then the token MUST be rejected
      for processing.
</p>
<p></p>
<ol class="text">
<li>The JWT MUST contain two period characters.
</li>
<li>The JWT MUST be split on the two period characters
          resulting in three non-empty segments.  The first segment is
          the JWT Envelope Segment; the second is the JWT Claim
          Segment; the third is the JWT Crypto Segment.
</li>
<li>The JWT Envelope Segment MUST be successfully base64url
          decoded following the restriction given in this spec that no
          padding characters may have been used.
</li>
<li>The Decoded JWT Envelope Segment MUST be completely valid
          JSON syntax.
</li>
<li>The JWT Claim Segment MUST be successfully base64url
          decoded following the restriction given in this spec that no
          padding characters may have been used.
</li>
<li>The Decoded JWT Claim Segment MUST be completely valid
          JSON syntax.
</li>
<li>The JWT Crypto Segment MUST be successfully base64url
          decoded following the restriction given in this spec that no
          padding characters may have been used.
</li>
<li>The JWT Envelope Segment MUST be validated to only
          include parameters and values whose syntax and semantics are
          both understood and supported.
</li>
<li>When used in a security-related context, the JWT Claim
          Segment MUST be validated to only include claims whose
          syntax and semantics are both understood and supported.
</li>
<li>The JWT Crypto Segment MUST be successfully validated
          against the JWT Claim Segment in the manner defined for the
          algorithm being used, which MUST be accurately represented
          by the value of the "alg" envelope parameter, which MUST be
          present.
</li>
</ol>

<p>Processing a JWT inevitably requires comparing known strings
      to values in the token. For example, in checking what the
      algorithm is, the Unicode string encoding "alg" will be checked
      against the member names in the Decoded JWT Envelope Segment to
      see if there is a matching envelope parameter name. A similar
      process occurs when determining if the value of the "alg"
      envelope parameter represents a supported algorithm. Comparing
      Unicode strings, however, has significant security implications,
      as per <a class='info' href='#Security'>Section&nbsp;10<span> (</span><span class='info'>Security Considerations</span><span>)</span></a>.
</p>
<p>Comparisons between JSON strings and other Unicode strings
      MUST be performed as specified below:
</p>
<p></p>
<ol class="text">
<li>Remove any JSON applied escaping to produce an array of
          Unicode code points.
</li>
<li><a class='info' href='#USA15'>Unicode Normalization<span> (</span><span class='info'>Davis, M., Whistler, K., and M. D&uuml;rst, &ldquo;Unicode Normalization Forms,&rdquo; 09&nbsp;2009.</span><span>)</span></a> [USA15] MUST
          NOT be applied at any point to either the JSON string or to
          the string it is to be compared against.
</li>
<li>Comparisons between the two strings MUST be performed as
          a Unicode code point to code point equality comparison.
</li>
</ol>

<a name="base64urllogic"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7"></a><h3>7.&nbsp;
Base64url encoding as used by JWTs</h3>

<p>JWTs make use of the base64url encoding as defined in <a class='info' href='#RFC4648'>RFC 4648<span> (</span><span class='info'>Josefsson, S., &ldquo;The Base16, Base32, and Base64 Data Encodings,&rdquo; October&nbsp;2006.</span><span>)</span></a> [RFC4648]. As allowed by Section 3.2 of the
      RFC, this specification mandates that base64url encoding
      when used with JWTs MUST NOT use padding. The reason for this
      restriction is that the padding character ('=') is not URL
      safe.
</p>
<p>For notes on implementing base64url encoding without padding,
      see <a class='info' href='#base64urlnotes'>Section&nbsp;14<span> (</span><span class='info'>Appendix - Non-Normative - Notes on implementing base64url encoding without padding</span><span>)</span></a>.
</p>
<a name="Signing"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.8"></a><h3>8.&nbsp;
Signing JWTs with Cryptographic Algorithms</h3>

<p>JWTs use specific cryptographic algorithms to sign the contents
    of the JWT Claim Segment.  The use of the following algorithms for
    producing JWTs is defined in this section.  The table below is the
    list of "alg" envelope parameter values reserved by this
    specification, each of which is explained in more detail in the
    following sections:
</p><br /><hr class="insert" />
<a name="AlgTable"></a>
<table class="full" align="center" border="0" cellpadding="2" cellspacing="2">
<col align="left"><col align="left">
<tr><th align="left">Alg Claim Value</th><th align="left">Algorithm</th></tr>
<tr>
<td align="left">HS256</td>
<td align="left">HMAC using SHA-256 hash algorithm</td>
</tr>
<tr>
<td align="left">HS384</td>
<td align="left">HMAC using SHA-384 hash algorithm</td>
</tr>
<tr>
<td align="left">HS512</td>
<td align="left">HMAC using SHA-512 hash algorithm</td>
</tr>
<tr>
<td align="left">RS256</td>
<td align="left">RSA using SHA-256 hash algorithm</td>
</tr>
<tr>
<td align="left">RS384</td>
<td align="left">RSA using SHA-384 hash algorithm</td>
</tr>
<tr>
<td align="left">RS512</td>
<td align="left">RSA using SHA-512 hash algorithm</td>
</tr>
<tr>
<td align="left">ES256</td>
<td align="left">ECDSA using P-256 curve and SHA-256 hash algorithm</td>
</tr>
<tr>
<td align="left">ES384</td>
<td align="left">ECDSA using P-384 curve and SHA-384 hash algorithm</td>
</tr>
<tr>
<td align="left">ES512</td>
<td align="left">ECDSA using P-521 curve and SHA-512 hash algorithm</td>
</tr>
</table>
<br clear="all" />
<table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Table 4: JSON Web Token Reserved Algorithm Values&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>Of these algorithms, only HMAC SHA-256 and RSA SHA-256 MUST be
    implemented.  It is RECOMMENDED that implementations also
    implement at least the ECDSA P-256 SHA-256 algorithm.
</p>
<a name="SigningWithHMACSHA256"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.8.1"></a><h3>8.1.&nbsp;
Signing a JWT with HMAC SHA-256</h3>

<p>Hash based Message Authentication Codes (HMACs) enable one to
      use a secret plus a cryptographic hash function to generate a
      Message Authentication Code (MAC). This can be used to
      demonstrate that the MAC matches the hashed content, in this
      case the JWT Claim Segment, which therefore demonstrates that
      whoever generated the MAC was in possession of the
      secret.
</p>
<p>The algorithm for implementing and validating HMACs is
      provided in <a class='info' href='#RFC2104'>RFC 2104<span> (</span><span class='info'>Krawczyk, H., Bellare, M., and R. Canetti, &ldquo;HMAC: Keyed-Hashing for Message Authentication,&rdquo; February&nbsp;1997.</span><span>)</span></a> [RFC2104]. Although any
      HMAC can be used with JWTs, this section defines the use of the
      SHA-256 cryptographic hash function as defined in <a class='info' href='#FIPS.180-3'>FIPS 180-3<span> (</span><span class='info'>National Institute of Standards and             Technology, &ldquo;Secure Hash Standard (SHS),&rdquo; October&nbsp;2008.</span><span>)</span></a> [FIPS.180&#8209;3]. The reserved "alg"
      envelope parameter value "HS256" is used in the JWT Envelope
      Segment to indicate that the JWT Crypto Segment contains a
      base64url encoded HMAC SHA-256 HMAC value.
</p>
<p>The HMAC SHA-256 MAC is generated as follows:
        </p>
<ol class="text">
<li>Take the bytes of the UTF-8 representation of the JWT
          Claim Segment and execute the HMAC SHA-256 algorithm on them
          using the shared key to produce an HMAC.
</li>
<li>Base64url encode the HMAC as defined in this document.
</li>
</ol><p>
      The output is placed in the JWT Crypto Segment for that JWT.
</p>
<p>The HMAC SHA-256 MAC on a JWT is validated as follows:
        </p>
<ol class="text">
<li>Take the bytes of the UTF-8 representation of the JWT
          Claim Segment and calculate an HMAC SHA-256 MAC on them
          using the shared key.
</li>
<li>Base64url encode the previously generated HMAC as defined in this
          document.
</li>
<li>If the JWT Crypto Segment and the previously calculated value
          exactly match in a character by character, case sensitive
          comparison, then one has confirmation that the key was
          used to generate the HMAC on the JWT and that the contents of
          the JWT Claim Segment have not be tampered with.
</li>
<li>If the validation fails, the token MUST be rejected.
</li>
</ol>

<p>Signing with the HMAC SHA-384 and HMAC SHA-512 algorithms is
      performed identically to the procedure for HMAC SHA-256 - just
      with correspondingly longer key and result values.
</p>
<p>JWT implementations MUST support the HMAC SHA-256 algorithm.
      Support for the HMAC SHA-384 and HMAC SHA-512 algorithms is
      OPTIONAL.
</p>
<a name="DefiningRSA"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.8.2"></a><h3>8.2.&nbsp;
Signing a JWT with RSA SHA-256</h3>

<p>This section defines the use of the RSASSA-PKCS1-v1_5
      signature algorithm as defined in <a class='info' href='#RFC3447'>RFC
      3447<span> (</span><span class='info'>Jonsson, J. and B. Kaliski, &ldquo;Public-Key Cryptography Standards (PKCS) #1: RSA Cryptography Specifications Version 2.1,&rdquo; February&nbsp;2003.</span><span>)</span></a> [RFC3447], Section 8.2 (commonly known as PKCS#1), using
      SHA-256 as the hash function.  Note that the use of the
      RSASSA-PKCS1-v1_5 algorithm is permitted in <a class='info' href='#FIPS.186-3'>FIPS 186-3<span> (</span><span class='info'>National Institute of Standards and             Technology, &ldquo;Digital Signature Standard (DSS),&rdquo; June&nbsp;2009.</span><span>)</span></a> [FIPS.186&#8209;3], Section 5.5, as is the
      SHA-256 cryptographic hash function, which is defined in <a class='info' href='#FIPS.180-3'>FIPS 180-3<span> (</span><span class='info'>National Institute of Standards and             Technology, &ldquo;Secure Hash Standard (SHS),&rdquo; October&nbsp;2008.</span><span>)</span></a> [FIPS.180&#8209;3].  The reserved "alg"
      envelope parameter value "RS256" is used in the JWT Envelope
      Segment to indicate that the JWT Crypto Segment contains an RSA
      SHA-256 signature.
</p>
<p>A 2048-bit or longer key length MUST be used with this algorithm.
</p>
<p>The RSA SHA-256 signature is generated as follows:
        </p>
<ol class="text">
<li>Let K be the signer's RSA private key and let M be the
          bytes of the UTF-8 representation of the JWT Claim
          Segment.
</li>
<li>Compute the octet string S = RSASSA-PKCS1-V1_5-SIGN (K, M).
</li>
<li>Base64url encode the octet string S, as defined in this document.
</li>
</ol><p>
      The output is placed in the JWT Crypto Segment for that JWT.
</p>
<p>The RSA SHA-256 signature on a JWT is validated as follows:
        </p>
<ol class="text">
<li>Take the JWT Crypto Segment and base64url decode it into
          an octet string S. If decoding fails, then the token MUST be
          rejected.
</li>
<li>Let M be the bytes of the UTF-8 representation of the JWT
          Claim Segment and let (n, e) be the public key corresponding
          to the private key used by the signer.
</li>
<li>Validate the signature with RSASSA-PKCS1-V1_5-VERIFY
	  ((n, e), M, S).
</li>
<li>If the validation fails, the token MUST be rejected.
</li>
</ol><p>
      
</p>
<p>Signing with the RSA SHA-384 and RSA SHA-512 algorithms is
      performed identically to the procedure for RSA SHA-256 - just
      with correspondingly longer key and result values.
</p>
<p>JWT implementations MUST support the RSA SHA-256 algorithm.
      Support for the RSA SHA-384 and RSA SHA-512 algorithms is
      OPTIONAL.
</p>
<a name="DefiningECDSA"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.8.3"></a><h3>8.3.&nbsp;
Signing a JWT with ECDSA P-256 SHA-256</h3>

<p>The Elliptic Curve Digital Signature Algorithm (ECDSA) is
      defined by <a class='info' href='#FIPS.186-3'>FIPS 186-3<span> (</span><span class='info'>National Institute of Standards and             Technology, &ldquo;Digital Signature Standard (DSS),&rdquo; June&nbsp;2009.</span><span>)</span></a> [FIPS.186&#8209;3]. ECDSA
      provides for the use of Elliptic Curve cryptography, which is
      able to provide equivalent security to RSA cryptography but
      using shorter key lengths and with greater processing
      speed. This means that ECDSA signatures will be substantially
      smaller in terms of length than equivalently strong RSA Digital
      Signatures.
</p>
<p>This specification defines the use of ECDSA with the P-256
      curve and the SHA-256 cryptographic hash function. The P-256
      curve is also defined in FIPS 186-3. The reserved "alg" envelope
      parameter value "ES256" is used in the JWT Envelope Segment to
      indicate that the JWT Crypto Segment contains a ECDSA P-256
      SHA-256 signature.
</p>
<p>A JWT is signed with an ECDSA P-256 SHA-256 signature as
      follows:
        </p>
<ol class="text">
<li>Take the bytes of the UTF-8 representation of the JWT
          Claim Segment and generate a digital signature of them using
          ECDSA P-256 SHA-256 with the desired private key. The output
          will be the EC point (R, S), where R and S are unsigned
          integers.
</li>
<li>Turn R and S into byte arrays in big endian order. Each array
          will be 32 bytes long.
</li>
<li>Concatenate the two byte arrays in the order R and then S.
</li>
<li>Base64url encode the 64 byte array as defined in this specification.
</li>
</ol><p>
      The output becomes the JWT Crypto Segment for the JWT.
</p>
<p>The following procedure is used to validate the ECDSA
      signature of a JWT:
        </p>
<ol class="text">
<li>Take the JWT Crypto Segment and base64url decode it into
          a byte array. If decoding fails, the token MUST be rejected.
</li>
<li>The output of the base64url decoding MUST be a 64 byte array.
</li>
<li>Split the 64 byte array into two 32 byte arrays. The first array
          will be R and the second S. Remember that the byte arrays are
          in big endian byte order; please check the ECDSA validator in
          use to see what byte order it requires.
</li>
<li>Submit the bytes of the UTF-8 representation of the JWT
	  Claim Segment, R, S and the public key (x, y) to the ECDSA
	  P-256 SHA-256 validator.
</li>
<li>If the validation fails, the token MUST be rejected.
</li>
</ol><p>

      The ECDSA validator will then determine if the digital signature
      is valid, given the inputs.  Note that ECDSA digital signature
      contains a value referred to as K, which is a random number
      generated for each digital signature instance. This means that
      two ECDSA digital signatures using exactly the same input
      parameters will output different signatures because their K
      values will be different. The consequence of this is that one
      must validate an ECDSA signature by submitting the previously
      specified inputs to an ECDSA validator.
</p>
<p>Signing with the ECDSA P-384 SHA-384 and ECDSA P-521 SHA-512 algorithms is
      performed identically to the procedure for ECDSA P-256 SHA-256 - just
      with correspondingly longer key and result values.
</p>
<p>It is RECOMMENDED that JWT implementations support the ECDSA
      P-256 SHA-256 algorithm.  Support for the ECDSA P-384 SHA-384
      and ECDSA P-521 SHA-512 algorithms is OPTIONAL.
</p>
<a name="anchor8"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.8.4"></a><h3>8.4.&nbsp;
Additional Algorithms</h3>

<p>Additional algorithms MAY be used to protect JWTs with
      corresponding "alg" envelope parameter values being defined to
      refer to them. Like claim names, new "alg" envelope parameter
      values SHOULD either be defined in the IANA JSON Web Token
      Algorithms registry or be a URI that contains a collision
      resistant namespace.  In particular, the use of algorithm
      identifiers defined in <a class='info' href='#RFC3275'>XML DSIG<span> (</span><span class='info'>Eastlake, D., Reagle, J., and D. Solo, &ldquo;(Extensible Markup Language) XML-Signature Syntax and Processing,&rdquo; March&nbsp;2002.</span><span>)</span></a> [RFC3275]
      and related specifications is permitted.
</p>
<a name="IANA"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.9"></a><h3>9.&nbsp;
IANA Considerations</h3>

<p>This specification calls for:
        </p>
<ul class="text">
<li>A new IANA registry entitled "JSON Web Token Claims" for
          reserved claim names <a class='info' href='#ReservedClaimName'>Section&nbsp;4.1<span> (</span><span class='info'>Reserved Claim Names</span><span>)</span></a> used in a Decoded JWT
          Claim Segment. Inclusion in the registry is RFC Required in
          the <a class='info' href='#RFC5226'>RFC 5226<span> (</span><span class='info'>Narten, T. and H. Alvestrand, &ldquo;Guidelines for Writing an IANA Considerations Section in RFCs,&rdquo; May&nbsp;2008.</span><span>)</span></a> [RFC5226] sense for
          reserved JWT claim names that are intended to be
          interoperable between implementations.  The registry will
          just record the reserved claim name and a pointer to the RFC
          that defines it. This specification defines inclusion of the
          claim names defined in <a class='info' href='#ClaimTable'>Table&nbsp;1<span> (</span><span class='info'>Reserved Claim Definitions</span><span>)</span></a>.
</li>
<li>A new IANA registry entitled "JSON Web Token Envelope
          Parameters" for reserved envelope parameter names <a class='info' href='#ReservedEnvelopeParameterName'>Section&nbsp;5.1<span> (</span><span class='info'>Reserved Envelope Parameter Names</span><span>)</span></a> used in a
          Decoded JWT Envelope Parameter Segment. Inclusion in the
          registry is RFC Required in the <a class='info' href='#RFC5226'>RFC
          5226<span> (</span><span class='info'>Narten, T. and H. Alvestrand, &ldquo;Guidelines for Writing an IANA Considerations Section in RFCs,&rdquo; May&nbsp;2008.</span><span>)</span></a> [RFC5226] sense for reserved JWT envelope parameter names
          that are intended to be interoperable between
          implementations.  The registry will just record the reserved
          envelope parameter name and a pointer to the RFC that
          defines it. This specification defines inclusion of the
          envelope parameter names defined in <a class='info' href='#EnvelopeParameterTable'>Table&nbsp;3<span> (</span><span class='info'>Reserved Envelope Parameter Definitions</span><span>)</span></a>.
</li>
<li>A new IANA registry entitled "JSON Web Token Algorithms"
          for reserved values used with the "alg" envelope parameter
          values used in a decoded JWT Envelope Segment. Inclusion in
          the registry is RFC Required in the <a class='info' href='#RFC5226'>RFC 5226<span> (</span><span class='info'>Narten, T. and H. Alvestrand, &ldquo;Guidelines for Writing an IANA Considerations Section in RFCs,&rdquo; May&nbsp;2008.</span><span>)</span></a> [RFC5226] sense. The registry will
          just record the "alg" value and a pointer to the RFC that
          defines it.  This specification defines inclusion of the
          algorithm values defined in <a class='info' href='#AlgTable'>Table&nbsp;4<span> (</span><span class='info'>JSON Web Token Reserved Algorithm Values</span><span>)</span></a>.
</li>
</ul>

<a name="Security"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.10"></a><h3>10.&nbsp;
Security Considerations</h3>

<p>TBD: Lots of work to do here. We need to remember to look
      into any issues relating to security and JSON parsing. One
      wonders just how secure most JSON parsing libraries are. Were
      they ever hardened for security scenarios? If not, what kind of
      holes does that open up? Also, we need to walk through the JSON
      standard and see what kind of issues we have especially around
      comparison of names.  For instance, comparisons of claim names
      and other parameters must occur after they are unescaped. Need
      to also put in text about: Importance of keeping secrets
      secret. Rotating keys. Strengths and weaknesses of the different
      algorithms. Case sensitivity and more generally Unicode
      comparison issues that can cause security holes, especially in
      claim names and explain why Unicode Normalization is such a
      problem.
</p>
<p>TBD: Need to put in text about why strict JSON validation is necessary.
      Basically, that if malformed JSON is received then the intent of the
      sender is impossible to reliably discern. While in non-security
      contexts it's o.k. to be generous in what one accepts, in security
      contexts this can lead to serious security holes. For example, malformed
      JSON might indicate that someone has managed to find a security hole in
      the issuer's code and is leveraging it to get the issuer to issue "bad"
      tokens whose content the attacker can control.
</p>
<a name="anchor9"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.10.1"></a><h3>10.1.&nbsp;
Unicode Comparison Security Issues</h3>

<p>Claim names in JWTs are Unicode strings.  For security
        reasons, the representations these names must be compared verbatim after performing
        any escape processing (as per <a class='info' href='#RFC4627'>RFC
        4627<span> (</span><span class='info'>Crockford, D., &ldquo;The application/json Media Type for JavaScript Object Notation (JSON),&rdquo; July&nbsp;2006.</span><span>)</span></a> [RFC4627], Section 2.5).  In particular, <a class='info' href='#USA15'>Unicode Normalization<span> (</span><span class='info'>Davis, M., Whistler, K., and M. D&uuml;rst, &ldquo;Unicode Normalization Forms,&rdquo; 09&nbsp;2009.</span><span>)</span></a> [USA15] or case folding
        MUST NOT be applied at any point to either the JSON string or
        to the string it is to be compared against.
</p>
<p>This means, for instance, that these JSON strings must
        compare as being equal ("JWT", "\u004aWT"), whereas these must
        all compare as being not equal to the first set or to each other
        ("jwt", "Jwt", "JW\u0074").
</p>
<p>JSON strings MAY contain characters outside the Unicode
        Basic Multilingual Plane.  For instance, the G clef character
        (U+1D11E) may be represented in a JSON string as
        "\uD834\uDD1E".  Ideally, JWT implementations SHOULD ensure
        that characters outside the Basic Multilingual Plane are
        preserved and compared correctly; alternatively, if this is
        not possible due to these characters exercising limitations
        present in the underlying JSON implementation, then input
        containing them MUST be rejected.
</p>
<a name="OpenIssues"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.11"></a><h3>11.&nbsp;
Open Issues</h3>

<p>The following open issues have been identified during review
      of previous drafts.  Additional input on them is solicited.
</p>
<ul class="text">
<li>The draft currently defines no mechanism(s) for retrieving
        public keys that are not encoded as X.509 certificates.  A
        mechanism or mechanisms similar to the Magic Signatures key
        discovery process for Magic Keys could be added to future
        drafts.  Some have suggested that they keys themselves also be
        encoded as JWTs.
</li>
<li>Related to the above, it's not clear whether the "iss"
	claim should be expected to contain a location for retrieving
	non-X.509 public keys, or whether a separate issuer key
	location parameter should be defined.  Also, does this belong
	in the envelope or the claims?
</li>
</ul>
<a name="Acknowledgements"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.12"></a><h3>12.&nbsp;
Acknowledgements</h3>

<p>The authors acknowledge that the design of JWTs was
      intentionally influenced by the design and simplicity of <a class='info' href='#SWT'>Simple Web Tokens<span> (</span><span class='info'>Hardt, D. and Y. Goland, &ldquo;Simple Web Token (SWT),&rdquo; November&nbsp;2009.</span><span>)</span></a> [SWT].  Solutions for signing
      JSON tokens were also previously explored by <a class='info' href='#MagicSignatures'>Magic Signatures<span> (</span><span class='info'>Panzer (editor), J., Laurie, B., and D. Balfanz, &ldquo;Magic Signatures,&rdquo; August&nbsp;2010.</span><span>)</span></a> [MagicSignatures], <a class='info' href='#JSS'>JSON Simple Sign<span> (</span><span class='info'>Bradley, J. and N. Sakimura (editor), &ldquo;JSON Simple Sign,&rdquo; September&nbsp;2010.</span><span>)</span></a> [JSS], and <a class='info' href='#CanvasApp'>Canvas Applications<span> (</span><span class='info'>Facebook, &ldquo;Canvas Applications,&rdquo; 2010.</span><span>)</span></a> [CanvasApp], all of which influenced this draft.
</p>
<a name="JWTExamples"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.13"></a><h3>13.&nbsp;
Appendix - Non-Normative - JWT Examples</h3>

<a name="HMACSHA256Example"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.13.1"></a><h3>13.1.&nbsp;
JWT using HMAC SHA-256</h3>

<a name="anchor10"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.13.1.1"></a><h3>13.1.1.&nbsp;
Encoding</h3>

<p>The Decoded JWT Claim Segment used in this example is:
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>{"iss":"joe",
 "exp":1300819380,
 "http://example.com/is_root":true}</pre></div>
<p>Note that white space is explicitly allowed in Decoded JWT Claim Segments
    and no canonicalization is performed before encoding. The
    following byte array contains the UTF-8 characters for the
    Decoded JWT Claim Segment:
</p>
<p>

[123, 34, 105, 115, 115, 34, 58, 34, 106, 111, 101, 34,
  44, 13, 10, 32, 34, 101, 120, 112, 34, 58, 49, 51,
  48, 48, 56, 49, 57, 51, 56, 48, 44, 13, 10, 32, 34,
  104, 116, 116, 112, 58, 47, 47, 101, 120, 97, 109, 112,
  108, 101, 46, 99, 111, 109, 47, 105, 115, 95, 114, 111,
  111, 116, 34,
58, 116, 114, 117, 101, 125]

    
</p>
<p>Base64url encoding the above yields the JWT Claim Segment value:
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>eyJpc3MiOiJqb2UiLA0KICJleHAiOjEzMDA4MTkzODAsDQogImh0dHA6Ly9leGFtcGxlLmNvbS9pc19yb290Ijp0cnVlfQ</pre></div>
<p>The following example JSON envelope object declares that the
      encoded object is a JSON Web Token (JWT) and the JWT Claim
      Segment is signed using the HMAC SHA-256 algorithm:
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>{"typ":"JWT",
 "alg":"HS256"}</pre></div>
<p> The following byte array contains the UTF-8 characters for
      the Decoded JWT Envelope Segment:
</p>
<p>

[123, 34, 116, 121, 112, 34, 58, 34, 74, 87, 84, 34,
  44, 13, 10, 32, 34, 97, 108, 103, 34, 58, 34, 72, 83,
  50, 53, 54, 34, 125]

    
</p>
<p>Base64url encoding this UTF-8 representation yields this JWT
      Envelope Segment value:
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>eyJ0eXAiOiJKV1QiLA0KICJhbGciOiJIUzI1NiJ9</pre></div>
<p>HMACs are generated using keys. This example used the
    key represented by the following byte array:
</p>
<p>

[83, 159, 117, 12, 235, 169, 168, 200, 131, 152, 227,
  246, 214, 212, 188, 74, 71, 83, 244, 166, 90, 24, 239,
  251, 32, 124, 6, 201, 194, 104, 241, 62, 174, 246, 65,
  111, 49, 52, 210, 118, 212, 124, 34, 88, 167, 112, 84,
  88, 83, 65, 155, 18, 234, 250, 224, 101, 147, 221, 23,
  104, 219, 170, 146, 215]
    
    
</p>
<p>Running the HMAC SHA-256 algorithm on the JWT Claim Segment
    with this key yields the following byte array:
</p>
<p>

[223, 155, 172, 90, 63, 87, 240, 124, 6, 75, 224, 131,
  115, 29, 73, 63, 99, 102, 169, 202, 203, 193, 158, 4,
  42, 159, 44, 53, 56, 95, 221, 198]

    
</p>
<p>Base64url encoding the above HMAC output yields the JWT Crypto Segment value:
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>35usWj9X8HwGS-CDcx1JP2NmqcrLwZ4EKp8sNThf3cY</pre></div>
<p>Combining these segments in the order
      Envelope.Claims.Signature with period characters between the
      segments yields this complete JWT (with line breaks for display
      purposes only):
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>eyJ0eXAiOiJKV1QiLA0KICJhbGciOiJIUzI1NiJ9
.
eyJpc3MiOiJqb2UiLA0KICJleHAiOjEzMDA4MTkzODAsDQogImh0dHA6Ly9leGFtcGxlLmNvbS9pc19yb290Ijp0cnVlfQ
.
35usWj9X8HwGS-CDcx1JP2NmqcrLwZ4EKp8sNThf3cY</pre></div>
<a name="anchor11"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.13.1.2"></a><h3>13.1.2.&nbsp;
Decoding</h3>

<p>Decoding the JWT first requires removing the base64url
      encoding from the JWT Envelope Segment and the JWT Claim
      Segment. We base64url decode the segments per <a class='info' href='#base64urllogic'>Section&nbsp;7<span> (</span><span class='info'>Base64url encoding as used by JWTs</span><span>)</span></a> and turn them into the
      corresponding UTF-8 byte arrays, which we then translate into
      the Decoded JWT Envelope Segment and Decoded JWT Claim Segment
      strings.
</p>
<a name="anchor12"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.13.1.3"></a><h3>13.1.3.&nbsp;
Validating</h3>

<p>Next we validate the decoded results.  Since the "alg"
      parameter in the envelope is "HS256", we validate the HMAC
      SHA-256 signature contained in the JWT Crypto Segment.  If any
      of the validation steps fail, the token MUST be rejected.
</p>
<p>First, we validate that the decoded envelope and claim
      segment strings are both legal JSON.
</p>
<p>To validate the signature, we repeat the previous process of
      using the correct key and the JWT Claim Segment as input to a
      SHA-256 HMAC function and then taking the output, base64url
      encoding it, and determining if it matches the JWT Crypto
      Segment in the JWT.  If it matches exactly, the token has been
      validated.
</p>
<a name="anchor13"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.13.2"></a><h3>13.2.&nbsp;
JWT using RSA SHA-256</h3>

<a name="anchor14"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.13.2.1"></a><h3>13.2.1.&nbsp;
Encoding</h3>

<p>The Decoded JWT Claim Segment used in this example is the same as in the previous example:
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>{"iss":"joe",
 "exp":1300819380,
 "http://example.com/is_root":true}</pre></div>
<p>Since the JWT Claim Segment will therefore be the same, its
      computation is not repeated here.  However, the Decoded JWT
      Envelope Segment is different in two ways: First, because a
      different algorithm is being used, the "alg" value is
      different.  Second, for illustration purposes only, the
      optional "typ" parameter is not used.  (This difference is not
      related to the signature algorithm employed.)  The Decoded JWT
      Envelope Segment used is:
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>{"alg":"RS256"}</pre></div>
<p> The following byte array contains the UTF-8 characters for
      the Decoded JWT Envelope Segment:
</p>
<p>

 [123, 34, 97, 108, 103, 34, 58, 34, 82, 83, 50, 53,
  54, 34, 125]

    
</p>
<p>Base64url encoding this UTF-8 representation yields this JWT
      Envelope Segment value:
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>eyJhbGciOiJSUzI1NiJ9</pre></div>
<p>The RSA key consists of a public part (n, e), and a
        private exponent d.  The values of the RSA key used in this
        example, presented as the byte arrays representing
        big endian integers are:
</p><table class="full" align="center" border="0" cellpadding="2" cellspacing="2">
<col align="left"><col align="left">
<tr><th align="left">Parameter Name</th><th align="left">Value</th></tr>
<tr>
<td align="left">n</td>
<td align="left">

[210, 252, 123, 106, 10, 30, 108, 103, 16, 74, 235, 143,
136, 178, 87, 102, 155, 77, 246, 121, 221, 173, 9, 155,
92, 74, 108, 217, 168, 128, 21, 181, 161, 51, 191, 11,
133, 108, 120, 113, 182, 223, 0, 11, 85, 79, 206, 179,
194, 237, 81, 43, 182, 143, 20, 92, 110, 132, 52, 117,
47, 171, 82, 161,
207, 193, 36, 64, 143, 121, 181, 138, 69, 120, 193,
100, 40, 133, 87, 137, 247, 162, 73, 227, 132, 203, 45,
159, 174, 45, 103, 253, 150, 251, 146, 108, 25, 142, 7,
115, 153, 253, 200, 21, 192, 175, 9, 125, 222, 90, 173,
239, 244, 77, 231, 14, 130, 127, 72, 120, 67, 36, 57,
191, 238, 185, 96, 104,
208, 71, 79, 197, 13, 109, 144, 191, 58, 152, 223, 175,
16, 64, 200, 156, 2, 214, 146, 171, 59, 60, 40, 150,
96, 157, 134, 253, 115, 183, 116, 206, 7, 64, 100, 124,
238, 234, 163, 16, 189, 18, 249, 133, 168, 235, 159,
89, 253, 212, 38, 206, 165, 178, 18, 15, 79, 42, 52,
188, 171, 118, 75, 126,
108, 84, 214, 132, 2, 56, 188, 196, 5, 135, 165, 158,
102, 237, 31, 51, 137, 69, 119, 99, 92, 71, 10, 247,
92, 249, 44, 32, 209, 218, 67, 225, 191, 196, 25, 226,
34, 166, 240, 208, 187, 53, 140, 94, 56, 249, 203, 5,
10, 234, 254, 144, 72, 20, 241, 172, 26, 164, 156, 202,
158, 160, 202, 131]

	  </td>
</tr>
<tr>
<td align="left">e</td>
<td align="left">

[1, 0, 1]

	  </td>
</tr>
<tr>
<td align="left">d</td>
<td align="left">

[95, 135, 19, 181, 226, 88, 254, 9, 248, 21, 131, 236,
92, 31, 43, 117, 120, 177, 230, 252, 44, 131, 81, 75,
55, 145, 55, 17, 161, 186, 68, 154, 21, 31, 225, 203,
44, 160, 253, 51, 183, 113, 230, 138, 59, 25, 68, 100,
157, 200, 103, 173, 28, 30, 82, 64, 187, 133, 62, 95,
36, 179, 52, 89,
177, 64, 40, 210, 214, 99, 107, 239, 236, 30, 141, 169,
116, 179, 82, 252, 83, 211, 246, 18, 126, 168, 163,
194, 157, 209, 79, 57, 65, 104, 44, 86, 167, 135, 104,
22, 78, 77, 218, 143, 6, 203, 249, 199, 52, 170, 232,
0, 50, 36, 39, 142, 169, 69, 74, 33, 177, 124, 176,
109, 23, 128, 117, 134,
140, 192, 91, 61, 182, 255, 29, 253, 195, 213, 99, 120,
180, 237, 173, 237, 240, 195, 122, 76, 220, 38, 209,
212, 154, 194, 111, 111, 227, 181, 34, 10, 93, 210,
147, 150, 98, 27, 188, 104, 140, 242, 238, 226, 198,
224, 213, 77, 163, 199, 130, 1, 76, 208, 115, 157, 178,
82, 204, 81, 202, 235, 168, 211,
241, 184, 36, 186, 171, 36, 208, 104, 236, 144, 50,
100, 215, 214, 120, 171, 8, 240, 110, 201, 231, 226,
61, 150, 6, 40, 183, 68, 191, 148, 179, 105, 70, 86,
70, 60, 126, 65, 115, 153, 237, 115, 208, 118, 200,
145, 252, 244, 99, 169, 170, 156, 230, 45, 169, 205,
23, 226, 55, 220, 42, 128, 2, 241]

	  </td>
</tr>
</table>
<br clear="all" />

<p>The RSA private key (n, d) is then passed to the RSA
	signing function, which also takes the hash type, SHA-256, and
	the JWT Claim Segment as inputs.  The result of the signature
	is a byte array S, which represents a big endian integer.  In
	this example, S is:
</p><table class="full" align="center" border="0" cellpadding="2" cellspacing="2">
<col align="left"><col align="left">
<tr><th align="left">Result Name</th><th align="left">Value</th></tr>
<tr>
<td align="left">S</td>
<td align="left">

[208, 141, 219, 44, 66, 129, 179, 230, 69, 120, 123,
108, 203, 96, 182, 145, 66, 179, 198, 104, 43, 187,
199, 159, 175, 5, 217, 101, 109, 236, 88, 136, 193,
133, 79, 39, 162, 131, 58, 114, 133, 202, 171, 227,
135, 157, 123, 188, 90, 111, 66, 241, 38, 238, 59, 18,
125, 146, 129, 14, 54, 183, 10, 221,
33, 105, 37, 173, 119, 239, 92, 27, 232, 175, 173, 49,
21, 28, 252, 237, 183, 107, 98, 156, 113, 116, 162,
219, 53, 96, 44, 214, 175, 154, 61, 100, 175, 90, 118,
247, 42, 196, 45, 74, 217, 145, 92, 39, 123, 224, 247,
171, 206, 203, 91, 167, 103, 57, 163, 87, 172, 67, 77,
255, 9, 218, 107, 62,
228, 71, 239, 36, 246, 23, 96, 108, 28, 19, 179, 24,
167, 196, 42, 97, 198, 80, 241, 79, 31, 0, 85, 17,
50, 6, 143, 238, 214, 131, 246, 13, 49, 111, 30, 142,
182, 145, 200, 17, 127, 76, 236, 69, 66, 133, 198, 137,
103, 45, 3, 48, 123, 203, 17, 162, 1, 105, 133, 22,
105, 25, 63, 173,
186, 231, 206, 246, 22, 243, 250, 53, 237, 209, 36,
111, 168, 11, 40, 237, 179, 83, 125, 180, 84, 231, 129,
37, 236, 172, 22, 234, 58, 198, 187, 124, 65, 145, 148,
227, 122, 177, 16, 176, 84, 28, 1, 141, 179, 57, 96,
232, 215, 51, 7, 49, 63, 195, 155, 94, 51, 22, 239,
90, 138, 207, 41, 62]

	  </td>
</tr>
</table>
<br clear="all" />

<p>Base64url encoding the signature produces this value for the JWT
	Crypto Segment:
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>0I3bLEKBs-ZFeHtsy2C2kUKzxmgru8efrwXZZW3sWIjBhU8nooM6coXKq-OHnXu8Wm9C8SbuOxJ9koEONrcK3SFpJa1371wb6K-tMRUc_O23a2KccXSi2zVgLNavmj1kr1p29yrELUrZkVwne-D3q87LW6dnOaNXrENN_wnaaz7kR-8k9hdgbBwTsxinxCphxlDxTx8AVREyBo_u1oP2DTFvHo62kcgRf0zsRUKFxolnLQMwe8sRogFphRZpGT-tuufO9hbz-jXt0SRvqAso7bNTfbRU54El7KwW6jrGu3xBkZTjerEQsFQcAY2zOWDo1zMHMT_Dm14zFu9ais8pPg</pre></div>
<p>Combining these segments in the order
      Envelope.Claims.Signature with period characters between the
      segments yields this complete JWT (with line breaks for display
      purposes only):
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>eyJhbGciOiJSUzI1NiJ9
.
eyJpc3MiOiJqb2UiLA0KICJleHAiOjEzMDA4MTkzODAsDQogImh0dHA6Ly9leGFtcGxlLmNvbS9pc19yb290Ijp0cnVlfQ
.
0I3bLEKBs-ZFeHtsy2C2kUKzxmgru8efrwXZZW3sWIjBhU8nooM6coXKq-OHnXu8Wm9C8SbuOxJ9koEONrcK3SFpJa1371wb6K-tMRUc_O23a2KccXSi2zVgLNavmj1kr1p29yrELUrZkVwne-D3q87LW6dnOaNXrENN_wnaaz7kR-8k9hdgbBwTsxinxCphxlDxTx8AVREyBo_u1oP2DTFvHo62kcgRf0zsRUKFxolnLQMwe8sRogFphRZpGT-tuufO9hbz-jXt0SRvqAso7bNTfbRU54El7KwW6jrGu3xBkZTjerEQsFQcAY2zOWDo1zMHMT_Dm14zFu9ais8pPg</pre></div>
<a name="anchor15"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.13.2.2"></a><h3>13.2.2.&nbsp;
Decoding</h3>

<p>Decoding the JWT from this example requires processing the
      JWT Envelope Segment and Claim Segment exactly as done in the
      first example.
</p>
<a name="anchor16"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.13.2.3"></a><h3>13.2.3.&nbsp;
Validating</h3>

<p>Since the "alg" parameter in the envelope is "RS256", we
      validate the RSA SHA-256 signature contained in the JWT Crypto
      Segment.  If any of the validation steps fail, the token MUST be
      rejected.
</p>
<p>First, we validate that the decoded envelope and claim
      segment strings are both legal JSON.
</p>
<p>Validating the JWT Crypto Segment is a little different from
      the previous example. First, we base64url decode the JWT Crypto
      Segment to produce a signature S to check.  We then pass (n, e),
      S and the JWT Claim Segment to an RSA signature verifier that
      has been configured to use the SHA-256 hash function.
</p>
<a name="anchor17"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.13.3"></a><h3>13.3.&nbsp;
JWT using ECDSA P-256 SHA-256</h3>

<a name="anchor18"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.13.3.1"></a><h3>13.3.1.&nbsp;
Encoding</h3>

<p>The Decoded JWT Claim Segment used in this example is the same as in the previous examples:
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>{"iss":"joe",
 "exp":1300819380,
 "http://example.com/is_root":true}</pre></div>
<p>Since the JWT Claim Segment will therefore be the same, its
      computation is not repeated here.  However, the Decoded JWT
      Envelope Segment is differs from the previous example because a
      different algorithm is being used.  The Decoded JWT Envelope
      Segment used is:
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>{"alg":"ES256"}</pre></div>
<p> The following byte array contains the UTF-8 characters for
      the Decoded JWT Envelope Segment:
</p>
<p>

[123, 34, 97, 108, 103, 34, 58, 34, 69, 83, 50, 53,
  54, 34, 125]

    
</p>
<p>Base64url encoding this UTF-8 representation yields this JWT
      Envelope Segment value:
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>eyJhbGciOiJFUzI1NiJ9</pre></div>
<p>The ECDSA key consists of a public part, the EC point (x, y), and a
      private part d.  The values of the ECDSA key used in this
      example, presented as the byte arrays representing
      big endian integers are:
</p><table class="full" align="center" border="0" cellpadding="2" cellspacing="2">
<col align="left"><col align="left">
<tr><th align="left">Parameter Name</th><th align="left">Value</th></tr>
<tr>
<td align="left">x</td>
<td align="left">

[48, 160, 66, 76, 210, 28, 41, 68, 131, 138, 45, 117,
201, 43, 55, 231, 110, 162, 13, 159, 0, 137, 58, 59,
78, 238, 138, 60, 10, 175, 236, 62]

	</td>
</tr>
<tr>
<td align="left">y</td>
<td align="left">

[224, 75, 101, 233, 36, 86, 217, 136, 139, 82, 179, 121,
189, 251, 213, 30, 232, 105, 239, 31, 15, 198, 91, 102,
89, 105, 91, 108, 206, 8, 23, 35]

	</td>
</tr>
<tr>
<td align="left">d</td>
<td align="left">

[243, 189, 12, 7, 168, 31, 185, 50, 120, 30, 213, 39,
82, 246, 12, 200, 154, 107, 229, 229, 25, 52, 254, 1,
147, 141, 219, 85, 216, 247, 120, 1]

	</td>
</tr>
</table>
<br clear="all" />

<p>The ECDSA private part d is then passed to an ECDSA
      signing function, which also takes the curve type,
      P-256, the hash type, SHA-256, and the JWT Claim
      Segment as inputs.  The result of the signature is the
      EC point (R, S), where R and S are unsigned integers.
      In this example, the R and S values, given as
      byte arrays representing big endian integers are:
</p><table class="full" align="center" border="0" cellpadding="2" cellspacing="2">
<col align="left"><col align="left">
<tr><th align="left">Result Name</th><th align="left">Value</th></tr>
<tr>
<td align="left">R</td>
<td align="left">

[175, 11, 115, 42, 160, 182, 181, 28, 135, 222, 52, 154,
  182, 237, 206, 137, 82, 20, 243, 7, 12, 164, 107, 72,
  236, 187, 241, 190, 26, 76, 32, 181]

	</td>
</tr>
<tr>
<td align="left">S</td>
<td align="left">

[120, 23, 189, 205, 202, 13, 177, 187, 23, 47, 12, 227,
  237, 250, 230, 233, 245, 216, 9, 170, 24, 185, 198,
  187, 193, 94, 158, 117, 167, 88, 153, 196]

	</td>
</tr>
</table>
<br clear="all" />

<p>Concatenating the S array to the end of the R array and
      base64url encoding the result produces this value for the JWT
      Crypto Segment:
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>rwtzKqC2tRyH3jSatu3OiVIU8wcMpGtI7LvxvhpMILV4F73Nyg2xuxcvDOPt-ubp9dgJqhi5xrvBXp51p1iZxA</pre></div>
<p>Combining these segments in the order
      Envelope.Claims.Signature with period characters between the
      segments yields this complete JWT (with line breaks for display
      purposes only):
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>eyJhbGciOiJFUzI1NiJ9
.
eyJpc3MiOiJqb2UiLA0KICJleHAiOjEzMDA4MTkzODAsDQogImh0dHA6Ly9leGFtcGxlLmNvbS9pc19yb290Ijp0cnVlfQ
.
rwtzKqC2tRyH3jSatu3OiVIU8wcMpGtI7LvxvhpMILV4F73Nyg2xuxcvDOPt-ubp9dgJqhi5xrvBXp51p1iZxA</pre></div>
<a name="anchor19"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.13.3.2"></a><h3>13.3.2.&nbsp;
Decoding</h3>

<p>Decoding the JWT from this example requires processing the
      JWT Envelope Segment and Claim Segment exactly as done in the
      first example.
</p>
<a name="anchor20"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.13.3.3"></a><h3>13.3.3.&nbsp;
Validating</h3>

<p>Since the "alg" parameter in the envelope is "ES256", we
      validate the ECDSA P-256 SHA-256 signature contained in the JWT
      Crypto Segment.  If any of the validation steps fail, the token
      MUST be rejected.
</p>
<p>First, we validate that the decoded envelope and claim
      segment strings are both legal JSON.
</p>
<p>Validating the JWT Crypto Segment is a little different from
      the first example. First, we base64url decode the JWT Crypto
      Segment as in the previous examples but we then need to split
      the 64 member byte array that must result into two 32 byte
      arrays, the first R and the second S. We then pass (x, y), (R,
      S) and the JWT Claim Segment to an ECDSA signature verifier that
      has been configured to use the P-256 curve with the SHA-256 hash
      function.
</p>
<p>As explained in <a class='info' href='#DefiningECDSA'>Section&nbsp;8.3<span> (</span><span class='info'>Signing a JWT with ECDSA P-256 SHA-256</span><span>)</span></a>, the
      use of the k value in ECDSA means that we cannot validate the
      correctness of the signature in the same way we validated the
      correctness of the HMAC. Instead, implementations MUST use an
      ECDSA validator to validate the signature.
</p>
<a name="base64urlnotes"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.14"></a><h3>14.&nbsp;
Appendix - Non-Normative - Notes on implementing base64url encoding without padding</h3>

<p>This appendix describes how to implement base64url encoding
  and decoding functions without padding based upon standard
  base64 encoding and decoding functions that do use padding.
</p>
<p>To be concrete, example C# code implementing these functions
  is shown below.  Similar code could be used in other
  languages.
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>static string base64urlencode(byte [] arg)
{
  string s = Convert.ToBase64String(arg); // Standard base64 encoder
  s = s.Split('=')[0]; // Remove any trailing '='s
  s = s.Replace('+', '-'); // 62nd char of encoding
  s = s.Replace('/', '_'); // 63rd char of encoding
  return s;
}

static byte [] base64urldecode(string arg)
{
  string s = arg;
  s = s.Replace('-', '+'); // 62nd char of encoding
  s = s.Replace('_', '/'); // 63rd char of encoding
  switch (s.Length % 4) // Pad with trailing '='s
  {
    case 0: break; // No pad chars in this case
    case 2: s += "=="; break; // Two pad chars
    case 3: s += "="; break; // One pad char
    default: throw new System.Exception(
      "Illegal base64url string!");
  }
  return Convert.FromBase64String(s); // Standard base64 decoder
}</pre></div>
<p>As per the example code above, the number of '=' padding
  characters that needs to be added to the end of a base64url
  encoded string without padding to turn it into one with padding
  is a deterministic function of the length of the encoded string.
  Specifically,
  if the length mod 4 is 0, no padding is added;
  if the length mod 4 is 2, two '=' padding characters are added;
  if the length mod 4 is 3, one '=' padding character is added;
  if the length mod 4 is 1, the input is malformed.
</p>
<p>An example correspondence between unencoded and encoded
  values follows.  The byte sequence below encodes into the string
  below, which when decoded, reproduces the byte sequence.
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>3 236 255 224 193</pre></div><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>A-z_4ME</pre></div>
<a name="anchor21"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.15"></a><h3>15.&nbsp;
Appendix - Non-Normative - Relationship of JWTs to SAML Tokens</h3>

<p><a class='info' href='#OASIS.saml-core-2.0-os'>SAML 2.0<span> (</span><span class='info'>Cantor, S., Kemp, J., Philpott, R., and E. Maler, &ldquo;Assertions and Protocol for the OASIS Security Assertion Markup Language             (SAML) V2.0,&rdquo; March&nbsp;2005.</span><span>)</span></a> [OASIS.saml&#8209;core&#8209;2.0&#8209;os]
  provides a standard for creating tokens with much greater
  expressivity and more security options than supported by
  JWTs. However, the cost of this flexibility and expressiveness
  is both size and complexity. In addition, SAML's use of <a class='info' href='#W3C.CR-xml11-20021015'>XML<span> (</span><span class='info'>Cowan, J., &ldquo;Extensible Markup Language (XML) 1.1,&rdquo; October&nbsp;2002.</span><span>)</span></a> [W3C.CR&#8209;xml11&#8209;20021015] and <a class='info' href='#RFC3275'>XML DSIG<span> (</span><span class='info'>Eastlake, D., Reagle, J., and D. Solo, &ldquo;(Extensible Markup Language) XML-Signature Syntax and Processing,&rdquo; March&nbsp;2002.</span><span>)</span></a> [RFC3275] only contributes to the size of
  SAML tokens.
</p>
<p>JWTs are intended to provide a simple token format
  that is small enough to fit into HTTP headers and query arguments in
  URIs. It does this by supporting a much simpler token model than
  SAML and using the <a class='info' href='#RFC4627'>JSON<span> (</span><span class='info'>Crockford, D., &ldquo;The application/json Media Type for JavaScript Object Notation (JSON),&rdquo; July&nbsp;2006.</span><span>)</span></a> [RFC4627] object encoding
  syntax. It also supports securing tokens using Hash-based Message
  Authentication Codes (HMACs) and digital signatures using a smaller (and
  less flexible) format than XML DSIG.
</p>
<p>Therefore, while JWTs can do some of the things SAML tokens
  do, JWTs are not intended as a full replacement for SAML tokens, but
  rather as a compromise token format to be used when space is at a
  premium.
</p>
<a name="anchor22"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.16"></a><h3>16.&nbsp;
Appendix - Non-Normative - Relationship of JWTs to Simple Web Tokens (SWTs)</h3>

<p>Both JWTs and Simple Web Tokens <a class='info' href='#SWT'>SWT<span> (</span><span class='info'>Hardt, D. and Y. Goland, &ldquo;Simple Web Token (SWT),&rdquo; November&nbsp;2009.</span><span>)</span></a> [SWT], at their core, enable sets of claims to
  be communicated between applications.  For SWTs, both the claim
  names and claim values are strings.  For JWTs, while
  claim names are strings, claim values can be any JSON type.
  Both token types offer cryptographic protection of their
  content: SWTs with HMAC SHA-256 and JWTs with a choice of
  algorithms, including HMAC SHA-256, RSA SHA-256, and ECDSA P-256
  SHA-256.
</p>
<a name="rfc.references"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.17"></a><h3>17.&nbsp;
References</h3>

<a name="rfc.references1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>17.1.&nbsp;Normative References</h3>
<table width="99%" border="0">
<tr><td class="author-text" valign="top"><a name="FIPS.180-3">[FIPS.180-3]</a></td>
<td class="author-text">National Institute of Standards and
            Technology, &ldquo;<a href="http://csrc.nist.gov/publications/fips/fips180-3/fips180-3_final.pdf">Secure Hash Standard (SHS)</a>,&rdquo; FIPS&nbsp;PUB 180-3, October&nbsp;2008.</td></tr>
<tr><td class="author-text" valign="top"><a name="FIPS.186-3">[FIPS.186-3]</a></td>
<td class="author-text">National Institute of Standards and
            Technology, &ldquo;<a href="http://csrc.nist.gov/publications/fips/fips186-3/fips_186-3.pdf">Digital Signature Standard (DSS)</a>,&rdquo; FIPS&nbsp;PUB 186-3, June&nbsp;2009.</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC2045">[RFC2045]</a></td>
<td class="author-text"><a href="mailto:ned@innosoft.com">Freed, N.</a> and <a href="mailto:nsb@nsb.fv.com">N. Borenstein</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc2045">Multipurpose Internet Mail Extensions (MIME) Part One: Format of Internet Message Bodies</a>,&rdquo; RFC&nbsp;2045, November&nbsp;1996 (<a href="http://www.rfc-editor.org/rfc/rfc2045.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC2104">[RFC2104]</a></td>
<td class="author-text"><a href="mailto:hugo@watson.ibm.com">Krawczyk, H.</a>, <a href="mailto:mihir@cs.ucsd.edu">Bellare, M.</a>, and <a href="mailto:canetti@watson.ibm.com">R. Canetti</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc2104">HMAC: Keyed-Hashing for Message Authentication</a>,&rdquo; RFC&nbsp;2104, February&nbsp;1997 (<a href="http://www.rfc-editor.org/rfc/rfc2104.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC2119">[RFC2119]</a></td>
<td class="author-text"><a href="mailto:sob@harvard.edu">Bradner, S.</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>,&rdquo; BCP&nbsp;14, RFC&nbsp;2119, March&nbsp;1997 (<a href="http://www.rfc-editor.org/rfc/rfc2119.txt">TXT</a>, <a href="http://xml.resource.org/public/rfc/html/rfc2119.html">HTML</a>, <a href="http://xml.resource.org/public/rfc/xml/rfc2119.xml">XML</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC3339">[RFC3339]</a></td>
<td class="author-text"><a href="mailto:GK@ACM.ORG">Klyne, G., Ed.</a> and <a href="mailto:chris.newman@sun.com">C. Newman</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc3339">Date and Time on the Internet: Timestamps</a>,&rdquo; RFC&nbsp;3339, July&nbsp;2002 (<a href="http://www.rfc-editor.org/rfc/rfc3339.txt">TXT</a>, <a href="http://xml.resource.org/public/rfc/html/rfc3339.html">HTML</a>, <a href="http://xml.resource.org/public/rfc/xml/rfc3339.xml">XML</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC3447">[RFC3447]</a></td>
<td class="author-text">Jonsson, J. and B. Kaliski, &ldquo;<a href="http://tools.ietf.org/html/rfc3447">Public-Key Cryptography Standards (PKCS) #1: RSA Cryptography Specifications Version 2.1</a>,&rdquo; RFC&nbsp;3447, February&nbsp;2003 (<a href="http://www.rfc-editor.org/rfc/rfc3447.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC3629">[RFC3629]</a></td>
<td class="author-text">Yergeau, F., &ldquo;<a href="http://tools.ietf.org/html/rfc3629">UTF-8, a transformation format of ISO 10646</a>,&rdquo; STD&nbsp;63, RFC&nbsp;3629, November&nbsp;2003 (<a href="http://www.rfc-editor.org/rfc/rfc3629.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC3986">[RFC3986]</a></td>
<td class="author-text"><a href="mailto:timbl@w3.org">Berners-Lee, T.</a>, <a href="mailto:fielding@gbiv.com">Fielding, R.</a>, and <a href="mailto:LMM@acm.org">L. Masinter</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc3986">Uniform Resource Identifier (URI): Generic Syntax</a>,&rdquo; STD&nbsp;66, RFC&nbsp;3986, January&nbsp;2005 (<a href="http://www.rfc-editor.org/rfc/rfc3986.txt">TXT</a>, <a href="http://xml.resource.org/public/rfc/html/rfc3986.html">HTML</a>, <a href="http://xml.resource.org/public/rfc/xml/rfc3986.xml">XML</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4627">[RFC4627]</a></td>
<td class="author-text">Crockford, D., &ldquo;<a href="http://tools.ietf.org/html/rfc4627">The application/json Media Type for JavaScript Object Notation (JSON)</a>,&rdquo; RFC&nbsp;4627, July&nbsp;2006 (<a href="http://www.rfc-editor.org/rfc/rfc4627.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4648">[RFC4648]</a></td>
<td class="author-text">Josefsson, S., &ldquo;<a href="http://tools.ietf.org/html/rfc4648">The Base16, Base32, and Base64 Data Encodings</a>,&rdquo; RFC&nbsp;4648, October&nbsp;2006 (<a href="http://www.rfc-editor.org/rfc/rfc4648.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC5226">[RFC5226]</a></td>
<td class="author-text">Narten, T. and H. Alvestrand, &ldquo;<a href="http://tools.ietf.org/html/rfc5226">Guidelines for Writing an IANA Considerations Section in RFCs</a>,&rdquo; BCP&nbsp;26, RFC&nbsp;5226, May&nbsp;2008 (<a href="http://www.rfc-editor.org/rfc/rfc5226.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="USA15">[USA15]</a></td>
<td class="author-text"><a href="mailto:markdavis@google.com">Davis, M.</a>, <a href="mailto:ken@unicode.org">Whistler, K.</a>, and M. D&uuml;rst, &ldquo;Unicode Normalization Forms,&rdquo; Unicode Standard Annex&nbsp;15, 09&nbsp;2009.</td></tr>
</table>

<a name="rfc.references2"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>17.2.&nbsp;Informative References</h3>
<table width="99%" border="0">
<tr><td class="author-text" valign="top"><a name="CanvasApp">[CanvasApp]</a></td>
<td class="author-text">Facebook, &ldquo;<a href="http://developers.facebook.com/docs/authentication/canvas">Canvas Applications</a>,&rdquo; 2010.</td></tr>
<tr><td class="author-text" valign="top"><a name="JSS">[JSS]</a></td>
<td class="author-text">Bradley, J. and N. Sakimura (editor), &ldquo;<a href="http://jsonenc.info/jss/1.0/">JSON Simple Sign</a>,&rdquo; September&nbsp;2010.</td></tr>
<tr><td class="author-text" valign="top"><a name="MagicSignatures">[MagicSignatures]</a></td>
<td class="author-text">Panzer (editor), J., Laurie, B., and D. Balfanz, &ldquo;<a href="http://salmon-protocol.googlecode.com/svn/trunk/draft-panzer-magicsig-experimental-00.html">Magic Signatures</a>,&rdquo; August&nbsp;2010.</td></tr>
<tr><td class="author-text" valign="top"><a name="OASIS.saml-core-2.0-os">[OASIS.saml-core-2.0-os]</a></td>
<td class="author-text"><a href="mailto:cantor.2@osu.edu">Cantor, S.</a>, <a href="mailto:John.Kemp@nokia.com">Kemp, J.</a>, <a href="mailto:rphilpott@rsasecurity.com">Philpott, R.</a>, and <a href="mailto:eve.maler@sun.com">E. Maler</a>, &ldquo;<a href="http://docs.oasis-open.org/security/saml/v2.0/saml-core-2.0-os.pdf">Assertions and Protocol for the OASIS Security Assertion Markup Language
            (SAML) V2.0</a>,&rdquo; OASIS Standard&nbsp;saml-core-2.0-os, March&nbsp;2005.</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC3275">[RFC3275]</a></td>
<td class="author-text">Eastlake, D., Reagle, J., and D. Solo, &ldquo;<a href="http://tools.ietf.org/html/rfc3275">(Extensible Markup Language) XML-Signature Syntax and Processing</a>,&rdquo; RFC&nbsp;3275, March&nbsp;2002 (<a href="http://www.rfc-editor.org/rfc/rfc3275.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4122">[RFC4122]</a></td>
<td class="author-text"><a href="mailto:paulle@microsoft.com">Leach, P.</a>, <a href="mailto:michael@refactored-networks.com">Mealling, M.</a>, and <a href="mailto:rsalz@datapower.com">R. Salz</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc4122">A Universally Unique IDentifier (UUID) URN Namespace</a>,&rdquo; RFC&nbsp;4122, July&nbsp;2005 (<a href="http://www.rfc-editor.org/rfc/rfc4122.txt">TXT</a>, <a href="http://xml.resource.org/public/rfc/html/rfc4122.html">HTML</a>, <a href="http://xml.resource.org/public/rfc/xml/rfc4122.xml">XML</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="SWT">[SWT]</a></td>
<td class="author-text">Hardt, D. and Y. Goland, &ldquo;<a href="http://oauth-wrap-wg.googlegroups.com/web/SWT-v0.9.5.1.pdf?gda=Sn4MsEMAAABFB7PFAFiVedPtjcqT8uuIImHXUksNUKMXLyrSumAs_dF2tzlQ33RhT1wW8BFYO1QytiJ-HdGYYcPi_09pl8N7FWLveOaWjzbYnpnkpmxcWg">Simple Web Token (SWT)</a>,&rdquo; Version&nbsp;0.9.5.1, November&nbsp;2009.</td></tr>
<tr><td class="author-text" valign="top"><a name="W3C.CR-xml11-20021015">[W3C.CR-xml11-20021015]</a></td>
<td class="author-text">Cowan, J., &ldquo;<a href="http://www.w3.org/TR/2002/CR-xml11-20021015">Extensible Markup Language (XML) 1.1</a>,&rdquo; W3C CR&nbsp;CR-xml11-20021015, October&nbsp;2002.</td></tr>
</table>

<a name="rfc.authors"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>Authors' Addresses</h3>
<table width="99%" border="0" cellpadding="0" cellspacing="0">
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Michael B. Jones</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Microsoft</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:mbj@microsoft.com">mbj@microsoft.com</a></td></tr>
<tr><td class="author" align="right">URI:&nbsp;</td>
<td class="author-text"><a href="http://self-issued.info/">http://self-issued.info/</a></td></tr>
<tr cellpadding="3"><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Dirk Balfanz</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Google</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:balfanz@google.com">balfanz@google.com</a></td></tr>
<tr cellpadding="3"><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">John Bradley</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">independent</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:ve7jtb@ve7jtb.com">ve7jtb@ve7jtb.com</a></td></tr>
<tr cellpadding="3"><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Yaron Y. Goland</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Microsoft</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:yarong@microsoft.com">yarong@microsoft.com</a></td></tr>
<tr cellpadding="3"><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">John Panzer</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Google</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:jpanzer@google.com">jpanzer@google.com</a></td></tr>
<tr cellpadding="3"><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Nat Sakimura</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Nomura Research Institute</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:n-sakimura@nri.co.jp">n-sakimura@nri.co.jp</a></td></tr>
</table>
</body></html>
